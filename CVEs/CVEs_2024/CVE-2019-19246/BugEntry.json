{"buggy_code": ["/**********************************************************************\n  regexec.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2019  K.Kosako\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"regint.h\"\n\n#define IS_MBC_WORD_ASCII_MODE(enc,s,end,mode) \\\n  ((mode) == 0 ? ONIGENC_IS_MBC_WORD(enc,s,end) : ONIGENC_IS_MBC_WORD_ASCII(enc,s,end))\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n#define ONIGENC_IS_MBC_CRNL(enc,p,end) \\\n  (ONIGENC_MBC_TO_CODE(enc,p,end) == 13 && \\\n   ONIGENC_IS_MBC_NEWLINE(enc,(p+enclen(enc,p)),end))\n#endif\n\n#define CHECK_INTERRUPT_IN_MATCH\n\n#ifdef USE_CALLOUT\ntypedef struct {\n  int last_match_at_call_counter;\n  struct {\n    OnigType  type;\n    OnigValue val;\n  } slot[ONIG_CALLOUT_DATA_SLOT_NUM];\n} CalloutData;\n#endif\n\nstruct OnigMatchParamStruct {\n  unsigned int    match_stack_limit;\n  unsigned long   retry_limit_in_match;\n#ifdef USE_CALLOUT\n  OnigCalloutFunc progress_callout_of_contents;\n  OnigCalloutFunc retraction_callout_of_contents;\n  int             match_at_call_counter;\n  void*           callout_user_data;\n  CalloutData*    callout_data;\n  int             callout_data_alloc_num;\n#endif\n};\n\nextern int\nonig_set_match_stack_limit_size_of_match_param(OnigMatchParam* param,\n                                               unsigned int limit)\n{\n  param->match_stack_limit = limit;\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_set_retry_limit_in_match_of_match_param(OnigMatchParam* param,\n                                             unsigned long limit)\n{\n  param->retry_limit_in_match = limit;\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_set_progress_callout_of_match_param(OnigMatchParam* param, OnigCalloutFunc f)\n{\n#ifdef USE_CALLOUT\n  param->progress_callout_of_contents = f;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\nextern int\nonig_set_retraction_callout_of_match_param(OnigMatchParam* param, OnigCalloutFunc f)\n{\n#ifdef USE_CALLOUT\n  param->retraction_callout_of_contents = f;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\nextern int\nonig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)\n{\n#ifdef USE_CALLOUT\n  param->callout_user_data = user_data;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\n\ntypedef struct {\n  void* stack_p;\n  int   stack_n;\n  OnigOptionType options;\n  OnigRegion*    region;\n  int            ptr_num;\n  const UChar*   start;   /* search start position (for \\G: BEGIN_POSITION) */\n  unsigned int   match_stack_limit;\n  unsigned long  retry_limit_in_match;\n  OnigMatchParam* mp;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n  int    best_len;      /* for ONIG_OPTION_FIND_LONGEST */\n  UChar* best_s;\n#endif\n} MatchArg;\n\n\n#ifdef ONIG_DEBUG\n\n/* arguments type */\ntypedef enum {\n  ARG_SPECIAL = -1,\n  ARG_NON     =  0,\n  ARG_RELADDR =  1,\n  ARG_ABSADDR =  2,\n  ARG_LENGTH  =  3,\n  ARG_MEMNUM  =  4,\n  ARG_OPTION  =  5,\n  ARG_MODE    =  6\n} OpArgType;\n\ntypedef struct {\n  short int opcode;\n  char*     name;\n} OpInfoType;\n\nstatic OpInfoType OpInfo[] = {\n  { OP_FINISH,            \"finish\" },\n  { OP_END,               \"end\"    },\n  { OP_EXACT1,            \"exact1\" },\n  { OP_EXACT2,            \"exact2\" },\n  { OP_EXACT3,            \"exact3\" },\n  { OP_EXACT4,            \"exact4\" },\n  { OP_EXACT5,            \"exact5\" },\n  { OP_EXACTN,            \"exactn\" },\n  { OP_EXACTMB2N1,        \"exactmb2-n1\" },\n  { OP_EXACTMB2N2,        \"exactmb2-n2\" },\n  { OP_EXACTMB2N3,        \"exactmb2-n3\" },\n  { OP_EXACTMB2N,         \"exactmb2-n\"  },\n  { OP_EXACTMB3N,         \"exactmb3n\"   },\n  { OP_EXACTMBN,          \"exactmbn\"    },\n  { OP_EXACT1_IC,         \"exact1-ic\"   },\n  { OP_EXACTN_IC,         \"exactn-ic\"   },\n  { OP_CCLASS,            \"cclass\"      },\n  { OP_CCLASS_MB,         \"cclass-mb\"   },\n  { OP_CCLASS_MIX,        \"cclass-mix\"  },\n  { OP_CCLASS_NOT,        \"cclass-not\"  },\n  { OP_CCLASS_MB_NOT,     \"cclass-mb-not\"  },\n  { OP_CCLASS_MIX_NOT,    \"cclass-mix-not\" },\n  { OP_ANYCHAR,               \"anychar\"     },\n  { OP_ANYCHAR_ML,            \"anychar-ml\"  },\n  { OP_ANYCHAR_STAR,          \"anychar*\"    },\n  { OP_ANYCHAR_ML_STAR,       \"anychar-ml*\" },\n  { OP_ANYCHAR_STAR_PEEK_NEXT,    \"anychar*-peek-next\" },\n  { OP_ANYCHAR_ML_STAR_PEEK_NEXT, \"anychar-ml*-peek-next\" },\n  { OP_WORD,                  \"word\"       },\n  { OP_WORD_ASCII,            \"word-ascii\" },\n  { OP_NO_WORD,               \"not-word\"   },\n  { OP_NO_WORD_ASCII,         \"not-word-ascii\" },\n  { OP_WORD_BOUNDARY,         \"word-boundary\"  },\n  { OP_NO_WORD_BOUNDARY,      \"not-word-boundary\" },\n  { OP_WORD_BEGIN,            \"word-begin\" },\n  { OP_WORD_END,              \"word-end\"   },\n  { OP_TEXT_SEGMENT_BOUNDARY, \"text-segment-boundary\" },\n  { OP_BEGIN_BUF,             \"begin-buf\"  },\n  { OP_END_BUF,               \"end-buf\"    },\n  { OP_BEGIN_LINE,            \"begin-line\" },\n  { OP_END_LINE,              \"end-line\"   },\n  { OP_SEMI_END_BUF,          \"semi-end-buf\"   },\n  { OP_BEGIN_POSITION,        \"begin-position\" },\n  { OP_BACKREF1,              \"backref1\"       },\n  { OP_BACKREF2,              \"backref2\"       },\n  { OP_BACKREF_N,             \"backref-n\"      },\n  { OP_BACKREF_N_IC,          \"backref-n-ic\"   },\n  { OP_BACKREF_MULTI,         \"backref_multi\"  },\n  { OP_BACKREF_MULTI_IC,      \"backref_multi-ic\"     },\n  { OP_BACKREF_WITH_LEVEL,    \"backref_with_level\"   },\n  { OP_BACKREF_WITH_LEVEL_IC, \"backref_with_level-c\" },\n  { OP_BACKREF_CHECK,         \"backref_check\"        },\n  { OP_BACKREF_CHECK_WITH_LEVEL, \"backref_check_with_level\" },\n  { OP_MEMORY_START_PUSH,     \"mem-start-push\"        },\n  { OP_MEMORY_START,          \"mem-start\"             },\n  { OP_MEMORY_END_PUSH,       \"mem-end-push\"          },\n  { OP_MEMORY_END_PUSH_REC,   \"mem-end-push-rec\"      },\n  { OP_MEMORY_END,            \"mem-end\"               },\n  { OP_MEMORY_END_REC,        \"mem-end-rec\"           },\n  { OP_FAIL,                  \"fail\"                  },\n  { OP_JUMP,                  \"jump\"                  },\n  { OP_PUSH,                  \"push\"                  },\n  { OP_PUSH_SUPER,            \"push-super\"            },\n  { OP_POP_OUT,               \"pop-out\"               },\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n  { OP_PUSH_OR_JUMP_EXACT1,   \"push-or-jump-e1\"       },\n#endif\n  { OP_PUSH_IF_PEEK_NEXT,     \"push-if-peek-next\"     },\n  { OP_REPEAT,                \"repeat\"                },\n  { OP_REPEAT_NG,             \"repeat-ng\"             },\n  { OP_REPEAT_INC,            \"repeat-inc\"            },\n  { OP_REPEAT_INC_NG,         \"repeat-inc-ng\"         },\n  { OP_REPEAT_INC_SG,         \"repeat-inc-sg\"         },\n  { OP_REPEAT_INC_NG_SG,      \"repeat-inc-ng-sg\"      },\n  { OP_EMPTY_CHECK_START,     \"empty-check-start\"     },\n  { OP_EMPTY_CHECK_END,       \"empty-check-end\"       },\n  { OP_EMPTY_CHECK_END_MEMST, \"empty-check-end-memst\" },\n  { OP_EMPTY_CHECK_END_MEMST_PUSH,\"empty-check-end-memst-push\" },\n  { OP_PREC_READ_START,       \"push-pos\"              },\n  { OP_PREC_READ_END,         \"pop-pos\"               },\n  { OP_PREC_READ_NOT_START,   \"prec-read-not-start\"   },\n  { OP_PREC_READ_NOT_END,     \"prec-read-not-end\"     },\n  { OP_ATOMIC_START,          \"atomic-start\"          },\n  { OP_ATOMIC_END,            \"atomic-end\"            },\n  { OP_LOOK_BEHIND,           \"look-behind\"           },\n  { OP_LOOK_BEHIND_NOT_START, \"look-behind-not-start\" },\n  { OP_LOOK_BEHIND_NOT_END,   \"look-behind-not-end\"   },\n  { OP_CALL,                  \"call\"                  },\n  { OP_RETURN,                \"return\"                },\n  { OP_PUSH_SAVE_VAL,         \"push-save-val\"         },\n  { OP_UPDATE_VAR,            \"update-var\"            },\n#ifdef USE_CALLOUT\n  { OP_CALLOUT_CONTENTS,      \"callout-contents\"      },\n  { OP_CALLOUT_NAME,          \"callout-name\"          },\n#endif\n  { -1, \"\" }\n};\n\nstatic char*\nop2name(int opcode)\n{\n  int i;\n\n  for (i = 0; OpInfo[i].opcode >= 0; i++) {\n    if (opcode == OpInfo[i].opcode) return OpInfo[i].name;\n  }\n\n  return \"\";\n}\n\nstatic void\np_string(FILE* f, int len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}\n\nstatic void\np_len_string(FILE* f, LengthType len, int mb_len, UChar* s)\n{\n  int x = len * mb_len;\n\n  fprintf(f, \":%d:\", len);\n  while (x-- > 0) { fputc(*s++, f); }\n}\n\nstatic void\np_rel_addr(FILE* f, RelAddrType rel_addr, Operation* p, Operation* start)\n{\n  RelAddrType curr = (RelAddrType )(p - start);\n\n  fprintf(f, \"{%d/%d}\", rel_addr, curr + rel_addr);\n}\n\nstatic int\nbitset_on_num(BitSetRef bs)\n{\n  int i, n;\n\n  n = 0;\n  for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n    if (BITSET_AT(bs, i)) n++;\n  }\n\n  return n;\n}\n\nstatic void\nprint_compiled_byte_code(FILE* f, regex_t* reg, int index,\n                         Operation* start, OnigEncoding enc)\n{\n  int i, n;\n  RelAddrType addr;\n  LengthType  len;\n  MemNumType  mem;\n  OnigCodePoint code;\n  ModeType mode;\n  UChar *q;\n  Operation* p;\n  enum OpCode opcode;\n\n  p = reg->ops + index;\n\n#ifdef USE_DIRECT_THREADED_CODE\n  opcode = reg->ocs[index];\n#else\n  opcode = p->opcode;\n#endif\n\n  fprintf(f, \"%s\", op2name(opcode));\n  switch (opcode) {\n  case OP_EXACT1:\n    p_string(f, 1, p->exact.s); break;\n  case OP_EXACT2:\n    p_string(f, 2, p->exact.s); break;\n  case OP_EXACT3:\n    p_string(f, 3, p->exact.s); break;\n  case OP_EXACT4:\n    p_string(f, 4, p->exact.s); break;\n  case OP_EXACT5:\n    p_string(f, 5, p->exact.s); break;\n  case OP_EXACTN:\n    len = p->exact_n.n;\n    p_string(f, len, p->exact_n.s); break;\n  case OP_EXACTMB2N1:\n    p_string(f, 2, p->exact.s); break;\n  case OP_EXACTMB2N2:\n    p_string(f, 4, p->exact.s); break;\n  case OP_EXACTMB2N3:\n    p_string(f, 3, p->exact.s); break;\n  case OP_EXACTMB2N:\n    len = p->exact_n.n;\n    p_len_string(f, len, 2, p->exact_n.s); break;\n  case OP_EXACTMB3N:\n    len = p->exact_n.n;\n    p_len_string(f, len, 3, p->exact_n.s); break;\n  case OP_EXACTMBN:\n    {\n      int mb_len;\n\n      mb_len = p->exact_len_n.len;\n      len    = p->exact_len_n.n;\n      q      = p->exact_len_n.s;\n      fprintf(f, \":%d:%d:\", mb_len, len);\n      n = len * mb_len;\n      while (n-- > 0) { fputc(*q++, f); }\n    }\n    break;\n  case OP_EXACT1_IC:\n    len = enclen(enc, p->exact.s);\n    p_string(f, len, p->exact.s);\n    break;\n  case OP_EXACTN_IC:\n    len = p->exact_n.n;\n    p_len_string(f, len, 1, p->exact_n.s);\n    break;\n\n  case OP_CCLASS:\n  case OP_CCLASS_NOT:\n    n = bitset_on_num(p->cclass.bsp);\n    fprintf(f, \":%d\", n);\n    break;\n  case OP_CCLASS_MB:\n  case OP_CCLASS_MB_NOT:\n    {\n      OnigCodePoint ncode;\n      OnigCodePoint* codes;      \n\n      codes = (OnigCodePoint* )p->cclass_mb.mb;\n      GET_CODE_POINT(ncode, codes);\n      codes++;\n      GET_CODE_POINT(code, codes);\n      fprintf(f, \":%u:%u\", code, ncode);\n    }\n    break;\n  case OP_CCLASS_MIX:\n  case OP_CCLASS_MIX_NOT:\n    {\n      OnigCodePoint ncode;\n      OnigCodePoint* codes;\n\n      codes = (OnigCodePoint* )p->cclass_mix.mb;\n      n = bitset_on_num(p->cclass_mix.bsp);\n\n      GET_CODE_POINT(ncode, codes);\n      codes++;\n      GET_CODE_POINT(code, codes);\n      fprintf(f, \":%d:%u:%u\", n, code, ncode);\n    }\n    break;\n\n  case OP_ANYCHAR_STAR_PEEK_NEXT:\n  case OP_ANYCHAR_ML_STAR_PEEK_NEXT:\n    p_string(f, 1, &(p->anychar_star_peek_next.c));\n    break;\n\n  case OP_WORD_BOUNDARY:\n  case OP_NO_WORD_BOUNDARY:\n  case OP_WORD_BEGIN:\n  case OP_WORD_END:\n    mode = p->word_boundary.mode;\n    fprintf(f, \":%d\", mode);\n    break;\n\n  case OP_BACKREF_N:\n  case OP_BACKREF_N_IC:\n    mem = p->backref_n.n1;\n    fprintf(f, \":%d\", mem);\n    break;\n  case OP_BACKREF_MULTI_IC:\n  case OP_BACKREF_MULTI:\n  case OP_BACKREF_CHECK:\n    fputs(\" \", f);\n    n = p->backref_general.num;\n    for (i = 0; i < n; i++) {\n      mem = (n == 1) ? p->backref_general.n1 : p->backref_general.ns[i];\n      if (i > 0) fputs(\", \", f);\n      fprintf(f, \"%d\", mem);\n    }\n    break;\n  case OP_BACKREF_WITH_LEVEL:\n  case OP_BACKREF_WITH_LEVEL_IC:\n  case OP_BACKREF_CHECK_WITH_LEVEL:\n    {\n      LengthType level;\n\n      level = p->backref_general.nest_level;\n      fprintf(f, \":%d\", level);\n      fputs(\" \", f);\n      n = p->backref_general.num;\n      for (i = 0; i < n; i++) {\n        mem = (n == 1) ? p->backref_general.n1 : p->backref_general.ns[i];\n        if (i > 0) fputs(\", \", f);\n        fprintf(f, \"%d\", mem);\n      }\n    }\n    break;\n\n  case OP_MEMORY_START:\n  case OP_MEMORY_START_PUSH:\n    mem = p->memory_start.num;\n    fprintf(f, \":%d\", mem);\n    break;\n  case OP_MEMORY_END_PUSH:\n  case OP_MEMORY_END_PUSH_REC:\n  case OP_MEMORY_END:\n  case OP_MEMORY_END_REC:\n    mem = p->memory_end.num;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_JUMP:\n    addr = p->jump.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_PUSH:\n  case OP_PUSH_SUPER:\n    addr = p->push.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n  case OP_PUSH_OR_JUMP_EXACT1:\n    addr = p->push_or_jump_exact1.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    p_string(f, 1, &(p->push_or_jump_exact1.c));\n    break;\n#endif\n\n  case OP_PUSH_IF_PEEK_NEXT:\n    addr = p->push_if_peek_next.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    p_string(f, 1, &(p->push_if_peek_next.c));\n    break;\n\n  case OP_REPEAT:\n  case OP_REPEAT_NG:\n    mem = p->repeat.id;\n    addr = p->repeat.addr;\n    fprintf(f, \":%d:\", mem);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_REPEAT_INC:\n  case OP_REPEAT_INC_NG:\n  case OP_REPEAT_INC_SG:\n  case OP_REPEAT_INC_NG_SG:\n    mem = p->repeat.id;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_EMPTY_CHECK_START:\n    mem = p->empty_check_start.mem;\n    fprintf(f, \":%d\", mem);\n    break;\n  case OP_EMPTY_CHECK_END:\n  case OP_EMPTY_CHECK_END_MEMST:\n  case OP_EMPTY_CHECK_END_MEMST_PUSH:\n    mem = p->empty_check_end.mem;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_PREC_READ_NOT_START:\n    addr = p->prec_read_not_start.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_LOOK_BEHIND:\n    len = p->look_behind.len;\n    fprintf(f, \":%d\", len);\n    break;\n\n  case OP_LOOK_BEHIND_NOT_START:\n    addr = p->look_behind_not_start.addr;\n    len  = p->look_behind_not_start.len;\n    fprintf(f, \":%d:\", len);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_CALL:\n    addr = p->call.addr;\n    fprintf(f, \":{/%d}\", addr);\n    break;\n\n  case OP_PUSH_SAVE_VAL:\n    {\n      SaveType type;\n\n      type = p->push_save_val.type;\n      mem  = p->push_save_val.id;\n      fprintf(f, \":%d:%d\", type, mem);\n    }\n    break;\n\n  case OP_UPDATE_VAR:\n    {\n      UpdateVarType type;\n\n      type = p->update_var.type;\n      mem  = p->update_var.id;\n      fprintf(f, \":%d:%d\", type, mem);\n    }\n    break;\n\n#ifdef USE_CALLOUT\n  case OP_CALLOUT_CONTENTS:\n    mem = p->callout_contents.num;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_CALLOUT_NAME:\n    {\n      int id;\n\n      id  = p->callout_name.id;\n      mem = p->callout_name.num;\n      fprintf(f, \":%d:%d\", id, mem);\n    }\n    break;\n#endif\n\n  case OP_TEXT_SEGMENT_BOUNDARY:\n    if (p->text_segment_boundary.not != 0)\n      fprintf(f, \":not\");\n    break;\n\n  case OP_FINISH:\n  case OP_END:\n  case OP_ANYCHAR:\n  case OP_ANYCHAR_ML:\n  case OP_ANYCHAR_STAR:\n  case OP_ANYCHAR_ML_STAR:\n  case OP_WORD:\n  case OP_WORD_ASCII:\n  case OP_NO_WORD:\n  case OP_NO_WORD_ASCII:\n  case OP_BEGIN_BUF:\n  case OP_END_BUF:\n  case OP_BEGIN_LINE:\n  case OP_END_LINE:\n  case OP_SEMI_END_BUF:\n  case OP_BEGIN_POSITION:\n  case OP_BACKREF1:\n  case OP_BACKREF2:\n  case OP_FAIL:\n  case OP_POP_OUT:\n  case OP_PREC_READ_START:\n  case OP_PREC_READ_END:\n  case OP_PREC_READ_NOT_END:\n  case OP_ATOMIC_START:\n  case OP_ATOMIC_END:\n  case OP_LOOK_BEHIND_NOT_END:\n  case OP_RETURN:\n    break;\n\n  default:\n    fprintf(stderr, \"print_compiled_byte_code: undefined code %d\\n\", opcode);\n    break;\n  }\n}\n#endif /* ONIG_DEBUG */\n\n#ifdef ONIG_DEBUG_COMPILE\nextern void\nonig_print_compiled_byte_code_list(FILE* f, regex_t* reg)\n{\n  Operation* bp;\n  Operation* start = reg->ops;\n  Operation* end   = reg->ops + reg->ops_used;\n\n  fprintf(f, \"bt_mem_start: 0x%x, bt_mem_end: 0x%x\\n\",\n          reg->bt_mem_start, reg->bt_mem_end);\n  fprintf(f, \"code-length: %d\\n\", reg->ops_used);\n\n  bp = start;\n  while (bp < end) {\n    int pos = bp - start;\n\n    fprintf(f, \"%4d: \", pos);\n    print_compiled_byte_code(f, reg, pos, start, reg->enc);\n    fprintf(f, \"\\n\");\n    bp++;\n  }\n  fprintf(f, \"\\n\");\n}\n#endif\n\n\n#ifdef USE_CAPTURE_HISTORY\nstatic void history_tree_free(OnigCaptureTreeNode* node);\n\nstatic void\nhistory_tree_clear(OnigCaptureTreeNode* node)\n{\n  int i;\n\n  if (IS_NULL(node)) return ;\n\n  for (i = 0; i < node->num_childs; i++) {\n    if (IS_NOT_NULL(node->childs[i])) {\n      history_tree_free(node->childs[i]);\n    }\n  }\n  for (i = 0; i < node->allocated; i++) {\n    node->childs[i] = (OnigCaptureTreeNode* )0;\n  }\n  node->num_childs = 0;\n  node->beg = ONIG_REGION_NOTPOS;\n  node->end = ONIG_REGION_NOTPOS;\n  node->group = -1;\n}\n\nstatic void\nhistory_tree_free(OnigCaptureTreeNode* node)\n{\n  history_tree_clear(node);\n  if (IS_NOT_NULL(node->childs)) xfree(node->childs);\n\n  xfree(node);\n}\n\nstatic void\nhistory_root_free(OnigRegion* r)\n{\n  if (IS_NULL(r->history_root)) return ;\n\n  history_tree_free(r->history_root);\n  r->history_root = (OnigCaptureTreeNode* )0;\n}\n\nstatic OnigCaptureTreeNode*\nhistory_node_new(void)\n{\n  OnigCaptureTreeNode* node;\n\n  node = (OnigCaptureTreeNode* )xmalloc(sizeof(OnigCaptureTreeNode));\n  CHECK_NULL_RETURN(node);\n\n  node->childs     = (OnigCaptureTreeNode** )0;\n  node->allocated  =  0;\n  node->num_childs =  0;\n  node->group      = -1;\n  node->beg        = ONIG_REGION_NOTPOS;\n  node->end        = ONIG_REGION_NOTPOS;\n\n  return node;\n}\n\nstatic int\nhistory_tree_add_child(OnigCaptureTreeNode* parent, OnigCaptureTreeNode* child)\n{\n#define HISTORY_TREE_INIT_ALLOC_SIZE  8\n\n  if (parent->num_childs >= parent->allocated) {\n    int n, i;\n\n    if (IS_NULL(parent->childs)) {\n      n = HISTORY_TREE_INIT_ALLOC_SIZE;\n      parent->childs =\n        (OnigCaptureTreeNode** )xmalloc(sizeof(parent->childs[0]) * n);\n    }\n    else {\n      n = parent->allocated * 2;\n      parent->childs =\n        (OnigCaptureTreeNode** )xrealloc(parent->childs,\n                                         sizeof(parent->childs[0]) * n);\n    }\n    CHECK_NULL_RETURN_MEMERR(parent->childs);\n    for (i = parent->allocated; i < n; i++) {\n      parent->childs[i] = (OnigCaptureTreeNode* )0;\n    }\n    parent->allocated = n;\n  }\n\n  parent->childs[parent->num_childs] = child;\n  parent->num_childs++;\n  return 0;\n}\n\nstatic OnigCaptureTreeNode*\nhistory_tree_clone(OnigCaptureTreeNode* node)\n{\n  int i;\n  OnigCaptureTreeNode *clone, *child;\n\n  clone = history_node_new();\n  CHECK_NULL_RETURN(clone);\n\n  clone->beg = node->beg;\n  clone->end = node->end;\n  for (i = 0; i < node->num_childs; i++) {\n    child = history_tree_clone(node->childs[i]);\n    if (IS_NULL(child)) {\n      history_tree_free(clone);\n      return (OnigCaptureTreeNode* )0;\n    }\n    history_tree_add_child(clone, child);\n  }\n\n  return clone;\n}\n\nextern  OnigCaptureTreeNode*\nonig_get_capture_tree(OnigRegion* region)\n{\n  return region->history_root;\n}\n#endif /* USE_CAPTURE_HISTORY */\n\nextern void\nonig_region_clear(OnigRegion* region)\n{\n  int i;\n\n  for (i = 0; i < region->num_regs; i++) {\n    region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n  }\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(region);\n#endif\n}\n\nextern int\nonig_region_resize(OnigRegion* region, int n)\n{\n  region->num_regs = n;\n\n  if (n < ONIG_NREGION)\n    n = ONIG_NREGION;\n\n  if (region->allocated == 0) {\n    region->beg = (int* )xmalloc(n * sizeof(int));\n    region->end = (int* )xmalloc(n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n  else if (region->allocated < n) {\n    region->beg = (int* )xrealloc(region->beg, n * sizeof(int));\n    region->end = (int* )xrealloc(region->end, n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n\n  return 0;\n}\n\nstatic int\nonig_region_resize_clear(OnigRegion* region, int n)\n{\n  int r;\n\n  r = onig_region_resize(region, n);\n  if (r != 0) return r;\n  onig_region_clear(region);\n  return 0;\n}\n\nextern int\nonig_region_set(OnigRegion* region, int at, int beg, int end)\n{\n  if (at < 0) return ONIGERR_INVALID_ARGUMENT;\n\n  if (at >= region->allocated) {\n    int r = onig_region_resize(region, at + 1);\n    if (r < 0) return r;\n  }\n\n  region->beg[at] = beg;\n  region->end[at] = end;\n  return 0;\n}\n\nextern void\nonig_region_init(OnigRegion* region)\n{\n  region->num_regs     = 0;\n  region->allocated    = 0;\n  region->beg          = (int* )0;\n  region->end          = (int* )0;\n  region->history_root = (OnigCaptureTreeNode* )0;\n}\n\nextern OnigRegion*\nonig_region_new(void)\n{\n  OnigRegion* r;\n\n  r = (OnigRegion* )xmalloc(sizeof(OnigRegion));\n  CHECK_NULL_RETURN(r);\n  onig_region_init(r);\n  return r;\n}\n\nextern void\nonig_region_free(OnigRegion* r, int free_self)\n{\n  if (r != 0) {\n    if (r->allocated > 0) {\n      if (r->beg) xfree(r->beg);\n      if (r->end) xfree(r->end);\n      r->allocated = 0;\n    }\n#ifdef USE_CAPTURE_HISTORY\n    history_root_free(r);\n#endif\n    if (free_self) xfree(r);\n  }\n}\n\nextern void\nonig_region_copy(OnigRegion* to, OnigRegion* from)\n{\n#define RREGC_SIZE   (sizeof(int) * from->num_regs)\n  int i;\n\n  if (to == from) return;\n\n  if (to->allocated == 0) {\n    if (from->num_regs > 0) {\n      to->beg = (int* )xmalloc(RREGC_SIZE);\n      if (IS_NULL(to->beg)) return;\n      to->end = (int* )xmalloc(RREGC_SIZE);\n      if (IS_NULL(to->end)) return;\n      to->allocated = from->num_regs;\n    }\n  }\n  else if (to->allocated < from->num_regs) {\n    to->beg = (int* )xrealloc(to->beg, RREGC_SIZE);\n    if (IS_NULL(to->beg)) return;\n    to->end = (int* )xrealloc(to->end, RREGC_SIZE);\n    if (IS_NULL(to->end)) return;\n    to->allocated = from->num_regs;\n  }\n\n  for (i = 0; i < from->num_regs; i++) {\n    to->beg[i] = from->beg[i];\n    to->end[i] = from->end[i];\n  }\n  to->num_regs = from->num_regs;\n\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(to);\n\n  if (IS_NOT_NULL(from->history_root)) {\n    to->history_root = history_tree_clone(from->history_root);\n  }\n#endif\n}\n\n#ifdef USE_CALLOUT\n#define CALLOUT_BODY(func, ain, aname_id, anum, user, args, result) do { \\\n  args.in            = (ain);\\\n  args.name_id       = (aname_id);\\\n  args.num           = anum;\\\n  args.regex         = reg;\\\n  args.string        = str;\\\n  args.string_end    = end;\\\n  args.start         = sstart;\\\n  args.right_range   = right_range;\\\n  args.current       = s;\\\n  args.retry_in_match_counter = retry_in_match_counter;\\\n  args.msa           = msa;\\\n  args.stk_base      = stk_base;\\\n  args.stk           = stk;\\\n  args.mem_start_stk = mem_start_stk;\\\n  args.mem_end_stk   = mem_end_stk;\\\n  result = (func)(&args, user);\\\n} while (0)\n\n#define RETRACTION_CALLOUT(func, aname_id, anum, user) do {\\\n  int result;\\\n  OnigCalloutArgs args;\\\n  CALLOUT_BODY(func, ONIG_CALLOUT_IN_RETRACTION, aname_id, anum, user, args, result);\\\n  switch (result) {\\\n  case ONIG_CALLOUT_FAIL:\\\n  case ONIG_CALLOUT_SUCCESS:\\\n    break;\\\n  default:\\\n    if (result > 0) {\\\n      result = ONIGERR_INVALID_ARGUMENT;\\\n    }\\\n    best_len = result;\\\n    goto finish;\\\n    break;\\\n  }\\\n} while(0)\n#endif\n\n\n/** stack **/\n#define INVALID_STACK_INDEX   -1\n\n#define STK_ALT_FLAG               0x0001\n\n/* stack type */\n/* used by normal-POP */\n#define STK_SUPER_ALT             STK_ALT_FLAG\n#define STK_ALT                   (0x0002 | STK_ALT_FLAG)\n#define STK_ALT_PREC_READ_NOT     (0x0004 | STK_ALT_FLAG)\n#define STK_ALT_LOOK_BEHIND_NOT   (0x0006 | STK_ALT_FLAG)\n\n/* handled by normal-POP */\n#define STK_MEM_START              0x0010\n#define STK_MEM_END                0x8030\n#define STK_REPEAT_INC             0x0050\n#ifdef USE_CALLOUT\n#define STK_CALLOUT                0x0070\n#endif\n\n/* avoided by normal-POP */\n#define STK_VOID                   0x0000  /* for fill a blank */\n#define STK_EMPTY_CHECK_START      0x3000\n#define STK_EMPTY_CHECK_END        0x5000  /* for recursive call */\n#define STK_MEM_END_MARK           0x8100\n#define STK_TO_VOID_START          0x1200  /* mark for \"(?>...)\" */\n#define STK_REPEAT                 0x0300\n#define STK_CALL_FRAME             0x0400\n#define STK_RETURN                 0x0500\n#define STK_SAVE_VAL               0x0600\n#define STK_PREC_READ_START        0x0700\n#define STK_PREC_READ_END          0x0800\n\n/* stack type check mask */\n#define STK_MASK_POP_USED          STK_ALT_FLAG\n#define STK_MASK_POP_HANDLED       0x0010\n#define STK_MASK_POP_HANDLED_TIL   (STK_MASK_POP_HANDLED | 0x0004)\n#define STK_MASK_TO_VOID_TARGET    0x100e\n#define STK_MASK_MEM_END_OR_MARK   0x8000  /* MEM_END or MEM_END_MARK */\n\ntypedef intptr_t StackIndex;\n\ntypedef struct _StackType {\n  unsigned int type;\n  int zid;\n  union {\n    struct {\n      Operation* pcode;     /* byte code position */\n      UChar*     pstr;      /* string position */\n      UChar*     pstr_prev; /* previous char position of pstr */\n    } state;\n    struct {\n      int        count;  /* for OP_REPEAT_INC, OP_REPEAT_INC_NG */\n      Operation* pcode;  /* byte code position (head of repeated target) */\n    } repeat;\n    struct {\n      StackIndex si;     /* index of stack */\n    } repeat_inc;\n    struct {\n      UChar *pstr;       /* start/end position */\n      /* Following information is set, if this stack type is MEM-START */\n      StackIndex prev_start;  /* prev. info (for backtrack  \"(...)*\" ) */\n      StackIndex prev_end;    /* prev. info (for backtrack  \"(...)*\" ) */\n    } mem;\n    struct {\n      UChar *pstr;       /* start position */\n    } empty_check;\n#ifdef USE_CALL\n    struct {\n      Operation *ret_addr; /* byte code position */\n      UChar *pstr;         /* string position */\n    } call_frame;\n#endif\n    struct {\n      enum SaveType type;\n      UChar* v;\n      UChar* v2;\n    } val;\n#ifdef USE_CALLOUT\n    struct {\n      int num;\n      OnigCalloutFunc func;\n    } callout;\n#endif\n  } u;\n} StackType;\n\n#ifdef USE_CALLOUT\n\nstruct OnigCalloutArgsStruct {\n  OnigCalloutIn    in;\n  int              name_id;   /* name id or ONIG_NON_NAME_ID */\n  int              num;\n  OnigRegex        regex;\n  const OnigUChar* string;\n  const OnigUChar* string_end;\n  const OnigUChar* start;\n  const OnigUChar* right_range;\n  const OnigUChar* current;  /* current matching position */\n  unsigned long    retry_in_match_counter;\n\n  /* invisible to users */\n  MatchArg*   msa;\n  StackType*  stk_base;\n  StackType*  stk;\n  StackIndex* mem_start_stk;\n  StackIndex* mem_end_stk;\n};\n\n#endif\n\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start, mp) do { \\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).match_stack_limit  = (mp)->match_stack_limit;\\\n  (msa).retry_limit_in_match = (mp)->retry_limit_in_match;\\\n  (msa).mp = mp;\\\n  (msa).best_len = ONIG_MISMATCH;\\\n  (msa).ptr_num  = (reg)->num_repeat + ((reg)->num_mem + 1) * 2; \\\n} while(0)\n#else\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start, mp) do { \\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).match_stack_limit  = (mp)->match_stack_limit;\\\n  (msa).retry_limit_in_match = (mp)->retry_limit_in_match;\\\n  (msa).mp = mp;\\\n  (msa).ptr_num  = (reg)->num_repeat + ((reg)->num_mem + 1) * 2; \\\n} while(0)\n#endif\n\n#define MATCH_ARG_FREE(msa)  if ((msa).stack_p) xfree((msa).stack_p)\n\n\n#define ALLOCA_PTR_NUM_LIMIT   50\n\n#define STACK_INIT(stack_num)  do {\\\n  if (msa->stack_p) {\\\n    is_alloca  = 0;\\\n    alloc_base = msa->stack_p;\\\n    stk_base   = (StackType* )(alloc_base\\\n                 + (sizeof(StackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + msa->stack_n;\\\n  }\\\n  else if (msa->ptr_num > ALLOCA_PTR_NUM_LIMIT) {\\\n    is_alloca  = 0;\\\n    alloc_base = (char* )xmalloc(sizeof(StackIndex) * msa->ptr_num\\\n                  + sizeof(StackType) * (stack_num));\\\n    CHECK_NULL_RETURN_MEMERR(alloc_base);\\\n    stk_base   = (StackType* )(alloc_base\\\n                 + (sizeof(StackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n  else {\\\n    is_alloca  = 1;\\\n    alloc_base = (char* )xalloca(sizeof(StackIndex) * msa->ptr_num\\\n                 + sizeof(StackType) * (stack_num));\\\n    CHECK_NULL_RETURN_MEMERR(alloc_base);\\\n    stk_base   = (StackType* )(alloc_base\\\n                 + (sizeof(StackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n} while(0);\n\n\n#define STACK_SAVE do{\\\n    msa->stack_n = (int )(stk_end - stk_base);\\\n  if (is_alloca != 0) {\\\n    size_t size = sizeof(StackIndex) * msa->ptr_num \\\n                + sizeof(StackType) * msa->stack_n;\\\n    msa->stack_p = xmalloc(size);\\\n    CHECK_NULL_RETURN_MEMERR(msa->stack_p);\\\n    xmemcpy(msa->stack_p, alloc_base, size);\\\n  }\\\n  else {\\\n    msa->stack_p = alloc_base;\\\n  };\\\n} while(0)\n\n#define UPDATE_FOR_STACK_REALLOC do{\\\n  repeat_stk    = (StackIndex* )alloc_base;\\\n  mem_start_stk = (StackIndex* )(repeat_stk + reg->num_repeat);\\\n  mem_end_stk   = mem_start_stk + num_mem + 1;\\\n} while(0)\n\nstatic unsigned int MatchStackLimit = DEFAULT_MATCH_STACK_LIMIT_SIZE;\n\nextern unsigned int\nonig_get_match_stack_limit_size(void)\n{\n  return MatchStackLimit;\n}\n\nextern int\nonig_set_match_stack_limit_size(unsigned int size)\n{\n  MatchStackLimit = size;\n  return 0;\n}\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n\nstatic unsigned long RetryLimitInMatch = DEFAULT_RETRY_LIMIT_IN_MATCH;\n\n#define CHECK_RETRY_LIMIT_IN_MATCH  do {\\\n  if (retry_in_match_counter++ > retry_limit_in_match) goto retry_limit_in_match_over;\\\n} while (0)\n\n#else\n\n#define CHECK_RETRY_LIMIT_IN_MATCH\n\n#endif /* USE_RETRY_LIMIT_IN_MATCH */\n\nextern unsigned long\nonig_get_retry_limit_in_match(void)\n{\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  return RetryLimitInMatch;\n#else\n  /* return ONIG_NO_SUPPORT_CONFIG; */\n  return 0;\n#endif\n}\n\nextern int\nonig_set_retry_limit_in_match(unsigned long size)\n{\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  RetryLimitInMatch = size;\n  return 0;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\n#ifdef USE_CALLOUT\nstatic OnigCalloutFunc DefaultProgressCallout;\nstatic OnigCalloutFunc DefaultRetractionCallout;\n#endif\n\nextern OnigMatchParam*\nonig_new_match_param(void)\n{\n  OnigMatchParam* p;\n\n  p = (OnigMatchParam* )xmalloc(sizeof(*p));\n  if (IS_NOT_NULL(p)) {\n    onig_initialize_match_param(p);\n  }\n\n  return p;\n}\n\nextern void\nonig_free_match_param_content(OnigMatchParam* p)\n{\n#ifdef USE_CALLOUT\n  if (IS_NOT_NULL(p->callout_data)) {\n    xfree(p->callout_data);\n    p->callout_data = 0;\n  }\n#endif\n}\n\nextern void\nonig_free_match_param(OnigMatchParam* p)\n{\n  if (IS_NOT_NULL(p)) {\n    onig_free_match_param_content(p);\n    xfree(p);\n  }\n}\n\nextern int\nonig_initialize_match_param(OnigMatchParam* mp)\n{\n  mp->match_stack_limit  = MatchStackLimit;\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  mp->retry_limit_in_match = RetryLimitInMatch;\n#endif\n\n#ifdef USE_CALLOUT\n  mp->progress_callout_of_contents   = DefaultProgressCallout;\n  mp->retraction_callout_of_contents = DefaultRetractionCallout;\n  mp->match_at_call_counter  = 0;\n  mp->callout_user_data      = 0;\n  mp->callout_data           = 0;\n  mp->callout_data_alloc_num = 0;\n#endif\n\n  return ONIG_NORMAL;\n}\n\n#ifdef USE_CALLOUT\n\nstatic int\nadjust_match_param(regex_t* reg, OnigMatchParam* mp)\n{\n  RegexExt* ext = reg->extp;\n\n  mp->match_at_call_counter = 0;\n\n  if (IS_NULL(ext) || ext->callout_num == 0) return ONIG_NORMAL;\n\n  if (ext->callout_num > mp->callout_data_alloc_num) {\n    CalloutData* d;\n    size_t n = ext->callout_num * sizeof(*d);\n    if (IS_NOT_NULL(mp->callout_data))\n      d = (CalloutData* )xrealloc(mp->callout_data, n);\n    else\n      d = (CalloutData* )xmalloc(n);\n    CHECK_NULL_RETURN_MEMERR(d);\n\n    mp->callout_data = d;\n    mp->callout_data_alloc_num = ext->callout_num;\n  }\n\n  xmemset(mp->callout_data, 0, mp->callout_data_alloc_num * sizeof(CalloutData));\n  return ONIG_NORMAL;\n}\n\n#define ADJUST_MATCH_PARAM(reg, mp) \\\n  r = adjust_match_param(reg, mp);\\\n  if (r != ONIG_NORMAL) return r;\n\n#define CALLOUT_DATA_AT_NUM(mp, num)  ((mp)->callout_data + ((num) - 1))\n\nextern int\nonig_check_callout_data_and_clear_old_values(OnigCalloutArgs* args)\n{\n  OnigMatchParam* mp;\n  int num;\n  CalloutData* d;\n\n  mp  = args->msa->mp;\n  num = args->num;\n\n  d = CALLOUT_DATA_AT_NUM(mp, num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n    return d->last_match_at_call_counter;\n  }\n\n  return 0;\n}\n\nextern int\nonig_get_callout_data_dont_clear_old(regex_t* reg, OnigMatchParam* mp,\n                                     int callout_num, int slot,\n                                     OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}\n\nextern int\nonig_get_callout_data_by_callout_args_self_dont_clear_old(OnigCalloutArgs* args,\n                                                          int slot, OnigType* type,\n                                                          OnigValue* val)\n{\n  return onig_get_callout_data_dont_clear_old(args->regex, args->msa->mp,\n                                              args->num, slot, type, val);\n}\n\nextern int\nonig_get_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n  }\n\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}\n\nextern int\nonig_get_callout_data_by_tag(regex_t* reg, OnigMatchParam* mp,\n                             const UChar* tag, const UChar* tag_end, int slot,\n                             OnigType* type, OnigValue* val)\n{\n  int num;\n\n  num = onig_get_callout_num_by_tag(reg, tag, tag_end);\n  if (num < 0)  return num;\n  if (num == 0) return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  return onig_get_callout_data(reg, mp, num, slot, type, val);\n}\n\nextern int\nonig_get_callout_data_by_callout_args(OnigCalloutArgs* args,\n                                      int callout_num, int slot,\n                                      OnigType* type, OnigValue* val)\n{\n  return onig_get_callout_data(args->regex, args->msa->mp, callout_num, slot,\n                               type, val);\n}\n\nextern int\nonig_get_callout_data_by_callout_args_self(OnigCalloutArgs* args,\n                                           int slot, OnigType* type, OnigValue* val)\n{\n  return onig_get_callout_data(args->regex, args->msa->mp, args->num, slot,\n                               type, val);\n}\n\nextern int\nonig_set_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType type, OnigValue* val)\n{\n  CalloutData* d;\n\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  d->slot[slot].type = type;\n  d->slot[slot].val  = *val;\n  d->last_match_at_call_counter = mp->match_at_call_counter;\n\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_set_callout_data_by_tag(regex_t* reg, OnigMatchParam* mp,\n                             const UChar* tag, const UChar* tag_end, int slot,\n                             OnigType type, OnigValue* val)\n{\n  int num;\n\n  num = onig_get_callout_num_by_tag(reg, tag, tag_end);\n  if (num < 0)  return num;\n  if (num == 0) return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  return onig_set_callout_data(reg, mp, num, slot, type, val);\n}\n\nextern int\nonig_set_callout_data_by_callout_args(OnigCalloutArgs* args,\n                                      int callout_num, int slot,\n                                      OnigType type, OnigValue* val)\n{\n  return onig_set_callout_data(args->regex, args->msa->mp, callout_num, slot,\n                               type, val);\n}\n\nextern int\nonig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,\n                                           int slot, OnigType type, OnigValue* val)\n{\n  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,\n                               type, val);\n}\n\n#else\n#define ADJUST_MATCH_PARAM(reg, mp)\n#endif /* USE_CALLOUT */\n\n\nstatic int\nstack_double(int is_alloca, char** arg_alloc_base,\n             StackType** arg_stk_base, StackType** arg_stk_end, StackType** arg_stk,\n             MatchArg* msa)\n{\n  unsigned int n;\n  int used;\n  size_t size;\n  size_t new_size;\n  char* alloc_base;\n  char* new_alloc_base;\n  StackType *stk_base, *stk_end, *stk;\n\n  alloc_base = *arg_alloc_base;\n  stk_base = *arg_stk_base;\n  stk_end  = *arg_stk_end;\n  stk      = *arg_stk;\n\n  n = (unsigned int )(stk_end - stk_base);\n  size = sizeof(StackIndex) * msa->ptr_num + sizeof(StackType) * n;\n  n *= 2;\n  new_size = sizeof(StackIndex) * msa->ptr_num + sizeof(StackType) * n;\n  if (is_alloca != 0) {\n    new_alloc_base = (char* )xmalloc(new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n    xmemcpy(new_alloc_base, alloc_base, size);\n  }\n  else {\n    if (msa->match_stack_limit != 0 && n > msa->match_stack_limit) {\n      if ((unsigned int )(stk_end - stk_base) == msa->match_stack_limit)\n        return ONIGERR_MATCH_STACK_LIMIT_OVER;\n      else\n        n = msa->match_stack_limit;\n    }\n    new_alloc_base = (char* )xrealloc(alloc_base, new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n  }\n\n  alloc_base = new_alloc_base;\n  used = (int )(stk - stk_base);\n  *arg_alloc_base = alloc_base;\n  *arg_stk_base   = (StackType* )(alloc_base\n                                  + (sizeof(StackIndex) * msa->ptr_num));\n  *arg_stk      = *arg_stk_base + used;\n  *arg_stk_end  = *arg_stk_base + n;\n  return 0;\n}\n\n#define STACK_ENSURE(n) do {\\\n    if ((int )(stk_end - stk) < (n)) {\\\n    int r = stack_double(is_alloca, &alloc_base, &stk_base, &stk_end, &stk, msa);\\\n    if (r != 0) { STACK_SAVE; return r; } \\\n    is_alloca = 0;\\\n    UPDATE_FOR_STACK_REALLOC;\\\n  }\\\n} while(0)\n\n#define STACK_AT(index)        (stk_base + (index))\n#define GET_STACK_INDEX(stk)   ((stk) - stk_base)\n\n#define STACK_PUSH_TYPE(stack_type) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  STACK_INC;\\\n} while(0)\n\n#define IS_TO_VOID_TARGET(stk) (((stk)->type & STK_MASK_TO_VOID_TARGET) != 0)\n\n#define STACK_PUSH(stack_type,pat,s,sprev) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ENSURED(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  STACK_INC;\\\n} while(0)\n\n#ifdef ONIG_DEBUG_MATCH\n#define STACK_PUSH_BOTTOM(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  stk->u.state.pstr      = s;\\\n  stk->u.state.pstr_prev = sprev;\\\n  STACK_INC;\\\n} while (0)\n#else\n#define STACK_PUSH_BOTTOM(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  STACK_INC;\\\n} while (0)\n#endif\n\n#define STACK_PUSH_ALT(pat,s,sprev)       STACK_PUSH(STK_ALT,pat,s,sprev)\n#define STACK_PUSH_SUPER_ALT(pat,s,sprev) STACK_PUSH(STK_SUPER_ALT,pat,s,sprev)\n#define STACK_PUSH_PREC_READ_START(s,sprev) \\\n  STACK_PUSH(STK_PREC_READ_START,(Operation* )0,s,sprev)\n#define STACK_PUSH_ALT_PREC_READ_NOT(pat,s,sprev) \\\n  STACK_PUSH(STK_ALT_PREC_READ_NOT,pat,s,sprev)\n#define STACK_PUSH_TO_VOID_START        STACK_PUSH_TYPE(STK_TO_VOID_START)\n#define STACK_PUSH_ALT_LOOK_BEHIND_NOT(pat,s,sprev) \\\n  STACK_PUSH(STK_ALT_LOOK_BEHIND_NOT,pat,s,sprev)\n\n#define STACK_PUSH_REPEAT(sid, pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT;\\\n  stk->zid  = (sid);\\\n  stk->u.repeat.pcode  = (pat);\\\n  stk->u.repeat.count  = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_REPEAT_INC(sindex) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT_INC;\\\n  stk->u.repeat_inc.si  = (sindex);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_START(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_START;\\\n  stk->zid  = (mnum);\\\n  stk->u.mem.pstr       = (s);\\\n  stk->u.mem.prev_start = mem_start_stk[mnum];\\\n  stk->u.mem.prev_end   = mem_end_stk[mnum];\\\n  mem_start_stk[mnum]   = GET_STACK_INDEX(stk);\\\n  mem_end_stk[mnum]     = INVALID_STACK_INDEX;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END;\\\n  stk->zid  = (mnum);\\\n  stk->u.mem.pstr       = (s);\\\n  stk->u.mem.prev_start = mem_start_stk[mnum];\\\n  stk->u.mem.prev_end   = mem_end_stk[mnum];\\\n  mem_end_stk[mnum] = GET_STACK_INDEX(stk);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END_MARK(mnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END_MARK;\\\n  stk->zid  = (mnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_GET_MEM_START(mnum, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    if ((k->type & STK_MASK_MEM_END_OR_MARK) != 0 \\\n      && k->zid == (mnum)) {\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_START && k->zid == (mnum)) {\\\n      if (level == 0) break;\\\n      level--;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_MEM_RANGE(k, mnum, start, end) do {\\\n  int level = 0;\\\n  while (k < stk) {\\\n    if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\\\n      if (level == 0) (start) = k->u.mem.pstr;\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_END && k->u.mem.num == (mnum)) {\\\n      level--;\\\n      if (level == 0) {\\\n        (end) = k->u.mem.pstr;\\\n        break;\\\n      }\\\n    }\\\n    k++;\\\n  }\\\n} while(0)\n\n#define STACK_PUSH_EMPTY_CHECK_START(cnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_EMPTY_CHECK_START;\\\n  stk->zid  = (cnum);\\\n  stk->u.empty_check.pstr = (s);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_EMPTY_CHECK_END(cnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_EMPTY_CHECK_END;\\\n  stk->zid  = (cnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_CALL_FRAME(pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALL_FRAME;\\\n  stk->u.call_frame.ret_addr = (pat);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_RETURN do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_RETURN;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_SAVE_VAL(sid, stype, sval) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_SAVE_VAL;\\\n  stk->zid  = (sid);\\\n  stk->u.val.type = (stype);\\\n  stk->u.val.v    = (UChar* )(sval);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_SAVE_VAL_WITH_SPREV(sid, stype, sval) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_SAVE_VAL;\\\n  stk->zid  = (sid);\\\n  stk->u.val.type = (stype);\\\n  stk->u.val.v    = (UChar* )(sval);\\\n  stk->u.val.v2   = sprev;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST(stype, sval) do {\\\n  StackType *k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)) {\\\n      (sval) = k->u.val.v;\\\n      break;\\\n    }\\\n  }\\\n} while (0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST_ID(stype, sid, sval) do { \\\n  int level = 0;\\\n  StackType *k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST_ID\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)\\\n        && k->zid == (sid)) {\\\n      if (level == 0) {\\\n        (sval) = k->u.val.v;\\\n        break;\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME)\\\n      level--;\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while (0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST_ID_WITH_SPREV(stype, sid, sval) do { \\\n  int level = 0;\\\n  StackType *k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST_ID\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)\\\n        && k->zid == (sid)) {\\\n      if (level == 0) {\\\n        (sval) = k->u.val.v;\\\n        sprev  = k->u.val.v2;\\\n        break;\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME)\\\n      level--;\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while (0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST_ID_FROM(stype, sid, sval, stk_from) do { \\\n  int level = 0;\\\n  StackType *k = (stk_from);\\\n  while (k > stk_base) {\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST_ID_FROM\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)\\\n        && k->u.val.id == (sid)) {\\\n      if (level == 0) {\\\n        (sval) = k->u.val.v;\\\n        break;\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME)\\\n      level--;\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n    k--;\\\n  }\\\n} while (0)\n\n#define STACK_PUSH_CALLOUT_CONTENTS(anum, func) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALLOUT;\\\n  stk->zid  = ONIG_NON_NAME_ID;\\\n  stk->u.callout.num = (anum);\\\n  stk->u.callout.func = (func);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_CALLOUT_NAME(aid, anum, func) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALLOUT;\\\n  stk->zid  = (aid);\\\n  stk->u.callout.num = (anum);\\\n  stk->u.callout.func = (func);\\\n  STACK_INC;\\\n} while(0)\n\n#ifdef ONIG_DEBUG\n#define STACK_BASE_CHECK(p, at) \\\n  if ((p) < stk_base) {\\\n    fprintf(stderr, \"at %s\\n\", at);\\\n    goto stack_error;\\\n  }\n#else\n#define STACK_BASE_CHECK(p, at)\n#endif\n\n#define STACK_POP_ONE do {\\\n  stk--;\\\n  STACK_BASE_CHECK(stk, \"STACK_POP_ONE\"); \\\n} while(0)\n\n\n#ifdef USE_CALLOUT\n#define POP_CALLOUT_CASE \\\n  else if (stk->type == STK_CALLOUT) {\\\n    RETRACTION_CALLOUT(stk->u.callout.func, stk->zid, stk->u.callout.num, msa->mp->callout_user_data);\\\n  }\n#else\n#define POP_CALLOUT_CASE\n#endif\n\n#define STACK_POP  do {\\\n  switch (pop_level) {\\\n  case STACK_POP_LEVEL_FREE:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n    }\\\n    break;\\\n  case STACK_POP_LEVEL_MEM_START:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 2\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if (stk->type == STK_MEM_START) {\\\n        mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n        mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n      }\\\n    }\\\n    break;\\\n  default:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 3\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if ((stk->type & STK_MASK_POP_HANDLED) != 0) {\\\n        if (stk->type == STK_MEM_START) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        else if (stk->type == STK_REPEAT_INC) {\\\n          STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n        }\\\n        else if (stk->type == STK_MEM_END) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        POP_CALLOUT_CASE\\\n      }\\\n    }\\\n    break;\\\n  }\\\n} while(0)\n\n#define POP_TIL_BODY(aname, til_type) do {\\\n  while (1) {\\\n    stk--;\\\n    STACK_BASE_CHECK(stk, (aname));\\\n    if ((stk->type & STK_MASK_POP_HANDLED_TIL) != 0) {\\\n      if (stk->type == (til_type)) break;\\\n      else {\\\n        if (stk->type == STK_MEM_START) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        else if (stk->type == STK_REPEAT_INC) {\\\n          STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n        }\\\n        else if (stk->type == STK_MEM_END) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        /* Don't call callout here because negation of total success by (?!..) (?<!..) */\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_POP_TIL_ALT_PREC_READ_NOT  do {\\\n  POP_TIL_BODY(\"STACK_POP_TIL_ALT_PREC_READ_NOT\", STK_ALT_PREC_READ_NOT);\\\n} while(0)\n\n#define STACK_POP_TIL_ALT_LOOK_BEHIND_NOT  do {\\\n  POP_TIL_BODY(\"STACK_POP_TIL_ALT_LOOK_BEHIND_NOT\", STK_ALT_LOOK_BEHIND_NOT);\\\n} while(0)\n\n\n#define STACK_EXEC_TO_VOID(k) do {\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EXEC_TO_VOID\"); \\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      if (k->type == STK_TO_VOID_START) {\\\n        k->type = STK_VOID;\\\n        break;\\\n      }\\\n      k->type = STK_VOID;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_PREC_READ_START(k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_PREC_READ_START\");\\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      k->type = STK_VOID;\\\n    }\\\n    else if (k->type == STK_PREC_READ_START) {\\\n      if (level == 0) {\\\n        break;\\\n      }\\\n      level--;\\\n    }\\\n    else if (k->type == STK_PREC_READ_END) {\\\n      level++;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_EMPTY_CHECK(isnull,sid,s) do {\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK\"); \\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->zid == (sid)) {\\\n        (isnull) = (k->u.empty_check.pstr == (s));\\\n        break;\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_MEM_START_GET_PREV_END_ADDR(k /* STK_MEM_START*/, reg, addr) do {\\\n  if (k->u.mem.prev_end == INVALID_STACK_INDEX) {\\\n    (addr) = 0;\\\n  }\\\n  else {\\\n    if (MEM_STATUS_AT((reg)->bt_mem_end, k->zid))\\\n      (addr) = STACK_AT(k->u.mem.prev_end)->u.mem.pstr;\\\n    else\\\n      (addr) = (UChar* )k->u.mem.prev_end;\\\n  }\\\n} while (0)\n\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n#define STACK_EMPTY_CHECK_MEM(isnull,sid,s,reg) do {\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK_MEM\"); \\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->zid == (sid)) {\\\n        if (k->u.empty_check.pstr != (s)) {\\\n          (isnull) = 0;\\\n          break;\\\n        }\\\n        else {\\\n          UChar* endp;\\\n          int level = 0;\\\n          (isnull) = 1;\\\n          while (k < stk) {\\\n            if (k->type == STK_MEM_START && level == 0) {\\\n              STACK_MEM_START_GET_PREV_END_ADDR(k, reg, endp);\\\n              if (endp == 0) {\\\n                (isnull) = 0; break;\\\n              }\\\n              else if (STACK_AT(k->u.mem.prev_start)->u.mem.pstr != endp) {\\\n                (isnull) = 0; break;\\\n              }\\\n              else if (endp != s) {\\\n                (isnull) = -1; /* empty, but position changed */ \\\n              }\\\n            }\\\n            else if (k->type == STK_PREC_READ_START) {\\\n              level++;\\\n            }\\\n            else if (k->type == STK_PREC_READ_END) {\\\n              level--;\\\n            }\\\n            k++;\\\n          }\\\n          break;\\\n        }\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_EMPTY_CHECK_MEM_REC(isnull,sid,s,reg) do {\\\n  int level = 0;\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK_MEM_REC\");\\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->zid == (sid)) {\\\n        if (level == 0) {\\\n          if (k->u.empty_check.pstr != (s)) {\\\n            (isnull) = 0;\\\n            break;\\\n          }\\\n          else {\\\n            UChar* endp;\\\n            int prec_level = 0;\\\n            (isnull) = 1;\\\n            while (k < stk) {\\\n              if (k->type == STK_MEM_START) {\\\n                if (level == 0 && prec_level == 0) {\\\n                  STACK_MEM_START_GET_PREV_END_ADDR(k, reg, endp);\\\n                  if (endp == 0) {\\\n                    (isnull) = 0; break;\\\n                  }\\\n                  else if (STACK_AT(k->u.mem.prev_start)->u.mem.pstr != endp) { \\\n                    (isnull) = 0; break;\\\n                  }\\\n                  else if (endp != s) {\\\n                    (isnull) = -1; /* empty, but position changed */\\\n                  }\\\n                }\\\n              }\\\n              else if (k->type == STK_EMPTY_CHECK_START) {\\\n                if (k->zid == (sid)) level++;\\\n              }\\\n              else if (k->type == STK_EMPTY_CHECK_END) {\\\n                if (k->zid == (sid)) level--;\\\n              }\\\n              else if (k->type == STK_PREC_READ_START) {\\\n                prec_level++;\\\n              }\\\n              else if (k->type == STK_PREC_READ_END) {\\\n                prec_level--;\\\n              }\\\n              k++;\\\n            }\\\n            break;\\\n          }\\\n        }\\\n        else {\\\n          level--;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_EMPTY_CHECK_END) {\\\n      if (k->zid == (sid)) level++;\\\n    }\\\n  }\\\n} while(0)\n#else\n#define STACK_EMPTY_CHECK_REC(isnull,id,s) do {\\\n  int level = 0;\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK_REC\"); \\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->u.empty_check.num == (id)) {\\\n        if (level == 0) {\\\n          (isnull) = (k->u.empty_check.pstr == (s));\\\n          break;\\\n        }\\\n      }\\\n      level--;\\\n    }\\\n    else if (k->type == STK_EMPTY_CHECK_END) {\\\n      level++;\\\n    }\\\n  }\\\n} while(0)\n#endif /* USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT */\n\n#define STACK_GET_REPEAT(sid, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_REPEAT\"); \\\n    if (k->type == STK_REPEAT) {\\\n      if (level == 0) {\\\n        if (k->zid == (sid)) {\\\n          break;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME) level--;\\\n    else if (k->type == STK_RETURN)     level++;\\\n  }\\\n} while(0)\n\n#define STACK_RETURN(addr)  do {\\\n  int level = 0;\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_RETURN\"); \\\n    if (k->type == STK_CALL_FRAME) {\\\n      if (level == 0) {\\\n        (addr) = k->u.call_frame.ret_addr;\\\n        break;\\\n      }\\\n      else level--;\\\n    }\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while(0)\n\n\n#define STRING_CMP(s1,s2,len) do {\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) goto fail;\\\n  }\\\n} while(0)\n\n#define STRING_CMP_IC(case_fold_flag,s1,ps2,len) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    goto fail; \\\n} while(0)\n\nstatic int string_cmp_ic(OnigEncoding enc, int case_fold_flag,\n                         UChar* s1, UChar** ps2, int mblen)\n{\n  UChar buf1[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar buf2[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *p1, *p2, *end1, *s2, *end2;\n  int len1, len2;\n\n  s2   = *ps2;\n  end1 = s1 + mblen;\n  end2 = s2 + mblen;\n  while (s1 < end1) {\n    len1 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s1, end1, buf1);\n    len2 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s2, end2, buf2);\n    if (len1 != len2) return 0;\n    p1 = buf1;\n    p2 = buf2;\n    while (len1-- > 0) {\n      if (*p1 != *p2) return 0;\n      p1++;\n      p2++;\n    }\n  }\n\n  *ps2 = s2;\n  return 1;\n}\n\n#define STRING_CMP_VALUE(s1,s2,len,is_fail) do {\\\n  is_fail = 0;\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) {\\\n      is_fail = 1; break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STRING_CMP_VALUE_IC(case_fold_flag,s1,ps2,len,is_fail) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    is_fail = 1; \\\n  else \\\n    is_fail = 0; \\\n} while(0)\n\n\n#define IS_EMPTY_STR           (str == end)\n#define ON_STR_BEGIN(s)        ((s) == str)\n#define ON_STR_END(s)          ((s) == end)\n#define DATA_ENSURE_CHECK1     (s < right_range)\n#define DATA_ENSURE_CHECK(n)   (s + (n) <= right_range)\n#define DATA_ENSURE(n)         if (s + (n) > right_range) goto fail\n\n#define INIT_RIGHT_RANGE    right_range = (UChar* )in_right_range\n\n#ifdef USE_CAPTURE_HISTORY\nstatic int\nmake_capture_history_tree(OnigCaptureTreeNode* node, StackType** kp,\n                          StackType* stk_top, UChar* str, regex_t* reg)\n{\n  int n, r;\n  OnigCaptureTreeNode* child;\n  StackType* k = *kp;\n\n  while (k < stk_top) {\n    if (k->type == STK_MEM_START) {\n      n = k->zid;\n      if (n <= ONIG_MAX_CAPTURE_HISTORY_GROUP &&\n          MEM_STATUS_AT(reg->capture_history, n) != 0) {\n        child = history_node_new();\n        CHECK_NULL_RETURN_MEMERR(child);\n        child->group = n;\n        child->beg = (int )(k->u.mem.pstr - str);\n        r = history_tree_add_child(node, child);\n        if (r != 0) return r;\n        *kp = (k + 1);\n        r = make_capture_history_tree(child, kp, stk_top, str, reg);\n        if (r != 0) return r;\n\n        k = *kp;\n        child->end = (int )(k->u.mem.pstr - str);\n      }\n    }\n    else if (k->type == STK_MEM_END) {\n      if (k->zid == node->group) {\n        node->end = (int )(k->u.mem.pstr - str);\n        *kp = k;\n        return 0;\n      }\n    }\n    k++;\n  }\n\n  return 1; /* 1: root node ending. */\n}\n#endif\n\n#ifdef USE_BACKREF_WITH_LEVEL\nstatic int mem_is_in_memp(int mem, int num, MemNumType* memp)\n{\n  int i;\n\n  for (i = 0; i < num; i++) {\n    if (mem == (int )memp[i]) return 1;\n  }\n  return 0;\n}\n\nstatic int\nbackref_match_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int ignore_case, int case_fold_flag,\n                              int nest, int mem_num, MemNumType* memp,\n                              UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  StackType* k;\n\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (IS_NOT_NULL(pend)) {\n            if (pend - pstart > send - *s) return 0; /* or goto next_mem; */\n            p  = pstart;\n            ss = *s;\n\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; /* or goto next_mem; */\n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; /* or goto next_mem; */\n              }\n            }\n\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n\n  return 0;\n}\n\nstatic int\nbackref_check_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int nest, int mem_num, MemNumType* memp)\n{\n  int level;\n  StackType* k;\n\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          return 1;\n        }\n      }\n    }\n    k--;\n  }\n\n  return 0;\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n\n#ifdef ONIG_DEBUG_STATISTICS\n\n#define USE_TIMEOFDAY\n\n#ifdef USE_TIMEOFDAY\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\nstatic struct timeval ts, te;\n#define GETTIME(t)        gettimeofday(&(t), (struct timezone* )0)\n#define TIMEDIFF(te,ts)   (((te).tv_usec - (ts).tv_usec) + \\\n                           (((te).tv_sec - (ts).tv_sec)*1000000))\n#else\n#ifdef HAVE_SYS_TIMES_H\n#include <sys/times.h>\n#endif\nstatic struct tms ts, te;\n#define GETTIME(t)         times(&(t))\n#define TIMEDIFF(te,ts)   ((te).tms_utime - (ts).tms_utime)\n#endif\n\nstatic int OpCounter[256];\nstatic int OpPrevCounter[256];\nstatic unsigned long OpTime[256];\nstatic int OpCurr = OP_FINISH;\nstatic int OpPrevTarget = OP_FAIL;\nstatic int MaxStackDepth = 0;\n\n#define SOP_IN(opcode) do {\\\n  if (opcode == OpPrevTarget) OpPrevCounter[OpCurr]++;\\\n  OpCurr = opcode;\\\n  OpCounter[opcode]++;\\\n  GETTIME(ts);\\\n} while(0)\n\n#define SOP_OUT do {\\\n  GETTIME(te);\\\n  OpTime[OpCurr] += TIMEDIFF(te, ts);\\\n} while(0)\n\nextern void\nonig_statistics_init(void)\n{\n  int i;\n  for (i = 0; i < 256; i++) {\n    OpCounter[i] = OpPrevCounter[i] = 0; OpTime[i] = 0;\n  }\n  MaxStackDepth = 0;\n}\n\nextern int\nonig_print_statistics(FILE* f)\n{\n  int r;\n  int i;\n\n  r = fprintf(f, \"   count      prev        time\\n\");\n  if (r < 0) return -1;\n\n  for (i = 0; OpInfo[i].opcode >= 0; i++) {\n    r = fprintf(f, \"%8d: %8d: %10ld: %s\\n\",\n                OpCounter[i], OpPrevCounter[i], OpTime[i], OpInfo[i].name);\n    if (r < 0) return -1;\n  }\n  r = fprintf(f, \"\\nmax stack depth: %d\\n\", MaxStackDepth);\n  if (r < 0) return -1;\n\n  return 0;\n}\n\n#define STACK_INC do {\\\n  stk++;\\\n  if (stk - stk_base > MaxStackDepth) \\\n    MaxStackDepth = stk - stk_base;\\\n} while(0)\n\n#else\n#define STACK_INC     stk++\n\n#define SOP_IN(opcode)\n#define SOP_OUT\n#endif\n\n\n/* matching region of POSIX API */\ntypedef int regoff_t;\n\ntypedef struct {\n  regoff_t  rm_so;\n  regoff_t  rm_eo;\n} posix_regmatch_t;\n\n\n\n#ifdef USE_THREADED_CODE\n\n#define BYTECODE_INTERPRETER_START      GOTO_OP;\n#define BYTECODE_INTERPRETER_END\n#define CASE_OP(x)   L_##x: SOP_IN(OP_##x); sbegin = s; MATCH_DEBUG_OUT(0)\n#define DEFAULT_OP   /* L_DEFAULT: */\n#define NEXT_OP      sprev = sbegin; JUMP_OP\n#define JUMP_OP      GOTO_OP\n#ifdef USE_DIRECT_THREADED_CODE\n#define GOTO_OP      goto *(p->opaddr)\n#else\n#define GOTO_OP      goto *opcode_to_label[p->opcode]\n#endif\n#define BREAK_OP     /* Nothing */\n\n#else\n\n#define BYTECODE_INTERPRETER_START \\\n  while (1) {\\\n  MATCH_DEBUG_OUT(0)\\\n  sbegin = s;\\\n  switch (p->opcode) {\n#define BYTECODE_INTERPRETER_END  } sprev = sbegin; }\n#define CASE_OP(x)   case OP_##x: SOP_IN(OP_##x);\n#define DEFAULT_OP   default:\n#define NEXT_OP      break\n#define JUMP_OP      GOTO_OP\n#define GOTO_OP      continue; break\n#define BREAK_OP     break\n\n#endif /* USE_THREADED_CODE */\n\n#define INC_OP       p++\n#define NEXT_OUT     SOP_OUT; NEXT_OP\n#define JUMP_OUT     SOP_OUT; JUMP_OP\n#define BREAK_OUT    SOP_OUT; BREAK_OP\n#define CHECK_INTERRUPT_JUMP_OUT  SOP_OUT; CHECK_INTERRUPT_IN_MATCH; JUMP_OP\n\n\n#ifdef ONIG_DEBUG_MATCH\n#define MATCH_DEBUG_OUT(offset) do {\\\n      Operation *xp;\\\n      UChar *q, *bp, buf[50];\\\n      int len, spos;\\\n      spos = IS_NOT_NULL(s) ? (int )(s - str) : -1;\\\n      xp = p - (offset);\\\n      fprintf(stderr, \"%7u: %7ld: %4d> \\\"\",\\\n              counter, GET_STACK_INDEX(stk), spos);\\\n      counter++;\\\n      bp = buf;\\\n      if (IS_NOT_NULL(s)) {\\\n        for (i = 0, q = s; i < 7 && q < end; i++) {\\\n          len = enclen(encode, q);\\\n          while (len-- > 0) *bp++ = *q++;\\\n        }\\\n        if (q < end) { xmemcpy(bp, \"...\\\"\", 4); bp += 4; }\\\n        else         { xmemcpy(bp, \"\\\"\",    1); bp += 1; }\\\n      }\\\n      else {\\\n        xmemcpy(bp, \"\\\"\", 1); bp += 1;\\\n      }\\\n      *bp = 0;\\\n      fputs((char* )buf, stderr);\\\n      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);\\\n      if (xp == FinishCode)\\\n        fprintf(stderr, \"----: finish\");\\\n      else {\\\n        fprintf(stderr, \"%4d: \", (int )(xp - reg->ops));\\\n        print_compiled_byte_code(stderr, reg, (int )(xp - reg->ops), reg->ops, encode);\\\n      }\\\n      fprintf(stderr, \"\\n\");\\\n  } while(0);\n#else\n#define MATCH_DEBUG_OUT(offset)\n#endif\n\n\n/* match data(str - end) from position (sstart). */\n/* if sstart == str then set sprev to NULL. */\nstatic int\nmatch_at(regex_t* reg, const UChar* str, const UChar* end,\n         const UChar* in_right_range, const UChar* sstart, UChar* sprev,\n         MatchArg* msa)\n{\n\n#if defined(USE_DIRECT_THREADED_CODE)\n  static Operation FinishCode[] = { { .opaddr=&&L_FINISH } };\n#else\n  static Operation FinishCode[] = { { OP_FINISH } };\n#endif\n\n#ifdef USE_THREADED_CODE\n  static const void *opcode_to_label[] = {\n  &&L_FINISH,\n  &&L_END,\n  &&L_EXACT1,\n  &&L_EXACT2,\n  &&L_EXACT3,\n  &&L_EXACT4,\n  &&L_EXACT5,\n  &&L_EXACTN,\n  &&L_EXACTMB2N1,\n  &&L_EXACTMB2N2,\n  &&L_EXACTMB2N3,\n  &&L_EXACTMB2N,\n  &&L_EXACTMB3N,\n  &&L_EXACTMBN,\n  &&L_EXACT1_IC,\n  &&L_EXACTN_IC,\n  &&L_CCLASS,\n  &&L_CCLASS_MB,\n  &&L_CCLASS_MIX,\n  &&L_CCLASS_NOT,\n  &&L_CCLASS_MB_NOT,\n  &&L_CCLASS_MIX_NOT,\n  &&L_ANYCHAR,\n  &&L_ANYCHAR_ML,\n  &&L_ANYCHAR_STAR,\n  &&L_ANYCHAR_ML_STAR,\n  &&L_ANYCHAR_STAR_PEEK_NEXT,\n  &&L_ANYCHAR_ML_STAR_PEEK_NEXT,\n  &&L_WORD,\n  &&L_WORD_ASCII,\n  &&L_NO_WORD,\n  &&L_NO_WORD_ASCII,\n  &&L_WORD_BOUNDARY,\n  &&L_NO_WORD_BOUNDARY,\n  &&L_WORD_BEGIN,\n  &&L_WORD_END,\n  &&L_TEXT_SEGMENT_BOUNDARY,\n  &&L_BEGIN_BUF,\n  &&L_END_BUF,\n  &&L_BEGIN_LINE,\n  &&L_END_LINE,\n  &&L_SEMI_END_BUF,\n  &&L_BEGIN_POSITION,\n  &&L_BACKREF1,\n  &&L_BACKREF2,\n  &&L_BACKREF_N,\n  &&L_BACKREF_N_IC,\n  &&L_BACKREF_MULTI,\n  &&L_BACKREF_MULTI_IC,\n  &&L_BACKREF_WITH_LEVEL,\n  &&L_BACKREF_WITH_LEVEL_IC,\n  &&L_BACKREF_CHECK,\n  &&L_BACKREF_CHECK_WITH_LEVEL,\n  &&L_MEMORY_START,\n  &&L_MEMORY_START_PUSH,\n  &&L_MEMORY_END_PUSH,\n  &&L_MEMORY_END_PUSH_REC,\n  &&L_MEMORY_END,\n  &&L_MEMORY_END_REC,\n  &&L_FAIL,\n  &&L_JUMP,\n  &&L_PUSH,\n  &&L_PUSH_SUPER,\n  &&L_POP_OUT,\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n  &&L_PUSH_OR_JUMP_EXACT1,\n#endif\n  &&L_PUSH_IF_PEEK_NEXT,\n  &&L_REPEAT,\n  &&L_REPEAT_NG,\n  &&L_REPEAT_INC,\n  &&L_REPEAT_INC_NG,\n  &&L_REPEAT_INC_SG,\n  &&L_REPEAT_INC_NG_SG,\n  &&L_EMPTY_CHECK_START,\n  &&L_EMPTY_CHECK_END,\n  &&L_EMPTY_CHECK_END_MEMST,\n  &&L_EMPTY_CHECK_END_MEMST_PUSH,\n  &&L_PREC_READ_START,\n  &&L_PREC_READ_END,\n  &&L_PREC_READ_NOT_START,\n  &&L_PREC_READ_NOT_END,\n  &&L_ATOMIC_START,\n  &&L_ATOMIC_END,\n  &&L_LOOK_BEHIND,\n  &&L_LOOK_BEHIND_NOT_START,\n  &&L_LOOK_BEHIND_NOT_END,\n  &&L_CALL,\n  &&L_RETURN,\n  &&L_PUSH_SAVE_VAL,\n  &&L_UPDATE_VAR,\n#ifdef USE_CALLOUT\n  &&L_CALLOUT_CONTENTS,\n  &&L_CALLOUT_NAME,\n#endif\n  };\n#endif\n\n  int i, n, num_mem, best_len, pop_level;\n  LengthType tlen, tlen2;\n  MemNumType mem;\n  RelAddrType addr;\n  UChar *s, *q, *ps, *sbegin;\n  UChar *right_range;\n  int is_alloca;\n  char *alloc_base;\n  StackType *stk_base, *stk, *stk_end;\n  StackType *stkp; /* used as any purpose. */\n  StackIndex si;\n  StackIndex *repeat_stk;\n  StackIndex *mem_start_stk, *mem_end_stk;\n  UChar* keep;\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  unsigned long retry_limit_in_match;\n  unsigned long retry_in_match_counter;\n#endif\n\n#ifdef USE_CALLOUT\n  int of;\n#endif\n\n  Operation* p = reg->ops;\n  OnigOptionType option = reg->options;\n  OnigEncoding encode = reg->enc;\n  OnigCaseFoldType case_fold_flag = reg->case_fold_flag;\n\n#ifdef ONIG_DEBUG_MATCH\n  static unsigned int counter = 1;\n#endif\n\n#ifdef USE_DIRECT_THREADED_CODE\n  if (IS_NULL(msa)) {\n    for (i = 0; i < reg->ops_used; i++) {\n       const void* addr;\n       addr = opcode_to_label[reg->ocs[i]];\n       p->opaddr = addr;\n       p++;\n    }\n    return ONIG_NORMAL;\n  }\n#endif\n\n#ifdef USE_CALLOUT\n  msa->mp->match_at_call_counter++;\n#endif\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  retry_limit_in_match = msa->retry_limit_in_match;\n#endif\n\n  pop_level = reg->stack_pop_level;\n  num_mem = reg->num_mem;\n  STACK_INIT(INIT_MATCH_STACK_SIZE);\n  UPDATE_FOR_STACK_REALLOC;\n  for (i = 1; i <= num_mem; i++) {\n    mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;\n  }\n\n#ifdef ONIG_DEBUG_MATCH\n  fprintf(stderr, \"match_at: str: %p, end: %p, start: %p, sprev: %p\\n\",\n          str, end, sstart, sprev);\n  fprintf(stderr, \"size: %d, start offset: %d\\n\",\n          (int )(end - str), (int )(sstart - str));\n#endif\n\n  best_len = ONIG_MISMATCH;\n  keep = s = (UChar* )sstart;\n  STACK_PUSH_BOTTOM(STK_ALT, FinishCode);  /* bottom stack */\n  INIT_RIGHT_RANGE;\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  retry_in_match_counter = 0;\n#endif\n\n  BYTECODE_INTERPRETER_START {\n    CASE_OP(END)\n      n = (int )(s - sstart);\n      if (n > best_len) {\n        OnigRegion* region;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n        if (IS_FIND_LONGEST(option)) {\n          if (n > msa->best_len) {\n            msa->best_len = n;\n            msa->best_s   = (UChar* )sstart;\n          }\n          else\n            goto end_best_len;\n        }\n#endif\n        best_len = n;\n        region = msa->region;\n        if (region) {\n          if (keep > s) keep = s;\n\n#ifdef USE_POSIX_API_REGION_OPTION\n          if (IS_POSIX_REGION(msa->options)) {\n            posix_regmatch_t* rmt = (posix_regmatch_t* )region;\n\n            rmt[0].rm_so = (regoff_t )(keep - str);\n            rmt[0].rm_eo = (regoff_t )(s    - str);\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (MEM_STATUS_AT(reg->bt_mem_start, i))\n                  rmt[i].rm_so = (regoff_t )(STACK_AT(mem_start_stk[i])->u.mem.pstr - str);\n                else\n                  rmt[i].rm_so = (regoff_t )((UChar* )((void* )(mem_start_stk[i])) - str);\n\n                rmt[i].rm_eo = (regoff_t )((MEM_STATUS_AT(reg->bt_mem_end, i)\n                                            ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                            : (UChar* )((void* )mem_end_stk[i]))\n                                           - str);\n              }\n              else {\n                rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;\n              }\n            }\n          }\n          else {\n#endif /* USE_POSIX_API_REGION_OPTION */\n            region->beg[0] = (int )(keep - str);\n            region->end[0] = (int )(s    - str);\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (MEM_STATUS_AT(reg->bt_mem_start, i))\n                  region->beg[i] = (int )(STACK_AT(mem_start_stk[i])->u.mem.pstr - str);\n                else\n                  region->beg[i] = (int )((UChar* )((void* )mem_start_stk[i]) - str);\n\n                region->end[i] = (int )((MEM_STATUS_AT(reg->bt_mem_end, i)\n                                         ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                         : (UChar* )((void* )mem_end_stk[i])) - str);\n              }\n              else {\n                region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n              }\n            }\n\n#ifdef USE_CAPTURE_HISTORY\n            if (reg->capture_history != 0) {\n              int r;\n              OnigCaptureTreeNode* node;\n\n              if (IS_NULL(region->history_root)) {\n                region->history_root = node = history_node_new();\n                CHECK_NULL_RETURN_MEMERR(node);\n              }\n              else {\n                node = region->history_root;\n                history_tree_clear(node);\n              }\n\n              node->group = 0;\n              node->beg   = (int )(keep - str);\n              node->end   = (int )(s    - str);\n\n              stkp = stk_base;\n              r = make_capture_history_tree(region->history_root, &stkp,\n                                            stk, (UChar* )str, reg);\n              if (r < 0) {\n                best_len = r; /* error code */\n                goto finish;\n              }\n            }\n#endif /* USE_CAPTURE_HISTORY */\n#ifdef USE_POSIX_API_REGION_OPTION\n          } /* else IS_POSIX_REGION() */\n#endif\n        } /* if (region) */\n      } /* n > best_len */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n    end_best_len:\n#endif\n      SOP_OUT;\n\n      if (IS_FIND_CONDITION(option)) {\n        if (IS_FIND_NOT_EMPTY(option) && s == sstart) {\n          best_len = ONIG_MISMATCH;\n          goto fail; /* for retry */\n        }\n        if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {\n          goto fail; /* for retry */\n        }\n      }\n\n      /* default behavior: return first-matching result. */\n      goto finish;\n\n    CASE_OP(EXACT1)\n      DATA_ENSURE(1);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      s++;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(EXACT1_IC)\n      {\n        int len;\n        UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        DATA_ENSURE(1);\n        len = ONIGENC_MBC_CASE_FOLD(encode,\n                 /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                    case_fold_flag,\n                                    &s, end, lowbuf);\n        DATA_ENSURE(0);\n        q = lowbuf;\n        ps = p->exact.s;\n        while (len-- > 0) {\n          if (*ps != *q) goto fail;\n          ps++; q++;\n        }\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(EXACT2)\n      DATA_ENSURE(2);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACT3)\n      DATA_ENSURE(3);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACT4)\n      DATA_ENSURE(4);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACT5)\n      DATA_ENSURE(5);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTN)\n      tlen = p->exact_n.n;\n      DATA_ENSURE(tlen);\n      ps = p->exact_n.s;\n      while (tlen-- > 0) {\n        if (*ps++ != *s++) goto fail;\n      }\n      sprev = s - 1;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTN_IC)\n      {\n        int len;\n        UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        tlen = p->exact_n.n;\n        ps   = p->exact_n.s;\n        endp = ps + tlen;\n        while (ps < endp) {\n          sprev = s;\n          DATA_ENSURE(1);\n          len = ONIGENC_MBC_CASE_FOLD(encode,\n                        /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                      case_fold_flag,\n                                      &s, end, lowbuf);\n          DATA_ENSURE(0);\n          q = lowbuf;\n          while (len-- > 0) {\n            if (*ps != *q) goto fail;\n            ps++; q++;\n          }\n        }\n      }\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB2N1)\n      DATA_ENSURE(2);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      s++;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(EXACTMB2N2)\n      DATA_ENSURE(4);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      sprev = s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB2N3)\n      DATA_ENSURE(6);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      sprev = s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB2N)\n      tlen = p->exact_n.n;\n      DATA_ENSURE(tlen * 2);\n      ps = p->exact_n.s;\n      while (tlen-- > 0) {\n        if (*ps != *s) goto fail;\n        ps++; s++;\n        if (*ps != *s) goto fail;\n        ps++; s++;\n      }\n      sprev = s - 2;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB3N)\n      tlen = p->exact_n.n;\n      DATA_ENSURE(tlen * 3);\n      ps = p->exact_n.s;\n      while (tlen-- > 0) {\n        if (*ps != *s) goto fail;\n        ps++; s++;\n        if (*ps != *s) goto fail;\n        ps++; s++;\n        if (*ps != *s) goto fail;\n        ps++; s++;\n      }\n      sprev = s - 3;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMBN)\n      tlen  = p->exact_len_n.len; /* mb byte len */\n      tlen2 = p->exact_len_n.n;   /* number of chars */\n      tlen2 *= tlen;\n      DATA_ENSURE(tlen2);\n      ps = p->exact_len_n.s;\n      while (tlen2-- > 0) {\n        if (*ps != *s) goto fail;\n        ps++; s++;\n      }\n      sprev = s - tlen;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(CCLASS)\n      DATA_ENSURE(1);\n      if (BITSET_AT(p->cclass.bsp, *s) == 0) goto fail;\n      s++;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MB)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;\n\n    cclass_mb:\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len;\n\n        DATA_ENSURE(1);\n        mb_len = enclen(encode, s);\n        DATA_ENSURE(mb_len);\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (! onig_is_in_code_range(p->cclass_mb.mb, code)) goto fail;\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MIX)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        goto cclass_mb;\n      }\n      else {\n        if (BITSET_AT(p->cclass_mix.bsp, *s) == 0)\n          goto fail;\n\n        s++;\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_NOT)\n      DATA_ENSURE(1);\n      if (BITSET_AT(p->cclass.bsp, *s) != 0) goto fail;\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MB_NOT)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) {\n        s++;\n        goto cc_mb_not_success;\n      }\n\n    cclass_mb_not:\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len = enclen(encode, s);\n\n        if (! DATA_ENSURE_CHECK(mb_len)) {\n          DATA_ENSURE(1);\n          s = (UChar* )end;\n          goto cc_mb_not_success;\n        }\n\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (onig_is_in_code_range(p->cclass_mb.mb, code)) goto fail;\n      }\n\n    cc_mb_not_success:\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MIX_NOT)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        goto cclass_mb_not;\n      }\n      else {\n        if (BITSET_AT(p->cclass_mix.bsp, *s) != 0)\n          goto fail;\n\n        s++;\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR)\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;\n      s += n;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR_ML)\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      s += n;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR_STAR)\n      INC_OP;\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      JUMP_OUT;\n\n    CASE_OP(ANYCHAR_ML_STAR)\n      INC_OP;\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      JUMP_OUT;\n\n    CASE_OP(ANYCHAR_STAR_PEEK_NEXT)\n      {\n        UChar c;\n\n        c = p->anychar_star_peek_next.c;\n        INC_OP;\n        while (DATA_ENSURE_CHECK1) {\n          if (c == *s) {\n            STACK_PUSH_ALT(p, s, sprev);\n          }\n          n = enclen(encode, s);\n          DATA_ENSURE(n);\n          if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n          sprev = s;\n          s += n;\n        }\n      }\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR_ML_STAR_PEEK_NEXT)\n      {\n        UChar c;\n\n        c = p->anychar_star_peek_next.c;\n        INC_OP;\n        while (DATA_ENSURE_CHECK1) {\n          if (c == *s) {\n            STACK_PUSH_ALT(p, s, sprev);\n          }\n          n = enclen(encode, s);\n          if (n > 1) {\n            DATA_ENSURE(n);\n            sprev = s;\n            s += n;\n          }\n          else {\n            sprev = s;\n            s++;\n          }\n        }\n      }\n      NEXT_OUT;\n\n    CASE_OP(WORD)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(WORD_ASCII)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD_ASCII(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(NO_WORD)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(NO_WORD_ASCII)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD_ASCII(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(WORD_BOUNDARY)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (ON_STR_BEGIN(s)) {\n          DATA_ENSURE(1);\n          if (! IS_MBC_WORD_ASCII_MODE(encode, s, end, mode))\n            goto fail;\n        }\n        else if (ON_STR_END(s)) {\n          if (! IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n        else {\n          if (IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)\n              == IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(NO_WORD_BOUNDARY)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (ON_STR_BEGIN(s)) {\n          if (DATA_ENSURE_CHECK1 && IS_MBC_WORD_ASCII_MODE(encode, s, end, mode))\n            goto fail;\n        }\n        else if (ON_STR_END(s)) {\n          if (IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n        else {\n          if (IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)\n              != IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_WORD_BEGIN_END\n    CASE_OP(WORD_BEGIN)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (DATA_ENSURE_CHECK1 && IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)) {\n          if (ON_STR_BEGIN(s) || !IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode)) {\n            INC_OP;\n            JUMP_OUT;\n          }\n        }\n      }\n      goto fail;\n\n    CASE_OP(WORD_END)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (!ON_STR_BEGIN(s) && IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode)) {\n          if (ON_STR_END(s) || ! IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)) {\n            INC_OP;\n            JUMP_OUT;\n          }\n        }\n      }\n      goto fail;\n#endif\n\n    CASE_OP(TEXT_SEGMENT_BOUNDARY)\n      {\n        int is_break;\n\n        switch (p->text_segment_boundary.type) {\n        case EXTENDED_GRAPHEME_CLUSTER_BOUNDARY:\n          is_break = onigenc_egcb_is_break_position(encode, s, sprev, str, end);\n          break;\n#ifdef USE_UNICODE_WORD_BREAK\n        case WORD_BOUNDARY:\n          is_break = onigenc_wb_is_break_position(encode, s, sprev, str, end);\n          break;\n#endif\n        default:\n          goto bytecode_error;\n          break;\n        }\n\n        if (p->text_segment_boundary.not != 0)\n          is_break = ! is_break;\n\n        if (is_break != 0) {\n          INC_OP;\n          JUMP_OUT;\n        }\n        else {\n          goto fail;\n        }\n      }\n\n    CASE_OP(BEGIN_BUF)\n      if (! ON_STR_BEGIN(s)) goto fail;\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(END_BUF)\n      if (! ON_STR_END(s)) goto fail;\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BEGIN_LINE)\n      if (ON_STR_BEGIN(s)) {\n        if (IS_NOTBOL(msa->options)) goto fail;\n        INC_OP;\n        JUMP_OUT;\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {\n        INC_OP;\n        JUMP_OUT;\n      }\n      goto fail;\n\n    CASE_OP(END_LINE)\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          INC_OP;\n          JUMP_OUT;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {\n        INC_OP;\n        JUMP_OUT;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        INC_OP;\n        JUMP_OUT;\n      }\n#endif\n      goto fail;\n\n    CASE_OP(SEMI_END_BUF)\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          INC_OP;\n          JUMP_OUT;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&\n               ON_STR_END(s + enclen(encode, s))) {\n        INC_OP;\n        JUMP_OUT;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        UChar* ss = s + enclen(encode, s);\n        ss += enclen(encode, ss);\n        if (ON_STR_END(ss)) {\n          INC_OP;\n          JUMP_OUT;\n        }\n      }\n#endif\n      goto fail;\n\n    CASE_OP(BEGIN_POSITION)\n      if (s != msa->start)\n        goto fail;\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_START_PUSH)\n      mem = p->memory_start.num;\n      STACK_PUSH_MEM_START(mem, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_START)\n      mem = p->memory_start.num;\n      mem_start_stk[mem] = (StackIndex )((void* )s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_END_PUSH)\n      mem = p->memory_end.num;\n      STACK_PUSH_MEM_END(mem, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_END)\n      mem = p->memory_end.num;\n      mem_end_stk[mem] = (StackIndex )((void* )s);\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_CALL\n    CASE_OP(MEMORY_END_PUSH_REC)\n      mem = p->memory_end.num;\n      STACK_GET_MEM_START(mem, stkp); /* should be before push mem-end. */\n      si = GET_STACK_INDEX(stkp);\n      STACK_PUSH_MEM_END(mem, s);\n      mem_start_stk[mem] = si;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_END_REC)\n      mem = p->memory_end.num;\n      mem_end_stk[mem] = (StackIndex )((void* )s);\n      STACK_GET_MEM_START(mem, stkp);\n\n      if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n        mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      else\n        mem_start_stk[mem] = (StackIndex )((void* )stkp->u.mem.pstr);\n\n      STACK_PUSH_MEM_END_MARK(mem);\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(BACKREF1)\n      mem = 1;\n      goto backref;\n\n    CASE_OP(BACKREF2)\n      mem = 2;\n      goto backref;\n\n    CASE_OP(BACKREF_N)\n      mem = p->backref_n.n1;\n    backref:\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = (int )(pend - pstart);\n        if (n != 0) {\n          DATA_ENSURE(n);\n          sprev = s;\n          STRING_CMP(s, pstart, n);\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BACKREF_N_IC)\n      mem = p->backref_n.n1;\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = (int )(pend - pstart);\n        if (n != 0) {\n          DATA_ENSURE(n);\n          sprev = s;\n          STRING_CMP_IC(case_fold_flag, pstart, &s, n);\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BACKREF_MULTI)\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        tlen = p->backref_general.num;\n        for (i = 0; i < tlen; i++) {\n          mem = tlen == 1 ? p->backref_general.n1 : p->backref_general.ns[i];\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = (int )(pend - pstart);\n          if (n != 0) {\n            DATA_ENSURE(n);\n            sprev = s;\n            swork = s;\n            STRING_CMP_VALUE(swork, pstart, n, is_fail);\n            if (is_fail) continue;\n            s = swork;\n            while (sprev + (len = enclen(encode, sprev)) < s)\n              sprev += len;\n          }\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BACKREF_MULTI_IC)\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        tlen = p->backref_general.num;\n        for (i = 0; i < tlen; i++) {\n          mem = tlen == 1 ? p->backref_general.n1 : p->backref_general.ns[i];\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = (int )(pend - pstart);\n          if (n != 0) {\n            DATA_ENSURE(n);\n            sprev = s;\n            swork = s;\n            STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);\n            if (is_fail) continue;\n            s = swork;\n            while (sprev + (len = enclen(encode, sprev)) < s)\n              sprev += len;\n          }\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    CASE_OP(BACKREF_WITH_LEVEL_IC)\n      n = 1; /* ignore case */\n      goto backref_with_level;\n    CASE_OP(BACKREF_WITH_LEVEL)\n      {\n        int len;\n        int level;\n        MemNumType* mems;\n        UChar* ssave;\n\n        n = 0;\n      backref_with_level:\n        level = p->backref_general.nest_level;\n        tlen  = p->backref_general.num;\n        mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;\n\n        ssave = s;\n        if (backref_match_at_nested_level(reg, stk, stk_base, n,\n                    case_fold_flag, level, (int )tlen, mems, &s, end)) {\n          if (ssave != s) {\n            sprev = ssave;\n            while (sprev + (len = enclen(encode, sprev)) < s)\n              sprev += len;\n          }\n        }\n        else\n          goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(BACKREF_CHECK)\n      {\n        MemNumType* mems;\n\n        tlen  = p->backref_general.num;\n        mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;\n\n        for (i = 0; i < tlen; i++) {\n          mem = mems[i];\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    CASE_OP(BACKREF_CHECK_WITH_LEVEL)\n      {\n        LengthType level;\n        MemNumType* mems;\n\n        level = p->backref_general.nest_level;\n        tlen  = p->backref_general.num;\n        mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;\n\n        if (backref_check_at_nested_level(reg, stk, stk_base,\n                                          (int )level, (int )tlen, mems) == 0)\n          goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(EMPTY_CHECK_START)\n      mem = p->empty_check_start.mem;   /* mem: null check id */\n      STACK_PUSH_EMPTY_CHECK_START(mem, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EMPTY_CHECK_END)\n      {\n        int is_empty;\n\n        mem = p->empty_check_end.mem;  /* mem: null check id */\n        STACK_EMPTY_CHECK(is_empty, mem, s);\n        INC_OP;\n        if (is_empty) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"EMPTY_CHECK_END: skip  id:%d, s:%p\\n\", (int )mem, s);\n#endif\n        empty_check_found:\n          /* empty loop founded, skip next instruction */\n#if defined(ONIG_DEBUG) && !defined(USE_DIRECT_THREADED_CODE)\n          switch (p->opcode) {\n          case OP_JUMP:\n          case OP_PUSH:\n          case OP_REPEAT_INC:\n          case OP_REPEAT_INC_NG:\n          case OP_REPEAT_INC_SG:\n          case OP_REPEAT_INC_NG_SG:\n            INC_OP;\n            break;\n          default:\n            goto unexpected_bytecode_error;\n            break;\n          }\n#else\n          INC_OP;\n#endif\n        }\n      }\n      JUMP_OUT;\n\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n    CASE_OP(EMPTY_CHECK_END_MEMST)\n      {\n        int is_empty;\n\n        mem = p->empty_check_end.mem;  /* mem: null check id */\n        STACK_EMPTY_CHECK_MEM(is_empty, mem, s, reg);\n        INC_OP;\n        if (is_empty) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"EMPTY_CHECK_END_MEM: skip  id:%d, s:%p\\n\", (int)mem, s);\n#endif\n          if (is_empty == -1) goto fail;\n          goto empty_check_found;\n        }\n      }\n      JUMP_OUT;\n#endif\n\n#ifdef USE_CALL\n    CASE_OP(EMPTY_CHECK_END_MEMST_PUSH)\n      {\n        int is_empty;\n\n        mem = p->empty_check_end.mem;  /* mem: null check id */\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n        STACK_EMPTY_CHECK_MEM_REC(is_empty, mem, s, reg);\n#else\n        STACK_EMPTY_CHECK_REC(is_empty, mem, s);\n#endif\n        INC_OP;\n        if (is_empty) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"EMPTY_CHECK_END_MEM_PUSH: skip  id:%d, s:%p\\n\",\n                  (int )mem, s);\n#endif\n          if (is_empty == -1) goto fail;\n          goto empty_check_found;\n        }\n        else {\n          STACK_PUSH_EMPTY_CHECK_END(mem);\n        }\n      }\n      JUMP_OUT;\n#endif\n\n    CASE_OP(JUMP)\n      addr = p->jump.addr;\n      p += addr;\n      CHECK_INTERRUPT_JUMP_OUT;\n\n    CASE_OP(PUSH)\n      addr = p->push.addr;\n      STACK_PUSH_ALT(p + addr, s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PUSH_SUPER)\n      addr = p->push.addr;\n      STACK_PUSH_SUPER_ALT(p + addr, s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(POP_OUT)\n      STACK_POP_ONE;\n      /* for stop backtrack */\n      /* CHECK_RETRY_LIMIT_IN_MATCH; */\n      INC_OP;\n      JUMP_OUT;\n\n #ifdef USE_OP_PUSH_OR_JUMP_EXACT\n    CASE_OP(PUSH_OR_JUMP_EXACT1)\n      {\n        UChar c;\n\n        addr = p->push_or_jump_exact1.addr;\n        c    = p->push_or_jump_exact1.c;\n        if (DATA_ENSURE_CHECK1 && c == *s) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n          INC_OP;\n          JUMP_OUT;\n        }\n      }\n      p += addr;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(PUSH_IF_PEEK_NEXT)\n      {\n        UChar c;\n\n        addr = p->push_if_peek_next.addr;\n        c    = p->push_if_peek_next.c;\n        if (c == *s) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n          INC_OP;\n          JUMP_OUT;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(REPEAT)\n      mem  = p->repeat.id;  /* mem: OP_REPEAT ID */\n      addr = p->repeat.addr;\n\n      STACK_ENSURE(1);\n      repeat_stk[mem] = GET_STACK_INDEX(stk);\n      STACK_PUSH_REPEAT(mem, p + 1);\n\n      if (reg->repeat_range[mem].lower == 0) {\n        STACK_PUSH_ALT(p + addr, s, sprev);\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(REPEAT_NG)\n      mem  = p->repeat.id;  /* mem: OP_REPEAT ID */\n      addr = p->repeat.addr;\n\n      STACK_ENSURE(1);\n      repeat_stk[mem] = GET_STACK_INDEX(stk);\n      STACK_PUSH_REPEAT(mem, p + 1);\n\n      if (reg->repeat_range[mem].lower == 0) {\n        STACK_PUSH_ALT(p + 1, s, sprev);\n        p += addr;\n      }\n      else\n        INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(REPEAT_INC)\n      mem  = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      si   = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {\n        /* end of repeat. Nothing to do. */\n        INC_OP;\n      }\n      else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n        INC_OP;\n        STACK_PUSH_ALT(p, s, sprev);\n        p = STACK_AT(si)->u.repeat.pcode; /* Don't use stkp after PUSH. */\n      }\n      else {\n        p = stkp->u.repeat.pcode;\n      }\n      STACK_PUSH_REPEAT_INC(si);\n      CHECK_INTERRUPT_JUMP_OUT;\n\n    CASE_OP(REPEAT_INC_SG)\n      mem = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc;\n\n    CASE_OP(REPEAT_INC_NG)\n      mem = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc_ng:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {\n        if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n          Operation* pcode = stkp->u.repeat.pcode;\n\n          STACK_PUSH_REPEAT_INC(si);\n          STACK_PUSH_ALT(pcode, s, sprev);\n          INC_OP;\n        }\n        else {\n          p = stkp->u.repeat.pcode;\n          STACK_PUSH_REPEAT_INC(si);\n        }\n      }\n      else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {\n        STACK_PUSH_REPEAT_INC(si);\n        INC_OP;\n      }\n      CHECK_INTERRUPT_JUMP_OUT;\n\n    CASE_OP(REPEAT_INC_NG_SG)\n      mem = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc_ng;\n\n    CASE_OP(PREC_READ_START)\n      STACK_PUSH_PREC_READ_START(s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PREC_READ_END)\n      STACK_GET_PREC_READ_START(stkp);\n      s     = stkp->u.state.pstr;\n      sprev = stkp->u.state.pstr_prev;\n      STACK_PUSH(STK_PREC_READ_END,0,0,0);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PREC_READ_NOT_START)\n      addr = p->prec_read_not_start.addr;\n      STACK_PUSH_ALT_PREC_READ_NOT(p + addr, s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PREC_READ_NOT_END)\n      STACK_POP_TIL_ALT_PREC_READ_NOT;\n      goto fail;\n\n    CASE_OP(ATOMIC_START)\n      STACK_PUSH_TO_VOID_START;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(ATOMIC_END)\n      STACK_EXEC_TO_VOID(stkp);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(LOOK_BEHIND)\n      tlen = p->look_behind.len;\n      s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(s)) goto fail;\n      sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(LOOK_BEHIND_NOT_START)\n      addr = p->look_behind_not_start.addr;\n      tlen = p->look_behind_not_start.len;\n      q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(q)) {\n        /* too short case -> success. ex. /(?<!XXX)a/.match(\"a\")\n           If you want to change to fail, replace following line. */\n        p += addr;\n        /* goto fail; */\n      }\n      else {\n        STACK_PUSH_ALT_LOOK_BEHIND_NOT(p + addr, s, sprev);\n        s = q;\n        sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n        INC_OP;\n      }\n      JUMP_OUT;\n\n    CASE_OP(LOOK_BEHIND_NOT_END)\n      STACK_POP_TIL_ALT_LOOK_BEHIND_NOT;\n      INC_OP;\n      goto fail;\n\n#ifdef USE_CALL\n    CASE_OP(CALL)\n      addr = p->call.addr;\n      INC_OP; STACK_PUSH_CALL_FRAME(p);\n      p = reg->ops + addr;\n      JUMP_OUT;\n\n    CASE_OP(RETURN)\n      STACK_RETURN(p);\n      STACK_PUSH_RETURN;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(PUSH_SAVE_VAL)\n      {\n        SaveType type;\n\n        type = p->push_save_val.type;\n        mem  = p->push_save_val.id; /* mem: save id */\n        switch ((enum SaveType )type) {\n        case SAVE_KEEP:\n          STACK_PUSH_SAVE_VAL(mem, type, s);\n          break;\n\n        case SAVE_S:\n          STACK_PUSH_SAVE_VAL_WITH_SPREV(mem, type, s);\n          break;\n\n        case SAVE_RIGHT_RANGE:\n          STACK_PUSH_SAVE_VAL(mem, SAVE_RIGHT_RANGE, right_range);\n          break;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(UPDATE_VAR)\n      {\n        UpdateVarType type;\n        enum SaveType save_type;\n\n        type = p->update_var.type;\n        mem  = p->update_var.id; /* mem: save id */\n\n        switch ((enum UpdateVarType )type) {\n        case UPDATE_VAR_KEEP_FROM_STACK_LAST:\n          STACK_GET_SAVE_VAL_TYPE_LAST(SAVE_KEEP, keep);\n          break;\n        case UPDATE_VAR_S_FROM_STACK:\n          STACK_GET_SAVE_VAL_TYPE_LAST_ID_WITH_SPREV(SAVE_S, mem, s);\n          break;\n        case UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK:\n          save_type = SAVE_S;\n          goto get_save_val_type_last_id;\n          break;\n        case UPDATE_VAR_RIGHT_RANGE_FROM_STACK:\n          save_type = SAVE_RIGHT_RANGE;\n        get_save_val_type_last_id:\n          STACK_GET_SAVE_VAL_TYPE_LAST_ID(save_type, mem, right_range);\n          break;\n        case UPDATE_VAR_RIGHT_RANGE_INIT:\n          INIT_RIGHT_RANGE;\n          break;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_CALLOUT\n    CASE_OP(CALLOUT_CONTENTS)\n      of = ONIG_CALLOUT_OF_CONTENTS;\n      mem = p->callout_contents.num;\n      goto callout_common_entry;\n      BREAK_OUT;\n\n    CASE_OP(CALLOUT_NAME)\n      {\n        int call_result;\n        int name_id;\n        int in;\n        CalloutListEntry* e;\n        OnigCalloutFunc func;\n        OnigCalloutArgs args;\n\n        of = ONIG_CALLOUT_OF_NAME;\n        name_id = p->callout_name.id;\n        mem     = p->callout_name.num;\n\n      callout_common_entry:\n        e = onig_reg_callout_list_at(reg, mem);\n        in = e->in;\n        if (of == ONIG_CALLOUT_OF_NAME) {\n          func = onig_get_callout_start_func(reg, mem);\n        }\n        else {\n          name_id = ONIG_NON_NAME_ID;\n          func = msa->mp->progress_callout_of_contents;\n        }\n\n        if (IS_NOT_NULL(func) && (in & ONIG_CALLOUT_IN_PROGRESS) != 0) {\n          CALLOUT_BODY(func, ONIG_CALLOUT_IN_PROGRESS, name_id,\n                       (int )mem, msa->mp->callout_user_data, args, call_result);\n          switch (call_result) {\n          case ONIG_CALLOUT_FAIL:\n            goto fail;\n            break;\n          case ONIG_CALLOUT_SUCCESS:\n            goto retraction_callout2;\n            break;\n          default: /* error code */\n            if (call_result > 0) {\n              call_result = ONIGERR_INVALID_ARGUMENT;\n            }\n            best_len = call_result;\n            goto finish;\n            break;\n          }\n        }\n        else {\n        retraction_callout2:\n          if ((in & ONIG_CALLOUT_IN_RETRACTION) != 0) {\n            if (of == ONIG_CALLOUT_OF_NAME) {\n              if (IS_NOT_NULL(func)) {\n                STACK_PUSH_CALLOUT_NAME(name_id, mem, func);\n              }\n            }\n            else {\n              func = msa->mp->retraction_callout_of_contents;\n              if (IS_NOT_NULL(func)) {\n                STACK_PUSH_CALLOUT_CONTENTS(mem, func);\n              }\n            }\n          }\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(FINISH)\n      goto finish;\n\n#ifdef ONIG_DEBUG_STATISTICS\n    fail:\n      SOP_OUT;\n      goto fail2;\n#endif\n    CASE_OP(FAIL)\n#ifdef ONIG_DEBUG_STATISTICS\n    fail2:\n#else\n    fail:\n#endif\n      STACK_POP;\n      p     = stk->u.state.pcode;\n      s     = stk->u.state.pstr;\n      sprev = stk->u.state.pstr_prev;\n      CHECK_RETRY_LIMIT_IN_MATCH;\n      JUMP_OUT;\n\n    DEFAULT_OP\n      goto bytecode_error;\n\n  } BYTECODE_INTERPRETER_END;\n\n finish:\n  STACK_SAVE;\n  return best_len;\n\n#ifdef ONIG_DEBUG\n stack_error:\n  STACK_SAVE;\n  return ONIGERR_STACK_BUG;\n#endif\n\n bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNDEFINED_BYTECODE;\n\n#if defined(ONIG_DEBUG) && !defined(USE_DIRECT_THREADED_CODE)\n unexpected_bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNEXPECTED_BYTECODE;\n#endif\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n retry_limit_in_match_over:\n  STACK_SAVE;\n  return ONIGERR_RETRY_LIMIT_IN_MATCH_OVER;\n#endif\n}\n\n\nstatic UChar*\nslow_search(OnigEncoding enc, UChar* target, UChar* target_end,\n            const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *t, *p, *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic int\nstr_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n                     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (*t++ != *q++) return 0;\n      lowlen--;\n    }\n  }\n\n  return 1;\n}\n\nstatic UChar*\nslow_search_ic(OnigEncoding enc, int case_fold_flag,\n               UChar* target, UChar* target_end,\n               const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n                             s, text_end))\n      return s;\n\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward(OnigEncoding enc, UChar* target, UChar* target_end,\n                     const UChar* text, const UChar* adjust_text,\n                     const UChar* text_end, const UChar* text_start)\n{\n  UChar *t, *p, *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward_ic(OnigEncoding enc, int case_fold_flag,\n                        UChar* target, UChar* target_end,\n                        const UChar* text, const UChar* adjust_text,\n                        const UChar* text_end, const UChar* text_start)\n{\n  UChar *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (str_lower_case_match(enc, case_fold_flag,\n                             target, target_end, s, text_end))\n      return s;\n\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\n\nstatic UChar*\nsunday_quick_search_step_forward(regex_t* reg,\n                                 const UChar* target, const UChar* target_end,\n                                 const UChar* text, const UChar* text_end,\n                                 const UChar* text_range)\n{\n  const UChar *s, *se, *t, *p, *end;\n  const UChar *tail;\n  int skip, tlen1;\n  int map_offset;\n  OnigEncoding enc;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n          \"sunday_quick_search_step_forward: text: %p, text_end: %p, text_range: %p\\n\", text, text_end, text_range);\n#endif\n\n  enc = reg->enc;\n\n  tail = target_end - 1;\n  tlen1 = (int )(tail - target);\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  map_offset = reg->map_offset;\n  s = text;\n\n  while (s < end) {\n    p = se = s + tlen1;\n    t = tail;\n    while (*p == *t) {\n      if (t == target) return (UChar* )s;\n      p--; t--;\n    }\n    if (se + map_offset >= text_end) break;\n    skip = reg->map[*(se + map_offset)];\n#if 0\n    t = s;\n    do {\n      s += enclen(enc, s);\n    } while ((s - t) < skip && s < end);\n#else\n    s += skip;\n    if (s < end)\n      s = onigenc_get_right_adjust_char_head(enc, text, s);\n#endif\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nsunday_quick_search(regex_t* reg, const UChar* target, const UChar* target_end,\n                    const UChar* text, const UChar* text_end,\n                    const UChar* text_range)\n{\n  const UChar *s, *t, *p, *end;\n  const UChar *tail;\n  int map_offset;\n\n  end = text_range + (target_end - target);\n  if (end > text_end)\n    end = text_end;\n\n  map_offset = reg->map_offset;\n  tail = target_end - 1;\n  s = text + (tail - target);\n\n  while (s < end) {\n    p = s;\n    t = tail;\n    while (*p == *t) {\n      if (t == target) return (UChar* )p;\n      p--; t--;\n    }\n    if (s + map_offset >= text_end) break;\n    s += reg->map[*(s + map_offset)];\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nsunday_quick_search_case_fold(regex_t* reg,\n                              const UChar* target, const UChar* target_end,\n                              const UChar* text,   const UChar* text_end,\n                              const UChar* text_range)\n{\n  const UChar *s, *se, *end;\n  const UChar *tail;\n  int skip, tlen1;\n  int map_offset;\n  int case_fold_flag;\n  OnigEncoding enc;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n          \"sunday_quick_search_case_fold: text: %p, text_end: %p, text_range: %p\\n\", text, text_end, text_range);\n#endif\n\n  enc = reg->enc;\n  case_fold_flag = reg->case_fold_flag;\n\n  tail = target_end - 1;\n  tlen1 = (int )(tail - target);\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  map_offset = reg->map_offset;\n  s = text;\n\n  while (s < end) {\n    if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n                             s, text_end))\n      return (UChar* )s;\n\n    se = s + tlen1;\n    if (se + map_offset >= text_end) break;\n    skip = reg->map[*(se + map_offset)];\n#if 0\n    p = s;\n    do {\n      s += enclen(enc, s);\n    } while ((s - p) < skip && s < end);\n#else\n    /* This is faster than prev code for long text.  ex: /(?i)Twain/  */\n    s += skip;\n    if (s < end)\n      s = onigenc_get_right_adjust_char_head(enc, text, s);\n#endif\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nmap_search(OnigEncoding enc, UChar map[],\n           const UChar* text, const UChar* text_range)\n{\n  const UChar *s = text;\n\n  while (s < text_range) {\n    if (map[*s]) return (UChar* )s;\n\n    s += enclen(enc, s);\n  }\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nmap_search_backward(OnigEncoding enc, UChar map[],\n                    const UChar* text, const UChar* adjust_text,\n                    const UChar* text_start)\n{\n  const UChar *s = text_start;\n\n  while (s >= text) {\n    if (map[*s]) return (UChar* )s;\n\n    s = onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n  return (UChar* )NULL;\n}\nextern int\nonig_match(regex_t* reg, const UChar* str, const UChar* end, const UChar* at,\n           OnigRegion* region, OnigOptionType option)\n{\n  int r;\n  OnigMatchParam mp;\n\n  onig_initialize_match_param(&mp);\n  r = onig_match_with_param(reg, str, end, at, region, option, &mp);\n  onig_free_match_param_content(&mp);\n  return r;\n}\n\nextern int\nonig_match_with_param(regex_t* reg, const UChar* str, const UChar* end,\n                      const UChar* at, OnigRegion* region, OnigOptionType option,\n                      OnigMatchParam* mp)\n{\n  int r;\n  UChar *prev;\n  MatchArg msa;\n\n  ADJUST_MATCH_PARAM(reg, mp);\n  MATCH_ARG_INIT(msa, reg, option, region, at, mp);\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n  }\n  else\n    r = 0;\n\n  if (r == 0) {\n    if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n      if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n        r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n        goto end;\n      }\n    }\n\n    prev = (UChar* )onigenc_get_prev_char_head(reg->enc, str, at);\n    r = match_at(reg, str, end, end, at, prev, &msa);\n  }\n\n end:\n  MATCH_ARG_FREE(msa);\n  return r;\n}\n\nstatic int\nforward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n                     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %p, end: %p, s: %p, range: %p\\n\",\n          str, end, s, range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case OPTIMIZE_STR:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case OPTIMIZE_STR_CASE_FOLD:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case OPTIMIZE_STR_CASE_FOLD_FAST:\n    p = sunday_quick_search_case_fold(reg, reg->exact, reg->exact_end, p, end,\n                                      range);\n    break;\n\n  case OPTIMIZE_STR_FAST:\n    p = sunday_quick_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case OPTIMIZE_STR_FAST_STEP_FORWARD:\n    p = sunday_quick_search_step_forward(reg, reg->exact, reg->exact_end,\n                                         p, end, range);\n    break;\n\n  case OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != INFINITE_LEN) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n        }\n        else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n            \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n            (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}\n\n\nstatic int\nbackward_search_range(regex_t* reg, const UChar* str, const UChar* end,\n                      UChar* s, const UChar* range, UChar* adjrange,\n                      UChar** low, UChar** high)\n{\n  UChar *p;\n\n  if (range == 0) goto fail;\n\n  range += reg->dmin;\n  p = s;\n\n retry:\n  switch (reg->optimize) {\n  case OPTIMIZE_STR:\n  exact_method:\n    p = slow_search_backward(reg->enc, reg->exact, reg->exact_end,\n                             range, adjrange, end, p);\n    break;\n\n  case OPTIMIZE_STR_CASE_FOLD:\n  case OPTIMIZE_STR_CASE_FOLD_FAST:\n    p = slow_search_backward_ic(reg->enc, reg->case_fold_flag,\n                                reg->exact, reg->exact_end,\n                                range, adjrange, end, p);\n    break;\n\n  case OPTIMIZE_STR_FAST:\n  case OPTIMIZE_STR_FAST_STEP_FORWARD:\n    goto exact_method;\n    break;\n\n  case OPTIMIZE_MAP:\n    p = map_search_backward(reg->enc, reg->map, range, adjrange, p);\n    break;\n  }\n\n  if (p) {\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc, str, p);\n          if (IS_NOT_NULL(prev) && !ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n        }\n        break;\n\n      case ANCR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(prev)) goto fail;\n          if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 ) {\n          p = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(p)) goto fail;\n          goto retry;\n        }\n        break;\n      }\n    }\n\n    /* no needs to adjust *high, *high is used as range check only */\n    if (reg->dmax != INFINITE_LEN) {\n      *low  = p - reg->dmax;\n      *high = p - reg->dmin;\n      *high = onigenc_get_right_adjust_char_head(reg->enc, adjrange, *high);\n    }\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"backward_search_range: low: %d, high: %d\\n\",\n            (int )(*low - str), (int )(*high - str));\n#endif\n    return 1; /* success */\n  }\n\n fail:\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"backward_search_range: fail.\\n\");\n#endif\n  return 0; /* fail */\n}\n\n\nextern int\nonig_search(regex_t* reg, const UChar* str, const UChar* end,\n            const UChar* start, const UChar* range, OnigRegion* region,\n            OnigOptionType option)\n{\n  int r;\n  OnigMatchParam mp;\n\n  onig_initialize_match_param(&mp);\n  r = onig_search_with_param(reg, str, end, start, range, region, option, &mp);\n  onig_free_match_param_content(&mp);\n  return r;\n\n}\n\nextern int\nonig_search_with_param(regex_t* reg, const UChar* str, const UChar* end,\n                       const UChar* start, const UChar* range, OnigRegion* region,\n                       OnigOptionType option, OnigMatchParam* mp)\n{\n  int r;\n  UChar *s, *prev;\n  MatchArg msa;\n  const UChar *orig_start = start;\n  const UChar *orig_range = range;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n     \"onig_search (entry point): str: %p, end: %d, start: %d, range: %d\\n\",\n     str, (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  ADJUST_MATCH_PARAM(reg, mp);\n\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n    if (r != 0) goto finish_no_msa;\n  }\n\n  if (start > end || start < str) goto mismatch_no_msa;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n      r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n      goto finish_no_msa;\n    }\n  }\n\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      if (! IS_FIND_LONGEST(reg->options)) {\\\n        goto match;\\\n      }\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#else\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      goto match;\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#endif /* USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE */\n\n\n  /* anchor optimize: resume search range */\n  if (reg->anchor != 0 && str < end) {\n    UChar *min_semi_end, *max_semi_end;\n\n    if (reg->anchor & ANCR_BEGIN_POSITION) {\n      /* search start-position only */\n    begin_position:\n      if (range > start)\n        range = start + 1;\n      else\n        range = start;\n    }\n    else if (reg->anchor & ANCR_BEGIN_BUF) {\n      /* search str-position only */\n      if (range > start) {\n        if (start != str) goto mismatch_no_msa;\n        range = str + 1;\n      }\n      else {\n        if (range <= str) {\n          start = str;\n          range = str;\n        }\n        else\n          goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCR_END_BUF) {\n      min_semi_end = max_semi_end = (UChar* )end;\n\n    end_buf:\n      if ((OnigLen )(max_semi_end - str) < reg->anchor_dmin)\n        goto mismatch_no_msa;\n\n      if (range > start) {\n        if ((OnigLen )(min_semi_end - start) > reg->anchor_dmax) {\n          start = min_semi_end - reg->anchor_dmax;\n          if (start < end)\n            start = onigenc_get_right_adjust_char_head(reg->enc, str, start);\n        }\n        if ((OnigLen )(max_semi_end - (range - 1)) < reg->anchor_dmin) {\n          range = max_semi_end - reg->anchor_dmin + 1;\n        }\n\n        if (start > range) goto mismatch_no_msa;\n        /* If start == range, match with empty at end.\n           Backward search is used. */\n      }\n      else {\n        if ((OnigLen )(min_semi_end - range) > reg->anchor_dmax) {\n          range = min_semi_end - reg->anchor_dmax;\n        }\n        if ((OnigLen )(max_semi_end - start) < reg->anchor_dmin) {\n          start = max_semi_end - reg->anchor_dmin;\n          start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start);\n        }\n        if (range > start) goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCR_SEMI_END_BUF) {\n      UChar* pre_end = ONIGENC_STEP_BACK(reg->enc, str, end, 1);\n\n      max_semi_end = (UChar* )end;\n      if (ONIGENC_IS_MBC_NEWLINE(reg->enc, pre_end, end)) {\n        min_semi_end = pre_end;\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n        pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, 1);\n        if (IS_NOT_NULL(pre_end) &&\n            ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {\n          min_semi_end = pre_end;\n        }\n#endif\n        if (min_semi_end > str && start <= min_semi_end) {\n          goto end_buf;\n        }\n      }\n      else {\n        min_semi_end = (UChar* )end;\n        goto end_buf;\n      }\n    }\n    else if ((reg->anchor & ANCR_ANYCHAR_INF_ML)) {\n      goto begin_position;\n    }\n  }\n  else if (str == end) { /* empty string */\n    static const UChar* address_for_empty_string = (UChar* )\"\";\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"onig_search: empty string.\\n\");\n#endif\n\n    if (reg->threshold_len == 0) {\n      start = end = str = address_for_empty_string;\n      s = (UChar* )start;\n      prev = (UChar* )NULL;\n\n      MATCH_ARG_INIT(msa, reg, option, region, start, mp);\n      MATCH_AND_RETURN_CHECK(end);\n      goto mismatch;\n    }\n    goto mismatch_no_msa;\n  }\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"onig_search(apply anchor): end: %d, start: %d, range: %d\\n\",\n          (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  MATCH_ARG_INIT(msa, reg, option, region, orig_start, mp);\n\n  s = (UChar* )start;\n  if (range > start) {   /* forward search */\n    if (s > str)\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n    else\n      prev = (UChar* )NULL;\n\n    if (reg->optimize != OPTIMIZE_NONE) {\n      UChar *sch_range, *low, *high, *low_prev;\n\n      sch_range = (UChar* )range;\n      if (reg->dmax != 0) {\n        if (reg->dmax == INFINITE_LEN)\n          sch_range = (UChar* )end;\n        else {\n          sch_range += reg->dmax;\n          if (sch_range > end) sch_range = (UChar* )end;\n        }\n      }\n\n      if ((end - start) < reg->threshold_len)\n        goto mismatch;\n\n      if (reg->dmax != INFINITE_LEN) {\n        do {\n          if (! forward_search_range(reg, str, end, s, sch_range,\n                                     &low, &high, &low_prev)) goto mismatch;\n          if (s < low) {\n            s    = low;\n            prev = low_prev;\n          }\n          while (s <= high) {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n          }\n        } while (s < range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if (! forward_search_range(reg, str, end, s, sch_range,\n                                   &low, &high, (UChar** )NULL)) goto mismatch;\n\n        if ((reg->anchor & ANCR_ANYCHAR_INF) != 0) {\n          do {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n\n            if ((reg->anchor & (ANCR_LOOK_BEHIND | ANCR_PREC_READ_NOT)) == 0) {\n              while (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end) && s < range) {\n                prev = s;\n                s += enclen(reg->enc, s);\n              }\n            }\n          } while (s < range);\n          goto mismatch;\n        }\n      }\n    }\n\n    do {\n      MATCH_AND_RETURN_CHECK(orig_range);\n      prev = s;\n      s += enclen(reg->enc, s);\n    } while (s < range);\n\n    if (s == range) { /* because empty match with /$/. */\n      MATCH_AND_RETURN_CHECK(orig_range);\n    }\n  }\n  else {  /* backward search */\n    if (range < str) goto mismatch;\n\n    if (orig_start < end)\n      orig_start += enclen(reg->enc, orig_start); /* is upper range */\n\n    if (reg->optimize != OPTIMIZE_NONE) {\n      UChar *low, *high, *adjrange, *sch_start;\n\n      if (range < end)\n        adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range);\n      else\n        adjrange = (UChar* )end;\n\n      if (reg->dmax != INFINITE_LEN &&\n          (end - range) >= reg->threshold_len) {\n        do {\n          sch_start = s + reg->dmax;\n          if (sch_start > end) sch_start = (UChar* )end;\n          if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                    &low, &high) <= 0)\n            goto mismatch;\n\n          if (s > high)\n            s = high;\n\n          while (s >= low) {\n            prev = onigenc_get_prev_char_head(reg->enc, str, s);\n            MATCH_AND_RETURN_CHECK(orig_start);\n            s = prev;\n          }\n        } while (s >= range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if ((end - range) < reg->threshold_len) goto mismatch;\n\n        sch_start = s;\n        if (reg->dmax != 0) {\n          if (reg->dmax == INFINITE_LEN)\n            sch_start = (UChar* )end;\n          else {\n            sch_start += reg->dmax;\n            if (sch_start > end) sch_start = (UChar* )end;\n            else\n              sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,\n                                                        start, sch_start);\n          }\n        }\n        if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                  &low, &high) <= 0) goto mismatch;\n      }\n    }\n\n    do {\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n      MATCH_AND_RETURN_CHECK(orig_start);\n      s = prev;\n    } while (s >= range);\n  }\n\n mismatch:\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n  if (IS_FIND_LONGEST(reg->options)) {\n    if (msa.best_len >= 0) {\n      s = msa.best_s;\n      goto match;\n    }\n  }\n#endif\n  r = ONIG_MISMATCH;\n\n finish:\n  MATCH_ARG_FREE(msa);\n\n  /* If result is mismatch and no FIND_NOT_EMPTY option,\n     then the region is not set in match_at(). */\n  if (IS_FIND_NOT_EMPTY(reg->options) && region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    onig_region_clear(region);\n  }\n\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n mismatch_no_msa:\n  r = ONIG_MISMATCH;\n finish_no_msa:\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n match:\n  MATCH_ARG_FREE(msa);\n  return (int )(s - str);\n}\n\nextern int\nonig_scan(regex_t* reg, const UChar* str, const UChar* end,\n          OnigRegion* region, OnigOptionType option,\n          int (*scan_callback)(int, int, OnigRegion*, void*),\n          void* callback_arg)\n{\n  int r;\n  int n;\n  int rs;\n  const UChar* start;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end))\n      return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n    ONIG_OPTION_OFF(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING);\n  }\n\n  n = 0;\n  start = str;\n  while (1) {\n    r = onig_search(reg, str, end, start, end, region, option);\n    if (r >= 0) {\n      rs = scan_callback(n, r, region, callback_arg);\n      n++;\n      if (rs != 0)\n        return rs;\n\n      if (region->end[0] == start - str) {\n        if (start >= end) break;\n        start += enclen(reg->enc, start);\n      }\n      else\n        start = str + region->end[0];\n\n      if (start > end)\n        break;\n    }\n    else if (r == ONIG_MISMATCH) {\n      break;\n    }\n    else { /* error */\n      return r;\n    }\n  }\n\n  return n;\n}\n\nextern OnigEncoding\nonig_get_encoding(regex_t* reg)\n{\n  return reg->enc;\n}\n\nextern OnigOptionType\nonig_get_options(regex_t* reg)\n{\n  return reg->options;\n}\n\nextern  OnigCaseFoldType\nonig_get_case_fold_flag(regex_t* reg)\n{\n  return reg->case_fold_flag;\n}\n\nextern OnigSyntaxType*\nonig_get_syntax(regex_t* reg)\n{\n  return reg->syntax;\n}\n\nextern int\nonig_number_of_captures(regex_t* reg)\n{\n  return reg->num_mem;\n}\n\nextern int\nonig_number_of_capture_histories(regex_t* reg)\n{\n#ifdef USE_CAPTURE_HISTORY\n  int i, n;\n\n  n = 0;\n  for (i = 0; i <= ONIG_MAX_CAPTURE_HISTORY_GROUP; i++) {\n    if (MEM_STATUS_AT(reg->capture_history, i) != 0)\n      n++;\n  }\n  return n;\n#else\n  return 0;\n#endif\n}\n\nextern void\nonig_copy_encoding(OnigEncoding to, OnigEncoding from)\n{\n  *to = *from;\n}\n\n#ifdef USE_DIRECT_THREADED_CODE\nextern int\nonig_init_for_match_at(regex_t* reg)\n{\n  return match_at(reg, (const UChar* )NULL, (const UChar* )NULL,\n                  (const UChar* )NULL, (const UChar* )NULL, (UChar* )NULL,\n                  (MatchArg* )NULL);\n}\n#endif\n\n\n/* for callout functions */\n\n#ifdef USE_CALLOUT\n\nextern OnigCalloutFunc\nonig_get_progress_callout(void)\n{\n  return DefaultProgressCallout;\n}\n\nextern int\nonig_set_progress_callout(OnigCalloutFunc f)\n{\n  DefaultProgressCallout = f;\n  return ONIG_NORMAL;\n}\n\nextern OnigCalloutFunc\nonig_get_retraction_callout(void)\n{\n  return DefaultRetractionCallout;\n}\n\nextern int\nonig_set_retraction_callout(OnigCalloutFunc f)\n{\n  DefaultRetractionCallout = f;\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_get_callout_num_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->num;\n}\n\nextern OnigCalloutIn\nonig_get_callout_in_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->in;\n}\n\nextern int\nonig_get_name_id_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->name_id;\n}\n\nextern const UChar*\nonig_get_contents_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return 0;\n  if (e->of == ONIG_CALLOUT_OF_CONTENTS) {\n    return e->u.content.start;\n  }\n\n  return 0;\n}\n\nextern const UChar*\nonig_get_contents_end_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return 0;\n  if (e->of == ONIG_CALLOUT_OF_CONTENTS) {\n    return e->u.content.end;\n  }\n\n  return 0;\n}\n\nextern int\nonig_get_args_num_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return ONIGERR_INVALID_ARGUMENT;\n  if (e->of == ONIG_CALLOUT_OF_NAME) {\n    return e->u.arg.num;\n  }\n\n  return ONIGERR_INVALID_ARGUMENT;\n}\n\nextern int\nonig_get_passed_args_num_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return ONIGERR_INVALID_ARGUMENT;\n  if (e->of == ONIG_CALLOUT_OF_NAME) {\n    return e->u.arg.passed_num;\n  }\n\n  return ONIGERR_INVALID_ARGUMENT;\n}\n\nextern int\nonig_get_arg_by_callout_args(OnigCalloutArgs* args, int index,\n                             OnigType* type, OnigValue* val)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return ONIGERR_INVALID_ARGUMENT;\n  if (e->of == ONIG_CALLOUT_OF_NAME) {\n    if (IS_NOT_NULL(type)) *type = e->u.arg.types[index];\n    if (IS_NOT_NULL(val))  *val  = e->u.arg.vals[index];\n    return ONIG_NORMAL;\n  }\n\n  return ONIGERR_INVALID_ARGUMENT;\n}\n\nextern const UChar*\nonig_get_string_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->string;\n}\n\nextern const UChar*\nonig_get_string_end_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->string_end;\n}\n\nextern const UChar*\nonig_get_start_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->start;\n}\n\nextern const UChar*\nonig_get_right_range_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->right_range;\n}\n\nextern const UChar*\nonig_get_current_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->current;\n}\n\nextern OnigRegex\nonig_get_regex_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->regex;\n}\n\nextern unsigned long\nonig_get_retry_counter_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->retry_in_match_counter;\n}\n\n\nextern int\nonig_get_capture_range_in_callout(OnigCalloutArgs* a, int mem_num, int* begin, int* end)\n{\n  OnigRegex    reg;\n  const UChar* str;\n  StackType*   stk_base;\n  int i;\n\n  i = mem_num;\n  reg = a->regex;\n  str = a->string;\n  stk_base = a->stk_base;\n\n  if (i > 0) {\n    if (a->mem_end_stk[i] != INVALID_STACK_INDEX) {\n      if (MEM_STATUS_AT(reg->bt_mem_start, i))\n        *begin = (int )(STACK_AT(a->mem_start_stk[i])->u.mem.pstr - str);\n      else\n        *begin = (int )((UChar* )((void* )a->mem_start_stk[i]) - str);\n\n      *end = (int )((MEM_STATUS_AT(reg->bt_mem_end, i)\n                     ? STACK_AT(a->mem_end_stk[i])->u.mem.pstr\n                     : (UChar* )((void* )a->mem_end_stk[i])) - str);\n    }\n    else {\n      *begin = *end = ONIG_REGION_NOTPOS;\n    }\n  }\n  else\n    return ONIGERR_INVALID_ARGUMENT;\n\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_get_used_stack_size_in_callout(OnigCalloutArgs* a, int* used_num, int* used_bytes)\n{\n  int n;\n\n  n = (int )(a->stk - a->stk_base);\n\n  if (used_num != 0)\n    *used_num = n;\n\n  if (used_bytes != 0)\n    *used_bytes = n * sizeof(StackType);\n\n  return ONIG_NORMAL;\n}\n\n\n/* builtin callout functions */\n\nextern int\nonig_builtin_fail(OnigCalloutArgs* args ARG_UNUSED, void* user_data ARG_UNUSED)\n{\n  return ONIG_CALLOUT_FAIL;\n}\n\nextern int\nonig_builtin_mismatch(OnigCalloutArgs* args ARG_UNUSED, void* user_data ARG_UNUSED)\n{\n  return ONIG_MISMATCH;\n}\n\nextern int\nonig_builtin_error(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int n;\n  OnigValue val;\n\n  r = onig_get_arg_by_callout_args(args, 0, 0, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  n = (int )val.l;\n  if (n >= 0) {\n    n = ONIGERR_INVALID_CALLOUT_BODY;\n  }\n  else if (onig_is_error_code_needs_param(n)) {\n    n = ONIGERR_INVALID_CALLOUT_BODY;\n  }\n\n  return n;\n}\n\nextern int\nonig_builtin_count(OnigCalloutArgs* args, void* user_data)\n{\n  (void )onig_check_callout_data_and_clear_old_values(args);\n\n  return onig_builtin_total_count(args, user_data);\n}\n\nextern int\nonig_builtin_total_count(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int slot;\n  OnigType  type;\n  OnigValue val;\n  OnigValue aval;\n  OnigCodePoint count_type;\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &aval);\n  if (r != ONIG_NORMAL) return r;\n\n  count_type = aval.c;\n  if (count_type != '>' && count_type != 'X' && count_type != '<')\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  r = onig_get_callout_data_by_callout_args_self_dont_clear_old(args, 0,\n                                                                &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    /* type == void: initial state */\n    val.l = 0;\n  }\n\n  if (args->in == ONIG_CALLOUT_IN_RETRACTION) {\n    slot = 2;\n    if (count_type == '<')\n      val.l++;\n    else if (count_type == 'X')\n      val.l--;\n  }\n  else {\n    slot = 1;\n    if (count_type != '<')\n      val.l++;\n  }\n\n  r = onig_set_callout_data_by_callout_args_self(args, 0, ONIG_TYPE_LONG, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  /* slot 1: in progress counter, slot 2: in retraction counter */\n  r = onig_get_callout_data_by_callout_args_self_dont_clear_old(args, slot,\n                                                                &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    val.l = 0;\n  }\n\n  val.l++;\n  r = onig_set_callout_data_by_callout_args_self(args, slot, ONIG_TYPE_LONG, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  return ONIG_CALLOUT_SUCCESS;\n}\n\nextern int\nonig_builtin_max(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int slot;\n  long max_val;\n  OnigCodePoint count_type;\n  OnigType  type;\n  OnigValue val;\n  OnigValue aval;\n\n  (void )onig_check_callout_data_and_clear_old_values(args);\n\n  slot = 0;\n  r = onig_get_callout_data_by_callout_args_self(args, slot, &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    /* type == void: initial state */\n    type  = ONIG_TYPE_LONG;\n    val.l = 0;\n  }\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &aval);\n  if (r != ONIG_NORMAL) return r;\n  if (type == ONIG_TYPE_TAG) {\n    r = onig_get_callout_data_by_callout_args(args, aval.tag, 0, &type, &aval);\n    if (r < ONIG_NORMAL) return r;\n    else if (r > ONIG_NORMAL)\n      max_val = 0L;\n    else\n      max_val = aval.l;\n  }\n  else { /* LONG */\n    max_val = aval.l;\n  }\n\n  r = onig_get_arg_by_callout_args(args, 1, &type, &aval);\n  if (r != ONIG_NORMAL) return r;\n\n  count_type = aval.c;\n  if (count_type != '>' && count_type != 'X' && count_type != '<')\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (args->in == ONIG_CALLOUT_IN_RETRACTION) {\n    if (count_type == '<') {\n      if (val.l >= max_val) return ONIG_CALLOUT_FAIL;\n      val.l++;\n    }\n    else if (count_type == 'X')\n      val.l--;\n  }\n  else {\n    if (count_type != '<') {\n      if (val.l >= max_val) return ONIG_CALLOUT_FAIL;\n      val.l++;\n    }\n  }\n\n  r = onig_set_callout_data_by_callout_args_self(args, slot, ONIG_TYPE_LONG, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  return ONIG_CALLOUT_SUCCESS;\n}\n\nenum OP_CMP {\n  OP_EQ,\n  OP_NE,\n  OP_LT,\n  OP_GT,\n  OP_LE,\n  OP_GE\n};\n\nextern int\nonig_builtin_cmp(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int slot;\n  long lv;\n  long rv;\n  OnigType  type;\n  OnigValue val;\n  regex_t* reg;\n  enum OP_CMP op;\n\n  reg = args->regex;\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  if (type == ONIG_TYPE_TAG) {\n    r = onig_get_callout_data_by_callout_args(args, val.tag, 0, &type, &val);\n    if (r < ONIG_NORMAL) return r;\n    else if (r > ONIG_NORMAL)\n      lv = 0L;\n    else\n      lv = val.l;\n  }\n  else { /* ONIG_TYPE_LONG */\n    lv = val.l;\n  }\n\n  r = onig_get_arg_by_callout_args(args, 2, &type, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  if (type == ONIG_TYPE_TAG) {\n    r = onig_get_callout_data_by_callout_args(args, val.tag, 0, &type, &val);\n    if (r < ONIG_NORMAL) return r;\n    else if (r > ONIG_NORMAL)\n      rv = 0L;\n    else\n      rv = val.l;\n  }\n  else { /* ONIG_TYPE_LONG */\n    rv = val.l;\n  }\n\n  slot = 0;\n  r = onig_get_callout_data_by_callout_args_self(args, slot, &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    /* type == void: initial state */\n    OnigCodePoint c1, c2;\n    UChar* p;\n\n    r = onig_get_arg_by_callout_args(args, 1, &type, &val);\n    if (r != ONIG_NORMAL) return r;\n\n    p = val.s.start;\n    c1 = ONIGENC_MBC_TO_CODE(reg->enc, p, val.s.end);\n    p += ONIGENC_MBC_ENC_LEN(reg->enc, p);\n    if (p < val.s.end) {\n      c2 = ONIGENC_MBC_TO_CODE(reg->enc, p, val.s.end);\n      p += ONIGENC_MBC_ENC_LEN(reg->enc, p);\n      if (p != val.s.end)  return ONIGERR_INVALID_CALLOUT_ARG;\n    }\n    else\n      c2 = 0;\n\n    switch (c1) {\n    case '=':\n      if (c2 != '=') return ONIGERR_INVALID_CALLOUT_ARG;\n      op = OP_EQ;\n      break;\n    case '!':\n      if (c2 != '=') return ONIGERR_INVALID_CALLOUT_ARG;\n      op = OP_NE;\n      break;\n    case '<':\n      if (c2 == '=') op = OP_LE;\n      else if (c2 == 0) op = OP_LT;\n      else  return ONIGERR_INVALID_CALLOUT_ARG;\n      break;\n    case '>':\n      if (c2 == '=') op = OP_GE;\n      else if (c2 == 0) op = OP_GT;\n      else  return ONIGERR_INVALID_CALLOUT_ARG;\n      break;\n    default:\n      return ONIGERR_INVALID_CALLOUT_ARG;\n      break;\n    }\n    val.l = (long )op;\n    r = onig_set_callout_data_by_callout_args_self(args, slot, ONIG_TYPE_LONG, &val);\n    if (r != ONIG_NORMAL) return r;\n  }\n  else {\n    op = (enum OP_CMP )val.l;\n  }\n\n  switch (op) {\n  case OP_EQ: r = (lv == rv); break;\n  case OP_NE: r = (lv != rv); break;\n  case OP_LT: r = (lv <  rv); break;\n  case OP_GT: r = (lv >  rv); break;\n  case OP_LE: r = (lv <= rv); break;\n  case OP_GE: r = (lv >= rv); break;\n  }\n\n  return r == 0 ? ONIG_CALLOUT_FAIL : ONIG_CALLOUT_SUCCESS;\n}\n\n\n#include <stdio.h>\n\nstatic FILE* OutFp;\n\n/* name start with \"onig_\" for macros. */\nstatic int\nonig_builtin_monitor(OnigCalloutArgs* args, void* user_data)\n{\n  int r;\n  int num;\n  size_t tag_len;\n  const UChar* start;\n  const UChar* right;\n  const UChar* current;\n  const UChar* string;\n  const UChar* strend;\n  const UChar* tag_start;\n  const UChar* tag_end;\n  regex_t* reg;\n  OnigCalloutIn in;\n  OnigType type;\n  OnigValue val;\n  char buf[20];\n  FILE* fp;\n\n  fp = OutFp;\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  in = onig_get_callout_in_by_callout_args(args);\n  if (in == ONIG_CALLOUT_IN_PROGRESS) {\n    if (val.c == '<')\n      return ONIG_CALLOUT_SUCCESS;\n  }\n  else {\n    if (val.c != 'X' && val.c != '<')\n      return ONIG_CALLOUT_SUCCESS;\n  }\n\n  num       = onig_get_callout_num_by_callout_args(args);\n  start     = onig_get_start_by_callout_args(args);\n  right     = onig_get_right_range_by_callout_args(args);\n  current   = onig_get_current_by_callout_args(args);\n  string    = onig_get_string_by_callout_args(args);\n  strend    = onig_get_string_end_by_callout_args(args);\n  reg       = onig_get_regex_by_callout_args(args);\n  tag_start = onig_get_callout_tag_start(reg, num);\n  tag_end   = onig_get_callout_tag_end(reg, num);\n\n  if (tag_start == 0)\n    xsnprintf(buf, sizeof(buf), \"#%d\", num);\n  else {\n    /* CAUTION: tag string is not terminated with NULL. */\n    int i;\n\n    tag_len = tag_end - tag_start;\n    if (tag_len >= sizeof(buf)) tag_len = sizeof(buf) - 1;\n    for (i = 0; i < tag_len; i++) buf[i] = tag_start[i];\n    buf[tag_len] = '\\0';\n  }\n\n  fprintf(fp, \"ONIG-MONITOR: %-4s %s at: %d [%d - %d] len: %d\\n\",\n          buf,\n          in == ONIG_CALLOUT_IN_PROGRESS ? \"=>\" : \"<=\",\n          (int )(current - string),\n          (int )(start   - string),\n          (int )(right   - string),\n          (int )(strend  - string));\n  fflush(fp);\n\n  return ONIG_CALLOUT_SUCCESS;\n}\n\nextern int\nonig_setup_builtin_monitors_by_ascii_encoded_name(void* fp /* FILE* */)\n{\n  int id;\n  char* name;\n  OnigEncoding enc;\n  unsigned int ts[4];\n  OnigValue opts[4];\n\n  if (IS_NOT_NULL(fp))\n    OutFp = (FILE* )fp;\n  else\n    OutFp = stdout;\n\n  enc = ONIG_ENCODING_ASCII;\n\n  name = \"MON\";\n  ts[0] = ONIG_TYPE_CHAR;\n  opts[0].c = '>';\n  BC_B_O(name, monitor, 1, ts, 1, opts);\n\n  return ONIG_NORMAL;\n}\n\n#endif /* USE_CALLOUT */\n"], "fixing_code": ["/**********************************************************************\n  regexec.c -  Oniguruma (regular expression library)\n**********************************************************************/\n/*-\n * Copyright (c) 2002-2019  K.Kosako\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n#include \"regint.h\"\n\n#define IS_MBC_WORD_ASCII_MODE(enc,s,end,mode) \\\n  ((mode) == 0 ? ONIGENC_IS_MBC_WORD(enc,s,end) : ONIGENC_IS_MBC_WORD_ASCII(enc,s,end))\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n#define ONIGENC_IS_MBC_CRNL(enc,p,end) \\\n  (ONIGENC_MBC_TO_CODE(enc,p,end) == 13 && \\\n   ONIGENC_IS_MBC_NEWLINE(enc,(p+enclen(enc,p)),end))\n#endif\n\n#define CHECK_INTERRUPT_IN_MATCH\n\n#ifdef USE_CALLOUT\ntypedef struct {\n  int last_match_at_call_counter;\n  struct {\n    OnigType  type;\n    OnigValue val;\n  } slot[ONIG_CALLOUT_DATA_SLOT_NUM];\n} CalloutData;\n#endif\n\nstruct OnigMatchParamStruct {\n  unsigned int    match_stack_limit;\n  unsigned long   retry_limit_in_match;\n#ifdef USE_CALLOUT\n  OnigCalloutFunc progress_callout_of_contents;\n  OnigCalloutFunc retraction_callout_of_contents;\n  int             match_at_call_counter;\n  void*           callout_user_data;\n  CalloutData*    callout_data;\n  int             callout_data_alloc_num;\n#endif\n};\n\nextern int\nonig_set_match_stack_limit_size_of_match_param(OnigMatchParam* param,\n                                               unsigned int limit)\n{\n  param->match_stack_limit = limit;\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_set_retry_limit_in_match_of_match_param(OnigMatchParam* param,\n                                             unsigned long limit)\n{\n  param->retry_limit_in_match = limit;\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_set_progress_callout_of_match_param(OnigMatchParam* param, OnigCalloutFunc f)\n{\n#ifdef USE_CALLOUT\n  param->progress_callout_of_contents = f;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\nextern int\nonig_set_retraction_callout_of_match_param(OnigMatchParam* param, OnigCalloutFunc f)\n{\n#ifdef USE_CALLOUT\n  param->retraction_callout_of_contents = f;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\nextern int\nonig_set_callout_user_data_of_match_param(OnigMatchParam* param, void* user_data)\n{\n#ifdef USE_CALLOUT\n  param->callout_user_data = user_data;\n  return ONIG_NORMAL;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\n\ntypedef struct {\n  void* stack_p;\n  int   stack_n;\n  OnigOptionType options;\n  OnigRegion*    region;\n  int            ptr_num;\n  const UChar*   start;   /* search start position (for \\G: BEGIN_POSITION) */\n  unsigned int   match_stack_limit;\n  unsigned long  retry_limit_in_match;\n  OnigMatchParam* mp;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n  int    best_len;      /* for ONIG_OPTION_FIND_LONGEST */\n  UChar* best_s;\n#endif\n} MatchArg;\n\n\n#ifdef ONIG_DEBUG\n\n/* arguments type */\ntypedef enum {\n  ARG_SPECIAL = -1,\n  ARG_NON     =  0,\n  ARG_RELADDR =  1,\n  ARG_ABSADDR =  2,\n  ARG_LENGTH  =  3,\n  ARG_MEMNUM  =  4,\n  ARG_OPTION  =  5,\n  ARG_MODE    =  6\n} OpArgType;\n\ntypedef struct {\n  short int opcode;\n  char*     name;\n} OpInfoType;\n\nstatic OpInfoType OpInfo[] = {\n  { OP_FINISH,            \"finish\" },\n  { OP_END,               \"end\"    },\n  { OP_EXACT1,            \"exact1\" },\n  { OP_EXACT2,            \"exact2\" },\n  { OP_EXACT3,            \"exact3\" },\n  { OP_EXACT4,            \"exact4\" },\n  { OP_EXACT5,            \"exact5\" },\n  { OP_EXACTN,            \"exactn\" },\n  { OP_EXACTMB2N1,        \"exactmb2-n1\" },\n  { OP_EXACTMB2N2,        \"exactmb2-n2\" },\n  { OP_EXACTMB2N3,        \"exactmb2-n3\" },\n  { OP_EXACTMB2N,         \"exactmb2-n\"  },\n  { OP_EXACTMB3N,         \"exactmb3n\"   },\n  { OP_EXACTMBN,          \"exactmbn\"    },\n  { OP_EXACT1_IC,         \"exact1-ic\"   },\n  { OP_EXACTN_IC,         \"exactn-ic\"   },\n  { OP_CCLASS,            \"cclass\"      },\n  { OP_CCLASS_MB,         \"cclass-mb\"   },\n  { OP_CCLASS_MIX,        \"cclass-mix\"  },\n  { OP_CCLASS_NOT,        \"cclass-not\"  },\n  { OP_CCLASS_MB_NOT,     \"cclass-mb-not\"  },\n  { OP_CCLASS_MIX_NOT,    \"cclass-mix-not\" },\n  { OP_ANYCHAR,               \"anychar\"     },\n  { OP_ANYCHAR_ML,            \"anychar-ml\"  },\n  { OP_ANYCHAR_STAR,          \"anychar*\"    },\n  { OP_ANYCHAR_ML_STAR,       \"anychar-ml*\" },\n  { OP_ANYCHAR_STAR_PEEK_NEXT,    \"anychar*-peek-next\" },\n  { OP_ANYCHAR_ML_STAR_PEEK_NEXT, \"anychar-ml*-peek-next\" },\n  { OP_WORD,                  \"word\"       },\n  { OP_WORD_ASCII,            \"word-ascii\" },\n  { OP_NO_WORD,               \"not-word\"   },\n  { OP_NO_WORD_ASCII,         \"not-word-ascii\" },\n  { OP_WORD_BOUNDARY,         \"word-boundary\"  },\n  { OP_NO_WORD_BOUNDARY,      \"not-word-boundary\" },\n  { OP_WORD_BEGIN,            \"word-begin\" },\n  { OP_WORD_END,              \"word-end\"   },\n  { OP_TEXT_SEGMENT_BOUNDARY, \"text-segment-boundary\" },\n  { OP_BEGIN_BUF,             \"begin-buf\"  },\n  { OP_END_BUF,               \"end-buf\"    },\n  { OP_BEGIN_LINE,            \"begin-line\" },\n  { OP_END_LINE,              \"end-line\"   },\n  { OP_SEMI_END_BUF,          \"semi-end-buf\"   },\n  { OP_BEGIN_POSITION,        \"begin-position\" },\n  { OP_BACKREF1,              \"backref1\"       },\n  { OP_BACKREF2,              \"backref2\"       },\n  { OP_BACKREF_N,             \"backref-n\"      },\n  { OP_BACKREF_N_IC,          \"backref-n-ic\"   },\n  { OP_BACKREF_MULTI,         \"backref_multi\"  },\n  { OP_BACKREF_MULTI_IC,      \"backref_multi-ic\"     },\n  { OP_BACKREF_WITH_LEVEL,    \"backref_with_level\"   },\n  { OP_BACKREF_WITH_LEVEL_IC, \"backref_with_level-c\" },\n  { OP_BACKREF_CHECK,         \"backref_check\"        },\n  { OP_BACKREF_CHECK_WITH_LEVEL, \"backref_check_with_level\" },\n  { OP_MEMORY_START_PUSH,     \"mem-start-push\"        },\n  { OP_MEMORY_START,          \"mem-start\"             },\n  { OP_MEMORY_END_PUSH,       \"mem-end-push\"          },\n  { OP_MEMORY_END_PUSH_REC,   \"mem-end-push-rec\"      },\n  { OP_MEMORY_END,            \"mem-end\"               },\n  { OP_MEMORY_END_REC,        \"mem-end-rec\"           },\n  { OP_FAIL,                  \"fail\"                  },\n  { OP_JUMP,                  \"jump\"                  },\n  { OP_PUSH,                  \"push\"                  },\n  { OP_PUSH_SUPER,            \"push-super\"            },\n  { OP_POP_OUT,               \"pop-out\"               },\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n  { OP_PUSH_OR_JUMP_EXACT1,   \"push-or-jump-e1\"       },\n#endif\n  { OP_PUSH_IF_PEEK_NEXT,     \"push-if-peek-next\"     },\n  { OP_REPEAT,                \"repeat\"                },\n  { OP_REPEAT_NG,             \"repeat-ng\"             },\n  { OP_REPEAT_INC,            \"repeat-inc\"            },\n  { OP_REPEAT_INC_NG,         \"repeat-inc-ng\"         },\n  { OP_REPEAT_INC_SG,         \"repeat-inc-sg\"         },\n  { OP_REPEAT_INC_NG_SG,      \"repeat-inc-ng-sg\"      },\n  { OP_EMPTY_CHECK_START,     \"empty-check-start\"     },\n  { OP_EMPTY_CHECK_END,       \"empty-check-end\"       },\n  { OP_EMPTY_CHECK_END_MEMST, \"empty-check-end-memst\" },\n  { OP_EMPTY_CHECK_END_MEMST_PUSH,\"empty-check-end-memst-push\" },\n  { OP_PREC_READ_START,       \"push-pos\"              },\n  { OP_PREC_READ_END,         \"pop-pos\"               },\n  { OP_PREC_READ_NOT_START,   \"prec-read-not-start\"   },\n  { OP_PREC_READ_NOT_END,     \"prec-read-not-end\"     },\n  { OP_ATOMIC_START,          \"atomic-start\"          },\n  { OP_ATOMIC_END,            \"atomic-end\"            },\n  { OP_LOOK_BEHIND,           \"look-behind\"           },\n  { OP_LOOK_BEHIND_NOT_START, \"look-behind-not-start\" },\n  { OP_LOOK_BEHIND_NOT_END,   \"look-behind-not-end\"   },\n  { OP_CALL,                  \"call\"                  },\n  { OP_RETURN,                \"return\"                },\n  { OP_PUSH_SAVE_VAL,         \"push-save-val\"         },\n  { OP_UPDATE_VAR,            \"update-var\"            },\n#ifdef USE_CALLOUT\n  { OP_CALLOUT_CONTENTS,      \"callout-contents\"      },\n  { OP_CALLOUT_NAME,          \"callout-name\"          },\n#endif\n  { -1, \"\" }\n};\n\nstatic char*\nop2name(int opcode)\n{\n  int i;\n\n  for (i = 0; OpInfo[i].opcode >= 0; i++) {\n    if (opcode == OpInfo[i].opcode) return OpInfo[i].name;\n  }\n\n  return \"\";\n}\n\nstatic void\np_string(FILE* f, int len, UChar* s)\n{\n  fputs(\":\", f);\n  while (len-- > 0) { fputc(*s++, f); }\n}\n\nstatic void\np_len_string(FILE* f, LengthType len, int mb_len, UChar* s)\n{\n  int x = len * mb_len;\n\n  fprintf(f, \":%d:\", len);\n  while (x-- > 0) { fputc(*s++, f); }\n}\n\nstatic void\np_rel_addr(FILE* f, RelAddrType rel_addr, Operation* p, Operation* start)\n{\n  RelAddrType curr = (RelAddrType )(p - start);\n\n  fprintf(f, \"{%d/%d}\", rel_addr, curr + rel_addr);\n}\n\nstatic int\nbitset_on_num(BitSetRef bs)\n{\n  int i, n;\n\n  n = 0;\n  for (i = 0; i < SINGLE_BYTE_SIZE; i++) {\n    if (BITSET_AT(bs, i)) n++;\n  }\n\n  return n;\n}\n\nstatic void\nprint_compiled_byte_code(FILE* f, regex_t* reg, int index,\n                         Operation* start, OnigEncoding enc)\n{\n  int i, n;\n  RelAddrType addr;\n  LengthType  len;\n  MemNumType  mem;\n  OnigCodePoint code;\n  ModeType mode;\n  UChar *q;\n  Operation* p;\n  enum OpCode opcode;\n\n  p = reg->ops + index;\n\n#ifdef USE_DIRECT_THREADED_CODE\n  opcode = reg->ocs[index];\n#else\n  opcode = p->opcode;\n#endif\n\n  fprintf(f, \"%s\", op2name(opcode));\n  switch (opcode) {\n  case OP_EXACT1:\n    p_string(f, 1, p->exact.s); break;\n  case OP_EXACT2:\n    p_string(f, 2, p->exact.s); break;\n  case OP_EXACT3:\n    p_string(f, 3, p->exact.s); break;\n  case OP_EXACT4:\n    p_string(f, 4, p->exact.s); break;\n  case OP_EXACT5:\n    p_string(f, 5, p->exact.s); break;\n  case OP_EXACTN:\n    len = p->exact_n.n;\n    p_string(f, len, p->exact_n.s); break;\n  case OP_EXACTMB2N1:\n    p_string(f, 2, p->exact.s); break;\n  case OP_EXACTMB2N2:\n    p_string(f, 4, p->exact.s); break;\n  case OP_EXACTMB2N3:\n    p_string(f, 3, p->exact.s); break;\n  case OP_EXACTMB2N:\n    len = p->exact_n.n;\n    p_len_string(f, len, 2, p->exact_n.s); break;\n  case OP_EXACTMB3N:\n    len = p->exact_n.n;\n    p_len_string(f, len, 3, p->exact_n.s); break;\n  case OP_EXACTMBN:\n    {\n      int mb_len;\n\n      mb_len = p->exact_len_n.len;\n      len    = p->exact_len_n.n;\n      q      = p->exact_len_n.s;\n      fprintf(f, \":%d:%d:\", mb_len, len);\n      n = len * mb_len;\n      while (n-- > 0) { fputc(*q++, f); }\n    }\n    break;\n  case OP_EXACT1_IC:\n    len = enclen(enc, p->exact.s);\n    p_string(f, len, p->exact.s);\n    break;\n  case OP_EXACTN_IC:\n    len = p->exact_n.n;\n    p_len_string(f, len, 1, p->exact_n.s);\n    break;\n\n  case OP_CCLASS:\n  case OP_CCLASS_NOT:\n    n = bitset_on_num(p->cclass.bsp);\n    fprintf(f, \":%d\", n);\n    break;\n  case OP_CCLASS_MB:\n  case OP_CCLASS_MB_NOT:\n    {\n      OnigCodePoint ncode;\n      OnigCodePoint* codes;      \n\n      codes = (OnigCodePoint* )p->cclass_mb.mb;\n      GET_CODE_POINT(ncode, codes);\n      codes++;\n      GET_CODE_POINT(code, codes);\n      fprintf(f, \":%u:%u\", code, ncode);\n    }\n    break;\n  case OP_CCLASS_MIX:\n  case OP_CCLASS_MIX_NOT:\n    {\n      OnigCodePoint ncode;\n      OnigCodePoint* codes;\n\n      codes = (OnigCodePoint* )p->cclass_mix.mb;\n      n = bitset_on_num(p->cclass_mix.bsp);\n\n      GET_CODE_POINT(ncode, codes);\n      codes++;\n      GET_CODE_POINT(code, codes);\n      fprintf(f, \":%d:%u:%u\", n, code, ncode);\n    }\n    break;\n\n  case OP_ANYCHAR_STAR_PEEK_NEXT:\n  case OP_ANYCHAR_ML_STAR_PEEK_NEXT:\n    p_string(f, 1, &(p->anychar_star_peek_next.c));\n    break;\n\n  case OP_WORD_BOUNDARY:\n  case OP_NO_WORD_BOUNDARY:\n  case OP_WORD_BEGIN:\n  case OP_WORD_END:\n    mode = p->word_boundary.mode;\n    fprintf(f, \":%d\", mode);\n    break;\n\n  case OP_BACKREF_N:\n  case OP_BACKREF_N_IC:\n    mem = p->backref_n.n1;\n    fprintf(f, \":%d\", mem);\n    break;\n  case OP_BACKREF_MULTI_IC:\n  case OP_BACKREF_MULTI:\n  case OP_BACKREF_CHECK:\n    fputs(\" \", f);\n    n = p->backref_general.num;\n    for (i = 0; i < n; i++) {\n      mem = (n == 1) ? p->backref_general.n1 : p->backref_general.ns[i];\n      if (i > 0) fputs(\", \", f);\n      fprintf(f, \"%d\", mem);\n    }\n    break;\n  case OP_BACKREF_WITH_LEVEL:\n  case OP_BACKREF_WITH_LEVEL_IC:\n  case OP_BACKREF_CHECK_WITH_LEVEL:\n    {\n      LengthType level;\n\n      level = p->backref_general.nest_level;\n      fprintf(f, \":%d\", level);\n      fputs(\" \", f);\n      n = p->backref_general.num;\n      for (i = 0; i < n; i++) {\n        mem = (n == 1) ? p->backref_general.n1 : p->backref_general.ns[i];\n        if (i > 0) fputs(\", \", f);\n        fprintf(f, \"%d\", mem);\n      }\n    }\n    break;\n\n  case OP_MEMORY_START:\n  case OP_MEMORY_START_PUSH:\n    mem = p->memory_start.num;\n    fprintf(f, \":%d\", mem);\n    break;\n  case OP_MEMORY_END_PUSH:\n  case OP_MEMORY_END_PUSH_REC:\n  case OP_MEMORY_END:\n  case OP_MEMORY_END_REC:\n    mem = p->memory_end.num;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_JUMP:\n    addr = p->jump.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_PUSH:\n  case OP_PUSH_SUPER:\n    addr = p->push.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n  case OP_PUSH_OR_JUMP_EXACT1:\n    addr = p->push_or_jump_exact1.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    p_string(f, 1, &(p->push_or_jump_exact1.c));\n    break;\n#endif\n\n  case OP_PUSH_IF_PEEK_NEXT:\n    addr = p->push_if_peek_next.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    p_string(f, 1, &(p->push_if_peek_next.c));\n    break;\n\n  case OP_REPEAT:\n  case OP_REPEAT_NG:\n    mem = p->repeat.id;\n    addr = p->repeat.addr;\n    fprintf(f, \":%d:\", mem);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_REPEAT_INC:\n  case OP_REPEAT_INC_NG:\n  case OP_REPEAT_INC_SG:\n  case OP_REPEAT_INC_NG_SG:\n    mem = p->repeat.id;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_EMPTY_CHECK_START:\n    mem = p->empty_check_start.mem;\n    fprintf(f, \":%d\", mem);\n    break;\n  case OP_EMPTY_CHECK_END:\n  case OP_EMPTY_CHECK_END_MEMST:\n  case OP_EMPTY_CHECK_END_MEMST_PUSH:\n    mem = p->empty_check_end.mem;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_PREC_READ_NOT_START:\n    addr = p->prec_read_not_start.addr;\n    fputc(':', f);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_LOOK_BEHIND:\n    len = p->look_behind.len;\n    fprintf(f, \":%d\", len);\n    break;\n\n  case OP_LOOK_BEHIND_NOT_START:\n    addr = p->look_behind_not_start.addr;\n    len  = p->look_behind_not_start.len;\n    fprintf(f, \":%d:\", len);\n    p_rel_addr(f, addr, p, start);\n    break;\n\n  case OP_CALL:\n    addr = p->call.addr;\n    fprintf(f, \":{/%d}\", addr);\n    break;\n\n  case OP_PUSH_SAVE_VAL:\n    {\n      SaveType type;\n\n      type = p->push_save_val.type;\n      mem  = p->push_save_val.id;\n      fprintf(f, \":%d:%d\", type, mem);\n    }\n    break;\n\n  case OP_UPDATE_VAR:\n    {\n      UpdateVarType type;\n\n      type = p->update_var.type;\n      mem  = p->update_var.id;\n      fprintf(f, \":%d:%d\", type, mem);\n    }\n    break;\n\n#ifdef USE_CALLOUT\n  case OP_CALLOUT_CONTENTS:\n    mem = p->callout_contents.num;\n    fprintf(f, \":%d\", mem);\n    break;\n\n  case OP_CALLOUT_NAME:\n    {\n      int id;\n\n      id  = p->callout_name.id;\n      mem = p->callout_name.num;\n      fprintf(f, \":%d:%d\", id, mem);\n    }\n    break;\n#endif\n\n  case OP_TEXT_SEGMENT_BOUNDARY:\n    if (p->text_segment_boundary.not != 0)\n      fprintf(f, \":not\");\n    break;\n\n  case OP_FINISH:\n  case OP_END:\n  case OP_ANYCHAR:\n  case OP_ANYCHAR_ML:\n  case OP_ANYCHAR_STAR:\n  case OP_ANYCHAR_ML_STAR:\n  case OP_WORD:\n  case OP_WORD_ASCII:\n  case OP_NO_WORD:\n  case OP_NO_WORD_ASCII:\n  case OP_BEGIN_BUF:\n  case OP_END_BUF:\n  case OP_BEGIN_LINE:\n  case OP_END_LINE:\n  case OP_SEMI_END_BUF:\n  case OP_BEGIN_POSITION:\n  case OP_BACKREF1:\n  case OP_BACKREF2:\n  case OP_FAIL:\n  case OP_POP_OUT:\n  case OP_PREC_READ_START:\n  case OP_PREC_READ_END:\n  case OP_PREC_READ_NOT_END:\n  case OP_ATOMIC_START:\n  case OP_ATOMIC_END:\n  case OP_LOOK_BEHIND_NOT_END:\n  case OP_RETURN:\n    break;\n\n  default:\n    fprintf(stderr, \"print_compiled_byte_code: undefined code %d\\n\", opcode);\n    break;\n  }\n}\n#endif /* ONIG_DEBUG */\n\n#ifdef ONIG_DEBUG_COMPILE\nextern void\nonig_print_compiled_byte_code_list(FILE* f, regex_t* reg)\n{\n  Operation* bp;\n  Operation* start = reg->ops;\n  Operation* end   = reg->ops + reg->ops_used;\n\n  fprintf(f, \"bt_mem_start: 0x%x, bt_mem_end: 0x%x\\n\",\n          reg->bt_mem_start, reg->bt_mem_end);\n  fprintf(f, \"code-length: %d\\n\", reg->ops_used);\n\n  bp = start;\n  while (bp < end) {\n    int pos = bp - start;\n\n    fprintf(f, \"%4d: \", pos);\n    print_compiled_byte_code(f, reg, pos, start, reg->enc);\n    fprintf(f, \"\\n\");\n    bp++;\n  }\n  fprintf(f, \"\\n\");\n}\n#endif\n\n\n#ifdef USE_CAPTURE_HISTORY\nstatic void history_tree_free(OnigCaptureTreeNode* node);\n\nstatic void\nhistory_tree_clear(OnigCaptureTreeNode* node)\n{\n  int i;\n\n  if (IS_NULL(node)) return ;\n\n  for (i = 0; i < node->num_childs; i++) {\n    if (IS_NOT_NULL(node->childs[i])) {\n      history_tree_free(node->childs[i]);\n    }\n  }\n  for (i = 0; i < node->allocated; i++) {\n    node->childs[i] = (OnigCaptureTreeNode* )0;\n  }\n  node->num_childs = 0;\n  node->beg = ONIG_REGION_NOTPOS;\n  node->end = ONIG_REGION_NOTPOS;\n  node->group = -1;\n}\n\nstatic void\nhistory_tree_free(OnigCaptureTreeNode* node)\n{\n  history_tree_clear(node);\n  if (IS_NOT_NULL(node->childs)) xfree(node->childs);\n\n  xfree(node);\n}\n\nstatic void\nhistory_root_free(OnigRegion* r)\n{\n  if (IS_NULL(r->history_root)) return ;\n\n  history_tree_free(r->history_root);\n  r->history_root = (OnigCaptureTreeNode* )0;\n}\n\nstatic OnigCaptureTreeNode*\nhistory_node_new(void)\n{\n  OnigCaptureTreeNode* node;\n\n  node = (OnigCaptureTreeNode* )xmalloc(sizeof(OnigCaptureTreeNode));\n  CHECK_NULL_RETURN(node);\n\n  node->childs     = (OnigCaptureTreeNode** )0;\n  node->allocated  =  0;\n  node->num_childs =  0;\n  node->group      = -1;\n  node->beg        = ONIG_REGION_NOTPOS;\n  node->end        = ONIG_REGION_NOTPOS;\n\n  return node;\n}\n\nstatic int\nhistory_tree_add_child(OnigCaptureTreeNode* parent, OnigCaptureTreeNode* child)\n{\n#define HISTORY_TREE_INIT_ALLOC_SIZE  8\n\n  if (parent->num_childs >= parent->allocated) {\n    int n, i;\n\n    if (IS_NULL(parent->childs)) {\n      n = HISTORY_TREE_INIT_ALLOC_SIZE;\n      parent->childs =\n        (OnigCaptureTreeNode** )xmalloc(sizeof(parent->childs[0]) * n);\n    }\n    else {\n      n = parent->allocated * 2;\n      parent->childs =\n        (OnigCaptureTreeNode** )xrealloc(parent->childs,\n                                         sizeof(parent->childs[0]) * n);\n    }\n    CHECK_NULL_RETURN_MEMERR(parent->childs);\n    for (i = parent->allocated; i < n; i++) {\n      parent->childs[i] = (OnigCaptureTreeNode* )0;\n    }\n    parent->allocated = n;\n  }\n\n  parent->childs[parent->num_childs] = child;\n  parent->num_childs++;\n  return 0;\n}\n\nstatic OnigCaptureTreeNode*\nhistory_tree_clone(OnigCaptureTreeNode* node)\n{\n  int i;\n  OnigCaptureTreeNode *clone, *child;\n\n  clone = history_node_new();\n  CHECK_NULL_RETURN(clone);\n\n  clone->beg = node->beg;\n  clone->end = node->end;\n  for (i = 0; i < node->num_childs; i++) {\n    child = history_tree_clone(node->childs[i]);\n    if (IS_NULL(child)) {\n      history_tree_free(clone);\n      return (OnigCaptureTreeNode* )0;\n    }\n    history_tree_add_child(clone, child);\n  }\n\n  return clone;\n}\n\nextern  OnigCaptureTreeNode*\nonig_get_capture_tree(OnigRegion* region)\n{\n  return region->history_root;\n}\n#endif /* USE_CAPTURE_HISTORY */\n\nextern void\nonig_region_clear(OnigRegion* region)\n{\n  int i;\n\n  for (i = 0; i < region->num_regs; i++) {\n    region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n  }\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(region);\n#endif\n}\n\nextern int\nonig_region_resize(OnigRegion* region, int n)\n{\n  region->num_regs = n;\n\n  if (n < ONIG_NREGION)\n    n = ONIG_NREGION;\n\n  if (region->allocated == 0) {\n    region->beg = (int* )xmalloc(n * sizeof(int));\n    region->end = (int* )xmalloc(n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n  else if (region->allocated < n) {\n    region->beg = (int* )xrealloc(region->beg, n * sizeof(int));\n    region->end = (int* )xrealloc(region->end, n * sizeof(int));\n\n    if (region->beg == 0 || region->end == 0)\n      return ONIGERR_MEMORY;\n\n    region->allocated = n;\n  }\n\n  return 0;\n}\n\nstatic int\nonig_region_resize_clear(OnigRegion* region, int n)\n{\n  int r;\n\n  r = onig_region_resize(region, n);\n  if (r != 0) return r;\n  onig_region_clear(region);\n  return 0;\n}\n\nextern int\nonig_region_set(OnigRegion* region, int at, int beg, int end)\n{\n  if (at < 0) return ONIGERR_INVALID_ARGUMENT;\n\n  if (at >= region->allocated) {\n    int r = onig_region_resize(region, at + 1);\n    if (r < 0) return r;\n  }\n\n  region->beg[at] = beg;\n  region->end[at] = end;\n  return 0;\n}\n\nextern void\nonig_region_init(OnigRegion* region)\n{\n  region->num_regs     = 0;\n  region->allocated    = 0;\n  region->beg          = (int* )0;\n  region->end          = (int* )0;\n  region->history_root = (OnigCaptureTreeNode* )0;\n}\n\nextern OnigRegion*\nonig_region_new(void)\n{\n  OnigRegion* r;\n\n  r = (OnigRegion* )xmalloc(sizeof(OnigRegion));\n  CHECK_NULL_RETURN(r);\n  onig_region_init(r);\n  return r;\n}\n\nextern void\nonig_region_free(OnigRegion* r, int free_self)\n{\n  if (r != 0) {\n    if (r->allocated > 0) {\n      if (r->beg) xfree(r->beg);\n      if (r->end) xfree(r->end);\n      r->allocated = 0;\n    }\n#ifdef USE_CAPTURE_HISTORY\n    history_root_free(r);\n#endif\n    if (free_self) xfree(r);\n  }\n}\n\nextern void\nonig_region_copy(OnigRegion* to, OnigRegion* from)\n{\n#define RREGC_SIZE   (sizeof(int) * from->num_regs)\n  int i;\n\n  if (to == from) return;\n\n  if (to->allocated == 0) {\n    if (from->num_regs > 0) {\n      to->beg = (int* )xmalloc(RREGC_SIZE);\n      if (IS_NULL(to->beg)) return;\n      to->end = (int* )xmalloc(RREGC_SIZE);\n      if (IS_NULL(to->end)) return;\n      to->allocated = from->num_regs;\n    }\n  }\n  else if (to->allocated < from->num_regs) {\n    to->beg = (int* )xrealloc(to->beg, RREGC_SIZE);\n    if (IS_NULL(to->beg)) return;\n    to->end = (int* )xrealloc(to->end, RREGC_SIZE);\n    if (IS_NULL(to->end)) return;\n    to->allocated = from->num_regs;\n  }\n\n  for (i = 0; i < from->num_regs; i++) {\n    to->beg[i] = from->beg[i];\n    to->end[i] = from->end[i];\n  }\n  to->num_regs = from->num_regs;\n\n#ifdef USE_CAPTURE_HISTORY\n  history_root_free(to);\n\n  if (IS_NOT_NULL(from->history_root)) {\n    to->history_root = history_tree_clone(from->history_root);\n  }\n#endif\n}\n\n#ifdef USE_CALLOUT\n#define CALLOUT_BODY(func, ain, aname_id, anum, user, args, result) do { \\\n  args.in            = (ain);\\\n  args.name_id       = (aname_id);\\\n  args.num           = anum;\\\n  args.regex         = reg;\\\n  args.string        = str;\\\n  args.string_end    = end;\\\n  args.start         = sstart;\\\n  args.right_range   = right_range;\\\n  args.current       = s;\\\n  args.retry_in_match_counter = retry_in_match_counter;\\\n  args.msa           = msa;\\\n  args.stk_base      = stk_base;\\\n  args.stk           = stk;\\\n  args.mem_start_stk = mem_start_stk;\\\n  args.mem_end_stk   = mem_end_stk;\\\n  result = (func)(&args, user);\\\n} while (0)\n\n#define RETRACTION_CALLOUT(func, aname_id, anum, user) do {\\\n  int result;\\\n  OnigCalloutArgs args;\\\n  CALLOUT_BODY(func, ONIG_CALLOUT_IN_RETRACTION, aname_id, anum, user, args, result);\\\n  switch (result) {\\\n  case ONIG_CALLOUT_FAIL:\\\n  case ONIG_CALLOUT_SUCCESS:\\\n    break;\\\n  default:\\\n    if (result > 0) {\\\n      result = ONIGERR_INVALID_ARGUMENT;\\\n    }\\\n    best_len = result;\\\n    goto finish;\\\n    break;\\\n  }\\\n} while(0)\n#endif\n\n\n/** stack **/\n#define INVALID_STACK_INDEX   -1\n\n#define STK_ALT_FLAG               0x0001\n\n/* stack type */\n/* used by normal-POP */\n#define STK_SUPER_ALT             STK_ALT_FLAG\n#define STK_ALT                   (0x0002 | STK_ALT_FLAG)\n#define STK_ALT_PREC_READ_NOT     (0x0004 | STK_ALT_FLAG)\n#define STK_ALT_LOOK_BEHIND_NOT   (0x0006 | STK_ALT_FLAG)\n\n/* handled by normal-POP */\n#define STK_MEM_START              0x0010\n#define STK_MEM_END                0x8030\n#define STK_REPEAT_INC             0x0050\n#ifdef USE_CALLOUT\n#define STK_CALLOUT                0x0070\n#endif\n\n/* avoided by normal-POP */\n#define STK_VOID                   0x0000  /* for fill a blank */\n#define STK_EMPTY_CHECK_START      0x3000\n#define STK_EMPTY_CHECK_END        0x5000  /* for recursive call */\n#define STK_MEM_END_MARK           0x8100\n#define STK_TO_VOID_START          0x1200  /* mark for \"(?>...)\" */\n#define STK_REPEAT                 0x0300\n#define STK_CALL_FRAME             0x0400\n#define STK_RETURN                 0x0500\n#define STK_SAVE_VAL               0x0600\n#define STK_PREC_READ_START        0x0700\n#define STK_PREC_READ_END          0x0800\n\n/* stack type check mask */\n#define STK_MASK_POP_USED          STK_ALT_FLAG\n#define STK_MASK_POP_HANDLED       0x0010\n#define STK_MASK_POP_HANDLED_TIL   (STK_MASK_POP_HANDLED | 0x0004)\n#define STK_MASK_TO_VOID_TARGET    0x100e\n#define STK_MASK_MEM_END_OR_MARK   0x8000  /* MEM_END or MEM_END_MARK */\n\ntypedef intptr_t StackIndex;\n\ntypedef struct _StackType {\n  unsigned int type;\n  int zid;\n  union {\n    struct {\n      Operation* pcode;     /* byte code position */\n      UChar*     pstr;      /* string position */\n      UChar*     pstr_prev; /* previous char position of pstr */\n    } state;\n    struct {\n      int        count;  /* for OP_REPEAT_INC, OP_REPEAT_INC_NG */\n      Operation* pcode;  /* byte code position (head of repeated target) */\n    } repeat;\n    struct {\n      StackIndex si;     /* index of stack */\n    } repeat_inc;\n    struct {\n      UChar *pstr;       /* start/end position */\n      /* Following information is set, if this stack type is MEM-START */\n      StackIndex prev_start;  /* prev. info (for backtrack  \"(...)*\" ) */\n      StackIndex prev_end;    /* prev. info (for backtrack  \"(...)*\" ) */\n    } mem;\n    struct {\n      UChar *pstr;       /* start position */\n    } empty_check;\n#ifdef USE_CALL\n    struct {\n      Operation *ret_addr; /* byte code position */\n      UChar *pstr;         /* string position */\n    } call_frame;\n#endif\n    struct {\n      enum SaveType type;\n      UChar* v;\n      UChar* v2;\n    } val;\n#ifdef USE_CALLOUT\n    struct {\n      int num;\n      OnigCalloutFunc func;\n    } callout;\n#endif\n  } u;\n} StackType;\n\n#ifdef USE_CALLOUT\n\nstruct OnigCalloutArgsStruct {\n  OnigCalloutIn    in;\n  int              name_id;   /* name id or ONIG_NON_NAME_ID */\n  int              num;\n  OnigRegex        regex;\n  const OnigUChar* string;\n  const OnigUChar* string_end;\n  const OnigUChar* start;\n  const OnigUChar* right_range;\n  const OnigUChar* current;  /* current matching position */\n  unsigned long    retry_in_match_counter;\n\n  /* invisible to users */\n  MatchArg*   msa;\n  StackType*  stk_base;\n  StackType*  stk;\n  StackIndex* mem_start_stk;\n  StackIndex* mem_end_stk;\n};\n\n#endif\n\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start, mp) do { \\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).match_stack_limit  = (mp)->match_stack_limit;\\\n  (msa).retry_limit_in_match = (mp)->retry_limit_in_match;\\\n  (msa).mp = mp;\\\n  (msa).best_len = ONIG_MISMATCH;\\\n  (msa).ptr_num  = (reg)->num_repeat + ((reg)->num_mem + 1) * 2; \\\n} while(0)\n#else\n#define MATCH_ARG_INIT(msa, reg, arg_option, arg_region, arg_start, mp) do { \\\n  (msa).stack_p  = (void* )0;\\\n  (msa).options  = (arg_option);\\\n  (msa).region   = (arg_region);\\\n  (msa).start    = (arg_start);\\\n  (msa).match_stack_limit  = (mp)->match_stack_limit;\\\n  (msa).retry_limit_in_match = (mp)->retry_limit_in_match;\\\n  (msa).mp = mp;\\\n  (msa).ptr_num  = (reg)->num_repeat + ((reg)->num_mem + 1) * 2; \\\n} while(0)\n#endif\n\n#define MATCH_ARG_FREE(msa)  if ((msa).stack_p) xfree((msa).stack_p)\n\n\n#define ALLOCA_PTR_NUM_LIMIT   50\n\n#define STACK_INIT(stack_num)  do {\\\n  if (msa->stack_p) {\\\n    is_alloca  = 0;\\\n    alloc_base = msa->stack_p;\\\n    stk_base   = (StackType* )(alloc_base\\\n                 + (sizeof(StackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + msa->stack_n;\\\n  }\\\n  else if (msa->ptr_num > ALLOCA_PTR_NUM_LIMIT) {\\\n    is_alloca  = 0;\\\n    alloc_base = (char* )xmalloc(sizeof(StackIndex) * msa->ptr_num\\\n                  + sizeof(StackType) * (stack_num));\\\n    CHECK_NULL_RETURN_MEMERR(alloc_base);\\\n    stk_base   = (StackType* )(alloc_base\\\n                 + (sizeof(StackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n  else {\\\n    is_alloca  = 1;\\\n    alloc_base = (char* )xalloca(sizeof(StackIndex) * msa->ptr_num\\\n                 + sizeof(StackType) * (stack_num));\\\n    CHECK_NULL_RETURN_MEMERR(alloc_base);\\\n    stk_base   = (StackType* )(alloc_base\\\n                 + (sizeof(StackIndex) * msa->ptr_num));\\\n    stk        = stk_base;\\\n    stk_end    = stk_base + (stack_num);\\\n  }\\\n} while(0);\n\n\n#define STACK_SAVE do{\\\n    msa->stack_n = (int )(stk_end - stk_base);\\\n  if (is_alloca != 0) {\\\n    size_t size = sizeof(StackIndex) * msa->ptr_num \\\n                + sizeof(StackType) * msa->stack_n;\\\n    msa->stack_p = xmalloc(size);\\\n    CHECK_NULL_RETURN_MEMERR(msa->stack_p);\\\n    xmemcpy(msa->stack_p, alloc_base, size);\\\n  }\\\n  else {\\\n    msa->stack_p = alloc_base;\\\n  };\\\n} while(0)\n\n#define UPDATE_FOR_STACK_REALLOC do{\\\n  repeat_stk    = (StackIndex* )alloc_base;\\\n  mem_start_stk = (StackIndex* )(repeat_stk + reg->num_repeat);\\\n  mem_end_stk   = mem_start_stk + num_mem + 1;\\\n} while(0)\n\nstatic unsigned int MatchStackLimit = DEFAULT_MATCH_STACK_LIMIT_SIZE;\n\nextern unsigned int\nonig_get_match_stack_limit_size(void)\n{\n  return MatchStackLimit;\n}\n\nextern int\nonig_set_match_stack_limit_size(unsigned int size)\n{\n  MatchStackLimit = size;\n  return 0;\n}\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n\nstatic unsigned long RetryLimitInMatch = DEFAULT_RETRY_LIMIT_IN_MATCH;\n\n#define CHECK_RETRY_LIMIT_IN_MATCH  do {\\\n  if (retry_in_match_counter++ > retry_limit_in_match) goto retry_limit_in_match_over;\\\n} while (0)\n\n#else\n\n#define CHECK_RETRY_LIMIT_IN_MATCH\n\n#endif /* USE_RETRY_LIMIT_IN_MATCH */\n\nextern unsigned long\nonig_get_retry_limit_in_match(void)\n{\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  return RetryLimitInMatch;\n#else\n  /* return ONIG_NO_SUPPORT_CONFIG; */\n  return 0;\n#endif\n}\n\nextern int\nonig_set_retry_limit_in_match(unsigned long size)\n{\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  RetryLimitInMatch = size;\n  return 0;\n#else\n  return ONIG_NO_SUPPORT_CONFIG;\n#endif\n}\n\n#ifdef USE_CALLOUT\nstatic OnigCalloutFunc DefaultProgressCallout;\nstatic OnigCalloutFunc DefaultRetractionCallout;\n#endif\n\nextern OnigMatchParam*\nonig_new_match_param(void)\n{\n  OnigMatchParam* p;\n\n  p = (OnigMatchParam* )xmalloc(sizeof(*p));\n  if (IS_NOT_NULL(p)) {\n    onig_initialize_match_param(p);\n  }\n\n  return p;\n}\n\nextern void\nonig_free_match_param_content(OnigMatchParam* p)\n{\n#ifdef USE_CALLOUT\n  if (IS_NOT_NULL(p->callout_data)) {\n    xfree(p->callout_data);\n    p->callout_data = 0;\n  }\n#endif\n}\n\nextern void\nonig_free_match_param(OnigMatchParam* p)\n{\n  if (IS_NOT_NULL(p)) {\n    onig_free_match_param_content(p);\n    xfree(p);\n  }\n}\n\nextern int\nonig_initialize_match_param(OnigMatchParam* mp)\n{\n  mp->match_stack_limit  = MatchStackLimit;\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  mp->retry_limit_in_match = RetryLimitInMatch;\n#endif\n\n#ifdef USE_CALLOUT\n  mp->progress_callout_of_contents   = DefaultProgressCallout;\n  mp->retraction_callout_of_contents = DefaultRetractionCallout;\n  mp->match_at_call_counter  = 0;\n  mp->callout_user_data      = 0;\n  mp->callout_data           = 0;\n  mp->callout_data_alloc_num = 0;\n#endif\n\n  return ONIG_NORMAL;\n}\n\n#ifdef USE_CALLOUT\n\nstatic int\nadjust_match_param(regex_t* reg, OnigMatchParam* mp)\n{\n  RegexExt* ext = reg->extp;\n\n  mp->match_at_call_counter = 0;\n\n  if (IS_NULL(ext) || ext->callout_num == 0) return ONIG_NORMAL;\n\n  if (ext->callout_num > mp->callout_data_alloc_num) {\n    CalloutData* d;\n    size_t n = ext->callout_num * sizeof(*d);\n    if (IS_NOT_NULL(mp->callout_data))\n      d = (CalloutData* )xrealloc(mp->callout_data, n);\n    else\n      d = (CalloutData* )xmalloc(n);\n    CHECK_NULL_RETURN_MEMERR(d);\n\n    mp->callout_data = d;\n    mp->callout_data_alloc_num = ext->callout_num;\n  }\n\n  xmemset(mp->callout_data, 0, mp->callout_data_alloc_num * sizeof(CalloutData));\n  return ONIG_NORMAL;\n}\n\n#define ADJUST_MATCH_PARAM(reg, mp) \\\n  r = adjust_match_param(reg, mp);\\\n  if (r != ONIG_NORMAL) return r;\n\n#define CALLOUT_DATA_AT_NUM(mp, num)  ((mp)->callout_data + ((num) - 1))\n\nextern int\nonig_check_callout_data_and_clear_old_values(OnigCalloutArgs* args)\n{\n  OnigMatchParam* mp;\n  int num;\n  CalloutData* d;\n\n  mp  = args->msa->mp;\n  num = args->num;\n\n  d = CALLOUT_DATA_AT_NUM(mp, num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n    return d->last_match_at_call_counter;\n  }\n\n  return 0;\n}\n\nextern int\nonig_get_callout_data_dont_clear_old(regex_t* reg, OnigMatchParam* mp,\n                                     int callout_num, int slot,\n                                     OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}\n\nextern int\nonig_get_callout_data_by_callout_args_self_dont_clear_old(OnigCalloutArgs* args,\n                                                          int slot, OnigType* type,\n                                                          OnigValue* val)\n{\n  return onig_get_callout_data_dont_clear_old(args->regex, args->msa->mp,\n                                              args->num, slot, type, val);\n}\n\nextern int\nonig_get_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType* type, OnigValue* val)\n{\n  OnigType t;\n  CalloutData* d;\n\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  if (d->last_match_at_call_counter != mp->match_at_call_counter) {\n    xmemset(d, 0, sizeof(*d));\n    d->last_match_at_call_counter = mp->match_at_call_counter;\n  }\n\n  t = d->slot[slot].type;\n  if (IS_NOT_NULL(type)) *type = t;\n  if (IS_NOT_NULL(val))  *val  = d->slot[slot].val;\n  return (t == ONIG_TYPE_VOID ? 1 : ONIG_NORMAL);\n}\n\nextern int\nonig_get_callout_data_by_tag(regex_t* reg, OnigMatchParam* mp,\n                             const UChar* tag, const UChar* tag_end, int slot,\n                             OnigType* type, OnigValue* val)\n{\n  int num;\n\n  num = onig_get_callout_num_by_tag(reg, tag, tag_end);\n  if (num < 0)  return num;\n  if (num == 0) return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  return onig_get_callout_data(reg, mp, num, slot, type, val);\n}\n\nextern int\nonig_get_callout_data_by_callout_args(OnigCalloutArgs* args,\n                                      int callout_num, int slot,\n                                      OnigType* type, OnigValue* val)\n{\n  return onig_get_callout_data(args->regex, args->msa->mp, callout_num, slot,\n                               type, val);\n}\n\nextern int\nonig_get_callout_data_by_callout_args_self(OnigCalloutArgs* args,\n                                           int slot, OnigType* type, OnigValue* val)\n{\n  return onig_get_callout_data(args->regex, args->msa->mp, args->num, slot,\n                               type, val);\n}\n\nextern int\nonig_set_callout_data(regex_t* reg, OnigMatchParam* mp,\n                      int callout_num, int slot,\n                      OnigType type, OnigValue* val)\n{\n  CalloutData* d;\n\n  if (callout_num <= 0) return ONIGERR_INVALID_ARGUMENT;\n\n  d = CALLOUT_DATA_AT_NUM(mp, callout_num);\n  d->slot[slot].type = type;\n  d->slot[slot].val  = *val;\n  d->last_match_at_call_counter = mp->match_at_call_counter;\n\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_set_callout_data_by_tag(regex_t* reg, OnigMatchParam* mp,\n                             const UChar* tag, const UChar* tag_end, int slot,\n                             OnigType type, OnigValue* val)\n{\n  int num;\n\n  num = onig_get_callout_num_by_tag(reg, tag, tag_end);\n  if (num < 0)  return num;\n  if (num == 0) return ONIGERR_INVALID_CALLOUT_TAG_NAME;\n\n  return onig_set_callout_data(reg, mp, num, slot, type, val);\n}\n\nextern int\nonig_set_callout_data_by_callout_args(OnigCalloutArgs* args,\n                                      int callout_num, int slot,\n                                      OnigType type, OnigValue* val)\n{\n  return onig_set_callout_data(args->regex, args->msa->mp, callout_num, slot,\n                               type, val);\n}\n\nextern int\nonig_set_callout_data_by_callout_args_self(OnigCalloutArgs* args,\n                                           int slot, OnigType type, OnigValue* val)\n{\n  return onig_set_callout_data(args->regex, args->msa->mp, args->num, slot,\n                               type, val);\n}\n\n#else\n#define ADJUST_MATCH_PARAM(reg, mp)\n#endif /* USE_CALLOUT */\n\n\nstatic int\nstack_double(int is_alloca, char** arg_alloc_base,\n             StackType** arg_stk_base, StackType** arg_stk_end, StackType** arg_stk,\n             MatchArg* msa)\n{\n  unsigned int n;\n  int used;\n  size_t size;\n  size_t new_size;\n  char* alloc_base;\n  char* new_alloc_base;\n  StackType *stk_base, *stk_end, *stk;\n\n  alloc_base = *arg_alloc_base;\n  stk_base = *arg_stk_base;\n  stk_end  = *arg_stk_end;\n  stk      = *arg_stk;\n\n  n = (unsigned int )(stk_end - stk_base);\n  size = sizeof(StackIndex) * msa->ptr_num + sizeof(StackType) * n;\n  n *= 2;\n  new_size = sizeof(StackIndex) * msa->ptr_num + sizeof(StackType) * n;\n  if (is_alloca != 0) {\n    new_alloc_base = (char* )xmalloc(new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n    xmemcpy(new_alloc_base, alloc_base, size);\n  }\n  else {\n    if (msa->match_stack_limit != 0 && n > msa->match_stack_limit) {\n      if ((unsigned int )(stk_end - stk_base) == msa->match_stack_limit)\n        return ONIGERR_MATCH_STACK_LIMIT_OVER;\n      else\n        n = msa->match_stack_limit;\n    }\n    new_alloc_base = (char* )xrealloc(alloc_base, new_size);\n    if (IS_NULL(new_alloc_base)) {\n      STACK_SAVE;\n      return ONIGERR_MEMORY;\n    }\n  }\n\n  alloc_base = new_alloc_base;\n  used = (int )(stk - stk_base);\n  *arg_alloc_base = alloc_base;\n  *arg_stk_base   = (StackType* )(alloc_base\n                                  + (sizeof(StackIndex) * msa->ptr_num));\n  *arg_stk      = *arg_stk_base + used;\n  *arg_stk_end  = *arg_stk_base + n;\n  return 0;\n}\n\n#define STACK_ENSURE(n) do {\\\n    if ((int )(stk_end - stk) < (n)) {\\\n    int r = stack_double(is_alloca, &alloc_base, &stk_base, &stk_end, &stk, msa);\\\n    if (r != 0) { STACK_SAVE; return r; } \\\n    is_alloca = 0;\\\n    UPDATE_FOR_STACK_REALLOC;\\\n  }\\\n} while(0)\n\n#define STACK_AT(index)        (stk_base + (index))\n#define GET_STACK_INDEX(stk)   ((stk) - stk_base)\n\n#define STACK_PUSH_TYPE(stack_type) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  STACK_INC;\\\n} while(0)\n\n#define IS_TO_VOID_TARGET(stk) (((stk)->type & STK_MASK_TO_VOID_TARGET) != 0)\n\n#define STACK_PUSH(stack_type,pat,s,sprev) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode     = (pat);\\\n  stk->u.state.pstr      = (s);\\\n  stk->u.state.pstr_prev = (sprev);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_ENSURED(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  STACK_INC;\\\n} while(0)\n\n#ifdef ONIG_DEBUG_MATCH\n#define STACK_PUSH_BOTTOM(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  stk->u.state.pstr      = s;\\\n  stk->u.state.pstr_prev = sprev;\\\n  STACK_INC;\\\n} while (0)\n#else\n#define STACK_PUSH_BOTTOM(stack_type,pat) do {\\\n  stk->type = (stack_type);\\\n  stk->u.state.pcode = (pat);\\\n  STACK_INC;\\\n} while (0)\n#endif\n\n#define STACK_PUSH_ALT(pat,s,sprev)       STACK_PUSH(STK_ALT,pat,s,sprev)\n#define STACK_PUSH_SUPER_ALT(pat,s,sprev) STACK_PUSH(STK_SUPER_ALT,pat,s,sprev)\n#define STACK_PUSH_PREC_READ_START(s,sprev) \\\n  STACK_PUSH(STK_PREC_READ_START,(Operation* )0,s,sprev)\n#define STACK_PUSH_ALT_PREC_READ_NOT(pat,s,sprev) \\\n  STACK_PUSH(STK_ALT_PREC_READ_NOT,pat,s,sprev)\n#define STACK_PUSH_TO_VOID_START        STACK_PUSH_TYPE(STK_TO_VOID_START)\n#define STACK_PUSH_ALT_LOOK_BEHIND_NOT(pat,s,sprev) \\\n  STACK_PUSH(STK_ALT_LOOK_BEHIND_NOT,pat,s,sprev)\n\n#define STACK_PUSH_REPEAT(sid, pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT;\\\n  stk->zid  = (sid);\\\n  stk->u.repeat.pcode  = (pat);\\\n  stk->u.repeat.count  = 0;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_REPEAT_INC(sindex) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_REPEAT_INC;\\\n  stk->u.repeat_inc.si  = (sindex);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_START(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_START;\\\n  stk->zid  = (mnum);\\\n  stk->u.mem.pstr       = (s);\\\n  stk->u.mem.prev_start = mem_start_stk[mnum];\\\n  stk->u.mem.prev_end   = mem_end_stk[mnum];\\\n  mem_start_stk[mnum]   = GET_STACK_INDEX(stk);\\\n  mem_end_stk[mnum]     = INVALID_STACK_INDEX;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END(mnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END;\\\n  stk->zid  = (mnum);\\\n  stk->u.mem.pstr       = (s);\\\n  stk->u.mem.prev_start = mem_start_stk[mnum];\\\n  stk->u.mem.prev_end   = mem_end_stk[mnum];\\\n  mem_end_stk[mnum] = GET_STACK_INDEX(stk);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_MEM_END_MARK(mnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_MEM_END_MARK;\\\n  stk->zid  = (mnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_GET_MEM_START(mnum, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    if ((k->type & STK_MASK_MEM_END_OR_MARK) != 0 \\\n      && k->zid == (mnum)) {\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_START && k->zid == (mnum)) {\\\n      if (level == 0) break;\\\n      level--;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_MEM_RANGE(k, mnum, start, end) do {\\\n  int level = 0;\\\n  while (k < stk) {\\\n    if (k->type == STK_MEM_START && k->u.mem.num == (mnum)) {\\\n      if (level == 0) (start) = k->u.mem.pstr;\\\n      level++;\\\n    }\\\n    else if (k->type == STK_MEM_END && k->u.mem.num == (mnum)) {\\\n      level--;\\\n      if (level == 0) {\\\n        (end) = k->u.mem.pstr;\\\n        break;\\\n      }\\\n    }\\\n    k++;\\\n  }\\\n} while(0)\n\n#define STACK_PUSH_EMPTY_CHECK_START(cnum, s) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_EMPTY_CHECK_START;\\\n  stk->zid  = (cnum);\\\n  stk->u.empty_check.pstr = (s);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_EMPTY_CHECK_END(cnum) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_EMPTY_CHECK_END;\\\n  stk->zid  = (cnum);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_CALL_FRAME(pat) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALL_FRAME;\\\n  stk->u.call_frame.ret_addr = (pat);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_RETURN do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_RETURN;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_SAVE_VAL(sid, stype, sval) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_SAVE_VAL;\\\n  stk->zid  = (sid);\\\n  stk->u.val.type = (stype);\\\n  stk->u.val.v    = (UChar* )(sval);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_SAVE_VAL_WITH_SPREV(sid, stype, sval) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_SAVE_VAL;\\\n  stk->zid  = (sid);\\\n  stk->u.val.type = (stype);\\\n  stk->u.val.v    = (UChar* )(sval);\\\n  stk->u.val.v2   = sprev;\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST(stype, sval) do {\\\n  StackType *k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)) {\\\n      (sval) = k->u.val.v;\\\n      break;\\\n    }\\\n  }\\\n} while (0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST_ID(stype, sid, sval) do { \\\n  int level = 0;\\\n  StackType *k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST_ID\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)\\\n        && k->zid == (sid)) {\\\n      if (level == 0) {\\\n        (sval) = k->u.val.v;\\\n        break;\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME)\\\n      level--;\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while (0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST_ID_WITH_SPREV(stype, sid, sval) do { \\\n  int level = 0;\\\n  StackType *k = stk;\\\n  while (k > stk_base) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST_ID\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)\\\n        && k->zid == (sid)) {\\\n      if (level == 0) {\\\n        (sval) = k->u.val.v;\\\n        sprev  = k->u.val.v2;\\\n        break;\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME)\\\n      level--;\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while (0)\n\n#define STACK_GET_SAVE_VAL_TYPE_LAST_ID_FROM(stype, sid, sval, stk_from) do { \\\n  int level = 0;\\\n  StackType *k = (stk_from);\\\n  while (k > stk_base) {\\\n    STACK_BASE_CHECK(k, \"STACK_GET_SAVE_VAL_TYPE_LAST_ID_FROM\"); \\\n    if (k->type == STK_SAVE_VAL && k->u.val.type == (stype)\\\n        && k->u.val.id == (sid)) {\\\n      if (level == 0) {\\\n        (sval) = k->u.val.v;\\\n        break;\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME)\\\n      level--;\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n    k--;\\\n  }\\\n} while (0)\n\n#define STACK_PUSH_CALLOUT_CONTENTS(anum, func) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALLOUT;\\\n  stk->zid  = ONIG_NON_NAME_ID;\\\n  stk->u.callout.num = (anum);\\\n  stk->u.callout.func = (func);\\\n  STACK_INC;\\\n} while(0)\n\n#define STACK_PUSH_CALLOUT_NAME(aid, anum, func) do {\\\n  STACK_ENSURE(1);\\\n  stk->type = STK_CALLOUT;\\\n  stk->zid  = (aid);\\\n  stk->u.callout.num = (anum);\\\n  stk->u.callout.func = (func);\\\n  STACK_INC;\\\n} while(0)\n\n#ifdef ONIG_DEBUG\n#define STACK_BASE_CHECK(p, at) \\\n  if ((p) < stk_base) {\\\n    fprintf(stderr, \"at %s\\n\", at);\\\n    goto stack_error;\\\n  }\n#else\n#define STACK_BASE_CHECK(p, at)\n#endif\n\n#define STACK_POP_ONE do {\\\n  stk--;\\\n  STACK_BASE_CHECK(stk, \"STACK_POP_ONE\"); \\\n} while(0)\n\n\n#ifdef USE_CALLOUT\n#define POP_CALLOUT_CASE \\\n  else if (stk->type == STK_CALLOUT) {\\\n    RETRACTION_CALLOUT(stk->u.callout.func, stk->zid, stk->u.callout.num, msa->mp->callout_user_data);\\\n  }\n#else\n#define POP_CALLOUT_CASE\n#endif\n\n#define STACK_POP  do {\\\n  switch (pop_level) {\\\n  case STACK_POP_LEVEL_FREE:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n    }\\\n    break;\\\n  case STACK_POP_LEVEL_MEM_START:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 2\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if (stk->type == STK_MEM_START) {\\\n        mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n        mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n      }\\\n    }\\\n    break;\\\n  default:\\\n    while (1) {\\\n      stk--;\\\n      STACK_BASE_CHECK(stk, \"STACK_POP 3\"); \\\n      if ((stk->type & STK_MASK_POP_USED) != 0)  break;\\\n      else if ((stk->type & STK_MASK_POP_HANDLED) != 0) {\\\n        if (stk->type == STK_MEM_START) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        else if (stk->type == STK_REPEAT_INC) {\\\n          STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n        }\\\n        else if (stk->type == STK_MEM_END) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        POP_CALLOUT_CASE\\\n      }\\\n    }\\\n    break;\\\n  }\\\n} while(0)\n\n#define POP_TIL_BODY(aname, til_type) do {\\\n  while (1) {\\\n    stk--;\\\n    STACK_BASE_CHECK(stk, (aname));\\\n    if ((stk->type & STK_MASK_POP_HANDLED_TIL) != 0) {\\\n      if (stk->type == (til_type)) break;\\\n      else {\\\n        if (stk->type == STK_MEM_START) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        else if (stk->type == STK_REPEAT_INC) {\\\n          STACK_AT(stk->u.repeat_inc.si)->u.repeat.count--;\\\n        }\\\n        else if (stk->type == STK_MEM_END) {\\\n          mem_start_stk[stk->zid] = stk->u.mem.prev_start;\\\n          mem_end_stk[stk->zid]   = stk->u.mem.prev_end;\\\n        }\\\n        /* Don't call callout here because negation of total success by (?!..) (?<!..) */\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_POP_TIL_ALT_PREC_READ_NOT  do {\\\n  POP_TIL_BODY(\"STACK_POP_TIL_ALT_PREC_READ_NOT\", STK_ALT_PREC_READ_NOT);\\\n} while(0)\n\n#define STACK_POP_TIL_ALT_LOOK_BEHIND_NOT  do {\\\n  POP_TIL_BODY(\"STACK_POP_TIL_ALT_LOOK_BEHIND_NOT\", STK_ALT_LOOK_BEHIND_NOT);\\\n} while(0)\n\n\n#define STACK_EXEC_TO_VOID(k) do {\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EXEC_TO_VOID\"); \\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      if (k->type == STK_TO_VOID_START) {\\\n        k->type = STK_VOID;\\\n        break;\\\n      }\\\n      k->type = STK_VOID;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_GET_PREC_READ_START(k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_PREC_READ_START\");\\\n    if (IS_TO_VOID_TARGET(k)) {\\\n      k->type = STK_VOID;\\\n    }\\\n    else if (k->type == STK_PREC_READ_START) {\\\n      if (level == 0) {\\\n        break;\\\n      }\\\n      level--;\\\n    }\\\n    else if (k->type == STK_PREC_READ_END) {\\\n      level++;\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_EMPTY_CHECK(isnull,sid,s) do {\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK\"); \\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->zid == (sid)) {\\\n        (isnull) = (k->u.empty_check.pstr == (s));\\\n        break;\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_MEM_START_GET_PREV_END_ADDR(k /* STK_MEM_START*/, reg, addr) do {\\\n  if (k->u.mem.prev_end == INVALID_STACK_INDEX) {\\\n    (addr) = 0;\\\n  }\\\n  else {\\\n    if (MEM_STATUS_AT((reg)->bt_mem_end, k->zid))\\\n      (addr) = STACK_AT(k->u.mem.prev_end)->u.mem.pstr;\\\n    else\\\n      (addr) = (UChar* )k->u.mem.prev_end;\\\n  }\\\n} while (0)\n\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n#define STACK_EMPTY_CHECK_MEM(isnull,sid,s,reg) do {\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK_MEM\"); \\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->zid == (sid)) {\\\n        if (k->u.empty_check.pstr != (s)) {\\\n          (isnull) = 0;\\\n          break;\\\n        }\\\n        else {\\\n          UChar* endp;\\\n          int level = 0;\\\n          (isnull) = 1;\\\n          while (k < stk) {\\\n            if (k->type == STK_MEM_START && level == 0) {\\\n              STACK_MEM_START_GET_PREV_END_ADDR(k, reg, endp);\\\n              if (endp == 0) {\\\n                (isnull) = 0; break;\\\n              }\\\n              else if (STACK_AT(k->u.mem.prev_start)->u.mem.pstr != endp) {\\\n                (isnull) = 0; break;\\\n              }\\\n              else if (endp != s) {\\\n                (isnull) = -1; /* empty, but position changed */ \\\n              }\\\n            }\\\n            else if (k->type == STK_PREC_READ_START) {\\\n              level++;\\\n            }\\\n            else if (k->type == STK_PREC_READ_END) {\\\n              level--;\\\n            }\\\n            k++;\\\n          }\\\n          break;\\\n        }\\\n      }\\\n    }\\\n  }\\\n} while(0)\n\n#define STACK_EMPTY_CHECK_MEM_REC(isnull,sid,s,reg) do {\\\n  int level = 0;\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK_MEM_REC\");\\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->zid == (sid)) {\\\n        if (level == 0) {\\\n          if (k->u.empty_check.pstr != (s)) {\\\n            (isnull) = 0;\\\n            break;\\\n          }\\\n          else {\\\n            UChar* endp;\\\n            int prec_level = 0;\\\n            (isnull) = 1;\\\n            while (k < stk) {\\\n              if (k->type == STK_MEM_START) {\\\n                if (level == 0 && prec_level == 0) {\\\n                  STACK_MEM_START_GET_PREV_END_ADDR(k, reg, endp);\\\n                  if (endp == 0) {\\\n                    (isnull) = 0; break;\\\n                  }\\\n                  else if (STACK_AT(k->u.mem.prev_start)->u.mem.pstr != endp) { \\\n                    (isnull) = 0; break;\\\n                  }\\\n                  else if (endp != s) {\\\n                    (isnull) = -1; /* empty, but position changed */\\\n                  }\\\n                }\\\n              }\\\n              else if (k->type == STK_EMPTY_CHECK_START) {\\\n                if (k->zid == (sid)) level++;\\\n              }\\\n              else if (k->type == STK_EMPTY_CHECK_END) {\\\n                if (k->zid == (sid)) level--;\\\n              }\\\n              else if (k->type == STK_PREC_READ_START) {\\\n                prec_level++;\\\n              }\\\n              else if (k->type == STK_PREC_READ_END) {\\\n                prec_level--;\\\n              }\\\n              k++;\\\n            }\\\n            break;\\\n          }\\\n        }\\\n        else {\\\n          level--;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_EMPTY_CHECK_END) {\\\n      if (k->zid == (sid)) level++;\\\n    }\\\n  }\\\n} while(0)\n#else\n#define STACK_EMPTY_CHECK_REC(isnull,id,s) do {\\\n  int level = 0;\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_EMPTY_CHECK_REC\"); \\\n    if (k->type == STK_EMPTY_CHECK_START) {\\\n      if (k->u.empty_check.num == (id)) {\\\n        if (level == 0) {\\\n          (isnull) = (k->u.empty_check.pstr == (s));\\\n          break;\\\n        }\\\n      }\\\n      level--;\\\n    }\\\n    else if (k->type == STK_EMPTY_CHECK_END) {\\\n      level++;\\\n    }\\\n  }\\\n} while(0)\n#endif /* USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT */\n\n#define STACK_GET_REPEAT(sid, k) do {\\\n  int level = 0;\\\n  k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_GET_REPEAT\"); \\\n    if (k->type == STK_REPEAT) {\\\n      if (level == 0) {\\\n        if (k->zid == (sid)) {\\\n          break;\\\n        }\\\n      }\\\n    }\\\n    else if (k->type == STK_CALL_FRAME) level--;\\\n    else if (k->type == STK_RETURN)     level++;\\\n  }\\\n} while(0)\n\n#define STACK_RETURN(addr)  do {\\\n  int level = 0;\\\n  StackType* k = stk;\\\n  while (1) {\\\n    k--;\\\n    STACK_BASE_CHECK(k, \"STACK_RETURN\"); \\\n    if (k->type == STK_CALL_FRAME) {\\\n      if (level == 0) {\\\n        (addr) = k->u.call_frame.ret_addr;\\\n        break;\\\n      }\\\n      else level--;\\\n    }\\\n    else if (k->type == STK_RETURN)\\\n      level++;\\\n  }\\\n} while(0)\n\n\n#define STRING_CMP(s1,s2,len) do {\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) goto fail;\\\n  }\\\n} while(0)\n\n#define STRING_CMP_IC(case_fold_flag,s1,ps2,len) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    goto fail; \\\n} while(0)\n\nstatic int string_cmp_ic(OnigEncoding enc, int case_fold_flag,\n                         UChar* s1, UChar** ps2, int mblen)\n{\n  UChar buf1[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar buf2[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n  UChar *p1, *p2, *end1, *s2, *end2;\n  int len1, len2;\n\n  s2   = *ps2;\n  end1 = s1 + mblen;\n  end2 = s2 + mblen;\n  while (s1 < end1) {\n    len1 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s1, end1, buf1);\n    len2 = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &s2, end2, buf2);\n    if (len1 != len2) return 0;\n    p1 = buf1;\n    p2 = buf2;\n    while (len1-- > 0) {\n      if (*p1 != *p2) return 0;\n      p1++;\n      p2++;\n    }\n  }\n\n  *ps2 = s2;\n  return 1;\n}\n\n#define STRING_CMP_VALUE(s1,s2,len,is_fail) do {\\\n  is_fail = 0;\\\n  while (len-- > 0) {\\\n    if (*s1++ != *s2++) {\\\n      is_fail = 1; break;\\\n    }\\\n  }\\\n} while(0)\n\n#define STRING_CMP_VALUE_IC(case_fold_flag,s1,ps2,len,is_fail) do {\\\n  if (string_cmp_ic(encode, case_fold_flag, s1, ps2, len) == 0) \\\n    is_fail = 1; \\\n  else \\\n    is_fail = 0; \\\n} while(0)\n\n\n#define IS_EMPTY_STR           (str == end)\n#define ON_STR_BEGIN(s)        ((s) == str)\n#define ON_STR_END(s)          ((s) == end)\n#define DATA_ENSURE_CHECK1     (s < right_range)\n#define DATA_ENSURE_CHECK(n)   (s + (n) <= right_range)\n#define DATA_ENSURE(n)         if (s + (n) > right_range) goto fail\n\n#define INIT_RIGHT_RANGE    right_range = (UChar* )in_right_range\n\n#ifdef USE_CAPTURE_HISTORY\nstatic int\nmake_capture_history_tree(OnigCaptureTreeNode* node, StackType** kp,\n                          StackType* stk_top, UChar* str, regex_t* reg)\n{\n  int n, r;\n  OnigCaptureTreeNode* child;\n  StackType* k = *kp;\n\n  while (k < stk_top) {\n    if (k->type == STK_MEM_START) {\n      n = k->zid;\n      if (n <= ONIG_MAX_CAPTURE_HISTORY_GROUP &&\n          MEM_STATUS_AT(reg->capture_history, n) != 0) {\n        child = history_node_new();\n        CHECK_NULL_RETURN_MEMERR(child);\n        child->group = n;\n        child->beg = (int )(k->u.mem.pstr - str);\n        r = history_tree_add_child(node, child);\n        if (r != 0) return r;\n        *kp = (k + 1);\n        r = make_capture_history_tree(child, kp, stk_top, str, reg);\n        if (r != 0) return r;\n\n        k = *kp;\n        child->end = (int )(k->u.mem.pstr - str);\n      }\n    }\n    else if (k->type == STK_MEM_END) {\n      if (k->zid == node->group) {\n        node->end = (int )(k->u.mem.pstr - str);\n        *kp = k;\n        return 0;\n      }\n    }\n    k++;\n  }\n\n  return 1; /* 1: root node ending. */\n}\n#endif\n\n#ifdef USE_BACKREF_WITH_LEVEL\nstatic int mem_is_in_memp(int mem, int num, MemNumType* memp)\n{\n  int i;\n\n  for (i = 0; i < num; i++) {\n    if (mem == (int )memp[i]) return 1;\n  }\n  return 0;\n}\n\nstatic int\nbackref_match_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int ignore_case, int case_fold_flag,\n                              int nest, int mem_num, MemNumType* memp,\n                              UChar** s, const UChar* send)\n{\n  UChar *ss, *p, *pstart, *pend = NULL_UCHARP;\n  int level;\n  StackType* k;\n\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_START) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pstart = k->u.mem.pstr;\n          if (IS_NOT_NULL(pend)) {\n            if (pend - pstart > send - *s) return 0; /* or goto next_mem; */\n            p  = pstart;\n            ss = *s;\n\n            if (ignore_case != 0) {\n              if (string_cmp_ic(reg->enc, case_fold_flag,\n                                pstart, &ss, (int )(pend - pstart)) == 0)\n                return 0; /* or goto next_mem; */\n            }\n            else {\n              while (p < pend) {\n                if (*p++ != *ss++) return 0; /* or goto next_mem; */\n              }\n            }\n\n            *s = ss;\n            return 1;\n          }\n        }\n      }\n      else if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          pend = k->u.mem.pstr;\n        }\n      }\n    }\n    k--;\n  }\n\n  return 0;\n}\n\nstatic int\nbackref_check_at_nested_level(regex_t* reg,\n                              StackType* top, StackType* stk_base,\n                              int nest, int mem_num, MemNumType* memp)\n{\n  int level;\n  StackType* k;\n\n  level = 0;\n  k = top;\n  k--;\n  while (k >= stk_base) {\n    if (k->type == STK_CALL_FRAME) {\n      level--;\n    }\n    else if (k->type == STK_RETURN) {\n      level++;\n    }\n    else if (level == nest) {\n      if (k->type == STK_MEM_END) {\n        if (mem_is_in_memp(k->zid, mem_num, memp)) {\n          return 1;\n        }\n      }\n    }\n    k--;\n  }\n\n  return 0;\n}\n#endif /* USE_BACKREF_WITH_LEVEL */\n\n\n#ifdef ONIG_DEBUG_STATISTICS\n\n#define USE_TIMEOFDAY\n\n#ifdef USE_TIMEOFDAY\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\nstatic struct timeval ts, te;\n#define GETTIME(t)        gettimeofday(&(t), (struct timezone* )0)\n#define TIMEDIFF(te,ts)   (((te).tv_usec - (ts).tv_usec) + \\\n                           (((te).tv_sec - (ts).tv_sec)*1000000))\n#else\n#ifdef HAVE_SYS_TIMES_H\n#include <sys/times.h>\n#endif\nstatic struct tms ts, te;\n#define GETTIME(t)         times(&(t))\n#define TIMEDIFF(te,ts)   ((te).tms_utime - (ts).tms_utime)\n#endif\n\nstatic int OpCounter[256];\nstatic int OpPrevCounter[256];\nstatic unsigned long OpTime[256];\nstatic int OpCurr = OP_FINISH;\nstatic int OpPrevTarget = OP_FAIL;\nstatic int MaxStackDepth = 0;\n\n#define SOP_IN(opcode) do {\\\n  if (opcode == OpPrevTarget) OpPrevCounter[OpCurr]++;\\\n  OpCurr = opcode;\\\n  OpCounter[opcode]++;\\\n  GETTIME(ts);\\\n} while(0)\n\n#define SOP_OUT do {\\\n  GETTIME(te);\\\n  OpTime[OpCurr] += TIMEDIFF(te, ts);\\\n} while(0)\n\nextern void\nonig_statistics_init(void)\n{\n  int i;\n  for (i = 0; i < 256; i++) {\n    OpCounter[i] = OpPrevCounter[i] = 0; OpTime[i] = 0;\n  }\n  MaxStackDepth = 0;\n}\n\nextern int\nonig_print_statistics(FILE* f)\n{\n  int r;\n  int i;\n\n  r = fprintf(f, \"   count      prev        time\\n\");\n  if (r < 0) return -1;\n\n  for (i = 0; OpInfo[i].opcode >= 0; i++) {\n    r = fprintf(f, \"%8d: %8d: %10ld: %s\\n\",\n                OpCounter[i], OpPrevCounter[i], OpTime[i], OpInfo[i].name);\n    if (r < 0) return -1;\n  }\n  r = fprintf(f, \"\\nmax stack depth: %d\\n\", MaxStackDepth);\n  if (r < 0) return -1;\n\n  return 0;\n}\n\n#define STACK_INC do {\\\n  stk++;\\\n  if (stk - stk_base > MaxStackDepth) \\\n    MaxStackDepth = stk - stk_base;\\\n} while(0)\n\n#else\n#define STACK_INC     stk++\n\n#define SOP_IN(opcode)\n#define SOP_OUT\n#endif\n\n\n/* matching region of POSIX API */\ntypedef int regoff_t;\n\ntypedef struct {\n  regoff_t  rm_so;\n  regoff_t  rm_eo;\n} posix_regmatch_t;\n\n\n\n#ifdef USE_THREADED_CODE\n\n#define BYTECODE_INTERPRETER_START      GOTO_OP;\n#define BYTECODE_INTERPRETER_END\n#define CASE_OP(x)   L_##x: SOP_IN(OP_##x); sbegin = s; MATCH_DEBUG_OUT(0)\n#define DEFAULT_OP   /* L_DEFAULT: */\n#define NEXT_OP      sprev = sbegin; JUMP_OP\n#define JUMP_OP      GOTO_OP\n#ifdef USE_DIRECT_THREADED_CODE\n#define GOTO_OP      goto *(p->opaddr)\n#else\n#define GOTO_OP      goto *opcode_to_label[p->opcode]\n#endif\n#define BREAK_OP     /* Nothing */\n\n#else\n\n#define BYTECODE_INTERPRETER_START \\\n  while (1) {\\\n  MATCH_DEBUG_OUT(0)\\\n  sbegin = s;\\\n  switch (p->opcode) {\n#define BYTECODE_INTERPRETER_END  } sprev = sbegin; }\n#define CASE_OP(x)   case OP_##x: SOP_IN(OP_##x);\n#define DEFAULT_OP   default:\n#define NEXT_OP      break\n#define JUMP_OP      GOTO_OP\n#define GOTO_OP      continue; break\n#define BREAK_OP     break\n\n#endif /* USE_THREADED_CODE */\n\n#define INC_OP       p++\n#define NEXT_OUT     SOP_OUT; NEXT_OP\n#define JUMP_OUT     SOP_OUT; JUMP_OP\n#define BREAK_OUT    SOP_OUT; BREAK_OP\n#define CHECK_INTERRUPT_JUMP_OUT  SOP_OUT; CHECK_INTERRUPT_IN_MATCH; JUMP_OP\n\n\n#ifdef ONIG_DEBUG_MATCH\n#define MATCH_DEBUG_OUT(offset) do {\\\n      Operation *xp;\\\n      UChar *q, *bp, buf[50];\\\n      int len, spos;\\\n      spos = IS_NOT_NULL(s) ? (int )(s - str) : -1;\\\n      xp = p - (offset);\\\n      fprintf(stderr, \"%7u: %7ld: %4d> \\\"\",\\\n              counter, GET_STACK_INDEX(stk), spos);\\\n      counter++;\\\n      bp = buf;\\\n      if (IS_NOT_NULL(s)) {\\\n        for (i = 0, q = s; i < 7 && q < end; i++) {\\\n          len = enclen(encode, q);\\\n          while (len-- > 0) *bp++ = *q++;\\\n        }\\\n        if (q < end) { xmemcpy(bp, \"...\\\"\", 4); bp += 4; }\\\n        else         { xmemcpy(bp, \"\\\"\",    1); bp += 1; }\\\n      }\\\n      else {\\\n        xmemcpy(bp, \"\\\"\", 1); bp += 1;\\\n      }\\\n      *bp = 0;\\\n      fputs((char* )buf, stderr);\\\n      for (i = 0; i < 20 - (bp - buf); i++) fputc(' ', stderr);\\\n      if (xp == FinishCode)\\\n        fprintf(stderr, \"----: finish\");\\\n      else {\\\n        fprintf(stderr, \"%4d: \", (int )(xp - reg->ops));\\\n        print_compiled_byte_code(stderr, reg, (int )(xp - reg->ops), reg->ops, encode);\\\n      }\\\n      fprintf(stderr, \"\\n\");\\\n  } while(0);\n#else\n#define MATCH_DEBUG_OUT(offset)\n#endif\n\n\n/* match data(str - end) from position (sstart). */\n/* if sstart == str then set sprev to NULL. */\nstatic int\nmatch_at(regex_t* reg, const UChar* str, const UChar* end,\n         const UChar* in_right_range, const UChar* sstart, UChar* sprev,\n         MatchArg* msa)\n{\n\n#if defined(USE_DIRECT_THREADED_CODE)\n  static Operation FinishCode[] = { { .opaddr=&&L_FINISH } };\n#else\n  static Operation FinishCode[] = { { OP_FINISH } };\n#endif\n\n#ifdef USE_THREADED_CODE\n  static const void *opcode_to_label[] = {\n  &&L_FINISH,\n  &&L_END,\n  &&L_EXACT1,\n  &&L_EXACT2,\n  &&L_EXACT3,\n  &&L_EXACT4,\n  &&L_EXACT5,\n  &&L_EXACTN,\n  &&L_EXACTMB2N1,\n  &&L_EXACTMB2N2,\n  &&L_EXACTMB2N3,\n  &&L_EXACTMB2N,\n  &&L_EXACTMB3N,\n  &&L_EXACTMBN,\n  &&L_EXACT1_IC,\n  &&L_EXACTN_IC,\n  &&L_CCLASS,\n  &&L_CCLASS_MB,\n  &&L_CCLASS_MIX,\n  &&L_CCLASS_NOT,\n  &&L_CCLASS_MB_NOT,\n  &&L_CCLASS_MIX_NOT,\n  &&L_ANYCHAR,\n  &&L_ANYCHAR_ML,\n  &&L_ANYCHAR_STAR,\n  &&L_ANYCHAR_ML_STAR,\n  &&L_ANYCHAR_STAR_PEEK_NEXT,\n  &&L_ANYCHAR_ML_STAR_PEEK_NEXT,\n  &&L_WORD,\n  &&L_WORD_ASCII,\n  &&L_NO_WORD,\n  &&L_NO_WORD_ASCII,\n  &&L_WORD_BOUNDARY,\n  &&L_NO_WORD_BOUNDARY,\n  &&L_WORD_BEGIN,\n  &&L_WORD_END,\n  &&L_TEXT_SEGMENT_BOUNDARY,\n  &&L_BEGIN_BUF,\n  &&L_END_BUF,\n  &&L_BEGIN_LINE,\n  &&L_END_LINE,\n  &&L_SEMI_END_BUF,\n  &&L_BEGIN_POSITION,\n  &&L_BACKREF1,\n  &&L_BACKREF2,\n  &&L_BACKREF_N,\n  &&L_BACKREF_N_IC,\n  &&L_BACKREF_MULTI,\n  &&L_BACKREF_MULTI_IC,\n  &&L_BACKREF_WITH_LEVEL,\n  &&L_BACKREF_WITH_LEVEL_IC,\n  &&L_BACKREF_CHECK,\n  &&L_BACKREF_CHECK_WITH_LEVEL,\n  &&L_MEMORY_START,\n  &&L_MEMORY_START_PUSH,\n  &&L_MEMORY_END_PUSH,\n  &&L_MEMORY_END_PUSH_REC,\n  &&L_MEMORY_END,\n  &&L_MEMORY_END_REC,\n  &&L_FAIL,\n  &&L_JUMP,\n  &&L_PUSH,\n  &&L_PUSH_SUPER,\n  &&L_POP_OUT,\n#ifdef USE_OP_PUSH_OR_JUMP_EXACT\n  &&L_PUSH_OR_JUMP_EXACT1,\n#endif\n  &&L_PUSH_IF_PEEK_NEXT,\n  &&L_REPEAT,\n  &&L_REPEAT_NG,\n  &&L_REPEAT_INC,\n  &&L_REPEAT_INC_NG,\n  &&L_REPEAT_INC_SG,\n  &&L_REPEAT_INC_NG_SG,\n  &&L_EMPTY_CHECK_START,\n  &&L_EMPTY_CHECK_END,\n  &&L_EMPTY_CHECK_END_MEMST,\n  &&L_EMPTY_CHECK_END_MEMST_PUSH,\n  &&L_PREC_READ_START,\n  &&L_PREC_READ_END,\n  &&L_PREC_READ_NOT_START,\n  &&L_PREC_READ_NOT_END,\n  &&L_ATOMIC_START,\n  &&L_ATOMIC_END,\n  &&L_LOOK_BEHIND,\n  &&L_LOOK_BEHIND_NOT_START,\n  &&L_LOOK_BEHIND_NOT_END,\n  &&L_CALL,\n  &&L_RETURN,\n  &&L_PUSH_SAVE_VAL,\n  &&L_UPDATE_VAR,\n#ifdef USE_CALLOUT\n  &&L_CALLOUT_CONTENTS,\n  &&L_CALLOUT_NAME,\n#endif\n  };\n#endif\n\n  int i, n, num_mem, best_len, pop_level;\n  LengthType tlen, tlen2;\n  MemNumType mem;\n  RelAddrType addr;\n  UChar *s, *q, *ps, *sbegin;\n  UChar *right_range;\n  int is_alloca;\n  char *alloc_base;\n  StackType *stk_base, *stk, *stk_end;\n  StackType *stkp; /* used as any purpose. */\n  StackIndex si;\n  StackIndex *repeat_stk;\n  StackIndex *mem_start_stk, *mem_end_stk;\n  UChar* keep;\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  unsigned long retry_limit_in_match;\n  unsigned long retry_in_match_counter;\n#endif\n\n#ifdef USE_CALLOUT\n  int of;\n#endif\n\n  Operation* p = reg->ops;\n  OnigOptionType option = reg->options;\n  OnigEncoding encode = reg->enc;\n  OnigCaseFoldType case_fold_flag = reg->case_fold_flag;\n\n#ifdef ONIG_DEBUG_MATCH\n  static unsigned int counter = 1;\n#endif\n\n#ifdef USE_DIRECT_THREADED_CODE\n  if (IS_NULL(msa)) {\n    for (i = 0; i < reg->ops_used; i++) {\n       const void* addr;\n       addr = opcode_to_label[reg->ocs[i]];\n       p->opaddr = addr;\n       p++;\n    }\n    return ONIG_NORMAL;\n  }\n#endif\n\n#ifdef USE_CALLOUT\n  msa->mp->match_at_call_counter++;\n#endif\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  retry_limit_in_match = msa->retry_limit_in_match;\n#endif\n\n  pop_level = reg->stack_pop_level;\n  num_mem = reg->num_mem;\n  STACK_INIT(INIT_MATCH_STACK_SIZE);\n  UPDATE_FOR_STACK_REALLOC;\n  for (i = 1; i <= num_mem; i++) {\n    mem_start_stk[i] = mem_end_stk[i] = INVALID_STACK_INDEX;\n  }\n\n#ifdef ONIG_DEBUG_MATCH\n  fprintf(stderr, \"match_at: str: %p, end: %p, start: %p, sprev: %p\\n\",\n          str, end, sstart, sprev);\n  fprintf(stderr, \"size: %d, start offset: %d\\n\",\n          (int )(end - str), (int )(sstart - str));\n#endif\n\n  best_len = ONIG_MISMATCH;\n  keep = s = (UChar* )sstart;\n  STACK_PUSH_BOTTOM(STK_ALT, FinishCode);  /* bottom stack */\n  INIT_RIGHT_RANGE;\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n  retry_in_match_counter = 0;\n#endif\n\n  BYTECODE_INTERPRETER_START {\n    CASE_OP(END)\n      n = (int )(s - sstart);\n      if (n > best_len) {\n        OnigRegion* region;\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n        if (IS_FIND_LONGEST(option)) {\n          if (n > msa->best_len) {\n            msa->best_len = n;\n            msa->best_s   = (UChar* )sstart;\n          }\n          else\n            goto end_best_len;\n        }\n#endif\n        best_len = n;\n        region = msa->region;\n        if (region) {\n          if (keep > s) keep = s;\n\n#ifdef USE_POSIX_API_REGION_OPTION\n          if (IS_POSIX_REGION(msa->options)) {\n            posix_regmatch_t* rmt = (posix_regmatch_t* )region;\n\n            rmt[0].rm_so = (regoff_t )(keep - str);\n            rmt[0].rm_eo = (regoff_t )(s    - str);\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (MEM_STATUS_AT(reg->bt_mem_start, i))\n                  rmt[i].rm_so = (regoff_t )(STACK_AT(mem_start_stk[i])->u.mem.pstr - str);\n                else\n                  rmt[i].rm_so = (regoff_t )((UChar* )((void* )(mem_start_stk[i])) - str);\n\n                rmt[i].rm_eo = (regoff_t )((MEM_STATUS_AT(reg->bt_mem_end, i)\n                                            ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                            : (UChar* )((void* )mem_end_stk[i]))\n                                           - str);\n              }\n              else {\n                rmt[i].rm_so = rmt[i].rm_eo = ONIG_REGION_NOTPOS;\n              }\n            }\n          }\n          else {\n#endif /* USE_POSIX_API_REGION_OPTION */\n            region->beg[0] = (int )(keep - str);\n            region->end[0] = (int )(s    - str);\n            for (i = 1; i <= num_mem; i++) {\n              if (mem_end_stk[i] != INVALID_STACK_INDEX) {\n                if (MEM_STATUS_AT(reg->bt_mem_start, i))\n                  region->beg[i] = (int )(STACK_AT(mem_start_stk[i])->u.mem.pstr - str);\n                else\n                  region->beg[i] = (int )((UChar* )((void* )mem_start_stk[i]) - str);\n\n                region->end[i] = (int )((MEM_STATUS_AT(reg->bt_mem_end, i)\n                                         ? STACK_AT(mem_end_stk[i])->u.mem.pstr\n                                         : (UChar* )((void* )mem_end_stk[i])) - str);\n              }\n              else {\n                region->beg[i] = region->end[i] = ONIG_REGION_NOTPOS;\n              }\n            }\n\n#ifdef USE_CAPTURE_HISTORY\n            if (reg->capture_history != 0) {\n              int r;\n              OnigCaptureTreeNode* node;\n\n              if (IS_NULL(region->history_root)) {\n                region->history_root = node = history_node_new();\n                CHECK_NULL_RETURN_MEMERR(node);\n              }\n              else {\n                node = region->history_root;\n                history_tree_clear(node);\n              }\n\n              node->group = 0;\n              node->beg   = (int )(keep - str);\n              node->end   = (int )(s    - str);\n\n              stkp = stk_base;\n              r = make_capture_history_tree(region->history_root, &stkp,\n                                            stk, (UChar* )str, reg);\n              if (r < 0) {\n                best_len = r; /* error code */\n                goto finish;\n              }\n            }\n#endif /* USE_CAPTURE_HISTORY */\n#ifdef USE_POSIX_API_REGION_OPTION\n          } /* else IS_POSIX_REGION() */\n#endif\n        } /* if (region) */\n      } /* n > best_len */\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n    end_best_len:\n#endif\n      SOP_OUT;\n\n      if (IS_FIND_CONDITION(option)) {\n        if (IS_FIND_NOT_EMPTY(option) && s == sstart) {\n          best_len = ONIG_MISMATCH;\n          goto fail; /* for retry */\n        }\n        if (IS_FIND_LONGEST(option) && DATA_ENSURE_CHECK1) {\n          goto fail; /* for retry */\n        }\n      }\n\n      /* default behavior: return first-matching result. */\n      goto finish;\n\n    CASE_OP(EXACT1)\n      DATA_ENSURE(1);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      s++;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(EXACT1_IC)\n      {\n        int len;\n        UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        DATA_ENSURE(1);\n        len = ONIGENC_MBC_CASE_FOLD(encode,\n                 /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                    case_fold_flag,\n                                    &s, end, lowbuf);\n        DATA_ENSURE(0);\n        q = lowbuf;\n        ps = p->exact.s;\n        while (len-- > 0) {\n          if (*ps != *q) goto fail;\n          ps++; q++;\n        }\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(EXACT2)\n      DATA_ENSURE(2);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACT3)\n      DATA_ENSURE(3);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACT4)\n      DATA_ENSURE(4);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACT5)\n      DATA_ENSURE(5);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      sprev = s;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTN)\n      tlen = p->exact_n.n;\n      DATA_ENSURE(tlen);\n      ps = p->exact_n.s;\n      while (tlen-- > 0) {\n        if (*ps++ != *s++) goto fail;\n      }\n      sprev = s - 1;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTN_IC)\n      {\n        int len;\n        UChar *q, *endp, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n        tlen = p->exact_n.n;\n        ps   = p->exact_n.s;\n        endp = ps + tlen;\n        while (ps < endp) {\n          sprev = s;\n          DATA_ENSURE(1);\n          len = ONIGENC_MBC_CASE_FOLD(encode,\n                        /* DISABLE_CASE_FOLD_MULTI_CHAR(case_fold_flag), */\n                                      case_fold_flag,\n                                      &s, end, lowbuf);\n          DATA_ENSURE(0);\n          q = lowbuf;\n          while (len-- > 0) {\n            if (*ps != *q) goto fail;\n            ps++; q++;\n          }\n        }\n      }\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB2N1)\n      DATA_ENSURE(2);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      s++;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(EXACTMB2N2)\n      DATA_ENSURE(4);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      sprev = s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB2N3)\n      DATA_ENSURE(6);\n      ps = p->exact.s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      sprev = s;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      if (*ps != *s) goto fail;\n      ps++; s++;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB2N)\n      tlen = p->exact_n.n;\n      DATA_ENSURE(tlen * 2);\n      ps = p->exact_n.s;\n      while (tlen-- > 0) {\n        if (*ps != *s) goto fail;\n        ps++; s++;\n        if (*ps != *s) goto fail;\n        ps++; s++;\n      }\n      sprev = s - 2;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMB3N)\n      tlen = p->exact_n.n;\n      DATA_ENSURE(tlen * 3);\n      ps = p->exact_n.s;\n      while (tlen-- > 0) {\n        if (*ps != *s) goto fail;\n        ps++; s++;\n        if (*ps != *s) goto fail;\n        ps++; s++;\n        if (*ps != *s) goto fail;\n        ps++; s++;\n      }\n      sprev = s - 3;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EXACTMBN)\n      tlen  = p->exact_len_n.len; /* mb byte len */\n      tlen2 = p->exact_len_n.n;   /* number of chars */\n      tlen2 *= tlen;\n      DATA_ENSURE(tlen2);\n      ps = p->exact_len_n.s;\n      while (tlen2-- > 0) {\n        if (*ps != *s) goto fail;\n        ps++; s++;\n      }\n      sprev = s - tlen;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(CCLASS)\n      DATA_ENSURE(1);\n      if (BITSET_AT(p->cclass.bsp, *s) == 0) goto fail;\n      s++;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MB)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) goto fail;\n\n    cclass_mb:\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len;\n\n        DATA_ENSURE(1);\n        mb_len = enclen(encode, s);\n        DATA_ENSURE(mb_len);\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (! onig_is_in_code_range(p->cclass_mb.mb, code)) goto fail;\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MIX)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        goto cclass_mb;\n      }\n      else {\n        if (BITSET_AT(p->cclass_mix.bsp, *s) == 0)\n          goto fail;\n\n        s++;\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_NOT)\n      DATA_ENSURE(1);\n      if (BITSET_AT(p->cclass.bsp, *s) != 0) goto fail;\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MB_NOT)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_HEAD(encode, s)) {\n        s++;\n        goto cc_mb_not_success;\n      }\n\n    cclass_mb_not:\n      {\n        OnigCodePoint code;\n        UChar *ss;\n        int mb_len = enclen(encode, s);\n\n        if (! DATA_ENSURE_CHECK(mb_len)) {\n          DATA_ENSURE(1);\n          s = (UChar* )end;\n          goto cc_mb_not_success;\n        }\n\n        ss = s;\n        s += mb_len;\n        code = ONIGENC_MBC_TO_CODE(encode, ss, s);\n        if (onig_is_in_code_range(p->cclass_mb.mb, code)) goto fail;\n      }\n\n    cc_mb_not_success:\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(CCLASS_MIX_NOT)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_HEAD(encode, s)) {\n        goto cclass_mb_not;\n      }\n      else {\n        if (BITSET_AT(p->cclass_mix.bsp, *s) != 0)\n          goto fail;\n\n        s++;\n      }\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR)\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) goto fail;\n      s += n;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR_ML)\n      DATA_ENSURE(1);\n      n = enclen(encode, s);\n      DATA_ENSURE(n);\n      s += n;\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR_STAR)\n      INC_OP;\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        DATA_ENSURE(n);\n        if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n        sprev = s;\n        s += n;\n      }\n      JUMP_OUT;\n\n    CASE_OP(ANYCHAR_ML_STAR)\n      INC_OP;\n      while (DATA_ENSURE_CHECK1) {\n        STACK_PUSH_ALT(p, s, sprev);\n        n = enclen(encode, s);\n        if (n > 1) {\n          DATA_ENSURE(n);\n          sprev = s;\n          s += n;\n        }\n        else {\n          sprev = s;\n          s++;\n        }\n      }\n      JUMP_OUT;\n\n    CASE_OP(ANYCHAR_STAR_PEEK_NEXT)\n      {\n        UChar c;\n\n        c = p->anychar_star_peek_next.c;\n        INC_OP;\n        while (DATA_ENSURE_CHECK1) {\n          if (c == *s) {\n            STACK_PUSH_ALT(p, s, sprev);\n          }\n          n = enclen(encode, s);\n          DATA_ENSURE(n);\n          if (ONIGENC_IS_MBC_NEWLINE(encode, s, end))  goto fail;\n          sprev = s;\n          s += n;\n        }\n      }\n      NEXT_OUT;\n\n    CASE_OP(ANYCHAR_ML_STAR_PEEK_NEXT)\n      {\n        UChar c;\n\n        c = p->anychar_star_peek_next.c;\n        INC_OP;\n        while (DATA_ENSURE_CHECK1) {\n          if (c == *s) {\n            STACK_PUSH_ALT(p, s, sprev);\n          }\n          n = enclen(encode, s);\n          if (n > 1) {\n            DATA_ENSURE(n);\n            sprev = s;\n            s += n;\n          }\n          else {\n            sprev = s;\n            s++;\n          }\n        }\n      }\n      NEXT_OUT;\n\n    CASE_OP(WORD)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(WORD_ASCII)\n      DATA_ENSURE(1);\n      if (! ONIGENC_IS_MBC_WORD_ASCII(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(NO_WORD)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(NO_WORD_ASCII)\n      DATA_ENSURE(1);\n      if (ONIGENC_IS_MBC_WORD_ASCII(encode, s, end))\n        goto fail;\n\n      s += enclen(encode, s);\n      INC_OP;\n      NEXT_OUT;\n\n    CASE_OP(WORD_BOUNDARY)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (ON_STR_BEGIN(s)) {\n          DATA_ENSURE(1);\n          if (! IS_MBC_WORD_ASCII_MODE(encode, s, end, mode))\n            goto fail;\n        }\n        else if (ON_STR_END(s)) {\n          if (! IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n        else {\n          if (IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)\n              == IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(NO_WORD_BOUNDARY)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (ON_STR_BEGIN(s)) {\n          if (DATA_ENSURE_CHECK1 && IS_MBC_WORD_ASCII_MODE(encode, s, end, mode))\n            goto fail;\n        }\n        else if (ON_STR_END(s)) {\n          if (IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n        else {\n          if (IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)\n              != IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode))\n            goto fail;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_WORD_BEGIN_END\n    CASE_OP(WORD_BEGIN)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (DATA_ENSURE_CHECK1 && IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)) {\n          if (ON_STR_BEGIN(s) || !IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode)) {\n            INC_OP;\n            JUMP_OUT;\n          }\n        }\n      }\n      goto fail;\n\n    CASE_OP(WORD_END)\n      {\n        ModeType mode;\n\n        mode = p->word_boundary.mode;\n        if (!ON_STR_BEGIN(s) && IS_MBC_WORD_ASCII_MODE(encode, sprev, end, mode)) {\n          if (ON_STR_END(s) || ! IS_MBC_WORD_ASCII_MODE(encode, s, end, mode)) {\n            INC_OP;\n            JUMP_OUT;\n          }\n        }\n      }\n      goto fail;\n#endif\n\n    CASE_OP(TEXT_SEGMENT_BOUNDARY)\n      {\n        int is_break;\n\n        switch (p->text_segment_boundary.type) {\n        case EXTENDED_GRAPHEME_CLUSTER_BOUNDARY:\n          is_break = onigenc_egcb_is_break_position(encode, s, sprev, str, end);\n          break;\n#ifdef USE_UNICODE_WORD_BREAK\n        case WORD_BOUNDARY:\n          is_break = onigenc_wb_is_break_position(encode, s, sprev, str, end);\n          break;\n#endif\n        default:\n          goto bytecode_error;\n          break;\n        }\n\n        if (p->text_segment_boundary.not != 0)\n          is_break = ! is_break;\n\n        if (is_break != 0) {\n          INC_OP;\n          JUMP_OUT;\n        }\n        else {\n          goto fail;\n        }\n      }\n\n    CASE_OP(BEGIN_BUF)\n      if (! ON_STR_BEGIN(s)) goto fail;\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(END_BUF)\n      if (! ON_STR_END(s)) goto fail;\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BEGIN_LINE)\n      if (ON_STR_BEGIN(s)) {\n        if (IS_NOTBOL(msa->options)) goto fail;\n        INC_OP;\n        JUMP_OUT;\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, sprev, end) && !ON_STR_END(s)) {\n        INC_OP;\n        JUMP_OUT;\n      }\n      goto fail;\n\n    CASE_OP(END_LINE)\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          INC_OP;\n          JUMP_OUT;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end)) {\n        INC_OP;\n        JUMP_OUT;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        INC_OP;\n        JUMP_OUT;\n      }\n#endif\n      goto fail;\n\n    CASE_OP(SEMI_END_BUF)\n      if (ON_STR_END(s)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        if (IS_EMPTY_STR || !ONIGENC_IS_MBC_NEWLINE(encode, sprev, end)) {\n#endif\n          if (IS_NOTEOL(msa->options)) goto fail;\n          INC_OP;\n          JUMP_OUT;\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n        }\n#endif\n      }\n      else if (ONIGENC_IS_MBC_NEWLINE(encode, s, end) &&\n               ON_STR_END(s + enclen(encode, s))) {\n        INC_OP;\n        JUMP_OUT;\n      }\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n      else if (ONIGENC_IS_MBC_CRNL(encode, s, end)) {\n        UChar* ss = s + enclen(encode, s);\n        ss += enclen(encode, ss);\n        if (ON_STR_END(ss)) {\n          INC_OP;\n          JUMP_OUT;\n        }\n      }\n#endif\n      goto fail;\n\n    CASE_OP(BEGIN_POSITION)\n      if (s != msa->start)\n        goto fail;\n\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_START_PUSH)\n      mem = p->memory_start.num;\n      STACK_PUSH_MEM_START(mem, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_START)\n      mem = p->memory_start.num;\n      mem_start_stk[mem] = (StackIndex )((void* )s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_END_PUSH)\n      mem = p->memory_end.num;\n      STACK_PUSH_MEM_END(mem, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_END)\n      mem = p->memory_end.num;\n      mem_end_stk[mem] = (StackIndex )((void* )s);\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_CALL\n    CASE_OP(MEMORY_END_PUSH_REC)\n      mem = p->memory_end.num;\n      STACK_GET_MEM_START(mem, stkp); /* should be before push mem-end. */\n      si = GET_STACK_INDEX(stkp);\n      STACK_PUSH_MEM_END(mem, s);\n      mem_start_stk[mem] = si;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(MEMORY_END_REC)\n      mem = p->memory_end.num;\n      mem_end_stk[mem] = (StackIndex )((void* )s);\n      STACK_GET_MEM_START(mem, stkp);\n\n      if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n        mem_start_stk[mem] = GET_STACK_INDEX(stkp);\n      else\n        mem_start_stk[mem] = (StackIndex )((void* )stkp->u.mem.pstr);\n\n      STACK_PUSH_MEM_END_MARK(mem);\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(BACKREF1)\n      mem = 1;\n      goto backref;\n\n    CASE_OP(BACKREF2)\n      mem = 2;\n      goto backref;\n\n    CASE_OP(BACKREF_N)\n      mem = p->backref_n.n1;\n    backref:\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = (int )(pend - pstart);\n        if (n != 0) {\n          DATA_ENSURE(n);\n          sprev = s;\n          STRING_CMP(s, pstart, n);\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BACKREF_N_IC)\n      mem = p->backref_n.n1;\n      {\n        int len;\n        UChar *pstart, *pend;\n\n        if (mem_end_stk[mem]   == INVALID_STACK_INDEX) goto fail;\n        if (mem_start_stk[mem] == INVALID_STACK_INDEX) goto fail;\n\n        if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n          pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n        else\n          pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n        pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                : (UChar* )((void* )mem_end_stk[mem]));\n        n = (int )(pend - pstart);\n        if (n != 0) {\n          DATA_ENSURE(n);\n          sprev = s;\n          STRING_CMP_IC(case_fold_flag, pstart, &s, n);\n          while (sprev + (len = enclen(encode, sprev)) < s)\n            sprev += len;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BACKREF_MULTI)\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        tlen = p->backref_general.num;\n        for (i = 0; i < tlen; i++) {\n          mem = tlen == 1 ? p->backref_general.n1 : p->backref_general.ns[i];\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = (int )(pend - pstart);\n          if (n != 0) {\n            DATA_ENSURE(n);\n            sprev = s;\n            swork = s;\n            STRING_CMP_VALUE(swork, pstart, n, is_fail);\n            if (is_fail) continue;\n            s = swork;\n            while (sprev + (len = enclen(encode, sprev)) < s)\n              sprev += len;\n          }\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(BACKREF_MULTI_IC)\n      {\n        int len, is_fail;\n        UChar *pstart, *pend, *swork;\n\n        tlen = p->backref_general.num;\n        for (i = 0; i < tlen; i++) {\n          mem = tlen == 1 ? p->backref_general.n1 : p->backref_general.ns[i];\n\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n\n          if (MEM_STATUS_AT(reg->bt_mem_start, mem))\n            pstart = STACK_AT(mem_start_stk[mem])->u.mem.pstr;\n          else\n            pstart = (UChar* )((void* )mem_start_stk[mem]);\n\n          pend = (MEM_STATUS_AT(reg->bt_mem_end, mem)\n                  ? STACK_AT(mem_end_stk[mem])->u.mem.pstr\n                  : (UChar* )((void* )mem_end_stk[mem]));\n          n = (int )(pend - pstart);\n          if (n != 0) {\n            DATA_ENSURE(n);\n            sprev = s;\n            swork = s;\n            STRING_CMP_VALUE_IC(case_fold_flag, pstart, &swork, n, is_fail);\n            if (is_fail) continue;\n            s = swork;\n            while (sprev + (len = enclen(encode, sprev)) < s)\n              sprev += len;\n          }\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    CASE_OP(BACKREF_WITH_LEVEL_IC)\n      n = 1; /* ignore case */\n      goto backref_with_level;\n    CASE_OP(BACKREF_WITH_LEVEL)\n      {\n        int len;\n        int level;\n        MemNumType* mems;\n        UChar* ssave;\n\n        n = 0;\n      backref_with_level:\n        level = p->backref_general.nest_level;\n        tlen  = p->backref_general.num;\n        mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;\n\n        ssave = s;\n        if (backref_match_at_nested_level(reg, stk, stk_base, n,\n                    case_fold_flag, level, (int )tlen, mems, &s, end)) {\n          if (ssave != s) {\n            sprev = ssave;\n            while (sprev + (len = enclen(encode, sprev)) < s)\n              sprev += len;\n          }\n        }\n        else\n          goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(BACKREF_CHECK)\n      {\n        MemNumType* mems;\n\n        tlen  = p->backref_general.num;\n        mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;\n\n        for (i = 0; i < tlen; i++) {\n          mem = mems[i];\n          if (mem_end_stk[mem]   == INVALID_STACK_INDEX) continue;\n          if (mem_start_stk[mem] == INVALID_STACK_INDEX) continue;\n          break; /* success */\n        }\n        if (i == tlen) goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_BACKREF_WITH_LEVEL\n    CASE_OP(BACKREF_CHECK_WITH_LEVEL)\n      {\n        LengthType level;\n        MemNumType* mems;\n\n        level = p->backref_general.nest_level;\n        tlen  = p->backref_general.num;\n        mems = tlen == 1 ? &(p->backref_general.n1) : p->backref_general.ns;\n\n        if (backref_check_at_nested_level(reg, stk, stk_base,\n                                          (int )level, (int )tlen, mems) == 0)\n          goto fail;\n      }\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(EMPTY_CHECK_START)\n      mem = p->empty_check_start.mem;   /* mem: null check id */\n      STACK_PUSH_EMPTY_CHECK_START(mem, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(EMPTY_CHECK_END)\n      {\n        int is_empty;\n\n        mem = p->empty_check_end.mem;  /* mem: null check id */\n        STACK_EMPTY_CHECK(is_empty, mem, s);\n        INC_OP;\n        if (is_empty) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"EMPTY_CHECK_END: skip  id:%d, s:%p\\n\", (int )mem, s);\n#endif\n        empty_check_found:\n          /* empty loop founded, skip next instruction */\n#if defined(ONIG_DEBUG) && !defined(USE_DIRECT_THREADED_CODE)\n          switch (p->opcode) {\n          case OP_JUMP:\n          case OP_PUSH:\n          case OP_REPEAT_INC:\n          case OP_REPEAT_INC_NG:\n          case OP_REPEAT_INC_SG:\n          case OP_REPEAT_INC_NG_SG:\n            INC_OP;\n            break;\n          default:\n            goto unexpected_bytecode_error;\n            break;\n          }\n#else\n          INC_OP;\n#endif\n        }\n      }\n      JUMP_OUT;\n\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n    CASE_OP(EMPTY_CHECK_END_MEMST)\n      {\n        int is_empty;\n\n        mem = p->empty_check_end.mem;  /* mem: null check id */\n        STACK_EMPTY_CHECK_MEM(is_empty, mem, s, reg);\n        INC_OP;\n        if (is_empty) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"EMPTY_CHECK_END_MEM: skip  id:%d, s:%p\\n\", (int)mem, s);\n#endif\n          if (is_empty == -1) goto fail;\n          goto empty_check_found;\n        }\n      }\n      JUMP_OUT;\n#endif\n\n#ifdef USE_CALL\n    CASE_OP(EMPTY_CHECK_END_MEMST_PUSH)\n      {\n        int is_empty;\n\n        mem = p->empty_check_end.mem;  /* mem: null check id */\n#ifdef USE_STUBBORN_CHECK_CAPTURES_IN_EMPTY_REPEAT\n        STACK_EMPTY_CHECK_MEM_REC(is_empty, mem, s, reg);\n#else\n        STACK_EMPTY_CHECK_REC(is_empty, mem, s);\n#endif\n        INC_OP;\n        if (is_empty) {\n#ifdef ONIG_DEBUG_MATCH\n          fprintf(stderr, \"EMPTY_CHECK_END_MEM_PUSH: skip  id:%d, s:%p\\n\",\n                  (int )mem, s);\n#endif\n          if (is_empty == -1) goto fail;\n          goto empty_check_found;\n        }\n        else {\n          STACK_PUSH_EMPTY_CHECK_END(mem);\n        }\n      }\n      JUMP_OUT;\n#endif\n\n    CASE_OP(JUMP)\n      addr = p->jump.addr;\n      p += addr;\n      CHECK_INTERRUPT_JUMP_OUT;\n\n    CASE_OP(PUSH)\n      addr = p->push.addr;\n      STACK_PUSH_ALT(p + addr, s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PUSH_SUPER)\n      addr = p->push.addr;\n      STACK_PUSH_SUPER_ALT(p + addr, s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(POP_OUT)\n      STACK_POP_ONE;\n      /* for stop backtrack */\n      /* CHECK_RETRY_LIMIT_IN_MATCH; */\n      INC_OP;\n      JUMP_OUT;\n\n #ifdef USE_OP_PUSH_OR_JUMP_EXACT\n    CASE_OP(PUSH_OR_JUMP_EXACT1)\n      {\n        UChar c;\n\n        addr = p->push_or_jump_exact1.addr;\n        c    = p->push_or_jump_exact1.c;\n        if (DATA_ENSURE_CHECK1 && c == *s) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n          INC_OP;\n          JUMP_OUT;\n        }\n      }\n      p += addr;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(PUSH_IF_PEEK_NEXT)\n      {\n        UChar c;\n\n        addr = p->push_if_peek_next.addr;\n        c    = p->push_if_peek_next.c;\n        if (c == *s) {\n          STACK_PUSH_ALT(p + addr, s, sprev);\n          INC_OP;\n          JUMP_OUT;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(REPEAT)\n      mem  = p->repeat.id;  /* mem: OP_REPEAT ID */\n      addr = p->repeat.addr;\n\n      STACK_ENSURE(1);\n      repeat_stk[mem] = GET_STACK_INDEX(stk);\n      STACK_PUSH_REPEAT(mem, p + 1);\n\n      if (reg->repeat_range[mem].lower == 0) {\n        STACK_PUSH_ALT(p + addr, s, sprev);\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(REPEAT_NG)\n      mem  = p->repeat.id;  /* mem: OP_REPEAT ID */\n      addr = p->repeat.addr;\n\n      STACK_ENSURE(1);\n      repeat_stk[mem] = GET_STACK_INDEX(stk);\n      STACK_PUSH_REPEAT(mem, p + 1);\n\n      if (reg->repeat_range[mem].lower == 0) {\n        STACK_PUSH_ALT(p + 1, s, sprev);\n        p += addr;\n      }\n      else\n        INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(REPEAT_INC)\n      mem  = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      si   = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count >= reg->repeat_range[mem].upper) {\n        /* end of repeat. Nothing to do. */\n        INC_OP;\n      }\n      else if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n        INC_OP;\n        STACK_PUSH_ALT(p, s, sprev);\n        p = STACK_AT(si)->u.repeat.pcode; /* Don't use stkp after PUSH. */\n      }\n      else {\n        p = stkp->u.repeat.pcode;\n      }\n      STACK_PUSH_REPEAT_INC(si);\n      CHECK_INTERRUPT_JUMP_OUT;\n\n    CASE_OP(REPEAT_INC_SG)\n      mem = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc;\n\n    CASE_OP(REPEAT_INC_NG)\n      mem = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      si = repeat_stk[mem];\n      stkp = STACK_AT(si);\n\n    repeat_inc_ng:\n      stkp->u.repeat.count++;\n      if (stkp->u.repeat.count < reg->repeat_range[mem].upper) {\n        if (stkp->u.repeat.count >= reg->repeat_range[mem].lower) {\n          Operation* pcode = stkp->u.repeat.pcode;\n\n          STACK_PUSH_REPEAT_INC(si);\n          STACK_PUSH_ALT(pcode, s, sprev);\n          INC_OP;\n        }\n        else {\n          p = stkp->u.repeat.pcode;\n          STACK_PUSH_REPEAT_INC(si);\n        }\n      }\n      else if (stkp->u.repeat.count == reg->repeat_range[mem].upper) {\n        STACK_PUSH_REPEAT_INC(si);\n        INC_OP;\n      }\n      CHECK_INTERRUPT_JUMP_OUT;\n\n    CASE_OP(REPEAT_INC_NG_SG)\n      mem = p->repeat_inc.id;  /* mem: OP_REPEAT ID */\n      STACK_GET_REPEAT(mem, stkp);\n      si = GET_STACK_INDEX(stkp);\n      goto repeat_inc_ng;\n\n    CASE_OP(PREC_READ_START)\n      STACK_PUSH_PREC_READ_START(s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PREC_READ_END)\n      STACK_GET_PREC_READ_START(stkp);\n      s     = stkp->u.state.pstr;\n      sprev = stkp->u.state.pstr_prev;\n      STACK_PUSH(STK_PREC_READ_END,0,0,0);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PREC_READ_NOT_START)\n      addr = p->prec_read_not_start.addr;\n      STACK_PUSH_ALT_PREC_READ_NOT(p + addr, s, sprev);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(PREC_READ_NOT_END)\n      STACK_POP_TIL_ALT_PREC_READ_NOT;\n      goto fail;\n\n    CASE_OP(ATOMIC_START)\n      STACK_PUSH_TO_VOID_START;\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(ATOMIC_END)\n      STACK_EXEC_TO_VOID(stkp);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(LOOK_BEHIND)\n      tlen = p->look_behind.len;\n      s = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(s)) goto fail;\n      sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(LOOK_BEHIND_NOT_START)\n      addr = p->look_behind_not_start.addr;\n      tlen = p->look_behind_not_start.len;\n      q = (UChar* )ONIGENC_STEP_BACK(encode, str, s, (int )tlen);\n      if (IS_NULL(q)) {\n        /* too short case -> success. ex. /(?<!XXX)a/.match(\"a\")\n           If you want to change to fail, replace following line. */\n        p += addr;\n        /* goto fail; */\n      }\n      else {\n        STACK_PUSH_ALT_LOOK_BEHIND_NOT(p + addr, s, sprev);\n        s = q;\n        sprev = (UChar* )onigenc_get_prev_char_head(encode, str, s);\n        INC_OP;\n      }\n      JUMP_OUT;\n\n    CASE_OP(LOOK_BEHIND_NOT_END)\n      STACK_POP_TIL_ALT_LOOK_BEHIND_NOT;\n      INC_OP;\n      goto fail;\n\n#ifdef USE_CALL\n    CASE_OP(CALL)\n      addr = p->call.addr;\n      INC_OP; STACK_PUSH_CALL_FRAME(p);\n      p = reg->ops + addr;\n      JUMP_OUT;\n\n    CASE_OP(RETURN)\n      STACK_RETURN(p);\n      STACK_PUSH_RETURN;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(PUSH_SAVE_VAL)\n      {\n        SaveType type;\n\n        type = p->push_save_val.type;\n        mem  = p->push_save_val.id; /* mem: save id */\n        switch ((enum SaveType )type) {\n        case SAVE_KEEP:\n          STACK_PUSH_SAVE_VAL(mem, type, s);\n          break;\n\n        case SAVE_S:\n          STACK_PUSH_SAVE_VAL_WITH_SPREV(mem, type, s);\n          break;\n\n        case SAVE_RIGHT_RANGE:\n          STACK_PUSH_SAVE_VAL(mem, SAVE_RIGHT_RANGE, right_range);\n          break;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n    CASE_OP(UPDATE_VAR)\n      {\n        UpdateVarType type;\n        enum SaveType save_type;\n\n        type = p->update_var.type;\n        mem  = p->update_var.id; /* mem: save id */\n\n        switch ((enum UpdateVarType )type) {\n        case UPDATE_VAR_KEEP_FROM_STACK_LAST:\n          STACK_GET_SAVE_VAL_TYPE_LAST(SAVE_KEEP, keep);\n          break;\n        case UPDATE_VAR_S_FROM_STACK:\n          STACK_GET_SAVE_VAL_TYPE_LAST_ID_WITH_SPREV(SAVE_S, mem, s);\n          break;\n        case UPDATE_VAR_RIGHT_RANGE_FROM_S_STACK:\n          save_type = SAVE_S;\n          goto get_save_val_type_last_id;\n          break;\n        case UPDATE_VAR_RIGHT_RANGE_FROM_STACK:\n          save_type = SAVE_RIGHT_RANGE;\n        get_save_val_type_last_id:\n          STACK_GET_SAVE_VAL_TYPE_LAST_ID(save_type, mem, right_range);\n          break;\n        case UPDATE_VAR_RIGHT_RANGE_INIT:\n          INIT_RIGHT_RANGE;\n          break;\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n\n#ifdef USE_CALLOUT\n    CASE_OP(CALLOUT_CONTENTS)\n      of = ONIG_CALLOUT_OF_CONTENTS;\n      mem = p->callout_contents.num;\n      goto callout_common_entry;\n      BREAK_OUT;\n\n    CASE_OP(CALLOUT_NAME)\n      {\n        int call_result;\n        int name_id;\n        int in;\n        CalloutListEntry* e;\n        OnigCalloutFunc func;\n        OnigCalloutArgs args;\n\n        of = ONIG_CALLOUT_OF_NAME;\n        name_id = p->callout_name.id;\n        mem     = p->callout_name.num;\n\n      callout_common_entry:\n        e = onig_reg_callout_list_at(reg, mem);\n        in = e->in;\n        if (of == ONIG_CALLOUT_OF_NAME) {\n          func = onig_get_callout_start_func(reg, mem);\n        }\n        else {\n          name_id = ONIG_NON_NAME_ID;\n          func = msa->mp->progress_callout_of_contents;\n        }\n\n        if (IS_NOT_NULL(func) && (in & ONIG_CALLOUT_IN_PROGRESS) != 0) {\n          CALLOUT_BODY(func, ONIG_CALLOUT_IN_PROGRESS, name_id,\n                       (int )mem, msa->mp->callout_user_data, args, call_result);\n          switch (call_result) {\n          case ONIG_CALLOUT_FAIL:\n            goto fail;\n            break;\n          case ONIG_CALLOUT_SUCCESS:\n            goto retraction_callout2;\n            break;\n          default: /* error code */\n            if (call_result > 0) {\n              call_result = ONIGERR_INVALID_ARGUMENT;\n            }\n            best_len = call_result;\n            goto finish;\n            break;\n          }\n        }\n        else {\n        retraction_callout2:\n          if ((in & ONIG_CALLOUT_IN_RETRACTION) != 0) {\n            if (of == ONIG_CALLOUT_OF_NAME) {\n              if (IS_NOT_NULL(func)) {\n                STACK_PUSH_CALLOUT_NAME(name_id, mem, func);\n              }\n            }\n            else {\n              func = msa->mp->retraction_callout_of_contents;\n              if (IS_NOT_NULL(func)) {\n                STACK_PUSH_CALLOUT_CONTENTS(mem, func);\n              }\n            }\n          }\n        }\n      }\n      INC_OP;\n      JUMP_OUT;\n#endif\n\n    CASE_OP(FINISH)\n      goto finish;\n\n#ifdef ONIG_DEBUG_STATISTICS\n    fail:\n      SOP_OUT;\n      goto fail2;\n#endif\n    CASE_OP(FAIL)\n#ifdef ONIG_DEBUG_STATISTICS\n    fail2:\n#else\n    fail:\n#endif\n      STACK_POP;\n      p     = stk->u.state.pcode;\n      s     = stk->u.state.pstr;\n      sprev = stk->u.state.pstr_prev;\n      CHECK_RETRY_LIMIT_IN_MATCH;\n      JUMP_OUT;\n\n    DEFAULT_OP\n      goto bytecode_error;\n\n  } BYTECODE_INTERPRETER_END;\n\n finish:\n  STACK_SAVE;\n  return best_len;\n\n#ifdef ONIG_DEBUG\n stack_error:\n  STACK_SAVE;\n  return ONIGERR_STACK_BUG;\n#endif\n\n bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNDEFINED_BYTECODE;\n\n#if defined(ONIG_DEBUG) && !defined(USE_DIRECT_THREADED_CODE)\n unexpected_bytecode_error:\n  STACK_SAVE;\n  return ONIGERR_UNEXPECTED_BYTECODE;\n#endif\n\n#ifdef USE_RETRY_LIMIT_IN_MATCH\n retry_limit_in_match_over:\n  STACK_SAVE;\n  return ONIGERR_RETRY_LIMIT_IN_MATCH_OVER;\n#endif\n}\n\n\nstatic UChar*\nslow_search(OnigEncoding enc, UChar* target, UChar* target_end,\n            const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *t, *p, *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic int\nstr_lower_case_match(OnigEncoding enc, int case_fold_flag,\n                     const UChar* t, const UChar* tend,\n                     const UChar* p, const UChar* end)\n{\n  int lowlen;\n  UChar *q, lowbuf[ONIGENC_MBC_CASE_FOLD_MAXLEN];\n\n  while (t < tend) {\n    lowlen = ONIGENC_MBC_CASE_FOLD(enc, case_fold_flag, &p, end, lowbuf);\n    q = lowbuf;\n    while (lowlen > 0) {\n      if (t >= tend)    return 0;\n      if (*t++ != *q++) return 0;\n      lowlen--;\n    }\n  }\n\n  return 1;\n}\n\nstatic UChar*\nslow_search_ic(OnigEncoding enc, int case_fold_flag,\n               UChar* target, UChar* target_end,\n               const UChar* text, const UChar* text_end, UChar* text_range)\n{\n  UChar *s, *end;\n\n  end = (UChar* )text_end;\n  end -= target_end - target - 1;\n  if (end > text_range)\n    end = text_range;\n\n  s = (UChar* )text;\n\n  while (s < end) {\n    if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n                             s, text_end))\n      return s;\n\n    s += enclen(enc, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward(OnigEncoding enc, UChar* target, UChar* target_end,\n                     const UChar* text, const UChar* adjust_text,\n                     const UChar* text_end, const UChar* text_start)\n{\n  UChar *t, *p, *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (*s == *target) {\n      p = s + 1;\n      t = target + 1;\n      while (t < target_end) {\n        if (*t != *p++)\n          break;\n        t++;\n      }\n      if (t == target_end)\n        return s;\n    }\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nslow_search_backward_ic(OnigEncoding enc, int case_fold_flag,\n                        UChar* target, UChar* target_end,\n                        const UChar* text, const UChar* adjust_text,\n                        const UChar* text_end, const UChar* text_start)\n{\n  UChar *s;\n\n  s = (UChar* )text_end;\n  s -= (target_end - target);\n  if (s > text_start)\n    s = (UChar* )text_start;\n  else\n    s = ONIGENC_LEFT_ADJUST_CHAR_HEAD(enc, adjust_text, s);\n\n  while (s >= text) {\n    if (str_lower_case_match(enc, case_fold_flag,\n                             target, target_end, s, text_end))\n      return s;\n\n    s = (UChar* )onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n\n  return (UChar* )NULL;\n}\n\n\nstatic UChar*\nsunday_quick_search_step_forward(regex_t* reg,\n                                 const UChar* target, const UChar* target_end,\n                                 const UChar* text, const UChar* text_end,\n                                 const UChar* text_range)\n{\n  const UChar *s, *se, *t, *p, *end;\n  const UChar *tail;\n  int skip, tlen1;\n  int map_offset;\n  OnigEncoding enc;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n          \"sunday_quick_search_step_forward: text: %p, text_end: %p, text_range: %p\\n\", text, text_end, text_range);\n#endif\n\n  enc = reg->enc;\n\n  tail = target_end - 1;\n  tlen1 = (int )(tail - target);\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  map_offset = reg->map_offset;\n  s = text;\n\n  while (s < end) {\n    p = se = s + tlen1;\n    t = tail;\n    while (*p == *t) {\n      if (t == target) return (UChar* )s;\n      p--; t--;\n    }\n    if (se + map_offset >= text_end) break;\n    skip = reg->map[*(se + map_offset)];\n#if 0\n    t = s;\n    do {\n      s += enclen(enc, s);\n    } while ((s - t) < skip && s < end);\n#else\n    s += skip;\n    if (s < end)\n      s = onigenc_get_right_adjust_char_head(enc, text, s);\n#endif\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nsunday_quick_search(regex_t* reg, const UChar* target, const UChar* target_end,\n                    const UChar* text, const UChar* text_end,\n                    const UChar* text_range)\n{\n  const UChar *s, *t, *p, *end;\n  const UChar *tail;\n  int map_offset;\n\n  end = text_range + (target_end - target);\n  if (end > text_end)\n    end = text_end;\n\n  map_offset = reg->map_offset;\n  tail = target_end - 1;\n  s = text + (tail - target);\n\n  while (s < end) {\n    p = s;\n    t = tail;\n    while (*p == *t) {\n      if (t == target) return (UChar* )p;\n      p--; t--;\n    }\n    if (s + map_offset >= text_end) break;\n    s += reg->map[*(s + map_offset)];\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nsunday_quick_search_case_fold(regex_t* reg,\n                              const UChar* target, const UChar* target_end,\n                              const UChar* text,   const UChar* text_end,\n                              const UChar* text_range)\n{\n  const UChar *s, *se, *end;\n  const UChar *tail;\n  int skip, tlen1;\n  int map_offset;\n  int case_fold_flag;\n  OnigEncoding enc;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n          \"sunday_quick_search_case_fold: text: %p, text_end: %p, text_range: %p\\n\", text, text_end, text_range);\n#endif\n\n  enc = reg->enc;\n  case_fold_flag = reg->case_fold_flag;\n\n  tail = target_end - 1;\n  tlen1 = (int )(tail - target);\n  end = text_range;\n  if (end + tlen1 > text_end)\n    end = text_end - tlen1;\n\n  map_offset = reg->map_offset;\n  s = text;\n\n  while (s < end) {\n    if (str_lower_case_match(enc, case_fold_flag, target, target_end,\n                             s, text_end))\n      return (UChar* )s;\n\n    se = s + tlen1;\n    if (se + map_offset >= text_end) break;\n    skip = reg->map[*(se + map_offset)];\n#if 0\n    p = s;\n    do {\n      s += enclen(enc, s);\n    } while ((s - p) < skip && s < end);\n#else\n    /* This is faster than prev code for long text.  ex: /(?i)Twain/  */\n    s += skip;\n    if (s < end)\n      s = onigenc_get_right_adjust_char_head(enc, text, s);\n#endif\n  }\n\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nmap_search(OnigEncoding enc, UChar map[],\n           const UChar* text, const UChar* text_range)\n{\n  const UChar *s = text;\n\n  while (s < text_range) {\n    if (map[*s]) return (UChar* )s;\n\n    s += enclen(enc, s);\n  }\n  return (UChar* )NULL;\n}\n\nstatic UChar*\nmap_search_backward(OnigEncoding enc, UChar map[],\n                    const UChar* text, const UChar* adjust_text,\n                    const UChar* text_start)\n{\n  const UChar *s = text_start;\n\n  while (s >= text) {\n    if (map[*s]) return (UChar* )s;\n\n    s = onigenc_get_prev_char_head(enc, adjust_text, s);\n  }\n  return (UChar* )NULL;\n}\nextern int\nonig_match(regex_t* reg, const UChar* str, const UChar* end, const UChar* at,\n           OnigRegion* region, OnigOptionType option)\n{\n  int r;\n  OnigMatchParam mp;\n\n  onig_initialize_match_param(&mp);\n  r = onig_match_with_param(reg, str, end, at, region, option, &mp);\n  onig_free_match_param_content(&mp);\n  return r;\n}\n\nextern int\nonig_match_with_param(regex_t* reg, const UChar* str, const UChar* end,\n                      const UChar* at, OnigRegion* region, OnigOptionType option,\n                      OnigMatchParam* mp)\n{\n  int r;\n  UChar *prev;\n  MatchArg msa;\n\n  ADJUST_MATCH_PARAM(reg, mp);\n  MATCH_ARG_INIT(msa, reg, option, region, at, mp);\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n  }\n  else\n    r = 0;\n\n  if (r == 0) {\n    if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n      if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n        r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n        goto end;\n      }\n    }\n\n    prev = (UChar* )onigenc_get_prev_char_head(reg->enc, str, at);\n    r = match_at(reg, str, end, end, at, prev, &msa);\n  }\n\n end:\n  MATCH_ARG_FREE(msa);\n  return r;\n}\n\nstatic int\nforward_search_range(regex_t* reg, const UChar* str, const UChar* end, UChar* s,\n                     UChar* range, UChar** low, UChar** high, UChar** low_prev)\n{\n  UChar *p, *pprev = (UChar* )NULL;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"forward_search_range: str: %p, end: %p, s: %p, range: %p\\n\",\n          str, end, s, range);\n#endif\n\n  p = s;\n  if (reg->dmin > 0) {\n    if (ONIGENC_IS_SINGLEBYTE(reg->enc)) {\n      p += reg->dmin;\n    }\n    else {\n      UChar *q = p + reg->dmin;\n\n      if (q >= end) return 0; /* fail */\n      while (p < q) p += enclen(reg->enc, p);\n    }\n  }\n\n retry:\n  switch (reg->optimize) {\n  case OPTIMIZE_STR:\n    p = slow_search(reg->enc, reg->exact, reg->exact_end, p, end, range);\n    break;\n  case OPTIMIZE_STR_CASE_FOLD:\n    p = slow_search_ic(reg->enc, reg->case_fold_flag,\n                       reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case OPTIMIZE_STR_CASE_FOLD_FAST:\n    p = sunday_quick_search_case_fold(reg, reg->exact, reg->exact_end, p, end,\n                                      range);\n    break;\n\n  case OPTIMIZE_STR_FAST:\n    p = sunday_quick_search(reg, reg->exact, reg->exact_end, p, end, range);\n    break;\n\n  case OPTIMIZE_STR_FAST_STEP_FORWARD:\n    p = sunday_quick_search_step_forward(reg, reg->exact, reg->exact_end,\n                                         p, end, range);\n    break;\n\n  case OPTIMIZE_MAP:\n    p = map_search(reg->enc, reg->map, p, range);\n    break;\n  }\n\n  if (p && p < range) {\n    if (p - reg->dmin < s) {\n    retry_gate:\n      pprev = p;\n      p += enclen(reg->enc, p);\n      goto retry;\n    }\n\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc,\n                                            (pprev ? pprev : str), p);\n          if (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n        }\n        break;\n\n      case ANCR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = (UChar* )onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), p);\n          if (prev && ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end))\n            goto retry_gate;\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 )\n          goto retry_gate;\n        break;\n      }\n    }\n\n    if (reg->dmax == 0) {\n      *low = p;\n      if (low_prev) {\n        if (*low > s)\n          *low_prev = onigenc_get_prev_char_head(reg->enc, s, p);\n        else\n          *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                 (pprev ? pprev : str), p);\n      }\n    }\n    else {\n      if (reg->dmax != INFINITE_LEN) {\n        if (p - str < reg->dmax) {\n          *low = (UChar* )str;\n          if (low_prev)\n            *low_prev = onigenc_get_prev_char_head(reg->enc, str, *low);\n        }\n        else {\n          *low = p - reg->dmax;\n          if (*low > s) {\n            *low = onigenc_get_right_adjust_char_head_with_prev(reg->enc, s,\n                                                 *low, (const UChar** )low_prev);\n            if (low_prev && IS_NULL(*low_prev))\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : s), *low);\n          }\n          else {\n            if (low_prev)\n              *low_prev = onigenc_get_prev_char_head(reg->enc,\n                                                     (pprev ? pprev : str), *low);\n          }\n        }\n      }\n    }\n    /* no needs to adjust *high, *high is used as range check only */\n    *high = p - reg->dmin;\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr,\n            \"forward_search_range success: low: %d, high: %d, dmin: %d, dmax: %d\\n\",\n            (int )(*low - str), (int )(*high - str), reg->dmin, reg->dmax);\n#endif\n    return 1; /* success */\n  }\n\n  return 0; /* fail */\n}\n\n\nstatic int\nbackward_search_range(regex_t* reg, const UChar* str, const UChar* end,\n                      UChar* s, const UChar* range, UChar* adjrange,\n                      UChar** low, UChar** high)\n{\n  UChar *p;\n\n  if (range == 0) goto fail;\n\n  range += reg->dmin;\n  p = s;\n\n retry:\n  switch (reg->optimize) {\n  case OPTIMIZE_STR:\n  exact_method:\n    p = slow_search_backward(reg->enc, reg->exact, reg->exact_end,\n                             range, adjrange, end, p);\n    break;\n\n  case OPTIMIZE_STR_CASE_FOLD:\n  case OPTIMIZE_STR_CASE_FOLD_FAST:\n    p = slow_search_backward_ic(reg->enc, reg->case_fold_flag,\n                                reg->exact, reg->exact_end,\n                                range, adjrange, end, p);\n    break;\n\n  case OPTIMIZE_STR_FAST:\n  case OPTIMIZE_STR_FAST_STEP_FORWARD:\n    goto exact_method;\n    break;\n\n  case OPTIMIZE_MAP:\n    p = map_search_backward(reg->enc, reg->map, range, adjrange, p);\n    break;\n  }\n\n  if (p) {\n    if (reg->sub_anchor) {\n      UChar* prev;\n\n      switch (reg->sub_anchor) {\n      case ANCR_BEGIN_LINE:\n        if (!ON_STR_BEGIN(p)) {\n          prev = onigenc_get_prev_char_head(reg->enc, str, p);\n          if (IS_NOT_NULL(prev) && !ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n        }\n        break;\n\n      case ANCR_END_LINE:\n        if (ON_STR_END(p)) {\n#ifndef USE_NEWLINE_AT_END_OF_STRING_HAS_EMPTY_LINE\n          prev = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(prev)) goto fail;\n          if (ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end)) {\n            p = prev;\n            goto retry;\n          }\n#endif\n        }\n        else if (! ONIGENC_IS_MBC_NEWLINE(reg->enc, p, end)\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n                 && ! ONIGENC_IS_MBC_CRNL(reg->enc, p, end)\n#endif\n                 ) {\n          p = onigenc_get_prev_char_head(reg->enc, adjrange, p);\n          if (IS_NULL(p)) goto fail;\n          goto retry;\n        }\n        break;\n      }\n    }\n\n    /* no needs to adjust *high, *high is used as range check only */\n    if (reg->dmax != INFINITE_LEN) {\n      *low  = p - reg->dmax;\n      *high = p - reg->dmin;\n      *high = onigenc_get_right_adjust_char_head(reg->enc, adjrange, *high);\n    }\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"backward_search_range: low: %d, high: %d\\n\",\n            (int )(*low - str), (int )(*high - str));\n#endif\n    return 1; /* success */\n  }\n\n fail:\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"backward_search_range: fail.\\n\");\n#endif\n  return 0; /* fail */\n}\n\n\nextern int\nonig_search(regex_t* reg, const UChar* str, const UChar* end,\n            const UChar* start, const UChar* range, OnigRegion* region,\n            OnigOptionType option)\n{\n  int r;\n  OnigMatchParam mp;\n\n  onig_initialize_match_param(&mp);\n  r = onig_search_with_param(reg, str, end, start, range, region, option, &mp);\n  onig_free_match_param_content(&mp);\n  return r;\n\n}\n\nextern int\nonig_search_with_param(regex_t* reg, const UChar* str, const UChar* end,\n                       const UChar* start, const UChar* range, OnigRegion* region,\n                       OnigOptionType option, OnigMatchParam* mp)\n{\n  int r;\n  UChar *s, *prev;\n  MatchArg msa;\n  const UChar *orig_start = start;\n  const UChar *orig_range = range;\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr,\n     \"onig_search (entry point): str: %p, end: %d, start: %d, range: %d\\n\",\n     str, (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  ADJUST_MATCH_PARAM(reg, mp);\n\n  if (region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    r = onig_region_resize_clear(region, reg->num_mem + 1);\n    if (r != 0) goto finish_no_msa;\n  }\n\n  if (start > end || start < str) goto mismatch_no_msa;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end)) {\n      r = ONIGERR_INVALID_WIDE_CHAR_VALUE;\n      goto finish_no_msa;\n    }\n  }\n\n\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      if (! IS_FIND_LONGEST(reg->options)) {\\\n        goto match;\\\n      }\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#else\n#define MATCH_AND_RETURN_CHECK(upper_range) \\\n  r = match_at(reg, str, end, (upper_range), s, prev, &msa); \\\n  if (r != ONIG_MISMATCH) {\\\n    if (r >= 0) {\\\n      goto match;\\\n    }\\\n    else goto finish; /* error */ \\\n  }\n#endif /* USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE */\n\n\n  /* anchor optimize: resume search range */\n  if (reg->anchor != 0 && str < end) {\n    UChar *min_semi_end, *max_semi_end;\n\n    if (reg->anchor & ANCR_BEGIN_POSITION) {\n      /* search start-position only */\n    begin_position:\n      if (range > start)\n        range = start + 1;\n      else\n        range = start;\n    }\n    else if (reg->anchor & ANCR_BEGIN_BUF) {\n      /* search str-position only */\n      if (range > start) {\n        if (start != str) goto mismatch_no_msa;\n        range = str + 1;\n      }\n      else {\n        if (range <= str) {\n          start = str;\n          range = str;\n        }\n        else\n          goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCR_END_BUF) {\n      min_semi_end = max_semi_end = (UChar* )end;\n\n    end_buf:\n      if ((OnigLen )(max_semi_end - str) < reg->anchor_dmin)\n        goto mismatch_no_msa;\n\n      if (range > start) {\n        if ((OnigLen )(min_semi_end - start) > reg->anchor_dmax) {\n          start = min_semi_end - reg->anchor_dmax;\n          if (start < end)\n            start = onigenc_get_right_adjust_char_head(reg->enc, str, start);\n        }\n        if ((OnigLen )(max_semi_end - (range - 1)) < reg->anchor_dmin) {\n          range = max_semi_end - reg->anchor_dmin + 1;\n        }\n\n        if (start > range) goto mismatch_no_msa;\n        /* If start == range, match with empty at end.\n           Backward search is used. */\n      }\n      else {\n        if ((OnigLen )(min_semi_end - range) > reg->anchor_dmax) {\n          range = min_semi_end - reg->anchor_dmax;\n        }\n        if ((OnigLen )(max_semi_end - start) < reg->anchor_dmin) {\n          start = max_semi_end - reg->anchor_dmin;\n          start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, start);\n        }\n        if (range > start) goto mismatch_no_msa;\n      }\n    }\n    else if (reg->anchor & ANCR_SEMI_END_BUF) {\n      UChar* pre_end = ONIGENC_STEP_BACK(reg->enc, str, end, 1);\n\n      max_semi_end = (UChar* )end;\n      if (ONIGENC_IS_MBC_NEWLINE(reg->enc, pre_end, end)) {\n        min_semi_end = pre_end;\n\n#ifdef USE_CRNL_AS_LINE_TERMINATOR\n        pre_end = ONIGENC_STEP_BACK(reg->enc, str, pre_end, 1);\n        if (IS_NOT_NULL(pre_end) &&\n            ONIGENC_IS_MBC_CRNL(reg->enc, pre_end, end)) {\n          min_semi_end = pre_end;\n        }\n#endif\n        if (min_semi_end > str && start <= min_semi_end) {\n          goto end_buf;\n        }\n      }\n      else {\n        min_semi_end = (UChar* )end;\n        goto end_buf;\n      }\n    }\n    else if ((reg->anchor & ANCR_ANYCHAR_INF_ML)) {\n      goto begin_position;\n    }\n  }\n  else if (str == end) { /* empty string */\n    static const UChar* address_for_empty_string = (UChar* )\"\";\n\n#ifdef ONIG_DEBUG_SEARCH\n    fprintf(stderr, \"onig_search: empty string.\\n\");\n#endif\n\n    if (reg->threshold_len == 0) {\n      start = end = str = address_for_empty_string;\n      s = (UChar* )start;\n      prev = (UChar* )NULL;\n\n      MATCH_ARG_INIT(msa, reg, option, region, start, mp);\n      MATCH_AND_RETURN_CHECK(end);\n      goto mismatch;\n    }\n    goto mismatch_no_msa;\n  }\n\n#ifdef ONIG_DEBUG_SEARCH\n  fprintf(stderr, \"onig_search(apply anchor): end: %d, start: %d, range: %d\\n\",\n          (int )(end - str), (int )(start - str), (int )(range - str));\n#endif\n\n  MATCH_ARG_INIT(msa, reg, option, region, orig_start, mp);\n\n  s = (UChar* )start;\n  if (range > start) {   /* forward search */\n    if (s > str)\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n    else\n      prev = (UChar* )NULL;\n\n    if (reg->optimize != OPTIMIZE_NONE) {\n      UChar *sch_range, *low, *high, *low_prev;\n\n      sch_range = (UChar* )range;\n      if (reg->dmax != 0) {\n        if (reg->dmax == INFINITE_LEN)\n          sch_range = (UChar* )end;\n        else {\n          sch_range += reg->dmax;\n          if (sch_range > end) sch_range = (UChar* )end;\n        }\n      }\n\n      if ((end - start) < reg->threshold_len)\n        goto mismatch;\n\n      if (reg->dmax != INFINITE_LEN) {\n        do {\n          if (! forward_search_range(reg, str, end, s, sch_range,\n                                     &low, &high, &low_prev)) goto mismatch;\n          if (s < low) {\n            s    = low;\n            prev = low_prev;\n          }\n          while (s <= high) {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n          }\n        } while (s < range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if (! forward_search_range(reg, str, end, s, sch_range,\n                                   &low, &high, (UChar** )NULL)) goto mismatch;\n\n        if ((reg->anchor & ANCR_ANYCHAR_INF) != 0) {\n          do {\n            MATCH_AND_RETURN_CHECK(orig_range);\n            prev = s;\n            s += enclen(reg->enc, s);\n\n            if ((reg->anchor & (ANCR_LOOK_BEHIND | ANCR_PREC_READ_NOT)) == 0) {\n              while (!ONIGENC_IS_MBC_NEWLINE(reg->enc, prev, end) && s < range) {\n                prev = s;\n                s += enclen(reg->enc, s);\n              }\n            }\n          } while (s < range);\n          goto mismatch;\n        }\n      }\n    }\n\n    do {\n      MATCH_AND_RETURN_CHECK(orig_range);\n      prev = s;\n      s += enclen(reg->enc, s);\n    } while (s < range);\n\n    if (s == range) { /* because empty match with /$/. */\n      MATCH_AND_RETURN_CHECK(orig_range);\n    }\n  }\n  else {  /* backward search */\n    if (range < str) goto mismatch;\n\n    if (orig_start < end)\n      orig_start += enclen(reg->enc, orig_start); /* is upper range */\n\n    if (reg->optimize != OPTIMIZE_NONE) {\n      UChar *low, *high, *adjrange, *sch_start;\n\n      if (range < end)\n        adjrange = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc, str, range);\n      else\n        adjrange = (UChar* )end;\n\n      if (reg->dmax != INFINITE_LEN &&\n          (end - range) >= reg->threshold_len) {\n        do {\n          sch_start = s + reg->dmax;\n          if (sch_start > end) sch_start = (UChar* )end;\n          if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                    &low, &high) <= 0)\n            goto mismatch;\n\n          if (s > high)\n            s = high;\n\n          while (s >= low) {\n            prev = onigenc_get_prev_char_head(reg->enc, str, s);\n            MATCH_AND_RETURN_CHECK(orig_start);\n            s = prev;\n          }\n        } while (s >= range);\n        goto mismatch;\n      }\n      else { /* check only. */\n        if ((end - range) < reg->threshold_len) goto mismatch;\n\n        sch_start = s;\n        if (reg->dmax != 0) {\n          if (reg->dmax == INFINITE_LEN)\n            sch_start = (UChar* )end;\n          else {\n            sch_start += reg->dmax;\n            if (sch_start > end) sch_start = (UChar* )end;\n            else\n              sch_start = ONIGENC_LEFT_ADJUST_CHAR_HEAD(reg->enc,\n                                                        start, sch_start);\n          }\n        }\n        if (backward_search_range(reg, str, end, sch_start, range, adjrange,\n                                  &low, &high) <= 0) goto mismatch;\n      }\n    }\n\n    do {\n      prev = onigenc_get_prev_char_head(reg->enc, str, s);\n      MATCH_AND_RETURN_CHECK(orig_start);\n      s = prev;\n    } while (s >= range);\n  }\n\n mismatch:\n#ifdef USE_FIND_LONGEST_SEARCH_ALL_OF_RANGE\n  if (IS_FIND_LONGEST(reg->options)) {\n    if (msa.best_len >= 0) {\n      s = msa.best_s;\n      goto match;\n    }\n  }\n#endif\n  r = ONIG_MISMATCH;\n\n finish:\n  MATCH_ARG_FREE(msa);\n\n  /* If result is mismatch and no FIND_NOT_EMPTY option,\n     then the region is not set in match_at(). */\n  if (IS_FIND_NOT_EMPTY(reg->options) && region\n#ifdef USE_POSIX_API_REGION_OPTION\n      && !IS_POSIX_REGION(option)\n#endif\n      ) {\n    onig_region_clear(region);\n  }\n\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n mismatch_no_msa:\n  r = ONIG_MISMATCH;\n finish_no_msa:\n#ifdef ONIG_DEBUG\n  if (r != ONIG_MISMATCH)\n    fprintf(stderr, \"onig_search: error %d\\n\", r);\n#endif\n  return r;\n\n match:\n  MATCH_ARG_FREE(msa);\n  return (int )(s - str);\n}\n\nextern int\nonig_scan(regex_t* reg, const UChar* str, const UChar* end,\n          OnigRegion* region, OnigOptionType option,\n          int (*scan_callback)(int, int, OnigRegion*, void*),\n          void* callback_arg)\n{\n  int r;\n  int n;\n  int rs;\n  const UChar* start;\n\n  if (ONIG_IS_OPTION_ON(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING)) {\n    if (! ONIGENC_IS_VALID_MBC_STRING(reg->enc, str, end))\n      return ONIGERR_INVALID_WIDE_CHAR_VALUE;\n\n    ONIG_OPTION_OFF(option, ONIG_OPTION_CHECK_VALIDITY_OF_STRING);\n  }\n\n  n = 0;\n  start = str;\n  while (1) {\n    r = onig_search(reg, str, end, start, end, region, option);\n    if (r >= 0) {\n      rs = scan_callback(n, r, region, callback_arg);\n      n++;\n      if (rs != 0)\n        return rs;\n\n      if (region->end[0] == start - str) {\n        if (start >= end) break;\n        start += enclen(reg->enc, start);\n      }\n      else\n        start = str + region->end[0];\n\n      if (start > end)\n        break;\n    }\n    else if (r == ONIG_MISMATCH) {\n      break;\n    }\n    else { /* error */\n      return r;\n    }\n  }\n\n  return n;\n}\n\nextern OnigEncoding\nonig_get_encoding(regex_t* reg)\n{\n  return reg->enc;\n}\n\nextern OnigOptionType\nonig_get_options(regex_t* reg)\n{\n  return reg->options;\n}\n\nextern  OnigCaseFoldType\nonig_get_case_fold_flag(regex_t* reg)\n{\n  return reg->case_fold_flag;\n}\n\nextern OnigSyntaxType*\nonig_get_syntax(regex_t* reg)\n{\n  return reg->syntax;\n}\n\nextern int\nonig_number_of_captures(regex_t* reg)\n{\n  return reg->num_mem;\n}\n\nextern int\nonig_number_of_capture_histories(regex_t* reg)\n{\n#ifdef USE_CAPTURE_HISTORY\n  int i, n;\n\n  n = 0;\n  for (i = 0; i <= ONIG_MAX_CAPTURE_HISTORY_GROUP; i++) {\n    if (MEM_STATUS_AT(reg->capture_history, i) != 0)\n      n++;\n  }\n  return n;\n#else\n  return 0;\n#endif\n}\n\nextern void\nonig_copy_encoding(OnigEncoding to, OnigEncoding from)\n{\n  *to = *from;\n}\n\n#ifdef USE_DIRECT_THREADED_CODE\nextern int\nonig_init_for_match_at(regex_t* reg)\n{\n  return match_at(reg, (const UChar* )NULL, (const UChar* )NULL,\n                  (const UChar* )NULL, (const UChar* )NULL, (UChar* )NULL,\n                  (MatchArg* )NULL);\n}\n#endif\n\n\n/* for callout functions */\n\n#ifdef USE_CALLOUT\n\nextern OnigCalloutFunc\nonig_get_progress_callout(void)\n{\n  return DefaultProgressCallout;\n}\n\nextern int\nonig_set_progress_callout(OnigCalloutFunc f)\n{\n  DefaultProgressCallout = f;\n  return ONIG_NORMAL;\n}\n\nextern OnigCalloutFunc\nonig_get_retraction_callout(void)\n{\n  return DefaultRetractionCallout;\n}\n\nextern int\nonig_set_retraction_callout(OnigCalloutFunc f)\n{\n  DefaultRetractionCallout = f;\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_get_callout_num_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->num;\n}\n\nextern OnigCalloutIn\nonig_get_callout_in_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->in;\n}\n\nextern int\nonig_get_name_id_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->name_id;\n}\n\nextern const UChar*\nonig_get_contents_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return 0;\n  if (e->of == ONIG_CALLOUT_OF_CONTENTS) {\n    return e->u.content.start;\n  }\n\n  return 0;\n}\n\nextern const UChar*\nonig_get_contents_end_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return 0;\n  if (e->of == ONIG_CALLOUT_OF_CONTENTS) {\n    return e->u.content.end;\n  }\n\n  return 0;\n}\n\nextern int\nonig_get_args_num_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return ONIGERR_INVALID_ARGUMENT;\n  if (e->of == ONIG_CALLOUT_OF_NAME) {\n    return e->u.arg.num;\n  }\n\n  return ONIGERR_INVALID_ARGUMENT;\n}\n\nextern int\nonig_get_passed_args_num_by_callout_args(OnigCalloutArgs* args)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return ONIGERR_INVALID_ARGUMENT;\n  if (e->of == ONIG_CALLOUT_OF_NAME) {\n    return e->u.arg.passed_num;\n  }\n\n  return ONIGERR_INVALID_ARGUMENT;\n}\n\nextern int\nonig_get_arg_by_callout_args(OnigCalloutArgs* args, int index,\n                             OnigType* type, OnigValue* val)\n{\n  int num;\n  CalloutListEntry* e;\n\n  num = args->num;\n  e = onig_reg_callout_list_at(args->regex, num);\n  if (IS_NULL(e)) return ONIGERR_INVALID_ARGUMENT;\n  if (e->of == ONIG_CALLOUT_OF_NAME) {\n    if (IS_NOT_NULL(type)) *type = e->u.arg.types[index];\n    if (IS_NOT_NULL(val))  *val  = e->u.arg.vals[index];\n    return ONIG_NORMAL;\n  }\n\n  return ONIGERR_INVALID_ARGUMENT;\n}\n\nextern const UChar*\nonig_get_string_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->string;\n}\n\nextern const UChar*\nonig_get_string_end_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->string_end;\n}\n\nextern const UChar*\nonig_get_start_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->start;\n}\n\nextern const UChar*\nonig_get_right_range_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->right_range;\n}\n\nextern const UChar*\nonig_get_current_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->current;\n}\n\nextern OnigRegex\nonig_get_regex_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->regex;\n}\n\nextern unsigned long\nonig_get_retry_counter_by_callout_args(OnigCalloutArgs* args)\n{\n  return args->retry_in_match_counter;\n}\n\n\nextern int\nonig_get_capture_range_in_callout(OnigCalloutArgs* a, int mem_num, int* begin, int* end)\n{\n  OnigRegex    reg;\n  const UChar* str;\n  StackType*   stk_base;\n  int i;\n\n  i = mem_num;\n  reg = a->regex;\n  str = a->string;\n  stk_base = a->stk_base;\n\n  if (i > 0) {\n    if (a->mem_end_stk[i] != INVALID_STACK_INDEX) {\n      if (MEM_STATUS_AT(reg->bt_mem_start, i))\n        *begin = (int )(STACK_AT(a->mem_start_stk[i])->u.mem.pstr - str);\n      else\n        *begin = (int )((UChar* )((void* )a->mem_start_stk[i]) - str);\n\n      *end = (int )((MEM_STATUS_AT(reg->bt_mem_end, i)\n                     ? STACK_AT(a->mem_end_stk[i])->u.mem.pstr\n                     : (UChar* )((void* )a->mem_end_stk[i])) - str);\n    }\n    else {\n      *begin = *end = ONIG_REGION_NOTPOS;\n    }\n  }\n  else\n    return ONIGERR_INVALID_ARGUMENT;\n\n  return ONIG_NORMAL;\n}\n\nextern int\nonig_get_used_stack_size_in_callout(OnigCalloutArgs* a, int* used_num, int* used_bytes)\n{\n  int n;\n\n  n = (int )(a->stk - a->stk_base);\n\n  if (used_num != 0)\n    *used_num = n;\n\n  if (used_bytes != 0)\n    *used_bytes = n * sizeof(StackType);\n\n  return ONIG_NORMAL;\n}\n\n\n/* builtin callout functions */\n\nextern int\nonig_builtin_fail(OnigCalloutArgs* args ARG_UNUSED, void* user_data ARG_UNUSED)\n{\n  return ONIG_CALLOUT_FAIL;\n}\n\nextern int\nonig_builtin_mismatch(OnigCalloutArgs* args ARG_UNUSED, void* user_data ARG_UNUSED)\n{\n  return ONIG_MISMATCH;\n}\n\nextern int\nonig_builtin_error(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int n;\n  OnigValue val;\n\n  r = onig_get_arg_by_callout_args(args, 0, 0, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  n = (int )val.l;\n  if (n >= 0) {\n    n = ONIGERR_INVALID_CALLOUT_BODY;\n  }\n  else if (onig_is_error_code_needs_param(n)) {\n    n = ONIGERR_INVALID_CALLOUT_BODY;\n  }\n\n  return n;\n}\n\nextern int\nonig_builtin_count(OnigCalloutArgs* args, void* user_data)\n{\n  (void )onig_check_callout_data_and_clear_old_values(args);\n\n  return onig_builtin_total_count(args, user_data);\n}\n\nextern int\nonig_builtin_total_count(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int slot;\n  OnigType  type;\n  OnigValue val;\n  OnigValue aval;\n  OnigCodePoint count_type;\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &aval);\n  if (r != ONIG_NORMAL) return r;\n\n  count_type = aval.c;\n  if (count_type != '>' && count_type != 'X' && count_type != '<')\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  r = onig_get_callout_data_by_callout_args_self_dont_clear_old(args, 0,\n                                                                &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    /* type == void: initial state */\n    val.l = 0;\n  }\n\n  if (args->in == ONIG_CALLOUT_IN_RETRACTION) {\n    slot = 2;\n    if (count_type == '<')\n      val.l++;\n    else if (count_type == 'X')\n      val.l--;\n  }\n  else {\n    slot = 1;\n    if (count_type != '<')\n      val.l++;\n  }\n\n  r = onig_set_callout_data_by_callout_args_self(args, 0, ONIG_TYPE_LONG, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  /* slot 1: in progress counter, slot 2: in retraction counter */\n  r = onig_get_callout_data_by_callout_args_self_dont_clear_old(args, slot,\n                                                                &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    val.l = 0;\n  }\n\n  val.l++;\n  r = onig_set_callout_data_by_callout_args_self(args, slot, ONIG_TYPE_LONG, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  return ONIG_CALLOUT_SUCCESS;\n}\n\nextern int\nonig_builtin_max(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int slot;\n  long max_val;\n  OnigCodePoint count_type;\n  OnigType  type;\n  OnigValue val;\n  OnigValue aval;\n\n  (void )onig_check_callout_data_and_clear_old_values(args);\n\n  slot = 0;\n  r = onig_get_callout_data_by_callout_args_self(args, slot, &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    /* type == void: initial state */\n    type  = ONIG_TYPE_LONG;\n    val.l = 0;\n  }\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &aval);\n  if (r != ONIG_NORMAL) return r;\n  if (type == ONIG_TYPE_TAG) {\n    r = onig_get_callout_data_by_callout_args(args, aval.tag, 0, &type, &aval);\n    if (r < ONIG_NORMAL) return r;\n    else if (r > ONIG_NORMAL)\n      max_val = 0L;\n    else\n      max_val = aval.l;\n  }\n  else { /* LONG */\n    max_val = aval.l;\n  }\n\n  r = onig_get_arg_by_callout_args(args, 1, &type, &aval);\n  if (r != ONIG_NORMAL) return r;\n\n  count_type = aval.c;\n  if (count_type != '>' && count_type != 'X' && count_type != '<')\n    return ONIGERR_INVALID_CALLOUT_ARG;\n\n  if (args->in == ONIG_CALLOUT_IN_RETRACTION) {\n    if (count_type == '<') {\n      if (val.l >= max_val) return ONIG_CALLOUT_FAIL;\n      val.l++;\n    }\n    else if (count_type == 'X')\n      val.l--;\n  }\n  else {\n    if (count_type != '<') {\n      if (val.l >= max_val) return ONIG_CALLOUT_FAIL;\n      val.l++;\n    }\n  }\n\n  r = onig_set_callout_data_by_callout_args_self(args, slot, ONIG_TYPE_LONG, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  return ONIG_CALLOUT_SUCCESS;\n}\n\nenum OP_CMP {\n  OP_EQ,\n  OP_NE,\n  OP_LT,\n  OP_GT,\n  OP_LE,\n  OP_GE\n};\n\nextern int\nonig_builtin_cmp(OnigCalloutArgs* args, void* user_data ARG_UNUSED)\n{\n  int r;\n  int slot;\n  long lv;\n  long rv;\n  OnigType  type;\n  OnigValue val;\n  regex_t* reg;\n  enum OP_CMP op;\n\n  reg = args->regex;\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  if (type == ONIG_TYPE_TAG) {\n    r = onig_get_callout_data_by_callout_args(args, val.tag, 0, &type, &val);\n    if (r < ONIG_NORMAL) return r;\n    else if (r > ONIG_NORMAL)\n      lv = 0L;\n    else\n      lv = val.l;\n  }\n  else { /* ONIG_TYPE_LONG */\n    lv = val.l;\n  }\n\n  r = onig_get_arg_by_callout_args(args, 2, &type, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  if (type == ONIG_TYPE_TAG) {\n    r = onig_get_callout_data_by_callout_args(args, val.tag, 0, &type, &val);\n    if (r < ONIG_NORMAL) return r;\n    else if (r > ONIG_NORMAL)\n      rv = 0L;\n    else\n      rv = val.l;\n  }\n  else { /* ONIG_TYPE_LONG */\n    rv = val.l;\n  }\n\n  slot = 0;\n  r = onig_get_callout_data_by_callout_args_self(args, slot, &type, &val);\n  if (r < ONIG_NORMAL)\n    return r;\n  else if (r > ONIG_NORMAL) {\n    /* type == void: initial state */\n    OnigCodePoint c1, c2;\n    UChar* p;\n\n    r = onig_get_arg_by_callout_args(args, 1, &type, &val);\n    if (r != ONIG_NORMAL) return r;\n\n    p = val.s.start;\n    c1 = ONIGENC_MBC_TO_CODE(reg->enc, p, val.s.end);\n    p += ONIGENC_MBC_ENC_LEN(reg->enc, p);\n    if (p < val.s.end) {\n      c2 = ONIGENC_MBC_TO_CODE(reg->enc, p, val.s.end);\n      p += ONIGENC_MBC_ENC_LEN(reg->enc, p);\n      if (p != val.s.end)  return ONIGERR_INVALID_CALLOUT_ARG;\n    }\n    else\n      c2 = 0;\n\n    switch (c1) {\n    case '=':\n      if (c2 != '=') return ONIGERR_INVALID_CALLOUT_ARG;\n      op = OP_EQ;\n      break;\n    case '!':\n      if (c2 != '=') return ONIGERR_INVALID_CALLOUT_ARG;\n      op = OP_NE;\n      break;\n    case '<':\n      if (c2 == '=') op = OP_LE;\n      else if (c2 == 0) op = OP_LT;\n      else  return ONIGERR_INVALID_CALLOUT_ARG;\n      break;\n    case '>':\n      if (c2 == '=') op = OP_GE;\n      else if (c2 == 0) op = OP_GT;\n      else  return ONIGERR_INVALID_CALLOUT_ARG;\n      break;\n    default:\n      return ONIGERR_INVALID_CALLOUT_ARG;\n      break;\n    }\n    val.l = (long )op;\n    r = onig_set_callout_data_by_callout_args_self(args, slot, ONIG_TYPE_LONG, &val);\n    if (r != ONIG_NORMAL) return r;\n  }\n  else {\n    op = (enum OP_CMP )val.l;\n  }\n\n  switch (op) {\n  case OP_EQ: r = (lv == rv); break;\n  case OP_NE: r = (lv != rv); break;\n  case OP_LT: r = (lv <  rv); break;\n  case OP_GT: r = (lv >  rv); break;\n  case OP_LE: r = (lv <= rv); break;\n  case OP_GE: r = (lv >= rv); break;\n  }\n\n  return r == 0 ? ONIG_CALLOUT_FAIL : ONIG_CALLOUT_SUCCESS;\n}\n\n\n#include <stdio.h>\n\nstatic FILE* OutFp;\n\n/* name start with \"onig_\" for macros. */\nstatic int\nonig_builtin_monitor(OnigCalloutArgs* args, void* user_data)\n{\n  int r;\n  int num;\n  size_t tag_len;\n  const UChar* start;\n  const UChar* right;\n  const UChar* current;\n  const UChar* string;\n  const UChar* strend;\n  const UChar* tag_start;\n  const UChar* tag_end;\n  regex_t* reg;\n  OnigCalloutIn in;\n  OnigType type;\n  OnigValue val;\n  char buf[20];\n  FILE* fp;\n\n  fp = OutFp;\n\n  r = onig_get_arg_by_callout_args(args, 0, &type, &val);\n  if (r != ONIG_NORMAL) return r;\n\n  in = onig_get_callout_in_by_callout_args(args);\n  if (in == ONIG_CALLOUT_IN_PROGRESS) {\n    if (val.c == '<')\n      return ONIG_CALLOUT_SUCCESS;\n  }\n  else {\n    if (val.c != 'X' && val.c != '<')\n      return ONIG_CALLOUT_SUCCESS;\n  }\n\n  num       = onig_get_callout_num_by_callout_args(args);\n  start     = onig_get_start_by_callout_args(args);\n  right     = onig_get_right_range_by_callout_args(args);\n  current   = onig_get_current_by_callout_args(args);\n  string    = onig_get_string_by_callout_args(args);\n  strend    = onig_get_string_end_by_callout_args(args);\n  reg       = onig_get_regex_by_callout_args(args);\n  tag_start = onig_get_callout_tag_start(reg, num);\n  tag_end   = onig_get_callout_tag_end(reg, num);\n\n  if (tag_start == 0)\n    xsnprintf(buf, sizeof(buf), \"#%d\", num);\n  else {\n    /* CAUTION: tag string is not terminated with NULL. */\n    int i;\n\n    tag_len = tag_end - tag_start;\n    if (tag_len >= sizeof(buf)) tag_len = sizeof(buf) - 1;\n    for (i = 0; i < tag_len; i++) buf[i] = tag_start[i];\n    buf[tag_len] = '\\0';\n  }\n\n  fprintf(fp, \"ONIG-MONITOR: %-4s %s at: %d [%d - %d] len: %d\\n\",\n          buf,\n          in == ONIG_CALLOUT_IN_PROGRESS ? \"=>\" : \"<=\",\n          (int )(current - string),\n          (int )(start   - string),\n          (int )(right   - string),\n          (int )(strend  - string));\n  fflush(fp);\n\n  return ONIG_CALLOUT_SUCCESS;\n}\n\nextern int\nonig_setup_builtin_monitors_by_ascii_encoded_name(void* fp /* FILE* */)\n{\n  int id;\n  char* name;\n  OnigEncoding enc;\n  unsigned int ts[4];\n  OnigValue opts[4];\n\n  if (IS_NOT_NULL(fp))\n    OutFp = (FILE* )fp;\n  else\n    OutFp = stdout;\n\n  enc = ONIG_ENCODING_ASCII;\n\n  name = \"MON\";\n  ts[0] = ONIG_TYPE_CHAR;\n  opts[0].c = '>';\n  BC_B_O(name, monitor, 1, ts, 1, opts);\n\n  return ONIG_NORMAL;\n}\n\n#endif /* USE_CALLOUT */\n"], "filenames": ["src/regexec.c"], "buggy_code_start_loc": [4198], "buggy_code_end_loc": [4198], "fixing_code_start_loc": [4199], "fixing_code_end_loc": [4200], "type": "CWE-125", "message": "Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c.", "other": {"cve": {"id": "CVE-2019-19246", "sourceIdentifier": "cve@mitre.org", "published": "2019-11-25T17:15:11.887", "lastModified": "2022-08-29T20:03:48.107", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Oniguruma through 6.9.3, as used in PHP 7.3.x and other products, has a heap-based buffer over-read in str_lower_case_match in regexec.c."}, {"lang": "es", "value": "Oniguruma versiones hasta 6.9.3, como es usado en PHP versi\u00f3n 7.3.x y otros productos, presenta una lectura excesiva de b\u00fafer en la regi\u00f3n heap de la memoria en la funci\u00f3n str_lower_case_match en el archivo regexec.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oniguruma_project:oniguruma:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.3", "matchCriteriaId": "68772ACF-793E-49F4-9352-53E54FA7540A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:php:php:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.3.0", "versionEndExcluding": "7.3.10", "matchCriteriaId": "DE288A62-8732-45BB-BF66-A8B40132153F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:esm:*:*:*", "matchCriteriaId": "815D70A8-47D3-459C-A32C-9FEACA0659D1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "https://bugs.php.net/bug.php?id=78559", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/kkos/oniguruma/commit/d3e402928b6eb3327f8f7d59a9edfa622fec557b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/12/msg00002.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/NO267PLHGYZSWX3XTRPKYBKD4J3YOU5V/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4460-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kkos/oniguruma/commit/d3e402928b6eb3327f8f7d59a9edfa622fec557b"}}