{"buggy_code": ["/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2010 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <jansson.h>\n#ifdef HAVE_LIBCURL\n#include <curl/curl.h>\n#endif\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#ifndef WIN32\n#include <fcntl.h>\n# ifdef __linux__\n#  include <sys/prctl.h>\n# endif\n# include <sys/socket.h>\n# include <netinet/in.h>\n# include <netinet/tcp.h>\n# include <netdb.h>\n#else\n# include <windows.h>\n# include <winsock2.h>\n# include <ws2tcpip.h>\n# include <mmsystem.h>\n#endif\n\n#include \"miner.h\"\n#include \"elist.h\"\n#include \"compat.h\"\n#include \"util.h\"\n#include \"pool.h\"\n\n#define DEFAULT_SOCKWAIT 60\nextern double opt_diff_mult;\n\nbool successful_connect = false;\nstatic void keep_sockalive(SOCKETTYPE fd)\n{\n\tconst int tcp_one = 1;\n#ifndef WIN32\n\tconst int tcp_keepidle = 45;\n\tconst int tcp_keepintvl = 30;\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, O_NONBLOCK | flags);\n#else\n\tu_long flags = 1;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n\n\tsetsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (const char *)&tcp_one, sizeof(tcp_one));\n\tif (!opt_delaynet)\n#ifndef __linux\n\t\tsetsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const char *)&tcp_one, sizeof(tcp_one));\n#else /* __linux */\n\t\tsetsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&tcp_one, sizeof(tcp_one));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPCNT, &tcp_one, sizeof(tcp_one));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPIDLE, &tcp_keepidle, sizeof(tcp_keepidle));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPINTVL, &tcp_keepintvl, sizeof(tcp_keepintvl));\n#endif /* __linux__ */\n\n#ifdef __APPLE_CC__\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &tcp_keepintvl, sizeof(tcp_keepintvl));\n#endif /* __APPLE_CC__ */\n\n}\n\nstruct tq_ent {\n\tvoid\t\t\t*data;\n\tstruct list_head\tq_node;\n};\n\n#ifdef HAVE_LIBCURL\nstruct timeval nettime;\n\nstruct data_buffer {\n\tvoid\t\t*buf;\n\tsize_t\t\tlen;\n};\n\nstruct upload_buffer {\n\tconst void\t*buf;\n\tsize_t\t\tlen;\n};\n\nstruct header_info {\n\tchar\t\t*lp_path;\n\tint\t\trolltime;\n\tchar\t\t*reason;\n\tchar\t\t*stratum_url;\n\tbool\t\thadrolltime;\n\tbool\t\tcanroll;\n\tbool\t\thadexpire;\n};\n\nstatic void databuf_free(struct data_buffer *db)\n{\n\tif (!db)\n\t\treturn;\n\n\tfree(db->buf);\n\n\tmemset(db, 0, sizeof(*db));\n}\n\nstatic size_t all_data_cb(const void *ptr, size_t size, size_t nmemb,\n\t\t\t  void *user_data)\n{\n\tstruct data_buffer *db = (struct data_buffer *)user_data;\n\tsize_t len = size * nmemb;\n\tsize_t oldlen, newlen;\n\tvoid *newmem;\n\tstatic const unsigned char zero = 0;\n\n\toldlen = db->len;\n\tnewlen = oldlen + len;\n\n\tnewmem = realloc(db->buf, newlen + 1);\n\tif (!newmem)\n\t\treturn 0;\n\n\tdb->buf = newmem;\n\tdb->len = newlen;\n\tmemcpy((uint8_t*)db->buf + oldlen, ptr, len);\n\tmemcpy((uint8_t*)db->buf + newlen, &zero, 1);\t/* null terminate */\n\n\treturn len;\n}\n\nstatic size_t upload_data_cb(void *ptr, size_t size, size_t nmemb,\n\t\t\t     void *user_data)\n{\n\tstruct upload_buffer *ub = (struct upload_buffer *)user_data;\n\tunsigned int len = size * nmemb;\n\n\tif (len > ub->len)\n\t\tlen = ub->len;\n\n\tif (len) {\n\t\tmemcpy(ptr, ub->buf, len);\n\t\tub->buf = (uint8_t*)ub->buf + len;\n\t\tub->len -= len;\n\t}\n\n\treturn len;\n}\n\nstatic size_t resp_hdr_cb(void *ptr, size_t size, size_t nmemb, void *user_data)\n{\n\tstruct header_info *hi = (struct header_info *)user_data;\n\tsize_t remlen, slen, ptrlen = size * nmemb;\n\tchar *rem, *val = NULL, *key = NULL;\n\tvoid *tmp;\n\n\tval = (char *)calloc(1, ptrlen);\n\tkey = (char *)calloc(1, ptrlen);\n\tif (!key || !val)\n\t\tgoto out;\n\n\ttmp = memchr(ptr, ':', ptrlen);\n\tif (!tmp || (tmp == ptr))\t/* skip empty keys / blanks */\n\t\tgoto out;\n\tslen = (uint8_t*)tmp - (uint8_t*)ptr;\n\tif ((slen + 1) == ptrlen)\t/* skip key w/ no value */\n\t\tgoto out;\n\tmemcpy(key, ptr, slen);\t\t/* store & nul term key */\n\tkey[slen] = 0;\n\n\trem = (char*)ptr + slen + 1;\t/* trim value's leading whitespace */\n\tremlen = ptrlen - slen - 1;\n\twhile ((remlen > 0) && (isspace(*rem))) {\n\t\tremlen--;\n\t\trem++;\n\t}\n\n\tmemcpy(val, rem, remlen);\t/* store value, trim trailing ws */\n\tval[remlen] = 0;\n\twhile ((*val) && (isspace(val[strlen(val) - 1])))\n\t\tval[strlen(val) - 1] = 0;\n\n\tif (!*val)\t\t\t/* skip blank value */\n\t\tgoto out;\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"HTTP hdr(%s): %s\", key, val);\n\n\tif (!strcasecmp(\"X-Roll-Ntime\", key)) {\n\t\thi->hadrolltime = true;\n\t\tif (!strncasecmp(\"N\", val, 1))\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime: N found\");\n\t\telse {\n\t\t\thi->canroll = true;\n\n\t\t\t/* Check to see if expire= is supported and if not, set\n\t\t\t * the rolltime to the default scantime */\n\t\t\tif (strlen(val) > 7 && !strncasecmp(\"expire=\", val, 7)) {\n\t\t\t\tsscanf(val + 7, \"%d\", &hi->rolltime);\n\t\t\t\thi->hadexpire = true;\n\t\t\t} else\n\t\t\t\thi->rolltime = opt_scantime;\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime expiry set to %d\", hi->rolltime);\n\t\t}\n\t}\n\n\tif (!strcasecmp(\"X-Long-Polling\", key)) {\n\t\thi->lp_path = val;\t/* steal memory reference */\n\t\tval = NULL;\n\t}\n\n\tif (!strcasecmp(\"X-Reject-Reason\", key)) {\n\t\thi->reason = val;\t/* steal memory reference */\n\t\tval = NULL;\n\t}\n\n\tif (!strcasecmp(\"X-Stratum\", key)) {\n\t\thi->stratum_url = val;\n\t\tval = NULL;\n\t}\n\nout:\n\tfree(key);\n\tfree(val);\n\treturn ptrlen;\n}\n\nstatic void last_nettime(struct timeval *last)\n{\n\trd_lock(&netacc_lock);\n\tlast->tv_sec = nettime.tv_sec;\n\tlast->tv_usec = nettime.tv_usec;\n\trd_unlock(&netacc_lock);\n}\n\nstatic void set_nettime(void)\n{\n\twr_lock(&netacc_lock);\n\tcgtime(&nettime);\n\twr_unlock(&netacc_lock);\n}\n\n#if CURL_HAS_KEEPALIVE\nstatic void keep_curlalive(CURL *curl)\n{\n\tconst long int keepalive = 1;\n\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, keepalive);\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, opt_tcp_keepalive);\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, opt_tcp_keepalive);\n}\n#else\nstatic void keep_curlalive(CURL *curl)\n{\n\tSOCKETTYPE sock;\n\n\tcurl_easy_getinfo(curl, CURLINFO_LASTSOCKET, (long *)&sock);\n\tkeep_sockalive(sock);\n}\n#endif\n\nstatic int curl_debug_cb(__maybe_unused CURL *handle, curl_infotype type,\n\t\t\t __maybe_unused char *data, size_t size, void *userdata)\n{\n\tstruct pool *pool = (struct pool *)userdata;\n\n\tswitch(type) {\n\t\tcase CURLINFO_HEADER_IN:\n\t\tcase CURLINFO_DATA_IN:\n\t\tcase CURLINFO_SSL_DATA_IN:\n\t\t\tpool->sgminer_pool_stats.net_bytes_received += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_HEADER_OUT:\n\t\tcase CURLINFO_DATA_OUT:\n\t\tcase CURLINFO_SSL_DATA_OUT:\n\t\t\tpool->sgminer_pool_stats.net_bytes_sent += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_TEXT:\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\njson_t *json_rpc_call(CURL *curl, const char *url,\n\t\t      const char *userpass, const char *rpc_req,\n\t\t      bool probe, bool longpoll, int *rolltime,\n\t\t      struct pool *pool, bool share)\n{\n\tlong timeout = longpoll ? (60 * 60) : 60;\n\tstruct data_buffer all_data = {NULL, 0};\n\tstruct header_info hi = {NULL, 0, NULL, NULL, false, false, false};\n\tchar len_hdr[64], user_agent_hdr[128];\n\tchar curl_err_str[CURL_ERROR_SIZE];\n\tstruct curl_slist *headers = NULL;\n\tstruct upload_buffer upload_data;\n\tjson_t *val, *err_val, *res_val;\n\tbool probing = false;\n\tdouble byte_count;\n\tjson_error_t err;\n\tint rc;\n\n\tmemset(&err, 0, sizeof(err));\n\n\t/* it is assumed that 'curl' is freshly [re]initialized at this pt */\n\n\tif (probe)\n\t\tprobing = !pool->probed;\n\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);\n\n\t// CURLOPT_VERBOSE won't write to stderr if we use CURLOPT_DEBUGFUNCTION\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_cb);\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGDATA, (void *)pool);\n\tcurl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n\n\tcurl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_ENCODING, \"\");\n\tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n\n\t/* Shares are staggered already and delays in submission can be costly\n\t * so do not delay them */\n\tif (!opt_delaynet || share)\n\t\tcurl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, all_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &all_data);\n\tcurl_easy_setopt(curl, CURLOPT_READFUNCTION, upload_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_READDATA, &upload_data);\n\tcurl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_err_str);\n\tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, resp_hdr_cb);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERDATA, &hi);\n\tcurl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n\tif (pool->rpc_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, pool->rpc_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, pool->rpc_proxytype);\n\t} else if (opt_socks_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, opt_socks_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);\n\t}\n\tif (userpass) {\n\t\tcurl_easy_setopt(curl, CURLOPT_USERPWD, userpass);\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n\t}\n\tif (longpoll)\n\t\tkeep_curlalive(curl);\n\tcurl_easy_setopt(curl, CURLOPT_POST, 1);\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"JSON protocol request:\\n%s\", rpc_req);\n\n\tupload_data.buf = rpc_req;\n\tupload_data.len = strlen(rpc_req);\n\tsprintf(len_hdr, \"Content-Length: %lu\",\n\t\t(unsigned long) upload_data.len);\n\tsprintf(user_agent_hdr, \"User-Agent: %s\", PACKAGE_STRING);\n\n\theaders = curl_slist_append(headers,\n\t\t\"Content-type: application/json\");\n\theaders = curl_slist_append(headers,\n\t\t\"X-Mining-Extensions: longpoll midstate rollntime submitold\");\n\n\tif (likely(global_hashrate)) {\n\t\tchar ghashrate[255];\n\n\t\tsprintf(ghashrate, \"X-Mining-Hashrate: %llu\", global_hashrate);\n\t\theaders = curl_slist_append(headers, ghashrate);\n\t}\n\n\theaders = curl_slist_append(headers, len_hdr);\n\theaders = curl_slist_append(headers, user_agent_hdr);\n\theaders = curl_slist_append(headers, \"Expect:\"); /* disable Expect hdr*/\n\n\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n\tif (opt_delaynet) {\n\t\t/* Don't delay share submission, but still track the nettime */\n\t\tif (!share) {\n\t\t\tlong long now_msecs, last_msecs;\n\t\t\tstruct timeval now, last;\n\n\t\t\tcgtime(&now);\n\t\t\tlast_nettime(&last);\n\t\t\tnow_msecs = (long long)now.tv_sec * 1000;\n\t\t\tnow_msecs += now.tv_usec / 1000;\n\t\t\tlast_msecs = (long long)last.tv_sec * 1000;\n\t\t\tlast_msecs += last.tv_usec / 1000;\n\t\t\tif (now_msecs > last_msecs && now_msecs - last_msecs < 250) {\n\t\t\t\tstruct timespec rgtp;\n\n\t\t\t\trgtp.tv_sec = 0;\n\t\t\t\trgtp.tv_nsec = (250 - (now_msecs - last_msecs)) * 1000000;\n\t\t\t\tnanosleep(&rgtp, NULL);\n\t\t\t}\n\t\t}\n\t\tset_nettime();\n\t}\n\n\trc = curl_easy_perform(curl);\n\tif (rc) {\n\t\tapplog(LOG_INFO, \"HTTP request failed: %s\", curl_err_str);\n\t\tgoto err_out;\n\t}\n\n\tif (!all_data.buf) {\n\t\tapplog(LOG_DEBUG, \"Empty data received in json_rpc_call.\");\n\t\tgoto err_out;\n\t}\n\n\tpool->sgminer_pool_stats.times_sent++;\n\tif (curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &byte_count) == CURLE_OK)\n\t\tpool->sgminer_pool_stats.bytes_sent += byte_count;\n\tpool->sgminer_pool_stats.times_received++;\n\tif (curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &byte_count) == CURLE_OK)\n\t\tpool->sgminer_pool_stats.bytes_received += byte_count;\n\n\tif (probing) {\n\t\tpool->probed = true;\n\t\t/* If X-Long-Polling was found, activate long polling */\n\t\tif (hi.lp_path) {\n\t\t\tif (pool->hdr_path != NULL)\n\t\t\t\tfree(pool->hdr_path);\n\t\t\tpool->hdr_path = hi.lp_path;\n\t\t} else\n\t\t\tpool->hdr_path = NULL;\n\t\tif (hi.stratum_url) {\n\t\t\tpool->stratum_url = hi.stratum_url;\n\t\t\thi.stratum_url = NULL;\n\t\t}\n\t} else {\n\t\tif (hi.lp_path) {\n\t\t\tfree(hi.lp_path);\n\t\t\thi.lp_path = NULL;\n\t\t}\n\t\tif (hi.stratum_url) {\n\t\t\tfree(hi.stratum_url);\n\t\t\thi.stratum_url = NULL;\n\t\t}\n\t}\n\n\t*rolltime = hi.rolltime;\n\tpool->sgminer_pool_stats.rolltime = hi.rolltime;\n\tpool->sgminer_pool_stats.hadrolltime = hi.hadrolltime;\n\tpool->sgminer_pool_stats.canroll = hi.canroll;\n\tpool->sgminer_pool_stats.hadexpire = hi.hadexpire;\n\n\tval = JSON_LOADS((const char *)all_data.buf, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\n\t\tif (opt_protocol)\n\t\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", (char *)(all_data.buf));\n\n\t\tgoto err_out;\n\t}\n\n\tif (opt_protocol) {\n\t\tchar *s = json_dumps(val, JSON_INDENT(3));\n\n\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", s);\n\t\tfree(s);\n\t}\n\n\t/* JSON-RPC valid response returns a non-null 'result',\n\t * and a null 'error'.\n\t */\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val ||(err_val && !json_is_null(err_val))) {\n\t\tchar *s;\n\n\t\tif (err_val)\n\t\t\ts = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\ts = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC call failed: %s\", s);\n\n\t\tfree(s);\n\n\t\tgoto err_out;\n\t}\n\n\tif (hi.reason) {\n\t\tjson_object_set_new(val, \"reject-reason\", json_string(hi.reason));\n\t\tfree(hi.reason);\n\t\thi.reason = NULL;\n\t}\n\tsuccessful_connect = true;\n\tdatabuf_free(&all_data);\n\tcurl_slist_free_all(headers);\n\tcurl_easy_reset(curl);\n\treturn val;\n\nerr_out:\n\tdatabuf_free(&all_data);\n\tcurl_slist_free_all(headers);\n\tcurl_easy_reset(curl);\n\tif (!successful_connect)\n\t\tapplog(LOG_DEBUG, \"Failed to connect in json_rpc_call\");\n\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\treturn NULL;\n}\n#define PROXY_HTTP\tCURLPROXY_HTTP\n#define PROXY_HTTP_1_0\tCURLPROXY_HTTP_1_0\n#define PROXY_SOCKS4\tCURLPROXY_SOCKS4\n#define PROXY_SOCKS5\tCURLPROXY_SOCKS5\n#define PROXY_SOCKS4A\tCURLPROXY_SOCKS4A\n#define PROXY_SOCKS5H\tCURLPROXY_SOCKS5_HOSTNAME\n#else /* HAVE_LIBCURL */\n#define PROXY_HTTP\t0\n#define PROXY_HTTP_1_0\t1\n#define PROXY_SOCKS4\t2\n#define PROXY_SOCKS5\t3\n#define PROXY_SOCKS4A\t4\n#define PROXY_SOCKS5H\t5\n#endif /* HAVE_LIBCURL */\n\nstatic struct {\n\tconst char *name;\n\tproxytypes_t proxytype;\n} proxynames[] = {\n\t{ \"http:\",\tPROXY_HTTP },\n\t{ \"http0:\",\tPROXY_HTTP_1_0 },\n\t{ \"socks4:\",\tPROXY_SOCKS4 },\n\t{ \"socks5:\",\tPROXY_SOCKS5 },\n\t{ \"socks4a:\",\tPROXY_SOCKS4A },\n\t{ \"socks5h:\",\tPROXY_SOCKS5H },\n\t{ NULL,\t(proxytypes_t)NULL }\n};\n\nconst char *proxytype(proxytypes_t proxytype)\n{\n\tint i;\n\n\tfor (i = 0; proxynames[i].name; i++)\n\t\tif (proxynames[i].proxytype == proxytype)\n\t\t\treturn proxynames[i].name;\n\n\treturn \"invalid\";\n}\n\nchar *get_proxy(char *url, struct pool *pool)\n{\n\tpool->rpc_proxy = NULL;\n\n\tchar *split;\n\tint plen, len, i;\n\n\tfor (i = 0; proxynames[i].name; i++) {\n\t\tplen = strlen(proxynames[i].name);\n\t\tif (strncmp(url, proxynames[i].name, plen) == 0) {\n\t\t\tif (!(split = strchr(url, '|')))\n\t\t\t\treturn url;\n\n\t\t\t*split = '\\0';\n\t\t\tlen = split - url;\n\t\t\tpool->rpc_proxy = (char *)malloc(1 + len - plen);\n\t\t\tif (!(pool->rpc_proxy))\n\t\t\t\tquithere(1, \"Failed to malloc rpc_proxy\");\n\n\t\t\tstrcpy(pool->rpc_proxy, url + plen);\n\t\t\textract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);\n\t\t\tpool->rpc_proxytype = proxynames[i].proxytype;\n\t\t\turl = split + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn url;\n}\n\n/* Adequate size s==len*2 + 1 must be alloced to use this variant */\nvoid __bin2hex(char *s, const unsigned char *p, size_t len)\n{\n\tint i;\n\tstatic const char hex[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n\tfor (i = 0; i < (int)len; i++) {\n\t\t*s++ = hex[p[i] >> 4];\n\t\t*s++ = hex[p[i] & 0xF];\n\t}\n\t*s++ = '\\0';\n}\n\n/* Returns a malloced array string of a binary value of arbitrary length. The\n * array is rounded up to a 4 byte size to appease architectures that need\n * aligned array  sizes */\nchar *bin2hex(const unsigned char *p, size_t len)\n{\n\tssize_t slen;\n\tchar *s;\n\n\tslen = len * 2 + 1;\n\tif (slen % 4)\n\t\tslen += 4 - (slen % 4);\n\ts = (char *)calloc(slen, 1);\n\tif (unlikely(!s))\n\t\tquithere(1, \"Failed to calloc\");\n\n\t__bin2hex(s, p, len);\n\n\treturn s;\n}\n\n/* Does the reverse of bin2hex but does not allocate any ram */\nstatic const int hex2bin_tbl[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n};\nbool hex2bin(unsigned char *p, const char *hexstr, size_t len)\n{\n\tint nibble1, nibble2;\n\tunsigned char idx;\n\tbool ret = false;\n\n\twhile (*hexstr && len) {\n\t\tif (unlikely(!hexstr[1])) {\n\t\t\tapplog(LOG_ERR, \"hex2bin str truncated\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tidx = *hexstr++;\n\t\tnibble1 = hex2bin_tbl[idx];\n\t\tidx = *hexstr++;\n\t\tnibble2 = hex2bin_tbl[idx];\n\n\t\tif (unlikely((nibble1 < 0) || (nibble2 < 0))) {\n\t\t\tapplog(LOG_ERR, \"hex2bin scan failed\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t*p++ = (((unsigned char)nibble1) << 4) | ((unsigned char)nibble2);\n\t\t--len;\n\t}\n\n\tif (likely(len == 0 && *hexstr == 0))\n\t\tret = true;\n\treturn ret;\n}\n\nbool fulltest(const unsigned char *hash, const unsigned char *target)\n{\n\tuint32_t *hash32 = (uint32_t *)hash;\n\tuint32_t *target32 = (uint32_t *)target;\n\tbool rc = true;\n\tint i;\n\n\tfor (i = 28 / 4; i >= 0; i--) {\n\t\tuint32_t h32tmp = le32toh(hash32[i]);\n\t\tuint32_t t32tmp = le32toh(target32[i]);\n\n\t\tif (h32tmp > t32tmp) {\n\t\t\trc = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (h32tmp < t32tmp) {\n\t\t\trc = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt_debug) {\n\t\tunsigned char hash_swap[32], target_swap[32];\n\t\tchar *hash_str, *target_str;\n\n\t\tswab256(hash_swap, hash);\n\t\tswab256(target_swap, target);\n\t\thash_str = bin2hex(hash_swap, 32);\n\t\ttarget_str = bin2hex(target_swap, 32);\n\n\t\tapplog(LOG_DEBUG, \" Proof: %s\\nTarget: %s\\nTrgVal? %s\",\n\t\t\thash_str,\n\t\t\ttarget_str,\n\t\t\trc ? \"YES (hash <= target)\" :\n\t\t\t     \"no (false positive; hash > target)\");\n\n\t\tfree(hash_str);\n\t\tfree(target_str);\n\t}\n\n\treturn rc;\n}\n\nstruct thread_q *tq_new(void)\n{\n\tstruct thread_q *tq;\n\n\ttq = (struct thread_q *)calloc(1, sizeof(*tq));\n\tif (!tq)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&tq->q);\n\tpthread_mutex_init(&tq->mutex, NULL);\n\tpthread_cond_init(&tq->cond, NULL);\n\n\treturn tq;\n}\n\nvoid tq_free(struct thread_q *tq)\n{\n\tstruct tq_ent *ent, *iter;\n\n\tif (!tq)\n\t\treturn;\n\n\tlist_for_each_entry_safe(ent, iter, &tq->q, q_node) {\n\t\tlist_del(&ent->q_node);\n\t\tfree(ent);\n\t}\n\n\tpthread_cond_destroy(&tq->cond);\n\tpthread_mutex_destroy(&tq->mutex);\n\n\tmemset(tq, 0, sizeof(*tq));\t/* poison */\n\tfree(tq);\n}\n\nstatic void tq_freezethaw(struct thread_q *tq, bool frozen)\n{\n\tmutex_lock(&tq->mutex);\n\ttq->frozen = frozen;\n\tpthread_cond_signal(&tq->cond);\n\tmutex_unlock(&tq->mutex);\n}\n\nvoid tq_freeze(struct thread_q *tq)\n{\n\ttq_freezethaw(tq, true);\n}\n\nvoid tq_thaw(struct thread_q *tq)\n{\n\ttq_freezethaw(tq, false);\n}\n\nbool tq_push(struct thread_q *tq, void *data)\n{\n\tstruct tq_ent *ent;\n\tbool rc = true;\n\n\tent = (struct tq_ent *)calloc(1, sizeof(*ent));\n\tif (!ent)\n\t\treturn false;\n\n\tent->data = data;\n\tINIT_LIST_HEAD(&ent->q_node);\n\n\tmutex_lock(&tq->mutex);\n\tif (!tq->frozen) {\n\t\tlist_add_tail(&ent->q_node, &tq->q);\n\t} else {\n\t\tfree(ent);\n\t\trc = false;\n\t}\n\tpthread_cond_signal(&tq->cond);\n\tmutex_unlock(&tq->mutex);\n\n\treturn rc;\n}\n\nvoid *tq_pop(struct thread_q *tq, const struct timespec *abstime)\n{\n\tstruct tq_ent *ent;\n\tvoid *rval = NULL;\n\tint rc;\n\n\tmutex_lock(&tq->mutex);\n\tif (!list_empty(&tq->q))\n\t\tgoto pop;\n\n\tif (abstime)\n\t\trc = pthread_cond_timedwait(&tq->cond, &tq->mutex, abstime);\n\telse\n\t\trc = pthread_cond_wait(&tq->cond, &tq->mutex);\n\tif (rc)\n\t\tgoto out;\n\tif (list_empty(&tq->q))\n\t\tgoto out;\npop:\n\tent = list_entry(tq->q.next, struct tq_ent*, q_node);\n\trval = ent->data;\n\n\tlist_del(&ent->q_node);\n\tfree(ent);\nout:\n\tmutex_unlock(&tq->mutex);\n\n\treturn rval;\n}\n\nint thr_info_create(struct thr_info *thr, pthread_attr_t *attr, void *(*start) (void *), void *arg)\n{\n\tcgsem_init(&thr->sem);\n\n\treturn pthread_create(&thr->pth, attr, start, arg);\n}\n\nvoid thr_info_cancel(struct thr_info *thr)\n{\n\tif (!thr)\n\t\treturn;\n\n\tif (PTH(thr) != 0L) {\n\t\tpthread_cancel(thr->pth);\n\t\tPTH(thr) = 0L;\n\t}\n\tcgsem_destroy(&thr->sem);\n}\n\nvoid subtime(struct timeval *a, struct timeval *b)\n{\n\ttimersub(a, b, b);\n}\n\nvoid addtime(struct timeval *a, struct timeval *b)\n{\n\ttimeradd(a, b, b);\n}\n\nbool time_more(struct timeval *a, struct timeval *b)\n{\n\treturn timercmp(a, b, >);\n}\n\nbool time_less(struct timeval *a, struct timeval *b)\n{\n\treturn timercmp(a, b, <);\n}\n\nvoid copy_time(struct timeval *dest, const struct timeval *src)\n{\n\tmemcpy(dest, src, sizeof(struct timeval));\n}\n\nvoid timespec_to_val(struct timeval *val, const struct timespec *spec)\n{\n\tval->tv_sec = spec->tv_sec;\n\tval->tv_usec = spec->tv_nsec / 1000;\n}\n\nvoid timeval_to_spec(struct timespec *spec, const struct timeval *val)\n{\n\tspec->tv_sec = val->tv_sec;\n\tspec->tv_nsec = val->tv_usec * 1000;\n}\n\nvoid us_to_timeval(struct timeval *val, int64_t us)\n{\n\tlldiv_t tvdiv = lldiv(us, 1000000);\n\n\tval->tv_sec = tvdiv.quot;\n\tval->tv_usec = tvdiv.rem;\n}\n\nvoid us_to_timespec(struct timespec *spec, int64_t us)\n{\n\tlldiv_t tvdiv = lldiv(us, 1000000);\n\n\tspec->tv_sec = tvdiv.quot;\n\tspec->tv_nsec = tvdiv.rem * 1000;\n}\n\nvoid ms_to_timespec(struct timespec *spec, int64_t ms)\n{\n\tlldiv_t tvdiv = lldiv(ms, 1000);\n\n\tspec->tv_sec = tvdiv.quot;\n\tspec->tv_nsec = tvdiv.rem * 1000000;\n}\n\nvoid ms_to_timeval(struct timeval *val, int64_t ms)\n{\n\tlldiv_t tvdiv = lldiv(ms, 1000);\n\n\tval->tv_sec = tvdiv.quot;\n\tval->tv_usec = tvdiv.rem * 1000;\n}\n\nvoid timeraddspec(struct timespec *a, const struct timespec *b)\n{\n\ta->tv_sec += b->tv_sec;\n\ta->tv_nsec += b->tv_nsec;\n\tif (a->tv_nsec >= 1000000000) {\n\t\ta->tv_nsec -= 1000000000;\n\t\ta->tv_sec++;\n\t}\n}\n\nstatic int __maybe_unused timespec_to_ms(struct timespec *ts)\n{\n\treturn ts->tv_sec * 1000 + ts->tv_nsec / 1000000;\n}\n\n/* Subtract b from a */\nstatic void __maybe_unused timersubspec(struct timespec *a, const struct timespec *b)\n{\n\ta->tv_sec -= b->tv_sec;\n\ta->tv_nsec -= b->tv_nsec;\n\tif (a->tv_nsec < 0) {\n\t\ta->tv_nsec += 1000000000;\n\t\ta->tv_sec--;\n\t}\n}\n\n/* These are sgminer specific sleep functions that use an absolute nanosecond\n * resolution timer to avoid poor usleep accuracy and overruns. */\n#ifdef WIN32\n/* Windows start time is since 1601 LOL so convert it to unix epoch 1970. */\n#define EPOCHFILETIME (116444736000000000LL)\n\n/* Return the system time as an lldiv_t in decimicroseconds. */\nstatic void decius_time(lldiv_t *lidiv)\n{\n\tFILETIME ft;\n\tLARGE_INTEGER li;\n\n\tGetSystemTimeAsFileTime(&ft);\n\tli.LowPart  = ft.dwLowDateTime;\n\tli.HighPart = ft.dwHighDateTime;\n\tli.QuadPart -= EPOCHFILETIME;\n\n\t/* SystemTime is in decimicroseconds so divide by an unusual number */\n\t*lidiv = lldiv(li.QuadPart, 10000000);\n}\n\n/* This is a sgminer gettimeofday wrapper. Since we always call gettimeofday\n * with tz set to NULL, and windows' default resolution is only 15ms, this\n * gives us higher resolution times on windows. */\nvoid cgtime(struct timeval *tv)\n{\n\tlldiv_t lidiv;\n\n\tdecius_time(&lidiv);\n\ttv->tv_sec = lidiv.quot;\n\ttv->tv_usec = lidiv.rem / 10;\n}\n\n#else /* WIN32 */\nvoid cgtime(struct timeval *tv)\n{\n\tgettimeofday(tv, NULL);\n}\n\nint cgtimer_to_ms(cgtimer_t *cgt)\n{\n\treturn timespec_to_ms(cgt);\n}\n\n/* Subtracts b from a and stores it in res. */\nvoid cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)\n{\n\tres->tv_sec = a->tv_sec - b->tv_sec;\n\tres->tv_nsec = a->tv_nsec - b->tv_nsec;\n\tif (res->tv_nsec < 0) {\n\t\tres->tv_nsec += 1000000000;\n\t\tres->tv_sec--;\n\t}\n}\n#endif /* WIN32 */\n\n#ifdef CLOCK_MONOTONIC /* Essentially just linux */\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tclock_gettime(CLOCK_MONOTONIC, ts_start);\n}\n\nstatic void nanosleep_abstime(struct timespec *ts_end)\n{\n\tint ret;\n\n\tdo {\n\t\tret = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ts_end, NULL);\n\t} while (ret == EINTR);\n}\n\n/* Reentrant version of cgsleep functions allow start time to be set separately\n * from the beginning of the actual sleep, allowing scheduling delays to be\n * counted in the sleep. */\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tstruct timespec ts_end;\n\n\tms_to_timespec(&ts_end, ms);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}\n\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tstruct timespec ts_end;\n\n\tus_to_timespec(&ts_end, us);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}\n#else /* CLOCK_MONOTONIC */\n#ifdef __MACH__\n#include <mach/clock.h>\n#include <mach/mach.h>\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tclock_serv_t cclock;\n\tmach_timespec_t mts;\n\n\thost_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &cclock);\n\tclock_get_time(cclock, &mts);\n\tmach_port_deallocate(mach_task_self(), cclock);\n\tts_start->tv_sec = mts.tv_sec;\n\tts_start->tv_nsec = mts.tv_nsec;\n}\n#elif !defined(WIN32) /* __MACH__ - Everything not linux/macosx/win32 */\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tstruct timeval tv;\n\n\tcgtime(&tv);\n\tts_start->tv_sec = tv->tv_sec;\n\tts_start->tv_nsec = tv->tv_usec * 1000;\n}\n#endif /* __MACH__ */\n\n#ifdef WIN32\n/* For windows we use the SystemTime stored as a LARGE_INTEGER as the cgtimer_t\n * typedef, allowing us to have sub-microsecond resolution for times, do simple\n * arithmetic for timer calculations, and use windows' own hTimers to get\n * accurate absolute timeouts. */\nint cgtimer_to_ms(cgtimer_t *cgt)\n{\n\treturn (int)(cgt->QuadPart / 10000LL);\n}\n\n/* Subtracts b from a and stores it in res. */\nvoid cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)\n{\n\tres->QuadPart = a->QuadPart - b->QuadPart;\n}\n\n/* Note that cgtimer time is NOT offset by the unix epoch since we use absolute\n * timeouts with hTimers. */\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tFILETIME ft;\n\n\tGetSystemTimeAsFileTime(&ft);\n\tts_start->LowPart = ft.dwLowDateTime;\n\tts_start->HighPart = ft.dwHighDateTime;\n}\n\nstatic void liSleep(LARGE_INTEGER *li, int timeout)\n{\n\tHANDLE hTimer;\n\tDWORD ret;\n\n\tif (unlikely(timeout <= 0))\n\t\treturn;\n\n\thTimer = CreateWaitableTimer(NULL, TRUE, NULL);\n\tif (unlikely(!hTimer))\n\t\tquit(1, \"Failed to create hTimer in liSleep\");\n\tret = SetWaitableTimer(hTimer, li, 0, NULL, NULL, 0);\n\tif (unlikely(!ret))\n\t\tquit(1, \"Failed to SetWaitableTimer in liSleep\");\n\t/* We still use a timeout as a sanity check in case the system time\n\t * is changed while we're running */\n\tret = WaitForSingleObject(hTimer, timeout);\n\tif (unlikely(ret != WAIT_OBJECT_0 && ret != WAIT_TIMEOUT))\n\t\tquit(1, \"Failed to WaitForSingleObject in liSleep\");\n\tCloseHandle(hTimer);\n}\n\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tLARGE_INTEGER li;\n\n\tli.QuadPart = ts_start->QuadPart + (int64_t)ms * 10000LL;\n\tliSleep(&li, ms);\n}\n\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tLARGE_INTEGER li;\n\tint ms;\n\n\tli.QuadPart = ts_start->QuadPart + us * 10LL;\n\tms = us / 1000;\n\tif (!ms)\n\t\tms = 1;\n\tliSleep(&li, ms);\n}\n#else /* WIN32 */\nstatic void cgsleep_spec(struct timespec *ts_diff, const struct timespec *ts_start)\n{\n\tstruct timespec now;\n\n\ttimeraddspec(ts_diff, ts_start);\n\tcgtimer_time(&now);\n\ttimersubspec(ts_diff, &now);\n\tif (unlikely(ts_diff->tv_sec < 0))\n\t\treturn;\n\tnanosleep(ts_diff, NULL);\n}\n\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tstruct timespec ts_diff;\n\n\tms_to_timespec(&ts_diff, ms);\n\tcgsleep_spec(&ts_diff, ts_start);\n}\n\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tstruct timespec ts_diff;\n\n\tus_to_timespec(&ts_diff, us);\n\tcgsleep_spec(&ts_diff, ts_start);\n}\n#endif /* WIN32 */\n#endif /* CLOCK_MONOTONIC */\n\nvoid cgsleep_ms(int ms)\n{\n\tcgtimer_t ts_start;\n\n\tcgsleep_prepare_r(&ts_start);\n\tcgsleep_ms_r(&ts_start, ms);\n}\n\nvoid cgsleep_us(int64_t us)\n{\n\tcgtimer_t ts_start;\n\n\tcgsleep_prepare_r(&ts_start);\n\tcgsleep_us_r(&ts_start, us);\n}\n\n/* Returns the microseconds difference between end and start times as a double */\ndouble us_tdiff(struct timeval *end, struct timeval *start)\n{\n\t/* Sanity check. We should only be using this for small differences so\n\t * limit the max to 60 seconds. */\n\tif (unlikely(end->tv_sec - start->tv_sec > 60))\n\t\treturn 60000000;\n\treturn (end->tv_sec - start->tv_sec) * 1000000 + (end->tv_usec - start->tv_usec);\n}\n\n/* Returns the milliseconds difference between end and start times */\nint ms_tdiff(struct timeval *end, struct timeval *start)\n{\n\t/* Like us_tdiff, limit to 1 hour. */\n\tif (unlikely(end->tv_sec - start->tv_sec > 3600))\n\t\treturn 3600000;\n\treturn (end->tv_sec - start->tv_sec) * 1000 + (end->tv_usec - start->tv_usec) / 1000;\n}\n\n/* Returns the seconds difference between end and start times as a double */\ndouble tdiff(struct timeval *end, struct timeval *start)\n{\n\treturn end->tv_sec - start->tv_sec + (end->tv_usec - start->tv_usec) / 1000000.0;\n}\n\nbool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\t\n\tif (url_len >= sizeof(url_address))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",\n\t\t       __func__, url_len, url_begin);\n\t\turl_len = sizeof(url_address) - 1;\n\t}\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n\nenum send_ret {\n\tSEND_OK,\n\tSEND_SELECTFAIL,\n\tSEND_SENDFAIL,\n\tSEND_INACTIVE\n};\n\n/* Send a single command across a socket, appending \\n to it. This should all\n * be done under stratum lock except when first establishing the socket */\nstatic enum send_ret __stratum_send(struct pool *pool, char *s, ssize_t len)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tssize_t ssent = 0;\n\n\tstrcat(s, \"\\n\");\n\tlen++;\n\n\twhile (len > 0 ) {\n\t\tstruct timeval timeout = {1, 0};\n\t\tssize_t sent;\n\t\tfd_set wd;\nretry:\n\t\tFD_ZERO(&wd);\n\t\tFD_SET(sock, &wd);\n\t\tif (select(sock + 1, NULL, &wd, NULL, &timeout) < 1) {\n\t\t\tif (interrupted())\n\t\t\t\tgoto retry;\n\t\t\treturn SEND_SELECTFAIL;\n\t\t}\n#ifdef __APPLE__\n\t\tsent = send(pool->sock, s + ssent, len, SO_NOSIGPIPE);\n#elif WIN32\n\t\tsent = send(pool->sock, s + ssent, len, 0);\n#else\n\t\tsent = send(pool->sock, s + ssent, len, MSG_NOSIGNAL);\n#endif\n\t\tif (sent < 0) {\n\t\t\tif (!sock_blocks())\n\t\t\t\treturn SEND_SENDFAIL;\n\t\t\tsent = 0;\n\t\t}\n\t\tssent += sent;\n\t\tlen -= sent;\n\t}\n\n\tpool->sgminer_pool_stats.times_sent++;\n\tpool->sgminer_pool_stats.bytes_sent += ssent;\n\tpool->sgminer_pool_stats.net_bytes_sent += ssent;\n\treturn SEND_OK;\n}\n\nbool stratum_send(struct pool *pool, char *s, ssize_t len)\n{\n\tenum send_ret ret = SEND_INACTIVE;\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"SEND: %s\", s);\n\n\tmutex_lock(&pool->stratum_lock);\n\tif (pool->stratum_active)\n\t\tret = __stratum_send(pool, s, len);\n\tmutex_unlock(&pool->stratum_lock);\n\n\t/* This is to avoid doing applog under stratum_lock */\n\tswitch (ret) {\n\t\tdefault:\n\t\tcase SEND_OK:\n\t\t\tbreak;\n\t\tcase SEND_SELECTFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Write select failed on %s sock\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_SENDFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Failed to send in stratum_send\");\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_INACTIVE:\n\t\t\tapplog(LOG_DEBUG, \"Stratum send failed due to no pool stratum_active\");\n\t\t\tbreak;\n\t}\n\treturn (ret == SEND_OK);\n}\n\nstatic bool socket_full(struct pool *pool, int wait)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tstruct timeval timeout;\n\tfd_set rd;\n\n\tif (unlikely(wait < 0))\n\t\twait = 0;\n\tFD_ZERO(&rd);\n\tFD_SET(sock, &rd);\n\ttimeout.tv_usec = 0;\n\ttimeout.tv_sec = wait;\n\tif (select(sock + 1, &rd, NULL, NULL, &timeout) > 0)\n\t\treturn true;\n\treturn false;\n}\n\n/* Check to see if Santa's been good to you */\nbool sock_full(struct pool *pool)\n{\n\tif (strlen(pool->sockbuf))\n\t\treturn true;\n\n\treturn (socket_full(pool, 0));\n}\n\nstatic void clear_sockbuf(struct pool *pool)\n{\n\tstrcpy(pool->sockbuf, \"\");\n}\n\nstatic void clear_sock(struct pool *pool)\n{\n\tssize_t n;\n\n\tmutex_lock(&pool->stratum_lock);\n\tdo {\n\t\tif (pool->sock)\n\t\t\tn = recv(pool->sock, pool->sockbuf, RECVSIZE, 0);\n\t\telse\n\t\t\tn = 0;\n\t} while (n > 0);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tclear_sockbuf(pool);\n}\n\n/* Make sure the pool sockbuf is large enough to cope with any coinbase size\n * by reallocing it to a large enough size rounded up to a multiple of RBUFSIZE\n * and zeroing the new memory */\nstatic void recalloc_sock(struct pool *pool, size_t len)\n{\n\tsize_t old, newlen;\n\n\told = strlen(pool->sockbuf);\n\tnewlen = old + len + 1;\n\tif (newlen < pool->sockbuf_size)\n\t\treturn;\n\tnewlen = newlen + (RBUFSIZE - (newlen % RBUFSIZE));\n\t// Avoid potentially recursive locking\n\t// applog(LOG_DEBUG, \"Recallocing pool sockbuf to %d\", new);\n\tpool->sockbuf = (char *)realloc(pool->sockbuf, newlen);\n\tif (!pool->sockbuf)\n\t\tquithere(1, \"Failed to realloc pool sockbuf\");\n\tmemset(pool->sockbuf + old, 0, newlen - old);\n\tpool->sockbuf_size = newlen;\n}\n\n/* Peeks at a socket to find the first end of line and then reads just that\n * from the socket and returns that as a malloced char */\nchar *recv_line(struct pool *pool)\n{\n\tchar *tok, *sret = NULL;\n\tssize_t len, buflen;\n\tint waited = 0;\n\n\tif (!strstr(pool->sockbuf, \"\\n\")) {\n\t\tstruct timeval rstart, now;\n\n\t\tcgtime(&rstart);\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\t\tapplog(LOG_DEBUG, \"Timed out waiting for data on socket_full\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tdo {\n\t\t\tchar s[RBUFSIZE];\n\t\t\tsize_t slen;\n\t\t\tssize_t n;\n\n\t\t\tmemset(s, 0, RBUFSIZE);\n\t\t\tn = recv(pool->sock, s, RECVSIZE, 0);\n\t\t\tif (!n) {\n\t\t\t\tapplog(LOG_DEBUG, \"Socket closed waiting in recv_line\");\n\t\t\t\tsuspend_stratum(pool);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcgtime(&now);\n\t\t\twaited = tdiff(&now, &rstart);\n\t\t\tif (n < 0) {\n\t\t\t\tif (!sock_blocks() || !socket_full(pool, DEFAULT_SOCKWAIT - waited)) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"Failed to recv sock in recv_line\");\n\t\t\t\t\tsuspend_stratum(pool);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslen = strlen(s);\n\t\t\t\trecalloc_sock(pool, slen);\n\t\t\t\tstrcat(pool->sockbuf, s);\n\t\t\t}\n\t\t} while (waited < DEFAULT_SOCKWAIT && !strstr(pool->sockbuf, \"\\n\"));\n\t}\n\n\tbuflen = strlen(pool->sockbuf);\n\ttok = strtok(pool->sockbuf, \"\\n\");\n\tif (!tok) {\n\t\tapplog(LOG_DEBUG, \"Failed to parse a \\\\n terminated string in recv_line\");\n\t\tgoto out;\n\t}\n\tsret = strdup(tok);\n\tlen = strlen(sret);\n\n\t/* Copy what's left in the buffer after the \\n, including the\n\t * terminating \\0 */\n\tif (buflen > len + 1)\n\t\tmemmove(pool->sockbuf, pool->sockbuf + len + 1, buflen - len + 1);\n\telse\n\t\tstrcpy(pool->sockbuf, \"\");\n\n\tpool->sgminer_pool_stats.times_received++;\n\tpool->sgminer_pool_stats.bytes_received += len;\n\tpool->sgminer_pool_stats.net_bytes_received += len;\nout:\n\tif (!sret)\n\t\tclear_sock(pool);\n\telse if (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"RECVD: %s\", sret);\n\treturn sret;\n}\n\n/* Extracts a string value from a json array with error checking. To be used\n * when the value of the string returned is only examined and not to be stored.\n * See json_array_string below */\nstatic char *__json_array_string(json_t *val, unsigned int entry)\n{\n\tjson_t *arr_entry;\n\n\tif (json_is_null(val))\n\t\treturn NULL;\n\tif (!json_is_array(val))\n\t\treturn NULL;\n\tif (entry > json_array_size(val))\n\t\treturn NULL;\n\tarr_entry = json_array_get(val, entry);\n\tif (!json_is_string(arr_entry))\n\t\treturn NULL;\n\n\treturn (char *)json_string_value(arr_entry);\n}\n\n/* Creates a freshly malloced dup of __json_array_string */\nstatic char *json_array_string(json_t *val, unsigned int entry)\n{\n\tchar *buf = __json_array_string(val, entry);\n\n\tif (buf)\n\t\treturn strdup(buf);\n\treturn NULL;\n}\n\nstatic char *blank_merkel = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nstatic bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, *header;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tunsigned char *cb1, *cb2;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = json_array_string(val, 5);\n\tnbit = json_array_string(val, 6);\n\tntime = json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n\t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (prev_hash)\n\t\t\tfree(prev_hash);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n\t\tif (bbversion)\n\t\t\tfree(bbversion);\n\t\tif (nbit)\n\t\t\tfree(nbit);\n\t\tif (ntime)\n\t\t\tfree(ntime);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tfree(pool->swork.prev_hash);\n\tfree(pool->swork.bbversion);\n\tfree(pool->swork.nbit);\n\tfree(pool->swork.ntime);\n\tpool->swork.job_id = job_id;\n\tpool->swork.prev_hash = prev_hash;\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tpool->swork.bbversion = bbversion;\n\tpool->swork.nbit = nbit;\n\tpool->swork.ntime = ntime;\n\tpool->swork.clean = clean;\n\talloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->swork.merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = (unsigned char *)malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\thex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t}\n\t}\n\tpool->swork.merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n\tpool->merkle_offset = strlen(pool->swork.bbversion) +\n\t\t\t      strlen(pool->swork.prev_hash);\n\tpool->swork.header_len = pool->merkle_offset +\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->swork.ntime) +\n\t\t\t\t strlen(pool->swork.nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n\tpool->merkle_offset /= 2;\n\tpool->swork.header_len = pool->swork.header_len * 2 + 1;\n\talign_len(&pool->swork.header_len);\n\theader = (char *)alloca(pool->swork.header_len);\n\tsnprintf(header, pool->swork.header_len,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->swork.bbversion,\n\t\tpool->swork.prev_hash,\n\t\tblank_merkel,\n\t\tpool->swork.ntime,\n\t\tpool->swork.nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tif (unlikely(!hex2bin(pool->header_bin, header, 128)))\n\t\tquit(1, \"Failed to convert header to header_bin in parse_notify\");\n\n\tcb1 = (unsigned char *)calloc(cb1_len, 1);\n\tif (unlikely(!cb1))\n\t\tquithere(1, \"Failed to calloc cb1 in parse_notify\");\n\thex2bin(cb1, coinbase1, cb1_len);\n\tcb2 = (unsigned char *)calloc(cb2_len, 1);\n\tif (unlikely(!cb2))\n\t\tquithere(1, \"Failed to calloc cb2 in parse_notify\");\n\thex2bin(cb2, coinbase2, cb2_len);\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = (unsigned char *)calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\tfree(cb1);\n\tfree(cb2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tret = true;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n\nstatic bool parse_diff(struct pool *pool, json_t *val)\n{\n\tdouble old_diff, diff;\n\n\tif (opt_diff_mult == 0.0)\n\t\tdiff = json_number_value(json_array_get(val, 0)) * pool->algorithm.diff_multiplier1;\n\telse\n\t\tdiff = json_number_value(json_array_get(val, 0)) * opt_diff_mult;\n\n\tif (diff == 0)\n\t\treturn false;\n\n\tcg_wlock(&pool->data_lock);\n\told_diff = pool->swork.diff;\n\tpool->swork.diff = diff;\n\tcg_wunlock(&pool->data_lock);\n\n\tif (old_diff != diff) {\n\t\tint idiff = diff;\n\n\t\tif ((double)idiff == diff)\n\t\t\tapplog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %d\", get_pool_name(pool), idiff);\n\t\telse\n\t\t\tapplog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %.3f\", get_pool_name(pool), diff);\n\t} else\n\t\tapplog(LOG_DEBUG, \"%s difficulty set to %f\", get_pool_name(pool), diff);\n\n\treturn true;\n}\n\nstatic bool parse_extranonce(struct pool *pool, json_t *val)\n{\n\tchar *nonce1;\n\tint n2size;\n\n\tnonce1 = json_array_string(val, 0);\n\tif (!nonce1) {\n\t\treturn false;\n\t}\n\tn2size = json_integer_value(json_array_get(val, 1));\n\tif (!n2size) {\n\t\tfree(nonce1);\n\t\treturn false;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\n\tapplog(LOG_NOTICE, \"%s extranonce change requested\", get_pool_name(pool));\n\n\treturn true;\n}\n\nstatic void __suspend_stratum(struct pool *pool)\n{\n\tclear_sockbuf(pool);\n\tpool->stratum_active = pool->stratum_notify = false;\n\tif (pool->sock)\n\t\tCLOSESOCKET(pool->sock);\n\tpool->sock = 0;\n}\n\nstatic bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect received but is disabled, not reconnecting.\");\n\t\treturn false;\n\t}\n\n\tchar *url, *port, address[256];\n\tchar *sockaddr_url, *stratum_port, *tmp; /* Tempvars. */\n\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsnprintf(address, sizeof(address), \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool send_version(struct pool *pool, json_t *val)\n{\n\tchar s[RBUFSIZE];\n\tint id = json_integer_value(json_object_get(val, \"id\"));\n\n\tif (!id)\n\t\treturn false;\n\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"result\\\": \\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"error\\\": null}\", id);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool show_message(struct pool *pool, json_t *val)\n{\n\tchar *msg;\n\n\tif (!json_is_array(val))\n\t\treturn false;\n\tmsg = (char *)json_string_value(json_array_get(val, 0));\n\tif (!msg)\n\t\treturn false;\n\tapplog(LOG_NOTICE, \"%s message: %s\", get_pool_name(pool), msg);\n\treturn true;\n}\n\nbool parse_method(struct pool *pool, char *s)\n{\n\tjson_t *val = NULL, *method, *err_val, *params;\n\tjson_error_t err;\n\tbool ret = false;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn ret;\n\n\tval = JSON_LOADS(s, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\treturn ret;\n\t}\n\n\tmethod = json_object_get(val, \"method\");\n\tif (!method) {\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\terr_val = json_object_get(val, \"error\");\n\tparams = json_object_get(val, \"params\");\n\n\tif (err_val && !json_is_null(err_val)) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC method decode failed: %s\", ss);\n\n\t\tjson_decref(val);\n\t\tfree(ss);\n\n\t\treturn ret;\n\t}\n\n\tbuf = (char *)json_string_value(method);\n\tif (!buf) {\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.notify\", 13)) {\n\t\tif (parse_notify(pool, params))\n\t\t\tpool->stratum_notify = ret = true;\n\t\telse\n\t\t\tpool->stratum_notify = ret = false;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.set_difficulty\", 21) && parse_diff(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.set_extranonce\", 21) && parse_extranonce(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"client.reconnect\", 16) && parse_reconnect(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"client.get_version\", 18) && send_version(pool, val)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"client.show_message\", 19) && show_message(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tjson_decref(val);\n\treturn ret;\n}\n\nbool subscribe_extranonce(struct pool *pool)\n{\n\tjson_t *val = NULL, *res_val, *err_val;\n\tchar s[RBUFSIZE], *sret = NULL;\n\tjson_error_t err;\n\tbool ret = false;\n\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.extranonce.subscribe\\\", \\\"params\\\": []}\",\n\t\tswork_id++);\n\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\n\t/* Parse all data in the queue and anything left should be the response */\n\twhile (42) {\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT / 30)) {\n\t\t\tapplog(LOG_DEBUG, \"Timed out waiting for response extranonce.subscribe\");\n\t\t\t/* some pool doesnt send anything, so this is normal */\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {\n\t\tchar *ss;\n\n\t\tif (err_val) {\n\t\t\tss = __json_array_string(err_val, 1);\n\t\t\tif (!ss)\n\t\t\t\tss = (char *)json_string_value(err_val);\n\t\t\tif (ss && (strcmp(ss, \"Method 'subscribe' not found for service 'mining.extranonce'\") == 0)) {\n\t\t\t\tapplog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));\n\t\t\t\tret = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ss && (strcmp(ss, \"Unrecognized request provided\") == 0)) {\n\t\t\t\tapplog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));\n\t\t\t\tret = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\t}\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tret = true;\n\tapplog(LOG_INFO, \"Stratum extranonce subscribe for %s\", get_pool_name(pool));\n\nout:\n\tjson_decref(val);\n\treturn ret;\n}\n\nbool auth_stratum(struct pool *pool)\n{\n\tjson_t *val = NULL, *res_val, *err_val;\n\tchar s[RBUFSIZE], *sret = NULL;\n\tjson_error_t err;\n\tbool ret = false;\n\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.authorize\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\",\n\t\tswork_id++, pool->rpc_user, pool->rpc_pass);\n\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\n\t/* Parse all data in the queue and anything left should be auth */\n\twhile (42) {\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);\n\t\tfree(ss);\n\n\t\tsuspend_stratum(pool);\n\n\t\tgoto out;\n\t}\n\n\tret = true;\n\tapplog(LOG_INFO, \"Stratum authorisation success for %s\", get_pool_name(pool));\n\tpool->probed = true;\n\tsuccessful_connect = true;\n\nout:\n\tjson_decref(val);\n\treturn ret;\n}\n\nstatic int recv_byte(int sockd)\n{\n\tchar c;\n\n\tif (recv(sockd, &c, 1, 0) != -1)\n\t\treturn c;\n\n\treturn -1;\n}\n\nstatic bool http_negotiate(struct pool *pool, int sockd, bool http0)\n{\n\tchar buf[1024];\n\tint i, len;\n\n\tif (http0) {\n\t\tsnprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.0\\r\\n\\r\\n\",\n\t\t\tpool->sockaddr_url, pool->stratum_port);\n\t} else {\n\t\tsnprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.1\\r\\nHost: %s:%s\\r\\n\\r\\n\",\n\t\t\tpool->sockaddr_url, pool->stratum_port, pool->sockaddr_url,\n\t\t\tpool->stratum_port);\n\t}\n\tapplog(LOG_DEBUG, \"Sending proxy %s:%s - %s\",\n\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\tsend(sockd, buf, strlen(buf), 0);\n\tlen = recv(sockd, buf, 12, 0);\n\tif (len <= 0) {\n\t\tapplog(LOG_WARNING, \"Couldn't read from proxy %s:%s after sending CONNECT\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\treturn false;\n\t}\n\tbuf[len] = '\\0';\n\tapplog(LOG_DEBUG, \"Received from proxy %s:%s - %s\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\tif (strcmp(buf, \"HTTP/1.1 200\") && strcmp(buf, \"HTTP/1.0 200\")) {\n\t\tapplog(LOG_WARNING, \"HTTP Error from proxy %s:%s - %s\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\t\treturn false;\n\t}\n\n\t/* Ignore unwanted headers till we get desired response */\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[i] = recv_byte(sockd);\n\t\tif (buf[i] == (char)-1) {\n\t\t\tapplog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\treturn false;\n\t\t}\n\t}\n\twhile (strncmp(buf, \"\\r\\n\\r\\n\", 4)) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tbuf[i] = buf[i + 1];\n\t\tbuf[3] = recv_byte(sockd);\n\t\tif (buf[3] == (char)-1) {\n\t\t\tapplog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tapplog(LOG_DEBUG, \"Success negotiating with %s:%s HTTP proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\treturn true;\n}\n\nstatic bool socks5_negotiate(struct pool *pool, int sockd)\n{\n\tunsigned char atyp, uclen;\n\tunsigned short port;\n\tchar buf[515];\n\tint i, len;\n\n\tbuf[0] = 0x05;\n\tbuf[1] = 0x01;\n\tbuf[2] = 0x00;\n\tapplog(LOG_DEBUG, \"Attempting to negotiate with %s:%s SOCKS5 proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\tsend(sockd, buf, 3, 0);\n\tif (recv_byte(sockd) != 0x05 || recv_byte(sockd) != buf[2]) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\n\tbuf[0] = 0x05;\n\tbuf[1] = 0x01;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x03;\n\tlen = (strlen(pool->sockaddr_url));\n\tif (len > 255)\n\t\tlen = 255;\n\tuclen = len;\n\tbuf[4] = (uclen & 0xff);\n\tmemcpy(buf + 5, pool->sockaddr_url, len);\n\tport = atoi(pool->stratum_port);\n\tbuf[5 + len] = (port >> 8);\n\tbuf[6 + len] = (port & 0xff);\n\tsend(sockd, buf, (7 + len), 0);\n\tif (recv_byte(sockd) != 0x05 || recv_byte(sockd) != 0x00) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\n\trecv_byte(sockd);\n\tatyp = recv_byte(sockd);\n\tif (atyp == 0x01) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\trecv_byte(sockd);\n\t} else if (atyp == 0x03) {\n\t\tlen = recv_byte(sockd);\n\t\tfor (i = 0; i < len; i++)\n\t\t\trecv_byte(sockd);\n\t} else {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 2; i++)\n\t\trecv_byte(sockd);\n\n\tapplog(LOG_DEBUG, \"Success negotiating with %s:%s SOCKS5 proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\treturn true;\n}\n\nstatic bool socks4_negotiate(struct pool *pool, int sockd, bool socks4a)\n{\n\tunsigned short port;\n\tin_addr_t inp;\n\tchar buf[515];\n\tint i, len;\n\tint ret;\n\n\tbuf[0] = 0x04;\n\tbuf[1] = 0x01;\n\tport = atoi(pool->stratum_port);\n\tbuf[2] = port >> 8;\n\tbuf[3] = port & 0xff;\n\tsprintf(&buf[8], \"SGMINER\");\n\n\t/* See if we've been given an IP address directly to avoid needing to\n\t * resolve it. */\n\tinp = inet_addr(pool->sockaddr_url);\n\tinp = ntohl(inp);\n\tif ((int)inp != -1)\n\t\tsocks4a = false;\n\telse {\n\t\t/* Try to extract the IP address ourselves first */\n\t\tstruct addrinfo servinfobase, *servinfo, hints;\n\n\t\tservinfo = &servinfobase;\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = AF_INET; /* IPV4 only */\n\t\tret = getaddrinfo(pool->sockaddr_url, NULL, &hints, &servinfo);\n\t\tif (!ret) {\n\t\t\tapplog(LOG_ERR, \"getaddrinfo() in socks4_negotiate() returned %i: %s\", ret, gai_strerror(ret));\n\n\t\t\tstruct sockaddr_in *saddr_in = (struct sockaddr_in *)servinfo->ai_addr;\n\n\t\t\tinp = ntohl(saddr_in->sin_addr.s_addr);\n\t\t\tsocks4a = false;\n\t\t\tfreeaddrinfo(servinfo);\n\t\t}\n\t}\n\n\tif (!socks4a) {\n\t\tif ((int)inp == -1) {\n\t\t\tapplog(LOG_WARNING, \"Invalid IP address specified for socks4 proxy: %s\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tbuf[4] = (inp >> 24) & 0xFF;\n\t\tbuf[5] = (inp >> 16) & 0xFF;\n\t\tbuf[6] = (inp >>  8) & 0xFF;\n\t\tbuf[7] = (inp >>  0) & 0xFF;\n\t\tsend(sockd, buf, 16, 0);\n\t} else {\n\t\t/* This appears to not be working but hopefully most will be\n\t\t * able to resolve IP addresses themselves. */\n\t\tbuf[4] = 0;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t\tlen = strlen(pool->sockaddr_url);\n\t\tif (len > 255)\n\t\t\tlen = 255;\n\t\tmemcpy(&buf[16], pool->sockaddr_url, len);\n\t\tlen += 16;\n\t\tbuf[len++] = '\\0';\n\t\tsend(sockd, buf, len, 0);\n\t}\n\n\tif (recv_byte(sockd) != 0x00 || recv_byte(sockd) != 0x5a) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS4 server\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\trecv_byte(sockd);\n\n\treturn true;\n}\n\nstatic void noblock_socket(SOCKETTYPE fd)\n{\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, O_NONBLOCK | flags);\n#else\n\tu_long flags = 1;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n}\n\nstatic void block_socket(SOCKETTYPE fd)\n{\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, flags & ~O_NONBLOCK);\n#else\n\tu_long flags = 0;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n}\n\nstatic bool sock_connecting(void)\n{\n#ifndef WIN32\n\treturn errno == EINPROGRESS;\n#else\n\treturn WSAGetLastError() == WSAEWOULDBLOCK;\n#endif\n}\nstatic bool setup_stratum_socket(struct pool *pool)\n{\n\tstruct addrinfo servinfobase, *servinfo, *hints, *p;\n\tchar *sockaddr_url, *sockaddr_port;\n\tint sockd;\n\tint ret;\n\n\tmutex_lock(&pool->stratum_lock);\n\tpool->stratum_active = false;\n\tif (pool->sock) {\n\t\t/* FIXME: change to LOG_DEBUG if issue #88 resolved */\n\t\tapplog(LOG_INFO, \"Closing %s socket\", get_pool_name(pool));\n\t\tCLOSESOCKET(pool->sock);\n\t}\n\tpool->sock = 0;\n\tmutex_unlock(&pool->stratum_lock);\n\n\thints = &pool->stratum_hints;\n\tmemset(hints, 0, sizeof(struct addrinfo));\n\thints->ai_family = AF_UNSPEC;\n\thints->ai_socktype = SOCK_STREAM;\n\tservinfo = &servinfobase;\n\n\tif (!pool->rpc_proxy && opt_socks_proxy) {\n\t\tpool->rpc_proxy = opt_socks_proxy;\n\t\textract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);\n\t\tpool->rpc_proxytype = PROXY_SOCKS5;\n\t}\n\n\tif (pool->rpc_proxy) {\n\t\tsockaddr_url = pool->sockaddr_proxy_url;\n\t\tsockaddr_port = pool->sockaddr_proxy_port;\n\t} else {\n\t\tsockaddr_url = pool->sockaddr_url;\n\t\tsockaddr_port = pool->stratum_port;\n\t}\n\n\tret = getaddrinfo(sockaddr_url, sockaddr_port, hints, &servinfo);\n\tif (ret) {\n\t\tapplog(LOG_INFO, \"getaddrinfo() in setup_stratum_socket() returned %i: %s\", ret, gai_strerror(ret));\n\t\tif (!pool->probed) {\n\t\t\tapplog(LOG_WARNING, \"Failed to resolve (wrong URL?) %s:%s\",\n\t\t\t       sockaddr_url, sockaddr_port);\n\t\t\tpool->probed = true;\n\t\t} else {\n\t\t\tapplog(LOG_INFO, \"Failed to getaddrinfo for %s:%s\",\n\t\t\t       sockaddr_url, sockaddr_port);\n\t\t}\n\t\treturn false;\n\t}\n\n\tfor (p = servinfo; p != NULL; p = p->ai_next) {\n\t\tsockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n\t\tif (sockd == -1) {\n\t\t\tapplog(LOG_DEBUG, \"Failed socket\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Iterate non blocking over entries returned by getaddrinfo\n\t\t * to cope with round robin DNS entries, finding the first one\n\t\t * we can connect to quickly. */\n\t\tnoblock_socket(sockd);\n\t\tif (connect(sockd, p->ai_addr, p->ai_addrlen) == -1) {\n\t\t\tstruct timeval tv_timeout = {1, 0};\n\t\t\tint selret;\n\t\t\tfd_set rw;\n\n\t\t\tif (!sock_connecting()) {\n\t\t\t\tCLOSESOCKET(sockd);\n\t\t\t\tapplog(LOG_DEBUG, \"Failed sock connect\");\n\t\t\t\tcontinue;\n\t\t\t}\nretry:\n\t\t\tFD_ZERO(&rw);\n\t\t\tFD_SET(sockd, &rw);\n\t\t\tselret = select(sockd + 1, NULL, &rw, NULL, &tv_timeout);\n\t\t\tif  (selret > 0 && FD_ISSET(sockd, &rw)) {\n\t\t\t\tsocklen_t len;\n\t\t\t\tint err, n;\n\n\t\t\t\tlen = sizeof(err);\n\t\t\t\tn = getsockopt(sockd, SOL_SOCKET, SO_ERROR, (char *)&err, &len);\n\t\t\t\tif (!n && !err) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"Succeeded delayed connect\");\n\t\t\t\t\tblock_socket(sockd);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selret < 0 && interrupted())\n\t\t\t\tgoto retry;\n\t\t\tCLOSESOCKET(sockd);\n\t\t\tapplog(LOG_DEBUG, \"Select timeout/failed connect\");\n\t\t\tcontinue;\n\t\t}\n\t\tapplog(LOG_WARNING, \"Succeeded immediate connect\");\n\t\tblock_socket(sockd);\n\n\t\tbreak;\n\t}\n\tif (p == NULL) {\n\t\tapplog(LOG_INFO, \"Failed to connect to stratum on %s:%s\",\n\t\t       sockaddr_url, sockaddr_port);\n\t\tfreeaddrinfo(servinfo);\n\t\treturn false;\n\t}\n\tfreeaddrinfo(servinfo);\n\n\tif (pool->rpc_proxy) {\n\t\tswitch (pool->rpc_proxytype) {\n\t\t\tcase PROXY_HTTP_1_0:\n\t\t\t\tif (!http_negotiate(pool, sockd, true))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_HTTP:\n\t\t\t\tif (!http_negotiate(pool, sockd, false))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS5:\n\t\t\tcase PROXY_SOCKS5H:\n\t\t\t\tif (!socks5_negotiate(pool, sockd))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS4:\n\t\t\t\tif (!socks4_negotiate(pool, sockd, false))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS4A:\n\t\t\t\tif (!socks4_negotiate(pool, sockd, true))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tapplog(LOG_WARNING, \"Unsupported proxy type for %s:%s\",\n\t\t\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pool->sockbuf) {\n\t\tpool->sockbuf = (char *)calloc(RBUFSIZE, 1);\n\t\tif (!pool->sockbuf)\n\t\t\tquithere(1, \"Failed to calloc pool sockbuf\");\n\t\tpool->sockbuf_size = RBUFSIZE;\n\t}\n\n\tpool->sock = sockd;\n\tkeep_sockalive(sockd);\n\treturn true;\n}\n\nstatic char *get_sessionid(json_t *val)\n{\n\tchar *ret = NULL;\n\tjson_t *arr_val;\n\tint arrsize, i;\n\n\tarr_val = json_array_get(val, 0);\n\tif (!arr_val || !json_is_array(arr_val))\n\t\tgoto out;\n\tarrsize = json_array_size(arr_val);\n\tfor (i = 0; i < arrsize; i++) {\n\t\tjson_t *arr = json_array_get(arr_val, i);\n\t\tchar *notify;\n\n\t\tif (!arr | !json_is_array(arr))\n\t\t\tbreak;\n\t\tnotify = __json_array_string(arr, 0);\n\t\tif (!notify)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(notify, \"mining.notify\", 13)) {\n\t\t\tret = json_array_string(arr, 1);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nvoid suspend_stratum(struct pool *pool)\n{\n\tapplog(LOG_INFO, \"Closing socket for stratum %s\", get_pool_name(pool));\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\tmutex_unlock(&pool->stratum_lock);\n}\n\nbool initiate_stratum(struct pool *pool)\n{\n\tbool ret = false, recvd = false, noresume = false, sockd = false;\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tjson_error_t err;\n\tint n2size;\n\nresend:\n\tif (!setup_stratum_socket(pool)) {\n\t\t/* FIXME: change to LOG_DEBUG when issue #88 resolved */\n\t\tapplog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));\n\t\tsockd = false;\n\t\tgoto out;\n\t}\n\n\tsockd = true;\n\n\tif (recvd) {\n\t\t/* Get rid of any crap lying around if we're resending */\n\t\tclear_sock(pool);\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\t} else {\n\t\tif (pool->sessionid)\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"%s\\\"]}\", swork_id++, pool->sessionid);\n\t\telse\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\"]}\", swork_id++);\n\t}\n\n\tif (__stratum_send(pool, s, strlen(s)) != SEND_OK) {\n\t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\n\trecvd = true;\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\n\tif (sessionid)\n\t\tapplog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);\n\n\tret = true;\nout:\n\tif (ret) {\n\t\tif (!pool->stratum_url)\n\t\t\tpool->stratum_url = pool->sockaddr_url;\n\t\tpool->stratum_active = true;\n\t\tpool->swork.diff = 1;\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, \"%s confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n\t\t\t       get_pool_name(pool), pool->nonce1, pool->n2size);\n\t\t}\n\t} else {\n\t\tif (recvd && !noresume) {\n\t\t\t/* Reset the sessionid used for stratum resuming in case the pool\n\t\t\t* does not support it, or does not know how to respond to the\n\t\t\t* presence of the sessionid parameter. */\n\t\t\tcg_wlock(&pool->data_lock);\n\t\t\tfree(pool->sessionid);\n\t\t\tfree(pool->nonce1);\n\t\t\tpool->sessionid = pool->nonce1 = NULL;\n\t\t\tcg_wunlock(&pool->data_lock);\n\n\t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n\t\t\tnoresume = true;\n\t\t\tjson_decref(val);\n\t\t\tgoto resend;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"Initiating stratum failed on %s\", get_pool_name(pool));\n\t\tif (sockd) {\n\t\t  applog(LOG_DEBUG, \"Suspending stratum on %s\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t}\n\t}\n\n\tjson_decref(val);\n\treturn ret;\n}\n\nbool restart_stratum(struct pool *pool)\n{\n\tapplog(LOG_DEBUG, \"Restarting stratum on pool %s\", get_pool_name(pool));\n\n\tif (pool->stratum_active)\n\t\tsuspend_stratum(pool);\n\tif (!initiate_stratum(pool))\n\t\treturn false;\n\tif (pool->extranonce_subscribe && !subscribe_extranonce(pool))\n\t\treturn false;\n\tif (!auth_stratum(pool))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid dev_error(struct cgpu_info *dev, enum dev_reason reason)\n{\n\tdev->device_last_not_well = time(NULL);\n\tdev->device_not_well_reason = reason;\n\n\tswitch (reason) {\n\t\tcase REASON_THREAD_FAIL_INIT:\n\t\t\tdev->thread_fail_init_count++;\n\t\t\tbreak;\n\t\tcase REASON_THREAD_ZERO_HASH:\n\t\t\tdev->thread_zero_hash_count++;\n\t\t\tbreak;\n\t\tcase REASON_THREAD_FAIL_QUEUE:\n\t\t\tdev->thread_fail_queue_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_SICK_IDLE_60:\n\t\t\tdev->dev_sick_idle_60_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_DEAD_IDLE_600:\n\t\t\tdev->dev_dead_idle_600_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_NOSTART:\n\t\t\tdev->dev_nostart_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_OVER_HEAT:\n\t\t\tdev->dev_over_heat_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_THERMAL_CUTOFF:\n\t\t\tdev->dev_thermal_cutoff_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_COMMS_ERROR:\n\t\t\tdev->dev_comms_error_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_THROTTLE:\n\t\t\tdev->dev_throttle_count++;\n\t\t\tbreak;\n\t}\n}\n\n/* Realloc an existing string to fit an extra string s, appending s to it. */\nvoid *realloc_strcat(char *ptr, char *s)\n{\n\tsize_t old = strlen(ptr), len = strlen(s);\n\tchar *ret;\n\n\tif (!len)\n\t\treturn ptr;\n\n\tlen += old + 1;\n\talign_len(&len);\n\n\tret = (char *)malloc(len);\n\tif (unlikely(!ret))\n\t\tquithere(1, \"Failed to malloc\");\n\n\tsprintf(ret, \"%s%s\", ptr, s);\n\tfree(ptr);\n\treturn ret;\n}\n\nvoid RenameThread(const char* name)\n{\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"cg@%s\", name);\n#if defined(PR_SET_NAME)\n\t// Only the first 15 characters are used (16 - NUL terminator)\n\tprctl(PR_SET_NAME, buf, 0, 0, 0);\n#elif (defined(__FreeBSD__) || defined(__OpenBSD__))\n\tpthread_set_name_np(pthread_self(), buf);\n#elif defined(MAC_OSX)\n\tpthread_setname_np(buf);\n#else\n\t// Prevent warnings\n\t(void)buf;\n#endif\n}\n\n/* sgminer specific wrappers for true unnamed semaphore usage on platforms\n * that support them and for apple which does not. We use a single byte across\n * a pipe to emulate semaphore behaviour there. */\n#ifdef __APPLE__\nvoid _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tint flags, fd, i;\n\n\tif (pipe(cgsem->pipefd) == -1)\n\t\tquitfrom(1, file, func, line, \"Failed pipe errno=%d\", errno);\n\n\t/* Make the pipes FD_CLOEXEC to allow them to close should we call\n\t * execv on restart. */\n\tfor (i = 0; i < 2; i++) {\n\t\tfd = cgsem->pipefd[i];\n\t\tflags = fcntl(fd, F_GETFD, 0);\n\t\tflags |= FD_CLOEXEC;\n\t\tif (fcntl(fd, F_SETFD, flags) == -1)\n\t\t\tquitfrom(1, file, func, line, \"Failed to fcntl errno=%d\", errno);\n\t}\n}\n\nvoid _cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tconst char buf = 1;\n\tint ret;\n\nretry:\n\tret = write(cgsem->pipefd[1], &buf, 1);\n\tif (unlikely(ret == 0))\n\t\tapplog(LOG_WARNING, \"Failed to write errno=%d\" IN_FMT_FFL, errno, file, func, line);\n\telse if (unlikely(ret < 0 && interrupted))\n\t\tgoto retry;\n}\n\nvoid _cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tchar buf;\n\tint ret;\nretry:\n\tret = read(cgsem->pipefd[0], &buf, 1);\n\tif (unlikely(ret == 0))\n\t\tapplog(LOG_WARNING, \"Failed to read errno=%d\" IN_FMT_FFL, errno, file, func, line);\n\telse if (unlikely(ret < 0 && interrupted))\n\t\tgoto retry;\n}\n\nvoid cgsem_destroy(cgsem_t *cgsem)\n{\n\tclose(cgsem->pipefd[1]);\n\tclose(cgsem->pipefd[0]);\n}\n\n/* This is similar to sem_timedwait but takes a millisecond value */\nint _cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)\n{\n\tstruct timeval timeout;\n\tint ret, fd;\n\tfd_set rd;\n\tchar buf;\n\nretry:\n\tfd = cgsem->pipefd[0];\n\tFD_ZERO(&rd);\n\tFD_SET(fd, &rd);\n\tms_to_timeval(&timeout, ms);\n\tret = select(fd + 1, &rd, NULL, NULL, &timeout);\n\n\tif (ret > 0) {\n\t\tret = read(fd, &buf, 1);\n\t\treturn 0;\n\t}\n\tif (likely(!ret))\n\t\treturn ETIMEDOUT;\n\tif (interrupted())\n\t\tgoto retry;\n\tquitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);\n\t/* We don't reach here */\n\treturn 0;\n}\n\n/* Reset semaphore count back to zero */\nvoid cgsem_reset(cgsem_t *cgsem)\n{\n\tint ret, fd;\n\tfd_set rd;\n\tchar buf;\n\n\tfd = cgsem->pipefd[0];\n\tFD_ZERO(&rd);\n\tFD_SET(fd, &rd);\n\tdo {\n\t\tstruct timeval timeout = {0, 0};\n\n\t\tret = select(fd + 1, &rd, NULL, NULL, &timeout);\n\t\tif (ret > 0)\n\t\t\tret = read(fd, &buf, 1);\n\t\telse if (unlikely(ret < 0 && interrupted()))\n\t\t\tret = 1;\n\t} while (ret > 0);\n}\n#else\nvoid _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tint ret;\n\tif ((ret = sem_init(cgsem, 0, 0)))\n\t\tquitfrom(1, file, func, line, \"Failed to sem_init ret=%d errno=%d\", ret, errno);\n}\n\nvoid _cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tif (unlikely(sem_post(cgsem)))\n\t\tquitfrom(1, file, func, line, \"Failed to sem_post errno=%d cgsem=0x%p\", errno, cgsem);\n}\n\nvoid _cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\nretry:\n\tif (unlikely(sem_wait(cgsem))) {\n\t\tif (interrupted())\n\t\t\tgoto retry;\n\t\tquitfrom(1, file, func, line, \"Failed to sem_wait errno=%d cgsem=0x%p\", errno, cgsem);\n\t}\n}\n\nint _cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)\n{\n\tstruct timespec abs_timeout, ts_now;\n\tstruct timeval tv_now;\n\tint ret;\n\n\tcgtime(&tv_now);\n\ttimeval_to_spec(&ts_now, &tv_now);\n\tms_to_timespec(&abs_timeout, ms);\nretry:\n\ttimeraddspec(&abs_timeout, &ts_now);\n\tret = sem_timedwait(cgsem, &abs_timeout);\n\n\tif (ret) {\n\t\tif (likely(sock_timeout()))\n\t\t\treturn ETIMEDOUT;\n\t\tif (interrupted())\n\t\t\tgoto retry;\n\t\tquitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);\n\t}\n\treturn 0;\n}\n\nvoid cgsem_reset(cgsem_t *cgsem)\n{\n\tint ret;\n\n\tdo {\n\t\tret = sem_trywait(cgsem);\n\t\tif (unlikely(ret < 0 && interrupted()))\n\t\t\tret = 0;\n\t} while (!ret);\n}\n\nvoid cgsem_destroy(cgsem_t *cgsem)\n{\n\tsem_destroy(cgsem);\n}\n#endif\n\n/* Provide a completion_timeout helper function for unreliable functions that\n * may die due to driver issues etc that time out if the function fails and\n * can then reliably return. */\nstruct cg_completion {\n\tcgsem_t cgsem;\n\tvoid (*fn)(void *fnarg);\n\tvoid *fnarg;\n};\n\nvoid *completion_thread(void *arg)\n{\n\tstruct cg_completion *cgc = (struct cg_completion *)arg;\n\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\tcgc->fn(cgc->fnarg);\n\tcgsem_post(&cgc->cgsem);\n\n\treturn NULL;\n}\n\nbool cg_completion_timeout(void *fn, void *fnarg, int timeout)\n{\n\tstruct cg_completion *cgc;\n\tpthread_t pthread;\n\tbool ret = false;\n\n\tcgc = (struct cg_completion *)malloc(sizeof(struct cg_completion));\n\tif (unlikely(!cgc))\n\t\treturn ret;\n\tcgsem_init(&cgc->cgsem);\n\n#ifdef _MSC_VER\n\tcgc->fn = (void(__cdecl *)(void *))fn;\n#else\n\tcgc->fn = fn;\n#endif\n\n\tcgc->fnarg = fnarg;\n\n\tpthread_create(&pthread, NULL, completion_thread, (void *)cgc);\n\n\tret = cgsem_mswait(&cgc->cgsem, timeout);\n\n\tif (ret)\n\t\tpthread_cancel(pthread);\n\n\tpthread_join(pthread, NULL);\n\tfree(cgc);\n\treturn !ret;\n}\n"], "fixing_code": ["/*\n * Copyright 2011-2013 Con Kolivas\n * Copyright 2010 Jeff Garzik\n *\n * This program is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License as published by the Free\n * Software Foundation; either version 3 of the License, or (at your option)\n * any later version.  See COPYING for more details.\n */\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <stdarg.h>\n#include <string.h>\n#include <jansson.h>\n#ifdef HAVE_LIBCURL\n#include <curl/curl.h>\n#endif\n#include <time.h>\n#include <errno.h>\n#include <unistd.h>\n#include <sys/types.h>\n#ifndef WIN32\n#include <fcntl.h>\n# ifdef __linux__\n#  include <sys/prctl.h>\n# endif\n# include <sys/socket.h>\n# include <netinet/in.h>\n# include <netinet/tcp.h>\n# include <netdb.h>\n#else\n# include <windows.h>\n# include <winsock2.h>\n# include <ws2tcpip.h>\n# include <mmsystem.h>\n#endif\n\n#include \"miner.h\"\n#include \"elist.h\"\n#include \"compat.h\"\n#include \"util.h\"\n#include \"pool.h\"\n\n#define DEFAULT_SOCKWAIT 60\nextern double opt_diff_mult;\n\nbool successful_connect = false;\nstatic void keep_sockalive(SOCKETTYPE fd)\n{\n\tconst int tcp_one = 1;\n#ifndef WIN32\n\tconst int tcp_keepidle = 45;\n\tconst int tcp_keepintvl = 30;\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, O_NONBLOCK | flags);\n#else\n\tu_long flags = 1;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n\n\tsetsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, (const char *)&tcp_one, sizeof(tcp_one));\n\tif (!opt_delaynet)\n#ifndef __linux\n\t\tsetsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (const char *)&tcp_one, sizeof(tcp_one));\n#else /* __linux */\n\t\tsetsockopt(fd, SOL_TCP, TCP_NODELAY, (const void *)&tcp_one, sizeof(tcp_one));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPCNT, &tcp_one, sizeof(tcp_one));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPIDLE, &tcp_keepidle, sizeof(tcp_keepidle));\n\tsetsockopt(fd, SOL_TCP, TCP_KEEPINTVL, &tcp_keepintvl, sizeof(tcp_keepintvl));\n#endif /* __linux__ */\n\n#ifdef __APPLE_CC__\n\tsetsockopt(fd, IPPROTO_TCP, TCP_KEEPALIVE, &tcp_keepintvl, sizeof(tcp_keepintvl));\n#endif /* __APPLE_CC__ */\n\n}\n\nstruct tq_ent {\n\tvoid\t\t\t*data;\n\tstruct list_head\tq_node;\n};\n\n#ifdef HAVE_LIBCURL\nstruct timeval nettime;\n\nstruct data_buffer {\n\tvoid\t\t*buf;\n\tsize_t\t\tlen;\n};\n\nstruct upload_buffer {\n\tconst void\t*buf;\n\tsize_t\t\tlen;\n};\n\nstruct header_info {\n\tchar\t\t*lp_path;\n\tint\t\trolltime;\n\tchar\t\t*reason;\n\tchar\t\t*stratum_url;\n\tbool\t\thadrolltime;\n\tbool\t\tcanroll;\n\tbool\t\thadexpire;\n};\n\nstatic void databuf_free(struct data_buffer *db)\n{\n\tif (!db)\n\t\treturn;\n\n\tfree(db->buf);\n\n\tmemset(db, 0, sizeof(*db));\n}\n\nstatic size_t all_data_cb(const void *ptr, size_t size, size_t nmemb,\n\t\t\t  void *user_data)\n{\n\tstruct data_buffer *db = (struct data_buffer *)user_data;\n\tsize_t len = size * nmemb;\n\tsize_t oldlen, newlen;\n\tvoid *newmem;\n\tstatic const unsigned char zero = 0;\n\n\toldlen = db->len;\n\tnewlen = oldlen + len;\n\n\tnewmem = realloc(db->buf, newlen + 1);\n\tif (!newmem)\n\t\treturn 0;\n\n\tdb->buf = newmem;\n\tdb->len = newlen;\n\tmemcpy((uint8_t*)db->buf + oldlen, ptr, len);\n\tmemcpy((uint8_t*)db->buf + newlen, &zero, 1);\t/* null terminate */\n\n\treturn len;\n}\n\nstatic size_t upload_data_cb(void *ptr, size_t size, size_t nmemb,\n\t\t\t     void *user_data)\n{\n\tstruct upload_buffer *ub = (struct upload_buffer *)user_data;\n\tunsigned int len = size * nmemb;\n\n\tif (len > ub->len)\n\t\tlen = ub->len;\n\n\tif (len) {\n\t\tmemcpy(ptr, ub->buf, len);\n\t\tub->buf = (uint8_t*)ub->buf + len;\n\t\tub->len -= len;\n\t}\n\n\treturn len;\n}\n\nstatic size_t resp_hdr_cb(void *ptr, size_t size, size_t nmemb, void *user_data)\n{\n\tstruct header_info *hi = (struct header_info *)user_data;\n\tsize_t remlen, slen, ptrlen = size * nmemb;\n\tchar *rem, *val = NULL, *key = NULL;\n\tvoid *tmp;\n\n\tval = (char *)calloc(1, ptrlen);\n\tkey = (char *)calloc(1, ptrlen);\n\tif (!key || !val)\n\t\tgoto out;\n\n\ttmp = memchr(ptr, ':', ptrlen);\n\tif (!tmp || (tmp == ptr))\t/* skip empty keys / blanks */\n\t\tgoto out;\n\tslen = (uint8_t*)tmp - (uint8_t*)ptr;\n\tif ((slen + 1) == ptrlen)\t/* skip key w/ no value */\n\t\tgoto out;\n\tmemcpy(key, ptr, slen);\t\t/* store & nul term key */\n\tkey[slen] = 0;\n\n\trem = (char*)ptr + slen + 1;\t/* trim value's leading whitespace */\n\tremlen = ptrlen - slen - 1;\n\twhile ((remlen > 0) && (isspace(*rem))) {\n\t\tremlen--;\n\t\trem++;\n\t}\n\n\tmemcpy(val, rem, remlen);\t/* store value, trim trailing ws */\n\tval[remlen] = 0;\n\twhile ((*val) && (isspace(val[strlen(val) - 1])))\n\t\tval[strlen(val) - 1] = 0;\n\n\tif (!*val)\t\t\t/* skip blank value */\n\t\tgoto out;\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"HTTP hdr(%s): %s\", key, val);\n\n\tif (!strcasecmp(\"X-Roll-Ntime\", key)) {\n\t\thi->hadrolltime = true;\n\t\tif (!strncasecmp(\"N\", val, 1))\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime: N found\");\n\t\telse {\n\t\t\thi->canroll = true;\n\n\t\t\t/* Check to see if expire= is supported and if not, set\n\t\t\t * the rolltime to the default scantime */\n\t\t\tif (strlen(val) > 7 && !strncasecmp(\"expire=\", val, 7)) {\n\t\t\t\tsscanf(val + 7, \"%d\", &hi->rolltime);\n\t\t\t\thi->hadexpire = true;\n\t\t\t} else\n\t\t\t\thi->rolltime = opt_scantime;\n\t\t\tapplog(LOG_DEBUG, \"X-Roll-Ntime expiry set to %d\", hi->rolltime);\n\t\t}\n\t}\n\n\tif (!strcasecmp(\"X-Long-Polling\", key)) {\n\t\thi->lp_path = val;\t/* steal memory reference */\n\t\tval = NULL;\n\t}\n\n\tif (!strcasecmp(\"X-Reject-Reason\", key)) {\n\t\thi->reason = val;\t/* steal memory reference */\n\t\tval = NULL;\n\t}\n\n\tif (!strcasecmp(\"X-Stratum\", key)) {\n\t\thi->stratum_url = val;\n\t\tval = NULL;\n\t}\n\nout:\n\tfree(key);\n\tfree(val);\n\treturn ptrlen;\n}\n\nstatic void last_nettime(struct timeval *last)\n{\n\trd_lock(&netacc_lock);\n\tlast->tv_sec = nettime.tv_sec;\n\tlast->tv_usec = nettime.tv_usec;\n\trd_unlock(&netacc_lock);\n}\n\nstatic void set_nettime(void)\n{\n\twr_lock(&netacc_lock);\n\tcgtime(&nettime);\n\twr_unlock(&netacc_lock);\n}\n\n#if CURL_HAS_KEEPALIVE\nstatic void keep_curlalive(CURL *curl)\n{\n\tconst long int keepalive = 1;\n\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPALIVE, keepalive);\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPIDLE, opt_tcp_keepalive);\n\tcurl_easy_setopt(curl, CURLOPT_TCP_KEEPINTVL, opt_tcp_keepalive);\n}\n#else\nstatic void keep_curlalive(CURL *curl)\n{\n\tSOCKETTYPE sock;\n\n\tcurl_easy_getinfo(curl, CURLINFO_LASTSOCKET, (long *)&sock);\n\tkeep_sockalive(sock);\n}\n#endif\n\nstatic int curl_debug_cb(__maybe_unused CURL *handle, curl_infotype type,\n\t\t\t __maybe_unused char *data, size_t size, void *userdata)\n{\n\tstruct pool *pool = (struct pool *)userdata;\n\n\tswitch(type) {\n\t\tcase CURLINFO_HEADER_IN:\n\t\tcase CURLINFO_DATA_IN:\n\t\tcase CURLINFO_SSL_DATA_IN:\n\t\t\tpool->sgminer_pool_stats.net_bytes_received += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_HEADER_OUT:\n\t\tcase CURLINFO_DATA_OUT:\n\t\tcase CURLINFO_SSL_DATA_OUT:\n\t\t\tpool->sgminer_pool_stats.net_bytes_sent += size;\n\t\t\tbreak;\n\t\tcase CURLINFO_TEXT:\n\t\tdefault:\n\t\t\tbreak;\n\t}\n\treturn 0;\n}\n\njson_t *json_rpc_call(CURL *curl, const char *url,\n\t\t      const char *userpass, const char *rpc_req,\n\t\t      bool probe, bool longpoll, int *rolltime,\n\t\t      struct pool *pool, bool share)\n{\n\tlong timeout = longpoll ? (60 * 60) : 60;\n\tstruct data_buffer all_data = {NULL, 0};\n\tstruct header_info hi = {NULL, 0, NULL, NULL, false, false, false};\n\tchar len_hdr[64], user_agent_hdr[128];\n\tchar curl_err_str[CURL_ERROR_SIZE];\n\tstruct curl_slist *headers = NULL;\n\tstruct upload_buffer upload_data;\n\tjson_t *val, *err_val, *res_val;\n\tbool probing = false;\n\tdouble byte_count;\n\tjson_error_t err;\n\tint rc;\n\n\tmemset(&err, 0, sizeof(err));\n\n\t/* it is assumed that 'curl' is freshly [re]initialized at this pt */\n\n\tif (probe)\n\t\tprobing = !pool->probed;\n\tcurl_easy_setopt(curl, CURLOPT_TIMEOUT, timeout);\n\n\t// CURLOPT_VERBOSE won't write to stderr if we use CURLOPT_DEBUGFUNCTION\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_cb);\n\tcurl_easy_setopt(curl, CURLOPT_DEBUGDATA, (void *)pool);\n\tcurl_easy_setopt(curl, CURLOPT_VERBOSE, 1);\n\n\tcurl_easy_setopt(curl, CURLOPT_NOSIGNAL, 1);\n\tcurl_easy_setopt(curl, CURLOPT_URL, url);\n\tcurl_easy_setopt(curl, CURLOPT_ENCODING, \"\");\n\tcurl_easy_setopt(curl, CURLOPT_FAILONERROR, 1);\n\n\t/* Shares are staggered already and delays in submission can be costly\n\t * so do not delay them */\n\tif (!opt_delaynet || share)\n\t\tcurl_easy_setopt(curl, CURLOPT_TCP_NODELAY, 1);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, all_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_WRITEDATA, &all_data);\n\tcurl_easy_setopt(curl, CURLOPT_READFUNCTION, upload_data_cb);\n\tcurl_easy_setopt(curl, CURLOPT_READDATA, &upload_data);\n\tcurl_easy_setopt(curl, CURLOPT_ERRORBUFFER, curl_err_str);\n\tcurl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, resp_hdr_cb);\n\tcurl_easy_setopt(curl, CURLOPT_HEADERDATA, &hi);\n\tcurl_easy_setopt(curl, CURLOPT_USE_SSL, CURLUSESSL_TRY);\n\tif (pool->rpc_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, pool->rpc_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, pool->rpc_proxytype);\n\t} else if (opt_socks_proxy) {\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXY, opt_socks_proxy);\n\t\tcurl_easy_setopt(curl, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS4);\n\t}\n\tif (userpass) {\n\t\tcurl_easy_setopt(curl, CURLOPT_USERPWD, userpass);\n\t\tcurl_easy_setopt(curl, CURLOPT_HTTPAUTH, CURLAUTH_BASIC);\n\t}\n\tif (longpoll)\n\t\tkeep_curlalive(curl);\n\tcurl_easy_setopt(curl, CURLOPT_POST, 1);\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"JSON protocol request:\\n%s\", rpc_req);\n\n\tupload_data.buf = rpc_req;\n\tupload_data.len = strlen(rpc_req);\n\tsprintf(len_hdr, \"Content-Length: %lu\",\n\t\t(unsigned long) upload_data.len);\n\tsprintf(user_agent_hdr, \"User-Agent: %s\", PACKAGE_STRING);\n\n\theaders = curl_slist_append(headers,\n\t\t\"Content-type: application/json\");\n\theaders = curl_slist_append(headers,\n\t\t\"X-Mining-Extensions: longpoll midstate rollntime submitold\");\n\n\tif (likely(global_hashrate)) {\n\t\tchar ghashrate[255];\n\n\t\tsprintf(ghashrate, \"X-Mining-Hashrate: %llu\", global_hashrate);\n\t\theaders = curl_slist_append(headers, ghashrate);\n\t}\n\n\theaders = curl_slist_append(headers, len_hdr);\n\theaders = curl_slist_append(headers, user_agent_hdr);\n\theaders = curl_slist_append(headers, \"Expect:\"); /* disable Expect hdr*/\n\n\tcurl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n\n\tif (opt_delaynet) {\n\t\t/* Don't delay share submission, but still track the nettime */\n\t\tif (!share) {\n\t\t\tlong long now_msecs, last_msecs;\n\t\t\tstruct timeval now, last;\n\n\t\t\tcgtime(&now);\n\t\t\tlast_nettime(&last);\n\t\t\tnow_msecs = (long long)now.tv_sec * 1000;\n\t\t\tnow_msecs += now.tv_usec / 1000;\n\t\t\tlast_msecs = (long long)last.tv_sec * 1000;\n\t\t\tlast_msecs += last.tv_usec / 1000;\n\t\t\tif (now_msecs > last_msecs && now_msecs - last_msecs < 250) {\n\t\t\t\tstruct timespec rgtp;\n\n\t\t\t\trgtp.tv_sec = 0;\n\t\t\t\trgtp.tv_nsec = (250 - (now_msecs - last_msecs)) * 1000000;\n\t\t\t\tnanosleep(&rgtp, NULL);\n\t\t\t}\n\t\t}\n\t\tset_nettime();\n\t}\n\n\trc = curl_easy_perform(curl);\n\tif (rc) {\n\t\tapplog(LOG_INFO, \"HTTP request failed: %s\", curl_err_str);\n\t\tgoto err_out;\n\t}\n\n\tif (!all_data.buf) {\n\t\tapplog(LOG_DEBUG, \"Empty data received in json_rpc_call.\");\n\t\tgoto err_out;\n\t}\n\n\tpool->sgminer_pool_stats.times_sent++;\n\tif (curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &byte_count) == CURLE_OK)\n\t\tpool->sgminer_pool_stats.bytes_sent += byte_count;\n\tpool->sgminer_pool_stats.times_received++;\n\tif (curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &byte_count) == CURLE_OK)\n\t\tpool->sgminer_pool_stats.bytes_received += byte_count;\n\n\tif (probing) {\n\t\tpool->probed = true;\n\t\t/* If X-Long-Polling was found, activate long polling */\n\t\tif (hi.lp_path) {\n\t\t\tif (pool->hdr_path != NULL)\n\t\t\t\tfree(pool->hdr_path);\n\t\t\tpool->hdr_path = hi.lp_path;\n\t\t} else\n\t\t\tpool->hdr_path = NULL;\n\t\tif (hi.stratum_url) {\n\t\t\tpool->stratum_url = hi.stratum_url;\n\t\t\thi.stratum_url = NULL;\n\t\t}\n\t} else {\n\t\tif (hi.lp_path) {\n\t\t\tfree(hi.lp_path);\n\t\t\thi.lp_path = NULL;\n\t\t}\n\t\tif (hi.stratum_url) {\n\t\t\tfree(hi.stratum_url);\n\t\t\thi.stratum_url = NULL;\n\t\t}\n\t}\n\n\t*rolltime = hi.rolltime;\n\tpool->sgminer_pool_stats.rolltime = hi.rolltime;\n\tpool->sgminer_pool_stats.hadrolltime = hi.hadrolltime;\n\tpool->sgminer_pool_stats.canroll = hi.canroll;\n\tpool->sgminer_pool_stats.hadexpire = hi.hadexpire;\n\n\tval = JSON_LOADS((const char *)all_data.buf, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\n\t\tif (opt_protocol)\n\t\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", (char *)(all_data.buf));\n\n\t\tgoto err_out;\n\t}\n\n\tif (opt_protocol) {\n\t\tchar *s = json_dumps(val, JSON_INDENT(3));\n\n\t\tapplog(LOG_DEBUG, \"JSON protocol response:\\n%s\", s);\n\t\tfree(s);\n\t}\n\n\t/* JSON-RPC valid response returns a non-null 'result',\n\t * and a null 'error'.\n\t */\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val ||(err_val && !json_is_null(err_val))) {\n\t\tchar *s;\n\n\t\tif (err_val)\n\t\t\ts = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\ts = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC call failed: %s\", s);\n\n\t\tfree(s);\n\n\t\tgoto err_out;\n\t}\n\n\tif (hi.reason) {\n\t\tjson_object_set_new(val, \"reject-reason\", json_string(hi.reason));\n\t\tfree(hi.reason);\n\t\thi.reason = NULL;\n\t}\n\tsuccessful_connect = true;\n\tdatabuf_free(&all_data);\n\tcurl_slist_free_all(headers);\n\tcurl_easy_reset(curl);\n\treturn val;\n\nerr_out:\n\tdatabuf_free(&all_data);\n\tcurl_slist_free_all(headers);\n\tcurl_easy_reset(curl);\n\tif (!successful_connect)\n\t\tapplog(LOG_DEBUG, \"Failed to connect in json_rpc_call\");\n\tcurl_easy_setopt(curl, CURLOPT_FRESH_CONNECT, 1);\n\treturn NULL;\n}\n#define PROXY_HTTP\tCURLPROXY_HTTP\n#define PROXY_HTTP_1_0\tCURLPROXY_HTTP_1_0\n#define PROXY_SOCKS4\tCURLPROXY_SOCKS4\n#define PROXY_SOCKS5\tCURLPROXY_SOCKS5\n#define PROXY_SOCKS4A\tCURLPROXY_SOCKS4A\n#define PROXY_SOCKS5H\tCURLPROXY_SOCKS5_HOSTNAME\n#else /* HAVE_LIBCURL */\n#define PROXY_HTTP\t0\n#define PROXY_HTTP_1_0\t1\n#define PROXY_SOCKS4\t2\n#define PROXY_SOCKS5\t3\n#define PROXY_SOCKS4A\t4\n#define PROXY_SOCKS5H\t5\n#endif /* HAVE_LIBCURL */\n\nstatic struct {\n\tconst char *name;\n\tproxytypes_t proxytype;\n} proxynames[] = {\n\t{ \"http:\",\tPROXY_HTTP },\n\t{ \"http0:\",\tPROXY_HTTP_1_0 },\n\t{ \"socks4:\",\tPROXY_SOCKS4 },\n\t{ \"socks5:\",\tPROXY_SOCKS5 },\n\t{ \"socks4a:\",\tPROXY_SOCKS4A },\n\t{ \"socks5h:\",\tPROXY_SOCKS5H },\n\t{ NULL,\t(proxytypes_t)NULL }\n};\n\nconst char *proxytype(proxytypes_t proxytype)\n{\n\tint i;\n\n\tfor (i = 0; proxynames[i].name; i++)\n\t\tif (proxynames[i].proxytype == proxytype)\n\t\t\treturn proxynames[i].name;\n\n\treturn \"invalid\";\n}\n\nchar *get_proxy(char *url, struct pool *pool)\n{\n\tpool->rpc_proxy = NULL;\n\n\tchar *split;\n\tint plen, len, i;\n\n\tfor (i = 0; proxynames[i].name; i++) {\n\t\tplen = strlen(proxynames[i].name);\n\t\tif (strncmp(url, proxynames[i].name, plen) == 0) {\n\t\t\tif (!(split = strchr(url, '|')))\n\t\t\t\treturn url;\n\n\t\t\t*split = '\\0';\n\t\t\tlen = split - url;\n\t\t\tpool->rpc_proxy = (char *)malloc(1 + len - plen);\n\t\t\tif (!(pool->rpc_proxy))\n\t\t\t\tquithere(1, \"Failed to malloc rpc_proxy\");\n\n\t\t\tstrcpy(pool->rpc_proxy, url + plen);\n\t\t\textract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);\n\t\t\tpool->rpc_proxytype = proxynames[i].proxytype;\n\t\t\turl = split + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn url;\n}\n\n/* Adequate size s==len*2 + 1 must be alloced to use this variant */\nvoid __bin2hex(char *s, const unsigned char *p, size_t len)\n{\n\tint i;\n\tstatic const char hex[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'};\n\n\tfor (i = 0; i < (int)len; i++) {\n\t\t*s++ = hex[p[i] >> 4];\n\t\t*s++ = hex[p[i] & 0xF];\n\t}\n\t*s++ = '\\0';\n}\n\n/* Returns a malloced array string of a binary value of arbitrary length. The\n * array is rounded up to a 4 byte size to appease architectures that need\n * aligned array  sizes */\nchar *bin2hex(const unsigned char *p, size_t len)\n{\n\tssize_t slen;\n\tchar *s;\n\n\tslen = len * 2 + 1;\n\tif (slen % 4)\n\t\tslen += 4 - (slen % 4);\n\ts = (char *)calloc(slen, 1);\n\tif (unlikely(!s))\n\t\tquithere(1, \"Failed to calloc\");\n\n\t__bin2hex(s, p, len);\n\n\treturn s;\n}\n\n/* Does the reverse of bin2hex but does not allocate any ram */\nstatic const int hex2bin_tbl[256] = {\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n\t-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n};\nbool hex2bin(unsigned char *p, const char *hexstr, size_t len)\n{\n\tint nibble1, nibble2;\n\tunsigned char idx;\n\tbool ret = false;\n\n\twhile (*hexstr && len) {\n\t\tif (unlikely(!hexstr[1])) {\n\t\t\tapplog(LOG_ERR, \"hex2bin str truncated\");\n\t\t\treturn ret;\n\t\t}\n\n\t\tidx = *hexstr++;\n\t\tnibble1 = hex2bin_tbl[idx];\n\t\tidx = *hexstr++;\n\t\tnibble2 = hex2bin_tbl[idx];\n\n\t\tif (unlikely((nibble1 < 0) || (nibble2 < 0))) {\n\t\t\tapplog(LOG_ERR, \"hex2bin scan failed\");\n\t\t\treturn ret;\n\t\t}\n\n\t\t*p++ = (((unsigned char)nibble1) << 4) | ((unsigned char)nibble2);\n\t\t--len;\n\t}\n\n\tif (likely(len == 0 && *hexstr == 0))\n\t\tret = true;\n\treturn ret;\n}\n\nbool fulltest(const unsigned char *hash, const unsigned char *target)\n{\n\tuint32_t *hash32 = (uint32_t *)hash;\n\tuint32_t *target32 = (uint32_t *)target;\n\tbool rc = true;\n\tint i;\n\n\tfor (i = 28 / 4; i >= 0; i--) {\n\t\tuint32_t h32tmp = le32toh(hash32[i]);\n\t\tuint32_t t32tmp = le32toh(target32[i]);\n\n\t\tif (h32tmp > t32tmp) {\n\t\t\trc = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (h32tmp < t32tmp) {\n\t\t\trc = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (opt_debug) {\n\t\tunsigned char hash_swap[32], target_swap[32];\n\t\tchar *hash_str, *target_str;\n\n\t\tswab256(hash_swap, hash);\n\t\tswab256(target_swap, target);\n\t\thash_str = bin2hex(hash_swap, 32);\n\t\ttarget_str = bin2hex(target_swap, 32);\n\n\t\tapplog(LOG_DEBUG, \" Proof: %s\\nTarget: %s\\nTrgVal? %s\",\n\t\t\thash_str,\n\t\t\ttarget_str,\n\t\t\trc ? \"YES (hash <= target)\" :\n\t\t\t     \"no (false positive; hash > target)\");\n\n\t\tfree(hash_str);\n\t\tfree(target_str);\n\t}\n\n\treturn rc;\n}\n\nstruct thread_q *tq_new(void)\n{\n\tstruct thread_q *tq;\n\n\ttq = (struct thread_q *)calloc(1, sizeof(*tq));\n\tif (!tq)\n\t\treturn NULL;\n\n\tINIT_LIST_HEAD(&tq->q);\n\tpthread_mutex_init(&tq->mutex, NULL);\n\tpthread_cond_init(&tq->cond, NULL);\n\n\treturn tq;\n}\n\nvoid tq_free(struct thread_q *tq)\n{\n\tstruct tq_ent *ent, *iter;\n\n\tif (!tq)\n\t\treturn;\n\n\tlist_for_each_entry_safe(ent, iter, &tq->q, q_node) {\n\t\tlist_del(&ent->q_node);\n\t\tfree(ent);\n\t}\n\n\tpthread_cond_destroy(&tq->cond);\n\tpthread_mutex_destroy(&tq->mutex);\n\n\tmemset(tq, 0, sizeof(*tq));\t/* poison */\n\tfree(tq);\n}\n\nstatic void tq_freezethaw(struct thread_q *tq, bool frozen)\n{\n\tmutex_lock(&tq->mutex);\n\ttq->frozen = frozen;\n\tpthread_cond_signal(&tq->cond);\n\tmutex_unlock(&tq->mutex);\n}\n\nvoid tq_freeze(struct thread_q *tq)\n{\n\ttq_freezethaw(tq, true);\n}\n\nvoid tq_thaw(struct thread_q *tq)\n{\n\ttq_freezethaw(tq, false);\n}\n\nbool tq_push(struct thread_q *tq, void *data)\n{\n\tstruct tq_ent *ent;\n\tbool rc = true;\n\n\tent = (struct tq_ent *)calloc(1, sizeof(*ent));\n\tif (!ent)\n\t\treturn false;\n\n\tent->data = data;\n\tINIT_LIST_HEAD(&ent->q_node);\n\n\tmutex_lock(&tq->mutex);\n\tif (!tq->frozen) {\n\t\tlist_add_tail(&ent->q_node, &tq->q);\n\t} else {\n\t\tfree(ent);\n\t\trc = false;\n\t}\n\tpthread_cond_signal(&tq->cond);\n\tmutex_unlock(&tq->mutex);\n\n\treturn rc;\n}\n\nvoid *tq_pop(struct thread_q *tq, const struct timespec *abstime)\n{\n\tstruct tq_ent *ent;\n\tvoid *rval = NULL;\n\tint rc;\n\n\tmutex_lock(&tq->mutex);\n\tif (!list_empty(&tq->q))\n\t\tgoto pop;\n\n\tif (abstime)\n\t\trc = pthread_cond_timedwait(&tq->cond, &tq->mutex, abstime);\n\telse\n\t\trc = pthread_cond_wait(&tq->cond, &tq->mutex);\n\tif (rc)\n\t\tgoto out;\n\tif (list_empty(&tq->q))\n\t\tgoto out;\npop:\n\tent = list_entry(tq->q.next, struct tq_ent*, q_node);\n\trval = ent->data;\n\n\tlist_del(&ent->q_node);\n\tfree(ent);\nout:\n\tmutex_unlock(&tq->mutex);\n\n\treturn rval;\n}\n\nint thr_info_create(struct thr_info *thr, pthread_attr_t *attr, void *(*start) (void *), void *arg)\n{\n\tcgsem_init(&thr->sem);\n\n\treturn pthread_create(&thr->pth, attr, start, arg);\n}\n\nvoid thr_info_cancel(struct thr_info *thr)\n{\n\tif (!thr)\n\t\treturn;\n\n\tif (PTH(thr) != 0L) {\n\t\tpthread_cancel(thr->pth);\n\t\tPTH(thr) = 0L;\n\t}\n\tcgsem_destroy(&thr->sem);\n}\n\nvoid subtime(struct timeval *a, struct timeval *b)\n{\n\ttimersub(a, b, b);\n}\n\nvoid addtime(struct timeval *a, struct timeval *b)\n{\n\ttimeradd(a, b, b);\n}\n\nbool time_more(struct timeval *a, struct timeval *b)\n{\n\treturn timercmp(a, b, >);\n}\n\nbool time_less(struct timeval *a, struct timeval *b)\n{\n\treturn timercmp(a, b, <);\n}\n\nvoid copy_time(struct timeval *dest, const struct timeval *src)\n{\n\tmemcpy(dest, src, sizeof(struct timeval));\n}\n\nvoid timespec_to_val(struct timeval *val, const struct timespec *spec)\n{\n\tval->tv_sec = spec->tv_sec;\n\tval->tv_usec = spec->tv_nsec / 1000;\n}\n\nvoid timeval_to_spec(struct timespec *spec, const struct timeval *val)\n{\n\tspec->tv_sec = val->tv_sec;\n\tspec->tv_nsec = val->tv_usec * 1000;\n}\n\nvoid us_to_timeval(struct timeval *val, int64_t us)\n{\n\tlldiv_t tvdiv = lldiv(us, 1000000);\n\n\tval->tv_sec = tvdiv.quot;\n\tval->tv_usec = tvdiv.rem;\n}\n\nvoid us_to_timespec(struct timespec *spec, int64_t us)\n{\n\tlldiv_t tvdiv = lldiv(us, 1000000);\n\n\tspec->tv_sec = tvdiv.quot;\n\tspec->tv_nsec = tvdiv.rem * 1000;\n}\n\nvoid ms_to_timespec(struct timespec *spec, int64_t ms)\n{\n\tlldiv_t tvdiv = lldiv(ms, 1000);\n\n\tspec->tv_sec = tvdiv.quot;\n\tspec->tv_nsec = tvdiv.rem * 1000000;\n}\n\nvoid ms_to_timeval(struct timeval *val, int64_t ms)\n{\n\tlldiv_t tvdiv = lldiv(ms, 1000);\n\n\tval->tv_sec = tvdiv.quot;\n\tval->tv_usec = tvdiv.rem * 1000;\n}\n\nvoid timeraddspec(struct timespec *a, const struct timespec *b)\n{\n\ta->tv_sec += b->tv_sec;\n\ta->tv_nsec += b->tv_nsec;\n\tif (a->tv_nsec >= 1000000000) {\n\t\ta->tv_nsec -= 1000000000;\n\t\ta->tv_sec++;\n\t}\n}\n\nstatic int __maybe_unused timespec_to_ms(struct timespec *ts)\n{\n\treturn ts->tv_sec * 1000 + ts->tv_nsec / 1000000;\n}\n\n/* Subtract b from a */\nstatic void __maybe_unused timersubspec(struct timespec *a, const struct timespec *b)\n{\n\ta->tv_sec -= b->tv_sec;\n\ta->tv_nsec -= b->tv_nsec;\n\tif (a->tv_nsec < 0) {\n\t\ta->tv_nsec += 1000000000;\n\t\ta->tv_sec--;\n\t}\n}\n\n/* These are sgminer specific sleep functions that use an absolute nanosecond\n * resolution timer to avoid poor usleep accuracy and overruns. */\n#ifdef WIN32\n/* Windows start time is since 1601 LOL so convert it to unix epoch 1970. */\n#define EPOCHFILETIME (116444736000000000LL)\n\n/* Return the system time as an lldiv_t in decimicroseconds. */\nstatic void decius_time(lldiv_t *lidiv)\n{\n\tFILETIME ft;\n\tLARGE_INTEGER li;\n\n\tGetSystemTimeAsFileTime(&ft);\n\tli.LowPart  = ft.dwLowDateTime;\n\tli.HighPart = ft.dwHighDateTime;\n\tli.QuadPart -= EPOCHFILETIME;\n\n\t/* SystemTime is in decimicroseconds so divide by an unusual number */\n\t*lidiv = lldiv(li.QuadPart, 10000000);\n}\n\n/* This is a sgminer gettimeofday wrapper. Since we always call gettimeofday\n * with tz set to NULL, and windows' default resolution is only 15ms, this\n * gives us higher resolution times on windows. */\nvoid cgtime(struct timeval *tv)\n{\n\tlldiv_t lidiv;\n\n\tdecius_time(&lidiv);\n\ttv->tv_sec = lidiv.quot;\n\ttv->tv_usec = lidiv.rem / 10;\n}\n\n#else /* WIN32 */\nvoid cgtime(struct timeval *tv)\n{\n\tgettimeofday(tv, NULL);\n}\n\nint cgtimer_to_ms(cgtimer_t *cgt)\n{\n\treturn timespec_to_ms(cgt);\n}\n\n/* Subtracts b from a and stores it in res. */\nvoid cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)\n{\n\tres->tv_sec = a->tv_sec - b->tv_sec;\n\tres->tv_nsec = a->tv_nsec - b->tv_nsec;\n\tif (res->tv_nsec < 0) {\n\t\tres->tv_nsec += 1000000000;\n\t\tres->tv_sec--;\n\t}\n}\n#endif /* WIN32 */\n\n#ifdef CLOCK_MONOTONIC /* Essentially just linux */\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tclock_gettime(CLOCK_MONOTONIC, ts_start);\n}\n\nstatic void nanosleep_abstime(struct timespec *ts_end)\n{\n\tint ret;\n\n\tdo {\n\t\tret = clock_nanosleep(CLOCK_MONOTONIC, TIMER_ABSTIME, ts_end, NULL);\n\t} while (ret == EINTR);\n}\n\n/* Reentrant version of cgsleep functions allow start time to be set separately\n * from the beginning of the actual sleep, allowing scheduling delays to be\n * counted in the sleep. */\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tstruct timespec ts_end;\n\n\tms_to_timespec(&ts_end, ms);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}\n\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tstruct timespec ts_end;\n\n\tus_to_timespec(&ts_end, us);\n\ttimeraddspec(&ts_end, ts_start);\n\tnanosleep_abstime(&ts_end);\n}\n#else /* CLOCK_MONOTONIC */\n#ifdef __MACH__\n#include <mach/clock.h>\n#include <mach/mach.h>\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tclock_serv_t cclock;\n\tmach_timespec_t mts;\n\n\thost_get_clock_service(mach_host_self(), SYSTEM_CLOCK, &cclock);\n\tclock_get_time(cclock, &mts);\n\tmach_port_deallocate(mach_task_self(), cclock);\n\tts_start->tv_sec = mts.tv_sec;\n\tts_start->tv_nsec = mts.tv_nsec;\n}\n#elif !defined(WIN32) /* __MACH__ - Everything not linux/macosx/win32 */\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tstruct timeval tv;\n\n\tcgtime(&tv);\n\tts_start->tv_sec = tv->tv_sec;\n\tts_start->tv_nsec = tv->tv_usec * 1000;\n}\n#endif /* __MACH__ */\n\n#ifdef WIN32\n/* For windows we use the SystemTime stored as a LARGE_INTEGER as the cgtimer_t\n * typedef, allowing us to have sub-microsecond resolution for times, do simple\n * arithmetic for timer calculations, and use windows' own hTimers to get\n * accurate absolute timeouts. */\nint cgtimer_to_ms(cgtimer_t *cgt)\n{\n\treturn (int)(cgt->QuadPart / 10000LL);\n}\n\n/* Subtracts b from a and stores it in res. */\nvoid cgtimer_sub(cgtimer_t *a, cgtimer_t *b, cgtimer_t *res)\n{\n\tres->QuadPart = a->QuadPart - b->QuadPart;\n}\n\n/* Note that cgtimer time is NOT offset by the unix epoch since we use absolute\n * timeouts with hTimers. */\nvoid cgtimer_time(cgtimer_t *ts_start)\n{\n\tFILETIME ft;\n\n\tGetSystemTimeAsFileTime(&ft);\n\tts_start->LowPart = ft.dwLowDateTime;\n\tts_start->HighPart = ft.dwHighDateTime;\n}\n\nstatic void liSleep(LARGE_INTEGER *li, int timeout)\n{\n\tHANDLE hTimer;\n\tDWORD ret;\n\n\tif (unlikely(timeout <= 0))\n\t\treturn;\n\n\thTimer = CreateWaitableTimer(NULL, TRUE, NULL);\n\tif (unlikely(!hTimer))\n\t\tquit(1, \"Failed to create hTimer in liSleep\");\n\tret = SetWaitableTimer(hTimer, li, 0, NULL, NULL, 0);\n\tif (unlikely(!ret))\n\t\tquit(1, \"Failed to SetWaitableTimer in liSleep\");\n\t/* We still use a timeout as a sanity check in case the system time\n\t * is changed while we're running */\n\tret = WaitForSingleObject(hTimer, timeout);\n\tif (unlikely(ret != WAIT_OBJECT_0 && ret != WAIT_TIMEOUT))\n\t\tquit(1, \"Failed to WaitForSingleObject in liSleep\");\n\tCloseHandle(hTimer);\n}\n\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tLARGE_INTEGER li;\n\n\tli.QuadPart = ts_start->QuadPart + (int64_t)ms * 10000LL;\n\tliSleep(&li, ms);\n}\n\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tLARGE_INTEGER li;\n\tint ms;\n\n\tli.QuadPart = ts_start->QuadPart + us * 10LL;\n\tms = us / 1000;\n\tif (!ms)\n\t\tms = 1;\n\tliSleep(&li, ms);\n}\n#else /* WIN32 */\nstatic void cgsleep_spec(struct timespec *ts_diff, const struct timespec *ts_start)\n{\n\tstruct timespec now;\n\n\ttimeraddspec(ts_diff, ts_start);\n\tcgtimer_time(&now);\n\ttimersubspec(ts_diff, &now);\n\tif (unlikely(ts_diff->tv_sec < 0))\n\t\treturn;\n\tnanosleep(ts_diff, NULL);\n}\n\nvoid cgsleep_ms_r(cgtimer_t *ts_start, int ms)\n{\n\tstruct timespec ts_diff;\n\n\tms_to_timespec(&ts_diff, ms);\n\tcgsleep_spec(&ts_diff, ts_start);\n}\n\nvoid cgsleep_us_r(cgtimer_t *ts_start, int64_t us)\n{\n\tstruct timespec ts_diff;\n\n\tus_to_timespec(&ts_diff, us);\n\tcgsleep_spec(&ts_diff, ts_start);\n}\n#endif /* WIN32 */\n#endif /* CLOCK_MONOTONIC */\n\nvoid cgsleep_ms(int ms)\n{\n\tcgtimer_t ts_start;\n\n\tcgsleep_prepare_r(&ts_start);\n\tcgsleep_ms_r(&ts_start, ms);\n}\n\nvoid cgsleep_us(int64_t us)\n{\n\tcgtimer_t ts_start;\n\n\tcgsleep_prepare_r(&ts_start);\n\tcgsleep_us_r(&ts_start, us);\n}\n\n/* Returns the microseconds difference between end and start times as a double */\ndouble us_tdiff(struct timeval *end, struct timeval *start)\n{\n\t/* Sanity check. We should only be using this for small differences so\n\t * limit the max to 60 seconds. */\n\tif (unlikely(end->tv_sec - start->tv_sec > 60))\n\t\treturn 60000000;\n\treturn (end->tv_sec - start->tv_sec) * 1000000 + (end->tv_usec - start->tv_usec);\n}\n\n/* Returns the milliseconds difference between end and start times */\nint ms_tdiff(struct timeval *end, struct timeval *start)\n{\n\t/* Like us_tdiff, limit to 1 hour. */\n\tif (unlikely(end->tv_sec - start->tv_sec > 3600))\n\t\treturn 3600000;\n\treturn (end->tv_sec - start->tv_sec) * 1000 + (end->tv_usec - start->tv_usec) / 1000;\n}\n\n/* Returns the seconds difference between end and start times as a double */\ndouble tdiff(struct timeval *end, struct timeval *start)\n{\n\treturn end->tv_sec - start->tv_sec + (end->tv_usec - start->tv_usec) / 1000000.0;\n}\n\nbool extract_sockaddr(char *url, char **sockaddr_url, char **sockaddr_port)\n{\n\tchar *url_begin, *url_end, *ipv6_begin, *ipv6_end, *port_start = NULL;\n\tchar url_address[256], port[6];\n\tint url_len, port_len = 0;\n\n\t*sockaddr_url = url;\n\turl_begin = strstr(url, \"//\");\n\tif (!url_begin)\n\t\turl_begin = url;\n\telse\n\t\turl_begin += 2;\n\n\t/* Look for numeric ipv6 entries */\n\tipv6_begin = strstr(url_begin, \"[\");\n\tipv6_end = strstr(url_begin, \"]\");\n\tif (ipv6_begin && ipv6_end && ipv6_end > ipv6_begin)\n\t\turl_end = strstr(ipv6_end, \":\");\n\telse\n\t\turl_end = strstr(url_begin, \":\");\n\tif (url_end) {\n\t\turl_len = url_end - url_begin;\n\t\tport_len = strlen(url_begin) - url_len - 1;\n\t\tif (port_len < 1)\n\t\t\treturn false;\n\t\tport_start = url_end + 1;\n\t} else\n\t\turl_len = strlen(url_begin);\n\n\tif (url_len < 1)\n\t\treturn false;\n\t\n\tif (url_len >= sizeof(url_address))\n\t{\n\t\tapplog(LOG_WARNING, \"%s: Truncating overflowed address '%.*s'\",\n\t\t       __func__, url_len, url_begin);\n\t\turl_len = sizeof(url_address) - 1;\n\t}\n\n\tsprintf(url_address, \"%.*s\", url_len, url_begin);\n\n\tif (port_len) {\n\t\tchar *slash;\n\n\t\tsnprintf(port, 6, \"%.*s\", port_len, port_start);\n\t\tslash = strchr(port, '/');\n\t\tif (slash)\n\t\t\t*slash = '\\0';\n\t} else\n\t\tstrcpy(port, \"80\");\n\n\t*sockaddr_port = strdup(port);\n\t*sockaddr_url = strdup(url_address);\n\n\treturn true;\n}\n\nenum send_ret {\n\tSEND_OK,\n\tSEND_SELECTFAIL,\n\tSEND_SENDFAIL,\n\tSEND_INACTIVE\n};\n\n/* Send a single command across a socket, appending \\n to it. This should all\n * be done under stratum lock except when first establishing the socket */\nstatic enum send_ret __stratum_send(struct pool *pool, char *s, ssize_t len)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tssize_t ssent = 0;\n\n\tstrcat(s, \"\\n\");\n\tlen++;\n\n\twhile (len > 0 ) {\n\t\tstruct timeval timeout = {1, 0};\n\t\tssize_t sent;\n\t\tfd_set wd;\nretry:\n\t\tFD_ZERO(&wd);\n\t\tFD_SET(sock, &wd);\n\t\tif (select(sock + 1, NULL, &wd, NULL, &timeout) < 1) {\n\t\t\tif (interrupted())\n\t\t\t\tgoto retry;\n\t\t\treturn SEND_SELECTFAIL;\n\t\t}\n#ifdef __APPLE__\n\t\tsent = send(pool->sock, s + ssent, len, SO_NOSIGPIPE);\n#elif WIN32\n\t\tsent = send(pool->sock, s + ssent, len, 0);\n#else\n\t\tsent = send(pool->sock, s + ssent, len, MSG_NOSIGNAL);\n#endif\n\t\tif (sent < 0) {\n\t\t\tif (!sock_blocks())\n\t\t\t\treturn SEND_SENDFAIL;\n\t\t\tsent = 0;\n\t\t}\n\t\tssent += sent;\n\t\tlen -= sent;\n\t}\n\n\tpool->sgminer_pool_stats.times_sent++;\n\tpool->sgminer_pool_stats.bytes_sent += ssent;\n\tpool->sgminer_pool_stats.net_bytes_sent += ssent;\n\treturn SEND_OK;\n}\n\nbool stratum_send(struct pool *pool, char *s, ssize_t len)\n{\n\tenum send_ret ret = SEND_INACTIVE;\n\n\tif (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"SEND: %s\", s);\n\n\tmutex_lock(&pool->stratum_lock);\n\tif (pool->stratum_active)\n\t\tret = __stratum_send(pool, s, len);\n\tmutex_unlock(&pool->stratum_lock);\n\n\t/* This is to avoid doing applog under stratum_lock */\n\tswitch (ret) {\n\t\tdefault:\n\t\tcase SEND_OK:\n\t\t\tbreak;\n\t\tcase SEND_SELECTFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Write select failed on %s sock\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_SENDFAIL:\n\t\t\tapplog(LOG_DEBUG, \"Failed to send in stratum_send\");\n\t\t\tsuspend_stratum(pool);\n\t\t\tbreak;\n\t\tcase SEND_INACTIVE:\n\t\t\tapplog(LOG_DEBUG, \"Stratum send failed due to no pool stratum_active\");\n\t\t\tbreak;\n\t}\n\treturn (ret == SEND_OK);\n}\n\nstatic bool socket_full(struct pool *pool, int wait)\n{\n\tSOCKETTYPE sock = pool->sock;\n\tstruct timeval timeout;\n\tfd_set rd;\n\n\tif (unlikely(wait < 0))\n\t\twait = 0;\n\tFD_ZERO(&rd);\n\tFD_SET(sock, &rd);\n\ttimeout.tv_usec = 0;\n\ttimeout.tv_sec = wait;\n\tif (select(sock + 1, &rd, NULL, NULL, &timeout) > 0)\n\t\treturn true;\n\treturn false;\n}\n\n/* Check to see if Santa's been good to you */\nbool sock_full(struct pool *pool)\n{\n\tif (strlen(pool->sockbuf))\n\t\treturn true;\n\n\treturn (socket_full(pool, 0));\n}\n\nstatic void clear_sockbuf(struct pool *pool)\n{\n\tstrcpy(pool->sockbuf, \"\");\n}\n\nstatic void clear_sock(struct pool *pool)\n{\n\tssize_t n;\n\n\tmutex_lock(&pool->stratum_lock);\n\tdo {\n\t\tif (pool->sock)\n\t\t\tn = recv(pool->sock, pool->sockbuf, RECVSIZE, 0);\n\t\telse\n\t\t\tn = 0;\n\t} while (n > 0);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tclear_sockbuf(pool);\n}\n\n/* Make sure the pool sockbuf is large enough to cope with any coinbase size\n * by reallocing it to a large enough size rounded up to a multiple of RBUFSIZE\n * and zeroing the new memory */\nstatic void recalloc_sock(struct pool *pool, size_t len)\n{\n\tsize_t old, newlen;\n\n\told = strlen(pool->sockbuf);\n\tnewlen = old + len + 1;\n\tif (newlen < pool->sockbuf_size)\n\t\treturn;\n\tnewlen = newlen + (RBUFSIZE - (newlen % RBUFSIZE));\n\t// Avoid potentially recursive locking\n\t// applog(LOG_DEBUG, \"Recallocing pool sockbuf to %d\", new);\n\tpool->sockbuf = (char *)realloc(pool->sockbuf, newlen);\n\tif (!pool->sockbuf)\n\t\tquithere(1, \"Failed to realloc pool sockbuf\");\n\tmemset(pool->sockbuf + old, 0, newlen - old);\n\tpool->sockbuf_size = newlen;\n}\n\n/* Peeks at a socket to find the first end of line and then reads just that\n * from the socket and returns that as a malloced char */\nchar *recv_line(struct pool *pool)\n{\n\tchar *tok, *sret = NULL;\n\tssize_t len, buflen;\n\tint waited = 0;\n\n\tif (!strstr(pool->sockbuf, \"\\n\")) {\n\t\tstruct timeval rstart, now;\n\n\t\tcgtime(&rstart);\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\t\tapplog(LOG_DEBUG, \"Timed out waiting for data on socket_full\");\n\t\t\tgoto out;\n\t\t}\n\n\t\tdo {\n\t\t\tchar s[RBUFSIZE];\n\t\t\tsize_t slen;\n\t\t\tssize_t n;\n\n\t\t\tmemset(s, 0, RBUFSIZE);\n\t\t\tn = recv(pool->sock, s, RECVSIZE, 0);\n\t\t\tif (!n) {\n\t\t\t\tapplog(LOG_DEBUG, \"Socket closed waiting in recv_line\");\n\t\t\t\tsuspend_stratum(pool);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcgtime(&now);\n\t\t\twaited = tdiff(&now, &rstart);\n\t\t\tif (n < 0) {\n\t\t\t\tif (!sock_blocks() || !socket_full(pool, DEFAULT_SOCKWAIT - waited)) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"Failed to recv sock in recv_line\");\n\t\t\t\t\tsuspend_stratum(pool);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tslen = strlen(s);\n\t\t\t\trecalloc_sock(pool, slen);\n\t\t\t\tstrcat(pool->sockbuf, s);\n\t\t\t}\n\t\t} while (waited < DEFAULT_SOCKWAIT && !strstr(pool->sockbuf, \"\\n\"));\n\t}\n\n\tbuflen = strlen(pool->sockbuf);\n\ttok = strtok(pool->sockbuf, \"\\n\");\n\tif (!tok) {\n\t\tapplog(LOG_DEBUG, \"Failed to parse a \\\\n terminated string in recv_line\");\n\t\tgoto out;\n\t}\n\tsret = strdup(tok);\n\tlen = strlen(sret);\n\n\t/* Copy what's left in the buffer after the \\n, including the\n\t * terminating \\0 */\n\tif (buflen > len + 1)\n\t\tmemmove(pool->sockbuf, pool->sockbuf + len + 1, buflen - len + 1);\n\telse\n\t\tstrcpy(pool->sockbuf, \"\");\n\n\tpool->sgminer_pool_stats.times_received++;\n\tpool->sgminer_pool_stats.bytes_received += len;\n\tpool->sgminer_pool_stats.net_bytes_received += len;\nout:\n\tif (!sret)\n\t\tclear_sock(pool);\n\telse if (opt_protocol)\n\t\tapplog(LOG_DEBUG, \"RECVD: %s\", sret);\n\treturn sret;\n}\n\n/* Extracts a string value from a json array with error checking. To be used\n * when the value of the string returned is only examined and not to be stored.\n * See json_array_string below */\nstatic char *__json_array_string(json_t *val, unsigned int entry)\n{\n\tjson_t *arr_entry;\n\n\tif (json_is_null(val))\n\t\treturn NULL;\n\tif (!json_is_array(val))\n\t\treturn NULL;\n\tif (entry > json_array_size(val))\n\t\treturn NULL;\n\tarr_entry = json_array_get(val, entry);\n\tif (!json_is_string(arr_entry))\n\t\treturn NULL;\n\n\treturn (char *)json_string_value(arr_entry);\n}\n\n/* Creates a freshly malloced dup of __json_array_string */\nstatic char *json_array_string(json_t *val, unsigned int entry)\n{\n\tchar *buf = __json_array_string(val, entry);\n\n\tif (buf)\n\t\treturn strdup(buf);\n\treturn NULL;\n}\n\nstatic char *blank_merkel = \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nstatic bool parse_notify(struct pool *pool, json_t *val)\n{\n\tchar *job_id, *prev_hash, *coinbase1, *coinbase2, *bbversion, *nbit,\n\t     *ntime, *header;\n\tsize_t cb1_len, cb2_len, alloc_len;\n\tunsigned char *cb1, *cb2;\n\tbool clean, ret = false;\n\tint merkles, i;\n\tjson_t *arr;\n\n\tarr = json_array_get(val, 4);\n\tif (!arr || !json_is_array(arr))\n\t\tgoto out;\n\n\tmerkles = json_array_size(arr);\n\n\tjob_id = json_array_string(val, 0);\n\tprev_hash = json_array_string(val, 1);\n\tcoinbase1 = json_array_string(val, 2);\n\tcoinbase2 = json_array_string(val, 3);\n\tbbversion = json_array_string(val, 5);\n\tnbit = json_array_string(val, 6);\n\tntime = json_array_string(val, 7);\n\tclean = json_is_true(json_array_get(val, 8));\n\n\tif (!job_id || !prev_hash || !coinbase1 || !coinbase2 || !bbversion || !nbit || !ntime) {\n\t\t/* Annoying but we must not leak memory */\n\t\tif (job_id)\n\t\t\tfree(job_id);\n\t\tif (prev_hash)\n\t\t\tfree(prev_hash);\n\t\tif (coinbase1)\n\t\t\tfree(coinbase1);\n\t\tif (coinbase2)\n\t\t\tfree(coinbase2);\n\t\tif (bbversion)\n\t\t\tfree(bbversion);\n\t\tif (nbit)\n\t\t\tfree(nbit);\n\t\tif (ntime)\n\t\t\tfree(ntime);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tfree(pool->swork.job_id);\n\tfree(pool->swork.prev_hash);\n\tfree(pool->swork.bbversion);\n\tfree(pool->swork.nbit);\n\tfree(pool->swork.ntime);\n\tpool->swork.job_id = job_id;\n\tpool->swork.prev_hash = prev_hash;\n\tcb1_len = strlen(coinbase1) / 2;\n\tcb2_len = strlen(coinbase2) / 2;\n\tpool->swork.bbversion = bbversion;\n\tpool->swork.nbit = nbit;\n\tpool->swork.ntime = ntime;\n\tpool->swork.clean = clean;\n\talloc_len = pool->swork.cb_len = cb1_len + pool->n1_len + pool->n2size + cb2_len;\n\tpool->nonce2_offset = cb1_len + pool->n1_len;\n\n\tfor (i = 0; i < pool->swork.merkles; i++)\n\t\tfree(pool->swork.merkle_bin[i]);\n\tif (merkles) {\n\t\tpool->swork.merkle_bin = (unsigned char **)realloc(pool->swork.merkle_bin,\n\t\t\t\t\t\t sizeof(char *) * merkles + 1);\n\t\tfor (i = 0; i < merkles; i++) {\n\t\t\tchar *merkle = json_array_string(arr, i);\n\n\t\t\tpool->swork.merkle_bin[i] = (unsigned char *)malloc(32);\n\t\t\tif (unlikely(!pool->swork.merkle_bin[i]))\n\t\t\t\tquit(1, \"Failed to malloc pool swork merkle_bin\");\n\t\t\thex2bin(pool->swork.merkle_bin[i], merkle, 32);\n\t\t\tfree(merkle);\n\t\t}\n\t}\n\tpool->swork.merkles = merkles;\n\tif (clean)\n\t\tpool->nonce2 = 0;\n\tpool->merkle_offset = strlen(pool->swork.bbversion) +\n\t\t\t      strlen(pool->swork.prev_hash);\n\tpool->swork.header_len = pool->merkle_offset +\n\t/* merkle_hash */\t 32 +\n\t\t\t\t strlen(pool->swork.ntime) +\n\t\t\t\t strlen(pool->swork.nbit) +\n\t/* nonce */\t\t 8 +\n\t/* workpadding */\t 96;\n\tpool->merkle_offset /= 2;\n\tpool->swork.header_len = pool->swork.header_len * 2 + 1;\n\talign_len(&pool->swork.header_len);\n\theader = (char *)alloca(pool->swork.header_len);\n\tsnprintf(header, pool->swork.header_len,\n\t\t\"%s%s%s%s%s%s%s\",\n\t\tpool->swork.bbversion,\n\t\tpool->swork.prev_hash,\n\t\tblank_merkel,\n\t\tpool->swork.ntime,\n\t\tpool->swork.nbit,\n\t\t\"00000000\", /* nonce */\n\t\tworkpadding);\n\tif (unlikely(!hex2bin(pool->header_bin, header, 128))) {\n\t\tapplog(LOG_WARNING, \"%s: Failed to convert header to header_bin, got %s\", __func__, header);\n\t\tpool_failed(pool);\n\t\t// TODO: memory leaks? goto out, clean up there?\n\t\treturn false;\n\t}\n\n\tcb1 = (unsigned char *)calloc(cb1_len, 1);\n\tif (unlikely(!cb1))\n\t\tquithere(1, \"Failed to calloc cb1 in parse_notify\");\n\thex2bin(cb1, coinbase1, cb1_len);\n\n\tcb2 = (unsigned char *)calloc(cb2_len, 1);\n\tif (unlikely(!cb2))\n\t\tquithere(1, \"Failed to calloc cb2 in parse_notify\");\n\thex2bin(cb2, coinbase2, cb2_len);\n\n\tfree(pool->coinbase);\n\talign_len(&alloc_len);\n\tpool->coinbase = (unsigned char *)calloc(alloc_len, 1);\n\tif (unlikely(!pool->coinbase))\n\t\tquit(1, \"Failed to calloc pool coinbase in parse_notify\");\n\tmemcpy(pool->coinbase, cb1, cb1_len);\n\tmemcpy(pool->coinbase + cb1_len, pool->nonce1bin, pool->n1_len);\n\t// NOTE: gap for nonce2, filled at work generation time\n\tmemcpy(pool->coinbase + cb1_len + pool->n1_len + pool->n2size, cb2, cb2_len);\n\tcg_wunlock(&pool->data_lock);\n\n\tif (opt_protocol) {\n\t\tapplog(LOG_DEBUG, \"job_id: %s\", job_id);\n\t\tapplog(LOG_DEBUG, \"prev_hash: %s\", prev_hash);\n\t\tapplog(LOG_DEBUG, \"coinbase1: %s\", coinbase1);\n\t\tapplog(LOG_DEBUG, \"coinbase2: %s\", coinbase2);\n\t\tapplog(LOG_DEBUG, \"bbversion: %s\", bbversion);\n\t\tapplog(LOG_DEBUG, \"nbit: %s\", nbit);\n\t\tapplog(LOG_DEBUG, \"ntime: %s\", ntime);\n\t\tapplog(LOG_DEBUG, \"clean: %s\", clean ? \"yes\" : \"no\");\n\t}\n\tfree(coinbase1);\n\tfree(coinbase2);\n\tfree(cb1);\n\tfree(cb2);\n\n\t/* A notify message is the closest stratum gets to a getwork */\n\tpool->getwork_requested++;\n\ttotal_getworks++;\n\tret = true;\n\tif (pool == current_pool())\n\t\topt_work_update = true;\nout:\n\treturn ret;\n}\n\nstatic bool parse_diff(struct pool *pool, json_t *val)\n{\n\tdouble old_diff, diff;\n\n\tif (opt_diff_mult == 0.0)\n\t\tdiff = json_number_value(json_array_get(val, 0)) * pool->algorithm.diff_multiplier1;\n\telse\n\t\tdiff = json_number_value(json_array_get(val, 0)) * opt_diff_mult;\n\n\tif (diff == 0)\n\t\treturn false;\n\n\tcg_wlock(&pool->data_lock);\n\told_diff = pool->swork.diff;\n\tpool->swork.diff = diff;\n\tcg_wunlock(&pool->data_lock);\n\n\tif (old_diff != diff) {\n\t\tint idiff = diff;\n\n\t\tif ((double)idiff == diff)\n\t\t\tapplog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %d\", get_pool_name(pool), idiff);\n\t\telse\n\t\t\tapplog(pool == current_pool() ? LOG_NOTICE : LOG_DEBUG, \"%s difficulty changed to %.3f\", get_pool_name(pool), diff);\n\t} else\n\t\tapplog(LOG_DEBUG, \"%s difficulty set to %f\", get_pool_name(pool), diff);\n\n\treturn true;\n}\n\nstatic bool parse_extranonce(struct pool *pool, json_t *val)\n{\n\tchar *nonce1;\n\tint n2size;\n\n\tnonce1 = json_array_string(val, 0);\n\tif (!nonce1) {\n\t\treturn false;\n\t}\n\tn2size = json_integer_value(json_array_get(val, 1));\n\tif (!n2size) {\n\t\tfree(nonce1);\n\t\treturn false;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\n\tapplog(LOG_NOTICE, \"%s extranonce change requested\", get_pool_name(pool));\n\n\treturn true;\n}\n\nstatic void __suspend_stratum(struct pool *pool)\n{\n\tclear_sockbuf(pool);\n\tpool->stratum_active = pool->stratum_notify = false;\n\tif (pool->sock)\n\t\tCLOSESOCKET(pool->sock);\n\tpool->sock = 0;\n}\n\nstatic bool parse_reconnect(struct pool *pool, json_t *val)\n{\n\tif (opt_disable_client_reconnect) {\n\t\tapplog(LOG_WARNING, \"Stratum client.reconnect received but is disabled, not reconnecting.\");\n\t\treturn false;\n\t}\n\n\tchar *url, *port, address[256];\n\tchar *sockaddr_url, *stratum_port, *tmp; /* Tempvars. */\n\n\turl = (char *)json_string_value(json_array_get(val, 0));\n\tif (!url)\n\t\turl = pool->sockaddr_url;\n\n\tport = (char *)json_string_value(json_array_get(val, 1));\n\tif (!port)\n\t\tport = pool->stratum_port;\n\n\tsnprintf(address, sizeof(address), \"%s:%s\", url, port);\n\tif (!extract_sockaddr(address, &sockaddr_url, &stratum_port))\n\t\treturn false;\n\n\tapplog(LOG_NOTICE, \"Reconnect requested from %s to %s\", get_pool_name(pool), address);\n\n\tclear_pool_work(pool);\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\ttmp = pool->sockaddr_url;\n\tpool->sockaddr_url = sockaddr_url;\n\tpool->stratum_url = pool->sockaddr_url;\n\tfree(tmp);\n\ttmp = pool->stratum_port;\n\tpool->stratum_port = stratum_port;\n\tfree(tmp);\n\tmutex_unlock(&pool->stratum_lock);\n\n\tif (!restart_stratum(pool)) {\n\t\tpool_failed(pool);\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic bool send_version(struct pool *pool, json_t *val)\n{\n\tchar s[RBUFSIZE];\n\tint id = json_integer_value(json_object_get(val, \"id\"));\n\n\tif (!id)\n\t\treturn false;\n\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"result\\\": \\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"error\\\": null}\", id);\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn false;\n\n\treturn true;\n}\n\nstatic bool show_message(struct pool *pool, json_t *val)\n{\n\tchar *msg;\n\n\tif (!json_is_array(val))\n\t\treturn false;\n\tmsg = (char *)json_string_value(json_array_get(val, 0));\n\tif (!msg)\n\t\treturn false;\n\tapplog(LOG_NOTICE, \"%s message: %s\", get_pool_name(pool), msg);\n\treturn true;\n}\n\nbool parse_method(struct pool *pool, char *s)\n{\n\tjson_t *val = NULL, *method, *err_val, *params;\n\tjson_error_t err;\n\tbool ret = false;\n\tchar *buf;\n\n\tif (!s)\n\t\treturn ret;\n\n\tval = JSON_LOADS(s, &err);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\treturn ret;\n\t}\n\n\tmethod = json_object_get(val, \"method\");\n\tif (!method) {\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\terr_val = json_object_get(val, \"error\");\n\tparams = json_object_get(val, \"params\");\n\n\tif (err_val && !json_is_null(err_val)) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC method decode failed: %s\", ss);\n\n\t\tjson_decref(val);\n\t\tfree(ss);\n\n\t\treturn ret;\n\t}\n\n\tbuf = (char *)json_string_value(method);\n\tif (!buf) {\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.notify\", 13)) {\n\t\tif (parse_notify(pool, params))\n\t\t\tpool->stratum_notify = ret = true;\n\t\telse\n\t\t\tpool->stratum_notify = ret = false;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.set_difficulty\", 21) && parse_diff(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"mining.set_extranonce\", 21) && parse_extranonce(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"client.reconnect\", 16) && parse_reconnect(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"client.get_version\", 18) && send_version(pool, val)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\n\tif (!strncasecmp(buf, \"client.show_message\", 19) && show_message(pool, params)) {\n\t\tret = true;\n\t\tjson_decref(val);\n\t\treturn ret;\n\t}\n\tjson_decref(val);\n\treturn ret;\n}\n\nbool subscribe_extranonce(struct pool *pool)\n{\n\tjson_t *val = NULL, *res_val, *err_val;\n\tchar s[RBUFSIZE], *sret = NULL;\n\tjson_error_t err;\n\tbool ret = false;\n\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.extranonce.subscribe\\\", \\\"params\\\": []}\",\n\t\tswork_id++);\n\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\n\t/* Parse all data in the queue and anything left should be the response */\n\twhile (42) {\n\t\tif (!socket_full(pool, DEFAULT_SOCKWAIT / 30)) {\n\t\t\tapplog(LOG_DEBUG, \"Timed out waiting for response extranonce.subscribe\");\n\t\t\t/* some pool doesnt send anything, so this is normal */\n\t\t\tret = true;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {\n\t\tchar *ss;\n\n\t\tif (err_val) {\n\t\t\tss = __json_array_string(err_val, 1);\n\t\t\tif (!ss)\n\t\t\t\tss = (char *)json_string_value(err_val);\n\t\t\tif (ss && (strcmp(ss, \"Method 'subscribe' not found for service 'mining.extranonce'\") == 0)) {\n\t\t\t\tapplog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));\n\t\t\t\tret = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (ss && (strcmp(ss, \"Unrecognized request provided\") == 0)) {\n\t\t\t\tapplog(LOG_INFO, \"Cannot subscribe to mining.extranonce on %s\", get_pool_name(pool));\n\t\t\t\tret = true;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\t}\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tret = true;\n\tapplog(LOG_INFO, \"Stratum extranonce subscribe for %s\", get_pool_name(pool));\n\nout:\n\tjson_decref(val);\n\treturn ret;\n}\n\nbool auth_stratum(struct pool *pool)\n{\n\tjson_t *val = NULL, *res_val, *err_val;\n\tchar s[RBUFSIZE], *sret = NULL;\n\tjson_error_t err;\n\tbool ret = false;\n\n\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.authorize\\\", \\\"params\\\": [\\\"%s\\\", \\\"%s\\\"]}\",\n\t\tswork_id++, pool->rpc_user, pool->rpc_pass);\n\n\tif (!stratum_send(pool, s, strlen(s)))\n\t\treturn ret;\n\n\t/* Parse all data in the queue and anything left should be auth */\n\twhile (42) {\n\t\tsret = recv_line(pool);\n\t\tif (!sret)\n\t\t\treturn ret;\n\t\tif (parse_method(pool, sret))\n\t\t\tfree(sret);\n\t\telse\n\t\t\tbreak;\n\t}\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_false(res_val) || (err_val && !json_is_null(err_val)))  {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\t\tapplog(LOG_INFO, \"%s JSON stratum auth failed: %s\", get_pool_name(pool), ss);\n\t\tfree(ss);\n\n\t\tsuspend_stratum(pool);\n\n\t\tgoto out;\n\t}\n\n\tret = true;\n\tapplog(LOG_INFO, \"Stratum authorisation success for %s\", get_pool_name(pool));\n\tpool->probed = true;\n\tsuccessful_connect = true;\n\nout:\n\tjson_decref(val);\n\treturn ret;\n}\n\nstatic int recv_byte(int sockd)\n{\n\tchar c;\n\n\tif (recv(sockd, &c, 1, 0) != -1)\n\t\treturn c;\n\n\treturn -1;\n}\n\nstatic bool http_negotiate(struct pool *pool, int sockd, bool http0)\n{\n\tchar buf[1024];\n\tint i, len;\n\n\tif (http0) {\n\t\tsnprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.0\\r\\n\\r\\n\",\n\t\t\tpool->sockaddr_url, pool->stratum_port);\n\t} else {\n\t\tsnprintf(buf, 1024, \"CONNECT %s:%s HTTP/1.1\\r\\nHost: %s:%s\\r\\n\\r\\n\",\n\t\t\tpool->sockaddr_url, pool->stratum_port, pool->sockaddr_url,\n\t\t\tpool->stratum_port);\n\t}\n\tapplog(LOG_DEBUG, \"Sending proxy %s:%s - %s\",\n\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\tsend(sockd, buf, strlen(buf), 0);\n\tlen = recv(sockd, buf, 12, 0);\n\tif (len <= 0) {\n\t\tapplog(LOG_WARNING, \"Couldn't read from proxy %s:%s after sending CONNECT\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\treturn false;\n\t}\n\tbuf[len] = '\\0';\n\tapplog(LOG_DEBUG, \"Received from proxy %s:%s - %s\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\tif (strcmp(buf, \"HTTP/1.1 200\") && strcmp(buf, \"HTTP/1.0 200\")) {\n\t\tapplog(LOG_WARNING, \"HTTP Error from proxy %s:%s - %s\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port, buf);\n\t\treturn false;\n\t}\n\n\t/* Ignore unwanted headers till we get desired response */\n\tfor (i = 0; i < 4; i++) {\n\t\tbuf[i] = recv_byte(sockd);\n\t\tif (buf[i] == (char)-1) {\n\t\t\tapplog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\treturn false;\n\t\t}\n\t}\n\twhile (strncmp(buf, \"\\r\\n\\r\\n\", 4)) {\n\t\tfor (i = 0; i < 3; i++)\n\t\t\tbuf[i] = buf[i + 1];\n\t\tbuf[3] = recv_byte(sockd);\n\t\tif (buf[3] == (char)-1) {\n\t\t\tapplog(LOG_WARNING, \"Couldn't read HTTP byte from proxy %s:%s\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tapplog(LOG_DEBUG, \"Success negotiating with %s:%s HTTP proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\treturn true;\n}\n\nstatic bool socks5_negotiate(struct pool *pool, int sockd)\n{\n\tunsigned char atyp, uclen;\n\tunsigned short port;\n\tchar buf[515];\n\tint i, len;\n\n\tbuf[0] = 0x05;\n\tbuf[1] = 0x01;\n\tbuf[2] = 0x00;\n\tapplog(LOG_DEBUG, \"Attempting to negotiate with %s:%s SOCKS5 proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\tsend(sockd, buf, 3, 0);\n\tif (recv_byte(sockd) != 0x05 || recv_byte(sockd) != buf[2]) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\n\tbuf[0] = 0x05;\n\tbuf[1] = 0x01;\n\tbuf[2] = 0x00;\n\tbuf[3] = 0x03;\n\tlen = (strlen(pool->sockaddr_url));\n\tif (len > 255)\n\t\tlen = 255;\n\tuclen = len;\n\tbuf[4] = (uclen & 0xff);\n\tmemcpy(buf + 5, pool->sockaddr_url, len);\n\tport = atoi(pool->stratum_port);\n\tbuf[5 + len] = (port >> 8);\n\tbuf[6 + len] = (port & 0xff);\n\tsend(sockd, buf, (7 + len), 0);\n\tif (recv_byte(sockd) != 0x05 || recv_byte(sockd) != 0x00) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\n\trecv_byte(sockd);\n\tatyp = recv_byte(sockd);\n\tif (atyp == 0x01) {\n\t\tfor (i = 0; i < 4; i++)\n\t\t\trecv_byte(sockd);\n\t} else if (atyp == 0x03) {\n\t\tlen = recv_byte(sockd);\n\t\tfor (i = 0; i < len; i++)\n\t\t\trecv_byte(sockd);\n\t} else {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS5 server\",\n\t\t\tpool->sockaddr_proxy_url, pool->sockaddr_proxy_port );\n\t\treturn false;\n\t}\n\tfor (i = 0; i < 2; i++)\n\t\trecv_byte(sockd);\n\n\tapplog(LOG_DEBUG, \"Success negotiating with %s:%s SOCKS5 proxy\",\n\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\treturn true;\n}\n\nstatic bool socks4_negotiate(struct pool *pool, int sockd, bool socks4a)\n{\n\tunsigned short port;\n\tin_addr_t inp;\n\tchar buf[515];\n\tint i, len;\n\tint ret;\n\n\tbuf[0] = 0x04;\n\tbuf[1] = 0x01;\n\tport = atoi(pool->stratum_port);\n\tbuf[2] = port >> 8;\n\tbuf[3] = port & 0xff;\n\tsprintf(&buf[8], \"SGMINER\");\n\n\t/* See if we've been given an IP address directly to avoid needing to\n\t * resolve it. */\n\tinp = inet_addr(pool->sockaddr_url);\n\tinp = ntohl(inp);\n\tif ((int)inp != -1)\n\t\tsocks4a = false;\n\telse {\n\t\t/* Try to extract the IP address ourselves first */\n\t\tstruct addrinfo servinfobase, *servinfo, hints;\n\n\t\tservinfo = &servinfobase;\n\t\tmemset(&hints, 0, sizeof(struct addrinfo));\n\t\thints.ai_family = AF_INET; /* IPV4 only */\n\t\tret = getaddrinfo(pool->sockaddr_url, NULL, &hints, &servinfo);\n\t\tif (!ret) {\n\t\t\tapplog(LOG_ERR, \"getaddrinfo() in socks4_negotiate() returned %i: %s\", ret, gai_strerror(ret));\n\n\t\t\tstruct sockaddr_in *saddr_in = (struct sockaddr_in *)servinfo->ai_addr;\n\n\t\t\tinp = ntohl(saddr_in->sin_addr.s_addr);\n\t\t\tsocks4a = false;\n\t\t\tfreeaddrinfo(servinfo);\n\t\t}\n\t}\n\n\tif (!socks4a) {\n\t\tif ((int)inp == -1) {\n\t\t\tapplog(LOG_WARNING, \"Invalid IP address specified for socks4 proxy: %s\",\n\t\t\t       pool->sockaddr_url);\n\t\t\treturn false;\n\t\t}\n\t\tbuf[4] = (inp >> 24) & 0xFF;\n\t\tbuf[5] = (inp >> 16) & 0xFF;\n\t\tbuf[6] = (inp >>  8) & 0xFF;\n\t\tbuf[7] = (inp >>  0) & 0xFF;\n\t\tsend(sockd, buf, 16, 0);\n\t} else {\n\t\t/* This appears to not be working but hopefully most will be\n\t\t * able to resolve IP addresses themselves. */\n\t\tbuf[4] = 0;\n\t\tbuf[5] = 0;\n\t\tbuf[6] = 0;\n\t\tbuf[7] = 1;\n\t\tlen = strlen(pool->sockaddr_url);\n\t\tif (len > 255)\n\t\t\tlen = 255;\n\t\tmemcpy(&buf[16], pool->sockaddr_url, len);\n\t\tlen += 16;\n\t\tbuf[len++] = '\\0';\n\t\tsend(sockd, buf, len, 0);\n\t}\n\n\tif (recv_byte(sockd) != 0x00 || recv_byte(sockd) != 0x5a) {\n\t\tapplog(LOG_WARNING, \"Bad response from %s:%s SOCKS4 server\",\n\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\treturn false;\n\t}\n\n\tfor (i = 0; i < 6; i++)\n\t\trecv_byte(sockd);\n\n\treturn true;\n}\n\nstatic void noblock_socket(SOCKETTYPE fd)\n{\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, O_NONBLOCK | flags);\n#else\n\tu_long flags = 1;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n}\n\nstatic void block_socket(SOCKETTYPE fd)\n{\n#ifndef WIN32\n\tint flags = fcntl(fd, F_GETFL, 0);\n\n\tfcntl(fd, F_SETFL, flags & ~O_NONBLOCK);\n#else\n\tu_long flags = 0;\n\n\tioctlsocket(fd, FIONBIO, &flags);\n#endif\n}\n\nstatic bool sock_connecting(void)\n{\n#ifndef WIN32\n\treturn errno == EINPROGRESS;\n#else\n\treturn WSAGetLastError() == WSAEWOULDBLOCK;\n#endif\n}\nstatic bool setup_stratum_socket(struct pool *pool)\n{\n\tstruct addrinfo servinfobase, *servinfo, *hints, *p;\n\tchar *sockaddr_url, *sockaddr_port;\n\tint sockd;\n\tint ret;\n\n\tmutex_lock(&pool->stratum_lock);\n\tpool->stratum_active = false;\n\tif (pool->sock) {\n\t\t/* FIXME: change to LOG_DEBUG if issue #88 resolved */\n\t\tapplog(LOG_INFO, \"Closing %s socket\", get_pool_name(pool));\n\t\tCLOSESOCKET(pool->sock);\n\t}\n\tpool->sock = 0;\n\tmutex_unlock(&pool->stratum_lock);\n\n\thints = &pool->stratum_hints;\n\tmemset(hints, 0, sizeof(struct addrinfo));\n\thints->ai_family = AF_UNSPEC;\n\thints->ai_socktype = SOCK_STREAM;\n\tservinfo = &servinfobase;\n\n\tif (!pool->rpc_proxy && opt_socks_proxy) {\n\t\tpool->rpc_proxy = opt_socks_proxy;\n\t\textract_sockaddr(pool->rpc_proxy, &pool->sockaddr_proxy_url, &pool->sockaddr_proxy_port);\n\t\tpool->rpc_proxytype = PROXY_SOCKS5;\n\t}\n\n\tif (pool->rpc_proxy) {\n\t\tsockaddr_url = pool->sockaddr_proxy_url;\n\t\tsockaddr_port = pool->sockaddr_proxy_port;\n\t} else {\n\t\tsockaddr_url = pool->sockaddr_url;\n\t\tsockaddr_port = pool->stratum_port;\n\t}\n\n\tret = getaddrinfo(sockaddr_url, sockaddr_port, hints, &servinfo);\n\tif (ret) {\n\t\tapplog(LOG_INFO, \"getaddrinfo() in setup_stratum_socket() returned %i: %s\", ret, gai_strerror(ret));\n\t\tif (!pool->probed) {\n\t\t\tapplog(LOG_WARNING, \"Failed to resolve (wrong URL?) %s:%s\",\n\t\t\t       sockaddr_url, sockaddr_port);\n\t\t\tpool->probed = true;\n\t\t} else {\n\t\t\tapplog(LOG_INFO, \"Failed to getaddrinfo for %s:%s\",\n\t\t\t       sockaddr_url, sockaddr_port);\n\t\t}\n\t\treturn false;\n\t}\n\n\tfor (p = servinfo; p != NULL; p = p->ai_next) {\n\t\tsockd = socket(p->ai_family, p->ai_socktype, p->ai_protocol);\n\t\tif (sockd == -1) {\n\t\t\tapplog(LOG_DEBUG, \"Failed socket\");\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Iterate non blocking over entries returned by getaddrinfo\n\t\t * to cope with round robin DNS entries, finding the first one\n\t\t * we can connect to quickly. */\n\t\tnoblock_socket(sockd);\n\t\tif (connect(sockd, p->ai_addr, p->ai_addrlen) == -1) {\n\t\t\tstruct timeval tv_timeout = {1, 0};\n\t\t\tint selret;\n\t\t\tfd_set rw;\n\n\t\t\tif (!sock_connecting()) {\n\t\t\t\tCLOSESOCKET(sockd);\n\t\t\t\tapplog(LOG_DEBUG, \"Failed sock connect\");\n\t\t\t\tcontinue;\n\t\t\t}\nretry:\n\t\t\tFD_ZERO(&rw);\n\t\t\tFD_SET(sockd, &rw);\n\t\t\tselret = select(sockd + 1, NULL, &rw, NULL, &tv_timeout);\n\t\t\tif  (selret > 0 && FD_ISSET(sockd, &rw)) {\n\t\t\t\tsocklen_t len;\n\t\t\t\tint err, n;\n\n\t\t\t\tlen = sizeof(err);\n\t\t\t\tn = getsockopt(sockd, SOL_SOCKET, SO_ERROR, (char *)&err, &len);\n\t\t\t\tif (!n && !err) {\n\t\t\t\t\tapplog(LOG_DEBUG, \"Succeeded delayed connect\");\n\t\t\t\t\tblock_socket(sockd);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (selret < 0 && interrupted())\n\t\t\t\tgoto retry;\n\t\t\tCLOSESOCKET(sockd);\n\t\t\tapplog(LOG_DEBUG, \"Select timeout/failed connect\");\n\t\t\tcontinue;\n\t\t}\n\t\tapplog(LOG_WARNING, \"Succeeded immediate connect\");\n\t\tblock_socket(sockd);\n\n\t\tbreak;\n\t}\n\tif (p == NULL) {\n\t\tapplog(LOG_INFO, \"Failed to connect to stratum on %s:%s\",\n\t\t       sockaddr_url, sockaddr_port);\n\t\tfreeaddrinfo(servinfo);\n\t\treturn false;\n\t}\n\tfreeaddrinfo(servinfo);\n\n\tif (pool->rpc_proxy) {\n\t\tswitch (pool->rpc_proxytype) {\n\t\t\tcase PROXY_HTTP_1_0:\n\t\t\t\tif (!http_negotiate(pool, sockd, true))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_HTTP:\n\t\t\t\tif (!http_negotiate(pool, sockd, false))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS5:\n\t\t\tcase PROXY_SOCKS5H:\n\t\t\t\tif (!socks5_negotiate(pool, sockd))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS4:\n\t\t\t\tif (!socks4_negotiate(pool, sockd, false))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tcase PROXY_SOCKS4A:\n\t\t\t\tif (!socks4_negotiate(pool, sockd, true))\n\t\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tapplog(LOG_WARNING, \"Unsupported proxy type for %s:%s\",\n\t\t\t\t       pool->sockaddr_proxy_url, pool->sockaddr_proxy_port);\n\t\t\t\treturn false;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!pool->sockbuf) {\n\t\tpool->sockbuf = (char *)calloc(RBUFSIZE, 1);\n\t\tif (!pool->sockbuf)\n\t\t\tquithere(1, \"Failed to calloc pool sockbuf\");\n\t\tpool->sockbuf_size = RBUFSIZE;\n\t}\n\n\tpool->sock = sockd;\n\tkeep_sockalive(sockd);\n\treturn true;\n}\n\nstatic char *get_sessionid(json_t *val)\n{\n\tchar *ret = NULL;\n\tjson_t *arr_val;\n\tint arrsize, i;\n\n\tarr_val = json_array_get(val, 0);\n\tif (!arr_val || !json_is_array(arr_val))\n\t\tgoto out;\n\tarrsize = json_array_size(arr_val);\n\tfor (i = 0; i < arrsize; i++) {\n\t\tjson_t *arr = json_array_get(arr_val, i);\n\t\tchar *notify;\n\n\t\tif (!arr | !json_is_array(arr))\n\t\t\tbreak;\n\t\tnotify = __json_array_string(arr, 0);\n\t\tif (!notify)\n\t\t\tcontinue;\n\t\tif (!strncasecmp(notify, \"mining.notify\", 13)) {\n\t\t\tret = json_array_string(arr, 1);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\treturn ret;\n}\n\nvoid suspend_stratum(struct pool *pool)\n{\n\tapplog(LOG_INFO, \"Closing socket for stratum %s\", get_pool_name(pool));\n\n\tmutex_lock(&pool->stratum_lock);\n\t__suspend_stratum(pool);\n\tmutex_unlock(&pool->stratum_lock);\n}\n\nbool initiate_stratum(struct pool *pool)\n{\n\tbool ret = false, recvd = false, noresume = false, sockd = false;\n\tchar s[RBUFSIZE], *sret = NULL, *nonce1, *sessionid;\n\tjson_t *val = NULL, *res_val, *err_val;\n\tjson_error_t err;\n\tint n2size;\n\nresend:\n\tif (!setup_stratum_socket(pool)) {\n\t\t/* FIXME: change to LOG_DEBUG when issue #88 resolved */\n\t\tapplog(LOG_INFO, \"setup_stratum_socket() on %s failed\", get_pool_name(pool));\n\t\tsockd = false;\n\t\tgoto out;\n\t}\n\n\tsockd = true;\n\n\tif (recvd) {\n\t\t/* Get rid of any crap lying around if we're resending */\n\t\tclear_sock(pool);\n\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": []}\", swork_id++);\n\t} else {\n\t\tif (pool->sessionid)\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\", \\\"%s\\\"]}\", swork_id++, pool->sessionid);\n\t\telse\n\t\t\tsprintf(s, \"{\\\"id\\\": %d, \\\"method\\\": \\\"mining.subscribe\\\", \\\"params\\\": [\\\"\"PACKAGE\"/\"VERSION\"\\\"]}\", swork_id++);\n\t}\n\n\tif (__stratum_send(pool, s, strlen(s)) != SEND_OK) {\n\t\tapplog(LOG_DEBUG, \"Failed to send s in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tif (!socket_full(pool, DEFAULT_SOCKWAIT)) {\n\t\tapplog(LOG_DEBUG, \"Timed out waiting for response in initiate_stratum\");\n\t\tgoto out;\n\t}\n\n\tsret = recv_line(pool);\n\tif (!sret)\n\t\tgoto out;\n\n\trecvd = true;\n\n\tval = JSON_LOADS(sret, &err);\n\tfree(sret);\n\tif (!val) {\n\t\tapplog(LOG_INFO, \"JSON decode failed(%d): %s\", err.line, err.text);\n\t\tgoto out;\n\t}\n\n\tres_val = json_object_get(val, \"result\");\n\terr_val = json_object_get(val, \"error\");\n\n\tif (!res_val || json_is_null(res_val) ||\n\t    (err_val && !json_is_null(err_val))) {\n\t\tchar *ss;\n\n\t\tif (err_val)\n\t\t\tss = json_dumps(err_val, JSON_INDENT(3));\n\t\telse\n\t\t\tss = strdup(\"(unknown reason)\");\n\n\t\tapplog(LOG_INFO, \"JSON-RPC decode failed: %s\", ss);\n\n\t\tfree(ss);\n\n\t\tgoto out;\n\t}\n\n\tsessionid = get_sessionid(res_val);\n\tif (!sessionid)\n\t\tapplog(LOG_DEBUG, \"Failed to get sessionid in initiate_stratum\");\n\tnonce1 = json_array_string(res_val, 1);\n\tif (!nonce1) {\n\t\tapplog(LOG_INFO, \"Failed to get nonce1 in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tgoto out;\n\t}\n\tn2size = json_integer_value(json_array_get(res_val, 2));\n\tif (n2size < 1)\n\t{\n\t\tapplog(LOG_INFO, \"Failed to get n2size in initiate_stratum\");\n\t\tfree(sessionid);\n\t\tfree(nonce1);\n\t\tgoto out;\n\t}\n\n\tcg_wlock(&pool->data_lock);\n\tpool->sessionid = sessionid;\n\tpool->nonce1 = nonce1;\n\tpool->n1_len = strlen(nonce1) / 2;\n\tfree(pool->nonce1bin);\n\tpool->nonce1bin = (unsigned char *)calloc(pool->n1_len, 1);\n\tif (unlikely(!pool->nonce1bin))\n\t\tquithere(1, \"Failed to calloc pool->nonce1bin\");\n\thex2bin(pool->nonce1bin, pool->nonce1, pool->n1_len);\n\tpool->n2size = n2size;\n\tcg_wunlock(&pool->data_lock);\n\n\tif (sessionid)\n\t\tapplog(LOG_DEBUG, \"%s stratum session id: %s\", get_pool_name(pool), pool->sessionid);\n\n\tret = true;\nout:\n\tif (ret) {\n\t\tif (!pool->stratum_url)\n\t\t\tpool->stratum_url = pool->sockaddr_url;\n\t\tpool->stratum_active = true;\n\t\tpool->swork.diff = 1;\n\t\tif (opt_protocol) {\n\t\t\tapplog(LOG_DEBUG, \"%s confirmed mining.subscribe with extranonce1 %s extran2size %d\",\n\t\t\t       get_pool_name(pool), pool->nonce1, pool->n2size);\n\t\t}\n\t} else {\n\t\tif (recvd && !noresume) {\n\t\t\t/* Reset the sessionid used for stratum resuming in case the pool\n\t\t\t* does not support it, or does not know how to respond to the\n\t\t\t* presence of the sessionid parameter. */\n\t\t\tcg_wlock(&pool->data_lock);\n\t\t\tfree(pool->sessionid);\n\t\t\tfree(pool->nonce1);\n\t\t\tpool->sessionid = pool->nonce1 = NULL;\n\t\t\tcg_wunlock(&pool->data_lock);\n\n\t\t\tapplog(LOG_DEBUG, \"Failed to resume stratum, trying afresh\");\n\t\t\tnoresume = true;\n\t\t\tjson_decref(val);\n\t\t\tgoto resend;\n\t\t}\n\t\tapplog(LOG_DEBUG, \"Initiating stratum failed on %s\", get_pool_name(pool));\n\t\tif (sockd) {\n\t\t  applog(LOG_DEBUG, \"Suspending stratum on %s\", get_pool_name(pool));\n\t\t\tsuspend_stratum(pool);\n\t\t}\n\t}\n\n\tjson_decref(val);\n\treturn ret;\n}\n\nbool restart_stratum(struct pool *pool)\n{\n\tapplog(LOG_DEBUG, \"Restarting stratum on pool %s\", get_pool_name(pool));\n\n\tif (pool->stratum_active)\n\t\tsuspend_stratum(pool);\n\tif (!initiate_stratum(pool))\n\t\treturn false;\n\tif (pool->extranonce_subscribe && !subscribe_extranonce(pool))\n\t\treturn false;\n\tif (!auth_stratum(pool))\n\t\treturn false;\n\n\treturn true;\n}\n\nvoid dev_error(struct cgpu_info *dev, enum dev_reason reason)\n{\n\tdev->device_last_not_well = time(NULL);\n\tdev->device_not_well_reason = reason;\n\n\tswitch (reason) {\n\t\tcase REASON_THREAD_FAIL_INIT:\n\t\t\tdev->thread_fail_init_count++;\n\t\t\tbreak;\n\t\tcase REASON_THREAD_ZERO_HASH:\n\t\t\tdev->thread_zero_hash_count++;\n\t\t\tbreak;\n\t\tcase REASON_THREAD_FAIL_QUEUE:\n\t\t\tdev->thread_fail_queue_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_SICK_IDLE_60:\n\t\t\tdev->dev_sick_idle_60_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_DEAD_IDLE_600:\n\t\t\tdev->dev_dead_idle_600_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_NOSTART:\n\t\t\tdev->dev_nostart_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_OVER_HEAT:\n\t\t\tdev->dev_over_heat_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_THERMAL_CUTOFF:\n\t\t\tdev->dev_thermal_cutoff_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_COMMS_ERROR:\n\t\t\tdev->dev_comms_error_count++;\n\t\t\tbreak;\n\t\tcase REASON_DEV_THROTTLE:\n\t\t\tdev->dev_throttle_count++;\n\t\t\tbreak;\n\t}\n}\n\n/* Realloc an existing string to fit an extra string s, appending s to it. */\nvoid *realloc_strcat(char *ptr, char *s)\n{\n\tsize_t old = strlen(ptr), len = strlen(s);\n\tchar *ret;\n\n\tif (!len)\n\t\treturn ptr;\n\n\tlen += old + 1;\n\talign_len(&len);\n\n\tret = (char *)malloc(len);\n\tif (unlikely(!ret))\n\t\tquithere(1, \"Failed to malloc\");\n\n\tsprintf(ret, \"%s%s\", ptr, s);\n\tfree(ptr);\n\treturn ret;\n}\n\nvoid RenameThread(const char* name)\n{\n\tchar buf[16];\n\n\tsnprintf(buf, sizeof(buf), \"cg@%s\", name);\n#if defined(PR_SET_NAME)\n\t// Only the first 15 characters are used (16 - NUL terminator)\n\tprctl(PR_SET_NAME, buf, 0, 0, 0);\n#elif (defined(__FreeBSD__) || defined(__OpenBSD__))\n\tpthread_set_name_np(pthread_self(), buf);\n#elif defined(MAC_OSX)\n\tpthread_setname_np(buf);\n#else\n\t// Prevent warnings\n\t(void)buf;\n#endif\n}\n\n/* sgminer specific wrappers for true unnamed semaphore usage on platforms\n * that support them and for apple which does not. We use a single byte across\n * a pipe to emulate semaphore behaviour there. */\n#ifdef __APPLE__\nvoid _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tint flags, fd, i;\n\n\tif (pipe(cgsem->pipefd) == -1)\n\t\tquitfrom(1, file, func, line, \"Failed pipe errno=%d\", errno);\n\n\t/* Make the pipes FD_CLOEXEC to allow them to close should we call\n\t * execv on restart. */\n\tfor (i = 0; i < 2; i++) {\n\t\tfd = cgsem->pipefd[i];\n\t\tflags = fcntl(fd, F_GETFD, 0);\n\t\tflags |= FD_CLOEXEC;\n\t\tif (fcntl(fd, F_SETFD, flags) == -1)\n\t\t\tquitfrom(1, file, func, line, \"Failed to fcntl errno=%d\", errno);\n\t}\n}\n\nvoid _cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tconst char buf = 1;\n\tint ret;\n\nretry:\n\tret = write(cgsem->pipefd[1], &buf, 1);\n\tif (unlikely(ret == 0))\n\t\tapplog(LOG_WARNING, \"Failed to write errno=%d\" IN_FMT_FFL, errno, file, func, line);\n\telse if (unlikely(ret < 0 && interrupted))\n\t\tgoto retry;\n}\n\nvoid _cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tchar buf;\n\tint ret;\nretry:\n\tret = read(cgsem->pipefd[0], &buf, 1);\n\tif (unlikely(ret == 0))\n\t\tapplog(LOG_WARNING, \"Failed to read errno=%d\" IN_FMT_FFL, errno, file, func, line);\n\telse if (unlikely(ret < 0 && interrupted))\n\t\tgoto retry;\n}\n\nvoid cgsem_destroy(cgsem_t *cgsem)\n{\n\tclose(cgsem->pipefd[1]);\n\tclose(cgsem->pipefd[0]);\n}\n\n/* This is similar to sem_timedwait but takes a millisecond value */\nint _cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)\n{\n\tstruct timeval timeout;\n\tint ret, fd;\n\tfd_set rd;\n\tchar buf;\n\nretry:\n\tfd = cgsem->pipefd[0];\n\tFD_ZERO(&rd);\n\tFD_SET(fd, &rd);\n\tms_to_timeval(&timeout, ms);\n\tret = select(fd + 1, &rd, NULL, NULL, &timeout);\n\n\tif (ret > 0) {\n\t\tret = read(fd, &buf, 1);\n\t\treturn 0;\n\t}\n\tif (likely(!ret))\n\t\treturn ETIMEDOUT;\n\tif (interrupted())\n\t\tgoto retry;\n\tquitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);\n\t/* We don't reach here */\n\treturn 0;\n}\n\n/* Reset semaphore count back to zero */\nvoid cgsem_reset(cgsem_t *cgsem)\n{\n\tint ret, fd;\n\tfd_set rd;\n\tchar buf;\n\n\tfd = cgsem->pipefd[0];\n\tFD_ZERO(&rd);\n\tFD_SET(fd, &rd);\n\tdo {\n\t\tstruct timeval timeout = {0, 0};\n\n\t\tret = select(fd + 1, &rd, NULL, NULL, &timeout);\n\t\tif (ret > 0)\n\t\t\tret = read(fd, &buf, 1);\n\t\telse if (unlikely(ret < 0 && interrupted()))\n\t\t\tret = 1;\n\t} while (ret > 0);\n}\n#else\nvoid _cgsem_init(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tint ret;\n\tif ((ret = sem_init(cgsem, 0, 0)))\n\t\tquitfrom(1, file, func, line, \"Failed to sem_init ret=%d errno=%d\", ret, errno);\n}\n\nvoid _cgsem_post(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\n\tif (unlikely(sem_post(cgsem)))\n\t\tquitfrom(1, file, func, line, \"Failed to sem_post errno=%d cgsem=0x%p\", errno, cgsem);\n}\n\nvoid _cgsem_wait(cgsem_t *cgsem, const char *file, const char *func, const int line)\n{\nretry:\n\tif (unlikely(sem_wait(cgsem))) {\n\t\tif (interrupted())\n\t\t\tgoto retry;\n\t\tquitfrom(1, file, func, line, \"Failed to sem_wait errno=%d cgsem=0x%p\", errno, cgsem);\n\t}\n}\n\nint _cgsem_mswait(cgsem_t *cgsem, int ms, const char *file, const char *func, const int line)\n{\n\tstruct timespec abs_timeout, ts_now;\n\tstruct timeval tv_now;\n\tint ret;\n\n\tcgtime(&tv_now);\n\ttimeval_to_spec(&ts_now, &tv_now);\n\tms_to_timespec(&abs_timeout, ms);\nretry:\n\ttimeraddspec(&abs_timeout, &ts_now);\n\tret = sem_timedwait(cgsem, &abs_timeout);\n\n\tif (ret) {\n\t\tif (likely(sock_timeout()))\n\t\t\treturn ETIMEDOUT;\n\t\tif (interrupted())\n\t\t\tgoto retry;\n\t\tquitfrom(1, file, func, line, \"Failed to sem_timedwait errno=%d cgsem=0x%p\", errno, cgsem);\n\t}\n\treturn 0;\n}\n\nvoid cgsem_reset(cgsem_t *cgsem)\n{\n\tint ret;\n\n\tdo {\n\t\tret = sem_trywait(cgsem);\n\t\tif (unlikely(ret < 0 && interrupted()))\n\t\t\tret = 0;\n\t} while (!ret);\n}\n\nvoid cgsem_destroy(cgsem_t *cgsem)\n{\n\tsem_destroy(cgsem);\n}\n#endif\n\n/* Provide a completion_timeout helper function for unreliable functions that\n * may die due to driver issues etc that time out if the function fails and\n * can then reliably return. */\nstruct cg_completion {\n\tcgsem_t cgsem;\n\tvoid (*fn)(void *fnarg);\n\tvoid *fnarg;\n};\n\nvoid *completion_thread(void *arg)\n{\n\tstruct cg_completion *cgc = (struct cg_completion *)arg;\n\n\tpthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);\n\tcgc->fn(cgc->fnarg);\n\tcgsem_post(&cgc->cgsem);\n\n\treturn NULL;\n}\n\nbool cg_completion_timeout(void *fn, void *fnarg, int timeout)\n{\n\tstruct cg_completion *cgc;\n\tpthread_t pthread;\n\tbool ret = false;\n\n\tcgc = (struct cg_completion *)malloc(sizeof(struct cg_completion));\n\tif (unlikely(!cgc))\n\t\treturn ret;\n\tcgsem_init(&cgc->cgsem);\n\n#ifdef _MSC_VER\n\tcgc->fn = (void(__cdecl *)(void *))fn;\n#else\n\tcgc->fn = fn;\n#endif\n\n\tcgc->fnarg = fnarg;\n\n\tpthread_create(&pthread, NULL, completion_thread, (void *)cgc);\n\n\tret = cgsem_mswait(&cgc->cgsem, timeout);\n\n\tif (ret)\n\t\tpthread_cancel(pthread);\n\n\tpthread_join(pthread, NULL);\n\tfree(cgc);\n\treturn !ret;\n}\n"], "filenames": ["util.c"], "buggy_code_start_loc": [1603], "buggy_code_end_loc": [1620], "fixing_code_start_loc": [1603], "fixing_code_end_loc": [1628], "type": "CWE-20", "message": "The parse_notify function in util.c in sgminer before 4.2.2 and cgminer 3.3.0 through 4.0.1 allows man-in-the-middle attackers to cause a denial of service (application exit) via a crafted (1) bbversion, (2) prev_hash, (3) nbit, or (4) ntime parameter in a mining.notify action stratum message.", "other": {"cve": {"id": "CVE-2014-4503", "sourceIdentifier": "cve@mitre.org", "published": "2014-07-23T14:55:06.180", "lastModified": "2014-07-23T18:25:30.867", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The parse_notify function in util.c in sgminer before 4.2.2 and cgminer 3.3.0 through 4.0.1 allows man-in-the-middle attackers to cause a denial of service (application exit) via a crafted (1) bbversion, (2) prev_hash, (3) nbit, or (4) ntime parameter in a mining.notify action stratum message."}, {"lang": "es", "value": "La funci\u00f3n parse_notify en util.c en sgminer anterior a 4.2.2 y cgminer 3.3.0 hasta 4.0.1 permite a atacantes man-in-the-middle causar una denegaci\u00f3n de servicio (salida de aplicaci\u00f3n) a trav\u00e9s de un par\u00e1metro (1) bbversion, (2) prev_hash, (3) nbit o (4) ntime manipulado en un mensaje de estrato de la acci\u00f3n mining.notify."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sgminer_project:sgminer:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.2.1", "matchCriteriaId": "674C554E-841D-4D4B-99B9-F2641327AF5A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sgminer_project:sgminer:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "0E3DD6BA-85F4-49B4-B489-DCB763AA65E2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sgminer_project:sgminer:4.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "95929A1F-64B1-45E7-A9A0-E1603FDCD176"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sgminer_project:sgminer:4.1.153:*:*:*:*:*:*:*", "matchCriteriaId": "22ADC6DB-0EB9-43E8-AA12-09FD74CC4914"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sgminer_project:sgminer:4.1.242:*:*:*:*:*:*:*", "matchCriteriaId": "FB19CC92-1BC6-44F2-B11B-B87EFC0AF8CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sgminer_project:sgminer:4.1.271:*:*:*:*:*:*:*", "matchCriteriaId": "94A63F06-378D-46BB-98D2-03E70E94A83C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:sgminer_project:sgminer:4.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "593E9A8D-2A7D-4089-8E4B-A26FF4E28407"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "A3E8FD90-BE95-466D-A8AB-8CFADE742039"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.3.1:*:*:*:*:*:*:*", "matchCriteriaId": "25B9B6E1-BE8A-468F-B071-FEFA56FDDE1D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "44026F02-2009-455F-9E72-B8CDDC010796"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "E4BB88E4-4B5F-4084-9834-827FD4953839"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.3.4:*:*:*:*:*:*:*", "matchCriteriaId": "BAEA1C00-137B-4C68-9A52-233AC3306D61"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "550E17E8-B1B2-469D-B5A8-A5B9682EC435"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.4.1:*:*:*:*:*:*:*", "matchCriteriaId": "D1EADA37-1025-48BB-B8D7-6EBDDA3F5750"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.4.2:*:*:*:*:*:*:*", "matchCriteriaId": "C313482C-F990-4931-96B6-5C3A2F9EEA0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.4.3:*:*:*:*:*:*:*", "matchCriteriaId": "197CA4B6-7637-4EEE-9977-309B9A9E1346"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.5.0:*:*:*:*:*:*:*", "matchCriteriaId": "EFA7646D-7AB9-4656-A342-0A76E739494A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.5.1:*:*:*:*:*:*:*", "matchCriteriaId": "BC726D8C-96D3-464F-9B6F-62915F03C3FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.6.0:*:*:*:*:*:*:*", "matchCriteriaId": "11967B63-B428-41D9-84D0-3EB7D25F302F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.6.1:*:*:*:*:*:*:*", "matchCriteriaId": "83A55FD3-C960-42E4-A739-B5F5C7A17E44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.6.2:*:*:*:*:*:*:*", "matchCriteriaId": "DBC52DEE-5617-450C-AE11-45D442E3DF0A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.6.3:*:*:*:*:*:*:*", "matchCriteriaId": "F8B7CF11-B917-4A7E-B356-66830793741F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.6.4:*:*:*:*:*:*:*", "matchCriteriaId": "15835C2F-03AA-43A5-B6CD-C8A4D2FB8257"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "6DB8FA77-AE23-4CF2-8059-342F2BC66945"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.7.1:*:*:*:*:*:*:*", "matchCriteriaId": "C2161A07-4A1B-427F-83CB-6E78A532D1A5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.7.2:*:*:*:*:*:*:*", "matchCriteriaId": "8622E0F6-FBC0-42EB-B105-C72BE9BB4D17"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "0767633B-81D0-4E1C-8218-FABDC75607EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.8.1:*:*:*:*:*:*:*", "matchCriteriaId": "14FFCA52-35C1-4132-8563-BA5047E67A84"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.8.2:*:*:*:*:*:*:*", "matchCriteriaId": "84C604A8-A630-4E0E-A884-957E68A1F329"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.8.3:*:*:*:*:*:*:*", "matchCriteriaId": "1F575419-5922-442E-BF8D-7A0271E00C09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.8.4:*:*:*:*:*:*:*", "matchCriteriaId": "33C85B0C-FAE7-4670-A43A-DE0E70548970"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.8.5:*:*:*:*:*:*:*", "matchCriteriaId": "87847DB7-81A7-4A00-9DFD-9EFFF9F43A5D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA3396A9-0D3E-4F5C-B682-2AC2BA8901B2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "5095EFA8-8E27-40F1-83AF-3C9503B452D4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.11.0:*:*:*:*:*:*:*", "matchCriteriaId": "F314E396-D64E-4106-B904-8D6395FAD131"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.12.0:*:*:*:*:*:*:*", "matchCriteriaId": "CD4C97EB-FF11-431A-8C90-9C56228971FD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.12.1:*:*:*:*:*:*:*", "matchCriteriaId": "5A059FA2-5314-43C9-8CDC-00FE7B32A3F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.12.2:*:*:*:*:*:*:*", "matchCriteriaId": "B764E3D6-CB4D-4873-84B1-1429018A7916"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:3.12.3:*:*:*:*:*:*:*", "matchCriteriaId": "775AFA05-A5D8-438C-BCB2-992E491FCA1E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "6D5F46BD-485D-4263-B4BA-63B775AC169B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:cgminer_project:cgminer:4.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "7893B678-C321-424A-B07E-7DB2E3592A81"}]}]}], "references": [{"url": "http://seclists.org/fulldisclosure/2014/Jul/120", "source": "cve@mitre.org"}, {"url": "https://github.com/sgminer-dev/sgminer/commit/910c36089940e81fb85c65b8e63dcd2fac71470c", "source": "cve@mitre.org", "tags": ["Exploit", "Patch"]}]}, "github_commit_url": "https://github.com/sgminer-dev/sgminer/commit/910c36089940e81fb85c65b8e63dcd2fac71470c"}}