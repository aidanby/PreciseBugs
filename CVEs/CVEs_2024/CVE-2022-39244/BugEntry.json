{"buggy_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/scanner.h>\n#include <pj/ctype.h>\n#include <pj/string.h>\n#include <pj/except.h>\n#include <pj/os.h>\n#include <pj/log.h>\n#include <pj/errno.h>\n#include <pj/assert.h>\n\n#define THIS_FILE   \"scanner.c\"\n\n#define PJ_SCAN_IS_SPACE(c)\t\t((c)==' ' || (c)=='\\t')\n#define PJ_SCAN_IS_NEWLINE(c)\t\t((c)=='\\r' || (c)=='\\n')\n#define PJ_SCAN_IS_PROBABLY_SPACE(c)\t((c) <= 32)\n#define PJ_SCAN_CHECK_EOF(s)\t\t(s != scanner->end)\n\n\n#if defined(PJ_SCANNER_USE_BITWISE) && PJ_SCANNER_USE_BITWISE != 0\n#  include \"scanner_cis_bitwise.c\"\n#else\n#  include \"scanner_cis_uint.c\"\n#endif\n\n\nstatic void pj_scan_syntax_err(pj_scanner *scanner)\n{\n    (*scanner->callback)(scanner);\n}\n\n\nPJ_DEF(void) pj_cis_add_range(pj_cis_t *cis, int cstart, int cend)\n{\n    /* Can not set zero. This is the requirement of the parser. */\n    pj_assert(cstart > 0);\n\n    while (cstart != cend) {\n        PJ_CIS_SET(cis, cstart);\n\t++cstart;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_alpha(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, 'a', 'z'+1);\n    pj_cis_add_range( cis, 'A', 'Z'+1);\n}\n\nPJ_DEF(void) pj_cis_add_num(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, '0', '9'+1);\n}\n\nPJ_DEF(void) pj_cis_add_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_SET(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_cis( pj_cis_t *cis, const pj_cis_t *rhs)\n{\n    int i;\n    for (i=0; i<256; ++i) {\n\tif (PJ_CIS_ISSET(rhs, i))\n\t    PJ_CIS_SET(cis, i);\n    }\n}\n\nPJ_DEF(void) pj_cis_del_range( pj_cis_t *cis, int cstart, int cend)\n{\n    while (cstart != cend) {\n        PJ_CIS_CLR(cis, cstart);\n        cstart++;\n    }\n}\n\nPJ_DEF(void) pj_cis_del_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_CLR(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_invert( pj_cis_t *cis )\n{\n    unsigned i;\n    /* Can not set zero. This is the requirement of the parser. */\n    for (i=1; i<256; ++i) {\n\tif (PJ_CIS_ISSET(cis,i))\n            PJ_CIS_CLR(cis,i);\n        else\n            PJ_CIS_SET(cis,i);\n    }\n}\n\nPJ_DEF(void) pj_scan_init( pj_scanner *scanner, char *bufstart, \n\t\t\t   pj_size_t buflen, unsigned options, \n\t\t\t   pj_syn_err_func_ptr callback )\n{\n    PJ_CHECK_STACK();\n\n    scanner->begin = scanner->curptr = bufstart;\n    scanner->end = bufstart + buflen;\n    scanner->line = 1;\n    scanner->start_line = scanner->begin;\n    scanner->callback = callback;\n    scanner->skip_ws = options;\n\n    if (scanner->skip_ws) \n\tpj_scan_skip_whitespace(scanner);\n}\n\n\nPJ_DEF(void) pj_scan_fini( pj_scanner *scanner )\n{\n    PJ_CHECK_STACK();\n    PJ_UNUSED_ARG(scanner);\n}\n\nPJ_DEF(void) pj_scan_skip_whitespace( pj_scanner *scanner )\n{\n    register char *s = scanner->curptr;\n\n    while (PJ_SCAN_IS_SPACE(*s)) {\n\t++s;\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_NEWLINE)) {\n\tfor (;;) {\n\t    if (*s == '\\r') {\n\t\t++s;\n\t\tif (*s == '\\n') ++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (*s == '\\n') {\n\t\t++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (PJ_SCAN_IS_SPACE(*s)) {\n\t\tdo {\n\t\t    ++s;\n\t\t} while (PJ_SCAN_IS_SPACE(*s));\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_WS_HEADER)==PJ_SCAN_AUTOSKIP_WS_HEADER) {\n\t/* Check for header continuation. */\n\tscanner->curptr = s;\n\n\tif (*s == '\\r') {\n\t    ++s;\n\t}\n\tif (*s == '\\n') {\n\t    ++s;\n\t}\n\tscanner->start_line = s;\n\n\tif (PJ_SCAN_IS_SPACE(*s)) {\n\t    register char *t = s;\n\t    do {\n\t\t++t;\n\t    } while (PJ_SCAN_IS_SPACE(*t));\n\n\t    ++scanner->line;\n\t    scanner->curptr = t;\n\t}\n    } else {\n\tscanner->curptr = s;\n    }\n}\n\nPJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}\n\nPJ_DEF(int) pj_scan_peek( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    /* Don't need to check EOF with PJ_SCAN_CHECK_EOF(s) */\n    while (pj_cis_match(spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(int) pj_scan_peek_n( pj_scanner *scanner,\n\t\t\t     pj_size_t len, pj_str_t *out)\n{\n    char *endpos = scanner->curptr + len;\n\n    if (endpos > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    pj_strset(out, scanner->curptr, len);\n    return *endpos;\n}\n\n\nPJ_DEF(int) pj_scan_peek_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, \n\t\t\t\tpj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match( spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    /* EOF is detected implicitly */\n    if (!pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    /* No need to check EOF here (PJ_SCAN_CHECK_EOF(s)) because\n     * buffer is NULL terminated and pj_cis_match(spec,0) should be\n     * false.\n     */\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    /* Must not match character '%' */\n    pj_assert(pj_cis_match(spec,'%')==0);\n\n    /* EOF is detected implicitly */\n    if (!pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n\t\n    } while (*s == '%');\n\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_quote( pj_scanner *scanner,\n\t\t\t\tint begin_quote, int end_quote, \n\t\t\t\tpj_str_t *out)\n{\n    char beg = (char)begin_quote;\n    char end = (char)end_quote;\n    pj_scan_get_quotes(scanner, &beg, &end, 1, out);\n}\n\nPJ_DEF(void) pj_scan_get_quotes(pj_scanner *scanner,\n                                const char *begin_quote, const char *end_quote,\n                                int qsize, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    int qpair = -1;\n    int i;\n\n    pj_assert(qsize > 0);\n\n    /* Check and eat the begin_quote. */\n    for (i = 0; i < qsize; ++i) {\n\tif (*s == begin_quote[i]) {\n\t    qpair = i;\n\t    break;\n\t}\n    }\n    if (qpair == -1) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    /* Loop until end_quote is found. \n     */\n    do {\n\t/* loop until end_quote is found. */\n\twhile (PJ_SCAN_CHECK_EOF(s) && *s != '\\n' && *s != end_quote[qpair]) {\n\t    ++s;\n\t}\n\n\t/* check that no backslash character precedes the end_quote. */\n\tif (*s == end_quote[qpair]) {\n\t    if (*(s-1) == '\\\\') {\n\t\tchar *q = s-2;\n\t\tchar *r = s-2;\n\n\t\twhile (r != scanner->begin && *r == '\\\\') {\n\t\t    --r;\n\t\t}\n\t\t/* break from main loop if we have odd number of backslashes */\n\t\tif (((unsigned)(q-r) & 0x01) == 1) {\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    } else {\n\t\t/* end_quote is not preceeded by backslash. break now. */\n\t\tbreak;\n\t    }\n\t} else {\n\t    /* loop ended by non-end_quote character. break now. */\n\t    break;\n\t}\n    } while (1);\n\n    /* Check and eat the end quote. */\n    if (*s != end_quote[qpair]) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    pj_strset(out, scanner->curptr, N);\n    \n    scanner->curptr += N;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n{\n    register char *s = scanner->curptr;\n    int chr;\n\n    if (s >= scanner->end || !*s) {\n\tpj_scan_syntax_err(scanner);\n\treturn 0;\n    }\n\n    chr = *s;\n\n    ++s;\n    scanner->curptr = s;\n    if (PJ_SCAN_CHECK_EOF(s) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n    \tscanner->skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n    return chr;\n}\n\n\nPJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (!PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (*scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n\n    /**\n     * This probably is a bug, see PROTOS test #2480.\n     * This would cause scanner to incorrectly eat two new lines, e.g.\n     * when parsing:\n     *   \n     *\tContent-Length: 120\\r\\n\n     *\t\\r\\n\n     *\t<space><space><space>...\n     *\n     * When pj_scan_get_newline() is called to parse the first newline\n     * in the Content-Length header, it will eat the second newline\n     * too because it thinks that it's a header continuation.\n     *\n     * if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n     *    pj_scan_skip_whitespace(scanner);\n     * }\n     */\n}\n\n\nPJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n\t\t\t\t     const char *until_spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_size_t speclen;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    speclen = strlen(until_spec);\n    while (PJ_SCAN_CHECK_EOF(s) && !memchr(until_spec, *s, speclen)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\nPJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    scanner->curptr += N;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_strcmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strncmp(scanner->curptr, s, len);\n}\n\n\nPJ_DEF(int) pj_scan_stricmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return pj_ansi_strnicmp(scanner->curptr, s, len);\n}\n\nPJ_DEF(int) pj_scan_stricmp_alnum( pj_scanner *scanner, const char *s, \n\t\t\t\t   int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strnicmp_alnum(scanner->curptr, s, len);\n}\n\nPJ_DEF(void) pj_scan_save_state( const pj_scanner *scanner, \n\t\t\t\t pj_scan_state *state)\n{\n    state->curptr = scanner->curptr;\n    state->line = scanner->line;\n    state->start_line = scanner->start_line;\n}\n\n\nPJ_DEF(void) pj_scan_restore_state( pj_scanner *scanner, \n\t\t\t\t    pj_scan_state *state)\n{\n    scanner->curptr = state->curptr;\n    scanner->line = state->line;\n    scanner->start_line = state->start_line;\n}\n\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtp.h>\n#include <pjmedia/errno.h>\n#include <pj/log.h>\n#include <pj/sock.h>\t/* pj_htonx, pj_htonx */\n#include <pj/assert.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n\n#define THIS_FILE   \"rtp.c\"\n\n#define RTP_VERSION\t2\n\n#define RTP_SEQ_MOD\t(1 << 16)\n#define MAX_DROPOUT \t((pj_int16_t)3000)\n#define MAX_MISORDER \t((pj_int16_t)100)\n#define MIN_SEQUENTIAL  ((pj_int16_t)2)\n\nstatic void pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *seq_ctrl, \n\t\t\t\t    pj_uint16_t seq);\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init( pjmedia_rtp_session *ses,\n\t\t\t\t\t      int default_pt, \n\t\t\t\t\t      pj_uint32_t sender_ssrc )\n{\n    PJ_LOG(5, (THIS_FILE, \n\t       \"pjmedia_rtp_session_init: ses=%p, default_pt=%d, ssrc=0x%x\",\n\t       ses, default_pt, sender_ssrc));\n\n    /* Check RTP header packing. */\n    if (sizeof(struct pjmedia_rtp_hdr) != 12) {\n\tpj_assert(!\"Wrong RTP header packing!\");\n\treturn PJMEDIA_RTP_EINPACK;\n    }\n\n    /* If sender_ssrc is not specified, create from random value. */\n    if (sender_ssrc == 0 || sender_ssrc == (pj_uint32_t)-1) {\n\tsender_ssrc = pj_htonl(pj_rand());\n    } else {\n\tsender_ssrc = pj_htonl(sender_ssrc);\n    }\n\n    /* Initialize session. */\n    pj_bzero(ses, sizeof(*ses));\n\n    /* Initial sequence number SHOULD be random, according to RFC 3550. */\n    /* According to RFC 3711, it should be random within 2^15 bit */\n    ses->out_extseq = pj_rand() & 0x7FFF;\n    ses->peer_ssrc = 0;\n    \n    /* Build default header for outgoing RTP packet. */\n    ses->out_hdr.v = RTP_VERSION;\n    ses->out_hdr.p = 0;\n    ses->out_hdr.x = 0;\n    ses->out_hdr.cc = 0;\n    ses->out_hdr.m = 0;\n    ses->out_hdr.pt = (pj_uint8_t) default_pt;\n    ses->out_hdr.seq = (pj_uint16_t) pj_htons( (pj_uint16_t)ses->out_extseq );\n    ses->out_hdr.ts = 0;\n    ses->out_hdr.ssrc = sender_ssrc;\n\n    /* Keep some arguments as session defaults. */\n    ses->out_pt = (pj_uint16_t) default_pt;\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init2( \n\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t    pjmedia_rtp_session_setting settings)\n{\n    pj_status_t status;\n    int\t\t pt = 0;\n    pj_uint32_t\t sender_ssrc = 0;\n\n    if (settings.flags & 1)\n\tpt = settings.default_pt;\n    if (settings.flags & 2)\n\tsender_ssrc = settings.sender_ssrc;\n\n    status = pjmedia_rtp_session_init(ses, pt, sender_ssrc);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    if (settings.flags & 4) {\n\tses->out_extseq = settings.seq;\n\tses->out_hdr.seq = pj_htons((pj_uint16_t)ses->out_extseq);\n    }\n    if (settings.flags & 8)\n\tses->out_hdr.ts = pj_htonl(settings.ts);\n    if (settings.flags & 16) {\n        ses->has_peer_ssrc = PJ_TRUE;\n\tses->peer_ssrc = settings.peer_ssrc;\n    }\n\n    PJ_LOG(5, (THIS_FILE,\n\t       \"pjmedia_rtp_session_init2: ses=%p, seq=%d, ts=%d, peer_ssrc=%d\",\n\t       ses, pj_ntohs(ses->out_hdr.seq), pj_ntohl(ses->out_hdr.ts),\n\t       ses->has_peer_ssrc? ses->peer_ssrc : 0));\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_encode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    int pt, int m,\n\t\t\t\t\t    int payload_len, int ts_len,\n\t\t\t\t\t    const void **rtphdr, int *hdrlen )\n{\n    /* Update timestamp */\n    ses->out_hdr.ts = pj_htonl(pj_ntohl(ses->out_hdr.ts)+ts_len);\n\n    /* If payload_len is zero, bail out.\n     * This is a clock frame; we're not really transmitting anything.\n     */\n    if (payload_len == 0)\n\treturn PJ_SUCCESS;\n\n    /* Update session. */\n    ses->out_extseq++;\n\n    /* Create outgoing header. */\n    ses->out_hdr.pt = (pj_uint8_t) ((pt == -1) ? ses->out_pt : pt);\n    ses->out_hdr.m = (pj_uint16_t) m;\n    ses->out_hdr.seq = pj_htons( (pj_uint16_t) ses->out_extseq);\n\n    /* Return values */\n    *rtphdr = &ses->out_hdr;\n    *hdrlen = sizeof(pjmedia_rtp_hdr);\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    pjmedia_rtp_dec_hdr dec_hdr;\n\n    return pjmedia_rtp_decode_rtp2(ses, pkt, pkt_len, hdr, &dec_hdr, \n\t\t\t\t   payload, payloadlen);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    /* Assume RTP header at the start of packet. We'll verify this later. */\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    /* Check RTP header sanity. */\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    /* Payload is located right after header plus CSRC */\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    /* Decode RTP extension. */\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > (unsigned)pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    /* Check that offset is less than packet size */\n    if (offset > pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    /* Find and set payload. */\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    /* Remove payload padding if any */\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(void) pjmedia_rtp_session_update( pjmedia_rtp_session *ses, \n\t\t\t\t\t const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t pjmedia_rtp_status *p_seq_st)\n{\n    pjmedia_rtp_session_update2(ses, hdr, p_seq_st, PJ_TRUE);\n}\n\nPJ_DEF(void) pjmedia_rtp_session_update2( pjmedia_rtp_session *ses, \n\t\t\t\t\t  const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t  pjmedia_rtp_status *p_seq_st,\n\t\t\t\t\t  pj_bool_t check_pt)\n{\n    pjmedia_rtp_status seq_st;\n\n    /* for now check_pt MUST be either PJ_TRUE or PJ_FALSE.\n     * In the future we might change check_pt from boolean to \n     * unsigned integer to accommodate more flags.\n     */\n    pj_assert(check_pt==PJ_TRUE || check_pt==PJ_FALSE);\n\n    /* Init status */\n    seq_st.status.value = 0;\n    seq_st.diff = 0;\n\n    /* Check SSRC. */\n    if (!ses->has_peer_ssrc && ses->peer_ssrc == 0)\n        ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n\n    if (pj_ntohl(hdr->ssrc) != ses->peer_ssrc) {\n\tseq_st.status.flag.badssrc = 1;\n\tif (!ses->has_peer_ssrc)\n\t    ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n    }\n\n    /* Check payload type. */\n    if (check_pt && hdr->pt != ses->out_pt) {\n\tif (p_seq_st) {\n\t    p_seq_st->status.value = seq_st.status.value;\n\t    p_seq_st->status.flag.bad = 1;\n\t    p_seq_st->status.flag.badpt = 1;\n\t}\n\treturn;\n    }\n\n    /* Initialize sequence number on first packet received. */\n    if (ses->received == 0)\n\tpjmedia_rtp_seq_init( &ses->seq_ctrl, pj_ntohs(hdr->seq) );\n\n    /* Check sequence number to see if remote session has been restarted. */\n    pjmedia_rtp_seq_update( &ses->seq_ctrl, pj_ntohs(hdr->seq), &seq_st);\n    if (seq_st.status.flag.restart) {\n\t++ses->received;\n\n    } else if (!seq_st.status.flag.bad) {\n\t++ses->received;\n    }\n\n    if (p_seq_st) {\n\tp_seq_st->status.value = seq_st.status.value;\n\tp_seq_st->diff = seq_st.diff;\n    }\n}\n\n\n\nvoid pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    sess->base_seq = seq;\n    sess->max_seq = seq;\n    sess->bad_seq = RTP_SEQ_MOD + 1;\n    sess->cycles = 0;\n}\n\n\nvoid pjmedia_rtp_seq_init(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    pjmedia_rtp_seq_restart(sess, seq);\n\n    sess->max_seq = (pj_uint16_t) (seq - 1);\n    sess->probation = MIN_SEQUENTIAL;\n}\n\n\nvoid pjmedia_rtp_seq_update( pjmedia_rtp_seq_session *sess, \n\t\t\t     pj_uint16_t seq,\n\t\t\t     pjmedia_rtp_status *seq_status)\n{\n    pj_uint16_t udelta = (pj_uint16_t) (seq - sess->max_seq);\n    pjmedia_rtp_status st;\n    \n    /* Init status */\n    st.status.value = 0;\n    st.diff = 0;\n\n    /*\n     * Source is not valid until MIN_SEQUENTIAL packets with\n     * sequential sequence numbers have been received.\n     */\n    if (sess->probation) {\n\n\tst.status.flag.probation = 1;\n\t\n        if (seq == sess->max_seq+ 1) {\n\t    /* packet is in sequence */\n\t    st.diff = 1;\n\t    sess->probation--;\n            sess->max_seq = seq;\n            if (sess->probation == 0) {\n\t\tst.status.flag.probation = 0;\n            }\n\t} else {\n\n\t    st.diff = 0;\n\n\t    st.status.flag.bad = 1;\n\t    if (seq == sess->max_seq)\n\t\tst.status.flag.dup = 1;\n\t    else\n\t\tst.status.flag.outorder = 1;\n\n\t    sess->probation = MIN_SEQUENTIAL - 1;\n\t    sess->max_seq = seq;\n        }\n\n\n    } else if (udelta == 0) {\n\n\tst.status.flag.dup = 1;\n\n    } else if (udelta < MAX_DROPOUT) {\n\t/* in order, with permissible gap */\n\tif (seq < sess->max_seq) {\n\t    /* Sequence number wrapped - count another 64K cycle. */\n\t    sess->cycles += RTP_SEQ_MOD;\n        }\n        sess->max_seq = seq;\n\n\tst.diff = udelta;\n\n    } else if (udelta <= (RTP_SEQ_MOD - MAX_MISORDER)) {\n\t/* the sequence number made a very large jump */\n        if (seq == sess->bad_seq) {\n\t    /*\n\t     * Two sequential packets -- assume that the other side\n\t     * restarted without telling us so just re-sync\n\t     * (i.e., pretend this was the first packet).\n\t     */\n\t    pjmedia_rtp_seq_restart(sess, seq);\n\t    st.status.flag.restart = 1;\n\t    st.status.flag.probation = 1;\n\t    st.diff = 1;\n\t}\n        else {\n\t    sess->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);\n            st.status.flag.bad = 1;\n\t    st.status.flag.outorder = 1;\n        }\n    } else {\n\t/* old duplicate or reordered packet.\n\t * Not necessarily bad packet (?)\n\t */\n\tst.status.flag.outorder = 1;\n    }\n    \n\n    if (seq_status) {\n\tseq_status->diff = st.diff;\n\tseq_status->status.value = st.status.value;\n    }\n}\n\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/sdp.h>\n#include <pjmedia/errno.h>\n#include <pjlib-util/scanner.h>\n#include <pj/array.h>\n#include <pj/except.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n\n\nenum {\n    SKIP_WS = 0,\n    SYNTAX_ERROR = 1,\n};\n// New token definition from RFC 4566 (SDP)\n#define TOKEN\t\t\"!#$%&'*+-.^_`{|}~\"\n//#define TOKEN\t\t\"-.!%*_=`'~\"\n//#define TOKEN\t\t\"'`-./:?\\\"#$&*;=@[]^_`{|}+~!\"\n#define NTP_OFFSET\t((pj_uint32_t)2208988800)\n#define THIS_FILE\t\"sdp.c\"\n\ntypedef struct parse_context\n{ \n    pj_status_t last_error;\n} parse_context;\n\n\n/*\n * Prototypes for line parser.\n */\nstatic void parse_version(pj_scanner *scanner, volatile parse_context *ctx);\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx);\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx);\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx);\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx);\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx);\nstatic pjmedia_sdp_attr *parse_attr(pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx);\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx);\nstatic void on_scanner_error(pj_scanner *scanner);\n\n/*\n * Scanner character specification.\n */\nstatic int is_initialized;\nstatic pj_cis_buf_t cis_buf;\nstatic pj_cis_t cs_digit, cs_token;\n\nstatic void init_sdp_parser(void)\n{\n    if (is_initialized != 0)\n\treturn;\n\n    pj_enter_critical_section();\n\n    if (is_initialized != 0) {\n\tpj_leave_critical_section();\n\treturn;\n    }\n    \n    pj_cis_buf_init(&cis_buf);\n\n    pj_cis_init(&cis_buf, &cs_token);\n    pj_cis_add_alpha(&cs_token);\n    pj_cis_add_num(&cs_token);\n    pj_cis_add_str(&cs_token, TOKEN);\n\n    pj_cis_init(&cis_buf, &cs_digit);\n    pj_cis_add_num(&cs_digit);\n\n    is_initialized = 1;\n    pj_leave_critical_section();\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create( pj_pool_t *pool,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   const pj_str_t *value)\n{\n    pjmedia_sdp_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && name, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    pj_strdup2(pool, &attr->name, name);\n\n    if (value)\n\tpj_strdup_with_null(pool, &attr->value, value);\n    else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_clone(pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_attr *rhs)\n{\n    pjmedia_sdp_attr *attr;\n    \n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    pj_strdup(pool, &attr->name, &rhs->name);\n    pj_strdup_with_null(pool, &attr->value, &rhs->value);\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find (unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const pj_str_t *name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    unsigned i;\n    unsigned c_pt = 0xFFFF;\n\n    PJ_ASSERT_RETURN(count <= PJMEDIA_MAX_SDP_ATTR, NULL);\n\n    if (c_fmt)\n\tc_pt = pj_strtoul(c_fmt);\n\n    for (i=0; i<count; ++i) {\n\tif (pj_strcmp(&attr_array[i]->name, name) == 0) {\n\t    const pjmedia_sdp_attr *a = attr_array[i];\n\t    if (c_fmt) {\n\t\tunsigned pt = (unsigned) pj_strtoul2(&a->value, NULL, 10);\n\t\tif (pt == c_pt) {\n\t\t    return (pjmedia_sdp_attr*)a;\n\t\t}\n\t    } else \n\t\treturn (pjmedia_sdp_attr*)a;\n\t}\n    }\n    return NULL;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find2(unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const char *c_name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    pj_str_t name;\n\n    name.ptr = (char*)c_name;\n    name.slen = pj_ansi_strlen(c_name);\n\n    return pjmedia_sdp_attr_find(count, attr_array, &name, c_fmt);\n}\n\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_add(unsigned *count,\n\t\t\t\t\t pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count < PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_array[*count] = attr;\n    (*count)++;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(unsigned) pjmedia_sdp_attr_remove_all(unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     const char *name)\n{\n    unsigned i, removed = 0;\n    pj_str_t attr_name;\n\n    PJ_ASSERT_RETURN(count && attr_array && name, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_name.ptr = (char*)name;\n    attr_name.slen = pj_ansi_strlen(name);\n\n    for (i=0; i<*count; ) {\n\tif (pj_strcmp(&attr_array[i]->name, &attr_name)==0) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}   \n    }\n\n    return removed;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_remove( unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     pjmedia_sdp_attr *attr )\n{\n    unsigned i, removed=0;\n\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    for (i=0; i<*count; ) {\n\tif (attr_array[i] == attr) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}\n    }\n\n    return removed ? PJ_SUCCESS : PJ_ENOTFOUND;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtpmap( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t\t pjmedia_sdp_rtpmap *rtpmap)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    char term = 0;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtpmap\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* Check if input is null terminated, and null terminate if\n     * necessary. Unfortunately this may crash the application if\n     * attribute was allocated from a read-only memory location.\n     * But this shouldn't happen as attribute's value normally is\n     * null terminated.\n     */\n    if (attr->value.ptr[attr->value.slen] != 0 &&\n\tattr->value.ptr[attr->value.slen] != '\\r' &&\n\tattr->value.ptr[attr->value.slen] != '\\n')\n    {\n\tpj_assert(!\"Shouldn't happen\");\n\tterm = attr->value.ptr[attr->value.slen];\n\tattr->value.ptr[attr->value.slen] = '\\0';\n    }\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */    \n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* rtpmap sample:\n     *\ta=rtpmap:98 L16/16000/2.\n     */\n\n    /* Init */\n    rtpmap->pt.slen = rtpmap->param.slen = rtpmap->enc_name.slen = 0;\n    rtpmap->clock_rate = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get payload type. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->pt);\n\n\n\t/* Get encoding name. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->enc_name);\n\n\t/* Expecting '/' after encoding name. */\n\tif (pj_scan_get_char(&scanner) != '/') {\n\t    status = PJMEDIA_SDP_EINRTPMAP;\n\t    goto on_return;\n\t}\n\n\n\t/* Get the clock rate. */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\trtpmap->clock_rate = pj_strtoul(&token);\n\n\t/* Expecting either '/' or EOF */\n\tif (*scanner.curptr == '/') {\n\t    /* Skip the '/' */\n\t    pj_scan_get_char(&scanner);\n\t    pj_scan_get(&scanner, &cs_token, &rtpmap->param);\n\t} else {\n\t    rtpmap->param.slen = 0;\n\t}\n\n\tstatus = PJ_SUCCESS;\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTPMAP;\n    }\n    PJ_END;\n\n\non_return:\n    pj_scan_fini(&scanner);\n    if (term) {\n\tattr->value.ptr[attr->value.slen] = term;\n    }\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_fmtp( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_fmtp *fmtp)\n{\n    const char *p = attr->value.ptr;\n    const char *end = attr->value.ptr + attr->value.slen;\n    pj_str_t token;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"fmtp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    /* fmtp BNF:\n     *\ta=fmtp:<format> <format specific parameter>\n     */\n\n    /* Get format. */\n    token.ptr = (char*)p;\n    while (pj_isdigit(*p) && p!=end)\n\t++p;\n    token.slen = p - token.ptr;\n    if (token.slen == 0)\n\treturn PJMEDIA_SDP_EINFMTP;\n\n    fmtp->fmt = token;\n\n    /* Expecting space after format. */\n    if (*p != ' ') return PJMEDIA_SDP_EINFMTP;\n\n    /* Get space. */\n    ++p;\n\n    /* Set the remaining string as fmtp format parameter. */\n    fmtp->fmt_param.ptr = (char*)p;\n    fmtp->fmt_param.slen = end - p;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtcp(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_rtcp_attr *rtcp)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtcp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* fmtp BNF:\n     *\ta=rtcp:<port> [nettype addrtype address]\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    rtcp->net_type.slen = rtcp->addr_type.slen = rtcp->addr.slen = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get the port */\n\tpj_scan_get(&scanner, &cs_token, &token);\n\trtcp->port = pj_strtoul(&token);\n\n\t/* Have address? */\n\tif (!pj_scan_is_eof(&scanner)) {\n\n\t    /* Get network type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->net_type);\n\n\t    /* Get address type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->addr_type);\n\n\t    /* Get the address */\n\t    //pj_scan_get(&scanner, &cs_token, &rtcp->addr);\n\t    pj_scan_get_until_chr(&scanner, \"/ \\t\\r\\n\", &rtcp->addr);\n\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTCP;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_rtcp(pj_pool_t *pool,\n\t\t\t\t\t\t       const pj_sockaddr *a)\n{\n    enum {\n\tATTR_LEN = PJ_INET6_ADDRSTRLEN+16\n    };\n    char tmp_addr[PJ_INET6_ADDRSTRLEN];\n    pjmedia_sdp_attr *attr;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"rtcp\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, ATTR_LEN);\n    if (a->addr.sa_family == pj_AF_INET()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP4 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n    } else if (a->addr.sa_family == pj_AF_INET6()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP6 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n\n    } else {\n\tpj_assert(!\"Unsupported address family\");\n\treturn NULL;\n    }\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_ssrc(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_ssrc_attr *ssrc)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"ssrc\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* ssrc BNF:\n     *  a=ssrc:<ssrc-id> <attribute>\n     *\ta=ssrc:<ssrc-id> <attribute>:<value>\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    pj_bzero(ssrc, sizeof(*ssrc));\n\n    /* Parse */\n    PJ_TRY {\n        pj_str_t scan_attr;\n\n\t/* Get the ssrc */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\tssrc->ssrc = pj_strtoul(&token);\n\n    \tpj_scan_get_char(&scanner);\n\tpj_scan_get(&scanner, &cs_token, &scan_attr);\n\t\n\t/* Get cname attribute, if any */\n\tif (!pj_scan_is_eof(&scanner) &&\n\t    pj_scan_get_char(&scanner) == ':' &&\n\t    pj_strcmp2(&scan_attr, \"cname\"))\n\t{\n\t    pj_scan_get(&scanner, &cs_token, &ssrc->cname);\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINSSRC;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_ssrc( pj_pool_t *pool,\n\t\t\t\t\t\t\tpj_uint32_t ssrc,\n\t\t\t\t\t\t\tconst pj_str_t *cname)\n{\n    pjmedia_sdp_attr *attr;\n\n    if (cname->slen == 0)\n        return NULL;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"ssrc\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, cname->slen+7 /* \" cname:\"*/\n    \t\t\t\t\t\t  + 10 /* 32-bit integer */\n    \t\t\t\t\t\t  + 1 /* NULL */);\n    attr->value.slen = pj_ansi_snprintf(attr->value.ptr, cname->slen+18,\n    \t\t\t\t\t\"%u cname:%.*s\", ssrc,\n\t\t\t   \t   \t(int)cname->slen, cname->ptr);\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_to_rtpmap(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_rtpmap **p_rtpmap)\n{\n    PJ_ASSERT_RETURN(pool && attr && p_rtpmap, PJ_EINVAL);\n\n    *p_rtpmap = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_rtpmap);\n    PJ_ASSERT_RETURN(*p_rtpmap, PJ_ENOMEM);\n\n    return pjmedia_sdp_attr_get_rtpmap(attr, *p_rtpmap);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_rtpmap_to_attr(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_rtpmap *rtpmap,\n\t\t\t\t\t       pjmedia_sdp_attr **p_attr)\n{\n    pjmedia_sdp_attr *attr;\n    char tempbuf[128];\n    int len;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && rtpmap && p_attr, PJ_EINVAL);\n\n    /* Check that mandatory attributes are specified. */\n    PJ_ASSERT_RETURN(rtpmap->enc_name.slen && rtpmap->clock_rate,\n\t\t     PJMEDIA_SDP_EINRTPMAP);\n\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    PJ_ASSERT_RETURN(attr != NULL, PJ_ENOMEM);\n\n    attr->name.ptr = \"rtpmap\";\n    attr->name.slen = 6;\n\n    /* Format: \":pt enc_name/clock_rate[/param]\" */\n    len = pj_ansi_snprintf(tempbuf, sizeof(tempbuf), \n\t\t\t   \"%.*s %.*s/%u%s%.*s\",\n\t\t\t   (int)rtpmap->pt.slen,\n\t\t\t   rtpmap->pt.ptr,\n\t\t\t   (int)rtpmap->enc_name.slen,\n\t\t\t   rtpmap->enc_name.ptr,\n\t\t\t   rtpmap->clock_rate,\n\t\t\t   (rtpmap->param.slen ? \"/\" : \"\"),\n\t\t\t   (int)rtpmap->param.slen,\n\t\t\t   rtpmap->param.ptr);\n\n    if (len < 1 || len >= (int)sizeof(tempbuf))\n\treturn PJMEDIA_SDP_ERTPMAPTOOLONG;\n\n    attr->value.slen = len;\n    attr->value.ptr = (char*) pj_pool_alloc(pool, attr->value.slen+1);\n    pj_memcpy(attr->value.ptr, tempbuf, attr->value.slen+1);\n\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic int print_connection_info( pjmedia_sdp_conn *c, char *buf, int len)\n{\n    int printed;\n\n    printed = pj_ansi_snprintf(buf, len, \"c=%.*s %.*s %.*s\\r\\n\",\n\t\t\t       (int)c->net_type.slen,\n\t\t\t       c->net_type.ptr,\n\t\t\t       (int)c->addr_type.slen,\n\t\t\t       c->addr_type.ptr,\n\t\t\t       (int)c->addr.slen,\n\t\t\t       c->addr.ptr);\n    if (printed < 1 || printed >= len)\n\treturn -1;\n\n    return printed;\n}\n\n\nPJ_DEF(pjmedia_sdp_conn*) pjmedia_sdp_conn_clone (pj_pool_t *pool, \n\t\t\t\t\t\t  const pjmedia_sdp_conn *rhs)\n{\n    pjmedia_sdp_conn *c = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_conn);\n    if (!c) return NULL;\n\n    if (!pj_strdup (pool, &c->net_type, &rhs->net_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr_type, &rhs->addr_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr, &rhs->addr)) return NULL;\n\n    return c;\n}\n\nPJ_DEF(pjmedia_sdp_bandw*)\npjmedia_sdp_bandw_clone (pj_pool_t *pool, \n\t\t\t const pjmedia_sdp_bandw *rhs)\n{\n    pjmedia_sdp_bandw *b = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_bandw);\n    if (!b) return NULL;\n\n    if (!pj_strdup (pool, &b->modifier, &rhs->modifier)) return NULL;\n    b->value = rhs->value;\n\n    return b;\n}\n\nstatic pj_ssize_t print_bandw(const pjmedia_sdp_bandw *bandw,\n\t\t\t      char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < bandw->modifier.slen + 10 + 5)\n\treturn -1;\n\n    *p++ = 'b';\n    *p++ = '=';\n    pj_memcpy(p, bandw->modifier.ptr, bandw->modifier.slen);\n    p += bandw->modifier.slen;\n    *p++ = ':';\n    p += pj_utoa(bandw->value, p);\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic pj_ssize_t print_attr(const pjmedia_sdp_attr *attr, \n\t\t\t     char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < attr->name.slen + attr->value.slen + 10)\n\treturn -1;\n\n    *p++ = 'a';\n    *p++ = '=';\n    pj_memcpy(p, attr->name.ptr, attr->name.slen);\n    p += attr->name.slen;\n    \n\n    if (attr->value.slen) {\n\t*p++ = ':';\n\tpj_memcpy(p, attr->value.ptr, attr->value.slen);\n\tp += attr->value.slen;\n    }\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\tif (end-p > m->desc.fmt[i].slen) {\n\t    *p++ = ' ';\n\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\t    p += m->desc.fmt[i].slen;\n\t} else {\n\t    return -1;\n\t}\n    }\n\n    if (end-p >= 2) {\n\t*p++ = '\\r';\n\t*p++ = '\\n';\n    } else {\n\treturn -1;\n    }\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\nPJ_DEF(int) pjmedia_sdp_media_print(const pjmedia_sdp_media *media,\n\t\t\t       char *buf, pj_size_t size)\n{\n\treturn print_media_desc(media, buf, size);\n}\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone(\n\t\t\t\t\t\t pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_media);\n    PJ_ASSERT_RETURN(m != NULL, NULL);\n\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    m->desc.port = rhs->desc.port;\n    m->desc.port_count = rhs->desc.port_count;\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    m->desc.fmt_count = rhs->desc.fmt_count;\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    } else {\n\tm->conn = NULL;\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    m->attr_count = rhs->attr_count;\n    for (i=0; i < rhs->attr_count; ++i) {\n\tm->attr[i] = pjmedia_sdp_attr_clone (pool, rhs->attr[i]);\n\tPJ_ASSERT_RETURN(m->attr[i] != NULL, NULL);\n    }\n\n    return m;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst pj_str_t *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find(m->attr_count, m->attr, name, fmt);\n}\n\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr2(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst char *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find2(m->attr_count, m->attr, name, fmt);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_add_attr( pjmedia_sdp_media *m,\n\t\t\t\t\t\tpjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_session_add_attr(pjmedia_sdp_session *s,\n\t\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&s->attr_count, s->attr, attr);\n}\n\nPJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,\n\t\t\t\t\t\t   const char *name)\n{\n    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_remove_attr(pjmedia_sdp_media *m,\n\t\t\t      \t\t\t  pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_remove(&m->attr_count, m->attr, attr);\n}\n\nstatic int print_session(const pjmedia_sdp_session *ses, \n\t\t\t char *buf, pj_ssize_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* Check length for v= and o= lines. */\n    if (len < 5+ \n\t      2+ses->origin.user.slen+18+\n\t      ses->origin.net_type.slen+ses->origin.addr.slen + 2)\n    {\n\treturn -1;\n    }\n\n    /* SDP version (v= line) */\n    pj_memcpy(p, \"v=0\\r\\n\", 5);\n    p += 5;\n\n    /* Owner (o=) line. */\n    *p++ = 'o';\n    *p++ = '=';\n    pj_memcpy(p, ses->origin.user.ptr, ses->origin.user.slen);\n    p += ses->origin.user.slen;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.id, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.version, p);\n    p += printed;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.net_type.ptr, ses->origin.net_type.slen);\n    p += ses->origin.net_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr_type.ptr, ses->origin.addr_type.slen);\n    p += ses->origin.addr_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr.ptr, ses->origin.addr.slen);\n    p += ses->origin.addr.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Session name (s=) line. */\n    if ((end-p)  < 8+ses->name.slen) {\n\treturn -1;\n    }\n    *p++ = 's';\n    *p++ = '=';\n    pj_memcpy(p, ses->name.ptr, ses->name.slen);\n    p += ses->name.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Connection line (c=) if exist. */\n    if (ses->conn) {\n\tprinted = print_connection_info(ses->conn, p, (int)(end-p));\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print optional bandwidth info. */\n    for (i=0; i<ses->bandw_count; ++i) {\n\tprinted = (int)print_bandw(ses->bandw[i], p, end-p);\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Time */\n    if ((end-p) < 24) {\n\treturn -1;\n    }\n    *p++ = 't';\n    *p++ = '=';\n    printed = pj_utoa(ses->time.start, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->time.stop, p);\n    p += printed;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Print all attribute (a=) lines. */\n    for (i=0; i<ses->attr_count; ++i) {\n\tprinted = (int)print_attr(ses->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Print media (m=) lines. */\n    for (i=0; i<ses->media_count; ++i) {\n\tprinted = print_media_desc(ses->media[i], p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\n/******************************************************************************\n * PARSERS\n */\n\nstatic void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* check version is 0 */\n    if (*(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* o= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* username. */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n\n    /* id */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* version */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n}\n\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* t= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* start time */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n\n    pj_scan_get_char(scanner);\n\n    /* stop time */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* get anything until newline (including whitespaces). */\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n\n    /* newline. */\n    pj_scan_get_newline(scanner);\n}\n\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINCONN;\n\n    /* c= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address. */\n    pj_scan_get_until_chr(scanner, \"/ \\t\\r\\n\", &conn->addr);\n    PJ_TODO(PARSE_SDP_CONN_ADDRESS_SUBFIELDS);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINBANDW;\n\n    /* b= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* modifier */\n    pj_scan_get_until_ch(scanner, ':', &bandw->modifier);\n    pj_scan_get_char(scanner);\n\n    /* value */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    bandw->value = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n\n    /* check the equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* m= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* type */\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n\n    /* port */\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (*scanner->curptr == '/') {\n\t/* port count */\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n\n    } else {\n\tmed->desc.port_count = 0;\n    }\n\n    if (pj_scan_get_char(scanner) != ' ') {\n\tPJ_THROW(SYNTAX_ERROR);\n    }\n\n    /* transport */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n\n    /* format list */\n    med->desc.fmt_count = 0;\n    while (*scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\n\tpj_scan_get_char(scanner);\n\n\t/* Check again for the end of the line */\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void on_scanner_error(pj_scanner *scanner)\n{\n    PJ_UNUSED_ARG(scanner);\n\n    PJ_THROW(SYNTAX_ERROR);\n}\n\nstatic pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    /* check equal sign */\n    if (*(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n\n    /* skip a= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    \n    /* get attr name. */\n    pj_scan_get(scanner, &cs_token, &attr->name);\n\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\t/* skip ':' if present. */\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\n\t/* get value */\n\tif (*scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n    return attr;\n}\n\n\n/*\n * Apply direction attribute in session to all media.\n */\nstatic void apply_media_direction(pjmedia_sdp_session *sdp)\n{\n    pjmedia_sdp_attr *dir_attr = NULL;\n    unsigned i;\n\n    const pj_str_t inactive = { \"inactive\", 8 };\n    const pj_str_t sendonly = { \"sendonly\", 8 };\n    const pj_str_t recvonly = { \"recvonly\", 8 };\n    const pj_str_t sendrecv = { \"sendrecv\", 8 };\n\n    /* Find direction attribute in session, don't need to find default \n     * direction \"sendrecv\".\n     */\n    for (i = 0; i < sdp->attr_count && !dir_attr; ++i) {\n\tif (!pj_strcmp(&sdp->attr[i]->name, &sendonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &recvonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &inactive)) \n\t{\n\t    dir_attr = sdp->attr[i];\n\t}\n    }\n\n    /* Found the direction attribute */\n    if (dir_attr) {\n\t/* Remove the direction attribute in session */\n\tpjmedia_sdp_attr_remove(&sdp->attr_count, sdp->attr, dir_attr);\n\n\t/* Apply the direction attribute to all media, but not overriding it\n\t * if media already has direction attribute.\n\t */\n\tfor (i = 0; i < sdp->media_count; ++i) {\n\t    pjmedia_sdp_media *m;\n\t    unsigned j;\n\n\t    /* Find direction attribute in this media */\n\t    m = sdp->media[i];\n\t    for (j = 0; j < m->attr_count; ++j) {\n\t\tif (!pj_strcmp(&m->attr[j]->name, &sendrecv) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &sendonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &recvonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &inactive)) \n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* Not found, apply direction attribute from session */\n\t    if (j == m->attr_count)\n\t\tpjmedia_sdp_media_add_attr(m, dir_attr);\n\t}\n    }\n}\n\n\n/*\n * Parse SDP message.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_parse( pj_pool_t *pool,\n\t\t\t\t       char *buf, pj_size_t len, \n\t\t\t\t       pjmedia_sdp_session **p_sdp)\n{\n    pj_scanner scanner;\n    pjmedia_sdp_session *session;\n    pjmedia_sdp_media *media = NULL;\n    pjmedia_sdp_attr *attr;\n    pjmedia_sdp_conn *conn;\n    pjmedia_sdp_bandw *bandw;\n    pj_str_t dummy;\n    int cur_name = 254;\n    volatile parse_context ctx;\n    PJ_USE_EXCEPTION;\n\n    ctx.last_error = PJ_SUCCESS;\n\n    init_sdp_parser();\n\n    pj_scan_init(&scanner, buf, len, 0, &on_scanner_error);\n    session = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(session != NULL, PJ_ENOMEM);\n\n    /* Ignore leading newlines */\n    while (*scanner.curptr=='\\r' || *scanner.curptr=='\\n')\n\tpj_scan_get_char(&scanner);\n\n    PJ_TRY {\n\twhile (!pj_scan_is_eof(&scanner)) {\n\t\tcur_name = *scanner.curptr;\n\t\tswitch (cur_name) {\n\t\tcase 'a':\n\t\t    attr = parse_attr(pool, &scanner, &ctx);\n\t\t    if (attr) {\n\t\t\tif (media) {\n\t\t\t    if (media->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_media_add_attr(media, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding media attribute, \"\n\t\t\t\t\t      \"attribute is ignored\"));\n\t\t\t} else {\n\t\t\t    if (session->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_session_add_attr(session, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding session attribute\"\n\t\t\t\t\t      \", attribute is ignored\"));\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 'o':\n\t\t    parse_origin(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 's':\n\t\t    parse_generic_line(&scanner, &session->name, &ctx);\n\t\t    break;\n\t\tcase 'c':\n\t\t    conn = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_conn);\n\t\t    parse_connection_info(&scanner, conn, &ctx);\n\t\t    if (media) {\n\t\t\tmedia->conn = conn;\n\t\t    } else {\n\t\t\tsession->conn = conn;\n\t\t    }\n\t\t    break;\n\t\tcase 't':\n\t\t    parse_time(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 'm':\n\t\t    media = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n\t\t    parse_media(&scanner, media, &ctx);\n\t\t    if (session->media_count < PJMEDIA_MAX_SDP_MEDIA)\n\t\t\tsession->media[ session->media_count++ ] = media;\n\t\t    else\n\t\t\tPJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t     \"Error adding media, media is ignored\"));\n\t\t    break;\n\t\tcase 'v':\n\t\t    parse_version(&scanner, &ctx);\n\t\t    break;\n\t\tcase 13:\n\t\tcase 10:\n\t\t    pj_scan_get_char(&scanner);\n\t\t    /* Allow empty newlines at the end of the message */\n\t\t    while (!pj_scan_is_eof(&scanner)) {\n\t\t\tif (*scanner.curptr != 13 && *scanner.curptr != 10) {\n\t\t\t    ctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\t    on_scanner_error(&scanner);\n\t\t\t}\n\t\t\tpj_scan_get_char(&scanner);\n\t\t    }\n\t\t    break;\n\t\tcase 'b':\n\t\t    bandw = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_bandw);\n\t\t    parse_bandwidth_info(&scanner, bandw, &ctx);\n\t\t    if (media) {\n\t\t\tif (media->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    media->bandw[media->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding media bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    } else {\n\t\t\tif (session->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    session->bandw[session->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding session bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    if (cur_name >= 'a' && cur_name <= 'z')\n\t\t\tparse_generic_line(&scanner, &dummy, &ctx);\n\t\t    else  {\n\t\t\tctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\ton_scanner_error(&scanner);\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\tctx.last_error = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\t\t\n\tPJ_PERROR(4, (THIS_FILE, ctx.last_error,\n\t\t      \"Error parsing SDP in line %d col %d\",\n\t\t      scanner.line, pj_scan_get_col(&scanner)));\n\n\tsession = NULL;\n\n\tpj_assert(ctx.last_error != PJ_SUCCESS);\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n\n    if (session)\n\tapply_media_direction(session);\n\n    *p_sdp = session;\n    return ctx.last_error;\n}\n\n/*\n * Print SDP description.\n */\nPJ_DEF(int) pjmedia_sdp_print( const pjmedia_sdp_session *desc, \n\t\t\t       char *buf, pj_size_t size)\n{\n    return print_session(desc, buf, size);\n}\n\n\n/*\n * Clone session\n */\nPJ_DEF(pjmedia_sdp_session*) pjmedia_sdp_session_clone( pj_pool_t *pool,\n\t\t\t   \t\t\tconst pjmedia_sdp_session *rhs)\n{\n    pjmedia_sdp_session *sess;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    sess = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(sess != NULL, NULL);\n\n    /* Clone origin line. */\n    pj_strdup(pool, &sess->origin.user, &rhs->origin.user);\n    sess->origin.id = rhs->origin.id;\n    sess->origin.version = rhs->origin.version;\n    pj_strdup(pool, &sess->origin.net_type, &rhs->origin.net_type);\n    pj_strdup(pool, &sess->origin.addr_type, &rhs->origin.addr_type);\n    pj_strdup(pool, &sess->origin.addr, &rhs->origin.addr);\n\n    /* Clone subject line. */\n    pj_strdup(pool, &sess->name, &rhs->name);\n\n    /* Clone connection line */\n    if (rhs->conn) {\n\tsess->conn = pjmedia_sdp_conn_clone(pool, rhs->conn);\n\tPJ_ASSERT_RETURN(sess->conn != NULL, NULL);\n    }\n\n    /* Duplicate bandwidth info */\n    sess->bandw_count = rhs->bandw_count;\n    for (i=0; i<rhs->bandw_count; ++i) {\n\tsess->bandw[i] = pjmedia_sdp_bandw_clone(pool, rhs->bandw[i]);\n    }\n\n    /* Clone time line. */\n    sess->time.start = rhs->time.start;\n    sess->time.stop = rhs->time.stop;\n\n    /* Duplicate session attributes. */\n    sess->attr_count = rhs->attr_count;\n    for (i=0; i<rhs->attr_count; ++i) {\n\tsess->attr[i] = pjmedia_sdp_attr_clone(pool, rhs->attr[i]);\n    }\n\n    /* Duplicate media descriptors. */\n    sess->media_count = rhs->media_count;\n    for (i=0; i<rhs->media_count; ++i) {\n\tsess->media[i] = pjmedia_sdp_media_clone(pool, rhs->media[i]);\n    }\n\n    return sess;\n}\n\n\n#define CHECK(exp,ret)\tdo {\t\t\t\\\n\t\t\t    /*pj_assert(exp);*/\t\\\n\t\t\t    if (!(exp))\t\t\\\n\t\t\t\treturn ret;\t\\\n\t\t\t} while (0)\n\n/* Validate SDP connetion info. */\nstatic pj_status_t validate_sdp_conn(const pjmedia_sdp_conn *c)\n{\n    CHECK( c, PJ_EINVAL);\n    CHECK( pj_strcmp2(&c->net_type, \"IN\")==0, PJMEDIA_SDP_EINCONN);\n    CHECK( pj_strcmp2(&c->addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&c->addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINCONN);\n    CHECK( c->addr.slen != 0, PJMEDIA_SDP_EINCONN);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate(const pjmedia_sdp_session *sdp)\n{\n    return pjmedia_sdp_validate2(sdp, PJ_TRUE);\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate2(const pjmedia_sdp_session *sdp,\n\t\t\t\t\t  pj_bool_t strict)\n{\n    unsigned i;\n    const pj_str_t STR_RTPMAP = { \"rtpmap\", 6 };\n\n    CHECK( sdp != NULL, PJ_EINVAL);\n\n    /* Validate origin line. */\n    CHECK( sdp->origin.user.slen != 0, PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.net_type, \"IN\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&sdp->origin.addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( sdp->origin.addr.slen != 0, PJMEDIA_SDP_EINORIGIN);\n\n    /* Validate subject line. */\n    CHECK( sdp->name.slen != 0, PJMEDIA_SDP_EINNAME);\n\n    /* Ignore start and stop time. */\n\n    /* If session level connection info is present, validate it. */\n    if (sdp->conn) {\n\tpj_status_t status = validate_sdp_conn(sdp->conn);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Validate each media. */\n    for (i=0; i<sdp->media_count; ++i) {\n\tconst pjmedia_sdp_media *m = sdp->media[i];\n\tunsigned j;\n\n\t/* Validate the m= line. */\n\tCHECK( m->desc.media.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.transport.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.fmt_count != 0 || m->desc.port==0, PJMEDIA_SDP_ENOFMT);\n\n\t/* If media level connection info is present, validate it. */\n\tif (m->conn) {\n\t    pj_status_t status = validate_sdp_conn(m->conn);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\t}\n\n\t/* If media doesn't have connection info, then connection info\n\t * must be present in the session.\n\t */\n\tif (m->conn == NULL) {\n\t    if (sdp->conn == NULL)\n\t\tif (strict || m->desc.port != 0)\n\t\t    return PJMEDIA_SDP_EMISSINGCONN;\n\t}\n\n\t/* Verify payload type. */\n\tfor (j=0; j<m->desc.fmt_count; ++j) {\n\n\t    /* Arrgh noo!! Payload type can be non-numeric!!\n\t     * RTC based programs sends \"null\" for instant messaging!\n\t     */\n\t    if (pj_isdigit(*m->desc.fmt[j].ptr)) {\n\t\tunsigned long pt;\n\t\tpj_status_t status = pj_strtoul3(&m->desc.fmt[j], &pt, 10);\n\n\t\t/* Payload type is between 0 and 127. \n\t\t */\n\t\tCHECK( status == PJ_SUCCESS && pt <= 127, PJMEDIA_SDP_EINPT);\n\n\t\t/* If port is not zero, then for each dynamic payload type, an\n\t\t * rtpmap attribute must be specified.\n\t\t */\n\t\tif (m->desc.port != 0 && pt >= 96) {\n\t\t    const pjmedia_sdp_attr *a;\n\n\t\t    a = pjmedia_sdp_media_find_attr(m, &STR_RTPMAP, \n\t\t\t\t\t\t    &m->desc.fmt[j]);\n\t\t    CHECK( a != NULL, PJMEDIA_SDP_EMISSINGRTPMAP);\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Looks good. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_transport_cmp( const pj_str_t *t1,\n\t\t\t\t\t       const pj_str_t *t2)\n{\n    pj_uint32_t t1_proto, t2_proto;\n\n    /* Exactly equal? */\n    if (pj_stricmp(t1, t2) == 0)\n\treturn PJ_SUCCESS;\n\n    /* Check if boths are RTP/AVP based */\n    t1_proto = pjmedia_sdp_transport_get_proto(t1);\n    t2_proto = pjmedia_sdp_transport_get_proto(t2);\n    if (PJMEDIA_TP_PROTO_HAS_FLAG(t1_proto, PJMEDIA_TP_PROTO_RTP_AVP) && \n\tPJMEDIA_TP_PROTO_HAS_FLAG(t2_proto, PJMEDIA_TP_PROTO_RTP_AVP))\n    {\n\treturn PJ_SUCCESS;\n    }\n\n    /* Compatible? */\n    //{\n    //\tstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\n    //\tstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n    //\tif ((!pj_stricmp(t1, &ID_RTP_AVP) || !pj_stricmp(t1, &ID_RTP_SAVP)) &&\n    //      (!pj_stricmp(t2, &ID_RTP_AVP) || !pj_stricmp(t2, &ID_RTP_SAVP)))\n    //\t    return PJ_SUCCESS;\n    //}\n\n    return PJMEDIA_SDP_ETPORTNOTEQUAL;\n}\n\n\n/*\n * Get media transport info, e.g: protocol and profile.\n */\nPJ_DEF(pj_uint32_t) pjmedia_sdp_transport_get_proto(const pj_str_t *tp)\n{\n    pj_str_t token, rest = {0};\n    pj_ssize_t idx;\n\n    PJ_ASSERT_RETURN(tp, PJMEDIA_TP_PROTO_NONE);\n\n    idx = pj_strtok2(tp, \"/\", &token, 0);\n    if (idx != tp->slen)\n\tpj_strset(&rest, tp->ptr + token.slen + 1, tp->slen - token.slen - 1);\n\n    if (pj_stricmp2(&token, \"RTP\") == 0) {\n\t/* Starts with \"RTP\" */\n\n\t/* RTP/AVP */\n\tif (pj_stricmp2(&rest, \"AVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVP;\n\n\t/* RTP/SAVP */\n\tif (pj_stricmp2(&rest, \"SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVP;\n\n\t/* RTP/AVPF */\n\tif (pj_stricmp2(&rest, \"AVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVPF;\n\n\t/* RTP/SAVPF */\n\tif (pj_stricmp2(&rest, \"SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVPF;\n\n    } else if (pj_stricmp2(&token, \"UDP\") == 0) {\n\t/* Starts with \"UDP\" */\n\n\t/* Plain UDP */\n\tif (rest.slen == 0)\n\t    return PJMEDIA_TP_PROTO_UDP;\n\n\t/* DTLS-SRTP */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTP;\n\n\t/* DTLS-SRTP with RTCP-FB */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTPF;\n    }\n\n    /* Unknown transport */\n    return PJMEDIA_TP_PROTO_UNKNOWN;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_deactivate(pj_pool_t *pool,\n\t\t\t\t\t\t pjmedia_sdp_media *m)\n{\n    PJ_ASSERT_RETURN(m, PJ_EINVAL);\n    PJ_UNUSED_ARG(pool);\n\n    /* Set port to zero */\n    m->desc.port = 0;\n\n    /* And remove attributes */\n    m->attr_count = 0;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone_deactivate(\n\t\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\t\tconst pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    m = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n    pj_memcpy(m, rhs, sizeof(*m));\n\n    /* Clone the media line only */\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    /* And deactivate it */\n    pjmedia_sdp_media_deactivate(pool, m);\n\n    return m;\n}\n"], "fixing_code": ["/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjlib-util/scanner.h>\n#include <pj/ctype.h>\n#include <pj/string.h>\n#include <pj/except.h>\n#include <pj/os.h>\n#include <pj/log.h>\n#include <pj/errno.h>\n#include <pj/assert.h>\n\n#define THIS_FILE   \"scanner.c\"\n\n#define PJ_SCAN_IS_SPACE(c)\t\t((c)==' ' || (c)=='\\t')\n#define PJ_SCAN_IS_NEWLINE(c)\t\t((c)=='\\r' || (c)=='\\n')\n#define PJ_SCAN_IS_PROBABLY_SPACE(c)\t((c) <= 32)\n#define PJ_SCAN_CHECK_EOF(s)\t\t(s != scanner->end)\n\n\n#if defined(PJ_SCANNER_USE_BITWISE) && PJ_SCANNER_USE_BITWISE != 0\n#  include \"scanner_cis_bitwise.c\"\n#else\n#  include \"scanner_cis_uint.c\"\n#endif\n\n\nstatic void pj_scan_syntax_err(pj_scanner *scanner)\n{\n    (*scanner->callback)(scanner);\n}\n\n\nPJ_DEF(void) pj_cis_add_range(pj_cis_t *cis, int cstart, int cend)\n{\n    /* Can not set zero. This is the requirement of the parser. */\n    pj_assert(cstart > 0);\n\n    while (cstart != cend) {\n        PJ_CIS_SET(cis, cstart);\n\t++cstart;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_alpha(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, 'a', 'z'+1);\n    pj_cis_add_range( cis, 'A', 'Z'+1);\n}\n\nPJ_DEF(void) pj_cis_add_num(pj_cis_t *cis)\n{\n    pj_cis_add_range( cis, '0', '9'+1);\n}\n\nPJ_DEF(void) pj_cis_add_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_SET(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_add_cis( pj_cis_t *cis, const pj_cis_t *rhs)\n{\n    int i;\n    for (i=0; i<256; ++i) {\n\tif (PJ_CIS_ISSET(rhs, i))\n\t    PJ_CIS_SET(cis, i);\n    }\n}\n\nPJ_DEF(void) pj_cis_del_range( pj_cis_t *cis, int cstart, int cend)\n{\n    while (cstart != cend) {\n        PJ_CIS_CLR(cis, cstart);\n        cstart++;\n    }\n}\n\nPJ_DEF(void) pj_cis_del_str( pj_cis_t *cis, const char *str)\n{\n    while (*str) {\n        PJ_CIS_CLR(cis, *str);\n\t++str;\n    }\n}\n\nPJ_DEF(void) pj_cis_invert( pj_cis_t *cis )\n{\n    unsigned i;\n    /* Can not set zero. This is the requirement of the parser. */\n    for (i=1; i<256; ++i) {\n\tif (PJ_CIS_ISSET(cis,i))\n            PJ_CIS_CLR(cis,i);\n        else\n            PJ_CIS_SET(cis,i);\n    }\n}\n\nPJ_DEF(void) pj_scan_init( pj_scanner *scanner, char *bufstart, \n\t\t\t   pj_size_t buflen, unsigned options, \n\t\t\t   pj_syn_err_func_ptr callback )\n{\n    PJ_CHECK_STACK();\n\n    scanner->begin = scanner->curptr = bufstart;\n    scanner->end = bufstart + buflen;\n    scanner->line = 1;\n    scanner->start_line = scanner->begin;\n    scanner->callback = callback;\n    scanner->skip_ws = options;\n\n    if (scanner->skip_ws) \n\tpj_scan_skip_whitespace(scanner);\n}\n\n\nPJ_DEF(void) pj_scan_fini( pj_scanner *scanner )\n{\n    PJ_CHECK_STACK();\n    PJ_UNUSED_ARG(scanner);\n}\n\nPJ_DEF(void) pj_scan_skip_whitespace( pj_scanner *scanner )\n{\n    register char *s = scanner->curptr;\n\n    while (PJ_SCAN_IS_SPACE(*s)) {\n\t++s;\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_NEWLINE)) {\n\tfor (;;) {\n\t    if (*s == '\\r') {\n\t\t++s;\n\t\tif (*s == '\\n') ++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (*s == '\\n') {\n\t\t++s;\n\t\t++scanner->line;\n\t\tscanner->curptr = scanner->start_line = s;\n\t    } else if (PJ_SCAN_IS_SPACE(*s)) {\n\t\tdo {\n\t\t    ++s;\n\t\t} while (PJ_SCAN_IS_SPACE(*s));\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    if (PJ_SCAN_IS_NEWLINE(*s) && (scanner->skip_ws & PJ_SCAN_AUTOSKIP_WS_HEADER)==PJ_SCAN_AUTOSKIP_WS_HEADER) {\n\t/* Check for header continuation. */\n\tscanner->curptr = s;\n\n\tif (*s == '\\r') {\n\t    ++s;\n\t}\n\tif (*s == '\\n') {\n\t    ++s;\n\t}\n\tscanner->start_line = s;\n\n\tif (PJ_SCAN_IS_SPACE(*s)) {\n\t    register char *t = s;\n\t    do {\n\t\t++t;\n\t    } while (PJ_SCAN_IS_SPACE(*t));\n\n\t    ++scanner->line;\n\t    scanner->curptr = t;\n\t}\n    } else {\n\tscanner->curptr = s;\n    }\n}\n\nPJ_DEF(void) pj_scan_skip_line( pj_scanner *scanner )\n{\n    char *s;\n\n    if (pj_scan_is_eof(scanner)) {\n        return;\n    }\n\n    s = pj_memchr(scanner->curptr, '\\n', scanner->end - scanner->curptr);\n    if (!s) {\n\tscanner->curptr = scanner->end;\n    } else {\n\tscanner->curptr = scanner->start_line = s+1;\n\tscanner->line++;\n   }\n}\n\nPJ_DEF(int) pj_scan_peek( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    /* Don't need to check EOF with PJ_SCAN_CHECK_EOF(s) */\n    while (pj_cis_match(spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(int) pj_scan_peek_n( pj_scanner *scanner,\n\t\t\t     pj_size_t len, pj_str_t *out)\n{\n    char *endpos = scanner->curptr + len;\n\n    if (endpos > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    pj_strset(out, scanner->curptr, len);\n    return *endpos;\n}\n\n\nPJ_DEF(int) pj_scan_peek_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, \n\t\t\t\tpj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match( spec, *s))\n\t++s;\n\n    pj_strset3(out, scanner->curptr, s);\n    return *s;\n}\n\n\nPJ_DEF(void) pj_scan_get( pj_scanner *scanner,\n\t\t\t  const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    if (pj_scan_is_eof(scanner) || !pj_cis_match(spec, *s)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    do {\n\t++s;\n    } while (pj_cis_match(spec, *s));\n    /* No need to check EOF here (PJ_SCAN_CHECK_EOF(s)) because\n     * buffer is NULL terminated and pj_cis_match(spec,0) should be\n     * false.\n     */\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_unescape( pj_scanner *scanner,\n\t\t\t\t   const pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    char *dst = s;\n\n    pj_assert(pj_cis_match(spec,0)==0);\n\n    /* Must not match character '%' */\n    pj_assert(pj_cis_match(spec,'%')==0);\n\n    if (pj_scan_is_eof(scanner) || !pj_cis_match(spec, *s) && *s != '%') {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    out->ptr = s;\n    do {\n\tif (*s == '%') {\n\t    if (s+3 <= scanner->end && pj_isxdigit(*(s+1)) && \n\t\tpj_isxdigit(*(s+2))) \n\t    {\n\t\t*dst = (pj_uint8_t) ((pj_hex_digit_to_val(*(s+1)) << 4) +\n\t\t\t\t      pj_hex_digit_to_val(*(s+2)));\n\t\t++dst;\n\t\ts += 3;\n\t    } else {\n\t\t*dst++ = *s++;\n\t\t*dst++ = *s++;\n\t\tbreak;\n\t    }\n\t}\n\t\n\tif (pj_cis_match(spec, *s)) {\n\t    char *start = s;\n\t    do {\n\t\t++s;\n\t    } while (pj_cis_match(spec, *s));\n\n\t    if (dst != start) pj_memmove(dst, start, s-start);\n\t    dst += (s-start);\n\t} \n\t\n    } while (*s == '%');\n\n    scanner->curptr = s;\n    out->slen = (dst - out->ptr);\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);    \n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_quote( pj_scanner *scanner,\n\t\t\t\tint begin_quote, int end_quote, \n\t\t\t\tpj_str_t *out)\n{\n    char beg = (char)begin_quote;\n    char end = (char)end_quote;\n    pj_scan_get_quotes(scanner, &beg, &end, 1, out);\n}\n\nPJ_DEF(void) pj_scan_get_quotes(pj_scanner *scanner,\n                                const char *begin_quote, const char *end_quote,\n                                int qsize, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    int qpair = -1;\n    int i;\n\n    pj_assert(qsize > 0);\n\n    /* Check and eat the begin_quote. */\n    for (i = 0; i < qsize; ++i) {\n\tif (*s == begin_quote[i]) {\n\t    qpair = i;\n\t    break;\n\t}\n    }\n    if (qpair == -1) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    /* Loop until end_quote is found. \n     */\n    do {\n\t/* loop until end_quote is found. */\n\twhile (PJ_SCAN_CHECK_EOF(s) && *s != '\\n' && *s != end_quote[qpair]) {\n\t    ++s;\n\t}\n\n\t/* check that no backslash character precedes the end_quote. */\n\tif (*s == end_quote[qpair]) {\n\t    if (*(s-1) == '\\\\') {\n\t\tchar *q = s-2;\n\t\tchar *r = s-2;\n\n\t\twhile (r != scanner->begin && *r == '\\\\') {\n\t\t    --r;\n\t\t}\n\t\t/* break from main loop if we have odd number of backslashes */\n\t\tif (((unsigned)(q-r) & 0x01) == 1) {\n\t\t    break;\n\t\t}\n\t\t++s;\n\t    } else {\n\t\t/* end_quote is not preceeded by backslash. break now. */\n\t\tbreak;\n\t    }\n\t} else {\n\t    /* loop ended by non-end_quote character. break now. */\n\t    break;\n\t}\n    } while (1);\n\n    /* Check and eat the end quote. */\n    if (*s != end_quote[qpair]) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n    ++s;\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (PJ_SCAN_IS_PROBABLY_SPACE(*s) && scanner->skip_ws) {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_n( pj_scanner *scanner,\n\t\t\t    unsigned N, pj_str_t *out)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    pj_strset(out, scanner->curptr, N);\n    \n    scanner->curptr += N;\n\n    if (!pj_scan_is_eof(scanner) &&\n\tPJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_get_char( pj_scanner *scanner )\n{\n    register char *s = scanner->curptr;\n    int chr;\n\n    if (s >= scanner->end || !*s) {\n\tpj_scan_syntax_err(scanner);\n\treturn 0;\n    }\n\n    chr = *s;\n\n    ++s;\n    scanner->curptr = s;\n    if (PJ_SCAN_CHECK_EOF(s) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n    \tscanner->skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n    return chr;\n}\n\n\nPJ_DEF(void) pj_scan_get_newline( pj_scanner *scanner )\n{\n    if (pj_scan_is_eof(scanner) || !PJ_SCAN_IS_NEWLINE(*scanner->curptr)) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    /* We have checked scanner->curptr validity above */\n    if (*scanner->curptr == '\\r') {\n\t++scanner->curptr;\n    }\n    if (!pj_scan_is_eof(scanner) && *scanner->curptr == '\\n') {\n\t++scanner->curptr;\n    }\n\n    ++scanner->line;\n    scanner->start_line = scanner->curptr;\n\n    /**\n     * This probably is a bug, see PROTOS test #2480.\n     * This would cause scanner to incorrectly eat two new lines, e.g.\n     * when parsing:\n     *   \n     *\tContent-Length: 120\\r\\n\n     *\t\\r\\n\n     *\t<space><space><space>...\n     *\n     * When pj_scan_get_newline() is called to parse the first newline\n     * in the Content-Length header, it will eat the second newline\n     * too because it thinks that it's a header continuation.\n     *\n     * if (PJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && scanner->skip_ws) {\n     *    pj_scan_skip_whitespace(scanner);\n     * }\n     */\n}\n\n\nPJ_DEF(void) pj_scan_get_until( pj_scanner *scanner,\n\t\t\t\tconst pj_cis_t *spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && !pj_cis_match(spec, *s)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (!pj_scan_is_eof(scanner) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n\tscanner->skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_ch( pj_scanner *scanner, \n\t\t\t\t   int until_char, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    while (PJ_SCAN_CHECK_EOF(s) && *s != until_char) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (!pj_scan_is_eof(scanner) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n\tscanner->skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(void) pj_scan_get_until_chr( pj_scanner *scanner,\n\t\t\t\t     const char *until_spec, pj_str_t *out)\n{\n    register char *s = scanner->curptr;\n    pj_size_t speclen;\n\n    if (s >= scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    speclen = strlen(until_spec);\n    while (PJ_SCAN_CHECK_EOF(s) && !memchr(until_spec, *s, speclen)) {\n\t++s;\n    }\n\n    pj_strset3(out, scanner->curptr, s);\n\n    scanner->curptr = s;\n\n    if (!pj_scan_is_eof(scanner) && PJ_SCAN_IS_PROBABLY_SPACE(*s) &&\n\tscanner->skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\nPJ_DEF(void) pj_scan_advance_n( pj_scanner *scanner,\n\t\t\t\t unsigned N, pj_bool_t skip_ws)\n{\n    if (scanner->curptr + N > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn;\n    }\n\n    scanner->curptr += N;\n\n    if (!pj_scan_is_eof(scanner) && \n\tPJ_SCAN_IS_PROBABLY_SPACE(*scanner->curptr) && skip_ws)\n    {\n\tpj_scan_skip_whitespace(scanner);\n    }\n}\n\n\nPJ_DEF(int) pj_scan_strcmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strncmp(scanner->curptr, s, len);\n}\n\n\nPJ_DEF(int) pj_scan_stricmp( pj_scanner *scanner, const char *s, int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return pj_ansi_strnicmp(scanner->curptr, s, len);\n}\n\nPJ_DEF(int) pj_scan_stricmp_alnum( pj_scanner *scanner, const char *s, \n\t\t\t\t   int len)\n{\n    if (scanner->curptr + len > scanner->end) {\n\tpj_scan_syntax_err(scanner);\n\treturn -1;\n    }\n    return strnicmp_alnum(scanner->curptr, s, len);\n}\n\nPJ_DEF(void) pj_scan_save_state( const pj_scanner *scanner, \n\t\t\t\t pj_scan_state *state)\n{\n    state->curptr = scanner->curptr;\n    state->line = scanner->line;\n    state->start_line = scanner->start_line;\n}\n\n\nPJ_DEF(void) pj_scan_restore_state( pj_scanner *scanner, \n\t\t\t\t    pj_scan_state *state)\n{\n    scanner->curptr = state->curptr;\n    scanner->line = state->line;\n    scanner->start_line = state->start_line;\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/rtp.h>\n#include <pjmedia/errno.h>\n#include <pj/log.h>\n#include <pj/sock.h>\t/* pj_htonx, pj_htonx */\n#include <pj/assert.h>\n#include <pj/rand.h>\n#include <pj/string.h>\n\n\n#define THIS_FILE   \"rtp.c\"\n\n#define RTP_VERSION\t2\n\n#define RTP_SEQ_MOD\t(1 << 16)\n#define MAX_DROPOUT \t((pj_int16_t)3000)\n#define MAX_MISORDER \t((pj_int16_t)100)\n#define MIN_SEQUENTIAL  ((pj_int16_t)2)\n\nstatic void pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *seq_ctrl, \n\t\t\t\t    pj_uint16_t seq);\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init( pjmedia_rtp_session *ses,\n\t\t\t\t\t      int default_pt, \n\t\t\t\t\t      pj_uint32_t sender_ssrc )\n{\n    PJ_LOG(5, (THIS_FILE, \n\t       \"pjmedia_rtp_session_init: ses=%p, default_pt=%d, ssrc=0x%x\",\n\t       ses, default_pt, sender_ssrc));\n\n    /* Check RTP header packing. */\n    if (sizeof(struct pjmedia_rtp_hdr) != 12) {\n\tpj_assert(!\"Wrong RTP header packing!\");\n\treturn PJMEDIA_RTP_EINPACK;\n    }\n\n    /* If sender_ssrc is not specified, create from random value. */\n    if (sender_ssrc == 0 || sender_ssrc == (pj_uint32_t)-1) {\n\tsender_ssrc = pj_htonl(pj_rand());\n    } else {\n\tsender_ssrc = pj_htonl(sender_ssrc);\n    }\n\n    /* Initialize session. */\n    pj_bzero(ses, sizeof(*ses));\n\n    /* Initial sequence number SHOULD be random, according to RFC 3550. */\n    /* According to RFC 3711, it should be random within 2^15 bit */\n    ses->out_extseq = pj_rand() & 0x7FFF;\n    ses->peer_ssrc = 0;\n    \n    /* Build default header for outgoing RTP packet. */\n    ses->out_hdr.v = RTP_VERSION;\n    ses->out_hdr.p = 0;\n    ses->out_hdr.x = 0;\n    ses->out_hdr.cc = 0;\n    ses->out_hdr.m = 0;\n    ses->out_hdr.pt = (pj_uint8_t) default_pt;\n    ses->out_hdr.seq = (pj_uint16_t) pj_htons( (pj_uint16_t)ses->out_extseq );\n    ses->out_hdr.ts = 0;\n    ses->out_hdr.ssrc = sender_ssrc;\n\n    /* Keep some arguments as session defaults. */\n    ses->out_pt = (pj_uint16_t) default_pt;\n\n    return PJ_SUCCESS;\n}\n\nPJ_DEF(pj_status_t) pjmedia_rtp_session_init2( \n\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t    pjmedia_rtp_session_setting settings)\n{\n    pj_status_t status;\n    int\t\t pt = 0;\n    pj_uint32_t\t sender_ssrc = 0;\n\n    if (settings.flags & 1)\n\tpt = settings.default_pt;\n    if (settings.flags & 2)\n\tsender_ssrc = settings.sender_ssrc;\n\n    status = pjmedia_rtp_session_init(ses, pt, sender_ssrc);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    if (settings.flags & 4) {\n\tses->out_extseq = settings.seq;\n\tses->out_hdr.seq = pj_htons((pj_uint16_t)ses->out_extseq);\n    }\n    if (settings.flags & 8)\n\tses->out_hdr.ts = pj_htonl(settings.ts);\n    if (settings.flags & 16) {\n        ses->has_peer_ssrc = PJ_TRUE;\n\tses->peer_ssrc = settings.peer_ssrc;\n    }\n\n    PJ_LOG(5, (THIS_FILE,\n\t       \"pjmedia_rtp_session_init2: ses=%p, seq=%d, ts=%d, peer_ssrc=%d\",\n\t       ses, pj_ntohs(ses->out_hdr.seq), pj_ntohl(ses->out_hdr.ts),\n\t       ses->has_peer_ssrc? ses->peer_ssrc : 0));\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_encode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    int pt, int m,\n\t\t\t\t\t    int payload_len, int ts_len,\n\t\t\t\t\t    const void **rtphdr, int *hdrlen )\n{\n    /* Update timestamp */\n    ses->out_hdr.ts = pj_htonl(pj_ntohl(ses->out_hdr.ts)+ts_len);\n\n    /* If payload_len is zero, bail out.\n     * This is a clock frame; we're not really transmitting anything.\n     */\n    if (payload_len == 0)\n\treturn PJ_SUCCESS;\n\n    /* Update session. */\n    ses->out_extseq++;\n\n    /* Create outgoing header. */\n    ses->out_hdr.pt = (pj_uint8_t) ((pt == -1) ? ses->out_pt : pt);\n    ses->out_hdr.m = (pj_uint16_t) m;\n    ses->out_hdr.seq = pj_htons( (pj_uint16_t) ses->out_extseq);\n\n    /* Return values */\n    *rtphdr = &ses->out_hdr;\n    *hdrlen = sizeof(pjmedia_rtp_hdr);\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp( pjmedia_rtp_session *ses, \n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    pjmedia_rtp_dec_hdr dec_hdr;\n\n    return pjmedia_rtp_decode_rtp2(ses, pkt, pkt_len, hdr, &dec_hdr, \n\t\t\t\t   payload, payloadlen);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_rtp_decode_rtp2(\n\t\t\t\t\t    pjmedia_rtp_session *ses,\n\t\t\t\t\t    const void *pkt, int pkt_len,\n\t\t\t\t\t    const pjmedia_rtp_hdr **hdr,\n\t\t\t\t\t    pjmedia_rtp_dec_hdr *dec_hdr,\n\t\t\t\t\t    const void **payload,\n\t\t\t\t\t    unsigned *payloadlen)\n{\n    int offset;\n\n    PJ_UNUSED_ARG(ses);\n\n    /* Assume RTP header at the start of packet. We'll verify this later. */\n    *hdr = (pjmedia_rtp_hdr*)pkt;\n\n    /* Check RTP header sanity. */\n    if ((*hdr)->v != RTP_VERSION) {\n\treturn PJMEDIA_RTP_EINVER;\n    }\n\n    /* Payload is located right after header plus CSRC */\n    offset = sizeof(pjmedia_rtp_hdr) + ((*hdr)->cc * sizeof(pj_uint32_t));\n\n    /* Check that offset is less than packet size */\n    if (offset >= pkt_len) {\n        return PJMEDIA_RTP_EINLEN;\n    }\n\n    /* Decode RTP extension. */\n    if ((*hdr)->x) {\n        if (offset + sizeof (pjmedia_rtp_ext_hdr) > (unsigned)pkt_len)\n            return PJMEDIA_RTP_EINLEN;\n        dec_hdr->ext_hdr = (pjmedia_rtp_ext_hdr*)(((pj_uint8_t*)pkt) + offset);\n        dec_hdr->ext = (pj_uint32_t*)(dec_hdr->ext_hdr + 1);\n        dec_hdr->ext_len = pj_ntohs((dec_hdr->ext_hdr)->length);\n        offset += ((dec_hdr->ext_len + 1) * sizeof(pj_uint32_t));\n    } else {\n\tdec_hdr->ext_hdr = NULL;\n\tdec_hdr->ext = NULL;\n\tdec_hdr->ext_len = 0;\n    }\n\n    /* Check again that offset is still less than packet size */\n    if (offset >= pkt_len)\n\treturn PJMEDIA_RTP_EINLEN;\n\n    /* Find and set payload. */\n    *payload = ((pj_uint8_t*)pkt) + offset;\n    *payloadlen = pkt_len - offset;\n \n    /* Remove payload padding if any */\n    if ((*hdr)->p && *payloadlen > 0) {\n\tpj_uint8_t pad_len;\n\n\tpad_len = ((pj_uint8_t*)(*payload))[*payloadlen - 1];\n\tif (pad_len <= *payloadlen)\n\t    *payloadlen -= pad_len;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(void) pjmedia_rtp_session_update( pjmedia_rtp_session *ses, \n\t\t\t\t\t const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t pjmedia_rtp_status *p_seq_st)\n{\n    pjmedia_rtp_session_update2(ses, hdr, p_seq_st, PJ_TRUE);\n}\n\nPJ_DEF(void) pjmedia_rtp_session_update2( pjmedia_rtp_session *ses, \n\t\t\t\t\t  const pjmedia_rtp_hdr *hdr,\n\t\t\t\t\t  pjmedia_rtp_status *p_seq_st,\n\t\t\t\t\t  pj_bool_t check_pt)\n{\n    pjmedia_rtp_status seq_st;\n\n    /* for now check_pt MUST be either PJ_TRUE or PJ_FALSE.\n     * In the future we might change check_pt from boolean to \n     * unsigned integer to accommodate more flags.\n     */\n    pj_assert(check_pt==PJ_TRUE || check_pt==PJ_FALSE);\n\n    /* Init status */\n    seq_st.status.value = 0;\n    seq_st.diff = 0;\n\n    /* Check SSRC. */\n    if (!ses->has_peer_ssrc && ses->peer_ssrc == 0)\n        ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n\n    if (pj_ntohl(hdr->ssrc) != ses->peer_ssrc) {\n\tseq_st.status.flag.badssrc = 1;\n\tif (!ses->has_peer_ssrc)\n\t    ses->peer_ssrc = pj_ntohl(hdr->ssrc);\n    }\n\n    /* Check payload type. */\n    if (check_pt && hdr->pt != ses->out_pt) {\n\tif (p_seq_st) {\n\t    p_seq_st->status.value = seq_st.status.value;\n\t    p_seq_st->status.flag.bad = 1;\n\t    p_seq_st->status.flag.badpt = 1;\n\t}\n\treturn;\n    }\n\n    /* Initialize sequence number on first packet received. */\n    if (ses->received == 0)\n\tpjmedia_rtp_seq_init( &ses->seq_ctrl, pj_ntohs(hdr->seq) );\n\n    /* Check sequence number to see if remote session has been restarted. */\n    pjmedia_rtp_seq_update( &ses->seq_ctrl, pj_ntohs(hdr->seq), &seq_st);\n    if (seq_st.status.flag.restart) {\n\t++ses->received;\n\n    } else if (!seq_st.status.flag.bad) {\n\t++ses->received;\n    }\n\n    if (p_seq_st) {\n\tp_seq_st->status.value = seq_st.status.value;\n\tp_seq_st->diff = seq_st.diff;\n    }\n}\n\n\n\nvoid pjmedia_rtp_seq_restart(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    sess->base_seq = seq;\n    sess->max_seq = seq;\n    sess->bad_seq = RTP_SEQ_MOD + 1;\n    sess->cycles = 0;\n}\n\n\nvoid pjmedia_rtp_seq_init(pjmedia_rtp_seq_session *sess, pj_uint16_t seq)\n{\n    pjmedia_rtp_seq_restart(sess, seq);\n\n    sess->max_seq = (pj_uint16_t) (seq - 1);\n    sess->probation = MIN_SEQUENTIAL;\n}\n\n\nvoid pjmedia_rtp_seq_update( pjmedia_rtp_seq_session *sess, \n\t\t\t     pj_uint16_t seq,\n\t\t\t     pjmedia_rtp_status *seq_status)\n{\n    pj_uint16_t udelta = (pj_uint16_t) (seq - sess->max_seq);\n    pjmedia_rtp_status st;\n    \n    /* Init status */\n    st.status.value = 0;\n    st.diff = 0;\n\n    /*\n     * Source is not valid until MIN_SEQUENTIAL packets with\n     * sequential sequence numbers have been received.\n     */\n    if (sess->probation) {\n\n\tst.status.flag.probation = 1;\n\t\n        if (seq == sess->max_seq+ 1) {\n\t    /* packet is in sequence */\n\t    st.diff = 1;\n\t    sess->probation--;\n            sess->max_seq = seq;\n            if (sess->probation == 0) {\n\t\tst.status.flag.probation = 0;\n            }\n\t} else {\n\n\t    st.diff = 0;\n\n\t    st.status.flag.bad = 1;\n\t    if (seq == sess->max_seq)\n\t\tst.status.flag.dup = 1;\n\t    else\n\t\tst.status.flag.outorder = 1;\n\n\t    sess->probation = MIN_SEQUENTIAL - 1;\n\t    sess->max_seq = seq;\n        }\n\n\n    } else if (udelta == 0) {\n\n\tst.status.flag.dup = 1;\n\n    } else if (udelta < MAX_DROPOUT) {\n\t/* in order, with permissible gap */\n\tif (seq < sess->max_seq) {\n\t    /* Sequence number wrapped - count another 64K cycle. */\n\t    sess->cycles += RTP_SEQ_MOD;\n        }\n        sess->max_seq = seq;\n\n\tst.diff = udelta;\n\n    } else if (udelta <= (RTP_SEQ_MOD - MAX_MISORDER)) {\n\t/* the sequence number made a very large jump */\n        if (seq == sess->bad_seq) {\n\t    /*\n\t     * Two sequential packets -- assume that the other side\n\t     * restarted without telling us so just re-sync\n\t     * (i.e., pretend this was the first packet).\n\t     */\n\t    pjmedia_rtp_seq_restart(sess, seq);\n\t    st.status.flag.restart = 1;\n\t    st.status.flag.probation = 1;\n\t    st.diff = 1;\n\t}\n        else {\n\t    sess->bad_seq = (seq + 1) & (RTP_SEQ_MOD-1);\n            st.status.flag.bad = 1;\n\t    st.status.flag.outorder = 1;\n        }\n    } else {\n\t/* old duplicate or reordered packet.\n\t * Not necessarily bad packet (?)\n\t */\n\tst.status.flag.outorder = 1;\n    }\n    \n\n    if (seq_status) {\n\tseq_status->diff = st.diff;\n\tseq_status->status.value = st.status.value;\n    }\n}\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/sdp.h>\n#include <pjmedia/errno.h>\n#include <pjlib-util/scanner.h>\n#include <pj/array.h>\n#include <pj/except.h>\n#include <pj/log.h>\n#include <pj/os.h>\n#include <pj/string.h>\n#include <pj/pool.h>\n#include <pj/assert.h>\n#include <pj/ctype.h>\n\n\nenum {\n    SKIP_WS = 0,\n    SYNTAX_ERROR = 1,\n};\n// New token definition from RFC 4566 (SDP)\n#define TOKEN\t\t\"!#$%&'*+-.^_`{|}~\"\n//#define TOKEN\t\t\"-.!%*_=`'~\"\n//#define TOKEN\t\t\"'`-./:?\\\"#$&*;=@[]^_`{|}+~!\"\n#define NTP_OFFSET\t((pj_uint32_t)2208988800)\n#define THIS_FILE\t\"sdp.c\"\n\ntypedef struct parse_context\n{ \n    pj_status_t last_error;\n} parse_context;\n\n\n/*\n * Prototypes for line parser.\n */\nstatic void parse_version(pj_scanner *scanner, volatile parse_context *ctx);\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx);\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx);\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx);\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx);\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx);\nstatic pjmedia_sdp_attr *parse_attr(pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx);\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx);\nstatic void on_scanner_error(pj_scanner *scanner);\n\n/*\n * Scanner character specification.\n */\nstatic int is_initialized;\nstatic pj_cis_buf_t cis_buf;\nstatic pj_cis_t cs_digit, cs_token;\n\nstatic void init_sdp_parser(void)\n{\n    if (is_initialized != 0)\n\treturn;\n\n    pj_enter_critical_section();\n\n    if (is_initialized != 0) {\n\tpj_leave_critical_section();\n\treturn;\n    }\n    \n    pj_cis_buf_init(&cis_buf);\n\n    pj_cis_init(&cis_buf, &cs_token);\n    pj_cis_add_alpha(&cs_token);\n    pj_cis_add_num(&cs_token);\n    pj_cis_add_str(&cs_token, TOKEN);\n\n    pj_cis_init(&cis_buf, &cs_digit);\n    pj_cis_add_num(&cs_digit);\n\n    is_initialized = 1;\n    pj_leave_critical_section();\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create( pj_pool_t *pool,\n\t\t\t\t\t\t   const char *name,\n\t\t\t\t\t\t   const pj_str_t *value)\n{\n    pjmedia_sdp_attr *attr;\n\n    PJ_ASSERT_RETURN(pool && name, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    pj_strdup2(pool, &attr->name, name);\n\n    if (value)\n\tpj_strdup_with_null(pool, &attr->value, value);\n    else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_clone(pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_attr *rhs)\n{\n    pjmedia_sdp_attr *attr;\n    \n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    pj_strdup(pool, &attr->name, &rhs->name);\n    pj_strdup_with_null(pool, &attr->value, &rhs->value);\n\n    return attr;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find (unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const pj_str_t *name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    unsigned i;\n    unsigned c_pt = 0xFFFF;\n\n    PJ_ASSERT_RETURN(count <= PJMEDIA_MAX_SDP_ATTR, NULL);\n\n    if (c_fmt)\n\tc_pt = pj_strtoul(c_fmt);\n\n    for (i=0; i<count; ++i) {\n\tif (pj_strcmp(&attr_array[i]->name, name) == 0) {\n\t    const pjmedia_sdp_attr *a = attr_array[i];\n\t    if (c_fmt) {\n\t\tunsigned pt = (unsigned) pj_strtoul2(&a->value, NULL, 10);\n\t\tif (pt == c_pt) {\n\t\t    return (pjmedia_sdp_attr*)a;\n\t\t}\n\t    } else \n\t\treturn (pjmedia_sdp_attr*)a;\n\t}\n    }\n    return NULL;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_find2(unsigned count, \n\t\t\t\t       pjmedia_sdp_attr *const attr_array[],\n\t\t\t\t       const char *c_name,\n\t\t\t\t       const pj_str_t *c_fmt)\n{\n    pj_str_t name;\n\n    name.ptr = (char*)c_name;\n    name.slen = pj_ansi_strlen(c_name);\n\n    return pjmedia_sdp_attr_find(count, attr_array, &name, c_fmt);\n}\n\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_add(unsigned *count,\n\t\t\t\t\t pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count < PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_array[*count] = attr;\n    (*count)++;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(unsigned) pjmedia_sdp_attr_remove_all(unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     const char *name)\n{\n    unsigned i, removed = 0;\n    pj_str_t attr_name;\n\n    PJ_ASSERT_RETURN(count && attr_array && name, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    attr_name.ptr = (char*)name;\n    attr_name.slen = pj_ansi_strlen(name);\n\n    for (i=0; i<*count; ) {\n\tif (pj_strcmp(&attr_array[i]->name, &attr_name)==0) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}   \n    }\n\n    return removed;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_remove( unsigned *count,\n\t\t\t\t\t     pjmedia_sdp_attr *attr_array[],\n\t\t\t\t\t     pjmedia_sdp_attr *attr )\n{\n    unsigned i, removed=0;\n\n    PJ_ASSERT_RETURN(count && attr_array && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(*count <= PJMEDIA_MAX_SDP_ATTR, PJ_ETOOMANY);\n\n    for (i=0; i<*count; ) {\n\tif (attr_array[i] == attr) {\n\t    pj_array_erase(attr_array, sizeof(pjmedia_sdp_attr*),\n\t\t\t   *count, i);\n\t    --(*count);\n\t    ++removed;\n\t} else {\n\t    ++i;\n\t}\n    }\n\n    return removed ? PJ_SUCCESS : PJ_ENOTFOUND;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtpmap( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t\t pjmedia_sdp_rtpmap *rtpmap)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    char term = 0;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtpmap\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* Check if input is null terminated, and null terminate if\n     * necessary. Unfortunately this may crash the application if\n     * attribute was allocated from a read-only memory location.\n     * But this shouldn't happen as attribute's value normally is\n     * null terminated.\n     */\n    if (attr->value.ptr[attr->value.slen] != 0 &&\n\tattr->value.ptr[attr->value.slen] != '\\r' &&\n\tattr->value.ptr[attr->value.slen] != '\\n')\n    {\n\tpj_assert(!\"Shouldn't happen\");\n\tterm = attr->value.ptr[attr->value.slen];\n\tattr->value.ptr[attr->value.slen] = '\\0';\n    }\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */    \n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* rtpmap sample:\n     *\ta=rtpmap:98 L16/16000/2.\n     */\n\n    /* Init */\n    rtpmap->pt.slen = rtpmap->param.slen = rtpmap->enc_name.slen = 0;\n    rtpmap->clock_rate = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get payload type. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->pt);\n\n\n\t/* Get encoding name. */\n\tpj_scan_get(&scanner, &cs_token, &rtpmap->enc_name);\n\n\t/* Expecting '/' after encoding name. */\n\tif (pj_scan_get_char(&scanner) != '/') {\n\t    status = PJMEDIA_SDP_EINRTPMAP;\n\t    goto on_return;\n\t}\n\n\n\t/* Get the clock rate. */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\trtpmap->clock_rate = pj_strtoul(&token);\n\n\t/* Expecting either '/' or EOF */\n\tif (*scanner.curptr == '/') {\n\t    /* Skip the '/' */\n\t    pj_scan_get_char(&scanner);\n\t    pj_scan_get(&scanner, &cs_token, &rtpmap->param);\n\t} else {\n\t    rtpmap->param.slen = 0;\n\t}\n\n\tstatus = PJ_SUCCESS;\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTPMAP;\n    }\n    PJ_END;\n\n\non_return:\n    pj_scan_fini(&scanner);\n    if (term) {\n\tattr->value.ptr[attr->value.slen] = term;\n    }\n    return status;\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_fmtp( const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_fmtp *fmtp)\n{\n    const char *p = attr->value.ptr;\n    const char *end = attr->value.ptr + attr->value.slen;\n    pj_str_t token;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"fmtp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    /* fmtp BNF:\n     *\ta=fmtp:<format> <format specific parameter>\n     */\n\n    /* Get format. */\n    token.ptr = (char*)p;\n    while (pj_isdigit(*p) && p!=end)\n\t++p;\n    token.slen = p - token.ptr;\n    if (token.slen == 0)\n\treturn PJMEDIA_SDP_EINFMTP;\n\n    fmtp->fmt = token;\n\n    /* Expecting space after format. */\n    if (*p != ' ') return PJMEDIA_SDP_EINFMTP;\n\n    /* Get space. */\n    ++p;\n\n    /* Set the remaining string as fmtp format parameter. */\n    fmtp->fmt_param.ptr = (char*)p;\n    fmtp->fmt_param.slen = end - p;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_rtcp(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_rtcp_attr *rtcp)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"rtcp\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* fmtp BNF:\n     *\ta=rtcp:<port> [nettype addrtype address]\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    rtcp->net_type.slen = rtcp->addr_type.slen = rtcp->addr.slen = 0;\n\n    /* Parse */\n    PJ_TRY {\n\n\t/* Get the port */\n\tpj_scan_get(&scanner, &cs_token, &token);\n\trtcp->port = pj_strtoul(&token);\n\n\t/* Have address? */\n\tif (!pj_scan_is_eof(&scanner)) {\n\n\t    /* Get network type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->net_type);\n\n\t    /* Get address type */\n\t    pj_scan_get(&scanner, &cs_token, &rtcp->addr_type);\n\n\t    /* Get the address */\n\t    //pj_scan_get(&scanner, &cs_token, &rtcp->addr);\n\t    pj_scan_get_until_chr(&scanner, \"/ \\t\\r\\n\", &rtcp->addr);\n\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINRTCP;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_rtcp(pj_pool_t *pool,\n\t\t\t\t\t\t       const pj_sockaddr *a)\n{\n    enum {\n\tATTR_LEN = PJ_INET6_ADDRSTRLEN+16\n    };\n    char tmp_addr[PJ_INET6_ADDRSTRLEN];\n    pjmedia_sdp_attr *attr;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"rtcp\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, ATTR_LEN);\n    if (a->addr.sa_family == pj_AF_INET()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP4 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n    } else if (a->addr.sa_family == pj_AF_INET6()) {\n\tattr->value.slen = \n\t    pj_ansi_snprintf(attr->value.ptr, ATTR_LEN,\n\t\t\t    \"%u IN IP6 %s\",\n\t\t\t    pj_sockaddr_get_port(a),\n\t\t\t    pj_sockaddr_print(a, tmp_addr, \n\t\t\t\t\t      sizeof(tmp_addr), 0));\n\n    } else {\n\tpj_assert(!\"Unsupported address family\");\n\treturn NULL;\n    }\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_get_ssrc(const pjmedia_sdp_attr *attr,\n\t\t\t\t\t      pjmedia_sdp_ssrc_attr *ssrc)\n{\n    pj_scanner scanner;\n    pj_str_t token;\n    pj_status_t status = -1;\n    PJ_USE_EXCEPTION;\n\n    PJ_ASSERT_RETURN(pj_strcmp2(&attr->name, \"ssrc\")==0, PJ_EINVALIDOP);\n\n    if (attr->value.slen == 0)\n        return PJMEDIA_SDP_EINATTR;\n\n    init_sdp_parser();\n\n    /* ssrc BNF:\n     *  a=ssrc:<ssrc-id> <attribute>\n     *\ta=ssrc:<ssrc-id> <attribute>:<value>\n     */\n\n    /* The buffer passed to the scanner is not guaranteed to be NULL\n     * terminated, but should be safe. See ticket #2063.\n     */\n    pj_scan_init(&scanner, (char*)attr->value.ptr, attr->value.slen,\n\t\t PJ_SCAN_AUTOSKIP_WS, &on_scanner_error);\n\n    /* Init */\n    pj_bzero(ssrc, sizeof(*ssrc));\n\n    /* Parse */\n    PJ_TRY {\n        pj_str_t scan_attr;\n\n\t/* Get the ssrc */\n\tpj_scan_get(&scanner, &cs_digit, &token);\n\tssrc->ssrc = pj_strtoul(&token);\n\n    \tpj_scan_get_char(&scanner);\n\tpj_scan_get(&scanner, &cs_token, &scan_attr);\n\t\n\t/* Get cname attribute, if any */\n\tif (!pj_scan_is_eof(&scanner) &&\n\t    pj_scan_get_char(&scanner) == ':' &&\n\t    pj_strcmp2(&scan_attr, \"cname\"))\n\t{\n\t    pj_scan_get(&scanner, &cs_token, &ssrc->cname);\n\t}\n\n\tstatus = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\n\tstatus = PJMEDIA_SDP_EINSSRC;\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n    return status;\n}\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_attr_create_ssrc( pj_pool_t *pool,\n\t\t\t\t\t\t\tpj_uint32_t ssrc,\n\t\t\t\t\t\t\tconst pj_str_t *cname)\n{\n    pjmedia_sdp_attr *attr;\n\n    if (cname->slen == 0)\n        return NULL;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    attr->name = pj_str(\"ssrc\");\n    attr->value.ptr = (char*) pj_pool_alloc(pool, cname->slen+7 /* \" cname:\"*/\n    \t\t\t\t\t\t  + 10 /* 32-bit integer */\n    \t\t\t\t\t\t  + 1 /* NULL */);\n    attr->value.slen = pj_ansi_snprintf(attr->value.ptr, cname->slen+18,\n    \t\t\t\t\t\"%u cname:%.*s\", ssrc,\n\t\t\t   \t   \t(int)cname->slen, cname->ptr);\n\n    return attr;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_attr_to_rtpmap(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_attr *attr,\n\t\t\t\t\t       pjmedia_sdp_rtpmap **p_rtpmap)\n{\n    PJ_ASSERT_RETURN(pool && attr && p_rtpmap, PJ_EINVAL);\n\n    *p_rtpmap = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_rtpmap);\n    PJ_ASSERT_RETURN(*p_rtpmap, PJ_ENOMEM);\n\n    return pjmedia_sdp_attr_get_rtpmap(attr, *p_rtpmap);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_rtpmap_to_attr(pj_pool_t *pool,\n\t\t\t\t\t       const pjmedia_sdp_rtpmap *rtpmap,\n\t\t\t\t\t       pjmedia_sdp_attr **p_attr)\n{\n    pjmedia_sdp_attr *attr;\n    char tempbuf[128];\n    int len;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(pool && rtpmap && p_attr, PJ_EINVAL);\n\n    /* Check that mandatory attributes are specified. */\n    PJ_ASSERT_RETURN(rtpmap->enc_name.slen && rtpmap->clock_rate,\n\t\t     PJMEDIA_SDP_EINRTPMAP);\n\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n    PJ_ASSERT_RETURN(attr != NULL, PJ_ENOMEM);\n\n    attr->name.ptr = \"rtpmap\";\n    attr->name.slen = 6;\n\n    /* Format: \":pt enc_name/clock_rate[/param]\" */\n    len = pj_ansi_snprintf(tempbuf, sizeof(tempbuf), \n\t\t\t   \"%.*s %.*s/%u%s%.*s\",\n\t\t\t   (int)rtpmap->pt.slen,\n\t\t\t   rtpmap->pt.ptr,\n\t\t\t   (int)rtpmap->enc_name.slen,\n\t\t\t   rtpmap->enc_name.ptr,\n\t\t\t   rtpmap->clock_rate,\n\t\t\t   (rtpmap->param.slen ? \"/\" : \"\"),\n\t\t\t   (int)rtpmap->param.slen,\n\t\t\t   rtpmap->param.ptr);\n\n    if (len < 1 || len >= (int)sizeof(tempbuf))\n\treturn PJMEDIA_SDP_ERTPMAPTOOLONG;\n\n    attr->value.slen = len;\n    attr->value.ptr = (char*) pj_pool_alloc(pool, attr->value.slen+1);\n    pj_memcpy(attr->value.ptr, tempbuf, attr->value.slen+1);\n\n    *p_attr = attr;\n    return PJ_SUCCESS;\n}\n\n\nstatic int print_connection_info( pjmedia_sdp_conn *c, char *buf, int len)\n{\n    int printed;\n\n    printed = pj_ansi_snprintf(buf, len, \"c=%.*s %.*s %.*s\\r\\n\",\n\t\t\t       (int)c->net_type.slen,\n\t\t\t       c->net_type.ptr,\n\t\t\t       (int)c->addr_type.slen,\n\t\t\t       c->addr_type.ptr,\n\t\t\t       (int)c->addr.slen,\n\t\t\t       c->addr.ptr);\n    if (printed < 1 || printed >= len)\n\treturn -1;\n\n    return printed;\n}\n\n\nPJ_DEF(pjmedia_sdp_conn*) pjmedia_sdp_conn_clone (pj_pool_t *pool, \n\t\t\t\t\t\t  const pjmedia_sdp_conn *rhs)\n{\n    pjmedia_sdp_conn *c = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_conn);\n    if (!c) return NULL;\n\n    if (!pj_strdup (pool, &c->net_type, &rhs->net_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr_type, &rhs->addr_type)) return NULL;\n    if (!pj_strdup (pool, &c->addr, &rhs->addr)) return NULL;\n\n    return c;\n}\n\nPJ_DEF(pjmedia_sdp_bandw*)\npjmedia_sdp_bandw_clone (pj_pool_t *pool, \n\t\t\t const pjmedia_sdp_bandw *rhs)\n{\n    pjmedia_sdp_bandw *b = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_bandw);\n    if (!b) return NULL;\n\n    if (!pj_strdup (pool, &b->modifier, &rhs->modifier)) return NULL;\n    b->value = rhs->value;\n\n    return b;\n}\n\nstatic pj_ssize_t print_bandw(const pjmedia_sdp_bandw *bandw,\n\t\t\t      char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < bandw->modifier.slen + 10 + 5)\n\treturn -1;\n\n    *p++ = 'b';\n    *p++ = '=';\n    pj_memcpy(p, bandw->modifier.ptr, bandw->modifier.slen);\n    p += bandw->modifier.slen;\n    *p++ = ':';\n    p += pj_utoa(bandw->value, p);\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic pj_ssize_t print_attr(const pjmedia_sdp_attr *attr, \n\t\t\t     char *buf, pj_size_t len)\n{\n    char *p = buf;\n\n    if ((int)len < attr->name.slen + attr->value.slen + 10)\n\treturn -1;\n\n    *p++ = 'a';\n    *p++ = '=';\n    pj_memcpy(p, attr->name.ptr, attr->name.slen);\n    p += attr->name.slen;\n    \n\n    if (attr->value.slen) {\n\t*p++ = ':';\n\tpj_memcpy(p, attr->value.ptr, attr->value.slen);\n\tp += attr->value.slen;\n    }\n\n    *p++ = '\\r';\n    *p++ = '\\n';\n    return p-buf;\n}\n\nstatic int print_media_desc(const pjmedia_sdp_media *m, char *buf, pj_size_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* check length for the \"m=\" line. */\n    if (len < (pj_size_t)m->desc.media.slen+m->desc.transport.slen+12+24) {\n\treturn -1;\n    }\n    *p++ = 'm';\t    /* m= */\n    *p++ = '=';\n    pj_memcpy(p, m->desc.media.ptr, m->desc.media.slen);\n    p += m->desc.media.slen;\n    *p++ = ' ';\n    printed = pj_utoa(m->desc.port, p);\n    p += printed;\n    if (m->desc.port_count > 1) {\n\t*p++ = '/';\n\tprinted = pj_utoa(m->desc.port_count, p);\n\tp += printed;\n    }\n    *p++ = ' ';\n    pj_memcpy(p, m->desc.transport.ptr, m->desc.transport.slen);\n    p += m->desc.transport.slen;\n    for (i=0; i<m->desc.fmt_count; ++i) {\n\tif (end-p > m->desc.fmt[i].slen) {\n\t    *p++ = ' ';\n\t    pj_memcpy(p, m->desc.fmt[i].ptr, m->desc.fmt[i].slen);\n\t    p += m->desc.fmt[i].slen;\n\t} else {\n\t    return -1;\n\t}\n    }\n\n    if (end-p >= 2) {\n\t*p++ = '\\r';\n\t*p++ = '\\n';\n    } else {\n\treturn -1;\n    }\n\n    /* print connection info, if present. */\n    if (m->conn) {\n\tprinted = print_connection_info(m->conn, p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n    \n    /* print optional bandwidth info. */\n    for (i=0; i<m->bandw_count; ++i) {\n\tprinted = (int)print_bandw(m->bandw[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print attributes. */\n    for (i=0; i<m->attr_count; ++i) {\n\tprinted = (int)print_attr(m->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\nPJ_DEF(int) pjmedia_sdp_media_print(const pjmedia_sdp_media *media,\n\t\t\t       char *buf, pj_size_t size)\n{\n\treturn print_media_desc(media, buf, size);\n}\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone(\n\t\t\t\t\t\t pj_pool_t *pool, \n\t\t\t\t\t\t const pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_media);\n    PJ_ASSERT_RETURN(m != NULL, NULL);\n\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    m->desc.port = rhs->desc.port;\n    m->desc.port_count = rhs->desc.port_count;\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    m->desc.fmt_count = rhs->desc.fmt_count;\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    } else {\n\tm->conn = NULL;\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    m->attr_count = rhs->attr_count;\n    for (i=0; i < rhs->attr_count; ++i) {\n\tm->attr[i] = pjmedia_sdp_attr_clone (pool, rhs->attr[i]);\n\tPJ_ASSERT_RETURN(m->attr[i] != NULL, NULL);\n    }\n\n    return m;\n}\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst pj_str_t *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find(m->attr_count, m->attr, name, fmt);\n}\n\n\n\nPJ_DEF(pjmedia_sdp_attr*) pjmedia_sdp_media_find_attr2(\n\t\t\t\tconst pjmedia_sdp_media *m,\n\t\t\t\tconst char *name, const pj_str_t *fmt)\n{\n    PJ_ASSERT_RETURN(m && name, NULL);\n    return pjmedia_sdp_attr_find2(m->attr_count, m->attr, name, fmt);\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_add_attr( pjmedia_sdp_media *m,\n\t\t\t\t\t\tpjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&m->attr_count, m->attr, attr);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_session_add_attr(pjmedia_sdp_session *s,\n\t\t\t\t\t\t pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_add(&s->attr_count, s->attr, attr);\n}\n\nPJ_DEF(unsigned) pjmedia_sdp_media_remove_all_attr(pjmedia_sdp_media *m,\n\t\t\t\t\t\t   const char *name)\n{\n    return pjmedia_sdp_attr_remove_all(&m->attr_count, m->attr, name);\n}\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_remove_attr(pjmedia_sdp_media *m,\n\t\t\t      \t\t\t  pjmedia_sdp_attr *attr)\n{\n    return pjmedia_sdp_attr_remove(&m->attr_count, m->attr, attr);\n}\n\nstatic int print_session(const pjmedia_sdp_session *ses, \n\t\t\t char *buf, pj_ssize_t len)\n{\n    char *p = buf;\n    char *end = buf+len;\n    unsigned i;\n    int printed;\n\n    /* Check length for v= and o= lines. */\n    if (len < 5+ \n\t      2+ses->origin.user.slen+18+\n\t      ses->origin.net_type.slen+ses->origin.addr.slen + 2)\n    {\n\treturn -1;\n    }\n\n    /* SDP version (v= line) */\n    pj_memcpy(p, \"v=0\\r\\n\", 5);\n    p += 5;\n\n    /* Owner (o=) line. */\n    *p++ = 'o';\n    *p++ = '=';\n    pj_memcpy(p, ses->origin.user.ptr, ses->origin.user.slen);\n    p += ses->origin.user.slen;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.id, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->origin.version, p);\n    p += printed;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.net_type.ptr, ses->origin.net_type.slen);\n    p += ses->origin.net_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr_type.ptr, ses->origin.addr_type.slen);\n    p += ses->origin.addr_type.slen;\n    *p++ = ' ';\n    pj_memcpy(p, ses->origin.addr.ptr, ses->origin.addr.slen);\n    p += ses->origin.addr.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Session name (s=) line. */\n    if ((end-p)  < 8+ses->name.slen) {\n\treturn -1;\n    }\n    *p++ = 's';\n    *p++ = '=';\n    pj_memcpy(p, ses->name.ptr, ses->name.slen);\n    p += ses->name.slen;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Connection line (c=) if exist. */\n    if (ses->conn) {\n\tprinted = print_connection_info(ses->conn, p, (int)(end-p));\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* print optional bandwidth info. */\n    for (i=0; i<ses->bandw_count; ++i) {\n\tprinted = (int)print_bandw(ses->bandw[i], p, end-p);\n\tif (printed < 1) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Time */\n    if ((end-p) < 24) {\n\treturn -1;\n    }\n    *p++ = 't';\n    *p++ = '=';\n    printed = pj_utoa(ses->time.start, p);\n    p += printed;\n    *p++ = ' ';\n    printed = pj_utoa(ses->time.stop, p);\n    p += printed;\n    *p++ = '\\r';\n    *p++ = '\\n';\n\n    /* Print all attribute (a=) lines. */\n    for (i=0; i<ses->attr_count; ++i) {\n\tprinted = (int)print_attr(ses->attr[i], p, end-p);\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    /* Print media (m=) lines. */\n    for (i=0; i<ses->media_count; ++i) {\n\tprinted = print_media_desc(ses->media[i], p, (int)(end-p));\n\tif (printed < 0) {\n\t    return -1;\n\t}\n\tp += printed;\n    }\n\n    return (int)(p-buf);\n}\n\n/******************************************************************************\n * PARSERS\n */\n\nstatic void parse_version(pj_scanner *scanner, \n                          volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINVER;\n\n    /* check equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* check version is 0 */\n    if (scanner->curptr+2 >= scanner->end || *(scanner->curptr+2) != '0') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_origin(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINORIGIN;\n\n    /* check equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* o= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* username. */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.user);\n    pj_scan_get_char(scanner);\n\n    /* id */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.id = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* version */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->origin.version = pj_strtoul(&str);\n    pj_scan_get_char(scanner);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &ses->origin.addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &ses->origin.addr);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n}\n\nstatic void parse_time(pj_scanner *scanner, pjmedia_sdp_session *ses,\n\t\t       volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINTIME;\n\n    /* check equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* t= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* start time */\n    pj_scan_get_until_ch(scanner, ' ', &str);\n    ses->time.start = pj_strtoul(&str);\n\n    pj_scan_get_char(scanner);\n\n    /* stop time */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    ses->time.stop = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_generic_line(pj_scanner *scanner, pj_str_t *str,\n\t\t\t       volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINSDP;\n\n    /* check equal sign */\n    if ((scanner->curptr+1 >= scanner->end) || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* x= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* get anything until newline (including whitespaces). */\n    pj_scan_get_until_chr(scanner, \"\\r\\n\", str);\n\n    /* newline. */\n    pj_scan_get_newline(scanner);\n}\n\nstatic void parse_connection_info(pj_scanner *scanner, pjmedia_sdp_conn *conn,\n\t\t\t\t  volatile parse_context *ctx)\n{\n    ctx->last_error = PJMEDIA_SDP_EINCONN;\n\n    /* c= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* network-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->net_type);\n    pj_scan_get_char(scanner);\n\n    /* addr-type */\n    pj_scan_get_until_ch(scanner, ' ', &conn->addr_type);\n    pj_scan_get_char(scanner);\n\n    /* address. */\n    pj_scan_get_until_chr(scanner, \"/ \\t\\r\\n\", &conn->addr);\n    PJ_TODO(PARSE_SDP_CONN_ADDRESS_SUBFIELDS);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_bandwidth_info(pj_scanner *scanner, pjmedia_sdp_bandw *bandw,\n\t\t\t\t volatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINBANDW;\n\n    /* b= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* modifier */\n    pj_scan_get_until_ch(scanner, ':', &bandw->modifier);\n    pj_scan_get_char(scanner);\n\n    /* value */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &str);\n    bandw->value = pj_strtoul(&str);\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void parse_media(pj_scanner *scanner, pjmedia_sdp_media *med,\n\t\t\tvolatile parse_context *ctx)\n{\n    pj_str_t str;\n\n    ctx->last_error = PJMEDIA_SDP_EINMEDIA;\n\n    /* check the equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn;\n    }\n\n    /* m= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n\n    /* type */\n    pj_scan_get_until_ch(scanner, ' ', &med->desc.media);\n    pj_scan_get_char(scanner);\n\n    /* port */\n    pj_scan_get(scanner, &cs_token, &str);\n    med->desc.port = (unsigned short)pj_strtoul(&str);\n    if (pj_scan_is_eof(scanner)) {\n        on_scanner_error(scanner);\n        return;\n    }\n    if (*scanner->curptr == '/') {\n\t/* port count */\n\tpj_scan_get_char(scanner);\n\tpj_scan_get(scanner, &cs_token, &str);\n\tmed->desc.port_count = pj_strtoul(&str);\n\n    } else {\n\tmed->desc.port_count = 0;\n    }\n\n    if (pj_scan_get_char(scanner) != ' ') {\n\ton_scanner_error(scanner);\n    }\n\n    /* transport */\n    pj_scan_get_until_chr(scanner, \" \\t\\r\\n\", &med->desc.transport);\n\n    /* format list */\n    med->desc.fmt_count = 0;\n    while (scanner->curptr < scanner->end && *scanner->curptr == ' ') {\n\tpj_str_t fmt;\n\n\tpj_scan_get_char(scanner);\n\n\t/* Check again for the end of the line */\n\tif ((*scanner->curptr == '\\r') || (*scanner->curptr == '\\n'))\n\t\tbreak;\n\n\tpj_scan_get(scanner, &cs_token, &fmt);\n\tif (med->desc.fmt_count < PJMEDIA_MAX_SDP_FMT)\n\t    med->desc.fmt[med->desc.fmt_count++] = fmt;\n\telse\n\t    PJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY, \n\t\t         \"Error adding SDP media format %.*s, \"\n\t\t\t \"format is ignored\",\n\t\t\t (int)fmt.slen, fmt.ptr));\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n}\n\nstatic void on_scanner_error(pj_scanner *scanner)\n{\n    PJ_UNUSED_ARG(scanner);\n\n    PJ_THROW(SYNTAX_ERROR);\n}\n\nstatic pjmedia_sdp_attr *parse_attr( pj_pool_t *pool, pj_scanner *scanner,\n\t\t\t\t    volatile parse_context *ctx)\n{\n    pjmedia_sdp_attr *attr;\n\n    ctx->last_error = PJMEDIA_SDP_EINATTR;\n\n    attr = PJ_POOL_ALLOC_T(pool, pjmedia_sdp_attr);\n\n    /* check equal sign */\n    if (scanner->curptr+1 >= scanner->end || *(scanner->curptr+1) != '=') {\n\ton_scanner_error(scanner);\n\treturn NULL;\n    }\n\n    /* skip a= */\n    pj_scan_advance_n(scanner, 2, SKIP_WS);\n    \n    /* get attr name. */\n    pj_scan_get(scanner, &cs_token, &attr->name);\n\n    if (*scanner->curptr && *scanner->curptr != '\\r' && \n\t*scanner->curptr != '\\n') \n    {\n\t/* skip ':' if present. */\n\tif (*scanner->curptr == ':')\n\t    pj_scan_get_char(scanner);\n\n\t/* get value */\n\tif (!pj_scan_is_eof(scanner) && *scanner->curptr != '\\r' && *scanner->curptr != '\\n') {\n\t    pj_scan_get_until_chr(scanner, \"\\r\\n\", &attr->value);\n\t} else {\n\t    attr->value.ptr = NULL;\n\t    attr->value.slen = 0;\n\t}\n\n    } else {\n\tattr->value.ptr = NULL;\n\tattr->value.slen = 0;\n    }\n\n    /* We've got what we're looking for, skip anything until newline */\n    pj_scan_skip_line(scanner);\n\n    return attr;\n}\n\n\n/*\n * Apply direction attribute in session to all media.\n */\nstatic void apply_media_direction(pjmedia_sdp_session *sdp)\n{\n    pjmedia_sdp_attr *dir_attr = NULL;\n    unsigned i;\n\n    const pj_str_t inactive = { \"inactive\", 8 };\n    const pj_str_t sendonly = { \"sendonly\", 8 };\n    const pj_str_t recvonly = { \"recvonly\", 8 };\n    const pj_str_t sendrecv = { \"sendrecv\", 8 };\n\n    /* Find direction attribute in session, don't need to find default \n     * direction \"sendrecv\".\n     */\n    for (i = 0; i < sdp->attr_count && !dir_attr; ++i) {\n\tif (!pj_strcmp(&sdp->attr[i]->name, &sendonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &recvonly) ||\n\t    !pj_strcmp(&sdp->attr[i]->name, &inactive)) \n\t{\n\t    dir_attr = sdp->attr[i];\n\t}\n    }\n\n    /* Found the direction attribute */\n    if (dir_attr) {\n\t/* Remove the direction attribute in session */\n\tpjmedia_sdp_attr_remove(&sdp->attr_count, sdp->attr, dir_attr);\n\n\t/* Apply the direction attribute to all media, but not overriding it\n\t * if media already has direction attribute.\n\t */\n\tfor (i = 0; i < sdp->media_count; ++i) {\n\t    pjmedia_sdp_media *m;\n\t    unsigned j;\n\n\t    /* Find direction attribute in this media */\n\t    m = sdp->media[i];\n\t    for (j = 0; j < m->attr_count; ++j) {\n\t\tif (!pj_strcmp(&m->attr[j]->name, &sendrecv) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &sendonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &recvonly) ||\n\t\t    !pj_strcmp(&m->attr[j]->name, &inactive)) \n\t\t{\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* Not found, apply direction attribute from session */\n\t    if (j == m->attr_count)\n\t\tpjmedia_sdp_media_add_attr(m, dir_attr);\n\t}\n    }\n}\n\n\n/*\n * Parse SDP message.\n */\nPJ_DEF(pj_status_t) pjmedia_sdp_parse( pj_pool_t *pool,\n\t\t\t\t       char *buf, pj_size_t len, \n\t\t\t\t       pjmedia_sdp_session **p_sdp)\n{\n    pj_scanner scanner;\n    pjmedia_sdp_session *session;\n    pjmedia_sdp_media *media = NULL;\n    pjmedia_sdp_attr *attr;\n    pjmedia_sdp_conn *conn;\n    pjmedia_sdp_bandw *bandw;\n    pj_str_t dummy;\n    int cur_name = 254;\n    volatile parse_context ctx;\n    PJ_USE_EXCEPTION;\n\n    ctx.last_error = PJ_SUCCESS;\n\n    init_sdp_parser();\n\n    pj_scan_init(&scanner, buf, len, 0, &on_scanner_error);\n    session = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(session != NULL, PJ_ENOMEM);\n\n    /* Ignore leading newlines */\n    while (*scanner.curptr=='\\r' || *scanner.curptr=='\\n')\n\tpj_scan_get_char(&scanner);\n\n    PJ_TRY {\n\twhile (!pj_scan_is_eof(&scanner)) {\n\t\tcur_name = *scanner.curptr;\n\t\tswitch (cur_name) {\n\t\tcase 'a':\n\t\t    attr = parse_attr(pool, &scanner, &ctx);\n\t\t    if (attr) {\n\t\t\tif (media) {\n\t\t\t    if (media->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_media_add_attr(media, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding media attribute, \"\n\t\t\t\t\t      \"attribute is ignored\"));\n\t\t\t} else {\n\t\t\t    if (session->attr_count < PJMEDIA_MAX_SDP_ATTR)\n\t\t\t\tpjmedia_sdp_session_add_attr(session, attr);\n\t\t\t    else\n\t\t\t\tPJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t      \"Error adding session attribute\"\n\t\t\t\t\t      \", attribute is ignored\"));\n\t\t\t}\n\t\t    }\n\t\t    break;\n\t\tcase 'o':\n\t\t    parse_origin(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 's':\n\t\t    parse_generic_line(&scanner, &session->name, &ctx);\n\t\t    break;\n\t\tcase 'c':\n\t\t    conn = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_conn);\n\t\t    parse_connection_info(&scanner, conn, &ctx);\n\t\t    if (media) {\n\t\t\tmedia->conn = conn;\n\t\t    } else {\n\t\t\tsession->conn = conn;\n\t\t    }\n\t\t    break;\n\t\tcase 't':\n\t\t    parse_time(&scanner, session, &ctx);\n\t\t    break;\n\t\tcase 'm':\n\t\t    media = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n\t\t    parse_media(&scanner, media, &ctx);\n\t\t    if (session->media_count < PJMEDIA_MAX_SDP_MEDIA)\n\t\t\tsession->media[ session->media_count++ ] = media;\n\t\t    else\n\t\t\tPJ_PERROR(2,(THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t     \"Error adding media, media is ignored\"));\n\t\t    break;\n\t\tcase 'v':\n\t\t    parse_version(&scanner, &ctx);\n\t\t    break;\n\t\tcase 13:\n\t\tcase 10:\n\t\t    pj_scan_get_char(&scanner);\n\t\t    /* Allow empty newlines at the end of the message */\n\t\t    while (!pj_scan_is_eof(&scanner)) {\n\t\t\tif (*scanner.curptr != 13 && *scanner.curptr != 10) {\n\t\t\t    ctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\t    on_scanner_error(&scanner);\n\t\t\t}\n\t\t\tpj_scan_get_char(&scanner);\n\t\t    }\n\t\t    break;\n\t\tcase 'b':\n\t\t    bandw = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_bandw);\n\t\t    parse_bandwidth_info(&scanner, bandw, &ctx);\n\t\t    if (media) {\n\t\t\tif (media->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    media->bandw[media->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding media bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    } else {\n\t\t\tif (session->bandw_count < PJMEDIA_MAX_SDP_BANDW)\n\t\t\t    session->bandw[session->bandw_count++] = bandw;\n\t\t\telse\n\t\t\t    PJ_PERROR(2, (THIS_FILE, PJ_ETOOMANY,\n\t\t\t\t\t  \"Error adding session bandwidth \"\n\t\t\t\t\t  \"info, info is ignored\"));\n\t\t    }\n\t\t    break;\n\t\tdefault:\n\t\t    if (cur_name >= 'a' && cur_name <= 'z')\n\t\t\tparse_generic_line(&scanner, &dummy, &ctx);\n\t\t    else  {\n\t\t\tctx.last_error = PJMEDIA_SDP_EINSDP;\n\t\t\ton_scanner_error(&scanner);\n\t\t    }\n\t\t    break;\n\t\t}\n\t}\n\n\tctx.last_error = PJ_SUCCESS;\n\n    }\n    PJ_CATCH_ANY {\t\t\n\tPJ_PERROR(4, (THIS_FILE, ctx.last_error,\n\t\t      \"Error parsing SDP in line %d col %d\",\n\t\t      scanner.line, pj_scan_get_col(&scanner)));\n\n\tsession = NULL;\n\n\tpj_assert(ctx.last_error != PJ_SUCCESS);\n    }\n    PJ_END;\n\n    pj_scan_fini(&scanner);\n\n    if (session)\n\tapply_media_direction(session);\n\n    *p_sdp = session;\n    return ctx.last_error;\n}\n\n/*\n * Print SDP description.\n */\nPJ_DEF(int) pjmedia_sdp_print( const pjmedia_sdp_session *desc, \n\t\t\t       char *buf, pj_size_t size)\n{\n    return print_session(desc, buf, size);\n}\n\n\n/*\n * Clone session\n */\nPJ_DEF(pjmedia_sdp_session*) pjmedia_sdp_session_clone( pj_pool_t *pool,\n\t\t\t   \t\t\tconst pjmedia_sdp_session *rhs)\n{\n    pjmedia_sdp_session *sess;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    sess = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_session);\n    PJ_ASSERT_RETURN(sess != NULL, NULL);\n\n    /* Clone origin line. */\n    pj_strdup(pool, &sess->origin.user, &rhs->origin.user);\n    sess->origin.id = rhs->origin.id;\n    sess->origin.version = rhs->origin.version;\n    pj_strdup(pool, &sess->origin.net_type, &rhs->origin.net_type);\n    pj_strdup(pool, &sess->origin.addr_type, &rhs->origin.addr_type);\n    pj_strdup(pool, &sess->origin.addr, &rhs->origin.addr);\n\n    /* Clone subject line. */\n    pj_strdup(pool, &sess->name, &rhs->name);\n\n    /* Clone connection line */\n    if (rhs->conn) {\n\tsess->conn = pjmedia_sdp_conn_clone(pool, rhs->conn);\n\tPJ_ASSERT_RETURN(sess->conn != NULL, NULL);\n    }\n\n    /* Duplicate bandwidth info */\n    sess->bandw_count = rhs->bandw_count;\n    for (i=0; i<rhs->bandw_count; ++i) {\n\tsess->bandw[i] = pjmedia_sdp_bandw_clone(pool, rhs->bandw[i]);\n    }\n\n    /* Clone time line. */\n    sess->time.start = rhs->time.start;\n    sess->time.stop = rhs->time.stop;\n\n    /* Duplicate session attributes. */\n    sess->attr_count = rhs->attr_count;\n    for (i=0; i<rhs->attr_count; ++i) {\n\tsess->attr[i] = pjmedia_sdp_attr_clone(pool, rhs->attr[i]);\n    }\n\n    /* Duplicate media descriptors. */\n    sess->media_count = rhs->media_count;\n    for (i=0; i<rhs->media_count; ++i) {\n\tsess->media[i] = pjmedia_sdp_media_clone(pool, rhs->media[i]);\n    }\n\n    return sess;\n}\n\n\n#define CHECK(exp,ret)\tdo {\t\t\t\\\n\t\t\t    /*pj_assert(exp);*/\t\\\n\t\t\t    if (!(exp))\t\t\\\n\t\t\t\treturn ret;\t\\\n\t\t\t} while (0)\n\n/* Validate SDP connetion info. */\nstatic pj_status_t validate_sdp_conn(const pjmedia_sdp_conn *c)\n{\n    CHECK( c, PJ_EINVAL);\n    CHECK( pj_strcmp2(&c->net_type, \"IN\")==0, PJMEDIA_SDP_EINCONN);\n    CHECK( pj_strcmp2(&c->addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&c->addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINCONN);\n    CHECK( c->addr.slen != 0, PJMEDIA_SDP_EINCONN);\n\n    return PJ_SUCCESS;\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate(const pjmedia_sdp_session *sdp)\n{\n    return pjmedia_sdp_validate2(sdp, PJ_TRUE);\n}\n\n\n/* Validate SDP session descriptor. */\nPJ_DEF(pj_status_t) pjmedia_sdp_validate2(const pjmedia_sdp_session *sdp,\n\t\t\t\t\t  pj_bool_t strict)\n{\n    unsigned i;\n    const pj_str_t STR_RTPMAP = { \"rtpmap\", 6 };\n\n    CHECK( sdp != NULL, PJ_EINVAL);\n\n    /* Validate origin line. */\n    CHECK( sdp->origin.user.slen != 0, PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.net_type, \"IN\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( pj_strcmp2(&sdp->origin.addr_type, \"IP4\")==0 ||\n\t   pj_strcmp2(&sdp->origin.addr_type, \"IP6\")==0, \n\t   PJMEDIA_SDP_EINORIGIN);\n    CHECK( sdp->origin.addr.slen != 0, PJMEDIA_SDP_EINORIGIN);\n\n    /* Validate subject line. */\n    CHECK( sdp->name.slen != 0, PJMEDIA_SDP_EINNAME);\n\n    /* Ignore start and stop time. */\n\n    /* If session level connection info is present, validate it. */\n    if (sdp->conn) {\n\tpj_status_t status = validate_sdp_conn(sdp->conn);\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Validate each media. */\n    for (i=0; i<sdp->media_count; ++i) {\n\tconst pjmedia_sdp_media *m = sdp->media[i];\n\tunsigned j;\n\n\t/* Validate the m= line. */\n\tCHECK( m->desc.media.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.transport.slen != 0, PJMEDIA_SDP_EINMEDIA);\n\tCHECK( m->desc.fmt_count != 0 || m->desc.port==0, PJMEDIA_SDP_ENOFMT);\n\n\t/* If media level connection info is present, validate it. */\n\tif (m->conn) {\n\t    pj_status_t status = validate_sdp_conn(m->conn);\n\t    if (status != PJ_SUCCESS)\n\t\treturn status;\n\t}\n\n\t/* If media doesn't have connection info, then connection info\n\t * must be present in the session.\n\t */\n\tif (m->conn == NULL) {\n\t    if (sdp->conn == NULL)\n\t\tif (strict || m->desc.port != 0)\n\t\t    return PJMEDIA_SDP_EMISSINGCONN;\n\t}\n\n\t/* Verify payload type. */\n\tfor (j=0; j<m->desc.fmt_count; ++j) {\n\n\t    /* Arrgh noo!! Payload type can be non-numeric!!\n\t     * RTC based programs sends \"null\" for instant messaging!\n\t     */\n\t    if (pj_isdigit(*m->desc.fmt[j].ptr)) {\n\t\tunsigned long pt;\n\t\tpj_status_t status = pj_strtoul3(&m->desc.fmt[j], &pt, 10);\n\n\t\t/* Payload type is between 0 and 127. \n\t\t */\n\t\tCHECK( status == PJ_SUCCESS && pt <= 127, PJMEDIA_SDP_EINPT);\n\n\t\t/* If port is not zero, then for each dynamic payload type, an\n\t\t * rtpmap attribute must be specified.\n\t\t */\n\t\tif (m->desc.port != 0 && pt >= 96) {\n\t\t    const pjmedia_sdp_attr *a;\n\n\t\t    a = pjmedia_sdp_media_find_attr(m, &STR_RTPMAP, \n\t\t\t\t\t\t    &m->desc.fmt[j]);\n\t\t    CHECK( a != NULL, PJMEDIA_SDP_EMISSINGRTPMAP);\n\t\t}\n\t    }\n\t}\n    }\n\n    /* Looks good. */\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_transport_cmp( const pj_str_t *t1,\n\t\t\t\t\t       const pj_str_t *t2)\n{\n    pj_uint32_t t1_proto, t2_proto;\n\n    /* Exactly equal? */\n    if (pj_stricmp(t1, t2) == 0)\n\treturn PJ_SUCCESS;\n\n    /* Check if boths are RTP/AVP based */\n    t1_proto = pjmedia_sdp_transport_get_proto(t1);\n    t2_proto = pjmedia_sdp_transport_get_proto(t2);\n    if (PJMEDIA_TP_PROTO_HAS_FLAG(t1_proto, PJMEDIA_TP_PROTO_RTP_AVP) && \n\tPJMEDIA_TP_PROTO_HAS_FLAG(t2_proto, PJMEDIA_TP_PROTO_RTP_AVP))\n    {\n\treturn PJ_SUCCESS;\n    }\n\n    /* Compatible? */\n    //{\n    //\tstatic const pj_str_t ID_RTP_AVP  = { \"RTP/AVP\", 7 };\n    //\tstatic const pj_str_t ID_RTP_SAVP = { \"RTP/SAVP\", 8 };\n    //\tif ((!pj_stricmp(t1, &ID_RTP_AVP) || !pj_stricmp(t1, &ID_RTP_SAVP)) &&\n    //      (!pj_stricmp(t2, &ID_RTP_AVP) || !pj_stricmp(t2, &ID_RTP_SAVP)))\n    //\t    return PJ_SUCCESS;\n    //}\n\n    return PJMEDIA_SDP_ETPORTNOTEQUAL;\n}\n\n\n/*\n * Get media transport info, e.g: protocol and profile.\n */\nPJ_DEF(pj_uint32_t) pjmedia_sdp_transport_get_proto(const pj_str_t *tp)\n{\n    pj_str_t token, rest = {0};\n    pj_ssize_t idx;\n\n    PJ_ASSERT_RETURN(tp, PJMEDIA_TP_PROTO_NONE);\n\n    idx = pj_strtok2(tp, \"/\", &token, 0);\n    if (idx != tp->slen)\n\tpj_strset(&rest, tp->ptr + token.slen + 1, tp->slen - token.slen - 1);\n\n    if (pj_stricmp2(&token, \"RTP\") == 0) {\n\t/* Starts with \"RTP\" */\n\n\t/* RTP/AVP */\n\tif (pj_stricmp2(&rest, \"AVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVP;\n\n\t/* RTP/SAVP */\n\tif (pj_stricmp2(&rest, \"SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVP;\n\n\t/* RTP/AVPF */\n\tif (pj_stricmp2(&rest, \"AVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_AVPF;\n\n\t/* RTP/SAVPF */\n\tif (pj_stricmp2(&rest, \"SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_RTP_SAVPF;\n\n    } else if (pj_stricmp2(&token, \"UDP\") == 0) {\n\t/* Starts with \"UDP\" */\n\n\t/* Plain UDP */\n\tif (rest.slen == 0)\n\t    return PJMEDIA_TP_PROTO_UDP;\n\n\t/* DTLS-SRTP */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVP\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTP;\n\n\t/* DTLS-SRTP with RTCP-FB */\n\tif (pj_stricmp2(&rest, \"TLS/RTP/SAVPF\") == 0)\n\t    return PJMEDIA_TP_PROTO_DTLS_SRTPF;\n    }\n\n    /* Unknown transport */\n    return PJMEDIA_TP_PROTO_UNKNOWN;\n}\n\n\nPJ_DEF(pj_status_t) pjmedia_sdp_media_deactivate(pj_pool_t *pool,\n\t\t\t\t\t\t pjmedia_sdp_media *m)\n{\n    PJ_ASSERT_RETURN(m, PJ_EINVAL);\n    PJ_UNUSED_ARG(pool);\n\n    /* Set port to zero */\n    m->desc.port = 0;\n\n    /* And remove attributes */\n    m->attr_count = 0;\n\n    return PJ_SUCCESS;\n}\n\n\nPJ_DEF(pjmedia_sdp_media*) pjmedia_sdp_media_clone_deactivate(\n\t\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\t\tconst pjmedia_sdp_media *rhs)\n{\n    unsigned int i;\n    pjmedia_sdp_media *m;\n\n    PJ_ASSERT_RETURN(pool && rhs, NULL);\n\n    m = PJ_POOL_ZALLOC_T(pool, pjmedia_sdp_media);\n    pj_memcpy(m, rhs, sizeof(*m));\n\n    /* Clone the media line only */\n    pj_strdup (pool, &m->desc.media, &rhs->desc.media);\n    pj_strdup (pool, &m->desc.transport, &rhs->desc.transport);\n    for (i=0; i<rhs->desc.fmt_count; ++i)\n\tpj_strdup(pool, &m->desc.fmt[i], &rhs->desc.fmt[i]);\n\n    if (rhs->conn) {\n\tm->conn = pjmedia_sdp_conn_clone (pool, rhs->conn);\n\tPJ_ASSERT_RETURN(m->conn != NULL, NULL);\n    }\n\n    m->bandw_count = rhs->bandw_count;\n    for (i=0; i < rhs->bandw_count; ++i) {\n\tm->bandw[i] = pjmedia_sdp_bandw_clone (pool, rhs->bandw[i]);\n\tPJ_ASSERT_RETURN(m->bandw[i] != NULL, NULL);\n    }\n\n    /* And deactivate it */\n    pjmedia_sdp_media_deactivate(pool, m);\n\n    return m;\n}\n"], "filenames": ["pjlib-util/src/pjlib-util/scanner.c", "pjmedia/src/pjmedia/rtp.c", "pjmedia/src/pjmedia/sdp.c"], "buggy_code_start_loc": [198, 190, 986], "buggy_code_end_loc": [641, 398, 1246], "fixing_code_start_loc": [198, 191, 986], "fixing_code_end_loc": [653, 400, 1250], "type": "CWE-120", "message": "PJSIP is a free and open source multimedia communication library written in C. In versions of PJSIP prior to 2.13 the PJSIP parser, PJMEDIA RTP decoder, and PJMEDIA SDP parser are affeced by a buffer overflow vulnerability. Users connecting to untrusted clients are at risk. This issue has been patched and is available as commit c4d3498 in the master branch and will be included in releases 2.13 and later. Users are advised to upgrade. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-39244", "sourceIdentifier": "security-advisories@github.com", "published": "2022-10-06T18:16:11.207", "lastModified": "2023-02-24T00:15:11.847", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in C. In versions of PJSIP prior to 2.13 the PJSIP parser, PJMEDIA RTP decoder, and PJMEDIA SDP parser are affeced by a buffer overflow vulnerability. Users connecting to untrusted clients are at risk. This issue has been patched and is available as commit c4d3498 in the master branch and will be included in releases 2.13 and later. Users are advised to upgrade. There are no known workarounds for this issue."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en C. En las versiones de PJSIP anteriores a 2.13, el analizador de PJSIP, el descodificador RTP de PJMEDIA y el analizador SDP de PJMEDIA est\u00e1n afectados por una vulnerabilidad de desbordamiento de b\u00fafer. Los usuarios que son conectados a clientes no confiables est\u00e1n en riesgo. Este problema ha sido parcheado y est\u00e1 disponible como commit c4d3498 en la rama master y ser\u00e1 incluida en las versiones 2.13 y posteriores. Es recomendado a usuarios actualizar. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.6, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pjsip:pjsip:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.13", "matchCriteriaId": "9753C329-1C55-4E81-A6C4-32BD8A61F48D"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/c4d34984ec92b3d5252a7d5cddd85a1d3a8001ae", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-fq45-m3f7-3mhj", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/02/msg00029.html", "source": "security-advisories@github.com"}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5358", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/c4d34984ec92b3d5252a7d5cddd85a1d3a8001ae"}}