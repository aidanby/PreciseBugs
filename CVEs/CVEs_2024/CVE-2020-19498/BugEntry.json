{"buggy_code": ["/*\n * HEIF codec.\n * Copyright (c) 2017 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libheif.\n *\n * libheif is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libheif is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libheif.  If not, see <http://www.gnu.org/licenses/>.\n */\n#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif\n\n#include \"box.h\"\n#include \"heif_limits.h\"\n\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\n\nusing namespace heif;\n\n\nheif::Error heif::Error::Ok(heif_error_Ok);\n\n\n\nstatic int32_t gcd(int a, int b)\n{\n  if (a == 0 && b == 0) {\n    return 1;\n  }\n\n  if (a == 0) return b;\n  if (b == 0) return a;\n\n  int32_t h;\n\n  do {\n    h = a % b;\n    a = b;\n    b = h;\n  } while (b != 0);\n\n  return a;\n}\n\n\nFraction::Fraction(int32_t num,int32_t den)\n{\n  int32_t g = gcd(num, den);\n\n  // these strange tests are for catching the case that we divide -2147483648 by -1,\n  // which would exceed the maximum positive value by one.\n\n  if (num == std::numeric_limits<int32_t>::min() && g == -1) {\n    num++;\n  }\n\n  if (den == std::numeric_limits<int32_t>::min() && g == -1) {\n    den++;\n  }\n\n\n  numerator = num / g;\n  denominator = den / g;\n\n\n  // Reduce resolution of fraction until we are in a safe range.\n  // We need this as adding fractions may lead to very large denominators\n  // (e.g. 0x10000 * 0x10000 > 0x100000000 -> overflow, leading to integer 0)\n\n  while (denominator > MAX_FRACTION_DENOMINATOR) {\n    numerator >>= 1;\n    denominator >>= 1;\n  }\n}\n\nFraction Fraction::operator+(const Fraction& b) const\n{\n  if (denominator == b.denominator) {\n    return Fraction { numerator + b.numerator, denominator };\n  }\n  else {\n    return Fraction { numerator * b.denominator + b.numerator * denominator,\n        denominator * b.denominator };\n  }\n}\n\nFraction Fraction::operator-(const Fraction& b) const\n{\n  if (denominator == b.denominator) {\n    return Fraction { numerator - b.numerator, denominator };\n  }\n  else {\n    return Fraction { numerator * b.denominator - b.numerator * denominator,\n        denominator * b.denominator };\n  }\n}\n\nFraction Fraction::operator-(int v) const\n{\n  return Fraction { numerator - v * denominator, denominator };\n}\n\nFraction Fraction::operator/(int v) const\n{\n  return Fraction { numerator, denominator*v };\n}\n\nint Fraction::round_down() const\n{\n  return numerator / denominator;\n}\n\nint Fraction::round_up() const\n{\n  return (numerator + denominator - 1)/denominator;\n}\n\nint Fraction::round() const\n{\n  return (numerator + denominator/2)/denominator;\n}\n\nbool Fraction::is_valid() const\n{\n  return denominator != 0;\n}\n\nuint32_t from_fourcc(const char* string)\n{\n  return ((string[0]<<24) |\n          (string[1]<<16) |\n          (string[2]<< 8) |\n          (string[3]));\n}\n\nstatic std::string to_fourcc(uint32_t code)\n{\n  std::string str(\"    \");\n  str[0] = static_cast<char>((code>>24) & 0xFF);\n  str[1] = static_cast<char>((code>>16) & 0xFF);\n  str[2] = static_cast<char>((code>> 8) & 0xFF);\n  str[3] = static_cast<char>((code>> 0) & 0xFF);\n\n  return str;\n}\n\n\nheif::BoxHeader::BoxHeader()\n{\n}\n\n\nstd::vector<uint8_t> heif::BoxHeader::get_type() const\n{\n  if (m_type == fourcc(\"uuid\")) {\n    return m_uuid_type;\n  }\n  else {\n    std::vector<uint8_t> type(4);\n    type[0] = static_cast<uint8_t>((m_type>>24) & 0xFF);\n    type[1] = static_cast<uint8_t>((m_type>>16) & 0xFF);\n    type[2] = static_cast<uint8_t>((m_type>> 8) & 0xFF);\n    type[3] = static_cast<uint8_t>((m_type>> 0) & 0xFF);\n    return type;\n  }\n}\n\n\nstd::string heif::BoxHeader::get_type_string() const\n{\n  if (m_type == fourcc(\"uuid\")) {\n    // 8-4-4-4-12\n\n    std::ostringstream sstr;\n    sstr << std::hex;\n    sstr << std::setfill('0');\n    sstr << std::setw(2);\n\n    for (int i=0;i<16;i++) {\n      if (i==4 || i==6 || i==8 || i==10) {\n        sstr << '-';\n      }\n\n      sstr << ((int)m_uuid_type[i]);\n    }\n\n    return sstr.str();\n  }\n  else {\n    return to_fourcc(m_type);\n  }\n}\n\n\nheif::Error heif::BoxHeader::parse(BitstreamRange& range)\n{\n  StreamReader::grow_status status;\n  status = range.wait_for_available_bytes(8);\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  m_size = range.read32();\n  m_type = range.read32();\n\n  m_header_size = 8;\n\n  if (m_size==1) {\n    status = range.wait_for_available_bytes(8);\n    if (status != StreamReader::size_reached) {\n      // TODO: return recoverable error at timeout\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_End_of_data);\n    }\n\n    uint64_t high = range.read32();\n    uint64_t low  = range.read32();\n\n    m_size = (high<<32) | low;\n    m_header_size += 8;\n\n    std::stringstream sstr;\n    sstr << \"Box size \" << m_size << \" exceeds security limit.\";\n\n    if (m_size > MAX_LARGE_BOX_SIZE) {\n      return Error(heif_error_Memory_allocation_error,\n                   heif_suberror_Security_limit_exceeded,\n                   sstr.str());\n    }\n  }\n\n  if (m_type==fourcc(\"uuid\")) {\n    status = range.wait_for_available_bytes(16);\n    if (status != StreamReader::size_reached) {\n      // TODO: return recoverable error at timeout\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_End_of_data);\n    }\n\n    if (range.prepare_read(16)) {\n      m_uuid_type.resize(16);\n      range.get_istream()->read((char*)m_uuid_type.data(), 16);\n    }\n\n    m_header_size += 16;\n  }\n\n  return range.get_error();\n}\n\n\nsize_t heif::BoxHeader::reserve_box_header_space(StreamWriter& writer) const\n{\n  size_t start_pos = writer.get_position();\n\n  int header_size = is_full_box_header() ? (8+4) : 8;\n\n  writer.skip(header_size);\n\n  return start_pos;\n}\n\n\nheif::Error heif::BoxHeader::prepend_header(StreamWriter& writer, size_t box_start) const\n{\n  const int reserved_header_size = is_full_box_header() ? (8+4) : 8;\n\n\n  // determine header size\n\n  int header_size = 0;\n\n  header_size += 8; // normal header size\n\n  if (is_full_box_header()) {\n    header_size += 4;\n  }\n\n  if (m_type==fourcc(\"uuid\")) {\n    header_size += 16;\n  }\n\n  bool large_size = false;\n\n  size_t data_size = writer.data_size() - box_start - reserved_header_size;\n\n  if (data_size + header_size > 0xFFFFFFFF) {\n    header_size += 8;\n    large_size = true;\n  }\n\n  size_t box_size = data_size + header_size;\n\n\n  // --- write header\n\n  writer.set_position(box_start);\n  assert(header_size >= reserved_header_size);\n  writer.insert(header_size - reserved_header_size);\n\n  if (large_size) {\n    writer.write32(1);\n  }\n  else {\n    assert(box_size <= 0xFFFFFFFF);\n    writer.write32( (uint32_t)box_size );\n  }\n\n  writer.write32( m_type );\n\n  if (large_size) {\n    writer.write64( box_size );\n  }\n\n  if (m_type==fourcc(\"uuid\")) {\n    assert(m_uuid_type.size()==16);\n    writer.write(m_uuid_type);\n  }\n\n  if (is_full_box_header()) {\n    assert((m_flags & ~0x00FFFFFF) == 0);\n\n    writer.write32( (m_version << 24) | m_flags );\n  }\n\n  writer.set_position_to_end();  // Note: should we move to the end of the box after writing the header?\n\n  return Error::Ok;\n}\n\n\nstd::string BoxHeader::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << indent << \"Box: \" << get_type_string() << \" -----\\n\";\n  sstr << indent << \"size: \" << get_box_size() << \"   (header size: \" << get_header_size() << \")\\n\";\n\n  if (m_is_full_box) {\n    sstr << indent << \"version: \" << ((int)m_version) << \"\\n\"\n         << indent << \"flags: \" << std::hex << m_flags << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nError Box::parse(BitstreamRange& range)\n{\n  // skip box\n\n  if (get_box_size() == size_until_end_of_file) {\n    range.skip_to_end_of_file();\n  }\n  else {\n    uint64_t content_size = get_box_size() - get_header_size();\n    if (range.prepare_read(content_size)) {\n      if (content_size > MAX_BOX_SIZE) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_Invalid_box_size);\n      }\n\n      range.get_istream()->seek_cur(get_box_size() - get_header_size());\n    }\n  }\n\n  // Note: seekg() clears the eof flag and it will not be set again afterwards,\n  // hence we have to test for the fail flag.\n\n  return range.get_error();\n}\n\n\nError BoxHeader::parse_full_box_header(BitstreamRange& range)\n{\n  uint32_t data = range.read32();\n  m_version = static_cast<uint8_t>(data >> 24);\n  m_flags = data & 0x00FFFFFF;\n  m_is_full_box = true;\n\n  m_header_size += 4;\n\n  return range.get_error();\n}\n\n\nError Box::read(BitstreamRange& range, std::shared_ptr<heif::Box>* result)\n{\n  BoxHeader hdr;\n  Error err = hdr.parse(range);\n  if (err) {\n    return err;\n  }\n\n  if (range.error()) {\n    return range.get_error();\n  }\n\n  std::shared_ptr<Box> box;\n\n  switch (hdr.get_short_type()) {\n  case fourcc(\"ftyp\"):\n    box = std::make_shared<Box_ftyp>(hdr);\n    break;\n\n  case fourcc(\"meta\"):\n    box = std::make_shared<Box_meta>(hdr);\n    break;\n\n  case fourcc(\"hdlr\"):\n    box = std::make_shared<Box_hdlr>(hdr);\n    break;\n\n  case fourcc(\"pitm\"):\n    box = std::make_shared<Box_pitm>(hdr);\n    break;\n\n  case fourcc(\"iloc\"):\n    box = std::make_shared<Box_iloc>(hdr);\n    break;\n\n  case fourcc(\"iinf\"):\n    box = std::make_shared<Box_iinf>(hdr);\n    break;\n\n  case fourcc(\"infe\"):\n    box = std::make_shared<Box_infe>(hdr);\n    break;\n\n  case fourcc(\"iprp\"):\n    box = std::make_shared<Box_iprp>(hdr);\n    break;\n\n  case fourcc(\"ipco\"):\n    box = std::make_shared<Box_ipco>(hdr);\n    break;\n\n  case fourcc(\"ipma\"):\n    box = std::make_shared<Box_ipma>(hdr);\n    break;\n\n  case fourcc(\"ispe\"):\n    box = std::make_shared<Box_ispe>(hdr);\n    break;\n\n  case fourcc(\"auxC\"):\n    box = std::make_shared<Box_auxC>(hdr);\n    break;\n\n  case fourcc(\"irot\"):\n    box = std::make_shared<Box_irot>(hdr);\n    break;\n\n  case fourcc(\"imir\"):\n    box = std::make_shared<Box_imir>(hdr);\n    break;\n\n  case fourcc(\"clap\"):\n    box = std::make_shared<Box_clap>(hdr);\n    break;\n\n  case fourcc(\"iref\"):\n    box = std::make_shared<Box_iref>(hdr);\n    break;\n\n  case fourcc(\"hvcC\"):\n    box = std::make_shared<Box_hvcC>(hdr);\n    break;\n\n  case fourcc(\"idat\"):\n    box = std::make_shared<Box_idat>(hdr);\n    break;\n\n  case fourcc(\"grpl\"):\n    box = std::make_shared<Box_grpl>(hdr);\n    break;\n\n  case fourcc(\"dinf\"):\n    box = std::make_shared<Box_dinf>(hdr);\n    break;\n\n  case fourcc(\"dref\"):\n    box = std::make_shared<Box_dref>(hdr);\n    break;\n\n  case fourcc(\"url \"):\n    box = std::make_shared<Box_url>(hdr);\n    break;\n\n  case fourcc(\"colr\"):\n    box = std::make_shared<Box_colr>(hdr);\n    break;\n\n  case fourcc(\"pixi\"):\n    box = std::make_shared<Box_pixi>(hdr);\n    break;\n\n  default:\n    box = std::make_shared<Box>(hdr);\n    break;\n  }\n\n  if (hdr.get_box_size() < hdr.get_header_size()) {\n    std::stringstream sstr;\n    sstr << \"Box size (\" << hdr.get_box_size() << \" bytes) smaller than header size (\"\n         << hdr.get_header_size() << \" bytes)\";\n\n    // Sanity check.\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size,\n                 sstr.str());\n  }\n\n\n  if (range.get_nesting_level() > MAX_BOX_NESTING_LEVEL) {\n    return Error(heif_error_Memory_allocation_error,\n                 heif_suberror_Security_limit_exceeded,\n                 \"Security limit for maximum nesting of boxes has been exceeded\");\n  }\n\n\n  auto status = range.wait_for_available_bytes( hdr.get_box_size() - hdr.get_header_size() );\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n\n  // Security check: make sure that box size does not exceed int64 size.\n\n  if (hdr.get_box_size() > std::numeric_limits<int64_t>::max()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size);\n  }\n\n  int64_t box_size = static_cast<int64_t>(hdr.get_box_size());\n  int64_t box_size_without_header = box_size - hdr.get_header_size();\n\n  // Box size may not be larger than remaining bytes in parent box.\n\n  if (range.get_remaining_bytes() < box_size_without_header) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size);\n  }\n\n\n  // Create child bitstream range and read box from that range.\n\n  BitstreamRange boxrange(range.get_istream(),\n                          box_size_without_header,\n                          &range);\n\n  err = box->parse(boxrange);\n  if (err == Error::Ok) {\n    *result = std::move(box);\n  }\n\n  boxrange.skip_to_end_of_box();\n\n  return err;\n}\n\n\nstd::string Box::dump(Indent& indent ) const\n{\n  std::ostringstream sstr;\n\n  sstr << BoxHeader::dump(indent);\n\n  return sstr.str();\n}\n\n\nError Box::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  Error err = write_children(writer);\n\n  prepend_header(writer, box_start);\n\n  return err;\n}\n\n\nstd::shared_ptr<Box> Box::get_child_box(uint32_t short_type) const\n{\n  for (auto& box : m_children) {\n    if (box->get_short_type()==short_type) {\n      return box;\n    }\n  }\n\n  return nullptr;\n}\n\n\nstd::vector<std::shared_ptr<Box>> Box::get_child_boxes(uint32_t short_type) const\n{\n  std::vector<std::shared_ptr<Box>> result;\n  for (auto& box : m_children) {\n    if (box->get_short_type()==short_type) {\n      result.push_back(box);\n    }\n  }\n\n  return result;\n}\n\n\nError Box::read_children(BitstreamRange& range, int max_number)\n{\n  int count = 0;\n\n  while (!range.eof() && !range.error()) {\n    std::shared_ptr<Box> box;\n    Error error = Box::read(range, &box);\n    if (error != Error::Ok) {\n      return error;\n    }\n\n    if (m_children.size() > MAX_CHILDREN_PER_BOX) {\n      std::stringstream sstr;\n      sstr << \"Maximum number of child boxes \" << MAX_CHILDREN_PER_BOX << \" exceeded.\";\n\n      // Sanity check.\n      return Error(heif_error_Memory_allocation_error,\n                   heif_suberror_Security_limit_exceeded,\n                   sstr.str());\n    }\n\n    m_children.push_back(std::move(box));\n\n\n    // count the new child and end reading new children when we reached the expected number\n\n    count++;\n\n    if (max_number != READ_CHILDREN_ALL &&\n        count == max_number) {\n      break;\n    }\n  }\n\n  return range.get_error();\n}\n\n\nError Box::write_children(StreamWriter& writer) const\n{\n  for (const auto& child : m_children) {\n    Error err = child->write(writer);\n    if (err) {\n      return err;\n    }\n  }\n\n  return Error::Ok;\n}\n\n\nstd::string Box::dump_children(Indent& indent) const\n{\n  std::ostringstream sstr;\n\n  bool first = true;\n\n  indent++;\n  for (const auto& childBox : m_children) {\n    if (first) {\n      first=false;\n    }\n    else {\n      sstr << indent << \"\\n\";\n    }\n\n    sstr << childBox->dump(indent);\n  }\n  indent--;\n\n  return sstr.str();\n}\n\n\nvoid Box::derive_box_version_recursive()\n{\n  derive_box_version();\n\n  for (auto& child : m_children) {\n    child->derive_box_version_recursive();\n  }\n}\n\n\nError Box_ftyp::parse(BitstreamRange& range)\n{\n  m_major_brand = range.read32();\n  m_minor_version = range.read32();\n\n  if (get_box_size() <= get_header_size() + 8) {\n    // Sanity check.\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size,\n                 \"ftyp box too small (less than 8 bytes)\");\n  }\n\n  uint64_t n_minor_brands = (get_box_size() - get_header_size() - 8) / 4;\n\n  for (uint64_t i=0;i<n_minor_brands && !range.error();i++) {\n    m_compatible_brands.push_back( range.read32() );\n  }\n\n  return range.get_error();\n}\n\n\nbool Box_ftyp::has_compatible_brand(uint32_t brand) const\n{\n  for (uint32_t b : m_compatible_brands) {\n    if (b==brand) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\nstd::string Box_ftyp::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n\n  sstr << BoxHeader::dump(indent);\n\n  sstr << indent << \"major brand: \" << to_fourcc(m_major_brand) << \"\\n\"\n       << indent << \"minor version: \" << m_minor_version << \"\\n\"\n       << indent << \"compatible brands: \";\n\n  bool first=true;\n  for (uint32_t brand : m_compatible_brands) {\n    if (first) { first=false; }\n    else { sstr << ','; }\n\n    sstr << to_fourcc(brand);\n  }\n  sstr << \"\\n\";\n\n  return sstr.str();\n}\n\n\nvoid Box_ftyp::add_compatible_brand(uint32_t brand)\n{\n  // TODO: check whether brand already exists in the list\n\n  m_compatible_brands.push_back(brand);\n}\n\n\nError Box_ftyp::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write32(m_major_brand);\n  writer.write32(m_minor_version);\n\n  for (uint32_t b : m_compatible_brands) {\n    writer.write32(b);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_meta::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  /*\n  uint64_t boxSizeLimit;\n  if (get_box_size() == BoxHeader::size_until_end_of_file) {\n    boxSizeLimit = sizeLimit;\n  }\n  else {\n    boxSizeLimit = get_box_size() - get_header_size();\n  }\n  */\n\n  return read_children(range);\n}\n\n\nstd::string Box_meta::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_hdlr::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_pre_defined = range.read32();\n  m_handler_type = range.read32();\n\n  for (int i=0;i<3;i++) {\n    m_reserved[i] = range.read32();\n  }\n\n  m_name = range.read_string();\n\n  return range.get_error();\n}\n\n\nstd::string Box_hdlr::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << indent << \"pre_defined: \" << m_pre_defined << \"\\n\"\n       << indent << \"handler_type: \" << to_fourcc(m_handler_type) << \"\\n\"\n       << indent << \"name: \" << m_name << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_hdlr::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write32(m_pre_defined);\n  writer.write32(m_handler_type);\n\n  for (int i=0;i<3;i++) {\n    writer.write32(m_reserved[i]);\n  }\n\n  writer.write(m_name);\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\n\nError Box_pitm::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  if (get_version()==0) {\n    m_item_ID = range.read16();\n  }\n  else {\n    m_item_ID = range.read32();\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_pitm::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << indent << \"item_ID: \" << m_item_ID << \"\\n\";\n\n  return sstr.str();\n}\n\n\nvoid Box_pitm::derive_box_version()\n{\n  if (m_item_ID <= 0xFFFF) {\n    set_version(0);\n  }\n  else {\n    set_version(1);\n  }\n}\n\n\nError Box_pitm::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  if (get_version()==0) {\n    assert(m_item_ID <= 0xFFFF);\n    writer.write16((uint16_t)m_item_ID);\n  }\n  else {\n    writer.write32(m_item_ID);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_iloc::parse(BitstreamRange& range)\n{\n  /*\n  printf(\"box size: %d\\n\",get_box_size());\n  printf(\"header size: %d\\n\",get_header_size());\n  printf(\"start limit: %d\\n\",sizeLimit);\n  */\n\n  parse_full_box_header(range);\n\n  uint16_t values4 = range.read16();\n\n  int offset_size = (values4 >> 12) & 0xF;\n  int length_size = (values4 >>  8) & 0xF;\n  int base_offset_size = (values4 >> 4) & 0xF;\n  int index_size = 0;\n\n  if (get_version()>1) {\n    index_size = (values4 & 0xF);\n  }\n\n  int item_count;\n  if (get_version()<2) {\n    item_count = range.read16();\n  }\n  else {\n    item_count = range.read32();\n  }\n\n  // Sanity check.\n  if (item_count > MAX_ILOC_ITEMS) {\n    std::stringstream sstr;\n    sstr << \"iloc box contains \" << item_count << \" items, which exceeds the security limit of \"\n         << MAX_ILOC_ITEMS << \" items.\";\n\n    return Error(heif_error_Memory_allocation_error,\n                 heif_suberror_Security_limit_exceeded,\n                 sstr.str());\n  }\n\n  for (int i=0;i<item_count;i++) {\n    Item item;\n\n    if (get_version()<2) {\n      item.item_ID = range.read16();\n    }\n    else {\n      item.item_ID = range.read32();\n    }\n\n    if (get_version()>=1) {\n      values4 = range.read16();\n      item.construction_method = (values4 & 0xF);\n    }\n\n    item.data_reference_index = range.read16();\n\n    item.base_offset = 0;\n    if (base_offset_size==4) {\n      item.base_offset = range.read32();\n    }\n    else if (base_offset_size==8) {\n      item.base_offset = ((uint64_t)range.read32()) << 32;\n      item.base_offset |= range.read32();\n    }\n\n    int extent_count = range.read16();\n    // Sanity check.\n    if (extent_count > MAX_ILOC_EXTENTS_PER_ITEM) {\n      std::stringstream sstr;\n      sstr << \"Number of extents in iloc box (\" << extent_count << \") exceeds security limit (\"\n           << MAX_ILOC_EXTENTS_PER_ITEM << \")\\n\";\n\n      return Error(heif_error_Memory_allocation_error,\n                   heif_suberror_Security_limit_exceeded,\n                   sstr.str());\n    }\n\n    for (int e=0;e<extent_count;e++) {\n      Extent extent;\n\n      if (get_version()>1 && index_size>0) {\n        if (index_size==4) {\n          extent.index = range.read32();\n        }\n        else if (index_size==8) {\n          extent.index = ((uint64_t)range.read32()) << 32;\n          extent.index |= range.read32();\n        }\n      }\n\n      extent.offset = 0;\n      if (offset_size==4) {\n        extent.offset = range.read32();\n      }\n      else if (offset_size==8) {\n        extent.offset = ((uint64_t)range.read32()) << 32;\n        extent.offset |= range.read32();\n      }\n\n\n      extent.length = 0;\n      if (length_size==4) {\n        extent.length = range.read32();\n      }\n      else if (length_size==8) {\n        extent.length = ((uint64_t)range.read32()) << 32;\n        extent.length |= range.read32();\n      }\n\n      item.extents.push_back(extent);\n    }\n\n    if (!range.error()) {\n      m_items.push_back(item);\n    }\n  }\n\n  //printf(\"end limit: %d\\n\",sizeLimit);\n\n  return range.get_error();\n}\n\n\nstd::string Box_iloc::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const Item& item : m_items) {\n    sstr << indent << \"item ID: \" << item.item_ID << \"\\n\"\n         << indent << \"  construction method: \" << ((int)item.construction_method) << \"\\n\"\n         << indent << \"  data_reference_index: \" << std::hex\n         << item.data_reference_index << std::dec << \"\\n\"\n         << indent << \"  base_offset: \" << item.base_offset << \"\\n\";\n\n    sstr << indent << \"  extents: \";\n    for (const Extent& extent : item.extents) {\n      sstr << extent.offset << \",\" << extent.length;\n      if (extent.index != 0) {\n        sstr << \";index=\" << extent.index;\n      }\n      sstr << \" \";\n    }\n    sstr << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nError Box_iloc::read_data(const Item& item,\n                          std::shared_ptr<StreamReader> istr,\n                          const std::shared_ptr<Box_idat>& idat,\n                          std::vector<uint8_t>* dest) const\n{\n  //istr.clear();\n\n  for (const auto& extent : item.extents) {\n    if (item.construction_method == 0) {\n\n      // --- security check that we do not allocate too much memory\n\n      size_t old_size = dest->size();\n      if (MAX_MEMORY_BLOCK_SIZE - old_size < extent.length) {\n        std::stringstream sstr;\n        sstr << \"iloc box contained \" << extent.length << \" bytes, total memory size would be \"\n             << (old_size + extent.length) << \" bytes, exceeding the security limit of \"\n             << MAX_MEMORY_BLOCK_SIZE << \" bytes\";\n\n        return Error(heif_error_Memory_allocation_error,\n                     heif_suberror_Security_limit_exceeded,\n                     sstr.str());\n      }\n\n\n      // --- make sure that all data is available\n\n      if (extent.offset > MAX_FILE_POS ||\n          item.base_offset > MAX_FILE_POS ||\n          extent.length > MAX_FILE_POS) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_Security_limit_exceeded,\n                     \"iloc data pointers out of allowed range\");\n      }\n\n      StreamReader::grow_status status = istr->wait_for_file_size(extent.offset + item.base_offset + extent.length);\n      if (status == StreamReader::size_beyond_eof) {\n        // Out-of-bounds\n        // TODO: I think we should not clear this. Maybe we want to try reading again later and\n        // hence should not lose the data already read.\n        dest->clear();\n\n        std::stringstream sstr;\n        sstr << \"Extent in iloc box references data outside of file bounds \"\n             << \"(points to file position \" << extent.offset + item.base_offset << \")\\n\";\n\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_End_of_data,\n                     sstr.str());\n      }\n      else if (status == StreamReader::timeout) {\n        // TODO: maybe we should introduce some 'Recoverable error' instead of 'Invalid input'\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_End_of_data);\n      }\n\n      // --- move file pointer to start of data\n\n      bool success = istr->seek(extent.offset + item.base_offset);\n      assert(success);\n      (void)success;\n\n\n      // --- read data\n\n      dest->resize(static_cast<size_t>(old_size + extent.length));\n      success = istr->read((char*)dest->data() + old_size, static_cast<size_t>(extent.length));\n      assert(success);\n    }\n    else if (item.construction_method==1) {\n      if (!idat) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_idat_box,\n                     \"idat box referenced in iref box is not present in file\");\n      }\n\n      idat->read_data(istr,\n                      extent.offset + item.base_offset,\n                      extent.length,\n                      *dest);\n    }\n    else {\n      std::stringstream sstr;\n      sstr << \"Item construction method \" << item.construction_method << \" not implemented\";\n      return Error(heif_error_Unsupported_feature,\n                   heif_suberror_No_idat_box,\n                   sstr.str());\n    }\n  }\n\n  return Error::Ok;\n}\n\n\nError Box_iloc::append_data(heif_item_id item_ID,\n                            const std::vector<uint8_t>& data,\n                            uint8_t construction_method)\n{\n  // check whether this item ID already exists\n\n  size_t idx;\n  for (idx=0;idx<m_items.size();idx++) {\n    if (m_items[idx].item_ID == item_ID) {\n      break;\n    }\n  }\n\n  // item does not exist -> add a new one to the end\n\n  if (idx == m_items.size()) {\n    Item item;\n    item.item_ID = item_ID;\n    item.construction_method = construction_method;\n\n    m_items.push_back(item);\n  }\n\n  if (m_items[idx].construction_method != construction_method) {\n    // TODO: return error: construction methods do not match\n  }\n\n  Extent extent;\n  extent.data = data;\n  m_items[idx].extents.push_back( std::move(extent) );\n\n  return Error::Ok;\n}\n\n\nvoid Box_iloc::derive_box_version()\n{\n  int min_version = m_user_defined_min_version;\n\n  if (m_items.size() > 0xFFFF) {\n    min_version = std::max(min_version, 2);\n  }\n\n  m_offset_size = 0;\n  m_length_size = 0;\n  m_base_offset_size = 0;\n  m_index_size = 0;\n\n  for (const auto& item : m_items) {\n    // check item_ID size\n    if (item.item_ID > 0xFFFF) {\n      min_version = std::max(min_version, 2);\n    }\n\n    // check construction method\n    if (item.construction_method != 0) {\n      min_version = std::max(min_version, 1);\n    }\n\n    // base offset size\n    /*\n    if (item.base_offset > 0xFFFFFFFF) {\n      m_base_offset_size = 8;\n    }\n    else if (item.base_offset > 0) {\n      m_base_offset_size = 4;\n    }\n    */\n\n    /*\n    for (const auto& extent : item.extents) {\n      // extent index size\n\n      if (extent.index != 0) {\n        min_version = std::max(min_version, 1);\n        m_index_size = 4;\n      }\n\n      if (extent.index > 0xFFFFFFFF) {\n        m_index_size = 8;\n      }\n\n      // extent offset size\n      if (extent.offset > 0xFFFFFFFF) {\n        m_offset_size = 8;\n      }\n      else {\n        m_offset_size = 4;\n      }\n\n      // extent length size\n      if (extent.length > 0xFFFFFFFF) {\n        m_length_size = 8;\n      }\n      else {\n        m_length_size = 4;\n      }\n    }\n      */\n  }\n\n  m_offset_size = 4;\n  m_length_size = 4;\n  m_base_offset_size = 4; // TODO: or could be 8 if we write >4GB files\n  m_index_size = 0;\n\n  set_version((uint8_t)min_version);\n}\n\n\nError Box_iloc::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  m_iloc_box_start = writer.get_position();\n\n  int nSkip = 0;\n\n  nSkip += 2;\n  nSkip += (get_version()<2) ? 2 : 4; // item_count\n\n  for (const auto& item : m_items) {\n    nSkip += (get_version()<2) ? 2 : 4; // item_ID\n    nSkip += (get_version()>=1) ? 2 : 0; // construction method\n    nSkip += 4 + m_base_offset_size;\n\n    for (const auto& extent : item.extents) {\n      (void)extent;\n\n      if (get_version()>=1) {\n        nSkip += m_index_size;\n      }\n\n      nSkip += m_offset_size + m_length_size;\n    }\n  }\n\n  writer.skip(nSkip);\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_iloc::write_mdat_after_iloc(StreamWriter& writer)\n{\n  // --- compute sum of all mdat data\n\n  size_t sum_mdat_size = 0;\n\n  for (const auto& item : m_items) {\n    if (item.construction_method == 0) {\n      for (const auto& extent : item.extents) {\n        sum_mdat_size += extent.data.size();\n      }\n    }\n  }\n\n  if (sum_mdat_size > 0xFFFFFFFF) {\n    // TODO: box size > 4 GB\n  }\n\n\n  // --- write mdat box\n\n  writer.write32((uint32_t)(sum_mdat_size + 8));\n  writer.write32(fourcc(\"mdat\"));\n\n  for (auto& item : m_items) {\n    item.base_offset = writer.get_position();\n\n    for (auto& extent : item.extents) {\n      extent.offset = writer.get_position() - item.base_offset;\n      extent.length = extent.data.size();\n\n      writer.write(extent.data);\n    }\n  }\n\n\n  // --- patch iloc box\n\n  patch_iloc_header(writer);\n\n  return Error::Ok;\n}\n\n\nvoid Box_iloc::patch_iloc_header(StreamWriter& writer) const\n{\n  size_t old_pos = writer.get_position();\n  writer.set_position(m_iloc_box_start);\n\n  writer.write8((uint8_t)((m_offset_size<<4) | (m_length_size)));\n  writer.write8((uint8_t)((m_base_offset_size<<4) | (m_index_size)));\n\n  if (get_version() < 2) {\n    writer.write16((uint16_t)m_items.size());\n  } else {\n    writer.write32((uint32_t)m_items.size());\n  }\n\n  for (const auto& item : m_items) {\n    if (get_version() < 2) {\n      writer.write16((uint16_t)item.item_ID);\n    } else {\n      writer.write32((uint32_t)item.item_ID);\n    }\n\n    if (get_version() >= 1) {\n      writer.write16(item.construction_method);\n    }\n\n    writer.write16(item.data_reference_index);\n    writer.write(m_base_offset_size, item.base_offset);\n    writer.write16((uint16_t)item.extents.size());\n\n    for (const auto& extent : item.extents) {\n      if (get_version()>=1 && m_index_size > 0) {\n        writer.write(m_index_size, extent.index);\n      }\n\n      writer.write(m_offset_size, extent.offset);\n      writer.write(m_length_size, extent.length);\n    }\n  }\n\n  writer.set_position(old_pos);\n}\n\n\nError Box_infe::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  if (get_version() <= 1) {\n    m_item_ID = range.read16();\n    m_item_protection_index = range.read16();\n\n    m_item_name = range.read_string();\n    m_content_type = range.read_string();\n    m_content_encoding = range.read_string();\n  }\n\n  if (get_version() >= 2) {\n    m_hidden_item = (get_flags() & 1);\n\n    if (get_version() == 2) {\n      m_item_ID = range.read16();\n    }\n    else {\n      m_item_ID = range.read32();\n    }\n\n    m_item_protection_index = range.read16();\n    uint32_t item_type =range.read32();\n    if (item_type != 0) {\n      m_item_type = to_fourcc(item_type);\n    }\n\n    m_item_name = range.read_string();\n    if (item_type == fourcc(\"mime\")) {\n      m_content_type = range.read_string();\n      m_content_encoding = range.read_string();\n    }\n    else if (item_type == fourcc(\"uri \")) {\n      m_item_uri_type = range.read_string();\n    }\n  }\n\n  return range.get_error();\n}\n\n\nvoid Box_infe::derive_box_version()\n{\n  int min_version = 0;\n\n  if (m_hidden_item) {\n    min_version = std::max(min_version, 2);\n  }\n\n  if (m_item_ID > 0xFFFF) {\n    min_version = std::max(min_version, 3);\n  }\n\n\n  if (m_item_type != \"\") {\n    min_version = std::max(min_version, 2);\n  }\n\n  set_version((uint8_t)min_version);\n}\n\n\nvoid Box_infe::set_hidden_item(bool hidden)\n{\n  m_hidden_item = hidden;\n\n  if (m_hidden_item) {\n    set_flags( get_flags() | 1);\n  }\n  else {\n    set_flags( get_flags() & ~1);\n  }\n}\n\nError Box_infe::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  if (get_version() <= 1) {\n    writer.write16((uint16_t)m_item_ID);\n    writer.write16(m_item_protection_index);\n\n    writer.write(m_item_name);\n    writer.write(m_content_type);\n    writer.write(m_content_encoding);\n  }\n\n  if (get_version() >= 2) {\n    if (get_version() == 2) {\n      writer.write16((uint16_t)m_item_ID);\n    }\n    else if (get_version()==3) {\n      writer.write32(m_item_ID);\n    }\n\n    writer.write16(m_item_protection_index);\n\n    if (m_item_type.empty()) {\n      writer.write32(0);\n    }\n    else {\n      writer.write32(from_fourcc(m_item_type.c_str()));\n    }\n\n    writer.write(m_item_name);\n    if (m_item_type == \"mime\") {\n      writer.write(m_content_type);\n      writer.write(m_content_encoding);\n    }\n    else if (m_item_type == \"uri \") {\n      writer.write(m_item_uri_type);\n    }\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nstd::string Box_infe::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"item_ID: \" << m_item_ID << \"\\n\"\n       << indent << \"item_protection_index: \" << m_item_protection_index << \"\\n\"\n       << indent << \"item_type: \" << m_item_type << \"\\n\"\n       << indent << \"item_name: \" << m_item_name << \"\\n\"\n       << indent << \"content_type: \" << m_content_type << \"\\n\"\n       << indent << \"content_encoding: \" << m_content_encoding << \"\\n\"\n       << indent << \"item uri type: \" << m_item_uri_type << \"\\n\"\n       << indent << \"hidden item: \" << std::boolalpha << m_hidden_item << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_iinf::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  int nEntries_size = (get_version() > 0) ? 4 : 2;\n\n  int item_count;\n  if (nEntries_size==2) {\n    item_count = range.read16();\n  }\n  else {\n    item_count = range.read32();\n  }\n\n  if (item_count == 0) {\n    return Error::Ok;\n  }\n\n  // TODO: Only try to read \"item_count\" children.\n  return read_children(range);\n}\n\n\nstd::string Box_iinf::dump(Indent& indent ) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_iprp::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  return read_children(range);\n}\n\n\nvoid Box_iinf::derive_box_version()\n{\n  if (m_children.size() > 0xFFFF) {\n    set_version(1);\n  }\n  else {\n    set_version(0);\n  }\n}\n\n\nError Box_iinf::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  int nEntries_size = (get_version() > 0) ? 4 : 2;\n\n  writer.write(nEntries_size, m_children.size());\n\n\n  Error err = write_children(writer);\n\n  prepend_header(writer, box_start);\n\n  return err;\n}\n\n\nstd::string Box_iprp::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_ipco::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  return read_children(range);\n}\n\n\nstd::string Box_ipco::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\nError color_profile_nclx::parse(BitstreamRange& range)\n{\n  StreamReader::grow_status status;\n  status = range.wait_for_available_bytes(7);\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  m_colour_primaries = range.read16();\n  m_transfer_characteristics = range.read16();\n  m_matrix_coefficients = range.read16();\n  m_full_range_flag = (range.read8() & 0x80 ? true : false);\n\n  return Error::Ok;\n}\n\nError Box_colr::parse(BitstreamRange& range)\n{\n  StreamReader::grow_status status;\n  uint32_t colour_type = range.read32();\n\n  if (colour_type == fourcc(\"nclx\")) {\n    auto color_profile = std::make_shared<color_profile_nclx>();\n    m_color_profile = color_profile;\n    Error err = color_profile->parse(range);\n    if (err) {\n      return err;\n    }\n  } else if (colour_type == fourcc(\"prof\") ||\n             colour_type == fourcc(\"rICC\")) {\n    auto profile_size = get_box_size() - get_header_size() - 4;\n    status = range.wait_for_available_bytes(profile_size);\n    if (status != StreamReader::size_reached) {\n      // TODO: return recoverable error at timeout\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_End_of_data);\n    }\n\n    std::vector<uint8_t> rawData(profile_size);\n    for (size_t i = 0; i < profile_size; i++ ){\n      rawData[i] = range.read8();\n    }\n\n    m_color_profile = std::make_shared<color_profile_raw>(colour_type, rawData);\n  }\n  else {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Unknown_color_profile_type);\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_colr::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"colour_type: \" << to_fourcc(get_color_profile_type()) << \"\\n\";\n\n  if (m_color_profile) {\n    sstr << m_color_profile->dump(indent);\n  }\n  else {\n    sstr << \"no color profile\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nstd::string color_profile_raw::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << indent << \"profile size: \" << m_data.size() << \"\\n\";\n  return sstr.str();\n}\n\n\nstd::string color_profile_nclx::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << indent << \"colour_primaries: \" << m_colour_primaries << \"\\n\"\n       << indent << \"transfer_characteristics: \" << m_transfer_characteristics << \"\\n\"\n       << indent << \"matrix_coefficients: \" << m_matrix_coefficients << \"\\n\"\n       << indent << \"full_range_flag: \" << m_full_range_flag << \"\\n\";\n  return sstr.str();\n}\n\n\nError color_profile_nclx::write(StreamWriter& writer) const\n{\n    writer.write16(m_colour_primaries);\n    writer.write16(m_transfer_characteristics);\n    writer.write16(m_matrix_coefficients);\n    writer.write8(m_full_range_flag ? 0x80 : 0x00);\n\n    return Error::Ok;\n}\n\nError color_profile_raw::write(StreamWriter& writer) const\n{\n  writer.write(m_data);\n\n    return Error::Ok;\n}\n\nError Box_colr::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  assert(m_color_profile);\n\n  writer.write32(m_color_profile->get_type());\n\n  Error err = m_color_profile->write(writer);\n  if (err) {\n    return err;\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\n\nError Box_pixi::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  StreamReader::grow_status status;\n  uint8_t num_channels = range.read8();\n  status = range.wait_for_available_bytes(num_channels);\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  m_bits_per_channel.resize(num_channels);\n  for (int i=0;i<num_channels;i++) {\n    m_bits_per_channel[i] = range.read8();\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_pixi::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"bits_per_channel: \";\n\n  for (size_t i=0;i<m_bits_per_channel.size();i++) {\n    if (i>0) sstr << \",\";\n    sstr << ((int)m_bits_per_channel[i]);\n  }\n\n  sstr << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_pixi::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  if (m_bits_per_channel.size() > 255 ||\n      m_bits_per_channel.empty()) {\n    // TODO: error\n    assert(false);\n  }\n\n  writer.write8((uint8_t)(m_bits_per_channel.size()));\n  for (size_t i=0;i<m_bits_per_channel.size();i++) {\n    writer.write8(m_bits_per_channel[i]);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_ipco::get_properties_for_item_ID(uint32_t itemID,\n                                           const std::shared_ptr<class Box_ipma>& ipma,\n                                           std::vector<Property>& out_properties) const\n{\n  const std::vector<Box_ipma::PropertyAssociation>* property_assoc = ipma->get_properties_for_item_ID(itemID);\n  if (property_assoc == nullptr) {\n    std::stringstream sstr;\n    sstr << \"Item (ID=\" << itemID << \") has no properties assigned to it in ipma box\";\n\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_No_properties_assigned_to_item,\n                 sstr.str());\n  }\n\n  auto allProperties = get_all_child_boxes();\n  for (const  Box_ipma::PropertyAssociation& assoc : *property_assoc) {\n    if (assoc.property_index > allProperties.size()) {\n      std::stringstream sstr;\n      sstr << \"Nonexisting property (index=\" << assoc.property_index << \") for item \"\n           << \" ID=\" << itemID << \" referenced in ipma box\";\n\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_Ipma_box_references_nonexisting_property,\n                   sstr.str());\n    }\n\n    Property prop;\n    prop.essential = assoc.essential;\n\n    if (assoc.property_index > 0) {\n      prop.property = allProperties[assoc.property_index - 1];\n      out_properties.push_back(prop);\n    }\n  }\n\n  return Error::Ok;\n}\n\n\nstd::shared_ptr<Box> Box_ipco::get_property_for_item_ID(heif_item_id itemID,\n                                                        const std::shared_ptr<class Box_ipma>& ipma,\n                                                        uint32_t box_type) const\n{\n  const std::vector<Box_ipma::PropertyAssociation>* property_assoc = ipma->get_properties_for_item_ID(itemID);\n  if (property_assoc == nullptr) {\n    return nullptr;\n  }\n\n  auto allProperties = get_all_child_boxes();\n  for (const  Box_ipma::PropertyAssociation& assoc : *property_assoc) {\n    if (assoc.property_index > allProperties.size() ||\n        assoc.property_index == 0) {\n      return nullptr;\n    }\n\n    auto property = allProperties[assoc.property_index - 1];\n    if (property->get_short_type() == box_type) {\n      return property;\n    }\n  }\n\n  return nullptr;\n}\n\n\nError Box_ispe::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_image_width = range.read32();\n  m_image_height = range.read32();\n\n  return range.get_error();\n}\n\n\nstd::string Box_ispe::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"image width: \" << m_image_width << \"\\n\"\n       << indent << \"image height: \" << m_image_height << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_ispe::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write32(m_image_width);\n  writer.write32(m_image_height);\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_ipma::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  int entry_cnt = range.read32();\n  for (int i = 0; i < entry_cnt && !range.error() && !range.eof(); i++) {\n    Entry entry;\n    if (get_version()<1) {\n      entry.item_ID = range.read16();\n    }\n    else {\n      entry.item_ID = range.read32();\n    }\n\n    int assoc_cnt = range.read8();\n    for (int k=0;k<assoc_cnt;k++) {\n      PropertyAssociation association;\n\n      uint16_t index;\n      if (get_flags() & 1) {\n        index = range.read16();\n        association.essential = !!(index & 0x8000);\n        association.property_index = (index & 0x7fff);\n      }\n      else {\n        index = range.read8();\n        association.essential = !!(index & 0x80);\n        association.property_index = (index & 0x7f);\n      }\n\n      entry.associations.push_back(association);\n    }\n\n    m_entries.push_back(entry);\n  }\n\n  return range.get_error();\n}\n\n\nconst std::vector<Box_ipma::PropertyAssociation>* Box_ipma::get_properties_for_item_ID(uint32_t itemID) const\n{\n  for (const auto& entry : m_entries) {\n    if (entry.item_ID == itemID) {\n      return &entry.associations;\n    }\n  }\n\n  return nullptr;\n}\n\n\nvoid Box_ipma::add_property_for_item_ID(heif_item_id itemID,\n                                        PropertyAssociation assoc)\n{\n  size_t idx;\n  for (idx=0; idx<m_entries.size(); idx++) {\n    if (m_entries[idx].item_ID == itemID) {\n      break;\n    }\n  }\n\n  // if itemID does not exist, add a new entry\n  if (idx == m_entries.size()) {\n    Entry entry;\n    entry.item_ID = itemID;\n    m_entries.push_back(entry);\n  }\n\n  // add the property association\n  m_entries[idx].associations.push_back(assoc);\n}\n\n\nstd::string Box_ipma::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const Entry& entry : m_entries) {\n    sstr << indent << \"associations for item ID: \" << entry.item_ID << \"\\n\";\n    indent++;\n    for (const auto& assoc : entry.associations) {\n      sstr << indent << \"property index: \" << assoc.property_index\n           << \" (essential: \" << std::boolalpha << assoc.essential << \")\\n\";\n    }\n    indent--;\n  }\n\n  return sstr.str();\n}\n\n\nvoid Box_ipma::derive_box_version()\n{\n  int version = 0;\n  bool large_property_indices = false;\n\n  for (const Entry& entry : m_entries) {\n    if (entry.item_ID > 0xFFFF) {\n      version = 1;\n    }\n\n    for (const auto& assoc : entry.associations) {\n      if (assoc.property_index > 0x7F) {\n        large_property_indices=true;\n      }\n    }\n  }\n\n  set_version((uint8_t)version);\n  set_flags(large_property_indices ? 1 : 0);\n}\n\n\nError Box_ipma::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  size_t entry_cnt = m_entries.size();\n  writer.write32((uint32_t)entry_cnt);\n\n  for (const Entry& entry : m_entries) {\n\n    if (get_version()<1) {\n      writer.write16((uint16_t)entry.item_ID);\n    }\n    else {\n      writer.write32(entry.item_ID);\n    }\n\n    size_t assoc_cnt = entry.associations.size();\n    if (assoc_cnt > 0xFF) {\n      // TODO: error, too many associations\n    }\n\n    writer.write8((uint8_t)assoc_cnt);\n\n    for (const PropertyAssociation& association : entry.associations) {\n\n      if (get_flags() & 1) {\n        writer.write16( (uint16_t)((association.essential ? 0x8000 : 0) |\n                                   (association.property_index & 0x7FFF)) );\n      }\n      else {\n        writer.write8( (uint8_t)((association.essential ? 0x80 : 0) |\n                                 (association.property_index & 0x7F)) );\n      }\n    }\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_auxC::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_aux_type = range.read_string();\n\n  while (!range.eof()) {\n    m_aux_subtypes.push_back( range.read8() );\n  }\n\n  return range.get_error();\n}\n\n\nError Box_auxC::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write(m_aux_type);\n\n  for (uint8_t subtype : m_aux_subtypes) {\n    writer.write8(subtype);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nstd::string Box_auxC::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"aux type: \" << m_aux_type << \"\\n\"\n       << indent << \"aux subtypes: \";\n  for (uint8_t subtype : m_aux_subtypes) {\n    sstr << std::hex << std::setw(2) << std::setfill('0') << ((int)subtype) << \" \";\n  }\n\n  sstr << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_irot::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  uint16_t rotation = range.read8();\n  rotation &= 0x03;\n\n  m_rotation = rotation * 90;\n\n  return range.get_error();\n}\n\n\nstd::string Box_irot::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"rotation: \" << m_rotation << \" degrees (CCW)\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_imir::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  uint16_t axis = range.read8();\n  if (axis & 1) {\n    m_axis = MirrorAxis::Horizontal;\n  }\n  else {\n    m_axis = MirrorAxis::Vertical;\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_imir::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"mirror axis: \";\n  switch (m_axis) {\n  case MirrorAxis::Vertical:   sstr << \"vertical\\n\"; break;\n  case MirrorAxis::Horizontal: sstr << \"horizontal\\n\"; break;\n  }\n\n  return sstr.str();\n}\n\n\nError Box_clap::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  m_clean_aperture_width.numerator   = range.read32();\n  m_clean_aperture_width.denominator = range.read32();\n  m_clean_aperture_height.numerator   = range.read32();\n  m_clean_aperture_height.denominator = range.read32();\n  m_horizontal_offset.numerator   = range.read32();\n  m_horizontal_offset.denominator = range.read32();\n  m_vertical_offset.numerator   = range.read32();\n  m_vertical_offset.denominator = range.read32();\n  if (!m_clean_aperture_width.is_valid() || !m_clean_aperture_height.is_valid() ||\n      !m_horizontal_offset.is_valid() || !m_vertical_offset.is_valid()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_fractional_number);\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_clap::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"clean_aperture: \" << m_clean_aperture_width.numerator\n       << \"/\" << m_clean_aperture_width.denominator << \" x \"\n       << m_clean_aperture_height.numerator << \"/\"\n       << m_clean_aperture_height.denominator << \"\\n\";\n  sstr << indent << \"offset: \" << m_horizontal_offset.numerator << \"/\"\n       << m_horizontal_offset.denominator << \" ; \"\n       << m_vertical_offset.numerator << \"/\"\n       << m_vertical_offset.denominator << \"\\n\";\n\n  return sstr.str();\n}\n\n\nint Box_clap::left_rounded(int image_width) const\n{\n  // pcX = horizOff + (width  - 1)/2\n  // pcX \u00b1 (cleanApertureWidth - 1)/2\n\n  // left = horizOff + (width-1)/2 - (clapWidth-1)/2\n\n  Fraction pcX  = m_horizontal_offset + Fraction(image_width-1, 2);\n  Fraction left = pcX - (m_clean_aperture_width-1)/2;\n\n  return left.round();\n}\n\nint Box_clap::right_rounded(int image_width) const\n{\n  Fraction pcX  = m_horizontal_offset + Fraction(image_width-1, 2);\n  Fraction right = pcX + (m_clean_aperture_width-1)/2;\n\n  return right.round();\n}\n\nint Box_clap::top_rounded(int image_height) const\n{\n  Fraction pcY  = m_vertical_offset + Fraction(image_height-1, 2);\n  Fraction top = pcY - (m_clean_aperture_height-1)/2;\n\n  return top.round();\n}\n\nint Box_clap::bottom_rounded(int image_height) const\n{\n  Fraction pcY  = m_vertical_offset + Fraction(image_height-1, 2);\n  Fraction bottom = pcY + (m_clean_aperture_height-1)/2;\n\n  return bottom.round();\n}\n\nint Box_clap::get_width_rounded() const\n{\n  int left  = (Fraction(0,1)-(m_clean_aperture_width-1)/2).round();\n  int right = (  (m_clean_aperture_width-1)/2).round();\n\n  return right+1-left;\n}\n\nint Box_clap::get_height_rounded() const\n{\n  int top    = (Fraction(0,1)-(m_clean_aperture_height-1)/2).round();\n  int bottom = ( (m_clean_aperture_height-1)/2).round();\n\n  return bottom+1-top;\n}\n\n\n\nError Box_iref::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  while (!range.eof()) {\n    Reference ref;\n\n    Error err = ref.header.parse(range);\n    if (err != Error::Ok) {\n      return err;\n    }\n\n    if (get_version()==0) {\n      ref.from_item_ID = range.read16();\n      int nRefs = range.read16();\n      for (int i=0;i<nRefs;i++) {\n        ref.to_item_ID.push_back( range.read16() );\n        if (range.eof()) {\n          break;\n        }\n      }\n    }\n    else {\n      ref.from_item_ID = range.read32();\n      int nRefs = range.read16();\n      for (int i=0;i<nRefs;i++) {\n        ref.to_item_ID.push_back( range.read32() );\n        if (range.eof()) {\n          break;\n        }\n      }\n    }\n\n    m_references.push_back(ref);\n  }\n\n  return range.get_error();\n}\n\n\nvoid Box_iref::derive_box_version()\n{\n  uint8_t version = 0;\n\n  for (const auto& ref : m_references) {\n    if (ref.from_item_ID > 0xFFFF) {\n      version=1;\n      break;\n    }\n\n    for (uint32_t r : ref.to_item_ID) {\n      if (r > 0xFFFF) {\n        version=1;\n        break;\n      }\n    }\n  }\n\n  set_version(version);\n}\n\n\nError Box_iref::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  int id_size = ((get_version()==0) ? 2 : 4);\n\n  for (const auto& ref : m_references) {\n    uint32_t box_size = uint32_t(4+4 + 2 + id_size * (1+ref.to_item_ID.size()));\n\n    // we write the BoxHeader ourselves since it is very simple\n    writer.write32(box_size);\n    writer.write32(ref.header.get_short_type());\n\n    writer.write(id_size, ref.from_item_ID);\n    writer.write16((uint16_t)ref.to_item_ID.size());\n\n    for (uint32_t r : ref.to_item_ID) {\n      writer.write(id_size, r);\n    }\n  }\n\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nstd::string Box_iref::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const auto& ref : m_references) {\n    sstr << indent << \"reference with type '\" << ref.header.get_type_string() << \"'\"\n         << \" from ID: \" << ref.from_item_ID\n         << \" to IDs: \";\n    for (uint32_t id : ref.to_item_ID) {\n      sstr << id << \" \";\n    }\n    sstr << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nbool Box_iref::has_references(uint32_t itemID) const\n{\n  for (const Reference& ref : m_references) {\n    if (ref.from_item_ID == itemID) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\nstd::vector<Box_iref::Reference> Box_iref::get_references_from(heif_item_id itemID) const\n{\n  std::vector<Reference> references;\n\n  for (const Reference& ref : m_references) {\n    if (ref.from_item_ID == itemID) {\n      references.push_back(ref);\n    }\n  }\n\n  return references;\n}\n\n\nstd::vector<uint32_t> Box_iref::get_references(uint32_t itemID, uint32_t ref_type) const\n{\n  for (const Reference& ref : m_references) {\n    if (ref.from_item_ID == itemID &&\n        ref.header.get_short_type() == ref_type) {\n      return ref.to_item_ID;\n    }\n  }\n\n  return std::vector<uint32_t>();\n}\n\n\nvoid Box_iref::add_reference(heif_item_id from_id, uint32_t type, std::vector<heif_item_id> to_ids)\n{\n  Reference ref;\n  ref.header.set_short_type(type);\n  ref.from_item_ID = from_id;\n  ref.to_item_ID = to_ids;\n\n  m_references.push_back(ref);\n}\n\n\nError Box_hvcC::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  uint8_t byte;\n\n  auto& c = m_configuration; // abbreviation\n\n  c.configuration_version = range.read8();\n  byte = range.read8();\n  c.general_profile_space = (byte>>6) & 3;\n  c.general_tier_flag = (byte>>5) & 1;\n  c.general_profile_idc = (byte & 0x1F);\n\n  c.general_profile_compatibility_flags = range.read32();\n\n  for (int i=0; i<6; i++)\n    {\n      byte = range.read8();\n\n      for (int b=0;b<8;b++) {\n        c.general_constraint_indicator_flags[i*8+b] = (byte >> (7-b)) & 1;\n      }\n    }\n\n  c.general_level_idc = range.read8();\n  c.min_spatial_segmentation_idc = range.read16() & 0x0FFF;\n  c.parallelism_type = range.read8() & 0x03;\n  c.chroma_format = range.read8() & 0x03;\n  c.bit_depth_luma = static_cast<uint8_t>((range.read8() & 0x07) + 8);\n  c.bit_depth_chroma = static_cast<uint8_t>((range.read8() & 0x07) + 8);\n  c.avg_frame_rate = range.read16();\n\n  byte = range.read8();\n  c.constant_frame_rate = (byte >> 6) & 0x03;\n  c.num_temporal_layers = (byte >> 3) & 0x07;\n  c.temporal_id_nested = (byte >> 2) & 1;\n\n  m_length_size = static_cast<uint8_t>((byte & 0x03) + 1);\n\n  int nArrays = range.read8();\n\n  for (int i=0; i<nArrays && !range.error(); i++)\n    {\n      byte = range.read8();\n\n      NalArray array;\n\n      array.m_array_completeness = (byte >> 6) & 1;\n      array.m_NAL_unit_type = (byte & 0x3F);\n\n      int nUnits = range.read16();\n      for (int u=0; u<nUnits && !range.error(); u++) {\n\n        std::vector<uint8_t> nal_unit;\n        int size = range.read16();\n        if (!size) {\n          // Ignore empty NAL units.\n          continue;\n        }\n\n        if (range.prepare_read(size)) {\n          nal_unit.resize(size);\n          range.get_istream()->read((char*)nal_unit.data(), size);\n        }\n\n        array.m_nal_units.push_back( std::move(nal_unit) );\n      }\n\n      m_nal_array.push_back( std::move(array) );\n    }\n\n  range.skip_to_end_of_box();\n\n  return range.get_error();\n}\n\n\nstd::string Box_hvcC::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  const auto& c = m_configuration; // abbreviation\n\n  sstr << indent << \"configuration_version: \" << ((int)c.configuration_version) << \"\\n\"\n       << indent << \"general_profile_space: \" << ((int)c.general_profile_space) << \"\\n\"\n       << indent << \"general_tier_flag: \" << c.general_tier_flag << \"\\n\"\n       << indent << \"general_profile_idc: \" << ((int)c.general_profile_idc) << \"\\n\";\n\n  sstr << indent << \"general_profile_compatibility_flags: \";\n  for (int i=0;i<32;i++) {\n    sstr << ((c.general_profile_compatibility_flags>>(31-i))&1);\n    if ((i%8)==7) sstr << ' ';\n    else if ((i%4)==3) sstr << '.';\n  }\n  sstr << \"\\n\";\n\n  sstr << indent << \"general_constraint_indicator_flags: \";\n  int cnt=0;\n  for (int i=0; i<configuration::NUM_CONSTRAINT_INDICATOR_FLAGS; i++) {\n    bool b = c.general_constraint_indicator_flags[i];\n\n    sstr << (b ? 1:0);\n    cnt++;\n    if ((cnt%8)==0)\n      sstr << ' ';\n  }\n  sstr << \"\\n\";\n\n  sstr << indent << \"general_level_idc: \" << ((int)c.general_level_idc) << \"\\n\"\n       << indent << \"min_spatial_segmentation_idc: \" << c.min_spatial_segmentation_idc << \"\\n\"\n       << indent << \"parallelism_type: \" << ((int)c.parallelism_type) << \"\\n\"\n       << indent << \"chroma_format: \" << ((int)c.chroma_format) << \"\\n\"\n       << indent << \"bit_depth_luma: \" << ((int)c.bit_depth_luma) << \"\\n\"\n       << indent << \"bit_depth_chroma: \" << ((int)c.bit_depth_chroma) << \"\\n\"\n       << indent << \"avg_frame_rate: \" << c.avg_frame_rate << \"\\n\"\n       << indent << \"constant_frame_rate: \" << ((int)c.constant_frame_rate) << \"\\n\"\n       << indent << \"num_temporal_layers: \" << ((int)c.num_temporal_layers) << \"\\n\"\n       << indent << \"temporal_id_nested: \" << ((int)c.temporal_id_nested) << \"\\n\"\n       << indent << \"length_size: \" << ((int)m_length_size) << \"\\n\";\n\n  for (const auto& array : m_nal_array) {\n    sstr << indent << \"<array>\\n\";\n\n    indent++;\n    sstr << indent << \"array_completeness: \" << ((int)array.m_array_completeness) << \"\\n\"\n         << indent << \"NAL_unit_type: \" << ((int)array.m_NAL_unit_type) << \"\\n\";\n\n    for (const auto& unit : array.m_nal_units) {\n      //sstr << \"  unit with \" << unit.size() << \" bytes of data\\n\";\n      sstr << indent;\n      for (uint8_t b : unit) {\n        sstr << std::setfill('0') << std::setw(2) << std::hex << ((int)b) << \" \";\n      }\n      sstr << \"\\n\";\n      sstr << std::dec;\n    }\n\n    indent--;\n  }\n\n  return sstr.str();\n}\n\n\nbool Box_hvcC::get_headers(std::vector<uint8_t>* dest) const\n{\n  for (const auto& array : m_nal_array) {\n    for (const auto& unit : array.m_nal_units) {\n\n      dest->push_back( (unit.size()>>24) & 0xFF );\n      dest->push_back( (unit.size()>>16) & 0xFF );\n      dest->push_back( (unit.size()>> 8) & 0xFF );\n      dest->push_back( (unit.size()>> 0) & 0xFF );\n\n      /*\n      dest->push_back(0);\n      dest->push_back(0);\n      dest->push_back(1);\n      */\n\n      dest->insert(dest->end(), unit.begin(), unit.end());\n    }\n  }\n\n  return true;\n}\n\n\nvoid Box_hvcC::append_nal_data(const std::vector<uint8_t>& nal)\n{\n  NalArray array;\n  array.m_array_completeness = 0;\n  array.m_NAL_unit_type = uint8_t(nal[0]>>1);\n  array.m_nal_units.push_back(nal);\n\n  m_nal_array.push_back(array);\n}\n\nvoid Box_hvcC::append_nal_data(const uint8_t* data, size_t size)\n{\n  std::vector<uint8_t> nal;\n  nal.resize(size);\n  memcpy(nal.data(), data, size);\n\n  NalArray array;\n  array.m_array_completeness = 0;\n  array.m_NAL_unit_type = uint8_t(nal[0]>>1);\n  array.m_nal_units.push_back( std::move(nal) );\n\n  m_nal_array.push_back(array);\n}\n\n\nError Box_hvcC::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  const auto& c = m_configuration; // abbreviation\n\n  writer.write8(c.configuration_version);\n\n  writer.write8((uint8_t)(((c.general_profile_space & 3) << 6) |\n                          ((c.general_tier_flag & 1) << 5) |\n                          (c.general_profile_idc & 0x1F)));\n\n  writer.write32(c.general_profile_compatibility_flags);\n\n  for (int i=0; i<6; i++)\n    {\n      uint8_t byte = 0;\n\n      for (int b=0;b<8;b++) {\n        if (c.general_constraint_indicator_flags[i*8+b]) {\n          byte |= 1;\n        }\n\n        byte = (uint8_t)(byte<<1);\n      }\n\n      writer.write8(byte);\n    }\n\n  writer.write8(c.general_level_idc);\n  writer.write16((c.min_spatial_segmentation_idc & 0x0FFF) | 0xF000);\n  writer.write8(c.parallelism_type | 0xFC);\n  writer.write8(c.chroma_format | 0xFC);\n  writer.write8((uint8_t)((c.bit_depth_luma - 8) | 0xF8));\n  writer.write8((uint8_t)((c.bit_depth_chroma - 8) | 0xF8));\n  writer.write16(c.avg_frame_rate);\n\n  writer.write8((uint8_t)(((c.constant_frame_rate & 0x03) << 6) |\n                          ((c.num_temporal_layers & 0x07) << 3) |\n                          ((c.temporal_id_nested & 1) << 2) |\n                          ((m_length_size-1) & 0x03)));\n\n  size_t nArrays = m_nal_array.size();\n  if (nArrays>0xFF) {\n    // TODO: error: too many NAL units\n  }\n\n  writer.write8((uint8_t)nArrays);\n\n  for (const NalArray& array : m_nal_array) {\n\n    writer.write8((uint8_t)(((array.m_array_completeness & 1) << 6) |\n                            (array.m_NAL_unit_type & 0x3F)));\n\n    size_t nUnits = array.m_nal_units.size();\n    if (nUnits > 0xFFFF) {\n      // TODO: error: too many NAL units\n    }\n\n    writer.write16((uint16_t)nUnits);\n\n    for (const std::vector<uint8_t>& nal_unit : array.m_nal_units) {\n      writer.write16((uint16_t)nal_unit.size());\n      writer.write(nal_unit);\n    }\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_idat::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  m_data_start_pos = range.get_istream()->get_position();\n\n  return range.get_error();\n}\n\n\nstd::string Box_idat::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"number of data bytes: \" << get_box_size() - get_header_size() << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_idat::read_data(std::shared_ptr<StreamReader> istr,\n                          uint64_t start, uint64_t length,\n                          std::vector<uint8_t>& out_data) const\n{\n  // --- security check that we do not allocate too much data\n\n  auto curr_size = out_data.size();\n\n  if (MAX_MEMORY_BLOCK_SIZE - curr_size < length) {\n    std::stringstream sstr;\n    sstr << \"idat box contained \" << length << \" bytes, total memory size would be \"\n         << (curr_size + length) << \" bytes, exceeding the security limit of \"\n         << MAX_MEMORY_BLOCK_SIZE << \" bytes\";\n\n    return Error(heif_error_Memory_allocation_error,\n                 heif_suberror_Security_limit_exceeded,\n                 sstr.str());\n  }\n\n\n  // move to start of data\n  if (start > (uint64_t)m_data_start_pos + get_box_size()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  } else if (length > get_box_size() || start + length > get_box_size()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  StreamReader::grow_status status = istr->wait_for_file_size((int64_t)m_data_start_pos + start + length);\n  if (status == StreamReader::size_beyond_eof ||\n      status == StreamReader::timeout) {\n    // TODO: maybe we should introduce some 'Recoverable error' instead of 'Invalid input'\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  bool success;\n  success = istr->seek(m_data_start_pos + (std::streampos)start);\n  assert(success);\n  (void)success;\n\n  // reserve space for the data in the output array\n\n  out_data.resize(static_cast<size_t>(curr_size + length));\n  uint8_t* data = &out_data[curr_size];\n\n  success = istr->read((char*)data, static_cast<size_t>(length));\n  assert(success);\n\n  return Error::Ok;\n}\n\n\nError Box_grpl::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  //return read_children(range);\n\n  while (!range.eof()) {\n    EntityGroup group;\n    Error err = group.header.parse(range);\n    if (err != Error::Ok) {\n      return err;\n    }\n\n    err = group.header.parse_full_box_header(range);\n    if (err != Error::Ok) {\n      return err;\n    }\n\n    group.group_id = range.read32();\n    int nEntities = range.read32();\n    for (int i=0;i<nEntities;i++) {\n      if (range.eof()) {\n        break;\n      }\n\n      group.entity_ids.push_back( range.read32() );\n    }\n\n    m_entity_groups.push_back(group);\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_grpl::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const auto& group : m_entity_groups) {\n    sstr << indent << \"group type: \" << group.header.get_type_string() << \"\\n\"\n         << indent << \"| group id: \" << group.group_id << \"\\n\"\n         << indent << \"| entity IDs: \";\n\n    for (uint32_t id : group.entity_ids) {\n      sstr << id << \" \";\n    }\n\n    sstr << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nError Box_dinf::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  return read_children(range);\n}\n\n\nstd::string Box_dinf::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_dref::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  int nEntities = range.read32();\n\n  /*\n  for (int i=0;i<nEntities;i++) {\n    if (range.eof()) {\n      break;\n    }\n  }\n  */\n\n  Error err = read_children(range, nEntities);\n  if (err) {\n    return err;\n  }\n\n  if ((int)m_children.size() != nEntities) {\n    // TODO return Error(\n  }\n\n  return err;\n}\n\n\nstd::string Box_dref::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_url::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_location = range.read_string();\n\n  return range.get_error();\n}\n\n\nstd::string Box_url::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  //sstr << dump_children(indent);\n\n  sstr << indent << \"location: \" << m_location << \"\\n\";\n\n  return sstr.str();\n}\n", "/*\n * HEIF codec.\n * Copyright (c) 2018 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libheif.\n *\n * libheif is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libheif is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libheif.  If not, see <http://www.gnu.org/licenses/>.\n */\n#ifndef LIBHEIF_HEIF_LIMITS_H\n#define LIBHEIF_HEIF_LIMITS_H\n\n#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif\n\n#if defined(HAVE_INTTYPES_H)\n#include <inttypes.h>\n#endif\n#if defined(HAVE_STDDEF_H)\n#include <stddef.h>\n#endif\n\nstatic const size_t MAX_CHILDREN_PER_BOX = 1024;\nstatic const int MAX_ILOC_ITEMS = 1024;\nstatic const int MAX_ILOC_EXTENTS_PER_ITEM = 32;\nstatic const int MAX_MEMORY_BLOCK_SIZE = 50*1024*1024; // 50 MB\n\n// Artificial limit to avoid allocating too much memory.\nstatic const int MAX_IMAGE_WIDTH = 16384;\nstatic const int MAX_IMAGE_HEIGHT = 16384;\n\n// Maximum nesting level of boxes in input files.\n// We put a limit on this to avoid unlimited stack usage by malicious input files.\nstatic const int MAX_BOX_NESTING_LEVEL = 20;\n\nstatic const int MAX_BOX_SIZE = 0x7FFFFFFF; // 2 GB\nstatic const int64_t MAX_LARGE_BOX_SIZE = 0x0FFFFFFFFFFFFFFF;\nstatic const int64_t MAX_FILE_POS = 0x007FFFFFFFFFFFFFLL; // maximum file position\nstatic const int MAX_FRACTION_DENOMINATOR = 0x10000;\n\n#endif  // LIBHEIF_HEIF_LIMITS_H\n"], "fixing_code": ["/*\n * HEIF codec.\n * Copyright (c) 2017 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libheif.\n *\n * libheif is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libheif is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libheif.  If not, see <http://www.gnu.org/licenses/>.\n */\n#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif\n\n#include \"box.h\"\n#include \"heif_limits.h\"\n\n#include <sstream>\n#include <iomanip>\n#include <utility>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <assert.h>\n\n\nusing namespace heif;\n\n\nheif::Error heif::Error::Ok(heif_error_Ok);\n\n\n\nFraction::Fraction(int32_t num,int32_t den)\n{\n  // Reduce resolution of fraction until we are in a safe range.\n  // We need this as adding fractions may lead to very large denominators\n  // (e.g. 0x10000 * 0x10000 > 0x100000000 -> overflow, leading to integer 0)\n\n  while (denominator > MAX_FRACTION_VALUE || denominator < -MAX_FRACTION_VALUE) {\n    numerator /= 2;\n    denominator /= 2;\n  }\n\n  while (numerator > MAX_FRACTION_VALUE || numerator < -MAX_FRACTION_VALUE) {\n    numerator /= 2;\n    denominator /= 2;\n  }\n}\n\nFraction Fraction::operator+(const Fraction& b) const\n{\n  if (denominator == b.denominator) {\n    return Fraction { numerator + b.numerator, denominator };\n  }\n  else {\n    return Fraction { numerator * b.denominator + b.numerator * denominator,\n        denominator * b.denominator };\n  }\n}\n\nFraction Fraction::operator-(const Fraction& b) const\n{\n  if (denominator == b.denominator) {\n    return Fraction { numerator - b.numerator, denominator };\n  }\n  else {\n    return Fraction { numerator * b.denominator - b.numerator * denominator,\n        denominator * b.denominator };\n  }\n}\n\nFraction Fraction::operator-(int v) const\n{\n  return Fraction { numerator - v * denominator, denominator };\n}\n\nFraction Fraction::operator/(int v) const\n{\n  return Fraction { numerator, denominator*v };\n}\n\nint Fraction::round_down() const\n{\n  return numerator / denominator;\n}\n\nint Fraction::round_up() const\n{\n  return (numerator + denominator - 1)/denominator;\n}\n\nint Fraction::round() const\n{\n  return (numerator + denominator/2)/denominator;\n}\n\nbool Fraction::is_valid() const\n{\n  return denominator != 0;\n}\n\nuint32_t from_fourcc(const char* string)\n{\n  return ((string[0]<<24) |\n          (string[1]<<16) |\n          (string[2]<< 8) |\n          (string[3]));\n}\n\nstatic std::string to_fourcc(uint32_t code)\n{\n  std::string str(\"    \");\n  str[0] = static_cast<char>((code>>24) & 0xFF);\n  str[1] = static_cast<char>((code>>16) & 0xFF);\n  str[2] = static_cast<char>((code>> 8) & 0xFF);\n  str[3] = static_cast<char>((code>> 0) & 0xFF);\n\n  return str;\n}\n\n\nheif::BoxHeader::BoxHeader()\n{\n}\n\n\nstd::vector<uint8_t> heif::BoxHeader::get_type() const\n{\n  if (m_type == fourcc(\"uuid\")) {\n    return m_uuid_type;\n  }\n  else {\n    std::vector<uint8_t> type(4);\n    type[0] = static_cast<uint8_t>((m_type>>24) & 0xFF);\n    type[1] = static_cast<uint8_t>((m_type>>16) & 0xFF);\n    type[2] = static_cast<uint8_t>((m_type>> 8) & 0xFF);\n    type[3] = static_cast<uint8_t>((m_type>> 0) & 0xFF);\n    return type;\n  }\n}\n\n\nstd::string heif::BoxHeader::get_type_string() const\n{\n  if (m_type == fourcc(\"uuid\")) {\n    // 8-4-4-4-12\n\n    std::ostringstream sstr;\n    sstr << std::hex;\n    sstr << std::setfill('0');\n    sstr << std::setw(2);\n\n    for (int i=0;i<16;i++) {\n      if (i==4 || i==6 || i==8 || i==10) {\n        sstr << '-';\n      }\n\n      sstr << ((int)m_uuid_type[i]);\n    }\n\n    return sstr.str();\n  }\n  else {\n    return to_fourcc(m_type);\n  }\n}\n\n\nheif::Error heif::BoxHeader::parse(BitstreamRange& range)\n{\n  StreamReader::grow_status status;\n  status = range.wait_for_available_bytes(8);\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  m_size = range.read32();\n  m_type = range.read32();\n\n  m_header_size = 8;\n\n  if (m_size==1) {\n    status = range.wait_for_available_bytes(8);\n    if (status != StreamReader::size_reached) {\n      // TODO: return recoverable error at timeout\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_End_of_data);\n    }\n\n    uint64_t high = range.read32();\n    uint64_t low  = range.read32();\n\n    m_size = (high<<32) | low;\n    m_header_size += 8;\n\n    std::stringstream sstr;\n    sstr << \"Box size \" << m_size << \" exceeds security limit.\";\n\n    if (m_size > MAX_LARGE_BOX_SIZE) {\n      return Error(heif_error_Memory_allocation_error,\n                   heif_suberror_Security_limit_exceeded,\n                   sstr.str());\n    }\n  }\n\n  if (m_type==fourcc(\"uuid\")) {\n    status = range.wait_for_available_bytes(16);\n    if (status != StreamReader::size_reached) {\n      // TODO: return recoverable error at timeout\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_End_of_data);\n    }\n\n    if (range.prepare_read(16)) {\n      m_uuid_type.resize(16);\n      range.get_istream()->read((char*)m_uuid_type.data(), 16);\n    }\n\n    m_header_size += 16;\n  }\n\n  return range.get_error();\n}\n\n\nsize_t heif::BoxHeader::reserve_box_header_space(StreamWriter& writer) const\n{\n  size_t start_pos = writer.get_position();\n\n  int header_size = is_full_box_header() ? (8+4) : 8;\n\n  writer.skip(header_size);\n\n  return start_pos;\n}\n\n\nheif::Error heif::BoxHeader::prepend_header(StreamWriter& writer, size_t box_start) const\n{\n  const int reserved_header_size = is_full_box_header() ? (8+4) : 8;\n\n\n  // determine header size\n\n  int header_size = 0;\n\n  header_size += 8; // normal header size\n\n  if (is_full_box_header()) {\n    header_size += 4;\n  }\n\n  if (m_type==fourcc(\"uuid\")) {\n    header_size += 16;\n  }\n\n  bool large_size = false;\n\n  size_t data_size = writer.data_size() - box_start - reserved_header_size;\n\n  if (data_size + header_size > 0xFFFFFFFF) {\n    header_size += 8;\n    large_size = true;\n  }\n\n  size_t box_size = data_size + header_size;\n\n\n  // --- write header\n\n  writer.set_position(box_start);\n  assert(header_size >= reserved_header_size);\n  writer.insert(header_size - reserved_header_size);\n\n  if (large_size) {\n    writer.write32(1);\n  }\n  else {\n    assert(box_size <= 0xFFFFFFFF);\n    writer.write32( (uint32_t)box_size );\n  }\n\n  writer.write32( m_type );\n\n  if (large_size) {\n    writer.write64( box_size );\n  }\n\n  if (m_type==fourcc(\"uuid\")) {\n    assert(m_uuid_type.size()==16);\n    writer.write(m_uuid_type);\n  }\n\n  if (is_full_box_header()) {\n    assert((m_flags & ~0x00FFFFFF) == 0);\n\n    writer.write32( (m_version << 24) | m_flags );\n  }\n\n  writer.set_position_to_end();  // Note: should we move to the end of the box after writing the header?\n\n  return Error::Ok;\n}\n\n\nstd::string BoxHeader::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << indent << \"Box: \" << get_type_string() << \" -----\\n\";\n  sstr << indent << \"size: \" << get_box_size() << \"   (header size: \" << get_header_size() << \")\\n\";\n\n  if (m_is_full_box) {\n    sstr << indent << \"version: \" << ((int)m_version) << \"\\n\"\n         << indent << \"flags: \" << std::hex << m_flags << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nError Box::parse(BitstreamRange& range)\n{\n  // skip box\n\n  if (get_box_size() == size_until_end_of_file) {\n    range.skip_to_end_of_file();\n  }\n  else {\n    uint64_t content_size = get_box_size() - get_header_size();\n    if (range.prepare_read(content_size)) {\n      if (content_size > MAX_BOX_SIZE) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_Invalid_box_size);\n      }\n\n      range.get_istream()->seek_cur(get_box_size() - get_header_size());\n    }\n  }\n\n  // Note: seekg() clears the eof flag and it will not be set again afterwards,\n  // hence we have to test for the fail flag.\n\n  return range.get_error();\n}\n\n\nError BoxHeader::parse_full_box_header(BitstreamRange& range)\n{\n  uint32_t data = range.read32();\n  m_version = static_cast<uint8_t>(data >> 24);\n  m_flags = data & 0x00FFFFFF;\n  m_is_full_box = true;\n\n  m_header_size += 4;\n\n  return range.get_error();\n}\n\n\nError Box::read(BitstreamRange& range, std::shared_ptr<heif::Box>* result)\n{\n  BoxHeader hdr;\n  Error err = hdr.parse(range);\n  if (err) {\n    return err;\n  }\n\n  if (range.error()) {\n    return range.get_error();\n  }\n\n  std::shared_ptr<Box> box;\n\n  switch (hdr.get_short_type()) {\n  case fourcc(\"ftyp\"):\n    box = std::make_shared<Box_ftyp>(hdr);\n    break;\n\n  case fourcc(\"meta\"):\n    box = std::make_shared<Box_meta>(hdr);\n    break;\n\n  case fourcc(\"hdlr\"):\n    box = std::make_shared<Box_hdlr>(hdr);\n    break;\n\n  case fourcc(\"pitm\"):\n    box = std::make_shared<Box_pitm>(hdr);\n    break;\n\n  case fourcc(\"iloc\"):\n    box = std::make_shared<Box_iloc>(hdr);\n    break;\n\n  case fourcc(\"iinf\"):\n    box = std::make_shared<Box_iinf>(hdr);\n    break;\n\n  case fourcc(\"infe\"):\n    box = std::make_shared<Box_infe>(hdr);\n    break;\n\n  case fourcc(\"iprp\"):\n    box = std::make_shared<Box_iprp>(hdr);\n    break;\n\n  case fourcc(\"ipco\"):\n    box = std::make_shared<Box_ipco>(hdr);\n    break;\n\n  case fourcc(\"ipma\"):\n    box = std::make_shared<Box_ipma>(hdr);\n    break;\n\n  case fourcc(\"ispe\"):\n    box = std::make_shared<Box_ispe>(hdr);\n    break;\n\n  case fourcc(\"auxC\"):\n    box = std::make_shared<Box_auxC>(hdr);\n    break;\n\n  case fourcc(\"irot\"):\n    box = std::make_shared<Box_irot>(hdr);\n    break;\n\n  case fourcc(\"imir\"):\n    box = std::make_shared<Box_imir>(hdr);\n    break;\n\n  case fourcc(\"clap\"):\n    box = std::make_shared<Box_clap>(hdr);\n    break;\n\n  case fourcc(\"iref\"):\n    box = std::make_shared<Box_iref>(hdr);\n    break;\n\n  case fourcc(\"hvcC\"):\n    box = std::make_shared<Box_hvcC>(hdr);\n    break;\n\n  case fourcc(\"idat\"):\n    box = std::make_shared<Box_idat>(hdr);\n    break;\n\n  case fourcc(\"grpl\"):\n    box = std::make_shared<Box_grpl>(hdr);\n    break;\n\n  case fourcc(\"dinf\"):\n    box = std::make_shared<Box_dinf>(hdr);\n    break;\n\n  case fourcc(\"dref\"):\n    box = std::make_shared<Box_dref>(hdr);\n    break;\n\n  case fourcc(\"url \"):\n    box = std::make_shared<Box_url>(hdr);\n    break;\n\n  case fourcc(\"colr\"):\n    box = std::make_shared<Box_colr>(hdr);\n    break;\n\n  case fourcc(\"pixi\"):\n    box = std::make_shared<Box_pixi>(hdr);\n    break;\n\n  default:\n    box = std::make_shared<Box>(hdr);\n    break;\n  }\n\n  if (hdr.get_box_size() < hdr.get_header_size()) {\n    std::stringstream sstr;\n    sstr << \"Box size (\" << hdr.get_box_size() << \" bytes) smaller than header size (\"\n         << hdr.get_header_size() << \" bytes)\";\n\n    // Sanity check.\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size,\n                 sstr.str());\n  }\n\n\n  if (range.get_nesting_level() > MAX_BOX_NESTING_LEVEL) {\n    return Error(heif_error_Memory_allocation_error,\n                 heif_suberror_Security_limit_exceeded,\n                 \"Security limit for maximum nesting of boxes has been exceeded\");\n  }\n\n\n  auto status = range.wait_for_available_bytes( hdr.get_box_size() - hdr.get_header_size() );\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n\n  // Security check: make sure that box size does not exceed int64 size.\n\n  if (hdr.get_box_size() > std::numeric_limits<int64_t>::max()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size);\n  }\n\n  int64_t box_size = static_cast<int64_t>(hdr.get_box_size());\n  int64_t box_size_without_header = box_size - hdr.get_header_size();\n\n  // Box size may not be larger than remaining bytes in parent box.\n\n  if (range.get_remaining_bytes() < box_size_without_header) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size);\n  }\n\n\n  // Create child bitstream range and read box from that range.\n\n  BitstreamRange boxrange(range.get_istream(),\n                          box_size_without_header,\n                          &range);\n\n  err = box->parse(boxrange);\n  if (err == Error::Ok) {\n    *result = std::move(box);\n  }\n\n  boxrange.skip_to_end_of_box();\n\n  return err;\n}\n\n\nstd::string Box::dump(Indent& indent ) const\n{\n  std::ostringstream sstr;\n\n  sstr << BoxHeader::dump(indent);\n\n  return sstr.str();\n}\n\n\nError Box::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  Error err = write_children(writer);\n\n  prepend_header(writer, box_start);\n\n  return err;\n}\n\n\nstd::shared_ptr<Box> Box::get_child_box(uint32_t short_type) const\n{\n  for (auto& box : m_children) {\n    if (box->get_short_type()==short_type) {\n      return box;\n    }\n  }\n\n  return nullptr;\n}\n\n\nstd::vector<std::shared_ptr<Box>> Box::get_child_boxes(uint32_t short_type) const\n{\n  std::vector<std::shared_ptr<Box>> result;\n  for (auto& box : m_children) {\n    if (box->get_short_type()==short_type) {\n      result.push_back(box);\n    }\n  }\n\n  return result;\n}\n\n\nError Box::read_children(BitstreamRange& range, int max_number)\n{\n  int count = 0;\n\n  while (!range.eof() && !range.error()) {\n    std::shared_ptr<Box> box;\n    Error error = Box::read(range, &box);\n    if (error != Error::Ok) {\n      return error;\n    }\n\n    if (m_children.size() > MAX_CHILDREN_PER_BOX) {\n      std::stringstream sstr;\n      sstr << \"Maximum number of child boxes \" << MAX_CHILDREN_PER_BOX << \" exceeded.\";\n\n      // Sanity check.\n      return Error(heif_error_Memory_allocation_error,\n                   heif_suberror_Security_limit_exceeded,\n                   sstr.str());\n    }\n\n    m_children.push_back(std::move(box));\n\n\n    // count the new child and end reading new children when we reached the expected number\n\n    count++;\n\n    if (max_number != READ_CHILDREN_ALL &&\n        count == max_number) {\n      break;\n    }\n  }\n\n  return range.get_error();\n}\n\n\nError Box::write_children(StreamWriter& writer) const\n{\n  for (const auto& child : m_children) {\n    Error err = child->write(writer);\n    if (err) {\n      return err;\n    }\n  }\n\n  return Error::Ok;\n}\n\n\nstd::string Box::dump_children(Indent& indent) const\n{\n  std::ostringstream sstr;\n\n  bool first = true;\n\n  indent++;\n  for (const auto& childBox : m_children) {\n    if (first) {\n      first=false;\n    }\n    else {\n      sstr << indent << \"\\n\";\n    }\n\n    sstr << childBox->dump(indent);\n  }\n  indent--;\n\n  return sstr.str();\n}\n\n\nvoid Box::derive_box_version_recursive()\n{\n  derive_box_version();\n\n  for (auto& child : m_children) {\n    child->derive_box_version_recursive();\n  }\n}\n\n\nError Box_ftyp::parse(BitstreamRange& range)\n{\n  m_major_brand = range.read32();\n  m_minor_version = range.read32();\n\n  if (get_box_size() <= get_header_size() + 8) {\n    // Sanity check.\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_box_size,\n                 \"ftyp box too small (less than 8 bytes)\");\n  }\n\n  uint64_t n_minor_brands = (get_box_size() - get_header_size() - 8) / 4;\n\n  for (uint64_t i=0;i<n_minor_brands && !range.error();i++) {\n    m_compatible_brands.push_back( range.read32() );\n  }\n\n  return range.get_error();\n}\n\n\nbool Box_ftyp::has_compatible_brand(uint32_t brand) const\n{\n  for (uint32_t b : m_compatible_brands) {\n    if (b==brand) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\nstd::string Box_ftyp::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n\n  sstr << BoxHeader::dump(indent);\n\n  sstr << indent << \"major brand: \" << to_fourcc(m_major_brand) << \"\\n\"\n       << indent << \"minor version: \" << m_minor_version << \"\\n\"\n       << indent << \"compatible brands: \";\n\n  bool first=true;\n  for (uint32_t brand : m_compatible_brands) {\n    if (first) { first=false; }\n    else { sstr << ','; }\n\n    sstr << to_fourcc(brand);\n  }\n  sstr << \"\\n\";\n\n  return sstr.str();\n}\n\n\nvoid Box_ftyp::add_compatible_brand(uint32_t brand)\n{\n  // TODO: check whether brand already exists in the list\n\n  m_compatible_brands.push_back(brand);\n}\n\n\nError Box_ftyp::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write32(m_major_brand);\n  writer.write32(m_minor_version);\n\n  for (uint32_t b : m_compatible_brands) {\n    writer.write32(b);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_meta::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  /*\n  uint64_t boxSizeLimit;\n  if (get_box_size() == BoxHeader::size_until_end_of_file) {\n    boxSizeLimit = sizeLimit;\n  }\n  else {\n    boxSizeLimit = get_box_size() - get_header_size();\n  }\n  */\n\n  return read_children(range);\n}\n\n\nstd::string Box_meta::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_hdlr::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_pre_defined = range.read32();\n  m_handler_type = range.read32();\n\n  for (int i=0;i<3;i++) {\n    m_reserved[i] = range.read32();\n  }\n\n  m_name = range.read_string();\n\n  return range.get_error();\n}\n\n\nstd::string Box_hdlr::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << indent << \"pre_defined: \" << m_pre_defined << \"\\n\"\n       << indent << \"handler_type: \" << to_fourcc(m_handler_type) << \"\\n\"\n       << indent << \"name: \" << m_name << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_hdlr::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write32(m_pre_defined);\n  writer.write32(m_handler_type);\n\n  for (int i=0;i<3;i++) {\n    writer.write32(m_reserved[i]);\n  }\n\n  writer.write(m_name);\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\n\nError Box_pitm::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  if (get_version()==0) {\n    m_item_ID = range.read16();\n  }\n  else {\n    m_item_ID = range.read32();\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_pitm::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << indent << \"item_ID: \" << m_item_ID << \"\\n\";\n\n  return sstr.str();\n}\n\n\nvoid Box_pitm::derive_box_version()\n{\n  if (m_item_ID <= 0xFFFF) {\n    set_version(0);\n  }\n  else {\n    set_version(1);\n  }\n}\n\n\nError Box_pitm::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  if (get_version()==0) {\n    assert(m_item_ID <= 0xFFFF);\n    writer.write16((uint16_t)m_item_ID);\n  }\n  else {\n    writer.write32(m_item_ID);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_iloc::parse(BitstreamRange& range)\n{\n  /*\n  printf(\"box size: %d\\n\",get_box_size());\n  printf(\"header size: %d\\n\",get_header_size());\n  printf(\"start limit: %d\\n\",sizeLimit);\n  */\n\n  parse_full_box_header(range);\n\n  uint16_t values4 = range.read16();\n\n  int offset_size = (values4 >> 12) & 0xF;\n  int length_size = (values4 >>  8) & 0xF;\n  int base_offset_size = (values4 >> 4) & 0xF;\n  int index_size = 0;\n\n  if (get_version()>1) {\n    index_size = (values4 & 0xF);\n  }\n\n  int item_count;\n  if (get_version()<2) {\n    item_count = range.read16();\n  }\n  else {\n    item_count = range.read32();\n  }\n\n  // Sanity check.\n  if (item_count > MAX_ILOC_ITEMS) {\n    std::stringstream sstr;\n    sstr << \"iloc box contains \" << item_count << \" items, which exceeds the security limit of \"\n         << MAX_ILOC_ITEMS << \" items.\";\n\n    return Error(heif_error_Memory_allocation_error,\n                 heif_suberror_Security_limit_exceeded,\n                 sstr.str());\n  }\n\n  for (int i=0;i<item_count;i++) {\n    Item item;\n\n    if (get_version()<2) {\n      item.item_ID = range.read16();\n    }\n    else {\n      item.item_ID = range.read32();\n    }\n\n    if (get_version()>=1) {\n      values4 = range.read16();\n      item.construction_method = (values4 & 0xF);\n    }\n\n    item.data_reference_index = range.read16();\n\n    item.base_offset = 0;\n    if (base_offset_size==4) {\n      item.base_offset = range.read32();\n    }\n    else if (base_offset_size==8) {\n      item.base_offset = ((uint64_t)range.read32()) << 32;\n      item.base_offset |= range.read32();\n    }\n\n    int extent_count = range.read16();\n    // Sanity check.\n    if (extent_count > MAX_ILOC_EXTENTS_PER_ITEM) {\n      std::stringstream sstr;\n      sstr << \"Number of extents in iloc box (\" << extent_count << \") exceeds security limit (\"\n           << MAX_ILOC_EXTENTS_PER_ITEM << \")\\n\";\n\n      return Error(heif_error_Memory_allocation_error,\n                   heif_suberror_Security_limit_exceeded,\n                   sstr.str());\n    }\n\n    for (int e=0;e<extent_count;e++) {\n      Extent extent;\n\n      if (get_version()>1 && index_size>0) {\n        if (index_size==4) {\n          extent.index = range.read32();\n        }\n        else if (index_size==8) {\n          extent.index = ((uint64_t)range.read32()) << 32;\n          extent.index |= range.read32();\n        }\n      }\n\n      extent.offset = 0;\n      if (offset_size==4) {\n        extent.offset = range.read32();\n      }\n      else if (offset_size==8) {\n        extent.offset = ((uint64_t)range.read32()) << 32;\n        extent.offset |= range.read32();\n      }\n\n\n      extent.length = 0;\n      if (length_size==4) {\n        extent.length = range.read32();\n      }\n      else if (length_size==8) {\n        extent.length = ((uint64_t)range.read32()) << 32;\n        extent.length |= range.read32();\n      }\n\n      item.extents.push_back(extent);\n    }\n\n    if (!range.error()) {\n      m_items.push_back(item);\n    }\n  }\n\n  //printf(\"end limit: %d\\n\",sizeLimit);\n\n  return range.get_error();\n}\n\n\nstd::string Box_iloc::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const Item& item : m_items) {\n    sstr << indent << \"item ID: \" << item.item_ID << \"\\n\"\n         << indent << \"  construction method: \" << ((int)item.construction_method) << \"\\n\"\n         << indent << \"  data_reference_index: \" << std::hex\n         << item.data_reference_index << std::dec << \"\\n\"\n         << indent << \"  base_offset: \" << item.base_offset << \"\\n\";\n\n    sstr << indent << \"  extents: \";\n    for (const Extent& extent : item.extents) {\n      sstr << extent.offset << \",\" << extent.length;\n      if (extent.index != 0) {\n        sstr << \";index=\" << extent.index;\n      }\n      sstr << \" \";\n    }\n    sstr << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nError Box_iloc::read_data(const Item& item,\n                          std::shared_ptr<StreamReader> istr,\n                          const std::shared_ptr<Box_idat>& idat,\n                          std::vector<uint8_t>* dest) const\n{\n  //istr.clear();\n\n  for (const auto& extent : item.extents) {\n    if (item.construction_method == 0) {\n\n      // --- security check that we do not allocate too much memory\n\n      size_t old_size = dest->size();\n      if (MAX_MEMORY_BLOCK_SIZE - old_size < extent.length) {\n        std::stringstream sstr;\n        sstr << \"iloc box contained \" << extent.length << \" bytes, total memory size would be \"\n             << (old_size + extent.length) << \" bytes, exceeding the security limit of \"\n             << MAX_MEMORY_BLOCK_SIZE << \" bytes\";\n\n        return Error(heif_error_Memory_allocation_error,\n                     heif_suberror_Security_limit_exceeded,\n                     sstr.str());\n      }\n\n\n      // --- make sure that all data is available\n\n      if (extent.offset > MAX_FILE_POS ||\n          item.base_offset > MAX_FILE_POS ||\n          extent.length > MAX_FILE_POS) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_Security_limit_exceeded,\n                     \"iloc data pointers out of allowed range\");\n      }\n\n      StreamReader::grow_status status = istr->wait_for_file_size(extent.offset + item.base_offset + extent.length);\n      if (status == StreamReader::size_beyond_eof) {\n        // Out-of-bounds\n        // TODO: I think we should not clear this. Maybe we want to try reading again later and\n        // hence should not lose the data already read.\n        dest->clear();\n\n        std::stringstream sstr;\n        sstr << \"Extent in iloc box references data outside of file bounds \"\n             << \"(points to file position \" << extent.offset + item.base_offset << \")\\n\";\n\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_End_of_data,\n                     sstr.str());\n      }\n      else if (status == StreamReader::timeout) {\n        // TODO: maybe we should introduce some 'Recoverable error' instead of 'Invalid input'\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_End_of_data);\n      }\n\n      // --- move file pointer to start of data\n\n      bool success = istr->seek(extent.offset + item.base_offset);\n      assert(success);\n      (void)success;\n\n\n      // --- read data\n\n      dest->resize(static_cast<size_t>(old_size + extent.length));\n      success = istr->read((char*)dest->data() + old_size, static_cast<size_t>(extent.length));\n      assert(success);\n    }\n    else if (item.construction_method==1) {\n      if (!idat) {\n        return Error(heif_error_Invalid_input,\n                     heif_suberror_No_idat_box,\n                     \"idat box referenced in iref box is not present in file\");\n      }\n\n      idat->read_data(istr,\n                      extent.offset + item.base_offset,\n                      extent.length,\n                      *dest);\n    }\n    else {\n      std::stringstream sstr;\n      sstr << \"Item construction method \" << item.construction_method << \" not implemented\";\n      return Error(heif_error_Unsupported_feature,\n                   heif_suberror_No_idat_box,\n                   sstr.str());\n    }\n  }\n\n  return Error::Ok;\n}\n\n\nError Box_iloc::append_data(heif_item_id item_ID,\n                            const std::vector<uint8_t>& data,\n                            uint8_t construction_method)\n{\n  // check whether this item ID already exists\n\n  size_t idx;\n  for (idx=0;idx<m_items.size();idx++) {\n    if (m_items[idx].item_ID == item_ID) {\n      break;\n    }\n  }\n\n  // item does not exist -> add a new one to the end\n\n  if (idx == m_items.size()) {\n    Item item;\n    item.item_ID = item_ID;\n    item.construction_method = construction_method;\n\n    m_items.push_back(item);\n  }\n\n  if (m_items[idx].construction_method != construction_method) {\n    // TODO: return error: construction methods do not match\n  }\n\n  Extent extent;\n  extent.data = data;\n  m_items[idx].extents.push_back( std::move(extent) );\n\n  return Error::Ok;\n}\n\n\nvoid Box_iloc::derive_box_version()\n{\n  int min_version = m_user_defined_min_version;\n\n  if (m_items.size() > 0xFFFF) {\n    min_version = std::max(min_version, 2);\n  }\n\n  m_offset_size = 0;\n  m_length_size = 0;\n  m_base_offset_size = 0;\n  m_index_size = 0;\n\n  for (const auto& item : m_items) {\n    // check item_ID size\n    if (item.item_ID > 0xFFFF) {\n      min_version = std::max(min_version, 2);\n    }\n\n    // check construction method\n    if (item.construction_method != 0) {\n      min_version = std::max(min_version, 1);\n    }\n\n    // base offset size\n    /*\n    if (item.base_offset > 0xFFFFFFFF) {\n      m_base_offset_size = 8;\n    }\n    else if (item.base_offset > 0) {\n      m_base_offset_size = 4;\n    }\n    */\n\n    /*\n    for (const auto& extent : item.extents) {\n      // extent index size\n\n      if (extent.index != 0) {\n        min_version = std::max(min_version, 1);\n        m_index_size = 4;\n      }\n\n      if (extent.index > 0xFFFFFFFF) {\n        m_index_size = 8;\n      }\n\n      // extent offset size\n      if (extent.offset > 0xFFFFFFFF) {\n        m_offset_size = 8;\n      }\n      else {\n        m_offset_size = 4;\n      }\n\n      // extent length size\n      if (extent.length > 0xFFFFFFFF) {\n        m_length_size = 8;\n      }\n      else {\n        m_length_size = 4;\n      }\n    }\n      */\n  }\n\n  m_offset_size = 4;\n  m_length_size = 4;\n  m_base_offset_size = 4; // TODO: or could be 8 if we write >4GB files\n  m_index_size = 0;\n\n  set_version((uint8_t)min_version);\n}\n\n\nError Box_iloc::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  m_iloc_box_start = writer.get_position();\n\n  int nSkip = 0;\n\n  nSkip += 2;\n  nSkip += (get_version()<2) ? 2 : 4; // item_count\n\n  for (const auto& item : m_items) {\n    nSkip += (get_version()<2) ? 2 : 4; // item_ID\n    nSkip += (get_version()>=1) ? 2 : 0; // construction method\n    nSkip += 4 + m_base_offset_size;\n\n    for (const auto& extent : item.extents) {\n      (void)extent;\n\n      if (get_version()>=1) {\n        nSkip += m_index_size;\n      }\n\n      nSkip += m_offset_size + m_length_size;\n    }\n  }\n\n  writer.skip(nSkip);\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_iloc::write_mdat_after_iloc(StreamWriter& writer)\n{\n  // --- compute sum of all mdat data\n\n  size_t sum_mdat_size = 0;\n\n  for (const auto& item : m_items) {\n    if (item.construction_method == 0) {\n      for (const auto& extent : item.extents) {\n        sum_mdat_size += extent.data.size();\n      }\n    }\n  }\n\n  if (sum_mdat_size > 0xFFFFFFFF) {\n    // TODO: box size > 4 GB\n  }\n\n\n  // --- write mdat box\n\n  writer.write32((uint32_t)(sum_mdat_size + 8));\n  writer.write32(fourcc(\"mdat\"));\n\n  for (auto& item : m_items) {\n    item.base_offset = writer.get_position();\n\n    for (auto& extent : item.extents) {\n      extent.offset = writer.get_position() - item.base_offset;\n      extent.length = extent.data.size();\n\n      writer.write(extent.data);\n    }\n  }\n\n\n  // --- patch iloc box\n\n  patch_iloc_header(writer);\n\n  return Error::Ok;\n}\n\n\nvoid Box_iloc::patch_iloc_header(StreamWriter& writer) const\n{\n  size_t old_pos = writer.get_position();\n  writer.set_position(m_iloc_box_start);\n\n  writer.write8((uint8_t)((m_offset_size<<4) | (m_length_size)));\n  writer.write8((uint8_t)((m_base_offset_size<<4) | (m_index_size)));\n\n  if (get_version() < 2) {\n    writer.write16((uint16_t)m_items.size());\n  } else {\n    writer.write32((uint32_t)m_items.size());\n  }\n\n  for (const auto& item : m_items) {\n    if (get_version() < 2) {\n      writer.write16((uint16_t)item.item_ID);\n    } else {\n      writer.write32((uint32_t)item.item_ID);\n    }\n\n    if (get_version() >= 1) {\n      writer.write16(item.construction_method);\n    }\n\n    writer.write16(item.data_reference_index);\n    writer.write(m_base_offset_size, item.base_offset);\n    writer.write16((uint16_t)item.extents.size());\n\n    for (const auto& extent : item.extents) {\n      if (get_version()>=1 && m_index_size > 0) {\n        writer.write(m_index_size, extent.index);\n      }\n\n      writer.write(m_offset_size, extent.offset);\n      writer.write(m_length_size, extent.length);\n    }\n  }\n\n  writer.set_position(old_pos);\n}\n\n\nError Box_infe::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  if (get_version() <= 1) {\n    m_item_ID = range.read16();\n    m_item_protection_index = range.read16();\n\n    m_item_name = range.read_string();\n    m_content_type = range.read_string();\n    m_content_encoding = range.read_string();\n  }\n\n  if (get_version() >= 2) {\n    m_hidden_item = (get_flags() & 1);\n\n    if (get_version() == 2) {\n      m_item_ID = range.read16();\n    }\n    else {\n      m_item_ID = range.read32();\n    }\n\n    m_item_protection_index = range.read16();\n    uint32_t item_type =range.read32();\n    if (item_type != 0) {\n      m_item_type = to_fourcc(item_type);\n    }\n\n    m_item_name = range.read_string();\n    if (item_type == fourcc(\"mime\")) {\n      m_content_type = range.read_string();\n      m_content_encoding = range.read_string();\n    }\n    else if (item_type == fourcc(\"uri \")) {\n      m_item_uri_type = range.read_string();\n    }\n  }\n\n  return range.get_error();\n}\n\n\nvoid Box_infe::derive_box_version()\n{\n  int min_version = 0;\n\n  if (m_hidden_item) {\n    min_version = std::max(min_version, 2);\n  }\n\n  if (m_item_ID > 0xFFFF) {\n    min_version = std::max(min_version, 3);\n  }\n\n\n  if (m_item_type != \"\") {\n    min_version = std::max(min_version, 2);\n  }\n\n  set_version((uint8_t)min_version);\n}\n\n\nvoid Box_infe::set_hidden_item(bool hidden)\n{\n  m_hidden_item = hidden;\n\n  if (m_hidden_item) {\n    set_flags( get_flags() | 1);\n  }\n  else {\n    set_flags( get_flags() & ~1);\n  }\n}\n\nError Box_infe::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  if (get_version() <= 1) {\n    writer.write16((uint16_t)m_item_ID);\n    writer.write16(m_item_protection_index);\n\n    writer.write(m_item_name);\n    writer.write(m_content_type);\n    writer.write(m_content_encoding);\n  }\n\n  if (get_version() >= 2) {\n    if (get_version() == 2) {\n      writer.write16((uint16_t)m_item_ID);\n    }\n    else if (get_version()==3) {\n      writer.write32(m_item_ID);\n    }\n\n    writer.write16(m_item_protection_index);\n\n    if (m_item_type.empty()) {\n      writer.write32(0);\n    }\n    else {\n      writer.write32(from_fourcc(m_item_type.c_str()));\n    }\n\n    writer.write(m_item_name);\n    if (m_item_type == \"mime\") {\n      writer.write(m_content_type);\n      writer.write(m_content_encoding);\n    }\n    else if (m_item_type == \"uri \") {\n      writer.write(m_item_uri_type);\n    }\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nstd::string Box_infe::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"item_ID: \" << m_item_ID << \"\\n\"\n       << indent << \"item_protection_index: \" << m_item_protection_index << \"\\n\"\n       << indent << \"item_type: \" << m_item_type << \"\\n\"\n       << indent << \"item_name: \" << m_item_name << \"\\n\"\n       << indent << \"content_type: \" << m_content_type << \"\\n\"\n       << indent << \"content_encoding: \" << m_content_encoding << \"\\n\"\n       << indent << \"item uri type: \" << m_item_uri_type << \"\\n\"\n       << indent << \"hidden item: \" << std::boolalpha << m_hidden_item << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_iinf::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  int nEntries_size = (get_version() > 0) ? 4 : 2;\n\n  int item_count;\n  if (nEntries_size==2) {\n    item_count = range.read16();\n  }\n  else {\n    item_count = range.read32();\n  }\n\n  if (item_count == 0) {\n    return Error::Ok;\n  }\n\n  // TODO: Only try to read \"item_count\" children.\n  return read_children(range);\n}\n\n\nstd::string Box_iinf::dump(Indent& indent ) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_iprp::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  return read_children(range);\n}\n\n\nvoid Box_iinf::derive_box_version()\n{\n  if (m_children.size() > 0xFFFF) {\n    set_version(1);\n  }\n  else {\n    set_version(0);\n  }\n}\n\n\nError Box_iinf::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  int nEntries_size = (get_version() > 0) ? 4 : 2;\n\n  writer.write(nEntries_size, m_children.size());\n\n\n  Error err = write_children(writer);\n\n  prepend_header(writer, box_start);\n\n  return err;\n}\n\n\nstd::string Box_iprp::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_ipco::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  return read_children(range);\n}\n\n\nstd::string Box_ipco::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\nError color_profile_nclx::parse(BitstreamRange& range)\n{\n  StreamReader::grow_status status;\n  status = range.wait_for_available_bytes(7);\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  m_colour_primaries = range.read16();\n  m_transfer_characteristics = range.read16();\n  m_matrix_coefficients = range.read16();\n  m_full_range_flag = (range.read8() & 0x80 ? true : false);\n\n  return Error::Ok;\n}\n\nError Box_colr::parse(BitstreamRange& range)\n{\n  StreamReader::grow_status status;\n  uint32_t colour_type = range.read32();\n\n  if (colour_type == fourcc(\"nclx\")) {\n    auto color_profile = std::make_shared<color_profile_nclx>();\n    m_color_profile = color_profile;\n    Error err = color_profile->parse(range);\n    if (err) {\n      return err;\n    }\n  } else if (colour_type == fourcc(\"prof\") ||\n             colour_type == fourcc(\"rICC\")) {\n    auto profile_size = get_box_size() - get_header_size() - 4;\n    status = range.wait_for_available_bytes(profile_size);\n    if (status != StreamReader::size_reached) {\n      // TODO: return recoverable error at timeout\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_End_of_data);\n    }\n\n    std::vector<uint8_t> rawData(profile_size);\n    for (size_t i = 0; i < profile_size; i++ ){\n      rawData[i] = range.read8();\n    }\n\n    m_color_profile = std::make_shared<color_profile_raw>(colour_type, rawData);\n  }\n  else {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Unknown_color_profile_type);\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_colr::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"colour_type: \" << to_fourcc(get_color_profile_type()) << \"\\n\";\n\n  if (m_color_profile) {\n    sstr << m_color_profile->dump(indent);\n  }\n  else {\n    sstr << \"no color profile\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nstd::string color_profile_raw::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << indent << \"profile size: \" << m_data.size() << \"\\n\";\n  return sstr.str();\n}\n\n\nstd::string color_profile_nclx::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << indent << \"colour_primaries: \" << m_colour_primaries << \"\\n\"\n       << indent << \"transfer_characteristics: \" << m_transfer_characteristics << \"\\n\"\n       << indent << \"matrix_coefficients: \" << m_matrix_coefficients << \"\\n\"\n       << indent << \"full_range_flag: \" << m_full_range_flag << \"\\n\";\n  return sstr.str();\n}\n\n\nError color_profile_nclx::write(StreamWriter& writer) const\n{\n    writer.write16(m_colour_primaries);\n    writer.write16(m_transfer_characteristics);\n    writer.write16(m_matrix_coefficients);\n    writer.write8(m_full_range_flag ? 0x80 : 0x00);\n\n    return Error::Ok;\n}\n\nError color_profile_raw::write(StreamWriter& writer) const\n{\n  writer.write(m_data);\n\n    return Error::Ok;\n}\n\nError Box_colr::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  assert(m_color_profile);\n\n  writer.write32(m_color_profile->get_type());\n\n  Error err = m_color_profile->write(writer);\n  if (err) {\n    return err;\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\n\nError Box_pixi::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  StreamReader::grow_status status;\n  uint8_t num_channels = range.read8();\n  status = range.wait_for_available_bytes(num_channels);\n  if (status != StreamReader::size_reached) {\n    // TODO: return recoverable error at timeout\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  m_bits_per_channel.resize(num_channels);\n  for (int i=0;i<num_channels;i++) {\n    m_bits_per_channel[i] = range.read8();\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_pixi::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"bits_per_channel: \";\n\n  for (size_t i=0;i<m_bits_per_channel.size();i++) {\n    if (i>0) sstr << \",\";\n    sstr << ((int)m_bits_per_channel[i]);\n  }\n\n  sstr << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_pixi::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  if (m_bits_per_channel.size() > 255 ||\n      m_bits_per_channel.empty()) {\n    // TODO: error\n    assert(false);\n  }\n\n  writer.write8((uint8_t)(m_bits_per_channel.size()));\n  for (size_t i=0;i<m_bits_per_channel.size();i++) {\n    writer.write8(m_bits_per_channel[i]);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_ipco::get_properties_for_item_ID(uint32_t itemID,\n                                           const std::shared_ptr<class Box_ipma>& ipma,\n                                           std::vector<Property>& out_properties) const\n{\n  const std::vector<Box_ipma::PropertyAssociation>* property_assoc = ipma->get_properties_for_item_ID(itemID);\n  if (property_assoc == nullptr) {\n    std::stringstream sstr;\n    sstr << \"Item (ID=\" << itemID << \") has no properties assigned to it in ipma box\";\n\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_No_properties_assigned_to_item,\n                 sstr.str());\n  }\n\n  auto allProperties = get_all_child_boxes();\n  for (const  Box_ipma::PropertyAssociation& assoc : *property_assoc) {\n    if (assoc.property_index > allProperties.size()) {\n      std::stringstream sstr;\n      sstr << \"Nonexisting property (index=\" << assoc.property_index << \") for item \"\n           << \" ID=\" << itemID << \" referenced in ipma box\";\n\n      return Error(heif_error_Invalid_input,\n                   heif_suberror_Ipma_box_references_nonexisting_property,\n                   sstr.str());\n    }\n\n    Property prop;\n    prop.essential = assoc.essential;\n\n    if (assoc.property_index > 0) {\n      prop.property = allProperties[assoc.property_index - 1];\n      out_properties.push_back(prop);\n    }\n  }\n\n  return Error::Ok;\n}\n\n\nstd::shared_ptr<Box> Box_ipco::get_property_for_item_ID(heif_item_id itemID,\n                                                        const std::shared_ptr<class Box_ipma>& ipma,\n                                                        uint32_t box_type) const\n{\n  const std::vector<Box_ipma::PropertyAssociation>* property_assoc = ipma->get_properties_for_item_ID(itemID);\n  if (property_assoc == nullptr) {\n    return nullptr;\n  }\n\n  auto allProperties = get_all_child_boxes();\n  for (const  Box_ipma::PropertyAssociation& assoc : *property_assoc) {\n    if (assoc.property_index > allProperties.size() ||\n        assoc.property_index == 0) {\n      return nullptr;\n    }\n\n    auto property = allProperties[assoc.property_index - 1];\n    if (property->get_short_type() == box_type) {\n      return property;\n    }\n  }\n\n  return nullptr;\n}\n\n\nError Box_ispe::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_image_width = range.read32();\n  m_image_height = range.read32();\n\n  return range.get_error();\n}\n\n\nstd::string Box_ispe::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"image width: \" << m_image_width << \"\\n\"\n       << indent << \"image height: \" << m_image_height << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_ispe::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write32(m_image_width);\n  writer.write32(m_image_height);\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_ipma::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  int entry_cnt = range.read32();\n  for (int i = 0; i < entry_cnt && !range.error() && !range.eof(); i++) {\n    Entry entry;\n    if (get_version()<1) {\n      entry.item_ID = range.read16();\n    }\n    else {\n      entry.item_ID = range.read32();\n    }\n\n    int assoc_cnt = range.read8();\n    for (int k=0;k<assoc_cnt;k++) {\n      PropertyAssociation association;\n\n      uint16_t index;\n      if (get_flags() & 1) {\n        index = range.read16();\n        association.essential = !!(index & 0x8000);\n        association.property_index = (index & 0x7fff);\n      }\n      else {\n        index = range.read8();\n        association.essential = !!(index & 0x80);\n        association.property_index = (index & 0x7f);\n      }\n\n      entry.associations.push_back(association);\n    }\n\n    m_entries.push_back(entry);\n  }\n\n  return range.get_error();\n}\n\n\nconst std::vector<Box_ipma::PropertyAssociation>* Box_ipma::get_properties_for_item_ID(uint32_t itemID) const\n{\n  for (const auto& entry : m_entries) {\n    if (entry.item_ID == itemID) {\n      return &entry.associations;\n    }\n  }\n\n  return nullptr;\n}\n\n\nvoid Box_ipma::add_property_for_item_ID(heif_item_id itemID,\n                                        PropertyAssociation assoc)\n{\n  size_t idx;\n  for (idx=0; idx<m_entries.size(); idx++) {\n    if (m_entries[idx].item_ID == itemID) {\n      break;\n    }\n  }\n\n  // if itemID does not exist, add a new entry\n  if (idx == m_entries.size()) {\n    Entry entry;\n    entry.item_ID = itemID;\n    m_entries.push_back(entry);\n  }\n\n  // add the property association\n  m_entries[idx].associations.push_back(assoc);\n}\n\n\nstd::string Box_ipma::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const Entry& entry : m_entries) {\n    sstr << indent << \"associations for item ID: \" << entry.item_ID << \"\\n\";\n    indent++;\n    for (const auto& assoc : entry.associations) {\n      sstr << indent << \"property index: \" << assoc.property_index\n           << \" (essential: \" << std::boolalpha << assoc.essential << \")\\n\";\n    }\n    indent--;\n  }\n\n  return sstr.str();\n}\n\n\nvoid Box_ipma::derive_box_version()\n{\n  int version = 0;\n  bool large_property_indices = false;\n\n  for (const Entry& entry : m_entries) {\n    if (entry.item_ID > 0xFFFF) {\n      version = 1;\n    }\n\n    for (const auto& assoc : entry.associations) {\n      if (assoc.property_index > 0x7F) {\n        large_property_indices=true;\n      }\n    }\n  }\n\n  set_version((uint8_t)version);\n  set_flags(large_property_indices ? 1 : 0);\n}\n\n\nError Box_ipma::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  size_t entry_cnt = m_entries.size();\n  writer.write32((uint32_t)entry_cnt);\n\n  for (const Entry& entry : m_entries) {\n\n    if (get_version()<1) {\n      writer.write16((uint16_t)entry.item_ID);\n    }\n    else {\n      writer.write32(entry.item_ID);\n    }\n\n    size_t assoc_cnt = entry.associations.size();\n    if (assoc_cnt > 0xFF) {\n      // TODO: error, too many associations\n    }\n\n    writer.write8((uint8_t)assoc_cnt);\n\n    for (const PropertyAssociation& association : entry.associations) {\n\n      if (get_flags() & 1) {\n        writer.write16( (uint16_t)((association.essential ? 0x8000 : 0) |\n                                   (association.property_index & 0x7FFF)) );\n      }\n      else {\n        writer.write8( (uint8_t)((association.essential ? 0x80 : 0) |\n                                 (association.property_index & 0x7F)) );\n      }\n    }\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_auxC::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_aux_type = range.read_string();\n\n  while (!range.eof()) {\n    m_aux_subtypes.push_back( range.read8() );\n  }\n\n  return range.get_error();\n}\n\n\nError Box_auxC::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  writer.write(m_aux_type);\n\n  for (uint8_t subtype : m_aux_subtypes) {\n    writer.write8(subtype);\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nstd::string Box_auxC::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"aux type: \" << m_aux_type << \"\\n\"\n       << indent << \"aux subtypes: \";\n  for (uint8_t subtype : m_aux_subtypes) {\n    sstr << std::hex << std::setw(2) << std::setfill('0') << ((int)subtype) << \" \";\n  }\n\n  sstr << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_irot::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  uint16_t rotation = range.read8();\n  rotation &= 0x03;\n\n  m_rotation = rotation * 90;\n\n  return range.get_error();\n}\n\n\nstd::string Box_irot::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"rotation: \" << m_rotation << \" degrees (CCW)\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_imir::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  uint16_t axis = range.read8();\n  if (axis & 1) {\n    m_axis = MirrorAxis::Horizontal;\n  }\n  else {\n    m_axis = MirrorAxis::Vertical;\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_imir::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"mirror axis: \";\n  switch (m_axis) {\n  case MirrorAxis::Vertical:   sstr << \"vertical\\n\"; break;\n  case MirrorAxis::Horizontal: sstr << \"horizontal\\n\"; break;\n  }\n\n  return sstr.str();\n}\n\n\nError Box_clap::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  m_clean_aperture_width.numerator   = range.read32();\n  m_clean_aperture_width.denominator = range.read32();\n  m_clean_aperture_height.numerator   = range.read32();\n  m_clean_aperture_height.denominator = range.read32();\n  m_horizontal_offset.numerator   = range.read32();\n  m_horizontal_offset.denominator = range.read32();\n  m_vertical_offset.numerator   = range.read32();\n  m_vertical_offset.denominator = range.read32();\n  if (!m_clean_aperture_width.is_valid() || !m_clean_aperture_height.is_valid() ||\n      !m_horizontal_offset.is_valid() || !m_vertical_offset.is_valid()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_Invalid_fractional_number);\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_clap::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"clean_aperture: \" << m_clean_aperture_width.numerator\n       << \"/\" << m_clean_aperture_width.denominator << \" x \"\n       << m_clean_aperture_height.numerator << \"/\"\n       << m_clean_aperture_height.denominator << \"\\n\";\n  sstr << indent << \"offset: \" << m_horizontal_offset.numerator << \"/\"\n       << m_horizontal_offset.denominator << \" ; \"\n       << m_vertical_offset.numerator << \"/\"\n       << m_vertical_offset.denominator << \"\\n\";\n\n  return sstr.str();\n}\n\n\nint Box_clap::left_rounded(int image_width) const\n{\n  // pcX = horizOff + (width  - 1)/2\n  // pcX \u00b1 (cleanApertureWidth - 1)/2\n\n  // left = horizOff + (width-1)/2 - (clapWidth-1)/2\n\n  Fraction pcX  = m_horizontal_offset + Fraction(image_width-1, 2);\n  Fraction left = pcX - (m_clean_aperture_width-1)/2;\n\n  return left.round();\n}\n\nint Box_clap::right_rounded(int image_width) const\n{\n  Fraction pcX  = m_horizontal_offset + Fraction(image_width-1, 2);\n  Fraction right = pcX + (m_clean_aperture_width-1)/2;\n\n  return right.round();\n}\n\nint Box_clap::top_rounded(int image_height) const\n{\n  Fraction pcY  = m_vertical_offset + Fraction(image_height-1, 2);\n  Fraction top = pcY - (m_clean_aperture_height-1)/2;\n\n  return top.round();\n}\n\nint Box_clap::bottom_rounded(int image_height) const\n{\n  Fraction pcY  = m_vertical_offset + Fraction(image_height-1, 2);\n  Fraction bottom = pcY + (m_clean_aperture_height-1)/2;\n\n  return bottom.round();\n}\n\nint Box_clap::get_width_rounded() const\n{\n  int left  = (Fraction(0,1)-(m_clean_aperture_width-1)/2).round();\n  int right = (  (m_clean_aperture_width-1)/2).round();\n\n  return right+1-left;\n}\n\nint Box_clap::get_height_rounded() const\n{\n  int top    = (Fraction(0,1)-(m_clean_aperture_height-1)/2).round();\n  int bottom = ( (m_clean_aperture_height-1)/2).round();\n\n  return bottom+1-top;\n}\n\n\n\nError Box_iref::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  while (!range.eof()) {\n    Reference ref;\n\n    Error err = ref.header.parse(range);\n    if (err != Error::Ok) {\n      return err;\n    }\n\n    if (get_version()==0) {\n      ref.from_item_ID = range.read16();\n      int nRefs = range.read16();\n      for (int i=0;i<nRefs;i++) {\n        ref.to_item_ID.push_back( range.read16() );\n        if (range.eof()) {\n          break;\n        }\n      }\n    }\n    else {\n      ref.from_item_ID = range.read32();\n      int nRefs = range.read16();\n      for (int i=0;i<nRefs;i++) {\n        ref.to_item_ID.push_back( range.read32() );\n        if (range.eof()) {\n          break;\n        }\n      }\n    }\n\n    m_references.push_back(ref);\n  }\n\n  return range.get_error();\n}\n\n\nvoid Box_iref::derive_box_version()\n{\n  uint8_t version = 0;\n\n  for (const auto& ref : m_references) {\n    if (ref.from_item_ID > 0xFFFF) {\n      version=1;\n      break;\n    }\n\n    for (uint32_t r : ref.to_item_ID) {\n      if (r > 0xFFFF) {\n        version=1;\n        break;\n      }\n    }\n  }\n\n  set_version(version);\n}\n\n\nError Box_iref::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  int id_size = ((get_version()==0) ? 2 : 4);\n\n  for (const auto& ref : m_references) {\n    uint32_t box_size = uint32_t(4+4 + 2 + id_size * (1+ref.to_item_ID.size()));\n\n    // we write the BoxHeader ourselves since it is very simple\n    writer.write32(box_size);\n    writer.write32(ref.header.get_short_type());\n\n    writer.write(id_size, ref.from_item_ID);\n    writer.write16((uint16_t)ref.to_item_ID.size());\n\n    for (uint32_t r : ref.to_item_ID) {\n      writer.write(id_size, r);\n    }\n  }\n\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nstd::string Box_iref::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const auto& ref : m_references) {\n    sstr << indent << \"reference with type '\" << ref.header.get_type_string() << \"'\"\n         << \" from ID: \" << ref.from_item_ID\n         << \" to IDs: \";\n    for (uint32_t id : ref.to_item_ID) {\n      sstr << id << \" \";\n    }\n    sstr << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nbool Box_iref::has_references(uint32_t itemID) const\n{\n  for (const Reference& ref : m_references) {\n    if (ref.from_item_ID == itemID) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\nstd::vector<Box_iref::Reference> Box_iref::get_references_from(heif_item_id itemID) const\n{\n  std::vector<Reference> references;\n\n  for (const Reference& ref : m_references) {\n    if (ref.from_item_ID == itemID) {\n      references.push_back(ref);\n    }\n  }\n\n  return references;\n}\n\n\nstd::vector<uint32_t> Box_iref::get_references(uint32_t itemID, uint32_t ref_type) const\n{\n  for (const Reference& ref : m_references) {\n    if (ref.from_item_ID == itemID &&\n        ref.header.get_short_type() == ref_type) {\n      return ref.to_item_ID;\n    }\n  }\n\n  return std::vector<uint32_t>();\n}\n\n\nvoid Box_iref::add_reference(heif_item_id from_id, uint32_t type, std::vector<heif_item_id> to_ids)\n{\n  Reference ref;\n  ref.header.set_short_type(type);\n  ref.from_item_ID = from_id;\n  ref.to_item_ID = to_ids;\n\n  m_references.push_back(ref);\n}\n\n\nError Box_hvcC::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  uint8_t byte;\n\n  auto& c = m_configuration; // abbreviation\n\n  c.configuration_version = range.read8();\n  byte = range.read8();\n  c.general_profile_space = (byte>>6) & 3;\n  c.general_tier_flag = (byte>>5) & 1;\n  c.general_profile_idc = (byte & 0x1F);\n\n  c.general_profile_compatibility_flags = range.read32();\n\n  for (int i=0; i<6; i++)\n    {\n      byte = range.read8();\n\n      for (int b=0;b<8;b++) {\n        c.general_constraint_indicator_flags[i*8+b] = (byte >> (7-b)) & 1;\n      }\n    }\n\n  c.general_level_idc = range.read8();\n  c.min_spatial_segmentation_idc = range.read16() & 0x0FFF;\n  c.parallelism_type = range.read8() & 0x03;\n  c.chroma_format = range.read8() & 0x03;\n  c.bit_depth_luma = static_cast<uint8_t>((range.read8() & 0x07) + 8);\n  c.bit_depth_chroma = static_cast<uint8_t>((range.read8() & 0x07) + 8);\n  c.avg_frame_rate = range.read16();\n\n  byte = range.read8();\n  c.constant_frame_rate = (byte >> 6) & 0x03;\n  c.num_temporal_layers = (byte >> 3) & 0x07;\n  c.temporal_id_nested = (byte >> 2) & 1;\n\n  m_length_size = static_cast<uint8_t>((byte & 0x03) + 1);\n\n  int nArrays = range.read8();\n\n  for (int i=0; i<nArrays && !range.error(); i++)\n    {\n      byte = range.read8();\n\n      NalArray array;\n\n      array.m_array_completeness = (byte >> 6) & 1;\n      array.m_NAL_unit_type = (byte & 0x3F);\n\n      int nUnits = range.read16();\n      for (int u=0; u<nUnits && !range.error(); u++) {\n\n        std::vector<uint8_t> nal_unit;\n        int size = range.read16();\n        if (!size) {\n          // Ignore empty NAL units.\n          continue;\n        }\n\n        if (range.prepare_read(size)) {\n          nal_unit.resize(size);\n          range.get_istream()->read((char*)nal_unit.data(), size);\n        }\n\n        array.m_nal_units.push_back( std::move(nal_unit) );\n      }\n\n      m_nal_array.push_back( std::move(array) );\n    }\n\n  range.skip_to_end_of_box();\n\n  return range.get_error();\n}\n\n\nstd::string Box_hvcC::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  const auto& c = m_configuration; // abbreviation\n\n  sstr << indent << \"configuration_version: \" << ((int)c.configuration_version) << \"\\n\"\n       << indent << \"general_profile_space: \" << ((int)c.general_profile_space) << \"\\n\"\n       << indent << \"general_tier_flag: \" << c.general_tier_flag << \"\\n\"\n       << indent << \"general_profile_idc: \" << ((int)c.general_profile_idc) << \"\\n\";\n\n  sstr << indent << \"general_profile_compatibility_flags: \";\n  for (int i=0;i<32;i++) {\n    sstr << ((c.general_profile_compatibility_flags>>(31-i))&1);\n    if ((i%8)==7) sstr << ' ';\n    else if ((i%4)==3) sstr << '.';\n  }\n  sstr << \"\\n\";\n\n  sstr << indent << \"general_constraint_indicator_flags: \";\n  int cnt=0;\n  for (int i=0; i<configuration::NUM_CONSTRAINT_INDICATOR_FLAGS; i++) {\n    bool b = c.general_constraint_indicator_flags[i];\n\n    sstr << (b ? 1:0);\n    cnt++;\n    if ((cnt%8)==0)\n      sstr << ' ';\n  }\n  sstr << \"\\n\";\n\n  sstr << indent << \"general_level_idc: \" << ((int)c.general_level_idc) << \"\\n\"\n       << indent << \"min_spatial_segmentation_idc: \" << c.min_spatial_segmentation_idc << \"\\n\"\n       << indent << \"parallelism_type: \" << ((int)c.parallelism_type) << \"\\n\"\n       << indent << \"chroma_format: \" << ((int)c.chroma_format) << \"\\n\"\n       << indent << \"bit_depth_luma: \" << ((int)c.bit_depth_luma) << \"\\n\"\n       << indent << \"bit_depth_chroma: \" << ((int)c.bit_depth_chroma) << \"\\n\"\n       << indent << \"avg_frame_rate: \" << c.avg_frame_rate << \"\\n\"\n       << indent << \"constant_frame_rate: \" << ((int)c.constant_frame_rate) << \"\\n\"\n       << indent << \"num_temporal_layers: \" << ((int)c.num_temporal_layers) << \"\\n\"\n       << indent << \"temporal_id_nested: \" << ((int)c.temporal_id_nested) << \"\\n\"\n       << indent << \"length_size: \" << ((int)m_length_size) << \"\\n\";\n\n  for (const auto& array : m_nal_array) {\n    sstr << indent << \"<array>\\n\";\n\n    indent++;\n    sstr << indent << \"array_completeness: \" << ((int)array.m_array_completeness) << \"\\n\"\n         << indent << \"NAL_unit_type: \" << ((int)array.m_NAL_unit_type) << \"\\n\";\n\n    for (const auto& unit : array.m_nal_units) {\n      //sstr << \"  unit with \" << unit.size() << \" bytes of data\\n\";\n      sstr << indent;\n      for (uint8_t b : unit) {\n        sstr << std::setfill('0') << std::setw(2) << std::hex << ((int)b) << \" \";\n      }\n      sstr << \"\\n\";\n      sstr << std::dec;\n    }\n\n    indent--;\n  }\n\n  return sstr.str();\n}\n\n\nbool Box_hvcC::get_headers(std::vector<uint8_t>* dest) const\n{\n  for (const auto& array : m_nal_array) {\n    for (const auto& unit : array.m_nal_units) {\n\n      dest->push_back( (unit.size()>>24) & 0xFF );\n      dest->push_back( (unit.size()>>16) & 0xFF );\n      dest->push_back( (unit.size()>> 8) & 0xFF );\n      dest->push_back( (unit.size()>> 0) & 0xFF );\n\n      /*\n      dest->push_back(0);\n      dest->push_back(0);\n      dest->push_back(1);\n      */\n\n      dest->insert(dest->end(), unit.begin(), unit.end());\n    }\n  }\n\n  return true;\n}\n\n\nvoid Box_hvcC::append_nal_data(const std::vector<uint8_t>& nal)\n{\n  NalArray array;\n  array.m_array_completeness = 0;\n  array.m_NAL_unit_type = uint8_t(nal[0]>>1);\n  array.m_nal_units.push_back(nal);\n\n  m_nal_array.push_back(array);\n}\n\nvoid Box_hvcC::append_nal_data(const uint8_t* data, size_t size)\n{\n  std::vector<uint8_t> nal;\n  nal.resize(size);\n  memcpy(nal.data(), data, size);\n\n  NalArray array;\n  array.m_array_completeness = 0;\n  array.m_NAL_unit_type = uint8_t(nal[0]>>1);\n  array.m_nal_units.push_back( std::move(nal) );\n\n  m_nal_array.push_back(array);\n}\n\n\nError Box_hvcC::write(StreamWriter& writer) const\n{\n  size_t box_start = reserve_box_header_space(writer);\n\n  const auto& c = m_configuration; // abbreviation\n\n  writer.write8(c.configuration_version);\n\n  writer.write8((uint8_t)(((c.general_profile_space & 3) << 6) |\n                          ((c.general_tier_flag & 1) << 5) |\n                          (c.general_profile_idc & 0x1F)));\n\n  writer.write32(c.general_profile_compatibility_flags);\n\n  for (int i=0; i<6; i++)\n    {\n      uint8_t byte = 0;\n\n      for (int b=0;b<8;b++) {\n        if (c.general_constraint_indicator_flags[i*8+b]) {\n          byte |= 1;\n        }\n\n        byte = (uint8_t)(byte<<1);\n      }\n\n      writer.write8(byte);\n    }\n\n  writer.write8(c.general_level_idc);\n  writer.write16((c.min_spatial_segmentation_idc & 0x0FFF) | 0xF000);\n  writer.write8(c.parallelism_type | 0xFC);\n  writer.write8(c.chroma_format | 0xFC);\n  writer.write8((uint8_t)((c.bit_depth_luma - 8) | 0xF8));\n  writer.write8((uint8_t)((c.bit_depth_chroma - 8) | 0xF8));\n  writer.write16(c.avg_frame_rate);\n\n  writer.write8((uint8_t)(((c.constant_frame_rate & 0x03) << 6) |\n                          ((c.num_temporal_layers & 0x07) << 3) |\n                          ((c.temporal_id_nested & 1) << 2) |\n                          ((m_length_size-1) & 0x03)));\n\n  size_t nArrays = m_nal_array.size();\n  if (nArrays>0xFF) {\n    // TODO: error: too many NAL units\n  }\n\n  writer.write8((uint8_t)nArrays);\n\n  for (const NalArray& array : m_nal_array) {\n\n    writer.write8((uint8_t)(((array.m_array_completeness & 1) << 6) |\n                            (array.m_NAL_unit_type & 0x3F)));\n\n    size_t nUnits = array.m_nal_units.size();\n    if (nUnits > 0xFFFF) {\n      // TODO: error: too many NAL units\n    }\n\n    writer.write16((uint16_t)nUnits);\n\n    for (const std::vector<uint8_t>& nal_unit : array.m_nal_units) {\n      writer.write16((uint16_t)nal_unit.size());\n      writer.write(nal_unit);\n    }\n  }\n\n  prepend_header(writer, box_start);\n\n  return Error::Ok;\n}\n\n\nError Box_idat::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  m_data_start_pos = range.get_istream()->get_position();\n\n  return range.get_error();\n}\n\n\nstd::string Box_idat::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  sstr << indent << \"number of data bytes: \" << get_box_size() - get_header_size() << \"\\n\";\n\n  return sstr.str();\n}\n\n\nError Box_idat::read_data(std::shared_ptr<StreamReader> istr,\n                          uint64_t start, uint64_t length,\n                          std::vector<uint8_t>& out_data) const\n{\n  // --- security check that we do not allocate too much data\n\n  auto curr_size = out_data.size();\n\n  if (MAX_MEMORY_BLOCK_SIZE - curr_size < length) {\n    std::stringstream sstr;\n    sstr << \"idat box contained \" << length << \" bytes, total memory size would be \"\n         << (curr_size + length) << \" bytes, exceeding the security limit of \"\n         << MAX_MEMORY_BLOCK_SIZE << \" bytes\";\n\n    return Error(heif_error_Memory_allocation_error,\n                 heif_suberror_Security_limit_exceeded,\n                 sstr.str());\n  }\n\n\n  // move to start of data\n  if (start > (uint64_t)m_data_start_pos + get_box_size()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  } else if (length > get_box_size() || start + length > get_box_size()) {\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  StreamReader::grow_status status = istr->wait_for_file_size((int64_t)m_data_start_pos + start + length);\n  if (status == StreamReader::size_beyond_eof ||\n      status == StreamReader::timeout) {\n    // TODO: maybe we should introduce some 'Recoverable error' instead of 'Invalid input'\n    return Error(heif_error_Invalid_input,\n                 heif_suberror_End_of_data);\n  }\n\n  bool success;\n  success = istr->seek(m_data_start_pos + (std::streampos)start);\n  assert(success);\n  (void)success;\n\n  // reserve space for the data in the output array\n\n  out_data.resize(static_cast<size_t>(curr_size + length));\n  uint8_t* data = &out_data[curr_size];\n\n  success = istr->read((char*)data, static_cast<size_t>(length));\n  assert(success);\n\n  return Error::Ok;\n}\n\n\nError Box_grpl::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  //return read_children(range);\n\n  while (!range.eof()) {\n    EntityGroup group;\n    Error err = group.header.parse(range);\n    if (err != Error::Ok) {\n      return err;\n    }\n\n    err = group.header.parse_full_box_header(range);\n    if (err != Error::Ok) {\n      return err;\n    }\n\n    group.group_id = range.read32();\n    int nEntities = range.read32();\n    for (int i=0;i<nEntities;i++) {\n      if (range.eof()) {\n        break;\n      }\n\n      group.entity_ids.push_back( range.read32() );\n    }\n\n    m_entity_groups.push_back(group);\n  }\n\n  return range.get_error();\n}\n\n\nstd::string Box_grpl::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n\n  for (const auto& group : m_entity_groups) {\n    sstr << indent << \"group type: \" << group.header.get_type_string() << \"\\n\"\n         << indent << \"| group id: \" << group.group_id << \"\\n\"\n         << indent << \"| entity IDs: \";\n\n    for (uint32_t id : group.entity_ids) {\n      sstr << id << \" \";\n    }\n\n    sstr << \"\\n\";\n  }\n\n  return sstr.str();\n}\n\n\nError Box_dinf::parse(BitstreamRange& range)\n{\n  //parse_full_box_header(range);\n\n  return read_children(range);\n}\n\n\nstd::string Box_dinf::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_dref::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  int nEntities = range.read32();\n\n  /*\n  for (int i=0;i<nEntities;i++) {\n    if (range.eof()) {\n      break;\n    }\n  }\n  */\n\n  Error err = read_children(range, nEntities);\n  if (err) {\n    return err;\n  }\n\n  if ((int)m_children.size() != nEntities) {\n    // TODO return Error(\n  }\n\n  return err;\n}\n\n\nstd::string Box_dref::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  sstr << dump_children(indent);\n\n  return sstr.str();\n}\n\n\nError Box_url::parse(BitstreamRange& range)\n{\n  parse_full_box_header(range);\n\n  m_location = range.read_string();\n\n  return range.get_error();\n}\n\n\nstd::string Box_url::dump(Indent& indent) const\n{\n  std::ostringstream sstr;\n  sstr << Box::dump(indent);\n  //sstr << dump_children(indent);\n\n  sstr << indent << \"location: \" << m_location << \"\\n\";\n\n  return sstr.str();\n}\n", "/*\n * HEIF codec.\n * Copyright (c) 2018 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * This file is part of libheif.\n *\n * libheif is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libheif is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libheif.  If not, see <http://www.gnu.org/licenses/>.\n */\n#ifndef LIBHEIF_HEIF_LIMITS_H\n#define LIBHEIF_HEIF_LIMITS_H\n\n#if defined(HAVE_CONFIG_H)\n#include \"config.h\"\n#endif\n\n#if defined(HAVE_INTTYPES_H)\n#include <inttypes.h>\n#endif\n#if defined(HAVE_STDDEF_H)\n#include <stddef.h>\n#endif\n\nstatic const size_t MAX_CHILDREN_PER_BOX = 1024;\nstatic const int MAX_ILOC_ITEMS = 1024;\nstatic const int MAX_ILOC_EXTENTS_PER_ITEM = 32;\nstatic const int MAX_MEMORY_BLOCK_SIZE = 50*1024*1024; // 50 MB\n\n// Artificial limit to avoid allocating too much memory.\nstatic const int MAX_IMAGE_WIDTH = 16384;\nstatic const int MAX_IMAGE_HEIGHT = 16384;\n\n// Maximum nesting level of boxes in input files.\n// We put a limit on this to avoid unlimited stack usage by malicious input files.\nstatic const int MAX_BOX_NESTING_LEVEL = 20;\n\nstatic const int MAX_BOX_SIZE = 0x7FFFFFFF; // 2 GB\nstatic const int64_t MAX_LARGE_BOX_SIZE = 0x0FFFFFFFFFFFFFFF;\nstatic const int64_t MAX_FILE_POS = 0x007FFFFFFFFFFFFFLL; // maximum file position\nstatic const int MAX_FRACTION_VALUE = 0x10000;\n\n#endif  // LIBHEIF_HEIF_LIMITS_H\n"], "filenames": ["libheif/box.cc", "libheif/heif_limits.h"], "buggy_code_start_loc": [43, 50], "buggy_code_end_loc": [91, 51], "fixing_code_start_loc": [42, 50], "fixing_code_end_loc": [57, 51], "type": "NVD-CWE-noinfo", "message": "Floating point exception in function Fraction in libheif 1.4.0, allows attackers to cause a Denial of Service or possibly other unspecified impacts.", "other": {"cve": {"id": "CVE-2020-19498", "sourceIdentifier": "cve@mitre.org", "published": "2021-07-21T18:15:09.133", "lastModified": "2021-07-30T15:27:46.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Floating point exception in function Fraction in libheif 1.4.0, allows attackers to cause a Denial of Service or possibly other unspecified impacts."}, {"lang": "es", "value": "Una excepci\u00f3n de punto flotante en la funci\u00f3n Fraction en libheif versi\u00f3n 1.4.0, permite a atacantes causar una Denegaci\u00f3n de Servicio o posiblemente otros impactos no especificados"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:struktur:libheif:1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6F0C81ED-3820-41B5-8DB0-36E2BC6D993C"}]}]}], "references": [{"url": "https://github.com/strukturag/libheif/commit/2710c930918609caaf0a664e9c7bc3dce05d5b58", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/strukturag/libheif/issues/139", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/strukturag/libheif/commit/2710c930918609caaf0a664e9c7bc3dce05d5b58"}}