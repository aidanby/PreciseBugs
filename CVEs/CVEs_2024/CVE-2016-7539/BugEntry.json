{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                      CCCC   AAA    CCCC  H   H  EEEEE                       %\n%                     C      A   A  C      H   H  E                           %\n%                     C      AAAAA  C      HHHHH  EEE                         %\n%                     C      A   A  C      H   H  E                           %\n%                      CCCC  A   A   CCCC  H   H  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Pixel Cache Methods                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1999                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-private.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/composite-private.h\"\n#include \"magick/distribute-cache-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/memory-private.h\"\n#include \"magick/nt-base-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/policy.h\"\n#include \"magick/quantum.h\"\n#include \"magick/random_.h\"\n#include \"magick/registry.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/thread-private.h\"\n#include \"magick/utility.h\"\n#include \"magick/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n#include \"zlib.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define CacheTick(offset,extent)  QuantumTick((MagickOffsetType) offset,extent)\n#define IsFileDescriptorLimitExceeded() (GetMagickResource(FileResource) > \\\n  GetMagickResourceLimit(FileResource) ? MagickTrue : MagickFalse)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _MagickModulo\n{\n  ssize_t\n    quotient,\n    remainder;\n} MagickModulo;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic Cache\n  GetImagePixelCache(Image *,const MagickBooleanType,ExceptionInfo *)\n    magick_hot_spot;\n\nstatic const IndexPacket\n  *GetVirtualIndexesFromCache(const Image *);\n\nstatic const PixelPacket\n  *GetVirtualPixelCache(const Image *,const VirtualPixelMethod,const ssize_t,\n    const ssize_t,const size_t,const size_t,ExceptionInfo *),\n  *GetVirtualPixelsCache(const Image *);\n\nstatic MagickBooleanType\n  GetOneAuthenticPixelFromCache(Image *,const ssize_t,const ssize_t,\n    PixelPacket *,ExceptionInfo *),\n  GetOneVirtualPixelFromCache(const Image *,const VirtualPixelMethod,\n    const ssize_t,const ssize_t,PixelPacket *,ExceptionInfo *),\n  OpenPixelCache(Image *,const MapMode,ExceptionInfo *),\n  OpenPixelCacheOnDisk(CacheInfo *,const MapMode),\n  ReadPixelCacheIndexes(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  ReadPixelCachePixels(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  SyncAuthenticPixelsCache(Image *,ExceptionInfo *),\n  WritePixelCacheIndexes(CacheInfo *,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  WritePixelCachePixels(CacheInfo *,NexusInfo *magick_restrict,\n    ExceptionInfo *);\n\nstatic PixelPacket\n  *GetAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *QueueAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *SetPixelCacheNexusPixels(const CacheInfo *,const MapMode,\n    const RectangleInfo *,const MagickBooleanType,NexusInfo *,ExceptionInfo *)\n    magick_hot_spot;\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic volatile MagickBooleanType\n  instantiate_cache = MagickFalse;\n\nstatic SemaphoreInfo\n  *cache_semaphore = (SemaphoreInfo *) NULL;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCache() acquires a pixel cache.\n%\n%  The format of the AcquirePixelCache() method is:\n%\n%      Cache AcquirePixelCache(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickExport Cache AcquirePixelCache(const size_t number_threads)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  char\n    *synchronize;\n\n  cache_info=(CacheInfo *) AcquireQuantumMemory(1,sizeof(*cache_info));\n  if (cache_info == (CacheInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(cache_info,0,sizeof(*cache_info));\n  cache_info->type=UndefinedCache;\n  cache_info->mode=IOMode;\n  cache_info->colorspace=sRGBColorspace;\n  cache_info->channels=4;\n  cache_info->file=(-1);\n  cache_info->id=GetMagickThreadId();\n  cache_info->number_threads=number_threads;\n  if (GetOpenMPMaximumThreads() > cache_info->number_threads)\n    cache_info->number_threads=GetOpenMPMaximumThreads();\n  if (GetMagickResourceLimit(ThreadResource) > cache_info->number_threads)\n    cache_info->number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  if (cache_info->number_threads == 0)\n    cache_info->number_threads=1;\n  cache_info->nexus_info=AcquirePixelCacheNexus(cache_info->number_threads);\n  if (cache_info->nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      cache_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  cache_info->semaphore=AllocateSemaphoreInfo();\n  cache_info->reference_count=1;\n  cache_info->file_semaphore=AllocateSemaphoreInfo();\n  cache_info->debug=IsEventLogging();\n  cache_info->signature=MagickSignature;\n  return((Cache ) cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCacheNexus() allocates the NexusInfo structure.\n%\n%  The format of the AcquirePixelCacheNexus method is:\n%\n%      NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickExport NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n{\n  NexusInfo\n    **magick_restrict nexus_info;\n\n  register ssize_t\n    i;\n\n  nexus_info=(NexusInfo **) MagickAssumeAligned(AcquireAlignedMemory(\n    number_threads,sizeof(*nexus_info)));\n  if (nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  nexus_info[0]=(NexusInfo *) AcquireQuantumMemory(number_threads,\n    sizeof(**nexus_info));\n  if (nexus_info[0] == (NexusInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(nexus_info[0],0,number_threads*sizeof(**nexus_info));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    nexus_info[i]=(&nexus_info[0][i]);\n    nexus_info[i]->signature=MagickSignature;\n  }\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e P i x e l s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCachePixels() returns the pixels associated with the specified\n%  image.\n%\n%  The format of the AcquirePixelCachePixels() method is:\n%\n%      const void *AcquirePixelCachePixels(const Image *image,\n%        MagickSizeType *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const void *AcquirePixelCachePixels(const Image *image,\n  MagickSizeType *length,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  (void) exception;\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((const void *) NULL);\n  *length=cache_info->length;\n  return((const void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t G e n e s i s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentGenesis() instantiates the cache component.\n%\n%  The format of the CacheComponentGenesis method is:\n%\n%      MagickBooleanType CacheComponentGenesis(void)\n%\n*/\nMagickExport MagickBooleanType CacheComponentGenesis(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    cache_semaphore=AllocateSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t T e r m i n u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentTerminus() destroys the cache component.\n%\n%  The format of the CacheComponentTerminus() method is:\n%\n%      CacheComponentTerminus(void)\n%\n*/\nMagickExport void CacheComponentTerminus(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&cache_semaphore);\n  LockSemaphoreInfo(cache_semaphore);\n  instantiate_cache=MagickFalse;\n  UnlockSemaphoreInfo(cache_semaphore);\n  DestroySemaphoreInfo(&cache_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l i p P i x e l C a c h e N e x u s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClipPixelCacheNexus() clips the cache nexus as defined by the image clip\n%  mask.  The method returns MagickTrue if the pixel region is clipped,\n%  otherwise MagickFalse.\n%\n%  The format of the ClipPixelCacheNexus() method is:\n%\n%      MagickBooleanType ClipPixelCacheNexus(Image *image,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to clip.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType ClipPixelCacheNexus(Image *image,\n  NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickSizeType\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict clip_nexus,\n    **magick_restrict image_nexus;\n\n  register const PixelPacket\n    *magick_restrict r;\n\n  register IndexPacket\n    *magick_restrict nexus_indexes,\n    *magick_restrict indexes;\n\n  register PixelPacket\n    *magick_restrict p,\n    *magick_restrict q;\n\n  register ssize_t\n    i;\n\n  /*\n    Apply clip mask.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->clip_mask == (Image *) NULL) ||\n      (image->storage_class == PseudoClass))\n    return(MagickTrue);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return(MagickFalse);\n  image_nexus=AcquirePixelCacheNexus(1);\n  clip_nexus=AcquirePixelCacheNexus(1);\n  if ((image_nexus == (NexusInfo **) NULL) ||\n      (clip_nexus == (NexusInfo **) NULL))\n    ThrowBinaryException(CacheError,\"UnableToGetCacheNexus\",image->filename);\n  p=GetAuthenticPixelCacheNexus(image,nexus_info->region.x,nexus_info->region.y,\n    nexus_info->region.width,nexus_info->region.height,image_nexus[0],\n    exception);\n  indexes=image_nexus[0]->indexes;\n  q=nexus_info->pixels;\n  nexus_indexes=nexus_info->indexes;\n  r=GetVirtualPixelsFromNexus(image->clip_mask,MaskVirtualPixelMethod,\n    nexus_info->region.x,nexus_info->region.y,nexus_info->region.width,\n    nexus_info->region.height,clip_nexus[0],exception);\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  for (i=0; i < (ssize_t) number_pixels; i++)\n  {\n    if ((p == (PixelPacket *) NULL) || (r == (const PixelPacket *) NULL))\n      break;\n    if (GetPixelIntensity(image,r) > (QuantumRange/2.0))\n      {\n        SetPixelRed(q,GetPixelRed(p));\n        SetPixelGreen(q,GetPixelGreen(p));\n        SetPixelBlue(q,GetPixelBlue(p));\n        SetPixelOpacity(q,GetPixelOpacity(p));\n        if (cache_info->active_index_channel != MagickFalse)\n          SetPixelIndex(nexus_indexes+i,GetPixelIndex(indexes+i));\n      }\n    p++;\n    q++;\n    r++;\n  }\n  clip_nexus=DestroyPixelCacheNexus(clip_nexus,1);\n  image_nexus=DestroyPixelCacheNexus(image_nexus,1);\n  if (i < (ssize_t) number_pixels)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCache() clones a pixel cache.\n%\n%  The format of the ClonePixelCache() method is:\n%\n%      Cache ClonePixelCache(const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport Cache ClonePixelCache(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict clone_info;\n\n  const CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != NULL);\n  cache_info=(const CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  clone_info=(CacheInfo *) AcquirePixelCache(cache_info->number_threads);\n  if (clone_info == (Cache) NULL)\n    return((Cache) NULL);\n  clone_info->virtual_pixel_method=cache_info->virtual_pixel_method;\n  return((Cache ) clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCacheMethods() clones the pixel cache methods from one cache to\n%  another.\n%\n%  The format of the ClonePixelCacheMethods() method is:\n%\n%      void ClonePixelCacheMethods(Cache clone,const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o clone: Specifies a pointer to a Cache structure.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport void ClonePixelCacheMethods(Cache clone,const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict source_info;\n\n  assert(clone != (Cache) NULL);\n  source_info=(CacheInfo *) clone;\n  assert(source_info->signature == MagickSignature);\n  if (source_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      source_info->filename);\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  source_info->methods=cache_info->methods;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e R e p o s i t o r y                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %\n%  ClonePixelCacheRepository() clones the source pixel cache to the destination\n%  cache.\n%\n%  The format of the ClonePixelCacheRepository() method is:\n%\n%      MagickBooleanType ClonePixelCacheRepository(CacheInfo *cache_info,\n%        CacheInfo *source_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o source_info: the source pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType ClonePixelCacheOnDisk(\n  CacheInfo *magick_restrict cache_info,CacheInfo *magick_restrict clone_info,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    extent;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Clone pixel cache on disk with identical morphology.\n  */\n  if ((OpenPixelCacheOnDisk(cache_info,ReadMode) == MagickFalse) ||\n      (OpenPixelCacheOnDisk(clone_info,IOMode) == MagickFalse))\n    return(MagickFalse);\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(cache_info->file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  extent=0;\n  while ((count=read(cache_info->file,buffer,quantum)) > 0)\n  {\n    ssize_t\n      number_bytes;\n\n    number_bytes=write(clone_info->file,buffer,(size_t) count);\n    if (number_bytes != count)\n      break;\n    extent+=number_bytes;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if (extent != cache_info->length)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ClonePixelCacheRepository(\n  CacheInfo *magick_restrict clone_info,CacheInfo *magick_restrict cache_info,\n  ExceptionInfo *exception)\n{\n#define MaxCacheThreads  2\n#define cache_threads(source,destination) \\\n  num_threads(((source)->type == DiskCache) || \\\n    ((destination)->type == DiskCache) || (((source)->rows) < \\\n    (16*GetMagickResourceLimit(ThreadResource))) ? 1 : \\\n    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \\\n    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)\n\n  MagickBooleanType\n    status;\n\n  NexusInfo\n    **magick_restrict cache_nexus,\n    **magick_restrict clone_nexus;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  assert(cache_info != (CacheInfo *) NULL);\n  assert(clone_info != (CacheInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  if ((cache_info->columns == clone_info->columns) &&\n      (cache_info->rows == clone_info->rows) &&\n      (cache_info->active_index_channel == clone_info->active_index_channel))\n    {\n      /*\n        Identical pixel cache morphology.\n      */\n      if (((cache_info->type == MemoryCache) ||\n           (cache_info->type == MapCache)) &&\n          ((clone_info->type == MemoryCache) ||\n           (clone_info->type == MapCache)))\n        {\n          (void) memcpy(clone_info->pixels,cache_info->pixels,\n            cache_info->columns*cache_info->rows*sizeof(*cache_info->pixels));\n          if ((cache_info->active_index_channel != MagickFalse) &&\n              (clone_info->active_index_channel != MagickFalse))\n            (void) memcpy(clone_info->indexes,cache_info->indexes,\n              cache_info->columns*cache_info->rows*\n              sizeof(*cache_info->indexes));\n          return(MagickTrue);\n        }\n      if ((cache_info->type == DiskCache) && (clone_info->type == DiskCache))\n        return(ClonePixelCacheOnDisk(cache_info,clone_info,exception));\n    }\n  /*\n    Mismatched pixel cache morphology.\n  */\n  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  if ((cache_nexus == (NexusInfo **) NULL) ||\n      (clone_nexus == (NexusInfo **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n    sizeof(*cache_info->pixels);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    cache_threads(cache_info,clone_info)\n#endif\n  for (y=0; y < (ssize_t) cache_info->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    PixelPacket\n      *pixels;\n\n    RectangleInfo\n      region;\n\n    if (status == MagickFalse)\n      continue;\n    if (y == (ssize_t) clone_info->rows)\n      continue;\n    region.width=cache_info->columns;\n    region.height=1;\n    region.x=0;\n    region.y=y;\n    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n      cache_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);\n    if (status == MagickFalse)\n      continue;\n    region.width=clone_info->columns;\n    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n      clone_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)\n      clone_nexus[id]->length);\n    (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length);\n    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);\n  }\n  if ((cache_info->active_index_channel != MagickFalse) &&\n      (clone_info->active_index_channel != MagickFalse))\n    {\n      /*\n        Clone indexes.\n      */\n      length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n        sizeof(*cache_info->indexes);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        cache_threads(cache_info,clone_info)\n#endif\n      for (y=0; y < (ssize_t) cache_info->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        PixelPacket\n          *pixels;\n\n        RectangleInfo\n          region;\n\n        if (status == MagickFalse)\n          continue;\n        if (y == (ssize_t) clone_info->rows)\n          continue;\n        region.width=cache_info->columns;\n        region.height=1;\n        region.x=0;\n        region.y=y;\n        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n          cache_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        status=ReadPixelCacheIndexes(cache_info,cache_nexus[id],exception);\n        if (status == MagickFalse)\n          continue;\n        region.width=clone_info->columns;\n        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n          clone_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        (void) memcpy(clone_nexus[id]->indexes,cache_nexus[id]->indexes,length);\n        status=WritePixelCacheIndexes(clone_info,clone_nexus[id],exception);\n      }\n    }\n  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);\n  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MaxTextExtent];\n\n      (void) FormatLocaleString(message,MaxTextExtent,\"%s => %s\",\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l C a c h e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixelCache() method is:\n%\n%      void DestroyImagePixelCache(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic void DestroyImagePixelCache(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->cache == (void *) NULL)\n    return;\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixels() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixels() method is:\n%\n%      void DestroyImagePixels(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImagePixels(Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    {\n      cache_info->methods.destroy_pixel_handler(image);\n      return;\n    }\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyPixelCache() method is:\n%\n%      Cache DestroyPixelCache(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\n\nstatic MagickBooleanType ClosePixelCacheOnDisk(CacheInfo *cache_info)\n{\n  int\n    status;\n\n  status=(-1);\n  if (cache_info->file != -1)\n    {\n      status=close(cache_info->file);\n      cache_info->file=(-1);\n      RelinquishMagickResource(FileResource,1);\n    }\n  return(status == -1 ? MagickFalse : MagickTrue);\n}\n\nstatic inline void RelinquishPixelCachePixels(CacheInfo *cache_info)\n{\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    {\n      if (cache_info->mapped == MagickFalse)\n        cache_info->pixels=(PixelPacket *) RelinquishAlignedMemory(\n          cache_info->pixels);\n      else\n        {\n          (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n          cache_info->pixels=(PixelPacket *) NULL;\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n      break;\n    }\n    case MapCache:\n    {\n      (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n      cache_info->pixels=(PixelPacket *) NULL;\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n    case DiskCache:\n    {\n      if (cache_info->file != -1)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      break;\n    }\n    case DistributedCache:\n    {\n      *cache_info->cache_filename='\\0';\n      (void) RelinquishDistributePixelCache((DistributeCacheInfo *)\n        cache_info->server_info);\n      break;\n    }\n    default:\n      break;\n  }\n  cache_info->type=UndefinedCache;\n  cache_info->mapped=MagickFalse;\n  cache_info->indexes=(IndexPacket *) NULL;\n}\n\nMagickExport Cache DestroyPixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count--;\n  if (cache_info->reference_count != 0)\n    {\n      UnlockSemaphoreInfo(cache_info->semaphore);\n      return((Cache) NULL);\n    }\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MaxTextExtent];\n\n      (void) FormatLocaleString(message,MaxTextExtent,\"destroy %s\",\n        cache_info->filename);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  RelinquishPixelCachePixels(cache_info);\n  if (cache_info->server_info != (DistributeCacheInfo *) NULL)\n    cache_info->server_info=DestroyDistributeCacheInfo((DistributeCacheInfo *)\n      cache_info->server_info);\n  if (cache_info->nexus_info != (NexusInfo **) NULL)\n    cache_info->nexus_info=DestroyPixelCacheNexus(cache_info->nexus_info,\n      cache_info->number_threads);\n  if (cache_info->random_info != (RandomInfo *) NULL)\n    cache_info->random_info=DestroyRandomInfo(cache_info->random_info);\n  if (cache_info->file_semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&cache_info->file_semaphore);\n  if (cache_info->semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&cache_info->semaphore);\n  cache_info->signature=(~MagickSignature);\n  cache_info=(CacheInfo *) RelinquishMagickMemory(cache_info);\n  cache=(Cache) NULL;\n  return(cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCacheNexus() destroys a pixel cache nexus.\n%\n%  The format of the DestroyPixelCacheNexus() method is:\n%\n%      NexusInfo **DestroyPixelCacheNexus(NexusInfo *nexus_info,\n%        const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus to destroy.\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\n\nstatic inline void RelinquishCacheNexusPixels(NexusInfo *nexus_info)\n{\n  if (nexus_info->mapped == MagickFalse)\n    (void) RelinquishAlignedMemory(nexus_info->cache);\n  else\n    (void) UnmapBlob(nexus_info->cache,(size_t) nexus_info->length);\n  nexus_info->cache=(PixelPacket *) NULL;\n  nexus_info->pixels=(PixelPacket *) NULL;\n  nexus_info->indexes=(IndexPacket *) NULL;\n  nexus_info->length=0;\n  nexus_info->mapped=MagickFalse;\n}\n\nMagickExport NexusInfo **DestroyPixelCacheNexus(NexusInfo **nexus_info,\n  const size_t number_threads)\n{\n  register ssize_t\n    i;\n\n  assert(nexus_info != (NexusInfo **) NULL);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    if (nexus_info[i]->cache != (PixelPacket *) NULL)\n      RelinquishCacheNexusPixels(nexus_info[i]);\n    nexus_info[i]->signature=(~MagickSignature);\n  }\n  nexus_info[0]=(NexusInfo *) RelinquishMagickMemory(nexus_info[0]);\n  nexus_info=(NexusInfo **) RelinquishAlignedMemory(nexus_info);\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c I n d e x e s F r o m C a c h e                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticIndexesFromCache() returns the indexes associated with the last\n%  call to QueueAuthenticPixelsCache() or GetAuthenticPixelsCache().\n%\n%  The format of the GetAuthenticIndexesFromCache() method is:\n%\n%      IndexPacket *GetAuthenticIndexesFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic IndexPacket *GetAuthenticIndexesFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->indexes);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c I n d e x Q u e u e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticIndexQueue() returns the authentic black channel or the colormap\n%  indexes associated with the last call to QueueAuthenticPixels() or\n%  GetVirtualPixels().  NULL is returned if the black channel or colormap\n%  indexes are not available.\n%\n%  The format of the GetAuthenticIndexQueue() method is:\n%\n%      IndexPacket *GetAuthenticIndexQueue(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport IndexPacket *GetAuthenticIndexQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_indexes_from_handler !=\n       (GetAuthenticIndexesFromHandler) NULL)\n    return(cache_info->methods.get_authentic_indexes_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->indexes);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l C a c h e N e x u s                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelCacheNexus() gets authentic pixels from the in-memory or\n%  disk pixel cache as defined by the geometry parameters.   A pointer to the\n%  pixels is returned if the pixels are transferred, otherwise a NULL is\n%  returned.\n%\n%  The format of the GetAuthenticPixelCacheNexus() method is:\n%\n%      PixelPacket *GetAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to return.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport PixelPacket *GetAuthenticPixelCacheNexus(Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  /*\n    Transfer pixels from the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickTrue,\n    nexus_info,exception);\n  if (pixels == (PixelPacket *) NULL)\n    return((PixelPacket *) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(pixels);\n  if (ReadPixelCachePixels(cache_info,nexus_info,exception) == MagickFalse)\n    return((PixelPacket *) NULL);\n  if (cache_info->active_index_channel != MagickFalse)\n    if (ReadPixelCacheIndexes(cache_info,nexus_info,exception) == MagickFalse)\n      return((PixelPacket *) NULL);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsFromCache() returns the pixels associated with the last\n%  call to the QueueAuthenticPixelsCache() or GetAuthenticPixelsCache() methods.\n%\n%  The format of the GetAuthenticPixelsFromCache() method is:\n%\n%      PixelPacket *GetAuthenticPixelsFromCache(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic PixelPacket *GetAuthenticPixelsFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l Q u e u e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelQueue() returns the authentic pixels associated with the\n%  last call to QueueAuthenticPixels() or GetAuthenticPixels().\n%\n%  The format of the GetAuthenticPixelQueue() method is:\n%\n%      PixelPacket *GetAuthenticPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_pixels_from_handler !=\n       (GetAuthenticPixelsFromHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixels() obtains a pixel region for read/write access. If the\n%  region is successfully accessed, a pointer to a PixelPacket array\n%  representing the region is returned, otherwise NULL is returned.\n%\n%  The returned pointer may point to a temporary working copy of the pixels\n%  or it may point to the original pixels in memory. Performance is maximized\n%  if the selected region is part of one row, or one or more full rows, since\n%  then there is opportunity to access the pixels in-place (without a copy)\n%  if the image is in memory, or in a memory-mapped file. The returned pointer\n%  must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  PixelPacket. If the image type is CMYK or if the storage class is\n%  PseduoClass, call GetAuthenticIndexQueue() after invoking\n%  GetAuthenticPixels() to obtain the black color component or colormap indexes\n%  (of type IndexPacket) corresponding to the region.  Once the PixelPacket\n%  (and/or IndexPacket) array has been updated, the changes must be saved back\n%  to the underlying image using SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the GetAuthenticPixels() method is:\n%\n%      PixelPacket *GetAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport PixelPacket *GetAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_pixels_handler !=\n       (GetAuthenticPixelsHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_handler(image,x,y,columns,\n      rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsCache() gets pixels from the in-memory or disk pixel cache\n%  as defined by the geometry parameters.   A pointer to the pixels is returned\n%  if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetAuthenticPixelsCache() method is:\n%\n%      PixelPacket *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic PixelPacket *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return((PixelPacket *) NULL);\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageExtent() returns the extent of the pixels associated with the\n%  last call to QueueAuthenticPixels() or GetAuthenticPixels().\n%\n%  The format of the GetImageExtent() method is:\n%\n%      MagickSizeType GetImageExtent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType GetImageExtent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetPixelCacheNexusExtent(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCache() ensures that there is only a single reference to the\n%  pixel cache to be modified, updating the provided cache pointer to point to\n%  a clone of the original pixel cache if necessary.\n%\n%  The format of the GetImagePixelCache method is:\n%\n%      Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone: any value other than MagickFalse clones the cache pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType ValidatePixelCacheMorphology(\n  const Image *magick_restrict image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  /*\n    Does the image match the pixel cache morphology?\n  */\n  cache_info=(CacheInfo *) image->cache;\n  if ((image->storage_class != cache_info->storage_class) ||\n      (image->colorspace != cache_info->colorspace) ||\n      (image->channels != cache_info->channels) ||\n      (image->columns != cache_info->columns) ||\n      (image->rows != cache_info->rows) ||\n      (cache_info->nexus_info == (NexusInfo **) NULL))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0,\n    time_limit = 0;\n\n  static time_t\n    cache_timestamp = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (time_limit == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      time_limit=GetMagickResourceLimit(TimeResource);\n      cache_timestamp=time((time_t *) NULL);\n    }\n  if ((time_limit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_timestamp) >= time_limit))\n     {\n#if defined(ECANCELED)\n       errno=ECANCELED;\n#endif\n       ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n     }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AllocateSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status != MagickFalse)\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  if (cache_info->reference_count == 1)\n                    cache_info->nexus_info=(NexusInfo **) NULL;\n                  destroy=MagickTrue;\n                  image->cache=clone_image.cache;\n                }\n            }\n          DestroySemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e T y p e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCacheType() returns the pixel cache type: UndefinedCache,\n%  DiskCache, MapCache, MemoryCache, or PingCache.\n%\n%  The format of the GetImagePixelCacheType() method is:\n%\n%      CacheType GetImagePixelCacheType(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nMagickExport CacheType GetPixelCacheType(const Image *image)\n{\n  return(GetImagePixelCacheType(image));\n}\n\nMagickExport CacheType GetImagePixelCacheType(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  return(cache_info->type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e A u t h e n t i c P i x e l                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixel() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixel() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixel(const Image image,const ssize_t x,\n%        const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneAuthenticPixel(Image *image,\n  const ssize_t x,const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  if (cache_info->methods.get_one_authentic_pixel_from_handler !=\n       (GetOneAuthenticPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_authentic_pixel_from_handler(image,x,y,\n      pixel,exception));\n  pixels=GetAuthenticPixelsCache(image,x,y,1UL,1UL,exception);\n  if (pixels == (PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e A u t h e n t i c P i x e l F r o m C a c h e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixelFromCache() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixelFromCache(const Image image,\n%        const ssize_t x,const ssize_t y,PixelPacket *pixel,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneAuthenticPixelFromCache(Image *image,\n  const ssize_t x,const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (pixels == (PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l M a g i c k P i x e l                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualMagickPixel() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.  If\n%  you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualMagickPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualMagickPixel(const Image image,\n%        const ssize_t x,const ssize_t y,MagickPixelPacket *pixel,\n%        ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  these values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualMagickPixel(const Image *image,\n  const ssize_t x,const ssize_t y,MagickPixelPacket *pixel,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  register const IndexPacket\n    *magick_restrict indexes;\n\n  register const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  GetMagickPixelPacket(image,pixel);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  indexes=GetVirtualIndexesFromNexus(cache_info,cache_info->nexus_info[id]);\n  SetMagickPixelPacket(image,pixels,indexes,pixel);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l M e t h o d P i x e l                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualMethodPixel() returns a single pixel at the specified (x,y)\n%  location as defined by specified pixel method.  The image background color\n%  is returned if an error occurs.  If you plan to modify the pixel, use\n%  GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualMethodPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualMethodPixel(const Image image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,Pixelpacket *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualMethodPixel(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      virtual_pixel_method,x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l P i x e l                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixel() returns a single virtual pixel at the specified\n%  (x,y) location.  The image background color is returned if an error occurs.\n%  If you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualPixel(const Image image,const ssize_t x,\n%        const ssize_t y,PixelPacket *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,\n  const ssize_t x,const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e V i r t u a l P i x e l F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixelFromCache() returns a single virtual pixel at the\n%  specified (x,y) location.  The image background color is returned if an\n%  error occurs.\n%\n%  The format of the GetOneVirtualPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneVirtualPixelFromCache(const Image image,\n%        const VirtualPixelPacket method,const ssize_t x,const ssize_t y,\n%        PixelPacket *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneVirtualPixelFromCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  *pixel=image->background_color;\n  pixels=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e C h a n n e l s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheChannels() returns the number of pixel channels associated\n%  with this instance of the pixel cache.\n%\n%  The format of the GetPixelCacheChannels() method is:\n%\n%      size_t GetPixelCacheChannels(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o type: GetPixelCacheChannels returns DirectClass or PseudoClass.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport size_t GetPixelCacheChannels(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->channels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e C o l o r s p a c e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheColorspace() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheColorspace() method is:\n%\n%      Colorspace GetPixelCacheColorspace(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport ColorspaceType GetPixelCacheColorspace(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->colorspace);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheMethods() initializes the CacheMethods structure.\n%\n%  The format of the GetPixelCacheMethods() method is:\n%\n%      void GetPixelCacheMethods(CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickExport void GetPixelCacheMethods(CacheMethods *cache_methods)\n{\n  assert(cache_methods != (CacheMethods *) NULL);\n  (void) ResetMagickMemory(cache_methods,0,sizeof(*cache_methods));\n  cache_methods->get_virtual_pixel_handler=GetVirtualPixelCache;\n  cache_methods->get_virtual_pixels_handler=GetVirtualPixelsCache;\n  cache_methods->get_virtual_indexes_from_handler=GetVirtualIndexesFromCache;\n  cache_methods->get_one_virtual_pixel_from_handler=GetOneVirtualPixelFromCache;\n  cache_methods->get_authentic_pixels_handler=GetAuthenticPixelsCache;\n  cache_methods->get_authentic_indexes_from_handler=\n    GetAuthenticIndexesFromCache;\n  cache_methods->get_authentic_pixels_from_handler=GetAuthenticPixelsFromCache;\n  cache_methods->get_one_authentic_pixel_from_handler=\n    GetOneAuthenticPixelFromCache;\n  cache_methods->queue_authentic_pixels_handler=QueueAuthenticPixelsCache;\n  cache_methods->sync_authentic_pixels_handler=SyncAuthenticPixelsCache;\n  cache_methods->destroy_pixel_handler=DestroyImagePixelCache;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e N e x u s E x t e n t                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheNexusExtent() returns the extent of the pixels associated with\n%  the last call to SetPixelCacheNexusPixels() or GetPixelCacheNexusPixels().\n%\n%  The format of the GetPixelCacheNexusExtent() method is:\n%\n%      MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus info.\n%\n*/\nMagickExport MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n  NexusInfo *nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickSizeType\n    extent;\n\n  assert(cache != NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  extent=(MagickSizeType) nexus_info->region.width*nexus_info->region.height;\n  if (extent == 0)\n    return((MagickSizeType) cache_info->columns*cache_info->rows);\n  return(extent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCachePixels() returns the pixels associated with the specified image.\n%\n%  The format of the GetPixelCachePixels() method is:\n%\n%      void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  assert(length != (MagickSizeType *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  (void) exception;\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((void *) NULL);\n  *length=cache_info->length;\n  return((void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e S t o r a g e C l a s s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheStorageClass() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheStorageClass() method is:\n%\n%      ClassType GetPixelCacheStorageClass(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o type: GetPixelCacheStorageClass returns DirectClass or PseudoClass.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport ClassType GetPixelCacheStorageClass(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->storage_class);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e T i l e S i z e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheTileSize() returns the pixel cache tile size.\n%\n%  The format of the GetPixelCacheTileSize() method is:\n%\n%      void GetPixelCacheTileSize(const Image *image,size_t *width,\n%        size_t *height)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the optimize cache tile width in pixels.\n%\n%    o height: the optimize cache tile height in pixels.\n%\n*/\nMagickExport void GetPixelCacheTileSize(const Image *image,size_t *width,\n  size_t *height)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *width=2048UL/sizeof(PixelPacket);\n  if (GetImagePixelCacheType(image) == DiskCache)\n    *width=8192UL/sizeof(PixelPacket);\n  *height=(*width);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheVirtualMethod() gets the \"virtual pixels\" method for the\n%  pixel cache.  A virtual pixel is any pixel access that is outside the\n%  boundaries of the image cache.\n%\n%  The format of the GetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  return(cache_info->virtual_pixel_method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l I n d e x e s F r o m C a c h e                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualIndexesFromCache() returns the indexes associated with the last\n%  call to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualIndexesFromCache() method is:\n%\n%      IndexPacket *GetVirtualIndexesFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const IndexPacket *GetVirtualIndexesFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualIndexesFromNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l I n d e x e s F r o m N e x u s                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualIndexesFromNexus() returns the indexes associated with the\n%  specified cache nexus.\n%\n%  The format of the GetVirtualIndexesFromNexus() method is:\n%\n%      const IndexPacket *GetVirtualIndexesFromNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the colormap indexes.\n%\n*/\nMagickExport const IndexPacket *GetVirtualIndexesFromNexus(const Cache cache,\n  NexusInfo *nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((IndexPacket *) NULL);\n  return(nexus_info->indexes);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l I n d e x Q u e u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualIndexQueue() returns the virtual black channel or the\n%  colormap indexes associated with the last call to QueueAuthenticPixels() or\n%  GetVirtualPixels().  NULL is returned if the black channel or colormap\n%  indexes are not available.\n%\n%  The format of the GetVirtualIndexQueue() method is:\n%\n%      const IndexPacket *GetVirtualIndexQueue(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const IndexPacket *GetVirtualIndexQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_indexes_from_handler !=\n       (GetVirtualIndexesFromHandler) NULL)\n    return(cache_info->methods.get_virtual_indexes_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualIndexesFromNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m N e x u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsFromNexus() gets virtual pixels from the in-memory or disk\n%  pixel cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelsFromNexus() method is:\n%\n%      PixelPacket *GetVirtualPixelsFromNexus(const Image *image,\n%        const VirtualPixelMethod method,const ssize_t x,const ssize_t y,\n%        const size_t columns,const size_t rows,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to acquire.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t\n  DitherMatrix[64] =\n  {\n     0,  48,  12,  60,   3,  51,  15,  63,\n    32,  16,  44,  28,  35,  19,  47,  31,\n     8,  56,   4,  52,  11,  59,   7,  55,\n    40,  24,  36,  20,  43,  27,  39,  23,\n     2,  50,  14,  62,   1,  49,  13,  61,\n    34,  18,  46,  30,  33,  17,  45,  29,\n    10,  58,   6,  54,   9,  57,   5,  53,\n    42,  26,  38,  22,  41,  25,  37,  21\n  };\n\nstatic inline ssize_t DitherX(const ssize_t x,const size_t columns)\n{\n  ssize_t\n    index;\n\n  index=x+DitherMatrix[x & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) columns)\n    return((ssize_t) columns-1L);\n  return(index);\n}\n\nstatic inline ssize_t DitherY(const ssize_t y,const size_t rows)\n{\n  ssize_t\n    index;\n\n  index=y+DitherMatrix[y & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) rows)\n    return((ssize_t) rows-1L);\n  return(index);\n}\n\nstatic inline ssize_t EdgeX(const ssize_t x,const size_t columns)\n{\n  if (x < 0L)\n    return(0L);\n  if (x >= (ssize_t) columns)\n    return((ssize_t) (columns-1));\n  return(x);\n}\n\nstatic inline ssize_t EdgeY(const ssize_t y,const size_t rows)\n{\n  if (y < 0L)\n    return(0L);\n  if (y >= (ssize_t) rows)\n    return((ssize_t) (rows-1));\n  return(y);\n}\n\nstatic inline ssize_t RandomX(RandomInfo *random_info,const size_t columns)\n{\n  return((ssize_t) (columns*GetPseudoRandomValue(random_info)));\n}\n\nstatic inline ssize_t RandomY(RandomInfo *random_info,const size_t rows)\n{\n  return((ssize_t) (rows*GetPseudoRandomValue(random_info)));\n}\n\n/*\n  VirtualPixelModulo() computes the remainder of dividing offset by extent.  It\n  returns not only the quotient (tile the offset falls in) but also the positive\n  remainer within that tile such that 0 <= remainder < extent.  This method is\n  essentially a ldiv() using a floored modulo division rather than the normal\n  default truncated modulo division.\n*/\nstatic inline MagickModulo VirtualPixelModulo(const ssize_t offset,\n  const size_t extent)\n{\n  MagickModulo\n    modulo;\n\n  modulo.quotient=offset/(ssize_t) extent;\n  if (offset < 0L)\n    modulo.quotient--;\n  modulo.remainder=offset-modulo.quotient*(ssize_t) extent;\n  return(modulo);\n}\n\nMagickExport const PixelPacket *GetVirtualPixelsFromNexus(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  IndexPacket\n    virtual_index;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict virtual_nexus;\n\n  PixelPacket\n    *magick_restrict pixels,\n    virtual_pixel;\n\n  RectangleInfo\n    region;\n\n  register const IndexPacket\n    *magick_restrict virtual_indexes;\n\n  register const PixelPacket\n    *magick_restrict p;\n\n  register IndexPacket\n    *magick_restrict indexes;\n\n  register PixelPacket\n    *magick_restrict q;\n\n  register ssize_t\n    u,\n    v;\n\n  /*\n    Acquire pixels.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->type == UndefinedCache)\n    return((const PixelPacket *) NULL);\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n    (image->clip_mask != (Image *) NULL) || (image->mask != (Image *) NULL) ?\n    MagickTrue : MagickFalse,nexus_info,exception);\n  if (pixels == (PixelPacket *) NULL)\n    return((const PixelPacket *) NULL);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) (nexus_info->region.height-1L)*cache_info->columns+\n    nexus_info->region.width-1L;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  if ((offset >= 0) && (((MagickSizeType) offset+length) < number_pixels))\n    if ((x >= 0) && ((ssize_t) (x+columns) <= (ssize_t) cache_info->columns) &&\n        (y >= 0) && ((ssize_t) (y+rows) <= (ssize_t) cache_info->rows))\n      {\n        MagickBooleanType\n          status;\n\n        /*\n          Pixel request is inside cache extents.\n        */\n        if (nexus_info->authentic_pixel_cache != MagickFalse)\n          return(pixels);\n        status=ReadPixelCachePixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          return((const PixelPacket *) NULL);\n        if ((cache_info->storage_class == PseudoClass) ||\n            (cache_info->colorspace == CMYKColorspace))\n          {\n            status=ReadPixelCacheIndexes(cache_info,nexus_info,exception);\n            if (status == MagickFalse)\n              return((const PixelPacket *) NULL);\n          }\n        return(pixels);\n      }\n  /*\n    Pixel request is outside cache extents.\n  */\n  q=pixels;\n  indexes=nexus_info->indexes;\n  virtual_nexus=AcquirePixelCacheNexus(1);\n  if (virtual_nexus == (NexusInfo **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"UnableToGetCacheNexus\",\"`%s'\",image->filename);\n      return((const PixelPacket *) NULL);\n    }\n  switch (virtual_pixel_method)\n  {\n    case BlackVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,0);\n      SetPixelGreen(&virtual_pixel,0);\n      SetPixelBlue(&virtual_pixel,0);\n      SetPixelOpacity(&virtual_pixel,OpaqueOpacity);\n      break;\n    }\n    case GrayVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,QuantumRange/2);\n      SetPixelGreen(&virtual_pixel,QuantumRange/2);\n      SetPixelBlue(&virtual_pixel,QuantumRange/2);\n      SetPixelOpacity(&virtual_pixel,OpaqueOpacity);\n      break;\n    }\n    case TransparentVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,0);\n      SetPixelGreen(&virtual_pixel,0);\n      SetPixelBlue(&virtual_pixel,0);\n      SetPixelOpacity(&virtual_pixel,TransparentOpacity);\n      break;\n    }\n    case MaskVirtualPixelMethod:\n    case WhiteVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,QuantumRange);\n      SetPixelGreen(&virtual_pixel,QuantumRange);\n      SetPixelBlue(&virtual_pixel,QuantumRange);\n      SetPixelOpacity(&virtual_pixel,OpaqueOpacity);\n      break;\n    }\n    default:\n    {\n      virtual_pixel=image->background_color;\n      break;\n    }\n  }\n  virtual_index=0;\n  for (v=0; v < (ssize_t) rows; v++)\n  {\n    ssize_t\n      y_offset;\n\n    y_offset=y+v;\n    if ((virtual_pixel_method == EdgeVirtualPixelMethod) ||\n        (virtual_pixel_method == UndefinedVirtualPixelMethod))\n      y_offset=EdgeY(y_offset,cache_info->rows);\n    for (u=0; u < (ssize_t) columns; u+=length)\n    {\n      ssize_t\n        x_offset;\n\n      x_offset=x+u;\n      length=(MagickSizeType) MagickMin(cache_info->columns-x_offset,columns-u);\n      if (((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns)) ||\n          ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows)) ||\n          (length == 0))\n        {\n          MagickModulo\n            x_modulo,\n            y_modulo;\n\n          /*\n            Transfer a single pixel.\n          */\n          length=(MagickSizeType) 1;\n          switch (virtual_pixel_method)\n          {\n            case BackgroundVirtualPixelMethod:\n            case ConstantVirtualPixelMethod:\n            case BlackVirtualPixelMethod:\n            case GrayVirtualPixelMethod:\n            case TransparentVirtualPixelMethod:\n            case MaskVirtualPixelMethod:\n            case WhiteVirtualPixelMethod:\n            {\n              p=(&virtual_pixel);\n              virtual_indexes=(&virtual_index);\n              break;\n            }\n            case EdgeVirtualPixelMethod:\n            default:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),\n                EdgeY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case RandomVirtualPixelMethod:\n            {\n              if (cache_info->random_info == (RandomInfo *) NULL)\n                cache_info->random_info=AcquireRandomInfo();\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                RandomX(cache_info->random_info,cache_info->columns),\n                RandomY(cache_info->random_info,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case DitherVirtualPixelMethod:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                DitherX(x_offset,cache_info->columns),\n                DitherY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case TileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case MirrorVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              if ((x_modulo.quotient & 0x01) == 1L)\n                x_modulo.remainder=(ssize_t) cache_info->columns-\n                  x_modulo.remainder-1L;\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if ((y_modulo.quotient & 0x01) == 1L)\n                y_modulo.remainder=(ssize_t) cache_info->rows-\n                  y_modulo.remainder-1L;\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case CheckerTileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if (((x_modulo.quotient ^ y_modulo.quotient) & 0x01) != 0L)\n                {\n                  p=(&virtual_pixel);\n                  virtual_indexes=(&virtual_index);\n                  break;\n                }\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case HorizontalTileVirtualPixelMethod:\n            {\n              if ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows))\n                {\n                  p=(&virtual_pixel);\n                  virtual_indexes=(&virtual_index);\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case VerticalTileVirtualPixelMethod:\n            {\n              if ((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns))\n                {\n                  p=(&virtual_pixel);\n                  virtual_indexes=(&virtual_index);\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case HorizontalTileEdgeVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,EdgeY(y_offset,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case VerticalTileEdgeVirtualPixelMethod:\n            {\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),y_modulo.remainder,1UL,1UL,\n                *virtual_nexus,exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n          }\n          if (p == (const PixelPacket *) NULL)\n            break;\n          *q++=(*p);\n          if ((indexes != (IndexPacket *) NULL) &&\n              (virtual_indexes != (const IndexPacket *) NULL))\n            *indexes++=(*virtual_indexes);\n          continue;\n        }\n      /*\n        Transfer a run of pixels.\n      */\n      p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x_offset,y_offset,\n        (size_t) length,1UL,*virtual_nexus,exception);\n      if (p == (const PixelPacket *) NULL)\n        break;\n      virtual_indexes=GetVirtualIndexesFromNexus(cache_info,*virtual_nexus);\n      (void) memcpy(q,p,(size_t) length*sizeof(*p));\n      q+=length;\n      if ((indexes != (IndexPacket *) NULL) &&\n          (virtual_indexes != (const IndexPacket *) NULL))\n        {\n          (void) memcpy(indexes,virtual_indexes,(size_t) length*\n            sizeof(*virtual_indexes));\n          indexes+=length;\n        }\n    }\n  }\n  virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l C a c h e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelCache() get virtual pixels from the in-memory or disk pixel\n%  cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelCache() method is:\n%\n%      const PixelPacket *GetVirtualPixelCache(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const PixelPacket *GetVirtualPixelCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,columns,rows,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l Q u e u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelQueue() returns the virtual pixels associated with the\n%  last call to QueueAuthenticPixels() or GetVirtualPixels().\n%\n%  The format of the GetVirtualPixelQueue() method is:\n%\n%      const PixelPacket *GetVirtualPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixels() returns an immutable pixel region. If the\n%  region is successfully accessed, a pointer to it is returned, otherwise\n%  NULL is returned.  The returned pointer may point to a temporary working\n%  copy of the pixels or it may point to the original pixels in memory.\n%  Performance is maximized if the selected region is part of one row, or one\n%  or more full rows, since there is opportunity to access the pixels in-place\n%  (without a copy) if the image is in memory, or in a memory-mapped file.  The\n%  returned pointer must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  PixelPacket.  If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticIndexQueue() after invoking GetAuthenticPixels() to access\n%  the black color component or to obtain the colormap indexes (of type\n%  IndexPacket) corresponding to the region.\n%\n%  If you plan to modify the pixels, use GetAuthenticPixels() instead.\n%\n%  Note, the GetVirtualPixels() and GetAuthenticPixels() methods are not thread-\n%  safe.  In a threaded environment, use GetCacheViewVirtualPixels() or\n%  GetCacheViewAuthenticPixels() instead.\n%\n%  The format of the GetVirtualPixels() method is:\n%\n%      const PixelPacket *GetVirtualPixels(const Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const PixelPacket *GetVirtualPixels(const Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixel_handler !=\n       (GetVirtualPixelHandler) NULL)\n    return(cache_info->methods.get_virtual_pixel_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,columns,rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    columns,rows,cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsCache() returns the pixels associated with the last call\n%  to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualPixelsCache() method is:\n%\n%      PixelPacket *GetVirtualPixelsCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const PixelPacket *GetVirtualPixelsCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(image->cache,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s N e x u s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsNexus() returns the pixels associated with the specified\n%  cache nexus.\n%\n%  The format of the GetVirtualPixelsNexus() method is:\n%\n%      const IndexPacket *GetVirtualPixelsNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the colormap pixels.\n%\n*/\nMagickExport const PixelPacket *GetVirtualPixelsNexus(const Cache cache,\n  NexusInfo *nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((PixelPacket *) NULL);\n  return((const PixelPacket *) nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M a s k P i x e l C a c h e N e x u s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MaskPixelCacheNexus() masks the cache nexus as defined by the image mask.\n%  The method returns MagickTrue if the pixel region is masked, otherwise\n%  MagickFalse.\n%\n%  The format of the MaskPixelCacheNexus() method is:\n%\n%      MagickBooleanType MaskPixelCacheNexus(Image *image,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to clip.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline void MagickPixelCompositeMask(const MagickPixelPacket *p,\n  const MagickRealType alpha,const MagickPixelPacket *q,\n  const MagickRealType beta,MagickPixelPacket *composite)\n{\n  double\n    gamma;\n\n  if (alpha == TransparentOpacity)\n    {\n      *composite=(*q);\n      return;\n    }\n  gamma=1.0-QuantumScale*QuantumScale*alpha*beta;\n  gamma=PerceptibleReciprocal(gamma);\n  composite->red=gamma*MagickOver_(p->red,alpha,q->red,beta);\n  composite->green=gamma*MagickOver_(p->green,alpha,q->green,beta);\n  composite->blue=gamma*MagickOver_(p->blue,alpha,q->blue,beta);\n  if ((p->colorspace == CMYKColorspace) && (q->colorspace == CMYKColorspace))\n    composite->index=gamma*MagickOver_(p->index,alpha,q->index,beta);\n}\n\nstatic MagickBooleanType MaskPixelCacheNexus(Image *image,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickPixelPacket\n    alpha,\n    beta;\n\n  MagickSizeType\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict clip_nexus,\n    **magick_restrict image_nexus;\n\n  register const PixelPacket\n    *magick_restrict r;\n\n  register IndexPacket\n    *magick_restrict nexus_indexes,\n    *magick_restrict indexes;\n\n  register PixelPacket\n    *magick_restrict p,\n    *magick_restrict q;\n\n  register ssize_t\n    i;\n\n  /*\n    Apply clip mask.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->mask == (Image *) NULL) || (image->storage_class == PseudoClass))\n    return(MagickTrue);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return(MagickFalse);\n  image_nexus=AcquirePixelCacheNexus(1);\n  clip_nexus=AcquirePixelCacheNexus(1);\n  if ((image_nexus == (NexusInfo **) NULL) ||\n      (clip_nexus == (NexusInfo **) NULL))\n    ThrowBinaryException(CacheError,\"UnableToGetCacheNexus\",image->filename);\n  p=GetAuthenticPixelCacheNexus(image,nexus_info->region.x,\n    nexus_info->region.y,nexus_info->region.width,nexus_info->region.height,\n    image_nexus[0],exception);\n  indexes=image_nexus[0]->indexes;\n  q=nexus_info->pixels;\n  nexus_indexes=nexus_info->indexes;\n  r=GetVirtualPixelsFromNexus(image->mask,MaskVirtualPixelMethod,\n    nexus_info->region.x,nexus_info->region.y,nexus_info->region.width,\n    nexus_info->region.height,clip_nexus[0],&image->exception);\n  GetMagickPixelPacket(image,&alpha);\n  GetMagickPixelPacket(image,&beta);\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  for (i=0; i < (ssize_t) number_pixels; i++)\n  {\n    if ((p == (PixelPacket *) NULL) || (r == (const PixelPacket *) NULL))\n      break;\n    SetMagickPixelPacket(image,p,indexes+i,&alpha);\n    SetMagickPixelPacket(image,q,nexus_indexes+i,&beta);\n    MagickPixelCompositeMask(&beta,GetPixelIntensity(image,r),&alpha,\n      alpha.opacity,&beta);\n    SetPixelRed(q,ClampToQuantum(beta.red));\n    SetPixelGreen(q,ClampToQuantum(beta.green));\n    SetPixelBlue(q,ClampToQuantum(beta.blue));\n    SetPixelOpacity(q,ClampToQuantum(beta.opacity));\n    if (cache_info->active_index_channel != MagickFalse)\n      SetPixelIndex(nexus_indexes+i,GetPixelIndex(indexes+i));\n    p++;\n    q++;\n    r++;\n  }\n  clip_nexus=DestroyPixelCacheNexus(clip_nexus,1);\n  image_nexus=DestroyPixelCacheNexus(image_nexus,1);\n  if (i < (ssize_t) number_pixels)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   O p e n P i x e l C a c h e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenPixelCache() allocates the pixel cache.  This includes defining the cache\n%  dimensions, allocating space for the image pixels and optionally the\n%  colormap indexes, and memory mapping the cache if it is disk based.  The\n%  cache nexus array is initialized as well.\n%\n%  The format of the OpenPixelCache() method is:\n%\n%      MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline void AllocatePixelCachePixels(CacheInfo *cache_info)\n{\n  cache_info->mapped=MagickFalse;\n  cache_info->pixels=(PixelPacket *) MagickAssumeAligned(\n    AcquireAlignedMemory(1,(size_t) cache_info->length));\n  if (cache_info->pixels == (PixelPacket *) NULL)\n    {\n      cache_info->mapped=MagickTrue;\n      cache_info->pixels=(PixelPacket *) MapBlob(-1,IOMode,0,(size_t)\n        cache_info->length);\n    }\n}\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if defined(SIGBUS)\nstatic void CacheSignalHandler(int status)\n{\n  ThrowFatalException(CacheFatalError,\"UnableToExtendPixelCache\");\n}\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType OpenPixelCacheOnDisk(CacheInfo *cache_info,\n  const MapMode mode)\n{\n  int\n    file;\n\n  /*\n    Open pixel cache on disk.\n  */\n  if ((cache_info->file != -1) && (cache_info->mode == mode))\n    return(MagickTrue);  /* cache already open and in the proper mode */\n  if (*cache_info->cache_filename == '\\0')\n    file=AcquireUniqueFileResource(cache_info->cache_filename);\n  else\n    switch (mode)\n    {\n      case ReadMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDONLY | O_BINARY,0);\n        break;\n      }\n      case WriteMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_WRONLY | O_CREAT |\n          O_BINARY | O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_WRONLY | O_BINARY,S_MODE);\n        break;\n      }\n      case IOMode:\n      default:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDWR | O_CREAT | O_BINARY |\n          O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_RDWR | O_BINARY,S_MODE);\n        break;\n      }\n    }\n  if (file == -1)\n    return(MagickFalse);\n  (void) AcquireMagickResource(FileResource,1);\n  if (cache_info->file != -1)\n    (void) ClosePixelCacheOnDisk(cache_info);\n  cache_info->file=file;\n  cache_info->mode=mode;\n  return(MagickTrue);\n}\n\nstatic inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType SetPixelCacheExtent(Image *image,MagickSizeType length)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    count,\n    extent,\n    offset;\n\n  cache_info=(CacheInfo *) image->cache;\n  if (image->debug != MagickFalse)\n    {\n      char\n        format[MaxTextExtent],\n        message[MaxTextExtent];\n\n      (void) FormatMagickSize(length,MagickFalse,format);\n      (void) FormatLocaleString(message,MaxTextExtent,\n        \"extend %s (%s[%d], disk, %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_END);\n  if (offset < 0)\n    return(MagickFalse);\n  if ((MagickSizeType) offset >= length)\n    count=(MagickOffsetType) 1;\n  else\n    {\n      extent=(MagickOffsetType) length-1;\n      count=WritePixelCacheRegion(cache_info,extent,1,(const unsigned char *)\n        \"\");\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n      if (cache_info->synchronize != MagickFalse)\n        (void) posix_fallocate(cache_info->file,offset+1,extent-offset);\n#endif\n#if defined(SIGBUS)\n      (void) signal(SIGBUS,CacheSignalHandler);\n#endif\n    }\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_SET);\n  if (offset < 0)\n    return(MagickFalse);\n  return(count != (MagickOffsetType) 1 ? MagickFalse : MagickTrue);\n}\n\nstatic MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    source_info;\n\n  char\n    format[MaxTextExtent],\n    message[MaxTextExtent];\n\n  const char\n    *type;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  MagickStatusType\n    status;\n\n  size_t\n    columns,\n    packet_size;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowBinaryException(CacheError,\"NoPixelsDefinedInCache\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n      (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  source_info=(*cache_info);\n  source_info.file=(-1);\n  (void) FormatLocaleString(cache_info->filename,MaxTextExtent,\"%s[%.20g]\",\n    image->filename,(double) GetImageIndexInList(image));\n  cache_info->mode=mode;\n  cache_info->rows=image->rows;\n  cache_info->columns=image->columns;\n  cache_info->channels=image->channels;\n  cache_info->active_index_channel=((image->storage_class == PseudoClass) ||\n    (image->colorspace == CMYKColorspace)) ? MagickTrue : MagickFalse;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  packet_size=sizeof(PixelPacket);\n  if (cache_info->active_index_channel != MagickFalse)\n    packet_size+=sizeof(IndexPacket);\n  length=number_pixels*packet_size;\n  columns=(size_t) (length/cache_info->rows/packet_size);\n  if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||\n      ((ssize_t) cache_info->rows < 0))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  cache_info->length=length;\n  if (image->ping != MagickFalse)\n    {\n      cache_info->storage_class=image->storage_class;\n      cache_info->colorspace=image->colorspace;\n      cache_info->type=PingCache;\n      return(MagickTrue);\n    }\n  status=AcquireMagickResource(AreaResource,cache_info->length);\n  length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));\n  if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))\n    {\n      status=AcquireMagickResource(MemoryResource,cache_info->length);\n      if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||\n          (cache_info->type == MemoryCache))\n        {\n          AllocatePixelCachePixels(cache_info);\n          if (cache_info->pixels == (PixelPacket *) NULL)\n            cache_info->pixels=source_info.pixels;\n          else\n            {\n              /*\n                Create memory pixel cache.\n              */\n              cache_info->colorspace=image->colorspace;\n              cache_info->type=MemoryCache;\n              cache_info->indexes=(IndexPacket *) NULL;\n              if (cache_info->active_index_channel != MagickFalse)\n                cache_info->indexes=(IndexPacket *) (cache_info->pixels+\n                  number_pixels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status&=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MaxTextExtent,\n                    \"open %s (%s %s, %.20gx%.20g %s)\",cache_info->filename,\n                    cache_info->mapped != MagickFalse ? \"Anonymous\" : \"Heap\",\n                    type,(double) cache_info->columns,(double) cache_info->rows,\n                    format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              cache_info->storage_class=image->storage_class;\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n    }\n  /*\n    Create pixel cache on disk.\n  */\n  status=AcquireMagickResource(DiskResource,cache_info->length);\n  if ((status == MagickFalse) || (cache_info->type == DistributedCache))\n    {\n      DistributeCacheInfo\n        *server_info;\n\n      if (cache_info->type == DistributedCache)\n        RelinquishMagickResource(DiskResource,cache_info->length);\n      server_info=AcquireDistributeCacheInfo(exception);\n      if (server_info != (DistributeCacheInfo *) NULL)\n        {\n          status=OpenDistributePixelCache(server_info,image);\n          if (status == MagickFalse)\n            {\n              ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n                GetDistributeCacheHostname(server_info));\n              server_info=DestroyDistributeCacheInfo(server_info);\n            }\n          else\n            {\n              /*\n                Create a distributed pixel cache.\n              */\n              cache_info->type=DistributedCache;\n              cache_info->storage_class=image->storage_class;\n              cache_info->colorspace=image->colorspace;\n              cache_info->server_info=server_info;\n              (void) FormatLocaleString(cache_info->cache_filename,\n                MaxTextExtent,\"%s:%d\",GetDistributeCacheHostname(\n                (DistributeCacheInfo *) cache_info->server_info),\n                GetDistributeCachePort((DistributeCacheInfo *)\n                cache_info->server_info));\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickFalse,\n                    format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MaxTextExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20g %s)\",cache_info->filename,\n                    cache_info->cache_filename,GetDistributeCacheFile(\n                    (DistributeCacheInfo *) cache_info->server_info),type,\n                    (double) cache_info->columns,(double) cache_info->rows,\n                    format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"CacheResourcesExhausted\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      (void) ClosePixelCacheOnDisk(cache_info);\n      *cache_info->cache_filename='\\0';\n    }\n  if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)\n    {\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+\n    cache_info->length);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToExtendCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  cache_info->storage_class=image->storage_class;\n  cache_info->colorspace=image->colorspace;\n  length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));\n  if (length != (MagickSizeType) ((size_t) length))\n    cache_info->type=DiskCache;\n  else\n    {\n      status=AcquireMagickResource(MapResource,cache_info->length);\n      if ((status == MagickFalse) && (cache_info->type != MapCache) &&\n          (cache_info->type != MemoryCache))\n        cache_info->type=DiskCache;\n      else\n        {\n          cache_info->pixels=(PixelPacket *) MapBlob(cache_info->file,mode,\n            cache_info->offset,(size_t) cache_info->length);\n          if (cache_info->pixels == (PixelPacket *) NULL)\n            {\n              cache_info->pixels=source_info.pixels;\n              cache_info->type=DiskCache;\n            }\n          else\n            {\n              /*\n                Create file-backed memory-mapped pixel cache.\n              */\n              (void) ClosePixelCacheOnDisk(cache_info);\n              cache_info->type=MapCache;\n              cache_info->mapped=MagickTrue;\n              cache_info->indexes=(IndexPacket *) NULL;\n              if (cache_info->active_index_channel != MagickFalse)\n                cache_info->indexes=(IndexPacket *) (cache_info->pixels+\n                  number_pixels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MaxTextExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    cache_info->file,type,(double) cache_info->columns,(double)\n                    cache_info->rows,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      status=ClonePixelCacheRepository(cache_info,&source_info,exception);\n      RelinquishPixelCachePixels(&source_info);\n    }\n  if (image->debug != MagickFalse)\n    {\n      (void) FormatMagickSize(cache_info->length,MagickFalse,format);\n      type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n        cache_info->type);\n      (void) FormatLocaleString(message,MaxTextExtent,\n        \"open %s (%s[%d], %s, %.20gx%.20g %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,type,(double)\n        cache_info->columns,(double) cache_info->rows,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P e r s i s t P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PersistPixelCache() attaches to or initializes a persistent pixel cache.  A\n%  persistent pixel cache is one that resides on disk and is not destroyed\n%  when the program exits.\n%\n%  The format of the PersistPixelCache() method is:\n%\n%      MagickBooleanType PersistPixelCache(Image *image,const char *filename,\n%        const MagickBooleanType attach,MagickOffsetType *offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: the persistent pixel cache filename.\n%\n%    o attach: A value other than zero initializes the persistent pixel cache.\n%\n%    o initialize: A value other than zero initializes the persistent pixel\n%      cache.\n%\n%    o offset: the offset in the persistent cache to store pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType PersistPixelCache(Image *image,\n  const char *filename,const MagickBooleanType attach,MagickOffsetType *offset,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict clone_info;\n\n  Image\n    clone_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    page_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (void *) NULL);\n  assert(filename != (const char *) NULL);\n  assert(offset != (MagickOffsetType *) NULL);\n  page_size=GetMagickPageSize();\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (attach != MagickFalse)\n    {\n      /*\n        Attach existing persistent pixel cache.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n          \"attach persistent cache\");\n      (void) CopyMagickString(cache_info->cache_filename,filename,\n        MaxTextExtent);\n      cache_info->type=DiskCache;\n      cache_info->offset=(*offset);\n      if (OpenPixelCache(image,ReadMode,exception) == MagickFalse)\n        return(MagickFalse);\n      *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n      return(MagickTrue);\n    }\n  if ((cache_info->mode != ReadMode) && (cache_info->type != MemoryCache) &&\n      (cache_info->reference_count == 1))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->mode != ReadMode) && (cache_info->type != MemoryCache) &&\n          (cache_info->reference_count == 1))\n        {\n          int\n            status;\n\n          /*\n            Usurp existing persistent pixel cache.\n          */\n          status=rename_utf8(cache_info->cache_filename,filename);\n          if (status == 0)\n            {\n              (void) CopyMagickString(cache_info->cache_filename,filename,\n                MaxTextExtent);\n              *offset+=cache_info->length+page_size-(cache_info->length %\n                page_size);\n              UnlockSemaphoreInfo(cache_info->semaphore);\n              cache_info=(CacheInfo *) ReferencePixelCache(cache_info);\n              if (image->debug != MagickFalse)\n                (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n                  \"Usurp resident persistent cache\");\n              return(MagickTrue);\n            }\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  /*\n    Clone persistent pixel cache.\n  */\n  clone_image=(*image);\n  clone_info=(CacheInfo *) clone_image.cache;\n  image->cache=ClonePixelCache(cache_info);\n  cache_info=(CacheInfo *) ReferencePixelCache(image->cache);\n  (void) CopyMagickString(cache_info->cache_filename,filename,MaxTextExtent);\n  cache_info->type=DiskCache;\n  cache_info->offset=(*offset);\n  cache_info=(CacheInfo *) image->cache;\n  status=OpenPixelCache(image,IOMode,exception);\n  if (status != MagickFalse)\n    status=ClonePixelCacheRepository(cache_info,clone_info,&image->exception);\n  *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n  clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l C a c h e N e x u s                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelCacheNexus() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelCacheNexus() method is:\n%\n%      PixelPacket *QueueAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        const MagickBooleanType clone,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o clone: clone the pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport PixelPacket *QueueAuthenticPixel(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  const MagickBooleanType clone,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  return(QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,clone,nexus_info,\n    exception));\n}\n\nMagickExport PixelPacket *QueueAuthenticPixelCacheNexus(Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  const MagickBooleanType clone,NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  RectangleInfo\n    region;\n\n  /*\n    Validate pixel cache geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,clone,exception);\n  if (cache_info == (Cache) NULL)\n    return((PixelPacket *) NULL);\n  assert(cache_info->signature == MagickSignature);\n  if ((cache_info->columns == 0) || (cache_info->rows == 0) || (x < 0) ||\n      (y < 0) || (x >= (ssize_t) cache_info->columns) ||\n      (y >= (ssize_t) cache_info->rows))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"PixelsAreNotAuthentic\",\"`%s'\",image->filename);\n      return((PixelPacket *) NULL);\n    }\n  offset=(MagickOffsetType) y*cache_info->columns+x;\n  if (offset < 0)\n    return((PixelPacket *) NULL);\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  offset+=(MagickOffsetType) (rows-1)*cache_info->columns+columns-1;\n  if ((MagickSizeType) offset >= number_pixels)\n    return((PixelPacket *) NULL);\n  /*\n    Return pixel cache.\n  */\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,WriteMode,&region,\n    (image->clip_mask != (Image *) NULL) || (image->mask != (Image *) NULL) ?\n    MagickTrue : MagickFalse,nexus_info,exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l s C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelsCache() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelsCache() method is:\n%\n%      PixelPacket *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic PixelPacket *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   Q u e u e A u t h e n t i c P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixels() queues a mutable pixel region.  If the region is\n%  successfully initialized a pointer to a PixelPacket array representing the\n%  region is returned, otherwise NULL is returned.  The returned pointer may\n%  point to a temporary working buffer for the pixels or it may point to the\n%  final location of the pixels in memory.\n%\n%  Write-only access means that any existing pixel values corresponding to\n%  the region are ignored.  This is useful if the initial image is being\n%  created from scratch, or if the existing pixel values are to be\n%  completely replaced without need to refer to their pre-existing values.\n%  The application is free to read and write the pixel buffer returned by\n%  QueueAuthenticPixels() any way it pleases. QueueAuthenticPixels() does not\n%  initialize the pixel array values. Initializing pixel array values is the\n%  application's responsibility.\n%\n%  Performance is maximized if the selected region is part of one row, or\n%  one or more full rows, since then there is opportunity to access the\n%  pixels in-place (without a copy) if the image is in memory, or in a\n%  memory-mapped file. The returned pointer must *never* be deallocated\n%  by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  PixelPacket. If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticIndexQueue() after invoking GetAuthenticPixels() to obtain\n%  the black color component or the colormap indexes (of type IndexPacket)\n%  corresponding to the region.  Once the PixelPacket (and/or IndexPacket)\n%  array has been updated, the changes must be saved back to the underlying\n%  image using SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the QueueAuthenticPixels() method is:\n%\n%      PixelPacket *QueueAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport PixelPacket *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n       (QueueAuthenticPixelsHandler) NULL)\n    return(cache_info->methods.queue_authentic_pixels_handler(image,x,y,columns,\n      rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e I n d e x e s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCacheIndexes() reads colormap indexes from the specified region of\n%  the pixel cache.\n%\n%  The format of the ReadPixelCacheIndexes() method is:\n%\n%      MagickBooleanType ReadPixelCacheIndexes(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the colormap indexes.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickOffsetType ReadPixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PREAD)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PREAD)\n    count=read(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pread(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType ReadPixelCacheIndexes(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register IndexPacket\n    *magick_restrict q;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->active_index_channel == MagickFalse)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(IndexPacket);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  q=nexus_info->indexes;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register IndexPacket\n        *magick_restrict p;\n\n      /*\n        Read indexes from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->indexes+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read indexes from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+extent*\n          sizeof(PixelPacket)+offset*sizeof(*q),length,(unsigned char *) q);\n        if ((MagickSizeType) count < length)\n          break;\n        offset+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read indexes from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCacheIndexes((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCachePixels() reads pixels from the specified region of the pixel\n%  cache.\n%\n%  The format of the ReadPixelCachePixels() method is:\n%\n%      MagickBooleanType ReadPixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType ReadPixelCachePixels(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register PixelPacket\n    *magick_restrict q;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns;\n  if ((ssize_t) (offset/cache_info->columns) != nexus_info->region.y)\n    return(MagickFalse);\n  offset+=nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(PixelPacket);\n  if ((length/sizeof(PixelPacket)) != nexus_info->region.width)\n    return(MagickFalse);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  if ((extent == 0) || ((extent/length) != rows))\n    return(MagickFalse);\n  q=nexus_info->pixels;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register PixelPacket\n        *magick_restrict p;\n\n      /*\n        Read pixels from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->pixels+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read pixels from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+offset*\n          sizeof(*q),length,(unsigned char *) q);\n        if ((MagickSizeType) count < length)\n          break;\n        offset+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read pixels from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e f e r e n c e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferencePixelCache() increments the reference count associated with the\n%  pixel cache returning a pointer to the cache.\n%\n%  The format of the ReferencePixelCache method is:\n%\n%      Cache ReferencePixelCache(Cache cache_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n*/\nMagickExport Cache ReferencePixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count++;\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  return(cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheMethods() sets the image pixel methods to the specified ones.\n%\n%  The format of the SetPixelCacheMethods() method is:\n%\n%      SetPixelCacheMethods(Cache *,CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickExport void SetPixelCacheMethods(Cache cache,CacheMethods *cache_methods)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  GetOneAuthenticPixelFromHandler\n    get_one_authentic_pixel_from_handler;\n\n  GetOneVirtualPixelFromHandler\n    get_one_virtual_pixel_from_handler;\n\n  /*\n    Set cache pixel methods.\n  */\n  assert(cache != (Cache) NULL);\n  assert(cache_methods != (CacheMethods *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  if (cache_methods->get_virtual_pixel_handler != (GetVirtualPixelHandler) NULL)\n    cache_info->methods.get_virtual_pixel_handler=\n      cache_methods->get_virtual_pixel_handler;\n  if (cache_methods->destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    cache_info->methods.destroy_pixel_handler=\n      cache_methods->destroy_pixel_handler;\n  if (cache_methods->get_virtual_indexes_from_handler !=\n      (GetVirtualIndexesFromHandler) NULL)\n    cache_info->methods.get_virtual_indexes_from_handler=\n      cache_methods->get_virtual_indexes_from_handler;\n  if (cache_methods->get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    cache_info->methods.get_authentic_pixels_handler=\n      cache_methods->get_authentic_pixels_handler;\n  if (cache_methods->queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    cache_info->methods.queue_authentic_pixels_handler=\n      cache_methods->queue_authentic_pixels_handler;\n  if (cache_methods->sync_authentic_pixels_handler !=\n      (SyncAuthenticPixelsHandler) NULL)\n    cache_info->methods.sync_authentic_pixels_handler=\n      cache_methods->sync_authentic_pixels_handler;\n  if (cache_methods->get_authentic_pixels_from_handler !=\n      (GetAuthenticPixelsFromHandler) NULL)\n    cache_info->methods.get_authentic_pixels_from_handler=\n      cache_methods->get_authentic_pixels_from_handler;\n  if (cache_methods->get_authentic_indexes_from_handler !=\n      (GetAuthenticIndexesFromHandler) NULL)\n    cache_info->methods.get_authentic_indexes_from_handler=\n      cache_methods->get_authentic_indexes_from_handler;\n  get_one_virtual_pixel_from_handler=\n    cache_info->methods.get_one_virtual_pixel_from_handler;\n  if (get_one_virtual_pixel_from_handler !=\n      (GetOneVirtualPixelFromHandler) NULL)\n    cache_info->methods.get_one_virtual_pixel_from_handler=\n      cache_methods->get_one_virtual_pixel_from_handler;\n  get_one_authentic_pixel_from_handler=\n    cache_methods->get_one_authentic_pixel_from_handler;\n  if (get_one_authentic_pixel_from_handler !=\n      (GetOneAuthenticPixelFromHandler) NULL)\n    cache_info->methods.get_one_authentic_pixel_from_handler=\n      cache_methods->get_one_authentic_pixel_from_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e N e x u s P i x e l s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheNexusPixels() defines the region of the cache for the\n%  specified cache nexus.\n%\n%  The format of the SetPixelCacheNexusPixels() method is:\n%\n%      PixelPacket SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n%        const MapMode mode,const RectangleInfo *region,\n%        const MagickBooleanType buffered,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o region: A pointer to the RectangleInfo structure that defines the\n%      region of this particular cache nexus.\n%\n%    o buffered: pixels are buffered.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType AcquireCacheNexusPixels(\n  const CacheInfo *magick_restrict cache_info,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  if (nexus_info->length != (MagickSizeType) ((size_t) nexus_info->length))\n    return(MagickFalse);\n  nexus_info->mapped=MagickFalse;\n  nexus_info->cache=(PixelPacket *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    (size_t) nexus_info->length));\n  if (nexus_info->cache == (PixelPacket *) NULL)\n    {\n      nexus_info->mapped=MagickTrue;\n      nexus_info->cache=(PixelPacket *) MapBlob(-1,IOMode,0,(size_t)\n        nexus_info->length);\n    }\n  if (nexus_info->cache == (PixelPacket *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        cache_info->filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsAuthenticPixelCache(\n  const CacheInfo *magick_restrict cache_info,\n  const NexusInfo *magick_restrict nexus_info)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  /*\n    Does nexus pixels point directly to in-core cache pixels or is it buffered?\n  */\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  status=nexus_info->pixels == (cache_info->pixels+offset) ? MagickTrue :\n    MagickFalse;\n  return(status);\n}\n\nstatic inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  magick_unreferenced(nexus_info);\n  magick_unreferenced(mode);\n\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}\n\nstatic PixelPacket *SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n  const MapMode mode,const RectangleInfo *region,\n  const MagickBooleanType buffered,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  assert(cache_info != (const CacheInfo *) NULL);\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->type == UndefinedCache)\n    return((PixelPacket *) NULL);\n  nexus_info->region=(*region);\n  if (((cache_info->type == MemoryCache) || (cache_info->type == MapCache)) &&\n      (buffered == MagickFalse))\n    {\n      ssize_t\n        x,\n        y;\n\n      x=nexus_info->region.x+(ssize_t) nexus_info->region.width-1;\n      y=nexus_info->region.y+(ssize_t) nexus_info->region.height-1;\n      if (((nexus_info->region.x >= 0) && (x < (ssize_t) cache_info->columns) &&\n           (nexus_info->region.y >= 0) && (y < (ssize_t) cache_info->rows)) &&\n          ((nexus_info->region.height == 1UL) || ((nexus_info->region.x == 0) &&\n           ((nexus_info->region.width == cache_info->columns) ||\n            ((nexus_info->region.width % cache_info->columns) == 0)))))\n        {\n          MagickOffsetType\n            offset;\n\n          /*\n            Pixels are accessed directly from memory.\n          */\n          offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n            nexus_info->region.x;\n          nexus_info->pixels=cache_info->pixels+offset;\n          nexus_info->indexes=(IndexPacket *) NULL;\n          if (cache_info->active_index_channel != MagickFalse)\n            nexus_info->indexes=cache_info->indexes+offset;\n          PrefetchPixelCacheNexusPixels(nexus_info,mode);\n          nexus_info->authentic_pixel_cache=IsAuthenticPixelCache(cache_info,\n            nexus_info);\n          return(nexus_info->pixels);\n        }\n    }\n  /*\n    Pixels are stored in a staging region until they are synced to the cache.\n  */\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  length=number_pixels*sizeof(PixelPacket);\n  if (cache_info->active_index_channel != MagickFalse)\n    length+=number_pixels*sizeof(IndexPacket);\n  if (nexus_info->cache == (PixelPacket *) NULL)\n    {\n      nexus_info->length=length;\n      status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n      if (status == MagickFalse)\n        {\n          nexus_info->length=0;\n          return((PixelPacket *) NULL);\n        }\n    }\n  else\n    if (nexus_info->length < length)\n      {\n        RelinquishCacheNexusPixels(nexus_info);\n        nexus_info->length=length;\n        status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          {\n            nexus_info->length=0;\n            return((PixelPacket *) NULL);\n          }\n      }\n  nexus_info->pixels=nexus_info->cache;\n  nexus_info->indexes=(IndexPacket *) NULL;\n  if (cache_info->active_index_channel != MagickFalse)\n    nexus_info->indexes=(IndexPacket *) (nexus_info->pixels+number_pixels);\n  PrefetchPixelCacheNexusPixels(nexus_info,mode);\n  nexus_info->authentic_pixel_cache=IsAuthenticPixelCache(cache_info,\n    nexus_info);\n  return(nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheVirtualMethod() sets the \"virtual pixels\" method for the\n%  pixel cache and returns the previous setting.  A virtual pixel is any pixel\n%  access that is outside the boundaries of the image cache.\n%\n%  The format of the SetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod SetPixelCacheVirtualMethod(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n*/\n\nstatic MagickBooleanType SetCacheAlphaChannel(Image *image,\n  const Quantum opacity)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  CacheView\n    *magick_restrict image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  image->matte=MagickTrue;\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,&image->exception);  /* must be virtual */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n      &image->exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      q->opacity=opacity;\n      q++;\n    }\n    status=SyncCacheViewAuthenticPixels(image_view,&image->exception);\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickExport VirtualPixelMethod SetPixelCacheVirtualMethod(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  VirtualPixelMethod\n    method;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  method=cache_info->virtual_pixel_method;\n  cache_info->virtual_pixel_method=virtual_pixel_method;\n  if ((image->columns != 0) && (image->rows != 0))\n    switch (virtual_pixel_method)\n    {\n      case BackgroundVirtualPixelMethod:\n      {\n        if ((image->background_color.opacity != OpaqueOpacity) &&\n            (image->matte == MagickFalse))\n          (void) SetCacheAlphaChannel((Image *) image,OpaqueOpacity);\n        if ((IsPixelGray(&image->background_color) == MagickFalse) &&\n            (IsGrayColorspace(image->colorspace) != MagickFalse))\n          (void) SetImageColorspace((Image *) image,sRGBColorspace);\n        break;\n      }\n      case TransparentVirtualPixelMethod:\n      {\n        if (image->matte == MagickFalse)\n          (void) SetCacheAlphaChannel((Image *) image,OpaqueOpacity);\n        break;\n      }\n      default:\n        break;\n    }\n  return(method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e N e x u s                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelCacheNexus() saves the authentic image pixels to the\n%  in-memory or disk cache.  The method returns MagickTrue if the pixel region\n%  is synced, otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelCacheNexus() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to sync.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Transfer pixels to the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->cache == (Cache) NULL)\n    ThrowBinaryException(CacheError,\"PixelCacheIsNotOpen\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->type == UndefinedCache)\n    return(MagickFalse);\n  if ((image->storage_class == DirectClass) &&\n      (image->clip_mask != (Image *) NULL) &&\n      (ClipPixelCacheNexus(image,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if ((image->storage_class == DirectClass) &&\n      (image->mask != (Image *) NULL) &&\n      (MaskPixelCacheNexus(image,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    {\n      image->taint=MagickTrue;\n      return(MagickTrue);\n    }\n  assert(cache_info->signature == MagickSignature);\n  status=WritePixelCachePixels(cache_info,nexus_info,exception);\n  if ((cache_info->active_index_channel != MagickFalse) &&\n      (WritePixelCacheIndexes(cache_info,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if (status != MagickFalse)\n    image->taint=MagickTrue;\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelsCache() saves the authentic image pixels to the in-memory\n%  or disk cache.  The method returns MagickTrue if the pixel region is synced,\n%  otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelsCache() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c A u t h e n t i c P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixels() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncAuthenticPixels() method is:\n%\n%      MagickBooleanType SyncAuthenticPixels(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SyncAuthenticPixels(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.sync_authentic_pixels_handler !=\n       (SyncAuthenticPixelsHandler) NULL)\n    return(cache_info->methods.sync_authentic_pixels_handler(image,exception));\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImagePixelCache() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncImagePixelCache() method is:\n%\n%      MagickBooleanType SyncImagePixelCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e P i x e l C a c h e I n d e x e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCacheIndexes() writes the colormap indexes to the specified\n%  region of the pixel cache.\n%\n%  The format of the WritePixelCacheIndexes() method is:\n%\n%      MagickBooleanType WritePixelCacheIndexes(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the colormap indexes.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCacheIndexes(CacheInfo *cache_info,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const IndexPacket\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->active_index_channel == MagickFalse)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(IndexPacket);\n  rows=nexus_info->region.height;\n  extent=(MagickSizeType) length*rows;\n  p=nexus_info->indexes;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register IndexPacket\n        *magick_restrict q;\n\n      /*\n        Write indexes to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=cache_info->indexes+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=nexus_info->region.width;\n        q+=cache_info->columns;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write indexes to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+extent*\n          sizeof(PixelPacket)+offset*sizeof(*p),length,(const unsigned char *)\n          p);\n        if ((MagickSizeType) count < length)\n          break;\n        p+=nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write indexes to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCacheIndexes((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e P i x e l C a c h e P i x e l s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCachePixels() writes image pixels to the specified region of the\n%  pixel cache.\n%\n%  The format of the WritePixelCachePixels() method is:\n%\n%      MagickBooleanType WritePixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCachePixels(CacheInfo *cache_info,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const PixelPacket\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(PixelPacket);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  p=nexus_info->pixels;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register PixelPacket\n        *magick_restrict q;\n\n      /*\n        Write pixels to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=cache_info->pixels+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=nexus_info->region.width;\n        q+=cache_info->columns;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write pixels to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+offset*\n          sizeof(*p),length,(const unsigned char *) p);\n        if ((MagickSizeType) count < length)\n          break;\n        p+=nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write pixels to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%                      CCCC   AAA    CCCC  H   H  EEEEE                       %\n%                     C      A   A  C      H   H  E                           %\n%                     C      AAAAA  C      HHHHH  EEE                         %\n%                     C      A   A  C      H   H  E                           %\n%                      CCCC  A   A   CCCC  H   H  EEEEE                       %\n%                                                                             %\n%                                                                             %\n%                       MagickCore Pixel Cache Methods                        %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1999                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2016 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    http://www.imagemagick.org/script/license.php                            %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"magick/studio.h\"\n#include \"magick/blob.h\"\n#include \"magick/blob-private.h\"\n#include \"magick/cache.h\"\n#include \"magick/cache-private.h\"\n#include \"magick/color-private.h\"\n#include \"magick/colorspace.h\"\n#include \"magick/colorspace-private.h\"\n#include \"magick/composite-private.h\"\n#include \"magick/distribute-cache-private.h\"\n#include \"magick/exception.h\"\n#include \"magick/exception-private.h\"\n#include \"magick/geometry.h\"\n#include \"magick/list.h\"\n#include \"magick/log.h\"\n#include \"magick/magick.h\"\n#include \"magick/memory_.h\"\n#include \"magick/memory-private.h\"\n#include \"magick/nt-base-private.h\"\n#include \"magick/option.h\"\n#include \"magick/pixel.h\"\n#include \"magick/pixel-accessor.h\"\n#include \"magick/pixel-private.h\"\n#include \"magick/policy.h\"\n#include \"magick/quantum.h\"\n#include \"magick/random_.h\"\n#include \"magick/registry.h\"\n#include \"magick/resource_.h\"\n#include \"magick/semaphore.h\"\n#include \"magick/splay-tree.h\"\n#include \"magick/string_.h\"\n#include \"magick/string-private.h\"\n#include \"magick/thread-private.h\"\n#include \"magick/utility.h\"\n#include \"magick/utility-private.h\"\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n#include \"zlib.h\"\n#endif\n\f\n/*\n  Define declarations.\n*/\n#define CacheTick(offset,extent)  QuantumTick((MagickOffsetType) offset,extent)\n#define IsFileDescriptorLimitExceeded() (GetMagickResource(FileResource) > \\\n  GetMagickResourceLimit(FileResource) ? MagickTrue : MagickFalse)\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _MagickModulo\n{\n  ssize_t\n    quotient,\n    remainder;\n} MagickModulo;\n\f\n/*\n  Forward declarations.\n*/\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\nstatic Cache\n  GetImagePixelCache(Image *,const MagickBooleanType,ExceptionInfo *)\n    magick_hot_spot;\n\nstatic const IndexPacket\n  *GetVirtualIndexesFromCache(const Image *);\n\nstatic const PixelPacket\n  *GetVirtualPixelCache(const Image *,const VirtualPixelMethod,const ssize_t,\n    const ssize_t,const size_t,const size_t,ExceptionInfo *),\n  *GetVirtualPixelsCache(const Image *);\n\nstatic MagickBooleanType\n  GetOneAuthenticPixelFromCache(Image *,const ssize_t,const ssize_t,\n    PixelPacket *,ExceptionInfo *),\n  GetOneVirtualPixelFromCache(const Image *,const VirtualPixelMethod,\n    const ssize_t,const ssize_t,PixelPacket *,ExceptionInfo *),\n  OpenPixelCache(Image *,const MapMode,ExceptionInfo *),\n  OpenPixelCacheOnDisk(CacheInfo *,const MapMode),\n  ReadPixelCacheIndexes(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  ReadPixelCachePixels(CacheInfo *magick_restrict,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  SyncAuthenticPixelsCache(Image *,ExceptionInfo *),\n  WritePixelCacheIndexes(CacheInfo *,NexusInfo *magick_restrict,\n    ExceptionInfo *),\n  WritePixelCachePixels(CacheInfo *,NexusInfo *magick_restrict,\n    ExceptionInfo *);\n\nstatic PixelPacket\n  *GetAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *QueueAuthenticPixelsCache(Image *,const ssize_t,const ssize_t,const size_t,\n    const size_t,ExceptionInfo *),\n  *SetPixelCacheNexusPixels(const CacheInfo *,const MapMode,\n    const RectangleInfo *,const MagickBooleanType,NexusInfo *,ExceptionInfo *)\n    magick_hot_spot;\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\f\n/*\n  Global declarations.\n*/\nstatic volatile MagickBooleanType\n  instantiate_cache = MagickFalse;\n\nstatic SemaphoreInfo\n  *cache_semaphore = (SemaphoreInfo *) NULL;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCache() acquires a pixel cache.\n%\n%  The format of the AcquirePixelCache() method is:\n%\n%      Cache AcquirePixelCache(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickExport Cache AcquirePixelCache(const size_t number_threads)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  char\n    *synchronize;\n\n  cache_info=(CacheInfo *) AcquireQuantumMemory(1,sizeof(*cache_info));\n  if (cache_info == (CacheInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(cache_info,0,sizeof(*cache_info));\n  cache_info->type=UndefinedCache;\n  cache_info->mode=IOMode;\n  cache_info->colorspace=sRGBColorspace;\n  cache_info->channels=4;\n  cache_info->file=(-1);\n  cache_info->id=GetMagickThreadId();\n  cache_info->number_threads=number_threads;\n  if (GetOpenMPMaximumThreads() > cache_info->number_threads)\n    cache_info->number_threads=GetOpenMPMaximumThreads();\n  if (GetMagickResourceLimit(ThreadResource) > cache_info->number_threads)\n    cache_info->number_threads=(size_t) GetMagickResourceLimit(ThreadResource);\n  if (cache_info->number_threads == 0)\n    cache_info->number_threads=1;\n  cache_info->nexus_info=AcquirePixelCacheNexus(cache_info->number_threads);\n  if (cache_info->nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  synchronize=GetEnvironmentValue(\"MAGICK_SYNCHRONIZE\");\n  if (synchronize != (const char *) NULL)\n    {\n      cache_info->synchronize=IsStringTrue(synchronize);\n      synchronize=DestroyString(synchronize);\n    }\n  cache_info->semaphore=AllocateSemaphoreInfo();\n  cache_info->reference_count=1;\n  cache_info->file_semaphore=AllocateSemaphoreInfo();\n  cache_info->debug=IsEventLogging();\n  cache_info->signature=MagickSignature;\n  return((Cache ) cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   A c q u i r e P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCacheNexus() allocates the NexusInfo structure.\n%\n%  The format of the AcquirePixelCacheNexus method is:\n%\n%      NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\nMagickExport NexusInfo **AcquirePixelCacheNexus(const size_t number_threads)\n{\n  NexusInfo\n    **magick_restrict nexus_info;\n\n  register ssize_t\n    i;\n\n  nexus_info=(NexusInfo **) MagickAssumeAligned(AcquireAlignedMemory(\n    number_threads,sizeof(*nexus_info)));\n  if (nexus_info == (NexusInfo **) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  nexus_info[0]=(NexusInfo *) AcquireQuantumMemory(number_threads,\n    sizeof(**nexus_info));\n  if (nexus_info[0] == (NexusInfo *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) ResetMagickMemory(nexus_info[0],0,number_threads*sizeof(**nexus_info));\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    nexus_info[i]=(&nexus_info[0][i]);\n    nexus_info[i]->signature=MagickSignature;\n  }\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   A c q u i r e P i x e l C a c h e P i x e l s                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  AcquirePixelCachePixels() returns the pixels associated with the specified\n%  image.\n%\n%  The format of the AcquirePixelCachePixels() method is:\n%\n%      const void *AcquirePixelCachePixels(const Image *image,\n%        MagickSizeType *length,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const void *AcquirePixelCachePixels(const Image *image,\n  MagickSizeType *length,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  (void) exception;\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((const void *) NULL);\n  *length=cache_info->length;\n  return((const void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t G e n e s i s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentGenesis() instantiates the cache component.\n%\n%  The format of the CacheComponentGenesis method is:\n%\n%      MagickBooleanType CacheComponentGenesis(void)\n%\n*/\nMagickExport MagickBooleanType CacheComponentGenesis(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    cache_semaphore=AllocateSemaphoreInfo();\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C a c h e C o m p o n e n t T e r m i n u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CacheComponentTerminus() destroys the cache component.\n%\n%  The format of the CacheComponentTerminus() method is:\n%\n%      CacheComponentTerminus(void)\n%\n*/\nMagickExport void CacheComponentTerminus(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&cache_semaphore);\n  LockSemaphoreInfo(cache_semaphore);\n  instantiate_cache=MagickFalse;\n  UnlockSemaphoreInfo(cache_semaphore);\n  DestroySemaphoreInfo(&cache_semaphore);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l i p P i x e l C a c h e N e x u s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClipPixelCacheNexus() clips the cache nexus as defined by the image clip\n%  mask.  The method returns MagickTrue if the pixel region is clipped,\n%  otherwise MagickFalse.\n%\n%  The format of the ClipPixelCacheNexus() method is:\n%\n%      MagickBooleanType ClipPixelCacheNexus(Image *image,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to clip.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType ClipPixelCacheNexus(Image *image,\n  NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickSizeType\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict clip_nexus,\n    **magick_restrict image_nexus;\n\n  register const PixelPacket\n    *magick_restrict r;\n\n  register IndexPacket\n    *magick_restrict nexus_indexes,\n    *magick_restrict indexes;\n\n  register PixelPacket\n    *magick_restrict p,\n    *magick_restrict q;\n\n  register ssize_t\n    i;\n\n  /*\n    Apply clip mask.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->clip_mask == (Image *) NULL) ||\n      (image->storage_class == PseudoClass))\n    return(MagickTrue);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return(MagickFalse);\n  image_nexus=AcquirePixelCacheNexus(1);\n  clip_nexus=AcquirePixelCacheNexus(1);\n  if ((image_nexus == (NexusInfo **) NULL) ||\n      (clip_nexus == (NexusInfo **) NULL))\n    ThrowBinaryException(CacheError,\"UnableToGetCacheNexus\",image->filename);\n  p=GetAuthenticPixelCacheNexus(image,nexus_info->region.x,nexus_info->region.y,\n    nexus_info->region.width,nexus_info->region.height,image_nexus[0],\n    exception);\n  indexes=image_nexus[0]->indexes;\n  q=nexus_info->pixels;\n  nexus_indexes=nexus_info->indexes;\n  r=GetVirtualPixelsFromNexus(image->clip_mask,MaskVirtualPixelMethod,\n    nexus_info->region.x,nexus_info->region.y,nexus_info->region.width,\n    nexus_info->region.height,clip_nexus[0],exception);\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  for (i=0; i < (ssize_t) number_pixels; i++)\n  {\n    if ((p == (PixelPacket *) NULL) || (r == (const PixelPacket *) NULL))\n      break;\n    if (GetPixelIntensity(image,r) > (QuantumRange/2.0))\n      {\n        SetPixelRed(q,GetPixelRed(p));\n        SetPixelGreen(q,GetPixelGreen(p));\n        SetPixelBlue(q,GetPixelBlue(p));\n        SetPixelOpacity(q,GetPixelOpacity(p));\n        if (cache_info->active_index_channel != MagickFalse)\n          SetPixelIndex(nexus_indexes+i,GetPixelIndex(indexes+i));\n      }\n    p++;\n    q++;\n    r++;\n  }\n  clip_nexus=DestroyPixelCacheNexus(clip_nexus,1);\n  image_nexus=DestroyPixelCacheNexus(image_nexus,1);\n  if (i < (ssize_t) number_pixels)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCache() clones a pixel cache.\n%\n%  The format of the ClonePixelCache() method is:\n%\n%      Cache ClonePixelCache(const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport Cache ClonePixelCache(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict clone_info;\n\n  const CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != NULL);\n  cache_info=(const CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  clone_info=(CacheInfo *) AcquirePixelCache(cache_info->number_threads);\n  if (clone_info == (Cache) NULL)\n    return((Cache) NULL);\n  clone_info->virtual_pixel_method=cache_info->virtual_pixel_method;\n  return((Cache ) clone_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e M e t h o d s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ClonePixelCacheMethods() clones the pixel cache methods from one cache to\n%  another.\n%\n%  The format of the ClonePixelCacheMethods() method is:\n%\n%      void ClonePixelCacheMethods(Cache clone,const Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o clone: Specifies a pointer to a Cache structure.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport void ClonePixelCacheMethods(Cache clone,const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict source_info;\n\n  assert(clone != (Cache) NULL);\n  source_info=(CacheInfo *) clone;\n  assert(source_info->signature == MagickSignature);\n  if (source_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      source_info->filename);\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  source_info->methods=cache_info->methods;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   C l o n e P i x e l C a c h e R e p o s i t o r y                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% %\n%  ClonePixelCacheRepository() clones the source pixel cache to the destination\n%  cache.\n%\n%  The format of the ClonePixelCacheRepository() method is:\n%\n%      MagickBooleanType ClonePixelCacheRepository(CacheInfo *cache_info,\n%        CacheInfo *source_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o source_info: the source pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic MagickBooleanType ClonePixelCacheOnDisk(\n  CacheInfo *magick_restrict cache_info,CacheInfo *magick_restrict clone_info,\n  ExceptionInfo *exception)\n{\n  MagickSizeType\n    extent;\n\n  size_t\n    quantum;\n\n  ssize_t\n    count;\n\n  struct stat\n    file_stats;\n\n  unsigned char\n    *buffer;\n\n  /*\n    Clone pixel cache on disk with identical morphology.\n  */\n  if ((OpenPixelCacheOnDisk(cache_info,ReadMode) == MagickFalse) ||\n      (OpenPixelCacheOnDisk(clone_info,IOMode) == MagickFalse))\n    return(MagickFalse);\n  quantum=(size_t) MagickMaxBufferExtent;\n  if ((fstat(cache_info->file,&file_stats) == 0) && (file_stats.st_size > 0))\n    quantum=(size_t) MagickMin(file_stats.st_size,MagickMaxBufferExtent);\n  buffer=(unsigned char *) AcquireQuantumMemory(quantum,sizeof(*buffer));\n  if (buffer == (unsigned char *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  extent=0;\n  while ((count=read(cache_info->file,buffer,quantum)) > 0)\n  {\n    ssize_t\n      number_bytes;\n\n    number_bytes=write(clone_info->file,buffer,(size_t) count);\n    if (number_bytes != count)\n      break;\n    extent+=number_bytes;\n  }\n  buffer=(unsigned char *) RelinquishMagickMemory(buffer);\n  if (extent != cache_info->length)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ClonePixelCacheRepository(\n  CacheInfo *magick_restrict clone_info,CacheInfo *magick_restrict cache_info,\n  ExceptionInfo *exception)\n{\n#define MaxCacheThreads  2\n#define cache_threads(source,destination) \\\n  num_threads(((source)->type == DiskCache) || \\\n    ((destination)->type == DiskCache) || (((source)->rows) < \\\n    (16*GetMagickResourceLimit(ThreadResource))) ? 1 : \\\n    GetMagickResourceLimit(ThreadResource) < MaxCacheThreads ? \\\n    GetMagickResourceLimit(ThreadResource) : MaxCacheThreads)\n\n  MagickBooleanType\n    status;\n\n  NexusInfo\n    **magick_restrict cache_nexus,\n    **magick_restrict clone_nexus;\n\n  size_t\n    length;\n\n  ssize_t\n    y;\n\n  assert(cache_info != (CacheInfo *) NULL);\n  assert(clone_info != (CacheInfo *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  if ((cache_info->columns == clone_info->columns) &&\n      (cache_info->rows == clone_info->rows) &&\n      (cache_info->active_index_channel == clone_info->active_index_channel))\n    {\n      /*\n        Identical pixel cache morphology.\n      */\n      if (((cache_info->type == MemoryCache) ||\n           (cache_info->type == MapCache)) &&\n          ((clone_info->type == MemoryCache) ||\n           (clone_info->type == MapCache)))\n        {\n          (void) memcpy(clone_info->pixels,cache_info->pixels,\n            cache_info->columns*cache_info->rows*sizeof(*cache_info->pixels));\n          if ((cache_info->active_index_channel != MagickFalse) &&\n              (clone_info->active_index_channel != MagickFalse))\n            (void) memcpy(clone_info->indexes,cache_info->indexes,\n              cache_info->columns*cache_info->rows*\n              sizeof(*cache_info->indexes));\n          return(MagickTrue);\n        }\n      if ((cache_info->type == DiskCache) && (clone_info->type == DiskCache))\n        return(ClonePixelCacheOnDisk(cache_info,clone_info,exception));\n    }\n  /*\n    Mismatched pixel cache morphology.\n  */\n  cache_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  clone_nexus=AcquirePixelCacheNexus(MaxCacheThreads);\n  if ((cache_nexus == (NexusInfo **) NULL) ||\n      (clone_nexus == (NexusInfo **) NULL))\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n    sizeof(*cache_info->pixels);\n  status=MagickTrue;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    cache_threads(cache_info,clone_info)\n#endif\n  for (y=0; y < (ssize_t) cache_info->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n\n    PixelPacket\n      *pixels;\n\n    RectangleInfo\n      region;\n\n    if (status == MagickFalse)\n      continue;\n    if (y == (ssize_t) clone_info->rows)\n      continue;\n    region.width=cache_info->columns;\n    region.height=1;\n    region.x=0;\n    region.y=y;\n    pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n      cache_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    status=ReadPixelCachePixels(cache_info,cache_nexus[id],exception);\n    if (status == MagickFalse)\n      continue;\n    region.width=clone_info->columns;\n    pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n      clone_nexus[id],exception);\n    if (pixels == (PixelPacket *) NULL)\n      continue;\n    (void) ResetMagickMemory(clone_nexus[id]->pixels,0,(size_t)\n      clone_nexus[id]->length);\n    (void) memcpy(clone_nexus[id]->pixels,cache_nexus[id]->pixels,length);\n    status=WritePixelCachePixels(clone_info,clone_nexus[id],exception);\n  }\n  if ((cache_info->active_index_channel != MagickFalse) &&\n      (clone_info->active_index_channel != MagickFalse))\n    {\n      /*\n        Clone indexes.\n      */\n      length=(size_t) MagickMin(cache_info->columns,clone_info->columns)*\n        sizeof(*cache_info->indexes);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp parallel for schedule(static,4) shared(status) \\\n        cache_threads(cache_info,clone_info)\n#endif\n      for (y=0; y < (ssize_t) cache_info->rows; y++)\n      {\n        const int\n          id = GetOpenMPThreadId();\n\n        PixelPacket\n          *pixels;\n\n        RectangleInfo\n          region;\n\n        if (status == MagickFalse)\n          continue;\n        if (y == (ssize_t) clone_info->rows)\n          continue;\n        region.width=cache_info->columns;\n        region.height=1;\n        region.x=0;\n        region.y=y;\n        pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,MagickTrue,\n          cache_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        status=ReadPixelCacheIndexes(cache_info,cache_nexus[id],exception);\n        if (status == MagickFalse)\n          continue;\n        region.width=clone_info->columns;\n        pixels=SetPixelCacheNexusPixels(clone_info,WriteMode,&region,MagickTrue,\n          clone_nexus[id],exception);\n        if (pixels == (PixelPacket *) NULL)\n          continue;\n        (void) memcpy(clone_nexus[id]->indexes,cache_nexus[id]->indexes,length);\n        status=WritePixelCacheIndexes(clone_info,clone_nexus[id],exception);\n      }\n    }\n  cache_nexus=DestroyPixelCacheNexus(cache_nexus,MaxCacheThreads);\n  clone_nexus=DestroyPixelCacheNexus(clone_nexus,MaxCacheThreads);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MaxTextExtent];\n\n      (void) FormatLocaleString(message,MaxTextExtent,\"%s => %s\",\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) cache_info->type),\n        CommandOptionToMnemonic(MagickCacheOptions,(ssize_t) clone_info->type));\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l C a c h e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixelCache() method is:\n%\n%      void DestroyImagePixelCache(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic void DestroyImagePixelCache(Image *image)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if (image->cache == (void *) NULL)\n    return;\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y I m a g e P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyImagePixels() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyImagePixels() method is:\n%\n%      void DestroyImagePixels(Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport void DestroyImagePixels(Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    {\n      cache_info->methods.destroy_pixel_handler(image);\n      return;\n    }\n  image->cache=DestroyPixelCache(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCache() deallocates memory associated with the pixel cache.\n%\n%  The format of the DestroyPixelCache() method is:\n%\n%      Cache DestroyPixelCache(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\n\nstatic MagickBooleanType ClosePixelCacheOnDisk(CacheInfo *cache_info)\n{\n  int\n    status;\n\n  status=(-1);\n  if (cache_info->file != -1)\n    {\n      status=close(cache_info->file);\n      cache_info->file=(-1);\n      RelinquishMagickResource(FileResource,1);\n    }\n  return(status == -1 ? MagickFalse : MagickTrue);\n}\n\nstatic inline void RelinquishPixelCachePixels(CacheInfo *cache_info)\n{\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    {\n      if (cache_info->mapped == MagickFalse)\n        cache_info->pixels=(PixelPacket *) RelinquishAlignedMemory(\n          cache_info->pixels);\n      else\n        {\n          (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n          cache_info->pixels=(PixelPacket *) NULL;\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n      break;\n    }\n    case MapCache:\n    {\n      (void) UnmapBlob(cache_info->pixels,(size_t) cache_info->length);\n      cache_info->pixels=(PixelPacket *) NULL;\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n    case DiskCache:\n    {\n      if (cache_info->file != -1)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      if (cache_info->mode != ReadMode)\n        (void) RelinquishUniqueFileResource(cache_info->cache_filename);\n      *cache_info->cache_filename='\\0';\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      break;\n    }\n    case DistributedCache:\n    {\n      *cache_info->cache_filename='\\0';\n      (void) RelinquishDistributePixelCache((DistributeCacheInfo *)\n        cache_info->server_info);\n      break;\n    }\n    default:\n      break;\n  }\n  cache_info->type=UndefinedCache;\n  cache_info->mapped=MagickFalse;\n  cache_info->indexes=(IndexPacket *) NULL;\n}\n\nMagickExport Cache DestroyPixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count--;\n  if (cache_info->reference_count != 0)\n    {\n      UnlockSemaphoreInfo(cache_info->semaphore);\n      return((Cache) NULL);\n    }\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  if (cache_info->debug != MagickFalse)\n    {\n      char\n        message[MaxTextExtent];\n\n      (void) FormatLocaleString(message,MaxTextExtent,\"destroy %s\",\n        cache_info->filename);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  RelinquishPixelCachePixels(cache_info);\n  if (cache_info->server_info != (DistributeCacheInfo *) NULL)\n    cache_info->server_info=DestroyDistributeCacheInfo((DistributeCacheInfo *)\n      cache_info->server_info);\n  if (cache_info->nexus_info != (NexusInfo **) NULL)\n    cache_info->nexus_info=DestroyPixelCacheNexus(cache_info->nexus_info,\n      cache_info->number_threads);\n  if (cache_info->random_info != (RandomInfo *) NULL)\n    cache_info->random_info=DestroyRandomInfo(cache_info->random_info);\n  if (cache_info->file_semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&cache_info->file_semaphore);\n  if (cache_info->semaphore != (SemaphoreInfo *) NULL)\n    DestroySemaphoreInfo(&cache_info->semaphore);\n  cache_info->signature=(~MagickSignature);\n  cache_info=(CacheInfo *) RelinquishMagickMemory(cache_info);\n  cache=(Cache) NULL;\n  return(cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   D e s t r o y P i x e l C a c h e N e x u s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  DestroyPixelCacheNexus() destroys a pixel cache nexus.\n%\n%  The format of the DestroyPixelCacheNexus() method is:\n%\n%      NexusInfo **DestroyPixelCacheNexus(NexusInfo *nexus_info,\n%        const size_t number_threads)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus to destroy.\n%\n%    o number_threads: the number of nexus threads.\n%\n*/\n\nstatic inline void RelinquishCacheNexusPixels(NexusInfo *nexus_info)\n{\n  if (nexus_info->mapped == MagickFalse)\n    (void) RelinquishAlignedMemory(nexus_info->cache);\n  else\n    (void) UnmapBlob(nexus_info->cache,(size_t) nexus_info->length);\n  nexus_info->cache=(PixelPacket *) NULL;\n  nexus_info->pixels=(PixelPacket *) NULL;\n  nexus_info->indexes=(IndexPacket *) NULL;\n  nexus_info->length=0;\n  nexus_info->mapped=MagickFalse;\n}\n\nMagickExport NexusInfo **DestroyPixelCacheNexus(NexusInfo **nexus_info,\n  const size_t number_threads)\n{\n  register ssize_t\n    i;\n\n  assert(nexus_info != (NexusInfo **) NULL);\n  for (i=0; i < (ssize_t) number_threads; i++)\n  {\n    if (nexus_info[i]->cache != (PixelPacket *) NULL)\n      RelinquishCacheNexusPixels(nexus_info[i]);\n    nexus_info[i]->signature=(~MagickSignature);\n  }\n  nexus_info[0]=(NexusInfo *) RelinquishMagickMemory(nexus_info[0]);\n  nexus_info=(NexusInfo **) RelinquishAlignedMemory(nexus_info);\n  return(nexus_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c I n d e x e s F r o m C a c h e                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticIndexesFromCache() returns the indexes associated with the last\n%  call to QueueAuthenticPixelsCache() or GetAuthenticPixelsCache().\n%\n%  The format of the GetAuthenticIndexesFromCache() method is:\n%\n%      IndexPacket *GetAuthenticIndexesFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic IndexPacket *GetAuthenticIndexesFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->indexes);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c I n d e x Q u e u e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticIndexQueue() returns the authentic black channel or the colormap\n%  indexes associated with the last call to QueueAuthenticPixels() or\n%  GetVirtualPixels().  NULL is returned if the black channel or colormap\n%  indexes are not available.\n%\n%  The format of the GetAuthenticIndexQueue() method is:\n%\n%      IndexPacket *GetAuthenticIndexQueue(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport IndexPacket *GetAuthenticIndexQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_indexes_from_handler !=\n       (GetAuthenticIndexesFromHandler) NULL)\n    return(cache_info->methods.get_authentic_indexes_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->indexes);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l C a c h e N e x u s                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelCacheNexus() gets authentic pixels from the in-memory or\n%  disk pixel cache as defined by the geometry parameters.   A pointer to the\n%  pixels is returned if the pixels are transferred, otherwise a NULL is\n%  returned.\n%\n%  The format of the GetAuthenticPixelCacheNexus() method is:\n%\n%      PixelPacket *GetAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to return.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nMagickExport PixelPacket *GetAuthenticPixelCacheNexus(Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  /*\n    Transfer pixels from the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  pixels=QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickTrue,\n    nexus_info,exception);\n  if (pixels == (PixelPacket *) NULL)\n    return((PixelPacket *) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(pixels);\n  if (ReadPixelCachePixels(cache_info,nexus_info,exception) == MagickFalse)\n    return((PixelPacket *) NULL);\n  if (cache_info->active_index_channel != MagickFalse)\n    if (ReadPixelCacheIndexes(cache_info,nexus_info,exception) == MagickFalse)\n      return((PixelPacket *) NULL);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsFromCache() returns the pixels associated with the last\n%  call to the QueueAuthenticPixelsCache() or GetAuthenticPixelsCache() methods.\n%\n%  The format of the GetAuthenticPixelsFromCache() method is:\n%\n%      PixelPacket *GetAuthenticPixelsFromCache(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic PixelPacket *GetAuthenticPixelsFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l Q u e u e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelQueue() returns the authentic pixels associated with the\n%  last call to QueueAuthenticPixels() or GetAuthenticPixels().\n%\n%  The format of the GetAuthenticPixelQueue() method is:\n%\n%      PixelPacket *GetAuthenticPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport PixelPacket *GetAuthenticPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_pixels_from_handler !=\n       (GetAuthenticPixelsFromHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(cache_info->nexus_info[id]->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t A u t h e n t i c P i x e l s                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixels() obtains a pixel region for read/write access. If the\n%  region is successfully accessed, a pointer to a PixelPacket array\n%  representing the region is returned, otherwise NULL is returned.\n%\n%  The returned pointer may point to a temporary working copy of the pixels\n%  or it may point to the original pixels in memory. Performance is maximized\n%  if the selected region is part of one row, or one or more full rows, since\n%  then there is opportunity to access the pixels in-place (without a copy)\n%  if the image is in memory, or in a memory-mapped file. The returned pointer\n%  must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  PixelPacket. If the image type is CMYK or if the storage class is\n%  PseduoClass, call GetAuthenticIndexQueue() after invoking\n%  GetAuthenticPixels() to obtain the black color component or colormap indexes\n%  (of type IndexPacket) corresponding to the region.  Once the PixelPacket\n%  (and/or IndexPacket) array has been updated, the changes must be saved back\n%  to the underlying image using SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the GetAuthenticPixels() method is:\n%\n%      PixelPacket *GetAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport PixelPacket *GetAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_authentic_pixels_handler !=\n       (GetAuthenticPixelsHandler) NULL)\n    return(cache_info->methods.get_authentic_pixels_handler(image,x,y,columns,\n      rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t A u t h e n t i c P i x e l s C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetAuthenticPixelsCache() gets pixels from the in-memory or disk pixel cache\n%  as defined by the geometry parameters.   A pointer to the pixels is returned\n%  if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetAuthenticPixelsCache() method is:\n%\n%      PixelPacket *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic PixelPacket *GetAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return((PixelPacket *) NULL);\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetAuthenticPixelCacheNexus(image,x,y,columns,rows,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e E x t e n t                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageExtent() returns the extent of the pixels associated with the\n%  last call to QueueAuthenticPixels() or GetAuthenticPixels().\n%\n%  The format of the GetImageExtent() method is:\n%\n%      MagickSizeType GetImageExtent(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport MagickSizeType GetImageExtent(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetPixelCacheNexusExtent(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCache() ensures that there is only a single reference to the\n%  pixel cache to be modified, updating the provided cache pointer to point to\n%  a clone of the original pixel cache if necessary.\n%\n%  The format of the GetImagePixelCache method is:\n%\n%      Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o clone: any value other than MagickFalse clones the cache pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType ValidatePixelCacheMorphology(\n  const Image *magick_restrict image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  /*\n    Does the image match the pixel cache morphology?\n  */\n  cache_info=(CacheInfo *) image->cache;\n  if ((image->storage_class != cache_info->storage_class) ||\n      (image->colorspace != cache_info->colorspace) ||\n      (image->channels != cache_info->channels) ||\n      (image->columns != cache_info->columns) ||\n      (image->rows != cache_info->rows) ||\n      (cache_info->nexus_info == (NexusInfo **) NULL))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic Cache GetImagePixelCache(Image *image,const MagickBooleanType clone,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    destroy,\n    status;\n\n  static MagickSizeType\n    cpu_throttle = MagickResourceInfinity,\n    cycles = 0,\n    time_limit = 0;\n\n  static time_t\n    cache_timestamp = 0;\n\n  status=MagickTrue;\n  if (cpu_throttle == MagickResourceInfinity)\n    cpu_throttle=GetMagickResourceLimit(ThrottleResource);\n  if ((cpu_throttle != 0) && ((cycles++ % 32) == 0))\n    MagickDelay(cpu_throttle);\n  if (time_limit == 0)\n    {\n      /*\n        Set the expire time in seconds.\n      */\n      time_limit=GetMagickResourceLimit(TimeResource);\n      cache_timestamp=time((time_t *) NULL);\n    }\n  if ((time_limit != MagickResourceInfinity) &&\n      ((MagickSizeType) (time((time_t *) NULL)-cache_timestamp) >= time_limit))\n     {\n#if defined(ECANCELED)\n       errno=ECANCELED;\n#endif\n       ThrowFatalException(ResourceLimitFatalError,\"TimeLimitExceeded\");\n     }\n  LockSemaphoreInfo(image->semaphore);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  destroy=MagickFalse;\n  if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->reference_count > 1) || (cache_info->mode == ReadMode))\n        {\n          CacheInfo\n            *clone_info;\n\n          Image\n            clone_image;\n\n          /*\n            Clone pixel cache.\n          */\n          clone_image=(*image);\n          clone_image.semaphore=AllocateSemaphoreInfo();\n          clone_image.reference_count=1;\n          clone_image.cache=ClonePixelCache(cache_info);\n          clone_info=(CacheInfo *) clone_image.cache;\n          status=OpenPixelCache(&clone_image,IOMode,exception);\n          if (status != MagickFalse)\n            {\n              if (clone != MagickFalse)\n                status=ClonePixelCacheRepository(clone_info,cache_info,\n                  exception);\n              if (status != MagickFalse)\n                {\n                  if (cache_info->reference_count == 1)\n                    cache_info->nexus_info=(NexusInfo **) NULL;\n                  destroy=MagickTrue;\n                  image->cache=clone_image.cache;\n                }\n            }\n          DestroySemaphoreInfo(&clone_image.semaphore);\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  if (destroy != MagickFalse)\n    cache_info=(CacheInfo *) DestroyPixelCache(cache_info);\n  if (status != MagickFalse)\n    {\n      /*\n        Ensure the image matches the pixel cache morphology.\n      */\n      image->type=UndefinedType;\n      if (ValidatePixelCacheMorphology(image) == MagickFalse)\n        {\n          status=OpenPixelCache(image,IOMode,exception);\n          cache_info=(CacheInfo *) image->cache;\n          if (cache_info->type == DiskCache)\n            (void) ClosePixelCacheOnDisk(cache_info);\n        }\n    }\n  UnlockSemaphoreInfo(image->semaphore);\n  if (status == MagickFalse)\n    return((Cache) NULL);\n  return(image->cache);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t I m a g e P i x e l C a c h e T y p e                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImagePixelCacheType() returns the pixel cache type: UndefinedCache,\n%  DiskCache, MapCache, MemoryCache, or PingCache.\n%\n%  The format of the GetImagePixelCacheType() method is:\n%\n%      CacheType GetImagePixelCacheType(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\n\nMagickExport CacheType GetPixelCacheType(const Image *image)\n{\n  return(GetImagePixelCacheType(image));\n}\n\nMagickExport CacheType GetImagePixelCacheType(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  return(cache_info->type);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e A u t h e n t i c P i x e l                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixel() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixel() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixel(const Image image,const ssize_t x,\n%        const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneAuthenticPixel(Image *image,\n  const ssize_t x,const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  if (cache_info->methods.get_one_authentic_pixel_from_handler !=\n       (GetOneAuthenticPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_authentic_pixel_from_handler(image,x,y,\n      pixel,exception));\n  pixels=GetAuthenticPixelsCache(image,x,y,1UL,1UL,exception);\n  if (pixels == (PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e A u t h e n t i c P i x e l F r o m C a c h e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneAuthenticPixelFromCache() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.\n%\n%  The format of the GetOneAuthenticPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneAuthenticPixelFromCache(const Image image,\n%        const ssize_t x,const ssize_t y,PixelPacket *pixel,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneAuthenticPixelFromCache(Image *image,\n  const ssize_t x,const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetAuthenticPixelCacheNexus(image,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (pixels == (PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l M a g i c k P i x e l                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualMagickPixel() returns a single pixel at the specified (x,y)\n%  location.  The image background color is returned if an error occurs.  If\n%  you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualMagickPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualMagickPixel(const Image image,\n%        const ssize_t x,const ssize_t y,MagickPixelPacket *pixel,\n%        ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  these values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualMagickPixel(const Image *image,\n  const ssize_t x,const ssize_t y,MagickPixelPacket *pixel,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  register const IndexPacket\n    *magick_restrict indexes;\n\n  register const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  GetMagickPixelPacket(image,pixel);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  indexes=GetVirtualIndexesFromNexus(cache_info,cache_info->nexus_info[id]);\n  SetMagickPixelPacket(image,pixels,indexes,pixel);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l M e t h o d P i x e l                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualMethodPixel() returns a single pixel at the specified (x,y)\n%  location as defined by specified pixel method.  The image background color\n%  is returned if an error occurs.  If you plan to modify the pixel, use\n%  GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualMethodPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualMethodPixel(const Image image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,Pixelpacket *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualMethodPixel(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      virtual_pixel_method,x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t O n e V i r t u a l P i x e l                                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixel() returns a single virtual pixel at the specified\n%  (x,y) location.  The image background color is returned if an error occurs.\n%  If you plan to modify the pixel, use GetOneAuthenticPixel() instead.\n%\n%  The format of the GetOneVirtualPixel() method is:\n%\n%      MagickBooleanType GetOneVirtualPixel(const Image image,const ssize_t x,\n%        const ssize_t y,PixelPacket *pixel,ExceptionInfo exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType GetOneVirtualPixel(const Image *image,\n  const ssize_t x,const ssize_t y,PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  *pixel=image->background_color;\n  if (cache_info->methods.get_one_virtual_pixel_from_handler !=\n       (GetOneVirtualPixelFromHandler) NULL)\n    return(cache_info->methods.get_one_virtual_pixel_from_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,pixel,exception));\n  assert(id < (int) cache_info->number_threads);\n  pixels=GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    1UL,1UL,cache_info->nexus_info[id],exception);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t O n e V i r t u a l P i x e l F r o m C a c h e                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetOneVirtualPixelFromCache() returns a single virtual pixel at the\n%  specified (x,y) location.  The image background color is returned if an\n%  error occurs.\n%\n%  The format of the GetOneVirtualPixelFromCache() method is:\n%\n%      MagickBooleanType GetOneVirtualPixelFromCache(const Image image,\n%        const VirtualPixelPacket method,const ssize_t x,const ssize_t y,\n%        PixelPacket *pixel,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y:  These values define the location of the pixel to return.\n%\n%    o pixel: return a pixel at the specified (x,y) location.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType GetOneVirtualPixelFromCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  PixelPacket *pixel,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  const PixelPacket\n    *magick_restrict pixels;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  *pixel=image->background_color;\n  pixels=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,1UL,1UL,\n    cache_info->nexus_info[id],exception);\n  if (pixels == (const PixelPacket *) NULL)\n    return(MagickFalse);\n  *pixel=(*pixels);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e C h a n n e l s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheChannels() returns the number of pixel channels associated\n%  with this instance of the pixel cache.\n%\n%  The format of the GetPixelCacheChannels() method is:\n%\n%      size_t GetPixelCacheChannels(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o type: GetPixelCacheChannels returns DirectClass or PseudoClass.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport size_t GetPixelCacheChannels(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->channels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e C o l o r s p a c e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheColorspace() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheColorspace() method is:\n%\n%      Colorspace GetPixelCacheColorspace(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport ColorspaceType GetPixelCacheColorspace(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->colorspace);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheMethods() initializes the CacheMethods structure.\n%\n%  The format of the GetPixelCacheMethods() method is:\n%\n%      void GetPixelCacheMethods(CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickExport void GetPixelCacheMethods(CacheMethods *cache_methods)\n{\n  assert(cache_methods != (CacheMethods *) NULL);\n  (void) ResetMagickMemory(cache_methods,0,sizeof(*cache_methods));\n  cache_methods->get_virtual_pixel_handler=GetVirtualPixelCache;\n  cache_methods->get_virtual_pixels_handler=GetVirtualPixelsCache;\n  cache_methods->get_virtual_indexes_from_handler=GetVirtualIndexesFromCache;\n  cache_methods->get_one_virtual_pixel_from_handler=GetOneVirtualPixelFromCache;\n  cache_methods->get_authentic_pixels_handler=GetAuthenticPixelsCache;\n  cache_methods->get_authentic_indexes_from_handler=\n    GetAuthenticIndexesFromCache;\n  cache_methods->get_authentic_pixels_from_handler=GetAuthenticPixelsFromCache;\n  cache_methods->get_one_authentic_pixel_from_handler=\n    GetOneAuthenticPixelFromCache;\n  cache_methods->queue_authentic_pixels_handler=QueueAuthenticPixelsCache;\n  cache_methods->sync_authentic_pixels_handler=SyncAuthenticPixelsCache;\n  cache_methods->destroy_pixel_handler=DestroyImagePixelCache;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e N e x u s E x t e n t                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheNexusExtent() returns the extent of the pixels associated with\n%  the last call to SetPixelCacheNexusPixels() or GetPixelCacheNexusPixels().\n%\n%  The format of the GetPixelCacheNexusExtent() method is:\n%\n%      MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o nexus_info: the nexus info.\n%\n*/\nMagickExport MagickSizeType GetPixelCacheNexusExtent(const Cache cache,\n  NexusInfo *nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickSizeType\n    extent;\n\n  assert(cache != NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  extent=(MagickSizeType) nexus_info->region.width*nexus_info->region.height;\n  if (extent == 0)\n    return((MagickSizeType) cache_info->columns*cache_info->rows);\n  return(extent);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCachePixels() returns the pixels associated with the specified image.\n%\n%  The format of the GetPixelCachePixels() method is:\n%\n%      void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o length: the pixel cache length.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport void *GetPixelCachePixels(Image *image,MagickSizeType *length,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  assert(length != (MagickSizeType *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickSignature);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  (void) exception;\n  *length=0;\n  if ((cache_info->type != MemoryCache) && (cache_info->type != MapCache))\n    return((void *) NULL);\n  *length=cache_info->length;\n  return((void *) cache_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e S t o r a g e C l a s s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheStorageClass() returns the class type of the pixel cache.\n%\n%  The format of the GetPixelCacheStorageClass() method is:\n%\n%      ClassType GetPixelCacheStorageClass(Cache cache)\n%\n%  A description of each parameter follows:\n%\n%    o type: GetPixelCacheStorageClass returns DirectClass or PseudoClass.\n%\n%    o cache: the pixel cache.\n%\n*/\nMagickExport ClassType GetPixelCacheStorageClass(const Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  return(cache_info->storage_class);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e T i l e S i z e                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheTileSize() returns the pixel cache tile size.\n%\n%  The format of the GetPixelCacheTileSize() method is:\n%\n%      void GetPixelCacheTileSize(const Image *image,size_t *width,\n%        size_t *height)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width: the optimize cache tile width in pixels.\n%\n%    o height: the optimize cache tile height in pixels.\n%\n*/\nMagickExport void GetPixelCacheTileSize(const Image *image,size_t *width,\n  size_t *height)\n{\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  *width=2048UL/sizeof(PixelPacket);\n  if (GetImagePixelCacheType(image) == DiskCache)\n    *width=8192UL/sizeof(PixelPacket);\n  *height=(*width);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetPixelCacheVirtualMethod() gets the \"virtual pixels\" method for the\n%  pixel cache.  A virtual pixel is any pixel access that is outside the\n%  boundaries of the image cache.\n%\n%  The format of the GetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport VirtualPixelMethod GetPixelCacheVirtualMethod(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  return(cache_info->virtual_pixel_method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l I n d e x e s F r o m C a c h e                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualIndexesFromCache() returns the indexes associated with the last\n%  call to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualIndexesFromCache() method is:\n%\n%      IndexPacket *GetVirtualIndexesFromCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const IndexPacket *GetVirtualIndexesFromCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualIndexesFromNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l I n d e x e s F r o m N e x u s                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualIndexesFromNexus() returns the indexes associated with the\n%  specified cache nexus.\n%\n%  The format of the GetVirtualIndexesFromNexus() method is:\n%\n%      const IndexPacket *GetVirtualIndexesFromNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the colormap indexes.\n%\n*/\nMagickExport const IndexPacket *GetVirtualIndexesFromNexus(const Cache cache,\n  NexusInfo *nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((IndexPacket *) NULL);\n  return(nexus_info->indexes);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l I n d e x Q u e u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualIndexQueue() returns the virtual black channel or the\n%  colormap indexes associated with the last call to QueueAuthenticPixels() or\n%  GetVirtualPixels().  NULL is returned if the black channel or colormap\n%  indexes are not available.\n%\n%  The format of the GetVirtualIndexQueue() method is:\n%\n%      const IndexPacket *GetVirtualIndexQueue(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const IndexPacket *GetVirtualIndexQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_indexes_from_handler !=\n       (GetVirtualIndexesFromHandler) NULL)\n    return(cache_info->methods.get_virtual_indexes_from_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualIndexesFromNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m N e x u s                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsFromNexus() gets virtual pixels from the in-memory or disk\n%  pixel cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelsFromNexus() method is:\n%\n%      PixelPacket *GetVirtualPixelsFromNexus(const Image *image,\n%        const VirtualPixelMethod method,const ssize_t x,const ssize_t y,\n%        const size_t columns,const size_t rows,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to acquire.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic ssize_t\n  DitherMatrix[64] =\n  {\n     0,  48,  12,  60,   3,  51,  15,  63,\n    32,  16,  44,  28,  35,  19,  47,  31,\n     8,  56,   4,  52,  11,  59,   7,  55,\n    40,  24,  36,  20,  43,  27,  39,  23,\n     2,  50,  14,  62,   1,  49,  13,  61,\n    34,  18,  46,  30,  33,  17,  45,  29,\n    10,  58,   6,  54,   9,  57,   5,  53,\n    42,  26,  38,  22,  41,  25,  37,  21\n  };\n\nstatic inline ssize_t DitherX(const ssize_t x,const size_t columns)\n{\n  ssize_t\n    index;\n\n  index=x+DitherMatrix[x & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) columns)\n    return((ssize_t) columns-1L);\n  return(index);\n}\n\nstatic inline ssize_t DitherY(const ssize_t y,const size_t rows)\n{\n  ssize_t\n    index;\n\n  index=y+DitherMatrix[y & 0x07]-32L;\n  if (index < 0L)\n    return(0L);\n  if (index >= (ssize_t) rows)\n    return((ssize_t) rows-1L);\n  return(index);\n}\n\nstatic inline ssize_t EdgeX(const ssize_t x,const size_t columns)\n{\n  if (x < 0L)\n    return(0L);\n  if (x >= (ssize_t) columns)\n    return((ssize_t) (columns-1));\n  return(x);\n}\n\nstatic inline ssize_t EdgeY(const ssize_t y,const size_t rows)\n{\n  if (y < 0L)\n    return(0L);\n  if (y >= (ssize_t) rows)\n    return((ssize_t) (rows-1));\n  return(y);\n}\n\nstatic inline ssize_t RandomX(RandomInfo *random_info,const size_t columns)\n{\n  return((ssize_t) (columns*GetPseudoRandomValue(random_info)));\n}\n\nstatic inline ssize_t RandomY(RandomInfo *random_info,const size_t rows)\n{\n  return((ssize_t) (rows*GetPseudoRandomValue(random_info)));\n}\n\n/*\n  VirtualPixelModulo() computes the remainder of dividing offset by extent.  It\n  returns not only the quotient (tile the offset falls in) but also the positive\n  remainer within that tile such that 0 <= remainder < extent.  This method is\n  essentially a ldiv() using a floored modulo division rather than the normal\n  default truncated modulo division.\n*/\nstatic inline MagickModulo VirtualPixelModulo(const ssize_t offset,\n  const size_t extent)\n{\n  MagickModulo\n    modulo;\n\n  modulo.quotient=offset/(ssize_t) extent;\n  if (offset < 0L)\n    modulo.quotient--;\n  modulo.remainder=offset-modulo.quotient*(ssize_t) extent;\n  return(modulo);\n}\n\nMagickExport const PixelPacket *GetVirtualPixelsFromNexus(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  IndexPacket\n    virtual_index;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict virtual_nexus;\n\n  PixelPacket\n    *magick_restrict pixels,\n    virtual_pixel;\n\n  RectangleInfo\n    region;\n\n  register const IndexPacket\n    *magick_restrict virtual_indexes;\n\n  register const PixelPacket\n    *magick_restrict p;\n\n  register IndexPacket\n    *magick_restrict indexes;\n\n  register PixelPacket\n    *magick_restrict q;\n\n  register ssize_t\n    u,\n    v;\n\n  /*\n    Acquire pixels.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->type == UndefinedCache)\n    return((const PixelPacket *) NULL);\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,ReadMode,&region,\n    (image->clip_mask != (Image *) NULL) || (image->mask != (Image *) NULL) ?\n    MagickTrue : MagickFalse,nexus_info,exception);\n  if (pixels == (PixelPacket *) NULL)\n    return((const PixelPacket *) NULL);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) (nexus_info->region.height-1L)*cache_info->columns+\n    nexus_info->region.width-1L;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  if ((offset >= 0) && (((MagickSizeType) offset+length) < number_pixels))\n    if ((x >= 0) && ((ssize_t) (x+columns) <= (ssize_t) cache_info->columns) &&\n        (y >= 0) && ((ssize_t) (y+rows) <= (ssize_t) cache_info->rows))\n      {\n        MagickBooleanType\n          status;\n\n        /*\n          Pixel request is inside cache extents.\n        */\n        if (nexus_info->authentic_pixel_cache != MagickFalse)\n          return(pixels);\n        status=ReadPixelCachePixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          return((const PixelPacket *) NULL);\n        if ((cache_info->storage_class == PseudoClass) ||\n            (cache_info->colorspace == CMYKColorspace))\n          {\n            status=ReadPixelCacheIndexes(cache_info,nexus_info,exception);\n            if (status == MagickFalse)\n              return((const PixelPacket *) NULL);\n          }\n        return(pixels);\n      }\n  /*\n    Pixel request is outside cache extents.\n  */\n  q=pixels;\n  indexes=nexus_info->indexes;\n  virtual_nexus=AcquirePixelCacheNexus(1);\n  if (virtual_nexus == (NexusInfo **) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"UnableToGetCacheNexus\",\"`%s'\",image->filename);\n      return((const PixelPacket *) NULL);\n    }\n  switch (virtual_pixel_method)\n  {\n    case BlackVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,0);\n      SetPixelGreen(&virtual_pixel,0);\n      SetPixelBlue(&virtual_pixel,0);\n      SetPixelOpacity(&virtual_pixel,OpaqueOpacity);\n      break;\n    }\n    case GrayVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,QuantumRange/2);\n      SetPixelGreen(&virtual_pixel,QuantumRange/2);\n      SetPixelBlue(&virtual_pixel,QuantumRange/2);\n      SetPixelOpacity(&virtual_pixel,OpaqueOpacity);\n      break;\n    }\n    case TransparentVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,0);\n      SetPixelGreen(&virtual_pixel,0);\n      SetPixelBlue(&virtual_pixel,0);\n      SetPixelOpacity(&virtual_pixel,TransparentOpacity);\n      break;\n    }\n    case MaskVirtualPixelMethod:\n    case WhiteVirtualPixelMethod:\n    {\n      SetPixelRed(&virtual_pixel,QuantumRange);\n      SetPixelGreen(&virtual_pixel,QuantumRange);\n      SetPixelBlue(&virtual_pixel,QuantumRange);\n      SetPixelOpacity(&virtual_pixel,OpaqueOpacity);\n      break;\n    }\n    default:\n    {\n      virtual_pixel=image->background_color;\n      break;\n    }\n  }\n  virtual_index=0;\n  for (v=0; v < (ssize_t) rows; v++)\n  {\n    ssize_t\n      y_offset;\n\n    y_offset=y+v;\n    if ((virtual_pixel_method == EdgeVirtualPixelMethod) ||\n        (virtual_pixel_method == UndefinedVirtualPixelMethod))\n      y_offset=EdgeY(y_offset,cache_info->rows);\n    for (u=0; u < (ssize_t) columns; u+=length)\n    {\n      ssize_t\n        x_offset;\n\n      x_offset=x+u;\n      length=(MagickSizeType) MagickMin(cache_info->columns-x_offset,columns-u);\n      if (((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns)) ||\n          ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows)) ||\n          (length == 0))\n        {\n          MagickModulo\n            x_modulo,\n            y_modulo;\n\n          /*\n            Transfer a single pixel.\n          */\n          length=(MagickSizeType) 1;\n          switch (virtual_pixel_method)\n          {\n            case BackgroundVirtualPixelMethod:\n            case ConstantVirtualPixelMethod:\n            case BlackVirtualPixelMethod:\n            case GrayVirtualPixelMethod:\n            case TransparentVirtualPixelMethod:\n            case MaskVirtualPixelMethod:\n            case WhiteVirtualPixelMethod:\n            {\n              p=(&virtual_pixel);\n              virtual_indexes=(&virtual_index);\n              break;\n            }\n            case EdgeVirtualPixelMethod:\n            default:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),\n                EdgeY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case RandomVirtualPixelMethod:\n            {\n              if (cache_info->random_info == (RandomInfo *) NULL)\n                cache_info->random_info=AcquireRandomInfo();\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                RandomX(cache_info->random_info,cache_info->columns),\n                RandomY(cache_info->random_info,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case DitherVirtualPixelMethod:\n            {\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                DitherX(x_offset,cache_info->columns),\n                DitherY(y_offset,cache_info->rows),1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case TileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case MirrorVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              if ((x_modulo.quotient & 0x01) == 1L)\n                x_modulo.remainder=(ssize_t) cache_info->columns-\n                  x_modulo.remainder-1L;\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if ((y_modulo.quotient & 0x01) == 1L)\n                y_modulo.remainder=(ssize_t) cache_info->rows-\n                  y_modulo.remainder-1L;\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case CheckerTileVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              if (((x_modulo.quotient ^ y_modulo.quotient) & 0x01) != 0L)\n                {\n                  p=(&virtual_pixel);\n                  virtual_indexes=(&virtual_index);\n                  break;\n                }\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case HorizontalTileVirtualPixelMethod:\n            {\n              if ((y_offset < 0) || (y_offset >= (ssize_t) cache_info->rows))\n                {\n                  p=(&virtual_pixel);\n                  virtual_indexes=(&virtual_index);\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case VerticalTileVirtualPixelMethod:\n            {\n              if ((x_offset < 0) || (x_offset >= (ssize_t) cache_info->columns))\n                {\n                  p=(&virtual_pixel);\n                  virtual_indexes=(&virtual_index);\n                  break;\n                }\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,y_modulo.remainder,1UL,1UL,*virtual_nexus,\n                exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case HorizontalTileEdgeVirtualPixelMethod:\n            {\n              x_modulo=VirtualPixelModulo(x_offset,cache_info->columns);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                x_modulo.remainder,EdgeY(y_offset,cache_info->rows),1UL,1UL,\n                *virtual_nexus,exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n            case VerticalTileEdgeVirtualPixelMethod:\n            {\n              y_modulo=VirtualPixelModulo(y_offset,cache_info->rows);\n              p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,\n                EdgeX(x_offset,cache_info->columns),y_modulo.remainder,1UL,1UL,\n                *virtual_nexus,exception);\n              virtual_indexes=GetVirtualIndexesFromNexus(cache_info,\n                *virtual_nexus);\n              break;\n            }\n          }\n          if (p == (const PixelPacket *) NULL)\n            break;\n          *q++=(*p);\n          if ((indexes != (IndexPacket *) NULL) &&\n              (virtual_indexes != (const IndexPacket *) NULL))\n            *indexes++=(*virtual_indexes);\n          continue;\n        }\n      /*\n        Transfer a run of pixels.\n      */\n      p=GetVirtualPixelsFromNexus(image,virtual_pixel_method,x_offset,y_offset,\n        (size_t) length,1UL,*virtual_nexus,exception);\n      if (p == (const PixelPacket *) NULL)\n        break;\n      virtual_indexes=GetVirtualIndexesFromNexus(cache_info,*virtual_nexus);\n      (void) memcpy(q,p,(size_t) length*sizeof(*p));\n      q+=length;\n      if ((indexes != (IndexPacket *) NULL) &&\n          (virtual_indexes != (const IndexPacket *) NULL))\n        {\n          (void) memcpy(indexes,virtual_indexes,(size_t) length*\n            sizeof(*virtual_indexes));\n          indexes+=length;\n        }\n    }\n  }\n  virtual_nexus=DestroyPixelCacheNexus(virtual_nexus,1);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l C a c h e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelCache() get virtual pixels from the in-memory or disk pixel\n%  cache as defined by the geometry parameters.   A pointer to the pixels\n%  is returned if the pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the GetVirtualPixelCache() method is:\n%\n%      const PixelPacket *GetVirtualPixelCache(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: the virtual pixel method.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic const PixelPacket *GetVirtualPixelCache(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method,const ssize_t x,const ssize_t y,\n  const size_t columns,const size_t rows,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsFromNexus(image,virtual_pixel_method,x,y,columns,rows,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l Q u e u e                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelQueue() returns the virtual pixels associated with the\n%  last call to QueueAuthenticPixels() or GetVirtualPixels().\n%\n%  The format of the GetVirtualPixelQueue() method is:\n%\n%      const PixelPacket *GetVirtualPixelQueue(const Image image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nMagickExport const PixelPacket *GetVirtualPixelQueue(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixels_handler !=\n       (GetVirtualPixelsHandler) NULL)\n    return(cache_info->methods.get_virtual_pixels_handler(image));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(cache_info,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t V i r t u a l P i x e l s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixels() returns an immutable pixel region. If the\n%  region is successfully accessed, a pointer to it is returned, otherwise\n%  NULL is returned.  The returned pointer may point to a temporary working\n%  copy of the pixels or it may point to the original pixels in memory.\n%  Performance is maximized if the selected region is part of one row, or one\n%  or more full rows, since there is opportunity to access the pixels in-place\n%  (without a copy) if the image is in memory, or in a memory-mapped file.  The\n%  returned pointer must *never* be deallocated by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  PixelPacket.  If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticIndexQueue() after invoking GetAuthenticPixels() to access\n%  the black color component or to obtain the colormap indexes (of type\n%  IndexPacket) corresponding to the region.\n%\n%  If you plan to modify the pixels, use GetAuthenticPixels() instead.\n%\n%  Note, the GetVirtualPixels() and GetAuthenticPixels() methods are not thread-\n%  safe.  In a threaded environment, use GetCacheViewVirtualPixels() or\n%  GetCacheViewAuthenticPixels() instead.\n%\n%  The format of the GetVirtualPixels() method is:\n%\n%      const PixelPacket *GetVirtualPixels(const Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport const PixelPacket *GetVirtualPixels(const Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.get_virtual_pixel_handler !=\n       (GetVirtualPixelHandler) NULL)\n    return(cache_info->methods.get_virtual_pixel_handler(image,\n      GetPixelCacheVirtualMethod(image),x,y,columns,rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsFromNexus(image,GetPixelCacheVirtualMethod(image),x,y,\n    columns,rows,cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s F r o m C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsCache() returns the pixels associated with the last call\n%  to QueueAuthenticPixelsCache() or GetVirtualPixelCache().\n%\n%  The format of the GetVirtualPixelsCache() method is:\n%\n%      PixelPacket *GetVirtualPixelsCache(const Image *image)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n*/\nstatic const PixelPacket *GetVirtualPixelsCache(const Image *image)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(GetVirtualPixelsNexus(image->cache,cache_info->nexus_info[id]));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   G e t V i r t u a l P i x e l s N e x u s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetVirtualPixelsNexus() returns the pixels associated with the specified\n%  cache nexus.\n%\n%  The format of the GetVirtualPixelsNexus() method is:\n%\n%      const IndexPacket *GetVirtualPixelsNexus(const Cache cache,\n%        NexusInfo *nexus_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o nexus_info: the cache nexus to return the colormap pixels.\n%\n*/\nMagickExport const PixelPacket *GetVirtualPixelsNexus(const Cache cache,\n  NexusInfo *nexus_info)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->storage_class == UndefinedClass)\n    return((PixelPacket *) NULL);\n  return((const PixelPacket *) nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   M a s k P i x e l C a c h e N e x u s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MaskPixelCacheNexus() masks the cache nexus as defined by the image mask.\n%  The method returns MagickTrue if the pixel region is masked, otherwise\n%  MagickFalse.\n%\n%  The format of the MaskPixelCacheNexus() method is:\n%\n%      MagickBooleanType MaskPixelCacheNexus(Image *image,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to clip.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline void MagickPixelCompositeMask(const MagickPixelPacket *p,\n  const MagickRealType alpha,const MagickPixelPacket *q,\n  const MagickRealType beta,MagickPixelPacket *composite)\n{\n  double\n    gamma;\n\n  if (alpha == TransparentOpacity)\n    {\n      *composite=(*q);\n      return;\n    }\n  gamma=1.0-QuantumScale*QuantumScale*alpha*beta;\n  gamma=PerceptibleReciprocal(gamma);\n  composite->red=gamma*MagickOver_(p->red,alpha,q->red,beta);\n  composite->green=gamma*MagickOver_(p->green,alpha,q->green,beta);\n  composite->blue=gamma*MagickOver_(p->blue,alpha,q->blue,beta);\n  if ((p->colorspace == CMYKColorspace) && (q->colorspace == CMYKColorspace))\n    composite->index=gamma*MagickOver_(p->index,alpha,q->index,beta);\n}\n\nstatic MagickBooleanType MaskPixelCacheNexus(Image *image,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickPixelPacket\n    alpha,\n    beta;\n\n  MagickSizeType\n    number_pixels;\n\n  NexusInfo\n    **magick_restrict clip_nexus,\n    **magick_restrict image_nexus;\n\n  register const PixelPacket\n    *magick_restrict r;\n\n  register IndexPacket\n    *magick_restrict nexus_indexes,\n    *magick_restrict indexes;\n\n  register PixelPacket\n    *magick_restrict p,\n    *magick_restrict q;\n\n  register ssize_t\n    i;\n\n  /*\n    Apply clip mask.\n  */\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->mask == (Image *) NULL) || (image->storage_class == PseudoClass))\n    return(MagickTrue);\n  cache_info=(CacheInfo *) image->cache;\n  if (cache_info == (Cache) NULL)\n    return(MagickFalse);\n  image_nexus=AcquirePixelCacheNexus(1);\n  clip_nexus=AcquirePixelCacheNexus(1);\n  if ((image_nexus == (NexusInfo **) NULL) ||\n      (clip_nexus == (NexusInfo **) NULL))\n    ThrowBinaryException(CacheError,\"UnableToGetCacheNexus\",image->filename);\n  p=GetAuthenticPixelCacheNexus(image,nexus_info->region.x,\n    nexus_info->region.y,nexus_info->region.width,nexus_info->region.height,\n    image_nexus[0],exception);\n  indexes=image_nexus[0]->indexes;\n  q=nexus_info->pixels;\n  nexus_indexes=nexus_info->indexes;\n  r=GetVirtualPixelsFromNexus(image->mask,MaskVirtualPixelMethod,\n    nexus_info->region.x,nexus_info->region.y,nexus_info->region.width,\n    nexus_info->region.height,clip_nexus[0],&image->exception);\n  GetMagickPixelPacket(image,&alpha);\n  GetMagickPixelPacket(image,&beta);\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  for (i=0; i < (ssize_t) number_pixels; i++)\n  {\n    if ((p == (PixelPacket *) NULL) || (r == (const PixelPacket *) NULL))\n      break;\n    SetMagickPixelPacket(image,p,indexes+i,&alpha);\n    SetMagickPixelPacket(image,q,nexus_indexes+i,&beta);\n    MagickPixelCompositeMask(&beta,GetPixelIntensity(image,r),&alpha,\n      alpha.opacity,&beta);\n    SetPixelRed(q,ClampToQuantum(beta.red));\n    SetPixelGreen(q,ClampToQuantum(beta.green));\n    SetPixelBlue(q,ClampToQuantum(beta.blue));\n    SetPixelOpacity(q,ClampToQuantum(beta.opacity));\n    if (cache_info->active_index_channel != MagickFalse)\n      SetPixelIndex(nexus_indexes+i,GetPixelIndex(indexes+i));\n    p++;\n    q++;\n    r++;\n  }\n  clip_nexus=DestroyPixelCacheNexus(clip_nexus,1);\n  image_nexus=DestroyPixelCacheNexus(image_nexus,1);\n  if (i < (ssize_t) number_pixels)\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   O p e n P i x e l C a c h e                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  OpenPixelCache() allocates the pixel cache.  This includes defining the cache\n%  dimensions, allocating space for the image pixels and optionally the\n%  colormap indexes, and memory mapping the cache if it is disk based.  The\n%  cache nexus array is initialized as well.\n%\n%  The format of the OpenPixelCache() method is:\n%\n%      MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(__cplusplus) || defined(c_plusplus)\nextern \"C\" {\n#endif\n\n#if defined(SIGBUS)\nstatic void CacheSignalHandler(int status)\n{\n  ThrowFatalException(CacheFatalError,\"UnableToExtendPixelCache\");\n}\n#endif\n\n#if defined(__cplusplus) || defined(c_plusplus)\n}\n#endif\n\nstatic MagickBooleanType OpenPixelCacheOnDisk(CacheInfo *cache_info,\n  const MapMode mode)\n{\n  int\n    file;\n\n  /*\n    Open pixel cache on disk.\n  */\n  if ((cache_info->file != -1) && (cache_info->mode == mode))\n    return(MagickTrue);  /* cache already open and in the proper mode */\n  if (*cache_info->cache_filename == '\\0')\n    file=AcquireUniqueFileResource(cache_info->cache_filename);\n  else\n    switch (mode)\n    {\n      case ReadMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDONLY | O_BINARY,0);\n        break;\n      }\n      case WriteMode:\n      {\n        file=open_utf8(cache_info->cache_filename,O_WRONLY | O_CREAT |\n          O_BINARY | O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_WRONLY | O_BINARY,S_MODE);\n        break;\n      }\n      case IOMode:\n      default:\n      {\n        file=open_utf8(cache_info->cache_filename,O_RDWR | O_CREAT | O_BINARY |\n          O_EXCL,S_MODE);\n        if (file == -1)\n          file=open_utf8(cache_info->cache_filename,O_RDWR | O_BINARY,S_MODE);\n        break;\n      }\n    }\n  if (file == -1)\n    return(MagickFalse);\n  (void) AcquireMagickResource(FileResource,1);\n  if (cache_info->file != -1)\n    (void) ClosePixelCacheOnDisk(cache_info);\n  cache_info->file=file;\n  cache_info->mode=mode;\n  return(MagickTrue);\n}\n\nstatic inline MagickOffsetType WritePixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,const unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PWRITE)\n    count=write(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pwrite(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType SetPixelCacheExtent(Image *image,MagickSizeType length)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    count,\n    extent,\n    offset;\n\n  cache_info=(CacheInfo *) image->cache;\n  if (image->debug != MagickFalse)\n    {\n      char\n        format[MaxTextExtent],\n        message[MaxTextExtent];\n\n      (void) FormatMagickSize(length,MagickFalse,format);\n      (void) FormatLocaleString(message,MaxTextExtent,\n        \"extend %s (%s[%d], disk, %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_END);\n  if (offset < 0)\n    return(MagickFalse);\n  if ((MagickSizeType) offset >= length)\n    count=(MagickOffsetType) 1;\n  else\n    {\n      extent=(MagickOffsetType) length-1;\n      count=WritePixelCacheRegion(cache_info,extent,1,(const unsigned char *)\n        \"\");\n#if defined(MAGICKCORE_HAVE_POSIX_FALLOCATE)\n      if (cache_info->synchronize != MagickFalse)\n        (void) posix_fallocate(cache_info->file,offset+1,extent-offset);\n#endif\n#if defined(SIGBUS)\n      (void) signal(SIGBUS,CacheSignalHandler);\n#endif\n    }\n  offset=(MagickOffsetType) lseek(cache_info->file,0,SEEK_SET);\n  if (offset < 0)\n    return(MagickFalse);\n  return(count != (MagickOffsetType) 1 ? MagickFalse : MagickTrue);\n}\n\nstatic MagickBooleanType OpenPixelCache(Image *image,const MapMode mode,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    source_info;\n\n  char\n    format[MaxTextExtent],\n    message[MaxTextExtent];\n\n  const char\n    *type;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  MagickStatusType\n    status;\n\n  size_t\n    columns,\n    packet_size;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns == 0) || (image->rows == 0))\n    ThrowBinaryException(CacheError,\"NoPixelsDefinedInCache\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if ((AcquireMagickResource(WidthResource,image->columns) == MagickFalse) ||\n      (AcquireMagickResource(HeightResource,image->rows) == MagickFalse))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  source_info=(*cache_info);\n  source_info.file=(-1);\n  (void) FormatLocaleString(cache_info->filename,MaxTextExtent,\"%s[%.20g]\",\n    image->filename,(double) GetImageIndexInList(image));\n  cache_info->mode=mode;\n  cache_info->rows=image->rows;\n  cache_info->columns=image->columns;\n  cache_info->channels=image->channels;\n  cache_info->active_index_channel=((image->storage_class == PseudoClass) ||\n    (image->colorspace == CMYKColorspace)) ? MagickTrue : MagickFalse;\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  packet_size=sizeof(PixelPacket);\n  if (cache_info->active_index_channel != MagickFalse)\n    packet_size+=sizeof(IndexPacket);\n  length=number_pixels*packet_size;\n  columns=(size_t) (length/cache_info->rows/packet_size);\n  if ((cache_info->columns != columns) || ((ssize_t) cache_info->columns < 0) ||\n      ((ssize_t) cache_info->rows < 0))\n    ThrowBinaryException(ResourceLimitError,\"PixelCacheAllocationFailed\",\n      image->filename);\n  cache_info->length=length;\n  if (image->ping != MagickFalse)\n    {\n      cache_info->storage_class=image->storage_class;\n      cache_info->colorspace=image->colorspace;\n      cache_info->type=PingCache;\n      return(MagickTrue);\n    }\n  status=AcquireMagickResource(AreaResource,cache_info->length);\n  length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));\n  if ((status != MagickFalse) && (length == (MagickSizeType) ((size_t) length)))\n    {\n      status=AcquireMagickResource(MemoryResource,cache_info->length);\n      if (((cache_info->type == UndefinedCache) && (status != MagickFalse)) ||\n          (cache_info->type == MemoryCache))\n        {\n          cache_info->mapped=MagickFalse;\n          cache_info->pixels=(PixelPacket *) MagickAssumeAligned(\n            AcquireAlignedMemory(1,(size_t) cache_info->length));\n          if (cache_info->pixels == (PixelPacket *) NULL)\n            cache_info->pixels=source_info.pixels;\n          else\n            {\n              /*\n                Create memory pixel cache.\n              */\n              cache_info->colorspace=image->colorspace;\n              cache_info->type=MemoryCache;\n              cache_info->indexes=(IndexPacket *) NULL;\n              if (cache_info->active_index_channel != MagickFalse)\n                cache_info->indexes=(IndexPacket *) (cache_info->pixels+\n                  number_pixels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status&=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MaxTextExtent,\n                    \"open %s (%s %s, %.20gx%.20g %s)\",cache_info->filename,\n                    cache_info->mapped != MagickFalse ? \"Anonymous\" : \"Heap\",\n                    type,(double) cache_info->columns,(double) cache_info->rows,\n                    format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              cache_info->storage_class=image->storage_class;\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(MemoryResource,cache_info->length);\n    }\n  /*\n    Create pixel cache on disk.\n  */\n  status=AcquireMagickResource(DiskResource,cache_info->length);\n  if ((status == MagickFalse) || (cache_info->type == DistributedCache))\n    {\n      DistributeCacheInfo\n        *server_info;\n\n      if (cache_info->type == DistributedCache)\n        RelinquishMagickResource(DiskResource,cache_info->length);\n      server_info=AcquireDistributeCacheInfo(exception);\n      if (server_info != (DistributeCacheInfo *) NULL)\n        {\n          status=OpenDistributePixelCache(server_info,image);\n          if (status == MagickFalse)\n            {\n              ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n                GetDistributeCacheHostname(server_info));\n              server_info=DestroyDistributeCacheInfo(server_info);\n            }\n          else\n            {\n              /*\n                Create a distributed pixel cache.\n              */\n              cache_info->type=DistributedCache;\n              cache_info->storage_class=image->storage_class;\n              cache_info->colorspace=image->colorspace;\n              cache_info->server_info=server_info;\n              (void) FormatLocaleString(cache_info->cache_filename,\n                MaxTextExtent,\"%s:%d\",GetDistributeCacheHostname(\n                (DistributeCacheInfo *) cache_info->server_info),\n                GetDistributeCachePort((DistributeCacheInfo *)\n                cache_info->server_info));\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickFalse,\n                    format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MaxTextExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20g %s)\",cache_info->filename,\n                    cache_info->cache_filename,GetDistributeCacheFile(\n                    (DistributeCacheInfo *) cache_info->server_info),type,\n                    (double) cache_info->columns,(double) cache_info->rows,\n                    format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"CacheResourcesExhausted\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      (void) ClosePixelCacheOnDisk(cache_info);\n      *cache_info->cache_filename='\\0';\n    }\n  if (OpenPixelCacheOnDisk(cache_info,mode) == MagickFalse)\n    {\n      RelinquishMagickResource(DiskResource,cache_info->length);\n      ThrowFileException(exception,CacheError,\"UnableToOpenPixelCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  status=SetPixelCacheExtent(image,(MagickSizeType) cache_info->offset+\n    cache_info->length);\n  if (status == MagickFalse)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToExtendCache\",\n        image->filename);\n      return(MagickFalse);\n    }\n  cache_info->storage_class=image->storage_class;\n  cache_info->colorspace=image->colorspace;\n  length=number_pixels*(sizeof(PixelPacket)+sizeof(IndexPacket));\n  if (length != (MagickSizeType) ((size_t) length))\n    cache_info->type=DiskCache;\n  else\n    {\n      status=AcquireMagickResource(MapResource,cache_info->length);\n      if ((status == MagickFalse) && (cache_info->type != MapCache) &&\n          (cache_info->type != MemoryCache))\n        cache_info->type=DiskCache;\n      else\n        {\n          cache_info->pixels=(PixelPacket *) MapBlob(cache_info->file,mode,\n            cache_info->offset,(size_t) cache_info->length);\n          if (cache_info->pixels == (PixelPacket *) NULL)\n            {\n              cache_info->pixels=source_info.pixels;\n              cache_info->type=DiskCache;\n            }\n          else\n            {\n              /*\n                Create file-backed memory-mapped pixel cache.\n              */\n              (void) ClosePixelCacheOnDisk(cache_info);\n              cache_info->type=MapCache;\n              cache_info->mapped=MagickTrue;\n              cache_info->indexes=(IndexPacket *) NULL;\n              if (cache_info->active_index_channel != MagickFalse)\n                cache_info->indexes=(IndexPacket *) (cache_info->pixels+\n                  number_pixels);\n              if ((source_info.storage_class != UndefinedClass) &&\n                  (mode != ReadMode))\n                {\n                  status=ClonePixelCacheRepository(cache_info,&source_info,\n                    exception);\n                  RelinquishPixelCachePixels(&source_info);\n                }\n              if (image->debug != MagickFalse)\n                {\n                  (void) FormatMagickSize(cache_info->length,MagickTrue,format);\n                  type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n                    cache_info->type);\n                  (void) FormatLocaleString(message,MaxTextExtent,\n                    \"open %s (%s[%d], %s, %.20gx%.20g %s)\",\n                    cache_info->filename,cache_info->cache_filename,\n                    cache_info->file,type,(double) cache_info->columns,(double)\n                    cache_info->rows,format);\n                  (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",\n                    message);\n                }\n              return(MagickTrue);\n            }\n        }\n      RelinquishMagickResource(MapResource,cache_info->length);\n    }\n  if ((source_info.storage_class != UndefinedClass) && (mode != ReadMode))\n    {\n      status=ClonePixelCacheRepository(cache_info,&source_info,exception);\n      RelinquishPixelCachePixels(&source_info);\n    }\n  if (image->debug != MagickFalse)\n    {\n      (void) FormatMagickSize(cache_info->length,MagickFalse,format);\n      type=CommandOptionToMnemonic(MagickCacheOptions,(ssize_t)\n        cache_info->type);\n      (void) FormatLocaleString(message,MaxTextExtent,\n        \"open %s (%s[%d], %s, %.20gx%.20g %s)\",cache_info->filename,\n        cache_info->cache_filename,cache_info->file,type,(double)\n        cache_info->columns,(double) cache_info->rows,format);\n      (void) LogMagickEvent(CacheEvent,GetMagickModule(),\"%s\",message);\n    }\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   P e r s i s t P i x e l C a c h e                                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  PersistPixelCache() attaches to or initializes a persistent pixel cache.  A\n%  persistent pixel cache is one that resides on disk and is not destroyed\n%  when the program exits.\n%\n%  The format of the PersistPixelCache() method is:\n%\n%      MagickBooleanType PersistPixelCache(Image *image,const char *filename,\n%        const MagickBooleanType attach,MagickOffsetType *offset,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o filename: the persistent pixel cache filename.\n%\n%    o attach: A value other than zero initializes the persistent pixel cache.\n%\n%    o initialize: A value other than zero initializes the persistent pixel\n%      cache.\n%\n%    o offset: the offset in the persistent cache to store pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType PersistPixelCache(Image *image,\n  const char *filename,const MagickBooleanType attach,MagickOffsetType *offset,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info,\n    *magick_restrict clone_info;\n\n  Image\n    clone_image;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    page_size;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (void *) NULL);\n  assert(filename != (const char *) NULL);\n  assert(offset != (MagickOffsetType *) NULL);\n  page_size=GetMagickPageSize();\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (attach != MagickFalse)\n    {\n      /*\n        Attach existing persistent pixel cache.\n      */\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n          \"attach persistent cache\");\n      (void) CopyMagickString(cache_info->cache_filename,filename,\n        MaxTextExtent);\n      cache_info->type=DiskCache;\n      cache_info->offset=(*offset);\n      if (OpenPixelCache(image,ReadMode,exception) == MagickFalse)\n        return(MagickFalse);\n      *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n      return(MagickTrue);\n    }\n  if ((cache_info->mode != ReadMode) && (cache_info->type != MemoryCache) &&\n      (cache_info->reference_count == 1))\n    {\n      LockSemaphoreInfo(cache_info->semaphore);\n      if ((cache_info->mode != ReadMode) && (cache_info->type != MemoryCache) &&\n          (cache_info->reference_count == 1))\n        {\n          int\n            status;\n\n          /*\n            Usurp existing persistent pixel cache.\n          */\n          status=rename_utf8(cache_info->cache_filename,filename);\n          if (status == 0)\n            {\n              (void) CopyMagickString(cache_info->cache_filename,filename,\n                MaxTextExtent);\n              *offset+=cache_info->length+page_size-(cache_info->length %\n                page_size);\n              UnlockSemaphoreInfo(cache_info->semaphore);\n              cache_info=(CacheInfo *) ReferencePixelCache(cache_info);\n              if (image->debug != MagickFalse)\n                (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n                  \"Usurp resident persistent cache\");\n              return(MagickTrue);\n            }\n        }\n      UnlockSemaphoreInfo(cache_info->semaphore);\n    }\n  /*\n    Clone persistent pixel cache.\n  */\n  clone_image=(*image);\n  clone_info=(CacheInfo *) clone_image.cache;\n  image->cache=ClonePixelCache(cache_info);\n  cache_info=(CacheInfo *) ReferencePixelCache(image->cache);\n  (void) CopyMagickString(cache_info->cache_filename,filename,MaxTextExtent);\n  cache_info->type=DiskCache;\n  cache_info->offset=(*offset);\n  cache_info=(CacheInfo *) image->cache;\n  status=OpenPixelCache(image,IOMode,exception);\n  if (status != MagickFalse)\n    status=ClonePixelCacheRepository(cache_info,clone_info,&image->exception);\n  *offset+=cache_info->length+page_size-(cache_info->length % page_size);\n  clone_info=(CacheInfo *) DestroyPixelCache(clone_info);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l C a c h e N e x u s                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelCacheNexus() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelCacheNexus() method is:\n%\n%      PixelPacket *QueueAuthenticPixelCacheNexus(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        const MagickBooleanType clone,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o clone: clone the pixel cache.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport PixelPacket *QueueAuthenticPixel(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  const MagickBooleanType clone,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  return(QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,clone,nexus_info,\n    exception));\n}\n\nMagickExport PixelPacket *QueueAuthenticPixelCacheNexus(Image *image,\n  const ssize_t x,const ssize_t y,const size_t columns,const size_t rows,\n  const MagickBooleanType clone,NexusInfo *nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickOffsetType\n    offset;\n\n  MagickSizeType\n    number_pixels;\n\n  PixelPacket\n    *magick_restrict pixels;\n\n  RectangleInfo\n    region;\n\n  /*\n    Validate pixel cache geometry.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,clone,exception);\n  if (cache_info == (Cache) NULL)\n    return((PixelPacket *) NULL);\n  assert(cache_info->signature == MagickSignature);\n  if ((cache_info->columns == 0) || (cache_info->rows == 0) || (x < 0) ||\n      (y < 0) || (x >= (ssize_t) cache_info->columns) ||\n      (y >= (ssize_t) cache_info->rows))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),CacheError,\n        \"PixelsAreNotAuthentic\",\"`%s'\",image->filename);\n      return((PixelPacket *) NULL);\n    }\n  offset=(MagickOffsetType) y*cache_info->columns+x;\n  if (offset < 0)\n    return((PixelPacket *) NULL);\n  number_pixels=(MagickSizeType) cache_info->columns*cache_info->rows;\n  offset+=(MagickOffsetType) (rows-1)*cache_info->columns+columns-1;\n  if ((MagickSizeType) offset >= number_pixels)\n    return((PixelPacket *) NULL);\n  /*\n    Return pixel cache.\n  */\n  region.x=x;\n  region.y=y;\n  region.width=columns;\n  region.height=rows;\n  pixels=SetPixelCacheNexusPixels(cache_info,WriteMode,&region,\n    (image->clip_mask != (Image *) NULL) || (image->mask != (Image *) NULL) ?\n    MagickTrue : MagickFalse,nexus_info,exception);\n  return(pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   Q u e u e A u t h e n t i c P i x e l s C a c h e                         %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixelsCache() allocates an region to store image pixels as\n%  defined by the region rectangle and returns a pointer to the region.  This\n%  region is subsequently transferred from the pixel cache with\n%  SyncAuthenticPixelsCache().  A pointer to the pixels is returned if the\n%  pixels are transferred, otherwise a NULL is returned.\n%\n%  The format of the QueueAuthenticPixelsCache() method is:\n%\n%      PixelPacket *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic PixelPacket *QueueAuthenticPixelsCache(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  return(QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   Q u e u e A u t h e n t i c P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  QueueAuthenticPixels() queues a mutable pixel region.  If the region is\n%  successfully initialized a pointer to a PixelPacket array representing the\n%  region is returned, otherwise NULL is returned.  The returned pointer may\n%  point to a temporary working buffer for the pixels or it may point to the\n%  final location of the pixels in memory.\n%\n%  Write-only access means that any existing pixel values corresponding to\n%  the region are ignored.  This is useful if the initial image is being\n%  created from scratch, or if the existing pixel values are to be\n%  completely replaced without need to refer to their pre-existing values.\n%  The application is free to read and write the pixel buffer returned by\n%  QueueAuthenticPixels() any way it pleases. QueueAuthenticPixels() does not\n%  initialize the pixel array values. Initializing pixel array values is the\n%  application's responsibility.\n%\n%  Performance is maximized if the selected region is part of one row, or\n%  one or more full rows, since then there is opportunity to access the\n%  pixels in-place (without a copy) if the image is in memory, or in a\n%  memory-mapped file. The returned pointer must *never* be deallocated\n%  by the user.\n%\n%  Pixels accessed via the returned pointer represent a simple array of type\n%  PixelPacket. If the image type is CMYK or the storage class is PseudoClass,\n%  call GetAuthenticIndexQueue() after invoking GetAuthenticPixels() to obtain\n%  the black color component or the colormap indexes (of type IndexPacket)\n%  corresponding to the region.  Once the PixelPacket (and/or IndexPacket)\n%  array has been updated, the changes must be saved back to the underlying\n%  image using SyncAuthenticPixels() or they may be lost.\n%\n%  The format of the QueueAuthenticPixels() method is:\n%\n%      PixelPacket *QueueAuthenticPixels(Image *image,const ssize_t x,\n%        const ssize_t y,const size_t columns,const size_t rows,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o x,y,columns,rows:  These values define the perimeter of a region of\n%      pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport PixelPacket *QueueAuthenticPixels(Image *image,const ssize_t x,\n  const ssize_t y,const size_t columns,const size_t rows,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.queue_authentic_pixels_handler !=\n       (QueueAuthenticPixelsHandler) NULL)\n    return(cache_info->methods.queue_authentic_pixels_handler(image,x,y,columns,\n      rows,exception));\n  assert(id < (int) cache_info->number_threads);\n  return(QueueAuthenticPixelCacheNexus(image,x,y,columns,rows,MagickFalse,\n    cache_info->nexus_info[id],exception));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e I n d e x e s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCacheIndexes() reads colormap indexes from the specified region of\n%  the pixel cache.\n%\n%  The format of the ReadPixelCacheIndexes() method is:\n%\n%      MagickBooleanType ReadPixelCacheIndexes(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the colormap indexes.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickOffsetType ReadPixelCacheRegion(\n  const CacheInfo *magick_restrict cache_info,const MagickOffsetType offset,\n  const MagickSizeType length,unsigned char *magick_restrict buffer)\n{\n  register MagickOffsetType\n    i;\n\n  ssize_t\n    count;\n\n#if !defined(MAGICKCORE_HAVE_PREAD)\n  if (lseek(cache_info->file,offset,SEEK_SET) < 0)\n    return((MagickOffsetType) -1);\n#endif\n  count=0;\n  for (i=0; i < (MagickOffsetType) length; i+=count)\n  {\n#if !defined(MAGICKCORE_HAVE_PREAD)\n    count=read(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX));\n#else\n    count=pread(cache_info->file,buffer+i,(size_t) MagickMin(length-i,(size_t)\n      SSIZE_MAX),(off_t) (offset+i));\n#endif\n    if (count <= 0)\n      {\n        count=0;\n        if (errno != EINTR)\n          break;\n      }\n  }\n  return(i);\n}\n\nstatic MagickBooleanType ReadPixelCacheIndexes(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register IndexPacket\n    *magick_restrict q;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->active_index_channel == MagickFalse)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(IndexPacket);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  q=nexus_info->indexes;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register IndexPacket\n        *magick_restrict p;\n\n      /*\n        Read indexes from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->indexes+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read indexes from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+extent*\n          sizeof(PixelPacket)+offset*sizeof(*q),length,(unsigned char *) q);\n        if ((MagickSizeType) count < length)\n          break;\n        offset+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read indexes from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCacheIndexes((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e a d P i x e l C a c h e P i x e l s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReadPixelCachePixels() reads pixels from the specified region of the pixel\n%  cache.\n%\n%  The format of the ReadPixelCachePixels() method is:\n%\n%      MagickBooleanType ReadPixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to read the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType ReadPixelCachePixels(\n  CacheInfo *magick_restrict cache_info,NexusInfo *magick_restrict nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register PixelPacket\n    *magick_restrict q;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns;\n  if ((ssize_t) (offset/cache_info->columns) != nexus_info->region.y)\n    return(MagickFalse);\n  offset+=nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(PixelPacket);\n  if ((length/sizeof(PixelPacket)) != nexus_info->region.width)\n    return(MagickFalse);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  if ((extent == 0) || ((extent/length) != rows))\n    return(MagickFalse);\n  q=nexus_info->pixels;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register PixelPacket\n        *magick_restrict p;\n\n      /*\n        Read pixels from memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      p=cache_info->pixels+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Read pixels from disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadPixelCacheRegion(cache_info,cache_info->offset+offset*\n          sizeof(*q),length,(unsigned char *) q);\n        if ((MagickSizeType) count < length)\n          break;\n        offset+=cache_info->columns;\n        q+=nexus_info->region.width;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Read pixels from distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=ReadDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(unsigned char *) q);\n        if (count != (MagickOffsetType) length)\n          break;\n        q+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToReadPixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   R e f e r e n c e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ReferencePixelCache() increments the reference count associated with the\n%  pixel cache returning a pointer to the cache.\n%\n%  The format of the ReferencePixelCache method is:\n%\n%      Cache ReferencePixelCache(Cache cache_info)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n*/\nMagickExport Cache ReferencePixelCache(Cache cache)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(cache != (Cache *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  LockSemaphoreInfo(cache_info->semaphore);\n  cache_info->reference_count++;\n  UnlockSemaphoreInfo(cache_info->semaphore);\n  return(cache_info);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e M e t h o d s                                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheMethods() sets the image pixel methods to the specified ones.\n%\n%  The format of the SetPixelCacheMethods() method is:\n%\n%      SetPixelCacheMethods(Cache *,CacheMethods *cache_methods)\n%\n%  A description of each parameter follows:\n%\n%    o cache: the pixel cache.\n%\n%    o cache_methods: Specifies a pointer to a CacheMethods structure.\n%\n*/\nMagickExport void SetPixelCacheMethods(Cache cache,CacheMethods *cache_methods)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  GetOneAuthenticPixelFromHandler\n    get_one_authentic_pixel_from_handler;\n\n  GetOneVirtualPixelFromHandler\n    get_one_virtual_pixel_from_handler;\n\n  /*\n    Set cache pixel methods.\n  */\n  assert(cache != (Cache) NULL);\n  assert(cache_methods != (CacheMethods *) NULL);\n  cache_info=(CacheInfo *) cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      cache_info->filename);\n  if (cache_methods->get_virtual_pixel_handler != (GetVirtualPixelHandler) NULL)\n    cache_info->methods.get_virtual_pixel_handler=\n      cache_methods->get_virtual_pixel_handler;\n  if (cache_methods->destroy_pixel_handler != (DestroyPixelHandler) NULL)\n    cache_info->methods.destroy_pixel_handler=\n      cache_methods->destroy_pixel_handler;\n  if (cache_methods->get_virtual_indexes_from_handler !=\n      (GetVirtualIndexesFromHandler) NULL)\n    cache_info->methods.get_virtual_indexes_from_handler=\n      cache_methods->get_virtual_indexes_from_handler;\n  if (cache_methods->get_authentic_pixels_handler !=\n      (GetAuthenticPixelsHandler) NULL)\n    cache_info->methods.get_authentic_pixels_handler=\n      cache_methods->get_authentic_pixels_handler;\n  if (cache_methods->queue_authentic_pixels_handler !=\n      (QueueAuthenticPixelsHandler) NULL)\n    cache_info->methods.queue_authentic_pixels_handler=\n      cache_methods->queue_authentic_pixels_handler;\n  if (cache_methods->sync_authentic_pixels_handler !=\n      (SyncAuthenticPixelsHandler) NULL)\n    cache_info->methods.sync_authentic_pixels_handler=\n      cache_methods->sync_authentic_pixels_handler;\n  if (cache_methods->get_authentic_pixels_from_handler !=\n      (GetAuthenticPixelsFromHandler) NULL)\n    cache_info->methods.get_authentic_pixels_from_handler=\n      cache_methods->get_authentic_pixels_from_handler;\n  if (cache_methods->get_authentic_indexes_from_handler !=\n      (GetAuthenticIndexesFromHandler) NULL)\n    cache_info->methods.get_authentic_indexes_from_handler=\n      cache_methods->get_authentic_indexes_from_handler;\n  get_one_virtual_pixel_from_handler=\n    cache_info->methods.get_one_virtual_pixel_from_handler;\n  if (get_one_virtual_pixel_from_handler !=\n      (GetOneVirtualPixelFromHandler) NULL)\n    cache_info->methods.get_one_virtual_pixel_from_handler=\n      cache_methods->get_one_virtual_pixel_from_handler;\n  get_one_authentic_pixel_from_handler=\n    cache_methods->get_one_authentic_pixel_from_handler;\n  if (get_one_authentic_pixel_from_handler !=\n      (GetOneAuthenticPixelFromHandler) NULL)\n    cache_info->methods.get_one_authentic_pixel_from_handler=\n      cache_methods->get_one_authentic_pixel_from_handler;\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S e t P i x e l C a c h e N e x u s P i x e l s                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheNexusPixels() defines the region of the cache for the\n%  specified cache nexus.\n%\n%  The format of the SetPixelCacheNexusPixels() method is:\n%\n%      PixelPacket SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n%        const MapMode mode,const RectangleInfo *region,\n%        const MagickBooleanType buffered,NexusInfo *nexus_info,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o mode: ReadMode, WriteMode, or IOMode.\n%\n%    o region: A pointer to the RectangleInfo structure that defines the\n%      region of this particular cache nexus.\n%\n%    o buffered: pixels are buffered.\n%\n%    o nexus_info: the cache nexus to set.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline MagickBooleanType AcquireCacheNexusPixels(\n  const CacheInfo *magick_restrict cache_info,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  if (nexus_info->length != (MagickSizeType) ((size_t) nexus_info->length))\n    return(MagickFalse);\n  nexus_info->mapped=MagickFalse;\n  nexus_info->cache=(PixelPacket *) MagickAssumeAligned(AcquireAlignedMemory(1,\n    (size_t) nexus_info->length));\n  if (nexus_info->cache == (PixelPacket *) NULL)\n    {\n      nexus_info->mapped=MagickTrue;\n      nexus_info->cache=(PixelPacket *) MapBlob(-1,IOMode,0,(size_t)\n        nexus_info->length);\n    }\n  if (nexus_info->cache == (PixelPacket *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        cache_info->filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}\n\nstatic inline MagickBooleanType IsAuthenticPixelCache(\n  const CacheInfo *magick_restrict cache_info,\n  const NexusInfo *magick_restrict nexus_info)\n{\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    offset;\n\n  /*\n    Does nexus pixels point directly to in-core cache pixels or is it buffered?\n  */\n  if (cache_info->type == PingCache)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  status=nexus_info->pixels == (cache_info->pixels+offset) ? MagickTrue :\n    MagickFalse;\n  return(status);\n}\n\nstatic inline void PrefetchPixelCacheNexusPixels(const NexusInfo *nexus_info,\n  const MapMode mode)\n{\n  magick_unreferenced(nexus_info);\n  magick_unreferenced(mode);\n\n  if (mode == ReadMode)\n    {\n      MagickCachePrefetch((unsigned char *) nexus_info->pixels,0,1);\n      return;\n    }\n  MagickCachePrefetch((unsigned char *) nexus_info->pixels,1,1);\n}\n\nstatic PixelPacket *SetPixelCacheNexusPixels(const CacheInfo *cache_info,\n  const MapMode mode,const RectangleInfo *region,\n  const MagickBooleanType buffered,NexusInfo *nexus_info,\n  ExceptionInfo *exception)\n{\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    length,\n    number_pixels;\n\n  assert(cache_info != (const CacheInfo *) NULL);\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->type == UndefinedCache)\n    return((PixelPacket *) NULL);\n  nexus_info->region=(*region);\n  if (((cache_info->type == MemoryCache) || (cache_info->type == MapCache)) &&\n      (buffered == MagickFalse))\n    {\n      ssize_t\n        x,\n        y;\n\n      x=nexus_info->region.x+(ssize_t) nexus_info->region.width-1;\n      y=nexus_info->region.y+(ssize_t) nexus_info->region.height-1;\n      if (((nexus_info->region.x >= 0) && (x < (ssize_t) cache_info->columns) &&\n           (nexus_info->region.y >= 0) && (y < (ssize_t) cache_info->rows)) &&\n          ((nexus_info->region.height == 1UL) || ((nexus_info->region.x == 0) &&\n           ((nexus_info->region.width == cache_info->columns) ||\n            ((nexus_info->region.width % cache_info->columns) == 0)))))\n        {\n          MagickOffsetType\n            offset;\n\n          /*\n            Pixels are accessed directly from memory.\n          */\n          offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n            nexus_info->region.x;\n          nexus_info->pixels=cache_info->pixels+offset;\n          nexus_info->indexes=(IndexPacket *) NULL;\n          if (cache_info->active_index_channel != MagickFalse)\n            nexus_info->indexes=cache_info->indexes+offset;\n          PrefetchPixelCacheNexusPixels(nexus_info,mode);\n          nexus_info->authentic_pixel_cache=IsAuthenticPixelCache(cache_info,\n            nexus_info);\n          return(nexus_info->pixels);\n        }\n    }\n  /*\n    Pixels are stored in a staging region until they are synced to the cache.\n  */\n  number_pixels=(MagickSizeType) nexus_info->region.width*\n    nexus_info->region.height;\n  length=number_pixels*sizeof(PixelPacket);\n  if (cache_info->active_index_channel != MagickFalse)\n    length+=number_pixels*sizeof(IndexPacket);\n  if (nexus_info->cache == (PixelPacket *) NULL)\n    {\n      nexus_info->length=length;\n      status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n      if (status == MagickFalse)\n        {\n          nexus_info->length=0;\n          return((PixelPacket *) NULL);\n        }\n    }\n  else\n    if (nexus_info->length < length)\n      {\n        RelinquishCacheNexusPixels(nexus_info);\n        nexus_info->length=length;\n        status=AcquireCacheNexusPixels(cache_info,nexus_info,exception);\n        if (status == MagickFalse)\n          {\n            nexus_info->length=0;\n            return((PixelPacket *) NULL);\n          }\n      }\n  nexus_info->pixels=nexus_info->cache;\n  nexus_info->indexes=(IndexPacket *) NULL;\n  if (cache_info->active_index_channel != MagickFalse)\n    nexus_info->indexes=(IndexPacket *) (nexus_info->pixels+number_pixels);\n  PrefetchPixelCacheNexusPixels(nexus_info,mode);\n  nexus_info->authentic_pixel_cache=IsAuthenticPixelCache(cache_info,\n    nexus_info);\n  return(nexus_info->pixels);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S e t P i x e l C a c h e V i r t u a l M e t h o d                       %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SetPixelCacheVirtualMethod() sets the \"virtual pixels\" method for the\n%  pixel cache and returns the previous setting.  A virtual pixel is any pixel\n%  access that is outside the boundaries of the image cache.\n%\n%  The format of the SetPixelCacheVirtualMethod() method is:\n%\n%      VirtualPixelMethod SetPixelCacheVirtualMethod(const Image *image,\n%        const VirtualPixelMethod virtual_pixel_method)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o virtual_pixel_method: choose the type of virtual pixel.\n%\n*/\n\nstatic MagickBooleanType SetCacheAlphaChannel(Image *image,\n  const Quantum opacity)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  CacheView\n    *magick_restrict image_view;\n\n  MagickBooleanType\n    status;\n\n  ssize_t\n    y;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  image->matte=MagickTrue;\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,&image->exception);  /* must be virtual */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static,4) shared(status) \\\n    magick_threads(image,image,1,1)\n#endif\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register PixelPacket\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(image_view,0,y,image->columns,1,\n      &image->exception);\n    if (q == (PixelPacket *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      q->opacity=opacity;\n      q++;\n    }\n    status=SyncCacheViewAuthenticPixels(image_view,&image->exception);\n  }\n  image_view=DestroyCacheView(image_view);\n  return(status);\n}\n\nMagickExport VirtualPixelMethod SetPixelCacheVirtualMethod(const Image *image,\n  const VirtualPixelMethod virtual_pixel_method)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  VirtualPixelMethod\n    method;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  method=cache_info->virtual_pixel_method;\n  cache_info->virtual_pixel_method=virtual_pixel_method;\n  if ((image->columns != 0) && (image->rows != 0))\n    switch (virtual_pixel_method)\n    {\n      case BackgroundVirtualPixelMethod:\n      {\n        if ((image->background_color.opacity != OpaqueOpacity) &&\n            (image->matte == MagickFalse))\n          (void) SetCacheAlphaChannel((Image *) image,OpaqueOpacity);\n        if ((IsPixelGray(&image->background_color) == MagickFalse) &&\n            (IsGrayColorspace(image->colorspace) != MagickFalse))\n          (void) SetImageColorspace((Image *) image,sRGBColorspace);\n        break;\n      }\n      case TransparentVirtualPixelMethod:\n      {\n        if (image->matte == MagickFalse)\n          (void) SetCacheAlphaChannel((Image *) image,OpaqueOpacity);\n        break;\n      }\n      default:\n        break;\n    }\n  return(method);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e N e x u s                   %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelCacheNexus() saves the authentic image pixels to the\n%  in-memory or disk cache.  The method returns MagickTrue if the pixel region\n%  is synced, otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelCacheNexus() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o nexus_info: the cache nexus to sync.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SyncAuthenticPixelCacheNexus(Image *image,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Transfer pixels to the cache.\n  */\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->cache == (Cache) NULL)\n    ThrowBinaryException(CacheError,\"PixelCacheIsNotOpen\",image->filename);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->type == UndefinedCache)\n    return(MagickFalse);\n  if ((image->storage_class == DirectClass) &&\n      (image->clip_mask != (Image *) NULL) &&\n      (ClipPixelCacheNexus(image,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if ((image->storage_class == DirectClass) &&\n      (image->mask != (Image *) NULL) &&\n      (MaskPixelCacheNexus(image,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    {\n      image->taint=MagickTrue;\n      return(MagickTrue);\n    }\n  assert(cache_info->signature == MagickSignature);\n  status=WritePixelCachePixels(cache_info,nexus_info,exception);\n  if ((cache_info->active_index_channel != MagickFalse) &&\n      (WritePixelCacheIndexes(cache_info,nexus_info,exception) == MagickFalse))\n    return(MagickFalse);\n  if (status != MagickFalse)\n    image->taint=MagickTrue;\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c A u t h e n t i c P i x e l C a c h e                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixelsCache() saves the authentic image pixels to the in-memory\n%  or disk cache.  The method returns MagickTrue if the pixel region is synced,\n%  otherwise MagickFalse.\n%\n%  The format of the SyncAuthenticPixelsCache() method is:\n%\n%      MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType SyncAuthenticPixelsCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   S y n c A u t h e n t i c P i x e l s                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncAuthenticPixels() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncAuthenticPixels() method is:\n%\n%      MagickBooleanType SyncAuthenticPixels(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport MagickBooleanType SyncAuthenticPixels(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  const int\n    id = GetOpenMPThreadId();\n\n  MagickBooleanType\n    status;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  assert(image->cache != (Cache) NULL);\n  cache_info=(CacheInfo *) image->cache;\n  assert(cache_info->signature == MagickSignature);\n  if (cache_info->methods.sync_authentic_pixels_handler !=\n       (SyncAuthenticPixelsHandler) NULL)\n    return(cache_info->methods.sync_authentic_pixels_handler(image,exception));\n  assert(id < (int) cache_info->number_threads);\n  status=SyncAuthenticPixelCacheNexus(image,cache_info->nexus_info[id],\n    exception);\n  return(status);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   S y n c I m a g e P i x e l C a c h e                                     %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  SyncImagePixelCache() saves the image pixels to the in-memory or disk cache.\n%  The method returns MagickTrue if the pixel region is flushed, otherwise\n%  MagickFalse.\n%\n%  The format of the SyncImagePixelCache() method is:\n%\n%      MagickBooleanType SyncImagePixelCache(Image *image,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *magick_restrict cache_info;\n\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e P i x e l C a c h e I n d e x e s                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCacheIndexes() writes the colormap indexes to the specified\n%  region of the pixel cache.\n%\n%  The format of the WritePixelCacheIndexes() method is:\n%\n%      MagickBooleanType WritePixelCacheIndexes(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the colormap indexes.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCacheIndexes(CacheInfo *cache_info,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const IndexPacket\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (cache_info->active_index_channel == MagickFalse)\n    return(MagickFalse);\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(IndexPacket);\n  rows=nexus_info->region.height;\n  extent=(MagickSizeType) length*rows;\n  p=nexus_info->indexes;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register IndexPacket\n        *magick_restrict q;\n\n      /*\n        Write indexes to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=cache_info->indexes+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=nexus_info->region.width;\n        q+=cache_info->columns;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write indexes to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      extent=(MagickSizeType) cache_info->columns*cache_info->rows;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+extent*\n          sizeof(PixelPacket)+offset*sizeof(*p),length,(const unsigned char *)\n          p);\n        if ((MagickSizeType) count < length)\n          break;\n        p+=nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write indexes to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCacheIndexes((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n+   W r i t e P i x e l C a c h e P i x e l s                                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  WritePixelCachePixels() writes image pixels to the specified region of the\n%  pixel cache.\n%\n%  The format of the WritePixelCachePixels() method is:\n%\n%      MagickBooleanType WritePixelCachePixels(CacheInfo *cache_info,\n%        NexusInfo *nexus_info,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o cache_info: the pixel cache.\n%\n%    o nexus_info: the cache nexus to write the pixels.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nstatic MagickBooleanType WritePixelCachePixels(CacheInfo *cache_info,\n  NexusInfo *magick_restrict nexus_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    count,\n    offset;\n\n  MagickSizeType\n    extent,\n    length;\n\n  register const PixelPacket\n    *magick_restrict p;\n\n  register ssize_t\n    y;\n\n  size_t\n    rows;\n\n  if (nexus_info->authentic_pixel_cache != MagickFalse)\n    return(MagickTrue);\n  offset=(MagickOffsetType) nexus_info->region.y*cache_info->columns+\n    nexus_info->region.x;\n  length=(MagickSizeType) nexus_info->region.width*sizeof(PixelPacket);\n  rows=nexus_info->region.height;\n  extent=length*rows;\n  p=nexus_info->pixels;\n  y=0;\n  switch (cache_info->type)\n  {\n    case MemoryCache:\n    case MapCache:\n    {\n      register PixelPacket\n        *magick_restrict q;\n\n      /*\n        Write pixels to memory.\n      */\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent == (MagickSizeType) ((size_t) extent)))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      q=cache_info->pixels+offset;\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        (void) memcpy(q,p,(size_t) length);\n        p+=nexus_info->region.width;\n        q+=cache_info->columns;\n      }\n      break;\n    }\n    case DiskCache:\n    {\n      /*\n        Write pixels to disk.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      if (OpenPixelCacheOnDisk(cache_info,IOMode) == MagickFalse)\n        {\n          ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n            cache_info->cache_filename);\n          UnlockSemaphoreInfo(cache_info->file_semaphore);\n          return(MagickFalse);\n        }\n      if ((cache_info->columns == nexus_info->region.width) &&\n          (extent <= MagickMaxBufferExtent))\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WritePixelCacheRegion(cache_info,cache_info->offset+offset*\n          sizeof(*p),length,(const unsigned char *) p);\n        if ((MagickSizeType) count < length)\n          break;\n        p+=nexus_info->region.width;\n        offset+=cache_info->columns;\n      }\n      if (IsFileDescriptorLimitExceeded() != MagickFalse)\n        (void) ClosePixelCacheOnDisk(cache_info);\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    case DistributedCache:\n    {\n      RectangleInfo\n        region;\n\n      /*\n        Write pixels to distributed cache.\n      */\n      LockSemaphoreInfo(cache_info->file_semaphore);\n      region=nexus_info->region;\n      if ((cache_info->columns != nexus_info->region.width) ||\n          (extent > MagickMaxBufferExtent))\n        region.height=1UL;\n      else\n        {\n          length=extent;\n          rows=1UL;\n        }\n      for (y=0; y < (ssize_t) rows; y++)\n      {\n        count=WriteDistributePixelCachePixels((DistributeCacheInfo *)\n          cache_info->server_info,&region,length,(const unsigned char *) p);\n        if (count != (MagickOffsetType) length)\n          break;\n        p+=nexus_info->region.width;\n        region.y++;\n      }\n      UnlockSemaphoreInfo(cache_info->file_semaphore);\n      break;\n    }\n    default:\n      break;\n  }\n  if (y < (ssize_t) rows)\n    {\n      ThrowFileException(exception,CacheError,\"UnableToWritePixelCache\",\n        cache_info->cache_filename);\n      return(MagickFalse);\n    }\n  if ((cache_info->debug != MagickFalse) &&\n      (CacheTick(nexus_info->region.y,cache_info->rows) != MagickFalse))\n    (void) LogMagickEvent(CacheEvent,GetMagickModule(),\n      \"%s[%.20gx%.20g%+.20g%+.20g]\",cache_info->filename,(double)\n      nexus_info->region.width,(double) nexus_info->region.height,(double)\n      nexus_info->region.x,(double) nexus_info->region.y);\n  return(MagickTrue);\n}\n"], "filenames": ["magick/cache.c"], "buggy_code_start_loc": [3427], "buggy_code_end_loc": [3660], "fixing_code_start_loc": [3426], "fixing_code_end_loc": [3649], "type": "CWE-399", "message": "Memory leak in AcquireVirtualMemory in ImageMagick before 7 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors.", "other": {"cve": {"id": "CVE-2016-7539", "sourceIdentifier": "security@debian.org", "published": "2017-07-25T14:29:00.253", "lastModified": "2017-07-27T18:19:56.547", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Memory leak in AcquireVirtualMemory in ImageMagick before 7 allows remote attackers to cause a denial of service (memory consumption) via unspecified vectors."}, {"lang": "es", "value": "Una p\u00e9rdida de memoria en la funci\u00f3n AcquireVirtualMemory en ImageMagick anterior a versi\u00f3n 7, permite a los atacantes remotos causar una denegaci\u00f3n de servicio (consumo de memoria) por medio de vectores no especificados."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-399"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.9.9-3", "matchCriteriaId": "5875084E-72B2-4260-B29C-39788CB1575D"}]}]}], "references": [{"url": "http://www.imagemagick.org/discourse-server/viewtopic.php?f=2&t=28946", "source": "security@debian.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2016/09/22/2", "source": "security@debian.org", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/93232", "source": "security@debian.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=833101", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1378776", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c", "source": "security@debian.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/4e81ce8b07219c69a9aeccb0f7f7b927ca6db74c"}}