{"buggy_code": ["package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/urfave/cli\"\n)\n\nvar execCommand = cli.Command{\n\tName:  \"exec\",\n\tUsage: \"execute new process inside the container\",\n\tArgsUsage: `<container-id> <command> [command options]  || -p process.json <container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container and\n\"<command>\" is the command to be executed in the container.\n\"<command>\" can't be empty unless a \"-p\" flag provided.\n\nEXAMPLE:\nFor example, if the container is configured to run the linux ps command the\nfollowing will output a list of processes running in the container:\n\n       # runc exec <container-id> ps`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"console-socket\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cwd\",\n\t\t\tUsage: \"current working directory in the container\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"env, e\",\n\t\t\tUsage: \"set environment variables\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"tty, t\",\n\t\t\tUsage: \"allocate a pseudo-TTY\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"user, u\",\n\t\t\tUsage: \"UID (format: <uid>[:<gid>])\",\n\t\t},\n\t\tcli.Int64SliceFlag{\n\t\t\tName:  \"additional-gids, g\",\n\t\t\tUsage: \"additional gids\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"process, p\",\n\t\t\tUsage: \"path to the process.json\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"detach,d\",\n\t\t\tUsage: \"detach from the container's process\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pid-file\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"specify the file to write the process id to\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"process-label\",\n\t\t\tUsage: \"set the asm process label for the process commonly used with selinux\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"apparmor\",\n\t\t\tUsage: \"set the apparmor profile for the process\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-new-privs\",\n\t\t\tUsage: \"set the no new privileges value for the process\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"cap, c\",\n\t\t\tValue: &cli.StringSlice{},\n\t\t\tUsage: \"add a capability to the bounding set for the process\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:  \"preserve-fds\",\n\t\t\tUsage: \"Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total)\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"cgroup\",\n\t\t\tUsage: \"run the process in an (existing) sub-cgroup(s). Format is [<controller>:]<cgroup>.\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"ignore-paused\",\n\t\t\tUsage: \"allow exec in a paused container\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, minArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := revisePidFile(context); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := execProcess(context)\n\t\tif err == nil {\n\t\t\tos.Exit(status)\n\t\t}\n\t\tfatalWithCode(fmt.Errorf(\"exec failed: %w\", err), 255)\n\t\treturn nil // to satisfy the linter\n\t},\n\tSkipArgReorder: true,\n}\n\nfunc getSubCgroupPaths(args []string) (map[string]string, error) {\n\tif len(args) == 0 {\n\t\treturn nil, nil\n\t}\n\tpaths := make(map[string]string, len(args))\n\tfor _, c := range args {\n\t\t// Split into controller:path.\n\t\tcs := strings.SplitN(c, \":\", 3)\n\t\tif len(cs) > 2 {\n\t\t\treturn nil, fmt.Errorf(\"invalid --cgroup argument: %s\", c)\n\t\t}\n\t\tif len(cs) == 1 { // no controller: prefix\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid --cgroup argument: %s (missing <controller>: prefix)\", c)\n\t\t\t}\n\t\t\tpaths[\"\"] = c\n\t\t} else {\n\t\t\t// There may be a few comma-separated controllers.\n\t\t\tfor _, ctrl := range strings.Split(cs[0], \",\") {\n\t\t\t\tpaths[ctrl] = cs[1]\n\t\t\t}\n\t\t}\n\t}\n\treturn paths, nil\n}\n\nfunc execProcess(context *cli.Context) (int, error) {\n\tcontainer, err := getContainer(context)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tstatus, err := container.Status()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tif status == libcontainer.Stopped {\n\t\treturn -1, errors.New(\"cannot exec in a stopped container\")\n\t}\n\tif status == libcontainer.Paused && !context.Bool(\"ignore-paused\") {\n\t\treturn -1, errors.New(\"cannot exec in a paused container (use --ignore-paused to override)\")\n\t}\n\tpath := context.String(\"process\")\n\tif path == \"\" && len(context.Args()) == 1 {\n\t\treturn -1, errors.New(\"process args cannot be empty\")\n\t}\n\tstate, err := container.State()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tbundle, ok := utils.SearchLabels(state.Config.Labels, \"bundle\")\n\tif !ok {\n\t\treturn -1, errors.New(\"bundle not found in labels\")\n\t}\n\tp, err := getProcess(context, bundle)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tcgPaths, err := getSubCgroupPaths(context.StringSlice(\"cgroup\"))\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tr := &runner{\n\t\tenableSubreaper: false,\n\t\tshouldDestroy:   false,\n\t\tcontainer:       container,\n\t\tconsoleSocket:   context.String(\"console-socket\"),\n\t\tdetach:          context.Bool(\"detach\"),\n\t\tpidFile:         context.String(\"pid-file\"),\n\t\taction:          CT_ACT_RUN,\n\t\tinit:            false,\n\t\tpreserveFDs:     context.Int(\"preserve-fds\"),\n\t\tsubCgroupPaths:  cgPaths,\n\t}\n\treturn r.run(p)\n}\n\nfunc getProcess(context *cli.Context, bundle string) (*specs.Process, error) {\n\tif path := context.String(\"process\"); path != \"\" {\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer f.Close()\n\t\tvar p specs.Process\n\t\tif err := json.NewDecoder(f).Decode(&p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &p, validateProcessSpec(&p)\n\t}\n\t// process via cli flags\n\tif err := os.Chdir(bundle); err != nil {\n\t\treturn nil, err\n\t}\n\tspec, err := loadSpec(specConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := spec.Process\n\tp.Args = context.Args()[1:]\n\t// override the cwd, if passed\n\tif context.String(\"cwd\") != \"\" {\n\t\tp.Cwd = context.String(\"cwd\")\n\t}\n\tif ap := context.String(\"apparmor\"); ap != \"\" {\n\t\tp.ApparmorProfile = ap\n\t}\n\tif l := context.String(\"process-label\"); l != \"\" {\n\t\tp.SelinuxLabel = l\n\t}\n\tif caps := context.StringSlice(\"cap\"); len(caps) > 0 {\n\t\tfor _, c := range caps {\n\t\t\tp.Capabilities.Bounding = append(p.Capabilities.Bounding, c)\n\t\t\tp.Capabilities.Inheritable = append(p.Capabilities.Inheritable, c)\n\t\t\tp.Capabilities.Effective = append(p.Capabilities.Effective, c)\n\t\t\tp.Capabilities.Permitted = append(p.Capabilities.Permitted, c)\n\t\t\tp.Capabilities.Ambient = append(p.Capabilities.Ambient, c)\n\t\t}\n\t}\n\t// append the passed env variables\n\tp.Env = append(p.Env, context.StringSlice(\"env\")...)\n\n\t// set the tty\n\tp.Terminal = false\n\tif context.IsSet(\"tty\") {\n\t\tp.Terminal = context.Bool(\"tty\")\n\t}\n\tif context.IsSet(\"no-new-privs\") {\n\t\tp.NoNewPrivileges = context.Bool(\"no-new-privs\")\n\t}\n\t// override the user, if passed\n\tif context.String(\"user\") != \"\" {\n\t\tu := strings.SplitN(context.String(\"user\"), \":\", 2)\n\t\tif len(u) > 1 {\n\t\t\tgid, err := strconv.Atoi(u[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"parsing %s as int for gid failed: %w\", u[1], err)\n\t\t\t}\n\t\t\tp.User.GID = uint32(gid)\n\t\t}\n\t\tuid, err := strconv.Atoi(u[0])\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"parsing %s as int for uid failed: %w\", u[0], err)\n\t\t}\n\t\tp.User.UID = uint32(uid)\n\t}\n\tfor _, gid := range context.Int64Slice(\"additional-gids\") {\n\t\tif gid < 0 {\n\t\t\treturn nil, fmt.Errorf(\"additional-gids must be a positive number %d\", gid)\n\t\t}\n\t\tp.User.AdditionalGids = append(p.User.AdditionalGids, uint32(gid))\n\t}\n\treturn p, validateProcessSpec(p)\n}\n", "# libcontainer\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/opencontainers/runc/libcontainer.svg)](https://pkg.go.dev/github.com/opencontainers/runc/libcontainer)\n\nLibcontainer provides a native Go implementation for creating containers\nwith namespaces, cgroups, capabilities, and filesystem access controls.\nIt allows you to manage the lifecycle of the container performing additional operations\nafter the container is created.\n\n\n#### Container\nA container is a self contained execution environment that shares the kernel of the\nhost system and which is (optionally) isolated from other containers in the system.\n\n#### Using libcontainer\n\nBecause containers are spawned in a two step process you will need a binary that\nwill be executed as the init process for the container. In libcontainer, we use\nthe current binary (/proc/self/exe) to be executed as the init process, and use\narg \"init\", we call the first step process \"bootstrap\", so you always need a \"init\"\nfunction as the entry of \"bootstrap\".\n\nIn addition to the go init function the early stage bootstrap is handled by importing\n[nsenter](https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/README.md).\n\n```go\nimport (\n\t_ \"github.com/opencontainers/runc/libcontainer/nsenter\"\n)\n\nfunc init() {\n\tif len(os.Args) > 1 && os.Args[1] == \"init\" {\n\t\truntime.GOMAXPROCS(1)\n\t\truntime.LockOSThread()\n\t\tif err := libcontainer.StartInitialization(); err != nil {\n\t\t\tlogrus.Fatal(err)\n\t\t}\n\t\tpanic(\"--this line should have never been executed, congratulations--\")\n\t}\n}\n```\n\nThen to create a container you first have to create a configuration\nstruct describing how the container is to be created. A sample would look similar to this:\n\n```go\ndefaultMountFlags := unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\nvar devices []*configs.DeviceRule\nfor _, device := range specconv.AllowedDevices {\n\tdevices = append(devices, &device.Rule)\n}\nconfig := &configs.Config{\n\tRootfs: \"/your/path/to/rootfs\",\n\tCapabilities: &configs.Capabilities{\n\t\tBounding: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t\tEffective: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t\tInheritable: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t\tPermitted: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t\tAmbient: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t},\n\tNamespaces: configs.Namespaces([]configs.Namespace{\n\t\t{Type: configs.NEWNS},\n\t\t{Type: configs.NEWUTS},\n\t\t{Type: configs.NEWIPC},\n\t\t{Type: configs.NEWPID},\n\t\t{Type: configs.NEWUSER},\n\t\t{Type: configs.NEWNET},\n\t\t{Type: configs.NEWCGROUP},\n\t}),\n\tCgroups: &configs.Cgroup{\n\t\tName:   \"test-container\",\n\t\tParent: \"system\",\n\t\tResources: &configs.Resources{\n\t\t\tMemorySwappiness: nil,\n\t\t\tDevices:          devices,\n\t\t},\n\t},\n\tMaskPaths: []string{\n\t\t\"/proc/kcore\",\n\t\t\"/sys/firmware\",\n\t},\n\tReadonlyPaths: []string{\n\t\t\"/proc/sys\", \"/proc/sysrq-trigger\", \"/proc/irq\", \"/proc/bus\",\n\t},\n\tDevices:  specconv.AllowedDevices,\n\tHostname: \"testing\",\n\tMounts: []*configs.Mount{\n\t\t{\n\t\t\tSource:      \"proc\",\n\t\t\tDestination: \"/proc\",\n\t\t\tDevice:      \"proc\",\n\t\t\tFlags:       defaultMountFlags,\n\t\t},\n\t\t{\n\t\t\tSource:      \"tmpfs\",\n\t\t\tDestination: \"/dev\",\n\t\t\tDevice:      \"tmpfs\",\n\t\t\tFlags:       unix.MS_NOSUID | unix.MS_STRICTATIME,\n\t\t\tData:        \"mode=755\",\n\t\t},\n\t\t{\n\t\t\tSource:      \"devpts\",\n\t\t\tDestination: \"/dev/pts\",\n\t\t\tDevice:      \"devpts\",\n\t\t\tFlags:       unix.MS_NOSUID | unix.MS_NOEXEC,\n\t\t\tData:        \"newinstance,ptmxmode=0666,mode=0620,gid=5\",\n\t\t},\n\t\t{\n\t\t\tDevice:      \"tmpfs\",\n\t\t\tSource:      \"shm\",\n\t\t\tDestination: \"/dev/shm\",\n\t\t\tData:        \"mode=1777,size=65536k\",\n\t\t\tFlags:       defaultMountFlags,\n\t\t},\n\t\t{\n\t\t\tSource:      \"mqueue\",\n\t\t\tDestination: \"/dev/mqueue\",\n\t\t\tDevice:      \"mqueue\",\n\t\t\tFlags:       defaultMountFlags,\n\t\t},\n\t\t{\n\t\t\tSource:      \"sysfs\",\n\t\t\tDestination: \"/sys\",\n\t\t\tDevice:      \"sysfs\",\n\t\t\tFlags:       defaultMountFlags | unix.MS_RDONLY,\n\t\t},\n\t},\n\tUidMappings: []configs.IDMap{\n\t\t{\n\t\t\tContainerID: 0,\n\t\t\tHostID: 1000,\n\t\t\tSize: 65536,\n\t\t},\n\t},\n\tGidMappings: []configs.IDMap{\n\t\t{\n\t\t\tContainerID: 0,\n\t\t\tHostID: 1000,\n\t\t\tSize: 65536,\n\t\t},\n\t},\n\tNetworks: []*configs.Network{\n\t\t{\n\t\t\tType:    \"loopback\",\n\t\t\tAddress: \"127.0.0.1/0\",\n\t\t\tGateway: \"localhost\",\n\t\t},\n\t},\n\tRlimits: []configs.Rlimit{\n\t\t{\n\t\t\tType: unix.RLIMIT_NOFILE,\n\t\t\tHard: uint64(1025),\n\t\t\tSoft: uint64(1025),\n\t\t},\n\t},\n}\n```\n\nOnce you have the configuration populated you can create a container\nwith a specified ID under a specified state directory:\n\n```go\ncontainer, err := libcontainer.Create(\"/run/containers\", \"container-id\", config)\nif err != nil {\n\tlogrus.Fatal(err)\n\treturn\n}\n```\n\nTo spawn bash as the initial process inside the container and have the\nprocesses pid returned in order to wait, signal, or kill the process:\n\n```go\nprocess := &libcontainer.Process{\n\tArgs:   []string{\"/bin/bash\"},\n\tEnv:    []string{\"PATH=/bin\"},\n\tUser:   \"daemon\",\n\tStdin:  os.Stdin,\n\tStdout: os.Stdout,\n\tStderr: os.Stderr,\n\tInit:   true,\n}\n\nerr := container.Run(process)\nif err != nil {\n\tcontainer.Destroy()\n\tlogrus.Fatal(err)\n\treturn\n}\n\n// wait for the process to finish.\n_, err := process.Wait()\nif err != nil {\n\tlogrus.Fatal(err)\n}\n\n// destroy the container.\ncontainer.Destroy()\n```\n\nAdditional ways to interact with a running container are:\n\n```go\n// return all the pids for all processes running inside the container.\nprocesses, err := container.Processes()\n\n// get detailed cpu, memory, io, and network statistics for the container and\n// it's processes.\nstats, err := container.Stats()\n\n// pause all processes inside the container.\ncontainer.Pause()\n\n// resume all paused processes.\ncontainer.Resume()\n\n// send signal to container's init process.\ncontainer.Signal(signal)\n\n// update container resource constraints.\ncontainer.Set(config)\n\n// get current status of the container.\nstatus, err := container.Status()\n\n// get current container's state information.\nstate, err := container.State()\n```\n\n\n#### Checkpoint & Restore\n\nlibcontainer now integrates [CRIU](http://criu.org/) for checkpointing and restoring containers.\nThis lets you save the state of a process running inside a container to disk, and then restore\nthat state into a new process, on the same machine or on another machine.\n\n`criu` version 1.5.2 or higher is required to use checkpoint and restore.\nIf you don't already  have `criu` installed, you can build it from source, following the\n[online instructions](http://criu.org/Installation). `criu` is also installed in the docker image\ngenerated when building libcontainer with docker.\n\n\n## Copyright and license\n\nCode and documentation copyright 2014 Docker, inc.\nThe code and documentation are released under the [Apache 2.0 license](../LICENSE).\nThe documentation is also released under Creative Commons Attribution 4.0 International License.\nYou may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.\n", "package integration\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/systemd\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestExecPS(t *testing.T) {\n\ttestExecPS(t, false)\n}\n\nfunc TestUsernsExecPS(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires userns.\")\n\t}\n\ttestExecPS(t, true)\n}\n\nfunc testExecPS(t *testing.T, userns bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, &tParam{userns: userns})\n\n\tbuffers, exitCode, err := runContainer(t, config, \"ps\", \"-o\", \"pid,user,comm\")\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %s\", buffers, err)\n\t}\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\tlines := strings.Split(buffers.Stdout.String(), \"\\n\")\n\tif len(lines) < 2 {\n\t\tt.Fatalf(\"more than one process running for output %q\", buffers.Stdout.String())\n\t}\n\texpected := `1 root     ps`\n\tactual := strings.Trim(lines[1], \"\\n \")\n\tif actual != expected {\n\t\tt.Fatalf(\"expected output %q but received %q\", expected, actual)\n\t}\n}\n\nfunc TestIPCPrivate(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/ipc\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual == l {\n\t\tt.Fatalf(\"ipc link should be private to the container but equals host %q %q\", actual, l)\n\t}\n}\n\nfunc TestIPCHost(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Remove(configs.NEWIPC)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/ipc\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"ipc link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestIPCJoinPath(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWIPC, \"/proc/1/ns/ipc\")\n\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/ipc\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"ipc link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestIPCBadPath(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWIPC, \"/proc/1/ns/ipcc\")\n\n\tif _, _, err := runContainer(t, config, \"true\"); err == nil {\n\t\tt.Fatal(\"container succeeded with bad ipc path\")\n\t}\n}\n\nfunc TestRlimit(t *testing.T) {\n\ttestRlimit(t, false)\n}\n\nfunc TestUsernsRlimit(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires userns.\")\n\t}\n\n\ttestRlimit(t, true)\n}\n\nfunc testRlimit(t *testing.T, userns bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{userns: userns})\n\n\t// ensure limit is lower than what the config requests to test that in a user namespace\n\t// the Setrlimit call happens early enough that we still have permissions to raise the limit.\n\tok(t, unix.Setrlimit(unix.RLIMIT_NOFILE, &unix.Rlimit{\n\t\tMax: 1024,\n\t\tCur: 1024,\n\t}))\n\n\tout, _, err := runContainer(t, config, \"/bin/sh\", \"-c\", \"ulimit -n\")\n\tok(t, err)\n\tif limit := strings.TrimSpace(out.Stdout.String()); limit != \"1025\" {\n\t\tt.Fatalf(\"expected rlimit to be 1025, got %s\", limit)\n\t}\n}\n\nfunc TestEnter(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\t// Execute a first process in the container\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tvar stdout, stdout2 bytes.Buffer\n\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"cat && readlink /proc/self/ns/pid\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  stdinR,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\tpid, err := pconfig.Pid()\n\tok(t, err)\n\n\t// Execute another process in the container\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\tpconfig2 := libcontainer.Process{\n\t\tCwd: \"/\",\n\t\tEnv: standardEnvironment,\n\t}\n\tpconfig2.Args = []string{\"sh\", \"-c\", \"cat && readlink /proc/self/ns/pid\"}\n\tpconfig2.Stdin = stdinR2\n\tpconfig2.Stdout = &stdout2\n\n\terr = container.Run(&pconfig2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\tpid2, err := pconfig2.Pid()\n\tok(t, err)\n\n\tprocesses, err := container.Processes()\n\tok(t, err)\n\n\tn := 0\n\tfor i := range processes {\n\t\tif processes[i] == pid || processes[i] == pid2 {\n\t\t\tn++\n\t\t}\n\t}\n\tif n != 2 {\n\t\tt.Fatal(\"unexpected number of processes\", processes, pid, pid2)\n\t}\n\n\t// Wait processes\n\t_ = stdinW2.Close()\n\twaitProcess(&pconfig2, t)\n\n\t_ = stdinW.Close()\n\twaitProcess(&pconfig, t)\n\n\t// Check that both processes live in the same pidns\n\tpidns := stdout.String()\n\tok(t, err)\n\n\tpidns2 := stdout2.String()\n\tok(t, err)\n\n\tif pidns != pidns2 {\n\t\tt.Fatal(\"The second process isn't in the required pid namespace\", pidns, pidns2)\n\t}\n}\n\nfunc TestProcessEnv(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:  \"/\",\n\t\tArgs: []string{\"sh\", \"-c\", \"env\"},\n\t\tEnv: []string{\n\t\t\t\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n\t\t\t\"HOSTNAME=integration\",\n\t\t\t\"TERM=xterm\",\n\t\t\t\"FOO=BAR\",\n\t\t},\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputEnv := stdout.String()\n\n\t// Check that the environment has the key/value pair we added\n\tif !strings.Contains(outputEnv, \"FOO=BAR\") {\n\t\tt.Fatal(\"Environment doesn't have the expected FOO=BAR key/value pair: \", outputEnv)\n\t}\n\n\t// Make sure that HOME is set\n\tif !strings.Contains(outputEnv, \"HOME=/root\") {\n\t\tt.Fatal(\"Environment doesn't have HOME set: \", outputEnv)\n\t}\n}\n\nfunc TestProcessEmptyCaps(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Capabilities = nil\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"cat /proc/self/status\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputStatus := stdout.String()\n\n\tlines := strings.Split(outputStatus, \"\\n\")\n\n\teffectiveCapsLine := \"\"\n\tfor _, l := range lines {\n\t\tline := strings.TrimSpace(l)\n\t\tif strings.Contains(line, \"CapEff:\") {\n\t\t\teffectiveCapsLine = line\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif effectiveCapsLine == \"\" {\n\t\tt.Fatal(\"Couldn't find effective caps: \", outputStatus)\n\t}\n}\n\nfunc TestProcessCaps(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:          \"/\",\n\t\tArgs:         []string{\"sh\", \"-c\", \"cat /proc/self/status\"},\n\t\tEnv:          standardEnvironment,\n\t\tStdin:        nil,\n\t\tStdout:       &stdout,\n\t\tCapabilities: &configs.Capabilities{},\n\t\tInit:         true,\n\t}\n\tpconfig.Capabilities.Bounding = append(config.Capabilities.Bounding, \"CAP_NET_ADMIN\")\n\tpconfig.Capabilities.Permitted = append(config.Capabilities.Permitted, \"CAP_NET_ADMIN\")\n\tpconfig.Capabilities.Effective = append(config.Capabilities.Effective, \"CAP_NET_ADMIN\")\n\tpconfig.Capabilities.Inheritable = append(config.Capabilities.Inheritable, \"CAP_NET_ADMIN\")\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputStatus := stdout.String()\n\n\tlines := strings.Split(outputStatus, \"\\n\")\n\n\teffectiveCapsLine := \"\"\n\tfor _, l := range lines {\n\t\tline := strings.TrimSpace(l)\n\t\tif strings.Contains(line, \"CapEff:\") {\n\t\t\teffectiveCapsLine = line\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif effectiveCapsLine == \"\" {\n\t\tt.Fatal(\"Couldn't find effective caps: \", outputStatus)\n\t}\n\n\tparts := strings.Split(effectiveCapsLine, \":\")\n\teffectiveCapsStr := strings.TrimSpace(parts[1])\n\n\teffectiveCaps, err := strconv.ParseUint(effectiveCapsStr, 16, 64)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse effective caps\", err)\n\t}\n\n\tconst netAdminMask = 1 << unix.CAP_NET_ADMIN\n\tif effectiveCaps&netAdminMask != netAdminMask {\n\t\tt.Fatal(\"CAP_NET_ADMIN is not set as expected\")\n\t}\n}\n\nfunc TestAdditionalGroups(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:              \"/\",\n\t\tArgs:             []string{\"sh\", \"-c\", \"id\", \"-Gn\"},\n\t\tEnv:              standardEnvironment,\n\t\tStdin:            nil,\n\t\tStdout:           &stdout,\n\t\tAdditionalGroups: []string{\"plugdev\", \"audio\"},\n\t\tInit:             true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputGroups := stdout.String()\n\n\t// Check that the groups output has the groups that we specified\n\tif !strings.Contains(outputGroups, \"audio\") {\n\t\tt.Fatalf(\"Listed groups do not contain the audio group as expected: %v\", outputGroups)\n\t}\n\n\tif !strings.Contains(outputGroups, \"plugdev\") {\n\t\tt.Fatalf(\"Listed groups do not contain the plugdev group as expected: %v\", outputGroups)\n\t}\n}\n\nfunc TestFreeze(t *testing.T) {\n\tfor _, systemd := range []bool{true, false} {\n\t\tfor _, set := range []bool{true, false} {\n\t\t\tname := \"\"\n\t\t\tif systemd {\n\t\t\t\tname += \"Systemd\"\n\t\t\t} else {\n\t\t\t\tname += \"FS\"\n\t\t\t}\n\t\t\tif set {\n\t\t\t\tname += \"ViaSet\"\n\t\t\t} else {\n\t\t\t\tname += \"ViaPauseResume\"\n\t\t\t}\n\t\t\tt.Run(name, func(t *testing.T) {\n\t\t\t\ttestFreeze(t, systemd, set)\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc testFreeze(t *testing.T, withSystemd bool, useSet bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif withSystemd && !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: withSystemd})\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\terr = container.Run(pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\n\tif !useSet {\n\t\terr = container.Pause()\n\t} else {\n\t\tconfig.Cgroups.Resources.Freezer = configs.Frozen\n\t\terr = container.Set(*config)\n\t}\n\tok(t, err)\n\n\tstate, err := container.Status()\n\tok(t, err)\n\tif state != libcontainer.Paused {\n\t\tt.Fatal(\"Unexpected state: \", state)\n\t}\n\n\tif !useSet {\n\t\terr = container.Resume()\n\t} else {\n\t\tconfig.Cgroups.Resources.Freezer = configs.Thawed\n\t\terr = container.Set(*config)\n\t}\n\tok(t, err)\n\n\t_ = stdinW.Close()\n\twaitProcess(pconfig, t)\n}\n\nfunc TestCpuShares(t *testing.T) {\n\ttestCpuShares(t, false)\n}\n\nfunc TestCpuSharesSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestCpuShares(t, true)\n}\n\nfunc testCpuShares(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tt.Skip(\"cgroup v2 does not support CpuShares\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.CpuShares = 1\n\n\tif _, _, err := runContainer(t, config, \"ps\"); err == nil {\n\t\tt.Fatalf(\"runContainer should failed with invalid CpuShares\")\n\t}\n}\n\nfunc TestPids(t *testing.T) {\n\ttestPids(t, false)\n}\n\nfunc TestPidsSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestPids(t, true)\n}\n\nfunc testPids(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.PidsLimit = -1\n\n\t// Running multiple processes.\n\t_, ret, err := runContainer(t, config, \"/bin/sh\", \"-c\", \"/bin/true | /bin/true | /bin/true | /bin/true\")\n\tok(t, err)\n\n\tif ret != 0 {\n\t\tt.Fatalf(\"expected fork() to succeed with no pids limit\")\n\t}\n\n\t// Enforce a permissive limit. This needs to be fairly hand-wavey due to the\n\t// issues with running Go binaries with pids restrictions (see below).\n\tconfig.Cgroups.Resources.PidsLimit = 64\n\t_, ret, err = runContainer(t, config, \"/bin/sh\", \"-c\", `\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true`)\n\tok(t, err)\n\n\tif ret != 0 {\n\t\tt.Fatalf(\"expected fork() to succeed with permissive pids limit\")\n\t}\n\n\t// Enforce a restrictive limit. 64 * /bin/true + 1 * shell should cause this\n\t// to fail reliability.\n\tconfig.Cgroups.Resources.PidsLimit = 64\n\tout, _, err := runContainer(t, config, \"/bin/sh\", \"-c\", `\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true`)\n\tif err != nil && !strings.Contains(out.String(), \"sh: can't fork\") {\n\t\tt.Fatal(err)\n\t}\n\n\tif err == nil {\n\t\tt.Fatal(\"expected fork() to fail with restrictive pids limit\")\n\t}\n\n\t// Minimal restrictions are not really supported, due to quirks in using Go\n\t// due to the fact that it spawns random processes. While we do our best with\n\t// late setting cgroup values, it's just too unreliable with very small pids.max.\n\t// As such, we don't test that case. YMMV.\n}\n\nfunc TestCgroupResourcesUnifiedErrorOnV1(t *testing.T) {\n\ttestCgroupResourcesUnifiedErrorOnV1(t, false)\n}\n\nfunc TestCgroupResourcesUnifiedErrorOnV1Systemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestCgroupResourcesUnifiedErrorOnV1(t, true)\n}\n\nfunc testCgroupResourcesUnifiedErrorOnV1(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tt.Skip(\"requires cgroup v1\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.Unified = map[string]string{\n\t\t\"memory.min\": \"10240\",\n\t}\n\t_, _, err := runContainer(t, config, \"true\")\n\tif !strings.Contains(err.Error(), cgroups.ErrV1NoUnified.Error()) {\n\t\tt.Fatalf(\"expected error to contain %v, got %v\", cgroups.ErrV1NoUnified, err)\n\t}\n}\n\nfunc TestCgroupResourcesUnified(t *testing.T) {\n\ttestCgroupResourcesUnified(t, false)\n}\n\nfunc TestCgroupResourcesUnifiedSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestCgroupResourcesUnified(t, true)\n}\n\nfunc testCgroupResourcesUnified(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif !cgroups.IsCgroup2UnifiedMode() {\n\t\tt.Skip(\"requires cgroup v2\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.Memory = 536870912     // 512M\n\tconfig.Cgroups.Resources.MemorySwap = 536870912 // 512M, i.e. no swap\n\tconfig.Namespaces.Add(configs.NEWCGROUP, \"\")\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tcfg      map[string]string\n\t\texpError string\n\t\tcmd      []string\n\t\texp      string\n\t}{\n\t\t{\n\t\t\tname: \"dummy\",\n\t\t\tcmd:  []string{\"true\"},\n\t\t\texp:  \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"set memory.min\",\n\t\t\tcfg:  map[string]string{\"memory.min\": \"131072\"},\n\t\t\tcmd:  []string{\"cat\", \"/sys/fs/cgroup/memory.min\"},\n\t\t\texp:  \"131072\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"check memory.max\",\n\t\t\tcmd:  []string{\"cat\", \"/sys/fs/cgroup/memory.max\"},\n\t\t\texp:  strconv.Itoa(int(config.Cgroups.Resources.Memory)) + \"\\n\",\n\t\t},\n\n\t\t{\n\t\t\tname: \"overwrite memory.max\",\n\t\t\tcfg:  map[string]string{\"memory.max\": \"268435456\"},\n\t\t\tcmd:  []string{\"cat\", \"/sys/fs/cgroup/memory.max\"},\n\t\t\texp:  \"268435456\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no such controller error\",\n\t\t\tcfg:      map[string]string{\"privet.vsem\": \"vam\"},\n\t\t\texpError: \"controller \\\"privet\\\" not available\",\n\t\t},\n\t\t{\n\t\t\tname:     \"slash in key error\",\n\t\t\tcfg:      map[string]string{\"bad/key\": \"val\"},\n\t\t\texpError: \"must be a file name (no slashes)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no dot in key error\",\n\t\t\tcfg:      map[string]string{\"badkey\": \"val\"},\n\t\t\texpError: \"must be in the form CONTROLLER.PARAMETER\",\n\t\t},\n\t\t{\n\t\t\tname:     \"read-only parameter\",\n\t\t\tcfg:      map[string]string{\"pids.current\": \"42\"},\n\t\t\texpError: \"failed to write\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tconfig.Cgroups.Resources.Unified = tc.cfg\n\t\tbuffers, ret, err := runContainer(t, config, tc.cmd...)\n\t\tif tc.expError != \"\" {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"case %q failed: expected error, got nil\", tc.name)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), tc.expError) {\n\t\t\t\tt.Errorf(\"case %q failed: expected error to contain %q, got %q\", tc.name, tc.expError, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"case %q failed: expected no error, got %v (command: %v, status: %d, stderr: %q)\",\n\t\t\t\ttc.name, err, tc.cmd, ret, buffers.Stderr.String())\n\t\t\tcontinue\n\t\t}\n\t\tif tc.exp != \"\" {\n\t\t\tout := buffers.Stdout.String()\n\t\t\tif out != tc.exp {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.exp, out)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestContainerState(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces = configs.Namespaces([]configs.Namespace{\n\t\t{Type: configs.NEWNS},\n\t\t{Type: configs.NEWUTS},\n\t\t// host for IPC\n\t\t//{Type: configs.NEWIPC},\n\t\t{Type: configs.NEWPID},\n\t\t{Type: configs.NEWNET},\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tp := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\terr = container.Run(p)\n\tok(t, err)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\n\tst, err := container.State()\n\tok(t, err)\n\n\tl1, err := os.Readlink(st.NamespacePaths[configs.NEWIPC])\n\tok(t, err)\n\tif l1 != l {\n\t\tt.Fatal(\"Container using non-host ipc namespace\")\n\t}\n\t_ = stdinW.Close()\n\twaitProcess(p, t)\n}\n\nfunc TestPassExtraFiles(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpipeout1, pipein1, err := os.Pipe()\n\tok(t, err)\n\tpipeout2, pipein2, err := os.Pipe()\n\tok(t, err)\n\tprocess := libcontainer.Process{\n\t\tCwd:        \"/\",\n\t\tArgs:       []string{\"sh\", \"-c\", \"cd /proc/$$/fd; echo -n *; echo -n 1 >3; echo -n 2 >4\"},\n\t\tEnv:        []string{\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"},\n\t\tExtraFiles: []*os.File{pipein1, pipein2},\n\t\tStdin:      nil,\n\t\tStdout:     &stdout,\n\t\tInit:       true,\n\t}\n\terr = container.Run(&process)\n\tok(t, err)\n\n\twaitProcess(&process, t)\n\n\tout := stdout.String()\n\t// fd 5 is the directory handle for /proc/$$/fd\n\tif out != \"0 1 2 3 4 5\" {\n\t\tt.Fatalf(\"expected to have the file descriptors '0 1 2 3 4 5' passed to init, got '%s'\", out)\n\t}\n\tbuf := []byte{0}\n\t_, err = pipeout1.Read(buf)\n\tok(t, err)\n\tout1 := string(buf)\n\tif out1 != \"1\" {\n\t\tt.Fatalf(\"expected first pipe to receive '1', got '%s'\", out1)\n\t}\n\n\t_, err = pipeout2.Read(buf)\n\tok(t, err)\n\tout2 := string(buf)\n\tif out2 != \"2\" {\n\t\tt.Fatalf(\"expected second pipe to receive '2', got '%s'\", out2)\n\t}\n}\n\nfunc TestSysctl(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Sysctl = map[string]string{\n\t\t\"kernel.shmmni\": \"8192\",\n\t\t\"kernel/shmmax\": \"4194304\",\n\t}\n\tconst (\n\t\tcmd = \"cat shmmni shmmax\"\n\t\texp = \"8192\\n4194304\\n\"\n\t)\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/proc/sys/kernel\",\n\t\tArgs:   []string{\"sh\", \"-c\", cmd},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\tout := stdout.String()\n\tif out != exp {\n\t\tt.Fatalf(\"expected %s, got %s\", exp, out)\n\t}\n}\n\nfunc TestMountCgroupRO(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"mount\")\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %s\", buffers, err)\n\t}\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\tmountInfo := buffers.Stdout.String()\n\tlines := strings.Split(mountInfo, \"\\n\")\n\tfor _, l := range lines {\n\t\tif strings.HasPrefix(l, \"tmpfs on /sys/fs/cgroup\") {\n\t\t\tif !strings.Contains(l, \"ro\") ||\n\t\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'ro,nosuid,nodev,noexec': %s\", l)\n\t\t\t}\n\t\t\tif !strings.Contains(l, \"mode=755\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'mode=755': %s\", l)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.HasPrefix(l, \"cgroup\") {\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.Contains(l, \"ro\") ||\n\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\tt.Fatalf(\"Mode expected to contain 'ro,nosuid,nodev,noexec': %s\", l)\n\t\t}\n\t}\n}\n\nfunc TestMountCgroupRW(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\t// clear the RO flag from cgroup mount\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"cgroup\" {\n\t\t\tm.Flags = defaultMountFlags\n\t\t\tbreak\n\t\t}\n\t}\n\n\tbuffers, exitCode, err := runContainer(t, config, \"mount\")\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %s\", buffers, err)\n\t}\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\tmountInfo := buffers.Stdout.String()\n\tlines := strings.Split(mountInfo, \"\\n\")\n\tfor _, l := range lines {\n\t\tif strings.HasPrefix(l, \"tmpfs on /sys/fs/cgroup\") {\n\t\t\tif !strings.Contains(l, \"rw\") ||\n\t\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'rw,nosuid,nodev,noexec': %s\", l)\n\t\t\t}\n\t\t\tif !strings.Contains(l, \"mode=755\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'mode=755': %s\", l)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.HasPrefix(l, \"cgroup\") {\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.Contains(l, \"rw\") ||\n\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\tt.Fatalf(\"Mode expected to contain 'rw,nosuid,nodev,noexec': %s\", l)\n\t\t}\n\t}\n}\n\nfunc TestOomScoreAdj(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.OomScoreAdj = ptrInt(200)\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"cat /proc/self/oom_score_adj\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\toutputOomScoreAdj := strings.TrimSpace(stdout.String())\n\n\t// Check that the oom_score_adj matches the value that was set as part of config.\n\tif outputOomScoreAdj != strconv.Itoa(*config.OomScoreAdj) {\n\t\tt.Fatalf(\"Expected oom_score_adj %d; got %q\", *config.OomScoreAdj, outputOomScoreAdj)\n\t}\n}\n\nfunc TestHook(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\texpectedBundle := t.TempDir()\n\tconfig.Labels = append(config.Labels, \"bundle=\"+expectedBundle)\n\n\tgetRootfsFromBundle := func(bundle string) (string, error) {\n\t\tf, err := os.Open(filepath.Join(bundle, \"config.json\"))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tvar config configs.Config\n\t\tif err = json.NewDecoder(f).Decode(&config); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn config.Rootfs, nil\n\t}\n\tcreateFileFromBundle := func(filename, bundle string) error {\n\t\troot, err := getRootfsFromBundle(bundle)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tf, err := os.Create(filepath.Join(root, filename))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn f.Close()\n\t}\n\n\t// Note FunctionHooks can't be serialized to json this means they won't be passed down to the container\n\t// For CreateContainer and StartContainer which run in the container namespace, this means we need to pass Command Hooks.\n\thookFiles := map[configs.HookName]string{\n\t\tconfigs.Prestart:        \"prestart\",\n\t\tconfigs.CreateRuntime:   \"createRuntime\",\n\t\tconfigs.CreateContainer: \"createContainer\",\n\t\tconfigs.StartContainer:  \"startContainer\",\n\t\tconfigs.Poststart:       \"poststart\",\n\t}\n\n\tconfig.Hooks = configs.Hooks{\n\t\tconfigs.Prestart: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected prestart hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\t\t\t\treturn createFileFromBundle(hookFiles[configs.Prestart], s.Bundle)\n\t\t\t}),\n\t\t},\n\t\tconfigs.CreateRuntime: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected createRuntime hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\t\t\t\treturn createFileFromBundle(hookFiles[configs.CreateRuntime], s.Bundle)\n\t\t\t}),\n\t\t},\n\t\tconfigs.CreateContainer: configs.HookList{\n\t\t\tconfigs.NewCommandHook(configs.Command{\n\t\t\t\tPath: \"/bin/bash\",\n\t\t\t\tArgs: []string{\"/bin/bash\", \"-c\", fmt.Sprintf(\"touch ./%s\", hookFiles[configs.CreateContainer])},\n\t\t\t}),\n\t\t},\n\t\tconfigs.StartContainer: configs.HookList{\n\t\t\tconfigs.NewCommandHook(configs.Command{\n\t\t\t\tPath: \"/bin/sh\",\n\t\t\t\tArgs: []string{\"/bin/sh\", \"-c\", fmt.Sprintf(\"touch /%s\", hookFiles[configs.StartContainer])},\n\t\t\t}),\n\t\t},\n\t\tconfigs.Poststart: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected poststart hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\t\t\t\treturn createFileFromBundle(hookFiles[configs.Poststart], s.Bundle)\n\t\t\t}),\n\t\t},\n\t\tconfigs.Poststop: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected poststop hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\n\t\t\t\troot, err := getRootfsFromBundle(s.Bundle)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tfor _, hook := range hookFiles {\n\t\t\t\t\tif err = os.RemoveAll(filepath.Join(root, hook)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t},\n\t}\n\n\t// write config of json format into config.json under bundle\n\tf, err := os.OpenFile(filepath.Join(expectedBundle, \"config.json\"), os.O_CREATE|os.O_RDWR, 0o644)\n\tok(t, err)\n\tok(t, json.NewEncoder(f).Encode(config))\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\n\t// e.g: 'ls /prestart ...'\n\tcmd := \"ls \"\n\tfor _, hook := range hookFiles {\n\t\tcmd += \"/\" + hook + \" \"\n\t}\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", cmd},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\tif err := container.Destroy(); err != nil {\n\t\tt.Fatalf(\"container destroy %s\", err)\n\t}\n\n\tfor _, hook := range []string{\"prestart\", \"createRuntime\", \"poststart\"} {\n\t\tfi, err := os.Stat(filepath.Join(config.Rootfs, hook))\n\t\tif err == nil || !os.IsNotExist(err) {\n\t\t\tt.Fatalf(\"expected file '%s to not exists, but it does\", fi.Name())\n\t\t}\n\t}\n}\n\nfunc TestSTDIOPermissions(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"sh\", \"-c\", \"echo hi > /dev/stderr\")\n\tok(t, err)\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stderr.String(), \"\\n\"); actual != \"hi\" {\n\t\tt.Fatalf(\"stderr should equal be equal %q %q\", actual, \"hi\")\n\t}\n}\n\nfunc unmountOp(path string) {\n\t_ = unix.Unmount(path, unix.MNT_DETACH)\n}\n\n// Launch container with rootfsPropagation in rslave mode. Also\n// bind mount a volume /mnt1host at /mnt1cont at the time of launch. Now do\n// another mount on host (/mnt1host/mnt2host) and this new mount should\n// propagate to container (/mnt1cont/mnt2host)\nfunc TestRootfsPropagationSlaveMount(t *testing.T) {\n\tvar mountPropagated bool\n\tvar dir1cont string\n\tvar dir2cont string\n\n\tdir1cont = \"/root/mnt1cont\"\n\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.RootPropagation = unix.MS_SLAVE | unix.MS_REC\n\n\t// Bind mount a volume.\n\tdir1host := t.TempDir()\n\n\t// Make this dir a \"shared\" mount point. This will make sure a\n\t// slave relationship can be established in container.\n\terr := unix.Mount(dir1host, dir1host, \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n\tok(t, err)\n\terr = unix.Mount(\"\", dir1host, \"\", unix.MS_SHARED|unix.MS_REC, \"\")\n\tok(t, err)\n\tdefer unmountOp(dir1host)\n\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      dir1host,\n\t\tDestination: dir1cont,\n\t\tDevice:      \"bind\",\n\t\tFlags:       unix.MS_BIND | unix.MS_REC,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\n\terr = container.Run(pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// Create mnt2host under dir1host and bind mount itself on top of it.\n\t// This should be visible in container.\n\tdir2host := filepath.Join(dir1host, \"mnt2host\")\n\terr = os.Mkdir(dir2host, 0o700)\n\tok(t, err)\n\tdefer remove(dir2host)\n\n\terr = unix.Mount(dir2host, dir2host, \"bind\", unix.MS_BIND, \"\")\n\tdefer unmountOp(dir2host)\n\tok(t, err)\n\n\t// Run \"cat /proc/self/mountinfo\" in container and look at mount points.\n\tvar stdout2 bytes.Buffer\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig2 := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"cat\", \"/proc/self/mountinfo\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  stdinR2,\n\t\tStdout: &stdout2,\n\t}\n\n\terr = container.Run(pconfig2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\t_ = stdinW2.Close()\n\twaitProcess(pconfig2, t)\n\t_ = stdinW.Close()\n\twaitProcess(pconfig, t)\n\n\tmountPropagated = false\n\tdir2cont = filepath.Join(dir1cont, filepath.Base(dir2host))\n\n\tpropagationInfo := stdout2.String()\n\tlines := strings.Split(propagationInfo, \"\\n\")\n\tfor _, l := range lines {\n\t\tlinefields := strings.Split(l, \" \")\n\t\tif len(linefields) < 5 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif linefields[4] == dir2cont {\n\t\t\tmountPropagated = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif mountPropagated != true {\n\t\tt.Fatalf(\"Mount on host %s did not propagate in container at %s\\n\", dir2host, dir2cont)\n\t}\n}\n\n// Launch container with rootfsPropagation 0 so no propagation flags are\n// applied. Also bind mount a volume /mnt1host at /mnt1cont at the time of\n// launch. Now do a mount in container (/mnt1cont/mnt2cont) and this new\n// mount should propagate to host (/mnt1host/mnt2cont)\n\nfunc TestRootfsPropagationSharedMount(t *testing.T) {\n\tvar dir1cont string\n\tvar dir2cont string\n\n\tdir1cont = \"/root/mnt1cont\"\n\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.RootPropagation = unix.MS_PRIVATE\n\n\t// Bind mount a volume.\n\tdir1host := t.TempDir()\n\n\t// Make this dir a \"shared\" mount point. This will make sure a\n\t// shared relationship can be established in container.\n\terr := unix.Mount(dir1host, dir1host, \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n\tok(t, err)\n\terr = unix.Mount(\"\", dir1host, \"\", unix.MS_SHARED|unix.MS_REC, \"\")\n\tok(t, err)\n\tdefer unmountOp(dir1host)\n\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      dir1host,\n\t\tDestination: dir1cont,\n\t\tDevice:      \"bind\",\n\t\tFlags:       unix.MS_BIND | unix.MS_REC,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\n\terr = container.Run(pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// Create mnt2cont under dir1host. This will become visible inside container\n\t// at mnt1cont/mnt2cont. Bind mount itself on top of it. This\n\t// should be visible on host now.\n\tdir2host := filepath.Join(dir1host, \"mnt2cont\")\n\terr = os.Mkdir(dir2host, 0o700)\n\tok(t, err)\n\tdefer remove(dir2host)\n\n\tdir2cont = filepath.Join(dir1cont, filepath.Base(dir2host))\n\n\t// Mount something in container and see if it is visible on host.\n\tvar stdout2 bytes.Buffer\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig2 := &libcontainer.Process{\n\t\tCwd:          \"/\",\n\t\tArgs:         []string{\"mount\", \"--bind\", dir2cont, dir2cont},\n\t\tEnv:          standardEnvironment,\n\t\tStdin:        stdinR2,\n\t\tStdout:       &stdout2,\n\t\tCapabilities: &configs.Capabilities{},\n\t}\n\n\t// Provide CAP_SYS_ADMIN\n\tpconfig2.Capabilities.Bounding = append(config.Capabilities.Bounding, \"CAP_SYS_ADMIN\")\n\tpconfig2.Capabilities.Permitted = append(config.Capabilities.Permitted, \"CAP_SYS_ADMIN\")\n\tpconfig2.Capabilities.Effective = append(config.Capabilities.Effective, \"CAP_SYS_ADMIN\")\n\tpconfig2.Capabilities.Inheritable = append(config.Capabilities.Inheritable, \"CAP_SYS_ADMIN\")\n\n\terr = container.Run(pconfig2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// Wait for process\n\t_ = stdinW2.Close()\n\twaitProcess(pconfig2, t)\n\t_ = stdinW.Close()\n\twaitProcess(pconfig, t)\n\n\tdefer unmountOp(dir2host)\n\n\t// Check if mount is visible on host or not.\n\tout, err := exec.Command(\"findmnt\", \"-n\", \"-f\", \"-oTARGET\", dir2host).CombinedOutput()\n\touttrim := string(bytes.TrimSpace(out))\n\tif err != nil {\n\t\tt.Logf(\"findmnt error %q: %q\", err, outtrim)\n\t}\n\n\tif outtrim != dir2host {\n\t\tt.Fatalf(\"Mount in container on %s did not propagate to host on %s. finmnt output=%s\", dir2cont, dir2host, outtrim)\n\t}\n}\n\nfunc TestPIDHost(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/pid\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Remove(configs.NEWPID)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/pid\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"ipc link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestPIDHostInitProcessWait(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tpidns := \"/proc/1/ns/pid\"\n\n\t// Run a container with two long-running processes.\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWPID, pidns)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer func() {\n\t\t_ = container.Destroy()\n\t}()\n\n\tprocess1 := &libcontainer.Process{\n\t\tCwd:  \"/\",\n\t\tArgs: []string{\"sleep\", \"100\"},\n\t\tEnv:  standardEnvironment,\n\t\tInit: true,\n\t}\n\terr = container.Run(process1)\n\tok(t, err)\n\n\tprocess2 := &libcontainer.Process{\n\t\tCwd:  \"/\",\n\t\tArgs: []string{\"sleep\", \"100\"},\n\t\tEnv:  standardEnvironment,\n\t\tInit: false,\n\t}\n\terr = container.Run(process2)\n\tok(t, err)\n\n\t// Kill the init process and Wait for it.\n\terr = process1.Signal(syscall.SIGKILL)\n\tok(t, err)\n\t_, err = process1.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"expected Wait to indicate failure\")\n\t}\n\n\t// The non-init process must've been killed.\n\terr = process2.Signal(syscall.Signal(0))\n\tif err == nil || err.Error() != \"no such process\" {\n\t\tt.Fatalf(\"expected process to have been killed: %v\", err)\n\t}\n}\n\nfunc TestInitJoinPID(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\t// Execute a long-running container\n\tconfig1 := newTemplateConfig(t, nil)\n\tcontainer1, err := newContainer(t, config1)\n\tok(t, err)\n\tdefer destroyContainer(container1)\n\n\tstdinR1, stdinW1, err := os.Pipe()\n\tok(t, err)\n\tinit1 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR1,\n\t\tInit:  true,\n\t}\n\terr = container1.Run(init1)\n\t_ = stdinR1.Close()\n\tdefer stdinW1.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// get the state of the first container\n\tstate1, err := container1.State()\n\tok(t, err)\n\tpidns1 := state1.NamespacePaths[configs.NEWPID]\n\n\t// Run a container inside the existing pidns but with different cgroups\n\tconfig2 := newTemplateConfig(t, nil)\n\tconfig2.Namespaces.Add(configs.NEWPID, pidns1)\n\tconfig2.Cgroups.Path = \"integration/test2\"\n\tcontainer2, err := newContainer(t, config2)\n\tok(t, err)\n\tdefer destroyContainer(container2)\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\tinit2 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR2,\n\t\tInit:  true,\n\t}\n\terr = container2.Run(init2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\t// get the state of the second container\n\tstate2, err := container2.State()\n\tok(t, err)\n\n\tns1, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/pid\", state1.InitProcessPid))\n\tok(t, err)\n\tns2, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/pid\", state2.InitProcessPid))\n\tok(t, err)\n\tif ns1 != ns2 {\n\t\tt.Errorf(\"pidns(%s), wanted %s\", ns2, ns1)\n\t}\n\n\t// check that namespaces are not the same\n\tif reflect.DeepEqual(state2.NamespacePaths, state1.NamespacePaths) {\n\t\tt.Errorf(\"Namespaces(%v), original %v\", state2.NamespacePaths,\n\t\t\tstate1.NamespacePaths)\n\t}\n\t// check that pidns is joined correctly. The initial container process list\n\t// should contain the second container's init process\n\tbuffers := newStdBuffers()\n\tps := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"ps\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdout: buffers.Stdout,\n\t}\n\terr = container1.Run(ps)\n\tok(t, err)\n\twaitProcess(ps, t)\n\n\t// Stop init processes one by one. Stop the second container should\n\t// not stop the first.\n\t_ = stdinW2.Close()\n\twaitProcess(init2, t)\n\t_ = stdinW1.Close()\n\twaitProcess(init1, t)\n\n\tout := strings.TrimSpace(buffers.Stdout.String())\n\t// output of ps inside the initial PID namespace should have\n\t// 1 line of header,\n\t// 2 lines of init processes,\n\t// 1 line of ps process\n\tif len(strings.Split(out, \"\\n\")) != 4 {\n\t\tt.Errorf(\"unexpected running process, output %q\", out)\n\t}\n}\n\nfunc TestInitJoinNetworkAndUser(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires userns.\")\n\t}\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Execute a long-running container\n\tconfig1 := newTemplateConfig(t, &tParam{userns: true})\n\tcontainer1, err := newContainer(t, config1)\n\tok(t, err)\n\tdefer destroyContainer(container1)\n\n\tstdinR1, stdinW1, err := os.Pipe()\n\tok(t, err)\n\tinit1 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR1,\n\t\tInit:  true,\n\t}\n\terr = container1.Run(init1)\n\t_ = stdinR1.Close()\n\tdefer stdinW1.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// get the state of the first container\n\tstate1, err := container1.State()\n\tok(t, err)\n\tnetns1 := state1.NamespacePaths[configs.NEWNET]\n\tuserns1 := state1.NamespacePaths[configs.NEWUSER]\n\n\t// Run a container inside the existing pidns but with different cgroups.\n\tconfig2 := newTemplateConfig(t, &tParam{userns: true})\n\tconfig2.Namespaces.Add(configs.NEWNET, netns1)\n\tconfig2.Namespaces.Add(configs.NEWUSER, userns1)\n\tconfig2.Cgroups.Path = \"integration/test2\"\n\tcontainer2, err := newContainer(t, config2)\n\tok(t, err)\n\tdefer destroyContainer(container2)\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\tinit2 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR2,\n\t\tInit:  true,\n\t}\n\terr = container2.Run(init2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// get the state of the second container\n\tstate2, err := container2.State()\n\tok(t, err)\n\n\tfor _, ns := range []string{\"net\", \"user\"} {\n\t\tns1, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/%s\", state1.InitProcessPid, ns))\n\t\tok(t, err)\n\t\tns2, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/%s\", state2.InitProcessPid, ns))\n\t\tok(t, err)\n\t\tif ns1 != ns2 {\n\t\t\tt.Errorf(\"%s(%s), wanted %s\", ns, ns2, ns1)\n\t\t}\n\t}\n\n\t// check that namespaces are not the same\n\tif reflect.DeepEqual(state2.NamespacePaths, state1.NamespacePaths) {\n\t\tt.Errorf(\"Namespaces(%v), original %v\", state2.NamespacePaths,\n\t\t\tstate1.NamespacePaths)\n\t}\n\t// Stop init processes one by one. Stop the second container should\n\t// not stop the first.\n\t_ = stdinW2.Close()\n\twaitProcess(init2, t)\n\t_ = stdinW1.Close()\n\twaitProcess(init1, t)\n}\n\nfunc TestTmpfsCopyUp(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      \"tmpfs\",\n\t\tDestination: \"/etc\",\n\t\tDevice:      \"tmpfs\",\n\t\tExtensions:  configs.EXT_COPYUP,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tArgs:   []string{\"ls\", \"/etc/passwd\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputLs := stdout.String()\n\n\t// Check that the ls output has /etc/passwd\n\tif !strings.Contains(outputLs, \"/etc/passwd\") {\n\t\tt.Fatalf(\"/etc/passwd not copied up as expected: %v\", outputLs)\n\t}\n}\n\nfunc TestCGROUPPrivate(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/cgroup\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires cgroupns.\")\n\t}\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/cgroup\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWCGROUP, \"\")\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/cgroup\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual == l {\n\t\tt.Fatalf(\"cgroup link should be private to the container but equals host %q %q\", actual, l)\n\t}\n}\n\nfunc TestCGROUPHost(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/cgroup\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires cgroupns.\")\n\t}\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/cgroup\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/cgroup\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"cgroup link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestFdLeaks(t *testing.T) {\n\ttestFdLeaks(t, false)\n}\n\nfunc TestFdLeaksSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestFdLeaks(t, true)\n}\n\nfunc testFdLeaks(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tpfd, err := os.Open(\"/proc/self/fd\")\n\tok(t, err)\n\tdefer pfd.Close()\n\tfds0, err := pfd.Readdirnames(0)\n\tok(t, err)\n\t_, err = pfd.Seek(0, 0)\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tbuffers, exitCode, err := runContainer(t, config, \"true\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tfds1, err := pfd.Readdirnames(0)\n\tok(t, err)\n\n\tif len(fds1) == len(fds0) {\n\t\treturn\n\t}\n\t// Show the extra opened files.\n\n\texcludedPaths := []string{\n\t\t\"/sys/fs/cgroup\",      // opened once, see prepareOpenat2\n\t\t\"anon_inode:bpf-prog\", // FIXME: see https://github.com/opencontainers/runc/issues/2366#issuecomment-776411392\n\t}\n\n\tcount := 0\nnext_fd:\n\tfor _, fd1 := range fds1 {\n\t\tfor _, fd0 := range fds0 {\n\t\t\tif fd0 == fd1 {\n\t\t\t\tcontinue next_fd\n\t\t\t}\n\t\t}\n\t\tdst, _ := os.Readlink(\"/proc/self/fd/\" + fd1)\n\t\tfor _, ex := range excludedPaths {\n\t\t\tif ex == dst {\n\t\t\t\tcontinue next_fd\n\t\t\t}\n\t\t}\n\n\t\tcount++\n\t\tt.Logf(\"extra fd %s -> %s\", fd1, dst)\n\t}\n\tif count > 0 {\n\t\tt.Fatalf(\"found %d extra fds after container.Run\", count)\n\t}\n}\n\n// Test that a container using user namespaces is able to bind mount a folder\n// that does not have permissions for group/others.\nfunc TestBindMountAndUser(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); errors.Is(err, os.ErrNotExist) {\n\t\tt.Skip(\"userns is unsupported\")\n\t}\n\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\ttemphost := t.TempDir()\n\tdirhost := filepath.Join(temphost, \"inaccessible\", \"dir\")\n\n\terr := os.MkdirAll(dirhost, 0o755)\n\tok(t, err)\n\n\terr = os.WriteFile(filepath.Join(dirhost, \"foo.txt\"), []byte(\"Hello\"), 0o755)\n\tok(t, err)\n\n\t// Make this dir inaccessible to \"group,others\".\n\terr = os.Chmod(filepath.Join(temphost, \"inaccessible\"), 0o700)\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, &tParam{\n\t\tuserns: true,\n\t})\n\n\t// Set HostID to 1000 to avoid DAC_OVERRIDE bypassing the purpose of this test.\n\tconfig.UidMappings[0].HostID = 1000\n\tconfig.GidMappings[0].HostID = 1000\n\n\t// Set the owner of rootfs to the effective IDs in the host to avoid errors\n\t// while creating the folders to perform the mounts.\n\terr = os.Chown(config.Rootfs, 1000, 1000)\n\tok(t, err)\n\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      dirhost,\n\t\tDestination: \"/tmp/mnt1cont\",\n\t\tDevice:      \"bind\",\n\t\tFlags:       unix.MS_BIND | unix.MS_REC,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint: errcheck\n\n\tvar stdout bytes.Buffer\n\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"stat /tmp/mnt1cont/foo.txt\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\twaitProcess(&pconfig, t)\n}\n", "package integration\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/specconv\"\n\t\"golang.org/x/sys/unix\"\n)\n\nvar standardEnvironment = []string{\n\t\"HOME=/root\",\n\t\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n\t\"HOSTNAME=integration\",\n\t\"TERM=xterm\",\n}\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype tParam struct {\n\tuserns  bool\n\tsystemd bool\n}\n\n// newTemplateConfig returns a base template for running a container.\n//\n// It uses a network strategy of just setting a loopback interface\n// and the default setup for devices.\n//\n// If p is nil, a default container is created.\nfunc newTemplateConfig(t *testing.T, p *tParam) *configs.Config {\n\tvar allowedDevices []*devices.Rule\n\tfor _, device := range specconv.AllowedDevices {\n\t\tallowedDevices = append(allowedDevices, &device.Rule)\n\t}\n\tif p == nil {\n\t\tp = &tParam{}\n\t}\n\tconfig := &configs.Config{\n\t\tRootfs: newRootfs(t),\n\t\tCapabilities: &configs.Capabilities{\n\t\t\tBounding: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t\tPermitted: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t\tInheritable: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t\tAmbient: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t\tEffective: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t},\n\t\tNamespaces: configs.Namespaces([]configs.Namespace{\n\t\t\t{Type: configs.NEWNS},\n\t\t\t{Type: configs.NEWUTS},\n\t\t\t{Type: configs.NEWIPC},\n\t\t\t{Type: configs.NEWPID},\n\t\t\t{Type: configs.NEWNET},\n\t\t}),\n\t\tCgroups: &configs.Cgroup{\n\t\t\tSystemd: p.systemd,\n\t\t\tResources: &configs.Resources{\n\t\t\t\tMemorySwappiness: nil,\n\t\t\t\tDevices:          allowedDevices,\n\t\t\t},\n\t\t},\n\t\tMaskPaths: []string{\n\t\t\t\"/proc/kcore\",\n\t\t\t\"/sys/firmware\",\n\t\t},\n\t\tReadonlyPaths: []string{\n\t\t\t\"/proc/sys\", \"/proc/sysrq-trigger\", \"/proc/irq\", \"/proc/bus\",\n\t\t},\n\t\tDevices:  specconv.AllowedDevices,\n\t\tHostname: \"integration\",\n\t\tMounts: []*configs.Mount{\n\t\t\t{\n\t\t\t\tSource:      \"proc\",\n\t\t\t\tDestination: \"/proc\",\n\t\t\t\tDevice:      \"proc\",\n\t\t\t\tFlags:       defaultMountFlags,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:      \"tmpfs\",\n\t\t\t\tDestination: \"/dev\",\n\t\t\t\tDevice:      \"tmpfs\",\n\t\t\t\tFlags:       unix.MS_NOSUID | unix.MS_STRICTATIME,\n\t\t\t\tData:        \"mode=755\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:      \"devpts\",\n\t\t\t\tDestination: \"/dev/pts\",\n\t\t\t\tDevice:      \"devpts\",\n\t\t\t\tFlags:       unix.MS_NOSUID | unix.MS_NOEXEC,\n\t\t\t\tData:        \"newinstance,ptmxmode=0666,mode=0620,gid=5\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tDevice:      \"tmpfs\",\n\t\t\t\tSource:      \"shm\",\n\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\tData:        \"mode=1777,size=65536k\",\n\t\t\t\tFlags:       defaultMountFlags,\n\t\t\t},\n\t\t\t/*\n\t\t\t\t            CI is broken on the debian based kernels with this\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSource:      \"mqueue\",\n\t\t\t\t\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\t\t\t\t\tDevice:      \"mqueue\",\n\t\t\t\t\t\t\t\tFlags:       defaultMountFlags,\n\t\t\t\t\t\t\t},\n\t\t\t*/\n\t\t\t{\n\t\t\t\tSource:      \"sysfs\",\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tDevice:      \"sysfs\",\n\t\t\t\tFlags:       defaultMountFlags | unix.MS_RDONLY,\n\t\t\t},\n\t\t},\n\t\tNetworks: []*configs.Network{\n\t\t\t{\n\t\t\t\tType:    \"loopback\",\n\t\t\t\tAddress: \"127.0.0.1/0\",\n\t\t\t\tGateway: \"localhost\",\n\t\t\t},\n\t\t},\n\t\tRlimits: []configs.Rlimit{\n\t\t\t{\n\t\t\t\tType: unix.RLIMIT_NOFILE,\n\t\t\t\tHard: uint64(1025),\n\t\t\t\tSoft: uint64(1025),\n\t\t\t},\n\t\t},\n\t}\n\n\tif p.userns {\n\t\tconfig.UidMappings = []configs.IDMap{{HostID: 0, ContainerID: 0, Size: 1000}}\n\t\tconfig.GidMappings = []configs.IDMap{{HostID: 0, ContainerID: 0, Size: 1000}}\n\t\tconfig.Namespaces = append(config.Namespaces, configs.Namespace{Type: configs.NEWUSER})\n\t} else {\n\t\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tDevice:      \"cgroup\",\n\t\t\tFlags:       defaultMountFlags | unix.MS_RDONLY,\n\t\t})\n\t}\n\n\tif p.systemd {\n\t\tid := strconv.FormatInt(-int64(time.Now().Nanosecond()), 36)\n\t\tconfig.Cgroups.Name = strings.ReplaceAll(t.Name(), \"/\", \"_\") + id\n\t\tconfig.Cgroups.Parent = \"system.slice\"\n\t\tconfig.Cgroups.ScopePrefix = \"runc-test\"\n\t} else {\n\t\tconfig.Cgroups.Path = \"/test/integration\"\n\t}\n\n\treturn config\n}\n", "package specconv\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\n// Example returns an example spec file, with many options set so a user can\n// see what a standard spec file looks like.\nfunc Example() *specs.Spec {\n\tspec := &specs.Spec{\n\t\tVersion: specs.Version,\n\t\tRoot: &specs.Root{\n\t\t\tPath:     \"rootfs\",\n\t\t\tReadonly: true,\n\t\t},\n\t\tProcess: &specs.Process{\n\t\t\tTerminal: true,\n\t\t\tUser:     specs.User{},\n\t\t\tArgs: []string{\n\t\t\t\t\"sh\",\n\t\t\t},\n\t\t\tEnv: []string{\n\t\t\t\t\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n\t\t\t\t\"TERM=xterm\",\n\t\t\t},\n\t\t\tCwd:             \"/\",\n\t\t\tNoNewPrivileges: true,\n\t\t\tCapabilities: &specs.LinuxCapabilities{\n\t\t\t\tBounding: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t\tPermitted: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t\tInheritable: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t\tAmbient: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t\tEffective: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRlimits: []specs.POSIXRlimit{\n\t\t\t\t{\n\t\t\t\t\tType: \"RLIMIT_NOFILE\",\n\t\t\t\t\tHard: uint64(1024),\n\t\t\t\t\tSoft: uint64(1024),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tHostname: \"runc\",\n\t\tMounts: []specs.Mount{\n\t\t\t{\n\t\t\t\tDestination: \"/proc\",\n\t\t\t\tType:        \"proc\",\n\t\t\t\tSource:      \"proc\",\n\t\t\t\tOptions:     nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"tmpfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"strictatime\", \"mode=755\", \"size=65536k\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/pts\",\n\t\t\t\tType:        \"devpts\",\n\t\t\t\tSource:      \"devpts\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\", \"gid=5\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"shm\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"mode=1777\", \"size=65536k\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\tType:        \"mqueue\",\n\t\t\t\tSource:      \"mqueue\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tType:        \"sysfs\",\n\t\t\t\tSource:      \"sysfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\t\tType:        \"cgroup\",\n\t\t\t\tSource:      \"cgroup\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"ro\"},\n\t\t\t},\n\t\t},\n\t\tLinux: &specs.Linux{\n\t\t\tMaskedPaths: []string{\n\t\t\t\t\"/proc/acpi\",\n\t\t\t\t\"/proc/asound\",\n\t\t\t\t\"/proc/kcore\",\n\t\t\t\t\"/proc/keys\",\n\t\t\t\t\"/proc/latency_stats\",\n\t\t\t\t\"/proc/timer_list\",\n\t\t\t\t\"/proc/timer_stats\",\n\t\t\t\t\"/proc/sched_debug\",\n\t\t\t\t\"/sys/firmware\",\n\t\t\t\t\"/proc/scsi\",\n\t\t\t},\n\t\t\tReadonlyPaths: []string{\n\t\t\t\t\"/proc/bus\",\n\t\t\t\t\"/proc/fs\",\n\t\t\t\t\"/proc/irq\",\n\t\t\t\t\"/proc/sys\",\n\t\t\t\t\"/proc/sysrq-trigger\",\n\t\t\t},\n\t\t\tResources: &specs.LinuxResources{\n\t\t\t\tDevices: []specs.LinuxDeviceCgroup{\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  false,\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tNamespaces: []specs.LinuxNamespace{\n\t\t\t\t{\n\t\t\t\t\tType: specs.PIDNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.NetworkNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.IPCNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.UTSNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.MountNamespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tspec.Linux.Namespaces = append(spec.Linux.Namespaces, specs.LinuxNamespace{\n\t\t\tType: specs.CgroupNamespace,\n\t\t})\n\t}\n\treturn spec\n}\n\n// ToRootless converts the given spec file into one that should work with\n// rootless containers (euid != 0), by removing incompatible options and adding others that\n// are needed.\nfunc ToRootless(spec *specs.Spec) {\n\tvar namespaces []specs.LinuxNamespace\n\n\t// Remove networkns from the spec.\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase specs.NetworkNamespace, specs.UserNamespace:\n\t\t\t// Do nothing.\n\t\tdefault:\n\t\t\tnamespaces = append(namespaces, ns)\n\t\t}\n\t}\n\t// Add userns to the spec.\n\tnamespaces = append(namespaces, specs.LinuxNamespace{\n\t\tType: specs.UserNamespace,\n\t})\n\tspec.Linux.Namespaces = namespaces\n\n\t// Add mappings for the current user.\n\tspec.Linux.UIDMappings = []specs.LinuxIDMapping{{\n\t\tHostID:      uint32(os.Geteuid()),\n\t\tContainerID: 0,\n\t\tSize:        1,\n\t}}\n\tspec.Linux.GIDMappings = []specs.LinuxIDMapping{{\n\t\tHostID:      uint32(os.Getegid()),\n\t\tContainerID: 0,\n\t\tSize:        1,\n\t}}\n\n\t// Fix up mounts.\n\tvar mounts []specs.Mount\n\tfor _, mount := range spec.Mounts {\n\t\t// Replace the /sys mount with an rbind.\n\t\tif filepath.Clean(mount.Destination) == \"/sys\" {\n\t\t\tmounts = append(mounts, specs.Mount{\n\t\t\t\tSource:      \"/sys\",\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tType:        \"none\",\n\t\t\t\tOptions:     []string{\"rbind\", \"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\n\t\t// Remove all gid= and uid= mappings.\n\t\tvar options []string\n\t\tfor _, option := range mount.Options {\n\t\t\tif !strings.HasPrefix(option, \"gid=\") && !strings.HasPrefix(option, \"uid=\") {\n\t\t\t\toptions = append(options, option)\n\t\t\t}\n\t\t}\n\n\t\tmount.Options = options\n\t\tmounts = append(mounts, mount)\n\t}\n\tspec.Mounts = mounts\n\n\t// Remove cgroup settings.\n\tspec.Linux.Resources = nil\n}\n"], "fixing_code": ["package main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/utils\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\t\"github.com/urfave/cli\"\n)\n\nvar execCommand = cli.Command{\n\tName:  \"exec\",\n\tUsage: \"execute new process inside the container\",\n\tArgsUsage: `<container-id> <command> [command options]  || -p process.json <container-id>\n\nWhere \"<container-id>\" is the name for the instance of the container and\n\"<command>\" is the command to be executed in the container.\n\"<command>\" can't be empty unless a \"-p\" flag provided.\n\nEXAMPLE:\nFor example, if the container is configured to run the linux ps command the\nfollowing will output a list of processes running in the container:\n\n       # runc exec <container-id> ps`,\n\tFlags: []cli.Flag{\n\t\tcli.StringFlag{\n\t\t\tName:  \"console-socket\",\n\t\t\tUsage: \"path to an AF_UNIX socket which will receive a file descriptor referencing the master end of the console's pseudoterminal\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"cwd\",\n\t\t\tUsage: \"current working directory in the container\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"env, e\",\n\t\t\tUsage: \"set environment variables\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"tty, t\",\n\t\t\tUsage: \"allocate a pseudo-TTY\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"user, u\",\n\t\t\tUsage: \"UID (format: <uid>[:<gid>])\",\n\t\t},\n\t\tcli.Int64SliceFlag{\n\t\t\tName:  \"additional-gids, g\",\n\t\t\tUsage: \"additional gids\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"process, p\",\n\t\t\tUsage: \"path to the process.json\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"detach,d\",\n\t\t\tUsage: \"detach from the container's process\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"pid-file\",\n\t\t\tValue: \"\",\n\t\t\tUsage: \"specify the file to write the process id to\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"process-label\",\n\t\t\tUsage: \"set the asm process label for the process commonly used with selinux\",\n\t\t},\n\t\tcli.StringFlag{\n\t\t\tName:  \"apparmor\",\n\t\t\tUsage: \"set the apparmor profile for the process\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"no-new-privs\",\n\t\t\tUsage: \"set the no new privileges value for the process\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"cap, c\",\n\t\t\tValue: &cli.StringSlice{},\n\t\t\tUsage: \"add a capability to the bounding set for the process\",\n\t\t},\n\t\tcli.IntFlag{\n\t\t\tName:  \"preserve-fds\",\n\t\t\tUsage: \"Pass N additional file descriptors to the container (stdio + $LISTEN_FDS + N in total)\",\n\t\t},\n\t\tcli.StringSliceFlag{\n\t\t\tName:  \"cgroup\",\n\t\t\tUsage: \"run the process in an (existing) sub-cgroup(s). Format is [<controller>:]<cgroup>.\",\n\t\t},\n\t\tcli.BoolFlag{\n\t\t\tName:  \"ignore-paused\",\n\t\t\tUsage: \"allow exec in a paused container\",\n\t\t},\n\t},\n\tAction: func(context *cli.Context) error {\n\t\tif err := checkArgs(context, 1, minArgs); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := revisePidFile(context); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tstatus, err := execProcess(context)\n\t\tif err == nil {\n\t\t\tos.Exit(status)\n\t\t}\n\t\tfatalWithCode(fmt.Errorf(\"exec failed: %w\", err), 255)\n\t\treturn nil // to satisfy the linter\n\t},\n\tSkipArgReorder: true,\n}\n\nfunc getSubCgroupPaths(args []string) (map[string]string, error) {\n\tif len(args) == 0 {\n\t\treturn nil, nil\n\t}\n\tpaths := make(map[string]string, len(args))\n\tfor _, c := range args {\n\t\t// Split into controller:path.\n\t\tcs := strings.SplitN(c, \":\", 3)\n\t\tif len(cs) > 2 {\n\t\t\treturn nil, fmt.Errorf(\"invalid --cgroup argument: %s\", c)\n\t\t}\n\t\tif len(cs) == 1 { // no controller: prefix\n\t\t\tif len(args) != 1 {\n\t\t\t\treturn nil, fmt.Errorf(\"invalid --cgroup argument: %s (missing <controller>: prefix)\", c)\n\t\t\t}\n\t\t\tpaths[\"\"] = c\n\t\t} else {\n\t\t\t// There may be a few comma-separated controllers.\n\t\t\tfor _, ctrl := range strings.Split(cs[0], \",\") {\n\t\t\t\tpaths[ctrl] = cs[1]\n\t\t\t}\n\t\t}\n\t}\n\treturn paths, nil\n}\n\nfunc execProcess(context *cli.Context) (int, error) {\n\tcontainer, err := getContainer(context)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tstatus, err := container.Status()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tif status == libcontainer.Stopped {\n\t\treturn -1, errors.New(\"cannot exec in a stopped container\")\n\t}\n\tif status == libcontainer.Paused && !context.Bool(\"ignore-paused\") {\n\t\treturn -1, errors.New(\"cannot exec in a paused container (use --ignore-paused to override)\")\n\t}\n\tpath := context.String(\"process\")\n\tif path == \"\" && len(context.Args()) == 1 {\n\t\treturn -1, errors.New(\"process args cannot be empty\")\n\t}\n\tstate, err := container.State()\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\tbundle, ok := utils.SearchLabels(state.Config.Labels, \"bundle\")\n\tif !ok {\n\t\treturn -1, errors.New(\"bundle not found in labels\")\n\t}\n\tp, err := getProcess(context, bundle)\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tcgPaths, err := getSubCgroupPaths(context.StringSlice(\"cgroup\"))\n\tif err != nil {\n\t\treturn -1, err\n\t}\n\n\tr := &runner{\n\t\tenableSubreaper: false,\n\t\tshouldDestroy:   false,\n\t\tcontainer:       container,\n\t\tconsoleSocket:   context.String(\"console-socket\"),\n\t\tdetach:          context.Bool(\"detach\"),\n\t\tpidFile:         context.String(\"pid-file\"),\n\t\taction:          CT_ACT_RUN,\n\t\tinit:            false,\n\t\tpreserveFDs:     context.Int(\"preserve-fds\"),\n\t\tsubCgroupPaths:  cgPaths,\n\t}\n\treturn r.run(p)\n}\n\nfunc getProcess(context *cli.Context, bundle string) (*specs.Process, error) {\n\tif path := context.String(\"process\"); path != \"\" {\n\t\tf, err := os.Open(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tdefer f.Close()\n\t\tvar p specs.Process\n\t\tif err := json.NewDecoder(f).Decode(&p); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn &p, validateProcessSpec(&p)\n\t}\n\t// process via cli flags\n\tif err := os.Chdir(bundle); err != nil {\n\t\treturn nil, err\n\t}\n\tspec, err := loadSpec(specConfig)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tp := spec.Process\n\tp.Args = context.Args()[1:]\n\t// override the cwd, if passed\n\tif context.String(\"cwd\") != \"\" {\n\t\tp.Cwd = context.String(\"cwd\")\n\t}\n\tif ap := context.String(\"apparmor\"); ap != \"\" {\n\t\tp.ApparmorProfile = ap\n\t}\n\tif l := context.String(\"process-label\"); l != \"\" {\n\t\tp.SelinuxLabel = l\n\t}\n\tif caps := context.StringSlice(\"cap\"); len(caps) > 0 {\n\t\tfor _, c := range caps {\n\t\t\tp.Capabilities.Bounding = append(p.Capabilities.Bounding, c)\n\t\t\tp.Capabilities.Effective = append(p.Capabilities.Effective, c)\n\t\t\tp.Capabilities.Permitted = append(p.Capabilities.Permitted, c)\n\t\t\tp.Capabilities.Ambient = append(p.Capabilities.Ambient, c)\n\t\t}\n\t}\n\t// append the passed env variables\n\tp.Env = append(p.Env, context.StringSlice(\"env\")...)\n\n\t// set the tty\n\tp.Terminal = false\n\tif context.IsSet(\"tty\") {\n\t\tp.Terminal = context.Bool(\"tty\")\n\t}\n\tif context.IsSet(\"no-new-privs\") {\n\t\tp.NoNewPrivileges = context.Bool(\"no-new-privs\")\n\t}\n\t// override the user, if passed\n\tif context.String(\"user\") != \"\" {\n\t\tu := strings.SplitN(context.String(\"user\"), \":\", 2)\n\t\tif len(u) > 1 {\n\t\t\tgid, err := strconv.Atoi(u[1])\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"parsing %s as int for gid failed: %w\", u[1], err)\n\t\t\t}\n\t\t\tp.User.GID = uint32(gid)\n\t\t}\n\t\tuid, err := strconv.Atoi(u[0])\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"parsing %s as int for uid failed: %w\", u[0], err)\n\t\t}\n\t\tp.User.UID = uint32(uid)\n\t}\n\tfor _, gid := range context.Int64Slice(\"additional-gids\") {\n\t\tif gid < 0 {\n\t\t\treturn nil, fmt.Errorf(\"additional-gids must be a positive number %d\", gid)\n\t\t}\n\t\tp.User.AdditionalGids = append(p.User.AdditionalGids, uint32(gid))\n\t}\n\treturn p, validateProcessSpec(p)\n}\n", "# libcontainer\n\n[![Go Reference](https://pkg.go.dev/badge/github.com/opencontainers/runc/libcontainer.svg)](https://pkg.go.dev/github.com/opencontainers/runc/libcontainer)\n\nLibcontainer provides a native Go implementation for creating containers\nwith namespaces, cgroups, capabilities, and filesystem access controls.\nIt allows you to manage the lifecycle of the container performing additional operations\nafter the container is created.\n\n\n#### Container\nA container is a self contained execution environment that shares the kernel of the\nhost system and which is (optionally) isolated from other containers in the system.\n\n#### Using libcontainer\n\nBecause containers are spawned in a two step process you will need a binary that\nwill be executed as the init process for the container. In libcontainer, we use\nthe current binary (/proc/self/exe) to be executed as the init process, and use\narg \"init\", we call the first step process \"bootstrap\", so you always need a \"init\"\nfunction as the entry of \"bootstrap\".\n\nIn addition to the go init function the early stage bootstrap is handled by importing\n[nsenter](https://github.com/opencontainers/runc/blob/master/libcontainer/nsenter/README.md).\n\n```go\nimport (\n\t_ \"github.com/opencontainers/runc/libcontainer/nsenter\"\n)\n\nfunc init() {\n\tif len(os.Args) > 1 && os.Args[1] == \"init\" {\n\t\truntime.GOMAXPROCS(1)\n\t\truntime.LockOSThread()\n\t\tif err := libcontainer.StartInitialization(); err != nil {\n\t\t\tlogrus.Fatal(err)\n\t\t}\n\t\tpanic(\"--this line should have never been executed, congratulations--\")\n\t}\n}\n```\n\nThen to create a container you first have to create a configuration\nstruct describing how the container is to be created. A sample would look similar to this:\n\n```go\ndefaultMountFlags := unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\nvar devices []*configs.DeviceRule\nfor _, device := range specconv.AllowedDevices {\n\tdevices = append(devices, &device.Rule)\n}\nconfig := &configs.Config{\n\tRootfs: \"/your/path/to/rootfs\",\n\tCapabilities: &configs.Capabilities{\n\t\tBounding: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t\tEffective: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t\tPermitted: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t\tAmbient: []string{\n\t\t\t\"CAP_CHOWN\",\n\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\"CAP_FSETID\",\n\t\t\t\"CAP_FOWNER\",\n\t\t\t\"CAP_MKNOD\",\n\t\t\t\"CAP_NET_RAW\",\n\t\t\t\"CAP_SETGID\",\n\t\t\t\"CAP_SETUID\",\n\t\t\t\"CAP_SETFCAP\",\n\t\t\t\"CAP_SETPCAP\",\n\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\"CAP_KILL\",\n\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t},\n\t},\n\tNamespaces: configs.Namespaces([]configs.Namespace{\n\t\t{Type: configs.NEWNS},\n\t\t{Type: configs.NEWUTS},\n\t\t{Type: configs.NEWIPC},\n\t\t{Type: configs.NEWPID},\n\t\t{Type: configs.NEWUSER},\n\t\t{Type: configs.NEWNET},\n\t\t{Type: configs.NEWCGROUP},\n\t}),\n\tCgroups: &configs.Cgroup{\n\t\tName:   \"test-container\",\n\t\tParent: \"system\",\n\t\tResources: &configs.Resources{\n\t\t\tMemorySwappiness: nil,\n\t\t\tDevices:          devices,\n\t\t},\n\t},\n\tMaskPaths: []string{\n\t\t\"/proc/kcore\",\n\t\t\"/sys/firmware\",\n\t},\n\tReadonlyPaths: []string{\n\t\t\"/proc/sys\", \"/proc/sysrq-trigger\", \"/proc/irq\", \"/proc/bus\",\n\t},\n\tDevices:  specconv.AllowedDevices,\n\tHostname: \"testing\",\n\tMounts: []*configs.Mount{\n\t\t{\n\t\t\tSource:      \"proc\",\n\t\t\tDestination: \"/proc\",\n\t\t\tDevice:      \"proc\",\n\t\t\tFlags:       defaultMountFlags,\n\t\t},\n\t\t{\n\t\t\tSource:      \"tmpfs\",\n\t\t\tDestination: \"/dev\",\n\t\t\tDevice:      \"tmpfs\",\n\t\t\tFlags:       unix.MS_NOSUID | unix.MS_STRICTATIME,\n\t\t\tData:        \"mode=755\",\n\t\t},\n\t\t{\n\t\t\tSource:      \"devpts\",\n\t\t\tDestination: \"/dev/pts\",\n\t\t\tDevice:      \"devpts\",\n\t\t\tFlags:       unix.MS_NOSUID | unix.MS_NOEXEC,\n\t\t\tData:        \"newinstance,ptmxmode=0666,mode=0620,gid=5\",\n\t\t},\n\t\t{\n\t\t\tDevice:      \"tmpfs\",\n\t\t\tSource:      \"shm\",\n\t\t\tDestination: \"/dev/shm\",\n\t\t\tData:        \"mode=1777,size=65536k\",\n\t\t\tFlags:       defaultMountFlags,\n\t\t},\n\t\t{\n\t\t\tSource:      \"mqueue\",\n\t\t\tDestination: \"/dev/mqueue\",\n\t\t\tDevice:      \"mqueue\",\n\t\t\tFlags:       defaultMountFlags,\n\t\t},\n\t\t{\n\t\t\tSource:      \"sysfs\",\n\t\t\tDestination: \"/sys\",\n\t\t\tDevice:      \"sysfs\",\n\t\t\tFlags:       defaultMountFlags | unix.MS_RDONLY,\n\t\t},\n\t},\n\tUidMappings: []configs.IDMap{\n\t\t{\n\t\t\tContainerID: 0,\n\t\t\tHostID: 1000,\n\t\t\tSize: 65536,\n\t\t},\n\t},\n\tGidMappings: []configs.IDMap{\n\t\t{\n\t\t\tContainerID: 0,\n\t\t\tHostID: 1000,\n\t\t\tSize: 65536,\n\t\t},\n\t},\n\tNetworks: []*configs.Network{\n\t\t{\n\t\t\tType:    \"loopback\",\n\t\t\tAddress: \"127.0.0.1/0\",\n\t\t\tGateway: \"localhost\",\n\t\t},\n\t},\n\tRlimits: []configs.Rlimit{\n\t\t{\n\t\t\tType: unix.RLIMIT_NOFILE,\n\t\t\tHard: uint64(1025),\n\t\t\tSoft: uint64(1025),\n\t\t},\n\t},\n}\n```\n\nOnce you have the configuration populated you can create a container\nwith a specified ID under a specified state directory:\n\n```go\ncontainer, err := libcontainer.Create(\"/run/containers\", \"container-id\", config)\nif err != nil {\n\tlogrus.Fatal(err)\n\treturn\n}\n```\n\nTo spawn bash as the initial process inside the container and have the\nprocesses pid returned in order to wait, signal, or kill the process:\n\n```go\nprocess := &libcontainer.Process{\n\tArgs:   []string{\"/bin/bash\"},\n\tEnv:    []string{\"PATH=/bin\"},\n\tUser:   \"daemon\",\n\tStdin:  os.Stdin,\n\tStdout: os.Stdout,\n\tStderr: os.Stderr,\n\tInit:   true,\n}\n\nerr := container.Run(process)\nif err != nil {\n\tcontainer.Destroy()\n\tlogrus.Fatal(err)\n\treturn\n}\n\n// wait for the process to finish.\n_, err := process.Wait()\nif err != nil {\n\tlogrus.Fatal(err)\n}\n\n// destroy the container.\ncontainer.Destroy()\n```\n\nAdditional ways to interact with a running container are:\n\n```go\n// return all the pids for all processes running inside the container.\nprocesses, err := container.Processes()\n\n// get detailed cpu, memory, io, and network statistics for the container and\n// it's processes.\nstats, err := container.Stats()\n\n// pause all processes inside the container.\ncontainer.Pause()\n\n// resume all paused processes.\ncontainer.Resume()\n\n// send signal to container's init process.\ncontainer.Signal(signal)\n\n// update container resource constraints.\ncontainer.Set(config)\n\n// get current status of the container.\nstatus, err := container.Status()\n\n// get current container's state information.\nstate, err := container.State()\n```\n\n\n#### Checkpoint & Restore\n\nlibcontainer now integrates [CRIU](http://criu.org/) for checkpointing and restoring containers.\nThis lets you save the state of a process running inside a container to disk, and then restore\nthat state into a new process, on the same machine or on another machine.\n\n`criu` version 1.5.2 or higher is required to use checkpoint and restore.\nIf you don't already  have `criu` installed, you can build it from source, following the\n[online instructions](http://criu.org/Installation). `criu` is also installed in the docker image\ngenerated when building libcontainer with docker.\n\n\n## Copyright and license\n\nCode and documentation copyright 2014 Docker, inc.\nThe code and documentation are released under the [Apache 2.0 license](../LICENSE).\nThe documentation is also released under Creative Commons Attribution 4.0 International License.\nYou may obtain a copy of the license, titled CC-BY-4.0, at http://creativecommons.org/licenses/by/4.0/.\n", "package integration\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path/filepath\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n\t\"syscall\"\n\t\"testing\"\n\n\t\"github.com/opencontainers/runc/libcontainer\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runc/libcontainer/cgroups/systemd\"\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n\n\t\"golang.org/x/sys/unix\"\n)\n\nfunc TestExecPS(t *testing.T) {\n\ttestExecPS(t, false)\n}\n\nfunc TestUsernsExecPS(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires userns.\")\n\t}\n\ttestExecPS(t, true)\n}\n\nfunc testExecPS(t *testing.T, userns bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, &tParam{userns: userns})\n\n\tbuffers, exitCode, err := runContainer(t, config, \"ps\", \"-o\", \"pid,user,comm\")\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %s\", buffers, err)\n\t}\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\tlines := strings.Split(buffers.Stdout.String(), \"\\n\")\n\tif len(lines) < 2 {\n\t\tt.Fatalf(\"more than one process running for output %q\", buffers.Stdout.String())\n\t}\n\texpected := `1 root     ps`\n\tactual := strings.Trim(lines[1], \"\\n \")\n\tif actual != expected {\n\t\tt.Fatalf(\"expected output %q but received %q\", expected, actual)\n\t}\n}\n\nfunc TestIPCPrivate(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/ipc\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual == l {\n\t\tt.Fatalf(\"ipc link should be private to the container but equals host %q %q\", actual, l)\n\t}\n}\n\nfunc TestIPCHost(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Remove(configs.NEWIPC)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/ipc\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"ipc link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestIPCJoinPath(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWIPC, \"/proc/1/ns/ipc\")\n\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/ipc\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"ipc link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestIPCBadPath(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWIPC, \"/proc/1/ns/ipcc\")\n\n\tif _, _, err := runContainer(t, config, \"true\"); err == nil {\n\t\tt.Fatal(\"container succeeded with bad ipc path\")\n\t}\n}\n\nfunc TestRlimit(t *testing.T) {\n\ttestRlimit(t, false)\n}\n\nfunc TestUsernsRlimit(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires userns.\")\n\t}\n\n\ttestRlimit(t, true)\n}\n\nfunc testRlimit(t *testing.T, userns bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{userns: userns})\n\n\t// ensure limit is lower than what the config requests to test that in a user namespace\n\t// the Setrlimit call happens early enough that we still have permissions to raise the limit.\n\tok(t, unix.Setrlimit(unix.RLIMIT_NOFILE, &unix.Rlimit{\n\t\tMax: 1024,\n\t\tCur: 1024,\n\t}))\n\n\tout, _, err := runContainer(t, config, \"/bin/sh\", \"-c\", \"ulimit -n\")\n\tok(t, err)\n\tif limit := strings.TrimSpace(out.Stdout.String()); limit != \"1025\" {\n\t\tt.Fatalf(\"expected rlimit to be 1025, got %s\", limit)\n\t}\n}\n\nfunc TestEnter(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\t// Execute a first process in the container\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tvar stdout, stdout2 bytes.Buffer\n\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"cat && readlink /proc/self/ns/pid\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  stdinR,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\tpid, err := pconfig.Pid()\n\tok(t, err)\n\n\t// Execute another process in the container\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\tpconfig2 := libcontainer.Process{\n\t\tCwd: \"/\",\n\t\tEnv: standardEnvironment,\n\t}\n\tpconfig2.Args = []string{\"sh\", \"-c\", \"cat && readlink /proc/self/ns/pid\"}\n\tpconfig2.Stdin = stdinR2\n\tpconfig2.Stdout = &stdout2\n\n\terr = container.Run(&pconfig2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\tpid2, err := pconfig2.Pid()\n\tok(t, err)\n\n\tprocesses, err := container.Processes()\n\tok(t, err)\n\n\tn := 0\n\tfor i := range processes {\n\t\tif processes[i] == pid || processes[i] == pid2 {\n\t\t\tn++\n\t\t}\n\t}\n\tif n != 2 {\n\t\tt.Fatal(\"unexpected number of processes\", processes, pid, pid2)\n\t}\n\n\t// Wait processes\n\t_ = stdinW2.Close()\n\twaitProcess(&pconfig2, t)\n\n\t_ = stdinW.Close()\n\twaitProcess(&pconfig, t)\n\n\t// Check that both processes live in the same pidns\n\tpidns := stdout.String()\n\tok(t, err)\n\n\tpidns2 := stdout2.String()\n\tok(t, err)\n\n\tif pidns != pidns2 {\n\t\tt.Fatal(\"The second process isn't in the required pid namespace\", pidns, pidns2)\n\t}\n}\n\nfunc TestProcessEnv(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:  \"/\",\n\t\tArgs: []string{\"sh\", \"-c\", \"env\"},\n\t\tEnv: []string{\n\t\t\t\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n\t\t\t\"HOSTNAME=integration\",\n\t\t\t\"TERM=xterm\",\n\t\t\t\"FOO=BAR\",\n\t\t},\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputEnv := stdout.String()\n\n\t// Check that the environment has the key/value pair we added\n\tif !strings.Contains(outputEnv, \"FOO=BAR\") {\n\t\tt.Fatal(\"Environment doesn't have the expected FOO=BAR key/value pair: \", outputEnv)\n\t}\n\n\t// Make sure that HOME is set\n\tif !strings.Contains(outputEnv, \"HOME=/root\") {\n\t\tt.Fatal(\"Environment doesn't have HOME set: \", outputEnv)\n\t}\n}\n\nfunc TestProcessEmptyCaps(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Capabilities = nil\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"cat /proc/self/status\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputStatus := stdout.String()\n\n\tlines := strings.Split(outputStatus, \"\\n\")\n\n\teffectiveCapsLine := \"\"\n\tfor _, l := range lines {\n\t\tline := strings.TrimSpace(l)\n\t\tif strings.Contains(line, \"CapEff:\") {\n\t\t\teffectiveCapsLine = line\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif effectiveCapsLine == \"\" {\n\t\tt.Fatal(\"Couldn't find effective caps: \", outputStatus)\n\t}\n}\n\nfunc TestProcessCaps(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:          \"/\",\n\t\tArgs:         []string{\"sh\", \"-c\", \"cat /proc/self/status\"},\n\t\tEnv:          standardEnvironment,\n\t\tStdin:        nil,\n\t\tStdout:       &stdout,\n\t\tCapabilities: &configs.Capabilities{},\n\t\tInit:         true,\n\t}\n\tpconfig.Capabilities.Bounding = append(config.Capabilities.Bounding, \"CAP_NET_ADMIN\")\n\tpconfig.Capabilities.Permitted = append(config.Capabilities.Permitted, \"CAP_NET_ADMIN\")\n\tpconfig.Capabilities.Effective = append(config.Capabilities.Effective, \"CAP_NET_ADMIN\")\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputStatus := stdout.String()\n\n\tlines := strings.Split(outputStatus, \"\\n\")\n\n\teffectiveCapsLine := \"\"\n\tfor _, l := range lines {\n\t\tline := strings.TrimSpace(l)\n\t\tif strings.Contains(line, \"CapEff:\") {\n\t\t\teffectiveCapsLine = line\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif effectiveCapsLine == \"\" {\n\t\tt.Fatal(\"Couldn't find effective caps: \", outputStatus)\n\t}\n\n\tparts := strings.Split(effectiveCapsLine, \":\")\n\teffectiveCapsStr := strings.TrimSpace(parts[1])\n\n\teffectiveCaps, err := strconv.ParseUint(effectiveCapsStr, 16, 64)\n\tif err != nil {\n\t\tt.Fatal(\"Could not parse effective caps\", err)\n\t}\n\n\tconst netAdminMask = 1 << unix.CAP_NET_ADMIN\n\tif effectiveCaps&netAdminMask != netAdminMask {\n\t\tt.Fatal(\"CAP_NET_ADMIN is not set as expected\")\n\t}\n}\n\nfunc TestAdditionalGroups(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:              \"/\",\n\t\tArgs:             []string{\"sh\", \"-c\", \"id\", \"-Gn\"},\n\t\tEnv:              standardEnvironment,\n\t\tStdin:            nil,\n\t\tStdout:           &stdout,\n\t\tAdditionalGroups: []string{\"plugdev\", \"audio\"},\n\t\tInit:             true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputGroups := stdout.String()\n\n\t// Check that the groups output has the groups that we specified\n\tif !strings.Contains(outputGroups, \"audio\") {\n\t\tt.Fatalf(\"Listed groups do not contain the audio group as expected: %v\", outputGroups)\n\t}\n\n\tif !strings.Contains(outputGroups, \"plugdev\") {\n\t\tt.Fatalf(\"Listed groups do not contain the plugdev group as expected: %v\", outputGroups)\n\t}\n}\n\nfunc TestFreeze(t *testing.T) {\n\tfor _, systemd := range []bool{true, false} {\n\t\tfor _, set := range []bool{true, false} {\n\t\t\tname := \"\"\n\t\t\tif systemd {\n\t\t\t\tname += \"Systemd\"\n\t\t\t} else {\n\t\t\t\tname += \"FS\"\n\t\t\t}\n\t\t\tif set {\n\t\t\t\tname += \"ViaSet\"\n\t\t\t} else {\n\t\t\t\tname += \"ViaPauseResume\"\n\t\t\t}\n\t\t\tt.Run(name, func(t *testing.T) {\n\t\t\t\ttestFreeze(t, systemd, set)\n\t\t\t})\n\t\t}\n\t}\n}\n\nfunc testFreeze(t *testing.T, withSystemd bool, useSet bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif withSystemd && !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: withSystemd})\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\terr = container.Run(pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\n\tif !useSet {\n\t\terr = container.Pause()\n\t} else {\n\t\tconfig.Cgroups.Resources.Freezer = configs.Frozen\n\t\terr = container.Set(*config)\n\t}\n\tok(t, err)\n\n\tstate, err := container.Status()\n\tok(t, err)\n\tif state != libcontainer.Paused {\n\t\tt.Fatal(\"Unexpected state: \", state)\n\t}\n\n\tif !useSet {\n\t\terr = container.Resume()\n\t} else {\n\t\tconfig.Cgroups.Resources.Freezer = configs.Thawed\n\t\terr = container.Set(*config)\n\t}\n\tok(t, err)\n\n\t_ = stdinW.Close()\n\twaitProcess(pconfig, t)\n}\n\nfunc TestCpuShares(t *testing.T) {\n\ttestCpuShares(t, false)\n}\n\nfunc TestCpuSharesSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestCpuShares(t, true)\n}\n\nfunc testCpuShares(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tt.Skip(\"cgroup v2 does not support CpuShares\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.CpuShares = 1\n\n\tif _, _, err := runContainer(t, config, \"ps\"); err == nil {\n\t\tt.Fatalf(\"runContainer should failed with invalid CpuShares\")\n\t}\n}\n\nfunc TestPids(t *testing.T) {\n\ttestPids(t, false)\n}\n\nfunc TestPidsSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestPids(t, true)\n}\n\nfunc testPids(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.PidsLimit = -1\n\n\t// Running multiple processes.\n\t_, ret, err := runContainer(t, config, \"/bin/sh\", \"-c\", \"/bin/true | /bin/true | /bin/true | /bin/true\")\n\tok(t, err)\n\n\tif ret != 0 {\n\t\tt.Fatalf(\"expected fork() to succeed with no pids limit\")\n\t}\n\n\t// Enforce a permissive limit. This needs to be fairly hand-wavey due to the\n\t// issues with running Go binaries with pids restrictions (see below).\n\tconfig.Cgroups.Resources.PidsLimit = 64\n\t_, ret, err = runContainer(t, config, \"/bin/sh\", \"-c\", `\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true`)\n\tok(t, err)\n\n\tif ret != 0 {\n\t\tt.Fatalf(\"expected fork() to succeed with permissive pids limit\")\n\t}\n\n\t// Enforce a restrictive limit. 64 * /bin/true + 1 * shell should cause this\n\t// to fail reliability.\n\tconfig.Cgroups.Resources.PidsLimit = 64\n\tout, _, err := runContainer(t, config, \"/bin/sh\", \"-c\", `\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true |\n\t/bin/true | /bin/true | /bin/true | /bin/true | /bin/true | /bin/true | bin/true | /bin/true`)\n\tif err != nil && !strings.Contains(out.String(), \"sh: can't fork\") {\n\t\tt.Fatal(err)\n\t}\n\n\tif err == nil {\n\t\tt.Fatal(\"expected fork() to fail with restrictive pids limit\")\n\t}\n\n\t// Minimal restrictions are not really supported, due to quirks in using Go\n\t// due to the fact that it spawns random processes. While we do our best with\n\t// late setting cgroup values, it's just too unreliable with very small pids.max.\n\t// As such, we don't test that case. YMMV.\n}\n\nfunc TestCgroupResourcesUnifiedErrorOnV1(t *testing.T) {\n\ttestCgroupResourcesUnifiedErrorOnV1(t, false)\n}\n\nfunc TestCgroupResourcesUnifiedErrorOnV1Systemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestCgroupResourcesUnifiedErrorOnV1(t, true)\n}\n\nfunc testCgroupResourcesUnifiedErrorOnV1(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tt.Skip(\"requires cgroup v1\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.Unified = map[string]string{\n\t\t\"memory.min\": \"10240\",\n\t}\n\t_, _, err := runContainer(t, config, \"true\")\n\tif !strings.Contains(err.Error(), cgroups.ErrV1NoUnified.Error()) {\n\t\tt.Fatalf(\"expected error to contain %v, got %v\", cgroups.ErrV1NoUnified, err)\n\t}\n}\n\nfunc TestCgroupResourcesUnified(t *testing.T) {\n\ttestCgroupResourcesUnified(t, false)\n}\n\nfunc TestCgroupResourcesUnifiedSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestCgroupResourcesUnified(t, true)\n}\n\nfunc testCgroupResourcesUnified(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tif !cgroups.IsCgroup2UnifiedMode() {\n\t\tt.Skip(\"requires cgroup v2\")\n\t}\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tconfig.Cgroups.Resources.Memory = 536870912     // 512M\n\tconfig.Cgroups.Resources.MemorySwap = 536870912 // 512M, i.e. no swap\n\tconfig.Namespaces.Add(configs.NEWCGROUP, \"\")\n\n\ttestCases := []struct {\n\t\tname     string\n\t\tcfg      map[string]string\n\t\texpError string\n\t\tcmd      []string\n\t\texp      string\n\t}{\n\t\t{\n\t\t\tname: \"dummy\",\n\t\t\tcmd:  []string{\"true\"},\n\t\t\texp:  \"\",\n\t\t},\n\t\t{\n\t\t\tname: \"set memory.min\",\n\t\t\tcfg:  map[string]string{\"memory.min\": \"131072\"},\n\t\t\tcmd:  []string{\"cat\", \"/sys/fs/cgroup/memory.min\"},\n\t\t\texp:  \"131072\\n\",\n\t\t},\n\t\t{\n\t\t\tname: \"check memory.max\",\n\t\t\tcmd:  []string{\"cat\", \"/sys/fs/cgroup/memory.max\"},\n\t\t\texp:  strconv.Itoa(int(config.Cgroups.Resources.Memory)) + \"\\n\",\n\t\t},\n\n\t\t{\n\t\t\tname: \"overwrite memory.max\",\n\t\t\tcfg:  map[string]string{\"memory.max\": \"268435456\"},\n\t\t\tcmd:  []string{\"cat\", \"/sys/fs/cgroup/memory.max\"},\n\t\t\texp:  \"268435456\\n\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no such controller error\",\n\t\t\tcfg:      map[string]string{\"privet.vsem\": \"vam\"},\n\t\t\texpError: \"controller \\\"privet\\\" not available\",\n\t\t},\n\t\t{\n\t\t\tname:     \"slash in key error\",\n\t\t\tcfg:      map[string]string{\"bad/key\": \"val\"},\n\t\t\texpError: \"must be a file name (no slashes)\",\n\t\t},\n\t\t{\n\t\t\tname:     \"no dot in key error\",\n\t\t\tcfg:      map[string]string{\"badkey\": \"val\"},\n\t\t\texpError: \"must be in the form CONTROLLER.PARAMETER\",\n\t\t},\n\t\t{\n\t\t\tname:     \"read-only parameter\",\n\t\t\tcfg:      map[string]string{\"pids.current\": \"42\"},\n\t\t\texpError: \"failed to write\",\n\t\t},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tconfig.Cgroups.Resources.Unified = tc.cfg\n\t\tbuffers, ret, err := runContainer(t, config, tc.cmd...)\n\t\tif tc.expError != \"\" {\n\t\t\tif err == nil {\n\t\t\t\tt.Errorf(\"case %q failed: expected error, got nil\", tc.name)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif !strings.Contains(err.Error(), tc.expError) {\n\t\t\t\tt.Errorf(\"case %q failed: expected error to contain %q, got %q\", tc.name, tc.expError, err)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif err != nil {\n\t\t\tt.Errorf(\"case %q failed: expected no error, got %v (command: %v, status: %d, stderr: %q)\",\n\t\t\t\ttc.name, err, tc.cmd, ret, buffers.Stderr.String())\n\t\t\tcontinue\n\t\t}\n\t\tif tc.exp != \"\" {\n\t\t\tout := buffers.Stdout.String()\n\t\t\tif out != tc.exp {\n\t\t\t\tt.Errorf(\"expected %q, got %q\", tc.exp, out)\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc TestContainerState(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/ipc\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces = configs.Namespaces([]configs.Namespace{\n\t\t{Type: configs.NEWNS},\n\t\t{Type: configs.NEWUTS},\n\t\t// host for IPC\n\t\t//{Type: configs.NEWIPC},\n\t\t{Type: configs.NEWPID},\n\t\t{Type: configs.NEWNET},\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tp := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\terr = container.Run(p)\n\tok(t, err)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\n\tst, err := container.State()\n\tok(t, err)\n\n\tl1, err := os.Readlink(st.NamespacePaths[configs.NEWIPC])\n\tok(t, err)\n\tif l1 != l {\n\t\tt.Fatal(\"Container using non-host ipc namespace\")\n\t}\n\t_ = stdinW.Close()\n\twaitProcess(p, t)\n}\n\nfunc TestPassExtraFiles(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpipeout1, pipein1, err := os.Pipe()\n\tok(t, err)\n\tpipeout2, pipein2, err := os.Pipe()\n\tok(t, err)\n\tprocess := libcontainer.Process{\n\t\tCwd:        \"/\",\n\t\tArgs:       []string{\"sh\", \"-c\", \"cd /proc/$$/fd; echo -n *; echo -n 1 >3; echo -n 2 >4\"},\n\t\tEnv:        []string{\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\"},\n\t\tExtraFiles: []*os.File{pipein1, pipein2},\n\t\tStdin:      nil,\n\t\tStdout:     &stdout,\n\t\tInit:       true,\n\t}\n\terr = container.Run(&process)\n\tok(t, err)\n\n\twaitProcess(&process, t)\n\n\tout := stdout.String()\n\t// fd 5 is the directory handle for /proc/$$/fd\n\tif out != \"0 1 2 3 4 5\" {\n\t\tt.Fatalf(\"expected to have the file descriptors '0 1 2 3 4 5' passed to init, got '%s'\", out)\n\t}\n\tbuf := []byte{0}\n\t_, err = pipeout1.Read(buf)\n\tok(t, err)\n\tout1 := string(buf)\n\tif out1 != \"1\" {\n\t\tt.Fatalf(\"expected first pipe to receive '1', got '%s'\", out1)\n\t}\n\n\t_, err = pipeout2.Read(buf)\n\tok(t, err)\n\tout2 := string(buf)\n\tif out2 != \"2\" {\n\t\tt.Fatalf(\"expected second pipe to receive '2', got '%s'\", out2)\n\t}\n}\n\nfunc TestSysctl(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Sysctl = map[string]string{\n\t\t\"kernel.shmmni\": \"8192\",\n\t\t\"kernel/shmmax\": \"4194304\",\n\t}\n\tconst (\n\t\tcmd = \"cat shmmni shmmax\"\n\t\texp = \"8192\\n4194304\\n\"\n\t)\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/proc/sys/kernel\",\n\t\tArgs:   []string{\"sh\", \"-c\", cmd},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\tout := stdout.String()\n\tif out != exp {\n\t\tt.Fatalf(\"expected %s, got %s\", exp, out)\n\t}\n}\n\nfunc TestMountCgroupRO(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"mount\")\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %s\", buffers, err)\n\t}\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\tmountInfo := buffers.Stdout.String()\n\tlines := strings.Split(mountInfo, \"\\n\")\n\tfor _, l := range lines {\n\t\tif strings.HasPrefix(l, \"tmpfs on /sys/fs/cgroup\") {\n\t\t\tif !strings.Contains(l, \"ro\") ||\n\t\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'ro,nosuid,nodev,noexec': %s\", l)\n\t\t\t}\n\t\t\tif !strings.Contains(l, \"mode=755\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'mode=755': %s\", l)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.HasPrefix(l, \"cgroup\") {\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.Contains(l, \"ro\") ||\n\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\tt.Fatalf(\"Mode expected to contain 'ro,nosuid,nodev,noexec': %s\", l)\n\t\t}\n\t}\n}\n\nfunc TestMountCgroupRW(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\t// clear the RO flag from cgroup mount\n\tfor _, m := range config.Mounts {\n\t\tif m.Device == \"cgroup\" {\n\t\t\tm.Flags = defaultMountFlags\n\t\t\tbreak\n\t\t}\n\t}\n\n\tbuffers, exitCode, err := runContainer(t, config, \"mount\")\n\tif err != nil {\n\t\tt.Fatalf(\"%s: %s\", buffers, err)\n\t}\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\tmountInfo := buffers.Stdout.String()\n\tlines := strings.Split(mountInfo, \"\\n\")\n\tfor _, l := range lines {\n\t\tif strings.HasPrefix(l, \"tmpfs on /sys/fs/cgroup\") {\n\t\t\tif !strings.Contains(l, \"rw\") ||\n\t\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'rw,nosuid,nodev,noexec': %s\", l)\n\t\t\t}\n\t\t\tif !strings.Contains(l, \"mode=755\") {\n\t\t\t\tt.Fatalf(\"Mode expected to contain 'mode=755': %s\", l)\n\t\t\t}\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.HasPrefix(l, \"cgroup\") {\n\t\t\tcontinue\n\t\t}\n\t\tif !strings.Contains(l, \"rw\") ||\n\t\t\t!strings.Contains(l, \"nosuid\") ||\n\t\t\t!strings.Contains(l, \"nodev\") ||\n\t\t\t!strings.Contains(l, \"noexec\") {\n\t\t\tt.Fatalf(\"Mode expected to contain 'rw,nosuid,nodev,noexec': %s\", l)\n\t\t}\n\t}\n}\n\nfunc TestOomScoreAdj(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.OomScoreAdj = ptrInt(200)\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"cat /proc/self/oom_score_adj\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\toutputOomScoreAdj := strings.TrimSpace(stdout.String())\n\n\t// Check that the oom_score_adj matches the value that was set as part of config.\n\tif outputOomScoreAdj != strconv.Itoa(*config.OomScoreAdj) {\n\t\tt.Fatalf(\"Expected oom_score_adj %d; got %q\", *config.OomScoreAdj, outputOomScoreAdj)\n\t}\n}\n\nfunc TestHook(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\texpectedBundle := t.TempDir()\n\tconfig.Labels = append(config.Labels, \"bundle=\"+expectedBundle)\n\n\tgetRootfsFromBundle := func(bundle string) (string, error) {\n\t\tf, err := os.Open(filepath.Join(bundle, \"config.json\"))\n\t\tif err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tvar config configs.Config\n\t\tif err = json.NewDecoder(f).Decode(&config); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t\treturn config.Rootfs, nil\n\t}\n\tcreateFileFromBundle := func(filename, bundle string) error {\n\t\troot, err := getRootfsFromBundle(bundle)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tf, err := os.Create(filepath.Join(root, filename))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn f.Close()\n\t}\n\n\t// Note FunctionHooks can't be serialized to json this means they won't be passed down to the container\n\t// For CreateContainer and StartContainer which run in the container namespace, this means we need to pass Command Hooks.\n\thookFiles := map[configs.HookName]string{\n\t\tconfigs.Prestart:        \"prestart\",\n\t\tconfigs.CreateRuntime:   \"createRuntime\",\n\t\tconfigs.CreateContainer: \"createContainer\",\n\t\tconfigs.StartContainer:  \"startContainer\",\n\t\tconfigs.Poststart:       \"poststart\",\n\t}\n\n\tconfig.Hooks = configs.Hooks{\n\t\tconfigs.Prestart: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected prestart hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\t\t\t\treturn createFileFromBundle(hookFiles[configs.Prestart], s.Bundle)\n\t\t\t}),\n\t\t},\n\t\tconfigs.CreateRuntime: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected createRuntime hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\t\t\t\treturn createFileFromBundle(hookFiles[configs.CreateRuntime], s.Bundle)\n\t\t\t}),\n\t\t},\n\t\tconfigs.CreateContainer: configs.HookList{\n\t\t\tconfigs.NewCommandHook(configs.Command{\n\t\t\t\tPath: \"/bin/bash\",\n\t\t\t\tArgs: []string{\"/bin/bash\", \"-c\", fmt.Sprintf(\"touch ./%s\", hookFiles[configs.CreateContainer])},\n\t\t\t}),\n\t\t},\n\t\tconfigs.StartContainer: configs.HookList{\n\t\t\tconfigs.NewCommandHook(configs.Command{\n\t\t\t\tPath: \"/bin/sh\",\n\t\t\t\tArgs: []string{\"/bin/sh\", \"-c\", fmt.Sprintf(\"touch /%s\", hookFiles[configs.StartContainer])},\n\t\t\t}),\n\t\t},\n\t\tconfigs.Poststart: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected poststart hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\t\t\t\treturn createFileFromBundle(hookFiles[configs.Poststart], s.Bundle)\n\t\t\t}),\n\t\t},\n\t\tconfigs.Poststop: configs.HookList{\n\t\t\tconfigs.NewFunctionHook(func(s *specs.State) error {\n\t\t\t\tif s.Bundle != expectedBundle {\n\t\t\t\t\tt.Fatalf(\"Expected poststop hook bundlePath '%s'; got '%s'\", expectedBundle, s.Bundle)\n\t\t\t\t}\n\n\t\t\t\troot, err := getRootfsFromBundle(s.Bundle)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\n\t\t\t\tfor _, hook := range hookFiles {\n\t\t\t\t\tif err = os.RemoveAll(filepath.Join(root, hook)); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn nil\n\t\t\t}),\n\t\t},\n\t}\n\n\t// write config of json format into config.json under bundle\n\tf, err := os.OpenFile(filepath.Join(expectedBundle, \"config.json\"), os.O_CREATE|os.O_RDWR, 0o644)\n\tok(t, err)\n\tok(t, json.NewEncoder(f).Encode(config))\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\n\t// e.g: 'ls /prestart ...'\n\tcmd := \"ls \"\n\tfor _, hook := range hookFiles {\n\t\tcmd += \"/\" + hook + \" \"\n\t}\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", cmd},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\tif err := container.Destroy(); err != nil {\n\t\tt.Fatalf(\"container destroy %s\", err)\n\t}\n\n\tfor _, hook := range []string{\"prestart\", \"createRuntime\", \"poststart\"} {\n\t\tfi, err := os.Stat(filepath.Join(config.Rootfs, hook))\n\t\tif err == nil || !os.IsNotExist(err) {\n\t\t\tt.Fatalf(\"expected file '%s to not exists, but it does\", fi.Name())\n\t\t}\n\t}\n}\n\nfunc TestSTDIOPermissions(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"sh\", \"-c\", \"echo hi > /dev/stderr\")\n\tok(t, err)\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stderr.String(), \"\\n\"); actual != \"hi\" {\n\t\tt.Fatalf(\"stderr should equal be equal %q %q\", actual, \"hi\")\n\t}\n}\n\nfunc unmountOp(path string) {\n\t_ = unix.Unmount(path, unix.MNT_DETACH)\n}\n\n// Launch container with rootfsPropagation in rslave mode. Also\n// bind mount a volume /mnt1host at /mnt1cont at the time of launch. Now do\n// another mount on host (/mnt1host/mnt2host) and this new mount should\n// propagate to container (/mnt1cont/mnt2host)\nfunc TestRootfsPropagationSlaveMount(t *testing.T) {\n\tvar mountPropagated bool\n\tvar dir1cont string\n\tvar dir2cont string\n\n\tdir1cont = \"/root/mnt1cont\"\n\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.RootPropagation = unix.MS_SLAVE | unix.MS_REC\n\n\t// Bind mount a volume.\n\tdir1host := t.TempDir()\n\n\t// Make this dir a \"shared\" mount point. This will make sure a\n\t// slave relationship can be established in container.\n\terr := unix.Mount(dir1host, dir1host, \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n\tok(t, err)\n\terr = unix.Mount(\"\", dir1host, \"\", unix.MS_SHARED|unix.MS_REC, \"\")\n\tok(t, err)\n\tdefer unmountOp(dir1host)\n\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      dir1host,\n\t\tDestination: dir1cont,\n\t\tDevice:      \"bind\",\n\t\tFlags:       unix.MS_BIND | unix.MS_REC,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\n\terr = container.Run(pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// Create mnt2host under dir1host and bind mount itself on top of it.\n\t// This should be visible in container.\n\tdir2host := filepath.Join(dir1host, \"mnt2host\")\n\terr = os.Mkdir(dir2host, 0o700)\n\tok(t, err)\n\tdefer remove(dir2host)\n\n\terr = unix.Mount(dir2host, dir2host, \"bind\", unix.MS_BIND, \"\")\n\tdefer unmountOp(dir2host)\n\tok(t, err)\n\n\t// Run \"cat /proc/self/mountinfo\" in container and look at mount points.\n\tvar stdout2 bytes.Buffer\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig2 := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"cat\", \"/proc/self/mountinfo\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  stdinR2,\n\t\tStdout: &stdout2,\n\t}\n\n\terr = container.Run(pconfig2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\t_ = stdinW2.Close()\n\twaitProcess(pconfig2, t)\n\t_ = stdinW.Close()\n\twaitProcess(pconfig, t)\n\n\tmountPropagated = false\n\tdir2cont = filepath.Join(dir1cont, filepath.Base(dir2host))\n\n\tpropagationInfo := stdout2.String()\n\tlines := strings.Split(propagationInfo, \"\\n\")\n\tfor _, l := range lines {\n\t\tlinefields := strings.Split(l, \" \")\n\t\tif len(linefields) < 5 {\n\t\t\tcontinue\n\t\t}\n\n\t\tif linefields[4] == dir2cont {\n\t\t\tmountPropagated = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif mountPropagated != true {\n\t\tt.Fatalf(\"Mount on host %s did not propagate in container at %s\\n\", dir2host, dir2cont)\n\t}\n}\n\n// Launch container with rootfsPropagation 0 so no propagation flags are\n// applied. Also bind mount a volume /mnt1host at /mnt1cont at the time of\n// launch. Now do a mount in container (/mnt1cont/mnt2cont) and this new\n// mount should propagate to host (/mnt1host/mnt2cont)\n\nfunc TestRootfsPropagationSharedMount(t *testing.T) {\n\tvar dir1cont string\n\tvar dir2cont string\n\n\tdir1cont = \"/root/mnt1cont\"\n\n\tif testing.Short() {\n\t\treturn\n\t}\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.RootPropagation = unix.MS_PRIVATE\n\n\t// Bind mount a volume.\n\tdir1host := t.TempDir()\n\n\t// Make this dir a \"shared\" mount point. This will make sure a\n\t// shared relationship can be established in container.\n\terr := unix.Mount(dir1host, dir1host, \"bind\", unix.MS_BIND|unix.MS_REC, \"\")\n\tok(t, err)\n\terr = unix.Mount(\"\", dir1host, \"\", unix.MS_SHARED|unix.MS_REC, \"\")\n\tok(t, err)\n\tdefer unmountOp(dir1host)\n\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      dir1host,\n\t\tDestination: dir1cont,\n\t\tDevice:      \"bind\",\n\t\tFlags:       unix.MS_BIND | unix.MS_REC,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tstdinR, stdinW, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR,\n\t\tInit:  true,\n\t}\n\n\terr = container.Run(pconfig)\n\t_ = stdinR.Close()\n\tdefer stdinW.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// Create mnt2cont under dir1host. This will become visible inside container\n\t// at mnt1cont/mnt2cont. Bind mount itself on top of it. This\n\t// should be visible on host now.\n\tdir2host := filepath.Join(dir1host, \"mnt2cont\")\n\terr = os.Mkdir(dir2host, 0o700)\n\tok(t, err)\n\tdefer remove(dir2host)\n\n\tdir2cont = filepath.Join(dir1cont, filepath.Base(dir2host))\n\n\t// Mount something in container and see if it is visible on host.\n\tvar stdout2 bytes.Buffer\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\n\tpconfig2 := &libcontainer.Process{\n\t\tCwd:          \"/\",\n\t\tArgs:         []string{\"mount\", \"--bind\", dir2cont, dir2cont},\n\t\tEnv:          standardEnvironment,\n\t\tStdin:        stdinR2,\n\t\tStdout:       &stdout2,\n\t\tCapabilities: &configs.Capabilities{},\n\t}\n\n\t// Provide CAP_SYS_ADMIN\n\tpconfig2.Capabilities.Bounding = append(config.Capabilities.Bounding, \"CAP_SYS_ADMIN\")\n\tpconfig2.Capabilities.Permitted = append(config.Capabilities.Permitted, \"CAP_SYS_ADMIN\")\n\tpconfig2.Capabilities.Effective = append(config.Capabilities.Effective, \"CAP_SYS_ADMIN\")\n\n\terr = container.Run(pconfig2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// Wait for process\n\t_ = stdinW2.Close()\n\twaitProcess(pconfig2, t)\n\t_ = stdinW.Close()\n\twaitProcess(pconfig, t)\n\n\tdefer unmountOp(dir2host)\n\n\t// Check if mount is visible on host or not.\n\tout, err := exec.Command(\"findmnt\", \"-n\", \"-f\", \"-oTARGET\", dir2host).CombinedOutput()\n\touttrim := string(bytes.TrimSpace(out))\n\tif err != nil {\n\t\tt.Logf(\"findmnt error %q: %q\", err, outtrim)\n\t}\n\n\tif outtrim != dir2host {\n\t\tt.Fatalf(\"Mount in container on %s did not propagate to host on %s. finmnt output=%s\", dir2cont, dir2host, outtrim)\n\t}\n}\n\nfunc TestPIDHost(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/pid\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Remove(configs.NEWPID)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/pid\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"ipc link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestPIDHostInitProcessWait(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tpidns := \"/proc/1/ns/pid\"\n\n\t// Run a container with two long-running processes.\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWPID, pidns)\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer func() {\n\t\t_ = container.Destroy()\n\t}()\n\n\tprocess1 := &libcontainer.Process{\n\t\tCwd:  \"/\",\n\t\tArgs: []string{\"sleep\", \"100\"},\n\t\tEnv:  standardEnvironment,\n\t\tInit: true,\n\t}\n\terr = container.Run(process1)\n\tok(t, err)\n\n\tprocess2 := &libcontainer.Process{\n\t\tCwd:  \"/\",\n\t\tArgs: []string{\"sleep\", \"100\"},\n\t\tEnv:  standardEnvironment,\n\t\tInit: false,\n\t}\n\terr = container.Run(process2)\n\tok(t, err)\n\n\t// Kill the init process and Wait for it.\n\terr = process1.Signal(syscall.SIGKILL)\n\tok(t, err)\n\t_, err = process1.Wait()\n\tif err == nil {\n\t\tt.Fatal(\"expected Wait to indicate failure\")\n\t}\n\n\t// The non-init process must've been killed.\n\terr = process2.Signal(syscall.Signal(0))\n\tif err == nil || err.Error() != \"no such process\" {\n\t\tt.Fatalf(\"expected process to have been killed: %v\", err)\n\t}\n}\n\nfunc TestInitJoinPID(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\t// Execute a long-running container\n\tconfig1 := newTemplateConfig(t, nil)\n\tcontainer1, err := newContainer(t, config1)\n\tok(t, err)\n\tdefer destroyContainer(container1)\n\n\tstdinR1, stdinW1, err := os.Pipe()\n\tok(t, err)\n\tinit1 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR1,\n\t\tInit:  true,\n\t}\n\terr = container1.Run(init1)\n\t_ = stdinR1.Close()\n\tdefer stdinW1.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// get the state of the first container\n\tstate1, err := container1.State()\n\tok(t, err)\n\tpidns1 := state1.NamespacePaths[configs.NEWPID]\n\n\t// Run a container inside the existing pidns but with different cgroups\n\tconfig2 := newTemplateConfig(t, nil)\n\tconfig2.Namespaces.Add(configs.NEWPID, pidns1)\n\tconfig2.Cgroups.Path = \"integration/test2\"\n\tcontainer2, err := newContainer(t, config2)\n\tok(t, err)\n\tdefer destroyContainer(container2)\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\tinit2 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR2,\n\t\tInit:  true,\n\t}\n\terr = container2.Run(init2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\t// get the state of the second container\n\tstate2, err := container2.State()\n\tok(t, err)\n\n\tns1, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/pid\", state1.InitProcessPid))\n\tok(t, err)\n\tns2, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/pid\", state2.InitProcessPid))\n\tok(t, err)\n\tif ns1 != ns2 {\n\t\tt.Errorf(\"pidns(%s), wanted %s\", ns2, ns1)\n\t}\n\n\t// check that namespaces are not the same\n\tif reflect.DeepEqual(state2.NamespacePaths, state1.NamespacePaths) {\n\t\tt.Errorf(\"Namespaces(%v), original %v\", state2.NamespacePaths,\n\t\t\tstate1.NamespacePaths)\n\t}\n\t// check that pidns is joined correctly. The initial container process list\n\t// should contain the second container's init process\n\tbuffers := newStdBuffers()\n\tps := &libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"ps\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdout: buffers.Stdout,\n\t}\n\terr = container1.Run(ps)\n\tok(t, err)\n\twaitProcess(ps, t)\n\n\t// Stop init processes one by one. Stop the second container should\n\t// not stop the first.\n\t_ = stdinW2.Close()\n\twaitProcess(init2, t)\n\t_ = stdinW1.Close()\n\twaitProcess(init1, t)\n\n\tout := strings.TrimSpace(buffers.Stdout.String())\n\t// output of ps inside the initial PID namespace should have\n\t// 1 line of header,\n\t// 2 lines of init processes,\n\t// 1 line of ps process\n\tif len(strings.Split(out, \"\\n\")) != 4 {\n\t\tt.Errorf(\"unexpected running process, output %q\", out)\n\t}\n}\n\nfunc TestInitJoinNetworkAndUser(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires userns.\")\n\t}\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\t// Execute a long-running container\n\tconfig1 := newTemplateConfig(t, &tParam{userns: true})\n\tcontainer1, err := newContainer(t, config1)\n\tok(t, err)\n\tdefer destroyContainer(container1)\n\n\tstdinR1, stdinW1, err := os.Pipe()\n\tok(t, err)\n\tinit1 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR1,\n\t\tInit:  true,\n\t}\n\terr = container1.Run(init1)\n\t_ = stdinR1.Close()\n\tdefer stdinW1.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// get the state of the first container\n\tstate1, err := container1.State()\n\tok(t, err)\n\tnetns1 := state1.NamespacePaths[configs.NEWNET]\n\tuserns1 := state1.NamespacePaths[configs.NEWUSER]\n\n\t// Run a container inside the existing pidns but with different cgroups.\n\tconfig2 := newTemplateConfig(t, &tParam{userns: true})\n\tconfig2.Namespaces.Add(configs.NEWNET, netns1)\n\tconfig2.Namespaces.Add(configs.NEWUSER, userns1)\n\tconfig2.Cgroups.Path = \"integration/test2\"\n\tcontainer2, err := newContainer(t, config2)\n\tok(t, err)\n\tdefer destroyContainer(container2)\n\n\tstdinR2, stdinW2, err := os.Pipe()\n\tok(t, err)\n\tinit2 := &libcontainer.Process{\n\t\tCwd:   \"/\",\n\t\tArgs:  []string{\"cat\"},\n\t\tEnv:   standardEnvironment,\n\t\tStdin: stdinR2,\n\t\tInit:  true,\n\t}\n\terr = container2.Run(init2)\n\t_ = stdinR2.Close()\n\tdefer stdinW2.Close() //nolint: errcheck\n\tok(t, err)\n\n\t// get the state of the second container\n\tstate2, err := container2.State()\n\tok(t, err)\n\n\tfor _, ns := range []string{\"net\", \"user\"} {\n\t\tns1, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/%s\", state1.InitProcessPid, ns))\n\t\tok(t, err)\n\t\tns2, err := os.Readlink(fmt.Sprintf(\"/proc/%d/ns/%s\", state2.InitProcessPid, ns))\n\t\tok(t, err)\n\t\tif ns1 != ns2 {\n\t\t\tt.Errorf(\"%s(%s), wanted %s\", ns, ns2, ns1)\n\t\t}\n\t}\n\n\t// check that namespaces are not the same\n\tif reflect.DeepEqual(state2.NamespacePaths, state1.NamespacePaths) {\n\t\tt.Errorf(\"Namespaces(%v), original %v\", state2.NamespacePaths,\n\t\t\tstate1.NamespacePaths)\n\t}\n\t// Stop init processes one by one. Stop the second container should\n\t// not stop the first.\n\t_ = stdinW2.Close()\n\twaitProcess(init2, t)\n\t_ = stdinW1.Close()\n\twaitProcess(init1, t)\n}\n\nfunc TestTmpfsCopyUp(t *testing.T) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      \"tmpfs\",\n\t\tDestination: \"/etc\",\n\t\tDevice:      \"tmpfs\",\n\t\tExtensions:  configs.EXT_COPYUP,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer destroyContainer(container)\n\n\tvar stdout bytes.Buffer\n\tpconfig := libcontainer.Process{\n\t\tArgs:   []string{\"ls\", \"/etc/passwd\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdin:  nil,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\t// Wait for process\n\twaitProcess(&pconfig, t)\n\n\toutputLs := stdout.String()\n\n\t// Check that the ls output has /etc/passwd\n\tif !strings.Contains(outputLs, \"/etc/passwd\") {\n\t\tt.Fatalf(\"/etc/passwd not copied up as expected: %v\", outputLs)\n\t}\n}\n\nfunc TestCGROUPPrivate(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/cgroup\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires cgroupns.\")\n\t}\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/cgroup\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tconfig.Namespaces.Add(configs.NEWCGROUP, \"\")\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/cgroup\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual == l {\n\t\tt.Fatalf(\"cgroup link should be private to the container but equals host %q %q\", actual, l)\n\t}\n}\n\nfunc TestCGROUPHost(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/cgroup\"); os.IsNotExist(err) {\n\t\tt.Skip(\"Test requires cgroupns.\")\n\t}\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tl, err := os.Readlink(\"/proc/1/ns/cgroup\")\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, nil)\n\tbuffers, exitCode, err := runContainer(t, config, \"readlink\", \"/proc/self/ns/cgroup\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tif actual := strings.Trim(buffers.Stdout.String(), \"\\n\"); actual != l {\n\t\tt.Fatalf(\"cgroup link not equal to host link %q %q\", actual, l)\n\t}\n}\n\nfunc TestFdLeaks(t *testing.T) {\n\ttestFdLeaks(t, false)\n}\n\nfunc TestFdLeaksSystemd(t *testing.T) {\n\tif !systemd.IsRunningSystemd() {\n\t\tt.Skip(\"Test requires systemd.\")\n\t}\n\ttestFdLeaks(t, true)\n}\n\nfunc testFdLeaks(t *testing.T, systemd bool) {\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\tpfd, err := os.Open(\"/proc/self/fd\")\n\tok(t, err)\n\tdefer pfd.Close()\n\tfds0, err := pfd.Readdirnames(0)\n\tok(t, err)\n\t_, err = pfd.Seek(0, 0)\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, &tParam{systemd: systemd})\n\tbuffers, exitCode, err := runContainer(t, config, \"true\")\n\tok(t, err)\n\n\tif exitCode != 0 {\n\t\tt.Fatalf(\"exit code not 0. code %d stderr %q\", exitCode, buffers.Stderr)\n\t}\n\n\tfds1, err := pfd.Readdirnames(0)\n\tok(t, err)\n\n\tif len(fds1) == len(fds0) {\n\t\treturn\n\t}\n\t// Show the extra opened files.\n\n\texcludedPaths := []string{\n\t\t\"/sys/fs/cgroup\",      // opened once, see prepareOpenat2\n\t\t\"anon_inode:bpf-prog\", // FIXME: see https://github.com/opencontainers/runc/issues/2366#issuecomment-776411392\n\t}\n\n\tcount := 0\nnext_fd:\n\tfor _, fd1 := range fds1 {\n\t\tfor _, fd0 := range fds0 {\n\t\t\tif fd0 == fd1 {\n\t\t\t\tcontinue next_fd\n\t\t\t}\n\t\t}\n\t\tdst, _ := os.Readlink(\"/proc/self/fd/\" + fd1)\n\t\tfor _, ex := range excludedPaths {\n\t\t\tif ex == dst {\n\t\t\t\tcontinue next_fd\n\t\t\t}\n\t\t}\n\n\t\tcount++\n\t\tt.Logf(\"extra fd %s -> %s\", fd1, dst)\n\t}\n\tif count > 0 {\n\t\tt.Fatalf(\"found %d extra fds after container.Run\", count)\n\t}\n}\n\n// Test that a container using user namespaces is able to bind mount a folder\n// that does not have permissions for group/others.\nfunc TestBindMountAndUser(t *testing.T) {\n\tif _, err := os.Stat(\"/proc/self/ns/user\"); errors.Is(err, os.ErrNotExist) {\n\t\tt.Skip(\"userns is unsupported\")\n\t}\n\n\tif testing.Short() {\n\t\treturn\n\t}\n\n\ttemphost := t.TempDir()\n\tdirhost := filepath.Join(temphost, \"inaccessible\", \"dir\")\n\n\terr := os.MkdirAll(dirhost, 0o755)\n\tok(t, err)\n\n\terr = os.WriteFile(filepath.Join(dirhost, \"foo.txt\"), []byte(\"Hello\"), 0o755)\n\tok(t, err)\n\n\t// Make this dir inaccessible to \"group,others\".\n\terr = os.Chmod(filepath.Join(temphost, \"inaccessible\"), 0o700)\n\tok(t, err)\n\n\tconfig := newTemplateConfig(t, &tParam{\n\t\tuserns: true,\n\t})\n\n\t// Set HostID to 1000 to avoid DAC_OVERRIDE bypassing the purpose of this test.\n\tconfig.UidMappings[0].HostID = 1000\n\tconfig.GidMappings[0].HostID = 1000\n\n\t// Set the owner of rootfs to the effective IDs in the host to avoid errors\n\t// while creating the folders to perform the mounts.\n\terr = os.Chown(config.Rootfs, 1000, 1000)\n\tok(t, err)\n\n\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\tSource:      dirhost,\n\t\tDestination: \"/tmp/mnt1cont\",\n\t\tDevice:      \"bind\",\n\t\tFlags:       unix.MS_BIND | unix.MS_REC,\n\t})\n\n\tcontainer, err := newContainer(t, config)\n\tok(t, err)\n\tdefer container.Destroy() //nolint: errcheck\n\n\tvar stdout bytes.Buffer\n\n\tpconfig := libcontainer.Process{\n\t\tCwd:    \"/\",\n\t\tArgs:   []string{\"sh\", \"-c\", \"stat /tmp/mnt1cont/foo.txt\"},\n\t\tEnv:    standardEnvironment,\n\t\tStdout: &stdout,\n\t\tInit:   true,\n\t}\n\terr = container.Run(&pconfig)\n\tok(t, err)\n\n\twaitProcess(&pconfig, t)\n}\n", "package integration\n\nimport (\n\t\"strconv\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/opencontainers/runc/libcontainer/configs\"\n\t\"github.com/opencontainers/runc/libcontainer/devices\"\n\t\"github.com/opencontainers/runc/libcontainer/specconv\"\n\t\"golang.org/x/sys/unix\"\n)\n\nvar standardEnvironment = []string{\n\t\"HOME=/root\",\n\t\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n\t\"HOSTNAME=integration\",\n\t\"TERM=xterm\",\n}\n\nconst defaultMountFlags = unix.MS_NOEXEC | unix.MS_NOSUID | unix.MS_NODEV\n\ntype tParam struct {\n\tuserns  bool\n\tsystemd bool\n}\n\n// newTemplateConfig returns a base template for running a container.\n//\n// It uses a network strategy of just setting a loopback interface\n// and the default setup for devices.\n//\n// If p is nil, a default container is created.\nfunc newTemplateConfig(t *testing.T, p *tParam) *configs.Config {\n\tvar allowedDevices []*devices.Rule\n\tfor _, device := range specconv.AllowedDevices {\n\t\tallowedDevices = append(allowedDevices, &device.Rule)\n\t}\n\tif p == nil {\n\t\tp = &tParam{}\n\t}\n\tconfig := &configs.Config{\n\t\tRootfs: newRootfs(t),\n\t\tCapabilities: &configs.Capabilities{\n\t\t\tBounding: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t\tPermitted: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t\tAmbient: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t\tEffective: []string{\n\t\t\t\t\"CAP_CHOWN\",\n\t\t\t\t\"CAP_DAC_OVERRIDE\",\n\t\t\t\t\"CAP_FSETID\",\n\t\t\t\t\"CAP_FOWNER\",\n\t\t\t\t\"CAP_MKNOD\",\n\t\t\t\t\"CAP_NET_RAW\",\n\t\t\t\t\"CAP_SETGID\",\n\t\t\t\t\"CAP_SETUID\",\n\t\t\t\t\"CAP_SETFCAP\",\n\t\t\t\t\"CAP_SETPCAP\",\n\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t\"CAP_SYS_CHROOT\",\n\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t},\n\t\t},\n\t\tNamespaces: configs.Namespaces([]configs.Namespace{\n\t\t\t{Type: configs.NEWNS},\n\t\t\t{Type: configs.NEWUTS},\n\t\t\t{Type: configs.NEWIPC},\n\t\t\t{Type: configs.NEWPID},\n\t\t\t{Type: configs.NEWNET},\n\t\t}),\n\t\tCgroups: &configs.Cgroup{\n\t\t\tSystemd: p.systemd,\n\t\t\tResources: &configs.Resources{\n\t\t\t\tMemorySwappiness: nil,\n\t\t\t\tDevices:          allowedDevices,\n\t\t\t},\n\t\t},\n\t\tMaskPaths: []string{\n\t\t\t\"/proc/kcore\",\n\t\t\t\"/sys/firmware\",\n\t\t},\n\t\tReadonlyPaths: []string{\n\t\t\t\"/proc/sys\", \"/proc/sysrq-trigger\", \"/proc/irq\", \"/proc/bus\",\n\t\t},\n\t\tDevices:  specconv.AllowedDevices,\n\t\tHostname: \"integration\",\n\t\tMounts: []*configs.Mount{\n\t\t\t{\n\t\t\t\tSource:      \"proc\",\n\t\t\t\tDestination: \"/proc\",\n\t\t\t\tDevice:      \"proc\",\n\t\t\t\tFlags:       defaultMountFlags,\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:      \"tmpfs\",\n\t\t\t\tDestination: \"/dev\",\n\t\t\t\tDevice:      \"tmpfs\",\n\t\t\t\tFlags:       unix.MS_NOSUID | unix.MS_STRICTATIME,\n\t\t\t\tData:        \"mode=755\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tSource:      \"devpts\",\n\t\t\t\tDestination: \"/dev/pts\",\n\t\t\t\tDevice:      \"devpts\",\n\t\t\t\tFlags:       unix.MS_NOSUID | unix.MS_NOEXEC,\n\t\t\t\tData:        \"newinstance,ptmxmode=0666,mode=0620,gid=5\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tDevice:      \"tmpfs\",\n\t\t\t\tSource:      \"shm\",\n\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\tData:        \"mode=1777,size=65536k\",\n\t\t\t\tFlags:       defaultMountFlags,\n\t\t\t},\n\t\t\t/*\n\t\t\t\t            CI is broken on the debian based kernels with this\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tSource:      \"mqueue\",\n\t\t\t\t\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\t\t\t\t\tDevice:      \"mqueue\",\n\t\t\t\t\t\t\t\tFlags:       defaultMountFlags,\n\t\t\t\t\t\t\t},\n\t\t\t*/\n\t\t\t{\n\t\t\t\tSource:      \"sysfs\",\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tDevice:      \"sysfs\",\n\t\t\t\tFlags:       defaultMountFlags | unix.MS_RDONLY,\n\t\t\t},\n\t\t},\n\t\tNetworks: []*configs.Network{\n\t\t\t{\n\t\t\t\tType:    \"loopback\",\n\t\t\t\tAddress: \"127.0.0.1/0\",\n\t\t\t\tGateway: \"localhost\",\n\t\t\t},\n\t\t},\n\t\tRlimits: []configs.Rlimit{\n\t\t\t{\n\t\t\t\tType: unix.RLIMIT_NOFILE,\n\t\t\t\tHard: uint64(1025),\n\t\t\t\tSoft: uint64(1025),\n\t\t\t},\n\t\t},\n\t}\n\n\tif p.userns {\n\t\tconfig.UidMappings = []configs.IDMap{{HostID: 0, ContainerID: 0, Size: 1000}}\n\t\tconfig.GidMappings = []configs.IDMap{{HostID: 0, ContainerID: 0, Size: 1000}}\n\t\tconfig.Namespaces = append(config.Namespaces, configs.Namespace{Type: configs.NEWUSER})\n\t} else {\n\t\tconfig.Mounts = append(config.Mounts, &configs.Mount{\n\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\tDevice:      \"cgroup\",\n\t\t\tFlags:       defaultMountFlags | unix.MS_RDONLY,\n\t\t})\n\t}\n\n\tif p.systemd {\n\t\tid := strconv.FormatInt(-int64(time.Now().Nanosecond()), 36)\n\t\tconfig.Cgroups.Name = strings.ReplaceAll(t.Name(), \"/\", \"_\") + id\n\t\tconfig.Cgroups.Parent = \"system.slice\"\n\t\tconfig.Cgroups.ScopePrefix = \"runc-test\"\n\t} else {\n\t\tconfig.Cgroups.Path = \"/test/integration\"\n\t}\n\n\treturn config\n}\n", "package specconv\n\nimport (\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/opencontainers/runc/libcontainer/cgroups\"\n\t\"github.com/opencontainers/runtime-spec/specs-go\"\n)\n\n// Example returns an example spec file, with many options set so a user can\n// see what a standard spec file looks like.\nfunc Example() *specs.Spec {\n\tspec := &specs.Spec{\n\t\tVersion: specs.Version,\n\t\tRoot: &specs.Root{\n\t\t\tPath:     \"rootfs\",\n\t\t\tReadonly: true,\n\t\t},\n\t\tProcess: &specs.Process{\n\t\t\tTerminal: true,\n\t\t\tUser:     specs.User{},\n\t\t\tArgs: []string{\n\t\t\t\t\"sh\",\n\t\t\t},\n\t\t\tEnv: []string{\n\t\t\t\t\"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\",\n\t\t\t\t\"TERM=xterm\",\n\t\t\t},\n\t\t\tCwd:             \"/\",\n\t\t\tNoNewPrivileges: true,\n\t\t\tCapabilities: &specs.LinuxCapabilities{\n\t\t\t\tBounding: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t\tPermitted: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t\tAmbient: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t\tEffective: []string{\n\t\t\t\t\t\"CAP_AUDIT_WRITE\",\n\t\t\t\t\t\"CAP_KILL\",\n\t\t\t\t\t\"CAP_NET_BIND_SERVICE\",\n\t\t\t\t},\n\t\t\t},\n\t\t\tRlimits: []specs.POSIXRlimit{\n\t\t\t\t{\n\t\t\t\t\tType: \"RLIMIT_NOFILE\",\n\t\t\t\t\tHard: uint64(1024),\n\t\t\t\t\tSoft: uint64(1024),\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tHostname: \"runc\",\n\t\tMounts: []specs.Mount{\n\t\t\t{\n\t\t\t\tDestination: \"/proc\",\n\t\t\t\tType:        \"proc\",\n\t\t\t\tSource:      \"proc\",\n\t\t\t\tOptions:     nil,\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"tmpfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"strictatime\", \"mode=755\", \"size=65536k\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/pts\",\n\t\t\t\tType:        \"devpts\",\n\t\t\t\tSource:      \"devpts\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"newinstance\", \"ptmxmode=0666\", \"mode=0620\", \"gid=5\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/shm\",\n\t\t\t\tType:        \"tmpfs\",\n\t\t\t\tSource:      \"shm\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"mode=1777\", \"size=65536k\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/dev/mqueue\",\n\t\t\t\tType:        \"mqueue\",\n\t\t\t\tSource:      \"mqueue\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tType:        \"sysfs\",\n\t\t\t\tSource:      \"sysfs\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t},\n\t\t\t{\n\t\t\t\tDestination: \"/sys/fs/cgroup\",\n\t\t\t\tType:        \"cgroup\",\n\t\t\t\tSource:      \"cgroup\",\n\t\t\t\tOptions:     []string{\"nosuid\", \"noexec\", \"nodev\", \"relatime\", \"ro\"},\n\t\t\t},\n\t\t},\n\t\tLinux: &specs.Linux{\n\t\t\tMaskedPaths: []string{\n\t\t\t\t\"/proc/acpi\",\n\t\t\t\t\"/proc/asound\",\n\t\t\t\t\"/proc/kcore\",\n\t\t\t\t\"/proc/keys\",\n\t\t\t\t\"/proc/latency_stats\",\n\t\t\t\t\"/proc/timer_list\",\n\t\t\t\t\"/proc/timer_stats\",\n\t\t\t\t\"/proc/sched_debug\",\n\t\t\t\t\"/sys/firmware\",\n\t\t\t\t\"/proc/scsi\",\n\t\t\t},\n\t\t\tReadonlyPaths: []string{\n\t\t\t\t\"/proc/bus\",\n\t\t\t\t\"/proc/fs\",\n\t\t\t\t\"/proc/irq\",\n\t\t\t\t\"/proc/sys\",\n\t\t\t\t\"/proc/sysrq-trigger\",\n\t\t\t},\n\t\t\tResources: &specs.LinuxResources{\n\t\t\t\tDevices: []specs.LinuxDeviceCgroup{\n\t\t\t\t\t{\n\t\t\t\t\t\tAllow:  false,\n\t\t\t\t\t\tAccess: \"rwm\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t\tNamespaces: []specs.LinuxNamespace{\n\t\t\t\t{\n\t\t\t\t\tType: specs.PIDNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.NetworkNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.IPCNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.UTSNamespace,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tType: specs.MountNamespace,\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tif cgroups.IsCgroup2UnifiedMode() {\n\t\tspec.Linux.Namespaces = append(spec.Linux.Namespaces, specs.LinuxNamespace{\n\t\t\tType: specs.CgroupNamespace,\n\t\t})\n\t}\n\treturn spec\n}\n\n// ToRootless converts the given spec file into one that should work with\n// rootless containers (euid != 0), by removing incompatible options and adding others that\n// are needed.\nfunc ToRootless(spec *specs.Spec) {\n\tvar namespaces []specs.LinuxNamespace\n\n\t// Remove networkns from the spec.\n\tfor _, ns := range spec.Linux.Namespaces {\n\t\tswitch ns.Type {\n\t\tcase specs.NetworkNamespace, specs.UserNamespace:\n\t\t\t// Do nothing.\n\t\tdefault:\n\t\t\tnamespaces = append(namespaces, ns)\n\t\t}\n\t}\n\t// Add userns to the spec.\n\tnamespaces = append(namespaces, specs.LinuxNamespace{\n\t\tType: specs.UserNamespace,\n\t})\n\tspec.Linux.Namespaces = namespaces\n\n\t// Add mappings for the current user.\n\tspec.Linux.UIDMappings = []specs.LinuxIDMapping{{\n\t\tHostID:      uint32(os.Geteuid()),\n\t\tContainerID: 0,\n\t\tSize:        1,\n\t}}\n\tspec.Linux.GIDMappings = []specs.LinuxIDMapping{{\n\t\tHostID:      uint32(os.Getegid()),\n\t\tContainerID: 0,\n\t\tSize:        1,\n\t}}\n\n\t// Fix up mounts.\n\tvar mounts []specs.Mount\n\tfor _, mount := range spec.Mounts {\n\t\t// Replace the /sys mount with an rbind.\n\t\tif filepath.Clean(mount.Destination) == \"/sys\" {\n\t\t\tmounts = append(mounts, specs.Mount{\n\t\t\t\tSource:      \"/sys\",\n\t\t\t\tDestination: \"/sys\",\n\t\t\t\tType:        \"none\",\n\t\t\t\tOptions:     []string{\"rbind\", \"nosuid\", \"noexec\", \"nodev\", \"ro\"},\n\t\t\t})\n\t\t\tcontinue\n\t\t}\n\n\t\t// Remove all gid= and uid= mappings.\n\t\tvar options []string\n\t\tfor _, option := range mount.Options {\n\t\t\tif !strings.HasPrefix(option, \"gid=\") && !strings.HasPrefix(option, \"uid=\") {\n\t\t\t\toptions = append(options, option)\n\t\t\t}\n\t\t}\n\n\t\tmount.Options = options\n\t\tmounts = append(mounts, mount)\n\t}\n\tspec.Mounts = mounts\n\n\t// Remove cgroup settings.\n\tspec.Linux.Resources = nil\n}\n"], "filenames": ["exec.go", "libcontainer/README.md", "libcontainer/integration/exec_test.go", "libcontainer/integration/template_test.go", "libcontainer/specconv/example.go"], "buggy_code_start_loc": [230, 87, 367, 63, 40], "buggy_code_end_loc": [231, 103, 1364, 79, 45], "fixing_code_start_loc": [229, 86, 366, 62, 39], "fixing_code_end_loc": [229, 86, 1361, 62, 39], "type": "CWE-276", "message": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. A bug was found in runc prior to version 1.1.2 where `runc exec --cap` created processes with non-empty inheritable Linux process capabilities, creating an atypical Linux environment and enabling programs with inheritable file capabilities to elevate those capabilities to the permitted set during execve(2). This bug did not affect the container security sandbox as the inheritable set never contained more capabilities than were included in the container's bounding set. This bug has been fixed in runc 1.1.2. This fix changes `runc exec --cap` behavior such that the additional capabilities granted to the process being executed (as specified via `--cap` arguments) do not include inheritable capabilities. In addition, `runc spec` is changed to not set any inheritable capabilities in the created example OCI spec (`config.json`) file.", "other": {"cve": {"id": "CVE-2022-29162", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-17T21:15:08.320", "lastModified": "2023-03-27T18:15:11.230", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "runc is a CLI tool for spawning and running containers on Linux according to the OCI specification. A bug was found in runc prior to version 1.1.2 where `runc exec --cap` created processes with non-empty inheritable Linux process capabilities, creating an atypical Linux environment and enabling programs with inheritable file capabilities to elevate those capabilities to the permitted set during execve(2). This bug did not affect the container security sandbox as the inheritable set never contained more capabilities than were included in the container's bounding set. This bug has been fixed in runc 1.1.2. This fix changes `runc exec --cap` behavior such that the additional capabilities granted to the process being executed (as specified via `--cap` arguments) do not include inheritable capabilities. In addition, `runc spec` is changed to not set any inheritable capabilities in the created example OCI spec (`config.json`) file."}, {"lang": "es", "value": "runc es una herramienta CLI para generar y ejecutar contenedores en Linux seg\u00fan la especificaci\u00f3n OCI. Se encontr\u00f3 un bug en runc versiones anteriores a 1.1.2 en el que \"runc exec --cap\" creaba procesos con capacidades de proceso heredables de Linux no vac\u00edas, creando un entorno Linux at\u00edpico y permitiendo a programas con capacidades de archivo heredables elevar esas capacidades al conjunto permitido durante execve(2). Este error no afectaba al sandbox de seguridad del contenedor, ya que el conjunto heredable nunca conten\u00eda m\u00e1s capacidades que las incluidas en el conjunto delimitador del contenedor. Este error ha sido corregido en runc versi\u00f3n 1.1.2. Esta correcci\u00f3n cambia el comportamiento de \"runc exec --cap\" de forma que las capacidades adicionales concedidas al proceso que est\u00e1 siendo ejecutando (especificadas por medio de los argumentos \"--cap\") no incluyen las capacidades heredables. Adem\u00e1s, \"runc spec\" ha sido modificado para que no establezca ninguna capacidad heredable en el archivo de especificaciones OCI de ejemplo creado (\"config.json')"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.5, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-276"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:runc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.1.2", "matchCriteriaId": "1266D0BA-8DDB-43DF-A1A0-D5CE23BE27C1"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/opencontainers/runc/commit/d04de3a9b72d7a2455c1885fc75eb36d02cd17b5", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/releases/tag/v1.1.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/opencontainers/runc/security/advisories/GHSA-f3fp-gc8g-vw66", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/03/msg00023.html", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AVPZBV7ISA7QKRPTC7ZXWKMIQI2HZEBB/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/D77CKD3AXPMU4PMQIQI5Q74SI4JATNND/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/GPQU4YC4AAY54JDXGDQHJEYKSXXG5T2Y/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/opencontainers/runc/commit/d04de3a9b72d7a2455c1885fc75eb36d02cd17b5"}}