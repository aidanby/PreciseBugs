{"buggy_code": ["<?php if (!defined('BASEPATH')) {\n    exit('No direct script access allowed');\n}\n/*\n* LimeSurvey\n* Copyright (C) 2007-2011 The LimeSurvey Project Team / Carsten Schmitz\n* All rights reserved.\n* License: GNU/GPL License v2 or later, see LICENSE.php\n* LimeSurvey is free software. This version may have been modified pursuant\n* to the GNU General Public License, and as distributed it includes or\n* is derivative of works licensed under the GNU General Public License or\n* other free or open source software licenses.\n* See COPYRIGHT.php for copyright notices and details.\n*/\nYii::import('application.helpers.sanitize_helper', true);\n\n\n/**\n * Translation helper function\n * @param string $sToTranslate\n * @param string $sEscapeMode Valid values are html (this is the default, js and unescaped)\n * @param string $sLanguage\n * @return mixed|string\n */\nfunction gT($sToTranslate, $sEscapeMode = 'html', $sLanguage = null)\n{\n    return quoteText(Yii::t('', $sToTranslate, array(), null, $sLanguage), $sEscapeMode);\n}\n\n/**\n * Translation helper function which outputs right away.\n * @param string $sToTranslate\n * @param string $sEscapeMode\n */\nfunction eT($sToTranslate, $sEscapeMode = 'html')\n{\n    echo gT($sToTranslate, $sEscapeMode);\n}\n\n/**\n * Translation helper function for plural forms\n * @param string $sTextToTranslate\n * @param integer $iCount\n * @param string $sEscapeMode\n * @return string\n */\nfunction ngT($sTextToTranslate, $iCount, $sEscapeMode = 'html')\n{\n    return quoteText(Yii::t('', $sTextToTranslate, $iCount), $sEscapeMode);\n}\n\n/**\n * Translation helper function for plural forms which outputs right away\n * @param string $sToTranslate\n * @param integer $iCount\n * @param string $sEscapeMode\n */\nfunction neT($sToTranslate, $iCount, $sEscapeMode = 'html')\n{\n    echo ngT($sToTranslate, $iCount, $sEscapeMode);\n}\n\n\n/**\n * Quotes a translation according to purpose\n * if sEscapeMode is null, we use HTML method because probably we had to specify null as sEscapeMode upstream\n *\n * @param mixed $sText Text to quote\n * @param string $sEscapeMode Optional - One of the values 'html','js' or 'unescaped' - defaults to 'html'\n * @return mixed|string\n */\nfunction quoteText($sText, $sEscapeMode = 'html')\n{\n    if ($sEscapeMode === null) {\n            $sEscapeMode = 'html';\n    }\n\n    switch ($sEscapeMode) {\n        case 'html':\n            return HTMLEscape($sText);\n        case 'js':\n            return javascriptEscape($sText);\n        case 'json':\n            return jsonEscape($sText);\n        case 'unescaped':\n            return $sText;\n        default:\n            return \"Unsupported EscapeMode in gT method\";\n    }\n}\n\n/**\n* getQuestionTypeList() Returns list of question types available in LimeSurvey. Edit this if you are adding a new\n*    question type\n*\n* @param string $SelectedCode Value of the Question Type (defaults to \"T\")\n* @param string $ReturnType Type of output from this function (defaults to selector)\n*\n* @return array|string depending on $ReturnType param, returns a straight \"array\" of question types, or an <option></option> list\n*\n* Explanation of questiontype array:\n*\n* description : Question description\n* subquestions : 0= Does not support subquestions x=Number of subquestion scales\n* answerscales : 0= Does not need answers x=Number of answer scales (usually 1, but e.g. for dual scale question set to 2)\n* assessable : 0=Does not support assessment values when editing answerd 1=Support assessment values\n*/\nfunction getQuestionTypeList($SelectedCode = \"T\", $ReturnType = \"selector\")\n{\n\n    $qtypes = Question::typeList();\n\n    if ($ReturnType == \"array\") {\n        return $qtypes;\n    }\n\n\n    if ($ReturnType == \"group\") {\n        $newqType = [];\n        foreach ($qtypes as $qkey => $qtype) {\n            $newqType[$qtype['group']][$qkey] = $qtype;\n        }\n\n\n        $qtypeselecter = \"\";\n        foreach ($newqType as $group => $members) {\n            $qtypeselecter .= '<optgroup label=\"'.$group.'\">';\n            foreach ($members as $TypeCode => $TypeProperties) {\n                $qtypeselecter .= \"<option value='$TypeCode'\";\n                if ($SelectedCode == $TypeCode) {\n                    $qtypeselecter .= \" selected='selected'\";\n                }\n                $qtypeselecter .= \">{$TypeProperties['description']}</option>\\n\";\n            }\n            $qtypeselecter .= '</optgroup>';\n        }\n\n        return $qtypeselecter;\n    };\n    $qtypeselecter = \"\";\n    foreach ($qtypes as $TypeCode => $TypeProperties) {\n        $qtypeselecter .= \"<option value='$TypeCode'\";\n        if ($SelectedCode == $TypeCode) {\n            $qtypeselecter .= \" selected='selected'\";\n        }\n        $qtypeselecter .= \">{$TypeProperties['description']}</option>\\n\";\n    }\n\n\n    return $qtypeselecter;\n}\n\n/**\n* isStandardTemplate returns true if a template is a standard template\n* This function does not check if a template actually exists\n*\n* @param mixed $sTemplateName template name to look for\n* @return bool True if standard template, otherwise false\n*/\nfunction isStandardTemplate($sTemplateName)\n{\n    return Template::isStandardTemplate($sTemplateName);\n}\n\n/**\n* getSurveyList() Queries the database (survey table) for a list of existing surveys\n*\n* @param boolean $bReturnArray If set to true an array instead of an HTML option list is given back\n* @return string|array This string is returned containing <option></option> formatted list of existing surveys\n*\n*/\nfunction getSurveyList($bReturnArray = false)\n{\n    static $cached = null;\n    $bCheckIntegrity = false;\n    $timeadjust = getGlobalSetting('timeadjust');\n    App()->setLanguage((isset(Yii::app()->session['adminlang']) ? Yii::app()->session['adminlang'] : 'en'));\n    $surveynames = array();\n\n    if (is_null($cached)) {\n        $surveyidresult = Survey::model()\n            ->permission(Yii::app()->user->getId())\n            ->with('languagesettings')\n            ->findAll();\n        foreach ($surveyidresult as $result) {\n            $surveynames[] = array_merge($result->attributes, $result->languagesettings[$result->language]->attributes);\n        }\n        \n        usort($surveynames, function($a, $b)\n        {\n                return strcmp($a['surveyls_title'], $b['surveyls_title']);\n        });\n        $cached = $surveynames;\n    } else {\n        $surveynames = $cached;\n    }\n    $surveyselecter = \"\";\n    if ($bReturnArray === true) {\n        return $surveynames;\n    }\n    $activesurveys = '';\n    $inactivesurveys = '';\n    $expiredsurveys = '';\n    foreach ($surveynames as $sv) {\n\n        $surveylstitle = flattenText($sv['surveyls_title']);\n        if (strlen($surveylstitle) > 70) {\n            $surveylstitle = htmlspecialchars(mb_strcut(html_entity_decode($surveylstitle, ENT_QUOTES, 'UTF-8'), 0, 70, 'UTF-8')).\"...\";\n        }\n\n        if ($sv['active'] != 'Y') {\n            $inactivesurveys .= \"<option \";\n            if (Yii::app()->user->getId() == $sv['owner_id']) {\n                $inactivesurveys .= \" class='mysurvey emphasis'\";\n            }\n            $inactivesurveys .= \" value='{$sv['sid']}'>{$surveylstitle}</option>\\n\";\n        } elseif ($sv['expires'] != '' && $sv['expires'] < dateShift((string) date(\"Y-m-d H:i:s\"), \"Y-m-d H:i:s\", $timeadjust)) {\n            $expiredsurveys .= \"<option \";\n            if (Yii::app()->user->getId() == $sv['owner_id']) {\n                $expiredsurveys .= \" class='mysurvey emphasis'\";\n            }\n            $expiredsurveys .= \" value='{$sv['sid']}'>{$surveylstitle}</option>\\n\";\n        } else {\n            $activesurveys .= \"<option \";\n            if (Yii::app()->user->getId() == $sv['owner_id']) {\n                $activesurveys .= \" class='mysurvey emphasis'\";\n            }\n            $activesurveys .= \" value='{$sv['sid']}'>{$surveylstitle}</option>\\n\";\n        }\n    } // End Foreach\n\n    //Only show each activesurvey group if there are some\n    if ($activesurveys != '') {\n        $surveyselecter .= \"<optgroup label='\".gT(\"Active\").\"' class='activesurveyselect'>\\n\";\n        $surveyselecter .= $activesurveys.\"</optgroup>\";\n    }\n    if ($expiredsurveys != '') {\n        $surveyselecter .= \"<optgroup label='\".gT(\"Expired\").\"' class='expiredsurveyselect'>\\n\";\n        $surveyselecter .= $expiredsurveys.\"</optgroup>\";\n    }\n    if ($inactivesurveys != '') {\n        $surveyselecter .= \"<optgroup label='\".gT(\"Inactive\").\"' class='inactivesurveyselect'>\\n\";\n        $surveyselecter .= $inactivesurveys.\"</optgroup>\";\n    }\n    $surveyselecter = \"<option selected='selected' value=''>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    return $surveyselecter;\n}\n\nfunction getTemplateList()\n{\n    return Template::getTemplateList();\n}\n\n\n/**\n* getGidPrevious() returns the Gid of the group prior to the current active group\n*\n* @param integer $surveyid\n* @param integer $gid\n*\n* @return integer|string The GID of the previous group or blank string if no group\n*/\nfunction getGidPrevious($surveyid, $gid)\n{\n    $surveyid = (int) $surveyid;\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n    $qresult = QuestionGroup::model()->findAllByAttributes(array('sid' => $surveyid, 'language' => $s_lang), array('order'=>'group_order'));\n\n    $i = 0;\n    $iPrev = -1;\n    foreach ($qresult as $qrow) {\n        $qrow = $qrow->attributes;\n        if ($gid == $qrow['gid']) {$iPrev = $i - 1; }\n        $i += 1;\n    }\n\n    if ($iPrev >= 0) {$GidPrev = $qresult[$iPrev]->gid; } else {$GidPrev = \"\"; }\n    return $GidPrev;\n}\n\n\n/**\n* getGidNext() returns the Gid of the group next to the current active group\n*\n* @param integer $surveyid\n* @param integer $gid\n*\n* @return integer|string The Gid of the next group or blank string if no group\n*/\nfunction getGidNext($surveyid, $gid)\n{\n    $surveyid = (int) $surveyid;\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n\n    $qresult = QuestionGroup::model()->findAllByAttributes(array('sid' => $surveyid, 'language' => $s_lang), array('order'=>'group_order'));\n\n    $i = 0;\n    $iNext = 0;\n\n    foreach ($qresult as $qrow) {\n        $qrow = $qrow->attributes;\n        if ($gid == $qrow['gid']) {\n            $iNext = $i + 1;\n        }\n        $i += 1;\n    }\n\n    if ($iNext < count($qresult)) {\n        $GidNext = $qresult[$iNext]->gid;\n    } else {\n        $GidNext = \"\";\n    }\n    return $GidNext;\n}\n\n\n/**\n * convertGETtoPOST a function to create a post Request from get parameters\n * !!! This functions result has to be wrappen in singlequotes!\n *\n * @param String $url | The complete url with all parameters\n * @return String | The onclick action for the element\n */\nfunction convertGETtoPOST($url)\n{\n    // This function must be deprecated and replaced by $.post\n    $url = preg_replace('/&amp;/i', '&', $url);\n    $stack = explode('?', $url);\n    $calledscript = array_shift($stack);\n    $query = array_shift($stack);\n    $aqueryitems = explode('&', $query);\n    $postArray = [];\n\n    foreach ($aqueryitems as $queryitem) {\n        $stack = explode('=', $queryitem);\n        $paramname = array_shift($stack);\n        $value = array_shift($stack);\n        $postArray[$paramname] = $value;\n    }\n\n    $callscript = \"window.LS.sendPost(\\\"\".$calledscript.\"\\\",\\\"\\\",\".json_encode($postArray).\");\";\n\n    return $callscript;\n}\n\n\n/**\n* This function calculates how much space is actually used by all files uploaded\n* using the File Upload question type\n*\n* @returns integer Actual space used in MB\n*/\nfunction calculateTotalFileUploadUsage()\n{\n    global $uploaddir;\n    $sQuery = 'select sid from {{surveys}}';\n    $oResult = dbExecuteAssoc($sQuery); //checked\n    $aRows = $oResult->readAll();\n    $iTotalSize = 0.0;\n    foreach ($aRows as $aRow) {\n        $sFilesPath = $uploaddir.'/surveys/'.$aRow['sid'].'/files';\n        if (file_exists($sFilesPath)) {\n            $iTotalSize += (float) getDirectorySize($sFilesPath);\n        }\n    }\n    return (float) $iTotalSize / 1024 / 1024;\n}\n\n/**\n * @param string $directory\n * @return int\n */\nfunction getDirectorySize($directory)\n{\n    $size = 0;\n    foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($directory)) as $file) {\n        $size += $file->getSize();\n    }\n    return $size;\n}\n\n\n\n/**\n * Queries the database for the maximum sortorder of a group and returns the next higher one.\n *\n * @param integer $surveyid\n * @return int\n */\nfunction getMaxGroupOrder($surveyid)\n{\n    $queryResult = QuestionGroup::model()->find(array(\n        'condition' => 'sid = :sid',\n        'params' => array(':sid' => $surveyid),\n        'order' => 'group_order desc',\n        'limit' => '1'\n    ));\n\n    $current_max = !is_null($queryResult) ? $queryResult->group_order : \"\";\n\n    if ($current_max !== \"\") {\n        $current_max += 1;\n        return $current_max;\n    } else {\n        return 0;\n    }\n}\n\n\n/**\n* getGroupOrder($surveyid,$gid) queries the database for the sortorder of a group.\n*\n* @param mixed $surveyid\n* @param mixed $gid\n* @return mixed\n*/\nfunction getGroupOrder($surveyid, $gid)\n{\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n    $grporder_result = QuestionGroup::model()->findByAttributes(array('sid' => $surveyid, 'gid' => $gid, 'language' => $s_lang)); //Checked\n    $grporder_row = $grporder_result->attributes;\n    $group_order = $grporder_row['group_order'];\n    if ($group_order == \"\") {\n        return \"0\";\n    } else {\n        return $group_order;\n    }\n}\n\n/**\n* Queries the database for the maximum sort order of a question.\n* \n* @param integer $gid\n* @param integer|null $surveyid\n* @return integer\n*/\nfunction getMaxQuestionOrder($gid, $surveyid)\n{\n    $gid = (int) $gid;\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n    $max_sql = \"SELECT max( question_order ) AS max FROM {{questions}} WHERE gid='{$gid}' AND language='{$s_lang}'\";\n    $max_result = Yii::app()->db->createCommand($max_sql)->query(); //Checked\n    $maxrow = $max_result->read();\n    $current_max = $maxrow['max'];\n    if ($current_max == \"\") {\n        return 0;\n    } else {\n        return (int) $current_max;\n    }\n}\n\n/**\n* getQuestionClass() returns a class name for a given question type to allow custom styling for each question type.\n*\n* @param string $input containing unique character representing each question type.\n* @return string containing the class name for a given question type.\n*/\nfunction getQuestionClass($input)\n{\n    Question::getQuestionClass($input);\n};\n\n/**\n* setupColumns() defines all the html tags to be wrapped around\n* various list type answers.\n*\n* @param integer $columns - the number of columns, usually supplied by $dcols\n* @param integer $answer_count - the number of answers to a question, usually supplied by $anscount\n* @param string $wrapperclass - a global class for the wrapper\n* @param string $itemclass - a class for the item\n* @return array with all the various opening and closing tags to generate a set of columns.\n*\n* It returns an array with the following items:\n*    $wrapper['whole-start']   = Opening wrapper for the whole list\n*    $wrapper['whole-end']     = closing wrapper for the whole list\n*    $wrapper['col-devide']    = normal column devider\n*    $wrapper['col-devide-last'] = the last column devider (to allow\n*                                for different styling of the last\n*                                column\n*    $wrapper['item-start']    = opening wrapper tag for individual\n*                                option\n*    $wrapper['item-start-other'] = opening wrapper tag for other\n*                                option\n*    $wrapper['item-start-noanswer'] = opening wrapper tag for no answer\n*                                option\n*    $wrapper['item-end']      = closing wrapper tag for individual\n*                                option\n*    $wrapper['maxrows']       = maximum number of rows in each\n*                                column\n*    $wrapper['cols']          = Number of columns to be inserted\n*                                (and checked against)\n*\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* Columns are a problem.\n* Really there is no perfect solution to columns at the moment.\n*\n* -  Using Tables is problematic semanticly.\n* -  Using inline or float to create columns, causes the answers\n*    flows horizontally, not vertically which is not ideal visually.\n* -  Using CSS3 columns is also a problem because of browser support\n*    and also because if you have answeres split across two or more\n*    lines, and those answeres happen to fall at the bottom of a\n*    column, the answer might be split across columns as well as\n*    lines.\n* -  Using nested unordered list with the first level of <LI>s\n*    floated is the same as using tables and so is bad semantically\n*    for the same reason tables are bad.\n* -  Breaking the unordered lists into consecutive floated unordered\n*    lists is not great semantically but probably not as bad as\n*    using tables.\n*\n* Because I haven't been able to decide which option is the least\n* bad, I have handed over that responsibility to the admin who sets\n* LimeSurvey up on their server.\n*\n* There are four options:\n*    'css'   using one of the various CSS only methods for\n*            rendering columns.\n*            (Check the CSS file for your chosen template to see\n*             how columns are defined.)\n*    'ul'    using multiple floated unordered lists. (DEFAULT)\n*    'table' using conventional tables based layout.\n*     NULL   blocks the use of columns\n*\n* 'ul' is the default because it's the best possible compromise\n* between semantic markup and visual layout.\n*/\nfunction setupColumns($columns, $answer_count, $wrapperclass = \"\", $itemclass = \"\")\n{\n\n    $column_style = Yii::app()->getConfig('column_style');\n    if (!in_array($column_style, array('css', 'ul', 'table')) && !is_null($column_style)) {\n        $column_style = 'ul';\n    };\n    if (!is_null($column_style) && $columns != 1) {\n// Add a global class for all column\n        $wrapperclass .= \" colstyle-{$column_style}\";\n    }\n    if ($columns < 2) {\n        $column_style = null;\n        $columns = 1;\n    }\n\n    if (($columns > $answer_count) && $answer_count > 0) {\n        $columns = $answer_count;\n    };\n\n\n    $class_first = ' class=\"'.$wrapperclass.'\"';\n    if ($columns > 1 && !is_null($column_style)) {\n        if ($column_style == 'ul') {\n            $ul = '-ul';\n        } else {\n            $ul = '';\n        }\n        $class_first = ' class=\"'.$wrapperclass.' cols-'.$columns.$ul.' first\"';\n        $class = ' class=\"'.$wrapperclass.' cols-'.$columns.$ul.'\"';\n        $class_last_ul = ' class=\"'.$wrapperclass.' cols-'.$columns.$ul.' last\"';\n        $class_last_table = ' class=\"'.$wrapperclass.' cols-'.$columns.' last\"';\n    } else {\n        $class = ' class=\"'.$wrapperclass.'\"';\n        $class_last_ul = ' class=\"'.$wrapperclass.'\"';\n        $class_last_table = ' class=\"'.$wrapperclass.'\"';\n    };\n\n    $wrapper = array(\n    'whole-start'  => \"\\n<ul$class_first>\\n\"\n    ,'whole-end'    => \"</ul>\\n\"\n    ,'col-devide'   => ''\n    ,'col-devide-last' => ''\n    ,'item-start'   => \"\\t<li class=\\\"{$itemclass}\\\">\\n\"\n    ,'item-start-other' => \"\\t<li class=\\\"{$itemclass} other other-item\\\">\\n\"\n    ,'item-start-noanswer' => \"\\t<li class=\\\"{$itemclass} noanswer-item\\\">\\n\"\n    ,'item-end' => \"\\t</li>\\n\"\n    ,'maxrows'  => ceil($answer_count / $columns) //Always rounds up to nearest whole number\n    ,'cols'     => $columns\n    );\n\n    switch ($column_style) {\n        case 'ul':  if ($columns > 1) {\n                $wrapper['col-devide'] = \"\\n</ul>\\n\\n<ul$class>\\n\";\n                $wrapper['col-devide-last'] = \"\\n</ul>\\n\\n<ul$class_last_ul>\\n\";\n            }\n            break;\n\n        case 'table':   $table_cols = '';\n            for ($cols = $columns; $cols > 0; --$cols) {\n                switch ($cols) {\n                    case $columns:  $table_cols .= \"\\t<col$class_first />\\n\";\n                        break;\n                    case 1:     $table_cols .= \"\\t<col$class_last_table />\\n\";\n                        break;\n                    default:    $table_cols .= \"\\t<col$class />\\n\";\n                };\n            };\n\n            if ($columns > 1) {\n                $wrapper['col-devide'] = \"\\t</ul>\\n</td>\\n\\n<td>\\n\\t<ul>\\n\";\n                $wrapper['col-devide-last'] = \"\\t</ul>\\n</td>\\n\\n<td class=\\\"last\\\">\\n\\t<ul>\\n\";\n            };\n            $wrapper['whole-start'] = \"\\n<table$class>\\n$table_cols\\n\\t<tbody>\\n<tr>\\n<td>\\n\\t<ul>\\n\";\n            $wrapper['whole-end']   = \"\\t</ul>\\n</td>\\n</tr>\\n\\t</tbody>\\n</table>\\n\";\n            $wrapper['item-start']  = \"<li class=\\\"{$itemclass}\\\">\\n\";\n            $wrapper['item-end']    = \"</li class=\\\"{$itemclass}\\\">\\n\";\n    };\n\n    return $wrapper;\n};\n\nfunction alternation($alternate = '', $type = 'col')\n{\n    /**\n     * alternation() Returns a class identifyer for alternating between\n     * two options. Used to style alternate elements differently. creates\n     * or alternates between the odd string and the even string used in\n     * as column and row classes for array type questions.\n     *\n     * @param string $alternate = '' (empty) (default) , 'array2' ,  'array1' , 'odd' , 'even'\n     * @param string  $type = 'col' (default) or 'row'\n     *\n     * @return string representing either the first alternation or the opposite alternation to the one supplied..\n     */\n    /*\n    // The following allows type to be left blank for row in subsequent\n    // function calls.\n    // It has been left out because 'row' must be defined the first time\n    // alternation() is called. Since it is only ever written once for each\n    // while statement within a function, 'row' is always defined.\n    if(!empty($alternate) && $type != 'row')\n    {   if($alternate == ('array2' || 'array1'))\n    {\n    $type = 'row';\n    };\n    };\n    // It has been left in case it becomes useful but probably should be\n    // removed.\n    */\n    if ($type == 'row') {\n// Row is sub question OR Y Axis subquestion : it must be column for array by column\n        $odd  = 'ls-odd';\n        $even = 'ls-even';\n    } else {\n// cols is answers part OR X axis subquestion : it must the row in array by column\n        $odd  = 'ls-col-odd';\n        $even = 'ls-col-even';\n    };\n    if ($alternate == $odd) {\n        $alternate = $even;\n    } else {\n        $alternate = $odd;\n    };\n    return $alternate;\n}\n\n\n/**\n* longestString() returns the length of the longest string past to it.\n* @peram string $new_string\n* @peram integer $longest_length length of the (previously) longest string passed to it.\n* @param integer $longest_length\n* @return integer representing the length of the longest string passed (updated if $new_string was longer than $longest_length)\n*\n* usage should look like this: $longest_length = longestString( $new_string , $longest_length );\n*\n*/\nfunction longestString($new_string, $longest_length)\n{\n    if ($longest_length < strlen(trim(strip_tags($new_string)))) {\n        $longest_length = strlen(trim(strip_tags($new_string)));\n    };\n    return $longest_length;\n};\n\n\n\n\n/**\n* getGroupList() queries the database for a list of all groups matching the current survey sid\n*\n*\n* @param string $gid - the currently selected gid/group\n* @param integer $surveyid\n*\n* @return string string is returned containing <option></option> formatted list of groups to current survey\n*/\nfunction getGroupList($gid, $surveyid)\n{\n\n    $groupselecter = \"\";\n    $gid = sanitize_int($gid);\n    $surveyid = sanitize_int($surveyid);\n    if (!$surveyid) {$surveyid = returnGlobal('sid', true); }\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n\n    $gidquery = \"SELECT gid, group_name FROM {{groups}} WHERE sid='{$surveyid}' AND  language='{$s_lang}' ORDER BY group_order\";\n    $gidresult = Yii::app()->db->createCommand($gidquery)->query(); //Checked\n    foreach ($gidresult->readAll() as $gv) {\n        $groupselecter .= \"<option\";\n        if ($gv['gid'] == $gid) {$groupselecter .= \" selected='selected'\"; $gvexist = 1; }\n        $groupselecter .= \" value='\".Yii::app()->getConfig('scriptname').\"?sid=$surveyid&amp;gid=\".$gv['gid'].\"'>\".htmlspecialchars($gv['group_name']).\"</option>\\n\";\n    }\n    if ($groupselecter) {\n        if (!isset($gvexist)) {$groupselecter = \"<option selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$groupselecter; } else {$groupselecter .= \"<option value='\".Yii::app()->getConfig('scriptname').\"?sid=$surveyid&amp;gid='>\".gT(\"None\").\"</option>\\n\"; }\n    }\n    return $groupselecter;\n}\n\n\n//FIXME rename and/or document this\nfunction getGroupList3($gid, $surveyid)\n{\n    //\n    $gid = sanitize_int($gid);\n    $surveyid = sanitize_int($surveyid);\n\n    if (!$surveyid) {$surveyid = returnGlobal('sid', true); }\n    $groupselecter = \"\";\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n\n\n    //$gidquery = \"SELECT gid, group_name FROM \".db_table_name('groups').\" WHERE sid=$surveyid AND language='{$s_lang}' ORDER BY group_order\";\n\n    $gidresult = QuestionGroup::model()->findAllByAttributes(array('sid' => $surveyid, 'language' => $s_lang), array('order'=>'group_order'));\n\n    foreach ($gidresult as $gv) {\n        $gv = $gv->attributes;\n        $groupselecter .= \"<option\";\n        if ($gv['gid'] == $gid) {$groupselecter .= \" selected='selected'\"; }\n        $groupselecter .= \" value='\".$gv['gid'].\"'>\".htmlspecialchars($gv['group_name']).\" (ID:\".$gv['gid'].\")</option>\\n\";\n    }\n\n\n    return $groupselecter;\n}\n\n/**\n * put your comment there...\n *\n * @param mixed $gid\n * @param mixed $language\n * @return string\n */\nfunction getGroupListLang($gid, $language, $surveyid)\n{\n    $groupselecter = \"\";\n    if (!$surveyid) {$surveyid = returnGlobal('sid', true); }\n\n    $gidresult = QuestionGroup::model()->findAll(array('condition'=>'sid=:surveyid AND language=:language',\n    'order'=>'group_order',\n    'params'=>array(':surveyid'=>$surveyid, ':language'=>$language))); //Checked)\n    foreach ($gidresult as $gv) {\n        $gv = $gv->attributes;\n        $groupselecter .= \"<option\";\n        if ($gv['gid'] == $gid) {$groupselecter .= \" selected='selected'\"; $gvexist = 1; }\n        $link = Yii::app()->getController()->createUrl(\"/admin/questiongroups/sa/view/surveyid/\".$surveyid.\"/gid/\".$gv['gid']);\n        $groupselecter .= \" value='{$link}'>\";\n        if (strip_tags($gv['group_name'])) {\n            $groupselecter .= htmlspecialchars(strip_tags($gv['group_name']));\n        } else {\n            $groupselecter .= htmlspecialchars($gv['group_name']);\n        }\n        $groupselecter .= \"</option>\\n\";\n    }\n    if ($groupselecter) {\n        $link = Yii::app()->getController()->createUrl(\"/admin/survey/sa/view/surveyid/\".$surveyid);\n        if (!isset($gvexist)) {$groupselecter = \"<option selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$groupselecter; } else {$groupselecter .= \"<option value='{$link}'>\".gT(\"None\").\"</option>\\n\"; }\n    }\n    return $groupselecter;\n}\n\n\nfunction getUserList($outputformat = 'fullinfoarray')\n{\n    if (!empty(Yii::app()->session['loginID'])) {\n        $myuid = sanitize_int(Yii::app()->session['loginID']);\n    }\n    $usercontrolSameGroupPolicy = Yii::app()->getConfig('usercontrolSameGroupPolicy');\n    if (!Permission::model()->hasGlobalPermission('superadmin', 'read') && isset($usercontrolSameGroupPolicy) &&\n    $usercontrolSameGroupPolicy == true) {\n        if (isset($myuid)) {\n            $sDatabaseType = Yii::app()->db->getDriverName();\n            if ($sDatabaseType == 'mssql' || $sDatabaseType == \"sqlsrv\" || $sDatabaseType == \"dblib\") {\n                $sSelectFields = 'users_name,uid,email,full_name,parent_id,CAST(password as varchar) as password';\n            } else {\n                $sSelectFields = 'users_name,uid,email,full_name,parent_id,password';\n            }\n\n            // List users from same group as me + all my childs\n            // a subselect is used here because MSSQL does not like to group by text\n            // also Postgres does like this one better\n            $uquery = \" SELECT {$sSelectFields} from {{users}} where uid in (\n                SELECT uid from {{user_in_groups}} where ugid in (\n                    SELECT ugid from {{user_in_groups}} where uid={$myuid}\n                    )\n                )\n            UNION\n            SELECT {$sSelectFields} from {{users}} v where v.parent_id={$myuid}\n            UNION\n            SELECT {$sSelectFields} from {{users}} v where uid={$myuid}\";\n\n        } else {\n            return array(); // Or die maybe\n        }\n\n    } else {\n        $uquery = \"SELECT * FROM {{users}} ORDER BY uid\";\n    }\n\n    $uresult = Yii::app()->db->createCommand($uquery)->query()->readAll(); //Checked\n\n    if (count($uresult) == 0 && !empty($myuid)) {\n//user is not in a group and usercontrolSameGroupPolicy is activated - at least show his own userinfo\n        $uquery = \"SELECT u.* FROM {{users}} AS u WHERE u.uid=\".$myuid;\n        $uresult = Yii::app()->db->createCommand($uquery)->query()->readAll(); //Checked\n    }\n\n    $userlist = array();\n    $userlist[0] = \"Reserved for logged in user\";\n    foreach ($uresult as $srow) {\n        if ($outputformat != 'onlyuidarray') {\n            if ($srow['uid'] != Yii::app()->session['loginID']) {\n                $userlist[] = array(\"user\"=>$srow['users_name'], \"uid\"=>$srow['uid'], \"email\"=>$srow['email'], \"password\"=>$srow['password'], \"full_name\"=>$srow['full_name'], \"parent_id\"=>$srow['parent_id']);\n            } else {\n                $userlist[0] = array(\"user\"=>$srow['users_name'], \"uid\"=>$srow['uid'], \"email\"=>$srow['email'], \"password\"=>$srow['password'], \"full_name\"=>$srow['full_name'], \"parent_id\"=>$srow['parent_id']);\n            }\n        } else {\n            if ($srow['uid'] != Yii::app()->session['loginID']) {\n                $userlist[] = $srow['uid'];\n            } else {\n                $userlist[0] = $srow['uid'];\n            }\n        }\n\n    }\n    return $userlist;\n}\n\n\n/**\n* Gets all survey infos in one big array including the language specific settings\n*\n* @param integer $surveyid  The survey ID\n* @param string $languagecode The language code - if not given the base language of the particular survey is used\n* @return array|bool Returns array with survey info or false, if survey does not exist\n*/\nfunction getSurveyInfo($surveyid, $languagecode = '')\n{\n    static $staticSurveyInfo = array(); // Use some static\n    $surveyid = sanitize_int($surveyid);\n    $languagecode = sanitize_languagecode($languagecode);\n    $thissurvey = false;\n    $oSurvey = Survey::model()->findByPk($surveyid);\n    // Do job only if this survey exist\n    if (!$oSurvey) {\n        return false;\n    }\n    // if no language code is set then get the base language one\n    if ((!isset($languagecode) || $languagecode == '')) {\n        $languagecode = Survey::model()->findByPk($surveyid)->language;\n    }\n\n    if (isset($staticSurveyInfo[$surveyid][$languagecode])) {\n        $thissurvey = $staticSurveyInfo[$surveyid][$languagecode];\n    } else {\n        $result = SurveyLanguageSetting::model()->with('survey')->findByPk(array('surveyls_survey_id' => $surveyid, 'surveyls_language' => $languagecode));\n        if (is_null($result)) {\n            // When additional language was added, but not saved it does not exists\n            // We should revert to the base language then\n            $languagecode = Survey::model()->findByPk($surveyid)->language;\n            $result = SurveyLanguageSetting::model()->with('survey')->findByPk(array('surveyls_survey_id' => $surveyid, 'surveyls_language' => $languagecode));\n        }\n        if ($result) {\n            $thissurvey = array_merge($result->survey->attributes, $result->attributes);\n            $thissurvey['name'] = $thissurvey['surveyls_title'];\n            $thissurvey['description'] = $thissurvey['surveyls_description'];\n            $thissurvey['welcome'] = $thissurvey['surveyls_welcometext'];\n            $thissurvey['datasecurity_notice_label'] = $thissurvey['surveyls_policy_notice_label'];\n            $thissurvey['datasecurity_error'] = $thissurvey['surveyls_policy_error'];\n            $thissurvey['datasecurity_notice'] = $thissurvey['surveyls_policy_notice'];\n            $thissurvey['templatedir'] = $thissurvey['template'];\n            $thissurvey['adminname'] = $thissurvey['admin'];\n            $thissurvey['tablename'] = $oSurvey->responsesTableName;\n            $thissurvey['urldescrip'] = $thissurvey['surveyls_urldescription'];\n            $thissurvey['url'] = $thissurvey['surveyls_url'];\n            $thissurvey['expiry'] = $thissurvey['expires'];\n            $thissurvey['email_invite_subj'] = $thissurvey['surveyls_email_invite_subj'];\n            $thissurvey['email_invite'] = $thissurvey['surveyls_email_invite'];\n            $thissurvey['email_remind_subj'] = $thissurvey['surveyls_email_remind_subj'];\n            $thissurvey['email_remind'] = $thissurvey['surveyls_email_remind'];\n            $thissurvey['email_confirm_subj'] = $thissurvey['surveyls_email_confirm_subj'];\n            $thissurvey['email_confirm'] = $thissurvey['surveyls_email_confirm'];\n            $thissurvey['email_register_subj'] = $thissurvey['surveyls_email_register_subj'];\n            $thissurvey['email_register'] = $thissurvey['surveyls_email_register'];\n            $thissurvey['attributedescriptions'] = $result->survey->tokenAttributes;\n            $thissurvey['attributecaptions'] = $result->attributeCaptions;\n            if (!isset($thissurvey['adminname'])) {$thissurvey['adminname'] = Yii::app()->getConfig('siteadminemail'); }\n            if (!isset($thissurvey['adminemail'])) {$thissurvey['adminemail'] = Yii::app()->getConfig('siteadminname'); }\n            if (!isset($thissurvey['urldescrip']) || $thissurvey['urldescrip'] == '') {$thissurvey['urldescrip'] = $thissurvey['surveyls_url']; }\n\n            $thissurvey['owner_username'] = $result->survey->owner->users_name;\n\n            $staticSurveyInfo[$surveyid][$languagecode] = $thissurvey;\n        }\n\n    }\n    $thissurvey['oSurvey'] = $oSurvey;\n    return $thissurvey;\n}\n\n/**\n* Returns the default email template texts as array\n*\n* @param mixed $sLanguage Required language translationb object\n* @param string $mode Escape mode for the translation function\n* @return array\n * // TODO move to template model\n*/\nfunction templateDefaultTexts($sLanguage, $mode = 'html', $sNewlines = 'text')\n{\n    \n    $aDefaultTexts = LsDefaultDataSets::getTemplateDefaultTexts($mode, $sLanguage);\n    \n    if ($sNewlines == 'html') {\n        $aDefaultTexts = array_map('nl2br', $aDefaultTexts);\n    }\n\n    return $aDefaultTexts;\n}\n\n/**\n* Compares two elements from an array (passed by the usort function)\n* and returns -1, 0 or 1 depending on the result of the comparison of\n* the sort order of the group_order and question_order field\n*\n* @param mixed $a\n* @param mixed $b\n* @return int\n*/\nfunction groupOrderThenQuestionOrder($a, $b)\n{\n    if (isset($a['group_order']) && isset($b['group_order'])) {\n        $GroupResult = strnatcasecmp($a['group_order'], $b['group_order']);\n    } else {\n        $GroupResult = \"\";\n    }\n    if ($GroupResult == 0) {\n        $TitleResult = strnatcasecmp($a[\"question_order\"], $b[\"question_order\"]);\n        return $TitleResult;\n    }\n    return $GroupResult;\n}\n\n\n//FIXME insert UestionGroup model to here\n/**\n * @param integer $sid\n * @param integer $gid\n * @param integer $shiftvalue\n */\nfunction shiftOrderQuestions($sid, $gid, $shiftvalue) //Function shifts the sortorder for questions\n{\n    $sid = (int) $sid;\n    $gid = (int) $gid;\n    $shiftvalue = (int) $shiftvalue;\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n\n    Question::model()->updateQuestionOrder($gid, $baselang, $shiftvalue);\n}\n\nfunction fixSortOrderGroups($surveyid) //Function rewrites the sortorder for groups\n{\n    $baselang = Survey::model()->findByPk($surveyid)->language;\n    QuestionGroup::model()->updateGroupOrder($surveyid, $baselang);\n}\n\n/**\n * @param integer $iSurveyID\n * @param integer $qid\n * @param integer $newgid\n */\nfunction fixMovedQuestionConditions($qid, $oldgid, $newgid, $iSurveyID = null) //Function rewrites the cfieldname for a question after group change\n{\n    if (!isset($iSurveyID)) {\n            $iSurveyID = Yii::app()->getConfig('sid');\n    }\n    $qid = (int) $qid;\n    $oldgid = (int) $oldgid;\n    $newgid = (int) $newgid;\n    Condition::model()->updateCFieldName($iSurveyID, $qid, $oldgid, $newgid);\n    // TMSW Condition->Relevance:  Call LEM->ConvertConditionsToRelevance() when done\n}\n\n\n/**\n * This function returns POST/REQUEST vars, for some vars like SID and others they are also sanitized\n * TODO: extends Yii:getParam\n *\n * @param string $stringname\n * @param boolean $bRestrictToString\n * @return array|bool|mixed|int|null\n */\nfunction returnGlobal($stringname, $bRestrictToString = false)\n{\n    $urlParam = Yii::app()->request->getParam($stringname);\n    $aCookies = Yii::app()->request->getCookies();\n    if (is_null($urlParam) && $stringname != 'sid') {\n        if (isset($aCookies[$stringname])) {\n            $urlParam = $aCookies[$stringname];\n        }\n    }\n    $bUrlParamIsArray = is_array($urlParam); // Needed to array map or if $bRestrictToString\n    if (!is_null($urlParam) && $stringname != '' && (!$bUrlParamIsArray || !$bRestrictToString)) {\n        if ($stringname == 'sid' || $stringname == \"gid\" || $stringname == \"oldqid\" ||\n        $stringname == \"qid\" || $stringname == \"tid\" ||\n        $stringname == \"lid\" || $stringname == \"ugid\" ||\n        $stringname == \"thisstep\" || $stringname == \"scenario\" ||\n        $stringname == \"cqid\" || $stringname == \"cid\" ||\n        $stringname == \"qaid\" || $stringname == \"scid\") {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_int\", $urlParam);\n            } else {\n                return sanitize_int($urlParam);\n            }\n        } elseif ($stringname == \"lang\" || $stringname == \"adminlang\") {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_languagecode\", $urlParam);\n            } else {\n                return sanitize_languagecode($urlParam);\n            }\n        } elseif ($stringname == \"htmleditormode\" ||\n        $stringname == \"subaction\" ||\n        $stringname == \"questionselectormode\" ||\n        $stringname == \"templateeditormode\"\n        ) {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_paranoid_string\", $urlParam);\n            } else {\n                return sanitize_paranoid_string($urlParam);\n            }\n        } elseif ($stringname == \"cquestions\") {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_cquestions\", $urlParam);\n            } else {\n                return sanitize_cquestions($urlParam);\n            }\n        }\n        return $urlParam;\n    } else {\n        return null;\n    }\n}\n\n\nfunction sendCacheHeaders()\n{\n    if (!headers_sent()) {\n        if (Yii::app()->getConfig('x_frame_options', 'allow') == 'sameorigin') {\n            header('X-Frame-Options: SAMEORIGIN');\n        }\n        header('P3P:CP=\"IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT\"'); // this line lets IE7 run LimeSurvey in an iframe\n        header(\"Expires: Mon, 26 Jul 1997 05:00:00 GMT\"); // Date in the past\n        header(\"Last-Modified: \".gmdate(\"D, d M Y H:i:s\").\" GMT\"); // always modified\n        header(\"Cache-Control: no-store, no-cache, must-revalidate\"); // HTTP/1.1\n        header(\"Cache-Control: post-check=0, pre-check=0\", false);\n        header(\"Pragma: no-cache\");\n        header('Content-Type: text/html; charset=utf-8');\n    }\n}\n\n/**\n* @param integer $iSurveyID The Survey ID\n* @param string $sFieldCode Field code of the particular field\n* @param string $sValue The stored response value\n* @param string $sLanguage Initialized limesurvey_lang object for the resulting response data\n* @return string\n*/\nfunction getExtendedAnswer($iSurveyID, $sFieldCode, $sValue, $sLanguage)\n{\n\n    if ($sValue == null || $sValue == '') {\n        return '';\n    }\n    $survey = Survey::model()->findByPk($iSurveyID);\n    //Fieldcode used to determine question, $sValue used to match against answer code\n    //Returns NULL if question type does not suit\n    if (strpos($sFieldCode, \"{$iSurveyID}X\") === 0) {\n//Only check if it looks like a real fieldcode\n        $fieldmap = createFieldMap($survey, 'short', false, false, $sLanguage);\n        if (isset($fieldmap[$sFieldCode])) {\n            $fields = $fieldmap[$sFieldCode];\n        } else {\n            return '';\n        }\n\n        // If it is a comment field there is nothing to convert here\n        if ($fields['aid'] == 'comment') {\n            return $sValue;\n        }\n\n        //Find out the question type\n        $this_type = $fields['type'];\n        switch ($this_type) {\n            case 'D':\n                if (trim($sValue) != '') {\n                    $qidattributes = QuestionAttribute::model()->getQuestionAttributes($fields['qid']);\n                    $dateformatdetails = getDateFormatDataForQID($qidattributes, $iSurveyID);\n                    $sValue = convertDateTimeFormat($sValue, \"Y-m-d H:i:s\", $dateformatdetails['phpdate']);\n                }\n                break;\n            case 'K':\n            case 'N':\n                if (trim($sValue) != '') {\n                    if (strpos($sValue, \".\") !== false) {\n                        $sValue = rtrim(rtrim($sValue, \"0\"), \".\");\n                    }\n                }\n                break;\n            case \"L\":\n            case \"!\":\n            case \"O\":\n            case \"^\":\n            case \"I\":\n            case \"R\":\n                $result = Answer::model()->getAnswerFromCode($fields['qid'], $sValue, $sLanguage);\n                foreach ($result as $row) {\n                    $this_answer = $row['answer'];\n                } // while\n                if ($sValue == \"-oth-\") {\n                    $this_answer = gT(\"Other\", null, $sLanguage);\n                }\n                break;\n            case \"M\":\n            case \"J\":\n            case \"P\":\n            switch ($sValue) {\n                case \"Y\": $this_answer = gT(\"Yes\", null, $sLanguage); break;\n            }\n            break;\n            case \"Y\":\n            switch ($sValue) {\n                case \"Y\": $this_answer = gT(\"Yes\", null, $sLanguage); break;\n                case \"N\": $this_answer = gT(\"No\", null, $sLanguage); break;\n                default: $this_answer = gT(\"No answer\", null, $sLanguage);\n            }\n            break;\n            case \"G\":\n            switch ($sValue) {\n                case \"M\": $this_answer = gT(\"Male\", null, $sLanguage); break;\n                case \"F\": $this_answer = gT(\"Female\", null, $sLanguage); break;\n                default: $this_answer = gT(\"No answer\", null, $sLanguage);\n            }\n            break;\n            case \"C\":\n            switch ($sValue) {\n                case \"Y\": $this_answer = gT(\"Yes\", null, $sLanguage); break;\n                case \"N\": $this_answer = gT(\"No\", null, $sLanguage); break;\n                case \"U\": $this_answer = gT(\"Uncertain\", null, $sLanguage); break;\n            }\n            break;\n            case \"E\":\n            switch ($sValue) {\n                case \"I\": $this_answer = gT(\"Increase\", null, $sLanguage); break;\n                case \"D\": $this_answer = gT(\"Decrease\", null, $sLanguage); break;\n                case \"S\": $this_answer = gT(\"Same\", null, $sLanguage); break;\n            }\n            break;\n            case \"F\":\n            case \"H\":\n            case \"1\":\n                if (isset($fields['scale_id'])) {\n                    $iScaleID = $fields['scale_id'];\n                } else {\n                    $iScaleID = 0;\n                }\n                $result = Answer::model()->getAnswerFromCode($fields['qid'], $sValue, $sLanguage, $iScaleID);\n                foreach ($result as $row) {\n                    $this_answer = $row['answer'];\n                } // while\n                if ($sValue == \"-oth-\") {\n                    $this_answer = gT(\"Other\", null, $sLanguage);\n                }\n                break;\n            case \"|\": //File upload\n                if (substr($sFieldCode, -9) != 'filecount') {\n                    //Show the filename, size, title and comment -- no link!\n                    $files = json_decode($sValue, true);\n                    $sValue = '';\n                    if (is_array($files)) {\n                        foreach ($files as $file) {\n                            if (!isset($file['title'])) {\n                                $file['title'] = '';\n                            }\n                            if (!isset($file['comment'])) {\n                                $file['comment'] = '';\n                            }\n                            $sValue .= rawurldecode($file['name']).\n                            ' ('.round($file['size']).'KB) '.\n                            strip_tags($file['title']);\n                            if (trim(strip_tags($file['comment'])) != \"\") {\n                                $sValue .= ' - '.strip_tags($file['comment']);\n                            }\n\n                        }\n                    }\n                }\n                break;\n            default:\n                ;\n        } // switch\n    }\n    switch ($sFieldCode) {\n        case 'submitdate':\n        case 'startdate':\n        case 'datestamp':\n            if (trim($sValue) != '') {\n                $dateformatdetails = getDateFormatDataForQID(null, $iSurveyID);\n                $sValue = convertDateTimeFormat($sValue, \"Y-m-d H:i:s\", $dateformatdetails['phpdate'].' H:i:s');\n            }\n            break;\n    }\n    if (isset($this_answer)) {\n        return $this_answer.\" [$sValue]\";\n    } else {\n        return $sValue;\n    }\n}\n\n/**\n* Validate an email address - also supports IDN email addresses\n* @returns True/false for valid/invalid\n*\n* @param mixed $sEmailAddress  Email address to check\n*/\nfunction validateEmailAddress($sEmailAddress)\n{\n    require_once(APPPATH.'third_party/idna-convert/idna_convert.class.php');\n    $oIdnConverter = new idna_convert();\n    $sEmailAddress = $oIdnConverter->encode($sEmailAddress);\n    $bResult = filter_var($sEmailAddress, FILTER_VALIDATE_EMAIL);\n    if ($bResult !== false) {\n        return true;\n    }\n    return false;\n}\n\n/**\n* Validate an list of email addresses - either as array or as semicolon-limited text\n* @return string List with valid email addresses - invalid email addresses are filtered - false if none of the email addresses are valid\n*\n* @param string $aEmailAddressList  Email address to check\n* @returns array\n*/\nfunction validateEmailAddresses($aEmailAddressList)\n{\n    $aOutList = [];\n    if (!is_array($aEmailAddressList)) {\n        $aEmailAddressList = explode(';', $aEmailAddressList);\n    }\n\n    foreach ($aEmailAddressList as $sEmailAddress) {\n        $sEmailAddress = trim($sEmailAddress);\n        if (validateEmailAddress($sEmailAddress)) {\n            $aOutList[] = $sEmailAddress;\n        }\n    }\n    return $aOutList;\n}\n\n/**\n * This functions generates a a summary containing the SGQA for questions of a survey, enriched with options per question\n * It can be used for the generation of statistics. Derived from Statistics_userController\n * @param int $iSurveyID Id of the Survey in question\n * @param array $aFilters an array which is the result of a query in Questions model\n * @param string $sLanguage\n * @return array The summary\n */\nfunction createCompleteSGQA($iSurveyID, $aFilters, $sLanguage)\n{\n    $allfields = [];\n    foreach ($aFilters as $flt) {\n        Yii::app()->loadHelper(\"surveytranslator\");\n        $myfield = \"{$iSurveyID}X{$flt['gid']}X{$flt['qid']}\";\n        $oSurvey = Survey::model()->findByPk($iSurveyID);\n        $aAdditionalLanguages = array_filter(explode(\" \", $oSurvey->additional_languages));\n        if (is_null($sLanguage) || !in_array($sLanguage, $aAdditionalLanguages)) {\n            $sLanguage = $oSurvey->language;\n        }\n        switch ($flt['type']) {\n            case \"K\": // Multiple Numerical\n            case \"Q\": // Multiple Short Text\n                //get answers\n                $result = Question::model()->getQuestionsForStatistics('title as code, question as answer', \"parent_qid=$flt[qid] AND language = '{$sLanguage}'\", 'question_order');\n\n                //go through all the (multiple) answers\n                foreach ($result as $row) {\n                    $myfield2 = $flt['type'].$myfield.reset($row);\n                    $allfields[] = $myfield2;\n                }\n                break;\n            case \"A\": // ARRAY OF 5 POINT CHOICE QUESTIONS\n            case \"B\": // ARRAY OF 10 POINT CHOICE QUESTIONS\n            case \"C\": // ARRAY OF YES\\No\\gT(\"Uncertain\") QUESTIONS\n            case \"E\": // ARRAY OF Increase/Same/Decrease QUESTIONS\n            case \"F\": // FlEXIBLE ARRAY\n            case \"H\": // ARRAY (By Column)\n                //get answers\n                $result = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}'\", 'question_order');\n\n                //go through all the (multiple) answers\n                foreach ($result as $row) {\n                    $myfield2 = $myfield.reset($row);\n                    $allfields[] = $myfield2;\n                }\n                break;\n                // all \"free text\" types (T, U, S)  get the same prefix (\"T\")\n            case \"T\": // Long free text\n            case \"U\": // Huge free text\n            case \"S\": // Short free text\n                $myfield = \"T$myfield\";\n                $allfields[] = $myfield;\n                break;\n            case \";\":  //ARRAY (Multi Flex) (Text)\n            case \":\":  //ARRAY (Multi Flex) (Numbers)\n                $result = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}' AND scale_id = 0\", 'question_order');\n\n                foreach ($result as $row) {\n                    $fresult = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}' AND scale_id = 1\", 'question_order');\n                    foreach ($fresult as $frow) {\n                        $myfield2 = $myfield.reset($row).\"_\".$frow['title'];\n                        $allfields[] = $myfield2;\n                    }\n                }\n                break;\n            case \"R\": //RANKING\n                //get some answers\n                $result = Answer::model()->getQuestionsForStatistics('code, answer', \"qid=$flt[qid] AND language = '{$sLanguage}'\", 'sortorder, answer');\n                //get number of answers\n                //loop through all answers. if there are 3 items to rate there will be 3 statistics\n                $i = 0;\n                foreach ($result as $row) {\n                    $i++;\n                    $myfield2 = \"R\".$myfield.$i.\"-\".strlen($i);\n                    $allfields[] = $myfield2;\n                }\n\n                break;\n                //Boilerplate questions are only used to put some text between other questions -> no analysis needed\n            case \"X\":  //This is a boilerplate question and it has no business in this script\n                break;\n            case \"1\": // MULTI SCALE\n                //get answers\n                $result = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}'\", 'question_order');\n                //loop through answers\n                foreach ($result as $row) {\n                    //----------------- LABEL 1 ---------------------\n                    $myfield2 = $myfield.reset($row).\"#0\";\n                    $allfields[] = $myfield2;\n                    //----------------- LABEL 2 ---------------------\n                    $myfield2 = $myfield.reset($row).\"#1\";\n                    $allfields[] = $myfield2;\n                }   //end WHILE -> loop through all answers\n                break;\n\n            case \"P\":  //P - Multiple choice with comments\n            case \"M\":  //M - Multiple choice\n            case \"N\":  //N - Numerical input\n            case \"D\":  //D - Date\n                $myfield2 = $flt['type'].$myfield;\n                $allfields[] = $myfield2;\n                break;\n            default:   //Default settings\n                $allfields[] = $myfield;\n                break;\n\n        } //end switch\n    }\n\n    return $allfields;\n\n}\n\n\n\n\n\n/**\n* This function generates an array containing the fieldcode, and matching data in the same order as the activate script\n*\n* @param Survey $survey\n* @param string $style 'short' (default) or 'full' - full creates extra information like default values\n* @param boolean $force_refresh - Forces to really refresh the array, not just take the session copy\n* @param bool|int $questionid Limit to a certain qid only (for question preview) - default is false\n* @param string $sLanguage The language to use\n* @param array $aDuplicateQIDs\n* @return array\n*/\nfunction createFieldMap($survey, $style = 'short', $force_refresh = false, $questionid = false, $sLanguage = '', &$aDuplicateQIDs = array())\n{\n\n    $sLanguage = sanitize_languagecode($sLanguage);\n    $surveyid = $survey->sid;\n    //checks to see if fieldmap has already been built for this page.\n    if (isset(Yii::app()->session['fieldmap-'.$surveyid.$sLanguage]) && !$force_refresh && $questionid === false) {\n        return Yii::app()->session['fieldmap-'.$surveyid.$sLanguage];\n    }\n    /* Check if $sLanguage is a survey valid language (else $fieldmap is empty) */\n    if ($sLanguage == '' || !in_array($sLanguage, $survey->allLanguages)) {\n        $sLanguage = $survey->language;\n    }\n    $fieldmap = [];\n    $fieldmap[\"id\"] = array(\"fieldname\"=>\"id\", 'sid'=>$surveyid, 'type'=>\"id\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"id\"]['title'] = \"\";\n        $fieldmap[\"id\"]['question'] = gT(\"Response ID\");\n        $fieldmap[\"id\"]['group_name'] = \"\";\n    }\n\n    $fieldmap[\"submitdate\"] = array(\"fieldname\"=>\"submitdate\", 'type'=>\"submitdate\", 'sid'=>$surveyid, \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"submitdate\"]['title'] = \"\";\n        $fieldmap[\"submitdate\"]['question'] = gT(\"Date submitted\");\n        $fieldmap[\"submitdate\"]['group_name'] = \"\";\n    }\n\n    $fieldmap[\"lastpage\"] = array(\"fieldname\"=>\"lastpage\", 'sid'=>$surveyid, 'type'=>\"lastpage\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"lastpage\"]['title'] = \"\";\n        $fieldmap[\"lastpage\"]['question'] = gT(\"Last page\");\n        $fieldmap[\"lastpage\"]['group_name'] = \"\";\n    }\n\n    $fieldmap[\"startlanguage\"] = array(\"fieldname\"=>\"startlanguage\", 'sid'=>$surveyid, 'type'=>\"startlanguage\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"startlanguage\"]['title'] = \"\";\n        $fieldmap[\"startlanguage\"]['question'] = gT(\"Start language\");\n        $fieldmap[\"startlanguage\"]['group_name'] = \"\";\n    }\n\n    $fieldmap['seed'] = array('fieldname' => 'seed', 'sid' => $surveyid, 'type' => 'seed', 'gid' => '', 'qid' => '', 'aid' => '');\n    if ($style == 'full') {\n        $fieldmap[\"seed\"]['title'] = \"\";\n        $fieldmap[\"seed\"]['question'] = gT(\"Seed\");\n        $fieldmap[\"seed\"]['group_name'] = \"\";\n    }\n\n    //Check for any additional fields for this survey and create necessary fields (token and datestamp and ipaddr)\n    $prow = $survey->getAttributes(); //Checked\n\n    if ($prow['anonymized'] == \"N\" && $survey->hasTokensTable) {\n        $fieldmap[\"token\"] = array(\"fieldname\"=>\"token\", 'sid'=>$surveyid, 'type'=>\"token\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"token\"]['title'] = \"\";\n            $fieldmap[\"token\"]['question'] = gT(\"Token\");\n            $fieldmap[\"token\"]['group_name'] = \"\";\n        }\n    }\n    if ($prow['datestamp'] == \"Y\") {\n        $fieldmap[\"startdate\"] = array(\"fieldname\"=>\"startdate\",\n        'type'=>\"startdate\",\n        'sid'=>$surveyid,\n        \"gid\"=>\"\",\n        \"qid\"=>\"\",\n        \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"startdate\"]['title'] = \"\";\n            $fieldmap[\"startdate\"]['question'] = gT(\"Date started\");\n            $fieldmap[\"startdate\"]['group_name'] = \"\";\n        }\n\n        $fieldmap[\"datestamp\"] = array(\"fieldname\"=>\"datestamp\",\n        'type'=>\"datestamp\",\n        'sid'=>$surveyid,\n        \"gid\"=>\"\",\n        \"qid\"=>\"\",\n        \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"datestamp\"]['title'] = \"\";\n            $fieldmap[\"datestamp\"]['question'] = gT(\"Date last action\");\n            $fieldmap[\"datestamp\"]['group_name'] = \"\";\n        }\n\n    }\n    if ($prow['ipaddr'] == \"Y\") {\n        $fieldmap[\"ipaddr\"] = array(\"fieldname\"=>\"ipaddr\",\n        'type'=>\"ipaddress\",\n        'sid'=>$surveyid,\n        \"gid\"=>\"\",\n        \"qid\"=>\"\",\n        \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"ipaddr\"]['title'] = \"\";\n            $fieldmap[\"ipaddr\"]['question'] = gT(\"IP address\");\n            $fieldmap[\"ipaddr\"]['group_name'] = \"\";\n        }\n    }\n    // Add 'refurl' to fieldmap.\n    if ($prow['refurl'] == \"Y\") {\n        $fieldmap[\"refurl\"] = array(\"fieldname\"=>\"refurl\", 'type'=>\"url\", 'sid'=>$surveyid, \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"refurl\"]['title'] = \"\";\n            $fieldmap[\"refurl\"]['question'] = gT(\"Referrer URL\");\n            $fieldmap[\"refurl\"]['group_name'] = \"\";\n        }\n    }\n\n    $sOldLanguage = App()->language;\n    App()->setLanguage($sLanguage);\n    // Collect all default values once so don't need separate query for each question with defaults\n    // First collect language specific defaults\n    $defaultsQuery = \"SELECT a.qid, a.sqid, a.scale_id, a.specialtype, a.defaultvalue\"\n    . \" FROM {{defaultvalues}} as a, {{questions}} as b\"\n    . \" WHERE a.qid = b.qid\"\n    . \" AND a.language = b.language\"\n    . \" AND a.language = '{$sLanguage}'\"\n    . \" AND b.same_default=0\"\n    . \" AND b.sid = \".$surveyid;\n    $defaultResults = Yii::app()->db->createCommand($defaultsQuery)->queryAll();\n\n    $defaultValues = array(); // indexed by question then subquestion\n    foreach ($defaultResults as $dv) {\n        if ($dv['specialtype'] != '') {\n            $sq = $dv['specialtype'];\n        } else {\n            $sq = $dv['sqid'];\n        }\n        $defaultValues[$dv['qid'].'~'.$sq] = $dv['defaultvalue'];\n    }\n\n    // Now overwrite language-specific defaults (if any) base language values for each question that uses same_defaults=1\n    $baseLanguage = $survey->language;\n    $defaultsQuery = \"SELECT a.qid, a.sqid, a.scale_id, a.specialtype, a.defaultvalue\"\n    . \" FROM {{defaultvalues}} as a, {{questions}} as b\"\n    . \" WHERE a.qid = b.qid\"\n    . \" AND a.language = b.language\"\n    . \" AND a.language = '{$baseLanguage}'\"\n    . \" AND b.same_default=1\"\n    . \" AND b.sid = \".$surveyid;\n    $defaultResults = Yii::app()->db->createCommand($defaultsQuery)->queryAll();\n\n    foreach ($defaultResults as $dv) {\n        if ($dv['specialtype'] != '') {\n            $sq = $dv['specialtype'];\n        } else {\n            $sq = $dv['sqid'];\n        }\n        $defaultValues[$dv['qid'].'~'.$sq] = $dv['defaultvalue'];\n    }\n    $qtypes = getQuestionTypeList('', 'array');\n\n    // Main query\n    $aquery = \"SELECT * \"\n    .\" FROM {{questions}} as questions, {{groups}} as question_groups\"\n    .\" WHERE questions.gid=question_groups.gid AND \"\n    .\" questions.sid=$surveyid AND \"\n    .\" questions.language='{$sLanguage}' AND \"\n    .\" questions.parent_qid=0 AND \"\n    .\" question_groups.language='{$sLanguage}' \";\n    if ($questionid !== false) {\n        $aquery .= \" and questions.qid={$questionid} \";\n    }\n    $aquery .= \" ORDER BY group_order, question_order\";\n    /** @var Question[] $questions */\n    $questions = Yii::app()->db->createCommand($aquery)->queryAll();\n    $questionSeq = -1; // this is incremental question sequence across all groups\n    $groupSeq = -1;\n    $_groupOrder = -1;\n\n    foreach ($questions as $arow) {\n//With each question, create the appropriate field(s))\n        ++$questionSeq;\n\n        // fix fact taht group_order may have gaps\n        if ($_groupOrder != $arow['group_order']) {\n            $_groupOrder = $arow['group_order'];\n            ++$groupSeq;\n        }\n        // Condition indicators are obsolete with EM.  However, they are so tightly coupled into LS code that easider to just set values to 'N' for now and refactor later.\n        $conditions = 'N';\n        $usedinconditions = 'N';\n\n        // Field identifier\n        // GXQXSXA\n        // G=Group  Q=Question S=Subquestion A=Answer Option\n        // If S or A don't exist then set it to 0\n        // Implicit (subqestion intermal to a question type ) or explicit qubquestions/answer count starts at 1\n\n        // Types \"L\", \"!\", \"O\", \"D\", \"G\", \"N\", \"X\", \"Y\", \"5\", \"S\", \"T\", \"U\"\n        $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}\";\n\n        if ($qtypes[$arow['type']]['subquestions'] == 0 && $arow['type'] != \"R\" && $arow['type'] != \"|\") {\n            if (isset($fieldmap[$fieldname])) {\n                $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n            }\n\n            $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>\"{$arow['type']}\", 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>\"\");\n            \n            if ($style == \"full\") {\n                $fieldmap[$fieldname]['title'] = $arow['title'];\n                $fieldmap[$fieldname]['question'] = $arow['question'];\n                $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                if (isset($defaultValues[$arow['qid'].'~0'])) {\n                    $fieldmap[$fieldname]['defaultvalue'] = $defaultValues[$arow['qid'].'~0'];\n                }\n            }\n            switch ($arow['type']) {\n                case \"L\":  //RADIO LIST\n                case \"!\":  //DROPDOWN LIST\n                    if ($arow['other'] == \"Y\") {\n                        $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}other\";\n                        if (isset($fieldmap[$fieldname])) {\n                            $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                        }\n\n                        $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                        'type'=>$arow['type'],\n                        'sid'=>$surveyid,\n                        \"gid\"=>$arow['gid'],\n                        \"qid\"=>$arow['qid'],\n                        \"aid\"=>\"other\");\n                        // dgk bug fix line above. aid should be set to \"other\" for export to append to the field name in the header line.\n                        if ($style == \"full\") {\n                            $fieldmap[$fieldname]['title'] = $arow['title'];\n                            $fieldmap[$fieldname]['question'] = $arow['question'];\n                            $fieldmap[$fieldname]['subquestion'] = gT(\"Other\");\n                            $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                            $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                            $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                            $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                            $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                            $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                            if (isset($defaultValues[$arow['qid'].'~other'])) {\n                                $fieldmap[$fieldname]['defaultvalue'] = $defaultValues[$arow['qid'].'~other'];\n                            }\n                        }\n                    }\n                    break;\n                case \"O\": //DROPDOWN LIST WITH COMMENT\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}comment\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                    'type'=>$arow['type'],\n                    'sid'=>$surveyid,\n                    \"gid\"=>$arow['gid'],\n                    \"qid\"=>$arow['qid'],\n                    \"aid\"=>\"comment\");\n                    // dgk bug fix line below. aid should be set to \"comment\" for export to append to the field name in the header line. Also needed set the type element correctly.\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion'] = gT(\"Comment\");\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    }\n                    break;\n            }\n        }\n        // For Multi flexi question types\n        elseif ($qtypes[$arow['type']]['subquestions'] == 2 && $qtypes[$arow['type']]['answerscales'] == 0) {\n            //MULTI FLEXI\n            $abrows = getSubQuestions($surveyid, $arow['qid'], $sLanguage);\n            //Now first process scale=1\n            $answerset = array();\n            $answerList = array();\n            foreach ($abrows as $key=>$abrow) {\n                if ($abrow['scale_id'] == 1) {\n                    $answerset[] = $abrow;\n                    $answerList[] = array(\n                    'code'=>$abrow['title'],\n                    'answer'=>$abrow['question'],\n                    );\n                    unset($abrows[$key]);\n                }\n            }\n            reset($abrows);\n            foreach ($abrows as $abrow) {\n                foreach ($answerset as $answer) {\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}_{$answer['title']}\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                    'type'=>$arow['type'],\n                    'sid'=>$surveyid,\n                    \"gid\"=>$arow['gid'],\n                    \"qid\"=>$arow['qid'],\n                    \"aid\"=>$abrow['title'].\"_\".$answer['title'],\n                    \"sqid\"=>$abrow['qid']);\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion1'] = $abrow['question'];\n                        $fieldmap[$fieldname]['subquestion2'] = $answer['question'];\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                        $fieldmap[$fieldname]['preg'] = $arow['preg'];\n                        $fieldmap[$fieldname]['answerList'] = $answerList;\n                        $fieldmap[$fieldname]['SQrelevance'] = $abrow['relevance'];\n                    }\n                }\n            }\n            unset($answerset);\n        } elseif ($arow['type'] == \"1\") {\n            $abrows = getSubQuestions($surveyid, $arow['qid'], $sLanguage);\n            foreach ($abrows as $abrow) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}#0\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$abrow['title'], \"scale_id\"=>0);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = $abrow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['scale'] = gT('Scale 1');\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    $fieldmap[$fieldname]['SQrelevance'] = $abrow['relevance'];\n                }\n\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}#1\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$abrow['title'], \"scale_id\"=>1);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = $abrow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['scale'] = gT('Scale 2');\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    // TODO SQrelevance for different scales? $fieldmap[$fieldname]['SQrelevance']=$abrow['relevance'];\n                }\n            }\n        } elseif ($arow['type'] == \"R\") {\n            // Sub question by answer number OR attribute\n            $answersCount = intval(Answer::model()->countByAttributes(array('qid' => $arow['qid'], 'language' => $sLanguage)));\n            $maxDbAnswer = QuestionAttribute::model()->find(\"qid = :qid AND attribute = 'max_subquestions'\", array(':qid' => $arow['qid']));\n            $columnsCount = (!$maxDbAnswer || intval($maxDbAnswer->value) < 1) ? $answersCount : intval($maxDbAnswer->value);\n            for ($i = 1; $i <= $columnsCount; $i++) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}$i\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$i);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = sprintf(gT('Rank %s'), $i);\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                }\n            }\n        } elseif ($arow['type'] == \"|\") {\n            $qidattributes = QuestionAttribute::model()->getQuestionAttributes($arow['qid']);\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}\";\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                'type'=>$arow['type'],\n                'sid'=>$surveyid,\n                \"gid\"=>$arow['gid'],\n                \"qid\"=>$arow['qid'],\n                \"aid\"=>''\n                );\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['max_files'] = $qidattributes['max_num_of_files'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                }\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}\".\"_filecount\";\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                'type'=>$arow['type'],\n                'sid'=>$surveyid,\n                \"gid\"=>$arow['gid'],\n                \"qid\"=>$arow['qid'],\n                \"aid\"=>\"filecount\"\n                );\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = \"filecount - \".$arow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                }\n        } else {\n// Question types with subquestions and one answer per subquestion  (M/A/B/C/E/F/H/P)\n            //MULTI ENTRY\n            $abrows = getSubQuestions($surveyid, $arow['qid'], $sLanguage);\n            foreach ($abrows as $abrow) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}\";\n\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                'type'=>$arow['type'],\n                'sid'=>$surveyid,\n                'gid'=>$arow['gid'],\n                'qid'=>$arow['qid'],\n                'aid'=>$abrow['title'],\n                'sqid'=>$abrow['qid']);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = $abrow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    $fieldmap[$fieldname]['preg'] = $arow['preg'];\n                    // get SQrelevance from DB\n                    $fieldmap[$fieldname]['SQrelevance'] = $abrow['relevance'];\n                    if (isset($defaultValues[$arow['qid'].'~'.$abrow['qid']])) {\n                        $fieldmap[$fieldname]['defaultvalue'] = $defaultValues[$arow['qid'].'~'.$abrow['qid']];\n                    }\n                }\n                if ($arow['type'] == \"P\") {\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}comment\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$abrow['title'].\"comment\");\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion'] = gT('Comment');\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    }\n                }\n            }\n            if ($arow['other'] == \"Y\" && ($arow['type'] == \"M\" || $arow['type'] == \"P\")) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}other\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>\"other\");\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = gT('Other');\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    $fieldmap[$fieldname]['other'] = $arow['other'];\n                }\n                if ($arow['type'] == \"P\") {\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}othercomment\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>\"othercomment\");\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion'] = gT('Other comment');\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                        $fieldmap[$fieldname]['other'] = $arow['other'];\n                    }\n                }\n            }\n        }\n        if (isset($fieldmap[$fieldname])) {\n            //set question relevance (uses last SQ's relevance field for question relevance)\n            $fieldmap[$fieldname]['relevance'] = $arow['relevance'];\n            $fieldmap[$fieldname]['grelevance'] = $arow['grelevance'];\n            $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n            $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n            $fieldmap[$fieldname]['preg'] = $arow['preg'];\n            $fieldmap[$fieldname]['other'] = $arow['other'];\n            $fieldmap[$fieldname]['help'] = $arow['help'];\n\n            // Set typeName\n        } else {\n            --$questionSeq; // didn't generate a valid $fieldmap entry, so decrement the question counter to ensure they are sequential\n        }\n\n        if (isset($fieldmap[$fieldname]['typename'])) {\n                    $fieldmap[$fieldname]['typename'] = $typename[$fieldname] = $arow['typename'];\n        }\n    }\n    App()->setLanguage($sOldLanguage);\n\n    if ($questionid === false) {\n        // If the fieldmap was randomized, the master will contain the proper order.  Copy that fieldmap with the new language settings.\n        if (isset(Yii::app()->session['survey_'.$surveyid]['fieldmap-'.$surveyid.'-randMaster'])) {\n            $masterFieldmap = Yii::app()->session['survey_'.$surveyid]['fieldmap-'.$surveyid.'-randMaster'];\n            $mfieldmap = Yii::app()->session['survey_'.$surveyid][$masterFieldmap];\n\n            foreach ($mfieldmap as $fieldname => $mf) {\n                if (isset($fieldmap[$fieldname])) {\n                    // This array holds the keys of translatable attributes\n                    $translatable = array_flip(array('question', 'subquestion', 'subquestion1', 'subquestion2', 'group_name', 'answerList', 'defaultValue', 'help'));\n                    // We take all translatable attributes from the new fieldmap\n                    $newText = array_intersect_key($fieldmap[$fieldname], $translatable);\n                    // And merge them with the other values from the random fieldmap like questionSeq, groupSeq etc.\n                    $mf = $newText + $mf;\n                }\n                $mfieldmap[$fieldname] = $mf;\n            }\n            $fieldmap = $mfieldmap;\n        }\n\n        Yii::app()->session['fieldmap-'.$surveyid.$sLanguage] = $fieldmap;\n    }\n    return $fieldmap;\n}\n\n/**\n* Returns true if the given survey has a File Upload Question Type\n* @param integer $iSurveyID\n* @return bool\n*/\nfunction hasFileUploadQuestion($iSurveyID)\n{\n    $iCount = Question::model()->count(\"sid=:surveyid AND parent_qid=0 AND type='|'\", array(':surveyid' => $iSurveyID));\n    return $iCount > 0;\n}\n\n/**\n* This function generates an array containing the fieldcode, and matching data in the same order as the activate script\n*\n* @param string $surveyid The Survey ID\n* @param string $style 'short' (default) or 'full' - full creates extra information like default values\n* @param boolean $force_refresh - Forces to really refresh the array, not just take the session copy\n* @param int $questionid Limit to a certain qid only (for question preview) - default is false\n* @param string $sQuestionLanguage The language to use\n* @return array\n*/\nfunction createTimingsFieldMap($surveyid, $style = 'full', $force_refresh = false, $questionid = false, $sQuestionLanguage = null)\n{\n\n    static $timingsFieldMap;\n\n    $sLanguage = sanitize_languagecode($sQuestionLanguage);\n    $surveyid = sanitize_int($surveyid);\n    $survey = Survey::model()->findByPk($surveyid);\n\n    $sOldLanguage = App()->language;\n    App()->setLanguage($sLanguage);\n\n    //checks to see if fieldmap has already been built for this page.\n    if (isset($timingsFieldMap[$surveyid][$style][$sLanguage]) && $force_refresh === false) {\n        return $timingsFieldMap[$surveyid][$style][$sLanguage];\n    }\n\n    //do something\n    $fields = createFieldMap($survey, $style, $force_refresh, $questionid, $sQuestionLanguage);\n    $fieldmap = [];\n    $fieldmap['interviewtime'] = array('fieldname'=>'interviewtime', 'type'=>'interview_time', 'sid'=>$surveyid, 'gid'=>'', 'qid'=>'', 'aid'=>'', 'question'=>gT('Total time'), 'title'=>'interviewtime');\n    foreach ($fields as $field) {\n        if (!empty($field['gid'])) {\n            // field for time spent on page\n            $fieldname = \"{$field['sid']}X{$field['gid']}time\";\n            if (!isset($fieldmap[$fieldname])) {\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>\"page_time\", 'sid'=>$surveyid, \"gid\"=>$field['gid'], \"group_name\"=>$field['group_name'], \"qid\"=>'', 'aid'=>'', 'title'=>'groupTime'.$field['gid'], 'question'=>gT('Group time').\": \".$field['group_name']);\n            }\n\n            // field for time spent on answering a question\n            $fieldname = \"{$field['sid']}X{$field['gid']}X{$field['qid']}time\";\n            if (!isset($fieldmap[$fieldname])) {\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>\"answer_time\", 'sid'=>$surveyid, \"gid\"=>$field['gid'], \"group_name\"=>$field['group_name'], \"qid\"=>$field['qid'], 'aid'=>'', \"title\"=>$field['title'].'Time', \"question\"=>gT('Question time').\": \".$field['title']);\n            }\n        }\n    }\n\n    $timingsFieldMap[$surveyid][$style][$sLanguage] = $fieldmap;\n    App()->setLanguage($sOldLanguage);\n    return $timingsFieldMap[$surveyid][$style][$sLanguage];\n}\n\n/**\n *\n * @param mixed $needle\n * @param mixed $haystack\n * @param string $keyname\n * @param integer $maxanswers\n * @return array\n */\nfunction arraySearchByKey($needle, $haystack, $keyname, $maxanswers = \"\")\n{\n    $output = array();\n    foreach ($haystack as $hay) {\n        if (array_key_exists($keyname, $hay)) {\n            if ($hay[$keyname] == $needle) {\n                if ($maxanswers == 1) {\n                    return $hay;\n                } else {\n                    $output[] = $hay;\n                }\n            }\n        }\n    }\n    return $output;\n}\n\n/**\n* This function returns a count of the number of saved responses to a survey\n*\n* @param mixed $surveyid Survey ID\n*/\nfunction getSavedCount($surveyid)\n{\n    $surveyid = (int) $surveyid;\n\n    return SavedControl::model()->getCountOfAll($surveyid);\n}\n\n\nfunction buildLabelSetCheckSumArray()\n{\n    // BUILD CHECKSUMS FOR ALL EXISTING LABEL SETS\n\n    /**$query = \"SELECT lid\n    FROM \".db_table_name('labelsets').\"\n    ORDER BY lid\"; */\n    $result = LabelSet::model()->getLID(); //($query) or safeDie(\"safe_died collecting labelset ids<br />$query<br />\");  //Checked)\n    $csarray = array();\n    foreach ($result as $row) {\n        $thisset = \"\";\n        $query2 = \"SELECT code, title, sortorder, language, assessment_value\n        FROM {{labels}}\n        WHERE lid={$row['lid']}\n        ORDER BY language, sortorder, code\";\n        $result2 = Yii::app()->db->createCommand($query2)->query();\n        foreach ($result2->readAll() as $row2) {\n            $thisset .= implode('.', $row2);\n        } // while\n        $csarray[$row['lid']] = dechex(crc32($thisset) * 1);\n    }\n\n    return $csarray;\n}\n\n\n\n/**\n*\n* Returns the questionAttribtue value set or '' if not set\n* @author: lemeur\n* @param $questionAttributeArray\n* @param string $attributeName\n* @param $language string Optional: The language if the particualr attributes is localizable\n* @return string\n*/\nfunction getQuestionAttributeValue($questionAttributeArray, $attributeName, $language = '')\n{\n    if ($language == '' && isset($questionAttributeArray[$attributeName])) {\n        return $questionAttributeArray[$attributeName];\n    } elseif ($language != '' && isset($questionAttributeArray[$attributeName][$language])) {\n        return $questionAttributeArray[$attributeName][$language];\n    } else {\n        return '';\n    }\n}\n\n\nfunction categorySort($a, $b)\n{\n    $result = strnatcasecmp($a['category'], $b['category']);\n    if ($result == 0) {\n        $result = $a['sortorder'] - $b['sortorder'];\n    }\n    return $result;\n}\n\n\n\n\n// make a string safe to include in an HTML 'value' attribute.\nfunction HTMLEscape($str)\n{\n    // escape newline characters, too, in case we put a value from\n    // a TEXTAREA  into an <input type=\"hidden\"> value attribute.\n    return str_replace(array(\"\\x0A\", \"\\x0D\"), array(\"&#10;\", \"&#13;\"),\n    htmlspecialchars($str, ENT_QUOTES));\n}\n\n/**\n* This function strips UTF-8 control characters from strings, except tabs, CR and LF\n* - it is intended to be used before any response data is saved to the response table\n*\n* @param mixed $sValue A string to be sanitized\n* @return string A sanitized string, otherwise the unmodified original variable\n*/\nfunction stripCtrlChars($sValue)\n{\n    if (is_string($sValue)) {\n        $sValue = preg_replace('/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x80-\\x9F]/u', '', $sValue);\n    }\n    return $sValue;\n}\n\n// make a string safe to include in a JavaScript String parameter.\nfunction javascriptEscape($str, $strip_tags = false, $htmldecode = false)\n{\n\n    if ($htmldecode == true) {\n        $str = html_entity_decode($str, ENT_QUOTES, 'UTF-8');\n    }\n    if ($strip_tags == true) {\n        $str = strip_tags($str);\n    }\n    return str_replace(array('\\'', '\"', \"\\n\", \"\\r\"),\n    array(\"\\\\'\", '\\u0022', \"\\\\n\", '\\r'),\n    $str);\n}\n// make a string safe to include in a json String parameter.\nfunction jsonEscape($str, $strip_tags = false, $htmldecode = false)\n{\n\n    if ($htmldecode == true) {\n        $str = html_entity_decode($str, ENT_QUOTES, 'UTF-8');\n    }\n    if ($strip_tags == true) {\n        $str = strip_tags($str);\n    }\n    return str_replace(array('\"','\\''), array(\"&apos;\",\"&apos;\"), $str);\n}\n\n/**\n* This function mails a text $body to the recipient $to.\n* You can use more than one recipient when using a semicolon separated string with recipients.\n*\n* @param string $body Body text of the email in plain text or HTML\n* @param mixed $subject Email subject\n* @param mixed $to Array with several email addresses or single string with one email address\n* @param mixed $from\n* @param mixed $sitename\n* @param boolean $ishtml\n* @param mixed $bouncemail\n* @param mixed $attachments\n* @return bool If successful returns true\n*/\nfunction SendEmailMessage($body, $subject, $to, $from, $sitename, $ishtml = false, $bouncemail = null, $attachments = null, $customheaders = \"\")\n{\n    global $maildebug, $maildebugbody;\n    require_once(APPPATH.'/third_party/html2text/src/Html2Text.php');\n\n    $emailmethod = Yii::app()->getConfig('emailmethod');\n    $emailsmtphost = Yii::app()->getConfig(\"emailsmtphost\");\n    $emailsmtpuser = Yii::app()->getConfig(\"emailsmtpuser\");\n    $emailsmtppassword = Yii::app()->getConfig(\"emailsmtppassword\");\n    $emailsmtpdebug = Yii::app()->getConfig(\"emailsmtpdebug\");\n    $emailsmtpssl = Yii::app()->getConfig(\"emailsmtpssl\");\n    $defaultlang = Yii::app()->getConfig(\"defaultlang\");\n    $emailcharset = Yii::app()->getConfig(\"emailcharset\");\n\n    if ($emailcharset != 'utf-8') {\n        $body = mb_convert_encoding($body, $emailcharset, 'utf-8');\n        $subject = mb_convert_encoding($subject, $emailcharset, 'utf-8');\n        $sitename = mb_convert_encoding($sitename, $emailcharset, 'utf-8');\n    }\n\n    if (!is_array($to)) {\n        $to = array($to);\n    }\n\n\n\n    if (!is_array($customheaders) && $customheaders == '') {\n        $customheaders = array();\n    }\n    if (Yii::app()->getConfig('demoMode')) {\n        $maildebug = gT('Email was not sent because demo-mode is activated.');\n        $maildebugbody = '';\n        return false;\n    }\n\n    if (is_null($bouncemail)) {\n        $sender = $from;\n    } else {\n        $sender = $bouncemail;\n    }\n\n\n    require_once(APPPATH.'/third_party/phpmailer/load_phpmailer.php');\n    $mail = new PHPMailer\\PHPMailer\\PHPMailer;\n    $mail->SMTPAutoTLS = false;\n    if (!$mail->SetLanguage($defaultlang, APPPATH.'/third_party/phpmailer/language/')) {\n        $mail->SetLanguage('en', APPPATH.'/third_party/phpmailer/language/');\n    }\n    $mail->CharSet = $emailcharset;\n    if (isset($emailsmtpssl) && trim($emailsmtpssl) !== '' && $emailsmtpssl !== 0) {\n        if ($emailsmtpssl === 1) {$mail->SMTPSecure = \"ssl\"; } else {$mail->SMTPSecure = $emailsmtpssl; }\n    }\n\n    $fromname = '';\n    $fromemail = $from;\n    if (strpos($from, '<')) {\n        $fromemail = substr($from, strpos($from, '<') + 1, strpos($from, '>') - 1 - strpos($from, '<'));\n        $fromname = trim(substr($from, 0, strpos($from, '<') - 1));\n    }\n\n    $senderemail = $sender;\n    if (strpos($sender, '<')) {\n        $senderemail = substr($sender, strpos($sender, '<') + 1, strpos($sender, '>') - 1 - strpos($sender, '<'));\n    }\n\n    switch ($emailmethod) {\n        case \"qmail\":\n            $mail->IsQmail();\n            break;\n        case \"smtp\":\n            $mail->IsSMTP();\n            if ($emailsmtpdebug > 0) {\n                $mail->SMTPDebug = $emailsmtpdebug;\n            }\n            if (strpos($emailsmtphost, ':') > 0) {\n                $mail->Host = substr($emailsmtphost, 0, strpos($emailsmtphost, ':'));\n                $mail->Port = (int) substr($emailsmtphost, strpos($emailsmtphost, ':') + 1);\n            } else {\n                $mail->Host = $emailsmtphost;\n            }\n            $mail->Username = $emailsmtpuser;\n            $mail->Password = $emailsmtppassword;\n            if (trim($emailsmtpuser) != \"\") {\n                $mail->SMTPAuth = true;\n            }\n            break;\n        case \"sendmail\":\n            $mail->IsSendmail();\n            break;\n        default:\n            $mail->IsMail();\n    }\n\n    $mail->SetFrom($fromemail, $fromname);\n    $mail->Sender = $senderemail; // Sets Return-Path for error notifications\n    foreach ($to as $singletoemail) {\n        if (strpos($singletoemail, '<')) {\n            $toemail = substr($singletoemail, strpos($singletoemail, '<') + 1, strpos($singletoemail, '>') - 1 - strpos($singletoemail, '<'));\n            $toname = trim(substr($singletoemail, 0, strpos($singletoemail, '<') - 1));\n            $mail->AddAddress($toemail, $toname);\n        } else {\n            $mail->AddAddress($singletoemail);\n        }\n    }\n    if (is_array($customheaders)) {\n        foreach ($customheaders as $key=>$val) {\n            $mail->AddCustomHeader($val);\n        }\n    }\n    $mail->AddCustomHeader(\"X-Surveymailer: $sitename Emailer (LimeSurvey.org)\");\n    if (get_magic_quotes_gpc() != \"0\") {$body = stripcslashes($body); }\n    if ($ishtml) {\n        $mail->IsHTML(true);\n        if (strpos($body, \"<html>\") === false) {\n            $body = \"<html>\".$body.\"</html>\";\n        }\n        $mail->msgHTML($body, App()->getConfig(\"publicdir\")); // This allow embedded image if we remove the servername from image\n        $html = new \\Html2Text\\Html2Text($body);\n        $mail->AltBody = $html->getText();\n    } else {\n        $mail->IsHTML(false);\n        $mail->Body = $body;\n    }\n    // Add attachments if they are there.\n    if (is_array($attachments)) {\n        foreach ($attachments as $attachment) {\n            // Attachment is either an array with filename and attachment name.\n            if (is_array($attachment)) {\n                $mail->AddAttachment($attachment[0], $attachment[1]);\n            } else {\n// Or a string with the filename.\n                $mail->AddAttachment($attachment);\n            }\n        }\n    }\n    $mail->Subject = $subject;\n\n    if ($emailsmtpdebug > 0) {\n        ob_start();\n    }\n    $sent = $mail->Send();\n    $maildebug = $mail->ErrorInfo;\n    if ($emailsmtpdebug > 0) {\n        $maildebug .= '<br><strong>'.gT('SMTP debug output:').'</strong><pre>'.\\CHtml::encode(ob_get_contents()).'</pre>';\n        ob_end_clean();\n    }\n    $maildebugbody = $mail->Body;\n    //if(!$sent) var_dump($maildebug);\n    return $sent;\n}\n\n\n/**\n*  This functions removes all HTML tags, Javascript, CRs, linefeeds and other strange chars from a given text\n*\n* @param string $sTextToFlatten  Text you want to clean\n* @param boolean $bKeepSpan set to true for keep span, used for expression manager. Default: false\n* @param boolean $bDecodeHTMLEntities If set to true then all HTML entities will be decoded to the specified charset. Default: false\n* @param string $sCharset Charset to decode to if $decodeHTMLEntities is set to true. Default: UTF-8\n* @param string $bStripNewLines strip new lines if true, if false replace all new line by \\r\\n. Default: true\n*\n* @return string  Cleaned text\n*/\nfunction flattenText($sTextToFlatten, $bKeepSpan = false, $bDecodeHTMLEntities = false, $sCharset = 'UTF-8', $bStripNewLines = true)\n{\n    $sNicetext = stripJavaScript($sTextToFlatten);\n    // When stripping tags, add a space before closing tags so that strings with embedded HTML tables don't get concatenated\n    $sNicetext = str_replace(array('</td', '</th'), array(' </td', ' </th'), $sNicetext);\n    if ($bKeepSpan) {\n        // Keep <span> so can show EM syntax-highlighting; add space before tags so that word-wrapping not destroyed when remove tags.\n        $sNicetext = strip_tags($sNicetext, '<span><table><tr><td><th>');\n    } else {\n        $sNicetext = strip_tags($sNicetext);\n    }\n    // ~\\R~u : see \"What \\R matches\" and \"Newline sequences\" in http://www.pcre.org/pcre.txt - only available since PCRE 7.0\n    if ($bStripNewLines) {\n// strip new lines\n        if (version_compare(substr(PCRE_VERSION, 0, strpos(PCRE_VERSION, ' ')), '7.0') > -1) {\n            $sNicetext = preg_replace(array('~\\R~u'), array(' '), $sNicetext);\n        } else {\n            // Poor man's replacement for line feeds\n            $sNicetext = str_replace(array(\"\\r\\n\", \"\\n\", \"\\r\"), array(' ', ' ', ' '), $sNicetext);\n        }\n    } elseif (version_compare(substr(PCRE_VERSION, 0, strpos(PCRE_VERSION, ' ')), '7.0') > -1) {\n        // unify newlines to \\r\\n\n        $sNicetext = preg_replace(array('~\\R~u'), array(\"\\r\\n\"), $sNicetext);\n    }\n    if ($bDecodeHTMLEntities === true) {\n        $sNicetext = str_replace('&nbsp;', ' ', $sNicetext); // html_entity_decode does not convert &nbsp; to spaces\n        $sNicetext = html_entity_decode($sNicetext, ENT_QUOTES, $sCharset);\n    }\n    $sNicetext = trim($sNicetext);\n    return  $sNicetext;\n}\n\n\n/**\n* getArrayFilterExcludesCascadesForGroup() queries the database and produces a list of array_filter_exclude questions and targets with in the same group\n* @return array a keyed nested array, keyed by the qid of the question, containing cascade information\n*/\nfunction getArrayFilterExcludesCascadesForGroup($surveyid, $gid = \"\", $output = \"qid\")\n{\n    $surveyid = sanitize_int($surveyid);\n    $survey = Survey::model()->findByPk($surveyid);\n\n    $gid = sanitize_int($gid);\n\n\n    $cascaded = array();\n    $sources = array();\n    $qidtotitle = array();\n    $fieldmap = createFieldMap($survey, 'full', false, false, $survey->language);\n\n    if ($gid != \"\") {\n        $qrows = arraySearchByKey($gid, $fieldmap, 'gid');\n    } else {\n        $qrows = $fieldmap;\n    }\n    $grows = array(); //Create an empty array in case query not return any rows\n    // Store each result as an array with in the $grows array\n    foreach ($qrows as $qrow) {\n        if (isset($qrow['gid']) && !empty($qrow['gid'])) {\n            $grows[$qrow['qid']] = array('qid' => $qrow['qid'], 'type' => $qrow['type'], 'mandatory' => $qrow['mandatory'], 'title' => $qrow['title'], 'gid' => $qrow['gid']);\n        }\n    }\n    foreach ($grows as $qrow) {\n    // Cycle through questions to see if any have list_filter attributes\n        $qidtotitle[$qrow['qid']] = $qrow['title'];\n        $qresult = QuestionAttribute::model()->getQuestionAttributes($qrow['qid']);\n        if (isset($qresult['array_filter_exclude'])) {\n        // We Found a array_filter attribute\n            $val = $qresult['array_filter_exclude']; // Get the Value of the Attribute ( should be a previous question's title in same group )\n            foreach ($grows as $avalue) {\n            // Cycle through all the other questions in this group until we find the source question for this array_filter\n                if ($avalue['title'] == $val) {\n                    /* This question ($avalue) is the question that provides the source information we use\n                    * to determine which answers show up in the question we're looking at, which is $qrow['qid']\n                    * So, in other words, we're currently working on question $qrow['qid'], trying to find out more\n                    * information about question $avalue['qid'], because that's the source */\n                    $sources[$qrow['qid']] = $avalue['qid']; /* This question ($qrow['qid']) relies on answers in $avalue['qid'] */\n                    if (isset($cascades)) {unset($cascades); }\n                    $cascades = array(); /* Create an empty array */\n\n                    /* At this stage, we know for sure that this question relies on one other question for the filter */\n                    /* But this function wants to send back information about questions that rely on multiple other questions for the filter */\n                    /* So we don't want to do anything yet */\n\n                    /* What we need to do now, is check whether the question this one relies on, also relies on another */\n\n                    /* The question we are now checking is $avalue['qid'] */\n                    $keepgoing = 1;\n                    $questiontocheck = $avalue['qid'];\n                    /* If there is a key in the $sources array that is equal to $avalue['qid'] then we want to add that\n                    * to the $cascades array */\n                    while ($keepgoing > 0) {\n                        if (!empty($sources[$questiontocheck])) {\n                            $cascades[] = $sources[$questiontocheck];\n                            /* Now we need to move down the chain */\n                            /* We want to check the $sources[$questiontocheck] question */\n                            $questiontocheck = $sources[$questiontocheck];\n                        } else {\n                            /* Since it was empty, there must not be any more questions down the cascade */\n                            $keepgoing = 0;\n                        }\n                    }\n                    /* Now add all that info */\n                    if (count($cascades) > 0) {\n                        $cascaded[$qrow['qid']] = $cascades;\n                    }\n                }\n            }\n        }\n    }\n    $cascade2 = array();\n    if ($output == \"title\") {\n        foreach ($cascaded as $key=>$cascade) {\n            foreach ($cascade as $item) {\n                $cascade2[$key][] = $qidtotitle[$item];\n            }\n        }\n        $cascaded = $cascade2;\n    }\n    return $cascaded;\n}\n\nfunction createPassword()\n{\n    $aCharacters = \"ABCDEGHJIKLMNOPQURSTUVWXYZabcdefhjmnpqrstuvwxyz23456789\";\n    $iPasswordLength = 12;\n    $sPassword = '';\n    for ($i = 0; $i < $iPasswordLength; $i++) {\n        $sPassword .= $aCharacters[(int) floor(rand(0, strlen($aCharacters) - 1))];\n    }\n    return $sPassword;\n}\n\n// TODO input Survey Object\nfunction languageDropdown($surveyid, $selected)\n{\n    $slangs = Survey::model()->findByPk($surveyid)->additionalLanguages;\n    $baselang = Survey::model()->findByPk($surveyid)->language;\n    array_unshift($slangs, $baselang);\n    $html = \"<select class='listboxquestions' name='langselect' onchange=\\\"window.open(this.options[this.selectedIndex].value, '_top')\\\">\\n\";\n\n    foreach ($slangs as $lang) {\n        $link = Yii::app()->homeUrl.(\"/admin/dataentry/sa/view/surveyid/\".$surveyid.\"/lang/\".$lang);\n        if ($lang == $selected) {\n            $html .= \"\\t<option value='{$link}' selected='selected'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n        if ($lang != $selected) {\n            $html .= \"\\t<option value='{$link}'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n    }\n    $html .= \"</select>\";\n    return $html;\n}\n\n// TODO input Survey Object\n/**\n * Creates a <select> HTML element for language selection for this survey\n *\n * @param int $surveyid\n * @param string $selected The selected language\n * @return string\n */\nfunction languageDropdownClean($surveyid, $selected)\n{\n    $slangs = Survey::model()->findByPk($surveyid)->additionalLanguages;\n    $baselang = Survey::model()->findByPk($surveyid)->language;\n    array_unshift($slangs, $baselang);\n    $html = \"<select class='form-control listboxquestions' id='language' name='language'>\\n\";\n    foreach ($slangs as $lang) {\n        if ($lang == $selected) {\n            $html .= \"\\t<option value='$lang' selected='selected'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n        if ($lang != $selected) {\n            $html .= \"\\t<option value='$lang'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n    }\n    $html .= \"</select>\";\n    return $html;\n}\n\n/**\n* This function removes a directory recursively\n*\n* @param string $dirname\n* @return bool\n*/\nfunction rmdirr($dirname)\n{\n    // Sanity check\n    if (!file_exists($dirname)) {\n        return false;\n    }\n\n    // Simple delete for a file\n    if (is_file($dirname) || is_link($dirname)) {\n        return @unlink($dirname);\n    }\n\n    // Loop through the folder\n    $dir = dir($dirname);\n    while (false !== $entry = $dir->read()) {\n        // Skip pointers\n        if ($entry == '.' || $entry == '..') {\n            continue;\n        }\n\n        // Recurse\n        rmdirr($dirname.DIRECTORY_SEPARATOR.$entry);\n    }\n\n    // Clean up\n    $dir->close();\n    return @rmdir($dirname);\n}\n\n/**\n* This function removes surrounding and masking quotes from the CSV field\n*\n* @param mixed $field\n* @return mixed\n*/\nfunction CSVUnquote($field)\n{\n    //print $field.\":\";\n    $field = preg_replace(\"/^\\040*\\\"/\", \"\", $field);\n    $field = preg_replace(\"/\\\"\\040*$/\", \"\", $field);\n    $field = str_replace('\"\"', '\"', $field);\n    //print $field.\"\\n\";\n    return $field;\n}\n\n/**\n* This function return actual completion state\n*\n* @return string|boolean (complete|incomplete|all) or false\n*/\nfunction incompleteAnsFilterState()\n{\n    $letsfilter = returnGlobal('completionstate'); //read get/post completionstate\n\n    // first let's initialize the incompleteanswers session variable\n    if ($letsfilter != '') {\n// use the read value if not empty\n        Yii::app()->session['incompleteanswers'] = $letsfilter;\n    } elseif (empty(Yii::app()->session['incompleteanswers'])) {\n// sets default variable value from config file\n        Yii::app()->session['incompleteanswers'] = Yii::app()->getConfig('filterout_incomplete_answers');\n    }\n\n    if (Yii::app()->session['incompleteanswers'] == 'complete' || Yii::app()->session['incompleteanswers'] == 'all' || Yii::app()->session['incompleteanswers'] == 'incomplete') {\n        return Yii::app()->session['incompleteanswers'];\n    } else {\n// last resort is to prevent filtering\n        return false;\n    }\n}\n\n\n/**\n* isCaptchaEnabled($screen, $usecaptchamode)\n* @param string $screen - the screen name for which to test captcha activation\n*\n* @return boolean|null - returns true if captcha must be enabled\n**/\nfunction isCaptchaEnabled($screen, $captchamode = '')\n{\n    if (!extension_loaded('gd')) {\n        return false;\n    }\n    switch ($screen) {\n        case 'registrationscreen':\n            if ($captchamode == 'A' ||\n            $captchamode == 'B' ||\n            $captchamode == 'D' ||\n            $captchamode == 'R') {\n                return true;\n            }\n            return false;\n        case 'surveyaccessscreen':\n            if ($captchamode == 'A' ||\n            $captchamode == 'B' ||\n            $captchamode == 'C' ||\n            $captchamode == 'X') {\n                return true;\n            }\n            return false;\n        case 'saveandloadscreen':\n            if ($captchamode == 'A' ||\n                $captchamode == 'C' ||\n                $captchamode == 'D' ||\n                $captchamode == 'S') {\n                return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\n\n/**\n* Check if a table does exist in the database\n*\n* @param string $sTableName Table name to check for (without dbprefix!))\n* @return boolean True or false if table exists or not\n*/\nfunction tableExists($sTableName)\n{\n    $sTableName = Yii::app()->db->tablePrefix.str_replace(array('{', '}'), array('', ''), $sTableName);\n    return in_array($sTableName, Yii::app()->db->schema->getTableNames());\n}\n\n// Returns false if the survey is anonymous,\n// and a survey participants table exists: in this case the completed field of a token\n// will contain 'Y' instead of the submitted date to ensure privacy\n// Returns true otherwise\nfunction isTokenCompletedDatestamped($thesurvey)\n{\n    if ($thesurvey['anonymized'] == 'Y' && tableExists('tokens_'.$thesurvey['sid'])) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n/**\n* example usage\n* $date = \"2006-12-31 21:00\";\n* $shift \"+6 hours\"; // could be days, weeks... see function strtotime() for usage\n*\n* echo sql_date_shift($date, \"Y-m-d H:i:s\", $shift);\n*\n* will output: 2007-01-01 03:00:00\n*\n* @param string $date\n* @param string $dformat\n* @param mixed $shift\n* @return string\n*/\nfunction dateShift($date, $dformat, $shift)\n{\n    return date($dformat, strtotime($shift, strtotime($date)));\n}\n\n\n// getBounceEmail: returns email used to receive error notifications\nfunction getBounceEmail($surveyid)\n{\n    $surveyInfo = getSurveyInfo($surveyid);\n\n    if ($surveyInfo['bounce_email'] == '') {\n        return null; // will be converted to from in MailText\n    } else {\n        return $surveyInfo['bounce_email'];\n    }\n}\n\n// getEmailFormat: returns email format for the survey\n// returns 'text' or 'html'\nfunction getEmailFormat($surveyid)\n{\n    $surveyInfo = getSurveyInfo($surveyid);\n    if ($surveyInfo['htmlemail'] == 'Y') {\n        return 'html';\n    } else {\n        return 'text';\n    }\n\n}\n\n// Check if user has manage rights for a template\nfunction hasTemplateManageRights($userid, $sThemeFolder)\n{\n    $userid = (int) $userid;\n    $sThemeFolder = sanitize_paranoid_string($sThemeFolder);\n    if ($sThemeFolder === false) {\n        return false;\n    }\n    return Permission::model()->hasTemplatePermission($sThemeFolder, 'read', $userid);\n}\n\n\n/**\n* Translate links which are in any answer/question/survey/email template/label set to their new counterpart\n*\n* @param string $sType 'survey' or 'label'\n* @param mixed $iOldSurveyID\n* @param mixed $iNewSurveyID\n* @param mixed $sString\n* @return string\n*/\nfunction translateLinks($sType, $iOldSurveyID, $iNewSurveyID, $sString)\n{\n    $iOldSurveyID = (int) $iOldSurveyID;\n    $iNewSurveyID = (int) $iNewSurveyID; // To avoid injection of a /e regex modifier without having to check all execution paths\n    if ($sType == 'survey') {\n        $sPattern = '(http(s)?:\\/\\/)?(([a-z0-9\\/\\.])*(?=(\\/upload))\\/upload\\/surveys\\/'.$iOldSurveyID.'\\/)';\n        $sReplace = Yii::app()->getConfig(\"publicurl\").\"upload/surveys/{$iNewSurveyID}/\";\n        return preg_replace('/'.$sPattern.'/u', $sReplace, $sString);\n    } elseif ($sType == 'label') {\n        $sPattern = '(http(s)?:\\/\\/)?(([a-z0-9\\/\\.])*(?=(\\/upload))\\/upload\\/labels\\/'.$iOldSurveyID.'\\/)';\n        $sReplace = Yii::app()->getConfig(\"publicurl\").\"upload/labels/{$iNewSurveyID}/\";\n        return preg_replace(\"/\".$sPattern.\"/u\", $sReplace, $sString);\n    } else // unknown type\n    {\n        return $sString;\n    }\n}\n\n/**\n * This function creates the old fieldnames for survey import\n *\n * @param mixed $iOldSID The old survey id\n * @param integer $iNewSID The new survey id\n * @param array $aGIDReplacements An array with group ids (oldgid=>newgid)\n * @param array $aQIDReplacements An array with question ids (oldqid=>newqid)\n * @return array|bool\n */\nfunction reverseTranslateFieldNames($iOldSID, $iNewSID, $aGIDReplacements, $aQIDReplacements)\n{\n    $aGIDReplacements = array_flip($aGIDReplacements);\n    $aQIDReplacements = array_flip($aQIDReplacements);\n\n    /** @var Survey $oNewSurvey */\n    $oNewSurvey = Survey::model()->findByPk($iNewSID);\n\n    if ($iOldSID == $iNewSID) {\n        $forceRefresh = true; // otherwise grabs the cached copy and throws undefined index exceptions\n    } else {\n        $forceRefresh = false;\n    }\n    $aFieldMap = createFieldMap($oNewSurvey, 'short', $forceRefresh, false, $oNewSurvey->language);\n\n    $aFieldMappings = array();\n    foreach ($aFieldMap as $sFieldname=>$aFieldinfo) {\n        if ($aFieldinfo['qid'] != null) {\n            $aFieldMappings[$sFieldname] = $iOldSID.'X'.$aGIDReplacements[$aFieldinfo['gid']].'X'.$aQIDReplacements[$aFieldinfo['qid']].$aFieldinfo['aid'];\n            if ($aFieldinfo['type'] == '1') {\n                $aFieldMappings[$sFieldname] = $aFieldMappings[$sFieldname].'#'.$aFieldinfo['scale_id'];\n            }\n            // now also add a shortened field mapping which is needed for certain kind of condition mappings\n            $aFieldMappings[$iNewSID.'X'.$aFieldinfo['gid'].'X'.$aFieldinfo['qid']] = $iOldSID.'X'.$aGIDReplacements[$aFieldinfo['gid']].'X'.$aQIDReplacements[$aFieldinfo['qid']];\n            // Shortened field mapping for timings table\n            $aFieldMappings[$iNewSID.'X'.$aFieldinfo['gid']] = $iOldSID.'X'.$aGIDReplacements[$aFieldinfo['gid']];\n        }\n    }\n    return array_flip($aFieldMappings);\n}\n\n/**\n * put your comment there...\n *\n * @param integer $id\n * @param string $type\n * @return bool\n */\nfunction hasResources($id, $type = 'survey')\n{\n    $dirname = Yii::app()->getConfig(\"uploaddir\");\n\n    if ($type == 'survey') {\n        $dirname .= \"/surveys/$id\";\n    } elseif ($type == 'label') {\n        $dirname .= \"/labels/$id\";\n    } else {\n        return false;\n    }\n\n    if (is_dir($dirname) && $dh = opendir($dirname)) {\n        while (($entry = readdir($dh)) !== false) {\n            if ($entry !== '.' && $entry !== '..') {\n                return true;\n            }\n        }\n        closedir($dh);\n    } else {\n        return false;\n    }\n\n    return false;\n}\n\n/**\n * Creates a random sequence of characters\n *\n * @param integer $length Length of resulting string\n * @param string $pattern To define which characters should be in the resulting string\n * @return string\n */\nfunction randomChars($length, $pattern = \"23456789abcdefghijkmnpqrstuvwxyz\")\n{\n    $patternlength = strlen($pattern) - 1;\n    $key = '';\n    for ($i = 0; $i < $length; $i++) {\n        $key .= $pattern{mt_rand(0, $patternlength)};\n    }\n    return $key;\n}\n\n/**\n* used to translate simple text to html (replacing \\n with <br />\n*\n* @param mixed $mytext\n* @param mixed $ishtml\n* @return mixed\n*/\nfunction conditionalNewlineToBreak($mytext, $ishtml, $encoded = '')\n{\n    if ($ishtml === true) {\n        // $mytext has been processed by gT with html mode\n        // and thus \\n has already been translated to &#10;\n        if ($encoded == '') {\n            $mytext = str_replace('&#10;', '<br />', $mytext);\n        }\n        return str_replace(\"\\n\", '<br />', $mytext);\n    } else {\n        return $mytext;\n    }\n}\n\n\nfunction breakToNewline($data)\n{\n    return preg_replace('!<br.*>!iU', \"\\n\", $data);\n}\n\n/**\n* Provides a safe way to end the application\n* \n* @param mixed $sText\n* @returns boolean Fake return so Scrutinizes shuts up\n*/\nfunction safeDie($sText)\n{\n    //Only allowed tag: <br />\n    $textarray = explode('<br />', $sText);\n    $textarray = array_map('htmlspecialchars', $textarray);\n    die(implode('<br />', $textarray));\n    return false; // do not remove\n}\n\n/**\n * @param string $str\n */\nfunction fixCKeditorText($str)\n{\n    $str = str_replace('<br type=\"_moz\" />', '', $str);\n    if ($str == \"<br />\" || $str == \" \" || $str == \"&nbsp;\") {\n        $str = \"\";\n    }\n    if (preg_match(\"/^[\\s]+$/\", $str)) {\n        $str = '';\n    }\n    if ($str == \"\\n\") {\n        $str = \"\";\n    }\n    if (trim($str) == \"&nbsp;\" || trim($str) == '') {\n// chrome adds a single &nbsp; element to empty fckeditor fields\n        $str = \"\";\n    }\n\n    return $str;\n}\n\n\n/**\n * This is a helper function for getAttributeFieldNames\n *\n * @param mixed $fieldname\n * @return bool\n */\nfunction filterForAttributes($fieldname)\n{\n    if (strpos($fieldname, 'attribute_') === false) {\n        return false;\n    } else {\n        return true;\n    }\n    }\n\n/**\n* Retrieves the attribute field names from the related survey participants table\n*\n* @param mixed $iSurveyID  The survey ID\n* @return array The fieldnames\n*/\nfunction getAttributeFieldNames($iSurveyID)\n{\n    $survey = Survey::model()->findByPk($iSurveyID);\n    if (!$survey->hasTokensTable || !$table = Yii::app()->db->schema->getTable($survey->tokensTableName)) {\n            return Array();\n    }\n\n    return array_filter(array_keys($table->columns), 'filterForAttributes');\n\n}\n\n/**\n * Returns the full list of attribute token fields including the properties for each field\n * Use this instead of plain Survey::model()->findByPk($iSurveyID)->tokenAttributes calls because Survey::model()->findByPk($iSurveyID)->tokenAttributes may contain old descriptions where the fields does not physically exist\n *\n * @param integer $iSurveyID The Survey ID\n * @return array\n */\nfunction getParticipantAttributes($iSurveyID)\n{\n    $survey = Survey::model()->findByPk($iSurveyID);\n    if (!$survey->hasTokensTable || !Yii::app()->db->schema->getTable($survey->tokensTableName)) {\n            return Array();\n    }\n    return getTokenFieldsAndNames($iSurveyID, true);\n}\n\n\n\n\n\n/**\n* Retrieves the attribute names from the related survey participants table\n*\n* @param mixed $surveyid  The survey ID\n* @param boolean $bOnlyAttributes Set this to true if you only want the fieldnames of the additional attribue fields - defaults to false\n* @return array The fieldnames as key and names as value in an Array\n*/\nfunction getTokenFieldsAndNames($surveyid, $bOnlyAttributes = false)\n{\n\n\n    $aBasicTokenFields = array('firstname'=>array(\n        'description'=>gT('First name'),\n        'mandatory'=>'N',\n        'showregister'=>'Y'\n        ),\n        'lastname'=>array(\n            'description'=>gT('Last name'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'email'=>array(\n            'description'=>gT('Email address'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'emailstatus'=>array(\n            'description'=>gT(\"Email status\"),\n            'mandatory'=>'N',\n            'showregister'=>'N'\n        ),\n        'token'=>array(\n            'description'=>gT('Token'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'language'=>array(\n            'description'=>gT('Language code'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'sent'=>array(\n            'description'=>gT('Invitation sent date'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'remindersent'=>array(\n            'description'=>gT('Last reminder sent date'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'remindercount'=>array(\n            'description'=>gT('Total numbers of sent reminders'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'usesleft'=>array(\n            'description'=>gT('Uses left'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n    );\n\n    $aExtraTokenFields = getAttributeFieldNames($surveyid);\n    $aSavedExtraTokenFields = Survey::model()->findByPk($surveyid)->tokenAttributes;\n\n    // Drop all fields that are in the saved field description but not in the table definition\n    $aSavedExtraTokenFields = array_intersect_key($aSavedExtraTokenFields, array_flip($aExtraTokenFields));\n\n    // Now add all fields that are in the table but not in the field description\n    foreach ($aExtraTokenFields as $sField) {\n        if (!isset($aSavedExtraTokenFields[$sField])) {\n            $aSavedExtraTokenFields[$sField] = array(\n            'description'=>$sField,\n            'mandatory'=>'N',\n            'showregister'=>'N',\n            'cpdbmap'=>''\n            );\n        } elseif (empty($aSavedExtraTokenFields[$sField]['description'])) {\n            $aSavedExtraTokenFields[$sField]['description'] = $sField;\n        }\n    }\n    if ($bOnlyAttributes) {\n        return $aSavedExtraTokenFields;\n    } else {\n        return array_merge($aBasicTokenFields, $aSavedExtraTokenFields);\n    }\n}\n\n\n/**\n* This function strips any content between and including <javascript> tags\n*\n* @param string $sContent String to clean\n* @return string  Cleaned string\n*/\nfunction stripJavaScript($sContent)\n{\n    $text = preg_replace('@<script[^>]*?>.*?</script>@si', '', $sContent);\n    // TODO : Adding the onload/onhover etc ... or remove this false security function\n    return $text;\n}\n\n/**\n* This function converts emebedded Javascript to Text\n*\n* @param string $sContent String to clean\n* @return string  Cleaned string\n*/\nfunction showJavaScript($sContent)\n{\n    $text = preg_replace_callback('@<script[^>]*?>.*?</script>@si', \n        function($matches) {\n            return htmlspecialchars($matches[0]);\n        }, $sContent);\n    return $text;\n}\n\n/**\n* This function cleans files from the temporary directory being older than 1 day\n* @todo Make the days configurable\n*/\nfunction cleanTempDirectory()\n{\n    $dir = Yii::app()->getConfig('tempdir').DIRECTORY_SEPARATOR;\n    $dp = opendir($dir) or safeDie('Could not open temporary directory');\n    while ($file = readdir($dp)) {\n        if (is_file($dir.$file) && (filemtime($dir.$file)) < (strtotime('-1 days')) && $file != 'index.html' && $file != '.gitignore' && $file != 'readme.txt') {\n            /** @scrutinizer ignore-unhandled */ @unlink($dir.$file); \n        }\n    }\n    $dir = Yii::app()->getConfig('tempdir').DIRECTORY_SEPARATOR.'upload'.DIRECTORY_SEPARATOR;\n    $dp = opendir($dir) or safeDie('Could not open temporary upload directory');\n    while ($file = readdir($dp)) {\n        if (is_file($dir.$file) && (filemtime($dir.$file)) < (strtotime('-1 days')) && $file != 'index.html' && $file != '.gitignore' && $file != 'readme.txt') {\n            /** @scrutinizer ignore-unhandled */ @unlink($dir.$file); \n        }\n    }\n    closedir($dp);\n}\n\nfunction useFirebug()\n{\n    if (FIREBUG == true) {\n        App()->getClientScript()->registerScriptFile('http://getfirebug.com/releases/lite/1.2/firebug-lite-compressed.js');\n    };\n};\n\n/**\n* This is a convenience function for the coversion of datetime values\n*\n* @param mixed $value\n* @param string $fromdateformat\n* @param mixed $todateformat\n* @return string\n*/\nfunction convertDateTimeFormat($value, $fromdateformat, $todateformat)\n{\n    $date = DateTime::createFromFormat($fromdateformat, $value);\n    if ($date) {\n        return $date->format($todateformat);\n    } else {\n        $date = new DateTime($value);\n        return $date->format($todateformat);\n    }\n}\n\n/**\n* This is a convenience function to convert any date, in any date format, to the global setting date format\n* Check if the time shoul be rendered also\n*\n* @param string $sDate\n* @param boolean $withTime\n* @return string\n*/\nfunction convertToGlobalSettingFormat($sDate, $withTime = false)\n{\n\n    $sDateformatdata = getDateFormatData(Yii::app()->session['dateformat']); // We get the Global Setting date format\n    $usedDatetime = ($withTime === true ? $sDateformatdata['phpdate'].\" H:i\" : $sDateformatdata['phpdate']); //return also hours and minutes if asked for\n    try {\n        // Workaround for bug in older PHP version (confirmed for 5.5.9)\n        // The bug is causing invalid dates to create an internal server error which cannot not be caught by try.. catch\n        if (@strtotime($sDate) === false) {\n            throw new Exception(\"Failed to parse date string ({$sDate})\");\n        }\n        $oDate           = new DateTime($sDate); // We generate the Date object (PHP will deal with the format of the string)\n        $sDate           = $oDate->format($usedDatetime); // We apply it to the Date object to generate a string date\n        return $sDate; // We return the string date\n    } catch (Exception $e) {\n        $oDate           = new DateTime('1/1/1980 00:00'); // We generate the Date object (PHP will deal with the format of the string)\n        $sDate           = $oDate->format($usedDatetime); // We apply it to the Date object to generate a string date\n        return $sDate; // We return the string date\n\n    }\n}\n\n/**\n* This function removes the UTF-8 Byte Order Mark from a string\n*\n* @param string $str\n* @return string\n*/\nfunction removeBOM($str = \"\")\n{\n    if (substr($str, 0, 3) == pack(\"CCC\", 0xef, 0xbb, 0xbf)) {\n        $str = substr($str, 3);\n    }\n    return $str;\n}\n\n\n/**\n * This function returns the complete directory path to a given template name\n *\n * @param mixed $sTemplateName\n * @return string\n */\nfunction getTemplatePath($sTemplateName = '')\n{\n    return Template::getTemplatePath($sTemplateName);\n}\n\n/**\n * This function returns the complete URL path to a given template name\n *\n * @param mixed $sTemplateName\n * @return string\n */\nfunction getTemplateURL($sTemplateName)\n{\n    return Template::getTemplateURL($sTemplateName);\n}\n\n/**\n * Return an array of subquestions for a given sid/qid\n *\n * @param int $sid\n * @param int $qid\n * @param string $sLanguage Language of the subquestion text\n * @return array\n */\nfunction getSubQuestions($sid, $qid, $sLanguage)\n{\n\n    static $subquestions;\n\n    if (!isset($subquestions[$sid])) {\n        $subquestions[$sid] = array();\n    }\n    if (!isset($subquestions[$sid][$sLanguage])) {\n\n        $query = \"SELECT sq.*, q.other FROM {{questions}} as sq, {{questions}} as q\"\n        .\" WHERE sq.parent_qid=q.qid AND q.sid=\".$sid\n        .\" AND sq.language='\".$sLanguage.\"' \"\n        .\" AND q.language='\".$sLanguage.\"' \"\n        .\" ORDER BY sq.parent_qid, q.question_order,sq.scale_id , sq.question_order\";\n\n        $query = Yii::app()->db->createCommand($query)->query();\n\n        $resultset = array();\n        //while ($row=$result->FetchRow())\n        foreach ($query->readAll() as $row) {\n            $resultset[$row['parent_qid']][] = $row;\n        }\n        $subquestions[$sid][$sLanguage] = $resultset;\n    }\n    if (isset($subquestions[$sid][$sLanguage][$qid])) {\n        return $subquestions[$sid][$sLanguage][$qid];\n    }\n    return array();\n}\n\n/**\n* Wrapper function to retrieve an xmlwriter object and do error handling if it is not compiled\n* into PHP\n*/\nfunction getXMLWriter()\n{\n    if (!extension_loaded('xmlwriter')) {\n        safeDie('XMLWriter class not compiled into PHP, please contact your system administrator');\n    }\n    return new XMLWriter();\n}\n\n/**\n* SSLRedirect() generates a redirect URL for the appropriate SSL mode then applies it.\n* (Was redirect() before CodeIgniter port.)\n*\n* @param string $enforceSSLMode string 's' or '' (empty).\n*/\nfunction SSLRedirect($enforceSSLMode)\n{\n    $url = 'http'.$enforceSSLMode.'://'.$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];\n    if (!headers_sent()) {\n// If headers not sent yet... then do php redirect\n        //ob_clean();\n        header('Location: '.$url);\n        //ob_flush();\n        Yii::app()->end();\n    };\n};\n\n/**\n* enforceSSLMode() $force_ssl is on or off, it checks if the current\n* request is to HTTPS (or not). If $force_ssl is on, and the\n* request is not to HTTPS, it redirects the request to the HTTPS\n* version of the URL, if the request is to HTTPS, it rewrites all\n* the URL variables so they also point to HTTPS.\n*/\nfunction enforceSSLMode()\n{\n    $bSSLActive = ((!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != \"off\") ||\n    (isset($_SERVER['HTTP_FORWARDED_PROTO']) && $_SERVER['HTTP_FORWARDED_PROTO'] == \"https\") ||\n    (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && $_SERVER['HTTP_X_FORWARDED_PROTO'] == \"https\"));\n    if (Yii::app()->getConfig('ssl_emergency_override') !== true) {\n        $force_ssl = strtolower(getGlobalSetting('force_ssl'));\n    } else {\n        $force_ssl = 'off';\n    };\n    if ($force_ssl == 'on' && !$bSSLActive) {\n        SSLRedirect('s');\n    }\n    if ($force_ssl == 'off' && $bSSLActive) {\n        SSLRedirect('');\n    };\n};\n\n\n/**\n * Creates an array with details on a particular response for display purposes\n * Used in Print answers, Detailed response view and Detailed admin notification email\n *\n * @param mixed $iSurveyID\n * @param mixed $iResponseID\n * @param mixed $sLanguageCode\n * @param boolean $bHonorConditions Apply conditions\n * @return array\n */\nfunction getFullResponseTable($iSurveyID, $iResponseID, $sLanguageCode, $bHonorConditions = true)\n{\n    $survey = Survey::model()->findByPk($iSurveyID);\n    $aFieldMap = createFieldMap($survey, 'full', false, false, $sLanguageCode);\n\n    //Get response data\n    $idrow = SurveyDynamic::model($iSurveyID)->findByAttributes(array('id'=>$iResponseID));\n\n    // Create array of non-null values - those are the relevant ones\n    $aRelevantFields = array();\n\n    foreach ($aFieldMap as $sKey=>$fname) {\n        if (LimeExpressionManager::QuestionIsRelevant($fname['qid']) || $bHonorConditions === false) {\n            $aRelevantFields[$sKey] = $fname;\n        }\n    }\n\n    $aResultTable = array();\n    $oldgid = 0;\n    $oldqid = 0;\n    foreach ($aRelevantFields as $sKey=>$fname) {\n        if (!empty($fname['qid'])) {\n            $attributes = QuestionAttribute::model()->getQuestionAttributes($fname['qid']);\n            if (getQuestionAttributeValue($attributes, 'hidden') == 1) {\n                continue;\n            }\n        }\n        $question = $fname['question'];\n        $subquestion = '';\n        if (isset($fname['gid']) && !empty($fname['gid'])) {\n            //Check to see if gid is the same as before. if not show group name\n            if ($oldgid !== $fname['gid']) {\n                $oldgid = $fname['gid'];\n                if (LimeExpressionManager::GroupIsRelevant($fname['gid']) || $bHonorConditions === false) {\n                    $aResultTable['gid_'.$fname['gid']] = array($fname['group_name'], QuestionGroup::model()->getGroupDescription($fname['gid'], $sLanguageCode));\n                }\n            }\n        }\n        if (!empty($fname['qid'])) {\n            if ($oldqid !== $fname['qid']) {\n                $oldqid = $fname['qid'];\n                if (isset($fname['subquestion']) || isset($fname['subquestion1']) || isset($fname['subquestion2'])) {\n                    $aResultTable['qid_'.$fname['sid'].'X'.$fname['gid'].'X'.$fname['qid']] = array($fname['question'], '', '');\n                } else {\n                    $answer = getExtendedAnswer($iSurveyID, $fname['fieldname'], $idrow[$fname['fieldname']], $sLanguageCode);\n                    $aResultTable[$fname['fieldname']] = array($question, '', $answer);\n                    continue;\n                }\n            }\n        } else {\n            $answer = getExtendedAnswer($iSurveyID, $fname['fieldname'], $idrow[$fname['fieldname']], $sLanguageCode);\n            $aResultTable[$fname['fieldname']] = array($question, '', $answer);\n            continue;\n        }\n        if (isset($fname['subquestion'])) {\n                    $subquestion = \"[{$fname['subquestion']}]\";\n        }\n\n        if (isset($fname['subquestion1'])) {\n                    $subquestion = \"[{$fname['subquestion1']}]\";\n        }\n\n        if (isset($fname['subquestion2'])) {\n                    $subquestion .= \"[{$fname['subquestion2']}]\";\n        }\n\n        $answer = getExtendedAnswer($iSurveyID, $fname['fieldname'], $idrow[$fname['fieldname']], $sLanguageCode);\n        $aResultTable[$fname['fieldname']] = array($question, $subquestion, $answer);\n    }\n    return $aResultTable;\n}\n\n/**\n * Check if $str is an integer, or string representation of an integer\n *\n * @param string $mStr\n * @return bool|int\n */\nfunction isNumericInt($mStr)\n{\n    if (is_int($mStr)) {\n            return true;\n    } elseif (is_string($mStr)) {\n            return preg_match(\"/^[0-9]+$/\", $mStr);\n    }\n    return false;\n}\n\n/**\n* Implode and sort content array for very long arrays\n*\n* @param string $sDelimeter\n* @param array $aArray\n* @return string String showing array content\n*/\nfunction short_implode($sDelimeter, $sHyphen, $aArray)\n{\n    if (sizeof($aArray) < Yii::app()->getConfig('minlengthshortimplode')) {\n        sort($aArray);\n        return implode($sDelimeter, $aArray);\n    } else {\n        sort($aArray);\n        $iIndexA = 0;\n        $sResult = null;\n        while ($iIndexA < sizeof($aArray)) {\n            if ($iIndexA == 0) {\n                $sResult = $aArray[$iIndexA];\n            } else {\n                if (strlen($sResult) > Yii::app()->getConfig('maxstringlengthshortimplode') - strlen($sDelimeter) - 3) {\n                    return $sResult.$sDelimeter.'...';\n                } else {\n                    $sResult = $sResult.$sDelimeter.$aArray[$iIndexA];\n                }\n            }\n            $iIndexB = $iIndexA + 1;\n            if ($iIndexB < sizeof($aArray)) {\n                while ($iIndexB < sizeof($aArray) && $aArray[$iIndexB] - 1 == $aArray[$iIndexB - 1]) {\n                    $iIndexB++;\n                }\n                if ($iIndexA < $iIndexB - 1) {\n                    $sResult = $sResult.$sHyphen.$aArray[$iIndexB - 1];\n                }\n            }\n            $iIndexA = $iIndexB;\n        }\n        return $sResult;\n    }\n}\n\n/**\n* Include Keypad headers\n*/\nfunction includeKeypad()\n{\n    App()->getClientScript()->registerScriptFile(Yii::app()->getConfig('third_party').'jquery-keypad/jquery.plugin.min.js');\n    App()->getClientScript()->registerScriptFile(Yii::app()->getConfig('third_party').'jquery-keypad/jquery.keypad.min.js');\n    $localefile = Yii::app()->getConfig('rootdir').'/third_party/jquery-keypad/jquery.keypad-'.App()->language.'.js';\n    if (App()->language != 'en' && file_exists($localefile)) {\n        Yii::app()->getClientScript()->registerScriptFile(Yii::app()->getConfig('third_party').'jquery-keypad/jquery.keypad-'.App()->language.'.js');\n    }\n    Yii::app()->getClientScript()->registerCssFile(Yii::app()->getConfig('third_party').\"jquery-keypad/jquery.keypad.alt.css\");\n}\n\n\n/**\n* This function replaces the old insertans tags with new ones across a survey\n*\n* @param string $newsid  Old SID\n* @param string $oldsid  New SID\n* @param mixed $fieldnames Array  array('oldfieldname'=>'newfieldname')\n*/\nfunction translateInsertansTags($newsid, $oldsid, $fieldnames)\n{\n    uksort($fieldnames, function($a, $b) {return strlen($a) < strlen($b); });\n\n    Yii::app()->loadHelper('database');\n    $newsid = (int) $newsid;\n    $oldsid = (int) $oldsid;\n\n    # translate 'surveyls_urldescription' and 'surveyls_url' INSERTANS tags in surveyls\n    $sql = \"SELECT surveyls_survey_id, surveyls_language, surveyls_urldescription, surveyls_url from {{surveys_languagesettings}}\n    WHERE surveyls_survey_id=\".$newsid.\" AND (surveyls_urldescription LIKE '%{$oldsid}X%' OR surveyls_url LIKE '%{$oldsid}X%')\";\n    $result = dbExecuteAssoc($sql) or safeDie(\"Can't read groups table in translateInsertansTags\"); // Checked\n\n    //while ($qentry = $res->FetchRow())\n    foreach ($result->readAll() as $qentry) {\n        $urldescription = $qentry['surveyls_urldescription'];\n        $endurl = $qentry['surveyls_url'];\n        $language = $qentry['surveyls_language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $urldescription = preg_replace('/'.$pattern.'/', $replacement, $urldescription);\n            $endurl = preg_replace('/'.$pattern.'/', $replacement, $endurl);\n        }\n\n        if (strcmp($urldescription, $qentry['surveyls_urldescription']) != 0 ||\n        (strcmp($endurl, $qentry['surveyls_url']) != 0)) {\n\n            // Update Field\n\n            $data = array(\n            'surveyls_urldescription' => $urldescription,\n            'surveyls_url' => $endurl\n            );\n\n            $where = array(\n            'surveyls_survey_id' => $newsid,\n            'surveyls_language' => $language\n            );\n\n            SurveyLanguageSetting::model()->updateRecord($data, $where);\n\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'quotals_urldescrip' and 'quotals_url' INSERTANS tags in quota_languagesettings\n    $sql = \"SELECT quotals_id, quotals_urldescrip, quotals_url from {{quota_languagesettings}} qls, {{quota}} q\n    WHERE sid=\".$newsid.\" AND q.id=qls.quotals_quota_id AND (quotals_urldescrip LIKE '%{$oldsid}X%' OR quotals_url LIKE '%{$oldsid}X%')\";\n    $result = dbExecuteAssoc($sql) or safeDie(\"Can't read quota table in transInsertAns\"); // Checked\n\n    foreach ($result->readAll() as $qentry) {\n        $urldescription = $qentry['quotals_urldescrip'];\n        $endurl = $qentry['quotals_url'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $urldescription = preg_replace('/'.$pattern.'/', $replacement, $urldescription);\n            $endurl = preg_replace('/'.$pattern.'/', $replacement, $endurl);\n        }\n\n        if (strcmp($urldescription, $qentry['quotals_urldescrip']) != 0 || (strcmp($endurl, $qentry['quotals_url']) != 0)) {\n            // Update Field\n            $sqlupdate = \"UPDATE {{quota_languagesettings}} SET quotals_urldescrip='\".$urldescription.\"', quotals_url='\".$endurl.\"' WHERE quotals_id={$qentry['quotals_id']}\";\n            dbExecuteAssoc($sqlupdate) or safeDie(\"Couldn't update INSERTANS in quota_languagesettings<br />$sqlupdate<br />\"); //Checked\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'description' INSERTANS tags in groups\n    $sql = \"SELECT gid, language, group_name, description from {{groups}}\n    WHERE sid=\".$newsid.\" AND description LIKE '%{$oldsid}X%' OR group_name LIKE '%{$oldsid}X%'\";\n    $res = dbExecuteAssoc($sql) or safeDie(\"Can't read groups table in transInsertAns\"); // Checked\n\n    //while ($qentry = $res->FetchRow())\n    foreach ($res->readAll() as $qentry) {\n        $gpname = $qentry['group_name'];\n        $description = $qentry['description'];\n        $gid = $qentry['gid'];\n        $language = $qentry['language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $gpname = preg_replace('/'.$pattern.'/', $replacement, $gpname);\n            $description = preg_replace('/'.$pattern.'/', $replacement, $description);\n        }\n\n        if (strcmp($description, $qentry['description']) != 0 || strcmp($gpname, $qentry['group_name']) != 0) {\n            // Update Fields\n            $where = array(\n            'gid' => $gid,\n            'language' => $language\n            );\n            $oGroup = QuestionGroup::model()->findByAttributes($where);\n            $oGroup->description = $description;\n            $oGroup->group_name = $gpname;\n            $oGroup->save();\n\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'question' and 'help' INSERTANS tags in questions\n    $sql = \"SELECT qid, language, question, help from {{questions}}\n    WHERE sid=\".$newsid.\" AND (question LIKE '%{$oldsid}X%' OR help LIKE '%{$oldsid}X%')\";\n    $result = dbExecuteAssoc($sql) or safeDie(\"Can't read question table in transInsertAns \"); // Checked\n\n    //while ($qentry = $res->FetchRow())\n    $aResultData = $result->readAll();\n    foreach ($aResultData as $qentry) {\n        $question = $qentry['question'];\n        $help = $qentry['help'];\n        $qid = $qentry['qid'];\n        $language = $qentry['language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $question = preg_replace('/'.$pattern.'/', $replacement, $question);\n            $help = preg_replace('/'.$pattern.'/', $replacement, $help);\n        }\n\n        if (strcmp($question, $qentry['question']) != 0 ||\n        strcmp($help, $qentry['help']) != 0) {\n            // Update Field\n\n            $data = array(\n            'question' => $question,\n            'help' => $help\n            );\n\n            $where = array(\n            'qid' => $qid,\n            'language' => $language\n            );\n\n            Question::model()->updateByPk($where, $data);\n\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'answer' INSERTANS tags in answers\n    $result = Answer::model()->oldNewInsertansTags($newsid, $oldsid);\n\n    //while ($qentry = $res->FetchRow())\n    foreach ($result as $qentry) {\n        $answer = $qentry['answer'];\n        $code = $qentry['code'];\n        $qid = $qentry['qid'];\n        $language = $qentry['language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $answer = preg_replace('/'.$pattern.'/', $replacement, $answer);\n        }\n\n        if (strcmp($answer, $qentry['answer']) != 0) {\n            // Update Field\n\n            $data = array(\n            'answer' => $answer,\n            'qid' => $qid\n            );\n\n            $where = array(\n            'code' => $code,\n            'language' => $language\n            );\n\n            Answer::model()->updateRecord($data, $where);\n\n        } // Enf if modified\n    } // end while qentry\n}\n\n/**\n* Replaces EM variable codes in a current survey with a new one\n*\n* @param integer $iSurveyID The survey ID\n* @param mixed $aCodeMap The codemap array (old_code=>new_code)\n*/\nfunction replaceExpressionCodes($iSurveyID, $aCodeMap)\n{\n    $arQuestions = Question::model()->findAll(\"sid=:sid\", array(':sid'=>$iSurveyID));\n    foreach ($arQuestions as $arQuestion) {\n        $bModified = false;\n        foreach ($aCodeMap as $sOldCode=>$sNewCode) {\n            // Don't search/replace old codes that are too short or were numeric (because they would not have been usable in EM expressions anyway)\n            if (strlen($sOldCode) > 1 && !is_numeric($sOldCode)) {\n                $sOldCode = preg_quote($sOldCode, '~');\n                $arQuestion->relevance=preg_replace(\"/\\b{$sOldCode}/\",$sNewCode,$arQuestion->relevance,-1,$iCount);\n                $bModified = $bModified || $iCount;\n                $arQuestion->question = preg_replace(\"~{[^}]*\\K{$sOldCode}(?=[^}]*?})~\", $sNewCode, $arQuestion->question, -1, $iCount);\n                $bModified = $bModified || $iCount;\n            }\n        }\n        if ($bModified) {\n            $arQuestion->save();\n        }\n    }\n    $arGroups = QuestionGroup::model()->findAll(\"sid=:sid\", array(':sid'=>$iSurveyID));\n    foreach ($arGroups as $arGroup) {\n        $bModified = false;\n        foreach ($aCodeMap as $sOldCode=>$sNewCode) {\n            $sOldCode = preg_quote($sOldCode, '~');\n            $arGroup->grelevance=preg_replace(\"~{[^}]*\\K{$sOldCode}(?=[^}]*?})~\",$sNewCode,$arGroup->grelevance,-1,$iCount);\n            $bModified = $bModified || $iCount;\n            $arGroup->description = preg_replace(\"~{[^}]*\\K{$sOldCode}(?=[^}]*?})~\", $sNewCode, $arGroup->description, -1, $iCount);\n            $bModified = $bModified || $iCount;\n        }\n        if ($bModified) {\n            $arGroup->save();\n        }\n    }\n}\n\n\n/**\n* cleanLanguagesFromSurvey() removes any languages from survey tables that are not in the passed list\n* @param string $sid - the currently selected survey\n* @param string $availlangs - space separated list of additional languages in survey\n* @return bool - always returns true\n*/\nfunction cleanLanguagesFromSurvey($sid, $availlangs)\n{\n\n    Yii::app()->loadHelper('database');\n    //\n    $sid = sanitize_int($sid);\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $aLanguages = [];\n    if (!empty($availlangs) && $availlangs != \" \") {\n        $availlangs = sanitize_languagecodeS($availlangs);\n        $aLanguages = explode(\" \", $availlangs);\n        if ($aLanguages[count($aLanguages) - 1] == \"\") {\n            array_pop($aLanguages);\n        }\n    }\n\n    $sqllang = \"language <> '\".$baselang.\"' \";\n\n    if (!empty($availlangs) && $availlangs != \" \") {\n        foreach ($aLanguages as $lang) {\n            $sqllang .= \"AND language <> '\".$lang.\"' \";\n        }\n    }\n\n    // Remove From Answer Table\n    $query = \"SELECT qid FROM {{questions}} WHERE sid='{$sid}' AND $sqllang\";\n    $qidresult = dbExecuteAssoc($query);\n\n    foreach ($qidresult->readAll() as $qrow) {\n\n        $myqid = $qrow['qid'];\n        $query = \"DELETE FROM {{answers}} WHERE qid='$myqid' AND $sqllang\";\n        dbExecuteAssoc($query);\n    }\n\n    // Remove From Questions Table\n    $query = \"DELETE FROM {{questions}} WHERE sid='{$sid}' AND $sqllang\";\n    dbExecuteAssoc($query);\n\n    // Remove From QuestionGroup Table\n    $query = \"DELETE FROM {{groups}} WHERE sid='{$sid}' AND $sqllang\";\n    dbExecuteAssoc($query);\n\n    return true;\n}\n\n/**\n* fixLanguageConsistency() fixes missing groups, questions, answers, quotas & assessments for languages on a survey\n* @param string $sid - the currently selected survey\n* @param string $availlangs - space separated list of additional languages in survey - if empty all additional languages of a survey are checked against the base language\n* @return bool - always returns true\n*/\nfunction fixLanguageConsistency($sid, $availlangs = '')\n{\n    $sid = sanitize_int($sid);\n\n\n    if (trim($availlangs) != '') {\n        $availlangs = sanitize_languagecodeS($availlangs);\n        $langs = explode(\" \", $availlangs);\n        if ($langs[count($langs) - 1] == \"\") {\n            array_pop($langs);\n        }\n    } else {\n        $langs = Survey::model()->findByPk($sid)->additionalLanguages;\n    }\n    if (count($langs) == 0) {\n        return true; // Survey only has one language\n    }\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $query = \"SELECT * FROM {{groups}} WHERE sid='{$sid}' AND language='{$baselang}'  ORDER BY group_order\";\n    $result = Yii::app()->db->createCommand($query)->query();\n    foreach ($result->readAll() as $group) {\n        foreach ($langs as $lang) {\n\n            $query = \"SELECT count(gid) FROM {{groups}} WHERE sid='{$sid}' AND gid='{$group['gid']}' AND language='{$lang}'\";\n            $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n            if ($gresult < 1) {\n                $data = array(\n                'gid' => $group['gid'],\n                'sid' => $group['sid'],\n                'group_name' => $group['group_name'],\n                'group_order' => $group['group_order'],\n                'description' => $group['description'],\n                'randomization_group' => $group['randomization_group'],\n                'grelevance' => $group['grelevance'],\n                'language' => $lang\n\n                );\n                switchMSSQLIdentityInsert('groups', true);\n                Yii::app()->db->createCommand()->insert('{{groups}}', $data);\n                switchMSSQLIdentityInsert('groups', false);\n            }\n        }\n        reset($langs);\n    }\n\n    $quests = array();\n    $query = \"SELECT * FROM {{questions}} WHERE sid='{$sid}' AND language='{$baselang}' ORDER BY question_order\";\n    $result = Yii::app()->db->createCommand($query)->query()->readAll();\n    if (count($result) > 0) {\n        foreach ($result as $question) {\n            array_push($quests, $question['qid']);\n            foreach ($langs as $lang) {\n                $query = \"SELECT count(qid) FROM {{questions}} WHERE sid='{$sid}' AND qid='{$question['qid']}' AND language='{$lang}' AND scale_id={$question['scale_id']}\";\n                $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n                if ($gresult < 1) {\n                    switchMSSQLIdentityInsert('questions', true);\n                    $data = array(\n                    'qid' => $question['qid'],\n                    'sid' => $question['sid'],\n                    'gid' => $question['gid'],\n                    'type' => $question['type'],\n                    'title' => $question['title'],\n                    'question' => $question['question'],\n                    'preg' => $question['preg'],\n                    'help' => $question['help'],\n                    'other' => $question['other'],\n                    'mandatory' => $question['mandatory'],\n                    'question_order' => $question['question_order'],\n                    'language' => $lang,\n                    'scale_id' => $question['scale_id'],\n                    'parent_qid' => $question['parent_qid'],\n                    'relevance' => $question['relevance']\n                    );\n                    Yii::app()->db->createCommand()->insert('{{questions}}', $data);\n                }\n            }\n            reset($langs);\n        }\n\n        $sqlans = \"\";\n        foreach ($quests as $quest) {\n            $sqlans .= \" OR qid = '\".$quest.\"' \";\n        }\n        $query = \"SELECT * FROM {{answers}} WHERE language='{$baselang}' and (\".trim($sqlans, ' OR').\") ORDER BY qid, code\";\n        $result = Yii::app()->db->createCommand($query)->query();\n        foreach ($result->readAll() as $answer) {\n            foreach ($langs as $lang) {\n                $query = \"SELECT count(qid) FROM {{answers}} WHERE code='{$answer['code']}' AND qid='{$answer['qid']}' AND language='{$lang}' AND scale_id={$answer['scale_id']}\";\n                $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n                if ($gresult < 1) {\n                    $data = array(\n                    'qid' => $answer['qid'],\n                    'code' => $answer['code'],\n                    'answer' => $answer['answer'],\n                    'scale_id' => $answer['scale_id'],\n                    'sortorder' => $answer['sortorder'],\n                    'language' => $lang,\n                    'assessment_value' =>  $answer['assessment_value']\n                    );\n                    Yii::app()->db->createCommand()->insert('{{answers}}', $data);\n                }\n            }\n            reset($langs);\n        }\n    }\n    /* Remove invalid question : can break survey */\n    Survey::model()->findByPk($sid)->fixInvalidQuestions();\n\n    $query = \"SELECT * FROM {{assessments}} WHERE sid='{$sid}' AND language='{$baselang}'\";\n    $result = Yii::app()->db->createCommand($query)->query();\n    foreach ($result->readAll() as $assessment) {\n        foreach ($langs as $lang) {\n            $query = \"SELECT count(id) FROM {{assessments}} WHERE sid='{$sid}' AND id='{$assessment['id']}' AND language='{$lang}'\";\n            $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n            if ($gresult < 1) {\n                $data = array(\n                'id' => $assessment['id'],\n                'sid' => $assessment['sid'],\n                'scope' => $assessment['scope'],\n                'gid' => $assessment['gid'],\n                'name' => $assessment['name'],\n                'minimum' => $assessment['minimum'],\n                'maximum' => $assessment['maximum'],\n                'message' => $assessment['message'],\n                'language' => $lang\n                );\n                Yii::app()->db->createCommand()->insert('{{assessments}}', $data);\n            }\n        }\n        reset($langs);\n    }\n\n\n    $query = \"SELECT * FROM {{quota_languagesettings}} join {{quota}} q on quotals_quota_id=q.id WHERE q.sid='{$sid}' AND quotals_language='{$baselang}'\";\n    $result = Yii::app()->db->createCommand($query)->query();\n    foreach ($result->readAll() as $qls) {\n        foreach ($langs as $lang) {\n            $query = \"SELECT count(quotals_id) FROM {{quota_languagesettings}} WHERE quotals_quota_id='{$qls['quotals_quota_id']}' AND quotals_language='{$lang}'\";\n            $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n            if ($gresult < 1) {\n                $data = array(\n                'quotals_quota_id' => $qls['quotals_quota_id'],\n                'quotals_name' => $qls['quotals_name'],\n                'quotals_message' => $qls['quotals_message'],\n                'quotals_url' => $qls['quotals_url'],\n                'quotals_urldescrip' => $qls['quotals_urldescrip'],\n                'quotals_language' => $lang\n                );\n                Yii::app()->db->createCommand()->insert('{{quota_languagesettings}}', $data);\n            }\n        }\n        reset($langs);\n    }\n\n    return true;\n}\n\n/**\n* This function switches identity insert on/off for the MSSQL database\n*\n* @param string $table table name (without prefix)\n* @param boolean $state  Set to true to activate ID insert, or false to deactivate\n*/\nfunction switchMSSQLIdentityInsert($table, $state)\n{\n    if (in_array(Yii::app()->db->getDriverName(), array('mssql', 'sqlsrv', 'dblib'))) {\n        if ($state === true) {\n            // This needs to be done directly on the PDO object because when using CdbCommand or similar it won't have any effect\n            Yii::app()->db->pdoInstance->exec('SET IDENTITY_INSERT '.Yii::app()->db->tablePrefix.$table.' ON');\n        } else {\n            // This needs to be done directly on the PDO object because when using CdbCommand or similar it won't have any effect\n            Yii::app()->db->pdoInstance->exec('SET IDENTITY_INSERT '.Yii::app()->db->tablePrefix.$table.' OFF');\n        }\n    }\n}\n\n/**\n * Retrieves the last Insert ID realiable for cross-DB applications\n *\n * @param string $sTableName Needed for Postgres and MSSQL\n * @return string\n */\nfunction getLastInsertID($sTableName)\n{\n    $sDBDriver = Yii::app()->db->getDriverName();\n    if ($sDBDriver == 'mysql' || $sDBDriver == 'mysqli') {\n        return Yii::app()->db->getLastInsertID();\n    } else {\n        return Yii::app()->db->getCommandBuilder()->getLastInsertID($sTableName);\n    }\n}\n\n// TMSW Condition->Relevance:  This function is not needed?  Optionally replace this with call to EM to get similar info\n/**\n* getGroupDepsForConditions() get Dependencies between groups caused by conditions\n* @param string $sid - the currently selected survey\n* @param string $depgid - (optionnal) get only the dependencies applying to the group with gid depgid\n* @param string $targgid - (optionnal) get only the dependencies for groups dependents on group targgid\n* @param string $indexby - (optionnal) \"by-depgid\" for result indexed with $res[$depgid][$targgid]\n*                   \"by-targgid\" for result indexed with $res[$targgid][$depgid]\n* @return array - returns an array describing the conditions or NULL if no dependecy is found\n*\n* Example outupt assumin $index-by=\"by-depgid\":\n*Array\n*(\n*    [125] => Array             // Group Id 125 is dependent on\n*        (\n*            [123] => Array         // Group Id 123\n*                (\n*                    [depgpname] => G3      // GID-125 has name G3\n*                    [targetgpname] => G1   // GID-123 has name G1\n*                    [conditions] => Array\n*                        (\n*                            [189] => Array // Because Question Id 189\n*                                (\n*                                    [0] => 9   // Have condition 9 set\n*                                    [1] => 10  // and condition 10 set\n*                                    [2] => 14  // and condition 14 set\n*                                )\n*\n*                        )\n*\n*                )\n*\n*            [124] => Array         // GID 125 is also dependent on GID 124\n*                (\n*                    [depgpname] => G3\n*                    [targetgpname] => G2\n*                    [conditions] => Array\n*                        (\n*                            [189] => Array // Because Question Id 189 have conditions set\n*                                (\n*                                    [0] => 11\n*                                )\n*\n*                            [215] => Array // And because Question Id 215 have conditions set\n*                                (\n*                                    [0] => 12\n*                                )\n*\n*                        )\n*\n*                )\n*\n*        )\n*\n*)\n*\n* Usage example:\n*   * Get all group dependencies for SID $sid indexed by depgid:\n*       $result=getGroupDepsForConditions($sid);\n*   * Get all group dependencies for GID $gid in survey $sid indexed by depgid:\n*       $result=getGroupDepsForConditions($sid,$gid);\n*   * Get all group dependents on group $gid in survey $sid indexed by targgid:\n*       $result=getGroupDepsForConditions($sid,\"all\",$gid,\"by-targgid\");\n*/\nfunction getGroupDepsForConditions($sid, $depgid = \"all\", $targgid = \"all\", $indexby = \"by-depgid\")\n{\n    $sid = sanitize_int($sid);\n    $condarray = Array();\n    $sqldepgid = \"\";\n    $sqltarggid = \"\";\n    if ($depgid != \"all\") { $depgid = sanitize_int($depgid); $sqldepgid = \"AND tq.gid=$depgid\"; }\n    if ($targgid != \"all\") {$targgid = sanitize_int($targgid); $sqltarggid = \"AND tq2.gid=$targgid\"; }\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $condquery = \"SELECT tg.gid as depgid, tg.group_name as depgpname, \"\n    . \"tg2.gid as targgid, tg2.group_name as targgpname, tq.qid as depqid, tc.cid FROM \"\n    . \"{{conditions}} AS tc, \"\n    . \"{{questions}} AS tq, \"\n    . \"{{questions}} AS tq2, \"\n    . \"{{groups}} AS tg ,\"\n    . \"{{groups}} AS tg2 \"\n    . \"WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tg.language='{$baselang}' AND tg2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid=$sid \"\n    . \"AND tq.gid = tg.gid AND tg2.gid = tq2.gid \"\n    . \"AND tq2.qid=tc.cqid AND tq.gid != tg2.gid $sqldepgid $sqltarggid\";\n    $condresult = Yii::app()->db->createCommand($condquery)->query()->readAll();\n\n    if (count($condresult) > 0) {\n        foreach ($condresult as $condrow) {\n\n            switch ($indexby) {\n                case \"by-depgid\":\n                    $depgid = $condrow['depgid'];\n                    $targetgid = $condrow['targgid'];\n                    $depqid = $condrow['depqid'];\n                    $cid = $condrow['cid'];\n                    $condarray[$depgid][$targetgid]['depgpname'] = $condrow['depgpname'];\n                    $condarray[$depgid][$targetgid]['targetgpname'] = $condrow['targgpname'];\n                    $condarray[$depgid][$targetgid]['conditions'][$depqid][] = $cid;\n                    break;\n\n                case \"by-targgid\":\n                    $depgid = $condrow['depgid'];\n                    $targetgid = $condrow['targgid'];\n                    $depqid = $condrow['depqid'];\n                    $cid = $condrow['cid'];\n                    $condarray[$targetgid][$depgid]['depgpname'] = $condrow['depgpname'];\n                    $condarray[$targetgid][$depgid]['targetgpname'] = $condrow['targgpname'];\n                    $condarray[$targetgid][$depgid]['conditions'][$depqid][] = $cid;\n                    break;\n            }\n        }\n        return $condarray;\n    }\n    return null;\n}\n\n// TMSW Condition->Relevance:  This function is not needed?  Optionally replace this with call to EM to get similar info\n/**\n* getQuestDepsForConditions() get Dependencies between groups caused by conditions\n* @param string $sid - the currently selected survey\n* @param string $gid - (optionnal) only search dependecies inside the Group Id $gid\n* @param string $depqid - (optionnal) get only the dependencies applying to the question with qid depqid\n* @param string $targqid - (optionnal) get only the dependencies for questions dependents on question Id targqid\n* @param string $indexby - (optionnal) \"by-depqid\" for result indexed with $res[$depqid][$targqid]\n*                   \"by-targqid\" for result indexed with $res[$targqid][$depqid]\n* @return array - returns an array describing the conditions or NULL if no dependecy is found\n*\n* Example outupt assumin $index-by=\"by-depqid\":\n*Array\n*(\n*    [184] => Array     // Question Id 184\n*        (\n*            [183] => Array // Depends on Question Id 183\n*                (\n*                    [0] => 5   // Because of condition Id 5\n*                )\n*\n*        )\n*\n*)\n*\n* Usage example:\n*   * Get all questions dependencies for Survey $sid and group $gid indexed by depqid:\n*       $result=getQuestDepsForConditions($sid,$gid);\n*   * Get all questions dependencies for question $qid in survey/group $sid/$gid indexed by depqid:\n*       $result=getGroupDepsForConditions($sid,$gid,$qid);\n*   * Get all questions dependents on question $qid in survey/group $sid/$gid indexed by targqid:\n*       $result=getGroupDepsForConditions($sid,$gid,\"all\",$qid,\"by-targgid\");\n*/\nfunction getQuestDepsForConditions($sid, $gid = \"all\", $depqid = \"all\", $targqid = \"all\", $indexby = \"by-depqid\", $searchscope = \"samegroup\")\n{\n\n    $condarray = Array();\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $sqlgid = \"\";\n    $sqldepqid = \"\";\n    $sqltargqid = \"\";\n    $sqlsearchscope = \"\";\n    if ($gid != \"all\") {$gid = sanitize_int($gid); $sqlgid = \"AND tq.gid=$gid\"; }\n    if ($depqid != \"all\") {$depqid = sanitize_int($depqid); $sqldepqid = \"AND tq.qid=$depqid\"; }\n    if ($targqid != \"all\") {$targqid = sanitize_int($targqid); $sqltargqid = \"AND tq2.qid=$targqid\"; }\n    if ($searchscope == \"samegroup\") {$sqlsearchscope = \"AND tq2.gid=tq.gid\"; }\n\n    $condquery = \"SELECT tq.qid as depqid, tq2.qid as targqid, tc.cid\n    FROM {{conditions}} AS tc, {{questions}} AS tq, {{questions}} AS tq2\n    WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid='$sid'\n    AND  tq2.qid=tc.cqid $sqlsearchscope $sqlgid $sqldepqid $sqltargqid\";\n    $condresult = Yii::app()->db->createCommand($condquery)->query()->readAll();\n    if (count($condresult) > 0) {\n        foreach ($condresult as $condrow) {\n            $depqid = $condrow['depqid'];\n            $targetqid = $condrow['targqid'];\n            $condid = $condrow['cid'];\n            switch ($indexby) {\n                case \"by-depqid\":\n                    $condarray[$depqid][$targetqid][] = $condid;\n                    break;\n\n                case \"by-targqid\":\n                    $condarray[$targetqid][$depqid][] = $condid;\n                    break;\n            }\n        }\n        return $condarray;\n    }\n    return null;\n}\n\n// TMSW Condition->Relevance:  This function is not needed - could replace with a message from EM output.\n/**\n* checkMoveQuestionConstraintsForConditions()\n* @param string $sid - the currently selected survey\n* @param string $qid - qid of the question you want to check possible moves\n* @param string $newgid - (optionnal) get only constraints when trying to move to this particular GroupId\n*                                     otherwise, get all moves constraints for this question\n*\n* @return array - returns an array describing the conditions\n*                 Array\n*                 (\n*                   ['notAbove'] = null | Array\n*                       (\n*                         Array ( gid1, group_order1, qid1, cid1 )\n*                       )\n*                   ['notBelow'] = null | Array\n*                       (\n*                         Array ( gid2, group_order2, qid2, cid2 )\n*                       )\n*                 )\n*\n* This should be read as:\n*    - this question can't be move above group gid1 in position group_order1 because of the condition cid1 on question qid1\n*    - this question can't be move below group gid2 in position group_order2 because of the condition cid2 on question qid2\n*\n*/\nfunction checkMoveQuestionConstraintsForConditions($sid, $qid, $newgid = \"all\")\n{\n\n    $resarray = Array();\n    $resarray['notAbove'] = null; // defaults to no constraint\n    $resarray['notBelow'] = null; // defaults to no constraint\n    $sid = sanitize_int($sid);\n    $qid = sanitize_int($qid);\n\n    if ($newgid != \"all\") {\n        $newgid = sanitize_int($newgid);\n        $newgorder = getGroupOrder($sid, $newgid);\n    } else {\n        $newgorder = ''; // Not used in this case\n    }\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n\n    // First look for 'my dependencies': questions on which I have set conditions\n    $condquery = \"SELECT tq.qid as depqid, tq.gid as depgid, tg.group_order as depgorder, \"\n    . \"tq2.qid as targqid, tq2.gid as targgid, tg2.group_order as targgorder, \"\n    . \"tc.cid FROM \"\n    . \"{{conditions}} AS tc, \"\n    . \"{{questions}} AS tq, \"\n    . \"{{questions}} AS tq2, \"\n    . \"{{groups}} AS tg, \"\n    . \"{{groups}} AS tg2 \"\n    . \"WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid=$sid \"\n    . \"AND  tq2.qid=tc.cqid AND tg.gid=tq.gid AND tg2.gid=tq2.gid AND tq.qid=$qid ORDER BY tg2.group_order DESC\";\n\n    $condresult = Yii::app()->db->createCommand($condquery)->query();\n\n    foreach ($condresult->readAll() as $condrow) {\n        // This Question can go up to the minimum GID on the 1st row\n        $depqid = $condrow['depqid'];\n        $targetgid = $condrow['targgid'];\n        $targetgorder = $condrow['targgorder'];\n        $condid = $condrow['cid'];\n        if ($newgid != \"all\") {\n        // Get only constraints when trying to move to this group\n            if ($newgorder < $targetgorder) {\n                $resarray['notAbove'][] = Array($targetgid, $targetgorder, $depqid, $condid);\n            }\n        } else {\n        // get all moves constraints\n            $resarray['notAbove'][] = Array($targetgid, $targetgorder, $depqid, $condid);\n        }\n    }\n\n    // Secondly look for 'questions dependent on me': questions that have conditions on my answers\n    $condquery = \"SELECT tq.qid as depqid, tq.gid as depgid, tg.group_order as depgorder, \"\n    . \"tq2.qid as targqid, tq2.gid as targgid, tg2.group_order as targgorder, \"\n    . \"tc.cid FROM {{conditions}} AS tc, \"\n    . \"{{questions}} AS tq, \"\n    . \"{{questions}} AS tq2, \"\n    . \"{{groups}} AS tg, \"\n    . \"{{groups}} AS tg2 \"\n    . \"WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid=$sid \"\n    . \"AND  tq2.qid=tc.cqid AND tg.gid=tq.gid AND tg2.gid=tq2.gid AND tq2.qid=$qid ORDER BY tg.group_order\";\n\n    $condresult = Yii::app()->db->createCommand($condquery)->query();\n\n    foreach ($condresult->readAll() as $condrow) {\n        // This Question can go down to the maximum GID on the 1st row\n        $depqid = $condrow['depqid'];\n        $depgid = $condrow['depgid'];\n        $depgorder = $condrow['depgorder'];\n        $condid = $condrow['cid'];\n        if ($newgid != \"all\") {\n        // Get only constraints when trying to move to this group\n            if ($newgorder > $depgorder) {\n                $resarray['notBelow'][] = Array($depgid, $depgorder, $depqid, $condid);\n            }\n        } else {\n        // get all moves constraints\n            $resarray['notBelow'][] = Array($depgid, $depgorder, $depqid, $condid);\n        }\n    }\n    return $resarray;\n}\n\n/**\n* Get a list of all user groups\n* @returns array\n*/\nfunction getUserGroupList()\n{\n    $sQuery = \"SELECT distinct a.ugid, a.name, a.owner_id FROM {{user_groups}} AS a LEFT JOIN {{user_in_groups}} AS b ON a.ugid = b.ugid WHERE 1=1 \";\n    if (!Permission::model()->hasGlobalPermission('superadmin', 'read')) {\n        $sQuery .= \"AND uid = \".Yii::app()->session['loginID'];\n    }\n    $sQuery .= \" ORDER BY name\";\n\n    $sresult = Yii::app()->db->createCommand($sQuery)->query(); //Checked\n    if (!$sresult) {return \"Database Error\"; }\n    $aGroupNames = [];\n    foreach ($sresult->readAll() as $row) {\n        $aGroupNames[] = $row;\n    }\n    $simplegidarray = array();\n    if (isset($aGroupNames)) {\n        foreach ($aGroupNames as $gn) {\n            $simplegidarray[] = $gn['ugid'];\n        }\n    }\n    return $simplegidarray;\n}\n\n// TODO use Yii model forms\nfunction getGroupUserList($ugid)\n{\n    Yii::app()->loadHelper('database');\n\n\n    $ugid = sanitize_int($ugid);\n    $surveyidquery = \"SELECT a.uid, a.users_name, a.full_name FROM {{users}} AS a LEFT JOIN (SELECT uid AS id FROM {{user_in_groups}} WHERE ugid = {$ugid}) AS b ON a.uid = b.id WHERE id IS NULL ORDER BY a.users_name\";\n\n    $surveyidresult = dbExecuteAssoc($surveyidquery); //Checked\n    if (!$surveyidresult) {return \"Database Error\"; }\n    $surveyselecter = \"\";\n    $aSurveyNames = [];\n    foreach ($surveyidresult->readAll() as $row) {\n        $aSurveyNames[] = $row;\n    }\n    //$surveynames = $surveyidresult->GetRows();\n    if (isset($aSurveyNames)) {\n        foreach ($aSurveyNames as $sv) {\n            $surveyselecter .= \"<option\";\n            $surveyselecter .= \" value='{$sv['uid']}'>\".\\CHtml::encode($sv['users_name']).\" (\".\\CHtml::encode($sv['full_name']).\")</option>\\n\";\n        }\n    }\n    $surveyselecter = \"<option value='-1' selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    return $surveyselecter;\n}\n\n/**\n* Run an arbitrary sequence of semicolon-delimited SQL commands\n*\n* Assumes that the input text (file or string) consists of\n* a number of SQL statements ENDING WITH SEMICOLONS.  The\n* semicolons MUST be the last character in a line.\n* Lines that are blank or that start with \"#\" or \"--\" (postgres) are ignored.\n* Only tested with mysql dump files (mysqldump -p -d limesurvey)\n* Function kindly borrowed by Moodle\n* @param string $sqlfile The path where a file with sql commands can be found on the server.\n* @param string $sqlstring If no path is supplied then a string with semicolon delimited sql\n* commands can be supplied in this argument.\n* @return bool Returns true if database was modified successfully.\n*/\nfunction modifyDatabase($sqlfile = '', $sqlstring = '')\n{\n    Yii::app()->loadHelper('database');\n\n\n    global $siteadminemail;\n    global $siteadminname;\n    global $codeString;\n    global $modifyoutput;\n\n    $success = true; // Let's be optimistic\n    $modifyoutput = '';\n    $lines = [];\n    if (!empty($sqlfile)) {\n        if (!is_readable($sqlfile)) {\n            $success = false;\n            echo '<p>Tried to modify database, but \"'.$sqlfile.'\" doesn\\'t exist!</p>';\n            return $success;\n        } else {\n            $lines = file($sqlfile);\n        }\n    } else {\n        $sqlstring = trim($sqlstring);\n        if ($sqlstring{strlen($sqlstring) - 1} != \";\") {\n            $sqlstring .= \";\"; // add it in if it's not there.\n        }\n        $lines[] = $sqlstring;\n    }\n\n    $command = '';\n\n    foreach ($lines as $line) {\n        $line = rtrim($line);\n        $length = strlen($line);\n\n        if ($length and $line[0] <> '#' and substr($line, 0, 2) <> '--') {\n            if (substr($line, $length - 1, 1) == ';') {\n                $line = substr($line, 0, $length - 1); // strip ;\n                $command .= $line;\n                $command = str_replace('prefix_', Yii::app()->db->tablePrefix, $command); // Table prefixes\n                $command = str_replace('$defaultuser', Yii::app()->getConfig('defaultuser'), $command);\n                $command = str_replace('$defaultpass', hash('sha256', Yii::app()->getConfig('defaultpass')), $command);\n                $command = str_replace('$siteadminname', $siteadminname, $command);\n                $command = str_replace('$siteadminemail', $siteadminemail, $command);\n                $command = str_replace('$defaultlang', Yii::app()->getConfig('defaultlang'), $command);\n                $command = str_replace('$databasetabletype', Yii::app()->db->getDriverName(), $command);\n\n                try\n                {   Yii::app()->db->createCommand($command)->query(); //Checked\n                    $command = htmlspecialchars($command);\n                    $modifyoutput .= \". \";\n                } catch (CDbException $e) {\n                    $command = htmlspecialchars($command);\n                    $modifyoutput .= \"<br />\".sprintf(gT(\"SQL command failed: %s\"), \"<span style='font-size:10px;'>\".$command.\"</span>\", \"<span style='color:#ee0000;font-size:10px;'></span><br/>\");\n                    $success = false;\n                }\n\n                $command = '';\n            } else {\n                $command .= $line;\n            }\n        }\n    }\n\n    return $success;\n\n}\n\n/**\n* Returns labelsets for given language(s), or for all if null\n*\n* @param string $languages\n* @return array\n*/\nfunction getLabelSets($languages = null)\n{\n    $aLanguages = array();\n    if (!empty($languages)) {\n        $languages = sanitize_languagecodeS($languages);\n        $aLanguages = explode(' ', trim($languages));\n    }\n\n    $criteria = new CDbCriteria;\n    $criteria->order = \"label_name\";\n    foreach ($aLanguages as $k => $item) {\n        $criteria->params[':lang_like1_'.$k] = \"% $item %\";\n        $criteria->params[':lang_'.$k] = $item;\n        $criteria->params[':lang_like2_'.$k] = \"% $item\";\n        $criteria->params[':lang_like3_'.$k] = \"$item %\";\n        $criteria->addCondition(\"\n        ((languages like :lang_like1_$k) or\n        (languages = :lang_$k) or\n        (languages like :lang_like2_$k) or\n        (languages like :lang_like3_$k))\");\n    }\n\n    $result = LabelSet::model()->findAll($criteria);\n    $labelsets = array();\n    foreach ($result as $row) {\n            $labelsets[] = array($row->lid, $row->label_name);\n    }\n    return $labelsets;\n}\n\n/**\n * get the header\n * @param bool $meta : not used in any call (2016-10-18)\n * @return string\n */\nfunction getHeader($meta = false)\n{\n    /* Todo : move this to layout/public.html */\n    global $surveyid;\n    Yii::app()->loadHelper('surveytranslator');\n\n    // Set Langage // TODO remove one of the Yii::app()->session see bug #5901\n    if (Yii::app()->session['survey_'.$surveyid]['s_lang']) {\n        $languagecode = Yii::app()->session['survey_'.$surveyid]['s_lang'];\n    } elseif (isset($surveyid) && $surveyid && Survey::model()->findByPk($surveyid)) {\n        $languagecode = Survey::model()->findByPk($surveyid)->language;\n    } else {\n        $languagecode = Yii::app()->getConfig('defaultlang');\n    }\n    $header = \"<!DOCTYPE html>\\n\";\n    $class = \"no-js $languagecode\";\n    $header .= \"<html lang=\\\"{$languagecode}\\\"\";\n\n    if (getLanguageRTL($languagecode)) {\n        $header .= \" dir=\\\"rtl\\\" \";\n        $class .= \" dir-rtl\";\n    } else {\n        $header .= \" dir=\\\"ltr\\\" \";\n        $class .= \" dir-ltr\";\n    }\n    $header .= \" class=\\\"{$class}\\\">\\n\";\n    $header .= \"\\t<head>\\n\";\n    Yii::app()->clientScript->registerScriptFile(Yii::app()->getConfig(\"generalscripts\").'nojs.js', CClientScript::POS_HEAD);\n    if ($meta) {\n            $header .= $meta;\n    }\n    return $header;\n}\n\n\nfunction doHeader()\n{\n    echo getHeader();\n}\n\n/**\n* This function returns the header for the printable survey\n* @return String\n*\n*/\nfunction getPrintableHeader()\n{\n    global $rooturl, $homeurl;\n    $headelements = App()->getController()->renderPartial('/survey/system/print_survey/header', array(), true, true);\n    return $headelements;\n}\n\n/**\n * This function returns the Footer as result string\n * If you want to echo the Footer use doFooter()!\n * @return string\n */\nfunction getFooter()\n{\n    return \"\\n\\n\\t</body>\\n</html>\\n\";\n}\n\nfunction doFooter()\n{\n    echo getFooter();\n}\n\n\n\n/**\n* Retrieve a HTML <OPTION> list of survey admin users\n*\n* @param boolean $bIncludeOwner If the survey owner should be included\n* @param boolean $bIncludeSuperAdmins If Super admins should be included\n* @param int $surveyid\n* @return string\n*/\nfunction getSurveyUserList($bIncludeSuperAdmins = true, $surveyid)\n{\n\n    $surveyid = (int) $surveyid;\n\n    $sSurveyIDQuery = \"SELECT a.uid, a.users_name, a.full_name FROM {{users}} AS a\n    LEFT OUTER JOIN (SELECT uid AS id FROM {{permissions}} WHERE entity_id = {$surveyid} and entity='survey') AS b ON a.uid = b.id\n    WHERE id IS NULL \";\n    if (!$bIncludeSuperAdmins) {\n        // @todo: Adjust for new permission system - not urgent since it it just display\n        //   $sSurveyIDQuery.='and superadmin=0 ';\n    }\n    $sSurveyIDQuery .= 'ORDER BY a.users_name';\n    $oSurveyIDResult = Yii::app()->db->createCommand($sSurveyIDQuery)->query(); //Checked\n    $aSurveyIDResult = $oSurveyIDResult->readAll();\n\n    $surveyselecter = \"\";\n    $authorizedUsersList = [];\n\n    if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == true) {\n        $authorizedUsersList = getUserList('onlyuidarray');\n    }\n\n    $svexist = false;\n    foreach ($aSurveyIDResult as $sv) {\n        if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == false ||\n            in_array($sv['uid'], $authorizedUsersList)) {\n            $surveyselecter .= \"<option\";\n            $surveyselecter .= \" value='{$sv['uid']}'>\".\\CHtml::encode($sv['users_name']).\" \".\\CHtml::encode($sv['full_name']).\"</option>\\n\";\n            $svexist = true;\n        }\n    }\n\n    if ($svexist) {\n        $surveyselecter = \"<option value='-1' selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    } else {\n        $surveyselecter = \"<option value='-1'>\".gT(\"None\").\"</option>\\n\".$surveyselecter;\n    }\n\n    return $surveyselecter;\n}\n\n/**\n * Return HTML <option> list of user groups\n * @param string $outputformat\n * @param int $surveyid\n * @return string|array \n */\nfunction getSurveyUserGroupList($outputformat = 'htmloptions', $surveyid)\n{\n\n    $surveyid = sanitize_int($surveyid);\n\n    $surveyidquery = \"SELECT a.ugid, a.name, MAX(d.ugid) AS da\n    FROM {{user_groups}} AS a\n    LEFT JOIN (\n    SELECT b.ugid\n    FROM {{user_in_groups}} AS b\n    LEFT JOIN (SELECT * FROM {{permissions}}\n    WHERE entity_id = {$surveyid} and entity='survey') AS c ON b.uid = c.uid WHERE c.uid IS NULL\n    ) AS d ON a.ugid = d.ugid GROUP BY a.ugid, a.name HAVING MAX(d.ugid) IS NOT NULL\";\n    $surveyidresult = Yii::app()->db->createCommand($surveyidquery)->query(); //Checked\n    $aResult = $surveyidresult->readAll();\n\n    $authorizedGroupsList = [];\n    if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == true) {\n        $authorizedGroupsList = getUserGroupList();\n    }\n\n    $svexist = false;\n    $surveyselecter = \"\";\n    $simpleugidarray = [];\n    foreach ($aResult as $sv) {\n        if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == false ||\n        in_array($sv['ugid'], $authorizedGroupsList)) {\n            $surveyselecter .= \"<option\";\n            $surveyselecter .= \" value='{$sv['ugid']}'>{$sv['name']}</option>\\n\";\n            $simpleugidarray[] = $sv['ugid'];\n            $svexist = true;\n        }\n    }\n\n    if ($svexist) {\n        $surveyselecter = \"<option value='-1' selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    } else {\n        $surveyselecter = \"<option value='-1'>\".gT(\"None\").\"</option>\\n\".$surveyselecter;\n    }\n\n    if ($outputformat == 'simpleugidarray') {\n        return $simpleugidarray;\n    } else {\n        return $surveyselecter;\n    }\n}\n\n\n\n/**\n* This function fixes the group ID and type on all subquestions\n* Optimized for minimum memory usage even on huge databases\n*/\nfunction fixSubquestions()\n{\n    $surveyidresult = Yii::app()->db->createCommand()\n    ->select('sq.qid, q.gid , q.type ')\n    ->from('{{questions}} sq')\n    ->join('{{questions}} q', 'sq.parent_qid=q.qid')\n    ->where('sq.parent_qid>0 AND (sq.gid!=q.gid or sq.type!=q.type)')\n    ->limit(10000)\n    ->query();\n    $aRecords = $surveyidresult->readAll();\n    while (count($aRecords) > 0) {\n        foreach ($aRecords as $sv) {\n            Yii::app()->db->createCommand(\"update {{questions}} set type='{$sv['type']}', gid={$sv['gid']} where qid={$sv['qid']}\")->execute();\n        }\n        $surveyidresult = Yii::app()->db->createCommand()\n        ->select('sq.qid, q.gid , q.type ')\n        ->from('{{questions}} sq')\n        ->join('{{questions}} q', 'sq.parent_qid=q.qid')\n        ->where('sq.parent_qid>0 AND (sq.gid!=q.gid or sq.type!=q.type)')\n        ->limit(10000)\n        ->query();\n        $aRecords = $surveyidresult->readAll();\n    }\n\n}\n\n/**\n* Must use ls_json_encode to json_encode content, otherwise LimeExpressionManager will think that the associative arrays are expressions and try to parse them.\n*/\nfunction ls_json_encode($content)\n{\n    if (is_string($content) && get_magic_quotes_gpc()) {\n        $content = stripslashes($content);\n    }\n    $ans = json_encode($content);\n    $ans = str_replace(array('{', '}'), array('{ ', ' }'), $ans);\n    return $ans;\n}\n\n/**\n * Decode a json string, sometimes needs stripslashes\n *\n * @param string $jsonString\n * @return mixed\n */\nfunction json_decode_ls($jsonString)\n{\n    $decoded = json_decode($jsonString, true);\n\n    if (is_null($decoded) && !empty($jsonString)) {\n        // probably we need stipslahes\n        $decoded = json_decode(stripslashes($jsonString), true);\n    }\n\n    return $decoded;\n}\n\n/**\n * Return accepted codingsArray for importing files\n *\n * Used in vvimport\n * TODO : use in token and\n * @return array\n */\nfunction aEncodingsArray()\n{\n        $aEncodings = array(\n        \"armscii8\" => gT(\"ARMSCII-8 Armenian\"),\n        \"ascii\" => gT(\"US ASCII\"),\n        \"big5\" => gT(\"Big5 Traditional Chinese\"),\n        \"binary\" => gT(\"Binary pseudo charset\"),\n        \"cp1250\" => gT(\"Windows Central European (Windows-1250)\"),\n        \"cp1251\" => gT(\"Windows Cyrillic (Windows-1251)\"),\n        \"cp1256\" => gT(\"Windows Arabic (Windows-1256)\"),\n        \"cp1257\" => gT(\"Windows Baltic (Windows-1257)\"),\n        \"cp850\" => gT(\"DOS West European (cp850)\"),\n        \"cp852\" => gT(\"DOS Central European (cp852)\"),\n        \"cp866\" => gT(\"DOS Cyrillic (cp866)\"),\n        \"cp932\" => gT(\"Windows-31J - SJIS for Windows Japanese (cp932)\"),\n        \"dec8\" => gT(\"DEC West European\"),\n        \"eucjpms\" => gT(\"UJIS for Windows Japanese\"),\n        \"euckr\" => gT(\"EUC-KR Korean\"),\n        \"gb2312\" => gT(\"GB2312 Simplified Chinese\"),\n        \"gbk\" => gT(\"GBK Simplified Chinese\"),\n        \"geostd8\" => gT(\"GEOSTD8 Georgian\"),\n        \"greek\" => gT(\"ISO 8859-7 Greek\"),\n        \"hebrew\" => gT(\"ISO 8859-8 Hebrew\"),\n        \"hp8\" => gT(\"HP West European\"),\n        \"keybcs2\" => gT(\"DOS Kamenicky Czech-Slovak (cp895)\"),\n        \"koi8r\" => gT(\"KOI8-R Relcom Russian\"),\n        \"koi8u\" => gT(\"KOI8-U Ukrainian\"),\n        \"latin1\" => gT(\"ISO 8859-1 West European (latin1)\"),\n        \"latin2\" => gT(\"ISO 8859-2 Central European (latin2)\"),\n        \"latin5\" => gT(\"ISO 8859-9 Turkish (latin5)\"),\n        \"latin7\" => gT(\"ISO 8859-13 Baltic (latin7)\"),\n        \"macce\" => gT(\"Mac Central European\"),\n        \"macroman\" => gT(\"Mac West European\"),\n        \"sjis\" => gT(\"Shift-JIS Japanese\"),\n        \"swe7\" => gT(\"7bit Swedish\"),\n        \"tis620\" => gT(\"TIS620 Thai\"),\n        \"ucs2\" => gT(\"UCS-2 Unicode\"),\n        \"ujis\" => gT(\"EUC-JP Japanese\"),\n        \"utf8\" => gT(\"UTF-8 Unicode\"),\n        );\n        // Sort list of encodings\n        asort($aEncodings);\n        $aEncodings = array(\"auto\" => gT(\"(Automatic)\")) + $aEncodings;\n        return $aEncodings;\n    }\n\n\n/**\n* Ellipsize String\n*\n* This public static function will strip tags from a string, split it at its max_length and ellipsize\n*\n* @param    string  $sString        string to ellipsize\n* @param    integer $iMaxLength       max length of string\n* @param    integer   $fPosition       int (1|0) or float, .5, .2, etc for position to split\n* @param    string  $sEllipsis      ellipsis ; Default '...'\n* @return    string        ellipsized string\n*/\nfunction ellipsize($sString, $iMaxLength, $fPosition = 1, $sEllipsis = '&hellip;')\n{\n    // Strip tags\n    $sString = trim(strip_tags($sString));\n    // Is the string long enough to ellipsize?\n    if (mb_strlen($sString, 'UTF-8') <= $iMaxLength + 3) {\n        return $sString;\n    }\n\n    $iStrLen = mb_strlen($sString, 'UTF-8');\n    $sBegin = mb_substr($sString, 0, (int) floor($iMaxLength * $fPosition), 'UTF-8');\n    $sEnd = mb_substr($sString, $iStrLen - ($iMaxLength - mb_strlen($sBegin, 'UTF-8')), $iStrLen, 'UTF-8');\n    return $sBegin.$sEllipsis.$sEnd;\n}\n\n/**\n* This function tries to returns the 'real' IP address under all configurations\n* Do not rely security-wise on the detected IP address as except for REMOTE_ADDR all fields could be manipulated by the web client\n*/\nfunction getIPAddress()\n{\n    $sIPAddress = '127.0.0.1';\n    if (!empty($_SERVER['HTTP_CLIENT_IP']) && filter_var($_SERVER['HTTP_CLIENT_IP'], FILTER_VALIDATE_IP)!==false) {\n        //check IP address from share internet\n        $sIPAddress = $_SERVER['HTTP_CLIENT_IP'];\n    } elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR']) && filter_var($_SERVER['HTTP_X_FORWARDED_FOR'], FILTER_VALIDATE_IP)!==false) {\n        //Check IP address passed from proxy\n        $sIPAddress = $_SERVER['HTTP_X_FORWARDED_FOR'];\n    } elseif (!empty($_SERVER['REMOTE_ADDR']) && filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP)!==false) {\n        $sIPAddress = $_SERVER['REMOTE_ADDR'];\n    }\n    return $sIPAddress;\n}\n\n\n/**\n* This function tries to find out a valid language code for the language of the browser used\n* If it cannot find it it will return the default language from global settings\n*\n*/\nfunction getBrowserLanguage()\n{\n    $sLanguage = Yii::app()->getRequest()->getPreferredLanguage();\n    Yii::app()->loadHelper(\"surveytranslator\");\n    $aLanguages = getLanguageData();\n    if (!isset($aLanguages[$sLanguage])) {\n        $sLanguage = str_replace('_', '-', $sLanguage);\n        if (strpos($sLanguage, '-') !== false) {\n            $aLanguage = explode('-', $sLanguage);\n            $aLanguage[1] = strtoupper($aLanguage[1]);\n            $sLanguage = implode('-', $aLanguage);\n        }\n        if (!isset($aLanguages[$sLanguage])) {\n            $sLanguage = substr($sLanguage, 0, strpos($sLanguage, '-'));\n            if (!isset($aLanguages[$sLanguage])) {\n                $sLanguage = Yii::app()->getConfig('defaultlang');\n            }\n        }\n    }\n    return $sLanguage;\n}\n\nfunction array_diff_assoc_recursive($array1, $array2)\n{\n    $difference = array();\n    foreach ($array1 as $key => $value) {\n        if (is_array($value)) {\n            if (!isset($array2[$key]) || !is_array($array2[$key])) {\n                $difference[$key] = $value;\n            } else {\n                $new_diff = array_diff_assoc_recursive($value, $array2[$key]);\n                if (!empty($new_diff)) {\n                                    $difference[$key] = $new_diff;\n                }\n            }\n        } else if (!array_key_exists($key, $array2) || $array2[$key] !== $value) {\n            $difference[$key] = $value;\n        }\n    }\n    return $difference;\n}\n\n/**\n * Calculate folder size\n * NB: If this function is changed, please notify LimeSurvey GmbH.\n *     An exact copy of this function is used to calculate storage\n *     limit on LimeSurvey Pro hosting.\n * @param string $dir Folder\n * @return integer Size in bytes.\n */\nfunction folderSize($dir)\n{\n    $size = 0;\n    foreach (glob(rtrim($dir, '/').'/*', GLOB_NOSORT) as $each) {\n        if (is_file($each)) {\n            // NB: stat() can be used to calculate disk usage (instead\n            // of file size - it's not the same thing).\n            //$stat = stat($each);\n            //$tmpsize = $stat[11] * $stat[12] / 8;\n            //$size += $tmpsize;\n            $size += filesize($each);\n        } else {\n            $size += folderSize($each);\n        }\n    }\n    return $size;\n}\n\n/**\n * Format size in human readable format.\n * @param int $bytes\n * @param int $decimals\n * @return string\n */\nfunction humanFilesize($bytes, $decimals = 2)\n{\n    $sz = 'BKMGTP';\n    //$factor = floor((strlen($bytes) - 1) / 3);\n    $factor = 2;\n    $string = sprintf(\"%.{$decimals}f\", $bytes / pow(1024, $factor)).@$sz[$factor];\n    $aLangData = getLanguageData();\n    $radix = getRadixPointData($aLangData[Yii::app()->session['adminlang']]['radixpoint']);\n    return str_replace('.', $radix['separator'], $string);\n}\n\n/**\n* This function transforms the php.ini notation for numbers (like '2M') to an integer (2*1024*1024 in this case)\n* \n* @param string $sSize\n* @return integer The value in bytes\n*/\nfunction convertPHPSizeToBytes($sSize)\n{\n    //\n    $sSuffix = strtoupper(substr($sSize, -1));\n    if (!in_array($sSuffix, array('P', 'T', 'G', 'M', 'K'))) {\n        return (int) $sSize;  \n    } \n    $iValue = substr($sSize, 0, -1);\n    switch ($sSuffix) {\n        case 'P':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'T':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'G':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'M':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'K':\n            $iValue *= 1024;\n            break;\n    }\n    return (int) $iValue;\n}\n\nfunction getMaximumFileUploadSize()\n{\n    return min(convertPHPSizeToBytes(ini_get('post_max_size')), convertPHPSizeToBytes(ini_get('upload_max_filesize')));\n}\n\n/**\n * Decodes token attribute data because due to bugs in the past it can be written in JSON or be serialized - future format should be JSON as serialized data can be exploited\n *\n * @param string $oTokenAttributeData The original token attributes as stored in the database\n * @return array|mixed\n */\nfunction decodeTokenAttributes($oTokenAttributeData)\n{\n    if (trim($oTokenAttributeData) == '') {\n        return array();\n    }\n    if (substr($oTokenAttributeData, 0, 1) != '{' && substr($oTokenAttributeData, 0, 1) != '[') {\n        $sSerialType = getSerialClass($oTokenAttributeData);\n        if ($sSerialType == 'array') {\n// Safe to decode\n            $aReturnData = @unserialize($oTokenAttributeData);\n        } else {\n// Something else, might be unsafe\n            return array();\n        }\n    } else {\n            $aReturnData = @json_decode($oTokenAttributeData, true);\n    }\n    if ($aReturnData === false || $aReturnData === null) {\n        return array();\n    }\n    return $aReturnData;\n}\n\n/**\n * @param string $sSerial\n * @return string|null\n */\nfunction getSerialClass($sSerial)\n{\n    $aTypes = array('s' => 'string', 'a' => 'array', 'b' => 'bool', 'i' => 'int', 'd' => 'float', 'N;' => 'NULL');\n\n    $aParts = explode(':', $sSerial, 4);\n    return isset($aTypes[$aParts[0]]) ? $aTypes[$aParts[0]] : (isset($aParts[2]) ? trim($aParts[2], '\"') : null);\n}\n\n/**\n* Force Yii to create a new CSRF token by removing the old one\n*\n*/\nfunction regenerateCSRFToken()\n{\n    // Expire the CSRF cookie\n    $cookie = new CHttpCookie('YII_CSRF_TOKEN', '');\n    $cookie->expire = time() - 3600;\n    Yii::app()->request->cookies['YII_CSRF_TOKEN'] = $cookie;\n}\n\n/**\n* A function to remove ../ or ./ from paths to prevent directory traversal\n*\n* @param mixed $path\n*/\nfunction get_absolute_path($path)\n{\n    $path = str_replace(array('/', '\\\\'), DIRECTORY_SEPARATOR, $path);\n    $parts = array_filter(explode(DIRECTORY_SEPARATOR, $path), 'strlen');\n    $absolutes = array();\n    foreach ($parts as $part) {\n        if ('.' == $part) {\n            continue;\n        }\n        if ('..' == $part) {\n            array_pop($absolutes);\n        } else {\n            $absolutes[] = $part;\n        }\n    }\n    return implode(DIRECTORY_SEPARATOR, $absolutes);\n}\n\n/**\n* Check if string is JSON array\n*\n* @param string $str\n* @return bool\n*/\nfunction isJson($str) {\n    $json = json_decode($str);\n    return $json && $str != $json;\n}\n\n/**\n* Check if array is associative\n*\n* @param array $array\n* @return bool\n*/\nfunction isAssociativeArray($array){\n    foreach ($array as $key => $value) {\n        if (is_string($key)) {\n            return true;\n        }\n    }\n    return false;\n}\n", "<?php\r\n// --------------------------------------------------------------------------------\r\n// PhpConcept Library - Zip Module 2.8.2\r\n// --------------------------------------------------------------------------------\r\n// License GNU/LGPL - Vincent Blavet - August 2009\r\n// http://www.phpconcept.net\r\n// --------------------------------------------------------------------------------\r\n//\r\n// Presentation :\r\n//   PclZip is a PHP library that manage ZIP archives.\r\n//   So far tests show that archives generated by PclZip are readable by\r\n//   WinZip application and other tools.\r\n//\r\n// Description :\r\n//   See readme.txt and http://www.phpconcept.net\r\n//\r\n// Warning :\r\n//   This library and the associated files are non commercial, non professional\r\n//   work.\r\n//   It should not have unexpected results. However if any damage is caused by\r\n//   this software the author can not be responsible.\r\n//   The use of this software is at the risk of the user.\r\n//\r\n// --------------------------------------------------------------------------------\r\n// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Constants\r\n  if (!defined('PCLZIP_READ_BLOCK_SIZE')) {\r\n    define( 'PCLZIP_READ_BLOCK_SIZE', 2048 );\r\n  }\r\n\r\n  // ----- File list separator\r\n  // In version 1.x of PclZip, the separator for file list is a space\r\n  // (which is not a very smart choice, specifically for windows paths !).\r\n  // A better separator should be a comma (,). This constant gives you the\r\n  // abilty to change that.\r\n  // However notice that changing this value, may have impact on existing\r\n  // scripts, using space separated filenames.\r\n  // Recommanded values for compatibility with older versions :\r\n  //define( 'PCLZIP_SEPARATOR', ' ' );\r\n  // Recommanded values for smart separation of filenames.\r\n  if (!defined('PCLZIP_SEPARATOR')) {\r\n    define( 'PCLZIP_SEPARATOR', ',' );\r\n  }\r\n\r\n  // ----- Error configuration\r\n  // 0 : PclZip Class integrated error handling\r\n  // 1 : PclError external library error handling. By enabling this\r\n  //     you must ensure that you have included PclError library.\r\n  // [2,...] : reserved for futur use\r\n  if (!defined('PCLZIP_ERROR_EXTERNAL')) {\r\n    define( 'PCLZIP_ERROR_EXTERNAL', 0 );\r\n  }\r\n\r\n  // ----- Optional static temporary directory\r\n  //       By default temporary files are generated in the script current\r\n  //       path.\r\n  //       If defined :\r\n  //       - MUST BE terminated by a '/'.\r\n  //       - MUST be a valid, already created directory\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );\r\n  // define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );\r\n  if (!defined('PCLZIP_TEMPORARY_DIR')) {\r\n    define( 'PCLZIP_TEMPORARY_DIR', '' );\r\n  }\r\n\r\n  // ----- Optional threshold ratio for use of temporary files\r\n  //       Pclzip sense the size of the file to add/extract and decide to\r\n  //       use or not temporary file. The algorythm is looking for\r\n  //       memory_limit of PHP and apply a ratio.\r\n  //       threshold = memory_limit * ratio.\r\n  //       Recommended values are under 0.5. Default 0.47.\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );\r\n  if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {\r\n    define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 );\r\n  }\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Global variables\r\n  $g_pclzip_version = \"2.8.2\";\r\n\r\n  // ----- Error codes\r\n  //   -1 : Unable to open file in binary write mode\r\n  //   -2 : Unable to open file in binary read mode\r\n  //   -3 : Invalid parameters\r\n  //   -4 : File does not exist\r\n  //   -5 : Filename is too long (max. 255)\r\n  //   -6 : Not a valid zip file\r\n  //   -7 : Invalid extracted file size\r\n  //   -8 : Unable to create directory\r\n  //   -9 : Invalid archive extension\r\n  //  -10 : Invalid archive format\r\n  //  -11 : Unable to delete file (unlink)\r\n  //  -12 : Unable to rename file (rename)\r\n  //  -13 : Invalid header checksum\r\n  //  -14 : Invalid archive size\r\n  define( 'PCLZIP_ERR_USER_ABORTED', 2 );\r\n  define( 'PCLZIP_ERR_NO_ERROR', 0 );\r\n  define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );\r\n  define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );\r\n  define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );\r\n  define( 'PCLZIP_ERR_MISSING_FILE', -4 );\r\n  define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );\r\n  define( 'PCLZIP_ERR_INVALID_ZIP', -6 );\r\n  define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );\r\n  define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );\r\n  define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );\r\n  define( 'PCLZIP_ERR_BAD_FORMAT', -10 );\r\n  define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );\r\n  define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );\r\n  define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );\r\n  define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );\r\n  define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );\r\n  define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );\r\n  define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );\r\n  define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );\r\n  define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );\r\n\r\n  // ----- Options values\r\n  define( 'PCLZIP_OPT_PATH', 77001 );\r\n  define( 'PCLZIP_OPT_ADD_PATH', 77002 );\r\n  define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );\r\n  define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );\r\n  define( 'PCLZIP_OPT_SET_CHMOD', 77005 );\r\n  define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );\r\n  define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );\r\n  define( 'PCLZIP_OPT_BY_NAME', 77008 );\r\n  define( 'PCLZIP_OPT_BY_INDEX', 77009 );\r\n  define( 'PCLZIP_OPT_BY_EREG', 77010 );\r\n  define( 'PCLZIP_OPT_BY_PREG', 77011 );\r\n  define( 'PCLZIP_OPT_COMMENT', 77012 );\r\n  define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );\r\n  define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );\r\n  define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );\r\n  define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );\r\n  define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );\r\n  // Having big trouble with crypt. Need to multiply 2 long int\r\n  // which is not correctly supported by PHP ...\r\n  //define( 'PCLZIP_OPT_CRYPT', 77018 );\r\n  define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );\r\n  define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022 ); // alias\r\n\r\n  // ----- File description attributes\r\n  define( 'PCLZIP_ATT_FILE_NAME', 79001 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );\r\n  define( 'PCLZIP_ATT_FILE_MTIME', 79004 );\r\n  define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );\r\n  define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );\r\n\r\n  // ----- Call backs values\r\n  define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );\r\n  define( 'PCLZIP_CB_POST_EXTRACT', 78002 );\r\n  define( 'PCLZIP_CB_PRE_ADD', 78003 );\r\n  define( 'PCLZIP_CB_POST_ADD', 78004 );\r\n  /* For futur use\r\n  define( 'PCLZIP_CB_PRE_LIST', 78005 );\r\n  define( 'PCLZIP_CB_POST_LIST', 78006 );\r\n  define( 'PCLZIP_CB_PRE_DELETE', 78007 );\r\n  define( 'PCLZIP_CB_POST_DELETE', 78008 );\r\n  */\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Class : PclZip\r\n  // Description :\r\n  //   PclZip is the class that represent a Zip archive.\r\n  //   The public methods allow the manipulation of the archive.\r\n  // Attributes :\r\n  //   Attributes must not be accessed directly.\r\n  // Methods :\r\n  //   PclZip() : Object creator\r\n  //   create() : Creates the Zip archive\r\n  //   listContent() : List the content of the Zip archive\r\n  //   extract() : Extract the content of the archive\r\n  //   properties() : List the properties of the archive\r\n  // --------------------------------------------------------------------------------\r\n  class PclZip\r\n  {\r\n    // ----- Filename of the zip file\r\n    var $zipname = '';\r\n\r\n    // ----- File descriptor of the zip file\r\n    var $zip_fd = 0;\r\n\r\n    // ----- Internal error handling\r\n    var $error_code = 1;\r\n    var $error_string = '';\r\n\r\n    // ----- Current status of the magic_quotes_runtime\r\n    // This value store the php configuration for magic_quotes\r\n    // The class can then disable the magic_quotes and reset it after\r\n    var $magic_quotes_status;\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZip()\r\n  // Description :\r\n  //   Creates a PclZip object and set the name of the associated Zip archive\r\n  //   filename.\r\n  //   Note that no real action is taken, if the archive does not exist it is not\r\n  //   created. Use create() for that.\r\n  // --------------------------------------------------------------------------------\r\n  public function __construct($p_zipname)\r\n  {\r\n\r\n    // ----- Tests the zlib\r\n    if (!function_exists('gzopen'))\r\n    {\r\n      die('Abort '.basename(__FILE__).' : Missing zlib extensions');\r\n    }\r\n\r\n    // ----- Set the attributes\r\n    $this->zipname = $p_zipname;\r\n    $this->zip_fd = 0;\r\n    $this->magic_quotes_status = -1;\r\n\r\n    // ----- Return\r\n    return;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   create($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   create($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two different synopsis. The first one is historical.\r\n  //   This method creates a Zip Archive. The Zip file is created in the\r\n  //   filesystem. The files and directories indicated in $p_filelist\r\n  //   are added in the archive. See the parameters description for the\r\n  //   supported format of $p_filelist.\r\n  //   When a directory is in the list, the directory and its content is added\r\n  //   in the archive.\r\n  //   In this synopsis, the function takes an optional variable list of\r\n  //   options. See bellow the supported options.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function create($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove from the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                             ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Invalid number / type of arguments\");\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        if ($v_string != '') {\r\n          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   add($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   add($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This methods add the list of files in an existing archive.\r\n  //   If a file with the same name already exists, it is added at the end of the\r\n  //   archive, the first one is still present.\r\n  //   If the archive does not exist, it is created.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_OPT_ADD_COMMENT :\r\n  //   PCLZIP_OPT_PREPEND_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function add($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type '\".gettype($p_filelist).\"' for p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : listContent()\r\n  // Description :\r\n  //   This public method, gives the list of the files and directories, with their\r\n  //   properties.\r\n  //   The properties of each entries in the list are (used also in other functions) :\r\n  //     filename : Name of the file. For a create or add action it is the filename\r\n  //                given by the user. For an extract function it is the filename\r\n  //                of the extracted file.\r\n  //     stored_filename : Name of the file / directory stored in the archive.\r\n  //     size : Size of the stored file.\r\n  //     compressed_size : Size of the file's data compressed in the archive\r\n  //                       (without the headers overhead)\r\n  //     mtime : Last known modification date of the file (UNIX timestamp)\r\n  //     comment : Comment associated with the file\r\n  //     folder : true | false\r\n  //     index : index of the file in the archive\r\n  //     status : status of the action (depending of the action) :\r\n  //              Values are :\r\n  //                ok : OK !\r\n  //                filtered : the file / dir is not extracted (filtered by user)\r\n  //                already_a_directory : the file can not be extracted because a\r\n  //                                      directory with the same name already exists\r\n  //                write_protected : the file can not be extracted because a file\r\n  //                                  with the same name already exists and is\r\n  //                                  write protected\r\n  //                newer_exist : the file was not extracted because a newer file exists\r\n  //                path_creation_fail : the file is not extracted because the folder\r\n  //                                     does not exist and can not be created\r\n  //                write_error : the file was not extracted because there was a\r\n  //                              error while writing the file\r\n  //                read_error : the file was not extracted because there was a error\r\n  //                             while reading the file\r\n  //                invalid_header : the file was not extracted because of an archive\r\n  //                                 format error (bad file header)\r\n  //   Note that each time a method can continue operating when there\r\n  //   is an action error on a file, the error is only logged in the file status.\r\n  // Return Values :\r\n  //   0 on an unrecoverable failure,\r\n  //   The list of the files in the archive.\r\n  // --------------------------------------------------------------------------------\r\n  function listContent()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    if (($v_result = $this->privList($p_list)) != 1)\r\n    {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extract($p_path=\"./\", $p_remove_path=\"\")\r\n  //   extract([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method extract all the files / directories from the archive to the\r\n  //   folder indicated in $p_path.\r\n  //   If you want to ignore the 'root' part of path of the memorized files\r\n  //   you can indicate this in the optional $p_remove_path parameter.\r\n  //   By default, if a newer file with the same name already exists, the\r\n  //   file is not extracted.\r\n  //\r\n  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions\r\n  //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append\r\n  //   at the end of the path value of PCLZIP_OPT_PATH.\r\n  // Parameters :\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 or a negative value on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function extract()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_BY_NAME => 'optional',\r\n                                                   PCLZIP_OPT_BY_EREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_PREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_INDEX => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                    ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path,\r\n                                         $v_remove_all_path, $v_options);\r\n    if ($v_result < 1) {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extractByIndex($p_index, $p_path=\"./\", $p_remove_path=\"\")\r\n  //   extractByIndex($p_index, [$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method is doing a partial extract of the archive.\r\n  //   The extracted files or folders are identified by their index in the\r\n  //   archive (from 0 to n).\r\n  //   Note that if the index identify a folder, only the folder entry is\r\n  //   extracted, not all the files included in the archive.\r\n  // Parameters :\r\n  //   $p_index : A single index (integer) or a string of indexes of files to\r\n  //              extract. The form of the string is \"0,4-6,8-12\" with only numbers\r\n  //              and '-' for range or ',' to separate ranges. No spaces or ';'\r\n  //              are allowed.\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and\r\n  //     not as files.\r\n  //     The resulting content is in a new field 'content' in the file\r\n  //     structure.\r\n  //     This option must be used alone (any other options are ignored).\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  //function extractByIndex($p_index, options...)\r\n  function extractByIndex($p_index)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {\r\n          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Trick\r\n    // Here I want to reuse extractByRule(), so I need to parse the $p_index\r\n    // with privParseOptions()\r\n    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);\r\n    $v_options_trick = array();\r\n    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick,\r\n                                        array (PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n    if ($v_result != 1) {\r\n        return 0;\r\n    }\r\n    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Call the extracting fct\r\n    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {\r\n        return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   delete([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method removes files from the archive.\r\n  //   If no parameters are given, then all the archive is emptied.\r\n  // Parameters :\r\n  //   None or optional arguments.\r\n  // Options :\r\n  //   PCLZIP_OPT_BY_INDEX :\r\n  //   PCLZIP_OPT_BY_NAME :\r\n  //   PCLZIP_OPT_BY_EREG :\r\n  //   PCLZIP_OPT_BY_PREG :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the files which are still present in the archive.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function delete()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Parse the options\r\n      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                        array (PCLZIP_OPT_BY_NAME => 'optional',\r\n                                               PCLZIP_OPT_BY_EREG => 'optional',\r\n                                               PCLZIP_OPT_BY_PREG => 'optional',\r\n                                               PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n      if ($v_result != 1) {\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Call the delete fct\r\n    $v_list = array();\r\n    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {\r\n      $this->privSwapBackMagicQuotes();\r\n      unset($v_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : deleteByIndex()\r\n  // Description :\r\n  //   ***** Deprecated *****\r\n  //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.\r\n  // --------------------------------------------------------------------------------\r\n  function deleteByIndex($p_index)\r\n  {\r\n\r\n    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : properties()\r\n  // Description :\r\n  //   This method gives the properties of the archive.\r\n  //   The properties are :\r\n  //     nb : Number of files in the archive\r\n  //     comment : Comment associated with the archive file\r\n  //     status : not_exist, ok\r\n  // Parameters :\r\n  //   None\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   An array with the archive properties.\r\n  // --------------------------------------------------------------------------------\r\n  function properties()\r\n  {\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      $this->privSwapBackMagicQuotes();\r\n      return(0);\r\n    }\r\n\r\n    // ----- Default properties\r\n    $v_prop = array();\r\n    $v_prop['comment'] = '';\r\n    $v_prop['nb'] = 0;\r\n    $v_prop['status'] = 'not_exist';\r\n\r\n    // ----- Look if file exists\r\n    if (@is_file($this->zipname))\r\n    {\r\n      // ----- Open the zip file\r\n      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n        // ----- Return\r\n        return 0;\r\n      }\r\n\r\n      // ----- Read the central directory informations\r\n      $v_central_dir = array();\r\n      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return 0;\r\n      }\r\n\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Set the user attributes\r\n      $v_prop['comment'] = $v_central_dir['comment'];\r\n      $v_prop['nb'] = $v_central_dir['entries'];\r\n      $v_prop['status'] = 'ok';\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_prop;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : duplicate()\r\n  // Description :\r\n  //   This method creates an archive by copying the content of an other one. If\r\n  //   the archive already exist, it is replaced by the new one without any warning.\r\n  // Parameters :\r\n  //   $p_archive : The filename of a valid archive, or\r\n  //                a valid PclZip object.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 or a negative value on error (error code).\r\n  // --------------------------------------------------------------------------------\r\n  function duplicate($p_archive)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the $p_archive is a PclZip object\r\n    if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Duplicate the archive\r\n      $v_result = $this->privDuplicate($p_archive->zipname);\r\n    }\r\n\r\n    // ----- Look if the $p_archive is a string (so a filename)\r\n    else if (is_string($p_archive))\r\n    {\r\n\r\n      // ----- Check that $p_archive is a valid zip file\r\n      // TBC : Should also check the archive format\r\n      if (!is_file($p_archive)) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"No file with filename '\".$p_archive.\"'\");\r\n        $v_result = PCLZIP_ERR_MISSING_FILE;\r\n      }\r\n      else {\r\n        // ----- Duplicate the archive\r\n        $v_result = $this->privDuplicate($p_archive);\r\n      }\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : merge()\r\n  // Description :\r\n  //   This method merge the $p_archive_to_add archive at the end of the current\r\n  //   one ($this).\r\n  //   If the archive ($this) does not exist, the merge becomes a duplicate.\r\n  //   If the $p_archive_to_add archive does not exist, the merge is a success.\r\n  // Parameters :\r\n  //   $p_archive_to_add : It can be directly the filename of a valid zip archive,\r\n  //                       or a PclZip object archive.\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 or negative values on error (see below).\r\n  // --------------------------------------------------------------------------------\r\n  function merge($p_archive_to_add)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a PclZip object\r\n    if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($p_archive_to_add);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a string (so a filename)\r\n    else if (is_string($p_archive_to_add))\r\n    {\r\n\r\n      // ----- Create a temporary archive\r\n      $v_object_archive = new PclZip($p_archive_to_add);\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($v_object_archive);\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorCode()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorCode()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorCode());\r\n    }\r\n    else {\r\n      return($this->error_code);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorName()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorName($p_with_code=false)\r\n  {\r\n    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',\r\n                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',\r\n                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',\r\n                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',\r\n                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',\r\n                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',\r\n                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',\r\n                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',\r\n                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',\r\n                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',\r\n                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',\r\n                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',\r\n                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',\r\n                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',\r\n                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',\r\n                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',\r\n                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',\r\n                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',\r\n                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'\r\n                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'\r\n                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'\r\n                    );\r\n\r\n    if (isset($v_name[$this->error_code])) {\r\n      $v_value = $v_name[$this->error_code];\r\n    }\r\n    else {\r\n      $v_value = 'NoName';\r\n    }\r\n\r\n    if ($p_with_code) {\r\n      return($v_value.' ('.$this->error_code.')');\r\n    }\r\n    else {\r\n      return($v_value);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorInfo()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorInfo($p_full=false)\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorString());\r\n    }\r\n    else {\r\n      if ($p_full) {\r\n        return($this->errorName(true).\" : \".$this->error_string);\r\n      }\r\n      else {\r\n        return($this->error_string.\" [code \".$this->error_code.\"]\");\r\n      }\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****\r\n// *****                                                        *****\r\n// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****\r\n// --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFormat()\r\n  // Description :\r\n  //   This method check that the archive exists and is a valid zip archive.\r\n  //   Several level of check exists. (futur)\r\n  // Parameters :\r\n  //   $p_level : Level of check. Default 0.\r\n  //              0 : Check the first bytes (magic codes) (default value))\r\n  //              1 : 0 + Check the central directory (futur)\r\n  //              2 : 1 + Check each file header (futur)\r\n  // Return Values :\r\n  //   true on success,\r\n  //   false on error, the error code is set.\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFormat($p_level=0)\r\n  {\r\n    $v_result = true;\r\n\r\n    // ----- Reset the file system cache\r\n    clearstatcache();\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the file exits\r\n    if (!is_file($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"Missing archive file '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check that the file is readeable\r\n    if (!is_readable($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to read archive '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check the magic code\r\n    // TBC\r\n\r\n    // ----- Check the central header\r\n    // TBC\r\n\r\n    // ----- Check each file header\r\n    // TBC\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privParseOptions()\r\n  // Description :\r\n  //   This internal methods reads the variable list of arguments ($p_options_list,\r\n  //   $p_size) and generate an array with the options and values ($v_result_list).\r\n  //   $v_requested_options contains the options that can be present and those that\r\n  //   must be present.\r\n  //   $v_requested_options is an array, with the option value as key, and 'optional',\r\n  //   or 'mandatory' as value.\r\n  // Parameters :\r\n  //   See above.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the options\r\n    $i=0;\r\n    while ($i<$p_size) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$p_options_list[$i]])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid optional parameter '\".$p_options_list[$i].\"' for this method\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for next option\r\n      switch ($p_options_list[$i]) {\r\n        // ----- Look for options that request a path value\r\n        case PCLZIP_OPT_PATH :\r\n        case PCLZIP_OPT_REMOVE_PATH :\r\n        case PCLZIP_OPT_ADD_PATH :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check the value\r\n          $v_value = $p_options_list[$i+1];\r\n          if ((!is_integer($v_value)) || ($v_value<0)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Integer expected for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value (and convert it in bytes)\r\n          $v_result_list[$p_options_list[$i]] = $v_value*1048576;\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_ON :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_OFF :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'\");\r\n            return PclZip::errorCode();\r\n          }\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (   is_string($p_options_list[$i+1])\r\n              && ($p_options_list[$i+1] != '')) {\r\n            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n            $i++;\r\n          }\r\n          else {\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that request an array of string for value\r\n        case PCLZIP_OPT_BY_NAME :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an EREG or PREG expression\r\n        case PCLZIP_OPT_BY_EREG :\r\n          // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG\r\n          // to PCLZIP_OPT_BY_PREG\r\n          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;\r\n        case PCLZIP_OPT_BY_PREG :\r\n        //case PCLZIP_OPT_CRYPT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_OPT_COMMENT :\r\n        case PCLZIP_OPT_ADD_COMMENT :\r\n        case PCLZIP_OPT_PREPEND_COMMENT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE,\r\n                                 \"Missing parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE,\r\n                                 \"Wrong parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an array of index\r\n        case PCLZIP_OPT_BY_INDEX :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_work_list = array();\r\n          if (is_string($p_options_list[$i+1])) {\r\n\r\n              // ----- Remove spaces\r\n              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');\r\n\r\n              // ----- Parse items\r\n              $v_work_list = explode(\",\", $p_options_list[$i+1]);\r\n          }\r\n          else if (is_integer($p_options_list[$i+1])) {\r\n              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_work_list = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Value must be integer, string or array for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Reduce the index list\r\n          // each index item in the list must be a couple with a start and\r\n          // an end value : [0,3], [5-5], [8-10], ...\r\n          // ----- Check the format of each item\r\n          $v_sort_flag=false;\r\n          $v_sort_value=0;\r\n          for ($j=0; $j<sizeof($v_work_list); $j++) {\r\n              // ----- Explode the item\r\n              $v_item_list = explode(\"-\", $v_work_list[$j]);\r\n              $v_size_item_list = sizeof($v_item_list);\r\n\r\n              // ----- TBC : Here we might check that each item is a\r\n              // real integer ...\r\n\r\n              // ----- Look for single value\r\n              if ($v_size_item_list == 1) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];\r\n              }\r\n              elseif ($v_size_item_list == 2) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];\r\n              }\r\n              else {\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Too many values in index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n\r\n\r\n              // ----- Look for list sort\r\n              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {\r\n                  $v_sort_flag=true;\r\n\r\n                  // ----- TBC : An automatic sort should be writen ...\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Invalid order of index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];\r\n          }\r\n\r\n          // ----- Sort the items\r\n          if ($v_sort_flag) {\r\n              // TBC : To Be Completed\r\n          }\r\n\r\n          // ----- Next option\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request no value\r\n        case PCLZIP_OPT_REMOVE_ALL_PATH :\r\n        case PCLZIP_OPT_EXTRACT_AS_STRING :\r\n        case PCLZIP_OPT_NO_COMPRESSION :\r\n        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :\r\n        case PCLZIP_OPT_REPLACE_NEWER :\r\n        case PCLZIP_OPT_STOP_ON_ERROR :\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        // ----- Look for options that request an octal value\r\n        case PCLZIP_OPT_SET_CHMOD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request a call-back\r\n        case PCLZIP_CB_PRE_EXTRACT :\r\n        case PCLZIP_CB_POST_EXTRACT :\r\n        case PCLZIP_CB_PRE_ADD :\r\n        case PCLZIP_CB_POST_ADD :\r\n        /* for futur use\r\n        case PCLZIP_CB_PRE_DELETE :\r\n        case PCLZIP_CB_POST_DELETE :\r\n        case PCLZIP_CB_PRE_LIST :\r\n        case PCLZIP_CB_POST_LIST :\r\n        */\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_function_name = $p_options_list[$i+1];\r\n\r\n          // ----- Check that the value is a valid existing function\r\n          if (!function_exists($v_function_name)) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Function '\".$v_function_name.\"()' is not an existing function for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Set the attribute\r\n          $v_result_list[$p_options_list[$i]] = $v_function_name;\r\n          $i++;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Unknown parameter '\"\r\n                               .$p_options_list[$i].\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Next options\r\n      $i++;\r\n    }\r\n\r\n    // ----- Look for mandatory options\r\n    if ($v_requested_options !== false) {\r\n      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n        // ----- Look for mandatory option\r\n        if ($v_requested_options[$key] == 'mandatory') {\r\n          // ----- Look if present\r\n          if (!isset($v_result_list[$key])) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default values\r\n    if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOptionDefaultThreshold()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privOptionDefaultThreshold(&$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n        || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get 'memory_limit' configuration value\r\n    $v_memory_limit = ini_get('memory_limit');\r\n    $v_memory_limit = trim($v_memory_limit);\r\n    $last = strtolower(substr($v_memory_limit, -1));\r\n\r\n    if($last == 'g') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit)*1073741824;\r\n    }\r\n    if($last == 'm') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit) * 1048576;\r\n    }\r\n    if($last == 'k') {\r\n        $v_memory_limit = ((int) $v_memory_limit)*1024;\r\n    }\r\n\r\n    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);\r\n\r\n\r\n    // ----- Sanity check : No threshold if value lower than 1M\r\n    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {\r\n      unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrParseAtt()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- For each file in the list check the attributes\r\n    foreach ($p_file_list as $v_key => $v_value) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$v_key])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file attribute '\".$v_key.\"' for this file\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for attribute\r\n      switch ($v_key) {\r\n        case PCLZIP_ATT_FILE_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['filename'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_short_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty short filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_FULL_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_full_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty full filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_ATT_FILE_COMMENT :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['comment'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_MTIME :\r\n          if (!is_integer($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". Integer expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['mtime'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_CONTENT :\r\n          $p_filedescr['content'] = $v_value;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                                   \"Unknown parameter '\".$v_key.\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for mandatory options\r\n      if ($v_requested_options !== false) {\r\n        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n          // ----- Look for mandatory option\r\n          if ($v_requested_options[$key] == 'mandatory') {\r\n            // ----- Look if present\r\n            if (!isset($p_file_list[$key])) {\r\n              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n              return PclZip::errorCode();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    // end foreach\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrExpand()\r\n  // Description :\r\n  //   This method look for each item of the list to see if its a file, a folder\r\n  //   or a string to be added as file. For any other type of files (link, other)\r\n  //   just ignore the item.\r\n  //   Then prepare the information that will be stored for that file.\r\n  //   When its a folder, expand the folder with all the files that are in that\r\n  //   folder (recursively).\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrExpand(&$p_filedescr_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Create a result list\r\n    $v_result_list = array();\r\n\r\n    // ----- Look each entry\r\n    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {\r\n\r\n      // ----- Get filedescr\r\n      $v_descr = $p_filedescr_list[$i];\r\n\r\n      // ----- Reduce the filename\r\n      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);\r\n      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);\r\n\r\n      // ----- Look for real file or folder\r\n      if (file_exists($v_descr['filename'])) {\r\n        if (@is_file($v_descr['filename'])) {\r\n          $v_descr['type'] = 'file';\r\n        }\r\n        else if (@is_dir($v_descr['filename'])) {\r\n          $v_descr['type'] = 'folder';\r\n        }\r\n        else if (@is_link($v_descr['filename'])) {\r\n          // skip\r\n          continue;\r\n        }\r\n        else {\r\n          // skip\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // ----- Look for string added as file\r\n      else if (isset($v_descr['content'])) {\r\n        $v_descr['type'] = 'virtual_file';\r\n      }\r\n\r\n      // ----- Missing file\r\n      else {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$v_descr['filename'].\"' does not exist\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Calculate the stored filename\r\n      $this->privCalculateStoredFilename($v_descr, $p_options);\r\n\r\n      // ----- Add the descriptor in result list\r\n      $v_result_list[sizeof($v_result_list)] = $v_descr;\r\n\r\n      // ----- Look for folder\r\n      if ($v_descr['type'] == 'folder') {\r\n        // ----- List of items in folder\r\n        $v_dirlist_descr = array();\r\n        $v_dirlist_nb = 0;\r\n        if ($v_folder_handler = @opendir($v_descr['filename'])) {\r\n          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {\r\n\r\n            // ----- Skip '.' and '..'\r\n            if (($v_item_handler == '.') || ($v_item_handler == '..')) {\r\n                continue;\r\n            }\r\n\r\n            // ----- Compose the full filename\r\n            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;\r\n\r\n            // ----- Look for different stored filename\r\n            // Because the name of the folder was changed, the name of the\r\n            // files/sub-folders also change\r\n            if (($v_descr['stored_filename'] != $v_descr['filename'])\r\n                 && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {\r\n              if ($v_descr['stored_filename'] != '') {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;\r\n              }\r\n              else {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;\r\n              }\r\n            }\r\n\r\n            $v_dirlist_nb++;\r\n          }\r\n\r\n          @closedir($v_folder_handler);\r\n        }\r\n        else {\r\n          // TBC : unable to open folder in read mode\r\n        }\r\n\r\n        // ----- Expand each element of the list\r\n        if ($v_dirlist_nb != 0) {\r\n          // ----- Expand\r\n          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Concat the resulting list\r\n          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);\r\n        }\r\n        else {\r\n        }\r\n\r\n        // ----- Free local array\r\n        unset($v_dirlist_descr);\r\n      }\r\n    }\r\n\r\n    // ----- Get the result list\r\n    $p_filedescr_list = $v_result_list;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCreate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCreate($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the file in write mode\r\n    if (($v_result = $this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the list of files\r\n    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAdd()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAdd($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Look if the archive exists or is empty\r\n    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0))\r\n    {\r\n\r\n      // ----- Do a create\r\n      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      fclose($v_zip_temp_fd);\r\n      $this->privCloseFd();\r\n      @unlink($v_zip_temp_name);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          fclose($v_zip_temp_fd);\r\n          $this->privCloseFd();\r\n          @unlink($v_zip_temp_name);\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = $v_central_dir['comment'];\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {\r\n      $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOpenFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privOpenFd($p_mode)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if already open\r\n    if ($this->zip_fd != 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \\''.$this->zipname.'\\' already open');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in '.$p_mode.' mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCloseFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privCloseFd()\r\n  {\r\n    $v_result=1;\r\n\r\n    if ($this->zip_fd != 0)\r\n      @fclose($this->zip_fd);\r\n    $this->zip_fd = 0;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddList()\r\n  // Description :\r\n  //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is\r\n  //   different from the real path of the file. This is usefull if you want to have PclTar\r\n  //   running in any directory, and memorize relative path from an other directory.\r\n  // Parameters :\r\n  //   $p_list : An array containing the file or directory names to add in the tar\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  //   $p_add_dir : Path to add in the filename path archived\r\n  //   $p_remove_dir : Path to remove in the filename path archived\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)\r\n  function privAddList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = '';\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileList()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_filedescr_list : An array containing the file description\r\n  //                      or directory names to add in the zip\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_header = array();\r\n\r\n    // ----- Recuperate the current number of elt in list\r\n    $v_nb = sizeof($p_result_list);\r\n\r\n    // ----- Loop on the files\r\n    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {\r\n      // ----- Format the filename\r\n      $p_filedescr_list[$j]['filename']\r\n      = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);\r\n\r\n\r\n      // ----- Skip empty file names\r\n      // TBC : Can this be possible ? not checked in DescrParseAtt ?\r\n      if ($p_filedescr_list[$j]['filename'] == \"\") {\r\n        continue;\r\n      }\r\n\r\n      // ----- Check the filename\r\n      if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')\r\n          && (!file_exists($p_filedescr_list[$j]['filename']))) {\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$p_filedescr_list[$j]['filename'].\"' does not exist\");\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look if it is a file or a dir with no all path remove option\r\n      // or a dir with all its path removed\r\n//      if (   (is_file($p_filedescr_list[$j]['filename']))\r\n//          || (   is_dir($p_filedescr_list[$j]['filename'])\r\n      if (   ($p_filedescr_list[$j]['type'] == 'file')\r\n          || ($p_filedescr_list[$j]['type'] == 'virtual_file')\r\n          || (   ($p_filedescr_list[$j]['type'] == 'folder')\r\n              && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])\r\n                  || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))\r\n          ) {\r\n\r\n        // ----- Add the file\r\n        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header,\r\n                                       $p_options);\r\n        if ($v_result != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Store the file infos\r\n        $p_result_list[$v_nb++] = $v_header;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n    // TBC : Already done in the fileAtt check ... ?\r\n    if ($p_filename == \"\") {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file list parameter (invalid or empty list)\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Look for a stored different filename\r\n    /* TBC : Removed\r\n    if (isset($p_filedescr['stored_filename'])) {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    else {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    */\r\n\r\n    // ----- Set the file properties\r\n    clearstatcache();\r\n    $p_header['version'] = 20;\r\n    $p_header['version_extracted'] = 10;\r\n    $p_header['flag'] = 0;\r\n    $p_header['compression'] = 0;\r\n    $p_header['crc'] = 0;\r\n    $p_header['compressed_size'] = 0;\r\n    $p_header['filename_len'] = strlen($p_filename);\r\n    $p_header['extra_len'] = 0;\r\n    $p_header['disk'] = 0;\r\n    $p_header['internal'] = 0;\r\n    $p_header['offset'] = 0;\r\n    $p_header['filename'] = $p_filename;\r\n// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;\r\n    $p_header['stored_filename'] = $p_filedescr['stored_filename'];\r\n    $p_header['extra'] = '';\r\n    $p_header['status'] = 'ok';\r\n    $p_header['index'] = -1;\r\n\r\n    // ----- Look for regular file\r\n    if ($p_filedescr['type']=='file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for regular folder\r\n    else if ($p_filedescr['type']=='folder') {\r\n      $p_header['external'] = 0x00000010;\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for virtual file\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = strlen($p_filedescr['content']);\r\n    }\r\n\r\n\r\n    // ----- Look for filetime\r\n    if (isset($p_filedescr['mtime'])) {\r\n      $p_header['mtime'] = $p_filedescr['mtime'];\r\n    }\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['mtime'] = time();\r\n    }\r\n    else {\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n    }\r\n\r\n    // ------ Look for file comment\r\n    if (isset($p_filedescr['comment'])) {\r\n      $p_header['comment_len'] = strlen($p_filedescr['comment']);\r\n      $p_header['comment'] = $p_filedescr['comment'];\r\n    }\r\n    else {\r\n      $p_header['comment_len'] = 0;\r\n      $p_header['comment'] = '';\r\n    }\r\n\r\n    // ----- Look for pre-add callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_ADD].'(PCLZIP_CB_PRE_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_header['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {\r\n        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);\r\n      }\r\n    }\r\n\r\n    // ----- Look for empty stored filename\r\n    if ($p_header['stored_filename'] == \"\") {\r\n      $p_header['status'] = \"filtered\";\r\n    }\r\n\r\n    // ----- Check the path length\r\n    if (strlen($p_header['stored_filename']) > 0xFF) {\r\n      $p_header['status'] = 'filename_too_long';\r\n    }\r\n\r\n    // ----- Look if no error, or file not skipped\r\n    if ($p_header['status'] == 'ok') {\r\n\r\n      // ----- Look for a file\r\n      if ($p_filedescr['type'] == 'file') {\r\n        // ----- Look for using temporary file to zip\r\n        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {\r\n          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);\r\n          if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n            return $v_result;\r\n          }\r\n        }\r\n\r\n        // ----- Use \"in memory\" zip algo\r\n        else {\r\n\r\n        // ----- Open the source file\r\n        if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Read the file content\r\n        $v_content = @fread($v_file, $p_header['size']);\r\n\r\n        // ----- Close the file\r\n        @fclose($v_file);\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n\r\n        }\r\n\r\n      }\r\n\r\n      // ----- Look for a virtual file (a file from string)\r\n      else if ($p_filedescr['type'] == 'virtual_file') {\r\n\r\n        $v_content = $p_filedescr['content'];\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n      }\r\n\r\n      // ----- Look for a directory\r\n      else if ($p_filedescr['type'] == 'folder') {\r\n        // ----- Look for directory last '/'\r\n        if (@substr($p_header['stored_filename'], -1) != '/') {\r\n          $p_header['stored_filename'] .= '/';\r\n        }\r\n\r\n        // ----- Set the file properties\r\n        $p_header['size'] = 0;\r\n        //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked\r\n        $p_header['external'] = 0x00000010;   // Value for a folder : to be checked\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for post-add callback\r\n    if (isset($p_options[PCLZIP_CB_POST_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_ADD].'(PCLZIP_CB_POST_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Ignored\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Nothing can be modified\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=PCLZIP_ERR_NO_ERROR;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n\r\n    // ----- Open the source file\r\n    if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Creates a compressed temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_file_compressed = @gzopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = filesize($p_filename);\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @gzputs($v_file_compressed, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file);\r\n    @gzclose($v_file_compressed);\r\n\r\n    // ----- Check the minimum file size\r\n    if (filesize($v_gzip_temp_name) < 18) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \\''.$v_gzip_temp_name.'\\' has invalid filesize - should be minimum 18 bytes');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the compressed attributes\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the gzip file header\r\n    $v_binary_data = @fread($v_file_compressed, 10);\r\n    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);\r\n\r\n    // ----- Check some parameters\r\n    $v_data_header['os'] = bin2hex($v_data_header['os']);\r\n\r\n    // ----- Read the gzip file footer\r\n    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);\r\n    $v_binary_data = @fread($v_file_compressed, 8);\r\n    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);\r\n\r\n    // ----- Set the attributes\r\n    $p_header['compression'] = ord($v_data_header['cm']);\r\n    //$p_header['mtime'] = $v_data_header['mtime'];\r\n    $p_header['crc'] = $v_data_footer['crc'];\r\n    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Call the header generation\r\n    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the compressed data\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0)\r\n    {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    fseek($v_file_compressed, 10);\r\n    $v_size = $p_header['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file_compressed, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Unlink the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCalculateStoredFilename()\r\n  // Description :\r\n  //   Based on file descriptor properties and global options, this method\r\n  //   calculate the filename that will be stored in the archive.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCalculateStoredFilename(&$p_filedescr, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variables\r\n    $p_filename = $p_filedescr['filename'];\r\n    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {\r\n      $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];\r\n    }\r\n    else {\r\n      $p_add_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n      $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];\r\n    }\r\n    else {\r\n      $p_remove_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n      $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n    }\r\n    else {\r\n      $p_remove_all_dir = 0;\r\n    }\r\n\r\n\r\n    // ----- Look for full name change\r\n    if (isset($p_filedescr['new_full_name'])) {\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);\r\n    }\r\n\r\n    // ----- Look for path and/or short name change\r\n    else {\r\n\r\n      // ----- Look for short name change\r\n      // Its when we cahnge just the filename but not the path\r\n      if (isset($p_filedescr['new_short_name'])) {\r\n        $v_path_info = pathinfo($p_filename);\r\n        $v_dir = '';\r\n        if ($v_path_info['dirname'] != '') {\r\n          $v_dir = $v_path_info['dirname'].'/';\r\n        }\r\n        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];\r\n      }\r\n      else {\r\n        // ----- Calculate the stored filename\r\n        $v_stored_filename = $p_filename;\r\n      }\r\n\r\n      // ----- Look for all path to remove\r\n      if ($p_remove_all_dir) {\r\n        $v_stored_filename = basename($p_filename);\r\n      }\r\n      // ----- Look for partial path remove\r\n      else if ($p_remove_dir != \"\") {\r\n        if (substr($p_remove_dir, -1) != '/')\r\n          $p_remove_dir .= \"/\";\r\n\r\n        if (   (substr($p_filename, 0, 2) == \"./\")\r\n            || (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n\r\n          if (   (substr($p_filename, 0, 2) == \"./\")\r\n              && (substr($p_remove_dir, 0, 2) != \"./\")) {\r\n            $p_remove_dir = \"./\".$p_remove_dir;\r\n          }\r\n          if (   (substr($p_filename, 0, 2) != \"./\")\r\n              && (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n            $p_remove_dir = substr($p_remove_dir, 2);\r\n          }\r\n        }\r\n\r\n        $v_compare = PclZipUtilPathInclusion($p_remove_dir,\r\n                                             $v_stored_filename);\r\n        if ($v_compare > 0) {\r\n          if ($v_compare == 2) {\r\n            $v_stored_filename = \"\";\r\n          }\r\n          else {\r\n            $v_stored_filename = substr($v_stored_filename,\r\n                                        strlen($p_remove_dir));\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);\r\n\r\n      // ----- Look for path to add\r\n      if ($p_add_dir != \"\") {\r\n        if (substr($p_add_dir, -1) == \"/\")\r\n          $v_stored_filename = $p_add_dir.$v_stored_filename;\r\n        else\r\n          $v_stored_filename = $p_add_dir.\"/\".$v_stored_filename;\r\n      }\r\n    }\r\n\r\n    // ----- Filename (reduce the path of stored name)\r\n    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);\r\n    $p_filedescr['stored_filename'] = $v_stored_filename;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Store the offset position of the file\r\n    $p_header['offset'] = ftell($this->zip_fd);\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvVVVvv\", 0x04034b50,\r\n                          $p_header['version_extracted'], $p_header['flag'],\r\n                          $p_header['compression'], $v_mtime, $v_mdate,\r\n                          $p_header['crc'], $p_header['compressed_size'],\r\n                          $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len']);\r\n\r\n    // ----- Write the first 148 bytes of the header in the archive\r\n    fputs($this->zip_fd, $v_binary_data, 30);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // TBC\r\n    //for(reset($p_header); $key = key($p_header); next($p_header)) {\r\n    //}\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvvVVVvvvvvVV\", 0x02014b50,\r\n                          $p_header['version'], $p_header['version_extracted'],\r\n                          $p_header['flag'], $p_header['compression'],\r\n                          $v_mtime, $v_mdate, $p_header['crc'],\r\n                          $p_header['compressed_size'], $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len'], $p_header['comment_len'],\r\n                          $p_header['disk'], $p_header['internal'],\r\n                          $p_header['external'], $p_header['offset']);\r\n\r\n    // ----- Write the 42 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 46);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n    if ($p_header['comment_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvVVv\", 0x06054b50, 0, 0, $p_nb_entries,\r\n                          $p_nb_entries, $p_size,\r\n                          $p_offset, strlen($p_comment));\r\n\r\n    // ----- Write the 22 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 22);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_comment) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_comment, strlen($p_comment));\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privList()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privList(&$p_list)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of Central Dir\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_central_dir['offset']))\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    for ($i=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n      // ----- Read the file header\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return $v_result;\r\n      }\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Get the only interesting attributes\r\n      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);\r\n      unset($v_header);\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privConvertHeader2FileInfo()\r\n  // Description :\r\n  //   This function takes the file informations from the central directory\r\n  //   entries and extract the interesting parameters that will be given back.\r\n  //   The resulting file infos are set in the array $p_info\r\n  //     $p_info['filename'] : Filename with full path. Given by user (add),\r\n  //                           extracted in the filesystem (extract).\r\n  //     $p_info['stored_filename'] : Stored filename in the archive.\r\n  //     $p_info['size'] = Size of the file.\r\n  //     $p_info['compressed_size'] = Compressed size of the file.\r\n  //     $p_info['mtime'] = Last modification date of the file.\r\n  //     $p_info['comment'] = Comment associated with the file.\r\n  //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.\r\n  //     $p_info['status'] = status of the action on the file.\r\n  //     $p_info['crc'] = CRC of the file content.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privConvertHeader2FileInfo($p_header, &$p_info)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Get the interesting attributes\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);\r\n    $p_info['filename'] = $v_temp_path;\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);\r\n    $p_info['stored_filename'] = $v_temp_path;\r\n    $p_info['size'] = $p_header['size'];\r\n    $p_info['compressed_size'] = $p_header['compressed_size'];\r\n    $p_info['mtime'] = $p_header['mtime'];\r\n    $p_info['comment'] = $p_header['comment'];\r\n    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);\r\n    $p_info['index'] = $p_header['index'];\r\n    $p_info['status'] = $p_header['status'];\r\n    $p_info['crc'] = $p_header['crc'];\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractByRule()\r\n  // Description :\r\n  //   Extract a file or directory depending of rules (by index, by name, ...)\r\n  // Parameters :\r\n  //   $p_file_list : An array where will be placed the properties of each\r\n  //                  extracted file\r\n  //   $p_path : Path to add while writing the extracted files\r\n  //   $p_remove_path : Path to remove (from the file memorized path) while writing the\r\n  //                    extracted files. If the path does not match the file path,\r\n  //                    the file is extracted with its memorized path.\r\n  //                    $p_remove_path does not apply to 'list' mode.\r\n  //                    $p_path and $p_remove_path are commulative.\r\n  // Return Values :\r\n  //   1 on success,0 or less on error (see error code list)\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check the path\r\n    if (   ($p_path == \"\")\r\n        || (   (substr($p_path, 0, 1) != \"/\")\r\n            && (substr($p_path, 0, 3) != \"../\")\r\n            && (substr($p_path,1,2)!=\":/\")))\r\n      $p_path = \"./\".$p_path;\r\n\r\n    // ----- Reduce the path last (and duplicated) '/'\r\n    if (($p_path != \"./\") && ($p_path != \"/\"))\r\n    {\r\n      // ----- Look for the path end '/'\r\n      while (substr($p_path, -1) == \"/\")\r\n      {\r\n        $p_path = substr($p_path, 0, strlen($p_path)-1);\r\n      }\r\n    }\r\n\r\n    // ----- Look for path to remove format (should end by /)\r\n    if (($p_remove_path != \"\") && (substr($p_remove_path, -1) != '/'))\r\n    {\r\n      $p_remove_path .= '/';\r\n    }\r\n    $p_remove_path_size = strlen($p_remove_path);\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result = $this->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n\r\n    // ----- Read each entry\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read next Central dir entry\r\n      @rewind($this->zip_fd);\r\n      if (@fseek($this->zip_fd, $v_pos_entry))\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read the file header\r\n      $v_header = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n      // ----- Store the index\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Store the file position\r\n      $v_pos_entry = ftell($this->zip_fd);\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_extract = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_extract = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_extract = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_extract = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for no rule, which means extract all the archive\r\n      else {\r\n          $v_extract = true;\r\n      }\r\n\r\n      // ----- Check compression method\r\n      if (   ($v_extract)\r\n          && (   ($v_header['compression'] != 8)\r\n              && ($v_header['compression'] != 0))) {\r\n          $v_header['status'] = 'unsupported_compression';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION,\r\n                                   \"Filename '\".$v_header['stored_filename'].\"' is \"\r\n                                       .\"compressed by an unsupported compression \"\r\n                                       .\"method (\".$v_header['compression'].\") \");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n      }\r\n\r\n      // ----- Check encrypted files\r\n      if (($v_extract) && (($v_header['flag'] & 1) == 1)) {\r\n          $v_header['status'] = 'unsupported_encryption';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION,\r\n                                   \"Unsupported encryption for \"\r\n                                       .\" filename '\".$v_header['stored_filename']\r\n                                   .\"'\");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n    }\r\n\r\n      // ----- Look for real extraction\r\n      if (($v_extract) && ($v_header['status'] != 'ok')) {\r\n          $v_result = $this->privConvertHeader2FileInfo($v_header,\r\n                                                $p_file_list[$v_nb_extracted++]);\r\n          if ($v_result != 1) {\r\n              $this->privCloseFd();\r\n              $this->privSwapBackMagicQuotes();\r\n              return $v_result;\r\n          }\r\n\r\n          $v_extract = false;\r\n      }\r\n\r\n      // ----- Look for real extraction\r\n      if ($v_extract)\r\n      {\r\n\r\n        // ----- Go to the file position\r\n        @rewind($this->zip_fd);\r\n        if (@fseek($this->zip_fd, $v_header['offset']))\r\n        {\r\n          // ----- Close the zip file\r\n          $this->privCloseFd();\r\n\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Look for extraction as string\r\n        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {\r\n\r\n          $v_string = '';\r\n\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Set the file content\r\n          $p_file_list[$v_nb_extracted]['content'] = $v_string;\r\n\r\n          // ----- Next extracted file\r\n          $v_nb_extracted++;\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for extraction in standard output\r\n        elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))\r\n                && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {\r\n          // ----- Extracting the file in standard output\r\n          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for normal extraction\r\n        else {\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFile($v_header,\r\n                                              $p_path, $p_remove_path,\r\n                                              $p_remove_all_path,\r\n                                              $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //\r\n  // 1 : ... ?\r\n  // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for all path to remove\r\n    if ($p_remove_all_path == true) {\r\n        // ----- Look for folder entry that not need to be extracted\r\n        if (($p_entry['external']&0x00000010)==0x00000010) {\r\n\r\n            $p_entry['status'] = \"filtered\";\r\n\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Get the basename of the path\r\n        $p_entry['filename'] = basename($p_entry['filename']);\r\n    }\r\n\r\n    // ----- Look for path to remove\r\n    else if ($p_remove_path != \"\")\r\n    {\r\n      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"filtered\";\r\n\r\n        // ----- Return\r\n        return $v_result;\r\n      }\r\n\r\n      $p_remove_path_size = strlen($p_remove_path);\r\n      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)\r\n      {\r\n\r\n        // ----- Remove the path\r\n        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);\r\n\r\n      }\r\n    }\r\n\r\n    // Added by LS Team to check for invalid paths\r\n    $p_entry['filename'] = get_absolute_path($p_entry['filename']);    \r\n\r\n    // ----- Add the path\r\n    if ($p_path != '') {\r\n      $p_entry['filename'] = $p_path.\"/\".$p_entry['filename'];\r\n    }\r\n\r\n    // ----- Check a base_dir_restriction\r\n    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {\r\n      $v_inclusion\r\n      = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION],\r\n                                $p_entry['filename']);\r\n      if ($v_inclusion == 0) {\r\n\r\n        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION\");\r\n\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n    // ----- Look for specific actions while the file exist\r\n    if (file_exists($p_entry['filename']))\r\n    {\r\n\r\n      // ----- Look if file is a directory\r\n      if (is_dir($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"already_a_directory\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"already used by an existing directory\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n      // ----- Look if file is write protected\r\n      else if (!is_writeable($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"write_protected\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                                 \"Filename '\".$p_entry['filename'].\"' exists \"\r\n                                 .\"and is write protected\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n\r\n      // ----- Look if the extracted file is older\r\n      else if (filemtime($p_entry['filename']) > $p_entry['mtime'])\r\n      {\r\n        // ----- Change the file status\r\n        if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))\r\n            && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {\r\n            }\r\n            else {\r\n            $p_entry['status'] = \"newer_exist\";\r\n\r\n            // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n            // For historical reason first PclZip implementation does not stop\r\n            // when this kind of error occurs.\r\n            if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n                && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                         \"Newer version of '\".$p_entry['filename'].\"' exists \"\r\n                        .\"and option PCLZIP_OPT_REPLACE_NEWER is not selected\");\r\n\r\n                return PclZip::errorCode();\r\n              }\r\n            }\r\n      }\r\n      else {\r\n      }\r\n    }\r\n\r\n    // ----- Check the directory availability and create it if necessary\r\n    else {\r\n      if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))\r\n        $v_dir_to_check = $p_entry['filename'];\r\n      else if (!strstr($p_entry['filename'], \"/\"))\r\n        $v_dir_to_check = \"\";\r\n      else\r\n        $v_dir_to_check = dirname($p_entry['filename']);\r\n\r\n        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {\r\n\r\n          // ----- Change the file status\r\n          $p_entry['status'] = \"path_creation_fail\";\r\n\r\n          // ----- Return\r\n          //return $v_result;\r\n          $v_result = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010))\r\n      {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n              // ----- Opening destination file\r\n          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)\r\n          {\r\n\r\n            // ----- Change the file status\r\n            $p_entry['status'] = \"write_error\";\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n          }\r\n\r\n\r\n          // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n          $v_size = $p_entry['compressed_size'];\r\n          while ($v_size != 0)\r\n          {\r\n            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n            $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n            /* Try to speed up the code\r\n            $v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n            @fwrite($v_dest_file, $v_binary_data, $v_read_size);\r\n            */\r\n            @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n            $v_size -= $v_read_size;\r\n          }\r\n\r\n          // ----- Closing the destination file\r\n          fclose($v_dest_file);\r\n\r\n          // ----- Change the file mtime\r\n          touch($p_entry['filename'], $p_entry['mtime']);\r\n\r\n\r\n        }\r\n        else {\r\n          // ----- TBC\r\n          // Need to be finished\r\n          if (($p_entry['flag'] & 1) == 1) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \\''.$p_entry['filename'].'\\' is encrypted. Encrypted files are not supported.');\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n\r\n          // ----- Look for using temporary file to unzip\r\n          if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n              && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                  || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                      && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {\r\n            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);\r\n            if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n              return $v_result;\r\n            }\r\n          }\r\n\r\n          // ----- Look for extract in memory\r\n          else {\r\n\r\n\r\n            // ----- Read the compressed file in a buffer (one shot)\r\n            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n            // ----- Decompress the file\r\n            $v_file_content = @gzinflate($v_buffer);\r\n            unset($v_buffer);\r\n            if ($v_file_content === FALSE) {\r\n\r\n              // ----- Change the file status\r\n              // TBC\r\n              $p_entry['status'] = \"error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Opening destination file\r\n            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n\r\n              // ----- Change the file status\r\n              $p_entry['status'] = \"write_error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Write the uncompressed data\r\n            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);\r\n            unset($v_file_content);\r\n\r\n            // ----- Closing the destination file\r\n            @fclose($v_dest_file);\r\n\r\n          }\r\n\r\n          // ----- Change the file mtime\r\n          @touch($p_entry['filename'], $p_entry['mtime']);\r\n        }\r\n\r\n        // ----- Look for chmod option\r\n        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {\r\n\r\n          // ----- Change the mode of the file\r\n          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileUsingTempFile(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Creates a temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_dest_file = @fopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Write gz file format header\r\n    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));\r\n    @fwrite($v_dest_file, $v_binary_data, 10);\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Write gz file format footer\r\n    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);\r\n    @fwrite($v_dest_file, $v_binary_data, 8);\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_dest_file);\r\n\r\n    // ----- Opening destination file\r\n    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n      $p_entry['status'] = \"write_error\";\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary gz file\r\n    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {\r\n      @fclose($v_dest_file);\r\n      $p_entry['status'] = \"read_error\";\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['size'];\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @gzread($v_src_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n    @fclose($v_dest_file);\r\n    @gzclose($v_src_file);\r\n\r\n    // ----- Delete the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileInOutput()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileInOutput(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compressed_size'] == $p_entry['size']) {\r\n\r\n          // ----- Read the file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_buffer;\r\n          unset($v_buffer);\r\n        }\r\n        else {\r\n\r\n          // ----- Read the compressed file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          $v_file_content = gzinflate($v_buffer);\r\n          unset($v_buffer);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_file_content;\r\n          unset($v_file_content);\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Change abort status\r\n    if ($p_entry['status'] == \"aborted\") {\r\n      $p_entry['status'] = \"skipped\";\r\n    }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileAsString()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    $v_header = array();\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n  //      if ($p_entry['compressed_size'] == $p_entry['size'])\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n          // ----- Reading the file\r\n          $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n        }\r\n        else {\r\n\r\n          // ----- Reading the file\r\n          $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          if (($p_string = @gzinflate($v_data)) === FALSE) {\r\n              // TBC\r\n          }\r\n        }\r\n\r\n        // ----- Trace\r\n      }\r\n      else {\r\n          // TBC : error : can not extract a folder in a string\r\n      }\r\n\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Swap the content to header\r\n      $v_local_header['content'] = $p_string;\r\n      $p_string = '';\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Swap back the content to header\r\n      $p_string = $v_local_header['content'];\r\n      unset($v_local_header['content']);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x04034b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 26);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 26)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);\r\n\r\n    // ----- Get extra_fields\r\n    if ($v_data['extra_len'] != 0) {\r\n      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);\r\n    }\r\n    else {\r\n      $p_header['extra'] = '';\r\n    }\r\n\r\n    // ----- Extract properties\r\n    $p_header['version_extracted'] = $v_data['version'];\r\n    $p_header['compression'] = $v_data['compression'];\r\n    $p_header['size'] = $v_data['size'];\r\n    $p_header['compressed_size'] = $v_data['compressed_size'];\r\n    $p_header['crc'] = $v_data['crc'];\r\n    $p_header['flag'] = $v_data['flag'];\r\n    $p_header['filename_len'] = $v_data['filename_len'];\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    $p_header['mdate'] = $v_data['mdate'];\r\n    $p_header['mtime'] = $v_data['mtime'];\r\n    if ($p_header['mdate'] && $p_header['mtime'])\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // TBC\r\n    //for(reset($v_data); $key = key($v_data); next($v_data)) {\r\n    //}\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set the status field\r\n    $p_header['status'] = \"ok\";\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x02014b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 42);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 42)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    if ($p_header['filename_len'] != 0)\r\n      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);\r\n    else\r\n      $p_header['filename'] = '';\r\n\r\n    // ----- Get extra\r\n    if ($p_header['extra_len'] != 0)\r\n      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);\r\n    else\r\n      $p_header['extra'] = '';\r\n\r\n    // ----- Get comment\r\n    if ($p_header['comment_len'] != 0)\r\n      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);\r\n    else\r\n      $p_header['comment'] = '';\r\n\r\n    // ----- Extract properties\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    //if ($p_header['mdate'] && $p_header['mtime'])\r\n    // TBC : bug : this was ignoring time with 0/0/0\r\n    if (1)\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set default status to ok\r\n    $p_header['status'] = 'ok';\r\n\r\n    // ----- Look if it is a directory\r\n    if (substr($p_header['filename'], -1) == '/') {\r\n      //$p_header['external'] = 0x41FF0010;\r\n      $p_header['external'] = 0x00000010;\r\n    }\r\n\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFileHeaders()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 on error;\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFileHeaders(&$p_local_header, &$p_central_header)\r\n  {\r\n    $v_result=1;\r\n\r\n      // ----- Check the static values\r\n      // TBC\r\n      if ($p_local_header['filename'] != $p_central_header['filename']) {\r\n      }\r\n      if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {\r\n      }\r\n      if ($p_local_header['flag'] != $p_central_header['flag']) {\r\n      }\r\n      if ($p_local_header['compression'] != $p_central_header['compression']) {\r\n      }\r\n      if ($p_local_header['mtime'] != $p_central_header['mtime']) {\r\n      }\r\n      if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {\r\n      }\r\n\r\n      // ----- Look for flag bit 3\r\n      if (($p_local_header['flag'] & 8) == 8) {\r\n          $p_local_header['size'] = $p_central_header['size'];\r\n          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];\r\n          $p_local_header['crc'] = $p_central_header['crc'];\r\n      }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadEndCentralDir()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadEndCentralDir(&$p_central_dir)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Go to the end of the zip file\r\n    $v_size = filesize($this->zipname);\r\n    @fseek($this->zip_fd, $v_size);\r\n    if (@ftell($this->zip_fd) != $v_size)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \\''.$this->zipname.'\\'');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- First try : look if this is an archive with no commentaries (most of the time)\r\n    // in this case the end of central dir is at 22 bytes of the file end\r\n    $v_found = 0;\r\n    if ($v_size > 26) {\r\n      @fseek($this->zip_fd, $v_size-22);\r\n      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read for bytes\r\n      $v_binary_data = @fread($this->zip_fd, 4);\r\n      $v_data = @unpack('Vid', $v_binary_data);\r\n\r\n      // ----- Check signature\r\n      if ($v_data['id'] == 0x06054b50) {\r\n        $v_found = 1;\r\n      }\r\n\r\n      $v_pos = ftell($this->zip_fd);\r\n    }\r\n\r\n    // ----- Go back to the maximum possible size of the Central Dir End Record\r\n    if (!$v_found) {\r\n      $v_maximum_size = 65557; // 0xFFFF + 22;\r\n      if ($v_maximum_size > $v_size)\r\n        $v_maximum_size = $v_size;\r\n      @fseek($this->zip_fd, $v_size-$v_maximum_size);\r\n      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read byte per byte in order to find the signature\r\n      $v_pos = ftell($this->zip_fd);\r\n      $v_bytes = 0x00000000;\r\n      while ($v_pos < $v_size)\r\n      {\r\n        // ----- Read a byte\r\n        $v_byte = @fread($this->zip_fd, 1);\r\n\r\n        // -----  Add the byte\r\n        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);\r\n        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number\r\n        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.\r\n        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);\r\n\r\n        // ----- Compare the bytes\r\n        if ($v_bytes == 0x504b0506)\r\n        {\r\n          $v_pos++;\r\n          break;\r\n        }\r\n\r\n        $v_pos++;\r\n      }\r\n\r\n      // ----- Look if not found end of central dir\r\n      if ($v_pos == $v_size)\r\n      {\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Unable to find End of Central Dir Record signature\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Read the first 18 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 18);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 18)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid End of Central Dir Record size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);\r\n\r\n    // ----- Check the global size\r\n    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {\r\n\r\n      // ----- Removed in release 2.2 see readme file\r\n      // The check of the file size is a little too strict.\r\n      // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.\r\n      // While decrypted, zip has training 0 bytes\r\n      if (0) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,\r\n                           'The central dir is not at the end of the archive.'\r\n                           .' Some trailing bytes exists after the archive.');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Get comment\r\n    if ($v_data['comment_size'] != 0) {\r\n      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);\r\n    }\r\n    else\r\n      $p_central_dir['comment'] = '';\r\n\r\n    $p_central_dir['entries'] = $v_data['entries'];\r\n    $p_central_dir['disk_entries'] = $v_data['disk_entries'];\r\n    $p_central_dir['offset'] = $v_data['offset'];\r\n    $p_central_dir['size'] = $v_data['size'];\r\n    $p_central_dir['disk'] = $v_data['disk'];\r\n    $p_central_dir['disk_start'] = $v_data['disk_start'];\r\n\r\n    // TBC\r\n    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {\r\n    //}\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDeleteByRule()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDeleteByRule(&$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Scan all the files\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_pos_entry))\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    $v_header_list = array();\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read the file header\r\n      $v_header_list[$v_nb_extracted] = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n\r\n      // ----- Store the index\r\n      $v_header_list[$v_nb_extracted]['index'] = $i;\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_found = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n                  elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /* Indicates a folder */\r\n                          && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_found = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_found = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          $v_found = true;\r\n      }\r\n\r\n      // ----- Look for deletion\r\n      if ($v_found)\r\n      {\r\n        unset($v_header_list[$v_nb_extracted]);\r\n      }\r\n      else\r\n      {\r\n        $v_nb_extracted++;\r\n      }\r\n    }\r\n\r\n    // ----- Look if something need to be deleted\r\n    if ($v_nb_extracted > 0) {\r\n\r\n        // ----- Creates a temporay file\r\n        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n        // ----- Creates a temporary zip archive\r\n        $v_temp_zip = new PclZip($v_zip_temp_name);\r\n\r\n        // ----- Open the temporary zip file in write mode\r\n        if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {\r\n            $this->privCloseFd();\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Look which file need to be kept\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n\r\n            // ----- Calculate the position of the header\r\n            @rewind($this->zip_fd);\r\n            if (@fseek($this->zip_fd,  $v_header_list[$i]['offset'])) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Error log\r\n                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n                // ----- Return\r\n                return PclZip::errorCode();\r\n            }\r\n\r\n            // ----- Read the file header\r\n            $v_local_header = array();\r\n            if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Check that local file header is same as central file header\r\n            if ($this->privCheckFileHeaders($v_local_header,\r\n                                            $v_header_list[$i]) != 1) {\r\n                // TBC\r\n            }\r\n            unset($v_local_header);\r\n\r\n            // ----- Write the file header\r\n            if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Read/write the data block\r\n            if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n        }\r\n\r\n        // ----- Store the offset of the central dir\r\n        $v_offset = @ftell($v_temp_zip->zip_fd);\r\n\r\n        // ----- Re-Create the Central Dir files header\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n            // ----- Create the file header\r\n            if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n                $v_temp_zip->privCloseFd();\r\n                $this->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Transform the header to a 'usable' info\r\n            $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n        }\r\n\r\n\r\n        // ----- Zip file comment\r\n        $v_comment = '';\r\n        if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n          $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n        }\r\n\r\n        // ----- Calculate the size of the central header\r\n        $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset;\r\n\r\n        // ----- Create the central dir footer\r\n        if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {\r\n            // ----- Reset the file list\r\n            unset($v_header_list);\r\n            $v_temp_zip->privCloseFd();\r\n            $this->privCloseFd();\r\n            @unlink($v_zip_temp_name);\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Close\r\n        $v_temp_zip->privCloseFd();\r\n        $this->privCloseFd();\r\n\r\n        // ----- Delete the zip file\r\n        // TBC : I should test the result ...\r\n        @unlink($this->zipname);\r\n\r\n        // ----- Rename the temporary file\r\n        // TBC : I should test the result ...\r\n        //@rename($v_zip_temp_name, $this->zipname);\r\n        PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n        // ----- Destroy the temporary archive\r\n        unset($v_temp_zip);\r\n    }\r\n\r\n    // ----- Remove every files : reset the file\r\n    else if ($v_central_dir['entries'] != 0) {\r\n        $this->privCloseFd();\r\n\r\n        if (($v_result = $this->privOpenFd('wb')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        $this->privCloseFd();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDirCheck()\r\n  // Description :\r\n  //   Check if a directory exists, if not it creates it and all the parents directory\r\n  //   which may be useful.\r\n  // Parameters :\r\n  //   $p_dir : Directory path to check.\r\n  // Return Values :\r\n  //    1 : OK\r\n  //   -1 : Unable to create directory\r\n  // --------------------------------------------------------------------------------\r\n  function privDirCheck($p_dir, $p_is_dir=false)\r\n  {\r\n    $v_result = 1;\r\n\r\n\r\n    // ----- Remove the final '/'\r\n    if (($p_is_dir) && (substr($p_dir, -1)=='/'))\r\n    {\r\n      $p_dir = substr($p_dir, 0, strlen($p_dir)-1);\r\n    }\r\n\r\n    // ----- Check the directory availability\r\n    if ((is_dir($p_dir)) || ($p_dir == \"\"))\r\n    {\r\n      return 1;\r\n    }\r\n\r\n    // ----- Extract parent directory\r\n    $p_parent_dir = dirname($p_dir);\r\n\r\n    // ----- Just a check\r\n    if ($p_parent_dir != $p_dir)\r\n    {\r\n      // ----- Look for parent directory\r\n      if ($p_parent_dir != \"\")\r\n      {\r\n        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Create the directory\r\n    if (!@mkdir($p_dir, 0777))\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, \"Unable to create directory '$p_dir'\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privMerge()\r\n  // Description :\r\n  //   If $p_archive_to_add does not exist, the function exit with a success result.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privMerge(&$p_archive_to_add)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the archive_to_add exists\r\n    if (!is_file($p_archive_to_add->zipname))\r\n    {\r\n\r\n      // ----- Nothing to merge, so merge is a success\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if the archive exists\r\n    if (!is_file($this->zipname))\r\n    {\r\n\r\n      // ----- Do a duplicate\r\n      $v_result = $this->privDuplicate($p_archive_to_add->zipname);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Open the archive_to_add file\r\n    if (($v_result=$p_archive_to_add->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir_to_add = array();\r\n    if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($p_archive_to_add->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the files from the archive_to_add into the temporary file\r\n    $v_size = $v_central_dir_to_add['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($v_zip_temp_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the block of file headers from the archive_to_add\r\n    $v_size = $v_central_dir_to_add['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Merge the file comments\r\n    $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];\r\n\r\n    // ----- Calculate the size of the (new) central header\r\n    $v_size = @ftell($v_zip_temp_fd)-$v_offset;\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive fd\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n      @fclose($v_zip_temp_fd);\r\n      $this->zip_fd = null;\r\n\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n    $p_archive_to_add->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDuplicate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDuplicate($p_archive_filename)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the $p_archive_filename exists\r\n    if (!is_file($p_archive_filename))\r\n    {\r\n\r\n      // ----- Nothing to duplicate, so duplicate is a success.\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \\''.$p_archive_filename.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = filesize($p_archive_filename);\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorLog()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorLog($p_error_code=0, $p_error_string='')\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclError($p_error_code, $p_error_string);\r\n    }\r\n    else {\r\n      $this->error_code = $p_error_code;\r\n      $this->error_string = $p_error_string;\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorReset()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorReset()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclErrorReset();\r\n    }\r\n    else {\r\n      $this->error_code = 0;\r\n      $this->error_string = '';\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDisableMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDisableMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if already done\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get and memorize the magic_quote value\r\n    $this->magic_quotes_status = @get_magic_quotes_runtime();\r\n\r\n    // ----- Disable magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n      @set_magic_quotes_runtime(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privSwapBackMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privSwapBackMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if something to do\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n        @set_magic_quotes_runtime($this->magic_quotes_status);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  }\r\n  // End of class\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathReduction()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathReduction($p_dir)\r\n  {\r\n    $v_result = \"\";\r\n\r\n    // ----- Look for not empty path\r\n    if ($p_dir != \"\") {\r\n      // ----- Explode path by directory names\r\n      $v_list = explode(\"/\", $p_dir);\r\n\r\n      // ----- Study directories from last to first\r\n      $v_skip = 0;\r\n      for ($i=sizeof($v_list)-1; $i>=0; $i--) {\r\n        // ----- Look for current path\r\n        if ($v_list[$i] == \".\") {\r\n          // ----- Ignore this directory\r\n          // Should be the first $i=0, but no check is done\r\n        }\r\n        else if ($v_list[$i] == \"..\") {\r\n          $v_skip++;\r\n        }\r\n        else if ($v_list[$i] == \"\") {\r\n          // ----- First '/' i.e. root slash\r\n          if ($i == 0) {\r\n            $v_result = \"/\".$v_result;\r\n            if ($v_skip > 0) {\r\n                // ----- It is an invalid path, so the path is not modified\r\n                // TBC\r\n                $v_result = $p_dir;\r\n                $v_skip = 0;\r\n            }\r\n          }\r\n          // ----- Last '/' i.e. indicates a directory\r\n          else if ($i == (sizeof($v_list)-1)) {\r\n            $v_result = $v_list[$i];\r\n          }\r\n          // ----- Double '/' inside the path\r\n          else {\r\n            // ----- Ignore only the double '//' in path,\r\n            // but not the first and last '/'\r\n          }\r\n        }\r\n        else {\r\n          // ----- Look for item to skip\r\n          if ($v_skip > 0) {\r\n            $v_skip--;\r\n          }\r\n          else {\r\n            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?\"/\".$v_result:\"\");\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Look for skip\r\n      if ($v_skip > 0) {\r\n        while ($v_skip > 0) {\r\n            $v_result = '../'.$v_result;\r\n            $v_skip--;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathInclusion()\r\n  // Description :\r\n  //   This function indicates if the path $p_path is under the $p_dir tree. Or,\r\n  //   said in an other way, if the file or sub-dir $p_path is inside the dir\r\n  //   $p_dir.\r\n  //   The function indicates also if the path is exactly the same as the dir.\r\n  //   This function supports path with duplicated '/' like '//', but does not\r\n  //   support '.' or '..' statements.\r\n  // Parameters :\r\n  // Return Values :\r\n  //   0 if $p_path is not inside directory $p_dir\r\n  //   1 if $p_path is inside directory $p_dir\r\n  //   2 if $p_path is exactly the same as $p_dir\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathInclusion($p_dir, $p_path)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Look for path beginning by ./\r\n    if (   ($p_dir == '.')\r\n        || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) {\r\n      $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1);\r\n    }\r\n    if (   ($p_path == '.')\r\n        || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) {\r\n      $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1);\r\n    }\r\n\r\n    // ----- Explode dir and path by directory separator\r\n    $v_list_dir = explode(\"/\", $p_dir);\r\n    $v_list_dir_size = sizeof($v_list_dir);\r\n    $v_list_path = explode(\"/\", $p_path);\r\n    $v_list_path_size = sizeof($v_list_path);\r\n\r\n    // ----- Study directories paths\r\n    $i = 0;\r\n    $j = 0;\r\n    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {\r\n\r\n      // ----- Look for empty dir (path reduction)\r\n      if ($v_list_dir[$i] == '') {\r\n        $i++;\r\n        continue;\r\n      }\r\n      if ($v_list_path[$j] == '') {\r\n        $j++;\r\n        continue;\r\n      }\r\n\r\n      // ----- Compare the items\r\n      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {\r\n        $v_result = 0;\r\n      }\r\n\r\n      // ----- Next items\r\n      $i++;\r\n      $j++;\r\n    }\r\n\r\n    // ----- Look if everything seems to be the same\r\n    if ($v_result) {\r\n      // ----- Skip all the empty items\r\n      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;\r\n      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;\r\n\r\n      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {\r\n        // ----- There are exactly the same\r\n        $v_result = 2;\r\n      }\r\n      else if ($i < $v_list_dir_size) {\r\n        // ----- The path is shorter than the dir\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilCopyBlock()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_mode : read/write compression mode\r\n  //             0 : src & dest normal\r\n  //             1 : src gzip, dest normal\r\n  //             2 : src normal, dest gzip\r\n  //             3 : src & dest gzip\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)\r\n  {\r\n    $v_result = 1;\r\n\r\n    if ($p_mode==0)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==1)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==2)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==3)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilRename()\r\n  // Description :\r\n  //   This function tries to do a simple rename() function. If it fails, it\r\n  //   tries to copy the $p_src file in a new $p_dest file and then unlink the\r\n  //   first one.\r\n  // Parameters :\r\n  //   $p_src : Old filename\r\n  //   $p_dest : New filename\r\n  // Return Values :\r\n  //   1 on success, 0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilRename($p_src, $p_dest)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Try to rename the files\r\n    if (!@rename($p_src, $p_dest)) {\r\n\r\n      // ----- Try to copy & unlink the src\r\n      if (!@copy($p_src, $p_dest)) {\r\n        $v_result = 0;\r\n      }\r\n      else if (!@unlink($p_src)) {\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilOptionText()\r\n  // Description :\r\n  //   Translate option value in text. Mainly for debug purpose.\r\n  // Parameters :\r\n  //   $p_option : the option value.\r\n  // Return Values :\r\n  //   The option text value.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilOptionText($p_option)\r\n  {\r\n\r\n    $v_list = get_defined_constants();\r\n    for (reset($v_list); $v_key = key($v_list); next($v_list)) {\r\n        $v_prefix = substr($v_key, 0, 10);\r\n        if ((   ($v_prefix == 'PCLZIP_OPT')\r\n           || ($v_prefix == 'PCLZIP_CB_')\r\n           || ($v_prefix == 'PCLZIP_ATT'))\r\n            && ($v_list[$v_key] == $p_option)) {\r\n        return $v_key;\r\n        }\r\n    }\r\n\r\n    $v_result = 'Unknown';\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilTranslateWinPath()\r\n  // Description :\r\n  //   Translate windows path by replacing '\\' by '/' and optionally removing\r\n  //   drive letter.\r\n  // Parameters :\r\n  //   $p_path : path to translate.\r\n  //   $p_remove_disk_letter : true | false\r\n  // Return Values :\r\n  //   The path translated.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)\r\n  {\r\n    if (stristr(php_uname(), 'windows')) {\r\n      // ----- Look for potential disk letter\r\n      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {\r\n          $p_path = substr($p_path, $v_position+1);\r\n      }\r\n      // ----- Change potential windows directory separator\r\n      if ((strpos($p_path, '\\\\') > 0) || (substr($p_path, 0,1) == '\\\\')) {\r\n          $p_path = strtr($p_path, '\\\\', '/');\r\n      }\r\n    }\r\n    return $p_path;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n?>\r\n"], "fixing_code": ["<?php if (!defined('BASEPATH')) {\n    exit('No direct script access allowed');\n}\n/*\n* LimeSurvey\n* Copyright (C) 2007-2011 The LimeSurvey Project Team / Carsten Schmitz\n* All rights reserved.\n* License: GNU/GPL License v2 or later, see LICENSE.php\n* LimeSurvey is free software. This version may have been modified pursuant\n* to the GNU General Public License, and as distributed it includes or\n* is derivative of works licensed under the GNU General Public License or\n* other free or open source software licenses.\n* See COPYRIGHT.php for copyright notices and details.\n*/\nYii::import('application.helpers.sanitize_helper', true);\n\n\n/**\n * Translation helper function\n * @param string $sToTranslate\n * @param string $sEscapeMode Valid values are html (this is the default, js and unescaped)\n * @param string $sLanguage\n * @return mixed|string\n */\nfunction gT($sToTranslate, $sEscapeMode = 'html', $sLanguage = null)\n{\n    return quoteText(Yii::t('', $sToTranslate, array(), null, $sLanguage), $sEscapeMode);\n}\n\n/**\n * Translation helper function which outputs right away.\n * @param string $sToTranslate\n * @param string $sEscapeMode\n */\nfunction eT($sToTranslate, $sEscapeMode = 'html')\n{\n    echo gT($sToTranslate, $sEscapeMode);\n}\n\n/**\n * Translation helper function for plural forms\n * @param string $sTextToTranslate\n * @param integer $iCount\n * @param string $sEscapeMode\n * @return string\n */\nfunction ngT($sTextToTranslate, $iCount, $sEscapeMode = 'html')\n{\n    return quoteText(Yii::t('', $sTextToTranslate, $iCount), $sEscapeMode);\n}\n\n/**\n * Translation helper function for plural forms which outputs right away\n * @param string $sToTranslate\n * @param integer $iCount\n * @param string $sEscapeMode\n */\nfunction neT($sToTranslate, $iCount, $sEscapeMode = 'html')\n{\n    echo ngT($sToTranslate, $iCount, $sEscapeMode);\n}\n\n\n/**\n * Quotes a translation according to purpose\n * if sEscapeMode is null, we use HTML method because probably we had to specify null as sEscapeMode upstream\n *\n * @param mixed $sText Text to quote\n * @param string $sEscapeMode Optional - One of the values 'html','js' or 'unescaped' - defaults to 'html'\n * @return mixed|string\n */\nfunction quoteText($sText, $sEscapeMode = 'html')\n{\n    if ($sEscapeMode === null) {\n            $sEscapeMode = 'html';\n    }\n\n    switch ($sEscapeMode) {\n        case 'html':\n            return HTMLEscape($sText);\n        case 'js':\n            return javascriptEscape($sText);\n        case 'json':\n            return jsonEscape($sText);\n        case 'unescaped':\n            return $sText;\n        default:\n            return \"Unsupported EscapeMode in gT method\";\n    }\n}\n\n/**\n* getQuestionTypeList() Returns list of question types available in LimeSurvey. Edit this if you are adding a new\n*    question type\n*\n* @param string $SelectedCode Value of the Question Type (defaults to \"T\")\n* @param string $ReturnType Type of output from this function (defaults to selector)\n*\n* @return array|string depending on $ReturnType param, returns a straight \"array\" of question types, or an <option></option> list\n*\n* Explanation of questiontype array:\n*\n* description : Question description\n* subquestions : 0= Does not support subquestions x=Number of subquestion scales\n* answerscales : 0= Does not need answers x=Number of answer scales (usually 1, but e.g. for dual scale question set to 2)\n* assessable : 0=Does not support assessment values when editing answerd 1=Support assessment values\n*/\nfunction getQuestionTypeList($SelectedCode = \"T\", $ReturnType = \"selector\")\n{\n\n    $qtypes = Question::typeList();\n\n    if ($ReturnType == \"array\") {\n        return $qtypes;\n    }\n\n\n    if ($ReturnType == \"group\") {\n        $newqType = [];\n        foreach ($qtypes as $qkey => $qtype) {\n            $newqType[$qtype['group']][$qkey] = $qtype;\n        }\n\n\n        $qtypeselecter = \"\";\n        foreach ($newqType as $group => $members) {\n            $qtypeselecter .= '<optgroup label=\"'.$group.'\">';\n            foreach ($members as $TypeCode => $TypeProperties) {\n                $qtypeselecter .= \"<option value='$TypeCode'\";\n                if ($SelectedCode == $TypeCode) {\n                    $qtypeselecter .= \" selected='selected'\";\n                }\n                $qtypeselecter .= \">{$TypeProperties['description']}</option>\\n\";\n            }\n            $qtypeselecter .= '</optgroup>';\n        }\n\n        return $qtypeselecter;\n    };\n    $qtypeselecter = \"\";\n    foreach ($qtypes as $TypeCode => $TypeProperties) {\n        $qtypeselecter .= \"<option value='$TypeCode'\";\n        if ($SelectedCode == $TypeCode) {\n            $qtypeselecter .= \" selected='selected'\";\n        }\n        $qtypeselecter .= \">{$TypeProperties['description']}</option>\\n\";\n    }\n\n\n    return $qtypeselecter;\n}\n\n/**\n* isStandardTemplate returns true if a template is a standard template\n* This function does not check if a template actually exists\n*\n* @param mixed $sTemplateName template name to look for\n* @return bool True if standard template, otherwise false\n*/\nfunction isStandardTemplate($sTemplateName)\n{\n    return Template::isStandardTemplate($sTemplateName);\n}\n\n/**\n* getSurveyList() Queries the database (survey table) for a list of existing surveys\n*\n* @param boolean $bReturnArray If set to true an array instead of an HTML option list is given back\n* @return string|array This string is returned containing <option></option> formatted list of existing surveys\n*\n*/\nfunction getSurveyList($bReturnArray = false)\n{\n    static $cached = null;\n    $bCheckIntegrity = false;\n    $timeadjust = getGlobalSetting('timeadjust');\n    App()->setLanguage((isset(Yii::app()->session['adminlang']) ? Yii::app()->session['adminlang'] : 'en'));\n    $surveynames = array();\n\n    if (is_null($cached)) {\n        $surveyidresult = Survey::model()\n            ->permission(Yii::app()->user->getId())\n            ->with('languagesettings')\n            ->findAll();\n        foreach ($surveyidresult as $result) {\n            $surveynames[] = array_merge($result->attributes, $result->languagesettings[$result->language]->attributes);\n        }\n        \n        usort($surveynames, function($a, $b)\n        {\n                return strcmp($a['surveyls_title'], $b['surveyls_title']);\n        });\n        $cached = $surveynames;\n    } else {\n        $surveynames = $cached;\n    }\n    $surveyselecter = \"\";\n    if ($bReturnArray === true) {\n        return $surveynames;\n    }\n    $activesurveys = '';\n    $inactivesurveys = '';\n    $expiredsurveys = '';\n    foreach ($surveynames as $sv) {\n\n        $surveylstitle = flattenText($sv['surveyls_title']);\n        if (strlen($surveylstitle) > 70) {\n            $surveylstitle = htmlspecialchars(mb_strcut(html_entity_decode($surveylstitle, ENT_QUOTES, 'UTF-8'), 0, 70, 'UTF-8')).\"...\";\n        }\n\n        if ($sv['active'] != 'Y') {\n            $inactivesurveys .= \"<option \";\n            if (Yii::app()->user->getId() == $sv['owner_id']) {\n                $inactivesurveys .= \" class='mysurvey emphasis'\";\n            }\n            $inactivesurveys .= \" value='{$sv['sid']}'>{$surveylstitle}</option>\\n\";\n        } elseif ($sv['expires'] != '' && $sv['expires'] < dateShift((string) date(\"Y-m-d H:i:s\"), \"Y-m-d H:i:s\", $timeadjust)) {\n            $expiredsurveys .= \"<option \";\n            if (Yii::app()->user->getId() == $sv['owner_id']) {\n                $expiredsurveys .= \" class='mysurvey emphasis'\";\n            }\n            $expiredsurveys .= \" value='{$sv['sid']}'>{$surveylstitle}</option>\\n\";\n        } else {\n            $activesurveys .= \"<option \";\n            if (Yii::app()->user->getId() == $sv['owner_id']) {\n                $activesurveys .= \" class='mysurvey emphasis'\";\n            }\n            $activesurveys .= \" value='{$sv['sid']}'>{$surveylstitle}</option>\\n\";\n        }\n    } // End Foreach\n\n    //Only show each activesurvey group if there are some\n    if ($activesurveys != '') {\n        $surveyselecter .= \"<optgroup label='\".gT(\"Active\").\"' class='activesurveyselect'>\\n\";\n        $surveyselecter .= $activesurveys.\"</optgroup>\";\n    }\n    if ($expiredsurveys != '') {\n        $surveyselecter .= \"<optgroup label='\".gT(\"Expired\").\"' class='expiredsurveyselect'>\\n\";\n        $surveyselecter .= $expiredsurveys.\"</optgroup>\";\n    }\n    if ($inactivesurveys != '') {\n        $surveyselecter .= \"<optgroup label='\".gT(\"Inactive\").\"' class='inactivesurveyselect'>\\n\";\n        $surveyselecter .= $inactivesurveys.\"</optgroup>\";\n    }\n    $surveyselecter = \"<option selected='selected' value=''>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    return $surveyselecter;\n}\n\nfunction getTemplateList()\n{\n    return Template::getTemplateList();\n}\n\n\n/**\n* getGidPrevious() returns the Gid of the group prior to the current active group\n*\n* @param integer $surveyid\n* @param integer $gid\n*\n* @return integer|string The GID of the previous group or blank string if no group\n*/\nfunction getGidPrevious($surveyid, $gid)\n{\n    $surveyid = (int) $surveyid;\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n    $qresult = QuestionGroup::model()->findAllByAttributes(array('sid' => $surveyid, 'language' => $s_lang), array('order'=>'group_order'));\n\n    $i = 0;\n    $iPrev = -1;\n    foreach ($qresult as $qrow) {\n        $qrow = $qrow->attributes;\n        if ($gid == $qrow['gid']) {$iPrev = $i - 1; }\n        $i += 1;\n    }\n\n    if ($iPrev >= 0) {$GidPrev = $qresult[$iPrev]->gid; } else {$GidPrev = \"\"; }\n    return $GidPrev;\n}\n\n\n/**\n* getGidNext() returns the Gid of the group next to the current active group\n*\n* @param integer $surveyid\n* @param integer $gid\n*\n* @return integer|string The Gid of the next group or blank string if no group\n*/\nfunction getGidNext($surveyid, $gid)\n{\n    $surveyid = (int) $surveyid;\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n\n    $qresult = QuestionGroup::model()->findAllByAttributes(array('sid' => $surveyid, 'language' => $s_lang), array('order'=>'group_order'));\n\n    $i = 0;\n    $iNext = 0;\n\n    foreach ($qresult as $qrow) {\n        $qrow = $qrow->attributes;\n        if ($gid == $qrow['gid']) {\n            $iNext = $i + 1;\n        }\n        $i += 1;\n    }\n\n    if ($iNext < count($qresult)) {\n        $GidNext = $qresult[$iNext]->gid;\n    } else {\n        $GidNext = \"\";\n    }\n    return $GidNext;\n}\n\n\n/**\n * convertGETtoPOST a function to create a post Request from get parameters\n * !!! This functions result has to be wrappen in singlequotes!\n *\n * @param String $url | The complete url with all parameters\n * @return String | The onclick action for the element\n */\nfunction convertGETtoPOST($url)\n{\n    // This function must be deprecated and replaced by $.post\n    $url = preg_replace('/&amp;/i', '&', $url);\n    $stack = explode('?', $url);\n    $calledscript = array_shift($stack);\n    $query = array_shift($stack);\n    $aqueryitems = explode('&', $query);\n    $postArray = [];\n\n    foreach ($aqueryitems as $queryitem) {\n        $stack = explode('=', $queryitem);\n        $paramname = array_shift($stack);\n        $value = array_shift($stack);\n        $postArray[$paramname] = $value;\n    }\n\n    $callscript = \"window.LS.sendPost(\\\"\".$calledscript.\"\\\",\\\"\\\",\".json_encode($postArray).\");\";\n\n    return $callscript;\n}\n\n\n/**\n* This function calculates how much space is actually used by all files uploaded\n* using the File Upload question type\n*\n* @returns integer Actual space used in MB\n*/\nfunction calculateTotalFileUploadUsage()\n{\n    global $uploaddir;\n    $sQuery = 'select sid from {{surveys}}';\n    $oResult = dbExecuteAssoc($sQuery); //checked\n    $aRows = $oResult->readAll();\n    $iTotalSize = 0.0;\n    foreach ($aRows as $aRow) {\n        $sFilesPath = $uploaddir.'/surveys/'.$aRow['sid'].'/files';\n        if (file_exists($sFilesPath)) {\n            $iTotalSize += (float) getDirectorySize($sFilesPath);\n        }\n    }\n    return (float) $iTotalSize / 1024 / 1024;\n}\n\n/**\n * @param string $directory\n * @return int\n */\nfunction getDirectorySize($directory)\n{\n    $size = 0;\n    foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($directory)) as $file) {\n        $size += $file->getSize();\n    }\n    return $size;\n}\n\n\n\n/**\n * Queries the database for the maximum sortorder of a group and returns the next higher one.\n *\n * @param integer $surveyid\n * @return int\n */\nfunction getMaxGroupOrder($surveyid)\n{\n    $queryResult = QuestionGroup::model()->find(array(\n        'condition' => 'sid = :sid',\n        'params' => array(':sid' => $surveyid),\n        'order' => 'group_order desc',\n        'limit' => '1'\n    ));\n\n    $current_max = !is_null($queryResult) ? $queryResult->group_order : \"\";\n\n    if ($current_max !== \"\") {\n        $current_max += 1;\n        return $current_max;\n    } else {\n        return 0;\n    }\n}\n\n\n/**\n* getGroupOrder($surveyid,$gid) queries the database for the sortorder of a group.\n*\n* @param mixed $surveyid\n* @param mixed $gid\n* @return mixed\n*/\nfunction getGroupOrder($surveyid, $gid)\n{\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n    $grporder_result = QuestionGroup::model()->findByAttributes(array('sid' => $surveyid, 'gid' => $gid, 'language' => $s_lang)); //Checked\n    $grporder_row = $grporder_result->attributes;\n    $group_order = $grporder_row['group_order'];\n    if ($group_order == \"\") {\n        return \"0\";\n    } else {\n        return $group_order;\n    }\n}\n\n/**\n* Queries the database for the maximum sort order of a question.\n* \n* @param integer $gid\n* @param integer|null $surveyid\n* @return integer\n*/\nfunction getMaxQuestionOrder($gid, $surveyid)\n{\n    $gid = (int) $gid;\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n    $max_sql = \"SELECT max( question_order ) AS max FROM {{questions}} WHERE gid='{$gid}' AND language='{$s_lang}'\";\n    $max_result = Yii::app()->db->createCommand($max_sql)->query(); //Checked\n    $maxrow = $max_result->read();\n    $current_max = $maxrow['max'];\n    if ($current_max == \"\") {\n        return 0;\n    } else {\n        return (int) $current_max;\n    }\n}\n\n/**\n* getQuestionClass() returns a class name for a given question type to allow custom styling for each question type.\n*\n* @param string $input containing unique character representing each question type.\n* @return string containing the class name for a given question type.\n*/\nfunction getQuestionClass($input)\n{\n    Question::getQuestionClass($input);\n};\n\n/**\n* setupColumns() defines all the html tags to be wrapped around\n* various list type answers.\n*\n* @param integer $columns - the number of columns, usually supplied by $dcols\n* @param integer $answer_count - the number of answers to a question, usually supplied by $anscount\n* @param string $wrapperclass - a global class for the wrapper\n* @param string $itemclass - a class for the item\n* @return array with all the various opening and closing tags to generate a set of columns.\n*\n* It returns an array with the following items:\n*    $wrapper['whole-start']   = Opening wrapper for the whole list\n*    $wrapper['whole-end']     = closing wrapper for the whole list\n*    $wrapper['col-devide']    = normal column devider\n*    $wrapper['col-devide-last'] = the last column devider (to allow\n*                                for different styling of the last\n*                                column\n*    $wrapper['item-start']    = opening wrapper tag for individual\n*                                option\n*    $wrapper['item-start-other'] = opening wrapper tag for other\n*                                option\n*    $wrapper['item-start-noanswer'] = opening wrapper tag for no answer\n*                                option\n*    $wrapper['item-end']      = closing wrapper tag for individual\n*                                option\n*    $wrapper['maxrows']       = maximum number of rows in each\n*                                column\n*    $wrapper['cols']          = Number of columns to be inserted\n*                                (and checked against)\n*\n*\n* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n* Columns are a problem.\n* Really there is no perfect solution to columns at the moment.\n*\n* -  Using Tables is problematic semanticly.\n* -  Using inline or float to create columns, causes the answers\n*    flows horizontally, not vertically which is not ideal visually.\n* -  Using CSS3 columns is also a problem because of browser support\n*    and also because if you have answeres split across two or more\n*    lines, and those answeres happen to fall at the bottom of a\n*    column, the answer might be split across columns as well as\n*    lines.\n* -  Using nested unordered list with the first level of <LI>s\n*    floated is the same as using tables and so is bad semantically\n*    for the same reason tables are bad.\n* -  Breaking the unordered lists into consecutive floated unordered\n*    lists is not great semantically but probably not as bad as\n*    using tables.\n*\n* Because I haven't been able to decide which option is the least\n* bad, I have handed over that responsibility to the admin who sets\n* LimeSurvey up on their server.\n*\n* There are four options:\n*    'css'   using one of the various CSS only methods for\n*            rendering columns.\n*            (Check the CSS file for your chosen template to see\n*             how columns are defined.)\n*    'ul'    using multiple floated unordered lists. (DEFAULT)\n*    'table' using conventional tables based layout.\n*     NULL   blocks the use of columns\n*\n* 'ul' is the default because it's the best possible compromise\n* between semantic markup and visual layout.\n*/\nfunction setupColumns($columns, $answer_count, $wrapperclass = \"\", $itemclass = \"\")\n{\n\n    $column_style = Yii::app()->getConfig('column_style');\n    if (!in_array($column_style, array('css', 'ul', 'table')) && !is_null($column_style)) {\n        $column_style = 'ul';\n    };\n    if (!is_null($column_style) && $columns != 1) {\n// Add a global class for all column\n        $wrapperclass .= \" colstyle-{$column_style}\";\n    }\n    if ($columns < 2) {\n        $column_style = null;\n        $columns = 1;\n    }\n\n    if (($columns > $answer_count) && $answer_count > 0) {\n        $columns = $answer_count;\n    };\n\n\n    $class_first = ' class=\"'.$wrapperclass.'\"';\n    if ($columns > 1 && !is_null($column_style)) {\n        if ($column_style == 'ul') {\n            $ul = '-ul';\n        } else {\n            $ul = '';\n        }\n        $class_first = ' class=\"'.$wrapperclass.' cols-'.$columns.$ul.' first\"';\n        $class = ' class=\"'.$wrapperclass.' cols-'.$columns.$ul.'\"';\n        $class_last_ul = ' class=\"'.$wrapperclass.' cols-'.$columns.$ul.' last\"';\n        $class_last_table = ' class=\"'.$wrapperclass.' cols-'.$columns.' last\"';\n    } else {\n        $class = ' class=\"'.$wrapperclass.'\"';\n        $class_last_ul = ' class=\"'.$wrapperclass.'\"';\n        $class_last_table = ' class=\"'.$wrapperclass.'\"';\n    };\n\n    $wrapper = array(\n    'whole-start'  => \"\\n<ul$class_first>\\n\"\n    ,'whole-end'    => \"</ul>\\n\"\n    ,'col-devide'   => ''\n    ,'col-devide-last' => ''\n    ,'item-start'   => \"\\t<li class=\\\"{$itemclass}\\\">\\n\"\n    ,'item-start-other' => \"\\t<li class=\\\"{$itemclass} other other-item\\\">\\n\"\n    ,'item-start-noanswer' => \"\\t<li class=\\\"{$itemclass} noanswer-item\\\">\\n\"\n    ,'item-end' => \"\\t</li>\\n\"\n    ,'maxrows'  => ceil($answer_count / $columns) //Always rounds up to nearest whole number\n    ,'cols'     => $columns\n    );\n\n    switch ($column_style) {\n        case 'ul':  if ($columns > 1) {\n                $wrapper['col-devide'] = \"\\n</ul>\\n\\n<ul$class>\\n\";\n                $wrapper['col-devide-last'] = \"\\n</ul>\\n\\n<ul$class_last_ul>\\n\";\n            }\n            break;\n\n        case 'table':   $table_cols = '';\n            for ($cols = $columns; $cols > 0; --$cols) {\n                switch ($cols) {\n                    case $columns:  $table_cols .= \"\\t<col$class_first />\\n\";\n                        break;\n                    case 1:     $table_cols .= \"\\t<col$class_last_table />\\n\";\n                        break;\n                    default:    $table_cols .= \"\\t<col$class />\\n\";\n                };\n            };\n\n            if ($columns > 1) {\n                $wrapper['col-devide'] = \"\\t</ul>\\n</td>\\n\\n<td>\\n\\t<ul>\\n\";\n                $wrapper['col-devide-last'] = \"\\t</ul>\\n</td>\\n\\n<td class=\\\"last\\\">\\n\\t<ul>\\n\";\n            };\n            $wrapper['whole-start'] = \"\\n<table$class>\\n$table_cols\\n\\t<tbody>\\n<tr>\\n<td>\\n\\t<ul>\\n\";\n            $wrapper['whole-end']   = \"\\t</ul>\\n</td>\\n</tr>\\n\\t</tbody>\\n</table>\\n\";\n            $wrapper['item-start']  = \"<li class=\\\"{$itemclass}\\\">\\n\";\n            $wrapper['item-end']    = \"</li class=\\\"{$itemclass}\\\">\\n\";\n    };\n\n    return $wrapper;\n};\n\nfunction alternation($alternate = '', $type = 'col')\n{\n    /**\n     * alternation() Returns a class identifyer for alternating between\n     * two options. Used to style alternate elements differently. creates\n     * or alternates between the odd string and the even string used in\n     * as column and row classes for array type questions.\n     *\n     * @param string $alternate = '' (empty) (default) , 'array2' ,  'array1' , 'odd' , 'even'\n     * @param string  $type = 'col' (default) or 'row'\n     *\n     * @return string representing either the first alternation or the opposite alternation to the one supplied..\n     */\n    /*\n    // The following allows type to be left blank for row in subsequent\n    // function calls.\n    // It has been left out because 'row' must be defined the first time\n    // alternation() is called. Since it is only ever written once for each\n    // while statement within a function, 'row' is always defined.\n    if(!empty($alternate) && $type != 'row')\n    {   if($alternate == ('array2' || 'array1'))\n    {\n    $type = 'row';\n    };\n    };\n    // It has been left in case it becomes useful but probably should be\n    // removed.\n    */\n    if ($type == 'row') {\n// Row is sub question OR Y Axis subquestion : it must be column for array by column\n        $odd  = 'ls-odd';\n        $even = 'ls-even';\n    } else {\n// cols is answers part OR X axis subquestion : it must the row in array by column\n        $odd  = 'ls-col-odd';\n        $even = 'ls-col-even';\n    };\n    if ($alternate == $odd) {\n        $alternate = $even;\n    } else {\n        $alternate = $odd;\n    };\n    return $alternate;\n}\n\n\n/**\n* longestString() returns the length of the longest string past to it.\n* @peram string $new_string\n* @peram integer $longest_length length of the (previously) longest string passed to it.\n* @param integer $longest_length\n* @return integer representing the length of the longest string passed (updated if $new_string was longer than $longest_length)\n*\n* usage should look like this: $longest_length = longestString( $new_string , $longest_length );\n*\n*/\nfunction longestString($new_string, $longest_length)\n{\n    if ($longest_length < strlen(trim(strip_tags($new_string)))) {\n        $longest_length = strlen(trim(strip_tags($new_string)));\n    };\n    return $longest_length;\n};\n\n\n\n\n/**\n* getGroupList() queries the database for a list of all groups matching the current survey sid\n*\n*\n* @param string $gid - the currently selected gid/group\n* @param integer $surveyid\n*\n* @return string string is returned containing <option></option> formatted list of groups to current survey\n*/\nfunction getGroupList($gid, $surveyid)\n{\n\n    $groupselecter = \"\";\n    $gid = sanitize_int($gid);\n    $surveyid = sanitize_int($surveyid);\n    if (!$surveyid) {$surveyid = returnGlobal('sid', true); }\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n\n    $gidquery = \"SELECT gid, group_name FROM {{groups}} WHERE sid='{$surveyid}' AND  language='{$s_lang}' ORDER BY group_order\";\n    $gidresult = Yii::app()->db->createCommand($gidquery)->query(); //Checked\n    foreach ($gidresult->readAll() as $gv) {\n        $groupselecter .= \"<option\";\n        if ($gv['gid'] == $gid) {$groupselecter .= \" selected='selected'\"; $gvexist = 1; }\n        $groupselecter .= \" value='\".Yii::app()->getConfig('scriptname').\"?sid=$surveyid&amp;gid=\".$gv['gid'].\"'>\".htmlspecialchars($gv['group_name']).\"</option>\\n\";\n    }\n    if ($groupselecter) {\n        if (!isset($gvexist)) {$groupselecter = \"<option selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$groupselecter; } else {$groupselecter .= \"<option value='\".Yii::app()->getConfig('scriptname').\"?sid=$surveyid&amp;gid='>\".gT(\"None\").\"</option>\\n\"; }\n    }\n    return $groupselecter;\n}\n\n\n//FIXME rename and/or document this\nfunction getGroupList3($gid, $surveyid)\n{\n    //\n    $gid = sanitize_int($gid);\n    $surveyid = sanitize_int($surveyid);\n\n    if (!$surveyid) {$surveyid = returnGlobal('sid', true); }\n    $groupselecter = \"\";\n    $s_lang = Survey::model()->findByPk($surveyid)->language;\n\n\n    //$gidquery = \"SELECT gid, group_name FROM \".db_table_name('groups').\" WHERE sid=$surveyid AND language='{$s_lang}' ORDER BY group_order\";\n\n    $gidresult = QuestionGroup::model()->findAllByAttributes(array('sid' => $surveyid, 'language' => $s_lang), array('order'=>'group_order'));\n\n    foreach ($gidresult as $gv) {\n        $gv = $gv->attributes;\n        $groupselecter .= \"<option\";\n        if ($gv['gid'] == $gid) {$groupselecter .= \" selected='selected'\"; }\n        $groupselecter .= \" value='\".$gv['gid'].\"'>\".htmlspecialchars($gv['group_name']).\" (ID:\".$gv['gid'].\")</option>\\n\";\n    }\n\n\n    return $groupselecter;\n}\n\n/**\n * put your comment there...\n *\n * @param mixed $gid\n * @param mixed $language\n * @return string\n */\nfunction getGroupListLang($gid, $language, $surveyid)\n{\n    $groupselecter = \"\";\n    if (!$surveyid) {$surveyid = returnGlobal('sid', true); }\n\n    $gidresult = QuestionGroup::model()->findAll(array('condition'=>'sid=:surveyid AND language=:language',\n    'order'=>'group_order',\n    'params'=>array(':surveyid'=>$surveyid, ':language'=>$language))); //Checked)\n    foreach ($gidresult as $gv) {\n        $gv = $gv->attributes;\n        $groupselecter .= \"<option\";\n        if ($gv['gid'] == $gid) {$groupselecter .= \" selected='selected'\"; $gvexist = 1; }\n        $link = Yii::app()->getController()->createUrl(\"/admin/questiongroups/sa/view/surveyid/\".$surveyid.\"/gid/\".$gv['gid']);\n        $groupselecter .= \" value='{$link}'>\";\n        if (strip_tags($gv['group_name'])) {\n            $groupselecter .= htmlspecialchars(strip_tags($gv['group_name']));\n        } else {\n            $groupselecter .= htmlspecialchars($gv['group_name']);\n        }\n        $groupselecter .= \"</option>\\n\";\n    }\n    if ($groupselecter) {\n        $link = Yii::app()->getController()->createUrl(\"/admin/survey/sa/view/surveyid/\".$surveyid);\n        if (!isset($gvexist)) {$groupselecter = \"<option selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$groupselecter; } else {$groupselecter .= \"<option value='{$link}'>\".gT(\"None\").\"</option>\\n\"; }\n    }\n    return $groupselecter;\n}\n\n\nfunction getUserList($outputformat = 'fullinfoarray')\n{\n    if (!empty(Yii::app()->session['loginID'])) {\n        $myuid = sanitize_int(Yii::app()->session['loginID']);\n    }\n    $usercontrolSameGroupPolicy = Yii::app()->getConfig('usercontrolSameGroupPolicy');\n    if (!Permission::model()->hasGlobalPermission('superadmin', 'read') && isset($usercontrolSameGroupPolicy) &&\n    $usercontrolSameGroupPolicy == true) {\n        if (isset($myuid)) {\n            $sDatabaseType = Yii::app()->db->getDriverName();\n            if ($sDatabaseType == 'mssql' || $sDatabaseType == \"sqlsrv\" || $sDatabaseType == \"dblib\") {\n                $sSelectFields = 'users_name,uid,email,full_name,parent_id,CAST(password as varchar) as password';\n            } else {\n                $sSelectFields = 'users_name,uid,email,full_name,parent_id,password';\n            }\n\n            // List users from same group as me + all my childs\n            // a subselect is used here because MSSQL does not like to group by text\n            // also Postgres does like this one better\n            $uquery = \" SELECT {$sSelectFields} from {{users}} where uid in (\n                SELECT uid from {{user_in_groups}} where ugid in (\n                    SELECT ugid from {{user_in_groups}} where uid={$myuid}\n                    )\n                )\n            UNION\n            SELECT {$sSelectFields} from {{users}} v where v.parent_id={$myuid}\n            UNION\n            SELECT {$sSelectFields} from {{users}} v where uid={$myuid}\";\n\n        } else {\n            return array(); // Or die maybe\n        }\n\n    } else {\n        $uquery = \"SELECT * FROM {{users}} ORDER BY uid\";\n    }\n\n    $uresult = Yii::app()->db->createCommand($uquery)->query()->readAll(); //Checked\n\n    if (count($uresult) == 0 && !empty($myuid)) {\n//user is not in a group and usercontrolSameGroupPolicy is activated - at least show his own userinfo\n        $uquery = \"SELECT u.* FROM {{users}} AS u WHERE u.uid=\".$myuid;\n        $uresult = Yii::app()->db->createCommand($uquery)->query()->readAll(); //Checked\n    }\n\n    $userlist = array();\n    $userlist[0] = \"Reserved for logged in user\";\n    foreach ($uresult as $srow) {\n        if ($outputformat != 'onlyuidarray') {\n            if ($srow['uid'] != Yii::app()->session['loginID']) {\n                $userlist[] = array(\"user\"=>$srow['users_name'], \"uid\"=>$srow['uid'], \"email\"=>$srow['email'], \"password\"=>$srow['password'], \"full_name\"=>$srow['full_name'], \"parent_id\"=>$srow['parent_id']);\n            } else {\n                $userlist[0] = array(\"user\"=>$srow['users_name'], \"uid\"=>$srow['uid'], \"email\"=>$srow['email'], \"password\"=>$srow['password'], \"full_name\"=>$srow['full_name'], \"parent_id\"=>$srow['parent_id']);\n            }\n        } else {\n            if ($srow['uid'] != Yii::app()->session['loginID']) {\n                $userlist[] = $srow['uid'];\n            } else {\n                $userlist[0] = $srow['uid'];\n            }\n        }\n\n    }\n    return $userlist;\n}\n\n\n/**\n* Gets all survey infos in one big array including the language specific settings\n*\n* @param integer $surveyid  The survey ID\n* @param string $languagecode The language code - if not given the base language of the particular survey is used\n* @return array|bool Returns array with survey info or false, if survey does not exist\n*/\nfunction getSurveyInfo($surveyid, $languagecode = '')\n{\n    static $staticSurveyInfo = array(); // Use some static\n    $surveyid = sanitize_int($surveyid);\n    $languagecode = sanitize_languagecode($languagecode);\n    $thissurvey = false;\n    $oSurvey = Survey::model()->findByPk($surveyid);\n    // Do job only if this survey exist\n    if (!$oSurvey) {\n        return false;\n    }\n    // if no language code is set then get the base language one\n    if ((!isset($languagecode) || $languagecode == '')) {\n        $languagecode = Survey::model()->findByPk($surveyid)->language;\n    }\n\n    if (isset($staticSurveyInfo[$surveyid][$languagecode])) {\n        $thissurvey = $staticSurveyInfo[$surveyid][$languagecode];\n    } else {\n        $result = SurveyLanguageSetting::model()->with('survey')->findByPk(array('surveyls_survey_id' => $surveyid, 'surveyls_language' => $languagecode));\n        if (is_null($result)) {\n            // When additional language was added, but not saved it does not exists\n            // We should revert to the base language then\n            $languagecode = Survey::model()->findByPk($surveyid)->language;\n            $result = SurveyLanguageSetting::model()->with('survey')->findByPk(array('surveyls_survey_id' => $surveyid, 'surveyls_language' => $languagecode));\n        }\n        if ($result) {\n            $thissurvey = array_merge($result->survey->attributes, $result->attributes);\n            $thissurvey['name'] = $thissurvey['surveyls_title'];\n            $thissurvey['description'] = $thissurvey['surveyls_description'];\n            $thissurvey['welcome'] = $thissurvey['surveyls_welcometext'];\n            $thissurvey['datasecurity_notice_label'] = $thissurvey['surveyls_policy_notice_label'];\n            $thissurvey['datasecurity_error'] = $thissurvey['surveyls_policy_error'];\n            $thissurvey['datasecurity_notice'] = $thissurvey['surveyls_policy_notice'];\n            $thissurvey['templatedir'] = $thissurvey['template'];\n            $thissurvey['adminname'] = $thissurvey['admin'];\n            $thissurvey['tablename'] = $oSurvey->responsesTableName;\n            $thissurvey['urldescrip'] = $thissurvey['surveyls_urldescription'];\n            $thissurvey['url'] = $thissurvey['surveyls_url'];\n            $thissurvey['expiry'] = $thissurvey['expires'];\n            $thissurvey['email_invite_subj'] = $thissurvey['surveyls_email_invite_subj'];\n            $thissurvey['email_invite'] = $thissurvey['surveyls_email_invite'];\n            $thissurvey['email_remind_subj'] = $thissurvey['surveyls_email_remind_subj'];\n            $thissurvey['email_remind'] = $thissurvey['surveyls_email_remind'];\n            $thissurvey['email_confirm_subj'] = $thissurvey['surveyls_email_confirm_subj'];\n            $thissurvey['email_confirm'] = $thissurvey['surveyls_email_confirm'];\n            $thissurvey['email_register_subj'] = $thissurvey['surveyls_email_register_subj'];\n            $thissurvey['email_register'] = $thissurvey['surveyls_email_register'];\n            $thissurvey['attributedescriptions'] = $result->survey->tokenAttributes;\n            $thissurvey['attributecaptions'] = $result->attributeCaptions;\n            if (!isset($thissurvey['adminname'])) {$thissurvey['adminname'] = Yii::app()->getConfig('siteadminemail'); }\n            if (!isset($thissurvey['adminemail'])) {$thissurvey['adminemail'] = Yii::app()->getConfig('siteadminname'); }\n            if (!isset($thissurvey['urldescrip']) || $thissurvey['urldescrip'] == '') {$thissurvey['urldescrip'] = $thissurvey['surveyls_url']; }\n\n            $thissurvey['owner_username'] = $result->survey->owner->users_name;\n\n            $staticSurveyInfo[$surveyid][$languagecode] = $thissurvey;\n        }\n\n    }\n    $thissurvey['oSurvey'] = $oSurvey;\n    return $thissurvey;\n}\n\n/**\n* Returns the default email template texts as array\n*\n* @param mixed $sLanguage Required language translationb object\n* @param string $mode Escape mode for the translation function\n* @return array\n * // TODO move to template model\n*/\nfunction templateDefaultTexts($sLanguage, $mode = 'html', $sNewlines = 'text')\n{\n    \n    $aDefaultTexts = LsDefaultDataSets::getTemplateDefaultTexts($mode, $sLanguage);\n    \n    if ($sNewlines == 'html') {\n        $aDefaultTexts = array_map('nl2br', $aDefaultTexts);\n    }\n\n    return $aDefaultTexts;\n}\n\n/**\n* Compares two elements from an array (passed by the usort function)\n* and returns -1, 0 or 1 depending on the result of the comparison of\n* the sort order of the group_order and question_order field\n*\n* @param mixed $a\n* @param mixed $b\n* @return int\n*/\nfunction groupOrderThenQuestionOrder($a, $b)\n{\n    if (isset($a['group_order']) && isset($b['group_order'])) {\n        $GroupResult = strnatcasecmp($a['group_order'], $b['group_order']);\n    } else {\n        $GroupResult = \"\";\n    }\n    if ($GroupResult == 0) {\n        $TitleResult = strnatcasecmp($a[\"question_order\"], $b[\"question_order\"]);\n        return $TitleResult;\n    }\n    return $GroupResult;\n}\n\n\n//FIXME insert UestionGroup model to here\n/**\n * @param integer $sid\n * @param integer $gid\n * @param integer $shiftvalue\n */\nfunction shiftOrderQuestions($sid, $gid, $shiftvalue) //Function shifts the sortorder for questions\n{\n    $sid = (int) $sid;\n    $gid = (int) $gid;\n    $shiftvalue = (int) $shiftvalue;\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n\n    Question::model()->updateQuestionOrder($gid, $baselang, $shiftvalue);\n}\n\nfunction fixSortOrderGroups($surveyid) //Function rewrites the sortorder for groups\n{\n    $baselang = Survey::model()->findByPk($surveyid)->language;\n    QuestionGroup::model()->updateGroupOrder($surveyid, $baselang);\n}\n\n/**\n * @param integer $iSurveyID\n * @param integer $qid\n * @param integer $newgid\n */\nfunction fixMovedQuestionConditions($qid, $oldgid, $newgid, $iSurveyID = null) //Function rewrites the cfieldname for a question after group change\n{\n    if (!isset($iSurveyID)) {\n            $iSurveyID = Yii::app()->getConfig('sid');\n    }\n    $qid = (int) $qid;\n    $oldgid = (int) $oldgid;\n    $newgid = (int) $newgid;\n    Condition::model()->updateCFieldName($iSurveyID, $qid, $oldgid, $newgid);\n    // TMSW Condition->Relevance:  Call LEM->ConvertConditionsToRelevance() when done\n}\n\n\n/**\n * This function returns POST/REQUEST vars, for some vars like SID and others they are also sanitized\n * TODO: extends Yii:getParam\n *\n * @param string $stringname\n * @param boolean $bRestrictToString\n * @return array|bool|mixed|int|null\n */\nfunction returnGlobal($stringname, $bRestrictToString = false)\n{\n    $urlParam = Yii::app()->request->getParam($stringname);\n    $aCookies = Yii::app()->request->getCookies();\n    if (is_null($urlParam) && $stringname != 'sid') {\n        if (isset($aCookies[$stringname])) {\n            $urlParam = $aCookies[$stringname];\n        }\n    }\n    $bUrlParamIsArray = is_array($urlParam); // Needed to array map or if $bRestrictToString\n    if (!is_null($urlParam) && $stringname != '' && (!$bUrlParamIsArray || !$bRestrictToString)) {\n        if ($stringname == 'sid' || $stringname == \"gid\" || $stringname == \"oldqid\" ||\n        $stringname == \"qid\" || $stringname == \"tid\" ||\n        $stringname == \"lid\" || $stringname == \"ugid\" ||\n        $stringname == \"thisstep\" || $stringname == \"scenario\" ||\n        $stringname == \"cqid\" || $stringname == \"cid\" ||\n        $stringname == \"qaid\" || $stringname == \"scid\") {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_int\", $urlParam);\n            } else {\n                return sanitize_int($urlParam);\n            }\n        } elseif ($stringname == \"lang\" || $stringname == \"adminlang\") {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_languagecode\", $urlParam);\n            } else {\n                return sanitize_languagecode($urlParam);\n            }\n        } elseif ($stringname == \"htmleditormode\" ||\n        $stringname == \"subaction\" ||\n        $stringname == \"questionselectormode\" ||\n        $stringname == \"templateeditormode\"\n        ) {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_paranoid_string\", $urlParam);\n            } else {\n                return sanitize_paranoid_string($urlParam);\n            }\n        } elseif ($stringname == \"cquestions\") {\n            if ($bUrlParamIsArray) {\n                return array_map(\"sanitize_cquestions\", $urlParam);\n            } else {\n                return sanitize_cquestions($urlParam);\n            }\n        }\n        return $urlParam;\n    } else {\n        return null;\n    }\n}\n\n\nfunction sendCacheHeaders()\n{\n    if (!headers_sent()) {\n        if (Yii::app()->getConfig('x_frame_options', 'allow') == 'sameorigin') {\n            header('X-Frame-Options: SAMEORIGIN');\n        }\n        header('P3P:CP=\"IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT\"'); // this line lets IE7 run LimeSurvey in an iframe\n        header(\"Expires: Mon, 26 Jul 1997 05:00:00 GMT\"); // Date in the past\n        header(\"Last-Modified: \".gmdate(\"D, d M Y H:i:s\").\" GMT\"); // always modified\n        header(\"Cache-Control: no-store, no-cache, must-revalidate\"); // HTTP/1.1\n        header(\"Cache-Control: post-check=0, pre-check=0\", false);\n        header(\"Pragma: no-cache\");\n        header('Content-Type: text/html; charset=utf-8');\n    }\n}\n\n/**\n* @param integer $iSurveyID The Survey ID\n* @param string $sFieldCode Field code of the particular field\n* @param string $sValue The stored response value\n* @param string $sLanguage Initialized limesurvey_lang object for the resulting response data\n* @return string\n*/\nfunction getExtendedAnswer($iSurveyID, $sFieldCode, $sValue, $sLanguage)\n{\n\n    if ($sValue == null || $sValue == '') {\n        return '';\n    }\n    $survey = Survey::model()->findByPk($iSurveyID);\n    //Fieldcode used to determine question, $sValue used to match against answer code\n    //Returns NULL if question type does not suit\n    if (strpos($sFieldCode, \"{$iSurveyID}X\") === 0) {\n//Only check if it looks like a real fieldcode\n        $fieldmap = createFieldMap($survey, 'short', false, false, $sLanguage);\n        if (isset($fieldmap[$sFieldCode])) {\n            $fields = $fieldmap[$sFieldCode];\n        } else {\n            return '';\n        }\n\n        // If it is a comment field there is nothing to convert here\n        if ($fields['aid'] == 'comment') {\n            return $sValue;\n        }\n\n        //Find out the question type\n        $this_type = $fields['type'];\n        switch ($this_type) {\n            case 'D':\n                if (trim($sValue) != '') {\n                    $qidattributes = QuestionAttribute::model()->getQuestionAttributes($fields['qid']);\n                    $dateformatdetails = getDateFormatDataForQID($qidattributes, $iSurveyID);\n                    $sValue = convertDateTimeFormat($sValue, \"Y-m-d H:i:s\", $dateformatdetails['phpdate']);\n                }\n                break;\n            case 'K':\n            case 'N':\n                if (trim($sValue) != '') {\n                    if (strpos($sValue, \".\") !== false) {\n                        $sValue = rtrim(rtrim($sValue, \"0\"), \".\");\n                    }\n                }\n                break;\n            case \"L\":\n            case \"!\":\n            case \"O\":\n            case \"^\":\n            case \"I\":\n            case \"R\":\n                $result = Answer::model()->getAnswerFromCode($fields['qid'], $sValue, $sLanguage);\n                foreach ($result as $row) {\n                    $this_answer = $row['answer'];\n                } // while\n                if ($sValue == \"-oth-\") {\n                    $this_answer = gT(\"Other\", null, $sLanguage);\n                }\n                break;\n            case \"M\":\n            case \"J\":\n            case \"P\":\n            switch ($sValue) {\n                case \"Y\": $this_answer = gT(\"Yes\", null, $sLanguage); break;\n            }\n            break;\n            case \"Y\":\n            switch ($sValue) {\n                case \"Y\": $this_answer = gT(\"Yes\", null, $sLanguage); break;\n                case \"N\": $this_answer = gT(\"No\", null, $sLanguage); break;\n                default: $this_answer = gT(\"No answer\", null, $sLanguage);\n            }\n            break;\n            case \"G\":\n            switch ($sValue) {\n                case \"M\": $this_answer = gT(\"Male\", null, $sLanguage); break;\n                case \"F\": $this_answer = gT(\"Female\", null, $sLanguage); break;\n                default: $this_answer = gT(\"No answer\", null, $sLanguage);\n            }\n            break;\n            case \"C\":\n            switch ($sValue) {\n                case \"Y\": $this_answer = gT(\"Yes\", null, $sLanguage); break;\n                case \"N\": $this_answer = gT(\"No\", null, $sLanguage); break;\n                case \"U\": $this_answer = gT(\"Uncertain\", null, $sLanguage); break;\n            }\n            break;\n            case \"E\":\n            switch ($sValue) {\n                case \"I\": $this_answer = gT(\"Increase\", null, $sLanguage); break;\n                case \"D\": $this_answer = gT(\"Decrease\", null, $sLanguage); break;\n                case \"S\": $this_answer = gT(\"Same\", null, $sLanguage); break;\n            }\n            break;\n            case \"F\":\n            case \"H\":\n            case \"1\":\n                if (isset($fields['scale_id'])) {\n                    $iScaleID = $fields['scale_id'];\n                } else {\n                    $iScaleID = 0;\n                }\n                $result = Answer::model()->getAnswerFromCode($fields['qid'], $sValue, $sLanguage, $iScaleID);\n                foreach ($result as $row) {\n                    $this_answer = $row['answer'];\n                } // while\n                if ($sValue == \"-oth-\") {\n                    $this_answer = gT(\"Other\", null, $sLanguage);\n                }\n                break;\n            case \"|\": //File upload\n                if (substr($sFieldCode, -9) != 'filecount') {\n                    //Show the filename, size, title and comment -- no link!\n                    $files = json_decode($sValue, true);\n                    $sValue = '';\n                    if (is_array($files)) {\n                        foreach ($files as $file) {\n                            if (!isset($file['title'])) {\n                                $file['title'] = '';\n                            }\n                            if (!isset($file['comment'])) {\n                                $file['comment'] = '';\n                            }\n                            $sValue .= rawurldecode($file['name']).\n                            ' ('.round($file['size']).'KB) '.\n                            strip_tags($file['title']);\n                            if (trim(strip_tags($file['comment'])) != \"\") {\n                                $sValue .= ' - '.strip_tags($file['comment']);\n                            }\n\n                        }\n                    }\n                }\n                break;\n            default:\n                ;\n        } // switch\n    }\n    switch ($sFieldCode) {\n        case 'submitdate':\n        case 'startdate':\n        case 'datestamp':\n            if (trim($sValue) != '') {\n                $dateformatdetails = getDateFormatDataForQID(null, $iSurveyID);\n                $sValue = convertDateTimeFormat($sValue, \"Y-m-d H:i:s\", $dateformatdetails['phpdate'].' H:i:s');\n            }\n            break;\n    }\n    if (isset($this_answer)) {\n        return $this_answer.\" [$sValue]\";\n    } else {\n        return $sValue;\n    }\n}\n\n/**\n* Validate an email address - also supports IDN email addresses\n* @returns True/false for valid/invalid\n*\n* @param mixed $sEmailAddress  Email address to check\n*/\nfunction validateEmailAddress($sEmailAddress)\n{\n    require_once(APPPATH.'third_party/idna-convert/idna_convert.class.php');\n    $oIdnConverter = new idna_convert();\n    $sEmailAddress = $oIdnConverter->encode($sEmailAddress);\n    $bResult = filter_var($sEmailAddress, FILTER_VALIDATE_EMAIL);\n    if ($bResult !== false) {\n        return true;\n    }\n    return false;\n}\n\n/**\n* Validate an list of email addresses - either as array or as semicolon-limited text\n* @return string List with valid email addresses - invalid email addresses are filtered - false if none of the email addresses are valid\n*\n* @param string $aEmailAddressList  Email address to check\n* @returns array\n*/\nfunction validateEmailAddresses($aEmailAddressList)\n{\n    $aOutList = [];\n    if (!is_array($aEmailAddressList)) {\n        $aEmailAddressList = explode(';', $aEmailAddressList);\n    }\n\n    foreach ($aEmailAddressList as $sEmailAddress) {\n        $sEmailAddress = trim($sEmailAddress);\n        if (validateEmailAddress($sEmailAddress)) {\n            $aOutList[] = $sEmailAddress;\n        }\n    }\n    return $aOutList;\n}\n\n/**\n * This functions generates a a summary containing the SGQA for questions of a survey, enriched with options per question\n * It can be used for the generation of statistics. Derived from Statistics_userController\n * @param int $iSurveyID Id of the Survey in question\n * @param array $aFilters an array which is the result of a query in Questions model\n * @param string $sLanguage\n * @return array The summary\n */\nfunction createCompleteSGQA($iSurveyID, $aFilters, $sLanguage)\n{\n    $allfields = [];\n    foreach ($aFilters as $flt) {\n        Yii::app()->loadHelper(\"surveytranslator\");\n        $myfield = \"{$iSurveyID}X{$flt['gid']}X{$flt['qid']}\";\n        $oSurvey = Survey::model()->findByPk($iSurveyID);\n        $aAdditionalLanguages = array_filter(explode(\" \", $oSurvey->additional_languages));\n        if (is_null($sLanguage) || !in_array($sLanguage, $aAdditionalLanguages)) {\n            $sLanguage = $oSurvey->language;\n        }\n        switch ($flt['type']) {\n            case \"K\": // Multiple Numerical\n            case \"Q\": // Multiple Short Text\n                //get answers\n                $result = Question::model()->getQuestionsForStatistics('title as code, question as answer', \"parent_qid=$flt[qid] AND language = '{$sLanguage}'\", 'question_order');\n\n                //go through all the (multiple) answers\n                foreach ($result as $row) {\n                    $myfield2 = $flt['type'].$myfield.reset($row);\n                    $allfields[] = $myfield2;\n                }\n                break;\n            case \"A\": // ARRAY OF 5 POINT CHOICE QUESTIONS\n            case \"B\": // ARRAY OF 10 POINT CHOICE QUESTIONS\n            case \"C\": // ARRAY OF YES\\No\\gT(\"Uncertain\") QUESTIONS\n            case \"E\": // ARRAY OF Increase/Same/Decrease QUESTIONS\n            case \"F\": // FlEXIBLE ARRAY\n            case \"H\": // ARRAY (By Column)\n                //get answers\n                $result = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}'\", 'question_order');\n\n                //go through all the (multiple) answers\n                foreach ($result as $row) {\n                    $myfield2 = $myfield.reset($row);\n                    $allfields[] = $myfield2;\n                }\n                break;\n                // all \"free text\" types (T, U, S)  get the same prefix (\"T\")\n            case \"T\": // Long free text\n            case \"U\": // Huge free text\n            case \"S\": // Short free text\n                $myfield = \"T$myfield\";\n                $allfields[] = $myfield;\n                break;\n            case \";\":  //ARRAY (Multi Flex) (Text)\n            case \":\":  //ARRAY (Multi Flex) (Numbers)\n                $result = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}' AND scale_id = 0\", 'question_order');\n\n                foreach ($result as $row) {\n                    $fresult = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}' AND scale_id = 1\", 'question_order');\n                    foreach ($fresult as $frow) {\n                        $myfield2 = $myfield.reset($row).\"_\".$frow['title'];\n                        $allfields[] = $myfield2;\n                    }\n                }\n                break;\n            case \"R\": //RANKING\n                //get some answers\n                $result = Answer::model()->getQuestionsForStatistics('code, answer', \"qid=$flt[qid] AND language = '{$sLanguage}'\", 'sortorder, answer');\n                //get number of answers\n                //loop through all answers. if there are 3 items to rate there will be 3 statistics\n                $i = 0;\n                foreach ($result as $row) {\n                    $i++;\n                    $myfield2 = \"R\".$myfield.$i.\"-\".strlen($i);\n                    $allfields[] = $myfield2;\n                }\n\n                break;\n                //Boilerplate questions are only used to put some text between other questions -> no analysis needed\n            case \"X\":  //This is a boilerplate question and it has no business in this script\n                break;\n            case \"1\": // MULTI SCALE\n                //get answers\n                $result = Question::model()->getQuestionsForStatistics('title, question', \"parent_qid=$flt[qid] AND language = '{$sLanguage}'\", 'question_order');\n                //loop through answers\n                foreach ($result as $row) {\n                    //----------------- LABEL 1 ---------------------\n                    $myfield2 = $myfield.reset($row).\"#0\";\n                    $allfields[] = $myfield2;\n                    //----------------- LABEL 2 ---------------------\n                    $myfield2 = $myfield.reset($row).\"#1\";\n                    $allfields[] = $myfield2;\n                }   //end WHILE -> loop through all answers\n                break;\n\n            case \"P\":  //P - Multiple choice with comments\n            case \"M\":  //M - Multiple choice\n            case \"N\":  //N - Numerical input\n            case \"D\":  //D - Date\n                $myfield2 = $flt['type'].$myfield;\n                $allfields[] = $myfield2;\n                break;\n            default:   //Default settings\n                $allfields[] = $myfield;\n                break;\n\n        } //end switch\n    }\n\n    return $allfields;\n\n}\n\n\n\n\n\n/**\n* This function generates an array containing the fieldcode, and matching data in the same order as the activate script\n*\n* @param Survey $survey\n* @param string $style 'short' (default) or 'full' - full creates extra information like default values\n* @param boolean $force_refresh - Forces to really refresh the array, not just take the session copy\n* @param bool|int $questionid Limit to a certain qid only (for question preview) - default is false\n* @param string $sLanguage The language to use\n* @param array $aDuplicateQIDs\n* @return array\n*/\nfunction createFieldMap($survey, $style = 'short', $force_refresh = false, $questionid = false, $sLanguage = '', &$aDuplicateQIDs = array())\n{\n\n    $sLanguage = sanitize_languagecode($sLanguage);\n    $surveyid = $survey->sid;\n    //checks to see if fieldmap has already been built for this page.\n    if (isset(Yii::app()->session['fieldmap-'.$surveyid.$sLanguage]) && !$force_refresh && $questionid === false) {\n        return Yii::app()->session['fieldmap-'.$surveyid.$sLanguage];\n    }\n    /* Check if $sLanguage is a survey valid language (else $fieldmap is empty) */\n    if ($sLanguage == '' || !in_array($sLanguage, $survey->allLanguages)) {\n        $sLanguage = $survey->language;\n    }\n    $fieldmap = [];\n    $fieldmap[\"id\"] = array(\"fieldname\"=>\"id\", 'sid'=>$surveyid, 'type'=>\"id\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"id\"]['title'] = \"\";\n        $fieldmap[\"id\"]['question'] = gT(\"Response ID\");\n        $fieldmap[\"id\"]['group_name'] = \"\";\n    }\n\n    $fieldmap[\"submitdate\"] = array(\"fieldname\"=>\"submitdate\", 'type'=>\"submitdate\", 'sid'=>$surveyid, \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"submitdate\"]['title'] = \"\";\n        $fieldmap[\"submitdate\"]['question'] = gT(\"Date submitted\");\n        $fieldmap[\"submitdate\"]['group_name'] = \"\";\n    }\n\n    $fieldmap[\"lastpage\"] = array(\"fieldname\"=>\"lastpage\", 'sid'=>$surveyid, 'type'=>\"lastpage\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"lastpage\"]['title'] = \"\";\n        $fieldmap[\"lastpage\"]['question'] = gT(\"Last page\");\n        $fieldmap[\"lastpage\"]['group_name'] = \"\";\n    }\n\n    $fieldmap[\"startlanguage\"] = array(\"fieldname\"=>\"startlanguage\", 'sid'=>$surveyid, 'type'=>\"startlanguage\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n    if ($style == \"full\") {\n        $fieldmap[\"startlanguage\"]['title'] = \"\";\n        $fieldmap[\"startlanguage\"]['question'] = gT(\"Start language\");\n        $fieldmap[\"startlanguage\"]['group_name'] = \"\";\n    }\n\n    $fieldmap['seed'] = array('fieldname' => 'seed', 'sid' => $surveyid, 'type' => 'seed', 'gid' => '', 'qid' => '', 'aid' => '');\n    if ($style == 'full') {\n        $fieldmap[\"seed\"]['title'] = \"\";\n        $fieldmap[\"seed\"]['question'] = gT(\"Seed\");\n        $fieldmap[\"seed\"]['group_name'] = \"\";\n    }\n\n    //Check for any additional fields for this survey and create necessary fields (token and datestamp and ipaddr)\n    $prow = $survey->getAttributes(); //Checked\n\n    if ($prow['anonymized'] == \"N\" && $survey->hasTokensTable) {\n        $fieldmap[\"token\"] = array(\"fieldname\"=>\"token\", 'sid'=>$surveyid, 'type'=>\"token\", \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"token\"]['title'] = \"\";\n            $fieldmap[\"token\"]['question'] = gT(\"Token\");\n            $fieldmap[\"token\"]['group_name'] = \"\";\n        }\n    }\n    if ($prow['datestamp'] == \"Y\") {\n        $fieldmap[\"startdate\"] = array(\"fieldname\"=>\"startdate\",\n        'type'=>\"startdate\",\n        'sid'=>$surveyid,\n        \"gid\"=>\"\",\n        \"qid\"=>\"\",\n        \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"startdate\"]['title'] = \"\";\n            $fieldmap[\"startdate\"]['question'] = gT(\"Date started\");\n            $fieldmap[\"startdate\"]['group_name'] = \"\";\n        }\n\n        $fieldmap[\"datestamp\"] = array(\"fieldname\"=>\"datestamp\",\n        'type'=>\"datestamp\",\n        'sid'=>$surveyid,\n        \"gid\"=>\"\",\n        \"qid\"=>\"\",\n        \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"datestamp\"]['title'] = \"\";\n            $fieldmap[\"datestamp\"]['question'] = gT(\"Date last action\");\n            $fieldmap[\"datestamp\"]['group_name'] = \"\";\n        }\n\n    }\n    if ($prow['ipaddr'] == \"Y\") {\n        $fieldmap[\"ipaddr\"] = array(\"fieldname\"=>\"ipaddr\",\n        'type'=>\"ipaddress\",\n        'sid'=>$surveyid,\n        \"gid\"=>\"\",\n        \"qid\"=>\"\",\n        \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"ipaddr\"]['title'] = \"\";\n            $fieldmap[\"ipaddr\"]['question'] = gT(\"IP address\");\n            $fieldmap[\"ipaddr\"]['group_name'] = \"\";\n        }\n    }\n    // Add 'refurl' to fieldmap.\n    if ($prow['refurl'] == \"Y\") {\n        $fieldmap[\"refurl\"] = array(\"fieldname\"=>\"refurl\", 'type'=>\"url\", 'sid'=>$surveyid, \"gid\"=>\"\", \"qid\"=>\"\", \"aid\"=>\"\");\n        if ($style == \"full\") {\n            $fieldmap[\"refurl\"]['title'] = \"\";\n            $fieldmap[\"refurl\"]['question'] = gT(\"Referrer URL\");\n            $fieldmap[\"refurl\"]['group_name'] = \"\";\n        }\n    }\n\n    $sOldLanguage = App()->language;\n    App()->setLanguage($sLanguage);\n    // Collect all default values once so don't need separate query for each question with defaults\n    // First collect language specific defaults\n    $defaultsQuery = \"SELECT a.qid, a.sqid, a.scale_id, a.specialtype, a.defaultvalue\"\n    . \" FROM {{defaultvalues}} as a, {{questions}} as b\"\n    . \" WHERE a.qid = b.qid\"\n    . \" AND a.language = b.language\"\n    . \" AND a.language = '{$sLanguage}'\"\n    . \" AND b.same_default=0\"\n    . \" AND b.sid = \".$surveyid;\n    $defaultResults = Yii::app()->db->createCommand($defaultsQuery)->queryAll();\n\n    $defaultValues = array(); // indexed by question then subquestion\n    foreach ($defaultResults as $dv) {\n        if ($dv['specialtype'] != '') {\n            $sq = $dv['specialtype'];\n        } else {\n            $sq = $dv['sqid'];\n        }\n        $defaultValues[$dv['qid'].'~'.$sq] = $dv['defaultvalue'];\n    }\n\n    // Now overwrite language-specific defaults (if any) base language values for each question that uses same_defaults=1\n    $baseLanguage = $survey->language;\n    $defaultsQuery = \"SELECT a.qid, a.sqid, a.scale_id, a.specialtype, a.defaultvalue\"\n    . \" FROM {{defaultvalues}} as a, {{questions}} as b\"\n    . \" WHERE a.qid = b.qid\"\n    . \" AND a.language = b.language\"\n    . \" AND a.language = '{$baseLanguage}'\"\n    . \" AND b.same_default=1\"\n    . \" AND b.sid = \".$surveyid;\n    $defaultResults = Yii::app()->db->createCommand($defaultsQuery)->queryAll();\n\n    foreach ($defaultResults as $dv) {\n        if ($dv['specialtype'] != '') {\n            $sq = $dv['specialtype'];\n        } else {\n            $sq = $dv['sqid'];\n        }\n        $defaultValues[$dv['qid'].'~'.$sq] = $dv['defaultvalue'];\n    }\n    $qtypes = getQuestionTypeList('', 'array');\n\n    // Main query\n    $aquery = \"SELECT * \"\n    .\" FROM {{questions}} as questions, {{groups}} as question_groups\"\n    .\" WHERE questions.gid=question_groups.gid AND \"\n    .\" questions.sid=$surveyid AND \"\n    .\" questions.language='{$sLanguage}' AND \"\n    .\" questions.parent_qid=0 AND \"\n    .\" question_groups.language='{$sLanguage}' \";\n    if ($questionid !== false) {\n        $aquery .= \" and questions.qid={$questionid} \";\n    }\n    $aquery .= \" ORDER BY group_order, question_order\";\n    /** @var Question[] $questions */\n    $questions = Yii::app()->db->createCommand($aquery)->queryAll();\n    $questionSeq = -1; // this is incremental question sequence across all groups\n    $groupSeq = -1;\n    $_groupOrder = -1;\n\n    foreach ($questions as $arow) {\n//With each question, create the appropriate field(s))\n        ++$questionSeq;\n\n        // fix fact taht group_order may have gaps\n        if ($_groupOrder != $arow['group_order']) {\n            $_groupOrder = $arow['group_order'];\n            ++$groupSeq;\n        }\n        // Condition indicators are obsolete with EM.  However, they are so tightly coupled into LS code that easider to just set values to 'N' for now and refactor later.\n        $conditions = 'N';\n        $usedinconditions = 'N';\n\n        // Field identifier\n        // GXQXSXA\n        // G=Group  Q=Question S=Subquestion A=Answer Option\n        // If S or A don't exist then set it to 0\n        // Implicit (subqestion intermal to a question type ) or explicit qubquestions/answer count starts at 1\n\n        // Types \"L\", \"!\", \"O\", \"D\", \"G\", \"N\", \"X\", \"Y\", \"5\", \"S\", \"T\", \"U\"\n        $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}\";\n\n        if ($qtypes[$arow['type']]['subquestions'] == 0 && $arow['type'] != \"R\" && $arow['type'] != \"|\") {\n            if (isset($fieldmap[$fieldname])) {\n                $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n            }\n\n            $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>\"{$arow['type']}\", 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>\"\");\n            \n            if ($style == \"full\") {\n                $fieldmap[$fieldname]['title'] = $arow['title'];\n                $fieldmap[$fieldname]['question'] = $arow['question'];\n                $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                if (isset($defaultValues[$arow['qid'].'~0'])) {\n                    $fieldmap[$fieldname]['defaultvalue'] = $defaultValues[$arow['qid'].'~0'];\n                }\n            }\n            switch ($arow['type']) {\n                case \"L\":  //RADIO LIST\n                case \"!\":  //DROPDOWN LIST\n                    if ($arow['other'] == \"Y\") {\n                        $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}other\";\n                        if (isset($fieldmap[$fieldname])) {\n                            $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                        }\n\n                        $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                        'type'=>$arow['type'],\n                        'sid'=>$surveyid,\n                        \"gid\"=>$arow['gid'],\n                        \"qid\"=>$arow['qid'],\n                        \"aid\"=>\"other\");\n                        // dgk bug fix line above. aid should be set to \"other\" for export to append to the field name in the header line.\n                        if ($style == \"full\") {\n                            $fieldmap[$fieldname]['title'] = $arow['title'];\n                            $fieldmap[$fieldname]['question'] = $arow['question'];\n                            $fieldmap[$fieldname]['subquestion'] = gT(\"Other\");\n                            $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                            $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                            $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                            $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                            $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                            $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                            if (isset($defaultValues[$arow['qid'].'~other'])) {\n                                $fieldmap[$fieldname]['defaultvalue'] = $defaultValues[$arow['qid'].'~other'];\n                            }\n                        }\n                    }\n                    break;\n                case \"O\": //DROPDOWN LIST WITH COMMENT\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}comment\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                    'type'=>$arow['type'],\n                    'sid'=>$surveyid,\n                    \"gid\"=>$arow['gid'],\n                    \"qid\"=>$arow['qid'],\n                    \"aid\"=>\"comment\");\n                    // dgk bug fix line below. aid should be set to \"comment\" for export to append to the field name in the header line. Also needed set the type element correctly.\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion'] = gT(\"Comment\");\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    }\n                    break;\n            }\n        }\n        // For Multi flexi question types\n        elseif ($qtypes[$arow['type']]['subquestions'] == 2 && $qtypes[$arow['type']]['answerscales'] == 0) {\n            //MULTI FLEXI\n            $abrows = getSubQuestions($surveyid, $arow['qid'], $sLanguage);\n            //Now first process scale=1\n            $answerset = array();\n            $answerList = array();\n            foreach ($abrows as $key=>$abrow) {\n                if ($abrow['scale_id'] == 1) {\n                    $answerset[] = $abrow;\n                    $answerList[] = array(\n                    'code'=>$abrow['title'],\n                    'answer'=>$abrow['question'],\n                    );\n                    unset($abrows[$key]);\n                }\n            }\n            reset($abrows);\n            foreach ($abrows as $abrow) {\n                foreach ($answerset as $answer) {\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}_{$answer['title']}\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                    'type'=>$arow['type'],\n                    'sid'=>$surveyid,\n                    \"gid\"=>$arow['gid'],\n                    \"qid\"=>$arow['qid'],\n                    \"aid\"=>$abrow['title'].\"_\".$answer['title'],\n                    \"sqid\"=>$abrow['qid']);\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion1'] = $abrow['question'];\n                        $fieldmap[$fieldname]['subquestion2'] = $answer['question'];\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                        $fieldmap[$fieldname]['preg'] = $arow['preg'];\n                        $fieldmap[$fieldname]['answerList'] = $answerList;\n                        $fieldmap[$fieldname]['SQrelevance'] = $abrow['relevance'];\n                    }\n                }\n            }\n            unset($answerset);\n        } elseif ($arow['type'] == \"1\") {\n            $abrows = getSubQuestions($surveyid, $arow['qid'], $sLanguage);\n            foreach ($abrows as $abrow) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}#0\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$abrow['title'], \"scale_id\"=>0);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = $abrow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['scale'] = gT('Scale 1');\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    $fieldmap[$fieldname]['SQrelevance'] = $abrow['relevance'];\n                }\n\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}#1\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$abrow['title'], \"scale_id\"=>1);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = $abrow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['scale'] = gT('Scale 2');\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    // TODO SQrelevance for different scales? $fieldmap[$fieldname]['SQrelevance']=$abrow['relevance'];\n                }\n            }\n        } elseif ($arow['type'] == \"R\") {\n            // Sub question by answer number OR attribute\n            $answersCount = intval(Answer::model()->countByAttributes(array('qid' => $arow['qid'], 'language' => $sLanguage)));\n            $maxDbAnswer = QuestionAttribute::model()->find(\"qid = :qid AND attribute = 'max_subquestions'\", array(':qid' => $arow['qid']));\n            $columnsCount = (!$maxDbAnswer || intval($maxDbAnswer->value) < 1) ? $answersCount : intval($maxDbAnswer->value);\n            for ($i = 1; $i <= $columnsCount; $i++) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}$i\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$i);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = sprintf(gT('Rank %s'), $i);\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                }\n            }\n        } elseif ($arow['type'] == \"|\") {\n            $qidattributes = QuestionAttribute::model()->getQuestionAttributes($arow['qid']);\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}\";\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                'type'=>$arow['type'],\n                'sid'=>$surveyid,\n                \"gid\"=>$arow['gid'],\n                \"qid\"=>$arow['qid'],\n                \"aid\"=>''\n                );\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['max_files'] = $qidattributes['max_num_of_files'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                }\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}\".\"_filecount\";\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                'type'=>$arow['type'],\n                'sid'=>$surveyid,\n                \"gid\"=>$arow['gid'],\n                \"qid\"=>$arow['qid'],\n                \"aid\"=>\"filecount\"\n                );\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = \"filecount - \".$arow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                }\n        } else {\n// Question types with subquestions and one answer per subquestion  (M/A/B/C/E/F/H/P)\n            //MULTI ENTRY\n            $abrows = getSubQuestions($surveyid, $arow['qid'], $sLanguage);\n            foreach ($abrows as $abrow) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}\";\n\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname,\n                'type'=>$arow['type'],\n                'sid'=>$surveyid,\n                'gid'=>$arow['gid'],\n                'qid'=>$arow['qid'],\n                'aid'=>$abrow['title'],\n                'sqid'=>$abrow['qid']);\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = $abrow['question'];\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    $fieldmap[$fieldname]['preg'] = $arow['preg'];\n                    // get SQrelevance from DB\n                    $fieldmap[$fieldname]['SQrelevance'] = $abrow['relevance'];\n                    if (isset($defaultValues[$arow['qid'].'~'.$abrow['qid']])) {\n                        $fieldmap[$fieldname]['defaultvalue'] = $defaultValues[$arow['qid'].'~'.$abrow['qid']];\n                    }\n                }\n                if ($arow['type'] == \"P\") {\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}{$abrow['title']}comment\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>$abrow['title'].\"comment\");\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion'] = gT('Comment');\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    }\n                }\n            }\n            if ($arow['other'] == \"Y\" && ($arow['type'] == \"M\" || $arow['type'] == \"P\")) {\n                $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}other\";\n                if (isset($fieldmap[$fieldname])) {\n                    $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                }\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>\"other\");\n                if ($style == \"full\") {\n                    $fieldmap[$fieldname]['title'] = $arow['title'];\n                    $fieldmap[$fieldname]['question'] = $arow['question'];\n                    $fieldmap[$fieldname]['subquestion'] = gT('Other');\n                    $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                    $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                    $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                    $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                    $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                    $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                    $fieldmap[$fieldname]['other'] = $arow['other'];\n                }\n                if ($arow['type'] == \"P\") {\n                    $fieldname = \"{$arow['sid']}X{$arow['gid']}X{$arow['qid']}othercomment\";\n                    if (isset($fieldmap[$fieldname])) {\n                        $aDuplicateQIDs[$arow['qid']] = array('fieldname'=>$fieldname, 'question'=>$arow['question'], 'gid'=>$arow['gid']);\n                    }\n                    $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>$arow['type'], 'sid'=>$surveyid, \"gid\"=>$arow['gid'], \"qid\"=>$arow['qid'], \"aid\"=>\"othercomment\");\n                    if ($style == \"full\") {\n                        $fieldmap[$fieldname]['title'] = $arow['title'];\n                        $fieldmap[$fieldname]['question'] = $arow['question'];\n                        $fieldmap[$fieldname]['subquestion'] = gT('Other comment');\n                        $fieldmap[$fieldname]['group_name'] = $arow['group_name'];\n                        $fieldmap[$fieldname]['mandatory'] = $arow['mandatory'];\n                        $fieldmap[$fieldname]['hasconditions'] = $conditions;\n                        $fieldmap[$fieldname]['usedinconditions'] = $usedinconditions;\n                        $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n                        $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n                        $fieldmap[$fieldname]['other'] = $arow['other'];\n                    }\n                }\n            }\n        }\n        if (isset($fieldmap[$fieldname])) {\n            //set question relevance (uses last SQ's relevance field for question relevance)\n            $fieldmap[$fieldname]['relevance'] = $arow['relevance'];\n            $fieldmap[$fieldname]['grelevance'] = $arow['grelevance'];\n            $fieldmap[$fieldname]['questionSeq'] = $questionSeq;\n            $fieldmap[$fieldname]['groupSeq'] = $groupSeq;\n            $fieldmap[$fieldname]['preg'] = $arow['preg'];\n            $fieldmap[$fieldname]['other'] = $arow['other'];\n            $fieldmap[$fieldname]['help'] = $arow['help'];\n\n            // Set typeName\n        } else {\n            --$questionSeq; // didn't generate a valid $fieldmap entry, so decrement the question counter to ensure they are sequential\n        }\n\n        if (isset($fieldmap[$fieldname]['typename'])) {\n                    $fieldmap[$fieldname]['typename'] = $typename[$fieldname] = $arow['typename'];\n        }\n    }\n    App()->setLanguage($sOldLanguage);\n\n    if ($questionid === false) {\n        // If the fieldmap was randomized, the master will contain the proper order.  Copy that fieldmap with the new language settings.\n        if (isset(Yii::app()->session['survey_'.$surveyid]['fieldmap-'.$surveyid.'-randMaster'])) {\n            $masterFieldmap = Yii::app()->session['survey_'.$surveyid]['fieldmap-'.$surveyid.'-randMaster'];\n            $mfieldmap = Yii::app()->session['survey_'.$surveyid][$masterFieldmap];\n\n            foreach ($mfieldmap as $fieldname => $mf) {\n                if (isset($fieldmap[$fieldname])) {\n                    // This array holds the keys of translatable attributes\n                    $translatable = array_flip(array('question', 'subquestion', 'subquestion1', 'subquestion2', 'group_name', 'answerList', 'defaultValue', 'help'));\n                    // We take all translatable attributes from the new fieldmap\n                    $newText = array_intersect_key($fieldmap[$fieldname], $translatable);\n                    // And merge them with the other values from the random fieldmap like questionSeq, groupSeq etc.\n                    $mf = $newText + $mf;\n                }\n                $mfieldmap[$fieldname] = $mf;\n            }\n            $fieldmap = $mfieldmap;\n        }\n\n        Yii::app()->session['fieldmap-'.$surveyid.$sLanguage] = $fieldmap;\n    }\n    return $fieldmap;\n}\n\n/**\n* Returns true if the given survey has a File Upload Question Type\n* @param integer $iSurveyID\n* @return bool\n*/\nfunction hasFileUploadQuestion($iSurveyID)\n{\n    $iCount = Question::model()->count(\"sid=:surveyid AND parent_qid=0 AND type='|'\", array(':surveyid' => $iSurveyID));\n    return $iCount > 0;\n}\n\n/**\n* This function generates an array containing the fieldcode, and matching data in the same order as the activate script\n*\n* @param string $surveyid The Survey ID\n* @param string $style 'short' (default) or 'full' - full creates extra information like default values\n* @param boolean $force_refresh - Forces to really refresh the array, not just take the session copy\n* @param int $questionid Limit to a certain qid only (for question preview) - default is false\n* @param string $sQuestionLanguage The language to use\n* @return array\n*/\nfunction createTimingsFieldMap($surveyid, $style = 'full', $force_refresh = false, $questionid = false, $sQuestionLanguage = null)\n{\n\n    static $timingsFieldMap;\n\n    $sLanguage = sanitize_languagecode($sQuestionLanguage);\n    $surveyid = sanitize_int($surveyid);\n    $survey = Survey::model()->findByPk($surveyid);\n\n    $sOldLanguage = App()->language;\n    App()->setLanguage($sLanguage);\n\n    //checks to see if fieldmap has already been built for this page.\n    if (isset($timingsFieldMap[$surveyid][$style][$sLanguage]) && $force_refresh === false) {\n        return $timingsFieldMap[$surveyid][$style][$sLanguage];\n    }\n\n    //do something\n    $fields = createFieldMap($survey, $style, $force_refresh, $questionid, $sQuestionLanguage);\n    $fieldmap = [];\n    $fieldmap['interviewtime'] = array('fieldname'=>'interviewtime', 'type'=>'interview_time', 'sid'=>$surveyid, 'gid'=>'', 'qid'=>'', 'aid'=>'', 'question'=>gT('Total time'), 'title'=>'interviewtime');\n    foreach ($fields as $field) {\n        if (!empty($field['gid'])) {\n            // field for time spent on page\n            $fieldname = \"{$field['sid']}X{$field['gid']}time\";\n            if (!isset($fieldmap[$fieldname])) {\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>\"page_time\", 'sid'=>$surveyid, \"gid\"=>$field['gid'], \"group_name\"=>$field['group_name'], \"qid\"=>'', 'aid'=>'', 'title'=>'groupTime'.$field['gid'], 'question'=>gT('Group time').\": \".$field['group_name']);\n            }\n\n            // field for time spent on answering a question\n            $fieldname = \"{$field['sid']}X{$field['gid']}X{$field['qid']}time\";\n            if (!isset($fieldmap[$fieldname])) {\n                $fieldmap[$fieldname] = array(\"fieldname\"=>$fieldname, 'type'=>\"answer_time\", 'sid'=>$surveyid, \"gid\"=>$field['gid'], \"group_name\"=>$field['group_name'], \"qid\"=>$field['qid'], 'aid'=>'', \"title\"=>$field['title'].'Time', \"question\"=>gT('Question time').\": \".$field['title']);\n            }\n        }\n    }\n\n    $timingsFieldMap[$surveyid][$style][$sLanguage] = $fieldmap;\n    App()->setLanguage($sOldLanguage);\n    return $timingsFieldMap[$surveyid][$style][$sLanguage];\n}\n\n/**\n *\n * @param mixed $needle\n * @param mixed $haystack\n * @param string $keyname\n * @param integer $maxanswers\n * @return array\n */\nfunction arraySearchByKey($needle, $haystack, $keyname, $maxanswers = \"\")\n{\n    $output = array();\n    foreach ($haystack as $hay) {\n        if (array_key_exists($keyname, $hay)) {\n            if ($hay[$keyname] == $needle) {\n                if ($maxanswers == 1) {\n                    return $hay;\n                } else {\n                    $output[] = $hay;\n                }\n            }\n        }\n    }\n    return $output;\n}\n\n/**\n* This function returns a count of the number of saved responses to a survey\n*\n* @param mixed $surveyid Survey ID\n*/\nfunction getSavedCount($surveyid)\n{\n    $surveyid = (int) $surveyid;\n\n    return SavedControl::model()->getCountOfAll($surveyid);\n}\n\n\nfunction buildLabelSetCheckSumArray()\n{\n    // BUILD CHECKSUMS FOR ALL EXISTING LABEL SETS\n\n    /**$query = \"SELECT lid\n    FROM \".db_table_name('labelsets').\"\n    ORDER BY lid\"; */\n    $result = LabelSet::model()->getLID(); //($query) or safeDie(\"safe_died collecting labelset ids<br />$query<br />\");  //Checked)\n    $csarray = array();\n    foreach ($result as $row) {\n        $thisset = \"\";\n        $query2 = \"SELECT code, title, sortorder, language, assessment_value\n        FROM {{labels}}\n        WHERE lid={$row['lid']}\n        ORDER BY language, sortorder, code\";\n        $result2 = Yii::app()->db->createCommand($query2)->query();\n        foreach ($result2->readAll() as $row2) {\n            $thisset .= implode('.', $row2);\n        } // while\n        $csarray[$row['lid']] = dechex(crc32($thisset) * 1);\n    }\n\n    return $csarray;\n}\n\n\n\n/**\n*\n* Returns the questionAttribtue value set or '' if not set\n* @author: lemeur\n* @param $questionAttributeArray\n* @param string $attributeName\n* @param $language string Optional: The language if the particualr attributes is localizable\n* @return string\n*/\nfunction getQuestionAttributeValue($questionAttributeArray, $attributeName, $language = '')\n{\n    if ($language == '' && isset($questionAttributeArray[$attributeName])) {\n        return $questionAttributeArray[$attributeName];\n    } elseif ($language != '' && isset($questionAttributeArray[$attributeName][$language])) {\n        return $questionAttributeArray[$attributeName][$language];\n    } else {\n        return '';\n    }\n}\n\n\nfunction categorySort($a, $b)\n{\n    $result = strnatcasecmp($a['category'], $b['category']);\n    if ($result == 0) {\n        $result = $a['sortorder'] - $b['sortorder'];\n    }\n    return $result;\n}\n\n\n\n\n// make a string safe to include in an HTML 'value' attribute.\nfunction HTMLEscape($str)\n{\n    // escape newline characters, too, in case we put a value from\n    // a TEXTAREA  into an <input type=\"hidden\"> value attribute.\n    return str_replace(array(\"\\x0A\", \"\\x0D\"), array(\"&#10;\", \"&#13;\"),\n    htmlspecialchars($str, ENT_QUOTES));\n}\n\n/**\n* This function strips UTF-8 control characters from strings, except tabs, CR and LF\n* - it is intended to be used before any response data is saved to the response table\n*\n* @param mixed $sValue A string to be sanitized\n* @return string A sanitized string, otherwise the unmodified original variable\n*/\nfunction stripCtrlChars($sValue)\n{\n    if (is_string($sValue)) {\n        $sValue = preg_replace('/[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x80-\\x9F]/u', '', $sValue);\n    }\n    return $sValue;\n}\n\n// make a string safe to include in a JavaScript String parameter.\nfunction javascriptEscape($str, $strip_tags = false, $htmldecode = false)\n{\n\n    if ($htmldecode == true) {\n        $str = html_entity_decode($str, ENT_QUOTES, 'UTF-8');\n    }\n    if ($strip_tags == true) {\n        $str = strip_tags($str);\n    }\n    return str_replace(array('\\'', '\"', \"\\n\", \"\\r\"),\n    array(\"\\\\'\", '\\u0022', \"\\\\n\", '\\r'),\n    $str);\n}\n// make a string safe to include in a json String parameter.\nfunction jsonEscape($str, $strip_tags = false, $htmldecode = false)\n{\n\n    if ($htmldecode == true) {\n        $str = html_entity_decode($str, ENT_QUOTES, 'UTF-8');\n    }\n    if ($strip_tags == true) {\n        $str = strip_tags($str);\n    }\n    return str_replace(array('\"','\\''), array(\"&apos;\",\"&apos;\"), $str);\n}\n\n/**\n* This function mails a text $body to the recipient $to.\n* You can use more than one recipient when using a semicolon separated string with recipients.\n*\n* @param string $body Body text of the email in plain text or HTML\n* @param mixed $subject Email subject\n* @param mixed $to Array with several email addresses or single string with one email address\n* @param mixed $from\n* @param mixed $sitename\n* @param boolean $ishtml\n* @param mixed $bouncemail\n* @param mixed $attachments\n* @return bool If successful returns true\n*/\nfunction SendEmailMessage($body, $subject, $to, $from, $sitename, $ishtml = false, $bouncemail = null, $attachments = null, $customheaders = \"\")\n{\n    global $maildebug, $maildebugbody;\n    require_once(APPPATH.'/third_party/html2text/src/Html2Text.php');\n\n    $emailmethod = Yii::app()->getConfig('emailmethod');\n    $emailsmtphost = Yii::app()->getConfig(\"emailsmtphost\");\n    $emailsmtpuser = Yii::app()->getConfig(\"emailsmtpuser\");\n    $emailsmtppassword = Yii::app()->getConfig(\"emailsmtppassword\");\n    $emailsmtpdebug = Yii::app()->getConfig(\"emailsmtpdebug\");\n    $emailsmtpssl = Yii::app()->getConfig(\"emailsmtpssl\");\n    $defaultlang = Yii::app()->getConfig(\"defaultlang\");\n    $emailcharset = Yii::app()->getConfig(\"emailcharset\");\n\n    if ($emailcharset != 'utf-8') {\n        $body = mb_convert_encoding($body, $emailcharset, 'utf-8');\n        $subject = mb_convert_encoding($subject, $emailcharset, 'utf-8');\n        $sitename = mb_convert_encoding($sitename, $emailcharset, 'utf-8');\n    }\n\n    if (!is_array($to)) {\n        $to = array($to);\n    }\n\n\n\n    if (!is_array($customheaders) && $customheaders == '') {\n        $customheaders = array();\n    }\n    if (Yii::app()->getConfig('demoMode')) {\n        $maildebug = gT('Email was not sent because demo-mode is activated.');\n        $maildebugbody = '';\n        return false;\n    }\n\n    if (is_null($bouncemail)) {\n        $sender = $from;\n    } else {\n        $sender = $bouncemail;\n    }\n\n\n    require_once(APPPATH.'/third_party/phpmailer/load_phpmailer.php');\n    $mail = new PHPMailer\\PHPMailer\\PHPMailer;\n    $mail->SMTPAutoTLS = false;\n    if (!$mail->SetLanguage($defaultlang, APPPATH.'/third_party/phpmailer/language/')) {\n        $mail->SetLanguage('en', APPPATH.'/third_party/phpmailer/language/');\n    }\n    $mail->CharSet = $emailcharset;\n    if (isset($emailsmtpssl) && trim($emailsmtpssl) !== '' && $emailsmtpssl !== 0) {\n        if ($emailsmtpssl === 1) {$mail->SMTPSecure = \"ssl\"; } else {$mail->SMTPSecure = $emailsmtpssl; }\n    }\n\n    $fromname = '';\n    $fromemail = $from;\n    if (strpos($from, '<')) {\n        $fromemail = substr($from, strpos($from, '<') + 1, strpos($from, '>') - 1 - strpos($from, '<'));\n        $fromname = trim(substr($from, 0, strpos($from, '<') - 1));\n    }\n\n    $senderemail = $sender;\n    if (strpos($sender, '<')) {\n        $senderemail = substr($sender, strpos($sender, '<') + 1, strpos($sender, '>') - 1 - strpos($sender, '<'));\n    }\n\n    switch ($emailmethod) {\n        case \"qmail\":\n            $mail->IsQmail();\n            break;\n        case \"smtp\":\n            $mail->IsSMTP();\n            if ($emailsmtpdebug > 0) {\n                $mail->SMTPDebug = $emailsmtpdebug;\n            }\n            if (strpos($emailsmtphost, ':') > 0) {\n                $mail->Host = substr($emailsmtphost, 0, strpos($emailsmtphost, ':'));\n                $mail->Port = (int) substr($emailsmtphost, strpos($emailsmtphost, ':') + 1);\n            } else {\n                $mail->Host = $emailsmtphost;\n            }\n            $mail->Username = $emailsmtpuser;\n            $mail->Password = $emailsmtppassword;\n            if (trim($emailsmtpuser) != \"\") {\n                $mail->SMTPAuth = true;\n            }\n            break;\n        case \"sendmail\":\n            $mail->IsSendmail();\n            break;\n        default:\n            $mail->IsMail();\n    }\n\n    $mail->SetFrom($fromemail, $fromname);\n    $mail->Sender = $senderemail; // Sets Return-Path for error notifications\n    foreach ($to as $singletoemail) {\n        if (strpos($singletoemail, '<')) {\n            $toemail = substr($singletoemail, strpos($singletoemail, '<') + 1, strpos($singletoemail, '>') - 1 - strpos($singletoemail, '<'));\n            $toname = trim(substr($singletoemail, 0, strpos($singletoemail, '<') - 1));\n            $mail->AddAddress($toemail, $toname);\n        } else {\n            $mail->AddAddress($singletoemail);\n        }\n    }\n    if (is_array($customheaders)) {\n        foreach ($customheaders as $key=>$val) {\n            $mail->AddCustomHeader($val);\n        }\n    }\n    $mail->AddCustomHeader(\"X-Surveymailer: $sitename Emailer (LimeSurvey.org)\");\n    if (get_magic_quotes_gpc() != \"0\") {$body = stripcslashes($body); }\n    if ($ishtml) {\n        $mail->IsHTML(true);\n        if (strpos($body, \"<html>\") === false) {\n            $body = \"<html>\".$body.\"</html>\";\n        }\n        $mail->msgHTML($body, App()->getConfig(\"publicdir\")); // This allow embedded image if we remove the servername from image\n        $html = new \\Html2Text\\Html2Text($body);\n        $mail->AltBody = $html->getText();\n    } else {\n        $mail->IsHTML(false);\n        $mail->Body = $body;\n    }\n    // Add attachments if they are there.\n    if (is_array($attachments)) {\n        foreach ($attachments as $attachment) {\n            // Attachment is either an array with filename and attachment name.\n            if (is_array($attachment)) {\n                $mail->AddAttachment($attachment[0], $attachment[1]);\n            } else {\n// Or a string with the filename.\n                $mail->AddAttachment($attachment);\n            }\n        }\n    }\n    $mail->Subject = $subject;\n\n    if ($emailsmtpdebug > 0) {\n        ob_start();\n    }\n    $sent = $mail->Send();\n    $maildebug = $mail->ErrorInfo;\n    if ($emailsmtpdebug > 0) {\n        $maildebug .= '<br><strong>'.gT('SMTP debug output:').'</strong><pre>'.\\CHtml::encode(ob_get_contents()).'</pre>';\n        ob_end_clean();\n    }\n    $maildebugbody = $mail->Body;\n    //if(!$sent) var_dump($maildebug);\n    return $sent;\n}\n\n\n/**\n*  This functions removes all HTML tags, Javascript, CRs, linefeeds and other strange chars from a given text\n*\n* @param string $sTextToFlatten  Text you want to clean\n* @param boolean $bKeepSpan set to true for keep span, used for expression manager. Default: false\n* @param boolean $bDecodeHTMLEntities If set to true then all HTML entities will be decoded to the specified charset. Default: false\n* @param string $sCharset Charset to decode to if $decodeHTMLEntities is set to true. Default: UTF-8\n* @param string $bStripNewLines strip new lines if true, if false replace all new line by \\r\\n. Default: true\n*\n* @return string  Cleaned text\n*/\nfunction flattenText($sTextToFlatten, $bKeepSpan = false, $bDecodeHTMLEntities = false, $sCharset = 'UTF-8', $bStripNewLines = true)\n{\n    $sNicetext = stripJavaScript($sTextToFlatten);\n    // When stripping tags, add a space before closing tags so that strings with embedded HTML tables don't get concatenated\n    $sNicetext = str_replace(array('</td', '</th'), array(' </td', ' </th'), $sNicetext);\n    if ($bKeepSpan) {\n        // Keep <span> so can show EM syntax-highlighting; add space before tags so that word-wrapping not destroyed when remove tags.\n        $sNicetext = strip_tags($sNicetext, '<span><table><tr><td><th>');\n    } else {\n        $sNicetext = strip_tags($sNicetext);\n    }\n    // ~\\R~u : see \"What \\R matches\" and \"Newline sequences\" in http://www.pcre.org/pcre.txt - only available since PCRE 7.0\n    if ($bStripNewLines) {\n// strip new lines\n        if (version_compare(substr(PCRE_VERSION, 0, strpos(PCRE_VERSION, ' ')), '7.0') > -1) {\n            $sNicetext = preg_replace(array('~\\R~u'), array(' '), $sNicetext);\n        } else {\n            // Poor man's replacement for line feeds\n            $sNicetext = str_replace(array(\"\\r\\n\", \"\\n\", \"\\r\"), array(' ', ' ', ' '), $sNicetext);\n        }\n    } elseif (version_compare(substr(PCRE_VERSION, 0, strpos(PCRE_VERSION, ' ')), '7.0') > -1) {\n        // unify newlines to \\r\\n\n        $sNicetext = preg_replace(array('~\\R~u'), array(\"\\r\\n\"), $sNicetext);\n    }\n    if ($bDecodeHTMLEntities === true) {\n        $sNicetext = str_replace('&nbsp;', ' ', $sNicetext); // html_entity_decode does not convert &nbsp; to spaces\n        $sNicetext = html_entity_decode($sNicetext, ENT_QUOTES, $sCharset);\n    }\n    $sNicetext = trim($sNicetext);\n    return  $sNicetext;\n}\n\n\n/**\n* getArrayFilterExcludesCascadesForGroup() queries the database and produces a list of array_filter_exclude questions and targets with in the same group\n* @return array a keyed nested array, keyed by the qid of the question, containing cascade information\n*/\nfunction getArrayFilterExcludesCascadesForGroup($surveyid, $gid = \"\", $output = \"qid\")\n{\n    $surveyid = sanitize_int($surveyid);\n    $survey = Survey::model()->findByPk($surveyid);\n\n    $gid = sanitize_int($gid);\n\n\n    $cascaded = array();\n    $sources = array();\n    $qidtotitle = array();\n    $fieldmap = createFieldMap($survey, 'full', false, false, $survey->language);\n\n    if ($gid != \"\") {\n        $qrows = arraySearchByKey($gid, $fieldmap, 'gid');\n    } else {\n        $qrows = $fieldmap;\n    }\n    $grows = array(); //Create an empty array in case query not return any rows\n    // Store each result as an array with in the $grows array\n    foreach ($qrows as $qrow) {\n        if (isset($qrow['gid']) && !empty($qrow['gid'])) {\n            $grows[$qrow['qid']] = array('qid' => $qrow['qid'], 'type' => $qrow['type'], 'mandatory' => $qrow['mandatory'], 'title' => $qrow['title'], 'gid' => $qrow['gid']);\n        }\n    }\n    foreach ($grows as $qrow) {\n    // Cycle through questions to see if any have list_filter attributes\n        $qidtotitle[$qrow['qid']] = $qrow['title'];\n        $qresult = QuestionAttribute::model()->getQuestionAttributes($qrow['qid']);\n        if (isset($qresult['array_filter_exclude'])) {\n        // We Found a array_filter attribute\n            $val = $qresult['array_filter_exclude']; // Get the Value of the Attribute ( should be a previous question's title in same group )\n            foreach ($grows as $avalue) {\n            // Cycle through all the other questions in this group until we find the source question for this array_filter\n                if ($avalue['title'] == $val) {\n                    /* This question ($avalue) is the question that provides the source information we use\n                    * to determine which answers show up in the question we're looking at, which is $qrow['qid']\n                    * So, in other words, we're currently working on question $qrow['qid'], trying to find out more\n                    * information about question $avalue['qid'], because that's the source */\n                    $sources[$qrow['qid']] = $avalue['qid']; /* This question ($qrow['qid']) relies on answers in $avalue['qid'] */\n                    if (isset($cascades)) {unset($cascades); }\n                    $cascades = array(); /* Create an empty array */\n\n                    /* At this stage, we know for sure that this question relies on one other question for the filter */\n                    /* But this function wants to send back information about questions that rely on multiple other questions for the filter */\n                    /* So we don't want to do anything yet */\n\n                    /* What we need to do now, is check whether the question this one relies on, also relies on another */\n\n                    /* The question we are now checking is $avalue['qid'] */\n                    $keepgoing = 1;\n                    $questiontocheck = $avalue['qid'];\n                    /* If there is a key in the $sources array that is equal to $avalue['qid'] then we want to add that\n                    * to the $cascades array */\n                    while ($keepgoing > 0) {\n                        if (!empty($sources[$questiontocheck])) {\n                            $cascades[] = $sources[$questiontocheck];\n                            /* Now we need to move down the chain */\n                            /* We want to check the $sources[$questiontocheck] question */\n                            $questiontocheck = $sources[$questiontocheck];\n                        } else {\n                            /* Since it was empty, there must not be any more questions down the cascade */\n                            $keepgoing = 0;\n                        }\n                    }\n                    /* Now add all that info */\n                    if (count($cascades) > 0) {\n                        $cascaded[$qrow['qid']] = $cascades;\n                    }\n                }\n            }\n        }\n    }\n    $cascade2 = array();\n    if ($output == \"title\") {\n        foreach ($cascaded as $key=>$cascade) {\n            foreach ($cascade as $item) {\n                $cascade2[$key][] = $qidtotitle[$item];\n            }\n        }\n        $cascaded = $cascade2;\n    }\n    return $cascaded;\n}\n\nfunction createPassword()\n{\n    $aCharacters = \"ABCDEGHJIKLMNOPQURSTUVWXYZabcdefhjmnpqrstuvwxyz23456789\";\n    $iPasswordLength = 12;\n    $sPassword = '';\n    for ($i = 0; $i < $iPasswordLength; $i++) {\n        $sPassword .= $aCharacters[(int) floor(rand(0, strlen($aCharacters) - 1))];\n    }\n    return $sPassword;\n}\n\n// TODO input Survey Object\nfunction languageDropdown($surveyid, $selected)\n{\n    $slangs = Survey::model()->findByPk($surveyid)->additionalLanguages;\n    $baselang = Survey::model()->findByPk($surveyid)->language;\n    array_unshift($slangs, $baselang);\n    $html = \"<select class='listboxquestions' name='langselect' onchange=\\\"window.open(this.options[this.selectedIndex].value, '_top')\\\">\\n\";\n\n    foreach ($slangs as $lang) {\n        $link = Yii::app()->homeUrl.(\"/admin/dataentry/sa/view/surveyid/\".$surveyid.\"/lang/\".$lang);\n        if ($lang == $selected) {\n            $html .= \"\\t<option value='{$link}' selected='selected'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n        if ($lang != $selected) {\n            $html .= \"\\t<option value='{$link}'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n    }\n    $html .= \"</select>\";\n    return $html;\n}\n\n// TODO input Survey Object\n/**\n * Creates a <select> HTML element for language selection for this survey\n *\n * @param int $surveyid\n * @param string $selected The selected language\n * @return string\n */\nfunction languageDropdownClean($surveyid, $selected)\n{\n    $slangs = Survey::model()->findByPk($surveyid)->additionalLanguages;\n    $baselang = Survey::model()->findByPk($surveyid)->language;\n    array_unshift($slangs, $baselang);\n    $html = \"<select class='form-control listboxquestions' id='language' name='language'>\\n\";\n    foreach ($slangs as $lang) {\n        if ($lang == $selected) {\n            $html .= \"\\t<option value='$lang' selected='selected'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n        if ($lang != $selected) {\n            $html .= \"\\t<option value='$lang'>\".getLanguageNameFromCode($lang, false).\"</option>\\n\";\n        }\n    }\n    $html .= \"</select>\";\n    return $html;\n}\n\n/**\n* This function removes a directory recursively\n*\n* @param string $dirname\n* @return bool\n*/\nfunction rmdirr($dirname)\n{\n    // Sanity check\n    if (!file_exists($dirname)) {\n        return false;\n    }\n\n    // Simple delete for a file\n    if (is_file($dirname) || is_link($dirname)) {\n        return @unlink($dirname);\n    }\n\n    // Loop through the folder\n    $dir = dir($dirname);\n    while (false !== $entry = $dir->read()) {\n        // Skip pointers\n        if ($entry == '.' || $entry == '..') {\n            continue;\n        }\n\n        // Recurse\n        rmdirr($dirname.DIRECTORY_SEPARATOR.$entry);\n    }\n\n    // Clean up\n    $dir->close();\n    return @rmdir($dirname);\n}\n\n/**\n* This function removes surrounding and masking quotes from the CSV field\n*\n* @param mixed $field\n* @return mixed\n*/\nfunction CSVUnquote($field)\n{\n    //print $field.\":\";\n    $field = preg_replace(\"/^\\040*\\\"/\", \"\", $field);\n    $field = preg_replace(\"/\\\"\\040*$/\", \"\", $field);\n    $field = str_replace('\"\"', '\"', $field);\n    //print $field.\"\\n\";\n    return $field;\n}\n\n/**\n* This function return actual completion state\n*\n* @return string|boolean (complete|incomplete|all) or false\n*/\nfunction incompleteAnsFilterState()\n{\n    $letsfilter = returnGlobal('completionstate'); //read get/post completionstate\n\n    // first let's initialize the incompleteanswers session variable\n    if ($letsfilter != '') {\n// use the read value if not empty\n        Yii::app()->session['incompleteanswers'] = $letsfilter;\n    } elseif (empty(Yii::app()->session['incompleteanswers'])) {\n// sets default variable value from config file\n        Yii::app()->session['incompleteanswers'] = Yii::app()->getConfig('filterout_incomplete_answers');\n    }\n\n    if (Yii::app()->session['incompleteanswers'] == 'complete' || Yii::app()->session['incompleteanswers'] == 'all' || Yii::app()->session['incompleteanswers'] == 'incomplete') {\n        return Yii::app()->session['incompleteanswers'];\n    } else {\n// last resort is to prevent filtering\n        return false;\n    }\n}\n\n\n/**\n* isCaptchaEnabled($screen, $usecaptchamode)\n* @param string $screen - the screen name for which to test captcha activation\n*\n* @return boolean|null - returns true if captcha must be enabled\n**/\nfunction isCaptchaEnabled($screen, $captchamode = '')\n{\n    if (!extension_loaded('gd')) {\n        return false;\n    }\n    switch ($screen) {\n        case 'registrationscreen':\n            if ($captchamode == 'A' ||\n            $captchamode == 'B' ||\n            $captchamode == 'D' ||\n            $captchamode == 'R') {\n                return true;\n            }\n            return false;\n        case 'surveyaccessscreen':\n            if ($captchamode == 'A' ||\n            $captchamode == 'B' ||\n            $captchamode == 'C' ||\n            $captchamode == 'X') {\n                return true;\n            }\n            return false;\n        case 'saveandloadscreen':\n            if ($captchamode == 'A' ||\n                $captchamode == 'C' ||\n                $captchamode == 'D' ||\n                $captchamode == 'S') {\n                return true;\n            }\n            return false;\n        default:\n            return true;\n    }\n}\n\n\n/**\n* Check if a table does exist in the database\n*\n* @param string $sTableName Table name to check for (without dbprefix!))\n* @return boolean True or false if table exists or not\n*/\nfunction tableExists($sTableName)\n{\n    $sTableName = Yii::app()->db->tablePrefix.str_replace(array('{', '}'), array('', ''), $sTableName);\n    return in_array($sTableName, Yii::app()->db->schema->getTableNames());\n}\n\n// Returns false if the survey is anonymous,\n// and a survey participants table exists: in this case the completed field of a token\n// will contain 'Y' instead of the submitted date to ensure privacy\n// Returns true otherwise\nfunction isTokenCompletedDatestamped($thesurvey)\n{\n    if ($thesurvey['anonymized'] == 'Y' && tableExists('tokens_'.$thesurvey['sid'])) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\n/**\n* example usage\n* $date = \"2006-12-31 21:00\";\n* $shift \"+6 hours\"; // could be days, weeks... see function strtotime() for usage\n*\n* echo sql_date_shift($date, \"Y-m-d H:i:s\", $shift);\n*\n* will output: 2007-01-01 03:00:00\n*\n* @param string $date\n* @param string $dformat\n* @param mixed $shift\n* @return string\n*/\nfunction dateShift($date, $dformat, $shift)\n{\n    return date($dformat, strtotime($shift, strtotime($date)));\n}\n\n\n// getBounceEmail: returns email used to receive error notifications\nfunction getBounceEmail($surveyid)\n{\n    $surveyInfo = getSurveyInfo($surveyid);\n\n    if ($surveyInfo['bounce_email'] == '') {\n        return null; // will be converted to from in MailText\n    } else {\n        return $surveyInfo['bounce_email'];\n    }\n}\n\n// getEmailFormat: returns email format for the survey\n// returns 'text' or 'html'\nfunction getEmailFormat($surveyid)\n{\n    $surveyInfo = getSurveyInfo($surveyid);\n    if ($surveyInfo['htmlemail'] == 'Y') {\n        return 'html';\n    } else {\n        return 'text';\n    }\n\n}\n\n// Check if user has manage rights for a template\nfunction hasTemplateManageRights($userid, $sThemeFolder)\n{\n    $userid = (int) $userid;\n    $sThemeFolder = sanitize_paranoid_string($sThemeFolder);\n    if ($sThemeFolder === false) {\n        return false;\n    }\n    return Permission::model()->hasTemplatePermission($sThemeFolder, 'read', $userid);\n}\n\n\n/**\n* Translate links which are in any answer/question/survey/email template/label set to their new counterpart\n*\n* @param string $sType 'survey' or 'label'\n* @param mixed $iOldSurveyID\n* @param mixed $iNewSurveyID\n* @param mixed $sString\n* @return string\n*/\nfunction translateLinks($sType, $iOldSurveyID, $iNewSurveyID, $sString)\n{\n    $iOldSurveyID = (int) $iOldSurveyID;\n    $iNewSurveyID = (int) $iNewSurveyID; // To avoid injection of a /e regex modifier without having to check all execution paths\n    if ($sType == 'survey') {\n        $sPattern = '(http(s)?:\\/\\/)?(([a-z0-9\\/\\.])*(?=(\\/upload))\\/upload\\/surveys\\/'.$iOldSurveyID.'\\/)';\n        $sReplace = Yii::app()->getConfig(\"publicurl\").\"upload/surveys/{$iNewSurveyID}/\";\n        return preg_replace('/'.$sPattern.'/u', $sReplace, $sString);\n    } elseif ($sType == 'label') {\n        $sPattern = '(http(s)?:\\/\\/)?(([a-z0-9\\/\\.])*(?=(\\/upload))\\/upload\\/labels\\/'.$iOldSurveyID.'\\/)';\n        $sReplace = Yii::app()->getConfig(\"publicurl\").\"upload/labels/{$iNewSurveyID}/\";\n        return preg_replace(\"/\".$sPattern.\"/u\", $sReplace, $sString);\n    } else // unknown type\n    {\n        return $sString;\n    }\n}\n\n/**\n * This function creates the old fieldnames for survey import\n *\n * @param mixed $iOldSID The old survey id\n * @param integer $iNewSID The new survey id\n * @param array $aGIDReplacements An array with group ids (oldgid=>newgid)\n * @param array $aQIDReplacements An array with question ids (oldqid=>newqid)\n * @return array|bool\n */\nfunction reverseTranslateFieldNames($iOldSID, $iNewSID, $aGIDReplacements, $aQIDReplacements)\n{\n    $aGIDReplacements = array_flip($aGIDReplacements);\n    $aQIDReplacements = array_flip($aQIDReplacements);\n\n    /** @var Survey $oNewSurvey */\n    $oNewSurvey = Survey::model()->findByPk($iNewSID);\n\n    if ($iOldSID == $iNewSID) {\n        $forceRefresh = true; // otherwise grabs the cached copy and throws undefined index exceptions\n    } else {\n        $forceRefresh = false;\n    }\n    $aFieldMap = createFieldMap($oNewSurvey, 'short', $forceRefresh, false, $oNewSurvey->language);\n\n    $aFieldMappings = array();\n    foreach ($aFieldMap as $sFieldname=>$aFieldinfo) {\n        if ($aFieldinfo['qid'] != null) {\n            $aFieldMappings[$sFieldname] = $iOldSID.'X'.$aGIDReplacements[$aFieldinfo['gid']].'X'.$aQIDReplacements[$aFieldinfo['qid']].$aFieldinfo['aid'];\n            if ($aFieldinfo['type'] == '1') {\n                $aFieldMappings[$sFieldname] = $aFieldMappings[$sFieldname].'#'.$aFieldinfo['scale_id'];\n            }\n            // now also add a shortened field mapping which is needed for certain kind of condition mappings\n            $aFieldMappings[$iNewSID.'X'.$aFieldinfo['gid'].'X'.$aFieldinfo['qid']] = $iOldSID.'X'.$aGIDReplacements[$aFieldinfo['gid']].'X'.$aQIDReplacements[$aFieldinfo['qid']];\n            // Shortened field mapping for timings table\n            $aFieldMappings[$iNewSID.'X'.$aFieldinfo['gid']] = $iOldSID.'X'.$aGIDReplacements[$aFieldinfo['gid']];\n        }\n    }\n    return array_flip($aFieldMappings);\n}\n\n/**\n * put your comment there...\n *\n * @param integer $id\n * @param string $type\n * @return bool\n */\nfunction hasResources($id, $type = 'survey')\n{\n    $dirname = Yii::app()->getConfig(\"uploaddir\");\n\n    if ($type == 'survey') {\n        $dirname .= \"/surveys/$id\";\n    } elseif ($type == 'label') {\n        $dirname .= \"/labels/$id\";\n    } else {\n        return false;\n    }\n\n    if (is_dir($dirname) && $dh = opendir($dirname)) {\n        while (($entry = readdir($dh)) !== false) {\n            if ($entry !== '.' && $entry !== '..') {\n                return true;\n            }\n        }\n        closedir($dh);\n    } else {\n        return false;\n    }\n\n    return false;\n}\n\n/**\n * Creates a random sequence of characters\n *\n * @param integer $length Length of resulting string\n * @param string $pattern To define which characters should be in the resulting string\n * @return string\n */\nfunction randomChars($length, $pattern = \"23456789abcdefghijkmnpqrstuvwxyz\")\n{\n    $patternlength = strlen($pattern) - 1;\n    $key = '';\n    for ($i = 0; $i < $length; $i++) {\n        $key .= $pattern{mt_rand(0, $patternlength)};\n    }\n    return $key;\n}\n\n/**\n* used to translate simple text to html (replacing \\n with <br />\n*\n* @param mixed $mytext\n* @param mixed $ishtml\n* @return mixed\n*/\nfunction conditionalNewlineToBreak($mytext, $ishtml, $encoded = '')\n{\n    if ($ishtml === true) {\n        // $mytext has been processed by gT with html mode\n        // and thus \\n has already been translated to &#10;\n        if ($encoded == '') {\n            $mytext = str_replace('&#10;', '<br />', $mytext);\n        }\n        return str_replace(\"\\n\", '<br />', $mytext);\n    } else {\n        return $mytext;\n    }\n}\n\n\nfunction breakToNewline($data)\n{\n    return preg_replace('!<br.*>!iU', \"\\n\", $data);\n}\n\n/**\n* Provides a safe way to end the application\n* \n* @param mixed $sText\n* @returns boolean Fake return so Scrutinizes shuts up\n*/\nfunction safeDie($sText)\n{\n    //Only allowed tag: <br />\n    $textarray = explode('<br />', $sText);\n    $textarray = array_map('htmlspecialchars', $textarray);\n    die(implode('<br />', $textarray));\n    return false; // do not remove\n}\n\n/**\n * @param string $str\n */\nfunction fixCKeditorText($str)\n{\n    $str = str_replace('<br type=\"_moz\" />', '', $str);\n    if ($str == \"<br />\" || $str == \" \" || $str == \"&nbsp;\") {\n        $str = \"\";\n    }\n    if (preg_match(\"/^[\\s]+$/\", $str)) {\n        $str = '';\n    }\n    if ($str == \"\\n\") {\n        $str = \"\";\n    }\n    if (trim($str) == \"&nbsp;\" || trim($str) == '') {\n// chrome adds a single &nbsp; element to empty fckeditor fields\n        $str = \"\";\n    }\n\n    return $str;\n}\n\n\n/**\n * This is a helper function for getAttributeFieldNames\n *\n * @param mixed $fieldname\n * @return bool\n */\nfunction filterForAttributes($fieldname)\n{\n    if (strpos($fieldname, 'attribute_') === false) {\n        return false;\n    } else {\n        return true;\n    }\n    }\n\n/**\n* Retrieves the attribute field names from the related survey participants table\n*\n* @param mixed $iSurveyID  The survey ID\n* @return array The fieldnames\n*/\nfunction getAttributeFieldNames($iSurveyID)\n{\n    $survey = Survey::model()->findByPk($iSurveyID);\n    if (!$survey->hasTokensTable || !$table = Yii::app()->db->schema->getTable($survey->tokensTableName)) {\n            return Array();\n    }\n\n    return array_filter(array_keys($table->columns), 'filterForAttributes');\n\n}\n\n/**\n * Returns the full list of attribute token fields including the properties for each field\n * Use this instead of plain Survey::model()->findByPk($iSurveyID)->tokenAttributes calls because Survey::model()->findByPk($iSurveyID)->tokenAttributes may contain old descriptions where the fields does not physically exist\n *\n * @param integer $iSurveyID The Survey ID\n * @return array\n */\nfunction getParticipantAttributes($iSurveyID)\n{\n    $survey = Survey::model()->findByPk($iSurveyID);\n    if (!$survey->hasTokensTable || !Yii::app()->db->schema->getTable($survey->tokensTableName)) {\n            return Array();\n    }\n    return getTokenFieldsAndNames($iSurveyID, true);\n}\n\n\n\n\n\n/**\n* Retrieves the attribute names from the related survey participants table\n*\n* @param mixed $surveyid  The survey ID\n* @param boolean $bOnlyAttributes Set this to true if you only want the fieldnames of the additional attribue fields - defaults to false\n* @return array The fieldnames as key and names as value in an Array\n*/\nfunction getTokenFieldsAndNames($surveyid, $bOnlyAttributes = false)\n{\n\n\n    $aBasicTokenFields = array('firstname'=>array(\n        'description'=>gT('First name'),\n        'mandatory'=>'N',\n        'showregister'=>'Y'\n        ),\n        'lastname'=>array(\n            'description'=>gT('Last name'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'email'=>array(\n            'description'=>gT('Email address'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'emailstatus'=>array(\n            'description'=>gT(\"Email status\"),\n            'mandatory'=>'N',\n            'showregister'=>'N'\n        ),\n        'token'=>array(\n            'description'=>gT('Token'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'language'=>array(\n            'description'=>gT('Language code'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'sent'=>array(\n            'description'=>gT('Invitation sent date'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'remindersent'=>array(\n            'description'=>gT('Last reminder sent date'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'remindercount'=>array(\n            'description'=>gT('Total numbers of sent reminders'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n        'usesleft'=>array(\n            'description'=>gT('Uses left'),\n            'mandatory'=>'N',\n            'showregister'=>'Y'\n        ),\n    );\n\n    $aExtraTokenFields = getAttributeFieldNames($surveyid);\n    $aSavedExtraTokenFields = Survey::model()->findByPk($surveyid)->tokenAttributes;\n\n    // Drop all fields that are in the saved field description but not in the table definition\n    $aSavedExtraTokenFields = array_intersect_key($aSavedExtraTokenFields, array_flip($aExtraTokenFields));\n\n    // Now add all fields that are in the table but not in the field description\n    foreach ($aExtraTokenFields as $sField) {\n        if (!isset($aSavedExtraTokenFields[$sField])) {\n            $aSavedExtraTokenFields[$sField] = array(\n            'description'=>$sField,\n            'mandatory'=>'N',\n            'showregister'=>'N',\n            'cpdbmap'=>''\n            );\n        } elseif (empty($aSavedExtraTokenFields[$sField]['description'])) {\n            $aSavedExtraTokenFields[$sField]['description'] = $sField;\n        }\n    }\n    if ($bOnlyAttributes) {\n        return $aSavedExtraTokenFields;\n    } else {\n        return array_merge($aBasicTokenFields, $aSavedExtraTokenFields);\n    }\n}\n\n\n/**\n* This function strips any content between and including <javascript> tags\n*\n* @param string $sContent String to clean\n* @return string  Cleaned string\n*/\nfunction stripJavaScript($sContent)\n{\n    $text = preg_replace('@<script[^>]*?>.*?</script>@si', '', $sContent);\n    // TODO : Adding the onload/onhover etc ... or remove this false security function\n    return $text;\n}\n\n/**\n* This function converts emebedded Javascript to Text\n*\n* @param string $sContent String to clean\n* @return string  Cleaned string\n*/\nfunction showJavaScript($sContent)\n{\n    $text = preg_replace_callback('@<script[^>]*?>.*?</script>@si', \n        function($matches) {\n            return htmlspecialchars($matches[0]);\n        }, $sContent);\n    return $text;\n}\n\n/**\n* This function cleans files from the temporary directory being older than 1 day\n* @todo Make the days configurable\n*/\nfunction cleanTempDirectory()\n{\n    $dir = Yii::app()->getConfig('tempdir').DIRECTORY_SEPARATOR;\n    $dp = opendir($dir) or safeDie('Could not open temporary directory');\n    while ($file = readdir($dp)) {\n        if (is_file($dir.$file) && (filemtime($dir.$file)) < (strtotime('-1 days')) && $file != 'index.html' && $file != '.gitignore' && $file != 'readme.txt') {\n            /** @scrutinizer ignore-unhandled */ @unlink($dir.$file); \n        }\n    }\n    $dir = Yii::app()->getConfig('tempdir').DIRECTORY_SEPARATOR.'upload'.DIRECTORY_SEPARATOR;\n    $dp = opendir($dir) or safeDie('Could not open temporary upload directory');\n    while ($file = readdir($dp)) {\n        if (is_file($dir.$file) && (filemtime($dir.$file)) < (strtotime('-1 days')) && $file != 'index.html' && $file != '.gitignore' && $file != 'readme.txt') {\n            /** @scrutinizer ignore-unhandled */ @unlink($dir.$file); \n        }\n    }\n    closedir($dp);\n}\n\nfunction useFirebug()\n{\n    if (FIREBUG == true) {\n        App()->getClientScript()->registerScriptFile('http://getfirebug.com/releases/lite/1.2/firebug-lite-compressed.js');\n    };\n};\n\n/**\n* This is a convenience function for the coversion of datetime values\n*\n* @param mixed $value\n* @param string $fromdateformat\n* @param mixed $todateformat\n* @return string\n*/\nfunction convertDateTimeFormat($value, $fromdateformat, $todateformat)\n{\n    $date = DateTime::createFromFormat($fromdateformat, $value);\n    if ($date) {\n        return $date->format($todateformat);\n    } else {\n        $date = new DateTime($value);\n        return $date->format($todateformat);\n    }\n}\n\n/**\n* This is a convenience function to convert any date, in any date format, to the global setting date format\n* Check if the time shoul be rendered also\n*\n* @param string $sDate\n* @param boolean $withTime\n* @return string\n*/\nfunction convertToGlobalSettingFormat($sDate, $withTime = false)\n{\n\n    $sDateformatdata = getDateFormatData(Yii::app()->session['dateformat']); // We get the Global Setting date format\n    $usedDatetime = ($withTime === true ? $sDateformatdata['phpdate'].\" H:i\" : $sDateformatdata['phpdate']); //return also hours and minutes if asked for\n    try {\n        // Workaround for bug in older PHP version (confirmed for 5.5.9)\n        // The bug is causing invalid dates to create an internal server error which cannot not be caught by try.. catch\n        if (@strtotime($sDate) === false) {\n            throw new Exception(\"Failed to parse date string ({$sDate})\");\n        }\n        $oDate           = new DateTime($sDate); // We generate the Date object (PHP will deal with the format of the string)\n        $sDate           = $oDate->format($usedDatetime); // We apply it to the Date object to generate a string date\n        return $sDate; // We return the string date\n    } catch (Exception $e) {\n        $oDate           = new DateTime('1/1/1980 00:00'); // We generate the Date object (PHP will deal with the format of the string)\n        $sDate           = $oDate->format($usedDatetime); // We apply it to the Date object to generate a string date\n        return $sDate; // We return the string date\n\n    }\n}\n\n/**\n* This function removes the UTF-8 Byte Order Mark from a string\n*\n* @param string $str\n* @return string\n*/\nfunction removeBOM($str = \"\")\n{\n    if (substr($str, 0, 3) == pack(\"CCC\", 0xef, 0xbb, 0xbf)) {\n        $str = substr($str, 3);\n    }\n    return $str;\n}\n\n\n/**\n * This function returns the complete directory path to a given template name\n *\n * @param mixed $sTemplateName\n * @return string\n */\nfunction getTemplatePath($sTemplateName = '')\n{\n    return Template::getTemplatePath($sTemplateName);\n}\n\n/**\n * This function returns the complete URL path to a given template name\n *\n * @param mixed $sTemplateName\n * @return string\n */\nfunction getTemplateURL($sTemplateName)\n{\n    return Template::getTemplateURL($sTemplateName);\n}\n\n/**\n * Return an array of subquestions for a given sid/qid\n *\n * @param int $sid\n * @param int $qid\n * @param string $sLanguage Language of the subquestion text\n * @return array\n */\nfunction getSubQuestions($sid, $qid, $sLanguage)\n{\n\n    static $subquestions;\n\n    if (!isset($subquestions[$sid])) {\n        $subquestions[$sid] = array();\n    }\n    if (!isset($subquestions[$sid][$sLanguage])) {\n\n        $query = \"SELECT sq.*, q.other FROM {{questions}} as sq, {{questions}} as q\"\n        .\" WHERE sq.parent_qid=q.qid AND q.sid=\".$sid\n        .\" AND sq.language='\".$sLanguage.\"' \"\n        .\" AND q.language='\".$sLanguage.\"' \"\n        .\" ORDER BY sq.parent_qid, q.question_order,sq.scale_id , sq.question_order\";\n\n        $query = Yii::app()->db->createCommand($query)->query();\n\n        $resultset = array();\n        //while ($row=$result->FetchRow())\n        foreach ($query->readAll() as $row) {\n            $resultset[$row['parent_qid']][] = $row;\n        }\n        $subquestions[$sid][$sLanguage] = $resultset;\n    }\n    if (isset($subquestions[$sid][$sLanguage][$qid])) {\n        return $subquestions[$sid][$sLanguage][$qid];\n    }\n    return array();\n}\n\n/**\n* Wrapper function to retrieve an xmlwriter object and do error handling if it is not compiled\n* into PHP\n*/\nfunction getXMLWriter()\n{\n    if (!extension_loaded('xmlwriter')) {\n        safeDie('XMLWriter class not compiled into PHP, please contact your system administrator');\n    }\n    return new XMLWriter();\n}\n\n/**\n* SSLRedirect() generates a redirect URL for the appropriate SSL mode then applies it.\n* (Was redirect() before CodeIgniter port.)\n*\n* @param string $enforceSSLMode string 's' or '' (empty).\n*/\nfunction SSLRedirect($enforceSSLMode)\n{\n    $url = 'http'.$enforceSSLMode.'://'.$_SERVER['HTTP_HOST'].$_SERVER['REQUEST_URI'];\n    if (!headers_sent()) {\n// If headers not sent yet... then do php redirect\n        //ob_clean();\n        header('Location: '.$url);\n        //ob_flush();\n        Yii::app()->end();\n    };\n};\n\n/**\n* enforceSSLMode() $force_ssl is on or off, it checks if the current\n* request is to HTTPS (or not). If $force_ssl is on, and the\n* request is not to HTTPS, it redirects the request to the HTTPS\n* version of the URL, if the request is to HTTPS, it rewrites all\n* the URL variables so they also point to HTTPS.\n*/\nfunction enforceSSLMode()\n{\n    $bSSLActive = ((!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] != \"off\") ||\n    (isset($_SERVER['HTTP_FORWARDED_PROTO']) && $_SERVER['HTTP_FORWARDED_PROTO'] == \"https\") ||\n    (isset($_SERVER['HTTP_X_FORWARDED_PROTO']) && $_SERVER['HTTP_X_FORWARDED_PROTO'] == \"https\"));\n    if (Yii::app()->getConfig('ssl_emergency_override') !== true) {\n        $force_ssl = strtolower(getGlobalSetting('force_ssl'));\n    } else {\n        $force_ssl = 'off';\n    };\n    if ($force_ssl == 'on' && !$bSSLActive) {\n        SSLRedirect('s');\n    }\n    if ($force_ssl == 'off' && $bSSLActive) {\n        SSLRedirect('');\n    };\n};\n\n\n/**\n * Creates an array with details on a particular response for display purposes\n * Used in Print answers, Detailed response view and Detailed admin notification email\n *\n * @param mixed $iSurveyID\n * @param mixed $iResponseID\n * @param mixed $sLanguageCode\n * @param boolean $bHonorConditions Apply conditions\n * @return array\n */\nfunction getFullResponseTable($iSurveyID, $iResponseID, $sLanguageCode, $bHonorConditions = true)\n{\n    $survey = Survey::model()->findByPk($iSurveyID);\n    $aFieldMap = createFieldMap($survey, 'full', false, false, $sLanguageCode);\n\n    //Get response data\n    $idrow = SurveyDynamic::model($iSurveyID)->findByAttributes(array('id'=>$iResponseID));\n\n    // Create array of non-null values - those are the relevant ones\n    $aRelevantFields = array();\n\n    foreach ($aFieldMap as $sKey=>$fname) {\n        if (LimeExpressionManager::QuestionIsRelevant($fname['qid']) || $bHonorConditions === false) {\n            $aRelevantFields[$sKey] = $fname;\n        }\n    }\n\n    $aResultTable = array();\n    $oldgid = 0;\n    $oldqid = 0;\n    foreach ($aRelevantFields as $sKey=>$fname) {\n        if (!empty($fname['qid'])) {\n            $attributes = QuestionAttribute::model()->getQuestionAttributes($fname['qid']);\n            if (getQuestionAttributeValue($attributes, 'hidden') == 1) {\n                continue;\n            }\n        }\n        $question = $fname['question'];\n        $subquestion = '';\n        if (isset($fname['gid']) && !empty($fname['gid'])) {\n            //Check to see if gid is the same as before. if not show group name\n            if ($oldgid !== $fname['gid']) {\n                $oldgid = $fname['gid'];\n                if (LimeExpressionManager::GroupIsRelevant($fname['gid']) || $bHonorConditions === false) {\n                    $aResultTable['gid_'.$fname['gid']] = array($fname['group_name'], QuestionGroup::model()->getGroupDescription($fname['gid'], $sLanguageCode));\n                }\n            }\n        }\n        if (!empty($fname['qid'])) {\n            if ($oldqid !== $fname['qid']) {\n                $oldqid = $fname['qid'];\n                if (isset($fname['subquestion']) || isset($fname['subquestion1']) || isset($fname['subquestion2'])) {\n                    $aResultTable['qid_'.$fname['sid'].'X'.$fname['gid'].'X'.$fname['qid']] = array($fname['question'], '', '');\n                } else {\n                    $answer = getExtendedAnswer($iSurveyID, $fname['fieldname'], $idrow[$fname['fieldname']], $sLanguageCode);\n                    $aResultTable[$fname['fieldname']] = array($question, '', $answer);\n                    continue;\n                }\n            }\n        } else {\n            $answer = getExtendedAnswer($iSurveyID, $fname['fieldname'], $idrow[$fname['fieldname']], $sLanguageCode);\n            $aResultTable[$fname['fieldname']] = array($question, '', $answer);\n            continue;\n        }\n        if (isset($fname['subquestion'])) {\n                    $subquestion = \"[{$fname['subquestion']}]\";\n        }\n\n        if (isset($fname['subquestion1'])) {\n                    $subquestion = \"[{$fname['subquestion1']}]\";\n        }\n\n        if (isset($fname['subquestion2'])) {\n                    $subquestion .= \"[{$fname['subquestion2']}]\";\n        }\n\n        $answer = getExtendedAnswer($iSurveyID, $fname['fieldname'], $idrow[$fname['fieldname']], $sLanguageCode);\n        $aResultTable[$fname['fieldname']] = array($question, $subquestion, $answer);\n    }\n    return $aResultTable;\n}\n\n/**\n * Check if $str is an integer, or string representation of an integer\n *\n * @param string $mStr\n * @return bool|int\n */\nfunction isNumericInt($mStr)\n{\n    if (is_int($mStr)) {\n            return true;\n    } elseif (is_string($mStr)) {\n            return preg_match(\"/^[0-9]+$/\", $mStr);\n    }\n    return false;\n}\n\n/**\n* Implode and sort content array for very long arrays\n*\n* @param string $sDelimeter\n* @param array $aArray\n* @return string String showing array content\n*/\nfunction short_implode($sDelimeter, $sHyphen, $aArray)\n{\n    if (sizeof($aArray) < Yii::app()->getConfig('minlengthshortimplode')) {\n        sort($aArray);\n        return implode($sDelimeter, $aArray);\n    } else {\n        sort($aArray);\n        $iIndexA = 0;\n        $sResult = null;\n        while ($iIndexA < sizeof($aArray)) {\n            if ($iIndexA == 0) {\n                $sResult = $aArray[$iIndexA];\n            } else {\n                if (strlen($sResult) > Yii::app()->getConfig('maxstringlengthshortimplode') - strlen($sDelimeter) - 3) {\n                    return $sResult.$sDelimeter.'...';\n                } else {\n                    $sResult = $sResult.$sDelimeter.$aArray[$iIndexA];\n                }\n            }\n            $iIndexB = $iIndexA + 1;\n            if ($iIndexB < sizeof($aArray)) {\n                while ($iIndexB < sizeof($aArray) && $aArray[$iIndexB] - 1 == $aArray[$iIndexB - 1]) {\n                    $iIndexB++;\n                }\n                if ($iIndexA < $iIndexB - 1) {\n                    $sResult = $sResult.$sHyphen.$aArray[$iIndexB - 1];\n                }\n            }\n            $iIndexA = $iIndexB;\n        }\n        return $sResult;\n    }\n}\n\n/**\n* Include Keypad headers\n*/\nfunction includeKeypad()\n{\n    App()->getClientScript()->registerScriptFile(Yii::app()->getConfig('third_party').'jquery-keypad/jquery.plugin.min.js');\n    App()->getClientScript()->registerScriptFile(Yii::app()->getConfig('third_party').'jquery-keypad/jquery.keypad.min.js');\n    $localefile = Yii::app()->getConfig('rootdir').'/third_party/jquery-keypad/jquery.keypad-'.App()->language.'.js';\n    if (App()->language != 'en' && file_exists($localefile)) {\n        Yii::app()->getClientScript()->registerScriptFile(Yii::app()->getConfig('third_party').'jquery-keypad/jquery.keypad-'.App()->language.'.js');\n    }\n    Yii::app()->getClientScript()->registerCssFile(Yii::app()->getConfig('third_party').\"jquery-keypad/jquery.keypad.alt.css\");\n}\n\n\n/**\n* This function replaces the old insertans tags with new ones across a survey\n*\n* @param string $newsid  Old SID\n* @param string $oldsid  New SID\n* @param mixed $fieldnames Array  array('oldfieldname'=>'newfieldname')\n*/\nfunction translateInsertansTags($newsid, $oldsid, $fieldnames)\n{\n    uksort($fieldnames, function($a, $b) {return strlen($a) < strlen($b); });\n\n    Yii::app()->loadHelper('database');\n    $newsid = (int) $newsid;\n    $oldsid = (int) $oldsid;\n\n    # translate 'surveyls_urldescription' and 'surveyls_url' INSERTANS tags in surveyls\n    $sql = \"SELECT surveyls_survey_id, surveyls_language, surveyls_urldescription, surveyls_url from {{surveys_languagesettings}}\n    WHERE surveyls_survey_id=\".$newsid.\" AND (surveyls_urldescription LIKE '%{$oldsid}X%' OR surveyls_url LIKE '%{$oldsid}X%')\";\n    $result = dbExecuteAssoc($sql) or safeDie(\"Can't read groups table in translateInsertansTags\"); // Checked\n\n    //while ($qentry = $res->FetchRow())\n    foreach ($result->readAll() as $qentry) {\n        $urldescription = $qentry['surveyls_urldescription'];\n        $endurl = $qentry['surveyls_url'];\n        $language = $qentry['surveyls_language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $urldescription = preg_replace('/'.$pattern.'/', $replacement, $urldescription);\n            $endurl = preg_replace('/'.$pattern.'/', $replacement, $endurl);\n        }\n\n        if (strcmp($urldescription, $qentry['surveyls_urldescription']) != 0 ||\n        (strcmp($endurl, $qentry['surveyls_url']) != 0)) {\n\n            // Update Field\n\n            $data = array(\n            'surveyls_urldescription' => $urldescription,\n            'surveyls_url' => $endurl\n            );\n\n            $where = array(\n            'surveyls_survey_id' => $newsid,\n            'surveyls_language' => $language\n            );\n\n            SurveyLanguageSetting::model()->updateRecord($data, $where);\n\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'quotals_urldescrip' and 'quotals_url' INSERTANS tags in quota_languagesettings\n    $sql = \"SELECT quotals_id, quotals_urldescrip, quotals_url from {{quota_languagesettings}} qls, {{quota}} q\n    WHERE sid=\".$newsid.\" AND q.id=qls.quotals_quota_id AND (quotals_urldescrip LIKE '%{$oldsid}X%' OR quotals_url LIKE '%{$oldsid}X%')\";\n    $result = dbExecuteAssoc($sql) or safeDie(\"Can't read quota table in transInsertAns\"); // Checked\n\n    foreach ($result->readAll() as $qentry) {\n        $urldescription = $qentry['quotals_urldescrip'];\n        $endurl = $qentry['quotals_url'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $urldescription = preg_replace('/'.$pattern.'/', $replacement, $urldescription);\n            $endurl = preg_replace('/'.$pattern.'/', $replacement, $endurl);\n        }\n\n        if (strcmp($urldescription, $qentry['quotals_urldescrip']) != 0 || (strcmp($endurl, $qentry['quotals_url']) != 0)) {\n            // Update Field\n            $sqlupdate = \"UPDATE {{quota_languagesettings}} SET quotals_urldescrip='\".$urldescription.\"', quotals_url='\".$endurl.\"' WHERE quotals_id={$qentry['quotals_id']}\";\n            dbExecuteAssoc($sqlupdate) or safeDie(\"Couldn't update INSERTANS in quota_languagesettings<br />$sqlupdate<br />\"); //Checked\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'description' INSERTANS tags in groups\n    $sql = \"SELECT gid, language, group_name, description from {{groups}}\n    WHERE sid=\".$newsid.\" AND description LIKE '%{$oldsid}X%' OR group_name LIKE '%{$oldsid}X%'\";\n    $res = dbExecuteAssoc($sql) or safeDie(\"Can't read groups table in transInsertAns\"); // Checked\n\n    //while ($qentry = $res->FetchRow())\n    foreach ($res->readAll() as $qentry) {\n        $gpname = $qentry['group_name'];\n        $description = $qentry['description'];\n        $gid = $qentry['gid'];\n        $language = $qentry['language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $gpname = preg_replace('/'.$pattern.'/', $replacement, $gpname);\n            $description = preg_replace('/'.$pattern.'/', $replacement, $description);\n        }\n\n        if (strcmp($description, $qentry['description']) != 0 || strcmp($gpname, $qentry['group_name']) != 0) {\n            // Update Fields\n            $where = array(\n            'gid' => $gid,\n            'language' => $language\n            );\n            $oGroup = QuestionGroup::model()->findByAttributes($where);\n            $oGroup->description = $description;\n            $oGroup->group_name = $gpname;\n            $oGroup->save();\n\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'question' and 'help' INSERTANS tags in questions\n    $sql = \"SELECT qid, language, question, help from {{questions}}\n    WHERE sid=\".$newsid.\" AND (question LIKE '%{$oldsid}X%' OR help LIKE '%{$oldsid}X%')\";\n    $result = dbExecuteAssoc($sql) or safeDie(\"Can't read question table in transInsertAns \"); // Checked\n\n    //while ($qentry = $res->FetchRow())\n    $aResultData = $result->readAll();\n    foreach ($aResultData as $qentry) {\n        $question = $qentry['question'];\n        $help = $qentry['help'];\n        $qid = $qentry['qid'];\n        $language = $qentry['language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $question = preg_replace('/'.$pattern.'/', $replacement, $question);\n            $help = preg_replace('/'.$pattern.'/', $replacement, $help);\n        }\n\n        if (strcmp($question, $qentry['question']) != 0 ||\n        strcmp($help, $qentry['help']) != 0) {\n            // Update Field\n\n            $data = array(\n            'question' => $question,\n            'help' => $help\n            );\n\n            $where = array(\n            'qid' => $qid,\n            'language' => $language\n            );\n\n            Question::model()->updateByPk($where, $data);\n\n        } // Enf if modified\n    } // end while qentry\n\n    # translate 'answer' INSERTANS tags in answers\n    $result = Answer::model()->oldNewInsertansTags($newsid, $oldsid);\n\n    //while ($qentry = $res->FetchRow())\n    foreach ($result as $qentry) {\n        $answer = $qentry['answer'];\n        $code = $qentry['code'];\n        $qid = $qentry['qid'];\n        $language = $qentry['language'];\n\n        foreach ($fieldnames as $sOldFieldname=>$sNewFieldname) {\n            $pattern = $sOldFieldname;\n            $replacement = $sNewFieldname;\n            $answer = preg_replace('/'.$pattern.'/', $replacement, $answer);\n        }\n\n        if (strcmp($answer, $qentry['answer']) != 0) {\n            // Update Field\n\n            $data = array(\n            'answer' => $answer,\n            'qid' => $qid\n            );\n\n            $where = array(\n            'code' => $code,\n            'language' => $language\n            );\n\n            Answer::model()->updateRecord($data, $where);\n\n        } // Enf if modified\n    } // end while qentry\n}\n\n/**\n* Replaces EM variable codes in a current survey with a new one\n*\n* @param integer $iSurveyID The survey ID\n* @param mixed $aCodeMap The codemap array (old_code=>new_code)\n*/\nfunction replaceExpressionCodes($iSurveyID, $aCodeMap)\n{\n    $arQuestions = Question::model()->findAll(\"sid=:sid\", array(':sid'=>$iSurveyID));\n    foreach ($arQuestions as $arQuestion) {\n        $bModified = false;\n        foreach ($aCodeMap as $sOldCode=>$sNewCode) {\n            // Don't search/replace old codes that are too short or were numeric (because they would not have been usable in EM expressions anyway)\n            if (strlen($sOldCode) > 1 && !is_numeric($sOldCode)) {\n                $sOldCode = preg_quote($sOldCode, '~');\n                $arQuestion->relevance=preg_replace(\"/\\b{$sOldCode}/\",$sNewCode,$arQuestion->relevance,-1,$iCount);\n                $bModified = $bModified || $iCount;\n                $arQuestion->question = preg_replace(\"~{[^}]*\\K{$sOldCode}(?=[^}]*?})~\", $sNewCode, $arQuestion->question, -1, $iCount);\n                $bModified = $bModified || $iCount;\n            }\n        }\n        if ($bModified) {\n            $arQuestion->save();\n        }\n    }\n    $arGroups = QuestionGroup::model()->findAll(\"sid=:sid\", array(':sid'=>$iSurveyID));\n    foreach ($arGroups as $arGroup) {\n        $bModified = false;\n        foreach ($aCodeMap as $sOldCode=>$sNewCode) {\n            $sOldCode = preg_quote($sOldCode, '~');\n            $arGroup->grelevance=preg_replace(\"~{[^}]*\\K{$sOldCode}(?=[^}]*?})~\",$sNewCode,$arGroup->grelevance,-1,$iCount);\n            $bModified = $bModified || $iCount;\n            $arGroup->description = preg_replace(\"~{[^}]*\\K{$sOldCode}(?=[^}]*?})~\", $sNewCode, $arGroup->description, -1, $iCount);\n            $bModified = $bModified || $iCount;\n        }\n        if ($bModified) {\n            $arGroup->save();\n        }\n    }\n}\n\n\n/**\n* cleanLanguagesFromSurvey() removes any languages from survey tables that are not in the passed list\n* @param string $sid - the currently selected survey\n* @param string $availlangs - space separated list of additional languages in survey\n* @return bool - always returns true\n*/\nfunction cleanLanguagesFromSurvey($sid, $availlangs)\n{\n\n    Yii::app()->loadHelper('database');\n    //\n    $sid = sanitize_int($sid);\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $aLanguages = [];\n    if (!empty($availlangs) && $availlangs != \" \") {\n        $availlangs = sanitize_languagecodeS($availlangs);\n        $aLanguages = explode(\" \", $availlangs);\n        if ($aLanguages[count($aLanguages) - 1] == \"\") {\n            array_pop($aLanguages);\n        }\n    }\n\n    $sqllang = \"language <> '\".$baselang.\"' \";\n\n    if (!empty($availlangs) && $availlangs != \" \") {\n        foreach ($aLanguages as $lang) {\n            $sqllang .= \"AND language <> '\".$lang.\"' \";\n        }\n    }\n\n    // Remove From Answer Table\n    $query = \"SELECT qid FROM {{questions}} WHERE sid='{$sid}' AND $sqllang\";\n    $qidresult = dbExecuteAssoc($query);\n\n    foreach ($qidresult->readAll() as $qrow) {\n\n        $myqid = $qrow['qid'];\n        $query = \"DELETE FROM {{answers}} WHERE qid='$myqid' AND $sqllang\";\n        dbExecuteAssoc($query);\n    }\n\n    // Remove From Questions Table\n    $query = \"DELETE FROM {{questions}} WHERE sid='{$sid}' AND $sqllang\";\n    dbExecuteAssoc($query);\n\n    // Remove From QuestionGroup Table\n    $query = \"DELETE FROM {{groups}} WHERE sid='{$sid}' AND $sqllang\";\n    dbExecuteAssoc($query);\n\n    return true;\n}\n\n/**\n* fixLanguageConsistency() fixes missing groups, questions, answers, quotas & assessments for languages on a survey\n* @param string $sid - the currently selected survey\n* @param string $availlangs - space separated list of additional languages in survey - if empty all additional languages of a survey are checked against the base language\n* @return bool - always returns true\n*/\nfunction fixLanguageConsistency($sid, $availlangs = '')\n{\n    $sid = sanitize_int($sid);\n\n\n    if (trim($availlangs) != '') {\n        $availlangs = sanitize_languagecodeS($availlangs);\n        $langs = explode(\" \", $availlangs);\n        if ($langs[count($langs) - 1] == \"\") {\n            array_pop($langs);\n        }\n    } else {\n        $langs = Survey::model()->findByPk($sid)->additionalLanguages;\n    }\n    if (count($langs) == 0) {\n        return true; // Survey only has one language\n    }\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $query = \"SELECT * FROM {{groups}} WHERE sid='{$sid}' AND language='{$baselang}'  ORDER BY group_order\";\n    $result = Yii::app()->db->createCommand($query)->query();\n    foreach ($result->readAll() as $group) {\n        foreach ($langs as $lang) {\n\n            $query = \"SELECT count(gid) FROM {{groups}} WHERE sid='{$sid}' AND gid='{$group['gid']}' AND language='{$lang}'\";\n            $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n            if ($gresult < 1) {\n                $data = array(\n                'gid' => $group['gid'],\n                'sid' => $group['sid'],\n                'group_name' => $group['group_name'],\n                'group_order' => $group['group_order'],\n                'description' => $group['description'],\n                'randomization_group' => $group['randomization_group'],\n                'grelevance' => $group['grelevance'],\n                'language' => $lang\n\n                );\n                switchMSSQLIdentityInsert('groups', true);\n                Yii::app()->db->createCommand()->insert('{{groups}}', $data);\n                switchMSSQLIdentityInsert('groups', false);\n            }\n        }\n        reset($langs);\n    }\n\n    $quests = array();\n    $query = \"SELECT * FROM {{questions}} WHERE sid='{$sid}' AND language='{$baselang}' ORDER BY question_order\";\n    $result = Yii::app()->db->createCommand($query)->query()->readAll();\n    if (count($result) > 0) {\n        foreach ($result as $question) {\n            array_push($quests, $question['qid']);\n            foreach ($langs as $lang) {\n                $query = \"SELECT count(qid) FROM {{questions}} WHERE sid='{$sid}' AND qid='{$question['qid']}' AND language='{$lang}' AND scale_id={$question['scale_id']}\";\n                $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n                if ($gresult < 1) {\n                    switchMSSQLIdentityInsert('questions', true);\n                    $data = array(\n                    'qid' => $question['qid'],\n                    'sid' => $question['sid'],\n                    'gid' => $question['gid'],\n                    'type' => $question['type'],\n                    'title' => $question['title'],\n                    'question' => $question['question'],\n                    'preg' => $question['preg'],\n                    'help' => $question['help'],\n                    'other' => $question['other'],\n                    'mandatory' => $question['mandatory'],\n                    'question_order' => $question['question_order'],\n                    'language' => $lang,\n                    'scale_id' => $question['scale_id'],\n                    'parent_qid' => $question['parent_qid'],\n                    'relevance' => $question['relevance']\n                    );\n                    Yii::app()->db->createCommand()->insert('{{questions}}', $data);\n                }\n            }\n            reset($langs);\n        }\n\n        $sqlans = \"\";\n        foreach ($quests as $quest) {\n            $sqlans .= \" OR qid = '\".$quest.\"' \";\n        }\n        $query = \"SELECT * FROM {{answers}} WHERE language='{$baselang}' and (\".trim($sqlans, ' OR').\") ORDER BY qid, code\";\n        $result = Yii::app()->db->createCommand($query)->query();\n        foreach ($result->readAll() as $answer) {\n            foreach ($langs as $lang) {\n                $query = \"SELECT count(qid) FROM {{answers}} WHERE code='{$answer['code']}' AND qid='{$answer['qid']}' AND language='{$lang}' AND scale_id={$answer['scale_id']}\";\n                $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n                if ($gresult < 1) {\n                    $data = array(\n                    'qid' => $answer['qid'],\n                    'code' => $answer['code'],\n                    'answer' => $answer['answer'],\n                    'scale_id' => $answer['scale_id'],\n                    'sortorder' => $answer['sortorder'],\n                    'language' => $lang,\n                    'assessment_value' =>  $answer['assessment_value']\n                    );\n                    Yii::app()->db->createCommand()->insert('{{answers}}', $data);\n                }\n            }\n            reset($langs);\n        }\n    }\n    /* Remove invalid question : can break survey */\n    Survey::model()->findByPk($sid)->fixInvalidQuestions();\n\n    $query = \"SELECT * FROM {{assessments}} WHERE sid='{$sid}' AND language='{$baselang}'\";\n    $result = Yii::app()->db->createCommand($query)->query();\n    foreach ($result->readAll() as $assessment) {\n        foreach ($langs as $lang) {\n            $query = \"SELECT count(id) FROM {{assessments}} WHERE sid='{$sid}' AND id='{$assessment['id']}' AND language='{$lang}'\";\n            $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n            if ($gresult < 1) {\n                $data = array(\n                'id' => $assessment['id'],\n                'sid' => $assessment['sid'],\n                'scope' => $assessment['scope'],\n                'gid' => $assessment['gid'],\n                'name' => $assessment['name'],\n                'minimum' => $assessment['minimum'],\n                'maximum' => $assessment['maximum'],\n                'message' => $assessment['message'],\n                'language' => $lang\n                );\n                Yii::app()->db->createCommand()->insert('{{assessments}}', $data);\n            }\n        }\n        reset($langs);\n    }\n\n\n    $query = \"SELECT * FROM {{quota_languagesettings}} join {{quota}} q on quotals_quota_id=q.id WHERE q.sid='{$sid}' AND quotals_language='{$baselang}'\";\n    $result = Yii::app()->db->createCommand($query)->query();\n    foreach ($result->readAll() as $qls) {\n        foreach ($langs as $lang) {\n            $query = \"SELECT count(quotals_id) FROM {{quota_languagesettings}} WHERE quotals_quota_id='{$qls['quotals_quota_id']}' AND quotals_language='{$lang}'\";\n            $gresult = Yii::app()->db->createCommand($query)->queryScalar();\n            if ($gresult < 1) {\n                $data = array(\n                'quotals_quota_id' => $qls['quotals_quota_id'],\n                'quotals_name' => $qls['quotals_name'],\n                'quotals_message' => $qls['quotals_message'],\n                'quotals_url' => $qls['quotals_url'],\n                'quotals_urldescrip' => $qls['quotals_urldescrip'],\n                'quotals_language' => $lang\n                );\n                Yii::app()->db->createCommand()->insert('{{quota_languagesettings}}', $data);\n            }\n        }\n        reset($langs);\n    }\n\n    return true;\n}\n\n/**\n* This function switches identity insert on/off for the MSSQL database\n*\n* @param string $table table name (without prefix)\n* @param boolean $state  Set to true to activate ID insert, or false to deactivate\n*/\nfunction switchMSSQLIdentityInsert($table, $state)\n{\n    if (in_array(Yii::app()->db->getDriverName(), array('mssql', 'sqlsrv', 'dblib'))) {\n        if ($state === true) {\n            // This needs to be done directly on the PDO object because when using CdbCommand or similar it won't have any effect\n            Yii::app()->db->pdoInstance->exec('SET IDENTITY_INSERT '.Yii::app()->db->tablePrefix.$table.' ON');\n        } else {\n            // This needs to be done directly on the PDO object because when using CdbCommand or similar it won't have any effect\n            Yii::app()->db->pdoInstance->exec('SET IDENTITY_INSERT '.Yii::app()->db->tablePrefix.$table.' OFF');\n        }\n    }\n}\n\n/**\n * Retrieves the last Insert ID realiable for cross-DB applications\n *\n * @param string $sTableName Needed for Postgres and MSSQL\n * @return string\n */\nfunction getLastInsertID($sTableName)\n{\n    $sDBDriver = Yii::app()->db->getDriverName();\n    if ($sDBDriver == 'mysql' || $sDBDriver == 'mysqli') {\n        return Yii::app()->db->getLastInsertID();\n    } else {\n        return Yii::app()->db->getCommandBuilder()->getLastInsertID($sTableName);\n    }\n}\n\n// TMSW Condition->Relevance:  This function is not needed?  Optionally replace this with call to EM to get similar info\n/**\n* getGroupDepsForConditions() get Dependencies between groups caused by conditions\n* @param string $sid - the currently selected survey\n* @param string $depgid - (optionnal) get only the dependencies applying to the group with gid depgid\n* @param string $targgid - (optionnal) get only the dependencies for groups dependents on group targgid\n* @param string $indexby - (optionnal) \"by-depgid\" for result indexed with $res[$depgid][$targgid]\n*                   \"by-targgid\" for result indexed with $res[$targgid][$depgid]\n* @return array - returns an array describing the conditions or NULL if no dependecy is found\n*\n* Example outupt assumin $index-by=\"by-depgid\":\n*Array\n*(\n*    [125] => Array             // Group Id 125 is dependent on\n*        (\n*            [123] => Array         // Group Id 123\n*                (\n*                    [depgpname] => G3      // GID-125 has name G3\n*                    [targetgpname] => G1   // GID-123 has name G1\n*                    [conditions] => Array\n*                        (\n*                            [189] => Array // Because Question Id 189\n*                                (\n*                                    [0] => 9   // Have condition 9 set\n*                                    [1] => 10  // and condition 10 set\n*                                    [2] => 14  // and condition 14 set\n*                                )\n*\n*                        )\n*\n*                )\n*\n*            [124] => Array         // GID 125 is also dependent on GID 124\n*                (\n*                    [depgpname] => G3\n*                    [targetgpname] => G2\n*                    [conditions] => Array\n*                        (\n*                            [189] => Array // Because Question Id 189 have conditions set\n*                                (\n*                                    [0] => 11\n*                                )\n*\n*                            [215] => Array // And because Question Id 215 have conditions set\n*                                (\n*                                    [0] => 12\n*                                )\n*\n*                        )\n*\n*                )\n*\n*        )\n*\n*)\n*\n* Usage example:\n*   * Get all group dependencies for SID $sid indexed by depgid:\n*       $result=getGroupDepsForConditions($sid);\n*   * Get all group dependencies for GID $gid in survey $sid indexed by depgid:\n*       $result=getGroupDepsForConditions($sid,$gid);\n*   * Get all group dependents on group $gid in survey $sid indexed by targgid:\n*       $result=getGroupDepsForConditions($sid,\"all\",$gid,\"by-targgid\");\n*/\nfunction getGroupDepsForConditions($sid, $depgid = \"all\", $targgid = \"all\", $indexby = \"by-depgid\")\n{\n    $sid = sanitize_int($sid);\n    $condarray = Array();\n    $sqldepgid = \"\";\n    $sqltarggid = \"\";\n    if ($depgid != \"all\") { $depgid = sanitize_int($depgid); $sqldepgid = \"AND tq.gid=$depgid\"; }\n    if ($targgid != \"all\") {$targgid = sanitize_int($targgid); $sqltarggid = \"AND tq2.gid=$targgid\"; }\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $condquery = \"SELECT tg.gid as depgid, tg.group_name as depgpname, \"\n    . \"tg2.gid as targgid, tg2.group_name as targgpname, tq.qid as depqid, tc.cid FROM \"\n    . \"{{conditions}} AS tc, \"\n    . \"{{questions}} AS tq, \"\n    . \"{{questions}} AS tq2, \"\n    . \"{{groups}} AS tg ,\"\n    . \"{{groups}} AS tg2 \"\n    . \"WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tg.language='{$baselang}' AND tg2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid=$sid \"\n    . \"AND tq.gid = tg.gid AND tg2.gid = tq2.gid \"\n    . \"AND tq2.qid=tc.cqid AND tq.gid != tg2.gid $sqldepgid $sqltarggid\";\n    $condresult = Yii::app()->db->createCommand($condquery)->query()->readAll();\n\n    if (count($condresult) > 0) {\n        foreach ($condresult as $condrow) {\n\n            switch ($indexby) {\n                case \"by-depgid\":\n                    $depgid = $condrow['depgid'];\n                    $targetgid = $condrow['targgid'];\n                    $depqid = $condrow['depqid'];\n                    $cid = $condrow['cid'];\n                    $condarray[$depgid][$targetgid]['depgpname'] = $condrow['depgpname'];\n                    $condarray[$depgid][$targetgid]['targetgpname'] = $condrow['targgpname'];\n                    $condarray[$depgid][$targetgid]['conditions'][$depqid][] = $cid;\n                    break;\n\n                case \"by-targgid\":\n                    $depgid = $condrow['depgid'];\n                    $targetgid = $condrow['targgid'];\n                    $depqid = $condrow['depqid'];\n                    $cid = $condrow['cid'];\n                    $condarray[$targetgid][$depgid]['depgpname'] = $condrow['depgpname'];\n                    $condarray[$targetgid][$depgid]['targetgpname'] = $condrow['targgpname'];\n                    $condarray[$targetgid][$depgid]['conditions'][$depqid][] = $cid;\n                    break;\n            }\n        }\n        return $condarray;\n    }\n    return null;\n}\n\n// TMSW Condition->Relevance:  This function is not needed?  Optionally replace this with call to EM to get similar info\n/**\n* getQuestDepsForConditions() get Dependencies between groups caused by conditions\n* @param string $sid - the currently selected survey\n* @param string $gid - (optionnal) only search dependecies inside the Group Id $gid\n* @param string $depqid - (optionnal) get only the dependencies applying to the question with qid depqid\n* @param string $targqid - (optionnal) get only the dependencies for questions dependents on question Id targqid\n* @param string $indexby - (optionnal) \"by-depqid\" for result indexed with $res[$depqid][$targqid]\n*                   \"by-targqid\" for result indexed with $res[$targqid][$depqid]\n* @return array - returns an array describing the conditions or NULL if no dependecy is found\n*\n* Example outupt assumin $index-by=\"by-depqid\":\n*Array\n*(\n*    [184] => Array     // Question Id 184\n*        (\n*            [183] => Array // Depends on Question Id 183\n*                (\n*                    [0] => 5   // Because of condition Id 5\n*                )\n*\n*        )\n*\n*)\n*\n* Usage example:\n*   * Get all questions dependencies for Survey $sid and group $gid indexed by depqid:\n*       $result=getQuestDepsForConditions($sid,$gid);\n*   * Get all questions dependencies for question $qid in survey/group $sid/$gid indexed by depqid:\n*       $result=getGroupDepsForConditions($sid,$gid,$qid);\n*   * Get all questions dependents on question $qid in survey/group $sid/$gid indexed by targqid:\n*       $result=getGroupDepsForConditions($sid,$gid,\"all\",$qid,\"by-targgid\");\n*/\nfunction getQuestDepsForConditions($sid, $gid = \"all\", $depqid = \"all\", $targqid = \"all\", $indexby = \"by-depqid\", $searchscope = \"samegroup\")\n{\n\n    $condarray = Array();\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n    $sqlgid = \"\";\n    $sqldepqid = \"\";\n    $sqltargqid = \"\";\n    $sqlsearchscope = \"\";\n    if ($gid != \"all\") {$gid = sanitize_int($gid); $sqlgid = \"AND tq.gid=$gid\"; }\n    if ($depqid != \"all\") {$depqid = sanitize_int($depqid); $sqldepqid = \"AND tq.qid=$depqid\"; }\n    if ($targqid != \"all\") {$targqid = sanitize_int($targqid); $sqltargqid = \"AND tq2.qid=$targqid\"; }\n    if ($searchscope == \"samegroup\") {$sqlsearchscope = \"AND tq2.gid=tq.gid\"; }\n\n    $condquery = \"SELECT tq.qid as depqid, tq2.qid as targqid, tc.cid\n    FROM {{conditions}} AS tc, {{questions}} AS tq, {{questions}} AS tq2\n    WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid='$sid'\n    AND  tq2.qid=tc.cqid $sqlsearchscope $sqlgid $sqldepqid $sqltargqid\";\n    $condresult = Yii::app()->db->createCommand($condquery)->query()->readAll();\n    if (count($condresult) > 0) {\n        foreach ($condresult as $condrow) {\n            $depqid = $condrow['depqid'];\n            $targetqid = $condrow['targqid'];\n            $condid = $condrow['cid'];\n            switch ($indexby) {\n                case \"by-depqid\":\n                    $condarray[$depqid][$targetqid][] = $condid;\n                    break;\n\n                case \"by-targqid\":\n                    $condarray[$targetqid][$depqid][] = $condid;\n                    break;\n            }\n        }\n        return $condarray;\n    }\n    return null;\n}\n\n// TMSW Condition->Relevance:  This function is not needed - could replace with a message from EM output.\n/**\n* checkMoveQuestionConstraintsForConditions()\n* @param string $sid - the currently selected survey\n* @param string $qid - qid of the question you want to check possible moves\n* @param string $newgid - (optionnal) get only constraints when trying to move to this particular GroupId\n*                                     otherwise, get all moves constraints for this question\n*\n* @return array - returns an array describing the conditions\n*                 Array\n*                 (\n*                   ['notAbove'] = null | Array\n*                       (\n*                         Array ( gid1, group_order1, qid1, cid1 )\n*                       )\n*                   ['notBelow'] = null | Array\n*                       (\n*                         Array ( gid2, group_order2, qid2, cid2 )\n*                       )\n*                 )\n*\n* This should be read as:\n*    - this question can't be move above group gid1 in position group_order1 because of the condition cid1 on question qid1\n*    - this question can't be move below group gid2 in position group_order2 because of the condition cid2 on question qid2\n*\n*/\nfunction checkMoveQuestionConstraintsForConditions($sid, $qid, $newgid = \"all\")\n{\n\n    $resarray = Array();\n    $resarray['notAbove'] = null; // defaults to no constraint\n    $resarray['notBelow'] = null; // defaults to no constraint\n    $sid = sanitize_int($sid);\n    $qid = sanitize_int($qid);\n\n    if ($newgid != \"all\") {\n        $newgid = sanitize_int($newgid);\n        $newgorder = getGroupOrder($sid, $newgid);\n    } else {\n        $newgorder = ''; // Not used in this case\n    }\n\n    $baselang = Survey::model()->findByPk($sid)->language;\n\n    // First look for 'my dependencies': questions on which I have set conditions\n    $condquery = \"SELECT tq.qid as depqid, tq.gid as depgid, tg.group_order as depgorder, \"\n    . \"tq2.qid as targqid, tq2.gid as targgid, tg2.group_order as targgorder, \"\n    . \"tc.cid FROM \"\n    . \"{{conditions}} AS tc, \"\n    . \"{{questions}} AS tq, \"\n    . \"{{questions}} AS tq2, \"\n    . \"{{groups}} AS tg, \"\n    . \"{{groups}} AS tg2 \"\n    . \"WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid=$sid \"\n    . \"AND  tq2.qid=tc.cqid AND tg.gid=tq.gid AND tg2.gid=tq2.gid AND tq.qid=$qid ORDER BY tg2.group_order DESC\";\n\n    $condresult = Yii::app()->db->createCommand($condquery)->query();\n\n    foreach ($condresult->readAll() as $condrow) {\n        // This Question can go up to the minimum GID on the 1st row\n        $depqid = $condrow['depqid'];\n        $targetgid = $condrow['targgid'];\n        $targetgorder = $condrow['targgorder'];\n        $condid = $condrow['cid'];\n        if ($newgid != \"all\") {\n        // Get only constraints when trying to move to this group\n            if ($newgorder < $targetgorder) {\n                $resarray['notAbove'][] = Array($targetgid, $targetgorder, $depqid, $condid);\n            }\n        } else {\n        // get all moves constraints\n            $resarray['notAbove'][] = Array($targetgid, $targetgorder, $depqid, $condid);\n        }\n    }\n\n    // Secondly look for 'questions dependent on me': questions that have conditions on my answers\n    $condquery = \"SELECT tq.qid as depqid, tq.gid as depgid, tg.group_order as depgorder, \"\n    . \"tq2.qid as targqid, tq2.gid as targgid, tg2.group_order as targgorder, \"\n    . \"tc.cid FROM {{conditions}} AS tc, \"\n    . \"{{questions}} AS tq, \"\n    . \"{{questions}} AS tq2, \"\n    . \"{{groups}} AS tg, \"\n    . \"{{groups}} AS tg2 \"\n    . \"WHERE tq.language='{$baselang}' AND tq2.language='{$baselang}' AND tc.qid = tq.qid AND tq.sid=$sid \"\n    . \"AND  tq2.qid=tc.cqid AND tg.gid=tq.gid AND tg2.gid=tq2.gid AND tq2.qid=$qid ORDER BY tg.group_order\";\n\n    $condresult = Yii::app()->db->createCommand($condquery)->query();\n\n    foreach ($condresult->readAll() as $condrow) {\n        // This Question can go down to the maximum GID on the 1st row\n        $depqid = $condrow['depqid'];\n        $depgid = $condrow['depgid'];\n        $depgorder = $condrow['depgorder'];\n        $condid = $condrow['cid'];\n        if ($newgid != \"all\") {\n        // Get only constraints when trying to move to this group\n            if ($newgorder > $depgorder) {\n                $resarray['notBelow'][] = Array($depgid, $depgorder, $depqid, $condid);\n            }\n        } else {\n        // get all moves constraints\n            $resarray['notBelow'][] = Array($depgid, $depgorder, $depqid, $condid);\n        }\n    }\n    return $resarray;\n}\n\n/**\n* Get a list of all user groups\n* @returns array\n*/\nfunction getUserGroupList()\n{\n    $sQuery = \"SELECT distinct a.ugid, a.name, a.owner_id FROM {{user_groups}} AS a LEFT JOIN {{user_in_groups}} AS b ON a.ugid = b.ugid WHERE 1=1 \";\n    if (!Permission::model()->hasGlobalPermission('superadmin', 'read')) {\n        $sQuery .= \"AND uid = \".Yii::app()->session['loginID'];\n    }\n    $sQuery .= \" ORDER BY name\";\n\n    $sresult = Yii::app()->db->createCommand($sQuery)->query(); //Checked\n    if (!$sresult) {return \"Database Error\"; }\n    $aGroupNames = [];\n    foreach ($sresult->readAll() as $row) {\n        $aGroupNames[] = $row;\n    }\n    $simplegidarray = array();\n    if (isset($aGroupNames)) {\n        foreach ($aGroupNames as $gn) {\n            $simplegidarray[] = $gn['ugid'];\n        }\n    }\n    return $simplegidarray;\n}\n\n// TODO use Yii model forms\nfunction getGroupUserList($ugid)\n{\n    Yii::app()->loadHelper('database');\n\n\n    $ugid = sanitize_int($ugid);\n    $surveyidquery = \"SELECT a.uid, a.users_name, a.full_name FROM {{users}} AS a LEFT JOIN (SELECT uid AS id FROM {{user_in_groups}} WHERE ugid = {$ugid}) AS b ON a.uid = b.id WHERE id IS NULL ORDER BY a.users_name\";\n\n    $surveyidresult = dbExecuteAssoc($surveyidquery); //Checked\n    if (!$surveyidresult) {return \"Database Error\"; }\n    $surveyselecter = \"\";\n    $aSurveyNames = [];\n    foreach ($surveyidresult->readAll() as $row) {\n        $aSurveyNames[] = $row;\n    }\n    //$surveynames = $surveyidresult->GetRows();\n    if (isset($aSurveyNames)) {\n        foreach ($aSurveyNames as $sv) {\n            $surveyselecter .= \"<option\";\n            $surveyselecter .= \" value='{$sv['uid']}'>\".\\CHtml::encode($sv['users_name']).\" (\".\\CHtml::encode($sv['full_name']).\")</option>\\n\";\n        }\n    }\n    $surveyselecter = \"<option value='-1' selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    return $surveyselecter;\n}\n\n/**\n* Run an arbitrary sequence of semicolon-delimited SQL commands\n*\n* Assumes that the input text (file or string) consists of\n* a number of SQL statements ENDING WITH SEMICOLONS.  The\n* semicolons MUST be the last character in a line.\n* Lines that are blank or that start with \"#\" or \"--\" (postgres) are ignored.\n* Only tested with mysql dump files (mysqldump -p -d limesurvey)\n* Function kindly borrowed by Moodle\n* @param string $sqlfile The path where a file with sql commands can be found on the server.\n* @param string $sqlstring If no path is supplied then a string with semicolon delimited sql\n* commands can be supplied in this argument.\n* @return bool Returns true if database was modified successfully.\n*/\nfunction modifyDatabase($sqlfile = '', $sqlstring = '')\n{\n    Yii::app()->loadHelper('database');\n\n\n    global $siteadminemail;\n    global $siteadminname;\n    global $codeString;\n    global $modifyoutput;\n\n    $success = true; // Let's be optimistic\n    $modifyoutput = '';\n    $lines = [];\n    if (!empty($sqlfile)) {\n        if (!is_readable($sqlfile)) {\n            $success = false;\n            echo '<p>Tried to modify database, but \"'.$sqlfile.'\" doesn\\'t exist!</p>';\n            return $success;\n        } else {\n            $lines = file($sqlfile);\n        }\n    } else {\n        $sqlstring = trim($sqlstring);\n        if ($sqlstring{strlen($sqlstring) - 1} != \";\") {\n            $sqlstring .= \";\"; // add it in if it's not there.\n        }\n        $lines[] = $sqlstring;\n    }\n\n    $command = '';\n\n    foreach ($lines as $line) {\n        $line = rtrim($line);\n        $length = strlen($line);\n\n        if ($length and $line[0] <> '#' and substr($line, 0, 2) <> '--') {\n            if (substr($line, $length - 1, 1) == ';') {\n                $line = substr($line, 0, $length - 1); // strip ;\n                $command .= $line;\n                $command = str_replace('prefix_', Yii::app()->db->tablePrefix, $command); // Table prefixes\n                $command = str_replace('$defaultuser', Yii::app()->getConfig('defaultuser'), $command);\n                $command = str_replace('$defaultpass', hash('sha256', Yii::app()->getConfig('defaultpass')), $command);\n                $command = str_replace('$siteadminname', $siteadminname, $command);\n                $command = str_replace('$siteadminemail', $siteadminemail, $command);\n                $command = str_replace('$defaultlang', Yii::app()->getConfig('defaultlang'), $command);\n                $command = str_replace('$databasetabletype', Yii::app()->db->getDriverName(), $command);\n\n                try\n                {   Yii::app()->db->createCommand($command)->query(); //Checked\n                    $command = htmlspecialchars($command);\n                    $modifyoutput .= \". \";\n                } catch (CDbException $e) {\n                    $command = htmlspecialchars($command);\n                    $modifyoutput .= \"<br />\".sprintf(gT(\"SQL command failed: %s\"), \"<span style='font-size:10px;'>\".$command.\"</span>\", \"<span style='color:#ee0000;font-size:10px;'></span><br/>\");\n                    $success = false;\n                }\n\n                $command = '';\n            } else {\n                $command .= $line;\n            }\n        }\n    }\n\n    return $success;\n\n}\n\n/**\n* Returns labelsets for given language(s), or for all if null\n*\n* @param string $languages\n* @return array\n*/\nfunction getLabelSets($languages = null)\n{\n    $aLanguages = array();\n    if (!empty($languages)) {\n        $languages = sanitize_languagecodeS($languages);\n        $aLanguages = explode(' ', trim($languages));\n    }\n\n    $criteria = new CDbCriteria;\n    $criteria->order = \"label_name\";\n    foreach ($aLanguages as $k => $item) {\n        $criteria->params[':lang_like1_'.$k] = \"% $item %\";\n        $criteria->params[':lang_'.$k] = $item;\n        $criteria->params[':lang_like2_'.$k] = \"% $item\";\n        $criteria->params[':lang_like3_'.$k] = \"$item %\";\n        $criteria->addCondition(\"\n        ((languages like :lang_like1_$k) or\n        (languages = :lang_$k) or\n        (languages like :lang_like2_$k) or\n        (languages like :lang_like3_$k))\");\n    }\n\n    $result = LabelSet::model()->findAll($criteria);\n    $labelsets = array();\n    foreach ($result as $row) {\n            $labelsets[] = array($row->lid, $row->label_name);\n    }\n    return $labelsets;\n}\n\n/**\n * get the header\n * @param bool $meta : not used in any call (2016-10-18)\n * @return string\n */\nfunction getHeader($meta = false)\n{\n    /* Todo : move this to layout/public.html */\n    global $surveyid;\n    Yii::app()->loadHelper('surveytranslator');\n\n    // Set Langage // TODO remove one of the Yii::app()->session see bug #5901\n    if (Yii::app()->session['survey_'.$surveyid]['s_lang']) {\n        $languagecode = Yii::app()->session['survey_'.$surveyid]['s_lang'];\n    } elseif (isset($surveyid) && $surveyid && Survey::model()->findByPk($surveyid)) {\n        $languagecode = Survey::model()->findByPk($surveyid)->language;\n    } else {\n        $languagecode = Yii::app()->getConfig('defaultlang');\n    }\n    $header = \"<!DOCTYPE html>\\n\";\n    $class = \"no-js $languagecode\";\n    $header .= \"<html lang=\\\"{$languagecode}\\\"\";\n\n    if (getLanguageRTL($languagecode)) {\n        $header .= \" dir=\\\"rtl\\\" \";\n        $class .= \" dir-rtl\";\n    } else {\n        $header .= \" dir=\\\"ltr\\\" \";\n        $class .= \" dir-ltr\";\n    }\n    $header .= \" class=\\\"{$class}\\\">\\n\";\n    $header .= \"\\t<head>\\n\";\n    Yii::app()->clientScript->registerScriptFile(Yii::app()->getConfig(\"generalscripts\").'nojs.js', CClientScript::POS_HEAD);\n    if ($meta) {\n            $header .= $meta;\n    }\n    return $header;\n}\n\n\nfunction doHeader()\n{\n    echo getHeader();\n}\n\n/**\n* This function returns the header for the printable survey\n* @return String\n*\n*/\nfunction getPrintableHeader()\n{\n    global $rooturl, $homeurl;\n    $headelements = App()->getController()->renderPartial('/survey/system/print_survey/header', array(), true, true);\n    return $headelements;\n}\n\n/**\n * This function returns the Footer as result string\n * If you want to echo the Footer use doFooter()!\n * @return string\n */\nfunction getFooter()\n{\n    return \"\\n\\n\\t</body>\\n</html>\\n\";\n}\n\nfunction doFooter()\n{\n    echo getFooter();\n}\n\n\n\n/**\n* Retrieve a HTML <OPTION> list of survey admin users\n*\n* @param boolean $bIncludeOwner If the survey owner should be included\n* @param boolean $bIncludeSuperAdmins If Super admins should be included\n* @param int $surveyid\n* @return string\n*/\nfunction getSurveyUserList($bIncludeSuperAdmins = true, $surveyid)\n{\n\n    $surveyid = (int) $surveyid;\n\n    $sSurveyIDQuery = \"SELECT a.uid, a.users_name, a.full_name FROM {{users}} AS a\n    LEFT OUTER JOIN (SELECT uid AS id FROM {{permissions}} WHERE entity_id = {$surveyid} and entity='survey') AS b ON a.uid = b.id\n    WHERE id IS NULL \";\n    if (!$bIncludeSuperAdmins) {\n        // @todo: Adjust for new permission system - not urgent since it it just display\n        //   $sSurveyIDQuery.='and superadmin=0 ';\n    }\n    $sSurveyIDQuery .= 'ORDER BY a.users_name';\n    $oSurveyIDResult = Yii::app()->db->createCommand($sSurveyIDQuery)->query(); //Checked\n    $aSurveyIDResult = $oSurveyIDResult->readAll();\n\n    $surveyselecter = \"\";\n    $authorizedUsersList = [];\n\n    if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == true) {\n        $authorizedUsersList = getUserList('onlyuidarray');\n    }\n\n    $svexist = false;\n    foreach ($aSurveyIDResult as $sv) {\n        if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == false ||\n            in_array($sv['uid'], $authorizedUsersList)) {\n            $surveyselecter .= \"<option\";\n            $surveyselecter .= \" value='{$sv['uid']}'>\".\\CHtml::encode($sv['users_name']).\" \".\\CHtml::encode($sv['full_name']).\"</option>\\n\";\n            $svexist = true;\n        }\n    }\n\n    if ($svexist) {\n        $surveyselecter = \"<option value='-1' selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    } else {\n        $surveyselecter = \"<option value='-1'>\".gT(\"None\").\"</option>\\n\".$surveyselecter;\n    }\n\n    return $surveyselecter;\n}\n\n/**\n * Return HTML <option> list of user groups\n * @param string $outputformat\n * @param int $surveyid\n * @return string|array \n */\nfunction getSurveyUserGroupList($outputformat = 'htmloptions', $surveyid)\n{\n\n    $surveyid = sanitize_int($surveyid);\n\n    $surveyidquery = \"SELECT a.ugid, a.name, MAX(d.ugid) AS da\n    FROM {{user_groups}} AS a\n    LEFT JOIN (\n    SELECT b.ugid\n    FROM {{user_in_groups}} AS b\n    LEFT JOIN (SELECT * FROM {{permissions}}\n    WHERE entity_id = {$surveyid} and entity='survey') AS c ON b.uid = c.uid WHERE c.uid IS NULL\n    ) AS d ON a.ugid = d.ugid GROUP BY a.ugid, a.name HAVING MAX(d.ugid) IS NOT NULL\";\n    $surveyidresult = Yii::app()->db->createCommand($surveyidquery)->query(); //Checked\n    $aResult = $surveyidresult->readAll();\n\n    $authorizedGroupsList = [];\n    if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == true) {\n        $authorizedGroupsList = getUserGroupList();\n    }\n\n    $svexist = false;\n    $surveyselecter = \"\";\n    $simpleugidarray = [];\n    foreach ($aResult as $sv) {\n        if (Yii::app()->getConfig('usercontrolSameGroupPolicy') == false ||\n        in_array($sv['ugid'], $authorizedGroupsList)) {\n            $surveyselecter .= \"<option\";\n            $surveyselecter .= \" value='{$sv['ugid']}'>{$sv['name']}</option>\\n\";\n            $simpleugidarray[] = $sv['ugid'];\n            $svexist = true;\n        }\n    }\n\n    if ($svexist) {\n        $surveyselecter = \"<option value='-1' selected='selected'>\".gT(\"Please choose...\").\"</option>\\n\".$surveyselecter;\n    } else {\n        $surveyselecter = \"<option value='-1'>\".gT(\"None\").\"</option>\\n\".$surveyselecter;\n    }\n\n    if ($outputformat == 'simpleugidarray') {\n        return $simpleugidarray;\n    } else {\n        return $surveyselecter;\n    }\n}\n\n\n\n/**\n* This function fixes the group ID and type on all subquestions\n* Optimized for minimum memory usage even on huge databases\n*/\nfunction fixSubquestions()\n{\n    $surveyidresult = Yii::app()->db->createCommand()\n    ->select('sq.qid, q.gid , q.type ')\n    ->from('{{questions}} sq')\n    ->join('{{questions}} q', 'sq.parent_qid=q.qid')\n    ->where('sq.parent_qid>0 AND (sq.gid!=q.gid or sq.type!=q.type)')\n    ->limit(10000)\n    ->query();\n    $aRecords = $surveyidresult->readAll();\n    while (count($aRecords) > 0) {\n        foreach ($aRecords as $sv) {\n            Yii::app()->db->createCommand(\"update {{questions}} set type='{$sv['type']}', gid={$sv['gid']} where qid={$sv['qid']}\")->execute();\n        }\n        $surveyidresult = Yii::app()->db->createCommand()\n        ->select('sq.qid, q.gid , q.type ')\n        ->from('{{questions}} sq')\n        ->join('{{questions}} q', 'sq.parent_qid=q.qid')\n        ->where('sq.parent_qid>0 AND (sq.gid!=q.gid or sq.type!=q.type)')\n        ->limit(10000)\n        ->query();\n        $aRecords = $surveyidresult->readAll();\n    }\n\n}\n\n/**\n* Must use ls_json_encode to json_encode content, otherwise LimeExpressionManager will think that the associative arrays are expressions and try to parse them.\n*/\nfunction ls_json_encode($content)\n{\n    if (is_string($content) && get_magic_quotes_gpc()) {\n        $content = stripslashes($content);\n    }\n    $ans = json_encode($content);\n    $ans = str_replace(array('{', '}'), array('{ ', ' }'), $ans);\n    return $ans;\n}\n\n/**\n * Decode a json string, sometimes needs stripslashes\n *\n * @param string $jsonString\n * @return mixed\n */\nfunction json_decode_ls($jsonString)\n{\n    $decoded = json_decode($jsonString, true);\n\n    if (is_null($decoded) && !empty($jsonString)) {\n        // probably we need stipslahes\n        $decoded = json_decode(stripslashes($jsonString), true);\n    }\n\n    return $decoded;\n}\n\n/**\n * Return accepted codingsArray for importing files\n *\n * Used in vvimport\n * TODO : use in token and\n * @return array\n */\nfunction aEncodingsArray()\n{\n        $aEncodings = array(\n        \"armscii8\" => gT(\"ARMSCII-8 Armenian\"),\n        \"ascii\" => gT(\"US ASCII\"),\n        \"big5\" => gT(\"Big5 Traditional Chinese\"),\n        \"binary\" => gT(\"Binary pseudo charset\"),\n        \"cp1250\" => gT(\"Windows Central European (Windows-1250)\"),\n        \"cp1251\" => gT(\"Windows Cyrillic (Windows-1251)\"),\n        \"cp1256\" => gT(\"Windows Arabic (Windows-1256)\"),\n        \"cp1257\" => gT(\"Windows Baltic (Windows-1257)\"),\n        \"cp850\" => gT(\"DOS West European (cp850)\"),\n        \"cp852\" => gT(\"DOS Central European (cp852)\"),\n        \"cp866\" => gT(\"DOS Cyrillic (cp866)\"),\n        \"cp932\" => gT(\"Windows-31J - SJIS for Windows Japanese (cp932)\"),\n        \"dec8\" => gT(\"DEC West European\"),\n        \"eucjpms\" => gT(\"UJIS for Windows Japanese\"),\n        \"euckr\" => gT(\"EUC-KR Korean\"),\n        \"gb2312\" => gT(\"GB2312 Simplified Chinese\"),\n        \"gbk\" => gT(\"GBK Simplified Chinese\"),\n        \"geostd8\" => gT(\"GEOSTD8 Georgian\"),\n        \"greek\" => gT(\"ISO 8859-7 Greek\"),\n        \"hebrew\" => gT(\"ISO 8859-8 Hebrew\"),\n        \"hp8\" => gT(\"HP West European\"),\n        \"keybcs2\" => gT(\"DOS Kamenicky Czech-Slovak (cp895)\"),\n        \"koi8r\" => gT(\"KOI8-R Relcom Russian\"),\n        \"koi8u\" => gT(\"KOI8-U Ukrainian\"),\n        \"latin1\" => gT(\"ISO 8859-1 West European (latin1)\"),\n        \"latin2\" => gT(\"ISO 8859-2 Central European (latin2)\"),\n        \"latin5\" => gT(\"ISO 8859-9 Turkish (latin5)\"),\n        \"latin7\" => gT(\"ISO 8859-13 Baltic (latin7)\"),\n        \"macce\" => gT(\"Mac Central European\"),\n        \"macroman\" => gT(\"Mac West European\"),\n        \"sjis\" => gT(\"Shift-JIS Japanese\"),\n        \"swe7\" => gT(\"7bit Swedish\"),\n        \"tis620\" => gT(\"TIS620 Thai\"),\n        \"ucs2\" => gT(\"UCS-2 Unicode\"),\n        \"ujis\" => gT(\"EUC-JP Japanese\"),\n        \"utf8\" => gT(\"UTF-8 Unicode\"),\n        );\n        // Sort list of encodings\n        asort($aEncodings);\n        $aEncodings = array(\"auto\" => gT(\"(Automatic)\")) + $aEncodings;\n        return $aEncodings;\n    }\n\n\n/**\n* Ellipsize String\n*\n* This public static function will strip tags from a string, split it at its max_length and ellipsize\n*\n* @param    string  $sString        string to ellipsize\n* @param    integer $iMaxLength       max length of string\n* @param    integer   $fPosition       int (1|0) or float, .5, .2, etc for position to split\n* @param    string  $sEllipsis      ellipsis ; Default '...'\n* @return    string        ellipsized string\n*/\nfunction ellipsize($sString, $iMaxLength, $fPosition = 1, $sEllipsis = '&hellip;')\n{\n    // Strip tags\n    $sString = trim(strip_tags($sString));\n    // Is the string long enough to ellipsize?\n    if (mb_strlen($sString, 'UTF-8') <= $iMaxLength + 3) {\n        return $sString;\n    }\n\n    $iStrLen = mb_strlen($sString, 'UTF-8');\n    $sBegin = mb_substr($sString, 0, (int) floor($iMaxLength * $fPosition), 'UTF-8');\n    $sEnd = mb_substr($sString, $iStrLen - ($iMaxLength - mb_strlen($sBegin, 'UTF-8')), $iStrLen, 'UTF-8');\n    return $sBegin.$sEllipsis.$sEnd;\n}\n\n/**\n* This function tries to returns the 'real' IP address under all configurations\n* Do not rely security-wise on the detected IP address as except for REMOTE_ADDR all fields could be manipulated by the web client\n*/\nfunction getIPAddress()\n{\n    $sIPAddress = '127.0.0.1';\n    if (!empty($_SERVER['HTTP_CLIENT_IP']) && filter_var($_SERVER['HTTP_CLIENT_IP'], FILTER_VALIDATE_IP)!==false) {\n        //check IP address from share internet\n        $sIPAddress = $_SERVER['HTTP_CLIENT_IP'];\n    } elseif (!empty($_SERVER['HTTP_X_FORWARDED_FOR']) && filter_var($_SERVER['HTTP_X_FORWARDED_FOR'], FILTER_VALIDATE_IP)!==false) {\n        //Check IP address passed from proxy\n        $sIPAddress = $_SERVER['HTTP_X_FORWARDED_FOR'];\n    } elseif (!empty($_SERVER['REMOTE_ADDR']) && filter_var($_SERVER['REMOTE_ADDR'], FILTER_VALIDATE_IP)!==false) {\n        $sIPAddress = $_SERVER['REMOTE_ADDR'];\n    }\n    return $sIPAddress;\n}\n\n\n/**\n* This function tries to find out a valid language code for the language of the browser used\n* If it cannot find it it will return the default language from global settings\n*\n*/\nfunction getBrowserLanguage()\n{\n    $sLanguage = Yii::app()->getRequest()->getPreferredLanguage();\n    Yii::app()->loadHelper(\"surveytranslator\");\n    $aLanguages = getLanguageData();\n    if (!isset($aLanguages[$sLanguage])) {\n        $sLanguage = str_replace('_', '-', $sLanguage);\n        if (strpos($sLanguage, '-') !== false) {\n            $aLanguage = explode('-', $sLanguage);\n            $aLanguage[1] = strtoupper($aLanguage[1]);\n            $sLanguage = implode('-', $aLanguage);\n        }\n        if (!isset($aLanguages[$sLanguage])) {\n            $sLanguage = substr($sLanguage, 0, strpos($sLanguage, '-'));\n            if (!isset($aLanguages[$sLanguage])) {\n                $sLanguage = Yii::app()->getConfig('defaultlang');\n            }\n        }\n    }\n    return $sLanguage;\n}\n\nfunction array_diff_assoc_recursive($array1, $array2)\n{\n    $difference = array();\n    foreach ($array1 as $key => $value) {\n        if (is_array($value)) {\n            if (!isset($array2[$key]) || !is_array($array2[$key])) {\n                $difference[$key] = $value;\n            } else {\n                $new_diff = array_diff_assoc_recursive($value, $array2[$key]);\n                if (!empty($new_diff)) {\n                                    $difference[$key] = $new_diff;\n                }\n            }\n        } else if (!array_key_exists($key, $array2) || $array2[$key] !== $value) {\n            $difference[$key] = $value;\n        }\n    }\n    return $difference;\n}\n\n/**\n * Calculate folder size\n * NB: If this function is changed, please notify LimeSurvey GmbH.\n *     An exact copy of this function is used to calculate storage\n *     limit on LimeSurvey Pro hosting.\n * @param string $dir Folder\n * @return integer Size in bytes.\n */\nfunction folderSize($dir)\n{\n    $size = 0;\n    foreach (glob(rtrim($dir, '/').'/*', GLOB_NOSORT) as $each) {\n        if (is_file($each)) {\n            // NB: stat() can be used to calculate disk usage (instead\n            // of file size - it's not the same thing).\n            //$stat = stat($each);\n            //$tmpsize = $stat[11] * $stat[12] / 8;\n            //$size += $tmpsize;\n            $size += filesize($each);\n        } else {\n            $size += folderSize($each);\n        }\n    }\n    return $size;\n}\n\n/**\n * Format size in human readable format.\n * @param int $bytes\n * @param int $decimals\n * @return string\n */\nfunction humanFilesize($bytes, $decimals = 2)\n{\n    $sz = 'BKMGTP';\n    //$factor = floor((strlen($bytes) - 1) / 3);\n    $factor = 2;\n    $string = sprintf(\"%.{$decimals}f\", $bytes / pow(1024, $factor)).@$sz[$factor];\n    $aLangData = getLanguageData();\n    $radix = getRadixPointData($aLangData[Yii::app()->session['adminlang']]['radixpoint']);\n    return str_replace('.', $radix['separator'], $string);\n}\n\n/**\n* This function transforms the php.ini notation for numbers (like '2M') to an integer (2*1024*1024 in this case)\n* \n* @param string $sSize\n* @return integer The value in bytes\n*/\nfunction convertPHPSizeToBytes($sSize)\n{\n    //\n    $sSuffix = strtoupper(substr($sSize, -1));\n    if (!in_array($sSuffix, array('P', 'T', 'G', 'M', 'K'))) {\n        return (int) $sSize;  \n    } \n    $iValue = substr($sSize, 0, -1);\n    switch ($sSuffix) {\n        case 'P':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'T':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'G':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'M':\n            $iValue *= 1024;\n            // Fallthrough intended\n        case 'K':\n            $iValue *= 1024;\n            break;\n    }\n    return (int) $iValue;\n}\n\nfunction getMaximumFileUploadSize()\n{\n    return min(convertPHPSizeToBytes(ini_get('post_max_size')), convertPHPSizeToBytes(ini_get('upload_max_filesize')));\n}\n\n/**\n * Decodes token attribute data because due to bugs in the past it can be written in JSON or be serialized - future format should be JSON as serialized data can be exploited\n *\n * @param string $oTokenAttributeData The original token attributes as stored in the database\n * @return array|mixed\n */\nfunction decodeTokenAttributes($oTokenAttributeData)\n{\n    if (trim($oTokenAttributeData) == '') {\n        return array();\n    }\n    if (substr($oTokenAttributeData, 0, 1) != '{' && substr($oTokenAttributeData, 0, 1) != '[') {\n        $sSerialType = getSerialClass($oTokenAttributeData);\n        if ($sSerialType == 'array') {\n// Safe to decode\n            $aReturnData = @unserialize($oTokenAttributeData);\n        } else {\n// Something else, might be unsafe\n            return array();\n        }\n    } else {\n            $aReturnData = @json_decode($oTokenAttributeData, true);\n    }\n    if ($aReturnData === false || $aReturnData === null) {\n        return array();\n    }\n    return $aReturnData;\n}\n\n/**\n * @param string $sSerial\n * @return string|null\n */\nfunction getSerialClass($sSerial)\n{\n    $aTypes = array('s' => 'string', 'a' => 'array', 'b' => 'bool', 'i' => 'int', 'd' => 'float', 'N;' => 'NULL');\n\n    $aParts = explode(':', $sSerial, 4);\n    return isset($aTypes[$aParts[0]]) ? $aTypes[$aParts[0]] : (isset($aParts[2]) ? trim($aParts[2], '\"') : null);\n}\n\n/**\n* Force Yii to create a new CSRF token by removing the old one\n*\n*/\nfunction regenerateCSRFToken()\n{\n    // Expire the CSRF cookie\n    $cookie = new CHttpCookie('YII_CSRF_TOKEN', '');\n    $cookie->expire = time() - 3600;\n    Yii::app()->request->cookies['YII_CSRF_TOKEN'] = $cookie;\n}\n\n/**\n* A function to remove ../ or ./ from paths to prevent directory traversal\n*\n* @param mixed $path\n*/\nfunction get_absolute_path($path)\n{\n    $path = str_replace(array('/', '\\\\'), DIRECTORY_SEPARATOR, $path);\n    $parts = array_filter(explode(DIRECTORY_SEPARATOR, $path), 'strlen');\n    $absolutes = array();\n    foreach ($parts as $part) {\n        if ('.' == $part) {\n            continue;\n        }\n        if ('..' == $part) {\n            array_pop($absolutes);\n        } else {\n            $absolutes[] = $part;\n        }\n    }\n    return implode(DIRECTORY_SEPARATOR, $absolutes);\n}\n\n/**\n* Check if string is JSON array\n*\n* @param string $str\n* @return bool\n*/\nfunction isJson($str) {\n    $json = json_decode($str);\n    return $json && $str != $json;\n}\n\n/**\n* Check if array is associative\n*\n* @param array $array\n* @return bool\n*/\nfunction isAssociativeArray($array){\n    foreach ($array as $key => $value) {\n        if (is_string($key)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Test if a given zip file is Zip Bomb\n * see comment here : http://php.net/manual/en/function.zip-entry-filesize.php\n * @param string $zip_filename\n * @return int\n */\nfunction isZipBomb($zip_filename)\n{\n    return ( get_zip_originalsize($zip_filename) >  getMaximumFileUploadSize() );\n}\n\n/**\n * Get the original size of a zip archive to prevent Zip Bombing\n * see comment here : http://php.net/manual/en/function.zip-entry-filesize.php\n * @param string $filename\n * @return int\n */\nfunction get_zip_originalsize($filename) {\n\n    if ( function_exists ('zip_entry_filesize') ){\n        $size = 0;\n        $resource = zip_open($filename);\n        while ($dir_resource = zip_read($resource)) {\n            $size += zip_entry_filesize($dir_resource);\n        }\n        zip_close($resource);\n\n        return $size;\n    }else{\n        if ( YII_DEBUG ){\n            Yii::app()->setFlashMessage(gT(\"Warning! php zip extension is not installed on your server. You're not protected from Zip Bomb attaacks.\"), 'error');\n        }\n    }\n\n    return -1;\n}\n", "<?php\r\n// --------------------------------------------------------------------------------\r\n// PhpConcept Library - Zip Module 2.8.2\r\n// --------------------------------------------------------------------------------\r\n// License GNU/LGPL - Vincent Blavet - August 2009\r\n// http://www.phpconcept.net\r\n// --------------------------------------------------------------------------------\r\n//\r\n// Presentation :\r\n//   PclZip is a PHP library that manage ZIP archives.\r\n//   So far tests show that archives generated by PclZip are readable by\r\n//   WinZip application and other tools.\r\n//\r\n// Description :\r\n//   See readme.txt and http://www.phpconcept.net\r\n//\r\n// Warning :\r\n//   This library and the associated files are non commercial, non professional\r\n//   work.\r\n//   It should not have unexpected results. However if any damage is caused by\r\n//   this software the author can not be responsible.\r\n//   The use of this software is at the risk of the user.\r\n//\r\n// --------------------------------------------------------------------------------\r\n// $Id: pclzip.lib.php,v 1.60 2009/09/30 21:01:04 vblavet Exp $\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Constants\r\n  if (!defined('PCLZIP_READ_BLOCK_SIZE')) {\r\n    define( 'PCLZIP_READ_BLOCK_SIZE', 2048 );\r\n  }\r\n\r\n  // ----- File list separator\r\n  // In version 1.x of PclZip, the separator for file list is a space\r\n  // (which is not a very smart choice, specifically for windows paths !).\r\n  // A better separator should be a comma (,). This constant gives you the\r\n  // abilty to change that.\r\n  // However notice that changing this value, may have impact on existing\r\n  // scripts, using space separated filenames.\r\n  // Recommanded values for compatibility with older versions :\r\n  //define( 'PCLZIP_SEPARATOR', ' ' );\r\n  // Recommanded values for smart separation of filenames.\r\n  if (!defined('PCLZIP_SEPARATOR')) {\r\n    define( 'PCLZIP_SEPARATOR', ',' );\r\n  }\r\n\r\n  // ----- Error configuration\r\n  // 0 : PclZip Class integrated error handling\r\n  // 1 : PclError external library error handling. By enabling this\r\n  //     you must ensure that you have included PclError library.\r\n  // [2,...] : reserved for futur use\r\n  if (!defined('PCLZIP_ERROR_EXTERNAL')) {\r\n    define( 'PCLZIP_ERROR_EXTERNAL', 0 );\r\n  }\r\n\r\n  // ----- Optional static temporary directory\r\n  //       By default temporary files are generated in the script current\r\n  //       path.\r\n  //       If defined :\r\n  //       - MUST BE terminated by a '/'.\r\n  //       - MUST be a valid, already created directory\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_DIR', '/temp/' );\r\n  // define( 'PCLZIP_TEMPORARY_DIR', 'C:/Temp/' );\r\n  if (!defined('PCLZIP_TEMPORARY_DIR')) {\r\n    define( 'PCLZIP_TEMPORARY_DIR', '' );\r\n  }\r\n\r\n  // ----- Optional threshold ratio for use of temporary files\r\n  //       Pclzip sense the size of the file to add/extract and decide to\r\n  //       use or not temporary file. The algorythm is looking for\r\n  //       memory_limit of PHP and apply a ratio.\r\n  //       threshold = memory_limit * ratio.\r\n  //       Recommended values are under 0.5. Default 0.47.\r\n  //       Samples :\r\n  // define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.5 );\r\n  if (!defined('PCLZIP_TEMPORARY_FILE_RATIO')) {\r\n    define( 'PCLZIP_TEMPORARY_FILE_RATIO', 0.47 );\r\n  }\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE NOTHING NEEDS TO BE MODIFIED *****\r\n// --------------------------------------------------------------------------------\r\n\r\n  // ----- Global variables\r\n  $g_pclzip_version = \"2.8.2\";\r\n\r\n  // ----- Error codes\r\n  //   -1 : Unable to open file in binary write mode\r\n  //   -2 : Unable to open file in binary read mode\r\n  //   -3 : Invalid parameters\r\n  //   -4 : File does not exist\r\n  //   -5 : Filename is too long (max. 255)\r\n  //   -6 : Not a valid zip file\r\n  //   -7 : Invalid extracted file size\r\n  //   -8 : Unable to create directory\r\n  //   -9 : Invalid archive extension\r\n  //  -10 : Invalid archive format\r\n  //  -11 : Unable to delete file (unlink)\r\n  //  -12 : Unable to rename file (rename)\r\n  //  -13 : Invalid header checksum\r\n  //  -14 : Invalid archive size\r\n  define( 'PCLZIP_ERR_USER_ABORTED', 2 );\r\n  define( 'PCLZIP_ERR_NO_ERROR', 0 );\r\n  define( 'PCLZIP_ERR_WRITE_OPEN_FAIL', -1 );\r\n  define( 'PCLZIP_ERR_READ_OPEN_FAIL', -2 );\r\n  define( 'PCLZIP_ERR_INVALID_PARAMETER', -3 );\r\n  define( 'PCLZIP_ERR_MISSING_FILE', -4 );\r\n  define( 'PCLZIP_ERR_FILENAME_TOO_LONG', -5 );\r\n  define( 'PCLZIP_ERR_INVALID_ZIP', -6 );\r\n  define( 'PCLZIP_ERR_BAD_EXTRACTED_FILE', -7 );\r\n  define( 'PCLZIP_ERR_DIR_CREATE_FAIL', -8 );\r\n  define( 'PCLZIP_ERR_BAD_EXTENSION', -9 );\r\n  define( 'PCLZIP_ERR_BAD_FORMAT', -10 );\r\n  define( 'PCLZIP_ERR_DELETE_FILE_FAIL', -11 );\r\n  define( 'PCLZIP_ERR_RENAME_FILE_FAIL', -12 );\r\n  define( 'PCLZIP_ERR_BAD_CHECKSUM', -13 );\r\n  define( 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP', -14 );\r\n  define( 'PCLZIP_ERR_MISSING_OPTION_VALUE', -15 );\r\n  define( 'PCLZIP_ERR_INVALID_OPTION_VALUE', -16 );\r\n  define( 'PCLZIP_ERR_ALREADY_A_DIRECTORY', -17 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION', -18 );\r\n  define( 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION', -19 );\r\n  define( 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE', -20 );\r\n  define( 'PCLZIP_ERR_DIRECTORY_RESTRICTION', -21 );\r\n\r\n  // ----- Options values\r\n  define( 'PCLZIP_OPT_PATH', 77001 );\r\n  define( 'PCLZIP_OPT_ADD_PATH', 77002 );\r\n  define( 'PCLZIP_OPT_REMOVE_PATH', 77003 );\r\n  define( 'PCLZIP_OPT_REMOVE_ALL_PATH', 77004 );\r\n  define( 'PCLZIP_OPT_SET_CHMOD', 77005 );\r\n  define( 'PCLZIP_OPT_EXTRACT_AS_STRING', 77006 );\r\n  define( 'PCLZIP_OPT_NO_COMPRESSION', 77007 );\r\n  define( 'PCLZIP_OPT_BY_NAME', 77008 );\r\n  define( 'PCLZIP_OPT_BY_INDEX', 77009 );\r\n  define( 'PCLZIP_OPT_BY_EREG', 77010 );\r\n  define( 'PCLZIP_OPT_BY_PREG', 77011 );\r\n  define( 'PCLZIP_OPT_COMMENT', 77012 );\r\n  define( 'PCLZIP_OPT_ADD_COMMENT', 77013 );\r\n  define( 'PCLZIP_OPT_PREPEND_COMMENT', 77014 );\r\n  define( 'PCLZIP_OPT_EXTRACT_IN_OUTPUT', 77015 );\r\n  define( 'PCLZIP_OPT_REPLACE_NEWER', 77016 );\r\n  define( 'PCLZIP_OPT_STOP_ON_ERROR', 77017 );\r\n  // Having big trouble with crypt. Need to multiply 2 long int\r\n  // which is not correctly supported by PHP ...\r\n  //define( 'PCLZIP_OPT_CRYPT', 77018 );\r\n  define( 'PCLZIP_OPT_EXTRACT_DIR_RESTRICTION', 77019 );\r\n  define( 'PCLZIP_OPT_TEMP_FILE_THRESHOLD', 77020 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_THRESHOLD', 77020 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_ON', 77021 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_ON', 77021 ); // alias\r\n  define( 'PCLZIP_OPT_TEMP_FILE_OFF', 77022 );\r\n  define( 'PCLZIP_OPT_ADD_TEMP_FILE_OFF', 77022 ); // alias\r\n\r\n  // ----- File description attributes\r\n  define( 'PCLZIP_ATT_FILE_NAME', 79001 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_SHORT_NAME', 79002 );\r\n  define( 'PCLZIP_ATT_FILE_NEW_FULL_NAME', 79003 );\r\n  define( 'PCLZIP_ATT_FILE_MTIME', 79004 );\r\n  define( 'PCLZIP_ATT_FILE_CONTENT', 79005 );\r\n  define( 'PCLZIP_ATT_FILE_COMMENT', 79006 );\r\n\r\n  // ----- Call backs values\r\n  define( 'PCLZIP_CB_PRE_EXTRACT', 78001 );\r\n  define( 'PCLZIP_CB_POST_EXTRACT', 78002 );\r\n  define( 'PCLZIP_CB_PRE_ADD', 78003 );\r\n  define( 'PCLZIP_CB_POST_ADD', 78004 );\r\n  /* For futur use\r\n  define( 'PCLZIP_CB_PRE_LIST', 78005 );\r\n  define( 'PCLZIP_CB_POST_LIST', 78006 );\r\n  define( 'PCLZIP_CB_PRE_DELETE', 78007 );\r\n  define( 'PCLZIP_CB_POST_DELETE', 78008 );\r\n  */\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Class : PclZip\r\n  // Description :\r\n  //   PclZip is the class that represent a Zip archive.\r\n  //   The public methods allow the manipulation of the archive.\r\n  // Attributes :\r\n  //   Attributes must not be accessed directly.\r\n  // Methods :\r\n  //   PclZip() : Object creator\r\n  //   create() : Creates the Zip archive\r\n  //   listContent() : List the content of the Zip archive\r\n  //   extract() : Extract the content of the archive\r\n  //   properties() : List the properties of the archive\r\n  // --------------------------------------------------------------------------------\r\n  class PclZip\r\n  {\r\n    // ----- Filename of the zip file\r\n    var $zipname = '';\r\n\r\n    // ----- File descriptor of the zip file\r\n    var $zip_fd = 0;\r\n\r\n    // ----- Internal error handling\r\n    var $error_code = 1;\r\n    var $error_string = '';\r\n\r\n    // ----- Current status of the magic_quotes_runtime\r\n    // This value store the php configuration for magic_quotes\r\n    // The class can then disable the magic_quotes and reset it after\r\n    var $magic_quotes_status;\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZip()\r\n  // Description :\r\n  //   Creates a PclZip object and set the name of the associated Zip archive\r\n  //   filename.\r\n  //   Note that no real action is taken, if the archive does not exist it is not\r\n  //   created. Use create() for that.\r\n  // --------------------------------------------------------------------------------\r\n  public function __construct($p_zipname)\r\n  {\r\n\r\n    // ----- Tests the zlib\r\n    if (!function_exists('gzopen'))\r\n    {\r\n      die('Abort '.basename(__FILE__).' : Missing zlib extensions');\r\n    }\r\n\r\n\r\n    // Added by LS Team to prevent Zip Bombing\r\n    if (isZipBomb($p_zipname)){\r\n        die('Abort '.basename(__FILE__).' : Unzipped file is superior to upload_max_filesize or to post_max_size');\r\n    }\r\n\r\n\r\n    // ----- Set the attributes\r\n    $this->zipname = $p_zipname;\r\n    $this->zip_fd = 0;\r\n    $this->magic_quotes_status = -1;\r\n\r\n    // ----- Return\r\n    return;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   create($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   create($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two different synopsis. The first one is historical.\r\n  //   This method creates a Zip Archive. The Zip file is created in the\r\n  //   filesystem. The files and directories indicated in $p_filelist\r\n  //   are added in the archive. See the parameters description for the\r\n  //   supported format of $p_filelist.\r\n  //   When a directory is in the list, the directory and its content is added\r\n  //   in the archive.\r\n  //   In this synopsis, the function takes an optional variable list of\r\n  //   options. See bellow the supported options.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function create($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove from the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                             ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Invalid number / type of arguments\");\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        if ($v_string != '') {\r\n          $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privCreate($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   add($p_filelist, $p_add_dir=\"\", $p_remove_dir=\"\")\r\n  //   add($p_filelist, $p_option, $p_option_value, ...)\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This methods add the list of files in an existing archive.\r\n  //   If a file with the same name already exists, it is added at the end of the\r\n  //   archive, the first one is still present.\r\n  //   If the archive does not exist, it is created.\r\n  // Parameters :\r\n  //   $p_filelist : An array containing file or directory names, or\r\n  //                 a string containing one filename or one directory name, or\r\n  //                 a string containing a list of filenames and/or directory\r\n  //                 names separated by spaces.\r\n  //   $p_add_dir : A path to add before the real path of the archived file,\r\n  //                in order to have it memorized in the archive.\r\n  //   $p_remove_dir : A path to remove from the real path of the file to archive,\r\n  //                   in order to have a shorter path memorized in the archive.\r\n  //                   When $p_add_dir and $p_remove_dir are set, $p_remove_dir\r\n  //                   is removed first, before $p_add_dir is added.\r\n  // Options :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_COMMENT :\r\n  //   PCLZIP_OPT_ADD_COMMENT :\r\n  //   PCLZIP_OPT_PREPEND_COMMENT :\r\n  //   PCLZIP_CB_PRE_ADD :\r\n  //   PCLZIP_CB_POST_ADD :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the added files, with a status of the add action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function add($p_filelist)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n    $v_options[PCLZIP_OPT_NO_COMPRESSION] = FALSE;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_ADD => 'optional',\r\n                                                   PCLZIP_CB_POST_ADD => 'optional',\r\n                                                   PCLZIP_OPT_NO_COMPRESSION => 'optional',\r\n                                                   PCLZIP_OPT_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_ADD_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_PREPEND_COMMENT => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   //, PCLZIP_OPT_CRYPT => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_options[PCLZIP_OPT_ADD_PATH] = $v_add_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_options[PCLZIP_OPT_REMOVE_PATH] = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Init\r\n    $v_string_list = array();\r\n    $v_att_list = array();\r\n    $v_filedescr_list = array();\r\n    $p_result_list = array();\r\n\r\n    // ----- Look if the $p_filelist is really an array\r\n    if (is_array($p_filelist)) {\r\n\r\n      // ----- Look if the first element is also an array\r\n      //       This will mean that this is a file description entry\r\n      if (isset($p_filelist[0]) && is_array($p_filelist[0])) {\r\n        $v_att_list = $p_filelist;\r\n      }\r\n\r\n      // ----- The list is a list of string names\r\n      else {\r\n        $v_string_list = $p_filelist;\r\n      }\r\n    }\r\n\r\n    // ----- Look if the $p_filelist is a string\r\n    else if (is_string($p_filelist)) {\r\n      // ----- Create a list from the string\r\n      $v_string_list = explode(PCLZIP_SEPARATOR, $p_filelist);\r\n    }\r\n\r\n    // ----- Invalid variable type for $p_filelist\r\n    else {\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type '\".gettype($p_filelist).\"' for p_filelist\");\r\n      return 0;\r\n    }\r\n\r\n    // ----- Reformat the string list\r\n    if (sizeof($v_string_list) != 0) {\r\n      foreach ($v_string_list as $v_string) {\r\n        $v_att_list[][PCLZIP_ATT_FILE_NAME] = $v_string;\r\n      }\r\n    }\r\n\r\n    // ----- For each file in the list check the attributes\r\n    $v_supported_attributes\r\n    = array ( PCLZIP_ATT_FILE_NAME => 'mandatory'\r\n             ,PCLZIP_ATT_FILE_NEW_SHORT_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_NEW_FULL_NAME => 'optional'\r\n             ,PCLZIP_ATT_FILE_MTIME => 'optional'\r\n             ,PCLZIP_ATT_FILE_CONTENT => 'optional'\r\n             ,PCLZIP_ATT_FILE_COMMENT => 'optional'\r\n                        );\r\n    foreach ($v_att_list as $v_entry) {\r\n      $v_result = $this->privFileDescrParseAtt($v_entry,\r\n                                               $v_filedescr_list[],\r\n                                               $v_options,\r\n                                               $v_supported_attributes);\r\n      if ($v_result != 1) {\r\n        return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Expand the filelist (expand directories)\r\n    $v_result = $this->privFileDescrExpand($v_filedescr_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Call the create fct\r\n    $v_result = $this->privAdd($v_filedescr_list, $p_result_list, $v_options);\r\n    if ($v_result != 1) {\r\n      return 0;\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_result_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : listContent()\r\n  // Description :\r\n  //   This public method, gives the list of the files and directories, with their\r\n  //   properties.\r\n  //   The properties of each entries in the list are (used also in other functions) :\r\n  //     filename : Name of the file. For a create or add action it is the filename\r\n  //                given by the user. For an extract function it is the filename\r\n  //                of the extracted file.\r\n  //     stored_filename : Name of the file / directory stored in the archive.\r\n  //     size : Size of the stored file.\r\n  //     compressed_size : Size of the file's data compressed in the archive\r\n  //                       (without the headers overhead)\r\n  //     mtime : Last known modification date of the file (UNIX timestamp)\r\n  //     comment : Comment associated with the file\r\n  //     folder : true | false\r\n  //     index : index of the file in the archive\r\n  //     status : status of the action (depending of the action) :\r\n  //              Values are :\r\n  //                ok : OK !\r\n  //                filtered : the file / dir is not extracted (filtered by user)\r\n  //                already_a_directory : the file can not be extracted because a\r\n  //                                      directory with the same name already exists\r\n  //                write_protected : the file can not be extracted because a file\r\n  //                                  with the same name already exists and is\r\n  //                                  write protected\r\n  //                newer_exist : the file was not extracted because a newer file exists\r\n  //                path_creation_fail : the file is not extracted because the folder\r\n  //                                     does not exist and can not be created\r\n  //                write_error : the file was not extracted because there was a\r\n  //                              error while writing the file\r\n  //                read_error : the file was not extracted because there was a error\r\n  //                             while reading the file\r\n  //                invalid_header : the file was not extracted because of an archive\r\n  //                                 format error (bad file header)\r\n  //   Note that each time a method can continue operating when there\r\n  //   is an action error on a file, the error is only logged in the file status.\r\n  // Return Values :\r\n  //   0 on an unrecoverable failure,\r\n  //   The list of the files in the archive.\r\n  // --------------------------------------------------------------------------------\r\n  function listContent()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    if (($v_result = $this->privList($p_list)) != 1)\r\n    {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extract($p_path=\"./\", $p_remove_path=\"\")\r\n  //   extract([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method extract all the files / directories from the archive to the\r\n  //   folder indicated in $p_path.\r\n  //   If you want to ignore the 'root' part of path of the memorized files\r\n  //   you can indicate this in the optional $p_remove_path parameter.\r\n  //   By default, if a newer file with the same name already exists, the\r\n  //   file is not extracted.\r\n  //\r\n  //   If both PCLZIP_OPT_PATH and PCLZIP_OPT_ADD_PATH aoptions\r\n  //   are used, the path indicated in PCLZIP_OPT_ADD_PATH is append\r\n  //   at the end of the path value of PCLZIP_OPT_PATH.\r\n  // Parameters :\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 or a negative value on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function extract()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_BY_NAME => 'optional',\r\n                                                   PCLZIP_OPT_BY_EREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_PREG => 'optional',\r\n                                                   PCLZIP_OPT_BY_INDEX => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_IN_OUTPUT => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                    ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Call the extracting fct\r\n    $p_list = array();\r\n    $v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path,\r\n                                         $v_remove_all_path, $v_options);\r\n    if ($v_result < 1) {\r\n      unset($p_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   extractByIndex($p_index, $p_path=\"./\", $p_remove_path=\"\")\r\n  //   extractByIndex($p_index, [$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method supports two synopsis. The first one is historical.\r\n  //   This method is doing a partial extract of the archive.\r\n  //   The extracted files or folders are identified by their index in the\r\n  //   archive (from 0 to n).\r\n  //   Note that if the index identify a folder, only the folder entry is\r\n  //   extracted, not all the files included in the archive.\r\n  // Parameters :\r\n  //   $p_index : A single index (integer) or a string of indexes of files to\r\n  //              extract. The form of the string is \"0,4-6,8-12\" with only numbers\r\n  //              and '-' for range or ',' to separate ranges. No spaces or ';'\r\n  //              are allowed.\r\n  //   $p_path : Path where the files and directories are to be extracted\r\n  //   $p_remove_path : First part ('root' part) of the memorized path\r\n  //                    (if any similar) to remove while extracting.\r\n  // Options :\r\n  //   PCLZIP_OPT_PATH :\r\n  //   PCLZIP_OPT_ADD_PATH :\r\n  //   PCLZIP_OPT_REMOVE_PATH :\r\n  //   PCLZIP_OPT_REMOVE_ALL_PATH :\r\n  //   PCLZIP_OPT_EXTRACT_AS_STRING : The files are extracted as strings and\r\n  //     not as files.\r\n  //     The resulting content is in a new field 'content' in the file\r\n  //     structure.\r\n  //     This option must be used alone (any other options are ignored).\r\n  //   PCLZIP_CB_PRE_EXTRACT :\r\n  //   PCLZIP_CB_POST_EXTRACT :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the extracted files, with a status of the action.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  //function extractByIndex($p_index, options...)\r\n  function extractByIndex($p_index)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n//    $v_path = \"./\";\r\n    $v_path = '';\r\n    $v_remove_path = \"\";\r\n    $v_remove_all_path = false;\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Default values for option\r\n    $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 1) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Remove form the options list the first argument\r\n      array_shift($v_arg_list);\r\n      $v_size--;\r\n\r\n      // ----- Look for first arg\r\n      if ((is_integer($v_arg_list[0])) && ($v_arg_list[0] > 77000)) {\r\n\r\n        // ----- Parse the options\r\n        $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                            array (PCLZIP_OPT_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_PATH => 'optional',\r\n                                                   PCLZIP_OPT_REMOVE_ALL_PATH => 'optional',\r\n                                                   PCLZIP_OPT_EXTRACT_AS_STRING => 'optional',\r\n                                                   PCLZIP_OPT_ADD_PATH => 'optional',\r\n                                                   PCLZIP_CB_PRE_EXTRACT => 'optional',\r\n                                                   PCLZIP_CB_POST_EXTRACT => 'optional',\r\n                                                   PCLZIP_OPT_SET_CHMOD => 'optional',\r\n                                                   PCLZIP_OPT_REPLACE_NEWER => 'optional'\r\n                                                   ,PCLZIP_OPT_STOP_ON_ERROR => 'optional'\r\n                                                   ,PCLZIP_OPT_EXTRACT_DIR_RESTRICTION => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_THRESHOLD => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_ON => 'optional',\r\n                                                   PCLZIP_OPT_TEMP_FILE_OFF => 'optional'\r\n                                                   ));\r\n        if ($v_result != 1) {\r\n          return 0;\r\n        }\r\n\r\n        // ----- Set the arguments\r\n        if (isset($v_options[PCLZIP_OPT_PATH])) {\r\n          $v_path = $v_options[PCLZIP_OPT_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n          $v_remove_path = $v_options[PCLZIP_OPT_REMOVE_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n          $v_remove_all_path = $v_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n        }\r\n        if (isset($v_options[PCLZIP_OPT_ADD_PATH])) {\r\n          // ----- Check for '/' in last path char\r\n          if ((strlen($v_path) > 0) && (substr($v_path, -1) != '/')) {\r\n            $v_path .= '/';\r\n          }\r\n          $v_path .= $v_options[PCLZIP_OPT_ADD_PATH];\r\n        }\r\n        if (!isset($v_options[PCLZIP_OPT_EXTRACT_AS_STRING])) {\r\n          $v_options[PCLZIP_OPT_EXTRACT_AS_STRING] = FALSE;\r\n        }\r\n        else {\r\n        }\r\n      }\r\n\r\n      // ----- Look for 2 args\r\n      // Here we need to support the first historic synopsis of the\r\n      // method.\r\n      else {\r\n\r\n        // ----- Get the first argument\r\n        $v_path = $v_arg_list[0];\r\n\r\n        // ----- Look for the optional second argument\r\n        if ($v_size == 2) {\r\n          $v_remove_path = $v_arg_list[1];\r\n        }\r\n        else if ($v_size > 2) {\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid number / type of arguments\");\r\n\r\n          // ----- Return\r\n          return 0;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Trick\r\n    // Here I want to reuse extractByRule(), so I need to parse the $p_index\r\n    // with privParseOptions()\r\n    $v_arg_trick = array (PCLZIP_OPT_BY_INDEX, $p_index);\r\n    $v_options_trick = array();\r\n    $v_result = $this->privParseOptions($v_arg_trick, sizeof($v_arg_trick), $v_options_trick,\r\n                                        array (PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n    if ($v_result != 1) {\r\n        return 0;\r\n    }\r\n    $v_options[PCLZIP_OPT_BY_INDEX] = $v_options_trick[PCLZIP_OPT_BY_INDEX];\r\n\r\n    // ----- Look for default option values\r\n    $this->privOptionDefaultThreshold($v_options);\r\n\r\n    // ----- Call the extracting fct\r\n    if (($v_result = $this->privExtractByRule($p_list, $v_path, $v_remove_path, $v_remove_all_path, $v_options)) < 1) {\r\n        return(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function :\r\n  //   delete([$p_option, $p_option_value, ...])\r\n  // Description :\r\n  //   This method removes files from the archive.\r\n  //   If no parameters are given, then all the archive is emptied.\r\n  // Parameters :\r\n  //   None or optional arguments.\r\n  // Options :\r\n  //   PCLZIP_OPT_BY_INDEX :\r\n  //   PCLZIP_OPT_BY_NAME :\r\n  //   PCLZIP_OPT_BY_EREG :\r\n  //   PCLZIP_OPT_BY_PREG :\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   The list of the files which are still present in the archive.\r\n  //   (see PclZip::listContent() for list entry format)\r\n  // --------------------------------------------------------------------------------\r\n  function delete()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Set default values\r\n    $v_options = array();\r\n\r\n    // ----- Look for variable options arguments\r\n    $v_size = func_num_args();\r\n\r\n    // ----- Look for arguments\r\n    if ($v_size > 0) {\r\n      // ----- Get the arguments\r\n      $v_arg_list = func_get_args();\r\n\r\n      // ----- Parse the options\r\n      $v_result = $this->privParseOptions($v_arg_list, $v_size, $v_options,\r\n                                        array (PCLZIP_OPT_BY_NAME => 'optional',\r\n                                               PCLZIP_OPT_BY_EREG => 'optional',\r\n                                               PCLZIP_OPT_BY_PREG => 'optional',\r\n                                               PCLZIP_OPT_BY_INDEX => 'optional' ));\r\n      if ($v_result != 1) {\r\n          return 0;\r\n      }\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Call the delete fct\r\n    $v_list = array();\r\n    if (($v_result = $this->privDeleteByRule($v_list, $v_options)) != 1) {\r\n      $this->privSwapBackMagicQuotes();\r\n      unset($v_list);\r\n      return(0);\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : deleteByIndex()\r\n  // Description :\r\n  //   ***** Deprecated *****\r\n  //   delete(PCLZIP_OPT_BY_INDEX, $p_index) should be prefered.\r\n  // --------------------------------------------------------------------------------\r\n  function deleteByIndex($p_index)\r\n  {\r\n\r\n    $p_list = $this->delete(PCLZIP_OPT_BY_INDEX, $p_index);\r\n\r\n    // ----- Return\r\n    return $p_list;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : properties()\r\n  // Description :\r\n  //   This method gives the properties of the archive.\r\n  //   The properties are :\r\n  //     nb : Number of files in the archive\r\n  //     comment : Comment associated with the archive file\r\n  //     status : not_exist, ok\r\n  // Parameters :\r\n  //   None\r\n  // Return Values :\r\n  //   0 on failure,\r\n  //   An array with the archive properties.\r\n  // --------------------------------------------------------------------------------\r\n  function properties()\r\n  {\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      $this->privSwapBackMagicQuotes();\r\n      return(0);\r\n    }\r\n\r\n    // ----- Default properties\r\n    $v_prop = array();\r\n    $v_prop['comment'] = '';\r\n    $v_prop['nb'] = 0;\r\n    $v_prop['status'] = 'not_exist';\r\n\r\n    // ----- Look if file exists\r\n    if (@is_file($this->zipname))\r\n    {\r\n      // ----- Open the zip file\r\n      if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n        // ----- Return\r\n        return 0;\r\n      }\r\n\r\n      // ----- Read the central directory informations\r\n      $v_central_dir = array();\r\n      if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return 0;\r\n      }\r\n\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Set the user attributes\r\n      $v_prop['comment'] = $v_central_dir['comment'];\r\n      $v_prop['nb'] = $v_central_dir['entries'];\r\n      $v_prop['status'] = 'ok';\r\n    }\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_prop;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : duplicate()\r\n  // Description :\r\n  //   This method creates an archive by copying the content of an other one. If\r\n  //   the archive already exist, it is replaced by the new one without any warning.\r\n  // Parameters :\r\n  //   $p_archive : The filename of a valid archive, or\r\n  //                a valid PclZip object.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 or a negative value on error (error code).\r\n  // --------------------------------------------------------------------------------\r\n  function duplicate($p_archive)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the $p_archive is a PclZip object\r\n    if ((is_object($p_archive)) && (get_class($p_archive) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Duplicate the archive\r\n      $v_result = $this->privDuplicate($p_archive->zipname);\r\n    }\r\n\r\n    // ----- Look if the $p_archive is a string (so a filename)\r\n    else if (is_string($p_archive))\r\n    {\r\n\r\n      // ----- Check that $p_archive is a valid zip file\r\n      // TBC : Should also check the archive format\r\n      if (!is_file($p_archive)) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"No file with filename '\".$p_archive.\"'\");\r\n        $v_result = PCLZIP_ERR_MISSING_FILE;\r\n      }\r\n      else {\r\n        // ----- Duplicate the archive\r\n        $v_result = $this->privDuplicate($p_archive);\r\n      }\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : merge()\r\n  // Description :\r\n  //   This method merge the $p_archive_to_add archive at the end of the current\r\n  //   one ($this).\r\n  //   If the archive ($this) does not exist, the merge becomes a duplicate.\r\n  //   If the $p_archive_to_add archive does not exist, the merge is a success.\r\n  // Parameters :\r\n  //   $p_archive_to_add : It can be directly the filename of a valid zip archive,\r\n  //                       or a PclZip object archive.\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 or negative values on error (see below).\r\n  // --------------------------------------------------------------------------------\r\n  function merge($p_archive_to_add)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Check archive\r\n    if (!$this->privCheckFormat()) {\r\n      return(0);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a PclZip object\r\n    if ((is_object($p_archive_to_add)) && (get_class($p_archive_to_add) == 'pclzip'))\r\n    {\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($p_archive_to_add);\r\n    }\r\n\r\n    // ----- Look if the $p_archive_to_add is a string (so a filename)\r\n    else if (is_string($p_archive_to_add))\r\n    {\r\n\r\n      // ----- Create a temporary archive\r\n      $v_object_archive = new PclZip($p_archive_to_add);\r\n\r\n      // ----- Merge the archive\r\n      $v_result = $this->privMerge($v_object_archive);\r\n    }\r\n\r\n    // ----- Invalid variable\r\n    else\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid variable type p_archive_to_add\");\r\n      $v_result = PCLZIP_ERR_INVALID_PARAMETER;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorCode()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorCode()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorCode());\r\n    }\r\n    else {\r\n      return($this->error_code);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorName()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorName($p_with_code=false)\r\n  {\r\n    $v_name = array ( PCLZIP_ERR_NO_ERROR => 'PCLZIP_ERR_NO_ERROR',\r\n                      PCLZIP_ERR_WRITE_OPEN_FAIL => 'PCLZIP_ERR_WRITE_OPEN_FAIL',\r\n                      PCLZIP_ERR_READ_OPEN_FAIL => 'PCLZIP_ERR_READ_OPEN_FAIL',\r\n                      PCLZIP_ERR_INVALID_PARAMETER => 'PCLZIP_ERR_INVALID_PARAMETER',\r\n                      PCLZIP_ERR_MISSING_FILE => 'PCLZIP_ERR_MISSING_FILE',\r\n                      PCLZIP_ERR_FILENAME_TOO_LONG => 'PCLZIP_ERR_FILENAME_TOO_LONG',\r\n                      PCLZIP_ERR_INVALID_ZIP => 'PCLZIP_ERR_INVALID_ZIP',\r\n                      PCLZIP_ERR_BAD_EXTRACTED_FILE => 'PCLZIP_ERR_BAD_EXTRACTED_FILE',\r\n                      PCLZIP_ERR_DIR_CREATE_FAIL => 'PCLZIP_ERR_DIR_CREATE_FAIL',\r\n                      PCLZIP_ERR_BAD_EXTENSION => 'PCLZIP_ERR_BAD_EXTENSION',\r\n                      PCLZIP_ERR_BAD_FORMAT => 'PCLZIP_ERR_BAD_FORMAT',\r\n                      PCLZIP_ERR_DELETE_FILE_FAIL => 'PCLZIP_ERR_DELETE_FILE_FAIL',\r\n                      PCLZIP_ERR_RENAME_FILE_FAIL => 'PCLZIP_ERR_RENAME_FILE_FAIL',\r\n                      PCLZIP_ERR_BAD_CHECKSUM => 'PCLZIP_ERR_BAD_CHECKSUM',\r\n                      PCLZIP_ERR_INVALID_ARCHIVE_ZIP => 'PCLZIP_ERR_INVALID_ARCHIVE_ZIP',\r\n                      PCLZIP_ERR_MISSING_OPTION_VALUE => 'PCLZIP_ERR_MISSING_OPTION_VALUE',\r\n                      PCLZIP_ERR_INVALID_OPTION_VALUE => 'PCLZIP_ERR_INVALID_OPTION_VALUE',\r\n                      PCLZIP_ERR_UNSUPPORTED_COMPRESSION => 'PCLZIP_ERR_UNSUPPORTED_COMPRESSION',\r\n                      PCLZIP_ERR_UNSUPPORTED_ENCRYPTION => 'PCLZIP_ERR_UNSUPPORTED_ENCRYPTION'\r\n                      ,PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE => 'PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE'\r\n                      ,PCLZIP_ERR_DIRECTORY_RESTRICTION => 'PCLZIP_ERR_DIRECTORY_RESTRICTION'\r\n                    );\r\n\r\n    if (isset($v_name[$this->error_code])) {\r\n      $v_value = $v_name[$this->error_code];\r\n    }\r\n    else {\r\n      $v_value = 'NoName';\r\n    }\r\n\r\n    if ($p_with_code) {\r\n      return($v_value.' ('.$this->error_code.')');\r\n    }\r\n    else {\r\n      return($v_value);\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : errorInfo()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function errorInfo($p_full=false)\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      return(PclErrorString());\r\n    }\r\n    else {\r\n      if ($p_full) {\r\n        return($this->errorName(true).\" : \".$this->error_string);\r\n      }\r\n      else {\r\n        return($this->error_string.\" [code \".$this->error_code.\"]\");\r\n      }\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n// --------------------------------------------------------------------------------\r\n// ***** UNDER THIS LINE ARE DEFINED PRIVATE INTERNAL FUNCTIONS *****\r\n// *****                                                        *****\r\n// *****       THESES FUNCTIONS MUST NOT BE USED DIRECTLY       *****\r\n// --------------------------------------------------------------------------------\r\n\r\n\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFormat()\r\n  // Description :\r\n  //   This method check that the archive exists and is a valid zip archive.\r\n  //   Several level of check exists. (futur)\r\n  // Parameters :\r\n  //   $p_level : Level of check. Default 0.\r\n  //              0 : Check the first bytes (magic codes) (default value))\r\n  //              1 : 0 + Check the central directory (futur)\r\n  //              2 : 1 + Check each file header (futur)\r\n  // Return Values :\r\n  //   true on success,\r\n  //   false on error, the error code is set.\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFormat($p_level=0)\r\n  {\r\n    $v_result = true;\r\n\r\n    // ----- Reset the file system cache\r\n    clearstatcache();\r\n\r\n    // ----- Reset the error handler\r\n    $this->privErrorReset();\r\n\r\n    // ----- Look if the file exits\r\n    if (!is_file($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"Missing archive file '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check that the file is readeable\r\n    if (!is_readable($this->zipname)) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to read archive '\".$this->zipname.\"'\");\r\n      return(false);\r\n    }\r\n\r\n    // ----- Check the magic code\r\n    // TBC\r\n\r\n    // ----- Check the central header\r\n    // TBC\r\n\r\n    // ----- Check each file header\r\n    // TBC\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privParseOptions()\r\n  // Description :\r\n  //   This internal methods reads the variable list of arguments ($p_options_list,\r\n  //   $p_size) and generate an array with the options and values ($v_result_list).\r\n  //   $v_requested_options contains the options that can be present and those that\r\n  //   must be present.\r\n  //   $v_requested_options is an array, with the option value as key, and 'optional',\r\n  //   or 'mandatory' as value.\r\n  // Parameters :\r\n  //   See above.\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privParseOptions(&$p_options_list, $p_size, &$v_result_list, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the options\r\n    $i=0;\r\n    while ($i<$p_size) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$p_options_list[$i]])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid optional parameter '\".$p_options_list[$i].\"' for this method\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for next option\r\n      switch ($p_options_list[$i]) {\r\n        // ----- Look for options that request a path value\r\n        case PCLZIP_OPT_PATH :\r\n        case PCLZIP_OPT_REMOVE_PATH :\r\n        case PCLZIP_OPT_ADD_PATH :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_THRESHOLD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Check the value\r\n          $v_value = $p_options_list[$i+1];\r\n          if ((!is_integer($v_value)) || ($v_value<0)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Integer expected for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value (and convert it in bytes)\r\n          $v_result_list[$p_options_list[$i]] = $v_value*1048576;\r\n          $i++;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_ON :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_OFF'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_TEMP_FILE_OFF :\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_ON])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_ON'\");\r\n            return PclZip::errorCode();\r\n          }\r\n          // ----- Check for incompatible options\r\n          if (isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Option '\".PclZipUtilOptionText($p_options_list[$i]).\"' can not be used with option 'PCLZIP_OPT_TEMP_FILE_THRESHOLD'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        case PCLZIP_OPT_EXTRACT_DIR_RESTRICTION :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (   is_string($p_options_list[$i+1])\r\n              && ($p_options_list[$i+1] != '')) {\r\n            $v_result_list[$p_options_list[$i]] = PclZipUtilTranslateWinPath($p_options_list[$i+1], FALSE);\r\n            $i++;\r\n          }\r\n          else {\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that request an array of string for value\r\n        case PCLZIP_OPT_BY_NAME :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]][0] = $p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an EREG or PREG expression\r\n        case PCLZIP_OPT_BY_EREG :\r\n          // ereg() is deprecated starting with PHP 5.3. Move PCLZIP_OPT_BY_EREG\r\n          // to PCLZIP_OPT_BY_PREG\r\n          $p_options_list[$i] = PCLZIP_OPT_BY_PREG;\r\n        case PCLZIP_OPT_BY_PREG :\r\n        //case PCLZIP_OPT_CRYPT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Wrong parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_OPT_COMMENT :\r\n        case PCLZIP_OPT_ADD_COMMENT :\r\n        case PCLZIP_OPT_PREPEND_COMMENT :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE,\r\n                                 \"Missing parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          if (is_string($p_options_list[$i+1])) {\r\n              $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE,\r\n                                 \"Wrong parameter value for option '\"\r\n                                 .PclZipUtilOptionText($p_options_list[$i])\r\n                                 .\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request an array of index\r\n        case PCLZIP_OPT_BY_INDEX :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_work_list = array();\r\n          if (is_string($p_options_list[$i+1])) {\r\n\r\n              // ----- Remove spaces\r\n              $p_options_list[$i+1] = strtr($p_options_list[$i+1], ' ', '');\r\n\r\n              // ----- Parse items\r\n              $v_work_list = explode(\",\", $p_options_list[$i+1]);\r\n          }\r\n          else if (is_integer($p_options_list[$i+1])) {\r\n              $v_work_list[0] = $p_options_list[$i+1].'-'.$p_options_list[$i+1];\r\n          }\r\n          else if (is_array($p_options_list[$i+1])) {\r\n              $v_work_list = $p_options_list[$i+1];\r\n          }\r\n          else {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Value must be integer, string or array for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Reduce the index list\r\n          // each index item in the list must be a couple with a start and\r\n          // an end value : [0,3], [5-5], [8-10], ...\r\n          // ----- Check the format of each item\r\n          $v_sort_flag=false;\r\n          $v_sort_value=0;\r\n          for ($j=0; $j<sizeof($v_work_list); $j++) {\r\n              // ----- Explode the item\r\n              $v_item_list = explode(\"-\", $v_work_list[$j]);\r\n              $v_size_item_list = sizeof($v_item_list);\r\n\r\n              // ----- TBC : Here we might check that each item is a\r\n              // real integer ...\r\n\r\n              // ----- Look for single value\r\n              if ($v_size_item_list == 1) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[0];\r\n              }\r\n              elseif ($v_size_item_list == 2) {\r\n                  // ----- Set the option value\r\n                  $v_result_list[$p_options_list[$i]][$j]['start'] = $v_item_list[0];\r\n                  $v_result_list[$p_options_list[$i]][$j]['end'] = $v_item_list[1];\r\n              }\r\n              else {\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Too many values in index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n\r\n\r\n              // ----- Look for list sort\r\n              if ($v_result_list[$p_options_list[$i]][$j]['start'] < $v_sort_value) {\r\n                  $v_sort_flag=true;\r\n\r\n                  // ----- TBC : An automatic sort should be writen ...\r\n                  // ----- Error log\r\n                  PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Invalid order of index range for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n                  // ----- Return\r\n                  return PclZip::errorCode();\r\n              }\r\n              $v_sort_value = $v_result_list[$p_options_list[$i]][$j]['start'];\r\n          }\r\n\r\n          // ----- Sort the items\r\n          if ($v_sort_flag) {\r\n              // TBC : To Be Completed\r\n          }\r\n\r\n          // ----- Next option\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request no value\r\n        case PCLZIP_OPT_REMOVE_ALL_PATH :\r\n        case PCLZIP_OPT_EXTRACT_AS_STRING :\r\n        case PCLZIP_OPT_NO_COMPRESSION :\r\n        case PCLZIP_OPT_EXTRACT_IN_OUTPUT :\r\n        case PCLZIP_OPT_REPLACE_NEWER :\r\n        case PCLZIP_OPT_STOP_ON_ERROR :\r\n          $v_result_list[$p_options_list[$i]] = true;\r\n        break;\r\n\r\n        // ----- Look for options that request an octal value\r\n        case PCLZIP_OPT_SET_CHMOD :\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_result_list[$p_options_list[$i]] = $p_options_list[$i+1];\r\n          $i++;\r\n        break;\r\n\r\n        // ----- Look for options that request a call-back\r\n        case PCLZIP_CB_PRE_EXTRACT :\r\n        case PCLZIP_CB_POST_EXTRACT :\r\n        case PCLZIP_CB_PRE_ADD :\r\n        case PCLZIP_CB_POST_ADD :\r\n        /* for futur use\r\n        case PCLZIP_CB_PRE_DELETE :\r\n        case PCLZIP_CB_POST_DELETE :\r\n        case PCLZIP_CB_PRE_LIST :\r\n        case PCLZIP_CB_POST_LIST :\r\n        */\r\n          // ----- Check the number of parameters\r\n          if (($i+1) >= $p_size) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_MISSING_OPTION_VALUE, \"Missing parameter value for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Get the value\r\n          $v_function_name = $p_options_list[$i+1];\r\n\r\n          // ----- Check that the value is a valid existing function\r\n          if (!function_exists($v_function_name)) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_OPTION_VALUE, \"Function '\".$v_function_name.\"()' is not an existing function for option '\".PclZipUtilOptionText($p_options_list[$i]).\"'\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          // ----- Set the attribute\r\n          $v_result_list[$p_options_list[$i]] = $v_function_name;\r\n          $i++;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                               \"Unknown parameter '\"\r\n                               .$p_options_list[$i].\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Next options\r\n      $i++;\r\n    }\r\n\r\n    // ----- Look for mandatory options\r\n    if ($v_requested_options !== false) {\r\n      for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n        // ----- Look for mandatory option\r\n        if ($v_requested_options[$key] == 'mandatory') {\r\n          // ----- Look if present\r\n          if (!isset($v_result_list[$key])) {\r\n            // ----- Error log\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n\r\n            // ----- Return\r\n            return PclZip::errorCode();\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for default values\r\n    if (!isset($v_result_list[PCLZIP_OPT_TEMP_FILE_THRESHOLD])) {\r\n\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOptionDefaultThreshold()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privOptionDefaultThreshold(&$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    if (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n        || isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF])) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get 'memory_limit' configuration value\r\n    $v_memory_limit = ini_get('memory_limit');\r\n    $v_memory_limit = trim($v_memory_limit);\r\n    $last = strtolower(substr($v_memory_limit, -1));\r\n\r\n    if($last == 'g') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit)*1073741824;\r\n    }\r\n    if($last == 'm') {\r\n        //$v_memory_limit = $v_memory_limit*1024*1024;\r\n        $v_memory_limit = ((int) $v_memory_limit) * 1048576;\r\n    }\r\n    if($last == 'k') {\r\n        $v_memory_limit = ((int) $v_memory_limit)*1024;\r\n    }\r\n\r\n    $p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] = floor($v_memory_limit*PCLZIP_TEMPORARY_FILE_RATIO);\r\n\r\n\r\n    // ----- Sanity check : No threshold if value lower than 1M\r\n    if ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] < 1048576) {\r\n      unset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD]);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrParseAtt()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrParseAtt(&$p_file_list, &$p_filedescr, $v_options, $v_requested_options=false)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- For each file in the list check the attributes\r\n    foreach ($p_file_list as $v_key => $v_value) {\r\n\r\n      // ----- Check if the option is supported\r\n      if (!isset($v_requested_options[$v_key])) {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file attribute '\".$v_key.\"' for this file\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for attribute\r\n      switch ($v_key) {\r\n        case PCLZIP_ATT_FILE_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['filename'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['filename'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_SHORT_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_short_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_short_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty short filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_NEW_FULL_NAME :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['new_full_name'] = PclZipUtilPathReduction($v_value);\r\n\r\n          if ($p_filedescr['new_full_name'] == '') {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid empty full filename for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n        break;\r\n\r\n        // ----- Look for options that takes a string\r\n        case PCLZIP_ATT_FILE_COMMENT :\r\n          if (!is_string($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". String expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['comment'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_MTIME :\r\n          if (!is_integer($v_value)) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_INVALID_ATTRIBUTE_VALUE, \"Invalid type \".gettype($v_value).\". Integer expected for attribute '\".PclZipUtilOptionText($v_key).\"'\");\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n          $p_filedescr['mtime'] = $v_value;\r\n        break;\r\n\r\n        case PCLZIP_ATT_FILE_CONTENT :\r\n          $p_filedescr['content'] = $v_value;\r\n        break;\r\n\r\n        default :\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER,\r\n                                   \"Unknown parameter '\".$v_key.\"'\");\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look for mandatory options\r\n      if ($v_requested_options !== false) {\r\n        for ($key=reset($v_requested_options); $key=key($v_requested_options); $key=next($v_requested_options)) {\r\n          // ----- Look for mandatory option\r\n          if ($v_requested_options[$key] == 'mandatory') {\r\n            // ----- Look if present\r\n            if (!isset($p_file_list[$key])) {\r\n              PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Missing mandatory parameter \".PclZipUtilOptionText($key).\"(\".$key.\")\");\r\n              return PclZip::errorCode();\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    // end foreach\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privFileDescrExpand()\r\n  // Description :\r\n  //   This method look for each item of the list to see if its a file, a folder\r\n  //   or a string to be added as file. For any other type of files (link, other)\r\n  //   just ignore the item.\r\n  //   Then prepare the information that will be stored for that file.\r\n  //   When its a folder, expand the folder with all the files that are in that\r\n  //   folder (recursively).\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success.\r\n  //   0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function privFileDescrExpand(&$p_filedescr_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Create a result list\r\n    $v_result_list = array();\r\n\r\n    // ----- Look each entry\r\n    for ($i=0; $i<sizeof($p_filedescr_list); $i++) {\r\n\r\n      // ----- Get filedescr\r\n      $v_descr = $p_filedescr_list[$i];\r\n\r\n      // ----- Reduce the filename\r\n      $v_descr['filename'] = PclZipUtilTranslateWinPath($v_descr['filename'], false);\r\n      $v_descr['filename'] = PclZipUtilPathReduction($v_descr['filename']);\r\n\r\n      // ----- Look for real file or folder\r\n      if (file_exists($v_descr['filename'])) {\r\n        if (@is_file($v_descr['filename'])) {\r\n          $v_descr['type'] = 'file';\r\n        }\r\n        else if (@is_dir($v_descr['filename'])) {\r\n          $v_descr['type'] = 'folder';\r\n        }\r\n        else if (@is_link($v_descr['filename'])) {\r\n          // skip\r\n          continue;\r\n        }\r\n        else {\r\n          // skip\r\n          continue;\r\n        }\r\n      }\r\n\r\n      // ----- Look for string added as file\r\n      else if (isset($v_descr['content'])) {\r\n        $v_descr['type'] = 'virtual_file';\r\n      }\r\n\r\n      // ----- Missing file\r\n      else {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$v_descr['filename'].\"' does not exist\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Calculate the stored filename\r\n      $this->privCalculateStoredFilename($v_descr, $p_options);\r\n\r\n      // ----- Add the descriptor in result list\r\n      $v_result_list[sizeof($v_result_list)] = $v_descr;\r\n\r\n      // ----- Look for folder\r\n      if ($v_descr['type'] == 'folder') {\r\n        // ----- List of items in folder\r\n        $v_dirlist_descr = array();\r\n        $v_dirlist_nb = 0;\r\n        if ($v_folder_handler = @opendir($v_descr['filename'])) {\r\n          while (($v_item_handler = @readdir($v_folder_handler)) !== false) {\r\n\r\n            // ----- Skip '.' and '..'\r\n            if (($v_item_handler == '.') || ($v_item_handler == '..')) {\r\n                continue;\r\n            }\r\n\r\n            // ----- Compose the full filename\r\n            $v_dirlist_descr[$v_dirlist_nb]['filename'] = $v_descr['filename'].'/'.$v_item_handler;\r\n\r\n            // ----- Look for different stored filename\r\n            // Because the name of the folder was changed, the name of the\r\n            // files/sub-folders also change\r\n            if (($v_descr['stored_filename'] != $v_descr['filename'])\r\n                 && (!isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))) {\r\n              if ($v_descr['stored_filename'] != '') {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_descr['stored_filename'].'/'.$v_item_handler;\r\n              }\r\n              else {\r\n                $v_dirlist_descr[$v_dirlist_nb]['new_full_name'] = $v_item_handler;\r\n              }\r\n            }\r\n\r\n            $v_dirlist_nb++;\r\n          }\r\n\r\n          @closedir($v_folder_handler);\r\n        }\r\n        else {\r\n          // TBC : unable to open folder in read mode\r\n        }\r\n\r\n        // ----- Expand each element of the list\r\n        if ($v_dirlist_nb != 0) {\r\n          // ----- Expand\r\n          if (($v_result = $this->privFileDescrExpand($v_dirlist_descr, $p_options)) != 1) {\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Concat the resulting list\r\n          $v_result_list = array_merge($v_result_list, $v_dirlist_descr);\r\n        }\r\n        else {\r\n        }\r\n\r\n        // ----- Free local array\r\n        unset($v_dirlist_descr);\r\n      }\r\n    }\r\n\r\n    // ----- Get the result list\r\n    $p_filedescr_list = $v_result_list;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCreate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCreate($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the file in write mode\r\n    if (($v_result = $this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the list of files\r\n    $v_result = $this->privAddList($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAdd()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAdd($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Look if the archive exists or is empty\r\n    if ((!is_file($this->zipname)) || (filesize($this->zipname) == 0))\r\n    {\r\n\r\n      // ----- Do a create\r\n      $v_result = $this->privCreate($p_filedescr_list, $p_result_list, $p_options);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      fclose($v_zip_temp_fd);\r\n      $this->privCloseFd();\r\n      @unlink($v_zip_temp_name);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0, $v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          fclose($v_zip_temp_fd);\r\n          $this->privCloseFd();\r\n          @unlink($v_zip_temp_name);\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = $v_central_dir['comment'];\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_ADD_COMMENT])) {\r\n      $v_comment = $v_comment.$p_options[PCLZIP_OPT_ADD_COMMENT];\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_PREPEND_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_PREPEND_COMMENT].$v_comment;\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count+$v_central_dir['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privOpenFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privOpenFd($p_mode)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if already open\r\n    if ($this->zip_fd != 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Zip file \\''.$this->zipname.'\\' already open');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, $p_mode)) == 0)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in '.$p_mode.' mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCloseFd()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privCloseFd()\r\n  {\r\n    $v_result=1;\r\n\r\n    if ($this->zip_fd != 0)\r\n      @fclose($this->zip_fd);\r\n    $this->zip_fd = 0;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddList()\r\n  // Description :\r\n  //   $p_add_dir and $p_remove_dir will give the ability to memorize a path which is\r\n  //   different from the real path of the file. This is usefull if you want to have PclTar\r\n  //   running in any directory, and memorize relative path from an other directory.\r\n  // Parameters :\r\n  //   $p_list : An array containing the file or directory names to add in the tar\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  //   $p_add_dir : Path to add in the filename path archived\r\n  //   $p_remove_dir : Path to remove in the filename path archived\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n//  function privAddList($p_list, &$p_result_list, $p_add_dir, $p_remove_dir, $p_remove_all_dir, &$p_options)\r\n  function privAddList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Add the files\r\n    $v_header_list = array();\r\n    if (($v_result = $this->privAddFileList($p_filedescr_list, $v_header_list, $p_options)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($this->zip_fd);\r\n\r\n    // ----- Create the Central Dir files header\r\n    for ($i=0,$v_count=0; $i<sizeof($v_header_list); $i++)\r\n    {\r\n      // ----- Create the file header\r\n      if ($v_header_list[$i]['status'] == 'ok') {\r\n        if (($v_result = $this->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n          // ----- Return\r\n          return $v_result;\r\n        }\r\n        $v_count++;\r\n      }\r\n\r\n      // ----- Transform the header to a 'usable' info\r\n      $this->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n    }\r\n\r\n    // ----- Zip file comment\r\n    $v_comment = '';\r\n    if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n      $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n    }\r\n\r\n    // ----- Calculate the size of the central header\r\n    $v_size = @ftell($this->zip_fd)-$v_offset;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_count, $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileList()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_filedescr_list : An array containing the file description\r\n  //                      or directory names to add in the zip\r\n  //   $p_result_list : list of added files with their properties (specially the status field)\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileList($p_filedescr_list, &$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_header = array();\r\n\r\n    // ----- Recuperate the current number of elt in list\r\n    $v_nb = sizeof($p_result_list);\r\n\r\n    // ----- Loop on the files\r\n    for ($j=0; ($j<sizeof($p_filedescr_list)) && ($v_result==1); $j++) {\r\n      // ----- Format the filename\r\n      $p_filedescr_list[$j]['filename']\r\n      = PclZipUtilTranslateWinPath($p_filedescr_list[$j]['filename'], false);\r\n\r\n\r\n      // ----- Skip empty file names\r\n      // TBC : Can this be possible ? not checked in DescrParseAtt ?\r\n      if ($p_filedescr_list[$j]['filename'] == \"\") {\r\n        continue;\r\n      }\r\n\r\n      // ----- Check the filename\r\n      if (   ($p_filedescr_list[$j]['type'] != 'virtual_file')\r\n          && (!file_exists($p_filedescr_list[$j]['filename']))) {\r\n        PclZip::privErrorLog(PCLZIP_ERR_MISSING_FILE, \"File '\".$p_filedescr_list[$j]['filename'].\"' does not exist\");\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Look if it is a file or a dir with no all path remove option\r\n      // or a dir with all its path removed\r\n//      if (   (is_file($p_filedescr_list[$j]['filename']))\r\n//          || (   is_dir($p_filedescr_list[$j]['filename'])\r\n      if (   ($p_filedescr_list[$j]['type'] == 'file')\r\n          || ($p_filedescr_list[$j]['type'] == 'virtual_file')\r\n          || (   ($p_filedescr_list[$j]['type'] == 'folder')\r\n              && (   !isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])\r\n                  || !$p_options[PCLZIP_OPT_REMOVE_ALL_PATH]))\r\n          ) {\r\n\r\n        // ----- Add the file\r\n        $v_result = $this->privAddFile($p_filedescr_list[$j], $v_header,\r\n                                       $p_options);\r\n        if ($v_result != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Store the file infos\r\n        $p_result_list[$v_nb++] = $v_header;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n    // TBC : Already done in the fileAtt check ... ?\r\n    if ($p_filename == \"\") {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_PARAMETER, \"Invalid file list parameter (invalid or empty list)\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Look for a stored different filename\r\n    /* TBC : Removed\r\n    if (isset($p_filedescr['stored_filename'])) {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    else {\r\n      $v_stored_filename = $p_filedescr['stored_filename'];\r\n    }\r\n    */\r\n\r\n    // ----- Set the file properties\r\n    clearstatcache();\r\n    $p_header['version'] = 20;\r\n    $p_header['version_extracted'] = 10;\r\n    $p_header['flag'] = 0;\r\n    $p_header['compression'] = 0;\r\n    $p_header['crc'] = 0;\r\n    $p_header['compressed_size'] = 0;\r\n    $p_header['filename_len'] = strlen($p_filename);\r\n    $p_header['extra_len'] = 0;\r\n    $p_header['disk'] = 0;\r\n    $p_header['internal'] = 0;\r\n    $p_header['offset'] = 0;\r\n    $p_header['filename'] = $p_filename;\r\n// TBC : Removed    $p_header['stored_filename'] = $v_stored_filename;\r\n    $p_header['stored_filename'] = $p_filedescr['stored_filename'];\r\n    $p_header['extra'] = '';\r\n    $p_header['status'] = 'ok';\r\n    $p_header['index'] = -1;\r\n\r\n    // ----- Look for regular file\r\n    if ($p_filedescr['type']=='file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for regular folder\r\n    else if ($p_filedescr['type']=='folder') {\r\n      $p_header['external'] = 0x00000010;\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n      $p_header['size'] = filesize($p_filename);\r\n    }\r\n\r\n    // ----- Look for virtual file\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['external'] = 0x00000000;\r\n      $p_header['size'] = strlen($p_filedescr['content']);\r\n    }\r\n\r\n\r\n    // ----- Look for filetime\r\n    if (isset($p_filedescr['mtime'])) {\r\n      $p_header['mtime'] = $p_filedescr['mtime'];\r\n    }\r\n    else if ($p_filedescr['type'] == 'virtual_file') {\r\n      $p_header['mtime'] = time();\r\n    }\r\n    else {\r\n      $p_header['mtime'] = filemtime($p_filename);\r\n    }\r\n\r\n    // ------ Look for file comment\r\n    if (isset($p_filedescr['comment'])) {\r\n      $p_header['comment_len'] = strlen($p_filedescr['comment']);\r\n      $p_header['comment'] = $p_filedescr['comment'];\r\n    }\r\n    else {\r\n      $p_header['comment_len'] = 0;\r\n      $p_header['comment'] = '';\r\n    }\r\n\r\n    // ----- Look for pre-add callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_ADD].'(PCLZIP_CB_PRE_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_ADD](PCLZIP_CB_PRE_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_header['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      if ($p_header['stored_filename'] != $v_local_header['stored_filename']) {\r\n        $p_header['stored_filename'] = PclZipUtilPathReduction($v_local_header['stored_filename']);\r\n      }\r\n    }\r\n\r\n    // ----- Look for empty stored filename\r\n    if ($p_header['stored_filename'] == \"\") {\r\n      $p_header['status'] = \"filtered\";\r\n    }\r\n\r\n    // ----- Check the path length\r\n    if (strlen($p_header['stored_filename']) > 0xFF) {\r\n      $p_header['status'] = 'filename_too_long';\r\n    }\r\n\r\n    // ----- Look if no error, or file not skipped\r\n    if ($p_header['status'] == 'ok') {\r\n\r\n      // ----- Look for a file\r\n      if ($p_filedescr['type'] == 'file') {\r\n        // ----- Look for using temporary file to zip\r\n        if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n            && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                    && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_header['size'])) ) ) {\r\n          $v_result = $this->privAddFileUsingTempFile($p_filedescr, $p_header, $p_options);\r\n          if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n            return $v_result;\r\n          }\r\n        }\r\n\r\n        // ----- Use \"in memory\" zip algo\r\n        else {\r\n\r\n        // ----- Open the source file\r\n        if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n          PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Read the file content\r\n        $v_content = @fread($v_file, $p_header['size']);\r\n\r\n        // ----- Close the file\r\n        @fclose($v_file);\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n\r\n        }\r\n\r\n      }\r\n\r\n      // ----- Look for a virtual file (a file from string)\r\n      else if ($p_filedescr['type'] == 'virtual_file') {\r\n\r\n        $v_content = $p_filedescr['content'];\r\n\r\n        // ----- Calculate the CRC\r\n        $p_header['crc'] = @crc32($v_content);\r\n\r\n        // ----- Look for no compression\r\n        if ($p_options[PCLZIP_OPT_NO_COMPRESSION]) {\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = $p_header['size'];\r\n          $p_header['compression'] = 0;\r\n        }\r\n\r\n        // ----- Look for normal compression\r\n        else {\r\n          // ----- Compress the content\r\n          $v_content = @gzdeflate($v_content);\r\n\r\n          // ----- Set header parameters\r\n          $p_header['compressed_size'] = strlen($v_content);\r\n          $p_header['compression'] = 8;\r\n        }\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n          @fclose($v_file);\r\n          return $v_result;\r\n        }\r\n\r\n        // ----- Write the compressed (or not) content\r\n        @fwrite($this->zip_fd, $v_content, $p_header['compressed_size']);\r\n      }\r\n\r\n      // ----- Look for a directory\r\n      else if ($p_filedescr['type'] == 'folder') {\r\n        // ----- Look for directory last '/'\r\n        if (@substr($p_header['stored_filename'], -1) != '/') {\r\n          $p_header['stored_filename'] .= '/';\r\n        }\r\n\r\n        // ----- Set the file properties\r\n        $p_header['size'] = 0;\r\n        //$p_header['external'] = 0x41FF0010;   // Value for a folder : to be checked\r\n        $p_header['external'] = 0x00000010;   // Value for a folder : to be checked\r\n\r\n        // ----- Call the header generation\r\n        if (($v_result = $this->privWriteFileHeader($p_header)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look for post-add callback\r\n    if (isset($p_options[PCLZIP_CB_POST_ADD])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_header, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_ADD].'(PCLZIP_CB_POST_ADD, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_ADD](PCLZIP_CB_POST_ADD, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Ignored\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Nothing can be modified\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privAddFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privAddFileUsingTempFile($p_filedescr, &$p_header, &$p_options)\r\n  {\r\n    $v_result=PCLZIP_ERR_NO_ERROR;\r\n\r\n    // ----- Working variable\r\n    $p_filename = $p_filedescr['filename'];\r\n\r\n\r\n    // ----- Open the source file\r\n    if (($v_file = @fopen($p_filename, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, \"Unable to open file '$p_filename' in binary read mode\");\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Creates a compressed temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_file_compressed = @gzopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = filesize($p_filename);\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @gzputs($v_file_compressed, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file);\r\n    @gzclose($v_file_compressed);\r\n\r\n    // ----- Check the minimum file size\r\n    if (filesize($v_gzip_temp_name) < 18) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'gzip temporary file \\''.$v_gzip_temp_name.'\\' has invalid filesize - should be minimum 18 bytes');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the compressed attributes\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0) {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the gzip file header\r\n    $v_binary_data = @fread($v_file_compressed, 10);\r\n    $v_data_header = unpack('a1id1/a1id2/a1cm/a1flag/Vmtime/a1xfl/a1os', $v_binary_data);\r\n\r\n    // ----- Check some parameters\r\n    $v_data_header['os'] = bin2hex($v_data_header['os']);\r\n\r\n    // ----- Read the gzip file footer\r\n    @fseek($v_file_compressed, filesize($v_gzip_temp_name)-8);\r\n    $v_binary_data = @fread($v_file_compressed, 8);\r\n    $v_data_footer = unpack('Vcrc/Vcompressed_size', $v_binary_data);\r\n\r\n    // ----- Set the attributes\r\n    $p_header['compression'] = ord($v_data_header['cm']);\r\n    //$p_header['mtime'] = $v_data_header['mtime'];\r\n    $p_header['crc'] = $v_data_footer['crc'];\r\n    $p_header['compressed_size'] = filesize($v_gzip_temp_name)-18;\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Call the header generation\r\n    if (($v_result = $this->privWriteFileHeader($p_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Add the compressed data\r\n    if (($v_file_compressed = @fopen($v_gzip_temp_name, \"rb\")) == 0)\r\n    {\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    fseek($v_file_compressed, 10);\r\n    $v_size = $p_header['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($v_file_compressed, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close the file\r\n    @fclose($v_file_compressed);\r\n\r\n    // ----- Unlink the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCalculateStoredFilename()\r\n  // Description :\r\n  //   Based on file descriptor properties and global options, this method\r\n  //   calculate the filename that will be stored in the archive.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privCalculateStoredFilename(&$p_filedescr, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Working variables\r\n    $p_filename = $p_filedescr['filename'];\r\n    if (isset($p_options[PCLZIP_OPT_ADD_PATH])) {\r\n      $p_add_dir = $p_options[PCLZIP_OPT_ADD_PATH];\r\n    }\r\n    else {\r\n      $p_add_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_PATH])) {\r\n      $p_remove_dir = $p_options[PCLZIP_OPT_REMOVE_PATH];\r\n    }\r\n    else {\r\n      $p_remove_dir = '';\r\n    }\r\n    if (isset($p_options[PCLZIP_OPT_REMOVE_ALL_PATH])) {\r\n      $p_remove_all_dir = $p_options[PCLZIP_OPT_REMOVE_ALL_PATH];\r\n    }\r\n    else {\r\n      $p_remove_all_dir = 0;\r\n    }\r\n\r\n\r\n    // ----- Look for full name change\r\n    if (isset($p_filedescr['new_full_name'])) {\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($p_filedescr['new_full_name']);\r\n    }\r\n\r\n    // ----- Look for path and/or short name change\r\n    else {\r\n\r\n      // ----- Look for short name change\r\n      // Its when we cahnge just the filename but not the path\r\n      if (isset($p_filedescr['new_short_name'])) {\r\n        $v_path_info = pathinfo($p_filename);\r\n        $v_dir = '';\r\n        if ($v_path_info['dirname'] != '') {\r\n          $v_dir = $v_path_info['dirname'].'/';\r\n        }\r\n        $v_stored_filename = $v_dir.$p_filedescr['new_short_name'];\r\n      }\r\n      else {\r\n        // ----- Calculate the stored filename\r\n        $v_stored_filename = $p_filename;\r\n      }\r\n\r\n      // ----- Look for all path to remove\r\n      if ($p_remove_all_dir) {\r\n        $v_stored_filename = basename($p_filename);\r\n      }\r\n      // ----- Look for partial path remove\r\n      else if ($p_remove_dir != \"\") {\r\n        if (substr($p_remove_dir, -1) != '/')\r\n          $p_remove_dir .= \"/\";\r\n\r\n        if (   (substr($p_filename, 0, 2) == \"./\")\r\n            || (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n\r\n          if (   (substr($p_filename, 0, 2) == \"./\")\r\n              && (substr($p_remove_dir, 0, 2) != \"./\")) {\r\n            $p_remove_dir = \"./\".$p_remove_dir;\r\n          }\r\n          if (   (substr($p_filename, 0, 2) != \"./\")\r\n              && (substr($p_remove_dir, 0, 2) == \"./\")) {\r\n            $p_remove_dir = substr($p_remove_dir, 2);\r\n          }\r\n        }\r\n\r\n        $v_compare = PclZipUtilPathInclusion($p_remove_dir,\r\n                                             $v_stored_filename);\r\n        if ($v_compare > 0) {\r\n          if ($v_compare == 2) {\r\n            $v_stored_filename = \"\";\r\n          }\r\n          else {\r\n            $v_stored_filename = substr($v_stored_filename,\r\n                                        strlen($p_remove_dir));\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Remove drive letter if any\r\n      $v_stored_filename = PclZipUtilTranslateWinPath($v_stored_filename);\r\n\r\n      // ----- Look for path to add\r\n      if ($p_add_dir != \"\") {\r\n        if (substr($p_add_dir, -1) == \"/\")\r\n          $v_stored_filename = $p_add_dir.$v_stored_filename;\r\n        else\r\n          $v_stored_filename = $p_add_dir.\"/\".$v_stored_filename;\r\n      }\r\n    }\r\n\r\n    // ----- Filename (reduce the path of stored name)\r\n    $v_stored_filename = PclZipUtilPathReduction($v_stored_filename);\r\n    $p_filedescr['stored_filename'] = $v_stored_filename;\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Store the offset position of the file\r\n    $p_header['offset'] = ftell($this->zip_fd);\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvVVVvv\", 0x04034b50,\r\n                          $p_header['version_extracted'], $p_header['flag'],\r\n                          $p_header['compression'], $v_mtime, $v_mdate,\r\n                          $p_header['crc'], $p_header['compressed_size'],\r\n                          $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len']);\r\n\r\n    // ----- Write the first 148 bytes of the header in the archive\r\n    fputs($this->zip_fd, $v_binary_data, 30);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // TBC\r\n    //for(reset($p_header); $key = key($p_header); next($p_header)) {\r\n    //}\r\n\r\n    // ----- Transform UNIX mtime to DOS format mdate/mtime\r\n    $v_date = getdate($p_header['mtime']);\r\n    $v_mtime = ($v_date['hours']<<11) + ($v_date['minutes']<<5) + $v_date['seconds']/2;\r\n    $v_mdate = (($v_date['year']-1980)<<9) + ($v_date['mon']<<5) + $v_date['mday'];\r\n\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvvvVVVvvvvvVV\", 0x02014b50,\r\n                          $p_header['version'], $p_header['version_extracted'],\r\n                          $p_header['flag'], $p_header['compression'],\r\n                          $v_mtime, $v_mdate, $p_header['crc'],\r\n                          $p_header['compressed_size'], $p_header['size'],\r\n                          strlen($p_header['stored_filename']),\r\n                          $p_header['extra_len'], $p_header['comment_len'],\r\n                          $p_header['disk'], $p_header['internal'],\r\n                          $p_header['external'], $p_header['offset']);\r\n\r\n    // ----- Write the 42 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 46);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_header['stored_filename']) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['stored_filename'], strlen($p_header['stored_filename']));\r\n    }\r\n    if ($p_header['extra_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['extra'], $p_header['extra_len']);\r\n    }\r\n    if ($p_header['comment_len'] != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_header['comment'], $p_header['comment_len']);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privWriteCentralHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privWriteCentralHeader($p_nb_entries, $p_size, $p_offset, $p_comment)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Packed data\r\n    $v_binary_data = pack(\"VvvvvVVv\", 0x06054b50, 0, 0, $p_nb_entries,\r\n                          $p_nb_entries, $p_size,\r\n                          $p_offset, strlen($p_comment));\r\n\r\n    // ----- Write the 22 bytes of the header in the zip file\r\n    fputs($this->zip_fd, $v_binary_data, 22);\r\n\r\n    // ----- Write the variable fields\r\n    if (strlen($p_comment) != 0)\r\n    {\r\n      fputs($this->zip_fd, $p_comment, strlen($p_comment));\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privList()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privList(&$p_list)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Open the zip file\r\n    if (($this->zip_fd = @fopen($this->zipname, 'rb')) == 0)\r\n    {\r\n      // ----- Magic quotes trick\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive \\''.$this->zipname.'\\' in binary read mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of Central Dir\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_central_dir['offset']))\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    for ($i=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n      // ----- Read the file header\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        $this->privSwapBackMagicQuotes();\r\n        return $v_result;\r\n      }\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Get the only interesting attributes\r\n      $this->privConvertHeader2FileInfo($v_header, $p_list[$i]);\r\n      unset($v_header);\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privConvertHeader2FileInfo()\r\n  // Description :\r\n  //   This function takes the file informations from the central directory\r\n  //   entries and extract the interesting parameters that will be given back.\r\n  //   The resulting file infos are set in the array $p_info\r\n  //     $p_info['filename'] : Filename with full path. Given by user (add),\r\n  //                           extracted in the filesystem (extract).\r\n  //     $p_info['stored_filename'] : Stored filename in the archive.\r\n  //     $p_info['size'] = Size of the file.\r\n  //     $p_info['compressed_size'] = Compressed size of the file.\r\n  //     $p_info['mtime'] = Last modification date of the file.\r\n  //     $p_info['comment'] = Comment associated with the file.\r\n  //     $p_info['folder'] = true/false : indicates if the entry is a folder or not.\r\n  //     $p_info['status'] = status of the action on the file.\r\n  //     $p_info['crc'] = CRC of the file content.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privConvertHeader2FileInfo($p_header, &$p_info)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Get the interesting attributes\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['filename']);\r\n    $p_info['filename'] = $v_temp_path;\r\n    $v_temp_path = PclZipUtilPathReduction($p_header['stored_filename']);\r\n    $p_info['stored_filename'] = $v_temp_path;\r\n    $p_info['size'] = $p_header['size'];\r\n    $p_info['compressed_size'] = $p_header['compressed_size'];\r\n    $p_info['mtime'] = $p_header['mtime'];\r\n    $p_info['comment'] = $p_header['comment'];\r\n    $p_info['folder'] = (($p_header['external']&0x00000010)==0x00000010);\r\n    $p_info['index'] = $p_header['index'];\r\n    $p_info['status'] = $p_header['status'];\r\n    $p_info['crc'] = $p_header['crc'];\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractByRule()\r\n  // Description :\r\n  //   Extract a file or directory depending of rules (by index, by name, ...)\r\n  // Parameters :\r\n  //   $p_file_list : An array where will be placed the properties of each\r\n  //                  extracted file\r\n  //   $p_path : Path to add while writing the extracted files\r\n  //   $p_remove_path : Path to remove (from the file memorized path) while writing the\r\n  //                    extracted files. If the path does not match the file path,\r\n  //                    the file is extracted with its memorized path.\r\n  //                    $p_remove_path does not apply to 'list' mode.\r\n  //                    $p_path and $p_remove_path are commulative.\r\n  // Return Values :\r\n  //   1 on success,0 or less on error (see error code list)\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractByRule(&$p_file_list, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Magic quotes trick\r\n    $this->privDisableMagicQuotes();\r\n\r\n    // ----- Check the path\r\n    if (   ($p_path == \"\")\r\n        || (   (substr($p_path, 0, 1) != \"/\")\r\n            && (substr($p_path, 0, 3) != \"../\")\r\n            && (substr($p_path,1,2)!=\":/\")))\r\n      $p_path = \"./\".$p_path;\r\n\r\n    // ----- Reduce the path last (and duplicated) '/'\r\n    if (($p_path != \"./\") && ($p_path != \"/\"))\r\n    {\r\n      // ----- Look for the path end '/'\r\n      while (substr($p_path, -1) == \"/\")\r\n      {\r\n        $p_path = substr($p_path, 0, strlen($p_path)-1);\r\n      }\r\n    }\r\n\r\n    // ----- Look for path to remove format (should end by /)\r\n    if (($p_remove_path != \"\") && (substr($p_remove_path, -1) != '/'))\r\n    {\r\n      $p_remove_path .= '/';\r\n    }\r\n    $p_remove_path_size = strlen($p_remove_path);\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result = $this->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privSwapBackMagicQuotes();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n      $this->privSwapBackMagicQuotes();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n\r\n    // ----- Read each entry\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read next Central dir entry\r\n      @rewind($this->zip_fd);\r\n      if (@fseek($this->zip_fd, $v_pos_entry))\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read the file header\r\n      $v_header = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header)) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n        $this->privSwapBackMagicQuotes();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n      // ----- Store the index\r\n      $v_header['index'] = $i;\r\n\r\n      // ----- Store the file position\r\n      $v_pos_entry = ftell($this->zip_fd);\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_extract = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_extract); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_extract = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_extract = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header['stored_filename'])) {\r\n              $v_extract = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_extract); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_extract = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for no rule, which means extract all the archive\r\n      else {\r\n          $v_extract = true;\r\n      }\r\n\r\n      // ----- Check compression method\r\n      if (   ($v_extract)\r\n          && (   ($v_header['compression'] != 8)\r\n              && ($v_header['compression'] != 0))) {\r\n          $v_header['status'] = 'unsupported_compression';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_COMPRESSION,\r\n                                   \"Filename '\".$v_header['stored_filename'].\"' is \"\r\n                                       .\"compressed by an unsupported compression \"\r\n                                       .\"method (\".$v_header['compression'].\") \");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n      }\r\n\r\n      // ----- Check encrypted files\r\n      if (($v_extract) && (($v_header['flag'] & 1) == 1)) {\r\n          $v_header['status'] = 'unsupported_encryption';\r\n\r\n          // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n          if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n              && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n              $this->privSwapBackMagicQuotes();\r\n\r\n              PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION,\r\n                                   \"Unsupported encryption for \"\r\n                                       .\" filename '\".$v_header['stored_filename']\r\n                                   .\"'\");\r\n\r\n              return PclZip::errorCode();\r\n          }\r\n    }\r\n\r\n      // ----- Look for real extraction\r\n      if (($v_extract) && ($v_header['status'] != 'ok')) {\r\n          $v_result = $this->privConvertHeader2FileInfo($v_header,\r\n                                                $p_file_list[$v_nb_extracted++]);\r\n          if ($v_result != 1) {\r\n              $this->privCloseFd();\r\n              $this->privSwapBackMagicQuotes();\r\n              return $v_result;\r\n          }\r\n\r\n          $v_extract = false;\r\n      }\r\n\r\n      // ----- Look for real extraction\r\n      if ($v_extract)\r\n      {\r\n\r\n        // ----- Go to the file position\r\n        @rewind($this->zip_fd);\r\n        if (@fseek($this->zip_fd, $v_header['offset']))\r\n        {\r\n          // ----- Close the zip file\r\n          $this->privCloseFd();\r\n\r\n          $this->privSwapBackMagicQuotes();\r\n\r\n          // ----- Error log\r\n          PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n          // ----- Return\r\n          return PclZip::errorCode();\r\n        }\r\n\r\n        // ----- Look for extraction as string\r\n        if ($p_options[PCLZIP_OPT_EXTRACT_AS_STRING]) {\r\n\r\n          $v_string = '';\r\n\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFileAsString($v_header, $v_string, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Set the file content\r\n          $p_file_list[$v_nb_extracted]['content'] = $v_string;\r\n\r\n          // ----- Next extracted file\r\n          $v_nb_extracted++;\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for extraction in standard output\r\n        elseif (   (isset($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT]))\r\n                && ($p_options[PCLZIP_OPT_EXTRACT_IN_OUTPUT])) {\r\n          // ----- Extracting the file in standard output\r\n          $v_result1 = $this->privExtractFileInOutput($v_header, $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n        // ----- Look for normal extraction\r\n        else {\r\n          // ----- Extracting the file\r\n          $v_result1 = $this->privExtractFile($v_header,\r\n                                              $p_path, $p_remove_path,\r\n                                              $p_remove_all_path,\r\n                                              $p_options);\r\n          if ($v_result1 < 1) {\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n            return $v_result1;\r\n          }\r\n\r\n          // ----- Get the only interesting attributes\r\n          if (($v_result = $this->privConvertHeader2FileInfo($v_header, $p_file_list[$v_nb_extracted++])) != 1)\r\n          {\r\n            // ----- Close the zip file\r\n            $this->privCloseFd();\r\n            $this->privSwapBackMagicQuotes();\r\n\r\n            return $v_result;\r\n          }\r\n\r\n          // ----- Look for user callback abort\r\n          if ($v_result1 == 2) {\r\n              break;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Close the zip file\r\n    $this->privCloseFd();\r\n    $this->privSwapBackMagicQuotes();\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //\r\n  // 1 : ... ?\r\n  // PCLZIP_ERR_USER_ABORTED(2) : User ask for extraction stop in callback\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFile(&$p_entry, $p_path, $p_remove_path, $p_remove_all_path, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for all path to remove\r\n    if ($p_remove_all_path == true) {\r\n        // ----- Look for folder entry that not need to be extracted\r\n        if (($p_entry['external']&0x00000010)==0x00000010) {\r\n\r\n            $p_entry['status'] = \"filtered\";\r\n\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Get the basename of the path\r\n        $p_entry['filename'] = basename($p_entry['filename']);\r\n    }\r\n\r\n    // ----- Look for path to remove\r\n    else if ($p_remove_path != \"\")\r\n    {\r\n      if (PclZipUtilPathInclusion($p_remove_path, $p_entry['filename']) == 2)\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"filtered\";\r\n\r\n        // ----- Return\r\n        return $v_result;\r\n      }\r\n\r\n      $p_remove_path_size = strlen($p_remove_path);\r\n      if (substr($p_entry['filename'], 0, $p_remove_path_size) == $p_remove_path)\r\n      {\r\n\r\n        // ----- Remove the path\r\n        $p_entry['filename'] = substr($p_entry['filename'], $p_remove_path_size);\r\n\r\n      }\r\n    }\r\n\r\n    // Added by LS Team to check for invalid paths\r\n    $p_entry['filename'] = get_absolute_path($p_entry['filename']);\r\n\r\n    // ----- Add the path\r\n    if ($p_path != '') {\r\n      $p_entry['filename'] = $p_path.\"/\".$p_entry['filename'];\r\n    }\r\n\r\n    // ----- Check a base_dir_restriction\r\n    if (isset($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION])) {\r\n      $v_inclusion\r\n      = PclZipUtilPathInclusion($p_options[PCLZIP_OPT_EXTRACT_DIR_RESTRICTION],\r\n                                $p_entry['filename']);\r\n      if ($v_inclusion == 0) {\r\n\r\n        PclZip::privErrorLog(PCLZIP_ERR_DIRECTORY_RESTRICTION,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"outside PCLZIP_OPT_EXTRACT_DIR_RESTRICTION\");\r\n\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n    // ----- Look for specific actions while the file exist\r\n    if (file_exists($p_entry['filename']))\r\n    {\r\n\r\n      // ----- Look if file is a directory\r\n      if (is_dir($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"already_a_directory\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_ALREADY_A_DIRECTORY,\r\n                                 \"Filename '\".$p_entry['filename'].\"' is \"\r\n                                 .\"already used by an existing directory\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n      // ----- Look if file is write protected\r\n      else if (!is_writeable($p_entry['filename']))\r\n      {\r\n\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"write_protected\";\r\n\r\n        // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n        // For historical reason first PclZip implementation does not stop\r\n        // when this kind of error occurs.\r\n        if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n            && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n            PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                                 \"Filename '\".$p_entry['filename'].\"' exists \"\r\n                                 .\"and is write protected\");\r\n\r\n            return PclZip::errorCode();\r\n            }\r\n      }\r\n\r\n      // ----- Look if the extracted file is older\r\n      else if (filemtime($p_entry['filename']) > $p_entry['mtime'])\r\n      {\r\n        // ----- Change the file status\r\n        if (   (isset($p_options[PCLZIP_OPT_REPLACE_NEWER]))\r\n            && ($p_options[PCLZIP_OPT_REPLACE_NEWER]===true)) {\r\n            }\r\n            else {\r\n            $p_entry['status'] = \"newer_exist\";\r\n\r\n            // ----- Look for PCLZIP_OPT_STOP_ON_ERROR\r\n            // For historical reason first PclZip implementation does not stop\r\n            // when this kind of error occurs.\r\n            if (   (isset($p_options[PCLZIP_OPT_STOP_ON_ERROR]))\r\n                && ($p_options[PCLZIP_OPT_STOP_ON_ERROR]===true)) {\r\n\r\n                PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL,\r\n                         \"Newer version of '\".$p_entry['filename'].\"' exists \"\r\n                        .\"and option PCLZIP_OPT_REPLACE_NEWER is not selected\");\r\n\r\n                return PclZip::errorCode();\r\n              }\r\n            }\r\n      }\r\n      else {\r\n      }\r\n    }\r\n\r\n    // ----- Check the directory availability and create it if necessary\r\n    else {\r\n      if ((($p_entry['external']&0x00000010)==0x00000010) || (substr($p_entry['filename'], -1) == '/'))\r\n        $v_dir_to_check = $p_entry['filename'];\r\n      else if (!strstr($p_entry['filename'], \"/\"))\r\n        $v_dir_to_check = \"\";\r\n      else\r\n        $v_dir_to_check = dirname($p_entry['filename']);\r\n\r\n        if (($v_result = $this->privDirCheck($v_dir_to_check, (($p_entry['external']&0x00000010)==0x00000010))) != 1) {\r\n\r\n          // ----- Change the file status\r\n          $p_entry['status'] = \"path_creation_fail\";\r\n\r\n          // ----- Return\r\n          //return $v_result;\r\n          $v_result = 1;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010))\r\n      {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n              // ----- Opening destination file\r\n          if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0)\r\n          {\r\n\r\n            // ----- Change the file status\r\n            $p_entry['status'] = \"write_error\";\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n          }\r\n\r\n\r\n          // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n          $v_size = $p_entry['compressed_size'];\r\n          while ($v_size != 0)\r\n          {\r\n            $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n            $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n            /* Try to speed up the code\r\n            $v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n            @fwrite($v_dest_file, $v_binary_data, $v_read_size);\r\n            */\r\n            @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n            $v_size -= $v_read_size;\r\n          }\r\n\r\n          // ----- Closing the destination file\r\n          fclose($v_dest_file);\r\n\r\n          // ----- Change the file mtime\r\n          touch($p_entry['filename'], $p_entry['mtime']);\r\n\r\n\r\n        }\r\n        else {\r\n          // ----- TBC\r\n          // Need to be finished\r\n          if (($p_entry['flag'] & 1) == 1) {\r\n            PclZip::privErrorLog(PCLZIP_ERR_UNSUPPORTED_ENCRYPTION, 'File \\''.$p_entry['filename'].'\\' is encrypted. Encrypted files are not supported.');\r\n            return PclZip::errorCode();\r\n          }\r\n\r\n\r\n          // ----- Look for using temporary file to unzip\r\n          if ( (!isset($p_options[PCLZIP_OPT_TEMP_FILE_OFF]))\r\n              && (isset($p_options[PCLZIP_OPT_TEMP_FILE_ON])\r\n                  || (isset($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD])\r\n                      && ($p_options[PCLZIP_OPT_TEMP_FILE_THRESHOLD] <= $p_entry['size'])) ) ) {\r\n            $v_result = $this->privExtractFileUsingTempFile($p_entry, $p_options);\r\n            if ($v_result < PCLZIP_ERR_NO_ERROR) {\r\n              return $v_result;\r\n            }\r\n          }\r\n\r\n          // ----- Look for extract in memory\r\n          else {\r\n\r\n\r\n            // ----- Read the compressed file in a buffer (one shot)\r\n            $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n            // ----- Decompress the file\r\n            $v_file_content = @gzinflate($v_buffer);\r\n            unset($v_buffer);\r\n            if ($v_file_content === FALSE) {\r\n\r\n              // ----- Change the file status\r\n              // TBC\r\n              $p_entry['status'] = \"error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Opening destination file\r\n            if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n\r\n              // ----- Change the file status\r\n              $p_entry['status'] = \"write_error\";\r\n\r\n              return $v_result;\r\n            }\r\n\r\n            // ----- Write the uncompressed data\r\n            @fwrite($v_dest_file, $v_file_content, $p_entry['size']);\r\n            unset($v_file_content);\r\n\r\n            // ----- Closing the destination file\r\n            @fclose($v_dest_file);\r\n\r\n          }\r\n\r\n          // ----- Change the file mtime\r\n          @touch($p_entry['filename'], $p_entry['mtime']);\r\n        }\r\n\r\n        // ----- Look for chmod option\r\n        if (isset($p_options[PCLZIP_OPT_SET_CHMOD])) {\r\n\r\n          // ----- Change the mode of the file\r\n          @chmod($p_entry['filename'], $p_options[PCLZIP_OPT_SET_CHMOD]);\r\n        }\r\n\r\n      }\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileUsingTempFile()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileUsingTempFile(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Creates a temporary file\r\n    $v_gzip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.gz';\r\n    if (($v_dest_file = @fopen($v_gzip_temp_name, \"wb\")) == 0) {\r\n      fclose($v_file);\r\n      PclZip::privErrorLog(PCLZIP_ERR_WRITE_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary write mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Write gz file format header\r\n    $v_binary_data = pack('va1a1Va1a1', 0x8b1f, Chr($p_entry['compression']), Chr(0x00), time(), Chr(0x00), Chr(3));\r\n    @fwrite($v_dest_file, $v_binary_data, 10);\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['compressed_size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Write gz file format footer\r\n    $v_binary_data = pack('VV', $p_entry['crc'], $p_entry['size']);\r\n    @fwrite($v_dest_file, $v_binary_data, 8);\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_dest_file);\r\n\r\n    // ----- Opening destination file\r\n    if (($v_dest_file = @fopen($p_entry['filename'], 'wb')) == 0) {\r\n      $p_entry['status'] = \"write_error\";\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary gz file\r\n    if (($v_src_file = @gzopen($v_gzip_temp_name, 'rb')) == 0) {\r\n      @fclose($v_dest_file);\r\n      $p_entry['status'] = \"read_error\";\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_gzip_temp_name.'\\' in binary read mode');\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n\r\n    // ----- Read the file by PCLZIP_READ_BLOCK_SIZE octets blocks\r\n    $v_size = $p_entry['size'];\r\n    while ($v_size != 0) {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @gzread($v_src_file, $v_read_size);\r\n      //$v_binary_data = pack('a'.$v_read_size, $v_buffer);\r\n      @fwrite($v_dest_file, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n    @fclose($v_dest_file);\r\n    @gzclose($v_src_file);\r\n\r\n    // ----- Delete the temporary file\r\n    @unlink($v_gzip_temp_name);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileInOutput()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileInOutput(&$p_entry, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1) {\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n    // ----- Trace\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n        if ($p_entry['compressed_size'] == $p_entry['size']) {\r\n\r\n          // ----- Read the file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_buffer;\r\n          unset($v_buffer);\r\n        }\r\n        else {\r\n\r\n          // ----- Read the compressed file in a buffer (one shot)\r\n          $v_buffer = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          $v_file_content = gzinflate($v_buffer);\r\n          unset($v_buffer);\r\n\r\n          // ----- Send the file to the output\r\n          echo $v_file_content;\r\n          unset($v_file_content);\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Change abort status\r\n    if ($p_entry['status'] == \"aborted\") {\r\n      $p_entry['status'] = \"skipped\";\r\n    }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privExtractFileAsString()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privExtractFileAsString(&$p_entry, &$p_string, &$p_options)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the file header\r\n    $v_header = array();\r\n    if (($v_result = $this->privReadFileHeader($v_header)) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n\r\n    // ----- Check that the file header is coherent with $p_entry info\r\n    if ($this->privCheckFileHeaders($v_header, $p_entry) != 1) {\r\n        // TBC\r\n    }\r\n\r\n    // ----- Look for pre-extract callback\r\n    if (isset($p_options[PCLZIP_CB_PRE_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_PRE_EXTRACT].'(PCLZIP_CB_PRE_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_PRE_EXTRACT](PCLZIP_CB_PRE_EXTRACT, $v_local_header);\r\n      if ($v_result == 0) {\r\n        // ----- Change the file status\r\n        $p_entry['status'] = \"skipped\";\r\n        $v_result = 1;\r\n      }\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n        // ----- This status is internal and will be changed in 'skipped'\r\n        $p_entry['status'] = \"aborted\";\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n\r\n      // ----- Update the informations\r\n      // Only some fields can be modified\r\n      $p_entry['filename'] = $v_local_header['filename'];\r\n    }\r\n\r\n\r\n    // ----- Look if extraction should be done\r\n    if ($p_entry['status'] == 'ok') {\r\n\r\n      // ----- Do the extraction (if not a folder)\r\n      if (!(($p_entry['external']&0x00000010)==0x00000010)) {\r\n        // ----- Look for not compressed file\r\n  //      if ($p_entry['compressed_size'] == $p_entry['size'])\r\n        if ($p_entry['compression'] == 0) {\r\n\r\n          // ----- Reading the file\r\n          $p_string = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n        }\r\n        else {\r\n\r\n          // ----- Reading the file\r\n          $v_data = @fread($this->zip_fd, $p_entry['compressed_size']);\r\n\r\n          // ----- Decompress the file\r\n          if (($p_string = @gzinflate($v_data)) === FALSE) {\r\n              // TBC\r\n          }\r\n        }\r\n\r\n        // ----- Trace\r\n      }\r\n      else {\r\n          // TBC : error : can not extract a folder in a string\r\n      }\r\n\r\n    }\r\n\r\n      // ----- Change abort status\r\n      if ($p_entry['status'] == \"aborted\") {\r\n        $p_entry['status'] = \"skipped\";\r\n      }\r\n\r\n    // ----- Look for post-extract callback\r\n    elseif (isset($p_options[PCLZIP_CB_POST_EXTRACT])) {\r\n\r\n      // ----- Generate a local information\r\n      $v_local_header = array();\r\n      $this->privConvertHeader2FileInfo($p_entry, $v_local_header);\r\n\r\n      // ----- Swap the content to header\r\n      $v_local_header['content'] = $p_string;\r\n      $p_string = '';\r\n\r\n      // ----- Call the callback\r\n      // Here I do not use call_user_func() because I need to send a reference to the\r\n      // header.\r\n//      eval('$v_result = '.$p_options[PCLZIP_CB_POST_EXTRACT].'(PCLZIP_CB_POST_EXTRACT, $v_local_header);');\r\n      $v_result = $p_options[PCLZIP_CB_POST_EXTRACT](PCLZIP_CB_POST_EXTRACT, $v_local_header);\r\n\r\n      // ----- Swap back the content to header\r\n      $p_string = $v_local_header['content'];\r\n      unset($v_local_header['content']);\r\n\r\n      // ----- Look for abort result\r\n      if ($v_result == 2) {\r\n          $v_result = PCLZIP_ERR_USER_ABORTED;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x04034b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 26);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 26)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vversion/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    $p_header['filename'] = fread($this->zip_fd, $v_data['filename_len']);\r\n\r\n    // ----- Get extra_fields\r\n    if ($v_data['extra_len'] != 0) {\r\n      $p_header['extra'] = fread($this->zip_fd, $v_data['extra_len']);\r\n    }\r\n    else {\r\n      $p_header['extra'] = '';\r\n    }\r\n\r\n    // ----- Extract properties\r\n    $p_header['version_extracted'] = $v_data['version'];\r\n    $p_header['compression'] = $v_data['compression'];\r\n    $p_header['size'] = $v_data['size'];\r\n    $p_header['compressed_size'] = $v_data['compressed_size'];\r\n    $p_header['crc'] = $v_data['crc'];\r\n    $p_header['flag'] = $v_data['flag'];\r\n    $p_header['filename_len'] = $v_data['filename_len'];\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    $p_header['mdate'] = $v_data['mdate'];\r\n    $p_header['mtime'] = $v_data['mtime'];\r\n    if ($p_header['mdate'] && $p_header['mtime'])\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // TBC\r\n    //for(reset($v_data); $key = key($v_data); next($v_data)) {\r\n    //}\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set the status field\r\n    $p_header['status'] = \"ok\";\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadCentralFileHeader()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadCentralFileHeader(&$p_header)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Read the 4 bytes signature\r\n    $v_binary_data = @fread($this->zip_fd, 4);\r\n    $v_data = unpack('Vid', $v_binary_data);\r\n\r\n    // ----- Check signature\r\n    if ($v_data['id'] != 0x02014b50)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Invalid archive structure');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read the first 42 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 42);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 42)\r\n    {\r\n      $p_header['filename'] = \"\";\r\n      $p_header['status'] = \"invalid_header\";\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid block size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $p_header = unpack('vversion/vversion_extracted/vflag/vcompression/vmtime/vmdate/Vcrc/Vcompressed_size/Vsize/vfilename_len/vextra_len/vcomment_len/vdisk/vinternal/Vexternal/Voffset', $v_binary_data);\r\n\r\n    // ----- Get filename\r\n    if ($p_header['filename_len'] != 0)\r\n      $p_header['filename'] = fread($this->zip_fd, $p_header['filename_len']);\r\n    else\r\n      $p_header['filename'] = '';\r\n\r\n    // ----- Get extra\r\n    if ($p_header['extra_len'] != 0)\r\n      $p_header['extra'] = fread($this->zip_fd, $p_header['extra_len']);\r\n    else\r\n      $p_header['extra'] = '';\r\n\r\n    // ----- Get comment\r\n    if ($p_header['comment_len'] != 0)\r\n      $p_header['comment'] = fread($this->zip_fd, $p_header['comment_len']);\r\n    else\r\n      $p_header['comment'] = '';\r\n\r\n    // ----- Extract properties\r\n\r\n    // ----- Recuperate date in UNIX format\r\n    //if ($p_header['mdate'] && $p_header['mtime'])\r\n    // TBC : bug : this was ignoring time with 0/0/0\r\n    if (1)\r\n    {\r\n      // ----- Extract time\r\n      $v_hour = ($p_header['mtime'] & 0xF800) >> 11;\r\n      $v_minute = ($p_header['mtime'] & 0x07E0) >> 5;\r\n      $v_seconde = ($p_header['mtime'] & 0x001F)*2;\r\n\r\n      // ----- Extract date\r\n      $v_year = (($p_header['mdate'] & 0xFE00) >> 9) + 1980;\r\n      $v_month = ($p_header['mdate'] & 0x01E0) >> 5;\r\n      $v_day = $p_header['mdate'] & 0x001F;\r\n\r\n      // ----- Get UNIX date format\r\n      $p_header['mtime'] = @mktime($v_hour, $v_minute, $v_seconde, $v_month, $v_day, $v_year);\r\n\r\n    }\r\n    else\r\n    {\r\n      $p_header['mtime'] = time();\r\n    }\r\n\r\n    // ----- Set the stored filename\r\n    $p_header['stored_filename'] = $p_header['filename'];\r\n\r\n    // ----- Set default status to ok\r\n    $p_header['status'] = 'ok';\r\n\r\n    // ----- Look if it is a directory\r\n    if (substr($p_header['filename'], -1) == '/') {\r\n      //$p_header['external'] = 0x41FF0010;\r\n      $p_header['external'] = 0x00000010;\r\n    }\r\n\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privCheckFileHeaders()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  //   1 on success,\r\n  //   0 on error;\r\n  // --------------------------------------------------------------------------------\r\n  function privCheckFileHeaders(&$p_local_header, &$p_central_header)\r\n  {\r\n    $v_result=1;\r\n\r\n      // ----- Check the static values\r\n      // TBC\r\n      if ($p_local_header['filename'] != $p_central_header['filename']) {\r\n      }\r\n      if ($p_local_header['version_extracted'] != $p_central_header['version_extracted']) {\r\n      }\r\n      if ($p_local_header['flag'] != $p_central_header['flag']) {\r\n      }\r\n      if ($p_local_header['compression'] != $p_central_header['compression']) {\r\n      }\r\n      if ($p_local_header['mtime'] != $p_central_header['mtime']) {\r\n      }\r\n      if ($p_local_header['filename_len'] != $p_central_header['filename_len']) {\r\n      }\r\n\r\n      // ----- Look for flag bit 3\r\n      if (($p_local_header['flag'] & 8) == 8) {\r\n          $p_local_header['size'] = $p_central_header['size'];\r\n          $p_local_header['compressed_size'] = $p_central_header['compressed_size'];\r\n          $p_local_header['crc'] = $p_central_header['crc'];\r\n      }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privReadEndCentralDir()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privReadEndCentralDir(&$p_central_dir)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Go to the end of the zip file\r\n    $v_size = filesize($this->zipname);\r\n    @fseek($this->zip_fd, $v_size);\r\n    if (@ftell($this->zip_fd) != $v_size)\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to go to the end of the archive \\''.$this->zipname.'\\'');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- First try : look if this is an archive with no commentaries (most of the time)\r\n    // in this case the end of central dir is at 22 bytes of the file end\r\n    $v_found = 0;\r\n    if ($v_size > 26) {\r\n      @fseek($this->zip_fd, $v_size-22);\r\n      if (($v_pos = @ftell($this->zip_fd)) != ($v_size-22))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read for bytes\r\n      $v_binary_data = @fread($this->zip_fd, 4);\r\n      $v_data = @unpack('Vid', $v_binary_data);\r\n\r\n      // ----- Check signature\r\n      if ($v_data['id'] == 0x06054b50) {\r\n        $v_found = 1;\r\n      }\r\n\r\n      $v_pos = ftell($this->zip_fd);\r\n    }\r\n\r\n    // ----- Go back to the maximum possible size of the Central Dir End Record\r\n    if (!$v_found) {\r\n      $v_maximum_size = 65557; // 0xFFFF + 22;\r\n      if ($v_maximum_size > $v_size)\r\n        $v_maximum_size = $v_size;\r\n      @fseek($this->zip_fd, $v_size-$v_maximum_size);\r\n      if (@ftell($this->zip_fd) != ($v_size-$v_maximum_size))\r\n      {\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, 'Unable to seek back to the middle of the archive \\''.$this->zipname.'\\'');\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n\r\n      // ----- Read byte per byte in order to find the signature\r\n      $v_pos = ftell($this->zip_fd);\r\n      $v_bytes = 0x00000000;\r\n      while ($v_pos < $v_size)\r\n      {\r\n        // ----- Read a byte\r\n        $v_byte = @fread($this->zip_fd, 1);\r\n\r\n        // -----  Add the byte\r\n        //$v_bytes = ($v_bytes << 8) | Ord($v_byte);\r\n        // Note we mask the old value down such that once shifted we can never end up with more than a 32bit number\r\n        // Otherwise on systems where we have 64bit integers the check below for the magic number will fail.\r\n        $v_bytes = ( ($v_bytes & 0xFFFFFF) << 8) | Ord($v_byte);\r\n\r\n        // ----- Compare the bytes\r\n        if ($v_bytes == 0x504b0506)\r\n        {\r\n          $v_pos++;\r\n          break;\r\n        }\r\n\r\n        $v_pos++;\r\n      }\r\n\r\n      // ----- Look if not found end of central dir\r\n      if ($v_pos == $v_size)\r\n      {\r\n\r\n        // ----- Error log\r\n        PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Unable to find End of Central Dir Record signature\");\r\n\r\n        // ----- Return\r\n        return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Read the first 18 bytes of the header\r\n    $v_binary_data = fread($this->zip_fd, 18);\r\n\r\n    // ----- Look for invalid block size\r\n    if (strlen($v_binary_data) != 18)\r\n    {\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT, \"Invalid End of Central Dir Record size : \".strlen($v_binary_data));\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Extract the values\r\n    $v_data = unpack('vdisk/vdisk_start/vdisk_entries/ventries/Vsize/Voffset/vcomment_size', $v_binary_data);\r\n\r\n    // ----- Check the global size\r\n    if (($v_pos + $v_data['comment_size'] + 18) != $v_size) {\r\n\r\n      // ----- Removed in release 2.2 see readme file\r\n      // The check of the file size is a little too strict.\r\n      // Some bugs where found when a zip is encrypted/decrypted with 'crypt'.\r\n      // While decrypted, zip has training 0 bytes\r\n      if (0) {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_BAD_FORMAT,\r\n                           'The central dir is not at the end of the archive.'\r\n                           .' Some trailing bytes exists after the archive.');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n      }\r\n    }\r\n\r\n    // ----- Get comment\r\n    if ($v_data['comment_size'] != 0) {\r\n      $p_central_dir['comment'] = fread($this->zip_fd, $v_data['comment_size']);\r\n    }\r\n    else\r\n      $p_central_dir['comment'] = '';\r\n\r\n    $p_central_dir['entries'] = $v_data['entries'];\r\n    $p_central_dir['disk_entries'] = $v_data['disk_entries'];\r\n    $p_central_dir['offset'] = $v_data['offset'];\r\n    $p_central_dir['size'] = $v_data['size'];\r\n    $p_central_dir['disk'] = $v_data['disk'];\r\n    $p_central_dir['disk_start'] = $v_data['disk_start'];\r\n\r\n    // TBC\r\n    //for(reset($p_central_dir); $key = key($p_central_dir); next($p_central_dir)) {\r\n    //}\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDeleteByRule()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDeleteByRule(&$p_result_list, &$p_options)\r\n  {\r\n    $v_result=1;\r\n    $v_list_detail = array();\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Scan all the files\r\n    // ----- Start at beginning of Central Dir\r\n    $v_pos_entry = $v_central_dir['offset'];\r\n    @rewind($this->zip_fd);\r\n    if (@fseek($this->zip_fd, $v_pos_entry))\r\n    {\r\n      // ----- Close the zip file\r\n      $this->privCloseFd();\r\n\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Read each entry\r\n    $v_header_list = array();\r\n    $j_start = 0;\r\n    for ($i=0, $v_nb_extracted=0; $i<$v_central_dir['entries']; $i++)\r\n    {\r\n\r\n      // ----- Read the file header\r\n      $v_header_list[$v_nb_extracted] = array();\r\n      if (($v_result = $this->privReadCentralFileHeader($v_header_list[$v_nb_extracted])) != 1)\r\n      {\r\n        // ----- Close the zip file\r\n        $this->privCloseFd();\r\n\r\n        return $v_result;\r\n      }\r\n\r\n\r\n      // ----- Store the index\r\n      $v_header_list[$v_nb_extracted]['index'] = $i;\r\n\r\n      // ----- Look for the specific extract rules\r\n      $v_found = false;\r\n\r\n      // ----- Look for extract by name rule\r\n      if (   (isset($p_options[PCLZIP_OPT_BY_NAME]))\r\n          && ($p_options[PCLZIP_OPT_BY_NAME] != 0)) {\r\n\r\n          // ----- Look if the filename is in the list\r\n          for ($j=0; ($j<sizeof($p_options[PCLZIP_OPT_BY_NAME])) && (!$v_found); $j++) {\r\n\r\n              // ----- Look for a directory\r\n              if (substr($p_options[PCLZIP_OPT_BY_NAME][$j], -1) == \"/\") {\r\n\r\n                  // ----- Look if the directory is in the filename path\r\n                  if (   (strlen($v_header_list[$v_nb_extracted]['stored_filename']) > strlen($p_options[PCLZIP_OPT_BY_NAME][$j]))\r\n                      && (substr($v_header_list[$v_nb_extracted]['stored_filename'], 0, strlen($p_options[PCLZIP_OPT_BY_NAME][$j])) == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n                  elseif (   (($v_header_list[$v_nb_extracted]['external']&0x00000010)==0x00000010) /* Indicates a folder */\r\n                          && ($v_header_list[$v_nb_extracted]['stored_filename'].'/' == $p_options[PCLZIP_OPT_BY_NAME][$j])) {\r\n                      $v_found = true;\r\n                  }\r\n              }\r\n              // ----- Look for a filename\r\n              elseif ($v_header_list[$v_nb_extracted]['stored_filename'] == $p_options[PCLZIP_OPT_BY_NAME][$j]) {\r\n                  $v_found = true;\r\n              }\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by ereg rule\r\n      // ereg() is deprecated with PHP 5.3\r\n      /*\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_EREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_EREG] != \"\")) {\r\n\r\n          if (ereg($p_options[PCLZIP_OPT_BY_EREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n      */\r\n\r\n      // ----- Look for extract by preg rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_PREG]))\r\n               && ($p_options[PCLZIP_OPT_BY_PREG] != \"\")) {\r\n\r\n          if (preg_match($p_options[PCLZIP_OPT_BY_PREG], $v_header_list[$v_nb_extracted]['stored_filename'])) {\r\n              $v_found = true;\r\n          }\r\n      }\r\n\r\n      // ----- Look for extract by index rule\r\n      else if (   (isset($p_options[PCLZIP_OPT_BY_INDEX]))\r\n               && ($p_options[PCLZIP_OPT_BY_INDEX] != 0)) {\r\n\r\n          // ----- Look if the index is in the list\r\n          for ($j=$j_start; ($j<sizeof($p_options[PCLZIP_OPT_BY_INDEX])) && (!$v_found); $j++) {\r\n\r\n              if (($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['start']) && ($i<=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end'])) {\r\n                  $v_found = true;\r\n              }\r\n              if ($i>=$p_options[PCLZIP_OPT_BY_INDEX][$j]['end']) {\r\n                  $j_start = $j+1;\r\n              }\r\n\r\n              if ($p_options[PCLZIP_OPT_BY_INDEX][$j]['start']>$i) {\r\n                  break;\r\n              }\r\n          }\r\n      }\r\n      else {\r\n          $v_found = true;\r\n      }\r\n\r\n      // ----- Look for deletion\r\n      if ($v_found)\r\n      {\r\n        unset($v_header_list[$v_nb_extracted]);\r\n      }\r\n      else\r\n      {\r\n        $v_nb_extracted++;\r\n      }\r\n    }\r\n\r\n    // ----- Look if something need to be deleted\r\n    if ($v_nb_extracted > 0) {\r\n\r\n        // ----- Creates a temporay file\r\n        $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n        // ----- Creates a temporary zip archive\r\n        $v_temp_zip = new PclZip($v_zip_temp_name);\r\n\r\n        // ----- Open the temporary zip file in write mode\r\n        if (($v_result = $v_temp_zip->privOpenFd('wb')) != 1) {\r\n            $this->privCloseFd();\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Look which file need to be kept\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n\r\n            // ----- Calculate the position of the header\r\n            @rewind($this->zip_fd);\r\n            if (@fseek($this->zip_fd,  $v_header_list[$i]['offset'])) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Error log\r\n                PclZip::privErrorLog(PCLZIP_ERR_INVALID_ARCHIVE_ZIP, 'Invalid archive size');\r\n\r\n                // ----- Return\r\n                return PclZip::errorCode();\r\n            }\r\n\r\n            // ----- Read the file header\r\n            $v_local_header = array();\r\n            if (($v_result = $this->privReadFileHeader($v_local_header)) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Check that local file header is same as central file header\r\n            if ($this->privCheckFileHeaders($v_local_header,\r\n                                            $v_header_list[$i]) != 1) {\r\n                // TBC\r\n            }\r\n            unset($v_local_header);\r\n\r\n            // ----- Write the file header\r\n            if (($v_result = $v_temp_zip->privWriteFileHeader($v_header_list[$i])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Read/write the data block\r\n            if (($v_result = PclZipUtilCopyBlock($this->zip_fd, $v_temp_zip->zip_fd, $v_header_list[$i]['compressed_size'])) != 1) {\r\n                // ----- Close the zip file\r\n                $this->privCloseFd();\r\n                $v_temp_zip->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n        }\r\n\r\n        // ----- Store the offset of the central dir\r\n        $v_offset = @ftell($v_temp_zip->zip_fd);\r\n\r\n        // ----- Re-Create the Central Dir files header\r\n        for ($i=0; $i<sizeof($v_header_list); $i++) {\r\n            // ----- Create the file header\r\n            if (($v_result = $v_temp_zip->privWriteCentralFileHeader($v_header_list[$i])) != 1) {\r\n                $v_temp_zip->privCloseFd();\r\n                $this->privCloseFd();\r\n                @unlink($v_zip_temp_name);\r\n\r\n                // ----- Return\r\n                return $v_result;\r\n            }\r\n\r\n            // ----- Transform the header to a 'usable' info\r\n            $v_temp_zip->privConvertHeader2FileInfo($v_header_list[$i], $p_result_list[$i]);\r\n        }\r\n\r\n\r\n        // ----- Zip file comment\r\n        $v_comment = '';\r\n        if (isset($p_options[PCLZIP_OPT_COMMENT])) {\r\n          $v_comment = $p_options[PCLZIP_OPT_COMMENT];\r\n        }\r\n\r\n        // ----- Calculate the size of the central header\r\n        $v_size = @ftell($v_temp_zip->zip_fd)-$v_offset;\r\n\r\n        // ----- Create the central dir footer\r\n        if (($v_result = $v_temp_zip->privWriteCentralHeader(sizeof($v_header_list), $v_size, $v_offset, $v_comment)) != 1) {\r\n            // ----- Reset the file list\r\n            unset($v_header_list);\r\n            $v_temp_zip->privCloseFd();\r\n            $this->privCloseFd();\r\n            @unlink($v_zip_temp_name);\r\n\r\n            // ----- Return\r\n            return $v_result;\r\n        }\r\n\r\n        // ----- Close\r\n        $v_temp_zip->privCloseFd();\r\n        $this->privCloseFd();\r\n\r\n        // ----- Delete the zip file\r\n        // TBC : I should test the result ...\r\n        @unlink($this->zipname);\r\n\r\n        // ----- Rename the temporary file\r\n        // TBC : I should test the result ...\r\n        //@rename($v_zip_temp_name, $this->zipname);\r\n        PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n        // ----- Destroy the temporary archive\r\n        unset($v_temp_zip);\r\n    }\r\n\r\n    // ----- Remove every files : reset the file\r\n    else if ($v_central_dir['entries'] != 0) {\r\n        $this->privCloseFd();\r\n\r\n        if (($v_result = $this->privOpenFd('wb')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        if (($v_result = $this->privWriteCentralHeader(0, 0, 0, '')) != 1) {\r\n          return $v_result;\r\n        }\r\n\r\n        $this->privCloseFd();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDirCheck()\r\n  // Description :\r\n  //   Check if a directory exists, if not it creates it and all the parents directory\r\n  //   which may be useful.\r\n  // Parameters :\r\n  //   $p_dir : Directory path to check.\r\n  // Return Values :\r\n  //    1 : OK\r\n  //   -1 : Unable to create directory\r\n  // --------------------------------------------------------------------------------\r\n  function privDirCheck($p_dir, $p_is_dir=false)\r\n  {\r\n    $v_result = 1;\r\n\r\n\r\n    // ----- Remove the final '/'\r\n    if (($p_is_dir) && (substr($p_dir, -1)=='/'))\r\n    {\r\n      $p_dir = substr($p_dir, 0, strlen($p_dir)-1);\r\n    }\r\n\r\n    // ----- Check the directory availability\r\n    if ((is_dir($p_dir)) || ($p_dir == \"\"))\r\n    {\r\n      return 1;\r\n    }\r\n\r\n    // ----- Extract parent directory\r\n    $p_parent_dir = dirname($p_dir);\r\n\r\n    // ----- Just a check\r\n    if ($p_parent_dir != $p_dir)\r\n    {\r\n      // ----- Look for parent directory\r\n      if ($p_parent_dir != \"\")\r\n      {\r\n        if (($v_result = $this->privDirCheck($p_parent_dir)) != 1)\r\n        {\r\n          return $v_result;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Create the directory\r\n    if (!@mkdir($p_dir, 0777))\r\n    {\r\n      // ----- Error log\r\n      PclZip::privErrorLog(PCLZIP_ERR_DIR_CREATE_FAIL, \"Unable to create directory '$p_dir'\");\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privMerge()\r\n  // Description :\r\n  //   If $p_archive_to_add does not exist, the function exit with a success result.\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privMerge(&$p_archive_to_add)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the archive_to_add exists\r\n    if (!is_file($p_archive_to_add->zipname))\r\n    {\r\n\r\n      // ----- Nothing to merge, so merge is a success\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if the archive exists\r\n    if (!is_file($this->zipname))\r\n    {\r\n\r\n      // ----- Do a duplicate\r\n      $v_result = $this->privDuplicate($p_archive_to_add->zipname);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('rb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir = array();\r\n    if (($v_result = $this->privReadEndCentralDir($v_central_dir)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($this->zip_fd);\r\n\r\n    // ----- Open the archive_to_add file\r\n    if (($v_result=$p_archive_to_add->privOpenFd('rb')) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Read the central directory informations\r\n    $v_central_dir_to_add = array();\r\n    if (($v_result = $p_archive_to_add->privReadEndCentralDir($v_central_dir_to_add)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Go to beginning of File\r\n    @rewind($p_archive_to_add->zip_fd);\r\n\r\n    // ----- Creates a temporay file\r\n    $v_zip_temp_name = PCLZIP_TEMPORARY_DIR.uniqid('pclzip-').'.tmp';\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($v_zip_temp_name, 'wb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open temporary file \\''.$v_zip_temp_name.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = $v_central_dir['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the files from the archive_to_add into the temporary file\r\n    $v_size = $v_central_dir_to_add['offset'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Store the offset of the central dir\r\n    $v_offset = @ftell($v_zip_temp_fd);\r\n\r\n    // ----- Copy the block of file headers from the old archive\r\n    $v_size = $v_central_dir['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($this->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Copy the block of file headers from the archive_to_add\r\n    $v_size = $v_central_dir_to_add['size'];\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = @fread($p_archive_to_add->zip_fd, $v_read_size);\r\n      @fwrite($v_zip_temp_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Merge the file comments\r\n    $v_comment = $v_central_dir['comment'].' '.$v_central_dir_to_add['comment'];\r\n\r\n    // ----- Calculate the size of the (new) central header\r\n    $v_size = @ftell($v_zip_temp_fd)-$v_offset;\r\n\r\n    // ----- Swap the file descriptor\r\n    // Here is a trick : I swap the temporary fd with the zip fd, in order to use\r\n    // the following methods on the temporary fil and not the real archive fd\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Create the central dir footer\r\n    if (($v_result = $this->privWriteCentralHeader($v_central_dir['entries']+$v_central_dir_to_add['entries'], $v_size, $v_offset, $v_comment)) != 1)\r\n    {\r\n      $this->privCloseFd();\r\n      $p_archive_to_add->privCloseFd();\r\n      @fclose($v_zip_temp_fd);\r\n      $this->zip_fd = null;\r\n\r\n      // ----- Reset the file list\r\n      unset($v_header_list);\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back the file descriptor\r\n    $v_swap = $this->zip_fd;\r\n    $this->zip_fd = $v_zip_temp_fd;\r\n    $v_zip_temp_fd = $v_swap;\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n    $p_archive_to_add->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Delete the zip file\r\n    // TBC : I should test the result ...\r\n    @unlink($this->zipname);\r\n\r\n    // ----- Rename the temporary file\r\n    // TBC : I should test the result ...\r\n    //@rename($v_zip_temp_name, $this->zipname);\r\n    PclZipUtilRename($v_zip_temp_name, $this->zipname);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDuplicate()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDuplicate($p_archive_filename)\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if the $p_archive_filename exists\r\n    if (!is_file($p_archive_filename))\r\n    {\r\n\r\n      // ----- Nothing to duplicate, so duplicate is a success.\r\n      $v_result = 1;\r\n\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the zip file\r\n    if (($v_result=$this->privOpenFd('wb')) != 1)\r\n    {\r\n      // ----- Return\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Open the temporary file in write mode\r\n    if (($v_zip_temp_fd = @fopen($p_archive_filename, 'rb')) == 0)\r\n    {\r\n      $this->privCloseFd();\r\n\r\n      PclZip::privErrorLog(PCLZIP_ERR_READ_OPEN_FAIL, 'Unable to open archive file \\''.$p_archive_filename.'\\' in binary write mode');\r\n\r\n      // ----- Return\r\n      return PclZip::errorCode();\r\n    }\r\n\r\n    // ----- Copy the files from the archive to the temporary file\r\n    // TBC : Here I should better append the file and go back to erase the central dir\r\n    $v_size = filesize($p_archive_filename);\r\n    while ($v_size != 0)\r\n    {\r\n      $v_read_size = ($v_size < PCLZIP_READ_BLOCK_SIZE ? $v_size : PCLZIP_READ_BLOCK_SIZE);\r\n      $v_buffer = fread($v_zip_temp_fd, $v_read_size);\r\n      @fwrite($this->zip_fd, $v_buffer, $v_read_size);\r\n      $v_size -= $v_read_size;\r\n    }\r\n\r\n    // ----- Close\r\n    $this->privCloseFd();\r\n\r\n    // ----- Close the temporary file\r\n    @fclose($v_zip_temp_fd);\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorLog()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorLog($p_error_code=0, $p_error_string='')\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclError($p_error_code, $p_error_string);\r\n    }\r\n    else {\r\n      $this->error_code = $p_error_code;\r\n      $this->error_string = $p_error_string;\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privErrorReset()\r\n  // Description :\r\n  // Parameters :\r\n  // --------------------------------------------------------------------------------\r\n  function privErrorReset()\r\n  {\r\n    if (PCLZIP_ERROR_EXTERNAL == 1) {\r\n      PclErrorReset();\r\n    }\r\n    else {\r\n      $this->error_code = 0;\r\n      $this->error_string = '';\r\n    }\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privDisableMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privDisableMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if already done\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Get and memorize the magic_quote value\r\n    $this->magic_quotes_status = @get_magic_quotes_runtime();\r\n\r\n    // ----- Disable magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n      @set_magic_quotes_runtime(0);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : privSwapBackMagicQuotes()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function privSwapBackMagicQuotes()\r\n  {\r\n    $v_result=1;\r\n\r\n    // ----- Look if function exists\r\n    if (   (!function_exists(\"get_magic_quotes_runtime\"))\r\n        || (!function_exists(\"set_magic_quotes_runtime\"))) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Look if something to do\r\n    if ($this->magic_quotes_status != -1) {\r\n      return $v_result;\r\n    }\r\n\r\n    // ----- Swap back magic_quotes\r\n    if ($this->magic_quotes_status == 1) {\r\n        @set_magic_quotes_runtime($this->magic_quotes_status);\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  }\r\n  // End of class\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathReduction()\r\n  // Description :\r\n  // Parameters :\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathReduction($p_dir)\r\n  {\r\n    $v_result = \"\";\r\n\r\n    // ----- Look for not empty path\r\n    if ($p_dir != \"\") {\r\n      // ----- Explode path by directory names\r\n      $v_list = explode(\"/\", $p_dir);\r\n\r\n      // ----- Study directories from last to first\r\n      $v_skip = 0;\r\n      for ($i=sizeof($v_list)-1; $i>=0; $i--) {\r\n        // ----- Look for current path\r\n        if ($v_list[$i] == \".\") {\r\n          // ----- Ignore this directory\r\n          // Should be the first $i=0, but no check is done\r\n        }\r\n        else if ($v_list[$i] == \"..\") {\r\n          $v_skip++;\r\n        }\r\n        else if ($v_list[$i] == \"\") {\r\n          // ----- First '/' i.e. root slash\r\n          if ($i == 0) {\r\n            $v_result = \"/\".$v_result;\r\n            if ($v_skip > 0) {\r\n                // ----- It is an invalid path, so the path is not modified\r\n                // TBC\r\n                $v_result = $p_dir;\r\n                $v_skip = 0;\r\n            }\r\n          }\r\n          // ----- Last '/' i.e. indicates a directory\r\n          else if ($i == (sizeof($v_list)-1)) {\r\n            $v_result = $v_list[$i];\r\n          }\r\n          // ----- Double '/' inside the path\r\n          else {\r\n            // ----- Ignore only the double '//' in path,\r\n            // but not the first and last '/'\r\n          }\r\n        }\r\n        else {\r\n          // ----- Look for item to skip\r\n          if ($v_skip > 0) {\r\n            $v_skip--;\r\n          }\r\n          else {\r\n            $v_result = $v_list[$i].($i!=(sizeof($v_list)-1)?\"/\".$v_result:\"\");\r\n          }\r\n        }\r\n      }\r\n\r\n      // ----- Look for skip\r\n      if ($v_skip > 0) {\r\n        while ($v_skip > 0) {\r\n            $v_result = '../'.$v_result;\r\n            $v_skip--;\r\n        }\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilPathInclusion()\r\n  // Description :\r\n  //   This function indicates if the path $p_path is under the $p_dir tree. Or,\r\n  //   said in an other way, if the file or sub-dir $p_path is inside the dir\r\n  //   $p_dir.\r\n  //   The function indicates also if the path is exactly the same as the dir.\r\n  //   This function supports path with duplicated '/' like '//', but does not\r\n  //   support '.' or '..' statements.\r\n  // Parameters :\r\n  // Return Values :\r\n  //   0 if $p_path is not inside directory $p_dir\r\n  //   1 if $p_path is inside directory $p_dir\r\n  //   2 if $p_path is exactly the same as $p_dir\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilPathInclusion($p_dir, $p_path)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Look for path beginning by ./\r\n    if (   ($p_dir == '.')\r\n        || ((strlen($p_dir) >=2) && (substr($p_dir, 0, 2) == './'))) {\r\n      $p_dir = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_dir, 1);\r\n    }\r\n    if (   ($p_path == '.')\r\n        || ((strlen($p_path) >=2) && (substr($p_path, 0, 2) == './'))) {\r\n      $p_path = PclZipUtilTranslateWinPath(getcwd(), FALSE).'/'.substr($p_path, 1);\r\n    }\r\n\r\n    // ----- Explode dir and path by directory separator\r\n    $v_list_dir = explode(\"/\", $p_dir);\r\n    $v_list_dir_size = sizeof($v_list_dir);\r\n    $v_list_path = explode(\"/\", $p_path);\r\n    $v_list_path_size = sizeof($v_list_path);\r\n\r\n    // ----- Study directories paths\r\n    $i = 0;\r\n    $j = 0;\r\n    while (($i < $v_list_dir_size) && ($j < $v_list_path_size) && ($v_result)) {\r\n\r\n      // ----- Look for empty dir (path reduction)\r\n      if ($v_list_dir[$i] == '') {\r\n        $i++;\r\n        continue;\r\n      }\r\n      if ($v_list_path[$j] == '') {\r\n        $j++;\r\n        continue;\r\n      }\r\n\r\n      // ----- Compare the items\r\n      if (($v_list_dir[$i] != $v_list_path[$j]) && ($v_list_dir[$i] != '') && ( $v_list_path[$j] != ''))  {\r\n        $v_result = 0;\r\n      }\r\n\r\n      // ----- Next items\r\n      $i++;\r\n      $j++;\r\n    }\r\n\r\n    // ----- Look if everything seems to be the same\r\n    if ($v_result) {\r\n      // ----- Skip all the empty items\r\n      while (($j < $v_list_path_size) && ($v_list_path[$j] == '')) $j++;\r\n      while (($i < $v_list_dir_size) && ($v_list_dir[$i] == '')) $i++;\r\n\r\n      if (($i >= $v_list_dir_size) && ($j >= $v_list_path_size)) {\r\n        // ----- There are exactly the same\r\n        $v_result = 2;\r\n      }\r\n      else if ($i < $v_list_dir_size) {\r\n        // ----- The path is shorter than the dir\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilCopyBlock()\r\n  // Description :\r\n  // Parameters :\r\n  //   $p_mode : read/write compression mode\r\n  //             0 : src & dest normal\r\n  //             1 : src gzip, dest normal\r\n  //             2 : src normal, dest gzip\r\n  //             3 : src & dest gzip\r\n  // Return Values :\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilCopyBlock($p_src, $p_dest, $p_size, $p_mode=0)\r\n  {\r\n    $v_result = 1;\r\n\r\n    if ($p_mode==0)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==1)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @fwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==2)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @fread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n    else if ($p_mode==3)\r\n    {\r\n      while ($p_size != 0)\r\n      {\r\n        $v_read_size = ($p_size < PCLZIP_READ_BLOCK_SIZE ? $p_size : PCLZIP_READ_BLOCK_SIZE);\r\n        $v_buffer = @gzread($p_src, $v_read_size);\r\n        @gzwrite($p_dest, $v_buffer, $v_read_size);\r\n        $p_size -= $v_read_size;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilRename()\r\n  // Description :\r\n  //   This function tries to do a simple rename() function. If it fails, it\r\n  //   tries to copy the $p_src file in a new $p_dest file and then unlink the\r\n  //   first one.\r\n  // Parameters :\r\n  //   $p_src : Old filename\r\n  //   $p_dest : New filename\r\n  // Return Values :\r\n  //   1 on success, 0 on failure.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilRename($p_src, $p_dest)\r\n  {\r\n    $v_result = 1;\r\n\r\n    // ----- Try to rename the files\r\n    if (!@rename($p_src, $p_dest)) {\r\n\r\n      // ----- Try to copy & unlink the src\r\n      if (!@copy($p_src, $p_dest)) {\r\n        $v_result = 0;\r\n      }\r\n      else if (!@unlink($p_src)) {\r\n        $v_result = 0;\r\n      }\r\n    }\r\n\r\n    // ----- Return\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilOptionText()\r\n  // Description :\r\n  //   Translate option value in text. Mainly for debug purpose.\r\n  // Parameters :\r\n  //   $p_option : the option value.\r\n  // Return Values :\r\n  //   The option text value.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilOptionText($p_option)\r\n  {\r\n\r\n    $v_list = get_defined_constants();\r\n    for (reset($v_list); $v_key = key($v_list); next($v_list)) {\r\n        $v_prefix = substr($v_key, 0, 10);\r\n        if ((   ($v_prefix == 'PCLZIP_OPT')\r\n           || ($v_prefix == 'PCLZIP_CB_')\r\n           || ($v_prefix == 'PCLZIP_ATT'))\r\n            && ($v_list[$v_key] == $p_option)) {\r\n        return $v_key;\r\n        }\r\n    }\r\n\r\n    $v_result = 'Unknown';\r\n\r\n    return $v_result;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n  // --------------------------------------------------------------------------------\r\n  // Function : PclZipUtilTranslateWinPath()\r\n  // Description :\r\n  //   Translate windows path by replacing '\\' by '/' and optionally removing\r\n  //   drive letter.\r\n  // Parameters :\r\n  //   $p_path : path to translate.\r\n  //   $p_remove_disk_letter : true | false\r\n  // Return Values :\r\n  //   The path translated.\r\n  // --------------------------------------------------------------------------------\r\n  function PclZipUtilTranslateWinPath($p_path, $p_remove_disk_letter=true)\r\n  {\r\n    if (stristr(php_uname(), 'windows')) {\r\n      // ----- Look for potential disk letter\r\n      if (($p_remove_disk_letter) && (($v_position = strpos($p_path, ':')) != false)) {\r\n          $p_path = substr($p_path, $v_position+1);\r\n      }\r\n      // ----- Change potential windows directory separator\r\n      if ((strpos($p_path, '\\\\') > 0) || (substr($p_path, 0,1) == '\\\\')) {\r\n          $p_path = strtr($p_path, '\\\\', '/');\r\n      }\r\n    }\r\n    return $p_path;\r\n  }\r\n  // --------------------------------------------------------------------------------\r\n\r\n\r\n?>\r\n"], "filenames": ["application/helpers/common_helper.php", "application/third_party/pclzip/pclzip.lib.php"], "buggy_code_start_loc": [4962, 222], "buggy_code_end_loc": [4962, 3674], "fixing_code_start_loc": [4963, 223], "fixing_code_end_loc": [5000, 3681], "type": "CWE-434", "message": "LimeSurvey version prior to 3.14.4 contains a file upload vulnerability in upload functionality that can result in an attacker gaining code execution via webshell. This attack appear to be exploitable via an authenticated user uploading a zip archive which can contains malicious php files that can be called under certain circumstances. This vulnerability appears to have been fixed in after commit 91d143230eb357260a19c8424b3005deb49a47f7 / version 3.14.4.", "other": {"cve": {"id": "CVE-2018-1000658", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-06T17:29:00.457", "lastModified": "2018-10-26T13:55:50.713", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "LimeSurvey version prior to 3.14.4 contains a file upload vulnerability in upload functionality that can result in an attacker gaining code execution via webshell. This attack appear to be exploitable via an authenticated user uploading a zip archive which can contains malicious php files that can be called under certain circumstances. This vulnerability appears to have been fixed in after commit 91d143230eb357260a19c8424b3005deb49a47f7 / version 3.14.4."}, {"lang": "es", "value": "LimeSurvey en versiones anteriores a la 3.14.4 contiene una vulnerabilidad de subida de archivos en la funcionalidad de subida que puede resultar en que un atacante pueda ejecutar c\u00f3digo mediante el shell web. El ataque parece ser explotable si un usuario autenticado sube un archivo zip que contenga archivos php maliciosos que pueden ser llamados en determinadas circunstancias. La vulnerabilidad parece haber sido solucionada tras el commit con ID 91d143230eb357260a19c8424b3005deb49a47f7 en la versi\u00f3n 3.14.4."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:limesurvey:limesurvey:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.14.4", "matchCriteriaId": "20BFBA04-281D-4CDB-BA16-6DA3088098B1"}]}]}], "references": [{"url": "https://github.com/LimeSurvey/LimeSurvey/commit/20fc85edccc80e7e7f162613542792380c44446a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LimeSurvey/LimeSurvey/commit/91d143230eb357260a19c8424b3005deb49a47f7", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LimeSurvey/LimeSurvey/commit/20fc85edccc80e7e7f162613542792380c44446a"}}