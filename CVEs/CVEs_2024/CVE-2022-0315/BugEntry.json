{"buggy_code": ["# Copyright IBM Corp. 2020. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nimport os\nimport tempfile\n\nfrom shlex import quote\n\nfrom horovod.runner.common.util import safe_shell_exec\nfrom horovod.runner.util import lsf\nfrom distutils.spawn import find_executable\nfrom horovod.runner.mpi_run import _get_mpi_implementation_flags, _MPI_NOT_FOUND_ERROR_MSG\n\n\ndef is_jsrun_installed():\n    \"\"\"Returns True if jsrun is installed.\"\"\"\n    return find_executable('jsrun') is not None\n\n\ndef js_run(settings, nics, env, command, stdout=None, stderr=None):\n    \"\"\"\n    Runs Horovod with jsrun.\n\n    Args:\n        settings: Settings for running jsrun.\n                  Note: settings.num_proc and settings.hosts must not be None.\n        nics: Interfaces to include by jsrun.\n        env: Environment dictionary to use for running jsrun.\n        command: Command and arguments to run as a list of string.\n        stdout: Stdout of the mpi process.\n                Only used when settings.run_func_mode is True.\n        stderr: Stderr of the mpi process.\n                Only used when settings.run_func_mode is True.\n    \"\"\"\n    mpi_impl_flags, _ = _get_mpi_implementation_flags(settings.tcp_flag, env=env)\n    if mpi_impl_flags is None:\n        raise Exception(_MPI_NOT_FOUND_ERROR_MSG)\n\n    if not is_jsrun_installed():\n        raise Exception(\n            'horovod does not find the jsrun command.\\n\\n'\n            'Please, make sure you are running on a cluster with jsrun installed or '\n            'use one of the other launchers.')\n\n    if nics and 'NCCL_SOCKET_IFNAME' not in env:\n        env['NCCL_SOCKET_IFNAME'] = ','.join(nics)\n\n    smpiargs = ' '.join(mpi_impl_flags)\n    if settings.extra_mpi_args:\n        smpiargs += ' ' + settings.extra_mpi_args\n\n    if settings.binding_args:\n        binding_args = settings.binding_args\n    else:\n        rf = generate_jsrun_rankfile(settings)\n        if settings.verbose >= 2:\n            safe_shell_exec.execute('cat {rf}'.format(rf=rf))\n        binding_args = '--erf_input {rf}'.format(rf=rf)\n\n    jsrun_command = (\n        'jsrun {binding_args} '\n        '{output_filename_arg} '\n        '{smpiargs} '\n        '{command}'\n        .format(binding_args = binding_args,\n                output_filename_arg='--stdio_stderr {file} --stdio_stdout {file}'.format(file=settings.output_filename)\n                                    if settings.output_filename else '',\n                smpiargs= '--smpiargs {args}'.format(args=quote(smpiargs)) if smpiargs else '',\n                command=' '.join(quote(par) for par in command))\n    )\n\n    if settings.verbose >= 2:\n        print(jsrun_command)\n\n    # Execute the jsrun command.\n    if settings.run_func_mode:\n        exit_code = safe_shell_exec.execute(jsrun_command, env=env, stdout=stdout, stderr=stderr)\n        if exit_code != 0:\n            raise RuntimeError(\"jsrun failed with exit code {exit_code}\".format(exit_code=exit_code))\n    else:\n        os.execve('/bin/sh', ['/bin/sh', '-c', jsrun_command], env)\n\n\ndef generate_jsrun_rankfile(settings, path=None):\n    \"\"\"\n    Generates rankfile to use with jsrun.\n    It splits the cores among the processes, which leads to best performance according to experiments.\n\n    Args:\n        settings: Settings for running jsrun.\n                  Note: settings.num_proc and settings.hosts must not be None.\n        path: Optional path of the rankfile.\n              Note: this file will be overwritten.\n    \"\"\"\n    cpu_per_gpu = (lsf.LSFUtils.get_num_cores() * lsf.LSFUtils.get_num_threads()) // lsf.LSFUtils.get_num_gpus()\n    host_list = (x.split(':') for x in settings.hosts.split(','))\n\n    # Verify and truncate host list if necessary\n    validated_list = []\n    remaining_slots = settings.num_proc\n    for host, slots in host_list:\n        slots = int(slots)\n        if slots > lsf.LSFUtils.get_num_gpus():\n            raise ValueError('Invalid host input, slot count for host \\'{host}:{slots}\\' is greater '\n                             'than number of GPUs per host \\'{gpus}\\'.'.format(\n                host=host, slots=slots, gpus=lsf.LSFUtils.get_num_gpus()))\n        needed_slots = min(slots, remaining_slots)\n        validated_list.append((host, needed_slots))\n        remaining_slots -= needed_slots\n        if remaining_slots == 0:\n            break\n    if remaining_slots != 0:\n        raise ValueError('Not enough slots on the hosts to fulfill the {slots} requested.'.format(\n            slots=settings.num_proc))\n\n    # Generate rankfile\n    path = tempfile.mktemp() if path is None else path\n    with open(path, 'w') as tmp:\n        tmp.write('overlapping_rs: allow\\n')\n        tmp.write('cpu_index_using: logical\\n')\n        rank = 0\n        for host, slots in validated_list:\n            cpu_val = 0\n            tmp.write('\\n')\n            for s in range(slots):\n                tmp.write('rank: {rank}: {{ hostname: {host}; cpu: {{{scpu}-{ecpu}}} ; gpu: * ; mem: * }}\\n'.format(\n                    rank=rank,\n                    host=host,\n                    scpu=cpu_val,\n                    ecpu=cpu_val + cpu_per_gpu - 1\n                ))\n                rank += 1\n                cpu_val += cpu_per_gpu\n    return path\n", "# Copyright 2019 Uber Technologies, Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nimport copy\nimport io\nimport itertools\nimport logging\nimport multiprocessing\nimport os\nimport subprocess\nimport sys\nimport threading\nimport time\nimport unittest\nimport warnings\n\nimport mock\nimport psutil\nimport pytest\nfrom mock import MagicMock\n\nimport horovod\nfrom horovod.runner import _HorovodArgs\nfrom horovod.runner.common.util import config_parser, hosts, safe_shell_exec, secret, \\\n    settings as hvd_settings, timeout\nfrom horovod.runner.common.util.host_hash import _hash, host_hash\nfrom horovod.runner.common.util.hosts import SlotInfo, get_host_assignments, parse_hosts\nfrom horovod.runner.gloo_run import gloo_run\nfrom horovod.runner.js_run import js_run, generate_jsrun_rankfile\nfrom horovod.runner.launch import gloo_built, parse_args, run_controller, _run\nfrom horovod.runner.mpi_run import _get_mpi_implementation, _get_mpi_implementation_flags, \\\n    _LARGE_CLUSTER_THRESHOLD as large_cluster_threshold, mpi_available, mpi_run, \\\n    _OMPI_IMPL, _SMPI_IMPL, _MPICH_IMPL, _IMPI_IMPL, _UNKNOWN_IMPL, _MISSING_IMPL\nfrom horovod.runner.util.threads import in_thread, on_event\n\nsys.path.append(os.path.join(os.path.dirname(__file__), os.pardir, 'utils'))\n\nfrom common import is_built, lsf_and_jsrun, override_args, override_env, temppath, delay, wait\n\n\nclass RunTests(unittest.TestCase):\n    \"\"\"\n    Tests for horovod.runner.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(RunTests, self).__init__(*args, **kwargs)\n        warnings.simplefilter('module')\n\n    def test_params_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--fusion-threshold-mb', '10',\n                           '--cycle-time-ms', '20',\n                           '--cache-capacity', '512',\n                           '--hierarchical-allreduce',\n                           '--hierarchical-allgather'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_FUSION_THRESHOLD), str(10 * 1024 * 1024))\n            self.assertEqual(env.get(config_parser.HOROVOD_CYCLE_TIME), '20.0')\n            self.assertEqual(env.get(config_parser.HOROVOD_CACHE_CAPACITY), '512')\n            self.assertEqual(env.get(config_parser.HOROVOD_HIERARCHICAL_ALLREDUCE), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_HIERARCHICAL_ALLGATHER), '1')\n\n    def test_autotune_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--autotune',\n                           '--autotune-log-file', '/tmp/autotune.txt',\n                           '--autotune-warmup-samples', '1',\n                           '--autotune-steps-per-sample', '5',\n                           '--autotune-bayes-opt-max-samples', '10',\n                           '--autotune-gaussian-process-noise', '0.2'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_LOG), '/tmp/autotune.txt')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_WARMUP_SAMPLES), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_STEPS_PER_SAMPLE), '5')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_BAYES_OPT_MAX_SAMPLES), '10')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_GAUSSIAN_PROCESS_NOISE), '0.2')\n\n    def test_autotuning_with_fixed_param(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--autotune',\n                           '--cache-capacity', '1024',\n                           '--no-hierarchical-allgather'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertNotIn(config_parser.HOROVOD_FUSION_THRESHOLD, env)\n            self.assertNotIn(config_parser.HOROVOD_CYCLE_TIME, env)\n            self.assertEqual(env.get(config_parser.HOROVOD_CACHE_CAPACITY), '1024')\n            self.assertNotIn(config_parser.HOROVOD_HIERARCHICAL_ALLREDUCE, env)\n            self.assertEqual(env.get(config_parser.HOROVOD_HIERARCHICAL_ALLGATHER), '0')\n\n    def test_timeline_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--timeline-filename', '/tmp/timeline.json',\n                           '--timeline-mark-cycles'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_TIMELINE), '/tmp/timeline.json')\n            self.assertEqual(env.get(config_parser.HOROVOD_TIMELINE_MARK_CYCLES), '1')\n\n    def test_stall_check_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--no-stall-check'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_STALL_CHECK_DISABLE), '1')\n\n        with override_args('horovodrun', '-np', '2',\n                           '--stall-check-warning-time-seconds', '10',\n                           '--stall-check-shutdown-time-seconds', '20'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertNotIn(config_parser.HOROVOD_STALL_CHECK_DISABLE, env)\n            self.assertEqual(env.get(config_parser.HOROVOD_STALL_CHECK_TIME_SECONDS), '10')\n            self.assertEqual(env.get(config_parser.HOROVOD_STALL_SHUTDOWN_TIME_SECONDS), '20')\n\n    def test_library_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--mpi-threads-disable',\n                           '--num-nccl-streams', '2',\n                           '--thread-affinity', '1',\n                           '--gloo-timeout-seconds', '60'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_MPI_THREADS_DISABLE), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_NUM_NCCL_STREAMS), '2')\n            self.assertEqual(env.get(config_parser.HOROVOD_THREAD_AFFINITY), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_GLOO_TIMEOUT_SECONDS), '60')\n\n    def test_library_env_override(self):\n        \"\"\"Tests that environment variables override arg defaults.\"\"\"\n        with override_args('horovodrun', '-np', '2'):\n            args = parse_args()\n            env = {\n                'HOROVOD_GLOO_TIMEOUT_SECONDS': '1800',\n            }\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_GLOO_TIMEOUT_SECONDS), '1800')\n\n    def test_logging_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--log-level', 'INFO',\n                           '--log-hide-timestamp'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_LOG_LEVEL), 'INFO')\n            self.assertEqual(env.get(config_parser.HOROVOD_LOG_HIDE_TIME), '1')\n\n    def test_config_file(self):\n        config_filename = os.path.join(os.path.dirname(__file__), 'data/config.test.yaml')\n        with override_args('horovodrun', '-np', '2',\n                           '--config-file', config_filename):\n            args = parse_args()\n\n            self.assertTrue(args.use_gloo)\n\n            # Params\n            self.assertEqual(args.fusion_threshold_mb, 32)\n            self.assertEqual(args.cycle_time_ms, 10)\n            self.assertEqual(args.cache_capacity, 2048)\n            self.assertTrue(args.hierarchical_allreduce)\n            self.assertTrue(args.hierarchical_allgather)\n\n            # Autotune\n            self.assertTrue(args.autotune)\n            self.assertEqual(args.autotune_log_file, 'horovod_autotune_log.txt')\n            self.assertEqual(args.autotune_warmup_samples, 5)\n            self.assertEqual(args.autotune_steps_per_sample, 20)\n            self.assertEqual(args.autotune_bayes_opt_max_samples, 50)\n            self.assertEqual(args.autotune_gaussian_process_noise, 0.9)\n\n            # Timeline\n            self.assertEqual(args.timeline_filename, 'horovod_timeline.json')\n            self.assertTrue(args.timeline_mark_cycles)\n\n            # Stall Check\n            self.assertFalse(args.no_stall_check)\n            self.assertEqual(args.stall_check_warning_time_seconds, 120)\n            self.assertEqual(args.stall_check_shutdown_time_seconds, 240)\n\n            # Library Options\n            self.assertTrue(args.mpi_threads_disable)\n            self.assertEqual(args.num_nccl_streams, 2)\n            self.assertEqual(args.thread_affinity, 1)\n            self.assertEqual(args.gloo_timeout_seconds, 60)\n\n            # Logging\n            self.assertEqual(args.log_level, 'INFO')\n            self.assertFalse(args.log_with_timestamp)\n\n    def test_config_file_override_args(self):\n        config_filename = os.path.join(os.path.dirname(__file__), 'data/config.test.yaml')\n        with override_args('horovodrun', '-np', '2',\n                           '--fusion-threshold-mb', '256',\n                           '--config-file', config_filename,\n                           '--cycle-time-ms', '20',):\n            args = parse_args()\n            self.assertEqual(args.fusion_threshold_mb, 256)\n            self.assertEqual(args.cycle_time_ms, 20)\n\n    def test_validate_config_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--fusion-threshold-mb', '-1'):\n            with pytest.raises(ValueError):\n                parse_args()\n\n    # test_on_event tests in_thread as well, but it does not test args\n    def test_in_thread_args(self):\n        fn = mock.Mock()\n        thread = in_thread(fn, args=(1,))\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once_with(1)\n\n        fn = mock.Mock()\n        thread = in_thread(fn, args=(1, 2))\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once_with(1, 2)\n\n        fn = mock.Mock()\n        thread = in_thread(fn, args=(1, 2), silent=True)\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once_with(1, 2)\n\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^args must be a tuple, not <(class|type) 'int'>, \"\n                                             \"for a single argument use \\\\(arg,\\\\)$\"):\n            in_thread(fn, args=1)\n        fn.assert_not_called()\n\n    def test_on_event(self):\n        # a happy run without args and stop event\n        event = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n\n        # a happy run with args but without stop event\n        event = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn, ('a', 1))\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n        fn.assert_called_once_with('a', 1)\n\n        # a happy run with stop event but unused\n        event = threading.Event()\n        stop = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn, stop=stop, check_stop_interval_s=0.01)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n        stop.set()\n        time.sleep(0.1)\n        fn.assert_called_once()\n\n        # stop the thread before we set the event\n        event = threading.Event()\n        stop = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn, stop=stop, check_stop_interval_s=0.01)\n        fn.assert_not_called()\n        stop.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_not_called()\n        event.set()\n        time.sleep(0.1)\n        fn.assert_not_called()\n\n        # test with exception\n        def exception():\n            raise Exception(\"Test Exception\")\n\n        event = threading.Event()\n        fn = mock.Mock(side_effect=exception)\n        thread = on_event(event, fn)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n\n        # test with exception but silent\n        event = threading.Event()\n        fn = mock.Mock(side_effect=exception)\n        thread = on_event(event, fn)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n\n        # test None event\n        event = None\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^Event must not be None$\"):\n            on_event(event, fn)\n        fn.assert_not_called()\n\n        # test non-tuple args\n        event = threading.Event()\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^args must be a tuple, not <(class|type) 'int'>, \"\n                                             \"for a single argument use \\\\(arg,\\\\)$\"):\n            on_event(event, fn, args=1)\n        fn.assert_not_called()\n\n        # test None stop and non-daemon\n        event = threading.Event()\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^Stop event must be given for non-daemon event thread$\"):\n            on_event(event, fn, stop=None, daemon=False)\n        fn.assert_not_called()\n\n    def test_prefix_connection(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:first line\\n'\n                                                '[123]<prefix>:second line\\n'\n                                                '[123]<prefix>:more lines\\n')\n\n    def test_prefix_connection_with_unicode(self):\n        string = '\u2200\u2201\u2202\u2203\u2204\u2205\u2206\u2207\u2208\u2209\u220a\u220b\u220c\u220d\u220e\u220f\u2210\u2211\\n\u231a\u231b\u26c4\u2705\u2026\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:\u2200\u2201\u2202\u2203\u2204\u2205\u2206\u2207\u2208\u2209\u220a\u220b\u220c\u220d\u220e\u220f\u2210\u2211\\n'\n                                                '[123]<prefix>:\u231a\u231b\u26c4\u2705\u2026\\n')\n\n    def test_prefix_connection_with_multibyte_unicode(self):\n        block = '\u2588\u2593\u2592\u2591\u2592\u2593'*1000\n        string = block + '\\n' + block + '\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:' + block + '\\n' +\n                                                '[123]<prefix>:' + block + '\\n')\n\n    def test_prefix_connection_with_timestamp(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection_with_timestamp(\n            string, prefix='prefix', index=123,\n            expected='Mon Jan 20 12:00:01 2020[123]<prefix>:first line\\n'\n                     'Mon Jan 20 12:00:02 2020[123]<prefix>:second line\\n'\n                     'Mon Jan 20 12:00:03 2020[123]<prefix>:more lines\\n'\n        )\n\n    def test_prefix_connection_with_timestamp_without_index(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection_with_timestamp(string, prefix=None, index=None,\n                                                      expected=string)\n\n    def test_prefix_connection_without_trailing_newline(self):\n        string = 'first line\\nsecond line\\nmore lines'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:first line\\n'\n                                            '[123]<prefix>:second line\\n'\n                                            '[123]<prefix>:more lines')\n\n    def test_prefix_connection_without_index(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=None, expected=string)\n\n    def test_prefix_connection_without_prefix(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection(string, prefix=None, index=123, expected=string)\n\n    def test_prefix_connection_with_carriage_return(self):\n        string = 'first line\\rfirst line again\\nsecond line\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:first line\\r'\n                                            '[123]<prefix>:first line again\\n'\n                                            '[123]<prefix>:second line\\n')\n\n    def test_prefix_connection_with_carriage_return_without_index(self):\n        string = 'first line\\rfirst line again\\nsecond line\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=None, expected=string)\n\n    def test_prefix_connection_with_carriage_return_without_prefix(self):\n        string = 'first line\\rfirst line again\\nsecond line\\n'\n        self.do_test_prefix_connection(string, prefix=None, index=123, expected=string)\n\n    def do_test_prefix_connection(self, string, prefix, index, expected, timestamp=False):\n        # create a Pipe Connection and populate it with string\n        (connection, w) = multiprocessing.get_context('spawn').Pipe(duplex=False)\n        with os.fdopen(w.fileno(), 'wt', encoding='utf8', newline='', closefd=False) as stream:\n            stream.write(string)\n        w.close()\n\n        dst = io.StringIO()\n        safe_shell_exec.prefix_connection(connection, dst, prefix=prefix, index=index,\n                                          prefix_output_with_timestamp=timestamp)\n        self.assertEqual(expected, dst.getvalue())\n\n    def do_test_prefix_connection_with_timestamp(self, string_or_connection, prefix, index, expected):\n        # control the time used to prepend the timestamp\n        class MockTime:\n            def __init__(self):\n                # start at 2020-01-20 12:00:00\n                self._time = 1579521600\n\n            def time(self, seconds):\n                from time import gmtime\n                self._time = self._time + 1\n                return gmtime(self._time)\n\n        with mock.patch('horovod.runner.common.util.safe_shell_exec.time.localtime',\n                        side_effect=MockTime().time):\n            self.do_test_prefix_connection(string_or_connection, prefix, index, expected, timestamp=True)\n\n    def test_prefix_connection_does_stream(self):\n        index = 123\n        prefix = 'prefix'\n        expected = '[123]<prefix>:first line\\r' \\\n                   '[123]<prefix>:first line again\\n' \\\n                   '[123]<prefix>:second line\\n' \\\n                   '[123]<prefix>:more lines'\n\n        timeout = 0.2\n        barrier = multiprocessing.Barrier(2, timeout=timeout)\n\n        def writer(write_connection):\n            def write(stream, text):\n                stream.write(text)\n                logging.info('wrote: {}'.format(text))\n                stream.flush()\n\n                # are we expecting the reader to read something\n                logging.info('waiting for reader')\n                if '\\r' in text or '\\n' in text:\n                    # yes, barrier should not timeout\n                    try:\n                        barrier.wait()\n                    except threading.BrokenBarrierError:\n                        self.fail('reader side should have read something from the stream')\n                else:\n                    # no, barrier should timeout\n                    try:\n                        barrier.wait()\n                        self.fail('reader side should not have read anything from the stream')\n                    except threading.BrokenBarrierError:\n                        logging.info('reader did not read')\n                        barrier.reset()\n                        pass\n                logging.info('continuing writing')\n\n            try:\n                with os.fdopen(write_connection.fileno(), 'wt', encoding='utf8', newline='', closefd=False) as stream:\n                    for text in ['first line\\r',\n                                 'first ', 'line ', 'again\\n',\n                                 'second line\\nmore ', 'lines']:\n                        write(stream, text)\n            finally:\n                write_connection.close()\n\n        actual = []\n        do_read = True\n\n        def reader(read_connection):\n            try:\n                while do_read:\n                    text = os.read(read_connection.fileno(), 1000)\n                    if not text:\n                        break\n                    text = text.decode('utf8')\n                    actual.append(text)\n                    logging.info('read: {}'.format(text))\n                    logging.info('waiting for writer')\n                    try:\n                        barrier.wait()\n                    except threading.BrokenBarrierError as e:\n                        if do_read:\n                            raise e\n                        break\n                    logging.info('continuing reading')\n            finally:\n                read_connection.close()\n\n        # one thread writes into the w side of this pipe\n        # prefix_connection reads on the other end of this pipe\n        (connection, w) = multiprocessing.get_context('spawn').Pipe(duplex=False)\n        writer_thread = in_thread(writer, (w,))\n\n        # prefix_connection writes to the write side of this Pipe (opened as a text stream)\n        # another thread reads from the r side of this pipe\n        (r, dst_con) = multiprocessing.get_context('spawn').Pipe(duplex=False)\n        reader_thread = in_thread(reader, (r,))\n\n        with os.fdopen(dst_con.fileno(), 'wt', encoding='utf8', newline='', closefd=False) as dst:\n            safe_shell_exec.prefix_connection(connection, dst, prefix=prefix, index=index,\n                                              prefix_output_with_timestamp=False)\n\n        writer_thread.join(2*timeout)\n        do_read = False\n        reader_thread.join(2*timeout)\n\n        self.assertEqual(expected, ''.join(actual))\n\n    def test_safe_shell_exec_captures_stdout(self):\n        self.do_test_safe_shell_exec('echo hello', 0, 'hello\\n', '')\n\n    def test_safe_shell_exec_captures_stderr(self):\n        self.do_test_safe_shell_exec('echo hello >&2', 0, '', 'hello\\n')\n\n    def test_safe_shell_exec_captures_last_line_wo_eol(self):\n        cmd = 'bash -c \"echo -e -n \\\\\"hello\\nstdout\\\\\"; echo -e -n \\\\\"hello\\nstderr\\\\\" >&2\"'\n        self.do_test_safe_shell_exec(cmd, 0, 'hello\\nstdout', 'hello\\nstderr')\n\n    def test_safe_shell_exec_returns_exit_code(self):\n        self.do_test_safe_shell_exec('false', 1, '', '')\n\n    @pytest.mark.skip(reason='https://github.com/horovod/horovod/issues/1993')\n    def test_safe_shell_exec_interrupts_on_event(self):\n        # interrupt execute in one second\n        interrupt = threading.Event()\n        interrupt_delay = 1.0\n        delay(lambda: interrupt.set(), interrupt_delay)\n\n        sleep = interrupt_delay + safe_shell_exec.GRACEFUL_TERMINATION_TIME_S + 2.0\n        start = time.time()\n        self.do_test_safe_shell_exec('sleep {}'.format(sleep), 143, '', None, interrupt)\n        duration = time.time() - start\n\n        self.assertGreaterEqual(duration, interrupt_delay)\n        self.assertLess(duration, sleep - 1.0, 'sleep should not finish')\n\n    def test_safe_shell_exec_interrupts_on_parent_shutdown(self):\n        sleep = 20\n        parent_script = os.path.join(os.path.dirname(__file__), 'data/run_safe_shell_exec.py')\n        child_script = os.path.join(os.path.dirname(__file__), 'data/sleep.py')\n\n        def get_pid(logfile):\n            # Wait until the script has written its PID to the logfile\n            wait(lambda: os.path.exists(logfile), timeout=5)\n            with open(logfile, 'r') as f:\n                return int(f.read())\n\n        with temppath() as parent_logfile, temppath() as child_logfile:\n            # It's important that this executes in an entirely different interpreter with as little shared\n            # state as possible, to avoid issues with the semaphore tracker.\n            cmd = ' '.join([sys.executable, parent_script, parent_logfile, child_script, str(sleep), child_logfile])\n            p = subprocess.Popen(cmd, shell=True)\n\n            parent = psutil.Process(get_pid(parent_logfile))\n            child = psutil.Process(get_pid(child_logfile))\n\n            self.assertTrue(parent.is_running())\n            self.assertTrue(child.is_running())\n\n            # Hard kill the parent process\n            parent.kill()\n            parent.wait(timeout=safe_shell_exec.GRACEFUL_TERMINATION_TIME_S)\n            p.wait()\n\n            # Child process will exit when pipe breaks\n            child.wait(timeout=2 * safe_shell_exec.GRACEFUL_TERMINATION_TIME_S + 1)\n\n            self.assertFalse(parent.is_running())\n            self.assertFalse(child.is_running())\n\n    def do_test_safe_shell_exec(self, cmd, expected_exit_code, expected_stdout, expected_stderr, event=None):\n        stdout = io.StringIO()\n        stderr = io.StringIO()\n        res = safe_shell_exec.execute(cmd, stdout=stdout, stderr=stderr, events=[event] if event else None)\n        self.assertEqual(expected_exit_code, res)\n        if expected_stdout is not None:\n            self.assertEqual(expected_stdout, stdout.getvalue())\n        if expected_stderr is not None:\n            self.assertEqual(expected_stderr, stderr.getvalue())\n\n    def test_hash(self):\n        hash = _hash(\"test string\")\n        self.assertEqual(hash, '6f8db599de986fab7a21625b7916589c')\n\n    def test_host_hash(self):\n        hash = host_hash()\n        salted = host_hash('salt')\n        empty_salted = host_hash('')\n\n        self.assertNotEqual(salted, hash)\n        self.assertEqual(empty_salted, hash)\n\n    def test_get_mpi_implementation(self):\n        def test(output, expected, exit_code=0):\n            ret = (output, exit_code) if output is not None else None\n            env = {'VAR': 'val'}\n            with mock.patch(\"horovod.runner.mpi_run.tiny_shell_exec.execute\", return_value=ret) as m:\n                implementation = _get_mpi_implementation(env)\n                self.assertEqual(expected, implementation)\n                m.assert_called_once_with('mpirun --version', env)\n\n        test((\"mpirun (Open MPI) 2.1.1\\n\"\n              \"Report bugs to http://www.open-mpi.org/community/help/\\n\"), _OMPI_IMPL)\n\n        test(\"OpenRTE\", _OMPI_IMPL)\n\n        test(\"IBM Spectrum MPI\", _SMPI_IMPL)\n\n        test((\"HYDRA build details:\\n\"\n              \"    Version:           3.3a2\\n\"\n              \"    Configure options: 'MPICHLIB_CFLAGS=-g -O2'\\n\"), _MPICH_IMPL)\n        \n        test(\"Intel(R) MPI\", _IMPI_IMPL)\n\n        test(\"Unknown MPI v1.00\", _UNKNOWN_IMPL)\n\n        test(\"output\", exit_code=1, expected=_MISSING_IMPL)\n\n        test(None, _MISSING_IMPL)\n\n    def test_run_controller(self):\n        def test(use_gloo, use_mpi, use_js,\n                 gloo_is_built, mpi_is_built,\n                 lsf_exists, jsrun_installed,\n                 expected, exception):\n            gloo_run = MagicMock()\n            mpi_run = MagicMock()\n            js_run = MagicMock()\n\n            with is_built(gloo_is_built, mpi_is_built):\n                with lsf_and_jsrun(lsf_exists, jsrun_installed):\n                    if exception is not None:\n                        with pytest.raises(ValueError, match=exception) as e:\n                            run_controller(use_gloo, gloo_run, use_mpi, mpi_run, use_js, js_run, verbosity=2)\n                        return\n                    run_controller(use_gloo, gloo_run, use_mpi, mpi_run, use_js, js_run, verbosity=2)\n\n            if expected == \"gloo\":\n                gloo_run.assert_called_once()\n                mpi_run.assert_not_called()\n                js_run.assert_not_called()\n            elif expected == \"mpi\":\n                gloo_run.assert_not_called()\n                mpi_run.assert_called_once()\n                js_run.assert_not_called()\n            elif expected == \"js\":\n                gloo_run.assert_not_called()\n                mpi_run.assert_not_called()\n                js_run.assert_called_once()\n            else:\n                raise ValueError(\"unsupported framework: {}\".format(expected))\n\n        bool_values = [False, True]\n        bool_values_and_none = [None, False, True]\n\n        for use_gloo, use_mpi, use_js, \\\n            gloo_is_built, mpi_is_built, \\\n            lsf_exists, jsrun_installed in \\\n            itertools.product(bool_values_and_none, bool_values_and_none, bool_values_and_none,\n                              bool_values, bool_values,\n                              bool_values, bool_values):\n\n            expected = exception = None\n            if use_gloo:\n                if gloo_is_built:\n                    expected = 'gloo'\n                else:\n                    exception = r'^Gloo support has not been built\\.  If this is not expected, ensure CMake is installed ' \\\n                                r'and reinstall Horovod with HOROVOD_WITH_GLOO=1 to debug the build error\\.$'\n            elif use_mpi:\n                if mpi_is_built:\n                    expected = 'mpi'\n                else:\n                    exception = r'^MPI support has not been built\\.  If this is not expected, ensure MPI is installed ' \\\n                                r'and reinstall Horovod with HOROVOD_WITH_MPI=1 to debug the build error\\.$'\n            elif use_js:\n                if mpi_is_built:\n                    if lsf_exists:\n                        expected = 'js'\n                    else:\n                        exception = 'Horovod did not detect an LSF job.  The jsrun launcher can only be used in that environment. ' \\\n                                    'Please, pick a different launcher for other environments.'\n                else:\n                    exception = r'^MPI support has not been built\\.  If this is not expected, ensure MPI is installed ' \\\n                                r'and reinstall Horovod with HOROVOD_WITH_MPI=1 to debug the build error\\.$'\n            elif mpi_is_built:\n                if lsf_exists and jsrun_installed:\n                    expected = 'js'\n                else:\n                    expected = 'mpi'\n            elif gloo_is_built:\n                expected = 'gloo'\n            else:\n                exception = r'Neither MPI nor Gloo support has been built\\. Try reinstalling Horovod ensuring that ' \\\n                            r'either MPI is installed \\(MPI\\) or CMake is installed \\(Gloo\\)\\.'\n\n            test(use_gloo, use_mpi, use_js,\n                 gloo_is_built, mpi_is_built,\n                 lsf_exists, jsrun_installed,\n                 expected, exception)\n\n    \"\"\"\n    Minimal mpi_run settings for tests.\n    \"\"\"\n    minimal_settings = hvd_settings.Settings(\n        verbose=0,\n        num_proc=2,\n        hosts='localhost:2',\n        run_func_mode=True\n    )\n\n    \"\"\"\n    Tests mpi_run with minimal settings.\n    \"\"\"\n    def test_mpi_run_minimal(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute:\n                mpi_run(settings, None, {}, cmd)\n\n                # call the mocked _get_mpi_implementation_flags method\n                mpi_flags, binding_args, mpi = horovod.runner.mpi_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                if _IMPI_IMPL == mpi:\n                    expected_cmd = ('mpirun '\n                                    '-l -n 2 -hosts localhost '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(binding_args=' '.join(binding_args), mpi_flags=' '.join(mpi_flags))\n                else:\n                    expected_cmd = ('mpirun '\n                                    '--allow-run-as-root --tag-output '\n                                    '-np 2 -H localhost:2 '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(binding_args=' '.join(binding_args), mpi_flags=' '.join(mpi_flags))\n\n                # remove PYTHONPATH from execute's env\n                # we cannot know the exact value of that env variable\n                # we test right handling of PYTHONPATH in test_mpi_run_*pythonpath* below\n                self.assertIn('env', execute.call_args.kwargs)\n                if 'PYTHONPATH' in execute.call_args.kwargs['env']:\n                    execute.call_args.kwargs['env'].pop('PYTHONPATH')\n\n                expected_env = {'PATH': os.environ.get('PATH')}\n                execute.assert_called_once_with(expected_cmd, env=expected_env, stdout=None, stderr=None)\n\n    \"\"\"\n    Tests mpi_run on a large cluster.\n    \"\"\"\n    def test_mpi_run_on_large_cluster(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = copy.copy(self.minimal_settings)\n        settings.hosts = ','.join(['localhost:1'] * large_cluster_threshold)\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute:\n                mpi_run(settings, None, {}, cmd)\n\n                # call the mocked _get_mpi_implementation_flags method\n                mpi_flags, binding_args, mpi = horovod.runner.mpi_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                if _IMPI_IMPL == mpi:\n                    expected_cmd = ('mpirun '\n                                    '-l -n 2 -ppn 1 -hosts {hosts} '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(hosts=settings.hosts, binding_args=' '.join(binding_args),\n                                                  mpi_flags=' '.join(mpi_flags))\n                else:\n                    mpi_flags.append('-mca plm_rsh_no_tree_spawn true')\n                    mpi_flags.append('-mca plm_rsh_num_concurrent {}'.format(large_cluster_threshold))\n                    expected_cmd = ('mpirun '\n                                    '--allow-run-as-root --tag-output '\n                                    '-np 2 -H {hosts} '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(hosts=settings.hosts, binding_args=' '.join(binding_args),\n                                                  mpi_flags=' '.join(mpi_flags))\n\n                # remove PYTHONPATH from execute's env\n                # we cannot know the exact value of that env variable\n                # we test right handling of PYTHONPATH in test_mpi_run_*pythonpath* below\n                self.assertIn('env', execute.call_args.kwargs)\n                if 'PYTHONPATH' in execute.call_args.kwargs['env']:\n                    execute.call_args.kwargs['env'].pop('PYTHONPATH')\n\n                expected_env = {'PATH': os.environ.get('PATH')}\n                execute.assert_called_once_with(expected_cmd, env=expected_env, stdout=None, stderr=None)\n\n    \"\"\"\n    Tests mpi_run with full settings.\n    \"\"\"\n    def test_mpi_run_full(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd', 'arg1', 'arg2']\n        nics = ['eth0', 'eth1']\n        env = {'env1': 'val1', 'env2': 'val2'}\n        stdout = '<stdout>'\n        stderr = '<stderr>'\n        tmout = timeout.Timeout(5, message='Timed out waiting for something.')\n        settings = hvd_settings.Settings(\n            verbose=0,\n            ssh_port=1022,\n            extra_mpi_args='>mpi-extra args go here<',\n            binding_args='>binding args go here<',\n            key=secret.make_secret_key(),\n            start_timeout=tmout,\n            num_proc=1,\n            hosts='localhost:1',\n            output_filename='>output filename goes here<',\n            run_func_mode=True\n        )\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags) as impl:\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute:\n                mpi_run(settings, nics, env, cmd, stdout=stdout, stderr=stderr)\n\n                # assert call on _get_mpi_implementation_flags\n                impl.assert_called_once_with(None, env=env)\n\n                # call the mocked _get_mpi_implementation_flags method ourselves\n                mpi_flags, _, mpi = horovod.runner.mpi_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                if _IMPI_IMPL == mpi:\n                    expected_command = ('mpirun '\n                                        '-l -n 1 -hosts {hosts} '\n                                        '>binding args go here< '\n                                        '{mpi_flags} '\n                                        '-bootstrap-exec-args \"-p 1022\" '\n                                        '-genv NCCL_SOCKET_IFNAME=eth0,eth1 '\n                                        '-outfile-pattern >output pattern goes here< '\n                                        '-genvlist env1,env2 '\n                                        '>mpi-extra args go here< '\n                                        'cmd arg1 arg2').format(hosts=settings.hosts,\n                                                                mpi_flags=' '.join(mpi_flags))\n                else:\n                    expected_command = ('mpirun '\n                                        '--allow-run-as-root --tag-output '\n                                        '-np 1 -H {hosts} '\n                                        '>binding args go here< '\n                                        '{mpi_flags} '\n                                        '-mca plm_rsh_args \"-p 1022\" '\n                                        '-mca btl_tcp_if_include eth0,eth1 -x NCCL_SOCKET_IFNAME=eth0,eth1 '\n                                        '--output-filename >output filename goes here< '\n                                        '-x env1 -x env2 '\n                                        '>mpi-extra args go here< '\n                                        'cmd arg1 arg2').format(hosts=settings.hosts,\n                                                                mpi_flags=' '.join(mpi_flags))\n\n                # remove PYTHONPATH from execute's env\n                # we cannot know the exact value of that env variable\n                # we test right handling of PYTHONPATH in test_mpi_run_*pythonpath* below\n                self.assertIn('env', execute.call_args.kwargs)\n                if 'PYTHONPATH' in execute.call_args.kwargs['env']:\n                    execute.call_args.kwargs['env'].pop('PYTHONPATH')\n\n                expected_env = {'env1': 'val1', 'env2': 'val2', 'PATH': os.environ.get('PATH')}\n                execute.assert_called_once_with(expected_command, env=expected_env, stdout=stdout, stderr=stderr)\n\n    \"\"\"\n    Tests mpi_run without PYTHONPATH set.\n    \"\"\"\n    def test_mpi_run_without_pythonpath(self):\n        self.do_test_mpi_run_env_override({}, {}, 'PYTHONPATH', None)\n\n    \"\"\"\n    Tests mpi_run with PYTHONPATH set in sys.\n    \"\"\"\n    def test_mpi_run_with_sys_pythonpath(self):\n        self.do_test_mpi_run_env_override({'PYTHONPATH': 'ppath'}, {}, 'PYTHONPATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with PYTHONPATH set in env.\n    \"\"\"\n    def test_mpi_run_with_env_pythonpath(self):\n        self.do_test_mpi_run_env_override({}, {'PYTHONPATH': 'ppath'}, 'PYTHONPATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with both PYTHONPATH set.\n    \"\"\"\n    def test_mpi_run_with_both_pythonpaths(self):\n        self.do_test_mpi_run_env_override({'PYTHONPATH': 'sys-ppath'}, {'PYTHONPATH': 'env-ppath'}, 'PYTHONPATH', 'env-ppath')\n\n    \"\"\"\n    Tests mpi_run without PATH set.\n    \"\"\"\n    def test_mpi_run_without_path(self):\n        self.do_test_mpi_run_env_override({}, {}, 'PATH', None)\n\n    \"\"\"\n    Tests mpi_run with PATH set in sys.\n    \"\"\"\n    def test_mpi_run_with_sys_path(self):\n        self.do_test_mpi_run_env_override({'PATH': 'ppath'}, {}, 'PATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with PATH set in env.\n    \"\"\"\n    def test_mpi_run_with_env_path(self):\n        self.do_test_mpi_run_env_override({}, {'PATH': 'ppath'}, 'PATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with both PATH set.\n    \"\"\"\n    def test_mpi_run_with_both_paths(self):\n        self.do_test_mpi_run_env_override({'PATH': 'sys-path'}, {'PATH': 'env-path'}, 'PATH', 'env-path')\n\n    \"\"\"\n    Actually tests mpi_run overrides arg env with sys env.\n    \"\"\"\n    def do_test_mpi_run_env_override(self, sysenv, argenv, env_var, expected):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags),\\\n             mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute,\\\n             override_env(sysenv):\n            mpi_run(settings, None, argenv, cmd)\n\n            # assert the env variable in the execute's env\n            self.assertIn('env', execute.call_args.kwargs)\n            self.assertEqual(execute.call_args.kwargs['env'].get(env_var), expected)\n\n    def test_mpi_run_with_non_zero_exit(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [], [], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=1):\n                with pytest.raises(RuntimeError, match=\"^mpirun failed with exit code 1$\"):\n                    mpi_run(settings, None, {}, cmd)\n\n    \"\"\"\n    Tests mpi_run with os.environ.\n    \"\"\"\n    def test_mpi_run_with_os_environ(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"]\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0):\n                with pytest.raises(Exception, match=\"^env argument must be a dict, not <class 'os._Environ'>: \"):\n                    mpi_run(settings, None, os.environ, cmd)\n\n    \"\"\"\n    Tests gloo_run with minimal settings.\n    \"\"\"\n    def test_gloo_run_minimal(self):\n        if not gloo_built:\n            self.skipTest(\"Gloo is not available\")\n\n        cmd = ['whoami']\n        settings = self.minimal_settings\n        gloo_run(settings, ['lo'], {}, '127.0.0.1', cmd)\n\n    \"\"\"\n    Tests gloo_run with os.environ.\n    \"\"\"\n    def test_gloo_run_with_os_environ(self):\n        if not gloo_built:\n            self.skipTest(\"Gloo is not available\")\n\n        cmd = ['whoami']\n        settings = self.minimal_settings\n        gloo_run(settings, ['lo'], os.environ, '127.0.0.1', cmd)\n\n    def test_horovodrun_hostfile(self):\n        with temppath() as host_filename:\n            with open(host_filename, 'w+') as fp:\n                fp.write('172.31.32.7 slots=8\\n')\n                fp.write('172.31.33.9 slots=8\\n')\n\n            hostnames = hosts.parse_host_files(host_filename)\n            self.assertEqual(hostnames, '172.31.32.7:8,172.31.33.9:8')\n\n    \"\"\"\n    Tests js_run.\n    \"\"\"\n    @mock.patch('horovod.runner.js_run.is_jsrun_installed', MagicMock(return_value=True))\n    @mock.patch('horovod.runner.js_run.generate_jsrun_rankfile', MagicMock(return_value='/tmp/rankfile'))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_gpus', MagicMock(return_value=2))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_cores', MagicMock(return_value=2))\n    def test_js_run(self):\n        if _get_mpi_implementation_flags(False)[0] is None:\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd', 'arg1', 'arg2']\n        env = {'env1': 'val1', 'env2': 'val2'}\n        stdout = '<stdout>'\n        stderr = '<stderr>'\n        settings = hvd_settings.Settings(\n            verbose=0,\n            extra_mpi_args='>mpi-extra args go here<',\n            num_proc=4,\n            hosts='localhost:2,127.0.0.1:2',\n            output_filename='>output filename goes here<',\n            run_func_mode=True\n        )\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], []\n\n        with mock.patch(\"horovod.runner.js_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.js_run.safe_shell_exec.execute\", return_value=0) as execute:\n                js_run(settings, None, env, cmd, stdout=stdout, stderr=stderr)\n\n                # call the mocked _get_mpi_implementation_flags method\n                mpi_flags, _ = horovod.runner.js_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                expected_command = ('jsrun '\n                                    '--erf_input /tmp/rankfile '\n                                    '--stdio_stderr >output filename goes here< '\n                                    '--stdio_stdout >output filename goes here< '\n                                    '--smpiargs \\'{mpi_args} >mpi-extra args go here<\\' '\n                                    'cmd arg1 arg2').format(mpi_args=' '.join(mpi_flags))\n                expected_env = {'env1': 'val1', 'env2': 'val2'}\n                execute.assert_called_once_with(expected_command, env=expected_env, stdout=stdout, stderr=stderr)\n\n    \"\"\"\n    Tests generate_jsrun_rankfile.\n    \"\"\"\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_gpus', MagicMock(return_value=4))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_cores', MagicMock(return_value=4))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_threads', MagicMock(return_value=4))\n    def test_generate_jsrun_rankfile(self):\n        settings = hvd_settings.Settings(\n            num_proc=5,\n            hosts='host1:4,host2:4,host3:4',\n        )\n\n        with temppath() as rankfile_path:\n            rankfile_path = generate_jsrun_rankfile(settings, rankfile_path)\n\n            with open(rankfile_path, 'r') as file:\n                gen_rankfile = file.read()\n\n            expected_rankfile = (\n\"\"\"overlapping_rs: allow\ncpu_index_using: logical\n\nrank: 0: { hostname: host1; cpu: {0-3} ; gpu: * ; mem: * }\nrank: 1: { hostname: host1; cpu: {4-7} ; gpu: * ; mem: * }\nrank: 2: { hostname: host1; cpu: {8-11} ; gpu: * ; mem: * }\nrank: 3: { hostname: host1; cpu: {12-15} ; gpu: * ; mem: * }\n\nrank: 4: { hostname: host2; cpu: {0-3} ; gpu: * ; mem: * }\n\"\"\")\n\n            self.assertMultiLineEqual(gen_rankfile, expected_rankfile)\n\n    \"\"\"\n    Tests horovod.runner.launch._run with jsrun\n    \"\"\"\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.using_lsf', MagicMock(return_value=True))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_compute_hosts', MagicMock(return_value=['host1', 'host2']))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_gpus', MagicMock(return_value=2))\n    @mock.patch('horovod.runner.util.network.filter_local_addresses', MagicMock(return_value=['host1', 'host2']))\n    @mock.patch('horovod.runner.launch._check_all_hosts_ssh_successful', MagicMock())\n    @mock.patch('horovod.runner.launch.run_controller')\n    def test_run_with_jsrun(self, mocked_run_controller):\n        hargs = _HorovodArgs()\n        _run(hargs)\n        mocked_run_controller.assert_called_once()\n\n    def test_get_host_assignments(self):\n        hosts = parse_hosts('worker-0:2,worker-1:2')\n        np = 4\n        assignments = get_host_assignments(hosts, np)\n\n        sizes = dict(size=4, local_size=2, cross_size=2)\n        expected = [SlotInfo(hostname='worker-0', rank=0, local_rank=0, cross_rank=0, **sizes),\n                    SlotInfo(hostname='worker-0', rank=1, local_rank=1, cross_rank=0, **sizes),\n                    SlotInfo(hostname='worker-1', rank=2, local_rank=0, cross_rank=1, **sizes),\n                    SlotInfo(hostname='worker-1', rank=3, local_rank=1, cross_rank=1, **sizes)]\n        self.assertListEqual(assignments, expected)\n\n    def test_get_host_assignments_elastic(self):\n        hosts = parse_hosts('worker-0:2,worker-1:2')\n        min_np = 1\n        max_np = 2\n        assignments = get_host_assignments(hosts, min_np=min_np, max_np=max_np)\n\n        sizes = dict(size=2, local_size=2, cross_size=1)\n        expected = [SlotInfo(hostname='worker-0', rank=0, local_rank=0, cross_rank=0, **sizes),\n                    SlotInfo(hostname='worker-0', rank=1, local_rank=1, cross_rank=0, **sizes)]\n        self.assertListEqual(assignments, expected)\n\n    def test_get_host_assignments_heterogeneous(self):\n        hosts = parse_hosts('worker-0:1,worker-1:2')\n        np = 3\n        assignments = get_host_assignments(hosts, np)\n\n        expected = [SlotInfo(hostname='worker-0', rank=0, local_rank=0, cross_rank=0,\n                             size=3, local_size=1, cross_size=2),\n                    SlotInfo(hostname='worker-1', rank=1, local_rank=0, cross_rank=1,\n                             size=3, local_size=2, cross_size=2),\n                    SlotInfo(hostname='worker-1', rank=2, local_rank=1, cross_rank=0,\n                             size=3, local_size=2, cross_size=1)]\n        self.assertListEqual(assignments, expected)\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n# Modifications copyright (C) 2018 Uber Technologies, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# =============================================================================\n\nimport contextlib\nimport multiprocessing\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport time\nimport traceback\n\nimport cloudpickle\nimport mock\n\nfrom horovod.runner.util.threads import in_thread\n\n\ndef mpi_env_rank_and_size():\n    \"\"\"Get MPI rank and size from environment variables and return them as a\n    tuple of integers.\n\n    Most MPI implementations have an `mpirun` or `mpiexec` command that will\n    run an MPI executable and set up all communication necessary between the\n    different processors. As part of that set up, they will set environment\n    variables that contain the rank and size of the MPI_COMM_WORLD\n    communicator. We can read those environment variables from Python in order\n    to ensure that `hvd.rank()` and `hvd.size()` return the expected values.\n\n    Since MPI is just a standard, not an implementation, implementations\n    typically choose their own environment variable names. This function tries\n    to support several different implementation, but really it only needs to\n    support whatever implementation we want to use for the TensorFlow test\n    suite.\n\n    If this is not running under MPI, then defaults of rank zero and size one\n    are returned. (This is appropriate because when you call MPI_Init in an\n    application not started with mpirun, it will create a new independent\n    communicator with only one process in it.)\n    \"\"\"\n    rank_env = 'PMI_RANK OMPI_COMM_WORLD_RANK'.split()\n    size_env = 'PMI_SIZE OMPI_COMM_WORLD_SIZE'.split()\n\n    for rank_var, size_var in zip(rank_env, size_env):\n        rank = os.environ.get(rank_var)\n        size = os.environ.get(size_var)\n        if rank is not None and size is not None:\n            return int(rank), int(size)\n\n    # Default to rank zero and size one if there are no environment variables\n    return 0, 1\n\n\ndef delay(func, seconds):\n    \"\"\"Delays the execution of func in a separate thread by given seconds.\"\"\"\n    def fn():\n        time.sleep(seconds)\n        func()\n\n    return in_thread(target=fn)\n\n\ndef wait(func, timeout=None):\n    \"\"\"Wait for func to return True until timeout.\"\"\"\n    start = int(time.time())\n    while not func():\n        time.sleep(0.1)\n        if timeout is not None and int(time.time()) - start > timeout:\n            raise TimeoutError('Timed out waiting for func to return True')\n\n\n@contextlib.contextmanager\ndef capture(stdout=None, stderr=None):\n    out = sys.stdout\n    err = sys.stderr\n    if stdout is not None:\n        sys.stdout = stdout\n    if stderr is not None:\n        sys.stderr = stderr\n    try:\n        yield\n    finally:\n        if stdout is not None:\n            sys.stdout.seek(0)\n            sys.stdout = out\n        if stderr is not None:\n            sys.stderr.seek(0)\n            sys.stderr = err\n\n\n@contextlib.contextmanager\ndef tempdir():\n    dirpath = tempfile.mkdtemp()\n    try:\n        yield dirpath\n    finally:\n        shutil.rmtree(dirpath)\n\n\n@contextlib.contextmanager\ndef temppath():\n    path = tempfile.mktemp()\n    try:\n        yield path\n    finally:\n        if os.path.exists(path):\n            if os.path.isfile(path):\n                os.remove(path)\n            else:\n                shutil.rmtree(path)\n\n\n@contextlib.contextmanager\ndef override_args(tool=None, *args):\n    old = sys.argv[:]\n    try:\n        if tool:\n            sys.argv[0] = tool\n        sys.argv[1:] = args\n        yield\n    finally:\n        sys.argv = old\n\n\n@contextlib.contextmanager\ndef override_env(env):\n    old = os.environ\n    try:\n        os.environ = env\n        yield\n    finally:\n        os.environ = old\n\n\n@contextlib.contextmanager\ndef undo(fn):\n    try:\n        yield\n    finally:\n        fn()\n\n\n@contextlib.contextmanager\ndef is_built(gloo_is_built, mpi_is_built):\n    \"\"\"\n    Patches the gloo_built and mpi_built methods called from horovod.runner.run.run_controller\n    to return the given booleans. That method is used by horovod.spark.run to determine which\n    controller to use. Patching these methods allows to test horovod.spark.run without an MPI\n    implementation to be installed.\n\n    :param gloo_is_built: boolean returned by gloo_built\n    :param mpi_is_built: boolean returned by mpi_built\n    :return: mocked gloo_built and mpi_built methods\n    \"\"\"\n    with mock.patch(\"horovod.runner.launch.gloo_built\", return_value=gloo_is_built) as g:\n        with mock.patch(\"horovod.runner.launch.mpi_built\", return_value=mpi_is_built) as m:\n            yield g, m\n\n\n@contextlib.contextmanager\ndef mpi_implementation_flags(flags=[\"--mock-mpi-impl-flags\"],\n                             binding_args=[\"--mock-mpi-binding-args\"],\n                             mpi=None):\n    \"\"\"\n    Patches the _get_mpi_implementation_flags method used by horovod.runner.mpi_run to retrieve\n    MPI implementation specific command line flags. Patching this method allows to test mpi_run\n    without an MPI implementation to be installed.\n\n    :param flags: mock flags\n    :return: the mocked method\n    \"\"\"\n    with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", return_value=(flags, binding_args, mpi)) as m:\n        yield m\n\n\n@contextlib.contextmanager\ndef lsf_and_jsrun(lsf_exists, jsrun_installed):\n    \"\"\"\n    Patches the lsf.LSFUtils.using_lsf and is_jsrun_installed methods called from\n    horovod.runner.run.run_controller to return the given booleans.\n    :param lsf_exists: boolean returned by lsf.LSFUtils.using_lsf\n    :param jsrun_installed: boolean returned by is_jsrun_installed\n    :return: mocked methods\n    \"\"\"\n    with mock.patch(\"horovod.runner.launch.lsf.LSFUtils.using_lsf\", return_value=lsf_exists) as u:\n        with mock.patch(\"horovod.runner.launch.is_jsrun_installed\", return_value=jsrun_installed) as i:\n            yield u, i\n\n\ndef _subproc_wrapper(fn, queue, *args, **kwargs):\n    fn = cloudpickle.loads(fn)\n    try:\n        results = fn(*args, **kwargs)\n    except Exception as e:\n        traceback.print_exc(file=sys.stderr)\n        results = e\n    queue.put(results)\n\n\ndef spawn(fn):\n    def wrapped_fn(*args, **kwargs):\n        ctx = multiprocessing.get_context('spawn')\n        queue = ctx.Queue()\n\n        p = ctx.Process(\n            target=_subproc_wrapper,\n            args=(cloudpickle.dumps(fn), queue, *args),\n            kwargs=kwargs)\n\n        p.start()\n        p.join()\n        results = queue.get()\n        if isinstance(results, Exception):\n            raise RuntimeError(f'Spawned subprocess raised {type(results).__name__}, '\n                               f'check log output above for stack trace.')\n        return results\n\n    return wrapped_fn\n\n\ndef skip_or_fail_gpu_test(test, message):\n    \"\"\"Fails the test if GPUs are required, otherwise skips.\"\"\"\n    if int(os.environ.get('HOROVOD_TEST_GPU', 0)):\n        test.fail(message)\n    else:\n        test.skipTest(message)\n"], "fixing_code": ["# Copyright IBM Corp. 2020. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nimport os\nimport tempfile\n\nfrom shlex import quote\n\nfrom horovod.runner.common.util import safe_shell_exec\nfrom horovod.runner.util import lsf\nfrom distutils.spawn import find_executable\nfrom horovod.runner.mpi_run import _get_mpi_implementation_flags, _MPI_NOT_FOUND_ERROR_MSG\n\n\ndef is_jsrun_installed():\n    \"\"\"Returns True if jsrun is installed.\"\"\"\n    return find_executable('jsrun') is not None\n\n\ndef js_run(settings, nics, env, command, stdout=None, stderr=None):\n    \"\"\"\n    Runs Horovod with jsrun.\n\n    Args:\n        settings: Settings for running jsrun.\n                  Note: settings.num_proc and settings.hosts must not be None.\n        nics: Interfaces to include by jsrun.\n        env: Environment dictionary to use for running jsrun.\n        command: Command and arguments to run as a list of string.\n        stdout: Stdout of the mpi process.\n                Only used when settings.run_func_mode is True.\n        stderr: Stderr of the mpi process.\n                Only used when settings.run_func_mode is True.\n    \"\"\"\n    mpi_impl_flags, _ = _get_mpi_implementation_flags(settings.tcp_flag, env=env)\n    if mpi_impl_flags is None:\n        raise Exception(_MPI_NOT_FOUND_ERROR_MSG)\n\n    if not is_jsrun_installed():\n        raise Exception(\n            'horovod does not find the jsrun command.\\n\\n'\n            'Please, make sure you are running on a cluster with jsrun installed or '\n            'use one of the other launchers.')\n\n    if nics and 'NCCL_SOCKET_IFNAME' not in env:\n        env['NCCL_SOCKET_IFNAME'] = ','.join(nics)\n\n    smpiargs = ' '.join(mpi_impl_flags)\n    if settings.extra_mpi_args:\n        smpiargs += ' ' + settings.extra_mpi_args\n\n    if settings.binding_args:\n        binding_args = settings.binding_args\n    else:\n        rf = generate_jsrun_rankfile(settings)\n        if settings.verbose >= 2:\n            safe_shell_exec.execute('cat {rf}'.format(rf=rf))\n        binding_args = '--erf_input {rf}'.format(rf=rf)\n\n    jsrun_command = (\n        'jsrun {binding_args} '\n        '{output_filename_arg} '\n        '{smpiargs} '\n        '{command}'\n        .format(binding_args = binding_args,\n                output_filename_arg='--stdio_stderr {file} --stdio_stdout {file}'.format(file=settings.output_filename)\n                                    if settings.output_filename else '',\n                smpiargs= '--smpiargs {args}'.format(args=quote(smpiargs)) if smpiargs else '',\n                command=' '.join(quote(par) for par in command))\n    )\n\n    if settings.verbose >= 2:\n        print(jsrun_command)\n\n    # Execute the jsrun command.\n    if settings.run_func_mode:\n        exit_code = safe_shell_exec.execute(jsrun_command, env=env, stdout=stdout, stderr=stderr)\n        if exit_code != 0:\n            raise RuntimeError(\"jsrun failed with exit code {exit_code}\".format(exit_code=exit_code))\n    else:\n        os.execve('/bin/sh', ['/bin/sh', '-c', jsrun_command], env)\n\n\ndef generate_jsrun_rankfile(settings, path=None):\n    \"\"\"\n    Generates rankfile to use with jsrun.\n    It splits the cores among the processes, which leads to best performance according to experiments.\n\n    Args:\n        settings: Settings for running jsrun.\n                  Note: settings.num_proc and settings.hosts must not be None.\n        path: Optional path of the rankfile.\n              Note: this file will be overwritten.\n    \"\"\"\n    cpu_per_gpu = (lsf.LSFUtils.get_num_cores() * lsf.LSFUtils.get_num_threads()) // lsf.LSFUtils.get_num_gpus()\n    host_list = (x.split(':') for x in settings.hosts.split(','))\n\n    # Verify and truncate host list if necessary\n    validated_list = []\n    remaining_slots = settings.num_proc\n    for host, slots in host_list:\n        slots = int(slots)\n        if slots > lsf.LSFUtils.get_num_gpus():\n            raise ValueError('Invalid host input, slot count for host \\'{host}:{slots}\\' is greater '\n                             'than number of GPUs per host \\'{gpus}\\'.'.format(\n                host=host, slots=slots, gpus=lsf.LSFUtils.get_num_gpus()))\n        needed_slots = min(slots, remaining_slots)\n        validated_list.append((host, needed_slots))\n        remaining_slots -= needed_slots\n        if remaining_slots == 0:\n            break\n    if remaining_slots != 0:\n        raise ValueError('Not enough slots on the hosts to fulfill the {slots} requested.'.format(\n            slots=settings.num_proc))\n\n    # Generate rankfile\n    # using mkstemp here instead of insecure mktemp.\n    # note that the caller is responsible for cleaning up this file\n    if path is None:\n        fd, path = tempfile.mkstemp()\n        fd.close()\n\n    with open(path, 'w') as tmp:\n        tmp.write('overlapping_rs: allow\\n')\n        tmp.write('cpu_index_using: logical\\n')\n        rank = 0\n        for host, slots in validated_list:\n            cpu_val = 0\n            tmp.write('\\n')\n            for s in range(slots):\n                tmp.write('rank: {rank}: {{ hostname: {host}; cpu: {{{scpu}-{ecpu}}} ; gpu: * ; mem: * }}\\n'.format(\n                    rank=rank,\n                    host=host,\n                    scpu=cpu_val,\n                    ecpu=cpu_val + cpu_per_gpu - 1\n                ))\n                rank += 1\n                cpu_val += cpu_per_gpu\n    return path\n", "# Copyright 2019 Uber Technologies, Inc. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\nimport copy\nimport io\nimport itertools\nimport logging\nimport multiprocessing\nimport os\nimport subprocess\nimport sys\nimport threading\nimport time\nimport unittest\nimport warnings\n\nimport mock\nimport psutil\nimport pytest\nfrom mock import MagicMock\n\nimport horovod\nfrom horovod.runner import _HorovodArgs\nfrom horovod.runner.common.util import config_parser, hosts, safe_shell_exec, secret, \\\n    settings as hvd_settings, timeout\nfrom horovod.runner.common.util.host_hash import _hash, host_hash\nfrom horovod.runner.common.util.hosts import SlotInfo, get_host_assignments, parse_hosts\nfrom horovod.runner.gloo_run import gloo_run\nfrom horovod.runner.js_run import js_run, generate_jsrun_rankfile\nfrom horovod.runner.launch import gloo_built, parse_args, run_controller, _run\nfrom horovod.runner.mpi_run import _get_mpi_implementation, _get_mpi_implementation_flags, \\\n    _LARGE_CLUSTER_THRESHOLD as large_cluster_threshold, mpi_available, mpi_run, \\\n    _OMPI_IMPL, _SMPI_IMPL, _MPICH_IMPL, _IMPI_IMPL, _UNKNOWN_IMPL, _MISSING_IMPL\nfrom horovod.runner.util.threads import in_thread, on_event\n\nsys.path.append(os.path.join(os.path.dirname(__file__), os.pardir, 'utils'))\n\nfrom common import is_built, lsf_and_jsrun, override_args, override_env, temppath, delay, wait\n\n\nclass RunTests(unittest.TestCase):\n    \"\"\"\n    Tests for horovod.runner.\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(RunTests, self).__init__(*args, **kwargs)\n        warnings.simplefilter('module')\n\n    def test_params_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--fusion-threshold-mb', '10',\n                           '--cycle-time-ms', '20',\n                           '--cache-capacity', '512',\n                           '--hierarchical-allreduce',\n                           '--hierarchical-allgather'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_FUSION_THRESHOLD), str(10 * 1024 * 1024))\n            self.assertEqual(env.get(config_parser.HOROVOD_CYCLE_TIME), '20.0')\n            self.assertEqual(env.get(config_parser.HOROVOD_CACHE_CAPACITY), '512')\n            self.assertEqual(env.get(config_parser.HOROVOD_HIERARCHICAL_ALLREDUCE), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_HIERARCHICAL_ALLGATHER), '1')\n\n    def test_autotune_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--autotune',\n                           '--autotune-log-file', '/tmp/autotune.txt',\n                           '--autotune-warmup-samples', '1',\n                           '--autotune-steps-per-sample', '5',\n                           '--autotune-bayes-opt-max-samples', '10',\n                           '--autotune-gaussian-process-noise', '0.2'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_LOG), '/tmp/autotune.txt')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_WARMUP_SAMPLES), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_STEPS_PER_SAMPLE), '5')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_BAYES_OPT_MAX_SAMPLES), '10')\n            self.assertEqual(env.get(config_parser.HOROVOD_AUTOTUNE_GAUSSIAN_PROCESS_NOISE), '0.2')\n\n    def test_autotuning_with_fixed_param(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--autotune',\n                           '--cache-capacity', '1024',\n                           '--no-hierarchical-allgather'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertNotIn(config_parser.HOROVOD_FUSION_THRESHOLD, env)\n            self.assertNotIn(config_parser.HOROVOD_CYCLE_TIME, env)\n            self.assertEqual(env.get(config_parser.HOROVOD_CACHE_CAPACITY), '1024')\n            self.assertNotIn(config_parser.HOROVOD_HIERARCHICAL_ALLREDUCE, env)\n            self.assertEqual(env.get(config_parser.HOROVOD_HIERARCHICAL_ALLGATHER), '0')\n\n    def test_timeline_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--timeline-filename', '/tmp/timeline.json',\n                           '--timeline-mark-cycles'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_TIMELINE), '/tmp/timeline.json')\n            self.assertEqual(env.get(config_parser.HOROVOD_TIMELINE_MARK_CYCLES), '1')\n\n    def test_stall_check_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--no-stall-check'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_STALL_CHECK_DISABLE), '1')\n\n        with override_args('horovodrun', '-np', '2',\n                           '--stall-check-warning-time-seconds', '10',\n                           '--stall-check-shutdown-time-seconds', '20'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertNotIn(config_parser.HOROVOD_STALL_CHECK_DISABLE, env)\n            self.assertEqual(env.get(config_parser.HOROVOD_STALL_CHECK_TIME_SECONDS), '10')\n            self.assertEqual(env.get(config_parser.HOROVOD_STALL_SHUTDOWN_TIME_SECONDS), '20')\n\n    def test_library_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--mpi-threads-disable',\n                           '--num-nccl-streams', '2',\n                           '--thread-affinity', '1',\n                           '--gloo-timeout-seconds', '60'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_MPI_THREADS_DISABLE), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_NUM_NCCL_STREAMS), '2')\n            self.assertEqual(env.get(config_parser.HOROVOD_THREAD_AFFINITY), '1')\n            self.assertEqual(env.get(config_parser.HOROVOD_GLOO_TIMEOUT_SECONDS), '60')\n\n    def test_library_env_override(self):\n        \"\"\"Tests that environment variables override arg defaults.\"\"\"\n        with override_args('horovodrun', '-np', '2'):\n            args = parse_args()\n            env = {\n                'HOROVOD_GLOO_TIMEOUT_SECONDS': '1800',\n            }\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_GLOO_TIMEOUT_SECONDS), '1800')\n\n    def test_logging_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--log-level', 'INFO',\n                           '--log-hide-timestamp'):\n            args = parse_args()\n            env = {}\n            config_parser.set_env_from_args(env, args)\n\n            self.assertEqual(env.get(config_parser.HOROVOD_LOG_LEVEL), 'INFO')\n            self.assertEqual(env.get(config_parser.HOROVOD_LOG_HIDE_TIME), '1')\n\n    def test_config_file(self):\n        config_filename = os.path.join(os.path.dirname(__file__), 'data/config.test.yaml')\n        with override_args('horovodrun', '-np', '2',\n                           '--config-file', config_filename):\n            args = parse_args()\n\n            self.assertTrue(args.use_gloo)\n\n            # Params\n            self.assertEqual(args.fusion_threshold_mb, 32)\n            self.assertEqual(args.cycle_time_ms, 10)\n            self.assertEqual(args.cache_capacity, 2048)\n            self.assertTrue(args.hierarchical_allreduce)\n            self.assertTrue(args.hierarchical_allgather)\n\n            # Autotune\n            self.assertTrue(args.autotune)\n            self.assertEqual(args.autotune_log_file, 'horovod_autotune_log.txt')\n            self.assertEqual(args.autotune_warmup_samples, 5)\n            self.assertEqual(args.autotune_steps_per_sample, 20)\n            self.assertEqual(args.autotune_bayes_opt_max_samples, 50)\n            self.assertEqual(args.autotune_gaussian_process_noise, 0.9)\n\n            # Timeline\n            self.assertEqual(args.timeline_filename, 'horovod_timeline.json')\n            self.assertTrue(args.timeline_mark_cycles)\n\n            # Stall Check\n            self.assertFalse(args.no_stall_check)\n            self.assertEqual(args.stall_check_warning_time_seconds, 120)\n            self.assertEqual(args.stall_check_shutdown_time_seconds, 240)\n\n            # Library Options\n            self.assertTrue(args.mpi_threads_disable)\n            self.assertEqual(args.num_nccl_streams, 2)\n            self.assertEqual(args.thread_affinity, 1)\n            self.assertEqual(args.gloo_timeout_seconds, 60)\n\n            # Logging\n            self.assertEqual(args.log_level, 'INFO')\n            self.assertFalse(args.log_with_timestamp)\n\n    def test_config_file_override_args(self):\n        config_filename = os.path.join(os.path.dirname(__file__), 'data/config.test.yaml')\n        with override_args('horovodrun', '-np', '2',\n                           '--fusion-threshold-mb', '256',\n                           '--config-file', config_filename,\n                           '--cycle-time-ms', '20',):\n            args = parse_args()\n            self.assertEqual(args.fusion_threshold_mb, 256)\n            self.assertEqual(args.cycle_time_ms, 20)\n\n    def test_validate_config_args(self):\n        with override_args('horovodrun', '-np', '2',\n                           '--fusion-threshold-mb', '-1'):\n            with pytest.raises(ValueError):\n                parse_args()\n\n    # test_on_event tests in_thread as well, but it does not test args\n    def test_in_thread_args(self):\n        fn = mock.Mock()\n        thread = in_thread(fn, args=(1,))\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once_with(1)\n\n        fn = mock.Mock()\n        thread = in_thread(fn, args=(1, 2))\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once_with(1, 2)\n\n        fn = mock.Mock()\n        thread = in_thread(fn, args=(1, 2), silent=True)\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once_with(1, 2)\n\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^args must be a tuple, not <(class|type) 'int'>, \"\n                                             \"for a single argument use \\\\(arg,\\\\)$\"):\n            in_thread(fn, args=1)\n        fn.assert_not_called()\n\n    def test_on_event(self):\n        # a happy run without args and stop event\n        event = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n\n        # a happy run with args but without stop event\n        event = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn, ('a', 1))\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n        fn.assert_called_once_with('a', 1)\n\n        # a happy run with stop event but unused\n        event = threading.Event()\n        stop = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn, stop=stop, check_stop_interval_s=0.01)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n        stop.set()\n        time.sleep(0.1)\n        fn.assert_called_once()\n\n        # stop the thread before we set the event\n        event = threading.Event()\n        stop = threading.Event()\n        fn = mock.Mock()\n        thread = on_event(event, fn, stop=stop, check_stop_interval_s=0.01)\n        fn.assert_not_called()\n        stop.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_not_called()\n        event.set()\n        time.sleep(0.1)\n        fn.assert_not_called()\n\n        # test with exception\n        def exception():\n            raise Exception(\"Test Exception\")\n\n        event = threading.Event()\n        fn = mock.Mock(side_effect=exception)\n        thread = on_event(event, fn)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n\n        # test with exception but silent\n        event = threading.Event()\n        fn = mock.Mock(side_effect=exception)\n        thread = on_event(event, fn)\n        fn.assert_not_called()\n        event.set()\n        thread.join(1.0)\n        self.assertFalse(thread.is_alive())\n        fn.assert_called_once()\n\n        # test None event\n        event = None\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^Event must not be None$\"):\n            on_event(event, fn)\n        fn.assert_not_called()\n\n        # test non-tuple args\n        event = threading.Event()\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^args must be a tuple, not <(class|type) 'int'>, \"\n                                             \"for a single argument use \\\\(arg,\\\\)$\"):\n            on_event(event, fn, args=1)\n        fn.assert_not_called()\n\n        # test None stop and non-daemon\n        event = threading.Event()\n        fn = mock.Mock()\n        with pytest.raises(ValueError, match=\"^Stop event must be given for non-daemon event thread$\"):\n            on_event(event, fn, stop=None, daemon=False)\n        fn.assert_not_called()\n\n    def test_prefix_connection(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:first line\\n'\n                                                '[123]<prefix>:second line\\n'\n                                                '[123]<prefix>:more lines\\n')\n\n    def test_prefix_connection_with_unicode(self):\n        string = '\u2200\u2201\u2202\u2203\u2204\u2205\u2206\u2207\u2208\u2209\u220a\u220b\u220c\u220d\u220e\u220f\u2210\u2211\\n\u231a\u231b\u26c4\u2705\u2026\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:\u2200\u2201\u2202\u2203\u2204\u2205\u2206\u2207\u2208\u2209\u220a\u220b\u220c\u220d\u220e\u220f\u2210\u2211\\n'\n                                                '[123]<prefix>:\u231a\u231b\u26c4\u2705\u2026\\n')\n\n    def test_prefix_connection_with_multibyte_unicode(self):\n        block = '\u2588\u2593\u2592\u2591\u2592\u2593'*1000\n        string = block + '\\n' + block + '\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:' + block + '\\n' +\n                                                '[123]<prefix>:' + block + '\\n')\n\n    def test_prefix_connection_with_timestamp(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection_with_timestamp(\n            string, prefix='prefix', index=123,\n            expected='Mon Jan 20 12:00:01 2020[123]<prefix>:first line\\n'\n                     'Mon Jan 20 12:00:02 2020[123]<prefix>:second line\\n'\n                     'Mon Jan 20 12:00:03 2020[123]<prefix>:more lines\\n'\n        )\n\n    def test_prefix_connection_with_timestamp_without_index(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection_with_timestamp(string, prefix=None, index=None,\n                                                      expected=string)\n\n    def test_prefix_connection_without_trailing_newline(self):\n        string = 'first line\\nsecond line\\nmore lines'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:first line\\n'\n                                            '[123]<prefix>:second line\\n'\n                                            '[123]<prefix>:more lines')\n\n    def test_prefix_connection_without_index(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=None, expected=string)\n\n    def test_prefix_connection_without_prefix(self):\n        string = 'first line\\nsecond line\\nmore lines\\n'\n        self.do_test_prefix_connection(string, prefix=None, index=123, expected=string)\n\n    def test_prefix_connection_with_carriage_return(self):\n        string = 'first line\\rfirst line again\\nsecond line\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=123,\n                                       expected='[123]<prefix>:first line\\r'\n                                            '[123]<prefix>:first line again\\n'\n                                            '[123]<prefix>:second line\\n')\n\n    def test_prefix_connection_with_carriage_return_without_index(self):\n        string = 'first line\\rfirst line again\\nsecond line\\n'\n        self.do_test_prefix_connection(string, prefix='prefix', index=None, expected=string)\n\n    def test_prefix_connection_with_carriage_return_without_prefix(self):\n        string = 'first line\\rfirst line again\\nsecond line\\n'\n        self.do_test_prefix_connection(string, prefix=None, index=123, expected=string)\n\n    def do_test_prefix_connection(self, string, prefix, index, expected, timestamp=False):\n        # create a Pipe Connection and populate it with string\n        (connection, w) = multiprocessing.get_context('spawn').Pipe(duplex=False)\n        with os.fdopen(w.fileno(), 'wt', encoding='utf8', newline='', closefd=False) as stream:\n            stream.write(string)\n        w.close()\n\n        dst = io.StringIO()\n        safe_shell_exec.prefix_connection(connection, dst, prefix=prefix, index=index,\n                                          prefix_output_with_timestamp=timestamp)\n        self.assertEqual(expected, dst.getvalue())\n\n    def do_test_prefix_connection_with_timestamp(self, string_or_connection, prefix, index, expected):\n        # control the time used to prepend the timestamp\n        class MockTime:\n            def __init__(self):\n                # start at 2020-01-20 12:00:00\n                self._time = 1579521600\n\n            def time(self, seconds):\n                from time import gmtime\n                self._time = self._time + 1\n                return gmtime(self._time)\n\n        with mock.patch('horovod.runner.common.util.safe_shell_exec.time.localtime',\n                        side_effect=MockTime().time):\n            self.do_test_prefix_connection(string_or_connection, prefix, index, expected, timestamp=True)\n\n    def test_prefix_connection_does_stream(self):\n        index = 123\n        prefix = 'prefix'\n        expected = '[123]<prefix>:first line\\r' \\\n                   '[123]<prefix>:first line again\\n' \\\n                   '[123]<prefix>:second line\\n' \\\n                   '[123]<prefix>:more lines'\n\n        timeout = 0.2\n        barrier = multiprocessing.Barrier(2, timeout=timeout)\n\n        def writer(write_connection):\n            def write(stream, text):\n                stream.write(text)\n                logging.info('wrote: {}'.format(text))\n                stream.flush()\n\n                # are we expecting the reader to read something\n                logging.info('waiting for reader')\n                if '\\r' in text or '\\n' in text:\n                    # yes, barrier should not timeout\n                    try:\n                        barrier.wait()\n                    except threading.BrokenBarrierError:\n                        self.fail('reader side should have read something from the stream')\n                else:\n                    # no, barrier should timeout\n                    try:\n                        barrier.wait()\n                        self.fail('reader side should not have read anything from the stream')\n                    except threading.BrokenBarrierError:\n                        logging.info('reader did not read')\n                        barrier.reset()\n                        pass\n                logging.info('continuing writing')\n\n            try:\n                with os.fdopen(write_connection.fileno(), 'wt', encoding='utf8', newline='', closefd=False) as stream:\n                    for text in ['first line\\r',\n                                 'first ', 'line ', 'again\\n',\n                                 'second line\\nmore ', 'lines']:\n                        write(stream, text)\n            finally:\n                write_connection.close()\n\n        actual = []\n        do_read = True\n\n        def reader(read_connection):\n            try:\n                while do_read:\n                    text = os.read(read_connection.fileno(), 1000)\n                    if not text:\n                        break\n                    text = text.decode('utf8')\n                    actual.append(text)\n                    logging.info('read: {}'.format(text))\n                    logging.info('waiting for writer')\n                    try:\n                        barrier.wait()\n                    except threading.BrokenBarrierError as e:\n                        if do_read:\n                            raise e\n                        break\n                    logging.info('continuing reading')\n            finally:\n                read_connection.close()\n\n        # one thread writes into the w side of this pipe\n        # prefix_connection reads on the other end of this pipe\n        (connection, w) = multiprocessing.get_context('spawn').Pipe(duplex=False)\n        writer_thread = in_thread(writer, (w,))\n\n        # prefix_connection writes to the write side of this Pipe (opened as a text stream)\n        # another thread reads from the r side of this pipe\n        (r, dst_con) = multiprocessing.get_context('spawn').Pipe(duplex=False)\n        reader_thread = in_thread(reader, (r,))\n\n        with os.fdopen(dst_con.fileno(), 'wt', encoding='utf8', newline='', closefd=False) as dst:\n            safe_shell_exec.prefix_connection(connection, dst, prefix=prefix, index=index,\n                                              prefix_output_with_timestamp=False)\n\n        writer_thread.join(2*timeout)\n        do_read = False\n        reader_thread.join(2*timeout)\n\n        self.assertEqual(expected, ''.join(actual))\n\n    def test_safe_shell_exec_captures_stdout(self):\n        self.do_test_safe_shell_exec('echo hello', 0, 'hello\\n', '')\n\n    def test_safe_shell_exec_captures_stderr(self):\n        self.do_test_safe_shell_exec('echo hello >&2', 0, '', 'hello\\n')\n\n    def test_safe_shell_exec_captures_last_line_wo_eol(self):\n        cmd = 'bash -c \"echo -e -n \\\\\"hello\\nstdout\\\\\"; echo -e -n \\\\\"hello\\nstderr\\\\\" >&2\"'\n        self.do_test_safe_shell_exec(cmd, 0, 'hello\\nstdout', 'hello\\nstderr')\n\n    def test_safe_shell_exec_returns_exit_code(self):\n        self.do_test_safe_shell_exec('false', 1, '', '')\n\n    @pytest.mark.skip(reason='https://github.com/horovod/horovod/issues/1993')\n    def test_safe_shell_exec_interrupts_on_event(self):\n        # interrupt execute in one second\n        interrupt = threading.Event()\n        interrupt_delay = 1.0\n        delay(lambda: interrupt.set(), interrupt_delay)\n\n        sleep = interrupt_delay + safe_shell_exec.GRACEFUL_TERMINATION_TIME_S + 2.0\n        start = time.time()\n        self.do_test_safe_shell_exec('sleep {}'.format(sleep), 143, '', None, interrupt)\n        duration = time.time() - start\n\n        self.assertGreaterEqual(duration, interrupt_delay)\n        self.assertLess(duration, sleep - 1.0, 'sleep should not finish')\n\n    def test_safe_shell_exec_interrupts_on_parent_shutdown(self):\n        sleep = 20\n        parent_script = os.path.join(os.path.dirname(__file__), 'data/run_safe_shell_exec.py')\n        child_script = os.path.join(os.path.dirname(__file__), 'data/sleep.py')\n\n        def get_pid(logfile):\n            # Wait until the script has written its PID to the logfile\n            wait(lambda: os.path.exists(logfile), timeout=5)\n            with open(logfile, 'r') as f:\n                return int(f.read())\n\n        with temppath() as parent_logfile, temppath() as child_logfile:\n            # It's important that this executes in an entirely different interpreter with as little shared\n            # state as possible, to avoid issues with the semaphore tracker.\n            cmd = ' '.join([sys.executable, parent_script, parent_logfile, child_script, str(sleep), child_logfile])\n            p = subprocess.Popen(cmd, shell=True)\n\n            parent = psutil.Process(get_pid(parent_logfile))\n            child = psutil.Process(get_pid(child_logfile))\n\n            self.assertTrue(parent.is_running())\n            self.assertTrue(child.is_running())\n\n            # Hard kill the parent process\n            parent.kill()\n            parent.wait(timeout=safe_shell_exec.GRACEFUL_TERMINATION_TIME_S)\n            p.wait()\n\n            # Child process will exit when pipe breaks\n            child.wait(timeout=2 * safe_shell_exec.GRACEFUL_TERMINATION_TIME_S + 1)\n\n            self.assertFalse(parent.is_running())\n            self.assertFalse(child.is_running())\n\n    def do_test_safe_shell_exec(self, cmd, expected_exit_code, expected_stdout, expected_stderr, event=None):\n        stdout = io.StringIO()\n        stderr = io.StringIO()\n        res = safe_shell_exec.execute(cmd, stdout=stdout, stderr=stderr, events=[event] if event else None)\n        self.assertEqual(expected_exit_code, res)\n        if expected_stdout is not None:\n            self.assertEqual(expected_stdout, stdout.getvalue())\n        if expected_stderr is not None:\n            self.assertEqual(expected_stderr, stderr.getvalue())\n\n    def test_hash(self):\n        hash = _hash(\"test string\")\n        self.assertEqual(hash, '6f8db599de986fab7a21625b7916589c')\n\n    def test_host_hash(self):\n        hash = host_hash()\n        salted = host_hash('salt')\n        empty_salted = host_hash('')\n\n        self.assertNotEqual(salted, hash)\n        self.assertEqual(empty_salted, hash)\n\n    def test_get_mpi_implementation(self):\n        def test(output, expected, exit_code=0):\n            ret = (output, exit_code) if output is not None else None\n            env = {'VAR': 'val'}\n            with mock.patch(\"horovod.runner.mpi_run.tiny_shell_exec.execute\", return_value=ret) as m:\n                implementation = _get_mpi_implementation(env)\n                self.assertEqual(expected, implementation)\n                m.assert_called_once_with('mpirun --version', env)\n\n        test((\"mpirun (Open MPI) 2.1.1\\n\"\n              \"Report bugs to http://www.open-mpi.org/community/help/\\n\"), _OMPI_IMPL)\n\n        test(\"OpenRTE\", _OMPI_IMPL)\n\n        test(\"IBM Spectrum MPI\", _SMPI_IMPL)\n\n        test((\"HYDRA build details:\\n\"\n              \"    Version:           3.3a2\\n\"\n              \"    Configure options: 'MPICHLIB_CFLAGS=-g -O2'\\n\"), _MPICH_IMPL)\n\n        test(\"Intel(R) MPI\", _IMPI_IMPL)\n\n        test(\"Unknown MPI v1.00\", _UNKNOWN_IMPL)\n\n        test(\"output\", exit_code=1, expected=_MISSING_IMPL)\n\n        test(None, _MISSING_IMPL)\n\n    def test_run_controller(self):\n        def test(use_gloo, use_mpi, use_js,\n                 gloo_is_built, mpi_is_built,\n                 lsf_exists, jsrun_installed,\n                 expected, exception):\n            gloo_run = MagicMock()\n            mpi_run = MagicMock()\n            js_run = MagicMock()\n\n            with is_built(gloo_is_built, mpi_is_built):\n                with lsf_and_jsrun(lsf_exists, jsrun_installed):\n                    if exception is not None:\n                        with pytest.raises(ValueError, match=exception) as e:\n                            run_controller(use_gloo, gloo_run, use_mpi, mpi_run, use_js, js_run, verbosity=2)\n                        return\n                    run_controller(use_gloo, gloo_run, use_mpi, mpi_run, use_js, js_run, verbosity=2)\n\n            if expected == \"gloo\":\n                gloo_run.assert_called_once()\n                mpi_run.assert_not_called()\n                js_run.assert_not_called()\n            elif expected == \"mpi\":\n                gloo_run.assert_not_called()\n                mpi_run.assert_called_once()\n                js_run.assert_not_called()\n            elif expected == \"js\":\n                gloo_run.assert_not_called()\n                mpi_run.assert_not_called()\n                js_run.assert_called_once()\n            else:\n                raise ValueError(\"unsupported framework: {}\".format(expected))\n\n        bool_values = [False, True]\n        bool_values_and_none = [None, False, True]\n\n        for use_gloo, use_mpi, use_js, \\\n            gloo_is_built, mpi_is_built, \\\n            lsf_exists, jsrun_installed in \\\n            itertools.product(bool_values_and_none, bool_values_and_none, bool_values_and_none,\n                              bool_values, bool_values,\n                              bool_values, bool_values):\n\n            expected = exception = None\n            if use_gloo:\n                if gloo_is_built:\n                    expected = 'gloo'\n                else:\n                    exception = r'^Gloo support has not been built\\.  If this is not expected, ensure CMake is installed ' \\\n                                r'and reinstall Horovod with HOROVOD_WITH_GLOO=1 to debug the build error\\.$'\n            elif use_mpi:\n                if mpi_is_built:\n                    expected = 'mpi'\n                else:\n                    exception = r'^MPI support has not been built\\.  If this is not expected, ensure MPI is installed ' \\\n                                r'and reinstall Horovod with HOROVOD_WITH_MPI=1 to debug the build error\\.$'\n            elif use_js:\n                if mpi_is_built:\n                    if lsf_exists:\n                        expected = 'js'\n                    else:\n                        exception = 'Horovod did not detect an LSF job.  The jsrun launcher can only be used in that environment. ' \\\n                                    'Please, pick a different launcher for other environments.'\n                else:\n                    exception = r'^MPI support has not been built\\.  If this is not expected, ensure MPI is installed ' \\\n                                r'and reinstall Horovod with HOROVOD_WITH_MPI=1 to debug the build error\\.$'\n            elif mpi_is_built:\n                if lsf_exists and jsrun_installed:\n                    expected = 'js'\n                else:\n                    expected = 'mpi'\n            elif gloo_is_built:\n                expected = 'gloo'\n            else:\n                exception = r'Neither MPI nor Gloo support has been built\\. Try reinstalling Horovod ensuring that ' \\\n                            r'either MPI is installed \\(MPI\\) or CMake is installed \\(Gloo\\)\\.'\n\n            test(use_gloo, use_mpi, use_js,\n                 gloo_is_built, mpi_is_built,\n                 lsf_exists, jsrun_installed,\n                 expected, exception)\n\n    \"\"\"\n    Minimal mpi_run settings for tests.\n    \"\"\"\n    minimal_settings = hvd_settings.Settings(\n        verbose=0,\n        num_proc=2,\n        hosts='localhost:2',\n        run_func_mode=True\n    )\n\n    \"\"\"\n    Tests mpi_run with minimal settings.\n    \"\"\"\n    def test_mpi_run_minimal(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute:\n                mpi_run(settings, None, {}, cmd)\n\n                # call the mocked _get_mpi_implementation_flags method\n                mpi_flags, binding_args, mpi = horovod.runner.mpi_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                if _IMPI_IMPL == mpi:\n                    expected_cmd = ('mpirun '\n                                    '-l -n 2 -hosts localhost '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(binding_args=' '.join(binding_args), mpi_flags=' '.join(mpi_flags))\n                else:\n                    expected_cmd = ('mpirun '\n                                    '--allow-run-as-root --tag-output '\n                                    '-np 2 -H localhost:2 '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(binding_args=' '.join(binding_args), mpi_flags=' '.join(mpi_flags))\n\n                # remove PYTHONPATH from execute's env\n                # we cannot know the exact value of that env variable\n                # we test right handling of PYTHONPATH in test_mpi_run_*pythonpath* below\n                self.assertIn('env', execute.call_args.kwargs)\n                if 'PYTHONPATH' in execute.call_args.kwargs['env']:\n                    execute.call_args.kwargs['env'].pop('PYTHONPATH')\n\n                expected_env = {'PATH': os.environ.get('PATH')}\n                execute.assert_called_once_with(expected_cmd, env=expected_env, stdout=None, stderr=None)\n\n    \"\"\"\n    Tests mpi_run on a large cluster.\n    \"\"\"\n    def test_mpi_run_on_large_cluster(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = copy.copy(self.minimal_settings)\n        settings.hosts = ','.join(['localhost:1'] * large_cluster_threshold)\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute:\n                mpi_run(settings, None, {}, cmd)\n\n                # call the mocked _get_mpi_implementation_flags method\n                mpi_flags, binding_args, mpi = horovod.runner.mpi_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                if _IMPI_IMPL == mpi:\n                    expected_cmd = ('mpirun '\n                                    '-l -n 2 -ppn 1 -hosts {hosts} '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(hosts=settings.hosts, binding_args=' '.join(binding_args),\n                                                  mpi_flags=' '.join(mpi_flags))\n                else:\n                    mpi_flags.append('-mca plm_rsh_no_tree_spawn true')\n                    mpi_flags.append('-mca plm_rsh_num_concurrent {}'.format(large_cluster_threshold))\n                    expected_cmd = ('mpirun '\n                                    '--allow-run-as-root --tag-output '\n                                    '-np 2 -H {hosts} '\n                                    '{binding_args} '\n                                    '{mpi_flags}       '\n                                    'cmd').format(hosts=settings.hosts, binding_args=' '.join(binding_args),\n                                                  mpi_flags=' '.join(mpi_flags))\n\n                # remove PYTHONPATH from execute's env\n                # we cannot know the exact value of that env variable\n                # we test right handling of PYTHONPATH in test_mpi_run_*pythonpath* below\n                self.assertIn('env', execute.call_args.kwargs)\n                if 'PYTHONPATH' in execute.call_args.kwargs['env']:\n                    execute.call_args.kwargs['env'].pop('PYTHONPATH')\n\n                expected_env = {'PATH': os.environ.get('PATH')}\n                execute.assert_called_once_with(expected_cmd, env=expected_env, stdout=None, stderr=None)\n\n    \"\"\"\n    Tests mpi_run with full settings.\n    \"\"\"\n    def test_mpi_run_full(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd', 'arg1', 'arg2']\n        nics = ['eth0', 'eth1']\n        env = {'env1': 'val1', 'env2': 'val2'}\n        stdout = '<stdout>'\n        stderr = '<stderr>'\n        tmout = timeout.Timeout(5, message='Timed out waiting for something.')\n        settings = hvd_settings.Settings(\n            verbose=0,\n            ssh_port=1022,\n            extra_mpi_args='>mpi-extra args go here<',\n            binding_args='>binding args go here<',\n            key=secret.make_secret_key(),\n            start_timeout=tmout,\n            num_proc=1,\n            hosts='localhost:1',\n            output_filename='>output filename goes here<',\n            run_func_mode=True\n        )\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags) as impl:\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute:\n                mpi_run(settings, nics, env, cmd, stdout=stdout, stderr=stderr)\n\n                # assert call on _get_mpi_implementation_flags\n                impl.assert_called_once_with(None, env=env)\n\n                # call the mocked _get_mpi_implementation_flags method ourselves\n                mpi_flags, _, mpi = horovod.runner.mpi_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                if _IMPI_IMPL == mpi:\n                    expected_command = ('mpirun '\n                                        '-l -n 1 -hosts {hosts} '\n                                        '>binding args go here< '\n                                        '{mpi_flags} '\n                                        '-bootstrap-exec-args \"-p 1022\" '\n                                        '-genv NCCL_SOCKET_IFNAME=eth0,eth1 '\n                                        '-outfile-pattern >output pattern goes here< '\n                                        '-genvlist env1,env2 '\n                                        '>mpi-extra args go here< '\n                                        'cmd arg1 arg2').format(hosts=settings.hosts,\n                                                                mpi_flags=' '.join(mpi_flags))\n                else:\n                    expected_command = ('mpirun '\n                                        '--allow-run-as-root --tag-output '\n                                        '-np 1 -H {hosts} '\n                                        '>binding args go here< '\n                                        '{mpi_flags} '\n                                        '-mca plm_rsh_args \"-p 1022\" '\n                                        '-mca btl_tcp_if_include eth0,eth1 -x NCCL_SOCKET_IFNAME=eth0,eth1 '\n                                        '--output-filename >output filename goes here< '\n                                        '-x env1 -x env2 '\n                                        '>mpi-extra args go here< '\n                                        'cmd arg1 arg2').format(hosts=settings.hosts,\n                                                                mpi_flags=' '.join(mpi_flags))\n\n                # remove PYTHONPATH from execute's env\n                # we cannot know the exact value of that env variable\n                # we test right handling of PYTHONPATH in test_mpi_run_*pythonpath* below\n                self.assertIn('env', execute.call_args.kwargs)\n                if 'PYTHONPATH' in execute.call_args.kwargs['env']:\n                    execute.call_args.kwargs['env'].pop('PYTHONPATH')\n\n                expected_env = {'env1': 'val1', 'env2': 'val2', 'PATH': os.environ.get('PATH')}\n                execute.assert_called_once_with(expected_command, env=expected_env, stdout=stdout, stderr=stderr)\n\n    \"\"\"\n    Tests mpi_run without PYTHONPATH set.\n    \"\"\"\n    def test_mpi_run_without_pythonpath(self):\n        self.do_test_mpi_run_env_override({}, {}, 'PYTHONPATH', None)\n\n    \"\"\"\n    Tests mpi_run with PYTHONPATH set in sys.\n    \"\"\"\n    def test_mpi_run_with_sys_pythonpath(self):\n        self.do_test_mpi_run_env_override({'PYTHONPATH': 'ppath'}, {}, 'PYTHONPATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with PYTHONPATH set in env.\n    \"\"\"\n    def test_mpi_run_with_env_pythonpath(self):\n        self.do_test_mpi_run_env_override({}, {'PYTHONPATH': 'ppath'}, 'PYTHONPATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with both PYTHONPATH set.\n    \"\"\"\n    def test_mpi_run_with_both_pythonpaths(self):\n        self.do_test_mpi_run_env_override({'PYTHONPATH': 'sys-ppath'}, {'PYTHONPATH': 'env-ppath'}, 'PYTHONPATH', 'env-ppath')\n\n    \"\"\"\n    Tests mpi_run without PATH set.\n    \"\"\"\n    def test_mpi_run_without_path(self):\n        self.do_test_mpi_run_env_override({}, {}, 'PATH', None)\n\n    \"\"\"\n    Tests mpi_run with PATH set in sys.\n    \"\"\"\n    def test_mpi_run_with_sys_path(self):\n        self.do_test_mpi_run_env_override({'PATH': 'ppath'}, {}, 'PATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with PATH set in env.\n    \"\"\"\n    def test_mpi_run_with_env_path(self):\n        self.do_test_mpi_run_env_override({}, {'PATH': 'ppath'}, 'PATH', 'ppath')\n\n    \"\"\"\n    Tests mpi_run with both PATH set.\n    \"\"\"\n    def test_mpi_run_with_both_paths(self):\n        self.do_test_mpi_run_env_override({'PATH': 'sys-path'}, {'PATH': 'env-path'}, 'PATH', 'env-path')\n\n    \"\"\"\n    Actually tests mpi_run overrides arg env with sys env.\n    \"\"\"\n    def do_test_mpi_run_env_override(self, sysenv, argenv, env_var, expected):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags),\\\n             mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0) as execute,\\\n             override_env(sysenv):\n            mpi_run(settings, None, argenv, cmd)\n\n            # assert the env variable in the execute's env\n            self.assertIn('env', execute.call_args.kwargs)\n            self.assertEqual(execute.call_args.kwargs['env'].get(env_var), expected)\n\n    def test_mpi_run_with_non_zero_exit(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [], [], None\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=1):\n                with pytest.raises(RuntimeError, match=\"^mpirun failed with exit code 1$\"):\n                    mpi_run(settings, None, {}, cmd)\n\n    \"\"\"\n    Tests mpi_run with os.environ.\n    \"\"\"\n    def test_mpi_run_with_os_environ(self):\n        if not mpi_available():\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd']\n        settings = self.minimal_settings\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], [\"--mock-mpi-binding-args\"]\n\n        with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.mpi_run.safe_shell_exec.execute\", return_value=0):\n                with pytest.raises(Exception, match=\"^env argument must be a dict, not <class 'os._Environ'>: \"):\n                    mpi_run(settings, None, os.environ, cmd)\n\n    \"\"\"\n    Tests gloo_run with minimal settings.\n    \"\"\"\n    def test_gloo_run_minimal(self):\n        if not gloo_built:\n            self.skipTest(\"Gloo is not available\")\n\n        cmd = ['whoami']\n        settings = self.minimal_settings\n        gloo_run(settings, ['lo'], {}, '127.0.0.1', cmd)\n\n    \"\"\"\n    Tests gloo_run with os.environ.\n    \"\"\"\n    def test_gloo_run_with_os_environ(self):\n        if not gloo_built:\n            self.skipTest(\"Gloo is not available\")\n\n        cmd = ['whoami']\n        settings = self.minimal_settings\n        gloo_run(settings, ['lo'], os.environ, '127.0.0.1', cmd)\n\n    def test_horovodrun_hostfile(self):\n        with temppath() as host_filename:\n            with open(host_filename, 'w+') as fp:\n                fp.write('172.31.32.7 slots=8\\n')\n                fp.write('172.31.33.9 slots=8\\n')\n\n            hostnames = hosts.parse_host_files(host_filename)\n            self.assertEqual(hostnames, '172.31.32.7:8,172.31.33.9:8')\n\n    \"\"\"\n    Tests js_run.\n    \"\"\"\n    @mock.patch('horovod.runner.js_run.is_jsrun_installed', MagicMock(return_value=True))\n    @mock.patch('horovod.runner.js_run.generate_jsrun_rankfile', MagicMock(return_value='/tmp/rankfile'))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_gpus', MagicMock(return_value=2))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_cores', MagicMock(return_value=2))\n    def test_js_run(self):\n        if _get_mpi_implementation_flags(False)[0] is None:\n            self.skipTest(\"MPI is not available\")\n\n        cmd = ['cmd', 'arg1', 'arg2']\n        env = {'env1': 'val1', 'env2': 'val2'}\n        stdout = '<stdout>'\n        stderr = '<stderr>'\n        settings = hvd_settings.Settings(\n            verbose=0,\n            extra_mpi_args='>mpi-extra args go here<',\n            num_proc=4,\n            hosts='localhost:2,127.0.0.1:2',\n            output_filename='>output filename goes here<',\n            run_func_mode=True\n        )\n\n        def mpi_impl_flags(tcp, env=None):\n            return [\"--mock-mpi-impl-flags\"], []\n\n        with mock.patch(\"horovod.runner.js_run._get_mpi_implementation_flags\", side_effect=mpi_impl_flags):\n            with mock.patch(\"horovod.runner.js_run.safe_shell_exec.execute\", return_value=0) as execute:\n                js_run(settings, None, env, cmd, stdout=stdout, stderr=stderr)\n\n                # call the mocked _get_mpi_implementation_flags method\n                mpi_flags, _ = horovod.runner.js_run._get_mpi_implementation_flags(False)\n                self.assertIsNotNone(mpi_flags)\n                expected_command = ('jsrun '\n                                    '--erf_input /tmp/rankfile '\n                                    '--stdio_stderr >output filename goes here< '\n                                    '--stdio_stdout >output filename goes here< '\n                                    '--smpiargs \\'{mpi_args} >mpi-extra args go here<\\' '\n                                    'cmd arg1 arg2').format(mpi_args=' '.join(mpi_flags))\n                expected_env = {'env1': 'val1', 'env2': 'val2'}\n                execute.assert_called_once_with(expected_command, env=expected_env, stdout=stdout, stderr=stderr)\n\n    \"\"\"\n    Tests generate_jsrun_rankfile.\n    \"\"\"\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_gpus', MagicMock(return_value=4))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_cores', MagicMock(return_value=4))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_threads', MagicMock(return_value=4))\n    def test_generate_jsrun_rankfile(self):\n        settings = hvd_settings.Settings(\n            num_proc=5,\n            hosts='host1:4,host2:4,host3:4',\n        )\n\n        with temppath() as rankfile_path:\n            rankfile_path = generate_jsrun_rankfile(settings, rankfile_path)\n\n            with open(rankfile_path, 'r') as file:\n                gen_rankfile = file.read()\n\n            expected_rankfile = (\n\"\"\"overlapping_rs: allow\ncpu_index_using: logical\n\nrank: 0: { hostname: host1; cpu: {0-3} ; gpu: * ; mem: * }\nrank: 1: { hostname: host1; cpu: {4-7} ; gpu: * ; mem: * }\nrank: 2: { hostname: host1; cpu: {8-11} ; gpu: * ; mem: * }\nrank: 3: { hostname: host1; cpu: {12-15} ; gpu: * ; mem: * }\n\nrank: 4: { hostname: host2; cpu: {0-3} ; gpu: * ; mem: * }\n\"\"\")\n\n            self.assertMultiLineEqual(gen_rankfile, expected_rankfile)\n\n    \"\"\"\n    Tests horovod.runner.launch._run with jsrun\n    \"\"\"\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.using_lsf', MagicMock(return_value=True))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_compute_hosts', MagicMock(return_value=['host1', 'host2']))\n    @mock.patch('horovod.runner.util.lsf.LSFUtils.get_num_gpus', MagicMock(return_value=2))\n    @mock.patch('horovod.runner.util.network.filter_local_addresses', MagicMock(return_value=['host1', 'host2']))\n    @mock.patch('horovod.runner.launch._check_all_hosts_ssh_successful', MagicMock())\n    @mock.patch('horovod.runner.launch.run_controller')\n    def test_run_with_jsrun(self, mocked_run_controller):\n        hargs = _HorovodArgs()\n        _run(hargs)\n        mocked_run_controller.assert_called_once()\n\n    def test_get_host_assignments(self):\n        hosts = parse_hosts('worker-0:2,worker-1:2')\n        np = 4\n        assignments = get_host_assignments(hosts, np)\n\n        sizes = dict(size=4, local_size=2, cross_size=2)\n        expected = [SlotInfo(hostname='worker-0', rank=0, local_rank=0, cross_rank=0, **sizes),\n                    SlotInfo(hostname='worker-0', rank=1, local_rank=1, cross_rank=0, **sizes),\n                    SlotInfo(hostname='worker-1', rank=2, local_rank=0, cross_rank=1, **sizes),\n                    SlotInfo(hostname='worker-1', rank=3, local_rank=1, cross_rank=1, **sizes)]\n        self.assertListEqual(assignments, expected)\n\n    def test_get_host_assignments_elastic(self):\n        hosts = parse_hosts('worker-0:2,worker-1:2')\n        min_np = 1\n        max_np = 2\n        assignments = get_host_assignments(hosts, min_np=min_np, max_np=max_np)\n\n        sizes = dict(size=2, local_size=2, cross_size=1)\n        expected = [SlotInfo(hostname='worker-0', rank=0, local_rank=0, cross_rank=0, **sizes),\n                    SlotInfo(hostname='worker-0', rank=1, local_rank=1, cross_rank=0, **sizes)]\n        self.assertListEqual(assignments, expected)\n\n    def test_get_host_assignments_heterogeneous(self):\n        hosts = parse_hosts('worker-0:1,worker-1:2')\n        np = 3\n        assignments = get_host_assignments(hosts, np)\n\n        expected = [SlotInfo(hostname='worker-0', rank=0, local_rank=0, cross_rank=0,\n                             size=3, local_size=1, cross_size=2),\n                    SlotInfo(hostname='worker-1', rank=1, local_rank=0, cross_rank=1,\n                             size=3, local_size=2, cross_size=2),\n                    SlotInfo(hostname='worker-1', rank=2, local_rank=1, cross_rank=0,\n                             size=3, local_size=2, cross_size=1)]\n        self.assertListEqual(assignments, expected)\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n# Modifications copyright (C) 2018 Uber Technologies, Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# =============================================================================\n\nimport contextlib\nimport multiprocessing\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport time\nimport traceback\n\nimport cloudpickle\nimport mock\n\nfrom horovod.runner.util.threads import in_thread\n\n\ndef mpi_env_rank_and_size():\n    \"\"\"Get MPI rank and size from environment variables and return them as a\n    tuple of integers.\n\n    Most MPI implementations have an `mpirun` or `mpiexec` command that will\n    run an MPI executable and set up all communication necessary between the\n    different processors. As part of that set up, they will set environment\n    variables that contain the rank and size of the MPI_COMM_WORLD\n    communicator. We can read those environment variables from Python in order\n    to ensure that `hvd.rank()` and `hvd.size()` return the expected values.\n\n    Since MPI is just a standard, not an implementation, implementations\n    typically choose their own environment variable names. This function tries\n    to support several different implementation, but really it only needs to\n    support whatever implementation we want to use for the TensorFlow test\n    suite.\n\n    If this is not running under MPI, then defaults of rank zero and size one\n    are returned. (This is appropriate because when you call MPI_Init in an\n    application not started with mpirun, it will create a new independent\n    communicator with only one process in it.)\n    \"\"\"\n    rank_env = 'PMI_RANK OMPI_COMM_WORLD_RANK'.split()\n    size_env = 'PMI_SIZE OMPI_COMM_WORLD_SIZE'.split()\n\n    for rank_var, size_var in zip(rank_env, size_env):\n        rank = os.environ.get(rank_var)\n        size = os.environ.get(size_var)\n        if rank is not None and size is not None:\n            return int(rank), int(size)\n\n    # Default to rank zero and size one if there are no environment variables\n    return 0, 1\n\n\ndef delay(func, seconds):\n    \"\"\"Delays the execution of func in a separate thread by given seconds.\"\"\"\n    def fn():\n        time.sleep(seconds)\n        func()\n\n    return in_thread(target=fn)\n\n\ndef wait(func, timeout=None):\n    \"\"\"Wait for func to return True until timeout.\"\"\"\n    start = int(time.time())\n    while not func():\n        time.sleep(0.1)\n        if timeout is not None and int(time.time()) - start > timeout:\n            raise TimeoutError('Timed out waiting for func to return True')\n\n\n@contextlib.contextmanager\ndef capture(stdout=None, stderr=None):\n    out = sys.stdout\n    err = sys.stderr\n    if stdout is not None:\n        sys.stdout = stdout\n    if stderr is not None:\n        sys.stderr = stderr\n    try:\n        yield\n    finally:\n        if stdout is not None:\n            sys.stdout.seek(0)\n            sys.stdout = out\n        if stderr is not None:\n            sys.stderr.seek(0)\n            sys.stderr = err\n\n\n@contextlib.contextmanager\ndef tempdir():\n    dirpath = tempfile.mkdtemp()\n    try:\n        yield dirpath\n    finally:\n        shutil.rmtree(dirpath)\n\n\n@contextlib.contextmanager\ndef temppath():\n    dir_path = tempfile.TemporaryDirectory()\n    path = os.path.join(dir_path.name,'temp_test_file')\n    try:\n        yield path\n    finally:\n        dir_path.cleanup()\n\n\n@contextlib.contextmanager\ndef override_args(tool=None, *args):\n    old = sys.argv[:]\n    try:\n        if tool:\n            sys.argv[0] = tool\n        sys.argv[1:] = args\n        yield\n    finally:\n        sys.argv = old\n\n\n@contextlib.contextmanager\ndef override_env(env):\n    old = os.environ\n    try:\n        os.environ = env\n        yield\n    finally:\n        os.environ = old\n\n\n@contextlib.contextmanager\ndef undo(fn):\n    try:\n        yield\n    finally:\n        fn()\n\n\n@contextlib.contextmanager\ndef is_built(gloo_is_built, mpi_is_built):\n    \"\"\"\n    Patches the gloo_built and mpi_built methods called from horovod.runner.run.run_controller\n    to return the given booleans. That method is used by horovod.spark.run to determine which\n    controller to use. Patching these methods allows to test horovod.spark.run without an MPI\n    implementation to be installed.\n\n    :param gloo_is_built: boolean returned by gloo_built\n    :param mpi_is_built: boolean returned by mpi_built\n    :return: mocked gloo_built and mpi_built methods\n    \"\"\"\n    with mock.patch(\"horovod.runner.launch.gloo_built\", return_value=gloo_is_built) as g:\n        with mock.patch(\"horovod.runner.launch.mpi_built\", return_value=mpi_is_built) as m:\n            yield g, m\n\n\n@contextlib.contextmanager\ndef mpi_implementation_flags(flags=[\"--mock-mpi-impl-flags\"],\n                             binding_args=[\"--mock-mpi-binding-args\"],\n                             mpi=None):\n    \"\"\"\n    Patches the _get_mpi_implementation_flags method used by horovod.runner.mpi_run to retrieve\n    MPI implementation specific command line flags. Patching this method allows to test mpi_run\n    without an MPI implementation to be installed.\n\n    :param flags: mock flags\n    :return: the mocked method\n    \"\"\"\n    with mock.patch(\"horovod.runner.mpi_run._get_mpi_implementation_flags\", return_value=(flags, binding_args, mpi)) as m:\n        yield m\n\n\n@contextlib.contextmanager\ndef lsf_and_jsrun(lsf_exists, jsrun_installed):\n    \"\"\"\n    Patches the lsf.LSFUtils.using_lsf and is_jsrun_installed methods called from\n    horovod.runner.run.run_controller to return the given booleans.\n    :param lsf_exists: boolean returned by lsf.LSFUtils.using_lsf\n    :param jsrun_installed: boolean returned by is_jsrun_installed\n    :return: mocked methods\n    \"\"\"\n    with mock.patch(\"horovod.runner.launch.lsf.LSFUtils.using_lsf\", return_value=lsf_exists) as u:\n        with mock.patch(\"horovod.runner.launch.is_jsrun_installed\", return_value=jsrun_installed) as i:\n            yield u, i\n\n\ndef _subproc_wrapper(fn, queue, *args, **kwargs):\n    fn = cloudpickle.loads(fn)\n    try:\n        results = fn(*args, **kwargs)\n    except Exception as e:\n        traceback.print_exc(file=sys.stderr)\n        results = e\n    queue.put(results)\n\n\ndef spawn(fn):\n    def wrapped_fn(*args, **kwargs):\n        ctx = multiprocessing.get_context('spawn')\n        queue = ctx.Queue()\n\n        p = ctx.Process(\n            target=_subproc_wrapper,\n            args=(cloudpickle.dumps(fn), queue, *args),\n            kwargs=kwargs)\n\n        p.start()\n        p.join()\n        results = queue.get()\n        if isinstance(results, Exception):\n            raise RuntimeError(f'Spawned subprocess raised {type(results).__name__}, '\n                               f'check log output above for stack trace.')\n        return results\n\n    return wrapped_fn\n\n\ndef skip_or_fail_gpu_test(test, message):\n    \"\"\"Fails the test if GPUs are required, otherwise skips.\"\"\"\n    if int(os.environ.get('HOROVOD_TEST_GPU', 0)):\n        test.fail(message)\n    else:\n        test.skipTest(message)\n"], "filenames": ["horovod/runner/js_run.py", "test/single/test_run.py", "test/utils/common.py"], "buggy_code_start_loc": [129, 643, 115], "buggy_code_end_loc": [130, 644, 124], "fixing_code_start_loc": [129, 643, 115], "fixing_code_end_loc": [135, 644, 121], "type": "CWE-668", "message": "Insecure Temporary File in GitHub repository horovod/horovod prior to 0.24.0.", "other": {"cve": {"id": "CVE-2022-0315", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-24T09:15:07.950", "lastModified": "2022-03-31T19:03:08.877", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Insecure Temporary File in GitHub repository horovod/horovod prior to 0.24.0."}, {"lang": "es", "value": "Un Archivo Temporal no Seguro en el repositorio de GitHub horovod/horovod versiones anteriores a 0.24.0"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 8.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-668"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-377"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:horovod:horovod:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.24.0", "matchCriteriaId": "139D44F4-9FCA-43A6-A358-80D77BB8C360"}]}]}], "references": [{"url": "https://github.com/horovod/horovod/commit/b96ecae4dc69fc0a83c7c2d3f1dde600c20a1b41", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/7e50397b-dd63-4bb5-b56d-704094a7da45", "source": "security@huntr.dev", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/horovod/horovod/commit/b96ecae4dc69fc0a83c7c2d3f1dde600c20a1b41"}}