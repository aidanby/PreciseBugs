{"buggy_code": ["# LUYA YII HELPERS\n\nAll notable changes to this project will be documented in this file. This project adheres to [Semantic Versioning](http://semver.org/).\n\n## 1.2.0 (15. June 2021)\n\n+ [#4](https://github.com/luyadev/yii-helpers/pull/4) Added option to define the delimiter in `StringHelper::template` function.\n\n## 1.1.1 (6. April 2021)\n\n+ [#2](https://github.com/luyadev/yii-helpers/issues/2) Fix issue where the highlight text has been highlight to.\n\n## 1.1.0 (17. March 2021)\n\n+ [#1](https://github.com/luyadev/yii-helpers/pull/1) Highlight word function works with text transliteration.\n\n## 1.0.0 (2. February 2021)\n\n+ First stable release", "<?php\n\nnamespace luya\\yii\\helpers;\n\nuse luya\\Exception;\nuse yii\\base\\Model;\nuse yii\\db\\QueryInterface;\n\n/**\n * Exporting into Formats.\n *\n * @author Basil Suter <basil@nadar.io>\n * @since 1.0.0\n */\nclass ExportHelper\n{\n    /**\n     * Export an Array or QueryInterface instance into a CSV formated string.\n     *\n     * @param array|QueryInterface $input The data to export into a csv\n     * @param array $keys Defines which keys should be packed into the generated CSV. The defined keys does not change the sort behavior of the generated csv.\n     * @param string $header Whether the column name should be set as header inside the csv or not.\n     * @param array $options Options\n     * + `sort`: boolean, whether they row should be sorted by its keys, default is true.\n     * @return string The generated CSV as string.\n     */\n    public static function csv($input, array $keys = [], $header = true, array $options = [])\n    {\n        $delimiter = \",\";\n        $input = self::transformInput($input);\n        $array = self::generateContentArray($input, $keys, $header, $options);\n\n        return self::generateOutputString($array, $delimiter);\n    }\n\n    /**\n     * Export an Array or QueryInterface instance into a Excel formatted string.\n     *\n     * @param array|QueryInterface $input\n     * @param array $keys Defines which keys should be packed into the generated xlsx. The defined keys does not change the sort behavior of the generated xls.\n     * @param bool $header\n     * @param array $options Options\n     * + `sort`: boolean, whether they row should be sorted by its keys, default is true.\n     * @return mixed\n     * @throws Exception\n     */\n    public static function xlsx($input, array $keys = [], $header = true, array $options = [])\n    {\n        $input = self::transformInput($input);\n\n        $array = self::generateContentArray($input, $keys, $header, $options);\n\n        $writer = new XLSXWriter();\n        $writer->writeSheet($array);\n\n        return $writer->writeToString();\n    }\n\n    /**\n     * Check type of input and return correct array.\n     *\n     * @param array|QueryInterface $input\n     * @return array\n     */\n    protected static function transformInput($input)\n    {\n        if ($input instanceof QueryInterface) {\n            return $input->all();\n        }\n\n        return $input;\n    }\n\n    /**\n     * Generate content by rows.\n     *\n     * @param array $contentRows\n     * @param string $delimiter\n     * @param array $keys\n     * @param bool $generateHeader\n     * @param array $options Options\n     * + `sort`: boolean, whether they row should be sorted by its keys, default is true.\n     * @return array\n     * @throws Exception\n     */\n    protected static function generateContentArray($contentRows, array $keys, $generateHeader = true, $options  = [])\n    {\n        if (is_scalar($contentRows)) {\n            throw new Exception(\"Content must be either an array, object or traversable.\");\n        }\n\n        $attributeKeys = $keys;\n        $header = [];\n        $rows = [];\n        $i = 0;\n        foreach ($contentRows as $content) {\n            // handle rows content\n            if (!empty($keys) && is_array($content)) {\n                foreach ($content as $k => $v) {\n                    if (!in_array($k, $keys)) {\n                        unset($content[$k]);\n                    }\n                }\n            } elseif (!empty($keys) && is_object($content)) {\n                $attributeKeys[get_class($content)] = $keys;\n            }\n            $row = ArrayHelper::toArray($content, $attributeKeys, false);\n\n            if (ArrayHelper::getValue($options, 'sort', true)) {\n                ksort($row);\n            }\n            \n            $rows[$i] = $row;\n\n            // handle header\n            if ($i == 0 && $generateHeader) {\n                if ($content instanceof Model) {\n                    /** @var Model $content */\n                    foreach ($content as $k => $v) {\n                        if (empty($keys)) {\n                            $header[$k] = $content->getAttributeLabel($k);\n                        } elseif (in_array($k, $keys)) {\n                            $header[$k] = $content->getAttributeLabel($k);\n                        }\n                    }\n                } else {\n                    $header = array_keys($rows[0]);\n                }\n\n                if (ArrayHelper::getValue($options, 'sort', true)) {\n                    ksort($header);\n                }\n            }\n\n            unset($row);\n            gc_collect_cycles();\n            $i++;\n        }\n\n        if ($generateHeader) {\n            return ArrayHelper::merge([$header], $rows);\n        }\n\n        return $rows;\n    }\n\n    /**\n     * Generate the output string with delimiters.\n     *\n     * @param array $input\n     * @param string $delimiter\n     * @return null|string\n     */\n    protected static function generateOutputString(array $input, $delimiter)\n    {\n        $output = null;\n        foreach ($input as $row) {\n            $output.= self::generateRow($row, $delimiter, '\"');\n        }\n\n        return $output;\n    }\n\n    /**\n     * Generate a row by its items.\n     *\n     * @param array $row\n     * @param string $delimiter\n     * @param string $enclose\n     * @return string\n     */\n    protected static function generateRow(array $row, $delimiter, $enclose)\n    {\n        array_walk($row, function (&$item) use ($enclose) {\n            if (is_bool($item)) {\n                $item = (int) $item;\n            } elseif (is_null($item)) {\n                $item = '';\n            } elseif (!is_scalar($item)) {\n                $item = \"[array]\";\n            }\n            $item = $enclose.str_replace([\n                '\"',\n            ], [\n                '\"\"',\n            ], $item).$enclose;\n        });\n\n        return implode($delimiter, $row) . PHP_EOL;\n    }\n}\n", "<?php\n\nnamespace luya\\yii\\tests\\helpers;\n\nuse Yii;\nuse luya\\yii\\helpers\\ExportHelper;\nuse luya\\yii\\tests\\HelpersTestCase;\nuse yii\\db\\ActiveRecord;\n\nclass CsvModelStub extends ActiveRecord\n{\n    public static function getDb()\n    {\n        return Yii::$app->sqllite;\n    }\n\n    public static function tableName()\n    {\n        return 'csvmodelstub';\n    }\n    \n    public function rules()\n    {\n        return [\n            [['id', 'name'], 'safe'],\n        ];\n    }\n}\n\nclass ExportHelperTest extends HelpersTestCase\n{\n    private function getArray()\n    {\n        return [\n            ['id' => 1, 'name' => 'John'],\n            ['id' => 2, 'name' => 'Jane'],\n        ];\n    }\n\n    private function initActiveRecord()\n    {\n        Yii::$app->sqllite->createCommand()->createTable('csvmodelstub', [\n            'id' => 'INT(11) PRIMARY KEY',\n            'name' => 'varchar(120)'])->execute();\n    }\n    \n    public function testCsvArrayExport()\n    {\n        $this->assertEquals('\"id\",\"name\"'.PHP_EOL.'\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv($this->getArray()));\n    }\n    \n    public function testCsvArrayRowTypes()\n    {\n        $this->assertEquals('\"1\",\"0\",\"0\",\"\",\"[array]\",\"string\",\"1\",\"1\"'. PHP_EOL, ExportHelper::csv([\n            [\n                true, false, 0, null, ['bar'], 'string', 1, '1'\n            ]\n        ], [], false));\n    }\n    \n    public function testCsvArrayExportWithProperties()\n    {\n        $this->assertEquals('\"id\"'.PHP_EOL.'\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv($this->getArray(), ['id']));\n    }\n    \n    public function testCsvArrayExportWithPropertiesAndDifferentArrangedSortedColumns()\n    {\n        $this->assertEquals('\"id\",\"name\"'.PHP_EOL.'\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv($this->getArray(), ['name', 'id']));\n    }\n    \n    public function testCsvArrayExportNoHeader()\n    {\n        $this->assertEquals('\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv($this->getArray(), [], false));\n    }\n    \n    public function testCsvArrayExportWithPropertiesNoHeader()\n    {\n        $this->assertEquals('\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv($this->getArray(), ['id'], false));\n    }\n\n    public function testActiveRecordCsv()\n    {\n        $this->initActiveRecord();\n     \n        foreach ($this->getArray() as $item) {\n            $m = new CsvModelStub();\n            $m->attributes = $item;\n            $m->save();\n        }\n\n        // active query find\n        $this->assertEquals('\"Id\",\"Name\"'.PHP_EOL.'\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find()));\n        $this->assertEquals('\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find(), [], false));\n        $this->assertEquals('\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find(), ['id'], false));\n        $this->assertEquals('\"Id\"'.PHP_EOL.'\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find(), ['id']));\n    }\n    \n    public function testException()\n    {\n        $this->expectException(\"luya\\Exception\");\n        ExportHelper::csv('foobarstring');\n    }\n\n    public function testXlsArrayExportWithHeader()\n    {\n        $filename = tempnam('', 'xlsx_test');\n        $this->saveArrayToXlsx($filename, $this->getArray(), ['id', 'name'], true);\n        $this->assertSame($this->getXmlSheetContent($filename), $this->getXmlSheetContent('tests/data/export/withheader.xlsx'));\n    }\n\n    public function testXlsArrayExportWithoutHeader()\n    {\n        $filename = tempnam('', 'xlsx_test');\n        $this->saveArrayToXlsx($filename, $this->getArray(), ['id', 'name'], false);\n        $this->assertSame($this->getXmlSheetContent($filename), $this->getXmlSheetContent('tests/data/export/withoutheader.xlsx'));\n    }\n\n    protected function getXmlSheetContent($filename)\n    {\n        $zip = new \\ZipArchive();\n        $zip->open($filename);\n        for ($z = 0; $z < $zip->numFiles; $z++) {\n            $inside_zip_filename = $zip->getNameIndex($z);\n            if (basename($inside_zip_filename) == 'sheet1.xml') {\n                return $zip->getFromName($inside_zip_filename);\n            }\n        }\n    }\n\n    protected function saveArrayToXlsx($filename, array $input, array $keys = [], $header = true)\n    {\n        $string = ExportHelper::xlsx($input, $keys, $header);\n        file_put_contents($filename, $string);\n    }\n\n    public function testSpecialCharsEncoding()\n    {\n        $content = ExportHelper::csv([\n            ['&', \"'\", 'a\"b\"c'],\n        ], [], false);\n\n        $this->assertSameTrimmed('\"&\",\"\\'\",\"a\"\"b\"\"c\"', $content);\n    }\n}\n"], "fixing_code": ["# LUYA YII HELPERS\n\nAll notable changes to this project will be documented in this file. This project adheres to [Semantic Versioning](http://semver.org/).\n\n## 1.2.1 (21. April 2022)\n\n+ [#7](https://github.com/luyadev/yii-helpers/pull/7) Fixed security issue with csv injection for formulas and functions.\n\n## 1.2.0 (15. June 2021)\n\n+ [#4](https://github.com/luyadev/yii-helpers/pull/4) Added option to define the delimiter in `StringHelper::template` function.\n\n## 1.1.1 (6. April 2021)\n\n+ [#2](https://github.com/luyadev/yii-helpers/issues/2) Fix issue where the highlight text has been highlight to.\n\n## 1.1.0 (17. March 2021)\n\n+ [#1](https://github.com/luyadev/yii-helpers/pull/1) Highlight word function works with text transliteration.\n\n## 1.0.0 (2. February 2021)\n\n+ First stable release", "<?php\n\nnamespace luya\\yii\\helpers;\n\nuse luya\\Exception;\nuse yii\\base\\Model;\nuse yii\\db\\QueryInterface;\n\n/**\n * Exporting into Formats.\n *\n * @author Basil Suter <basil@nadar.io>\n * @since 1.0.0\n */\nclass ExportHelper\n{\n    /**\n     * Export an Array or QueryInterface instance into a CSV formated string.\n     *\n     * @param array|QueryInterface $input The data to export into a csv\n     * @param array $keys Defines which keys should be packed into the generated CSV. The defined keys does not change the sort behavior of the generated csv.\n     * @param string $header Whether the column name should be set as header inside the csv or not.\n     * @param array $options Options\n     * + `sort`: boolean, whether they row should be sorted by its keys, default is true.\n     * @return string The generated CSV as string.\n     */\n    public static function csv($input, array $keys = [], $header = true, array $options = [])\n    {\n        $delimiter = \",\";\n        $input = self::transformInput($input);\n        $array = self::generateContentArray($input, $keys, $header, $options);\n\n        return self::generateOutputString($array, $delimiter);\n    }\n\n    /**\n     * Export an Array or QueryInterface instance into a Excel formatted string.\n     *\n     * @param array|QueryInterface $input\n     * @param array $keys Defines which keys should be packed into the generated xlsx. The defined keys does not change the sort behavior of the generated xls.\n     * @param bool $header\n     * @param array $options Options\n     * + `sort`: boolean, whether they row should be sorted by its keys, default is true.\n     * @return mixed\n     * @throws Exception\n     */\n    public static function xlsx($input, array $keys = [], $header = true, array $options = [])\n    {\n        $input = self::transformInput($input);\n\n        $array = self::generateContentArray($input, $keys, $header, $options);\n\n        $writer = new XLSXWriter();\n        $writer->writeSheet($array);\n\n        return $writer->writeToString();\n    }\n\n    /**\n     * Check type of input and return correct array.\n     *\n     * @param array|QueryInterface $input\n     * @return array\n     */\n    protected static function transformInput($input)\n    {\n        if ($input instanceof QueryInterface) {\n            return $input->all();\n        }\n\n        return $input;\n    }\n\n    /**\n     * Generate content by rows.\n     *\n     * @param array $contentRows\n     * @param string $delimiter\n     * @param array $keys\n     * @param bool $generateHeader\n     * @param array $options Options\n     * + `sort`: boolean, whether they row should be sorted by its keys, default is true.\n     * @return array\n     * @throws Exception\n     */\n    protected static function generateContentArray($contentRows, array $keys, $generateHeader = true, $options  = [])\n    {\n        if (is_scalar($contentRows)) {\n            throw new Exception(\"Content must be either an array, object or traversable.\");\n        }\n\n        $attributeKeys = $keys;\n        $header = [];\n        $rows = [];\n        $i = 0;\n        foreach ($contentRows as $content) {\n            // handle rows content\n            if (!empty($keys) && is_array($content)) {\n                foreach ($content as $k => $v) {\n                    if (!in_array($k, $keys)) {\n                        unset($content[$k]);\n                    }\n                }\n            } elseif (!empty($keys) && is_object($content)) {\n                $attributeKeys[get_class($content)] = $keys;\n            }\n            $row = ArrayHelper::toArray($content, $attributeKeys, false);\n\n            if (ArrayHelper::getValue($options, 'sort', true)) {\n                ksort($row);\n            }\n            \n            $rows[$i] = $row;\n\n            // handle header\n            if ($i == 0 && $generateHeader) {\n                if ($content instanceof Model) {\n                    /** @var Model $content */\n                    foreach ($content as $k => $v) {\n                        if (empty($keys)) {\n                            $header[$k] = $content->getAttributeLabel($k);\n                        } elseif (in_array($k, $keys)) {\n                            $header[$k] = $content->getAttributeLabel($k);\n                        }\n                    }\n                } else {\n                    $header = array_keys($rows[0]);\n                }\n\n                if (ArrayHelper::getValue($options, 'sort', true)) {\n                    ksort($header);\n                }\n            }\n\n            unset($row);\n            gc_collect_cycles();\n            $i++;\n        }\n\n        if ($generateHeader) {\n            return ArrayHelper::merge([$header], $rows);\n        }\n\n        return $rows;\n    }\n\n    /**\n     * Generate the output string with delimiters.\n     *\n     * @param array $input\n     * @param string $delimiter\n     * @return null|string\n     */\n    protected static function generateOutputString(array $input, $delimiter)\n    {\n        $output = null;\n        foreach ($input as $row) {\n            $output.= self::generateRow($row, $delimiter, '\"');\n        }\n\n        return $output;\n    }\n\n    /**\n     * Generate a row by its items.\n     *\n     * @param array $row\n     * @param string $delimiter\n     * @param string $enclose\n     * @return string\n     */\n    protected static function generateRow(array $row, $delimiter, $enclose)\n    {\n        array_walk($row, function (&$item) use ($enclose) {\n            if (is_bool($item)) {\n                $item = (int) $item;\n            } elseif (is_null($item)) {\n                $item = '';\n            } elseif (!is_scalar($item)) {\n                $item = \"[array]\";\n            }\n            $item = $enclose.self::sanitizeValue($item).$enclose;\n        });\n\n        return implode($delimiter, $row) . PHP_EOL;\n    }\n\n    /**\n     * Sanitize Certain Values to increase security from user generated output.\n     * \n     * @param string $value\n     * @return string\n     * @see https://owasp.org/www-community/attacks/CSV_Injection\n     * @since 1.2.1\n     */\n    public static function sanitizeValue($value)\n    {\n        $value = str_replace([\n            '\"',\n        ], [\n            '\"\"',\n        ], trim($value));\n\n        $firstChar = substr($value, 0, 1);\n        if (in_array($firstChar, ['=', '+', '-', '@', PHP_EOL, \"\\t\", \"\\n\"])) {\n            $value = StringHelper::replaceFirst($firstChar, \"'$firstChar\", $value);\n        }\n\n        return $value;\n    }\n}\n", "<?php\n\nnamespace luya\\yii\\tests\\helpers;\n\nuse Yii;\nuse luya\\yii\\helpers\\ExportHelper;\nuse luya\\yii\\tests\\HelpersTestCase;\nuse yii\\db\\ActiveRecord;\n\nclass CsvModelStub extends ActiveRecord\n{\n    public static function getDb()\n    {\n        return Yii::$app->sqllite;\n    }\n\n    public static function tableName()\n    {\n        return 'csvmodelstub';\n    }\n    \n    public function rules()\n    {\n        return [\n            [['id', 'name'], 'safe'],\n        ];\n    }\n}\n\nclass ExportHelperTest extends HelpersTestCase\n{\n    private function getArray()\n    {\n        return [\n            ['id' => 1, 'name' => 'John'],\n            ['id' => 2, 'name' => 'Jane'],\n        ];\n    }\n\n    private function initActiveRecord()\n    {\n        Yii::$app->sqllite->createCommand()->createTable('csvmodelstub', [\n            'id' => 'INT(11) PRIMARY KEY',\n            'name' => 'varchar(120)'])->execute();\n    }\n    \n    public function testCsvArrayExport()\n    {\n        $this->assertEquals('\"id\",\"name\"'.PHP_EOL.'\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv($this->getArray()));\n    }\n    \n    public function testCsvArrayRowTypes()\n    {\n        $this->assertEquals('\"1\",\"0\",\"0\",\"\",\"[array]\",\"string\",\"1\",\"1\"'. PHP_EOL, ExportHelper::csv([\n            [\n                true, false, 0, null, ['bar'], 'string', 1, '1'\n            ]\n        ], [], false));\n    }\n    \n    public function testCsvArrayExportWithProperties()\n    {\n        $this->assertEquals('\"id\"'.PHP_EOL.'\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv($this->getArray(), ['id']));\n    }\n    \n    public function testCsvArrayExportWithPropertiesAndDifferentArrangedSortedColumns()\n    {\n        $this->assertEquals('\"id\",\"name\"'.PHP_EOL.'\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv($this->getArray(), ['name', 'id']));\n    }\n    \n    public function testCsvArrayExportNoHeader()\n    {\n        $this->assertEquals('\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv($this->getArray(), [], false));\n    }\n    \n    public function testCsvArrayExportWithPropertiesNoHeader()\n    {\n        $this->assertEquals('\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv($this->getArray(), ['id'], false));\n    }\n\n    public function testActiveRecordCsv()\n    {\n        $this->initActiveRecord();\n     \n        foreach ($this->getArray() as $item) {\n            $m = new CsvModelStub();\n            $m->attributes = $item;\n            $m->save();\n        }\n\n        // active query find\n        $this->assertEquals('\"Id\",\"Name\"'.PHP_EOL.'\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find()));\n        $this->assertEquals('\"1\",\"John\"'.PHP_EOL.'\"2\",\"Jane\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find(), [], false));\n        $this->assertEquals('\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find(), ['id'], false));\n        $this->assertEquals('\"Id\"'.PHP_EOL.'\"1\"'.PHP_EOL.'\"2\"'. PHP_EOL, ExportHelper::csv(CsvModelStub::find(), ['id']));\n    }\n    \n    public function testException()\n    {\n        $this->expectException(\"luya\\Exception\");\n        ExportHelper::csv('foobarstring');\n    }\n\n    public function testXlsArrayExportWithHeader()\n    {\n        $filename = tempnam('', 'xlsx_test');\n        $this->saveArrayToXlsx($filename, $this->getArray(), ['id', 'name'], true);\n        $this->assertSame($this->getXmlSheetContent($filename), $this->getXmlSheetContent('tests/data/export/withheader.xlsx'));\n    }\n\n    public function testXlsArrayExportWithoutHeader()\n    {\n        $filename = tempnam('', 'xlsx_test');\n        $this->saveArrayToXlsx($filename, $this->getArray(), ['id', 'name'], false);\n        $this->assertSame($this->getXmlSheetContent($filename), $this->getXmlSheetContent('tests/data/export/withoutheader.xlsx'));\n    }\n\n    protected function getXmlSheetContent($filename)\n    {\n        $zip = new \\ZipArchive();\n        $zip->open($filename);\n        for ($z = 0; $z < $zip->numFiles; $z++) {\n            $inside_zip_filename = $zip->getNameIndex($z);\n            if (basename($inside_zip_filename) == 'sheet1.xml') {\n                return $zip->getFromName($inside_zip_filename);\n            }\n        }\n    }\n\n    protected function saveArrayToXlsx($filename, array $input, array $keys = [], $header = true)\n    {\n        $string = ExportHelper::xlsx($input, $keys, $header);\n        file_put_contents($filename, $string);\n    }\n\n    public function testSpecialCharsEncoding()\n    {\n        $content = ExportHelper::csv([\n            ['&', \"'\", 'a\"b\"c'],\n            ['nix', 'nix', '=1+2\";=1+2']\n        ], [], false);\n\n        $this->assertSameTrimmed('\"&\",\"\\'\",\"a\"\"b\"\"c\" \"nix\",\"nix\",\"\\'=1+2\"\";=1+2\"', $content);\n    }\n}\n"], "filenames": ["CHANGELOG.md", "src/helpers/ExportHelper.php", "tests/helpers/ExportHelperTest.php"], "buggy_code_start_loc": [3, 182, 139], "buggy_code_end_loc": [3, 190, 143], "fixing_code_start_loc": [4, 182, 140], "fixing_code_end_loc": [8, 211, 144], "type": "CWE-1236", "message": "Formula Injection/CSV Injection due to Improper Neutralization of Formula Elements in CSV File in GitHub repository luyadev/yii-helpers prior to 1.2.1. Successful exploitation can lead to impacts such as client-sided command injection, code execution, or remote ex-filtration of contained confidential data.", "other": {"cve": {"id": "CVE-2022-1544", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-01T12:15:07.787", "lastModified": "2022-05-12T02:31:40.930", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Formula Injection/CSV Injection due to Improper Neutralization of Formula Elements in CSV File in GitHub repository luyadev/yii-helpers prior to 1.2.1. Successful exploitation can lead to impacts such as client-sided command injection, code execution, or remote ex-filtration of contained confidential data."}, {"lang": "es", "value": "Una Inyecci\u00f3n de f\u00f3rmulas/inyecci\u00f3n de CSV debido a una Neutralizaci\u00f3n Inapropiada de elementos de f\u00f3rmulas en el archivo CSV en el repositorio de GitHub luyadev/yii-helpers versiones anteriores a 1.2.1. Una explotaci\u00f3n con \u00e9xito puede conllevar a impactos como una inyecci\u00f3n de comandos del lado del cliente, una ejecuci\u00f3n de c\u00f3digo o una exfiltraci\u00f3n remota de datos confidenciales contenidos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.1, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1236"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-1236"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:luya:yii-helpers:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.1", "matchCriteriaId": "2A398AA6-A3D5-4D58-8B5C-DCD177FFE04C"}]}]}], "references": [{"url": "https://github.com/luyadev/yii-helpers/commit/9956ed63f516110c2b588471507b870e748c4cfb", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/fa6d6e75-bc7a-40f6-9bdd-2541318912d4", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/luyadev/yii-helpers/commit/9956ed63f516110c2b588471507b870e748c4cfb"}}