{"buggy_code": ["#!/usr/bin/perl\n\n# whohas, a Perl utility to display availability of source\n# and binary packages from major Linux and BSD distributions\n#\n# Copyright (C) Philipp L. Wesche 2005-2011\n#\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nuse strict;\nuse sigtrap;\n\n#TODO --fetch-unstable switch\n#TODO make sure that debian's version numbers are from i386\n#TODO get date info about debian, ubuntu (link is to changelog)\n#TODO get date info about slackware packages from subsequent links  - postponed until slackware packages is online again\n#TODO architecture tests for those that support several\n#TODO Gentoo: only report two most recent for each package?\n#TODO make more use of the conf directory, e.g. for Fedora, Sourcemage, so we download those indexes only sparingly, and save ourselves processing time; MAKE SURE YOU WRITE THE PROCESSED RESULTS FOR EASY PARSING ON THE NEXT RUN\n#TODO we can also cache search results there to drastically reduce query time on subsequent queries\n#TODO add option to override the cache (newly fetched file written to cache)\n#TODO ubuntu: allow two releases: the long term supported and the most recent\n#TODO allow searching on several packages; return results only for those distros that have a hit for each package, possibly in tabular format\n#TODO deal gracefully with hyphens that may be present in some distros but not others, i.e. include extra hyphens in regexes, and allow user-specified hyphens to be absent\n\nuse Config;\nuse Env qw(HOME);\neval {\n\trequire if $^O ne 'MSWin32', 'forks';\n};\nuse if $Config{usethreads}, \"threads\";\nuse Getopt::Long;\nuse LWP::UserAgent;\nuse Thread::Queue;\n\nmy $conffile = \"whohas.cf\";\nmy $confdir = \"$HOME/.whohas\";\n# make .whohas directory in home directory\nunless (-d $confdir) {\n\tmkdir ($confdir, 0755);\n}\n\nmy @columns = (11,38,18,4,10,25);\nmy $cols = 6;\n\nour $fedora_min_release\t\t =  \"\"\t\t\t;\nour $fedora_max_release\t\t =  \"\"\t\t\t;\nour $debian_current_release\t = \"all\"\t\t;\nour $ubuntu_current_release\t = \"all\"\t\t;\nour $openbsd_release\t\t = \"6.0\"\t\t;\n\nmy @distrosAvailable = qw(arch cygwin debian fedora fink freebsd gentoo macports mandriva netbsd openbsd opensuse slack sourcemage ubuntu);\nmy %distrosSelected;\nforeach (@distrosAvailable) {\n\t$distrosSelected{$_} = 1;\n}\n\nour @distroSelections;\nmy $nothreads;\nmy $shallow;\nmy $option_help;\nmy $option_strict;\n\nif ( -s \"$confdir/$conffile\" ) {\n\teval {\n\t\tdo \"$confdir/$conffile\";\n\t};\n\tif ($@) {\n\t\tprint STDERR 'Eval of configuration caused errors. Aborting.\\n';\n\t\texit;\n\t}\n}\n\nGetOptions(\n\t\"d=s\" => \\@distroSelections,\n\t\"no-threads\" => \\$nothreads,\n\t\"shallow\" => \\$shallow,\n\t\"help|usage|h\" => \\$option_help,\n\t\"strict|s\" => \\$option_strict,\n);\n\nif ($option_help) {\n\tprint \"Usage: $0 [--no-threads] [--shallow] [--strict] [-d Dist1[,Dist2[,Dist3...]]] pkgname\\n\";\n\texit 0;\n}\n\nif (@ARGV > 1) {\n\tdie \"Error:\\tToo many parameters. Usage: $0 [--no-threads] [--shallow] [--strict] [-d Dist1[,Dist2[,Dist3...]]] pkgname\\n\";\n} elsif (@ARGV < 1) {\n\tdie \"Error:\\tPlease specify a search term.\\n\";\n}\n\nif (!$Config{usethreads} && !$nothreads) {\n\t$nothreads = 1;\n\twarn \"No threads support, --no-threads is forced.\\n\";\n}\n\n#\n# BUILD %distrosSelected\n#\n\nif (@distroSelections) {\n\tforeach (@distrosAvailable) {\n\t\t$distrosSelected{$_} = 0;\n\t}\n\t@distroSelections = split(/,/,join(',',@distroSelections));\n\tfor my $distro (@distroSelections) {\n\t\t$distro =~ tr/A-Z/a-z/;\n\t\tif (\t\t$distro =~ /archlinux/i) {\t$distrosSelected{arch}\t= 1;\n\t\t} elsif (\t$distro =~ /slackware/i) {\t$distrosSelected{slack}\t= 1;\n\t\t} else {\n\t\t\tif (exists $distrosSelected{$distro}) {\t# NB only due to previous setting of hash values for all known distros can we use this test to see if the distro is known\n\t\t\t\t$distrosSelected{$distro} = 1;\n\t\t\t} else {\n\t\t\t\tdie \"Unsupported distribution '$distro'\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n\n#\n# DISPATCH TO SUBROUTINES, THREADED OR UNTHREADED\n#\n\nif ($ARGV[0] eq \"whohasme\") {\n\tprint \"Congratulations. You discovered an Easter egg. Maybe you can send a quick email to phi1ipp\\@yahoo.com to say hello and tell the developer what you think of the software.\\n\";\n\texit;\n}\n\nmy $q = Thread::Queue->new();\nforeach (keys %distrosSelected) {\n\tif ($distrosSelected{$_}) {\n\t\tif ($_ eq 'arch') {\n\t\t\tuse JSON;\n\t\t\t$q->enqueue('arch', 'aur');\n\t\t} else {\n\t\t\t$q->enqueue($_);\n\t\t}\n\t}\n}\n$q->end();\n\nif (!$nothreads) {\n\tmy $maxthreads = maxthreads($q);\n\tmy @thrs;\n\tfor (0..$maxthreads - 1) {\n\t\tpush(@thrs, threads->new(\\&worker));\n\t}\n\tforeach (@thrs) {\n\t\t$_->join;\n\t}\n} else {\n\tworker();\n}\n\nsub worker {\n\tno strict \"refs\";\n\twhile (defined(my $distro = $q->dequeue())) {\n\t\t# NB this is only safe because we've previously checked for illegal subs\n\t\t&$distro($ARGV[0]);\n\t}\n}\n\nsub maxthreads {\n\tmy ($q) = @_;\n\tmy $jobcount = $q->pending();\n\teval { require Sys::CPU; };\n\tif ($@) {\n\t\treturn $jobcount;\n\t} else {\n\t\tmy $cpucount = Sys::CPU::cpu_count();\n\t\treturn $cpucount < $jobcount ? $cpucount : $jobcount;\n\t}\n}\n\nsub fedora {\n\tmy $baseurl = \"http://dl.fedoraproject.org/pub/fedora/linux/releases/\";\n\tmy $distroname = \"Fedora\";\n\tmy $arch = \"x86_64\";\n\tmy $searchy = $_[0];\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\n\tif (not $fedora_max_release) {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl);\n\t\tfor (my $li = 0; $li < @lines; $li++) {\n\t\t\tif ($lines[$li] =~ m{<img src=\"[^\"]*folder[^\"]*\" alt=\"[^\"]*\"> *<a href=\"[0-9]+/\"}) {\n\t\t\t\tmy ($release) = ($lines[$li] =~ m{<img src=\"[^\"]*folder[^\"]*\" alt=\"[^\"]*\"> *<a href=\"([0-9]+)/\"});\n\t\t\t\tif ($release > $fedora_max_release) {\n\t\t\t\t\t$fedora_max_release = $release;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (not $fedora_max_release) {\n\t\t\tprint STDERR \"Could not parse Fedora release list, skipping Fedora packages\\n\";\n\t\t\treturn ();\n\t\t}\n\t}\n\tif (not $fedora_min_release) {\n\t\t$fedora_min_release = $fedora_max_release - 2;\n\t}\n\n\tfor (my $i = $fedora_max_release; $i >= $fedora_min_release; $i--) {\n\t\tmy @fed_urls = (\"$i/Everything/$arch/os/Packages/\");\n\t\tmy $file = \"$confdir/$distroname\\_$i.list\";\n\t\t{\n\t\t\tfor (my $a = 0; $a < @fed_urls; $a++) {\n\t\t\t\tmy @lines = split /\\n/, &fetchdoc($baseurl.$fed_urls[$a].lc(substr($searchy, 0, 1)).'/');\n\t\t\t\tfor (my $li = 0; $li < @lines; $li++) {\n\t\t\t\t\tif ($lines[$li] =~ / +<a href=\"[^\"]+?rpm\"/) {\n\t\t\t\t\t\tmy ($name, $version, $date, $size) = ($lines[$li] =~ m{ +<a href=\"(.+?)-([0-9].*)\\.fc[0-9]*\\.[^.]*\\.rpm\">[^<]*</a> *([^ ]* [^ ]*) *([^ ]*) *(?:RPM Package)?});\n\t\t\t\t\t\tpush @names, $name;\n\t\t\t\t\t\tpush @versions, $version;\n\t\t\t\t\t\tpush @dates, $date;\n\t\t\t\t\t\tpush @sizes, $size;\n\t\t\t\t\t\tpush @urls, \"https://apps.fedoraproject.org/packages/$name\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\tif ($names[$i] =~ /$searchy/i) {\n\t\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t\t}\n\t}\n\treturn ();\n}\n\nsub month_to_digits {\n\t$_[0] =~ s/JAN/01/i;\n\t$_[0] =~ s/FEB/02/i;\n\t$_[0] =~ s/MAR/03/i;\n\t$_[0] =~ s/APR/04/i;\n\t$_[0] =~ s/MAY/05/i;\n\t$_[0] =~ s/JUN/06/i;\n\t$_[0] =~ s/JUL/07/i;\n\t$_[0] =~ s/AUG/08/i;\n\t$_[0] =~ s/SEP/09/i;\n\t$_[0] =~ s/OCT/10/i;\n\t$_[0] =~ s/NOV/11/i;\n\t$_[0] =~ s/DEC/12/i;\n\treturn ($_[0]);\n}\n\nsub macports {\n\tmy $baseurl = \"http://www.macports.org\";\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"/ports.php?by=name&substr=\".$_[0]);\n\tfor (my $i = 70; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /<dt><b>/) {\n\t\t\tmy @parties = split /\\<dt\\>\\<b\\>/, $lines[$i];\n\t\t\tfor (my $javar = 1; $javar < @parties; $javar++) {\n\t\t\t\tmy @parts = split /href=\"|\">|<\\/a><\\/b> |<\\/dt/, $parties[$javar];\n\t\t\t\tpush @urls,     $parts[1];\n\t\t\t\tpush @names,    $parts[2];\n\t\t\t\tpush @versions, $parts[3];\n\t\t\t\tpush @repos, \"\";\n\t\t\t\tpush @sizes, \"\";\n\t\t\t\tpush @dates, \"\";\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"MacPorts\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n\nsub fink {\n\tmy $baseurl = \"http://pdb.finkproject.org/pdb/\";\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"browse.php?name=\".$_[0]);\n\tfor (my $i = 60; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /tr class=\\\"package\\\"/) {\n\t\t\tif ($lines[$i] =~ /^\\<tr class\\=\\\"pdbHeading\\\"\\>/) {\n\t\t\t\t$lines[$i] =~ s/.*?\\<\\/tr\\>//;\n\t\t\t}\n\t\t\tmy @splitty = split /href\\=\\\"|\\\"\\>|\\<\\/a\\>\\<\\/td\\>\\<td class=\\\"packageName\\\"\\>|\\<\\/td\\>\\<td\\>/, $lines[$i];\n\t\t\tpush @urls, $splitty[3];\n\t\t\tpush @names, $splitty[4];\n\t\t\tpush @versions, $splitty[5];\n\t\t\tpush @repos, \"\";\n\t\t\tpush @sizes, \"\";\n\t\t\tpush @dates, \"\";\n\t\t} elsif ($lines[$i] =~ /\\<p\\>Query took /) {\n\t\t\tlast;\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Fink\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub fink_get_details {\n\tmy @repos;\n\tmy @versions;\n\tmy @lines = split /\\n/, &fetchdoc($_[0]);\n\tfor (my $i = 60; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /10\\./) {\n\t\t\tmy @parts = split /nowrap\">|<\\/div>/, $lines[$i];\n\t\t\tunless ($parts[5] =~ /not present/ or $parts[5] =~ /unsupported/) {\n\t\t\t\tif ($parts[1] =~ /<br>/) {\n\t\t\t\t\tpush @repos, (split /<br>/, $parts[1])[0];\n\t\t\t\t} else {\n\t\t\t\t\tpush @repos, $parts[1];\n\t\t\t\t}\n\t\t\t\t$parts[5] =~ s/\\<\\!\\-\\-.*\\-\\-\\>//;\n\t\t\t\tpush @versions, $parts[5];\n\t\t\t}\n\t\t}\n\t\tif ($lines[$i] eq '</table>') {\n\t\t\tlast;\n\t\t}\n\t}\n\treturn (\\@versions,\\@repos);\n}\n\nsub size_trim {\n\t# give at least two significant figures; if a 10^3 edge is encountered, put a dot\n\tmy $leave =  length($_[0]) % 3;\n\tmy $threes = (length($_[0]) - $leave) / 3;\n\tif ($leave == 0) {\n\t\t$leave = 3;\n\t\t$threes--;\n\t}\n\t\n\tmy @parts = split //, $_[0];\n\tmy $retval = join \"\", @parts[0..($leave-1)];\n\tif (length($retval)==1 && $threes > 0) {\n\t\t# add one more significant figure\n\t\tmy $add_sf = $parts[$leave];\n\t\tif ($parts[$leave+1] > 4) {\n\t\t\t# rounding\n\t\t\t$add_sf++;\n\t\t\tif ($add_sf == 10) {\n\t\t\t\t$add_sf = 0;\n\t\t\t\t$retval++;\n\t\t\t\tif ($retval == 10) {\n\t\t\t\t\treturn(&size_trim($retval*(1000**$threes)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$retval .= \".$add_sf\";\n\t} elsif (defined($parts[$leave]) && $parts[$leave] > 4) { # instead of defined(...), ($threes > 0) is also possible\n\t\tmy $before = length($retval);\n\t\t# rounding\n\t\t$retval++;\n\t\tif (length($retval) > $before) {\n\t\t\treturn(&size_trim($retval*(1000**$threes)));\n\t\t}\n\t}\n\tmy @suffixes = (\"k\",\"M\",\"G\");\n\tif ($threes > 0) {\n\t\t$retval .= $suffixes[($threes-1)];\n\t}\n\treturn $retval;\n}\n\n\nsub freebsd {\n\tmy $query = \"http://www.freebsd.org/cgi/ports.cgi?query=\".$_[0].\"&stype=all\";\n\tmy @lines = split /\\n/, &fetchdoc($query);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy $now = 0;\n\tfor (my $i = 50; $i<@lines; $i++) {\n\t\tif ($lines[$i] =~ /^<dt><b>/) {\n\t\t\tmy @parts = split /\"/, $lines[$i];\n\t\t\t($names[$now],$versions[$now]) = &combos_freebsd($parts[1]);\n\t\t\tmy @subparts = split /\\//, $parts[3];\n\t\t\tpush @sizes, \"\";\n\t\t\tpush @repos, $subparts[@subparts-2];\n\t\t\tpush @urls,  \"http://www.freebsd.org/cgi/ports.cgi?stype=all&query=$names[$now]\";\n\t\t\t$now++;\n\t\t\tpush @dates, \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"FreeBSD\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n\nsub sourcemage {\n\tmy @grimoires = (\"test\",\"stable\",\"binary\",\"z-rejected\",\"games\");\n\tmy @lines = split /\\n/, &fetchdoc(\"http://codex.sourcemage.org/listing.txt\");\n\tmy @inirepos;\n\tmy @ininames;\n\tmy @iniversions;\n\tmy @iniurls;\n\tmy @inidates;\n\tmy @inisizes;\n\tforeach (@lines) {\n\t\tmy @comps = split /\\^/, $_;\n\t\tfor (my $a = 0; $a < @grimoires;$a++) {\n\t\t\tif (length($comps[$a+1]) > 0) {\n\t\t\t\tpush @inirepos, $grimoires[$a];\n\t\t\t\tpush @ininames, $comps[0];\n\t\t\t\tpush @iniversions, $comps[$a+1];\n\t\t\t\tpush @inisizes, \"\";\n\t\t\t\tpush @iniurls,  \"\";\n\t\t\t\tpush @inidates, \"\";\n\t\t\t}\n\t\t}\n\t}\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\\@ininames,\\@iniversions,\\@inisizes,\\@inidates,\\@inirepos,\\@iniurls,$_[0]);\n\tmy @names    = @$p1;\n\tmy @versions = @$p2;\n\tmy @sizes    = @$p3;\n\tmy @dates    = @$p4;\n\tmy @repos    = @$p5;\n\tmy @urls     = @$p6;\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Source Mage\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n\nsub search_by_name { # versions, sizes, dates, repos, urls\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6,$search) = @_;\n\tmy @ininames    = @$p1;\n\tmy @iniversions = @$p2;\n\tmy @inisizes    = @$p3;\n\tmy @inidates    = @$p4;\n\tmy @inirepos    = @$p5;\n\tmy @iniurls     = @$p6;\n\tmy @names;\n\tmy @versions;\n\tmy @sizes;\n\tmy @dates;\n\tmy @repos;\n\tmy @urls;\n\tfor (my $i = 0;$i<@ininames;$i++) {\n\t\tif ($ininames[$i] =~ /$search/i) {\n\t\t\tpush @names,    $ininames[$i];\n\t\t\tpush @repos,    $inirepos[$i];\n\t\t\tpush @versions, $iniversions[$i];\n\t\t\tpush @sizes,    $inisizes[$i];\n\t\t\tpush @dates,    $inidates[$i];\n\t\t\tpush @urls,     $iniurls[$i];\n\t\t}\n\t}\n\treturn(\\@names,\\@versions,\\@sizes,\\@dates,\\@repos,\\@urls);\n}\n\nsub netbsd_old {\n\tmy $netbsdbase = \"ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/\";\n\tmy @ininames;\n\tmy @iniversions;\n\tmy @iniurls;\n\tmy @inirepos;\n\tmy @inisizes;\n\tmy @inidates;\n\tmy $now = 0;\n\tmy $distroname = \"NetBSD\";\n\tmy $file = \"$confdir/$distroname.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\tmy @lines = split /\\n/, &fetchdoc($netbsdbase.\"README-all.html\");\n\t\tfor (my $i = 10; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /^<!-- [0-9A-Za-z]/) {\n\t\t\t\tmy @parts = split / /, $lines[$i];\n\t\t\t\t($ininames[$now],$iniversions[$now]) = &combos($parts[1]);\n\t\t\t\t$now++;\n\t\t\t\t@parts = split /a href=\"|\">/, $lines[$i];\n\t\t\t\tpush @iniurls, $netbsdbase.$parts[1];\n\t\t\t\tpush @inirepos, \"\";\n\t\t\t\tpush @inisizes, \"\";\n\t\t\t\tpush @inidates, \"\";\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @iniurls;$i++) {\n\t\t\tprint OUT \"$ininames[$i]\\t$iniversions[$i]\\t$iniurls[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\\@ininames,\\@iniversions,\\@inisizes,\\@inidates,\\@inirepos,\\@iniurls,$_[0]);\n\tmy @names    = @$p1;\n\tmy @versions = @$p2;\n\tmy @sizes    = @$p3;\n\tmy @dates    = @$p4;\n\tmy @repos    = @$p5;\n\tmy @urls     = @$p6;\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub openbsd {\n\tif ($openbsd_release < 5) {\n\t\t&openbsd_older(@_);\n\t} else {\n\t\t&openbsd_newer(@_);\n\t}\n\treturn();\n}\n\nsub openbsd_combos {\n\tmy @parts = split /-/, $_[0];\n\tfor (my $i = 1; $i < @parts; $i++) {\n\t\tif ($parts[$i] =~ /^[0-9]/) {\n\t\t\treturn ( (join '-',@parts[0..($i-1)]), (join '-', @parts[$i..(@parts-1)]) );\n\t\t}\n\t}\n}\n\nsub openbsd_newer {\n\tmy $rel = $openbsd_release;\n\tmy $arch = \"i386\";\n\tmy $baseurl = 'http://ftp.openbsd.org/pub/OpenBSD/'.$rel.'/packages/'.$arch.'/';\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @repos;\n\tmy @sizes;\n\tmy @dates;\n\tmy $distroname = \"OpenBSD\";\n\tmy $file = \"$confdir/$distroname\\_$rel.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t($names[$i],$versions[$i],$dates[$i],$sizes[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl);\n\t\tmy $now = 0;\n\t\tfor (my $i = 0; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /^<IMG SRC=\"\\/icons\\/compressed\\.gif|\\.tgz/i) {\n\t\t\t\tmy @firstParts = split /<A HREF=\"|\\.tgz\">|.tgz<\\/A> +|  +/i, $lines[$i];\n\t\t\t\tmy $a = @names;\n\t\t\t\t($names[$a],$versions[$a]) = &openbsd_combos($firstParts[2]);\n\t\t\t\tpush @dates, $firstParts[4];\n\t\t\t\tpush @sizes, $firstParts[5];\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @names;$i++) {\n\t\t\tprint OUT \"$names[$i]\\t$versions[$i]\\t$dates[$i]\\t$sizes[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\tmy $matcher = $_[0];\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\tif ($names[$i] =~ /$matcher/i) {\n\t\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t\t}\n\t}\n\treturn ();\n}\n\nsub openbsd_older {\n\tmy $rel = $openbsd_release;\n\tmy $arch = \"i386\";\n\tmy $baseurl = \"http://www.openbsd.org/\".$rel.'_packages/';\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @repos;\n\tmy @sizes;\n\tmy @dates;\n\tmy $distroname = \"OpenBSD\";\n\tmy $file = \"$confdir/$distroname\\_$rel.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t($names[$i],$versions[$i],$urls[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl.$arch.\".html\");\n\t\tmy $now = 0;\n\t\tfor (my $i = 0; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /^<td><b><a/) {\n\t\t\t\tmy @parts = split />|href=|\\.tgz</, $lines[$i];\n\t\t\t\tpush @urls, $baseurl.$parts[3];\n\t\t\t\t($names[$now],$versions[$now]) = &combos($parts[4]);\n\t\t\t\t$now++;\n\t\t\t\tpush @repos, \"\";\n\t\t\t\tpush @sizes, \"\";\n\t\t\t\tpush @dates, \"\";\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @urls;$i++) {\n\t\t\tprint OUT \"$names[$i]\\t$versions[$i]\\t$urls[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\tmy $matcher = $_[0];\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\tif ($names[$i] =~ /$matcher/i) {\n\t\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t\t}\n\t}\n\treturn ();\n}\n\nsub cygwin {\n\tmy $baseurl = \"http://www.cygwin.com/packages\";\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @repos;\n\tmy @sizes;\n\tmy @dates;\n\tmy @archs;\n\tmy $distroname = \"Cygwin\";\n\tmy $searchy = $_[0];\n\tmy @lines = split /\\n/, &fetchdoc(\"$baseurl/package_list.html\");\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tmy $line = $lines[$i];\n\t\tif ($line =~ /<tr><td><a href=\"/) {\n\t\t\t$line =~ s{^<tr><td>}{};\n\t\t\t$line =~ s{</td></tr>$}{};\n\t\t\tmy @parts = split /<\\/td><td>/, $line;\n\t\t\t$parts[0] =~ s{^<a href=\"?}{};\n\t\t\t$parts[0] =~ s{</a>$}{};\n\t\t\tmy ($temp, $name) = split /\"?>/, $parts[0], 2;\n\t\t\tnext unless $name =~ /$searchy/i;\n\t\t\tmy @detailLines = split /\\n/, &fetchdoc(\"$baseurl/$temp/\");\n\t\t\tmy $highest = '';\n\t\t\tfor (my $a = 0; $a < @detailLines; $a++) { # incrementing ensures that the highest version number will prevail\n\t\t\t\t\t\t\t\t   # (higher ones occur lower down at time of writing)\n\t\t\t\tif ($detailLines[$a] =~ /<li><a href=\"/ && $detailLines[$a] !~ /\\-src\\<\\/a\\>\\<\\/li\\>/) {\n\t\t\t\t\t$highest = (split /<a href=\"|\">/, $detailLines[$a])[1]; # due to server apache config currently only works when $arch eq 'x86_64' - more work needed\n\t\t\t\t}\n\t\t\t}\n\t\t\tpush @versions, (&combos($highest))[1];\n\t\t\tmy @comps = split /\\//, $temp;\n\t\t\tpush @names,    $comps[1];\n\t\t\tpush @archs,    $comps[0];\n\t\t\tpush @dates,    '';\n\t\t\tpush @urls,     \"$baseurl/$temp/$highest\";\n\t\t\tpush @sizes,    '';\n\t\t\tpush @repos,    '';\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\t#&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i],$archs[$i]);\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub gentoo {\n\tmy $gentoobase = \"http://gpo.zugaina.org/\";\n\tmy $gentoobaseofficial = \"http://packages.gentoo.org/package\";\n\tmy $distroname = \"Gentoo\";\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @dates;\n\tmy @lines = split /\\n/, &fetchdoc($gentoobase.\"/Search?search=\".$_[0]);\n\tmy $name;\n\tmy @repos;\n\tmy @sizes;\n\tmy @groups;\n\tfor (my $i = 0; $i < @lines; $i++) { # starting value is a speed compromise\n\t\tif ($lines[$i] =~ /<div id\\=\\\"search_results\\\"\\>/) {\n\t\t\tfor (my $a = $i+1; $a < @lines; $a++) {\n\t\t\t\tif ($lines[$a] =~ /\\<\\/div\\>/) {\n\t\t\t\t\tif ($lines[$a] !~ /\\<div\\>/) {\n\t\t\t\t\t\tlast;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmy @parts = split /\\<div\\>/, $lines[$a];\n\t\t\t\t\t\tmy @dosparts = split /\\//, $parts[1];\n\t\t\t\t\t\t$dosparts[1] =~ / +$/;\n\t\t\t\t\t\tmy $tempurl = $gentoobase.\"/\".$dosparts[0].\"/\".$dosparts[1];\n\t\t\t\t\t\tmy $officialurl = $gentoobaseofficial.\"/\".$dosparts[0].\"/\".$dosparts[1];\n\t\t\t\t\t\tmy @newlines = split /\\n/, &fetchdoc($tempurl);\n\t\t\t\t\t\tfor (my $li = 0; $li < @newlines; $li++) {\n\t\t\t\t\t\t\tif ($newlines[$li] =~ /\\<li class\\=\\\"[a-z]+ebuildrow\\\"/) {\n\t\t\t\t\t\t\t\tmy @tempbreak = split /\\<b\\>|\\<\\/b\\>|-/, $newlines[$li+2];\n\t\t\t\t\t\t\t\tmy $vernum;\n\t\t\t\t\t\t\t\tfor (my $incrementa = 2; $incrementa < @tempbreak; $incrementa++) {\n\t\t\t\t\t\t\t\t\tif ($tempbreak[$incrementa] =~ /^[0-9]/) {\n\t\t\t\t\t\t\t\t\t\t$vernum = join \"-\", @tempbreak[$incrementa..(@tempbreak-2)];\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpush @names, $dosparts[1];\n\t\t\t\t\t\t\t\tpush @groups, $dosparts[0];\n\t\t\t\t\t\t\t\tpush @urls, $officialurl;\n\t\t\t\t\t\t\t\tpush @versions, $vernum;\n\t\t\t\t\t\t\t\tpush @repos, \"\";\n\t\t\t\t\t\t\t\tpush @sizes, \"\";\n\t\t\t\t\t\t\t\tpush @dates, \"\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n# this almost works, will make the whole thing a lot faster!\n#sub combos {\n#\tmy @parts = split /-/, $_[0];\n#\tmy $name;\n#\tmy $version;\n#\tfor (my $i = 1; $i < @parts-1; $i++) {\n#\t\tif ($parts[$i] =~ /^[0-9]/) {\n#\t\t\t$name = join \"-\", @parts[0..($i-1)];\n#\t\t\t$version = join \"-\", @parts[$i..(@parts-1)];\n#\t\t\tlast;\n#\t\t}\n#\t}\n#\treturn($name,$version);\n#}\n\nsub combos {\n        my @chars = split //, $_[0];\n        my $name;\n        my $version; \n        for (my $i = 0; $i < @chars-1; $i++) {\n                if ($chars[$i] eq \"-\"#) {\n#\t\t\tif (\n&& $chars[$i+1] =~ /[0-9]/) {\n                        \t$name = join \"\", @chars[0..($i-1)];\n                        \t$version = join \"\", @chars[($i+1)..(@chars-1)];\n                        \tlast;\n#\t\t\t} else {\n#\t\t\t\t$i++; #minor speed-up\n#\t\t\t}\n                }\n        }\n        return($name,$version);\n}\n\nsub combor {\n\tmy @chars = split //, $_[0];\n\tmy $name;\n\tmy $version;\n\tfor (my $i = @chars - 1; $i >= 0; $i--) {\n\t\tif ($chars[$i] !~ /[0-9\\-\\.]/ && !($chars[$i] eq \"i\" && $chars[$i-1] eq \"-\" && $chars[$i+1] =~ /[6543]/)) {\n\t\t\t$name = join \"\", @chars[0..($i)];\n\t\t\t$version = join \"\", @chars[($i+2)..(@chars-1)];\n\t\t\tlast;\n\t\t}\n\t}\n\treturn($name,$version);\n}\n\nsub combos_freebsd {\n\tmy @parts = split /-/, $_[0];\n\tmy $name;\n\tmy $version;\n\tfor (my $i = 1; $i < @parts; $i++) {\n\t\tif ($parts[$i] =~ /^[0-9]/) {\n\t\t\t$name = join \"-\", @parts[0..($i-1)];\n\t\t\t$version = join \"-\", @parts[$i..(@parts-1)];\n\t\t}\n\t}\n\treturn($name,$version);\n}\n\nsub slack_combos {\n\t$_[0] =~ s/^\\s*//;\n\tmy @parts = split /-/, $_[0];\n\treturn ((join '-', @parts[0..(@parts-4)]),$parts[(@parts-3)]);\n}\n\nsub slack {\n\tmy $slackbase  = \"http://packages.slackware.com/\";\n\tmy @repos;\n\tmy @groups;\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @combos;\n\tmy @sizes;\n\tmy @dates;\n\tmy @lines = split /\\n|<br>|<\\/tr>/, &fetchdoc($slackbase.\"/?release=slackware-current&mode=package&result=100&extra=on&pasture=on&patches=on&slackware=on&source=on&testing=on&search=\".$_[0]);\n\tmy $now = 0;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /<td nowrap><a href=/) {\n\t\t\tmy $line = $lines[$i];\n\t\t\t$line =~ s{<td align=\"right\">}{<td>};\n\t\t\t$line =~ s{<td nowrap>}{<td>};\n\t\t\t$line =~ s{^<tr><td>}{};\n\t\t\t$line =~ s{</td>$}{};\n\t\t\tmy @parts = split /<\\/td><td>/, $line;\n\t\t\tmy ($repo, $group) = split '/', $parts[1], 2;\n\t\t\tpush @groups, $group;\n\t\t\tpush @repos, $repo;\n\t\t\t$parts[2] =~ s{^<a href=\"?}{};\n\t\t\t$parts[2] =~ s{</a>$}{};\n\t\t\tmy ($url, $combo) = split '>', $parts[2], 2;\n\t\t\tmy ($name, $version) = &slack_combos($combo);\n\t\t\t($names[$now],$versions[$now]) = ($name, $version);\n\t\t\t$now++;\n\t\t\tpush @urls, $slackbase.$url;\n\t\t\tpush @dates, \"\";\n\t\t\tpush @sizes, $parts[3];\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Slackware\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub debian_sizes {\n\tmy @lines = split /\\n/, &fetchdoc($_[0]);\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /download\\\">i386<\\/a/) {\n\t\t\tmy @newparts = split /\\\"size\\\"\\>|<\\/td>/, $lines[$i+3];\n\t\t\treturn &debian_size_convert($newparts[1]);\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /download\\\">all<\\/a/) {\n\t\t\tmy @newparts = split /\\\"size\\\"\\>|<\\/td>/, $lines[$i+3];\n\t\t\treturn &debian_size_convert($newparts[1]);\n\t\t}\n\t}\n}\n\nsub debian_size_convert {\n\tif ($_[0] =~ s/\\&nbsp;kB$//) {\n\t\t$_[0] =~ s/,//g;\n\t\tmy @parts = split /\\./, $_[0];\n\t\tmy @partses = split //, $parts[1];\n\t\tif ($partses[0] >= 5) {\n\t\t\t$parts[0]++;\n\t\t}\n\t\tif ($parts[0] < 1000) {\n\t\t\treturn $parts[0].\"K\";\n\t\t} else {\n\t\t\tmy $val = round($parts[0]/1024);\n\t\t\treturn $val.\"M\";\n\t\t}\n\t} else {\n\t\tdie \"Strange packet size encountered: $_[0]\\n\";\n\t}\n}\n\nsub debian {\n\tmy @dists = ($debian_current_release);\n\t&debuntu('http://packages.debian.org','Debian',\\@dists,$_[0]);\n\treturn();\n}\n\nsub ubuntu {\n\tmy @array = ($ubuntu_current_release);\n\t&debuntu('http://packages.ubuntu.com','Ubuntu',\\@array,$_[0]);\n\treturn();\n}\n\nsub debuntu {\n\tmy ($baseurl,$distname,$releaseArrayP,$searchTerm) = @_;\n\tmy @dists = @$releaseArrayP;\n\tmy @names;\n\tmy @repos;\n\tmy @groups;\n\tmy @versions;\n\tmy @urls;\n\tmy @sizes;\n\tmy @dates;\n\tfor (my $x = 0; $x < @dists; $x++) {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"/search?keywords=\".$searchTerm.\"&searchon=names&suite=\".$dists[$x].\"&section=all\");\n\t\tfor (my $i = 50; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /<h3>Package /) {\n\t\t\t\tmy $name = (split /h3>Package |<\\/h3>/, $lines[$i])[1];\n\t\t\t\t# There are now one or more 8-line blocks that are approximately\n\t\t\t\t# $lines[$i]   <li class=\"intrepid\"><a class=\"resultlink\" href=\"/intrepid/dpkg\">intrepid</a> (base):\n\t\t\t\t# $lines[$i+3] <br>1.14.20ubuntu6: amd64 i386\n\t\t\t\t# And this list starts with <ul> and ends with </ul>\n\t\t\t\t$i += 1;\n\t\t\t\twhile (($lines[$i] !~ '</ul>') && ($i < @lines)) {\n\t\t\t\t\tif ($lines[$i] =~ /class=\"resultlink\"/) {\n\t\t\t\t\t\tpush @names, $name;\n\t\t\t\t\t\tmy @parts = split /href\\=\\\"|\\\"\\>|<\\/a\\>/, $lines[$i];\n\t\t\t\t\t\t$parts[4] =~ s/ \\(|\\)://g;\n\t\t\t\t\t\tpush @groups, $parts[4];\n\t\t\t\t\t\tpush @repos, $dists[$x];\n\t\t\t\t\t\tpush @urls,  $baseurl.$parts[2];\n\t\t\t\t\t\tpush @dates, \"\";\n\t\t\t\t\t\tmy $vline = $lines[$i+3];\n\t\t\t\t\t\t# prune possibly existing link to backports\n\t\t\t\t\t\t$vline =~ s/ *\\[.*strong.*\\]//g;\n\t\t\t\t\t\t# Split lines e.g. \"0.8.4-3+squeeze1: all\"\n\t\t\t\t\t\t@parts = split />|: /, $vline;\n\t\t\t\t\t\tpush @versions, $parts[1];\n\t\t\t\t\t\t$i += 4; # do not be too greedy\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$i += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tunless ($shallow) {\n\t\tif (!$nothreads) {\n\t\t\tmy @thr;\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\tpush @thr, threads->new(\\&debian_sizes, $urls[$i]);\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @thr; $i++) {\n\t\t\t\tpush @sizes, $thr[$i]->join;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\tpush @sizes, &debian_sizes($urls[$i]);\t# TODO but we want installed size - or both?\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\tpush @sizes, \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub aur {\n\tmy $aurbase    = \"https://aur.archlinux.org\";\n\tmy @lines = split /\\n/, &fetchdoc($aurbase.\"/rpc/?v=5&type=search&arg=\".$_[0]);\n\n\tmy @repos;\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @urls;\n\tmy @sizes;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /\\{/) {\n\t\t\tmy $content = decode_json($lines[$i]);\n\t\t\tif ($content->{version} != 5 ) {\n\t\t\t\twarn (\"Unknown version\");\n\t\t\t\treturn ();\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @{$content->{results}}; $i++) {\n\t\t\t\tmy $pkg = $content->{results}[$i];\n\t\t\t\tif ($pkg->{Name} =~ $_[0]) {\n\t\t\t\t\t# push @repos, # there are no \"repos\" in AUR\n\t\t\t\t\tpush @names, $pkg->{Name};\n\t\t\t\t\tpush @versions, $pkg->{Version}; # XXX: Versions can be too long\n\t\t\t\t\t# push @sizes, # not build so size is unknown\n\t\t\t\t\t# push @dates, # not build so date is unknown\n\t\t\t\t\tpush @urls, \"$aurbase/packages/$pkg->{Name}\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\t&pretty_print($cols,@columns,\"AUR\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub human {\n        my $size = $_[0];\n\tmy @suffixes = (' ', 'K', 'M', 'G');\n\tmy $index = 0;\n\n\twhile ($size > 1024) {\n\t\t$index++;\n\t\t$size = POSIX::floor($size / 1024);\n\t}\n\treturn(\"$size@suffixes[$index]\");\n}\n\nsub arch {\n\tmy $archbase   = \"https://archlinux.org\";\n\tmy @lines = split /\\n/, &fetchdoc($archbase.\"/packages/search/json/?q=\".$_[0]);\n\n\tmy @repos;\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @urls;\n\tmy @sizes;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /\\{/) {\n\t\t\tmy $content = decode_json($lines[$i]);\n\t\t\tif ($content->{version} != 2 ) {\n\t\t\t\twarn (\"Unknown version\");\n\t\t\t\treturn ();\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @{$content->{results}}; $i++) {\n\t\t\t\tmy $pkg = $content->{results}[$i];\n\t\t\t\tif ($pkg->{pkgname} =~ $_[0]) {\n\t\t\t\t\tpush @repos, $pkg->{repo};\n\t\t\t\t\tpush @names, $pkg->{pkgname};\n\t\t\t\t\tmy $epoch = \"\";\n\t\t\t\t\tif ($pkg->{epoch} != 0) {\n\t\t\t\t\t\t$epoch = \"$pkg->{epoch}:\";\n\t\t\t\t\t}\n\t\t\t\t\tpush @versions, \"$epoch$pkg->{pkgver}-$pkg->{pkgrel}\";\n\t\t\t\t\tpush @sizes, human($pkg->{compressed_size}); # XXX: there is also installed_size\n\t\t\t\t\tpush @dates, $pkg->{build_date};\n\t\t\t\t\tpush @urls, \"$archbase/packages/$pkg->{repo}/$pkg->{arch}/$pkg->{pkgname}/\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Arch\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub arch_site_get_url {\n\tmy $temp = $_[0];\n\t$temp =~ s/.*\\<a href=\\\"|\\\".*//g;\n\treturn $temp;\n}\n\nsub arch_site_get_cont {\n \tmy @parts = split />/, $_[0];\n \tfor (my $i = 0; $i < @parts; $i++) {\n \t\tif ($parts[$i] =~ /^[A-Za-z0-9]/) {\n \t\t\treturn (split /</, $parts[$i])[0];\n \t\t}\n \t}\n}\n\nsub arch_site_ger_cont {\n\tmy $temp = $_[0];\n\t$temp =~ s/.*\\\"\\>|\\<\\/a.*//g;\n\treturn $temp;\n}\n\nsub aur_site_get_url {\n\treturn (split /\\'/, $_[0])[5];\n}\n\nsub fetchdoc {\n\tmy $url = $_[0];\n\tmy $silent = 0;\n\tif (@_ == 2 && $_[1] eq \"silent\") {\n\t\t$silent = 1;\n\t}\n\n\t$url =~ s/\\&amp\\;/\\&/ig;   # convert &amp; to &\n\n\tmy $ua = LWP::UserAgent->new;\n\t$ua->env_proxy;\n        my @firstline;\n        my @response;\n        for (my $count = 0; ; ++$count) {   # termination condition inside loop\n                my $req = HTTP::Request->new(GET => $url);\n                my $res = $ua->request($req)->as_string;\n                @response = split (/\\n/, $res);\n                @firstline = split (/ /, $response[0]);\n\t\tmy $restest = 0;\n\t\tif (@firstline == 3) {\n\t\t\t$restest = $firstline[1];\n\t\t} elsif (@firstline > 3) {\n\t\t\t$restest = $firstline[0];\n\t\t}\n\t\tif ($restest == 200 || $response[0] =~ /200 OK/) { #NB the matching expression added specifically for NetBSD package page!\n\t\t# server response 200 is a stringent criterion, but should work\n\t\t\tlast;\n\t\t} elsif ($count > 4) {   # loop termination condition\n\t\t\tunless ($silent == 1) {\n\t\t\t\twarn (\"Tried fetching \\\"$url\\\" five times. Giving up.\\n\");\n\t\t\t}\n\t\t\treturn ();\n\t\t\tlast;\n\t\t}\n\t}\n    my $end = @response - 1;\n    my $finaldoc = join (\"\\n\", @response[14..$end]);\n    return ($finaldoc);\n}\n\nsub pretty_print {\n\tif( $option_strict && trim($_[$cols+2]) ne $ARGV[0]) {\n\t\treturn; # strictness enabled, we should print exact matches only\n\t}\n\tmy $n = $_[0];\n\tmy @colwidths = @_[1..$n];\n\tmy @colvals = @_[($n+1)..(@_-1)];\n\tfor (my $i = 0; $i < @colwidths;$i++) {\n\t\tif (length($colvals[$i]) > $colwidths[$i]) {\n\t\t\tmy @letters = split //, $colvals[$i];\n\t\t\tprint join \"\", @letters[0..($colwidths[$i]-1)];\n\t\t\tprint \" \";\n\t\t} else {\n\t\t\tprint $colvals[$i];\n\t\t\tfor (my $a = 0; $a < $colwidths[$i] + 1 - length($colvals[$i]); $a++) {\n\t\t\t\tprint \" \";\n\t\t\t}\n\t\t}\n\t}\n\tprint $colvals[@colvals-1].\"\\n\"; #last column is unrestricted in length\n}\n\nsub trim($) {\n\t# Perl trim function to remove whitespace from the start and end of the\n\t# string\n\tmy $string = shift;\n\t$string =~ s/^\\s+//;\n\t$string =~ s/\\s+$//;\n\treturn $string;\n}\n\nsub opensuse {\n\tmy $opensusebase = \"http://software.opensuse.org\";\n\tmy @names;\n\tmy @repos;\n\tmy @groups;\n\tmy @versions;\n\tmy @urls;\n\tmy @sizes;\n\tmy @dates;\n\tmy $distroname = \"openSUSE\";\n\n\tmy @lines = split /\\n/, &fetchdoc($opensusebase.\"/search?q=\".$_[0].\"&baseproject=\".$distroname.\"&lang=en&exclude_debug=true\");\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /<div class=\"search-result-txt\"/) {\n\t\t\tmy $line = $lines[($i+1)];\n\t\t\t$line =~ s{^.*<h3><a href=\"}{};\n\t\t\t$line =~ s{</?mark>}{}g;\n\t\t\t$line =~ s{</a>.*}{};\n\t\t\tmy ($url, $name) = split /\">/, $line, 2;\n\t\t\tpush @names, $name;\n\t\t\tpush @urls, \"$opensusebase$url\";\n\t\t\tpush @versions, '';\n\t\t\tpush @sizes,  '';\n\t\t\tpush @dates,  '';\n\t\t\tpush @groups, '';\n\t\t\tpush @repos, '';\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn();\n}\n\nsub netbsd_pkgsrc_size {\n\tmy @retvals;\n\tmy $continueAt = 0;\n\tmy @lines = split /\\n|<br\\/>/, &fetchdoc($_[0]);\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /Filesize:/) {\n\t\t\tmy @parts = split /<\\/b> /, $lines[$i];\n\t\t\tpush @retvals, &sizeconvert($parts[1]);\n\t\t\t$continueAt = $i;\n\t\t\tlast;\n\t\t}\n\t}\n\tif ($continueAt == 0) {\n\t\tpush @retvals, \"\";\n\t}\n\t$retvals[1] = \"\"; #just in case there's no match found\n\tfor (my $i = $continueAt; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /Updated to version|Package added to/) {\n\t\t\tmy @parts = split /<b>|<\\/b>/, $lines[$i];\n\t\t\t$retvals[1] = $parts[1];\n\t\t\tlast;\n\t\t}\n\t}\n\treturn @retvals;\n}\n\nsub round {\n    my($number) = shift;\n    return int($number + .5);\n}\n\nsub sizeconvert {\n\tif ($_[0] =~ s/ KB$//) {\n\t\tmy @parts = split /\\./, $_[0];\n\t\tmy @partses = split //, $parts[1];\n\t\tif ($partses[0] >= 5) {\n\t\t\t$parts[0]++;\n\t\t}\n\t\tif ($parts[0] < 1000) {\n\t\t\treturn $parts[0].\"K\";\n\t\t} else {\n\t\t\tmy $val = round($parts[0]/1024);\n\t\t\treturn $val.\"M\";\n\t\t}\n\t} else {\n\t\tdie \"Strange packet size encountered: $_[0]\\n\";\n\t}\n}\n\nsub netbsd {\n\tmy @lines = split /\\n|<br\\/>/, &fetchdoc(\"http://pkgsrc.se/search.php?so=\".$_[0]);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /version.+maintainer/) {\n\t\t\tmy @parts = split /href=\"|<\\/a>, <em><b>version |<\\/b>, maintainer|\\\">/, $lines[$i];\n\t\t\tpush @urls, \t$parts[1];\n\t\t\tpush @versions, $parts[3];\n\t\t\tmy @subparts = split /\\//, $parts[2];\n\t\t\tpush @repos, $subparts[0];\n\t\t\tpush @names, $subparts[1];\n\t\t}\n\t}\n\tunless ($shallow) {\n\t\tif (!$nothreads) {\n\t\t\tmy @thr;\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\tpush @thr, threads->new(\\&netbsd_pkgsrc_size, $urls[$i]);\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @thr; $i++) {\n\t\t\t\t($sizes[$i],$dates[$i]) = $thr[$i]->join;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\t($sizes[$i],$dates[$i]) = &netbsd_pkgsrc_size($urls[$i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t($sizes[$i],$dates[$i]) = (\"\",\"\");\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"NetBSD\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn();\n}\n\nsub fedora_admin {\n# THIS is a possibility, but offers no date or size info\n\tmy $query = \"https://admin.fedoraproject.org/pkgdb/search/package/?searchwords=\".$_[0].\"&operator=AND&release=19&searchon=name\";\n\tmy @lines = split /\\n/, &fetchdoc($query);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy $now = 0;\n\tfor (my $i = 0; $i<@lines; $i++) {\n\t\tif ($lines[$i] =~ /unique_tag/) {\n\t\t\t# typically, this is where most of the text processing goes:\n\t\t\t# getting the info and putting it in appropriate arrays\n\n\t\t\t# use subroutine \"combos\" if the name and version are represented as, firefox-1.0.6, with the hyphen, and the version number starting with a digit\n\t\t\tmy $anchor = \"something\";\n\t\t\t($names[$now],$versions[$now]) = &combos($anchor);\n\t\t\t$now++;\n\t\t\tpush @names,    \"\";\n\t\t\tpush @versions, \"\";\n\t\t\tpush @repos,    \"\";\n\t\t\tpush @sizes,    \"\";\n\t\t\tpush @urls,     \"\";\n\t\t\tpush @dates,    \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Distroname\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub template_query {\n\tmy $query = \"url\";\n\tmy @lines = split /\\n/, &fetchdoc($query);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy $now = 0;\n\tfor (my $i = 0; $i<@lines; $i++) {\n\t\tif ($lines[$i] =~ /unique_tag/) {\n\t\t\t# typically, this is where most of the text processing goes:\n\t\t\t# getting the info and putting it in appropriate arrays\n\n\t\t\t# use subroutine \"combos\" if the name and version are represented as, firefox-1.0.6, with the hyphen, and the version number starting with a digit\n\t\t\tmy $anchor = \"something\";\n\t\t\t($names[$now],$versions[$now]) = &combos($anchor);\n\t\t\t$now++;\n\t\t\tpush @names,    \"\";\n\t\t\tpush @versions, \"\";\n\t\t\tpush @repos,    \"\";\n\t\t\tpush @sizes,    \"\";\n\t\t\tpush @urls,     \"\";\n\t\t\tpush @dates,    \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Distroname\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub template_listing {\n\tmy @ininames;\n\tmy @iniversions;\n\tmy @iniurls;\n\tmy @inirepos;\n\tmy @inisizes;\n\tmy @inidates;\n\tmy $now = 0;\n\tmy $distroname = \"mydistro\";\n\tmy $base = \"url\";\n\t# prepare a list file\n\tmy $file = \"$confdir/$distroname.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t# get back any info that you put in the file\n\t\t\t($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\t# download fresh copy\n\t\tmy @lines = split /\\n/, &fetchdoc($base.\"README-all.html\");\n\t\tfor (my $i = 0; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /unique_tag/) {\n\t\t\t\t# extract all info from the downloaded list\n\t\t\t\tmy @parts = split / /, $lines[$i];\n\t\t\t\t# use subroutine \"combos\" to separate name and version number\n\t\t\t\t($ininames[$now],$iniversions[$now]) = &combos($parts[1]);\n\t\t\t\t$now++;\n\t\t\t\t# any info you couldn't get, put a blank in\n\t\t\t\tpush @iniurls,  \"\";\n\t\t\t\tpush @inirepos, \"\";\n\t\t\t\tpush @inisizes, \"\";\n\t\t\t\tpush @inidates, \"\";\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @iniurls;$i++) {\n\t\t\t# store the available info in the file\n\t\t\tprint OUT \"$ininames[$i]\\t$iniversions[$i]\\t$iniurls[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\t# search by hand\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\\@ininames,\\@iniversions,\\@inisizes,\\@inidates,\\@inirepos,\\@iniurls,$_[0]);\n\tmy @names    = @$p1;\n\tmy @versions = @$p2;\n\tmy @sizes    = @$p3;\n\tmy @dates    = @$p4;\n\tmy @repos    = @$p5;\n\tmy @urls     = @$p6;\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub mandriva_combos {\n\t$_[0] =~ s/\\<\\/a\\>.*//;\n\tmy @parts = split /-/, $_[0];\n\tfor (my $i = 1; $i < @parts; $i++) {\n\t\tif ($parts[$i] =~ /^[0-9]/) {\n\t\t\treturn ( (join '-',@parts[0..($i-1)]), (join '-', @parts[$i..(@parts-1)]) );\n\t\t}\n\t}\n}\n\nsub mandriva {\n\tmy $baseurl = \"http://sophie.zarb.org\";\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\t# NB this server also supports exact matching\n\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"/search?search=\".$_[0].\"&type=fuzzyname&deptype=P&distribution=Mandriva&release=current\");\n\tfor (my $i = 350; $i < @lines; $i++) {\n\t\t#TODO need to check for possible further pages (lists 20 per page)\n\t\t#TODO ajax or xml::rpc access might have advantages w.r.t. paging (i.e. none required) \n\t\tif ($lines[$i] =~ /<div class=\"sophie_search_list\">/) {\n\t\t\tmy $a = @names;\n\t\t\tpush @urls, (split /\"/, $lines[$i+1])[1];\n\t\t\t($names[$a],$versions[$a]) = &mandriva_combos($lines[$i+2]); # name, version, arch\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t&pretty_print($cols,@columns,\"Mandriva\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n"], "fixing_code": ["#!/usr/bin/perl\n\n# whohas, a Perl utility to display availability of source\n# and binary packages from major Linux and BSD distributions\n#\n# Copyright (C) Philipp L. Wesche 2005-2011\n#\n#\n# This program is free software; you can redistribute it and/or modify\n# it under the terms of the GNU General Public License as published by\n# the Free Software Foundation; either version 2 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU General Public License for more details.\n#\n# You should have received a copy of the GNU General Public License along\n# with this program; if not, write to the Free Software Foundation, Inc.,\n# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\nuse strict;\nuse sigtrap;\n\n#TODO --fetch-unstable switch\n#TODO make sure that debian's version numbers are from i386\n#TODO get date info about debian, ubuntu (link is to changelog)\n#TODO get date info about slackware packages from subsequent links  - postponed until slackware packages is online again\n#TODO architecture tests for those that support several\n#TODO Gentoo: only report two most recent for each package?\n#TODO make more use of the conf directory, e.g. for Fedora, Sourcemage, so we download those indexes only sparingly, and save ourselves processing time; MAKE SURE YOU WRITE THE PROCESSED RESULTS FOR EASY PARSING ON THE NEXT RUN\n#TODO we can also cache search results there to drastically reduce query time on subsequent queries\n#TODO add option to override the cache (newly fetched file written to cache)\n#TODO ubuntu: allow two releases: the long term supported and the most recent\n#TODO allow searching on several packages; return results only for those distros that have a hit for each package, possibly in tabular format\n#TODO deal gracefully with hyphens that may be present in some distros but not others, i.e. include extra hyphens in regexes, and allow user-specified hyphens to be absent\n\nuse Config;\nuse Env qw(HOME);\neval {\n\trequire if $^O ne 'MSWin32', 'forks';\n};\nuse if $Config{usethreads}, \"threads\";\nuse Getopt::Long;\nuse LWP::UserAgent;\nuse Thread::Queue;\n\nmy $conffile = \"whohas.cf\";\nmy $confdir = \"$HOME/.whohas\";\n# make .whohas directory in home directory\nunless (-d $confdir) {\n\tmkdir ($confdir, 0755);\n}\n\nmy @columns = (11,38,18,4,10,25);\nmy $cols = 6;\n\nour $fedora_min_release\t\t =  \"\"\t\t\t;\nour $fedora_max_release\t\t =  \"\"\t\t\t;\nour $debian_current_release\t = \"all\"\t\t;\nour $ubuntu_current_release\t = \"all\"\t\t;\nour $openbsd_release\t\t = \"6.0\"\t\t;\n\nmy @distrosAvailable = qw(arch cygwin debian fedora fink freebsd gentoo macports mandriva netbsd openbsd opensuse slack sourcemage ubuntu);\nmy %distrosSelected;\nforeach (@distrosAvailable) {\n\t$distrosSelected{$_} = 1;\n}\n\nour @distroSelections;\nmy $nothreads;\nmy $shallow;\nmy $option_help;\nmy $option_strict;\n\nif ( -s \"$confdir/$conffile\" ) {\n\teval {\n\t\tdo \"$confdir/$conffile\";\n\t};\n\tif ($@) {\n\t\tprint STDERR 'Eval of configuration caused errors. Aborting.\\n';\n\t\texit;\n\t}\n}\n\nGetOptions(\n\t\"d=s\" => \\@distroSelections,\n\t\"no-threads\" => \\$nothreads,\n\t\"shallow\" => \\$shallow,\n\t\"help|usage|h\" => \\$option_help,\n\t\"strict|s\" => \\$option_strict,\n);\n\nif ($option_help) {\n\tprint \"Usage: $0 [--no-threads] [--shallow] [--strict] [-d Dist1[,Dist2[,Dist3...]]] pkgname\\n\";\n\texit 0;\n}\n\nif (@ARGV > 1) {\n\tdie \"Error:\\tToo many parameters. Usage: $0 [--no-threads] [--shallow] [--strict] [-d Dist1[,Dist2[,Dist3...]]] pkgname\\n\";\n} elsif (@ARGV < 1) {\n\tdie \"Error:\\tPlease specify a search term.\\n\";\n}\n\nif (!$Config{usethreads} && !$nothreads) {\n\t$nothreads = 1;\n\twarn \"No threads support, --no-threads is forced.\\n\";\n}\n\n#\n# BUILD %distrosSelected\n#\n\nif (@distroSelections) {\n\tforeach (@distrosAvailable) {\n\t\t$distrosSelected{$_} = 0;\n\t}\n\t@distroSelections = split(/,/,join(',',@distroSelections));\n\tfor my $distro (@distroSelections) {\n\t\t$distro =~ tr/A-Z/a-z/;\n\t\tif (\t\t$distro =~ /archlinux/i) {\t$distrosSelected{arch}\t= 1;\n\t\t} elsif (\t$distro =~ /slackware/i) {\t$distrosSelected{slack}\t= 1;\n\t\t} else {\n\t\t\tif (exists $distrosSelected{$distro}) {\t# NB only due to previous setting of hash values for all known distros can we use this test to see if the distro is known\n\t\t\t\t$distrosSelected{$distro} = 1;\n\t\t\t} else {\n\t\t\t\tdie \"Unsupported distribution '$distro'\\n\";\n\t\t\t}\n\t\t}\n\t}\n}\n\n#\n# DISPATCH TO SUBROUTINES, THREADED OR UNTHREADED\n#\n\nif ($ARGV[0] eq \"whohasme\") {\n\tprint \"Congratulations. You discovered an Easter egg. Maybe you can send a quick email to phi1ipp\\@yahoo.com to say hello and tell the developer what you think of the software.\\n\";\n\texit;\n}\n\nmy $q = Thread::Queue->new();\nforeach (keys %distrosSelected) {\n\tif ($distrosSelected{$_}) {\n\t\tif ($_ eq 'arch') {\n\t\t\tuse JSON;\n\t\t\t$q->enqueue('arch', 'aur');\n\t\t} else {\n\t\t\t$q->enqueue($_);\n\t\t}\n\t}\n}\n$q->end();\n\nif (!$nothreads) {\n\tmy $maxthreads = maxthreads($q);\n\tmy @thrs;\n\tfor (0..$maxthreads - 1) {\n\t\tpush(@thrs, threads->new(\\&worker));\n\t}\n\tforeach (@thrs) {\n\t\t$_->join;\n\t}\n} else {\n\tworker();\n}\n\nsub worker {\n\tno strict \"refs\";\n\twhile (defined(my $distro = $q->dequeue())) {\n\t\t# NB this is only safe because we've previously checked for illegal subs\n\t\t&$distro($ARGV[0]);\n\t}\n}\n\nsub maxthreads {\n\tmy ($q) = @_;\n\tmy $jobcount = $q->pending();\n\teval { require Sys::CPU; };\n\tif ($@) {\n\t\treturn $jobcount;\n\t} else {\n\t\tmy $cpucount = Sys::CPU::cpu_count();\n\t\treturn $cpucount < $jobcount ? $cpucount : $jobcount;\n\t}\n}\n\nsub fedora {\n\tmy $baseurl = \"https://dl.fedoraproject.org/pub/fedora/linux/releases/\";\n\tmy $distroname = \"Fedora\";\n\tmy $arch = \"x86_64\";\n\tmy $searchy = $_[0];\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\n\tif (not $fedora_max_release) {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl);\n\t\tfor (my $li = 0; $li < @lines; $li++) {\n\t\t\tif ($lines[$li] =~ m{<img src=\"[^\"]*folder[^\"]*\" alt=\"[^\"]*\"> *<a href=\"[0-9]+/\"}) {\n\t\t\t\tmy ($release) = ($lines[$li] =~ m{<img src=\"[^\"]*folder[^\"]*\" alt=\"[^\"]*\"> *<a href=\"([0-9]+)/\"});\n\t\t\t\tif ($release > $fedora_max_release) {\n\t\t\t\t\t$fedora_max_release = $release;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (not $fedora_max_release) {\n\t\t\tprint STDERR \"Could not parse Fedora release list, skipping Fedora packages\\n\";\n\t\t\treturn ();\n\t\t}\n\t}\n\tif (not $fedora_min_release) {\n\t\t$fedora_min_release = $fedora_max_release - 2;\n\t}\n\n\tfor (my $i = $fedora_max_release; $i >= $fedora_min_release; $i--) {\n\t\tmy @fed_urls = (\"$i/Everything/$arch/os/Packages/\");\n\t\tmy $file = \"$confdir/$distroname\\_$i.list\";\n\t\t{\n\t\t\tfor (my $a = 0; $a < @fed_urls; $a++) {\n\t\t\t\tmy @lines = split /\\n/, &fetchdoc($baseurl.$fed_urls[$a].lc(substr($searchy, 0, 1)).'/');\n\t\t\t\tfor (my $li = 0; $li < @lines; $li++) {\n\t\t\t\t\tif ($lines[$li] =~ / +<a href=\"[^\"]+?rpm\"/) {\n\t\t\t\t\t\tmy ($name, $version, $date, $size) = ($lines[$li] =~ m{ +<a href=\"(.+?)-([0-9].*)\\.fc[0-9]*\\.[^.]*\\.rpm\">[^<]*</a> *([^ ]* [^ ]*) *([^ ]*) *(?:RPM Package)?});\n\t\t\t\t\t\tpush @names, $name;\n\t\t\t\t\t\tpush @versions, $version;\n\t\t\t\t\t\tpush @dates, $date;\n\t\t\t\t\t\tpush @sizes, $size;\n\t\t\t\t\t\tpush @urls, \"https://apps.fedoraproject.org/packages/$name\";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\tif ($names[$i] =~ /$searchy/i) {\n\t\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t\t}\n\t}\n\treturn ();\n}\n\nsub month_to_digits {\n\t$_[0] =~ s/JAN/01/i;\n\t$_[0] =~ s/FEB/02/i;\n\t$_[0] =~ s/MAR/03/i;\n\t$_[0] =~ s/APR/04/i;\n\t$_[0] =~ s/MAY/05/i;\n\t$_[0] =~ s/JUN/06/i;\n\t$_[0] =~ s/JUL/07/i;\n\t$_[0] =~ s/AUG/08/i;\n\t$_[0] =~ s/SEP/09/i;\n\t$_[0] =~ s/OCT/10/i;\n\t$_[0] =~ s/NOV/11/i;\n\t$_[0] =~ s/DEC/12/i;\n\treturn ($_[0]);\n}\n\nsub macports {\n\tmy $baseurl = \"https://www.macports.org\";\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"/ports.php?by=name&substr=\".$_[0]);\n\tfor (my $i = 70; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /<dt><b>/) {\n\t\t\tmy @parties = split /\\<dt\\>\\<b\\>/, $lines[$i];\n\t\t\tfor (my $javar = 1; $javar < @parties; $javar++) {\n\t\t\t\tmy @parts = split /href=\"|\">|<\\/a><\\/b> |<\\/dt/, $parties[$javar];\n\t\t\t\tpush @urls,     $parts[1];\n\t\t\t\tpush @names,    $parts[2];\n\t\t\t\tpush @versions, $parts[3];\n\t\t\t\tpush @repos, \"\";\n\t\t\t\tpush @sizes, \"\";\n\t\t\t\tpush @dates, \"\";\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"MacPorts\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n\nsub fink {\n\tmy $baseurl = \"https://pdb.finkproject.org/pdb/\";\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"browse.php?name=\".$_[0]);\n\tfor (my $i = 60; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /tr class=\\\"package\\\"/) {\n\t\t\tif ($lines[$i] =~ /^\\<tr class\\=\\\"pdbHeading\\\"\\>/) {\n\t\t\t\t$lines[$i] =~ s/.*?\\<\\/tr\\>//;\n\t\t\t}\n\t\t\tmy @splitty = split /href\\=\\\"|\\\"\\>|\\<\\/a\\>\\<\\/td\\>\\<td class=\\\"packageName\\\"\\>|\\<\\/td\\>\\<td\\>/, $lines[$i];\n\t\t\tpush @urls, $splitty[3];\n\t\t\tpush @names, $splitty[4];\n\t\t\tpush @versions, $splitty[5];\n\t\t\tpush @repos, \"\";\n\t\t\tpush @sizes, \"\";\n\t\t\tpush @dates, \"\";\n\t\t} elsif ($lines[$i] =~ /\\<p\\>Query took /) {\n\t\t\tlast;\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Fink\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub fink_get_details {\n\tmy @repos;\n\tmy @versions;\n\tmy @lines = split /\\n/, &fetchdoc($_[0]);\n\tfor (my $i = 60; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /10\\./) {\n\t\t\tmy @parts = split /nowrap\">|<\\/div>/, $lines[$i];\n\t\t\tunless ($parts[5] =~ /not present/ or $parts[5] =~ /unsupported/) {\n\t\t\t\tif ($parts[1] =~ /<br>/) {\n\t\t\t\t\tpush @repos, (split /<br>/, $parts[1])[0];\n\t\t\t\t} else {\n\t\t\t\t\tpush @repos, $parts[1];\n\t\t\t\t}\n\t\t\t\t$parts[5] =~ s/\\<\\!\\-\\-.*\\-\\-\\>//;\n\t\t\t\tpush @versions, $parts[5];\n\t\t\t}\n\t\t}\n\t\tif ($lines[$i] eq '</table>') {\n\t\t\tlast;\n\t\t}\n\t}\n\treturn (\\@versions,\\@repos);\n}\n\nsub size_trim {\n\t# give at least two significant figures; if a 10^3 edge is encountered, put a dot\n\tmy $leave =  length($_[0]) % 3;\n\tmy $threes = (length($_[0]) - $leave) / 3;\n\tif ($leave == 0) {\n\t\t$leave = 3;\n\t\t$threes--;\n\t}\n\t\n\tmy @parts = split //, $_[0];\n\tmy $retval = join \"\", @parts[0..($leave-1)];\n\tif (length($retval)==1 && $threes > 0) {\n\t\t# add one more significant figure\n\t\tmy $add_sf = $parts[$leave];\n\t\tif ($parts[$leave+1] > 4) {\n\t\t\t# rounding\n\t\t\t$add_sf++;\n\t\t\tif ($add_sf == 10) {\n\t\t\t\t$add_sf = 0;\n\t\t\t\t$retval++;\n\t\t\t\tif ($retval == 10) {\n\t\t\t\t\treturn(&size_trim($retval*(1000**$threes)));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$retval .= \".$add_sf\";\n\t} elsif (defined($parts[$leave]) && $parts[$leave] > 4) { # instead of defined(...), ($threes > 0) is also possible\n\t\tmy $before = length($retval);\n\t\t# rounding\n\t\t$retval++;\n\t\tif (length($retval) > $before) {\n\t\t\treturn(&size_trim($retval*(1000**$threes)));\n\t\t}\n\t}\n\tmy @suffixes = (\"k\",\"M\",\"G\");\n\tif ($threes > 0) {\n\t\t$retval .= $suffixes[($threes-1)];\n\t}\n\treturn $retval;\n}\n\n\nsub freebsd {\n\tmy $query = \"https://www.freebsd.org/cgi/ports.cgi?query=\".$_[0].\"&stype=all\";\n\tmy @lines = split /\\n/, &fetchdoc($query);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy $now = 0;\n\tfor (my $i = 50; $i<@lines; $i++) {\n\t\tif ($lines[$i] =~ /^<dt><b>/) {\n\t\t\tmy @parts = split /\"/, $lines[$i];\n\t\t\t($names[$now],$versions[$now]) = &combos_freebsd($parts[1]);\n\t\t\tmy @subparts = split /\\//, $parts[3];\n\t\t\tpush @sizes, \"\";\n\t\t\tpush @repos, $subparts[@subparts-2];\n\t\t\tpush @urls,  \"https://www.freebsd.org/cgi/ports.cgi?stype=all&query=$names[$now]\";\n\t\t\t$now++;\n\t\t\tpush @dates, \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"FreeBSD\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n\nsub sourcemage {\n\tmy @grimoires = (\"test\",\"stable\",\"binary\",\"z-rejected\",\"games\");\n\tmy @lines = split /\\n/, &fetchdoc(\"http://codex.sourcemage.org/listing.txt\");\n\tmy @inirepos;\n\tmy @ininames;\n\tmy @iniversions;\n\tmy @iniurls;\n\tmy @inidates;\n\tmy @inisizes;\n\tforeach (@lines) {\n\t\tmy @comps = split /\\^/, $_;\n\t\tfor (my $a = 0; $a < @grimoires;$a++) {\n\t\t\tif (length($comps[$a+1]) > 0) {\n\t\t\t\tpush @inirepos, $grimoires[$a];\n\t\t\t\tpush @ininames, $comps[0];\n\t\t\t\tpush @iniversions, $comps[$a+1];\n\t\t\t\tpush @inisizes, \"\";\n\t\t\t\tpush @iniurls,  \"\";\n\t\t\t\tpush @inidates, \"\";\n\t\t\t}\n\t\t}\n\t}\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\\@ininames,\\@iniversions,\\@inisizes,\\@inidates,\\@inirepos,\\@iniurls,$_[0]);\n\tmy @names    = @$p1;\n\tmy @versions = @$p2;\n\tmy @sizes    = @$p3;\n\tmy @dates    = @$p4;\n\tmy @repos    = @$p5;\n\tmy @urls     = @$p6;\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Source Mage\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n\nsub search_by_name { # versions, sizes, dates, repos, urls\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6,$search) = @_;\n\tmy @ininames    = @$p1;\n\tmy @iniversions = @$p2;\n\tmy @inisizes    = @$p3;\n\tmy @inidates    = @$p4;\n\tmy @inirepos    = @$p5;\n\tmy @iniurls     = @$p6;\n\tmy @names;\n\tmy @versions;\n\tmy @sizes;\n\tmy @dates;\n\tmy @repos;\n\tmy @urls;\n\tfor (my $i = 0;$i<@ininames;$i++) {\n\t\tif ($ininames[$i] =~ /$search/i) {\n\t\t\tpush @names,    $ininames[$i];\n\t\t\tpush @repos,    $inirepos[$i];\n\t\t\tpush @versions, $iniversions[$i];\n\t\t\tpush @sizes,    $inisizes[$i];\n\t\t\tpush @dates,    $inidates[$i];\n\t\t\tpush @urls,     $iniurls[$i];\n\t\t}\n\t}\n\treturn(\\@names,\\@versions,\\@sizes,\\@dates,\\@repos,\\@urls);\n}\n\nsub netbsd_old {\n\tmy $netbsdbase = \"ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/\";\n\tmy @ininames;\n\tmy @iniversions;\n\tmy @iniurls;\n\tmy @inirepos;\n\tmy @inisizes;\n\tmy @inidates;\n\tmy $now = 0;\n\tmy $distroname = \"NetBSD\";\n\tmy $file = \"$confdir/$distroname.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\tmy @lines = split /\\n/, &fetchdoc($netbsdbase.\"README-all.html\");\n\t\tfor (my $i = 10; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /^<!-- [0-9A-Za-z]/) {\n\t\t\t\tmy @parts = split / /, $lines[$i];\n\t\t\t\t($ininames[$now],$iniversions[$now]) = &combos($parts[1]);\n\t\t\t\t$now++;\n\t\t\t\t@parts = split /a href=\"|\">/, $lines[$i];\n\t\t\t\tpush @iniurls, $netbsdbase.$parts[1];\n\t\t\t\tpush @inirepos, \"\";\n\t\t\t\tpush @inisizes, \"\";\n\t\t\t\tpush @inidates, \"\";\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @iniurls;$i++) {\n\t\t\tprint OUT \"$ininames[$i]\\t$iniversions[$i]\\t$iniurls[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\\@ininames,\\@iniversions,\\@inisizes,\\@inidates,\\@inirepos,\\@iniurls,$_[0]);\n\tmy @names    = @$p1;\n\tmy @versions = @$p2;\n\tmy @sizes    = @$p3;\n\tmy @dates    = @$p4;\n\tmy @repos    = @$p5;\n\tmy @urls     = @$p6;\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub openbsd {\n\tif ($openbsd_release < 5) {\n\t\t&openbsd_older(@_);\n\t} else {\n\t\t&openbsd_newer(@_);\n\t}\n\treturn();\n}\n\nsub openbsd_combos {\n\tmy @parts = split /-/, $_[0];\n\tfor (my $i = 1; $i < @parts; $i++) {\n\t\tif ($parts[$i] =~ /^[0-9]/) {\n\t\t\treturn ( (join '-',@parts[0..($i-1)]), (join '-', @parts[$i..(@parts-1)]) );\n\t\t}\n\t}\n}\n\nsub openbsd_newer {\n\tmy $rel = $openbsd_release;\n\tmy $arch = \"i386\";\n\tmy $baseurl = 'https://ftp.openbsd.org/pub/OpenBSD/'.$rel.'/packages/'.$arch.'/';\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @repos;\n\tmy @sizes;\n\tmy @dates;\n\tmy $distroname = \"OpenBSD\";\n\tmy $file = \"$confdir/$distroname\\_$rel.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t($names[$i],$versions[$i],$dates[$i],$sizes[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl);\n\t\tmy $now = 0;\n\t\tfor (my $i = 0; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /^<IMG SRC=\"\\/icons\\/compressed\\.gif|\\.tgz/i) {\n\t\t\t\tmy @firstParts = split /<A HREF=\"|\\.tgz\">|.tgz<\\/A> +|  +/i, $lines[$i];\n\t\t\t\tmy $a = @names;\n\t\t\t\t($names[$a],$versions[$a]) = &openbsd_combos($firstParts[2]);\n\t\t\t\tpush @dates, $firstParts[4];\n\t\t\t\tpush @sizes, $firstParts[5];\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @names;$i++) {\n\t\t\tprint OUT \"$names[$i]\\t$versions[$i]\\t$dates[$i]\\t$sizes[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\tmy $matcher = $_[0];\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\tif ($names[$i] =~ /$matcher/i) {\n\t\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t\t}\n\t}\n\treturn ();\n}\n\nsub openbsd_older {\n\tmy $rel = $openbsd_release;\n\tmy $arch = \"i386\";\n\tmy $baseurl = \"https://www.openbsd.org/\".$rel.'_packages/';\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @repos;\n\tmy @sizes;\n\tmy @dates;\n\tmy $distroname = \"OpenBSD\";\n\tmy $file = \"$confdir/$distroname\\_$rel.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t($names[$i],$versions[$i],$urls[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl.$arch.\".html\");\n\t\tmy $now = 0;\n\t\tfor (my $i = 0; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /^<td><b><a/) {\n\t\t\t\tmy @parts = split />|href=|\\.tgz</, $lines[$i];\n\t\t\t\tpush @urls, $baseurl.$parts[3];\n\t\t\t\t($names[$now],$versions[$now]) = &combos($parts[4]);\n\t\t\t\t$now++;\n\t\t\t\tpush @repos, \"\";\n\t\t\t\tpush @sizes, \"\";\n\t\t\t\tpush @dates, \"\";\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @urls;$i++) {\n\t\t\tprint OUT \"$names[$i]\\t$versions[$i]\\t$urls[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\tmy $matcher = $_[0];\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\tif ($names[$i] =~ /$matcher/i) {\n\t\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t\t}\n\t}\n\treturn ();\n}\n\nsub cygwin {\n\tmy $baseurl = \"https://www.cygwin.com/packages\";\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @repos;\n\tmy @sizes;\n\tmy @dates;\n\tmy @archs;\n\tmy $distroname = \"Cygwin\";\n\tmy $searchy = $_[0];\n\tmy @lines = split /\\n/, &fetchdoc(\"$baseurl/package_list.html\");\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tmy $line = $lines[$i];\n\t\tif ($line =~ /<tr><td><a href=\"/) {\n\t\t\t$line =~ s{^<tr><td>}{};\n\t\t\t$line =~ s{</td></tr>$}{};\n\t\t\tmy @parts = split /<\\/td><td>/, $line;\n\t\t\t$parts[0] =~ s{^<a href=\"?}{};\n\t\t\t$parts[0] =~ s{</a>$}{};\n\t\t\tmy ($temp, $name) = split /\"?>/, $parts[0], 2;\n\t\t\tnext unless $name =~ /$searchy/i;\n\t\t\tmy @detailLines = split /\\n/, &fetchdoc(\"$baseurl/$temp/\");\n\t\t\tmy $highest = '';\n\t\t\tfor (my $a = 0; $a < @detailLines; $a++) { # incrementing ensures that the highest version number will prevail\n\t\t\t\t\t\t\t\t   # (higher ones occur lower down at time of writing)\n\t\t\t\tif ($detailLines[$a] =~ /<li><a href=\"/ && $detailLines[$a] !~ /\\-src\\<\\/a\\>\\<\\/li\\>/) {\n\t\t\t\t\t$highest = (split /<a href=\"|\">/, $detailLines[$a])[1]; # due to server apache config currently only works when $arch eq 'x86_64' - more work needed\n\t\t\t\t}\n\t\t\t}\n\t\t\tpush @versions, (&combos($highest))[1];\n\t\t\tmy @comps = split /\\//, $temp;\n\t\t\tpush @names,    $comps[1];\n\t\t\tpush @archs,    $comps[0];\n\t\t\tpush @dates,    '';\n\t\t\tpush @urls,     \"$baseurl/$temp/$highest\";\n\t\t\tpush @sizes,    '';\n\t\t\tpush @repos,    '';\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\t#&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i],$archs[$i]);\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub gentoo {\n\tmy $gentoobase = \"https://gpo.zugaina.org/\";\n\tmy $gentoobaseofficial = \"https://packages.gentoo.org/package\";\n\tmy $distroname = \"Gentoo\";\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @dates;\n\tmy @lines = split /\\n/, &fetchdoc($gentoobase.\"/Search?search=\".$_[0]);\n\tmy $name;\n\tmy @repos;\n\tmy @sizes;\n\tmy @groups;\n\tfor (my $i = 0; $i < @lines; $i++) { # starting value is a speed compromise\n\t\tif ($lines[$i] =~ /<div id\\=\\\"search_results\\\"\\>/) {\n\t\t\tfor (my $a = $i+1; $a < @lines; $a++) {\n\t\t\t\tif ($lines[$a] =~ /\\<\\/div\\>/) {\n\t\t\t\t\tif ($lines[$a] !~ /\\<div\\>/) {\n\t\t\t\t\t\tlast;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmy @parts = split /\\<div\\>/, $lines[$a];\n\t\t\t\t\t\tmy @dosparts = split /\\//, $parts[1];\n\t\t\t\t\t\t$dosparts[1] =~ / +$/;\n\t\t\t\t\t\tmy $tempurl = $gentoobase.\"/\".$dosparts[0].\"/\".$dosparts[1];\n\t\t\t\t\t\tmy $officialurl = $gentoobaseofficial.\"/\".$dosparts[0].\"/\".$dosparts[1];\n\t\t\t\t\t\tmy @newlines = split /\\n/, &fetchdoc($tempurl);\n\t\t\t\t\t\tfor (my $li = 0; $li < @newlines; $li++) {\n\t\t\t\t\t\t\tif ($newlines[$li] =~ /\\<li class\\=\\\"[a-z]+ebuildrow\\\"/) {\n\t\t\t\t\t\t\t\tmy @tempbreak = split /\\<b\\>|\\<\\/b\\>|-/, $newlines[$li+2];\n\t\t\t\t\t\t\t\tmy $vernum;\n\t\t\t\t\t\t\t\tfor (my $incrementa = 2; $incrementa < @tempbreak; $incrementa++) {\n\t\t\t\t\t\t\t\t\tif ($tempbreak[$incrementa] =~ /^[0-9]/) {\n\t\t\t\t\t\t\t\t\t\t$vernum = join \"-\", @tempbreak[$incrementa..(@tempbreak-2)];\n\t\t\t\t\t\t\t\t\t}\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tpush @names, $dosparts[1];\n\t\t\t\t\t\t\t\tpush @groups, $dosparts[0];\n\t\t\t\t\t\t\t\tpush @urls, $officialurl;\n\t\t\t\t\t\t\t\tpush @versions, $vernum;\n\t\t\t\t\t\t\t\tpush @repos, \"\";\n\t\t\t\t\t\t\t\tpush @sizes, \"\";\n\t\t\t\t\t\t\t\tpush @dates, \"\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlast;\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\n# this almost works, will make the whole thing a lot faster!\n#sub combos {\n#\tmy @parts = split /-/, $_[0];\n#\tmy $name;\n#\tmy $version;\n#\tfor (my $i = 1; $i < @parts-1; $i++) {\n#\t\tif ($parts[$i] =~ /^[0-9]/) {\n#\t\t\t$name = join \"-\", @parts[0..($i-1)];\n#\t\t\t$version = join \"-\", @parts[$i..(@parts-1)];\n#\t\t\tlast;\n#\t\t}\n#\t}\n#\treturn($name,$version);\n#}\n\nsub combos {\n        my @chars = split //, $_[0];\n        my $name;\n        my $version; \n        for (my $i = 0; $i < @chars-1; $i++) {\n                if ($chars[$i] eq \"-\"#) {\n#\t\t\tif (\n&& $chars[$i+1] =~ /[0-9]/) {\n                        \t$name = join \"\", @chars[0..($i-1)];\n                        \t$version = join \"\", @chars[($i+1)..(@chars-1)];\n                        \tlast;\n#\t\t\t} else {\n#\t\t\t\t$i++; #minor speed-up\n#\t\t\t}\n                }\n        }\n        return($name,$version);\n}\n\nsub combor {\n\tmy @chars = split //, $_[0];\n\tmy $name;\n\tmy $version;\n\tfor (my $i = @chars - 1; $i >= 0; $i--) {\n\t\tif ($chars[$i] !~ /[0-9\\-\\.]/ && !($chars[$i] eq \"i\" && $chars[$i-1] eq \"-\" && $chars[$i+1] =~ /[6543]/)) {\n\t\t\t$name = join \"\", @chars[0..($i)];\n\t\t\t$version = join \"\", @chars[($i+2)..(@chars-1)];\n\t\t\tlast;\n\t\t}\n\t}\n\treturn($name,$version);\n}\n\nsub combos_freebsd {\n\tmy @parts = split /-/, $_[0];\n\tmy $name;\n\tmy $version;\n\tfor (my $i = 1; $i < @parts; $i++) {\n\t\tif ($parts[$i] =~ /^[0-9]/) {\n\t\t\t$name = join \"-\", @parts[0..($i-1)];\n\t\t\t$version = join \"-\", @parts[$i..(@parts-1)];\n\t\t}\n\t}\n\treturn($name,$version);\n}\n\nsub slack_combos {\n\t$_[0] =~ s/^\\s*//;\n\tmy @parts = split /-/, $_[0];\n\treturn ((join '-', @parts[0..(@parts-4)]),$parts[(@parts-3)]);\n}\n\nsub slack {\n\tmy $slackbase  = \"https://packages.slackware.com/\";\n\tmy @repos;\n\tmy @groups;\n\tmy @names;\n\tmy @versions;\n\tmy @urls;\n\tmy @combos;\n\tmy @sizes;\n\tmy @dates;\n\tmy @lines = split /\\n|<br>|<\\/tr>/, &fetchdoc($slackbase.\"/?release=slackware-current&mode=package&result=100&extra=on&pasture=on&patches=on&slackware=on&source=on&testing=on&search=\".$_[0]);\n\tmy $now = 0;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /<td nowrap><a href=/) {\n\t\t\tmy $line = $lines[$i];\n\t\t\t$line =~ s{<td align=\"right\">}{<td>};\n\t\t\t$line =~ s{<td nowrap>}{<td>};\n\t\t\t$line =~ s{^<tr><td>}{};\n\t\t\t$line =~ s{</td>$}{};\n\t\t\tmy @parts = split /<\\/td><td>/, $line;\n\t\t\tmy ($repo, $group) = split '/', $parts[1], 2;\n\t\t\tpush @groups, $group;\n\t\t\tpush @repos, $repo;\n\t\t\t$parts[2] =~ s{^<a href=\"?}{};\n\t\t\t$parts[2] =~ s{</a>$}{};\n\t\t\tmy ($url, $combo) = split '>', $parts[2], 2;\n\t\t\tmy ($name, $version) = &slack_combos($combo);\n\t\t\t($names[$now],$versions[$now]) = ($name, $version);\n\t\t\t$now++;\n\t\t\tpush @urls, $slackbase.$url;\n\t\t\tpush @dates, \"\";\n\t\t\tpush @sizes, $parts[3];\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Slackware\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub debian_sizes {\n\tmy @lines = split /\\n/, &fetchdoc($_[0]);\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /download\\\">i386<\\/a/) {\n\t\t\tmy @newparts = split /\\\"size\\\"\\>|<\\/td>/, $lines[$i+3];\n\t\t\treturn &debian_size_convert($newparts[1]);\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /download\\\">all<\\/a/) {\n\t\t\tmy @newparts = split /\\\"size\\\"\\>|<\\/td>/, $lines[$i+3];\n\t\t\treturn &debian_size_convert($newparts[1]);\n\t\t}\n\t}\n}\n\nsub debian_size_convert {\n\tif ($_[0] =~ s/\\&nbsp;kB$//) {\n\t\t$_[0] =~ s/,//g;\n\t\tmy @parts = split /\\./, $_[0];\n\t\tmy @partses = split //, $parts[1];\n\t\tif ($partses[0] >= 5) {\n\t\t\t$parts[0]++;\n\t\t}\n\t\tif ($parts[0] < 1000) {\n\t\t\treturn $parts[0].\"K\";\n\t\t} else {\n\t\t\tmy $val = round($parts[0]/1024);\n\t\t\treturn $val.\"M\";\n\t\t}\n\t} else {\n\t\tdie \"Strange packet size encountered: $_[0]\\n\";\n\t}\n}\n\nsub debian {\n\tmy @dists = ($debian_current_release);\n\t&debuntu('https://packages.debian.org','Debian',\\@dists,$_[0]);\n\treturn();\n}\n\nsub ubuntu {\n\tmy @array = ($ubuntu_current_release);\n\t&debuntu('https://packages.ubuntu.com','Ubuntu',\\@array,$_[0]);\n\treturn();\n}\n\nsub debuntu {\n\tmy ($baseurl,$distname,$releaseArrayP,$searchTerm) = @_;\n\tmy @dists = @$releaseArrayP;\n\tmy @names;\n\tmy @repos;\n\tmy @groups;\n\tmy @versions;\n\tmy @urls;\n\tmy @sizes;\n\tmy @dates;\n\tfor (my $x = 0; $x < @dists; $x++) {\n\t\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"/search?keywords=\".$searchTerm.\"&searchon=names&suite=\".$dists[$x].\"&section=all\");\n\t\tfor (my $i = 50; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /<h3>Package /) {\n\t\t\t\tmy $name = (split /h3>Package |<\\/h3>/, $lines[$i])[1];\n\t\t\t\t# There are now one or more 8-line blocks that are approximately\n\t\t\t\t# $lines[$i]   <li class=\"intrepid\"><a class=\"resultlink\" href=\"/intrepid/dpkg\">intrepid</a> (base):\n\t\t\t\t# $lines[$i+3] <br>1.14.20ubuntu6: amd64 i386\n\t\t\t\t# And this list starts with <ul> and ends with </ul>\n\t\t\t\t$i += 1;\n\t\t\t\twhile (($lines[$i] !~ '</ul>') && ($i < @lines)) {\n\t\t\t\t\tif ($lines[$i] =~ /class=\"resultlink\"/) {\n\t\t\t\t\t\tpush @names, $name;\n\t\t\t\t\t\tmy @parts = split /href\\=\\\"|\\\"\\>|<\\/a\\>/, $lines[$i];\n\t\t\t\t\t\t$parts[4] =~ s/ \\(|\\)://g;\n\t\t\t\t\t\tpush @groups, $parts[4];\n\t\t\t\t\t\tpush @repos, $dists[$x];\n\t\t\t\t\t\tpush @urls,  $baseurl.$parts[2];\n\t\t\t\t\t\tpush @dates, \"\";\n\t\t\t\t\t\tmy $vline = $lines[$i+3];\n\t\t\t\t\t\t# prune possibly existing link to backports\n\t\t\t\t\t\t$vline =~ s/ *\\[.*strong.*\\]//g;\n\t\t\t\t\t\t# Split lines e.g. \"0.8.4-3+squeeze1: all\"\n\t\t\t\t\t\t@parts = split />|: /, $vline;\n\t\t\t\t\t\tpush @versions, $parts[1];\n\t\t\t\t\t\t$i += 4; # do not be too greedy\n\t\t\t\t\t} else {\n\t\t\t\t\t\t$i += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tunless ($shallow) {\n\t\tif (!$nothreads) {\n\t\t\tmy @thr;\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\tpush @thr, threads->new(\\&debian_sizes, $urls[$i]);\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @thr; $i++) {\n\t\t\t\tpush @sizes, $thr[$i]->join;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\tpush @sizes, &debian_sizes($urls[$i]);\t# TODO but we want installed size - or both?\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\tpush @sizes, \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub aur {\n\tmy $aurbase    = \"https://aur.archlinux.org\";\n\tmy @lines = split /\\n/, &fetchdoc($aurbase.\"/rpc/?v=5&type=search&arg=\".$_[0]);\n\n\tmy @repos;\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @urls;\n\tmy @sizes;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /\\{/) {\n\t\t\tmy $content = decode_json($lines[$i]);\n\t\t\tif ($content->{version} != 5 ) {\n\t\t\t\twarn (\"Unknown version\");\n\t\t\t\treturn ();\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @{$content->{results}}; $i++) {\n\t\t\t\tmy $pkg = $content->{results}[$i];\n\t\t\t\tif ($pkg->{Name} =~ $_[0]) {\n\t\t\t\t\t# push @repos, # there are no \"repos\" in AUR\n\t\t\t\t\tpush @names, $pkg->{Name};\n\t\t\t\t\tpush @versions, $pkg->{Version}; # XXX: Versions can be too long\n\t\t\t\t\t# push @sizes, # not build so size is unknown\n\t\t\t\t\t# push @dates, # not build so date is unknown\n\t\t\t\t\tpush @urls, \"$aurbase/packages/$pkg->{Name}\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @names; $i++) {\n\t\t&pretty_print($cols,@columns,\"AUR\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub human {\n        my $size = $_[0];\n\tmy @suffixes = (' ', 'K', 'M', 'G');\n\tmy $index = 0;\n\n\twhile ($size > 1024) {\n\t\t$index++;\n\t\t$size = POSIX::floor($size / 1024);\n\t}\n\treturn(\"$size@suffixes[$index]\");\n}\n\nsub arch {\n\tmy $archbase   = \"https://archlinux.org\";\n\tmy @lines = split /\\n/, &fetchdoc($archbase.\"/packages/search/json/?q=\".$_[0]);\n\n\tmy @repos;\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @urls;\n\tmy @sizes;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /\\{/) {\n\t\t\tmy $content = decode_json($lines[$i]);\n\t\t\tif ($content->{version} != 2 ) {\n\t\t\t\twarn (\"Unknown version\");\n\t\t\t\treturn ();\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @{$content->{results}}; $i++) {\n\t\t\t\tmy $pkg = $content->{results}[$i];\n\t\t\t\tif ($pkg->{pkgname} =~ $_[0]) {\n\t\t\t\t\tpush @repos, $pkg->{repo};\n\t\t\t\t\tpush @names, $pkg->{pkgname};\n\t\t\t\t\tmy $epoch = \"\";\n\t\t\t\t\tif ($pkg->{epoch} != 0) {\n\t\t\t\t\t\t$epoch = \"$pkg->{epoch}:\";\n\t\t\t\t\t}\n\t\t\t\t\tpush @versions, \"$epoch$pkg->{pkgver}-$pkg->{pkgrel}\";\n\t\t\t\t\tpush @sizes, human($pkg->{compressed_size}); # XXX: there is also installed_size\n\t\t\t\t\tpush @dates, $pkg->{build_date};\n\t\t\t\t\tpush @urls, \"$archbase/packages/$pkg->{repo}/$pkg->{arch}/$pkg->{pkgname}/\";\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Arch\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub arch_site_get_url {\n\tmy $temp = $_[0];\n\t$temp =~ s/.*\\<a href=\\\"|\\\".*//g;\n\treturn $temp;\n}\n\nsub arch_site_get_cont {\n \tmy @parts = split />/, $_[0];\n \tfor (my $i = 0; $i < @parts; $i++) {\n \t\tif ($parts[$i] =~ /^[A-Za-z0-9]/) {\n \t\t\treturn (split /</, $parts[$i])[0];\n \t\t}\n \t}\n}\n\nsub arch_site_ger_cont {\n\tmy $temp = $_[0];\n\t$temp =~ s/.*\\\"\\>|\\<\\/a.*//g;\n\treturn $temp;\n}\n\nsub aur_site_get_url {\n\treturn (split /\\'/, $_[0])[5];\n}\n\nsub fetchdoc {\n\tmy $url = $_[0];\n\tmy $silent = 0;\n\tif (@_ == 2 && $_[1] eq \"silent\") {\n\t\t$silent = 1;\n\t}\n\n\t$url =~ s/\\&amp\\;/\\&/ig;   # convert &amp; to &\n\n\tmy $ua = LWP::UserAgent->new;\n\t$ua->env_proxy;\n        my @firstline;\n        my @response;\n        for (my $count = 0; ; ++$count) {   # termination condition inside loop\n                my $req = HTTP::Request->new(GET => $url);\n                my $res = $ua->request($req)->as_string;\n                @response = split (/\\n/, $res);\n                @firstline = split (/ /, $response[0]);\n\t\tmy $restest = 0;\n\t\tif (@firstline == 3) {\n\t\t\t$restest = $firstline[1];\n\t\t} elsif (@firstline > 3) {\n\t\t\t$restest = $firstline[0];\n\t\t}\n\t\tif ($restest == 200 || $response[0] =~ /200 OK/) { #NB the matching expression added specifically for NetBSD package page!\n\t\t# server response 200 is a stringent criterion, but should work\n\t\t\tlast;\n\t\t} elsif ($count > 4) {   # loop termination condition\n\t\t\tunless ($silent == 1) {\n\t\t\t\twarn (\"Tried fetching \\\"$url\\\" five times. Giving up.\\n\");\n\t\t\t}\n\t\t\treturn ();\n\t\t\tlast;\n\t\t}\n\t}\n    my $end = @response - 1;\n    my $finaldoc = join (\"\\n\", @response[14..$end]);\n    return ($finaldoc);\n}\n\nsub pretty_print {\n\tif( $option_strict && trim($_[$cols+2]) ne $ARGV[0]) {\n\t\treturn; # strictness enabled, we should print exact matches only\n\t}\n\tmy $n = $_[0];\n\tmy @colwidths = @_[1..$n];\n\tmy @colvals = @_[($n+1)..(@_-1)];\n\tfor (my $i = 0; $i < @colwidths;$i++) {\n\t\tif (length($colvals[$i]) > $colwidths[$i]) {\n\t\t\tmy @letters = split //, $colvals[$i];\n\t\t\tprint join \"\", @letters[0..($colwidths[$i]-1)];\n\t\t\tprint \" \";\n\t\t} else {\n\t\t\tprint $colvals[$i];\n\t\t\tfor (my $a = 0; $a < $colwidths[$i] + 1 - length($colvals[$i]); $a++) {\n\t\t\t\tprint \" \";\n\t\t\t}\n\t\t}\n\t}\n\tprint $colvals[@colvals-1].\"\\n\"; #last column is unrestricted in length\n}\n\nsub trim($) {\n\t# Perl trim function to remove whitespace from the start and end of the\n\t# string\n\tmy $string = shift;\n\t$string =~ s/^\\s+//;\n\t$string =~ s/\\s+$//;\n\treturn $string;\n}\n\nsub opensuse {\n\tmy $opensusebase = \"https://software.opensuse.org\";\n\tmy @names;\n\tmy @repos;\n\tmy @groups;\n\tmy @versions;\n\tmy @urls;\n\tmy @sizes;\n\tmy @dates;\n\tmy $distroname = \"openSUSE\";\n\n\tmy @lines = split /\\n/, &fetchdoc($opensusebase.\"/search?q=\".$_[0].\"&baseproject=\".$distroname.\"&lang=en&exclude_debug=true\");\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /<div class=\"search-result-txt\"/) {\n\t\t\tmy $line = $lines[($i+1)];\n\t\t\t$line =~ s{^.*<h3><a href=\"}{};\n\t\t\t$line =~ s{</?mark>}{}g;\n\t\t\t$line =~ s{</a>.*}{};\n\t\t\tmy ($url, $name) = split /\">/, $line, 2;\n\t\t\tpush @names, $name;\n\t\t\tpush @urls, \"$opensusebase$url\";\n\t\t\tpush @versions, '';\n\t\t\tpush @sizes,  '';\n\t\t\tpush @dates,  '';\n\t\t\tpush @groups, '';\n\t\t\tpush @repos, '';\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn();\n}\n\nsub netbsd_pkgsrc_size {\n\tmy @retvals;\n\tmy $continueAt = 0;\n\tmy @lines = split /\\n|<br\\/>/, &fetchdoc($_[0]);\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /Filesize:/) {\n\t\t\tmy @parts = split /<\\/b> /, $lines[$i];\n\t\t\tpush @retvals, &sizeconvert($parts[1]);\n\t\t\t$continueAt = $i;\n\t\t\tlast;\n\t\t}\n\t}\n\tif ($continueAt == 0) {\n\t\tpush @retvals, \"\";\n\t}\n\t$retvals[1] = \"\"; #just in case there's no match found\n\tfor (my $i = $continueAt; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /Updated to version|Package added to/) {\n\t\t\tmy @parts = split /<b>|<\\/b>/, $lines[$i];\n\t\t\t$retvals[1] = $parts[1];\n\t\t\tlast;\n\t\t}\n\t}\n\treturn @retvals;\n}\n\nsub round {\n    my($number) = shift;\n    return int($number + .5);\n}\n\nsub sizeconvert {\n\tif ($_[0] =~ s/ KB$//) {\n\t\tmy @parts = split /\\./, $_[0];\n\t\tmy @partses = split //, $parts[1];\n\t\tif ($partses[0] >= 5) {\n\t\t\t$parts[0]++;\n\t\t}\n\t\tif ($parts[0] < 1000) {\n\t\t\treturn $parts[0].\"K\";\n\t\t} else {\n\t\t\tmy $val = round($parts[0]/1024);\n\t\t\treturn $val.\"M\";\n\t\t}\n\t} else {\n\t\tdie \"Strange packet size encountered: $_[0]\\n\";\n\t}\n}\n\nsub netbsd {\n\tmy @lines = split /\\n|<br\\/>/, &fetchdoc(\"https://pkgsrc.se/search.php?so=\".$_[0]);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tfor (my $i = 0; $i < @lines; $i++) {\n\t\tif ($lines[$i] =~ /version.+maintainer/) {\n\t\t\tmy @parts = split /href=\"|<\\/a>, <em><b>version |<\\/b>, maintainer|\\\">/, $lines[$i];\n\t\t\tpush @urls, \t$parts[1];\n\t\t\tpush @versions, $parts[3];\n\t\t\tmy @subparts = split /\\//, $parts[2];\n\t\t\tpush @repos, $subparts[0];\n\t\t\tpush @names, $subparts[1];\n\t\t}\n\t}\n\tunless ($shallow) {\n\t\tif (!$nothreads) {\n\t\t\tmy @thr;\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\tpush @thr, threads->new(\\&netbsd_pkgsrc_size, $urls[$i]);\n\t\t\t}\n\t\t\tfor (my $i = 0; $i < @thr; $i++) {\n\t\t\t\t($sizes[$i],$dates[$i]) = $thr[$i]->join;\n\t\t\t}\n\t\t} else {\n\t\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t\t($sizes[$i],$dates[$i]) = &netbsd_pkgsrc_size($urls[$i]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t\t($sizes[$i],$dates[$i]) = (\"\",\"\");\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"NetBSD\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn();\n}\n\nsub fedora_admin {\n# THIS is a possibility, but offers no date or size info\n\tmy $query = \"https://admin.fedoraproject.org/pkgdb/search/package/?searchwords=\".$_[0].\"&operator=AND&release=19&searchon=name\";\n\tmy @lines = split /\\n/, &fetchdoc($query);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy $now = 0;\n\tfor (my $i = 0; $i<@lines; $i++) {\n\t\tif ($lines[$i] =~ /unique_tag/) {\n\t\t\t# typically, this is where most of the text processing goes:\n\t\t\t# getting the info and putting it in appropriate arrays\n\n\t\t\t# use subroutine \"combos\" if the name and version are represented as, firefox-1.0.6, with the hyphen, and the version number starting with a digit\n\t\t\tmy $anchor = \"something\";\n\t\t\t($names[$now],$versions[$now]) = &combos($anchor);\n\t\t\t$now++;\n\t\t\tpush @names,    \"\";\n\t\t\tpush @versions, \"\";\n\t\t\tpush @repos,    \"\";\n\t\t\tpush @sizes,    \"\";\n\t\t\tpush @urls,     \"\";\n\t\t\tpush @dates,    \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Distroname\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub template_query {\n\tmy $query = \"url\";\n\tmy @lines = split /\\n/, &fetchdoc($query);\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\tmy $now = 0;\n\tfor (my $i = 0; $i<@lines; $i++) {\n\t\tif ($lines[$i] =~ /unique_tag/) {\n\t\t\t# typically, this is where most of the text processing goes:\n\t\t\t# getting the info and putting it in appropriate arrays\n\n\t\t\t# use subroutine \"combos\" if the name and version are represented as, firefox-1.0.6, with the hyphen, and the version number starting with a digit\n\t\t\tmy $anchor = \"something\";\n\t\t\t($names[$now],$versions[$now]) = &combos($anchor);\n\t\t\t$now++;\n\t\t\tpush @names,    \"\";\n\t\t\tpush @versions, \"\";\n\t\t\tpush @repos,    \"\";\n\t\t\tpush @sizes,    \"\";\n\t\t\tpush @urls,     \"\";\n\t\t\tpush @dates,    \"\";\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,\"Distroname\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub template_listing {\n\tmy @ininames;\n\tmy @iniversions;\n\tmy @iniurls;\n\tmy @inirepos;\n\tmy @inisizes;\n\tmy @inidates;\n\tmy $now = 0;\n\tmy $distroname = \"mydistro\";\n\tmy $base = \"url\";\n\t# prepare a list file\n\tmy $file = \"$confdir/$distroname.list\";\n\t# if the list file exists and is recent, use its contents, otherwise download and parse a fresh copy\n\tif (-s $file && `date +%Y-%m-%d` =~ (split / /, `ls -l $file`)[6]) {\n\t\topen IN, $file;\n\t\tchomp (my @lines = <IN>);\n\t\tfor (my $i = 0; $i<@lines;$i++) {\n\t\t\t# get back any info that you put in the file\n\t\t\t($ininames[$i],$iniversions[$i],$iniurls[$i]) = split /\\t/, $lines[$i];\n\t\t}\n\t\tclose IN;\n\t} else {\n\t\t# download fresh copy\n\t\tmy @lines = split /\\n/, &fetchdoc($base.\"README-all.html\");\n\t\tfor (my $i = 0; $i < @lines; $i++) {\n\t\t\tif ($lines[$i] =~ /unique_tag/) {\n\t\t\t\t# extract all info from the downloaded list\n\t\t\t\tmy @parts = split / /, $lines[$i];\n\t\t\t\t# use subroutine \"combos\" to separate name and version number\n\t\t\t\t($ininames[$now],$iniversions[$now]) = &combos($parts[1]);\n\t\t\t\t$now++;\n\t\t\t\t# any info you couldn't get, put a blank in\n\t\t\t\tpush @iniurls,  \"\";\n\t\t\t\tpush @inirepos, \"\";\n\t\t\t\tpush @inisizes, \"\";\n\t\t\t\tpush @inidates, \"\";\n\t\t\t}\n\t\t}\n\t\topen OUT, \">$file\";\n\t\tfor (my $i = 0; $i < @iniurls;$i++) {\n\t\t\t# store the available info in the file\n\t\t\tprint OUT \"$ininames[$i]\\t$iniversions[$i]\\t$iniurls[$i]\\n\";\n\t\t}\n\t\tclose OUT;\n\t}\n\t# search by hand\n\tmy ($p1,$p2,$p3,$p4,$p5,$p6) = &search_by_name(\\@ininames,\\@iniversions,\\@inisizes,\\@inidates,\\@inirepos,\\@iniurls,$_[0]);\n\tmy @names    = @$p1;\n\tmy @versions = @$p2;\n\tmy @sizes    = @$p3;\n\tmy @dates    = @$p4;\n\tmy @repos    = @$p5;\n\tmy @urls     = @$p6;\n\tfor (my $i = 0; $i < @repos; $i++) {\n\t\t&pretty_print($cols,@columns,$distroname,$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n\nsub mandriva_combos {\n\t$_[0] =~ s/\\<\\/a\\>.*//;\n\tmy @parts = split /-/, $_[0];\n\tfor (my $i = 1; $i < @parts; $i++) {\n\t\tif ($parts[$i] =~ /^[0-9]/) {\n\t\t\treturn ( (join '-',@parts[0..($i-1)]), (join '-', @parts[$i..(@parts-1)]) );\n\t\t}\n\t}\n}\n\nsub mandriva {\n\tmy $baseurl = \"http://sophie.zarb.org\";\n\tmy @names;\n\tmy @versions;\n\tmy @dates;\n\tmy @sizes;\n\tmy @repos;\n\tmy @urls;\n\t# NB this server also supports exact matching\n\tmy @lines = split /\\n/, &fetchdoc($baseurl.\"/search?search=\".$_[0].\"&type=fuzzyname&deptype=P&distribution=Mandriva&release=current\");\n\tfor (my $i = 350; $i < @lines; $i++) {\n\t\t#TODO need to check for possible further pages (lists 20 per page)\n\t\t#TODO ajax or xml::rpc access might have advantages w.r.t. paging (i.e. none required) \n\t\tif ($lines[$i] =~ /<div class=\"sophie_search_list\">/) {\n\t\t\tmy $a = @names;\n\t\t\tpush @urls, (split /\"/, $lines[$i+1])[1];\n\t\t\t($names[$a],$versions[$a]) = &mandriva_combos($lines[$i+2]); # name, version, arch\n\t\t}\n\t}\n\tfor (my $i = 0; $i < @urls; $i++) {\n\t\t&pretty_print($cols,@columns,\"Mandriva\",$names[$i],$versions[$i],$sizes[$i],$dates[$i],$repos[$i],$urls[$i]);\n\t}\n\treturn ();\n}\n"], "filenames": ["whohas"], "buggy_code_start_loc": [190], "buggy_code_end_loc": [1242], "fixing_code_start_loc": [190], "fixing_code_end_loc": [1242], "type": "CWE-319", "message": "** DISPUTED ** A vulnerability was found in whohas. It has been rated as problematic. This issue affects some unknown processing of the component Package Information Handler. The manipulation leads to cleartext transmission of sensitive information. The attack may be initiated remotely. The real existence of this vulnerability is still doubted at the moment. The name of the patch is 667c3e2e9178f15c23d7918b5db25cd0792c8472. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216251. NOTE: Most sources redirect to the encrypted site which limits the possibilities of an attack.", "other": {"cve": {"id": "CVE-2021-4258", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-19T14:15:10.383", "lastModified": "2022-12-27T17:58:42.480", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "** DISPUTED ** A vulnerability was found in whohas. It has been rated as problematic. This issue affects some unknown processing of the component Package Information Handler. The manipulation leads to cleartext transmission of sensitive information. The attack may be initiated remotely. The real existence of this vulnerability is still doubted at the moment. The name of the patch is 667c3e2e9178f15c23d7918b5db25cd0792c8472. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-216251. NOTE: Most sources redirect to the encrypted site which limits the possibilities of an attack."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-319"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-310"}, {"lang": "en", "value": "CWE-319"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:whohas_project:whohas:*:*:*:*:*:*:*:*", "versionEndExcluding": "2021-11-01", "matchCriteriaId": "3260C8E2-6A86-4CA6-834C-265BAB0E4FE8"}]}]}], "references": [{"url": "https://github.com/whohas/whohas/commit/667c3e2e9178f15c23d7918b5db25cd0792c8472", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.216251", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory", "VDB Entry"]}]}, "github_commit_url": "https://github.com/whohas/whohas/commit/667c3e2e9178f15c23d7918b5db25cd0792c8472"}}