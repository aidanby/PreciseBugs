{"buggy_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Codec\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CODEC_NSCODEC_H\n#define FREERDP_CODEC_NSCODEC_H\n\n#include <freerdp/api.h>\n#include <freerdp/types.h>\n#include <freerdp/constants.h>\n\n#include <winpr/stream.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct _NSC_MESSAGE\n{\n\tUINT32 x;\n\tUINT32 y;\n\tUINT32 width;\n\tUINT32 height;\n\tconst BYTE* data;\n\tUINT32 scanline;\n\tBYTE* PlaneBuffer;\n\tUINT32 MaxPlaneSize;\n\tBYTE* PlaneBuffers[5];\n\tUINT32 OrgByteCount[4];\n\n\tUINT32 LumaPlaneByteCount;\n\tUINT32 OrangeChromaPlaneByteCount;\n\tUINT32 GreenChromaPlaneByteCount;\n\tUINT32 AlphaPlaneByteCount;\n\tUINT32 ColorLossLevel;\n\tUINT32 ChromaSubsamplingLevel;\n};\ntypedef struct _NSC_MESSAGE NSC_MESSAGE;\n\ntypedef struct _NSC_CONTEXT_PRIV NSC_CONTEXT_PRIV;\n\ntypedef struct _NSC_CONTEXT NSC_CONTEXT;\n\nstruct _NSC_CONTEXT\n{\n\tUINT32 OrgByteCount[4];\n\tUINT32 format;\n\tUINT16 width;\n\tUINT16 height;\n\tBYTE* BitmapData;\n\tUINT32 BitmapDataLength;\n\n\tBYTE* Planes;\n\tUINT32 PlaneByteCount[4];\n\tUINT32 ColorLossLevel;\n\tUINT32 ChromaSubsamplingLevel;\n\tBOOL DynamicColorFidelity;\n\n\t/* color palette allocated by the application */\n\tconst BYTE* palette;\n\n\tvoid (*decode)(NSC_CONTEXT* context);\n\tvoid (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData,\n\t               UINT32 rowstride);\n\n\tNSC_CONTEXT_PRIV* priv;\n};\n\nFREERDP_API BOOL nsc_context_set_pixel_format(NSC_CONTEXT* context,\n        UINT32 pixel_format);\nFREERDP_API BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,\n                                     UINT32 width, UINT32 height,\n                                     const BYTE* data, UINT32 length,\n                                     BYTE* pDstData, UINT32 DstFormat,\n                                     UINT32 nDstStride, UINT32 nXDst, UINT32 nYDst,\n                                     UINT32 nWidth, UINT32 nHeight, UINT32 flip);\nFREERDP_API BOOL nsc_compose_message(NSC_CONTEXT* context, wStream* s,\n                                     const BYTE* bmpdata,\n                                     UINT32 width, UINT32 height, UINT32 rowstride);\n\nFREERDP_API NSC_MESSAGE* nsc_encode_messages(NSC_CONTEXT* context,\n        const BYTE* data,\n        UINT32 x, UINT32 y,\n        UINT32 width, UINT32 height, UINT32 scanline,\n        UINT32* numMessages, UINT32 maxDataSize);\nFREERDP_API BOOL nsc_write_message(NSC_CONTEXT* context, wStream* s,\n                                   NSC_MESSAGE* message);\nFREERDP_API void nsc_message_free(NSC_CONTEXT* context, NSC_MESSAGE* message);\n\nFREERDP_API BOOL nsc_context_reset(NSC_CONTEXT* context, UINT32 width,\n                                   UINT32 height);\n\nFREERDP_API NSC_CONTEXT* nsc_context_new(void);\nFREERDP_API void nsc_context_free(NSC_CONTEXT* context);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* FREERDP_CODEC_NSCODEC_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Codec\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/codec/nsc.h>\n#include <freerdp/codec/color.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_encode.h\"\n\n#include \"nsc_sse2.h\"\n\n#ifndef NSC_INIT_SIMD\n#define NSC_INIT_SIMD(_nsc_context) do { } while (0)\n#endif\n\nstatic void nsc_decode(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw = ROUND_UP_TO(context->width, 8);\n\tBYTE shift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n\tBYTE* bmpdata = context->BitmapData;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tconst BYTE* yplane;\n\t\tconst BYTE* coplane;\n\t\tconst BYTE* cgplane;\n\t\tconst BYTE* aplane = context->priv->PlaneBuffers[3] + y * context->width; /* A */\n\n\t\tif (context->ChromaSubsamplingLevel)\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * rw; /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + (y >> 1) * (rw >>\n\t\t\t          1); /* Co, supersampled */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + (y >> 1) * (rw >>\n\t\t\t          1); /* Cg, supersampled */\n\t\t}\n\t\telse\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * context->width; /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + y * context->width; /* Co */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + y * context->width; /* Cg */\n\t\t}\n\n\t\tfor (x = 0; x < context->width; x++)\n\t\t{\n\t\t\tINT16 y_val = (INT16) * yplane;\n\t\t\tINT16 co_val = (INT16)(INT8)(*coplane << shift);\n\t\t\tINT16 cg_val = (INT16)(INT8)(*cgplane << shift);\n\t\t\tINT16 r_val = y_val + co_val - cg_val;\n\t\t\tINT16 g_val = y_val + cg_val;\n\t\t\tINT16 b_val = y_val - co_val - cg_val;\n\t\t\t*bmpdata++ = MINMAX(b_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(g_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(r_val, 0, 0xFF);\n\t\t\t*bmpdata++ = *aplane;\n\t\t\typlane++;\n\t\t\tcoplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\tcgplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\taplane++;\n\t\t}\n\t}\n}\n\nstatic void nsc_rle_decode(BYTE* in, BYTE* out, UINT32 originalSize)\n{\n\tUINT32 len;\n\tUINT32 left;\n\tBYTE value;\n\tleft = originalSize;\n\n\twhile (left > 4)\n\t{\n\t\tvalue = *in++;\n\n\t\tif (left == 5)\n\t\t{\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32) * in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = *((UINT32*) in);\n\t\t\t\tin += 4;\n\t\t\t}\n\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\n\t*((UINT32*)out) = *((UINT32*)in);\n}\n\nstatic void nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\trle = context->Planes;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\t\tplaneSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\telse if (planeSize < originalSize)\n\t\t\tnsc_rle_decode(rle, context->priv->PlaneBuffers[i], originalSize);\n\t\telse\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\n\t\trle += planeSize;\n\t}\n}\n\nstatic BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tint i;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < 4; i++)\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\n\tStream_Read_UINT8(s, context->ColorLossLevel); /* ColorLossLevel (1 byte) */\n\tStream_Read_UINT8(s,\n\t                  context->ChromaSubsamplingLevel); /* ChromaSubsamplingLevel (1 byte) */\n\tStream_Seek(s, 2); /* Reserved (2 bytes) */\n\tcontext->Planes = Stream_Pointer(s);\n\treturn TRUE;\n}\n\nstatic BOOL nsc_context_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tint i;\n\tUINT32 length;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\n\tif (!nsc_stream_initialize(context, s))\n\t\treturn FALSE;\n\n\tlength = context->width * context->height * 4;\n\n\tif (!context->BitmapData)\n\t{\n\t\tcontext->BitmapData = calloc(1, length + 16);\n\n\t\tif (!context->BitmapData)\n\t\t\treturn FALSE;\n\n\t\tcontext->BitmapDataLength = length;\n\t}\n\telse if (length > context->BitmapDataLength)\n\t{\n\t\tvoid* tmp;\n\t\ttmp = realloc(context->BitmapData, length + 16);\n\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\n\t\tcontext->BitmapData = tmp;\n\t\tcontext->BitmapDataLength = length;\n\t}\n\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tlength = tempWidth * tempHeight;\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 4; i++)\n\t\t{\n\t\t\tvoid* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n\n\t\t\tif (!tmp)\n\t\t\t\treturn FALSE;\n\n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = length;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tcontext->OrgByteCount[i] = context->width * context->height;\n\t}\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = (tempWidth >> 1) * (tempHeight >> 1);\n\t\tcontext->OrgByteCount[2] = context->OrgByteCount[1];\n\t}\n\n\treturn TRUE;\n}\n\nstatic void nsc_profiler_print(NSC_CONTEXT_PRIV* priv)\n{\n\tPROFILER_PRINT_HEADER\n\tPROFILER_PRINT(priv->prof_nsc_rle_decompress_data)\n\tPROFILER_PRINT(priv->prof_nsc_decode)\n\tPROFILER_PRINT(priv->prof_nsc_rle_compress_data)\n\tPROFILER_PRINT(priv->prof_nsc_encode)\n\tPROFILER_PRINT_FOOTER\n}\n\nBOOL nsc_context_reset(NSC_CONTEXT* context, UINT32 width, UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->width = width;\n\tcontext->height = height;\n\treturn TRUE;\n}\n\nNSC_CONTEXT* nsc_context_new(void)\n{\n\tNSC_CONTEXT* context;\n\tcontext = (NSC_CONTEXT*) calloc(1, sizeof(NSC_CONTEXT));\n\n\tif (!context)\n\t\treturn NULL;\n\n\tcontext->priv = (NSC_CONTEXT_PRIV*) calloc(1, sizeof(NSC_CONTEXT_PRIV));\n\n\tif (!context->priv)\n\t\tgoto error;\n\n\tcontext->priv->log = WLog_Get(\"com.freerdp.codec.nsc\");\n\tWLog_OpenAppender(context->priv->log);\n\tcontext->BitmapData = NULL;\n\tcontext->decode = nsc_decode;\n\tcontext->encode = nsc_encode;\n\tcontext->priv->PlanePool = BufferPool_New(TRUE, 0, 16);\n\n\tif (!context->priv->PlanePool)\n\t\tgoto error;\n\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_decompress_data,\n\t                \"nsc_rle_decompress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_decode, \"nsc_decode\")\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_compress_data,\n\t                \"nsc_rle_compress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_encode, \"nsc_encode\")\n\t/* Default encoding parameters */\n\tcontext->ColorLossLevel = 3;\n\tcontext->ChromaSubsamplingLevel = 1;\n\t/* init optimized methods */\n\tNSC_INIT_SIMD(context);\n\treturn context;\nerror:\n\tnsc_context_free(context);\n\treturn NULL;\n}\n\nvoid nsc_context_free(NSC_CONTEXT* context)\n{\n\tsize_t i;\n\n\tif (!context)\n\t\treturn;\n\n\tif (context->priv)\n\t{\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tfree(context->priv->PlaneBuffers[i]);\n\n\t\tBufferPool_Free(context->priv->PlanePool);\n\t\tnsc_profiler_print(context->priv);\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_decompress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_decode)\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_compress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_encode)\n\t\tfree(context->priv);\n\t}\n\n\tfree(context->BitmapData);\n\tfree(context);\n}\n\nBOOL nsc_context_set_pixel_format(NSC_CONTEXT* context, UINT32 pixel_format)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->format = pixel_format;\n\treturn TRUE;\n}\n\nBOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,\n                         UINT32 width, UINT32 height,\n                         const BYTE* data, UINT32 length,\n                         BYTE* pDstData, UINT32 DstFormat,\n                         UINT32 nDstStride,\n                         UINT32 nXDst, UINT32 nYDst, UINT32 nWidth,\n                         UINT32 nHeight, UINT32 flip)\n{\n\twStream* s;\n\tBOOL ret;\n\ts = Stream_New((BYTE*)data, length);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (nDstStride == 0)\n\t\tnDstStride = nWidth * GetBytesPerPixel(DstFormat);\n\n\tswitch (bpp)\n\t{\n\t\tcase 32:\n\t\t\tcontext->format = PIXEL_FORMAT_BGRA32;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR24;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR16;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tcontext->format = PIXEL_FORMAT_RGB8;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tcontext->format = PIXEL_FORMAT_A4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tStream_Free(s, TRUE);\n\t\t\treturn FALSE;\n\t}\n\n\tcontext->width = width;\n\tcontext->height = height;\n\tret = nsc_context_initialize(context, s);\n\tStream_Free(s, FALSE);\n\n\tif (!ret)\n\t\treturn FALSE;\n\n\t/* RLE decode */\n\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n\tnsc_rle_decompress_data(context);\n\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n\t/* Colorloss recover, Chroma supersample and AYCoCg to ARGB Conversion in one step */\n\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n\tcontext->decode(context);\n\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n\n\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,\n\t                        width, height, context->BitmapData,\n\t                        PIXEL_FORMAT_BGRA32, 0, 0, 0, NULL, flip))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Encoder\n *\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/codec/nsc.h>\n#include <freerdp/codec/color.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_encode.h\"\n\nstatic BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n{\n\tint i;\n\tUINT32 length;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tlength = tempWidth * tempHeight + 16;\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 5; i++)\n\t\t{\n\t\t\tBYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n\t\t\tif (!tmp)\n\t\t\t\tgoto fail;\n\n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = length;\n\t}\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[2] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\telse\n\t{\n\t\tcontext->OrgByteCount[0] = context->width * context->height;\n\t\tcontext->OrgByteCount[1] = context->width * context->height;\n\t\tcontext->OrgByteCount[2] = context->width * context->height;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\n\treturn TRUE;\nfail:\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tfree(context->priv->PlaneBuffers[i]);\n\t}\n\n\treturn FALSE;\n}\n\nstatic void nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n                                      UINT32 scanline)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE ccl;\n\tconst BYTE* src;\n\tBYTE* yplane = NULL;\n\tBYTE* coplane = NULL;\n\tBYTE* cgplane = NULL;\n\tBYTE* aplane = NULL;\n\tINT16 r_val;\n\tINT16 g_val;\n\tINT16 b_val;\n\tBYTE a_val;\n\tUINT32 tempWidth;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\trw = (context->ChromaSubsamplingLevel ? tempWidth : context->width);\n\tccl = context->ColorLossLevel;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tsrc = data + (context->height - 1 - y) * scanline;\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\taplane = context->priv->PlaneBuffers[3] + y * context->width;\n\n\t\tfor (x = 0; x < context->width; x++)\n\t\t{\n\t\t\tswitch (context->format)\n\t\t\t{\n\t\t\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tsrc++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\ta_val = *src++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBX32:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tsrc++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBA32:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\ta_val = *src++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR24:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB24:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR16:\n\t\t\t\t\tb_val = (INT16)(((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5));\n\t\t\t\t\tg_val = (INT16)((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3));\n\t\t\t\t\tr_val = (INT16)((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07));\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tsrc += 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB16:\n\t\t\t\t\tr_val = (INT16)(((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5));\n\t\t\t\t\tg_val = (INT16)((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3));\n\t\t\t\t\tb_val = (INT16)((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07));\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tsrc += 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_A4:\n\t\t\t\t\t{\n\t\t\t\t\t\tint shift;\n\t\t\t\t\t\tBYTE idx;\n\t\t\t\t\t\tshift = (7 - (x % 8));\n\t\t\t\t\t\tidx = ((*src) >> shift) & 1;\n\t\t\t\t\t\tidx |= (((*(src + 1)) >> shift) & 1) << 1;\n\t\t\t\t\t\tidx |= (((*(src + 2)) >> shift) & 1) << 2;\n\t\t\t\t\t\tidx |= (((*(src + 3)) >> shift) & 1) << 3;\n\t\t\t\t\t\tidx *= 3;\n\t\t\t\t\t\tr_val = (INT16) context->palette[idx];\n\t\t\t\t\t\tg_val = (INT16) context->palette[idx + 1];\n\t\t\t\t\t\tb_val = (INT16) context->palette[idx + 2];\n\n\t\t\t\t\t\tif (shift == 0)\n\t\t\t\t\t\t\tsrc += 4;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint idx = (*src) * 3;\n\t\t\t\t\t\tr_val = (INT16) context->palette[idx];\n\t\t\t\t\t\tg_val = (INT16) context->palette[idx + 1];\n\t\t\t\t\t\tb_val = (INT16) context->palette[idx + 2];\n\t\t\t\t\t\tsrc++;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tr_val = g_val = b_val = a_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t*yplane++ = (BYTE)((r_val >> 2) + (g_val >> 1) + (b_val >> 2));\n\t\t\t/* Perform color loss reduction here */\n\t\t\t*coplane++ = (BYTE)((r_val - b_val) >> ccl);\n\t\t\t*cgplane++ = (BYTE)((-(r_val >> 1) + g_val - (b_val >> 1)) >> ccl);\n\t\t\t*aplane++ = a_val;\n\t\t}\n\n\t\tif (context->ChromaSubsamplingLevel && (x % 2) == 1)\n\t\t{\n\t\t\t*yplane = *(yplane - 1);\n\t\t\t*coplane = *(coplane - 1);\n\t\t\t*cgplane = *(cgplane - 1);\n\t\t}\n\t}\n\n\tif (context->ChromaSubsamplingLevel && (y % 2) == 1)\n\t{\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\tCopyMemory(yplane, yplane - rw, rw);\n\t\tCopyMemory(coplane, coplane - rw, rw);\n\t\tCopyMemory(cgplane, cgplane - rw, rw);\n\t}\n}\n\nstatic void nsc_encode_subsampling(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tBYTE* co_dst;\n\tBYTE* cg_dst;\n\tINT8* co_src0;\n\tINT8* co_src1;\n\tINT8* cg_src0;\n\tINT8* cg_src1;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\n\tfor (y = 0; y < tempHeight >> 1; y++)\n\t{\n\t\tco_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n\t\tcg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n\t\tco_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n\t\tco_src1 = co_src0 + tempWidth;\n\t\tcg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n\t\tcg_src1 = cg_src0 + tempWidth;\n\n\t\tfor (x = 0; x < tempWidth >> 1; x++)\n\t\t{\n\t\t\t*co_dst++ = (BYTE)(((INT16) * co_src0 + (INT16) * (co_src0 + 1) +\n\t\t\t                    (INT16) * co_src1 + (INT16) * (co_src1 + 1)) >> 2);\n\t\t\t*cg_dst++ = (BYTE)(((INT16) * cg_src0 + (INT16) * (cg_src0 + 1) +\n\t\t\t                    (INT16) * cg_src1 + (INT16) * (cg_src1 + 1)) >> 2);\n\t\t\tco_src0 += 2;\n\t\t\tco_src1 += 2;\n\t\t\tcg_src0 += 2;\n\t\t\tcg_src1 += 2;\n\t\t}\n\t}\n}\n\nvoid nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tnsc_encode_argb_to_aycocg(context, bmpdata, rowstride);\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tnsc_encode_subsampling(context);\n\t}\n}\n\nstatic UINT32 nsc_rle_encode(BYTE* in, BYTE* out, UINT32 originalSize)\n{\n\tUINT32 left;\n\tUINT32 runlength = 1;\n\tUINT32 planeSize = 0;\n\tleft = originalSize;\n\n\t/**\n\t * We quit the loop if the running compressed size is larger than the original.\n\t * In such cases data will be sent uncompressed.\n\t */\n\twhile (left > 4 && planeSize < originalSize - 4)\n\t{\n\t\tif (left > 5 && *in == *(in + 1))\n\t\t{\n\t\t\trunlength++;\n\t\t}\n\t\telse if (runlength == 1)\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\tplaneSize++;\n\t\t}\n\t\telse if (runlength < 256)\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\t*out++ = *in;\n\t\t\t*out++ = runlength - 2;\n\t\t\trunlength = 1;\n\t\t\tplaneSize += 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\t*out++ = *in;\n\t\t\t*out++ = 0xFF;\n\t\t\t*out++ = (runlength & 0x000000FF);\n\t\t\t*out++ = (runlength & 0x0000FF00) >> 8;\n\t\t\t*out++ = (runlength & 0x00FF0000) >> 16;\n\t\t\t*out++ = (runlength & 0xFF000000) >> 24;\n\t\t\trunlength = 1;\n\t\t\tplaneSize += 7;\n\t\t}\n\n\t\tin++;\n\t\tleft--;\n\t}\n\n\tif (planeSize < originalSize - 4)\n\t\tCopyMemory(out, in, 4);\n\n\tplaneSize += 4;\n\treturn planeSize;\n}\n\nstatic void nsc_rle_compress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\n\t\tif (originalSize == 0)\n\t\t{\n\t\t\tplaneSize = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplaneSize = nsc_rle_encode(context->priv->PlaneBuffers[i],\n\t\t\t                           context->priv->PlaneBuffers[4], originalSize);\n\n\t\t\tif (planeSize < originalSize)\n\t\t\t\tCopyMemory(context->priv->PlaneBuffers[i], context->priv->PlaneBuffers[4],\n\t\t\t\t           planeSize);\n\t\t\telse\n\t\t\t\tplaneSize = originalSize;\n\t\t}\n\n\t\tcontext->PlaneByteCount[i] = planeSize;\n\t}\n}\n\nUINT32 nsc_compute_byte_count(NSC_CONTEXT* context, UINT32* ByteCount,\n                              UINT32 width, UINT32 height)\n{\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\tUINT32 maxPlaneSize;\n\ttempWidth = ROUND_UP_TO(width, 8);\n\ttempHeight = ROUND_UP_TO(height, 2);\n\tmaxPlaneSize = tempWidth * tempHeight + 16;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tByteCount[0] = tempWidth * height;\n\t\tByteCount[1] = tempWidth * tempHeight / 4;\n\t\tByteCount[2] = tempWidth * tempHeight / 4;\n\t\tByteCount[3] = width * height;\n\t}\n\telse\n\t{\n\t\tByteCount[0] = width * height;\n\t\tByteCount[1] = width * height;\n\t\tByteCount[2] = width * height;\n\t\tByteCount[3] = width * height;\n\t}\n\n\treturn maxPlaneSize;\n}\n\nNSC_MESSAGE* nsc_encode_messages(NSC_CONTEXT* context, const BYTE* data,\n                                 UINT32 x, UINT32 y, UINT32 width, UINT32 height,\n                                 UINT32 scanline, UINT32* numMessages,\n                                 UINT32 maxDataSize)\n{\n\tUINT32 i, j, k;\n\tUINT32 dataOffset;\n\tUINT32 rows, cols;\n\tUINT32 BytesPerPixel;\n\tUINT32 MaxRegionWidth;\n\tUINT32 MaxRegionHeight;\n\tUINT32 ByteCount[4];\n\tUINT32 MaxPlaneSize;\n\tUINT32 MaxMessageSize;\n\tNSC_MESSAGE* messages;\n\tUINT32 PaddedMaxPlaneSize;\n\tk = 0;\n\tMaxRegionWidth = 64 * 4;\n\tMaxRegionHeight = 64 * 2;\n\tBytesPerPixel = GetBytesPerPixel(context->format);\n\trows = (width + (MaxRegionWidth - (width % MaxRegionWidth))) / MaxRegionWidth;\n\tcols = (height + (MaxRegionHeight - (height % MaxRegionHeight))) /\n\t       MaxRegionHeight;\n\t*numMessages = rows * cols;\n\tMaxPlaneSize = nsc_compute_byte_count(context, (UINT32*) ByteCount, width,\n\t                                      height);\n\tMaxMessageSize = ByteCount[0] + ByteCount[1] + ByteCount[2] + ByteCount[3] + 20;\n\tmaxDataSize -= 1024; /* reserve enough space for headers */\n\tmessages = (NSC_MESSAGE*) calloc(*numMessages, sizeof(NSC_MESSAGE));\n\n\tif (!messages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < rows; i++)\n\t{\n\t\tfor (j = 0; j < cols; j++)\n\t\t{\n\t\t\tmessages[k].x = x + (i * MaxRegionWidth);\n\t\t\tmessages[k].y = y + (j * MaxRegionHeight);\n\t\t\tmessages[k].width = (i < (rows - 1)) ? MaxRegionWidth : width -\n\t\t\t                    (i * MaxRegionWidth);\n\t\t\tmessages[k].height = (j < (cols - 1)) ? MaxRegionHeight : height -\n\t\t\t                     (j * MaxRegionHeight);\n\t\t\tmessages[k].data = data;\n\t\t\tmessages[k].scanline = scanline;\n\t\t\tmessages[k].MaxPlaneSize = nsc_compute_byte_count(context,\n\t\t\t                           (UINT32*) messages[k].OrgByteCount, messages[k].width, messages[k].height);\n\t\t\tk++;\n\t\t}\n\t}\n\n\t*numMessages = k;\n\n\tfor (i = 0; i < *numMessages; i++)\n\t{\n\t\tPaddedMaxPlaneSize = messages[i].MaxPlaneSize + 32;\n\t\tmessages[i].PlaneBuffer = (BYTE*) BufferPool_Take(context->priv->PlanePool,\n\t\t                          PaddedMaxPlaneSize * 5);\n\n\t\tif (!messages[i].PlaneBuffer)\n\t\t\tgoto fail;\n\n\t\tmessages[i].PlaneBuffers[0] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 0) + 16]);\n\t\tmessages[i].PlaneBuffers[1] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 1) + 16]);\n\t\tmessages[i].PlaneBuffers[2] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 2) + 16]);\n\t\tmessages[i].PlaneBuffers[3] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 3) + 16]);\n\t\tmessages[i].PlaneBuffers[4] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 4) + 16]);\n\t}\n\n\tfor (i = 0; i < *numMessages; i++)\n\t{\n\t\tcontext->width = messages[i].width;\n\t\tcontext->height = messages[i].height;\n\t\tcontext->OrgByteCount[0] = messages[i].OrgByteCount[0];\n\t\tcontext->OrgByteCount[1] = messages[i].OrgByteCount[1];\n\t\tcontext->OrgByteCount[2] = messages[i].OrgByteCount[2];\n\t\tcontext->OrgByteCount[3] = messages[i].OrgByteCount[3];\n\t\tcontext->priv->PlaneBuffersLength = messages[i].MaxPlaneSize;\n\t\tcontext->priv->PlaneBuffers[0] = messages[i].PlaneBuffers[0];\n\t\tcontext->priv->PlaneBuffers[1] = messages[i].PlaneBuffers[1];\n\t\tcontext->priv->PlaneBuffers[2] = messages[i].PlaneBuffers[2];\n\t\tcontext->priv->PlaneBuffers[3] = messages[i].PlaneBuffers[3];\n\t\tcontext->priv->PlaneBuffers[4] = messages[i].PlaneBuffers[4];\n\t\tdataOffset = (messages[i].y * messages[i].scanline) + (messages[i].x *\n\t\t             BytesPerPixel);\n\t\tPROFILER_ENTER(context->priv->prof_nsc_encode)\n\t\tcontext->encode(context, &data[dataOffset], scanline);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_encode)\n\t\tPROFILER_ENTER(context->priv->prof_nsc_rle_compress_data)\n\t\tnsc_rle_compress_data(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_rle_compress_data)\n\t\tmessages[i].LumaPlaneByteCount = context->PlaneByteCount[0];\n\t\tmessages[i].OrangeChromaPlaneByteCount = context->PlaneByteCount[1];\n\t\tmessages[i].GreenChromaPlaneByteCount = context->PlaneByteCount[2];\n\t\tmessages[i].AlphaPlaneByteCount = context->PlaneByteCount[3];\n\t\tmessages[i].ColorLossLevel = context->ColorLossLevel;\n\t\tmessages[i].ChromaSubsamplingLevel = context->ChromaSubsamplingLevel;\n\t}\n\n\tcontext->priv->PlaneBuffers[0] = NULL;\n\tcontext->priv->PlaneBuffers[1] = NULL;\n\tcontext->priv->PlaneBuffers[2] = NULL;\n\tcontext->priv->PlaneBuffers[3] = NULL;\n\tcontext->priv->PlaneBuffers[4] = NULL;\n\treturn messages;\nfail:\n\n\tfor (i = 0; i < *numMessages; i++)\n\t\tBufferPool_Return(context->priv->PlanePool, messages[i].PlaneBuffer);\n\n\tfree(messages);\n\treturn NULL;\n}\n\nBOOL nsc_write_message(NSC_CONTEXT* context, wStream* s, NSC_MESSAGE* message)\n{\n\tUINT32 totalPlaneByteCount;\n\ttotalPlaneByteCount = message->LumaPlaneByteCount +\n\t                      message->OrangeChromaPlaneByteCount +\n\t                      message->GreenChromaPlaneByteCount + message->AlphaPlaneByteCount;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 20 + totalPlaneByteCount))\n\t\treturn -1;\n\n\tStream_Write_UINT32(s,\n\t                    message->LumaPlaneByteCount); /* LumaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT32(s,\n\t                    message->OrangeChromaPlaneByteCount); /* OrangeChromaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT32(s,\n\t                    message->GreenChromaPlaneByteCount); /* GreenChromaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT32(s,\n\t                    message->AlphaPlaneByteCount); /* AlphaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT8(s, message->ColorLossLevel); /* ColorLossLevel (1 byte) */\n\tStream_Write_UINT8(s,\n\t                   message->ChromaSubsamplingLevel); /* ChromaSubsamplingLevel (1 byte) */\n\tStream_Write_UINT16(s, 0); /* Reserved (2 bytes) */\n\n\tif (message->LumaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[0],\n\t\t             message->LumaPlaneByteCount); /* LumaPlane */\n\n\tif (message->OrangeChromaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[1],\n\t\t             message->OrangeChromaPlaneByteCount); /* OrangeChromaPlane */\n\n\tif (message->GreenChromaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[2],\n\t\t             message->GreenChromaPlaneByteCount); /* GreenChromaPlane */\n\n\tif (message->AlphaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[3],\n\t\t             message->AlphaPlaneByteCount); /* AlphaPlane */\n\n\treturn TRUE;\n}\n\nvoid nsc_message_free(NSC_CONTEXT* context, NSC_MESSAGE* message)\n{\n\tBufferPool_Return(context->priv->PlanePool, message->PlaneBuffer);\n}\n\nBOOL nsc_compose_message(NSC_CONTEXT* context, wStream* s, const BYTE* data,\n                         UINT32 width, UINT32 height, UINT32 scanline)\n{\n\tNSC_MESSAGE s_message = { 0 };\n\tNSC_MESSAGE* message = &s_message;\n\tcontext->width = width;\n\tcontext->height = height;\n\n\tif (!nsc_context_initialize_encode(context))\n\t\treturn FALSE;\n\n\t/* ARGB to AYCoCg conversion, chroma subsampling and colorloss reduction */\n\tPROFILER_ENTER(context->priv->prof_nsc_encode)\n\tcontext->encode(context, data, scanline);\n\tPROFILER_EXIT(context->priv->prof_nsc_encode)\n\t/* RLE encode */\n\tPROFILER_ENTER(context->priv->prof_nsc_rle_compress_data)\n\tnsc_rle_compress_data(context);\n\tPROFILER_EXIT(context->priv->prof_nsc_rle_compress_data)\n\tmessage->PlaneBuffers[0] = context->priv->PlaneBuffers[0];\n\tmessage->PlaneBuffers[1] = context->priv->PlaneBuffers[1];\n\tmessage->PlaneBuffers[2] = context->priv->PlaneBuffers[2];\n\tmessage->PlaneBuffers[3] = context->priv->PlaneBuffers[3];\n\tmessage->LumaPlaneByteCount = context->PlaneByteCount[0];\n\tmessage->OrangeChromaPlaneByteCount = context->PlaneByteCount[1];\n\tmessage->GreenChromaPlaneByteCount = context->PlaneByteCount[2];\n\tmessage->AlphaPlaneByteCount = context->PlaneByteCount[3];\n\tmessage->ColorLossLevel = context->ColorLossLevel;\n\tmessage->ChromaSubsamplingLevel = context->ChromaSubsamplingLevel;\n\treturn nsc_write_message(context, s, message);\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Encoder\n *\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CODEC_NSC_ENCODE_H\n#define FREERDP_LIB_CODEC_NSC_ENCODE_H\n\n#include <freerdp/api.h>\n\nFREERDP_LOCAL void nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata,\n                              UINT32 rowstride);\n\n#endif /* FREERDP_LIB_CODEC_NSC_ENCODE_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Library - SSE2 Optimizations\n *\n * Copyright 2012 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <xmmintrin.h>\n#include <emmintrin.h>\n\n#include <freerdp/codec/color.h>\n#include <winpr/crt.h>\n#include <winpr/sysinfo.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_sse2.h\"\n\nstatic void nsc_encode_argb_to_aycocg_sse2(NSC_CONTEXT* context,\n        const BYTE* data, UINT32 scanline)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE ccl;\n\tconst BYTE* src;\n\tBYTE* yplane = NULL;\n\tBYTE* coplane = NULL;\n\tBYTE* cgplane = NULL;\n\tBYTE* aplane = NULL;\n\t__m128i r_val;\n\t__m128i g_val;\n\t__m128i b_val;\n\t__m128i a_val;\n\t__m128i y_val;\n\t__m128i co_val;\n\t__m128i cg_val;\n\tUINT32 tempWidth;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\trw = (context->ChromaSubsamplingLevel > 0 ? tempWidth : context->width);\n\tccl = context->ColorLossLevel;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tsrc = data + (context->height - 1 - y) * scanline;\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\taplane = context->priv->PlaneBuffers[3] + y * context->width;\n\n\t\tfor (x = 0; x < context->width; x += 8)\n\t\t{\n\t\t\tswitch (context->format)\n\t\t\t{\n\t\t\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set_epi16(*(src + 31), *(src + 27), *(src + 23), *(src + 19),\n\t\t\t\t\t                      *(src + 15), *(src + 11), *(src + 7), *(src + 3));\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBX32:\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBA32:\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set_epi16(*(src + 31), *(src + 27), *(src + 23), *(src + 19),\n\t\t\t\t\t                      *(src + 15), *(src + 11), *(src + 7), *(src + 3));\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR24:\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 21), *(src + 18), *(src + 15), *(src + 12),\n\t\t\t\t\t                      *(src + 9), *(src + 6), *(src + 3), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 22), *(src + 19), *(src + 16), *(src + 13),\n\t\t\t\t\t                      *(src + 10), *(src + 7), *(src + 4), *(src + 1));\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 23), *(src + 20), *(src + 17), *(src + 14),\n\t\t\t\t\t                      *(src + 11), *(src + 8), *(src + 5), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 24;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB24:\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 21), *(src + 18), *(src + 15), *(src + 12),\n\t\t\t\t\t                      *(src + 9), *(src + 6), *(src + 3), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 22), *(src + 19), *(src + 16), *(src + 13),\n\t\t\t\t\t                      *(src + 10), *(src + 7), *(src + 4), *(src + 1));\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 23), *(src + 20), *(src + 17), *(src + 14),\n\t\t\t\t\t                      *(src + 11), *(src + 8), *(src + 5), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 24;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR16:\n\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t            (((*(src + 15)) & 0xF8) | ((*(src + 15)) >> 5)),\n\t\t\t\t\t            (((*(src + 13)) & 0xF8) | ((*(src + 13)) >> 5)),\n\t\t\t\t\t            (((*(src + 11)) & 0xF8) | ((*(src + 11)) >> 5)),\n\t\t\t\t\t            (((*(src + 9)) & 0xF8) | ((*(src + 9)) >> 5)),\n\t\t\t\t\t            (((*(src + 7)) & 0xF8) | ((*(src + 7)) >> 5)),\n\t\t\t\t\t            (((*(src + 5)) & 0xF8) | ((*(src + 5)) >> 5)),\n\t\t\t\t\t            (((*(src + 3)) & 0xF8) | ((*(src + 3)) >> 5)),\n\t\t\t\t\t            (((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5)));\n\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 15)) & 0x07) << 5) | (((*(src + 14)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 13)) & 0x07) << 5) | (((*(src + 12)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 11)) & 0x07) << 5) | (((*(src + 10)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 9)) & 0x07) << 5) | (((*(src + 8)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 7)) & 0x07) << 5) | (((*(src + 6)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 5)) & 0x07) << 5) | (((*(src + 4)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 3)) & 0x07) << 5) | (((*(src + 2)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3)));\n\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 14)) & 0x1F) << 3) | (((*(src + 14)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 12)) & 0x1F) << 3) | (((*(src + 12)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 10)) & 0x1F) << 3) | (((*(src + 10)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 8)) & 0x1F) << 3) | (((*(src + 8)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 6)) & 0x1F) << 3) | (((*(src + 6)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 4)) & 0x1F) << 3) | (((*(src + 4)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 2)) & 0x1F) << 3) | (((*(src + 2)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07)));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB16:\n\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t            (((*(src + 15)) & 0xF8) | ((*(src + 15)) >> 5)),\n\t\t\t\t\t            (((*(src + 13)) & 0xF8) | ((*(src + 13)) >> 5)),\n\t\t\t\t\t            (((*(src + 11)) & 0xF8) | ((*(src + 11)) >> 5)),\n\t\t\t\t\t            (((*(src + 9)) & 0xF8) | ((*(src + 9)) >> 5)),\n\t\t\t\t\t            (((*(src + 7)) & 0xF8) | ((*(src + 7)) >> 5)),\n\t\t\t\t\t            (((*(src + 5)) & 0xF8) | ((*(src + 5)) >> 5)),\n\t\t\t\t\t            (((*(src + 3)) & 0xF8) | ((*(src + 3)) >> 5)),\n\t\t\t\t\t            (((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5)));\n\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 15)) & 0x07) << 5) | (((*(src + 14)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 13)) & 0x07) << 5) | (((*(src + 12)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 11)) & 0x07) << 5) | (((*(src + 10)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 9)) & 0x07) << 5) | (((*(src + 8)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 7)) & 0x07) << 5) | (((*(src + 6)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 5)) & 0x07) << 5) | (((*(src + 4)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 3)) & 0x07) << 5) | (((*(src + 2)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3)));\n\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 14)) & 0x1F) << 3) | (((*(src + 14)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 12)) & 0x1F) << 3) | (((*(src + 12)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 10)) & 0x1F) << 3) | (((*(src + 10)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 8)) & 0x1F) << 3) | (((*(src + 8)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 6)) & 0x1F) << 3) | (((*(src + 6)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 4)) & 0x1F) << 3) | (((*(src + 4)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 2)) & 0x1F) << 3) | (((*(src + 2)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07)));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_A4:\n\t\t\t\t\t{\n\t\t\t\t\t\tint shift;\n\t\t\t\t\t\tBYTE idx[8];\n\n\t\t\t\t\t\tfor (shift = 7; shift >= 0; shift--)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tidx[shift] = ((*src) >> shift) & 1;\n\t\t\t\t\t\t\tidx[shift] |= (((*(src + 1)) >> shift) & 1) << 1;\n\t\t\t\t\t\t\tidx[shift] |= (((*(src + 2)) >> shift) & 1) << 2;\n\t\t\t\t\t\t\tidx[shift] |= (((*(src + 3)) >> shift) & 1) << 3;\n\t\t\t\t\t\t\tidx[shift] *= 3;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[idx[0]],\n\t\t\t\t\t\t            context->palette[idx[1]],\n\t\t\t\t\t\t            context->palette[idx[2]],\n\t\t\t\t\t\t            context->palette[idx[3]],\n\t\t\t\t\t\t            context->palette[idx[4]],\n\t\t\t\t\t\t            context->palette[idx[5]],\n\t\t\t\t\t\t            context->palette[idx[6]],\n\t\t\t\t\t\t            context->palette[idx[7]]);\n\t\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[idx[0] + 1],\n\t\t\t\t\t\t            context->palette[idx[1] + 1],\n\t\t\t\t\t\t            context->palette[idx[2] + 1],\n\t\t\t\t\t\t            context->palette[idx[3] + 1],\n\t\t\t\t\t\t            context->palette[idx[4] + 1],\n\t\t\t\t\t\t            context->palette[idx[5] + 1],\n\t\t\t\t\t\t            context->palette[idx[6] + 1],\n\t\t\t\t\t\t            context->palette[idx[7] + 1]);\n\t\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[idx[0] + 2],\n\t\t\t\t\t\t            context->palette[idx[1] + 2],\n\t\t\t\t\t\t            context->palette[idx[2] + 2],\n\t\t\t\t\t\t            context->palette[idx[3] + 2],\n\t\t\t\t\t\t            context->palette[idx[4] + 2],\n\t\t\t\t\t\t            context->palette[idx[5] + 2],\n\t\t\t\t\t\t            context->palette[idx[6] + 2],\n\t\t\t\t\t\t            context->palette[idx[7] + 2]);\n\t\t\t\t\t\tsrc += 4;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB8:\n\t\t\t\t\t{\n\t\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[(*(src + 7)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 6)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 5)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 4)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 3)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 2)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 1)) * 3],\n\t\t\t\t\t\t            context->palette[(*src) * 3]);\n\t\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[(*(src + 7)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 6)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 5)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 4)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 3)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 2)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 1)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*src) * 3 + 1]);\n\t\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[(*(src + 7)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 6)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 5)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 4)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 3)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 2)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 1)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*src) * 3 + 2]);\n\t\t\t\t\t\tsrc += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tr_val = g_val = b_val = a_val = _mm_set1_epi16(0);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ty_val = _mm_srai_epi16(r_val, 2);\n\t\t\ty_val = _mm_add_epi16(y_val, _mm_srai_epi16(g_val, 1));\n\t\t\ty_val = _mm_add_epi16(y_val, _mm_srai_epi16(b_val, 2));\n\t\t\tco_val = _mm_sub_epi16(r_val, b_val);\n\t\t\tco_val = _mm_srai_epi16(co_val, ccl);\n\t\t\tcg_val = _mm_sub_epi16(g_val, _mm_srai_epi16(r_val, 1));\n\t\t\tcg_val = _mm_sub_epi16(cg_val, _mm_srai_epi16(b_val, 1));\n\t\t\tcg_val = _mm_srai_epi16(cg_val, ccl);\n\t\t\ty_val = _mm_packus_epi16(y_val, y_val);\n\t\t\t_mm_storeu_si128((__m128i*) yplane, y_val);\n\t\t\tco_val = _mm_packs_epi16(co_val, co_val);\n\t\t\t_mm_storeu_si128((__m128i*) coplane, co_val);\n\t\t\tcg_val = _mm_packs_epi16(cg_val, cg_val);\n\t\t\t_mm_storeu_si128((__m128i*) cgplane, cg_val);\n\t\t\ta_val = _mm_packus_epi16(a_val, a_val);\n\t\t\t_mm_storeu_si128((__m128i*) aplane, a_val);\n\t\t\typlane += 8;\n\t\t\tcoplane += 8;\n\t\t\tcgplane += 8;\n\t\t\taplane += 8;\n\t\t}\n\n\t\tif (context->ChromaSubsamplingLevel > 0 && (context->width % 2) == 1)\n\t\t{\n\t\t\tcontext->priv->PlaneBuffers[0][y * rw + context->width] =\n\t\t\t    context->priv->PlaneBuffers[0][y * rw + context->width - 1];\n\t\t\tcontext->priv->PlaneBuffers[1][y * rw + context->width] =\n\t\t\t    context->priv->PlaneBuffers[1][y * rw + context->width - 1];\n\t\t\tcontext->priv->PlaneBuffers[2][y * rw + context->width] =\n\t\t\t    context->priv->PlaneBuffers[2][y * rw + context->width - 1];\n\t\t}\n\t}\n\n\tif (context->ChromaSubsamplingLevel > 0 && (y % 2) == 1)\n\t{\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\tCopyMemory(yplane, yplane - rw, rw);\n\t\tCopyMemory(coplane, coplane - rw, rw);\n\t\tCopyMemory(cgplane, cgplane - rw, rw);\n\t}\n}\n\nstatic void nsc_encode_subsampling_sse2(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tBYTE* co_dst;\n\tBYTE* cg_dst;\n\tINT8* co_src0;\n\tINT8* co_src1;\n\tINT8* cg_src0;\n\tINT8* cg_src1;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\t__m128i t;\n\t__m128i val;\n\t__m128i mask = _mm_set1_epi16(0xFF);\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\n\tfor (y = 0; y < tempHeight >> 1; y++)\n\t{\n\t\tco_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n\t\tcg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n\t\tco_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n\t\tco_src1 = co_src0 + tempWidth;\n\t\tcg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n\t\tcg_src1 = cg_src0 + tempWidth;\n\n\t\tfor (x = 0; x < tempWidth >> 1; x += 8)\n\t\t{\n\t\t\tt = _mm_loadu_si128((__m128i*) co_src0);\n\t\t\tt = _mm_avg_epu8(t, _mm_loadu_si128((__m128i*) co_src1));\n\t\t\tval = _mm_and_si128(_mm_srli_si128(t, 1), mask);\n\t\t\tval = _mm_avg_epu16(val, _mm_and_si128(t, mask));\n\t\t\tval = _mm_packus_epi16(val, val);\n\t\t\t_mm_storeu_si128((__m128i*) co_dst, val);\n\t\t\tco_dst += 8;\n\t\t\tco_src0 += 16;\n\t\t\tco_src1 += 16;\n\t\t\tt = _mm_loadu_si128((__m128i*) cg_src0);\n\t\t\tt = _mm_avg_epu8(t, _mm_loadu_si128((__m128i*) cg_src1));\n\t\t\tval = _mm_and_si128(_mm_srli_si128(t, 1), mask);\n\t\t\tval = _mm_avg_epu16(val, _mm_and_si128(t, mask));\n\t\t\tval = _mm_packus_epi16(val, val);\n\t\t\t_mm_storeu_si128((__m128i*) cg_dst, val);\n\t\t\tcg_dst += 8;\n\t\t\tcg_src0 += 16;\n\t\t\tcg_src1 += 16;\n\t\t}\n\t}\n}\n\nstatic void nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n}\n\nvoid nsc_init_sse2(NSC_CONTEXT* context)\n{\n\tif (!IsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE))\n\t\treturn;\n\n\tPROFILER_RENAME(context->priv->prof_nsc_encode, \"nsc_encode_sse2\");\n\tcontext->encode = nsc_encode_sse2;\n}\n"], "fixing_code": ["/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Codec\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_CODEC_NSCODEC_H\n#define FREERDP_CODEC_NSCODEC_H\n\n#include <freerdp/api.h>\n#include <freerdp/types.h>\n#include <freerdp/constants.h>\n\n#include <winpr/stream.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\nstruct _NSC_MESSAGE\n{\n\tUINT32 x;\n\tUINT32 y;\n\tUINT32 width;\n\tUINT32 height;\n\tconst BYTE* data;\n\tUINT32 scanline;\n\tBYTE* PlaneBuffer;\n\tUINT32 MaxPlaneSize;\n\tBYTE* PlaneBuffers[5];\n\tUINT32 OrgByteCount[4];\n\n\tUINT32 LumaPlaneByteCount;\n\tUINT32 OrangeChromaPlaneByteCount;\n\tUINT32 GreenChromaPlaneByteCount;\n\tUINT32 AlphaPlaneByteCount;\n\tUINT32 ColorLossLevel;\n\tUINT32 ChromaSubsamplingLevel;\n};\ntypedef struct _NSC_MESSAGE NSC_MESSAGE;\n\ntypedef struct _NSC_CONTEXT_PRIV NSC_CONTEXT_PRIV;\n\ntypedef struct _NSC_CONTEXT NSC_CONTEXT;\n\nstruct _NSC_CONTEXT\n{\n\tUINT32 OrgByteCount[4];\n\tUINT32 format;\n\tUINT16 width;\n\tUINT16 height;\n\tBYTE* BitmapData;\n\tUINT32 BitmapDataLength;\n\n\tBYTE* Planes;\n\tUINT32 PlaneByteCount[4];\n\tUINT32 ColorLossLevel;\n\tUINT32 ChromaSubsamplingLevel;\n\tBOOL DynamicColorFidelity;\n\n\t/* color palette allocated by the application */\n\tconst BYTE* palette;\n\n\tBOOL (*decode)(NSC_CONTEXT* context);\n\tBOOL (*encode)(NSC_CONTEXT* context, const BYTE* BitmapData,\n\t               UINT32 rowstride);\n\n\tNSC_CONTEXT_PRIV* priv;\n};\n\nFREERDP_API BOOL nsc_context_set_pixel_format(NSC_CONTEXT* context,\n        UINT32 pixel_format);\nFREERDP_API BOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,\n                                     UINT32 width, UINT32 height,\n                                     const BYTE* data, UINT32 length,\n                                     BYTE* pDstData, UINT32 DstFormat,\n                                     UINT32 nDstStride, UINT32 nXDst, UINT32 nYDst,\n                                     UINT32 nWidth, UINT32 nHeight, UINT32 flip);\nFREERDP_API BOOL nsc_compose_message(NSC_CONTEXT* context, wStream* s,\n                                     const BYTE* bmpdata,\n                                     UINT32 width, UINT32 height, UINT32 rowstride);\n\nFREERDP_API NSC_MESSAGE* nsc_encode_messages(NSC_CONTEXT* context,\n        const BYTE* data,\n        UINT32 x, UINT32 y,\n        UINT32 width, UINT32 height, UINT32 scanline,\n        UINT32* numMessages, UINT32 maxDataSize);\nFREERDP_API BOOL nsc_write_message(NSC_CONTEXT* context, wStream* s,\n                                   NSC_MESSAGE* message);\nFREERDP_API void nsc_message_free(NSC_CONTEXT* context, NSC_MESSAGE* message);\n\nFREERDP_API BOOL nsc_context_reset(NSC_CONTEXT* context, UINT32 width,\n                                   UINT32 height);\n\nFREERDP_API NSC_CONTEXT* nsc_context_new(void);\nFREERDP_API void nsc_context_free(NSC_CONTEXT* context);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* FREERDP_CODEC_NSCODEC_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Codec\n *\n * Copyright 2011 Samsung, Author Jiten Pathy\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/codec/nsc.h>\n#include <freerdp/codec/color.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_encode.h\"\n\n#include \"nsc_sse2.h\"\n\n#ifndef NSC_INIT_SIMD\n#define NSC_INIT_SIMD(_nsc_context) do { } while (0)\n#endif\n\nstatic BOOL nsc_decode(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE shift;\n\tBYTE* bmpdata;\n\tsize_t pos = 0;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\trw = ROUND_UP_TO(context->width, 8);\n\tshift = context->ColorLossLevel - 1; /* colorloss recovery + YCoCg shift */\n\tbmpdata = context->BitmapData;\n\n\tif (!bmpdata)\n\t\treturn FALSE;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tconst BYTE* yplane;\n\t\tconst BYTE* coplane;\n\t\tconst BYTE* cgplane;\n\t\tconst BYTE* aplane = context->priv->PlaneBuffers[3] + y * context->width; /* A */\n\n\t\tif (context->ChromaSubsamplingLevel)\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * rw; /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + (y >> 1) * (rw >>\n\t\t\t          1); /* Co, supersampled */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + (y >> 1) * (rw >>\n\t\t\t          1); /* Cg, supersampled */\n\t\t}\n\t\telse\n\t\t{\n\t\t\typlane = context->priv->PlaneBuffers[0] + y * context->width; /* Y */\n\t\t\tcoplane = context->priv->PlaneBuffers[1] + y * context->width; /* Co */\n\t\t\tcgplane = context->priv->PlaneBuffers[2] + y * context->width; /* Cg */\n\t\t}\n\n\t\tfor (x = 0; x < context->width; x++)\n\t\t{\n\t\t\tINT16 y_val = (INT16) * yplane;\n\t\t\tINT16 co_val = (INT16)(INT8)(*coplane << shift);\n\t\t\tINT16 cg_val = (INT16)(INT8)(*cgplane << shift);\n\t\t\tINT16 r_val = y_val + co_val - cg_val;\n\t\t\tINT16 g_val = y_val + cg_val;\n\t\t\tINT16 b_val = y_val - co_val - cg_val;\n\n\t\t\tif (pos + 4 > context->BitmapDataLength)\n\t\t\t\treturn FALSE;\n\n\t\t\tpos += 4;\n\t\t\t*bmpdata++ = MINMAX(b_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(g_val, 0, 0xFF);\n\t\t\t*bmpdata++ = MINMAX(r_val, 0, 0xFF);\n\t\t\t*bmpdata++ = *aplane;\n\t\t\typlane++;\n\t\t\tcoplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\tcgplane += (context->ChromaSubsamplingLevel ? x % 2 : 1);\n\t\t\taplane++;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL nsc_rle_decode(BYTE* in, BYTE* out, UINT32 outSize, UINT32 originalSize)\n{\n\tUINT32 len;\n\tUINT32 left;\n\tBYTE value;\n\tleft = originalSize;\n\n\twhile (left > 4)\n\t{\n\t\tvalue = *in++;\n\n\t\tif (left == 5)\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t\telse if (value == *in)\n\t\t{\n\t\t\tin++;\n\n\t\t\tif (*in < 0xFF)\n\t\t\t{\n\t\t\t\tlen = (UINT32) * in++;\n\t\t\t\tlen += 2;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tin++;\n\t\t\t\tlen = *((UINT32*) in);\n\t\t\t\tin += 4;\n\t\t\t}\n\n\t\t\tif (outSize < len)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize -= len;\n\t\t\tFillMemory(out, len, value);\n\t\t\tout += len;\n\t\t\tleft -= len;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (outSize < 1)\n\t\t\t\treturn FALSE;\n\n\t\t\toutSize--;\n\t\t\t*out++ = value;\n\t\t\tleft--;\n\t\t}\n\t}\n\n\tif ((outSize < 4) || (left < 4))\n\t\treturn FALSE;\n\n\tmemcpy(out, in, 4);\n\treturn TRUE;\n}\n\nstatic BOOL nsc_rle_decompress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tBYTE* rle;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\trle = context->Planes;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\t\tplaneSize = context->PlaneByteCount[i];\n\n\t\tif (planeSize == 0)\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tFillMemory(context->priv->PlaneBuffers[i], originalSize, 0xFF);\n\t\t}\n\t\telse if (planeSize < originalSize)\n\t\t{\n\t\t\tif (!nsc_rle_decode(rle, context->priv->PlaneBuffers[i], context->priv->PlaneBuffersLength,\n\t\t\t                    originalSize))\n\t\t\t\treturn FALSE;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (context->priv->PlaneBuffersLength < originalSize)\n\t\t\t\treturn FALSE;\n\n\t\t\tCopyMemory(context->priv->PlaneBuffers[i], rle, originalSize);\n\t\t}\n\n\t\trle += planeSize;\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL nsc_stream_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tint i;\n\n\tif (Stream_GetRemainingLength(s) < 20)\n\t\treturn FALSE;\n\n\tfor (i = 0; i < 4; i++)\n\t\tStream_Read_UINT32(s, context->PlaneByteCount[i]);\n\n\tStream_Read_UINT8(s, context->ColorLossLevel); /* ColorLossLevel (1 byte) */\n\tStream_Read_UINT8(s,\n\t                  context->ChromaSubsamplingLevel); /* ChromaSubsamplingLevel (1 byte) */\n\tStream_Seek(s, 2); /* Reserved (2 bytes) */\n\tcontext->Planes = Stream_Pointer(s);\n\treturn TRUE;\n}\n\nstatic BOOL nsc_context_initialize(NSC_CONTEXT* context, wStream* s)\n{\n\tint i;\n\tUINT32 length;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\n\tif (!nsc_stream_initialize(context, s))\n\t\treturn FALSE;\n\n\tlength = context->width * context->height * 4;\n\n\tif (!context->BitmapData)\n\t{\n\t\tcontext->BitmapData = calloc(1, length + 16);\n\n\t\tif (!context->BitmapData)\n\t\t\treturn FALSE;\n\n\t\tcontext->BitmapDataLength = length;\n\t}\n\telse if (length > context->BitmapDataLength)\n\t{\n\t\tvoid* tmp;\n\t\ttmp = realloc(context->BitmapData, length + 16);\n\n\t\tif (!tmp)\n\t\t\treturn FALSE;\n\n\t\tcontext->BitmapData = tmp;\n\t\tcontext->BitmapDataLength = length;\n\t}\n\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tlength = tempWidth * tempHeight;\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 4; i++)\n\t\t{\n\t\t\tvoid* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n\n\t\t\tif (!tmp)\n\t\t\t\treturn FALSE;\n\n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = length;\n\t}\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\tcontext->OrgByteCount[i] = context->width * context->height;\n\t}\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = (tempWidth >> 1) * (tempHeight >> 1);\n\t\tcontext->OrgByteCount[2] = context->OrgByteCount[1];\n\t}\n\n\treturn TRUE;\n}\n\nstatic void nsc_profiler_print(NSC_CONTEXT_PRIV* priv)\n{\n\tPROFILER_PRINT_HEADER\n\tPROFILER_PRINT(priv->prof_nsc_rle_decompress_data)\n\tPROFILER_PRINT(priv->prof_nsc_decode)\n\tPROFILER_PRINT(priv->prof_nsc_rle_compress_data)\n\tPROFILER_PRINT(priv->prof_nsc_encode)\n\tPROFILER_PRINT_FOOTER\n}\n\nBOOL nsc_context_reset(NSC_CONTEXT* context, UINT32 width, UINT32 height)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->width = width;\n\tcontext->height = height;\n\treturn TRUE;\n}\n\nNSC_CONTEXT* nsc_context_new(void)\n{\n\tNSC_CONTEXT* context;\n\tcontext = (NSC_CONTEXT*) calloc(1, sizeof(NSC_CONTEXT));\n\n\tif (!context)\n\t\treturn NULL;\n\n\tcontext->priv = (NSC_CONTEXT_PRIV*) calloc(1, sizeof(NSC_CONTEXT_PRIV));\n\n\tif (!context->priv)\n\t\tgoto error;\n\n\tcontext->priv->log = WLog_Get(\"com.freerdp.codec.nsc\");\n\tWLog_OpenAppender(context->priv->log);\n\tcontext->BitmapData = NULL;\n\tcontext->decode = nsc_decode;\n\tcontext->encode = nsc_encode;\n\tcontext->priv->PlanePool = BufferPool_New(TRUE, 0, 16);\n\n\tif (!context->priv->PlanePool)\n\t\tgoto error;\n\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_decompress_data,\n\t                \"nsc_rle_decompress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_decode, \"nsc_decode\")\n\tPROFILER_CREATE(context->priv->prof_nsc_rle_compress_data,\n\t                \"nsc_rle_compress_data\")\n\tPROFILER_CREATE(context->priv->prof_nsc_encode, \"nsc_encode\")\n\t/* Default encoding parameters */\n\tcontext->ColorLossLevel = 3;\n\tcontext->ChromaSubsamplingLevel = 1;\n\t/* init optimized methods */\n\tNSC_INIT_SIMD(context);\n\treturn context;\nerror:\n\tnsc_context_free(context);\n\treturn NULL;\n}\n\nvoid nsc_context_free(NSC_CONTEXT* context)\n{\n\tsize_t i;\n\n\tif (!context)\n\t\treturn;\n\n\tif (context->priv)\n\t{\n\t\tfor (i = 0; i < 4; i++)\n\t\t\tfree(context->priv->PlaneBuffers[i]);\n\n\t\tBufferPool_Free(context->priv->PlanePool);\n\t\tnsc_profiler_print(context->priv);\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_decompress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_decode)\n\t\tPROFILER_FREE(context->priv->prof_nsc_rle_compress_data)\n\t\tPROFILER_FREE(context->priv->prof_nsc_encode)\n\t\tfree(context->priv);\n\t}\n\n\tfree(context->BitmapData);\n\tfree(context);\n}\n\nBOOL nsc_context_set_pixel_format(NSC_CONTEXT* context, UINT32 pixel_format)\n{\n\tif (!context)\n\t\treturn FALSE;\n\n\tcontext->format = pixel_format;\n\treturn TRUE;\n}\n\nBOOL nsc_process_message(NSC_CONTEXT* context, UINT16 bpp,\n                         UINT32 width, UINT32 height,\n                         const BYTE* data, UINT32 length,\n                         BYTE* pDstData, UINT32 DstFormat,\n                         UINT32 nDstStride,\n                         UINT32 nXDst, UINT32 nYDst, UINT32 nWidth,\n                         UINT32 nHeight, UINT32 flip)\n{\n\twStream* s;\n\tBOOL ret;\n\ts = Stream_New((BYTE*)data, length);\n\n\tif (!s)\n\t\treturn FALSE;\n\n\tif (nDstStride == 0)\n\t\tnDstStride = nWidth * GetBytesPerPixel(DstFormat);\n\n\tswitch (bpp)\n\t{\n\t\tcase 32:\n\t\t\tcontext->format = PIXEL_FORMAT_BGRA32;\n\t\t\tbreak;\n\n\t\tcase 24:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR24;\n\t\t\tbreak;\n\n\t\tcase 16:\n\t\t\tcontext->format = PIXEL_FORMAT_BGR16;\n\t\t\tbreak;\n\n\t\tcase 8:\n\t\t\tcontext->format = PIXEL_FORMAT_RGB8;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tcontext->format = PIXEL_FORMAT_A4;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tStream_Free(s, TRUE);\n\t\t\treturn FALSE;\n\t}\n\n\tcontext->width = width;\n\tcontext->height = height;\n\tret = nsc_context_initialize(context, s);\n\tStream_Free(s, FALSE);\n\n\tif (!ret)\n\t\treturn FALSE;\n\n\t/* RLE decode */\n\t{\n\t\tBOOL rc;\n\t\tPROFILER_ENTER(context->priv->prof_nsc_rle_decompress_data)\n\t\trc = nsc_rle_decompress_data(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_rle_decompress_data)\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\t/* Colorloss recover, Chroma supersample and AYCoCg to ARGB Conversion in one step */\n\t{\n\t\tBOOL rc;\n\t\tPROFILER_ENTER(context->priv->prof_nsc_decode)\n\t\trc = context->decode(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_decode)\n\n\t\tif (!rc)\n\t\t\treturn FALSE;\n\t}\n\n\tif (!freerdp_image_copy(pDstData, DstFormat, nDstStride, nXDst, nYDst,\n\t                        width, height, context->BitmapData,\n\t                        PIXEL_FORMAT_BGRA32, 0, 0, 0, NULL, flip))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Encoder\n *\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n\n#include <freerdp/codec/nsc.h>\n#include <freerdp/codec/color.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_encode.h\"\n\nstatic BOOL nsc_context_initialize_encode(NSC_CONTEXT* context)\n{\n\tint i;\n\tUINT32 length;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\t/* The maximum length a decoded plane can reach in all cases */\n\tlength = tempWidth * tempHeight + 16;\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 5; i++)\n\t\t{\n\t\t\tBYTE* tmp = (BYTE*) realloc(context->priv->PlaneBuffers[i], length);\n\n\t\t\tif (!tmp)\n\t\t\t\tgoto fail;\n\n\t\t\tcontext->priv->PlaneBuffers[i] = tmp;\n\t\t}\n\n\t\tcontext->priv->PlaneBuffersLength = length;\n\t}\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tcontext->OrgByteCount[0] = tempWidth * context->height;\n\t\tcontext->OrgByteCount[1] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[2] = tempWidth * tempHeight / 4;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\telse\n\t{\n\t\tcontext->OrgByteCount[0] = context->width * context->height;\n\t\tcontext->OrgByteCount[1] = context->width * context->height;\n\t\tcontext->OrgByteCount[2] = context->width * context->height;\n\t\tcontext->OrgByteCount[3] = context->width * context->height;\n\t}\n\n\treturn TRUE;\nfail:\n\n\tif (length > context->priv->PlaneBuffersLength)\n\t{\n\t\tfor (i = 0; i < 5; i++)\n\t\t\tfree(context->priv->PlaneBuffers[i]);\n\t}\n\n\treturn FALSE;\n}\n\nstatic BOOL nsc_encode_argb_to_aycocg(NSC_CONTEXT* context, const BYTE* data,\n                                      UINT32 scanline)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE ccl;\n\tconst BYTE* src;\n\tBYTE* yplane = NULL;\n\tBYTE* coplane = NULL;\n\tBYTE* cgplane = NULL;\n\tBYTE* aplane = NULL;\n\tINT16 r_val;\n\tINT16 g_val;\n\tINT16 b_val;\n\tBYTE a_val;\n\tUINT32 tempWidth;\n\n\tif (!context || data || (scanline == 0))\n\t\treturn FALSE;\n\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\trw = (context->ChromaSubsamplingLevel ? tempWidth : context->width);\n\tccl = context->ColorLossLevel;\n\n\tif (context->priv->PlaneBuffersLength < rw * scanline)\n\t\treturn FALSE;\n\n\tif (rw < scanline * 2)\n\t\treturn FALSE;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tsrc = data + (context->height - 1 - y) * scanline;\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\taplane = context->priv->PlaneBuffers[3] + y * context->width;\n\n\t\tfor (x = 0; x < context->width; x++)\n\t\t{\n\t\t\tswitch (context->format)\n\t\t\t{\n\t\t\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tsrc++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\ta_val = *src++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBX32:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tsrc++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBA32:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\ta_val = *src++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR24:\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB24:\n\t\t\t\t\tr_val = *src++;\n\t\t\t\t\tg_val = *src++;\n\t\t\t\t\tb_val = *src++;\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR16:\n\t\t\t\t\tb_val = (INT16)(((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5));\n\t\t\t\t\tg_val = (INT16)((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3));\n\t\t\t\t\tr_val = (INT16)((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07));\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tsrc += 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB16:\n\t\t\t\t\tr_val = (INT16)(((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5));\n\t\t\t\t\tg_val = (INT16)((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3));\n\t\t\t\t\tb_val = (INT16)((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07));\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tsrc += 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_A4:\n\t\t\t\t\t{\n\t\t\t\t\t\tint shift;\n\t\t\t\t\t\tBYTE idx;\n\t\t\t\t\t\tshift = (7 - (x % 8));\n\t\t\t\t\t\tidx = ((*src) >> shift) & 1;\n\t\t\t\t\t\tidx |= (((*(src + 1)) >> shift) & 1) << 1;\n\t\t\t\t\t\tidx |= (((*(src + 2)) >> shift) & 1) << 2;\n\t\t\t\t\t\tidx |= (((*(src + 3)) >> shift) & 1) << 3;\n\t\t\t\t\t\tidx *= 3;\n\t\t\t\t\t\tr_val = (INT16) context->palette[idx];\n\t\t\t\t\t\tg_val = (INT16) context->palette[idx + 1];\n\t\t\t\t\t\tb_val = (INT16) context->palette[idx + 2];\n\n\t\t\t\t\t\tif (shift == 0)\n\t\t\t\t\t\t\tsrc += 4;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB8:\n\t\t\t\t\t{\n\t\t\t\t\t\tint idx = (*src) * 3;\n\t\t\t\t\t\tr_val = (INT16) context->palette[idx];\n\t\t\t\t\t\tg_val = (INT16) context->palette[idx + 1];\n\t\t\t\t\t\tb_val = (INT16) context->palette[idx + 2];\n\t\t\t\t\t\tsrc++;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = 0xFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tr_val = g_val = b_val = a_val = 0;\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t*yplane++ = (BYTE)((r_val >> 2) + (g_val >> 1) + (b_val >> 2));\n\t\t\t/* Perform color loss reduction here */\n\t\t\t*coplane++ = (BYTE)((r_val - b_val) >> ccl);\n\t\t\t*cgplane++ = (BYTE)((-(r_val >> 1) + g_val - (b_val >> 1)) >> ccl);\n\t\t\t*aplane++ = a_val;\n\t\t}\n\n\t\tif (context->ChromaSubsamplingLevel && (x % 2) == 1)\n\t\t{\n\t\t\t*yplane = *(yplane - 1);\n\t\t\t*coplane = *(coplane - 1);\n\t\t\t*cgplane = *(cgplane - 1);\n\t\t}\n\t}\n\n\tif (context->ChromaSubsamplingLevel && (y % 2) == 1)\n\t{\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\tCopyMemory(yplane, yplane - rw, rw);\n\t\tCopyMemory(coplane, coplane - rw, rw);\n\t\tCopyMemory(cgplane, cgplane - rw, rw);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL nsc_encode_subsampling(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\n\tif (!context)\n\t\treturn FALSE;\n\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\n\tif (tempHeight == 0)\n\t\treturn FALSE;\n\n\tif (tempWidth > context->priv->PlaneBuffersLength / tempHeight)\n\t\treturn FALSE;\n\n\tfor (y = 0; y < tempHeight >> 1; y++)\n\t{\n\t\tBYTE* co_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n\t\tBYTE* cg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n\t\tconst INT8* co_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n\t\tconst INT8* co_src1 = co_src0 + tempWidth;\n\t\tconst INT8* cg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n\t\tconst INT8* cg_src1 = cg_src0 + tempWidth;\n\n\t\tfor (x = 0; x < tempWidth >> 1; x++)\n\t\t{\n\t\t\t*co_dst++ = (BYTE)(((INT16) * co_src0 + (INT16) * (co_src0 + 1) +\n\t\t\t                    (INT16) * co_src1 + (INT16) * (co_src1 + 1)) >> 2);\n\t\t\t*cg_dst++ = (BYTE)(((INT16) * cg_src0 + (INT16) * (cg_src0 + 1) +\n\t\t\t                    (INT16) * cg_src1 + (INT16) * (cg_src1 + 1)) >> 2);\n\t\t\tco_src0 += 2;\n\t\t\tco_src1 += 2;\n\t\t\tcg_src0 += 2;\n\t\t\tcg_src1 += 2;\n\t\t}\n\t}\n\n\treturn TRUE;\n}\n\nBOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata, UINT32 rowstride)\n{\n\tif (!context || !bmpdata || (rowstride == 0))\n\t\treturn FALSE;\n\n\tif (!nsc_encode_argb_to_aycocg(context, bmpdata, rowstride))\n\t\treturn FALSE;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tif (!nsc_encode_subsampling(context))\n\t\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nstatic UINT32 nsc_rle_encode(const BYTE* in, BYTE* out, UINT32 originalSize)\n{\n\tUINT32 left;\n\tUINT32 runlength = 1;\n\tUINT32 planeSize = 0;\n\tleft = originalSize;\n\n\t/**\n\t * We quit the loop if the running compressed size is larger than the original.\n\t * In such cases data will be sent uncompressed.\n\t */\n\twhile (left > 4 && planeSize < originalSize - 4)\n\t{\n\t\tif (left > 5 && *in == *(in + 1))\n\t\t{\n\t\t\trunlength++;\n\t\t}\n\t\telse if (runlength == 1)\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\tplaneSize++;\n\t\t}\n\t\telse if (runlength < 256)\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\t*out++ = *in;\n\t\t\t*out++ = runlength - 2;\n\t\t\trunlength = 1;\n\t\t\tplaneSize += 3;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t*out++ = *in;\n\t\t\t*out++ = *in;\n\t\t\t*out++ = 0xFF;\n\t\t\t*out++ = (runlength & 0x000000FF);\n\t\t\t*out++ = (runlength & 0x0000FF00) >> 8;\n\t\t\t*out++ = (runlength & 0x00FF0000) >> 16;\n\t\t\t*out++ = (runlength & 0xFF000000) >> 24;\n\t\t\trunlength = 1;\n\t\t\tplaneSize += 7;\n\t\t}\n\n\t\tin++;\n\t\tleft--;\n\t}\n\n\tif (planeSize < originalSize - 4)\n\t\tCopyMemory(out, in, 4);\n\n\tplaneSize += 4;\n\treturn planeSize;\n}\n\nstatic void nsc_rle_compress_data(NSC_CONTEXT* context)\n{\n\tUINT16 i;\n\tUINT32 planeSize;\n\tUINT32 originalSize;\n\n\tfor (i = 0; i < 4; i++)\n\t{\n\t\toriginalSize = context->OrgByteCount[i];\n\n\t\tif (originalSize == 0)\n\t\t{\n\t\t\tplaneSize = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tplaneSize = nsc_rle_encode(context->priv->PlaneBuffers[i],\n\t\t\t                           context->priv->PlaneBuffers[4], originalSize);\n\n\t\t\tif (planeSize < originalSize)\n\t\t\t\tCopyMemory(context->priv->PlaneBuffers[i], context->priv->PlaneBuffers[4],\n\t\t\t\t           planeSize);\n\t\t\telse\n\t\t\t\tplaneSize = originalSize;\n\t\t}\n\n\t\tcontext->PlaneByteCount[i] = planeSize;\n\t}\n}\n\nUINT32 nsc_compute_byte_count(NSC_CONTEXT* context, UINT32* ByteCount,\n                              UINT32 width, UINT32 height)\n{\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\tUINT32 maxPlaneSize;\n\ttempWidth = ROUND_UP_TO(width, 8);\n\ttempHeight = ROUND_UP_TO(height, 2);\n\tmaxPlaneSize = tempWidth * tempHeight + 16;\n\n\tif (context->ChromaSubsamplingLevel)\n\t{\n\t\tByteCount[0] = tempWidth * height;\n\t\tByteCount[1] = tempWidth * tempHeight / 4;\n\t\tByteCount[2] = tempWidth * tempHeight / 4;\n\t\tByteCount[3] = width * height;\n\t}\n\telse\n\t{\n\t\tByteCount[0] = width * height;\n\t\tByteCount[1] = width * height;\n\t\tByteCount[2] = width * height;\n\t\tByteCount[3] = width * height;\n\t}\n\n\treturn maxPlaneSize;\n}\n\nNSC_MESSAGE* nsc_encode_messages(NSC_CONTEXT* context, const BYTE* data,\n                                 UINT32 x, UINT32 y, UINT32 width, UINT32 height,\n                                 UINT32 scanline, UINT32* numMessages,\n                                 UINT32 maxDataSize)\n{\n\tUINT32 i, j, k;\n\tUINT32 dataOffset;\n\tUINT32 rows, cols;\n\tUINT32 BytesPerPixel;\n\tUINT32 MaxRegionWidth;\n\tUINT32 MaxRegionHeight;\n\tUINT32 ByteCount[4];\n\tUINT32 MaxPlaneSize;\n\tUINT32 MaxMessageSize;\n\tNSC_MESSAGE* messages;\n\tUINT32 PaddedMaxPlaneSize;\n\tk = 0;\n\tMaxRegionWidth = 64 * 4;\n\tMaxRegionHeight = 64 * 2;\n\tBytesPerPixel = GetBytesPerPixel(context->format);\n\trows = (width + (MaxRegionWidth - (width % MaxRegionWidth))) / MaxRegionWidth;\n\tcols = (height + (MaxRegionHeight - (height % MaxRegionHeight))) /\n\t       MaxRegionHeight;\n\t*numMessages = rows * cols;\n\tMaxPlaneSize = nsc_compute_byte_count(context, (UINT32*) ByteCount, width,\n\t                                      height);\n\tMaxMessageSize = ByteCount[0] + ByteCount[1] + ByteCount[2] + ByteCount[3] + 20;\n\tmaxDataSize -= 1024; /* reserve enough space for headers */\n\tmessages = (NSC_MESSAGE*) calloc(*numMessages, sizeof(NSC_MESSAGE));\n\n\tif (!messages)\n\t\treturn NULL;\n\n\tfor (i = 0; i < rows; i++)\n\t{\n\t\tfor (j = 0; j < cols; j++)\n\t\t{\n\t\t\tmessages[k].x = x + (i * MaxRegionWidth);\n\t\t\tmessages[k].y = y + (j * MaxRegionHeight);\n\t\t\tmessages[k].width = (i < (rows - 1)) ? MaxRegionWidth : width -\n\t\t\t                    (i * MaxRegionWidth);\n\t\t\tmessages[k].height = (j < (cols - 1)) ? MaxRegionHeight : height -\n\t\t\t                     (j * MaxRegionHeight);\n\t\t\tmessages[k].data = data;\n\t\t\tmessages[k].scanline = scanline;\n\t\t\tmessages[k].MaxPlaneSize = nsc_compute_byte_count(context,\n\t\t\t                           (UINT32*) messages[k].OrgByteCount, messages[k].width, messages[k].height);\n\t\t\tk++;\n\t\t}\n\t}\n\n\t*numMessages = k;\n\n\tfor (i = 0; i < *numMessages; i++)\n\t{\n\t\tPaddedMaxPlaneSize = messages[i].MaxPlaneSize + 32;\n\t\tmessages[i].PlaneBuffer = (BYTE*) BufferPool_Take(context->priv->PlanePool,\n\t\t                          PaddedMaxPlaneSize * 5);\n\n\t\tif (!messages[i].PlaneBuffer)\n\t\t\tgoto fail;\n\n\t\tmessages[i].PlaneBuffers[0] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 0) + 16]);\n\t\tmessages[i].PlaneBuffers[1] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 1) + 16]);\n\t\tmessages[i].PlaneBuffers[2] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 2) + 16]);\n\t\tmessages[i].PlaneBuffers[3] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 3) + 16]);\n\t\tmessages[i].PlaneBuffers[4] = (BYTE*) &\n\t\t                              (messages[i].PlaneBuffer[(PaddedMaxPlaneSize * 4) + 16]);\n\t}\n\n\tfor (i = 0; i < *numMessages; i++)\n\t{\n\t\tcontext->width = messages[i].width;\n\t\tcontext->height = messages[i].height;\n\t\tcontext->OrgByteCount[0] = messages[i].OrgByteCount[0];\n\t\tcontext->OrgByteCount[1] = messages[i].OrgByteCount[1];\n\t\tcontext->OrgByteCount[2] = messages[i].OrgByteCount[2];\n\t\tcontext->OrgByteCount[3] = messages[i].OrgByteCount[3];\n\t\tcontext->priv->PlaneBuffersLength = messages[i].MaxPlaneSize;\n\t\tcontext->priv->PlaneBuffers[0] = messages[i].PlaneBuffers[0];\n\t\tcontext->priv->PlaneBuffers[1] = messages[i].PlaneBuffers[1];\n\t\tcontext->priv->PlaneBuffers[2] = messages[i].PlaneBuffers[2];\n\t\tcontext->priv->PlaneBuffers[3] = messages[i].PlaneBuffers[3];\n\t\tcontext->priv->PlaneBuffers[4] = messages[i].PlaneBuffers[4];\n\t\tdataOffset = (messages[i].y * messages[i].scanline) + (messages[i].x *\n\t\t             BytesPerPixel);\n\t\tPROFILER_ENTER(context->priv->prof_nsc_encode)\n\t\tcontext->encode(context, &data[dataOffset], scanline);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_encode)\n\t\tPROFILER_ENTER(context->priv->prof_nsc_rle_compress_data)\n\t\tnsc_rle_compress_data(context);\n\t\tPROFILER_EXIT(context->priv->prof_nsc_rle_compress_data)\n\t\tmessages[i].LumaPlaneByteCount = context->PlaneByteCount[0];\n\t\tmessages[i].OrangeChromaPlaneByteCount = context->PlaneByteCount[1];\n\t\tmessages[i].GreenChromaPlaneByteCount = context->PlaneByteCount[2];\n\t\tmessages[i].AlphaPlaneByteCount = context->PlaneByteCount[3];\n\t\tmessages[i].ColorLossLevel = context->ColorLossLevel;\n\t\tmessages[i].ChromaSubsamplingLevel = context->ChromaSubsamplingLevel;\n\t}\n\n\tcontext->priv->PlaneBuffers[0] = NULL;\n\tcontext->priv->PlaneBuffers[1] = NULL;\n\tcontext->priv->PlaneBuffers[2] = NULL;\n\tcontext->priv->PlaneBuffers[3] = NULL;\n\tcontext->priv->PlaneBuffers[4] = NULL;\n\treturn messages;\nfail:\n\n\tfor (i = 0; i < *numMessages; i++)\n\t\tBufferPool_Return(context->priv->PlanePool, messages[i].PlaneBuffer);\n\n\tfree(messages);\n\treturn NULL;\n}\n\nBOOL nsc_write_message(NSC_CONTEXT* context, wStream* s, NSC_MESSAGE* message)\n{\n\tUINT32 totalPlaneByteCount;\n\ttotalPlaneByteCount = message->LumaPlaneByteCount +\n\t                      message->OrangeChromaPlaneByteCount +\n\t                      message->GreenChromaPlaneByteCount + message->AlphaPlaneByteCount;\n\n\tif (!Stream_EnsureRemainingCapacity(s, 20 + totalPlaneByteCount))\n\t\treturn -1;\n\n\tStream_Write_UINT32(s,\n\t                    message->LumaPlaneByteCount); /* LumaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT32(s,\n\t                    message->OrangeChromaPlaneByteCount); /* OrangeChromaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT32(s,\n\t                    message->GreenChromaPlaneByteCount); /* GreenChromaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT32(s,\n\t                    message->AlphaPlaneByteCount); /* AlphaPlaneByteCount (4 bytes) */\n\tStream_Write_UINT8(s, message->ColorLossLevel); /* ColorLossLevel (1 byte) */\n\tStream_Write_UINT8(s,\n\t                   message->ChromaSubsamplingLevel); /* ChromaSubsamplingLevel (1 byte) */\n\tStream_Write_UINT16(s, 0); /* Reserved (2 bytes) */\n\n\tif (message->LumaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[0],\n\t\t             message->LumaPlaneByteCount); /* LumaPlane */\n\n\tif (message->OrangeChromaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[1],\n\t\t             message->OrangeChromaPlaneByteCount); /* OrangeChromaPlane */\n\n\tif (message->GreenChromaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[2],\n\t\t             message->GreenChromaPlaneByteCount); /* GreenChromaPlane */\n\n\tif (message->AlphaPlaneByteCount)\n\t\tStream_Write(s, message->PlaneBuffers[3],\n\t\t             message->AlphaPlaneByteCount); /* AlphaPlane */\n\n\treturn TRUE;\n}\n\nvoid nsc_message_free(NSC_CONTEXT* context, NSC_MESSAGE* message)\n{\n\tBufferPool_Return(context->priv->PlanePool, message->PlaneBuffer);\n}\n\nBOOL nsc_compose_message(NSC_CONTEXT* context, wStream* s, const BYTE* data,\n                         UINT32 width, UINT32 height, UINT32 scanline)\n{\n\tNSC_MESSAGE s_message = { 0 };\n\tNSC_MESSAGE* message = &s_message;\n\tcontext->width = width;\n\tcontext->height = height;\n\n\tif (!nsc_context_initialize_encode(context))\n\t\treturn FALSE;\n\n\t/* ARGB to AYCoCg conversion, chroma subsampling and colorloss reduction */\n\tPROFILER_ENTER(context->priv->prof_nsc_encode)\n\tcontext->encode(context, data, scanline);\n\tPROFILER_EXIT(context->priv->prof_nsc_encode)\n\t/* RLE encode */\n\tPROFILER_ENTER(context->priv->prof_nsc_rle_compress_data)\n\tnsc_rle_compress_data(context);\n\tPROFILER_EXIT(context->priv->prof_nsc_rle_compress_data)\n\tmessage->PlaneBuffers[0] = context->priv->PlaneBuffers[0];\n\tmessage->PlaneBuffers[1] = context->priv->PlaneBuffers[1];\n\tmessage->PlaneBuffers[2] = context->priv->PlaneBuffers[2];\n\tmessage->PlaneBuffers[3] = context->priv->PlaneBuffers[3];\n\tmessage->LumaPlaneByteCount = context->PlaneByteCount[0];\n\tmessage->OrangeChromaPlaneByteCount = context->PlaneByteCount[1];\n\tmessage->GreenChromaPlaneByteCount = context->PlaneByteCount[2];\n\tmessage->AlphaPlaneByteCount = context->PlaneByteCount[3];\n\tmessage->ColorLossLevel = context->ColorLossLevel;\n\tmessage->ChromaSubsamplingLevel = context->ChromaSubsamplingLevel;\n\treturn nsc_write_message(context, s, message);\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Encoder\n *\n * Copyright 2012 Vic Lee\n * Copyright 2016 Armin Novak <armin.novak@thincast.com>\n * Copyright 2016 Thincast Technologies GmbH\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifndef FREERDP_LIB_CODEC_NSC_ENCODE_H\n#define FREERDP_LIB_CODEC_NSC_ENCODE_H\n\n#include <freerdp/api.h>\n\nFREERDP_LOCAL BOOL nsc_encode(NSC_CONTEXT* context, const BYTE* bmpdata,\n                              UINT32 rowstride);\n\n#endif /* FREERDP_LIB_CODEC_NSC_ENCODE_H */\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * NSCodec Library - SSE2 Optimizations\n *\n * Copyright 2012 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <xmmintrin.h>\n#include <emmintrin.h>\n\n#include <freerdp/codec/color.h>\n#include <winpr/crt.h>\n#include <winpr/sysinfo.h>\n\n#include \"nsc_types.h\"\n#include \"nsc_sse2.h\"\n\nstatic void nsc_encode_argb_to_aycocg_sse2(NSC_CONTEXT* context,\n        const BYTE* data, UINT32 scanline)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tUINT16 rw;\n\tBYTE ccl;\n\tconst BYTE* src;\n\tBYTE* yplane = NULL;\n\tBYTE* coplane = NULL;\n\tBYTE* cgplane = NULL;\n\tBYTE* aplane = NULL;\n\t__m128i r_val;\n\t__m128i g_val;\n\t__m128i b_val;\n\t__m128i a_val;\n\t__m128i y_val;\n\t__m128i co_val;\n\t__m128i cg_val;\n\tUINT32 tempWidth;\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\trw = (context->ChromaSubsamplingLevel > 0 ? tempWidth : context->width);\n\tccl = context->ColorLossLevel;\n\n\tfor (y = 0; y < context->height; y++)\n\t{\n\t\tsrc = data + (context->height - 1 - y) * scanline;\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\taplane = context->priv->PlaneBuffers[3] + y * context->width;\n\n\t\tfor (x = 0; x < context->width; x += 8)\n\t\t{\n\t\t\tswitch (context->format)\n\t\t\t{\n\t\t\t\tcase PIXEL_FORMAT_BGRX32:\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGRA32:\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set_epi16(*(src + 31), *(src + 27), *(src + 23), *(src + 19),\n\t\t\t\t\t                      *(src + 15), *(src + 11), *(src + 7), *(src + 3));\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBX32:\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGBA32:\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 28), *(src + 24), *(src + 20), *(src + 16),\n\t\t\t\t\t                      *(src + 12), *(src + 8), *(src + 4), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 29), *(src + 25), *(src + 21), *(src + 17),\n\t\t\t\t\t                      *(src + 13), *(src + 9), *(src + 5), *(src + 1));\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 30), *(src + 26), *(src + 22), *(src + 18),\n\t\t\t\t\t                      *(src + 14), *(src + 10), *(src + 6), *(src + 2));\n\t\t\t\t\ta_val = _mm_set_epi16(*(src + 31), *(src + 27), *(src + 23), *(src + 19),\n\t\t\t\t\t                      *(src + 15), *(src + 11), *(src + 7), *(src + 3));\n\t\t\t\t\tsrc += 32;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR24:\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 21), *(src + 18), *(src + 15), *(src + 12),\n\t\t\t\t\t                      *(src + 9), *(src + 6), *(src + 3), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 22), *(src + 19), *(src + 16), *(src + 13),\n\t\t\t\t\t                      *(src + 10), *(src + 7), *(src + 4), *(src + 1));\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 23), *(src + 20), *(src + 17), *(src + 14),\n\t\t\t\t\t                      *(src + 11), *(src + 8), *(src + 5), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 24;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB24:\n\t\t\t\t\tr_val = _mm_set_epi16(*(src + 21), *(src + 18), *(src + 15), *(src + 12),\n\t\t\t\t\t                      *(src + 9), *(src + 6), *(src + 3), *src);\n\t\t\t\t\tg_val = _mm_set_epi16(*(src + 22), *(src + 19), *(src + 16), *(src + 13),\n\t\t\t\t\t                      *(src + 10), *(src + 7), *(src + 4), *(src + 1));\n\t\t\t\t\tb_val = _mm_set_epi16(*(src + 23), *(src + 20), *(src + 17), *(src + 14),\n\t\t\t\t\t                      *(src + 11), *(src + 8), *(src + 5), *(src + 2));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 24;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_BGR16:\n\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t            (((*(src + 15)) & 0xF8) | ((*(src + 15)) >> 5)),\n\t\t\t\t\t            (((*(src + 13)) & 0xF8) | ((*(src + 13)) >> 5)),\n\t\t\t\t\t            (((*(src + 11)) & 0xF8) | ((*(src + 11)) >> 5)),\n\t\t\t\t\t            (((*(src + 9)) & 0xF8) | ((*(src + 9)) >> 5)),\n\t\t\t\t\t            (((*(src + 7)) & 0xF8) | ((*(src + 7)) >> 5)),\n\t\t\t\t\t            (((*(src + 5)) & 0xF8) | ((*(src + 5)) >> 5)),\n\t\t\t\t\t            (((*(src + 3)) & 0xF8) | ((*(src + 3)) >> 5)),\n\t\t\t\t\t            (((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5)));\n\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 15)) & 0x07) << 5) | (((*(src + 14)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 13)) & 0x07) << 5) | (((*(src + 12)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 11)) & 0x07) << 5) | (((*(src + 10)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 9)) & 0x07) << 5) | (((*(src + 8)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 7)) & 0x07) << 5) | (((*(src + 6)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 5)) & 0x07) << 5) | (((*(src + 4)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 3)) & 0x07) << 5) | (((*(src + 2)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3)));\n\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 14)) & 0x1F) << 3) | (((*(src + 14)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 12)) & 0x1F) << 3) | (((*(src + 12)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 10)) & 0x1F) << 3) | (((*(src + 10)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 8)) & 0x1F) << 3) | (((*(src + 8)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 6)) & 0x1F) << 3) | (((*(src + 6)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 4)) & 0x1F) << 3) | (((*(src + 4)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 2)) & 0x1F) << 3) | (((*(src + 2)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07)));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB16:\n\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t            (((*(src + 15)) & 0xF8) | ((*(src + 15)) >> 5)),\n\t\t\t\t\t            (((*(src + 13)) & 0xF8) | ((*(src + 13)) >> 5)),\n\t\t\t\t\t            (((*(src + 11)) & 0xF8) | ((*(src + 11)) >> 5)),\n\t\t\t\t\t            (((*(src + 9)) & 0xF8) | ((*(src + 9)) >> 5)),\n\t\t\t\t\t            (((*(src + 7)) & 0xF8) | ((*(src + 7)) >> 5)),\n\t\t\t\t\t            (((*(src + 5)) & 0xF8) | ((*(src + 5)) >> 5)),\n\t\t\t\t\t            (((*(src + 3)) & 0xF8) | ((*(src + 3)) >> 5)),\n\t\t\t\t\t            (((*(src + 1)) & 0xF8) | ((*(src + 1)) >> 5)));\n\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 15)) & 0x07) << 5) | (((*(src + 14)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 13)) & 0x07) << 5) | (((*(src + 12)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 11)) & 0x07) << 5) | (((*(src + 10)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 9)) & 0x07) << 5) | (((*(src + 8)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 7)) & 0x07) << 5) | (((*(src + 6)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 5)) & 0x07) << 5) | (((*(src + 4)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 3)) & 0x07) << 5) | (((*(src + 2)) & 0xE0) >> 3)),\n\t\t\t\t\t            ((((*(src + 1)) & 0x07) << 5) | (((*src) & 0xE0) >> 3)));\n\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t            ((((*(src + 14)) & 0x1F) << 3) | (((*(src + 14)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 12)) & 0x1F) << 3) | (((*(src + 12)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 10)) & 0x1F) << 3) | (((*(src + 10)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 8)) & 0x1F) << 3) | (((*(src + 8)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 6)) & 0x1F) << 3) | (((*(src + 6)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 4)) & 0x1F) << 3) | (((*(src + 4)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*(src + 2)) & 0x1F) << 3) | (((*(src + 2)) >> 2) & 0x07)),\n\t\t\t\t\t            ((((*src) & 0x1F) << 3) | (((*src) >> 2) & 0x07)));\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tsrc += 16;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_A4:\n\t\t\t\t\t{\n\t\t\t\t\t\tint shift;\n\t\t\t\t\t\tBYTE idx[8];\n\n\t\t\t\t\t\tfor (shift = 7; shift >= 0; shift--)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tidx[shift] = ((*src) >> shift) & 1;\n\t\t\t\t\t\t\tidx[shift] |= (((*(src + 1)) >> shift) & 1) << 1;\n\t\t\t\t\t\t\tidx[shift] |= (((*(src + 2)) >> shift) & 1) << 2;\n\t\t\t\t\t\t\tidx[shift] |= (((*(src + 3)) >> shift) & 1) << 3;\n\t\t\t\t\t\t\tidx[shift] *= 3;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[idx[0]],\n\t\t\t\t\t\t            context->palette[idx[1]],\n\t\t\t\t\t\t            context->palette[idx[2]],\n\t\t\t\t\t\t            context->palette[idx[3]],\n\t\t\t\t\t\t            context->palette[idx[4]],\n\t\t\t\t\t\t            context->palette[idx[5]],\n\t\t\t\t\t\t            context->palette[idx[6]],\n\t\t\t\t\t\t            context->palette[idx[7]]);\n\t\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[idx[0] + 1],\n\t\t\t\t\t\t            context->palette[idx[1] + 1],\n\t\t\t\t\t\t            context->palette[idx[2] + 1],\n\t\t\t\t\t\t            context->palette[idx[3] + 1],\n\t\t\t\t\t\t            context->palette[idx[4] + 1],\n\t\t\t\t\t\t            context->palette[idx[5] + 1],\n\t\t\t\t\t\t            context->palette[idx[6] + 1],\n\t\t\t\t\t\t            context->palette[idx[7] + 1]);\n\t\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[idx[0] + 2],\n\t\t\t\t\t\t            context->palette[idx[1] + 2],\n\t\t\t\t\t\t            context->palette[idx[2] + 2],\n\t\t\t\t\t\t            context->palette[idx[3] + 2],\n\t\t\t\t\t\t            context->palette[idx[4] + 2],\n\t\t\t\t\t\t            context->palette[idx[5] + 2],\n\t\t\t\t\t\t            context->palette[idx[6] + 2],\n\t\t\t\t\t\t            context->palette[idx[7] + 2]);\n\t\t\t\t\t\tsrc += 4;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase PIXEL_FORMAT_RGB8:\n\t\t\t\t\t{\n\t\t\t\t\t\tr_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[(*(src + 7)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 6)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 5)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 4)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 3)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 2)) * 3],\n\t\t\t\t\t\t            context->palette[(*(src + 1)) * 3],\n\t\t\t\t\t\t            context->palette[(*src) * 3]);\n\t\t\t\t\t\tg_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[(*(src + 7)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 6)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 5)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 4)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 3)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 2)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*(src + 1)) * 3 + 1],\n\t\t\t\t\t\t            context->palette[(*src) * 3 + 1]);\n\t\t\t\t\t\tb_val = _mm_set_epi16(\n\t\t\t\t\t\t            context->palette[(*(src + 7)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 6)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 5)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 4)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 3)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 2)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*(src + 1)) * 3 + 2],\n\t\t\t\t\t\t            context->palette[(*src) * 3 + 2]);\n\t\t\t\t\t\tsrc += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ta_val = _mm_set1_epi16(0xFF);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tr_val = g_val = b_val = a_val = _mm_set1_epi16(0);\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ty_val = _mm_srai_epi16(r_val, 2);\n\t\t\ty_val = _mm_add_epi16(y_val, _mm_srai_epi16(g_val, 1));\n\t\t\ty_val = _mm_add_epi16(y_val, _mm_srai_epi16(b_val, 2));\n\t\t\tco_val = _mm_sub_epi16(r_val, b_val);\n\t\t\tco_val = _mm_srai_epi16(co_val, ccl);\n\t\t\tcg_val = _mm_sub_epi16(g_val, _mm_srai_epi16(r_val, 1));\n\t\t\tcg_val = _mm_sub_epi16(cg_val, _mm_srai_epi16(b_val, 1));\n\t\t\tcg_val = _mm_srai_epi16(cg_val, ccl);\n\t\t\ty_val = _mm_packus_epi16(y_val, y_val);\n\t\t\t_mm_storeu_si128((__m128i*) yplane, y_val);\n\t\t\tco_val = _mm_packs_epi16(co_val, co_val);\n\t\t\t_mm_storeu_si128((__m128i*) coplane, co_val);\n\t\t\tcg_val = _mm_packs_epi16(cg_val, cg_val);\n\t\t\t_mm_storeu_si128((__m128i*) cgplane, cg_val);\n\t\t\ta_val = _mm_packus_epi16(a_val, a_val);\n\t\t\t_mm_storeu_si128((__m128i*) aplane, a_val);\n\t\t\typlane += 8;\n\t\t\tcoplane += 8;\n\t\t\tcgplane += 8;\n\t\t\taplane += 8;\n\t\t}\n\n\t\tif (context->ChromaSubsamplingLevel > 0 && (context->width % 2) == 1)\n\t\t{\n\t\t\tcontext->priv->PlaneBuffers[0][y * rw + context->width] =\n\t\t\t    context->priv->PlaneBuffers[0][y * rw + context->width - 1];\n\t\t\tcontext->priv->PlaneBuffers[1][y * rw + context->width] =\n\t\t\t    context->priv->PlaneBuffers[1][y * rw + context->width - 1];\n\t\t\tcontext->priv->PlaneBuffers[2][y * rw + context->width] =\n\t\t\t    context->priv->PlaneBuffers[2][y * rw + context->width - 1];\n\t\t}\n\t}\n\n\tif (context->ChromaSubsamplingLevel > 0 && (y % 2) == 1)\n\t{\n\t\typlane = context->priv->PlaneBuffers[0] + y * rw;\n\t\tcoplane = context->priv->PlaneBuffers[1] + y * rw;\n\t\tcgplane = context->priv->PlaneBuffers[2] + y * rw;\n\t\tCopyMemory(yplane, yplane - rw, rw);\n\t\tCopyMemory(coplane, coplane - rw, rw);\n\t\tCopyMemory(cgplane, cgplane - rw, rw);\n\t}\n}\n\nstatic void nsc_encode_subsampling_sse2(NSC_CONTEXT* context)\n{\n\tUINT16 x;\n\tUINT16 y;\n\tBYTE* co_dst;\n\tBYTE* cg_dst;\n\tINT8* co_src0;\n\tINT8* co_src1;\n\tINT8* cg_src0;\n\tINT8* cg_src1;\n\tUINT32 tempWidth;\n\tUINT32 tempHeight;\n\t__m128i t;\n\t__m128i val;\n\t__m128i mask = _mm_set1_epi16(0xFF);\n\ttempWidth = ROUND_UP_TO(context->width, 8);\n\ttempHeight = ROUND_UP_TO(context->height, 2);\n\n\tfor (y = 0; y < tempHeight >> 1; y++)\n\t{\n\t\tco_dst = context->priv->PlaneBuffers[1] + y * (tempWidth >> 1);\n\t\tcg_dst = context->priv->PlaneBuffers[2] + y * (tempWidth >> 1);\n\t\tco_src0 = (INT8*) context->priv->PlaneBuffers[1] + (y << 1) * tempWidth;\n\t\tco_src1 = co_src0 + tempWidth;\n\t\tcg_src0 = (INT8*) context->priv->PlaneBuffers[2] + (y << 1) * tempWidth;\n\t\tcg_src1 = cg_src0 + tempWidth;\n\n\t\tfor (x = 0; x < tempWidth >> 1; x += 8)\n\t\t{\n\t\t\tt = _mm_loadu_si128((__m128i*) co_src0);\n\t\t\tt = _mm_avg_epu8(t, _mm_loadu_si128((__m128i*) co_src1));\n\t\t\tval = _mm_and_si128(_mm_srli_si128(t, 1), mask);\n\t\t\tval = _mm_avg_epu16(val, _mm_and_si128(t, mask));\n\t\t\tval = _mm_packus_epi16(val, val);\n\t\t\t_mm_storeu_si128((__m128i*) co_dst, val);\n\t\t\tco_dst += 8;\n\t\t\tco_src0 += 16;\n\t\t\tco_src1 += 16;\n\t\t\tt = _mm_loadu_si128((__m128i*) cg_src0);\n\t\t\tt = _mm_avg_epu8(t, _mm_loadu_si128((__m128i*) cg_src1));\n\t\t\tval = _mm_and_si128(_mm_srli_si128(t, 1), mask);\n\t\t\tval = _mm_avg_epu16(val, _mm_and_si128(t, mask));\n\t\t\tval = _mm_packus_epi16(val, val);\n\t\t\t_mm_storeu_si128((__m128i*) cg_dst, val);\n\t\t\tcg_dst += 8;\n\t\t\tcg_src0 += 16;\n\t\t\tcg_src1 += 16;\n\t\t}\n\t}\n}\n\nstatic BOOL nsc_encode_sse2(NSC_CONTEXT* context, const BYTE* data,\n                            UINT32 scanline)\n{\n\tnsc_encode_argb_to_aycocg_sse2(context, data, scanline);\n\n\tif (context->ChromaSubsamplingLevel > 0)\n\t{\n\t\tnsc_encode_subsampling_sse2(context);\n\t}\n\n\treturn TRUE;\n}\n\nvoid nsc_init_sse2(NSC_CONTEXT* context)\n{\n\tif (!IsProcessorFeaturePresent(PF_XMMI64_INSTRUCTIONS_AVAILABLE))\n\t\treturn;\n\n\tPROFILER_RENAME(context->priv->prof_nsc_encode, \"nsc_encode_sse2\");\n\tcontext->encode = nsc_encode_sse2;\n}\n"], "filenames": ["include/freerdp/codec/nsc.h", "libfreerdp/codec/nsc.c", "libfreerdp/codec/nsc_encode.c", "libfreerdp/codec/nsc_encode.h", "libfreerdp/codec/nsc_sse2.c"], "buggy_code_start_loc": [80, 45, 53, 27, 388], "buggy_code_end_loc": [82, 406, 296, 28, 396], "fixing_code_start_loc": [80, 45, 54, 27, 388], "fixing_code_end_loc": [82, 472, 322, 28, 399], "type": "CWE-787", "message": "FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution.", "other": {"cve": {"id": "CVE-2018-8788", "sourceIdentifier": "cve@checkpoint.com", "published": "2018-11-29T18:29:00.990", "lastModified": "2019-06-03T16:29:00.700", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FreeRDP prior to version 2.0.0-rc4 contains an Out-Of-Bounds Write of up to 4 bytes in function nsc_rle_decode() that results in a memory corruption and possibly even a remote code execution."}, {"lang": "es", "value": "FreeRDP en versiones anteriores a la 2.0.0-rc4 contiene una escritura fuera de l\u00edmites de hasta 4 bytes en la funci\u00f3n nsc_rle_decode() que resulta en una corrupci\u00f3n de memoria y, probablemente, incluso en la ejecuci\u00f3n remota de c\u00f3digo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}, {"source": "cve@checkpoint.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.2.0", "matchCriteriaId": "FB13905B-B0E9-443E-B150-9D64E20DC464"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc1:*:*:*:*:*:*", "matchCriteriaId": "F226993C-3AB8-4F86-8591-40CAAC8DD73E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "985D90BF-3B2B-4A3C-B698-DBCB0241B95B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:2.0.0:rc3:*:*:*:*:*:*", "matchCriteriaId": "7C4656D2-EEC4-4871-BA0F-76F760526B1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/106938", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2019:0697", "source": "cve@checkpoint.com"}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659", "source": "cve@checkpoint.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/02/msg00015.html", "source": "cve@checkpoint.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://research.checkpoint.com/reverse-rdp-attack-code-execution-on-rdp-clients/", "source": "cve@checkpoint.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-1/", "source": "cve@checkpoint.com", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/3845-2/", "source": "cve@checkpoint.com"}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/d1112c279bd1a327e8e4d0b5f371458bf2579659"}}