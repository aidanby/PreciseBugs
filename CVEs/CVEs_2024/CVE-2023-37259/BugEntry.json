{"buggy_code": ["/*\nCopyright 2021 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Room } from \"matrix-js-sdk/src/models/room\";\nimport { MatrixEvent } from \"matrix-js-sdk/src/models/event\";\nimport { renderToStaticMarkup } from \"react-dom/server\";\nimport { EventType, MsgType } from \"matrix-js-sdk/src/@types/event\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\n\nimport Exporter from \"./Exporter\";\nimport { mediaFromMxc } from \"../../customisations/Media\";\nimport { Layout } from \"../../settings/enums/Layout\";\nimport { shouldFormContinuation } from \"../../components/structures/MessagePanel\";\nimport { formatFullDateNoDayNoTime, wantsDateSeparator } from \"../../DateUtils\";\nimport { RoomPermalinkCreator } from \"../permalinks/Permalinks\";\nimport { _t } from \"../../languageHandler\";\nimport * as Avatar from \"../../Avatar\";\nimport EventTile from \"../../components/views/rooms/EventTile\";\nimport DateSeparator from \"../../components/views/messages/DateSeparator\";\nimport BaseAvatar from \"../../components/views/avatars/BaseAvatar\";\nimport { ExportType, IExportOptions } from \"./exportUtils\";\nimport MatrixClientContext from \"../../contexts/MatrixClientContext\";\nimport getExportCSS from \"./exportCSS\";\nimport { textForEvent } from \"../../TextForEvent\";\nimport { haveRendererForEvent } from \"../../events/EventTileFactory\";\n\nimport exportJS from \"!!raw-loader!./exportJS\";\n\nexport default class HTMLExporter extends Exporter {\n    protected avatars: Map<string, boolean>;\n    protected permalinkCreator: RoomPermalinkCreator;\n    protected totalSize: number;\n    protected mediaOmitText: string;\n\n    public constructor(\n        room: Room,\n        exportType: ExportType,\n        exportOptions: IExportOptions,\n        setProgressText: React.Dispatch<React.SetStateAction<string>>,\n    ) {\n        super(room, exportType, exportOptions, setProgressText);\n        this.avatars = new Map<string, boolean>();\n        this.permalinkCreator = new RoomPermalinkCreator(this.room);\n        this.totalSize = 0;\n        this.mediaOmitText = !this.exportOptions.attachmentsIncluded\n            ? _t(\"Media omitted\")\n            : _t(\"Media omitted - file size limit exceeded\");\n    }\n\n    protected async getRoomAvatar(): Promise<string> {\n        let blob: Blob | undefined = undefined;\n        const avatarUrl = Avatar.avatarUrlForRoom(this.room, 32, 32, \"crop\");\n        const avatarPath = \"room.png\";\n        if (avatarUrl) {\n            try {\n                const image = await fetch(avatarUrl);\n                blob = await image.blob();\n                this.totalSize += blob.size;\n                this.addFile(avatarPath, blob);\n            } catch (err) {\n                logger.log(\"Failed to fetch room's avatar\" + err);\n            }\n        }\n        const avatar = (\n            <BaseAvatar\n                width={32}\n                height={32}\n                name={this.room.name}\n                title={this.room.name}\n                url={blob ? avatarPath : \"\"}\n                resizeMethod=\"crop\"\n            />\n        );\n        return renderToStaticMarkup(avatar);\n    }\n\n    protected async wrapHTML(content: string, currentPage: number, nbPages: number): Promise<string> {\n        const roomAvatar = await this.getRoomAvatar();\n        const exportDate = formatFullDateNoDayNoTime(new Date());\n        const creator = this.room.currentState.getStateEvents(EventType.RoomCreate, \"\")?.getSender();\n        const creatorName = (creator ? this.room.getMember(creator)?.rawDisplayName : creator) || creator;\n        const exporter = this.room.client.getSafeUserId();\n        const exporterName = this.room.getMember(exporter)?.rawDisplayName;\n        const topic = this.room.currentState.getStateEvents(EventType.RoomTopic, \"\")?.getContent()?.topic || \"\";\n        const createdText = _t(\"%(creatorName)s created this room.\", {\n            creatorName,\n        });\n\n        const exportedText = renderToStaticMarkup(\n            <p>\n                {_t(\n                    \"This is the start of export of <roomName/>. Exported by <exporterDetails/> at %(exportDate)s.\",\n                    {\n                        exportDate,\n                    },\n                    {\n                        roomName: () => <b>{this.room.name}</b>,\n                        exporterDetails: () => (\n                            <a href={`https://matrix.to/#/${exporter}`} target=\"_blank\" rel=\"noopener noreferrer\">\n                                {exporterName ? (\n                                    <>\n                                        <b>{exporterName}</b>\n                                        {\" (\" + exporter + \")\"}\n                                    </>\n                                ) : (\n                                    <b>{exporter}</b>\n                                )}\n                            </a>\n                        ),\n                    },\n                )}\n            </p>,\n        );\n\n        const topicText = topic ? _t(\"Topic: %(topic)s\", { topic }) : \"\";\n        const previousMessagesLink = renderToStaticMarkup(\n            currentPage !== 0 ? (\n                <div style={{ textAlign: \"center\" }}>\n                    <a href={`./messages${currentPage === 1 ? \"\" : currentPage}.html`} style={{ fontWeight: \"bold\" }}>\n                        {_t(\"Previous group of messages\")}\n                    </a>\n                </div>\n            ) : (\n                <></>\n            ),\n        );\n\n        const nextMessagesLink = renderToStaticMarkup(\n            currentPage < nbPages - 1 ? (\n                <div style={{ textAlign: \"center\", margin: \"10px\" }}>\n                    <a href={\"./messages\" + (currentPage + 2) + \".html\"} style={{ fontWeight: \"bold\" }}>\n                        {_t(\"Next group of messages\")}\n                    </a>\n                </div>\n            ) : (\n                <></>\n            ),\n        );\n\n        return `\n          <!DOCTYPE html>\n            <html lang=\"en\">\n            <head>\n                <meta charset=\"UTF-8\" />\n                <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n                <link href=\"css/style.css\" rel=\"stylesheet\" />\n                <script src=\"js/script.js\"></script>\n                <title>${_t(\"Exported Data\")}</title>\n            </head>\n            <body style=\"height: 100vh;\">\n                <section\n                id=\"matrixchat\"\n                style=\"height: 100%; overflow: auto\"\n                class=\"notranslate\"\n                >\n                <div class=\"mx_MatrixChat_wrapper\" aria-hidden=\"false\">\n                    <div class=\"mx_MatrixChat\">\n                    <main class=\"mx_RoomView\">\n                        <div class=\"mx_RoomHeader light-panel\">\n                        <div class=\"mx_RoomHeader_wrapper\" aria-owns=\"mx_RightPanel\">\n                            <div class=\"mx_RoomHeader_avatar\">\n                            <div class=\"mx_DecoratedRoomAvatar\">\n                               ${roomAvatar}\n                            </div>\n                            </div>\n                            <div class=\"mx_RoomHeader_name\">\n                            <div\n                                dir=\"auto\"\n                                class=\"mx_RoomHeader_nametext\"\n                                title=\"${this.room.name}\"\n                            >\n                                ${this.room.name}\n                            </div>\n                            </div>\n                            <div class=\"mx_RoomHeader_topic\" dir=\"auto\"> ${topic} </div>\n                        </div>\n                        </div>\n                        ${previousMessagesLink}\n                        <div class=\"mx_MainSplit\">\n                        <div class=\"mx_RoomView_body\">\n                            <div\n                            class=\"mx_RoomView_timeline mx_RoomView_timeline_rr_enabled\"\n                            >\n                            <div\n                                class=\"\n                                mx_AutoHideScrollbar\n                                mx_ScrollPanel\n                                mx_RoomView_messagePanel\n                                \"\n                            >\n                                <div class=\"mx_RoomView_messageListWrapper\">\n                                <ol\n                                    class=\"mx_RoomView_MessageList\"\n                                    aria-live=\"polite\"\n                                    role=\"list\"\n                                >\n                                ${\n                                    currentPage == 0\n                                        ? `<div class=\"mx_NewRoomIntro\">\n                                        ${roomAvatar}\n                                        <h2> ${this.room.name} </h2>\n                                        <p> ${createdText} <br/><br/> ${exportedText} </p>\n                                        <br/>\n                                        <p> ${topicText} </p>\n                                    </div>`\n                                        : \"\"\n                                }\n                                ${content}\n                                </ol>\n                                </div>\n                            </div>\n                            </div>\n                            <div class=\"mx_RoomView_statusArea\">\n                            <div class=\"mx_RoomView_statusAreaBox\">\n                                <div class=\"mx_RoomView_statusAreaBox_line\"></div>\n                            </div>\n                            </div>\n                        </div>\n                        </div>\n                        ${nextMessagesLink}\n                    </main>\n                    </div>\n                </div>\n                </section>\n                <div id=\"snackbar\"/>\n            </body>\n        </html>`;\n    }\n\n    protected getAvatarURL(event: MatrixEvent): string | null {\n        const member = event.sender;\n        const avatarUrl = member?.getMxcAvatarUrl();\n        return avatarUrl ? mediaFromMxc(avatarUrl).getThumbnailOfSourceHttp(30, 30, \"crop\") : null;\n    }\n\n    protected async saveAvatarIfNeeded(event: MatrixEvent): Promise<void> {\n        const member = event.sender!;\n        if (!this.avatars.has(member.userId)) {\n            try {\n                const avatarUrl = this.getAvatarURL(event);\n                this.avatars.set(member.userId, true);\n                const image = await fetch(avatarUrl!);\n                const blob = await image.blob();\n                this.addFile(`users/${member.userId.replace(/:/g, \"-\")}.png`, blob);\n            } catch (err) {\n                logger.log(\"Failed to fetch user's avatar\" + err);\n            }\n        }\n    }\n\n    protected getDateSeparator(event: MatrixEvent): string {\n        const ts = event.getTs();\n        const dateSeparator = (\n            <li key={ts}>\n                <DateSeparator forExport={true} key={ts} roomId={event.getRoomId()!} ts={ts} />\n            </li>\n        );\n        return renderToStaticMarkup(dateSeparator);\n    }\n\n    protected needsDateSeparator(event: MatrixEvent, prevEvent: MatrixEvent | null): boolean {\n        if (!prevEvent) return true;\n        return wantsDateSeparator(prevEvent.getDate() || undefined, event.getDate() || undefined);\n    }\n\n    public getEventTile(mxEv: MatrixEvent, continuation: boolean): JSX.Element {\n        return (\n            <div className=\"mx_Export_EventWrapper\" id={mxEv.getId()}>\n                <MatrixClientContext.Provider value={this.room.client}>\n                    <EventTile\n                        mxEvent={mxEv}\n                        continuation={continuation}\n                        isRedacted={mxEv.isRedacted()}\n                        replacingEventId={mxEv.replacingEventId()}\n                        forExport={true}\n                        alwaysShowTimestamps={true}\n                        showUrlPreview={false}\n                        checkUnmounting={() => false}\n                        isTwelveHour={false}\n                        last={false}\n                        lastInSection={false}\n                        permalinkCreator={this.permalinkCreator}\n                        lastSuccessful={false}\n                        isSelectedEvent={false}\n                        showReactions={false}\n                        layout={Layout.Group}\n                        showReadReceipts={false}\n                    />\n                </MatrixClientContext.Provider>\n            </div>\n        );\n    }\n\n    protected async getEventTileMarkup(mxEv: MatrixEvent, continuation: boolean, filePath?: string): Promise<string> {\n        const avatarUrl = this.getAvatarURL(mxEv);\n        const hasAvatar = !!avatarUrl;\n        if (hasAvatar) await this.saveAvatarIfNeeded(mxEv);\n        const EventTile = this.getEventTile(mxEv, continuation);\n        let eventTileMarkup: string;\n\n        if (\n            mxEv.getContent().msgtype == MsgType.Emote ||\n            mxEv.getContent().msgtype == MsgType.Notice ||\n            mxEv.getContent().msgtype === MsgType.Text\n        ) {\n            // to linkify textual events, we'll need lifecycle methods which won't be invoked in renderToString\n            // So, we'll have to render the component into a temporary root element\n            const tempRoot = document.createElement(\"div\");\n            ReactDOM.render(EventTile, tempRoot);\n            eventTileMarkup = tempRoot.innerHTML;\n        } else {\n            eventTileMarkup = renderToStaticMarkup(EventTile);\n        }\n\n        if (filePath) {\n            const mxc = mxEv.getContent().url ?? mxEv.getContent().file?.url;\n            eventTileMarkup = eventTileMarkup.split(mxc).join(filePath);\n        }\n        eventTileMarkup = eventTileMarkup.replace(/<span class=\"mx_MFileBody_info_icon\".*?>.*?<\\/span>/, \"\");\n        if (hasAvatar) {\n            eventTileMarkup = eventTileMarkup.replace(\n                encodeURI(avatarUrl).replace(/&/g, \"&amp;\"),\n                `users/${mxEv.sender!.userId.replace(/:/g, \"-\")}.png`,\n            );\n        }\n        return eventTileMarkup;\n    }\n\n    protected createModifiedEvent(text: string, mxEv: MatrixEvent, italic = true): MatrixEvent {\n        const modifiedContent = {\n            msgtype: MsgType.Text,\n            body: `${text}`,\n            format: \"org.matrix.custom.html\",\n            formatted_body: `${text}`,\n        };\n        if (italic) {\n            modifiedContent.formatted_body = \"<em>\" + modifiedContent.formatted_body + \"</em>\";\n            modifiedContent.body = \"*\" + modifiedContent.body + \"*\";\n        }\n        const modifiedEvent = new MatrixEvent();\n        modifiedEvent.event = mxEv.event;\n        modifiedEvent.sender = mxEv.sender;\n        modifiedEvent.event.type = \"m.room.message\";\n        modifiedEvent.event.content = modifiedContent;\n        return modifiedEvent;\n    }\n\n    protected async createMessageBody(mxEv: MatrixEvent, joined = false): Promise<string> {\n        let eventTile: string;\n        try {\n            if (this.isAttachment(mxEv)) {\n                if (this.exportOptions.attachmentsIncluded) {\n                    try {\n                        const blob = await this.getMediaBlob(mxEv);\n                        if (this.totalSize + blob.size > this.exportOptions.maxSize) {\n                            eventTile = await this.getEventTileMarkup(\n                                this.createModifiedEvent(this.mediaOmitText, mxEv),\n                                joined,\n                            );\n                        } else {\n                            this.totalSize += blob.size;\n                            const filePath = this.getFilePath(mxEv);\n                            eventTile = await this.getEventTileMarkup(mxEv, joined, filePath);\n                            if (this.totalSize == this.exportOptions.maxSize) {\n                                this.exportOptions.attachmentsIncluded = false;\n                            }\n                            this.addFile(filePath, blob);\n                        }\n                    } catch (e) {\n                        logger.log(\"Error while fetching file\" + e);\n                        eventTile = await this.getEventTileMarkup(\n                            this.createModifiedEvent(_t(\"Error fetching file\"), mxEv),\n                            joined,\n                        );\n                    }\n                } else {\n                    eventTile = await this.getEventTileMarkup(\n                        this.createModifiedEvent(this.mediaOmitText, mxEv),\n                        joined,\n                    );\n                }\n            } else {\n                eventTile = await this.getEventTileMarkup(mxEv, joined);\n            }\n        } catch (e) {\n            // TODO: Handle callEvent errors\n            logger.error(e);\n            eventTile = await this.getEventTileMarkup(\n                this.createModifiedEvent(textForEvent(mxEv, this.room.client), mxEv, false),\n                joined,\n            );\n        }\n\n        return eventTile;\n    }\n\n    protected async createHTML(\n        events: MatrixEvent[],\n        start: number,\n        currentPage: number,\n        nbPages: number,\n    ): Promise<string> {\n        let content = \"\";\n        let prevEvent: MatrixEvent | null = null;\n        for (let i = start; i < Math.min(start + 1000, events.length); i++) {\n            const event = events[i];\n            this.updateProgress(\n                _t(\"Processing event %(number)s out of %(total)s\", {\n                    number: i + 1,\n                    total: events.length,\n                }),\n                false,\n                true,\n            );\n            if (this.cancelled) return this.cleanUp();\n            if (!haveRendererForEvent(event, this.room.client, false)) continue;\n\n            content += this.needsDateSeparator(event, prevEvent) ? this.getDateSeparator(event) : \"\";\n            const shouldBeJoined =\n                !this.needsDateSeparator(event, prevEvent) &&\n                shouldFormContinuation(prevEvent, event, this.room.client, false);\n            const body = await this.createMessageBody(event, shouldBeJoined);\n            this.totalSize += Buffer.byteLength(body);\n            content += body;\n            prevEvent = event;\n        }\n        return this.wrapHTML(content, currentPage, nbPages);\n    }\n\n    public async export(): Promise<void> {\n        this.updateProgress(_t(\"Starting export\u2026\"));\n\n        const fetchStart = performance.now();\n        const res = await this.getRequiredEvents();\n        const fetchEnd = performance.now();\n\n        this.updateProgress(\n            _t(\"Fetched %(count)s events in %(seconds)ss\", {\n                count: res.length,\n                seconds: (fetchEnd - fetchStart) / 1000,\n            }),\n            true,\n            false,\n        );\n\n        this.updateProgress(_t(\"Creating HTML\u2026\"));\n\n        const usedClasses = new Set<string>();\n        for (let page = 0; page < res.length / 1000; page++) {\n            const html = await this.createHTML(res, page * 1000, page, res.length / 1000);\n            const document = new DOMParser().parseFromString(html, \"text/html\");\n            document.querySelectorAll(\"*\").forEach((element) => {\n                element.classList.forEach((c) => usedClasses.add(c));\n            });\n            this.addFile(`messages${page ? page + 1 : \"\"}.html`, new Blob([html]));\n        }\n\n        const exportCSS = await getExportCSS(usedClasses);\n        this.addFile(\"css/style.css\", new Blob([exportCSS]));\n        this.addFile(\"js/script.js\", new Blob([exportJS]));\n\n        await this.downloadZIP();\n\n        const exportEnd = performance.now();\n\n        if (this.cancelled) {\n            logger.info(\"Export cancelled successfully\");\n        } else {\n            this.updateProgress(_t(\"Export successful!\"));\n            this.updateProgress(\n                _t(\"Exported %(count)s events in %(seconds)s seconds\", {\n                    count: res.length,\n                    seconds: (exportEnd - fetchStart) / 1000,\n                }),\n            );\n        }\n\n        this.cleanUp();\n    }\n}\n", "/*\nCopyright 2022 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    EventType,\n    IRoomEvent,\n    MatrixClient,\n    MatrixEvent,\n    MsgType,\n    Room,\n    RoomMember,\n    RoomState,\n} from \"matrix-js-sdk/src/matrix\";\nimport fetchMock from \"fetch-mock-jest\";\n\nimport { filterConsole, mkStubRoom, REPEATABLE_DATE, stubClient } from \"../../test-utils\";\nimport { ExportType, IExportOptions } from \"../../../src/utils/exportUtils/exportUtils\";\nimport SdkConfig from \"../../../src/SdkConfig\";\nimport HTMLExporter from \"../../../src/utils/exportUtils/HtmlExport\";\nimport DMRoomMap from \"../../../src/utils/DMRoomMap\";\nimport { mediaFromMxc } from \"../../../src/customisations/Media\";\n\njest.mock(\"jszip\");\n\nconst EVENT_MESSAGE: IRoomEvent = {\n    event_id: \"$1\",\n    type: EventType.RoomMessage,\n    sender: \"@bob:example.com\",\n    origin_server_ts: 0,\n    content: {\n        msgtype: \"m.text\",\n        body: \"Message\",\n        avatar_url: \"mxc://example.org/avatar.bmp\",\n    },\n};\n\nconst EVENT_ATTACHMENT: IRoomEvent = {\n    event_id: \"$2\",\n    type: EventType.RoomMessage,\n    sender: \"@alice:example.com\",\n    origin_server_ts: 1,\n    content: {\n        msgtype: MsgType.File,\n        body: \"hello.txt\",\n        filename: \"hello.txt\",\n        url: \"mxc://example.org/test-id\",\n    },\n};\n\nconst EVENT_ATTACHMENT_MALFORMED: IRoomEvent = {\n    event_id: \"$2\",\n    type: EventType.RoomMessage,\n    sender: \"@alice:example.com\",\n    origin_server_ts: 1,\n    content: {\n        msgtype: MsgType.File,\n        body: \"hello.txt\",\n        file: {\n            url: undefined,\n        },\n    },\n};\n\ndescribe(\"HTMLExport\", () => {\n    let client: jest.Mocked<MatrixClient>;\n    let room: Room;\n\n    filterConsole(\n        \"Starting export\",\n        \"events in\", // Fetched # events in # seconds\n        \"events so far\",\n        \"Export successful!\",\n        \"does not have an m.room.create event\",\n        \"Creating HTML\",\n        \"Generating a ZIP\",\n        \"Cleaning up\",\n    );\n\n    beforeEach(() => {\n        jest.useFakeTimers();\n        jest.setSystemTime(REPEATABLE_DATE);\n\n        client = stubClient() as jest.Mocked<MatrixClient>;\n        DMRoomMap.makeShared(client);\n\n        room = new Room(\"!myroom:example.org\", client, \"@me:example.org\");\n        client.getRoom.mockReturnValue(room);\n    });\n\n    function mockMessages(...events: IRoomEvent[]): void {\n        client.createMessagesRequest.mockImplementation((_roomId, fromStr, limit = 30) => {\n            const from = fromStr === null ? 0 : parseInt(fromStr);\n            const chunk = events.slice(from, limit);\n            return Promise.resolve({\n                chunk,\n                from: from.toString(),\n                to: (from + limit).toString(),\n            });\n        });\n    }\n\n    /** Retrieve a map of files within the zip. */\n    function getFiles(exporter: HTMLExporter): { [filename: string]: Blob } {\n        //@ts-ignore private access\n        const files = exporter.files;\n        return files.reduce((d, f) => ({ ...d, [f.name]: f.blob }), {});\n    }\n\n    function getMessageFile(exporter: HTMLExporter): Blob {\n        const files = getFiles(exporter);\n        return files[\"messages.html\"]!;\n    }\n\n    /** set a mock fetch response for an MXC */\n    function mockMxc(mxc: string, body: string) {\n        const media = mediaFromMxc(mxc, client);\n        fetchMock.get(media.srcHttp!, body);\n    }\n\n    it(\"should throw when created with invalid config for LastNMessages\", async () => {\n        expect(\n            () =>\n                new HTMLExporter(\n                    room,\n                    ExportType.LastNMessages,\n                    {\n                        attachmentsIncluded: false,\n                        maxSize: 1_024 * 1_024,\n                        numberOfMessages: undefined,\n                    },\n                    () => {},\n                ),\n        ).toThrow(\"Invalid export options\");\n    });\n\n    it(\"should have an SDK-branded destination file name\", () => {\n        const roomName = \"My / Test / Room: Welcome\";\n        const stubOptions: IExportOptions = {\n            attachmentsIncluded: false,\n            maxSize: 50000000,\n        };\n        const stubRoom = mkStubRoom(\"!myroom:example.org\", roomName, client);\n        const exporter = new HTMLExporter(stubRoom, ExportType.Timeline, stubOptions, () => {});\n\n        expect(exporter.destinationFileName).toMatchSnapshot();\n\n        SdkConfig.put({ brand: \"BrandedChat/WithSlashes/ForFun\" });\n\n        expect(exporter.destinationFileName).toMatchSnapshot();\n    });\n\n    it(\"should export\", async () => {\n        const events = [...Array(50)].map<IRoomEvent>((_, i) => ({\n            event_id: `${i}`,\n            type: EventType.RoomMessage,\n            sender: `@user${i}:example.com`,\n            origin_server_ts: 5_000 + i * 1000,\n            content: {\n                msgtype: \"m.text\",\n                body: `Message #${i}`,\n            },\n        }));\n        mockMessages(...events);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.LastNMessages,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n                numberOfMessages: events.length,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const file = getMessageFile(exporter);\n        expect(await file.text()).toMatchSnapshot();\n    });\n\n    it(\"should include the room's avatar\", async () => {\n        mockMessages(EVENT_MESSAGE);\n\n        const mxc = \"mxc://www.example.com/avatars/nice-room.jpeg\";\n        const avatar = \"011011000110111101101100\";\n        jest.spyOn(room, \"getMxcAvatarUrl\").mockReturnValue(mxc);\n        mockMxc(mxc, avatar);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const files = getFiles(exporter);\n        expect(await files[\"room.png\"]!.text()).toBe(avatar);\n    });\n\n    it(\"should include the creation event\", async () => {\n        const creator = \"@bob:example.com\";\n        mockMessages(EVENT_MESSAGE);\n        room.currentState.setStateEvents([\n            new MatrixEvent({\n                type: EventType.RoomCreate,\n                event_id: \"$00001\",\n                room_id: room.roomId,\n                sender: creator,\n                origin_server_ts: 0,\n                content: {},\n                state_key: \"\",\n            }),\n        ]);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        expect(await getMessageFile(exporter).text()).toContain(`${creator} created this room.`);\n    });\n\n    it(\"should include the topic\", async () => {\n        const topic = \":^-) (-^:\";\n        mockMessages(EVENT_MESSAGE);\n        room.currentState.setStateEvents([\n            new MatrixEvent({\n                type: EventType.RoomTopic,\n                event_id: \"$00001\",\n                room_id: room.roomId,\n                sender: \"@alice:example.com\",\n                origin_server_ts: 0,\n                content: { topic },\n                state_key: \"\",\n            }),\n        ]);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        expect(await getMessageFile(exporter).text()).toContain(`Topic: ${topic}`);\n    });\n\n    it(\"should include avatars\", async () => {\n        mockMessages(EVENT_MESSAGE);\n\n        jest.spyOn(RoomMember.prototype, \"getMxcAvatarUrl\").mockReturnValue(\"mxc://example.org/avatar.bmp\");\n\n        const avatarContent = \"this is a bitmap all the pixels are red :^-)\";\n        mockMxc(\"mxc://example.org/avatar.bmp\", avatarContent);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // Ensure that the avatar is present\n        const files = getFiles(exporter);\n        const file = files[\"users/@bob-example.com.png\"];\n        expect(file).not.toBeUndefined();\n\n        // Ensure it has the expected content\n        expect(await file.text()).toBe(avatarContent);\n    });\n\n    it(\"should handle when an event has no sender\", async () => {\n        const EVENT_MESSAGE_NO_SENDER: IRoomEvent = {\n            event_id: \"$1\",\n            type: EventType.RoomMessage,\n            sender: \"\",\n            origin_server_ts: 0,\n            content: {\n                msgtype: \"m.text\",\n                body: \"Message with no sender\",\n            },\n        };\n        mockMessages(EVENT_MESSAGE_NO_SENDER);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const file = getMessageFile(exporter);\n        expect(await file.text()).toContain(EVENT_MESSAGE_NO_SENDER.content.body);\n    });\n\n    it(\"should handle when events sender cannot be found in room state\", async () => {\n        mockMessages(EVENT_MESSAGE);\n\n        jest.spyOn(RoomState.prototype, \"getSentinelMember\").mockReturnValue(null);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const file = getMessageFile(exporter);\n        expect(await file.text()).toContain(EVENT_MESSAGE.content.body);\n    });\n\n    it(\"should include attachments\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT);\n        const attachmentBody = \"Lorem ipsum dolor sit amet\";\n\n        mockMxc(\"mxc://example.org/test-id\", attachmentBody);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: true,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // Ensure that the attachment is present\n        const files = getFiles(exporter);\n        const file = files[Object.keys(files).find((k) => k.endsWith(\".txt\"))!];\n        expect(file).not.toBeUndefined();\n\n        // Ensure that the attachment has the expected content\n        const text = await file.text();\n        expect(text).toBe(attachmentBody);\n    });\n\n    it(\"should handle when attachment cannot be fetched\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT_MALFORMED, EVENT_ATTACHMENT);\n        const attachmentBody = \"Lorem ipsum dolor sit amet\";\n\n        mockMxc(\"mxc://example.org/test-id\", attachmentBody);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: true,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // good attachment present\n        const files = getFiles(exporter);\n        const file = files[Object.keys(files).find((k) => k.endsWith(\".txt\"))!];\n        expect(file).not.toBeUndefined();\n\n        // Ensure that the attachment has the expected content\n        const text = await file.text();\n        expect(text).toBe(attachmentBody);\n\n        // messages export still successful\n        const messagesFile = getMessageFile(exporter);\n        expect(await messagesFile.text()).toBeTruthy();\n    });\n\n    it(\"should handle when attachment srcHttp is falsy\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT);\n        const attachmentBody = \"Lorem ipsum dolor sit amet\";\n\n        mockMxc(\"mxc://example.org/test-id\", attachmentBody);\n\n        jest.spyOn(client, \"mxcUrlToHttp\").mockReturnValue(null);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: true,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // attachment not present\n        const files = getFiles(exporter);\n        const file = files[Object.keys(files).find((k) => k.endsWith(\".txt\"))!];\n        expect(file).toBeUndefined();\n\n        // messages export still successful\n        const messagesFile = getMessageFile(exporter);\n        expect(await messagesFile.text()).toBeTruthy();\n    });\n\n    it(\"should omit attachments\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // Ensure that the attachment is present\n        const files = getFiles(exporter);\n        for (const fileName of Object.keys(files)) {\n            expect(fileName).not.toMatch(/^files\\/hello/);\n        }\n    });\n\n    it(\"should add link to next and previous file\", async () => {\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.LastNMessages,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n                numberOfMessages: 5000,\n            },\n            () => {},\n        );\n\n        // test link to the first page\n        //@ts-ignore private access\n        let result = await exporter.wrapHTML(\"\", 0, 3);\n        expect(result).not.toContain(\"Previous group of messages\");\n        expect(result).toContain(\n            '<div style=\"text-align:center;margin:10px\"><a href=\"./messages2.html\" style=\"font-weight:bold\">Next group of messages</a></div>',\n        );\n\n        // test link for a middle page\n        //@ts-ignore private access\n        result = await exporter.wrapHTML(\"\", 1, 3);\n        expect(result).toContain(\n            '<div style=\"text-align:center\"><a href=\"./messages.html\" style=\"font-weight:bold\">Previous group of messages</a></div>',\n        );\n        expect(result).toContain(\n            '<div style=\"text-align:center;margin:10px\"><a href=\"./messages3.html\" style=\"font-weight:bold\">Next group of messages</a></div>',\n        );\n\n        // test link for last page\n        //@ts-ignore private access\n        result = await exporter.wrapHTML(\"\", 2, 3);\n        expect(result).toContain(\n            '<div style=\"text-align:center\"><a href=\"./messages2.html\" style=\"font-weight:bold\">Previous group of messages</a></div>',\n        );\n        expect(result).not.toContain(\"Next group of messages\");\n    });\n});\n"], "fixing_code": ["/*\nCopyright 2021 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Room } from \"matrix-js-sdk/src/models/room\";\nimport { MatrixEvent } from \"matrix-js-sdk/src/models/event\";\nimport { renderToStaticMarkup } from \"react-dom/server\";\nimport { EventType, MsgType } from \"matrix-js-sdk/src/@types/event\";\nimport { logger } from \"matrix-js-sdk/src/logger\";\nimport escapeHtml from \"escape-html\";\n\nimport Exporter from \"./Exporter\";\nimport { mediaFromMxc } from \"../../customisations/Media\";\nimport { Layout } from \"../../settings/enums/Layout\";\nimport { shouldFormContinuation } from \"../../components/structures/MessagePanel\";\nimport { formatFullDateNoDayNoTime, wantsDateSeparator } from \"../../DateUtils\";\nimport { RoomPermalinkCreator } from \"../permalinks/Permalinks\";\nimport { _t } from \"../../languageHandler\";\nimport * as Avatar from \"../../Avatar\";\nimport EventTile from \"../../components/views/rooms/EventTile\";\nimport DateSeparator from \"../../components/views/messages/DateSeparator\";\nimport BaseAvatar from \"../../components/views/avatars/BaseAvatar\";\nimport { ExportType, IExportOptions } from \"./exportUtils\";\nimport MatrixClientContext from \"../../contexts/MatrixClientContext\";\nimport getExportCSS from \"./exportCSS\";\nimport { textForEvent } from \"../../TextForEvent\";\nimport { haveRendererForEvent } from \"../../events/EventTileFactory\";\n\nimport exportJS from \"!!raw-loader!./exportJS\";\n\nexport default class HTMLExporter extends Exporter {\n    protected avatars: Map<string, boolean>;\n    protected permalinkCreator: RoomPermalinkCreator;\n    protected totalSize: number;\n    protected mediaOmitText: string;\n\n    public constructor(\n        room: Room,\n        exportType: ExportType,\n        exportOptions: IExportOptions,\n        setProgressText: React.Dispatch<React.SetStateAction<string>>,\n    ) {\n        super(room, exportType, exportOptions, setProgressText);\n        this.avatars = new Map<string, boolean>();\n        this.permalinkCreator = new RoomPermalinkCreator(this.room);\n        this.totalSize = 0;\n        this.mediaOmitText = !this.exportOptions.attachmentsIncluded\n            ? _t(\"Media omitted\")\n            : _t(\"Media omitted - file size limit exceeded\");\n    }\n\n    protected async getRoomAvatar(): Promise<string> {\n        let blob: Blob | undefined = undefined;\n        const avatarUrl = Avatar.avatarUrlForRoom(this.room, 32, 32, \"crop\");\n        const avatarPath = \"room.png\";\n        if (avatarUrl) {\n            try {\n                const image = await fetch(avatarUrl);\n                blob = await image.blob();\n                this.totalSize += blob.size;\n                this.addFile(avatarPath, blob);\n            } catch (err) {\n                logger.log(\"Failed to fetch room's avatar\" + err);\n            }\n        }\n        const avatar = (\n            <BaseAvatar\n                width={32}\n                height={32}\n                name={this.room.name}\n                title={this.room.name}\n                url={blob ? avatarPath : \"\"}\n                resizeMethod=\"crop\"\n            />\n        );\n        return renderToStaticMarkup(avatar);\n    }\n\n    protected async wrapHTML(content: string, currentPage: number, nbPages: number): Promise<string> {\n        const roomAvatar = await this.getRoomAvatar();\n        const exportDate = formatFullDateNoDayNoTime(new Date());\n        const creator = this.room.currentState.getStateEvents(EventType.RoomCreate, \"\")?.getSender();\n        const creatorName = (creator ? this.room.getMember(creator)?.rawDisplayName : creator) || creator;\n        const exporter = this.room.client.getSafeUserId();\n        const exporterName = this.room.getMember(exporter)?.rawDisplayName;\n        const topic = this.room.currentState.getStateEvents(EventType.RoomTopic, \"\")?.getContent()?.topic || \"\";\n\n        const safeCreatedText = escapeHtml(\n            _t(\"%(creatorName)s created this room.\", {\n                creatorName,\n            }),\n        );\n        const safeExporter = escapeHtml(exporter);\n        const safeRoomName = escapeHtml(this.room.name);\n        const safeTopic = escapeHtml(topic);\n        const safeExportedText = renderToStaticMarkup(\n            <p>\n                {_t(\n                    \"This is the start of export of <roomName/>. Exported by <exporterDetails/> at %(exportDate)s.\",\n                    {\n                        exportDate,\n                    },\n                    {\n                        roomName: () => <b>{safeRoomName}</b>,\n                        exporterDetails: () => (\n                            <a\n                                href={`https://matrix.to/#/${encodeURIComponent(exporter)}`}\n                                target=\"_blank\"\n                                rel=\"noopener noreferrer\"\n                            >\n                                {exporterName ? (\n                                    <>\n                                        <b>{escapeHtml(exporterName)}</b>I {\" (\" + safeExporter + \")\"}\n                                    </>\n                                ) : (\n                                    <b>{safeExporter}</b>\n                                )}\n                            </a>\n                        ),\n                    },\n                )}\n            </p>,\n        );\n\n        const safeTopicText = topic ? _t(\"Topic: %(topic)s\", { topic: safeTopic }) : \"\";\n        const previousMessagesLink = renderToStaticMarkup(\n            currentPage !== 0 ? (\n                <div style={{ textAlign: \"center\" }}>\n                    <a href={`./messages${currentPage === 1 ? \"\" : currentPage}.html`} style={{ fontWeight: \"bold\" }}>\n                        {_t(\"Previous group of messages\")}\n                    </a>\n                </div>\n            ) : (\n                <></>\n            ),\n        );\n\n        const nextMessagesLink = renderToStaticMarkup(\n            currentPage < nbPages - 1 ? (\n                <div style={{ textAlign: \"center\", margin: \"10px\" }}>\n                    <a href={\"./messages\" + (currentPage + 2) + \".html\"} style={{ fontWeight: \"bold\" }}>\n                        {_t(\"Next group of messages\")}\n                    </a>\n                </div>\n            ) : (\n                <></>\n            ),\n        );\n\n        return `\n          <!DOCTYPE html>\n            <html lang=\"en\">\n            <head>\n                <meta charset=\"UTF-8\" />\n                <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\" />\n                <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n                <link href=\"css/style.css\" rel=\"stylesheet\" />\n                <script src=\"js/script.js\"></script>\n                <title>${_t(\"Exported Data\")}</title>\n            </head>\n            <body style=\"height: 100vh;\">\n                <section\n                id=\"matrixchat\"\n                style=\"height: 100%; overflow: auto\"\n                class=\"notranslate\"\n                >\n                <div class=\"mx_MatrixChat_wrapper\" aria-hidden=\"false\">\n                    <div class=\"mx_MatrixChat\">\n                    <main class=\"mx_RoomView\">\n                        <div class=\"mx_RoomHeader light-panel\">\n                        <div class=\"mx_RoomHeader_wrapper\" aria-owns=\"mx_RightPanel\">\n                            <div class=\"mx_RoomHeader_avatar\">\n                            <div class=\"mx_DecoratedRoomAvatar\">\n                               ${roomAvatar}\n                            </div>\n                            </div>\n                            <div class=\"mx_RoomHeader_name\">\n                            <div\n                                dir=\"auto\"\n                                class=\"mx_RoomHeader_nametext\"\n                                title=\"${safeRoomName}\"\n                            >\n                                ${safeRoomName}\n                            </div>\n                            </div>\n                            <div class=\"mx_RoomHeader_topic\" dir=\"auto\"> ${safeTopic} </div>\n                        </div>\n                        </div>\n                        ${previousMessagesLink}\n                        <div class=\"mx_MainSplit\">\n                        <div class=\"mx_RoomView_body\">\n                            <div\n                            class=\"mx_RoomView_timeline mx_RoomView_timeline_rr_enabled\"\n                            >\n                            <div\n                                class=\"\n                                mx_AutoHideScrollbar\n                                mx_ScrollPanel\n                                mx_RoomView_messagePanel\n                                \"\n                            >\n                                <div class=\"mx_RoomView_messageListWrapper\">\n                                <ol\n                                    class=\"mx_RoomView_MessageList\"\n                                    aria-live=\"polite\"\n                                    role=\"list\"\n                                >\n                                ${\n                                    currentPage == 0\n                                        ? `<div class=\"mx_NewRoomIntro\">\n                                        ${roomAvatar}\n                                        <h2> ${safeRoomName} </h2>\n                                        <p> ${safeCreatedText} <br/><br/> ${safeExportedText} </p>\n                                        <br/>\n                                        <p> ${safeTopicText} </p>\n                                    </div>`\n                                        : \"\"\n                                }\n                                ${content}\n                                </ol>\n                                </div>\n                            </div>\n                            </div>\n                            <div class=\"mx_RoomView_statusArea\">\n                            <div class=\"mx_RoomView_statusAreaBox\">\n                                <div class=\"mx_RoomView_statusAreaBox_line\"></div>\n                            </div>\n                            </div>\n                        </div>\n                        </div>\n                        ${nextMessagesLink}\n                    </main>\n                    </div>\n                </div>\n                </section>\n                <div id=\"snackbar\"/>\n            </body>\n        </html>`;\n    }\n\n    protected getAvatarURL(event: MatrixEvent): string | null {\n        const member = event.sender;\n        const avatarUrl = member?.getMxcAvatarUrl();\n        return avatarUrl ? mediaFromMxc(avatarUrl).getThumbnailOfSourceHttp(30, 30, \"crop\") : null;\n    }\n\n    protected async saveAvatarIfNeeded(event: MatrixEvent): Promise<void> {\n        const member = event.sender!;\n        if (!this.avatars.has(member.userId)) {\n            try {\n                const avatarUrl = this.getAvatarURL(event);\n                this.avatars.set(member.userId, true);\n                const image = await fetch(avatarUrl!);\n                const blob = await image.blob();\n                this.addFile(`users/${member.userId.replace(/:/g, \"-\")}.png`, blob);\n            } catch (err) {\n                logger.log(\"Failed to fetch user's avatar\" + err);\n            }\n        }\n    }\n\n    protected getDateSeparator(event: MatrixEvent): string {\n        const ts = event.getTs();\n        const dateSeparator = (\n            <li key={ts}>\n                <DateSeparator forExport={true} key={ts} roomId={event.getRoomId()!} ts={ts} />\n            </li>\n        );\n        return renderToStaticMarkup(dateSeparator);\n    }\n\n    protected needsDateSeparator(event: MatrixEvent, prevEvent: MatrixEvent | null): boolean {\n        if (!prevEvent) return true;\n        return wantsDateSeparator(prevEvent.getDate() || undefined, event.getDate() || undefined);\n    }\n\n    public getEventTile(mxEv: MatrixEvent, continuation: boolean): JSX.Element {\n        return (\n            <div className=\"mx_Export_EventWrapper\" id={mxEv.getId()}>\n                <MatrixClientContext.Provider value={this.room.client}>\n                    <EventTile\n                        mxEvent={mxEv}\n                        continuation={continuation}\n                        isRedacted={mxEv.isRedacted()}\n                        replacingEventId={mxEv.replacingEventId()}\n                        forExport={true}\n                        alwaysShowTimestamps={true}\n                        showUrlPreview={false}\n                        checkUnmounting={() => false}\n                        isTwelveHour={false}\n                        last={false}\n                        lastInSection={false}\n                        permalinkCreator={this.permalinkCreator}\n                        lastSuccessful={false}\n                        isSelectedEvent={false}\n                        showReactions={false}\n                        layout={Layout.Group}\n                        showReadReceipts={false}\n                    />\n                </MatrixClientContext.Provider>\n            </div>\n        );\n    }\n\n    protected async getEventTileMarkup(mxEv: MatrixEvent, continuation: boolean, filePath?: string): Promise<string> {\n        const avatarUrl = this.getAvatarURL(mxEv);\n        const hasAvatar = !!avatarUrl;\n        if (hasAvatar) await this.saveAvatarIfNeeded(mxEv);\n        const EventTile = this.getEventTile(mxEv, continuation);\n        let eventTileMarkup: string;\n\n        if (\n            mxEv.getContent().msgtype == MsgType.Emote ||\n            mxEv.getContent().msgtype == MsgType.Notice ||\n            mxEv.getContent().msgtype === MsgType.Text\n        ) {\n            // to linkify textual events, we'll need lifecycle methods which won't be invoked in renderToString\n            // So, we'll have to render the component into a temporary root element\n            const tempRoot = document.createElement(\"div\");\n            ReactDOM.render(EventTile, tempRoot);\n            eventTileMarkup = tempRoot.innerHTML;\n        } else {\n            eventTileMarkup = renderToStaticMarkup(EventTile);\n        }\n\n        if (filePath) {\n            const mxc = mxEv.getContent().url ?? mxEv.getContent().file?.url;\n            eventTileMarkup = eventTileMarkup.split(mxc).join(filePath);\n        }\n        eventTileMarkup = eventTileMarkup.replace(/<span class=\"mx_MFileBody_info_icon\".*?>.*?<\\/span>/, \"\");\n        if (hasAvatar) {\n            eventTileMarkup = eventTileMarkup.replace(\n                encodeURI(avatarUrl).replace(/&/g, \"&amp;\"),\n                `users/${mxEv.sender!.userId.replace(/:/g, \"-\")}.png`,\n            );\n        }\n        return eventTileMarkup;\n    }\n\n    protected createModifiedEvent(text: string, mxEv: MatrixEvent, italic = true): MatrixEvent {\n        const modifiedContent = {\n            msgtype: MsgType.Text,\n            body: `${text}`,\n            format: \"org.matrix.custom.html\",\n            formatted_body: `${text}`,\n        };\n        if (italic) {\n            modifiedContent.formatted_body = \"<em>\" + modifiedContent.formatted_body + \"</em>\";\n            modifiedContent.body = \"*\" + modifiedContent.body + \"*\";\n        }\n        const modifiedEvent = new MatrixEvent();\n        modifiedEvent.event = mxEv.event;\n        modifiedEvent.sender = mxEv.sender;\n        modifiedEvent.event.type = \"m.room.message\";\n        modifiedEvent.event.content = modifiedContent;\n        return modifiedEvent;\n    }\n\n    protected async createMessageBody(mxEv: MatrixEvent, joined = false): Promise<string> {\n        let eventTile: string;\n        try {\n            if (this.isAttachment(mxEv)) {\n                if (this.exportOptions.attachmentsIncluded) {\n                    try {\n                        const blob = await this.getMediaBlob(mxEv);\n                        if (this.totalSize + blob.size > this.exportOptions.maxSize) {\n                            eventTile = await this.getEventTileMarkup(\n                                this.createModifiedEvent(this.mediaOmitText, mxEv),\n                                joined,\n                            );\n                        } else {\n                            this.totalSize += blob.size;\n                            const filePath = this.getFilePath(mxEv);\n                            eventTile = await this.getEventTileMarkup(mxEv, joined, filePath);\n                            if (this.totalSize == this.exportOptions.maxSize) {\n                                this.exportOptions.attachmentsIncluded = false;\n                            }\n                            this.addFile(filePath, blob);\n                        }\n                    } catch (e) {\n                        logger.log(\"Error while fetching file\" + e);\n                        eventTile = await this.getEventTileMarkup(\n                            this.createModifiedEvent(_t(\"Error fetching file\"), mxEv),\n                            joined,\n                        );\n                    }\n                } else {\n                    eventTile = await this.getEventTileMarkup(\n                        this.createModifiedEvent(this.mediaOmitText, mxEv),\n                        joined,\n                    );\n                }\n            } else {\n                eventTile = await this.getEventTileMarkup(mxEv, joined);\n            }\n        } catch (e) {\n            // TODO: Handle callEvent errors\n            logger.error(e);\n            eventTile = await this.getEventTileMarkup(\n                this.createModifiedEvent(textForEvent(mxEv, this.room.client), mxEv, false),\n                joined,\n            );\n        }\n\n        return eventTile;\n    }\n\n    protected async createHTML(\n        events: MatrixEvent[],\n        start: number,\n        currentPage: number,\n        nbPages: number,\n    ): Promise<string> {\n        let content = \"\";\n        let prevEvent: MatrixEvent | null = null;\n        for (let i = start; i < Math.min(start + 1000, events.length); i++) {\n            const event = events[i];\n            this.updateProgress(\n                _t(\"Processing event %(number)s out of %(total)s\", {\n                    number: i + 1,\n                    total: events.length,\n                }),\n                false,\n                true,\n            );\n            if (this.cancelled) return this.cleanUp();\n            if (!haveRendererForEvent(event, this.room.client, false)) continue;\n\n            content += this.needsDateSeparator(event, prevEvent) ? this.getDateSeparator(event) : \"\";\n            const shouldBeJoined =\n                !this.needsDateSeparator(event, prevEvent) &&\n                shouldFormContinuation(prevEvent, event, this.room.client, false);\n            const body = await this.createMessageBody(event, shouldBeJoined);\n            this.totalSize += Buffer.byteLength(body);\n            content += body;\n            prevEvent = event;\n        }\n        return this.wrapHTML(content, currentPage, nbPages);\n    }\n\n    public async export(): Promise<void> {\n        this.updateProgress(_t(\"Starting export\u2026\"));\n\n        const fetchStart = performance.now();\n        const res = await this.getRequiredEvents();\n        const fetchEnd = performance.now();\n\n        this.updateProgress(\n            _t(\"Fetched %(count)s events in %(seconds)ss\", {\n                count: res.length,\n                seconds: (fetchEnd - fetchStart) / 1000,\n            }),\n            true,\n            false,\n        );\n\n        this.updateProgress(_t(\"Creating HTML\u2026\"));\n\n        const usedClasses = new Set<string>();\n        for (let page = 0; page < res.length / 1000; page++) {\n            const html = await this.createHTML(res, page * 1000, page, res.length / 1000);\n            const document = new DOMParser().parseFromString(html, \"text/html\");\n            document.querySelectorAll(\"*\").forEach((element) => {\n                element.classList.forEach((c) => usedClasses.add(c));\n            });\n            this.addFile(`messages${page ? page + 1 : \"\"}.html`, new Blob([html]));\n        }\n\n        const exportCSS = await getExportCSS(usedClasses);\n        this.addFile(\"css/style.css\", new Blob([exportCSS]));\n        this.addFile(\"js/script.js\", new Blob([exportJS]));\n\n        await this.downloadZIP();\n\n        const exportEnd = performance.now();\n\n        if (this.cancelled) {\n            logger.info(\"Export cancelled successfully\");\n        } else {\n            this.updateProgress(_t(\"Export successful!\"));\n            this.updateProgress(\n                _t(\"Exported %(count)s events in %(seconds)s seconds\", {\n                    count: res.length,\n                    seconds: (exportEnd - fetchStart) / 1000,\n                }),\n            );\n        }\n\n        this.cleanUp();\n    }\n}\n", "/*\nCopyright 2022 - 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    EventType,\n    IRoomEvent,\n    MatrixClient,\n    MatrixEvent,\n    MsgType,\n    Room,\n    RoomMember,\n    RoomState,\n} from \"matrix-js-sdk/src/matrix\";\nimport fetchMock from \"fetch-mock-jest\";\nimport escapeHtml from \"escape-html\";\n\nimport { filterConsole, mkStubRoom, REPEATABLE_DATE, stubClient } from \"../../test-utils\";\nimport { ExportType, IExportOptions } from \"../../../src/utils/exportUtils/exportUtils\";\nimport SdkConfig from \"../../../src/SdkConfig\";\nimport HTMLExporter from \"../../../src/utils/exportUtils/HtmlExport\";\nimport DMRoomMap from \"../../../src/utils/DMRoomMap\";\nimport { mediaFromMxc } from \"../../../src/customisations/Media\";\n\njest.mock(\"jszip\");\n\nconst EVENT_MESSAGE: IRoomEvent = {\n    event_id: \"$1\",\n    type: EventType.RoomMessage,\n    sender: \"@bob:example.com\",\n    origin_server_ts: 0,\n    content: {\n        msgtype: \"m.text\",\n        body: \"Message\",\n        avatar_url: \"mxc://example.org/avatar.bmp\",\n    },\n};\n\nconst EVENT_ATTACHMENT: IRoomEvent = {\n    event_id: \"$2\",\n    type: EventType.RoomMessage,\n    sender: \"@alice:example.com\",\n    origin_server_ts: 1,\n    content: {\n        msgtype: MsgType.File,\n        body: \"hello.txt\",\n        filename: \"hello.txt\",\n        url: \"mxc://example.org/test-id\",\n    },\n};\n\nconst EVENT_ATTACHMENT_MALFORMED: IRoomEvent = {\n    event_id: \"$2\",\n    type: EventType.RoomMessage,\n    sender: \"@alice:example.com\",\n    origin_server_ts: 1,\n    content: {\n        msgtype: MsgType.File,\n        body: \"hello.txt\",\n        file: {\n            url: undefined,\n        },\n    },\n};\n\ndescribe(\"HTMLExport\", () => {\n    let client: jest.Mocked<MatrixClient>;\n    let room: Room;\n\n    filterConsole(\n        \"Starting export\",\n        \"events in\", // Fetched # events in # seconds\n        \"events so far\",\n        \"Export successful!\",\n        \"does not have an m.room.create event\",\n        \"Creating HTML\",\n        \"Generating a ZIP\",\n        \"Cleaning up\",\n    );\n\n    beforeEach(() => {\n        jest.useFakeTimers();\n        jest.setSystemTime(REPEATABLE_DATE);\n\n        client = stubClient() as jest.Mocked<MatrixClient>;\n        DMRoomMap.makeShared(client);\n\n        room = new Room(\"!myroom:example.org\", client, \"@me:example.org\");\n        client.getRoom.mockReturnValue(room);\n    });\n\n    function mockMessages(...events: IRoomEvent[]): void {\n        client.createMessagesRequest.mockImplementation((_roomId, fromStr, limit = 30) => {\n            const from = fromStr === null ? 0 : parseInt(fromStr);\n            const chunk = events.slice(from, limit);\n            return Promise.resolve({\n                chunk,\n                from: from.toString(),\n                to: (from + limit).toString(),\n            });\n        });\n    }\n\n    /** Retrieve a map of files within the zip. */\n    function getFiles(exporter: HTMLExporter): { [filename: string]: Blob } {\n        //@ts-ignore private access\n        const files = exporter.files;\n        return files.reduce((d, f) => ({ ...d, [f.name]: f.blob }), {});\n    }\n\n    function getMessageFile(exporter: HTMLExporter): Blob {\n        const files = getFiles(exporter);\n        return files[\"messages.html\"]!;\n    }\n\n    /** set a mock fetch response for an MXC */\n    function mockMxc(mxc: string, body: string) {\n        const media = mediaFromMxc(mxc, client);\n        fetchMock.get(media.srcHttp!, body);\n    }\n\n    it(\"should throw when created with invalid config for LastNMessages\", async () => {\n        expect(\n            () =>\n                new HTMLExporter(\n                    room,\n                    ExportType.LastNMessages,\n                    {\n                        attachmentsIncluded: false,\n                        maxSize: 1_024 * 1_024,\n                        numberOfMessages: undefined,\n                    },\n                    () => {},\n                ),\n        ).toThrow(\"Invalid export options\");\n    });\n\n    it(\"should have an SDK-branded destination file name\", () => {\n        const roomName = \"My / Test / Room: Welcome\";\n        const stubOptions: IExportOptions = {\n            attachmentsIncluded: false,\n            maxSize: 50000000,\n        };\n        const stubRoom = mkStubRoom(\"!myroom:example.org\", roomName, client);\n        const exporter = new HTMLExporter(stubRoom, ExportType.Timeline, stubOptions, () => {});\n\n        expect(exporter.destinationFileName).toMatchSnapshot();\n\n        SdkConfig.put({ brand: \"BrandedChat/WithSlashes/ForFun\" });\n\n        expect(exporter.destinationFileName).toMatchSnapshot();\n    });\n\n    it(\"should export\", async () => {\n        const events = [...Array(50)].map<IRoomEvent>((_, i) => ({\n            event_id: `${i}`,\n            type: EventType.RoomMessage,\n            sender: `@user${i}:example.com`,\n            origin_server_ts: 5_000 + i * 1000,\n            content: {\n                msgtype: \"m.text\",\n                body: `Message #${i}`,\n            },\n        }));\n        mockMessages(...events);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.LastNMessages,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n                numberOfMessages: events.length,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const file = getMessageFile(exporter);\n        expect(await file.text()).toMatchSnapshot();\n    });\n\n    it(\"should include the room's avatar\", async () => {\n        mockMessages(EVENT_MESSAGE);\n\n        const mxc = \"mxc://www.example.com/avatars/nice-room.jpeg\";\n        const avatar = \"011011000110111101101100\";\n        jest.spyOn(room, \"getMxcAvatarUrl\").mockReturnValue(mxc);\n        mockMxc(mxc, avatar);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const files = getFiles(exporter);\n        expect(await files[\"room.png\"]!.text()).toBe(avatar);\n    });\n\n    it(\"should include the creation event\", async () => {\n        const creator = \"@bob:example.com\";\n        mockMessages(EVENT_MESSAGE);\n        room.currentState.setStateEvents([\n            new MatrixEvent({\n                type: EventType.RoomCreate,\n                event_id: \"$00001\",\n                room_id: room.roomId,\n                sender: creator,\n                origin_server_ts: 0,\n                content: {},\n                state_key: \"\",\n            }),\n        ]);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        expect(await getMessageFile(exporter).text()).toContain(`${creator} created this room.`);\n    });\n\n    it(\"should include the topic\", async () => {\n        const topic = \":^-) (-^:\";\n        mockMessages(EVENT_MESSAGE);\n        room.currentState.setStateEvents([\n            new MatrixEvent({\n                type: EventType.RoomTopic,\n                event_id: \"$00001\",\n                room_id: room.roomId,\n                sender: \"@alice:example.com\",\n                origin_server_ts: 0,\n                content: { topic },\n                state_key: \"\",\n            }),\n        ]);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        expect(await getMessageFile(exporter).text()).toContain(`Topic: ${topic}`);\n    });\n\n    it(\"should include avatars\", async () => {\n        mockMessages(EVENT_MESSAGE);\n\n        jest.spyOn(RoomMember.prototype, \"getMxcAvatarUrl\").mockReturnValue(\"mxc://example.org/avatar.bmp\");\n\n        const avatarContent = \"this is a bitmap all the pixels are red :^-)\";\n        mockMxc(\"mxc://example.org/avatar.bmp\", avatarContent);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // Ensure that the avatar is present\n        const files = getFiles(exporter);\n        const file = files[\"users/@bob-example.com.png\"];\n        expect(file).not.toBeUndefined();\n\n        // Ensure it has the expected content\n        expect(await file.text()).toBe(avatarContent);\n    });\n\n    it(\"should handle when an event has no sender\", async () => {\n        const EVENT_MESSAGE_NO_SENDER: IRoomEvent = {\n            event_id: \"$1\",\n            type: EventType.RoomMessage,\n            sender: \"\",\n            origin_server_ts: 0,\n            content: {\n                msgtype: \"m.text\",\n                body: \"Message with no sender\",\n            },\n        };\n        mockMessages(EVENT_MESSAGE_NO_SENDER);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const file = getMessageFile(exporter);\n        expect(await file.text()).toContain(EVENT_MESSAGE_NO_SENDER.content.body);\n    });\n\n    it(\"should handle when events sender cannot be found in room state\", async () => {\n        mockMessages(EVENT_MESSAGE);\n\n        jest.spyOn(RoomState.prototype, \"getSentinelMember\").mockReturnValue(null);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        const file = getMessageFile(exporter);\n        expect(await file.text()).toContain(EVENT_MESSAGE.content.body);\n    });\n\n    it(\"should include attachments\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT);\n        const attachmentBody = \"Lorem ipsum dolor sit amet\";\n\n        mockMxc(\"mxc://example.org/test-id\", attachmentBody);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: true,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // Ensure that the attachment is present\n        const files = getFiles(exporter);\n        const file = files[Object.keys(files).find((k) => k.endsWith(\".txt\"))!];\n        expect(file).not.toBeUndefined();\n\n        // Ensure that the attachment has the expected content\n        const text = await file.text();\n        expect(text).toBe(attachmentBody);\n    });\n\n    it(\"should handle when attachment cannot be fetched\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT_MALFORMED, EVENT_ATTACHMENT);\n        const attachmentBody = \"Lorem ipsum dolor sit amet\";\n\n        mockMxc(\"mxc://example.org/test-id\", attachmentBody);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: true,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // good attachment present\n        const files = getFiles(exporter);\n        const file = files[Object.keys(files).find((k) => k.endsWith(\".txt\"))!];\n        expect(file).not.toBeUndefined();\n\n        // Ensure that the attachment has the expected content\n        const text = await file.text();\n        expect(text).toBe(attachmentBody);\n\n        // messages export still successful\n        const messagesFile = getMessageFile(exporter);\n        expect(await messagesFile.text()).toBeTruthy();\n    });\n\n    it(\"should handle when attachment srcHttp is falsy\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT);\n        const attachmentBody = \"Lorem ipsum dolor sit amet\";\n\n        mockMxc(\"mxc://example.org/test-id\", attachmentBody);\n\n        jest.spyOn(client, \"mxcUrlToHttp\").mockReturnValue(null);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: true,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // attachment not present\n        const files = getFiles(exporter);\n        const file = files[Object.keys(files).find((k) => k.endsWith(\".txt\"))!];\n        expect(file).toBeUndefined();\n\n        // messages export still successful\n        const messagesFile = getMessageFile(exporter);\n        expect(await messagesFile.text()).toBeTruthy();\n    });\n\n    it(\"should omit attachments\", async () => {\n        mockMessages(EVENT_MESSAGE, EVENT_ATTACHMENT);\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n\n        // Ensure that the attachment is present\n        const files = getFiles(exporter);\n        for (const fileName of Object.keys(files)) {\n            expect(fileName).not.toMatch(/^files\\/hello/);\n        }\n    });\n\n    it(\"should add link to next and previous file\", async () => {\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.LastNMessages,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n                numberOfMessages: 5000,\n            },\n            () => {},\n        );\n\n        // test link to the first page\n        //@ts-ignore private access\n        let result = await exporter.wrapHTML(\"\", 0, 3);\n        expect(result).not.toContain(\"Previous group of messages\");\n        expect(result).toContain(\n            '<div style=\"text-align:center;margin:10px\"><a href=\"./messages2.html\" style=\"font-weight:bold\">Next group of messages</a></div>',\n        );\n\n        // test link for a middle page\n        //@ts-ignore private access\n        result = await exporter.wrapHTML(\"\", 1, 3);\n        expect(result).toContain(\n            '<div style=\"text-align:center\"><a href=\"./messages.html\" style=\"font-weight:bold\">Previous group of messages</a></div>',\n        );\n        expect(result).toContain(\n            '<div style=\"text-align:center;margin:10px\"><a href=\"./messages3.html\" style=\"font-weight:bold\">Next group of messages</a></div>',\n        );\n\n        // test link for last page\n        //@ts-ignore private access\n        result = await exporter.wrapHTML(\"\", 2, 3);\n        expect(result).toContain(\n            '<div style=\"text-align:center\"><a href=\"./messages2.html\" style=\"font-weight:bold\">Previous group of messages</a></div>',\n        );\n        expect(result).not.toContain(\"Next group of messages\");\n    });\n\n    it(\"should not leak javascript from room names or topics\", async () => {\n        const name = \"<svg onload=alert(3)>\";\n        const topic = \"<svg onload=alert(5)>\";\n        mockMessages(EVENT_MESSAGE);\n        room.currentState.setStateEvents([\n            new MatrixEvent({\n                type: EventType.RoomName,\n                event_id: \"$00001\",\n                room_id: room.roomId,\n                sender: \"@alice:example.com\",\n                origin_server_ts: 0,\n                content: { name },\n                state_key: \"\",\n            }),\n            new MatrixEvent({\n                type: EventType.RoomTopic,\n                event_id: \"$00002\",\n                room_id: room.roomId,\n                sender: \"@alice:example.com\",\n                origin_server_ts: 1,\n                content: { topic },\n                state_key: \"\",\n            }),\n        ]);\n        room.recalculate();\n\n        const exporter = new HTMLExporter(\n            room,\n            ExportType.Timeline,\n            {\n                attachmentsIncluded: false,\n                maxSize: 1_024 * 1_024,\n            },\n            () => {},\n        );\n\n        await exporter.export();\n        const html = await getMessageFile(exporter).text();\n\n        expect(html).not.toContain(`${name}`);\n        expect(html).toContain(`${escapeHtml(name)}`);\n        expect(html).not.toContain(`${topic}`);\n        expect(html).toContain(`Topic: ${escapeHtml(topic)}`);\n    });\n});\n"], "filenames": ["src/utils/exportUtils/HtmlExport.tsx", "test/utils/exportUtils/HTMLExport-test.ts"], "buggy_code_start_loc": [23, 27], "buggy_code_end_loc": [221, 507], "fixing_code_start_loc": [24, 28], "fixing_code_end_loc": [230, 554], "type": "CWE-79", "message": "matrix-react-sdk is a react-based SDK for inserting a Matrix chat/voip client into a web page. The Export Chat feature includes certain attacker-controlled elements in the generated document without sufficient escaping, leading to stored Cross site scripting (XSS). Since the Export Chat feature generates a separate document, an attacker can only inject code run from the `null` origin, restricting the impact. However, the attacker can still potentially use the XSS to leak message contents. A malicious homeserver is a potential attacker since the affected inputs are controllable server-side. This issue has been addressed in commit `22fcd34c60` which is included in release version 3.76.0. Users are advised to upgrade. The only known workaround for this issue is to disable or to not use the Export Chat feature.", "other": {"cve": {"id": "CVE-2023-37259", "sourceIdentifier": "security-advisories@github.com", "published": "2023-07-18T17:15:11.490", "lastModified": "2023-07-27T19:50:08.540", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "matrix-react-sdk is a react-based SDK for inserting a Matrix chat/voip client into a web page. The Export Chat feature includes certain attacker-controlled elements in the generated document without sufficient escaping, leading to stored Cross site scripting (XSS). Since the Export Chat feature generates a separate document, an attacker can only inject code run from the `null` origin, restricting the impact. However, the attacker can still potentially use the XSS to leak message contents. A malicious homeserver is a potential attacker since the affected inputs are controllable server-side. This issue has been addressed in commit `22fcd34c60` which is included in release version 3.76.0. Users are advised to upgrade. The only known workaround for this issue is to disable or to not use the Export Chat feature."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:L/UI:R/S:C/C:H/I:N/A:N", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 4.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:matrix-react-sdk_project:matrix-react-sdk:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.32.0", "versionEndExcluding": "3.76.0", "matchCriteriaId": "E73DB529-1353-4F26-BEE4-8AC754FA3B70"}, {"vulnerable": true, "criteria": "cpe:2.3:a:matrix-react-sdk_project:matrix-react-sdk:3.76.0:rc1:*:*:*:node.js:*:*", "matchCriteriaId": "5664080A-3C0B-423C-A17D-458C8E41BBB6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:matrix-react-sdk_project:matrix-react-sdk:3.76.0:rc2:*:*:*:node.js:*:*", "matchCriteriaId": "3128DB5F-8C45-4362-BF0E-F6F456C2E39E"}]}]}], "references": [{"url": "https://github.com/matrix-org/matrix-react-sdk/commit/22fcd34c606f32129ebc967fc21f24fb708a98b8", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/matrix-org/matrix-react-sdk/security/advisories/GHSA-c9vx-2g7w-rp65", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/matrix-org/matrix-react-sdk/commit/22fcd34c606f32129ebc967fc21f24fb708a98b8"}}