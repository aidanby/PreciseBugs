{"buggy_code": ["const _ = require('lodash');\nconst ActiveConnector = require('../../connector/active');\n\nconst FAMILY = {\n  1: 4,\n  2: 6\n};\n\nmodule.exports = {\n  directive: 'EPRT',\n  handler: function ({command} = {}) {\n    const [, protocol, ip, port] = _.chain(command).get('arg', '').split('|').value();\n    const family = FAMILY[protocol];\n    if (!family) return this.reply(504, 'Unknown network protocol');\n\n    this.connector = new ActiveConnector(this);\n    return this.connector.setupConnection(ip, port, family)\n    .then(() => this.reply(200));\n  },\n  syntax: '{{cmd}} |<protocol>|<address>|<port>|',\n  description: 'Specifies an address and port to which the server should connect'\n};\n", "const PassiveConnector = require('../../connector/passive');\n\nmodule.exports = {\n  directive: 'EPSV',\n  handler: function () {\n    this.connector = new PassiveConnector(this);\n    return this.connector.setupServer()\n    .then((server) => {\n      const {port} = server.address();\n\n      return this.reply(229, `EPSV OK (|||${port}|)`);\n    });\n  },\n  syntax: '{{cmd}} [<protocol>]',\n  description: 'Initiate passive mode'\n};\n", "const PassiveConnector = require('../../connector/passive');\nconst {isLocalIP} = require('../../helpers/is-local');\n\nmodule.exports = {\n  directive: 'PASV',\n  handler: function ({log} = {}) {\n    if (!this.server.options.pasv_url) {\n      return this.reply(502);\n    }\n\n    this.connector = new PassiveConnector(this);\n    return this.connector.setupServer()\n    .then((server) => {\n      let address = this.server.options.pasv_url;\n      // Allow connecting from local\n      if (isLocalIP(this.ip)) {\n        address = this.ip;\n      }\n      const {port} = server.address();\n      const host = address.replace(/\\./g, ',');\n      const portByte1 = port / 256 | 0;\n      const portByte2 = port % 256;\n\n      return this.reply(227, `PASV OK (${host},${portByte1},${portByte2})`);\n    })\n    .catch((err) => {\n      log.error(err);\n      return this.reply(425);\n    });\n  },\n  syntax: '{{cmd}}',\n  description: 'Initiate passive mode'\n};\n", "const _ = require('lodash');\nconst ActiveConnector = require('../../connector/active');\n\nmodule.exports = {\n  directive: 'PORT',\n  handler: function ({log, command} = {}) {\n    this.connector = new ActiveConnector(this);\n\n    const rawConnection = _.get(command, 'arg', '').split(',');\n    if (rawConnection.length !== 6) return this.reply(425);\n\n    const ip = rawConnection.slice(0, 4).join('.');\n    const portBytes = rawConnection.slice(4).map((p) => parseInt(p));\n    const port = portBytes[0] * 256 + portBytes[1];\n\n    return this.connector.setupConnection(ip, port)\n    .then(() => this.reply(200))\n    .catch((err) => {\n      log.error(err);\n      return this.reply(425);\n    });\n  },\n  syntax: '{{cmd}} <x>,<x>,<x>,<x>,<y>,<y>',\n  description: 'Specifies an address and port to which the server should connect'\n};\n", "const {Socket} = require('net');\nconst tls = require('tls');\nconst Promise = require('bluebird');\nconst Connector = require('./base');\n\nclass Active extends Connector {\n  constructor(connection) {\n    super(connection);\n    this.type = 'active';\n  }\n\n  waitForConnection({timeout = 5000, delay = 250} = {}) {\n    const checkSocket = () => {\n      if (this.dataSocket && this.dataSocket.connected) {\n        return Promise.resolve(this.dataSocket);\n      }\n      return Promise.resolve().delay(delay)\n      .then(() => checkSocket());\n    };\n\n    return checkSocket().timeout(timeout);\n  }\n\n  setupConnection(host, port, family = 4) {\n    const closeExistingServer = () => Promise.resolve(\n      this.dataSocket ? this.dataSocket.destroy() : undefined);\n\n    return closeExistingServer()\n    .then(() => {\n      this.dataSocket = new Socket();\n      this.dataSocket.on('error', (err) => this.server && this.server.emit('client-error', {connection: this.connection, context: 'dataSocket', error: err}));\n      this.dataSocket.connect({host, port, family}, () => {\n        this.dataSocket.pause();\n\n        if (this.connection.secure) {\n          const secureContext = tls.createSecureContext(this.server.options.tls);\n          const secureSocket = new tls.TLSSocket(this.dataSocket, {\n            isServer: true,\n            secureContext\n          });\n          this.dataSocket = secureSocket;\n        }\n        this.dataSocket.connected = true;\n      });\n    });\n  }\n}\nmodule.exports = Active;\n", "const Promise = require('bluebird');\nconst errors = require('../errors');\n\nclass Connector {\n  constructor(connection) {\n    this.connection = connection;\n\n    this.dataSocket = null;\n    this.dataServer = null;\n    this.type = false;\n  }\n\n  get log() {\n    return this.connection.log;\n  }\n\n  get socket() {\n    return this.dataSocket;\n  }\n\n  get server() {\n    return this.connection.server;\n  }\n\n  waitForConnection() {\n    return Promise.reject(new errors.ConnectorError('No connector setup, send PASV or PORT'));\n  }\n\n  closeSocket() {\n    if (this.dataSocket) {\n      const socket = this.dataSocket;\n      this.dataSocket.end(() => socket.destroy());\n      this.dataSocket = null;\n    }\n  }\n\n  closeServer() {\n    if (this.dataServer) {\n      this.dataServer.close();\n      this.dataServer = null;\n    }\n  }\n\n\n  end() {\n    this.closeSocket();\n    this.closeServer();\n\n    this.type = false;\n    this.connection.connector = new Connector(this);\n  }\n}\nmodule.exports = Connector;\n", "const Promise = require('bluebird');\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst ActiveConnector = require('../../../src/connector/active');\n\nconst CMD = 'EPRT';\ndescribe(CMD, function () {\n  let sandbox;\n  const mockClient = {\n    reply: () => Promise.resolve()\n  };\n  const cmdFn = require(`../../../src/commands/registration/${CMD.toLowerCase()}`).handler.bind(mockClient);\n\n  beforeEach(() => {\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    sandbox.spy(mockClient, 'reply');\n    sandbox.stub(ActiveConnector.prototype, 'setupConnection').resolves();\n  });\n  afterEach(() => {\n    sandbox.restore();\n  });\n\n  it('// unsuccessful | no argument', () => {\n    return cmdFn()\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(504);\n    });\n  });\n\n  it('// unsuccessful | invalid argument', () => {\n    return cmdFn({command: {arg: 'blah'}})\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(504);\n    });\n  });\n\n  it('// successful IPv4', () => {\n    return cmdFn({command: {arg: '|1|192.168.0.100|35286|'}})\n    .then(() => {\n      const [ip, port, family] = ActiveConnector.prototype.setupConnection.args[0];\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n      expect(ip).to.equal('192.168.0.100');\n      expect(port).to.equal('35286');\n      expect(family).to.equal(4);\n    });\n  });\n\n  it('// successful IPv6', () => {\n    return cmdFn({command: {arg: '|2|8536:933f:e7f3:3e91:6dc1:e8c6:8482:7b23|35286|'}})\n    .then(() => {\n      const [ip, port, family] = ActiveConnector.prototype.setupConnection.args[0];\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n      expect(ip).to.equal('8536:933f:e7f3:3e91:6dc1:e8c6:8482:7b23');\n      expect(port).to.equal('35286');\n      expect(family).to.equal(6);\n    });\n  });\n});\n", "const Promise = require('bluebird');\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst PassiveConnector = require('../../../src/connector/passive');\n\nconst CMD = 'EPSV';\ndescribe(CMD, function () {\n  let sandbox;\n  const mockClient = {\n    reply: () => Promise.resolve()\n  };\n  const cmdFn = require(`../../../src/commands/registration/${CMD.toLowerCase()}`).handler.bind(mockClient);\n\n  beforeEach(() => {\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    sandbox.stub(mockClient, 'reply').resolves();\n    sandbox.stub(PassiveConnector.prototype, 'setupServer').resolves({\n      address: () => ({port: 12345})\n    });\n  });\n  afterEach(() => {\n    sandbox.restore();\n  });\n\n  it('// successful IPv4', () => {\n    return cmdFn()\n    .then(() => {\n      const [code, message] = mockClient.reply.args[0];\n      expect(code).to.equal(229);\n      expect(message).to.equal('EPSV OK (|||12345|)');\n    });\n  });\n});\n", "const Promise = require('bluebird');\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst CMD = 'OPTS';\ndescribe(CMD, function () {\n  let sandbox;\n  const mockClient = {\n    reply: () => Promise.resolve()\n  };\n  const cmdFn = require(`../../../src/commands/registration/${CMD.toLowerCase()}`).handler.bind(mockClient);\n\n  beforeEach(() => {\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    sandbox.spy(mockClient, 'reply');\n  });\n  afterEach(() => {\n    sandbox.restore();\n  });\n\n  it('// unsuccessful', () => {\n    return cmdFn()\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(501);\n    });\n  });\n\n  it('BAD // unsuccessful', () => {\n    return cmdFn({command: {arg: 'BAD', directive: CMD}})\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(500);\n    });\n  });\n\n  it('UTF8 BAD // unsuccessful', () => {\n    return cmdFn({command: {arg: 'UTF8 BAD', directive: CMD}})\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(501);\n    });\n  });\n\n  it('UTF8 OFF // successful', () => {\n    return cmdFn({command: {arg: 'UTF8 OFF', directive: CMD}})\n    .then(() => {\n      expect(mockClient.encoding).to.equal('ascii');\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n    });\n  });\n\n  it('UTF8 ON // successful', () => {\n    return cmdFn({command: {arg: 'UTF8 ON', directive: CMD}})\n    .then(() => {\n      expect(mockClient.encoding).to.equal('utf8');\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n    });\n  });\n});\n", "/* eslint no-unused-expressions: 0 */\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst net = require('net');\nconst tls = require('tls');\n\nconst ActiveConnector = require('../../src/connector/active');\nconst {getNextPortFactory} = require('../../src/helpers/find-port');\n\ndescribe('Connector - Active //', function () {\n  const host = '127.0.0.1';\n  let getNextPort = getNextPortFactory(host, 1024);\n  let PORT;\n  let active;\n  let mockConnection = {};\n  let sandbox;\n  let server;\n\n  before(() => {\n    active = new ActiveConnector(mockConnection);\n  });\n  beforeEach((done) => {\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    getNextPort()\n    .then((port) => {\n      PORT = port;\n      server = net.createServer()\n      .on('connection', (socket) => socket.destroy())\n      .listen(PORT, () => done());\n    });\n  });\n  afterEach((done) => {\n    sandbox.restore();\n    server.close(done);\n  });\n\n  it('sets up a connection', function () {\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      expect(active.dataSocket).to.exist;\n    });\n  });\n\n  it('destroys existing connection, then sets up a connection', function () {\n    const destroyFnSpy = sandbox.spy(active.dataSocket, 'destroy');\n\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      expect(destroyFnSpy.callCount).to.equal(1);\n      expect(active.dataSocket).to.exist;\n    });\n  });\n\n  it('waits for connection', function () {\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      expect(active.dataSocket).to.exist;\n      return active.waitForConnection();\n    })\n    .then((dataSocket) => {\n      expect(dataSocket.connected).to.equal(true);\n      expect(dataSocket instanceof net.Socket).to.equal(true);\n      expect(dataSocket instanceof tls.TLSSocket).to.equal(false);\n    });\n  });\n\n  it('upgrades to a secure connection', function () {\n    mockConnection.secure = true;\n    mockConnection.server = {\n      options: {\n        tls: {}\n      }\n    };\n\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      expect(active.dataSocket).to.exist;\n      return active.waitForConnection();\n    })\n    .then((dataSocket) => {\n      expect(dataSocket.connected).to.equal(true);\n      expect(dataSocket instanceof net.Socket).to.equal(true);\n      expect(dataSocket instanceof tls.TLSSocket).to.equal(true);\n    });\n  });\n});\n"], "fixing_code": ["const _ = require('lodash');\nconst ActiveConnector = require('../../connector/active');\n\nconst FAMILY = {\n  1: 4,\n  2: 6\n};\n\nmodule.exports = {\n  directive: 'EPRT',\n  handler: function ({log, command} = {}) {\n    const [, protocol, ip, port] = _.chain(command).get('arg', '').split('|').value();\n    const family = FAMILY[protocol];\n    if (!family) return this.reply(504, 'Unknown network protocol');\n\n    this.connector = new ActiveConnector(this);\n    return this.connector.setupConnection(ip, port, family)\n    .then(() => this.reply(200))\n    .catch((err) => {\n      log.error(err);\n      return this.reply(err.code || 425, err.message);\n    });\n  },\n  syntax: '{{cmd}} |<protocol>|<address>|<port>|',\n  description: 'Specifies an address and port to which the server should connect'\n};\n", "const PassiveConnector = require('../../connector/passive');\n\nmodule.exports = {\n  directive: 'EPSV',\n  handler: function ({log}) {\n    this.connector = new PassiveConnector(this);\n    return this.connector.setupServer()\n    .then((server) => {\n      const {port} = server.address();\n\n      return this.reply(229, `EPSV OK (|||${port}|)`);\n    })\n    .catch((err) => {\n      log.error(err);\n      return this.reply(err.code || 425, err.message);\n    });\n  },\n  syntax: '{{cmd}} [<protocol>]',\n  description: 'Initiate passive mode'\n};\n", "const PassiveConnector = require('../../connector/passive');\nconst {isLocalIP} = require('../../helpers/is-local');\n\nmodule.exports = {\n  directive: 'PASV',\n  handler: function ({log} = {}) {\n    if (!this.server.options.pasv_url) {\n      return this.reply(502);\n    }\n\n    this.connector = new PassiveConnector(this);\n    return this.connector.setupServer()\n    .then((server) => {\n      let address = this.server.options.pasv_url;\n      // Allow connecting from local\n      if (isLocalIP(this.ip)) {\n        address = this.ip;\n      }\n      const {port} = server.address();\n      const host = address.replace(/\\./g, ',');\n      const portByte1 = port / 256 | 0;\n      const portByte2 = port % 256;\n\n      return this.reply(227, `PASV OK (${host},${portByte1},${portByte2})`);\n    })\n    .catch((err) => {\n      log.error(err);\n      return this.reply(err.code || 425, err.message);\n    });\n  },\n  syntax: '{{cmd}}',\n  description: 'Initiate passive mode'\n};\n", "const _ = require('lodash');\nconst ActiveConnector = require('../../connector/active');\n\nmodule.exports = {\n  directive: 'PORT',\n  handler: function ({log, command} = {}) {\n    this.connector = new ActiveConnector(this);\n\n    const rawConnection = _.get(command, 'arg', '').split(',');\n    if (rawConnection.length !== 6) return this.reply(425);\n\n    const ip = rawConnection.slice(0, 4).join('.');\n    const portBytes = rawConnection.slice(4).map((p) => parseInt(p));\n    const port = portBytes[0] * 256 + portBytes[1];\n\n    return this.connector.setupConnection(ip, port)\n    .then(() => this.reply(200))\n    .catch((err) => {\n      log.error(err);\n      return this.reply(err.code || 425, err.message);\n    });\n  },\n  syntax: '{{cmd}} <x>,<x>,<x>,<x>,<y>,<y>',\n  description: 'Specifies an address and port to which the server should connect'\n};\n", "const {Socket} = require('net');\nconst tls = require('tls');\nconst ip = require('ip');\nconst Promise = require('bluebird');\nconst Connector = require('./base');\nconst {SocketError} = require('../errors');\n\nclass Active extends Connector {\n  constructor(connection) {\n    super(connection);\n    this.type = 'active';\n  }\n\n  waitForConnection({timeout = 5000, delay = 250} = {}) {\n    const checkSocket = () => {\n      if (this.dataSocket && this.dataSocket.connected) {\n        return Promise.resolve(this.dataSocket);\n      }\n      return Promise.resolve().delay(delay)\n      .then(() => checkSocket());\n    };\n\n    return checkSocket().timeout(timeout);\n  }\n\n  setupConnection(host, port, family = 4) {\n    const closeExistingServer = () => Promise.resolve(\n      this.dataSocket ? this.dataSocket.destroy() : undefined);\n\n    return closeExistingServer()\n    .then(() => {\n      if (!ip.isEqual(this.connection.commandSocket.remoteAddress, host)) {\n        throw new SocketError('The given address is not yours', 500);\n      }\n\n      this.dataSocket = new Socket();\n      this.dataSocket.on('error', (err) => this.server && this.server.emit('client-error', {connection: this.connection, context: 'dataSocket', error: err}));\n      this.dataSocket.connect({host, port, family}, () => {\n        this.dataSocket.pause();\n\n        if (this.connection.secure) {\n          const secureContext = tls.createSecureContext(this.server.options.tls);\n          const secureSocket = new tls.TLSSocket(this.dataSocket, {\n            isServer: true,\n            secureContext\n          });\n          this.dataSocket = secureSocket;\n        }\n        this.dataSocket.connected = true;\n      });\n    });\n  }\n}\nmodule.exports = Active;\n", "const Promise = require('bluebird');\nconst errors = require('../errors');\n\nclass Connector {\n  constructor(connection) {\n    this.connection = connection;\n\n    this.dataSocket = null;\n    this.dataServer = null;\n    this.type = false;\n  }\n\n  get log() {\n    return this.connection.log;\n  }\n\n  get socket() {\n    return this.dataSocket;\n  }\n\n  get server() {\n    return this.connection.server;\n  }\n\n  waitForConnection() {\n    return Promise.reject(new errors.ConnectorError('No connector setup, send PASV or PORT'));\n  }\n\n  closeSocket() {\n    if (this.dataSocket) {\n      const socket = this.dataSocket;\n      this.dataSocket.end(() => socket && socket.destroy());\n      this.dataSocket = null;\n    }\n  }\n\n  closeServer() {\n    if (this.dataServer) {\n      this.dataServer.close();\n      this.dataServer = null;\n    }\n  }\n\n\n  end() {\n    this.closeSocket();\n    this.closeServer();\n\n    this.type = false;\n    this.connection.connector = new Connector(this);\n  }\n}\nmodule.exports = Connector;\n", "const Promise = require('bluebird');\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst ActiveConnector = require('../../../src/connector/active');\n\nconst CMD = 'EPRT';\ndescribe(CMD, function () {\n  let sandbox;\n  const mockClient = {\n    reply: () => Promise.resolve()\n  };\n  const cmdFn = require(`../../../src/commands/registration/${CMD.toLowerCase()}`).handler.bind(mockClient);\n\n  beforeEach(() => {\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    sandbox.spy(mockClient, 'reply');\n    sandbox.stub(ActiveConnector.prototype, 'setupConnection').resolves();\n  });\n  afterEach(() => {\n    sandbox.restore();\n  });\n\n  it('// unsuccessful | no argument', () => {\n    return cmdFn({})\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(504);\n    });\n  });\n\n  it('// unsuccessful | invalid argument', () => {\n    return cmdFn({command: {arg: 'blah'}})\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(504);\n    });\n  });\n\n  it('// successful IPv4', () => {\n    return cmdFn({command: {arg: '|1|192.168.0.100|35286|'}})\n    .then(() => {\n      const [ip, port, family] = ActiveConnector.prototype.setupConnection.args[0];\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n      expect(ip).to.equal('192.168.0.100');\n      expect(port).to.equal('35286');\n      expect(family).to.equal(4);\n    });\n  });\n\n  it('// successful IPv6', () => {\n    return cmdFn({command: {arg: '|2|8536:933f:e7f3:3e91:6dc1:e8c6:8482:7b23|35286|'}})\n    .then(() => {\n      const [ip, port, family] = ActiveConnector.prototype.setupConnection.args[0];\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n      expect(ip).to.equal('8536:933f:e7f3:3e91:6dc1:e8c6:8482:7b23');\n      expect(port).to.equal('35286');\n      expect(family).to.equal(6);\n    });\n  });\n});\n", "const Promise = require('bluebird');\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst PassiveConnector = require('../../../src/connector/passive');\n\nconst CMD = 'EPSV';\ndescribe(CMD, function () {\n  let sandbox;\n  const mockClient = {\n    reply: () => Promise.resolve()\n  };\n  const cmdFn = require(`../../../src/commands/registration/${CMD.toLowerCase()}`).handler.bind(mockClient);\n\n  beforeEach(() => {\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    sandbox.stub(mockClient, 'reply').resolves();\n    sandbox.stub(PassiveConnector.prototype, 'setupServer').resolves({\n      address: () => ({port: 12345})\n    });\n  });\n  afterEach(() => {\n    sandbox.restore();\n  });\n\n  it('// successful IPv4', () => {\n    return cmdFn({})\n    .then(() => {\n      const [code, message] = mockClient.reply.args[0];\n      expect(code).to.equal(229);\n      expect(message).to.equal('EPSV OK (|||12345|)');\n    });\n  });\n});\n", "const Promise = require('bluebird');\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst CMD = 'OPTS';\ndescribe(CMD, function () {\n  let sandbox;\n  const mockClient = {\n    reply: () => Promise.resolve()\n  };\n  const cmdFn = require(`../../../src/commands/registration/${CMD.toLowerCase()}`).handler.bind(mockClient);\n\n  beforeEach(() => {\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    sandbox.spy(mockClient, 'reply');\n  });\n  afterEach(() => {\n    sandbox.restore();\n  });\n\n  it('// unsuccessful', () => {\n    return cmdFn()\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(501);\n    });\n  });\n\n  it('BAD // unsuccessful', () => {\n    return cmdFn({command: {arg: 'BAD', directive: CMD}})\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(501);\n    });\n  });\n\n  it('UTF8 BAD // unsuccessful', () => {\n    return cmdFn({command: {arg: 'UTF8 BAD', directive: CMD}})\n    .then(() => {\n      expect(mockClient.reply.args[0][0]).to.equal(501);\n    });\n  });\n\n  it('UTF8 OFF // successful', () => {\n    return cmdFn({command: {arg: 'UTF8 OFF', directive: CMD}})\n    .then(() => {\n      expect(mockClient.encoding).to.equal('ascii');\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n    });\n  });\n\n  it('UTF8 ON // successful', () => {\n    return cmdFn({command: {arg: 'UTF8 ON', directive: CMD}})\n    .then(() => {\n      expect(mockClient.encoding).to.equal('utf8');\n      expect(mockClient.reply.args[0][0]).to.equal(200);\n    });\n  });\n});\n", "/* eslint no-unused-expressions: 0 */\nconst {expect} = require('chai');\nconst sinon = require('sinon');\n\nconst net = require('net');\nconst tls = require('tls');\n\nconst ActiveConnector = require('../../src/connector/active');\nconst {getNextPortFactory} = require('../../src/helpers/find-port');\n\ndescribe('Connector - Active //', function () {\n  const host = '127.0.0.1';\n  let getNextPort = getNextPortFactory(host, 1024);\n  let PORT;\n  let active;\n  let mockConnection = {\n    commandSocket: {\n      remoteAddress: '::ffff:127.0.0.1'\n    }\n  };\n  let sandbox;\n  let server;\n\n  beforeEach((done) => {\n    active = new ActiveConnector(mockConnection);\n    sandbox = sinon.sandbox.create().usingPromise(Promise);\n\n    getNextPort()\n    .then((port) => {\n      PORT = port;\n      server = net.createServer()\n      .on('connection', (socket) => socket.destroy())\n      .listen(PORT, () => done());\n    });\n  });\n\n  afterEach(() => {\n    sandbox.restore();\n    server.close();\n    active.end();\n\n  });\n\n  it('sets up a connection', function () {\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      expect(active.dataSocket).to.exist;\n    });\n  });\n\n  it('rejects alternative host', function () {\n    return active.setupConnection('123.45.67.89', PORT)\n    .catch((err) => {\n      expect(err.code).to.equal(500);\n      expect(err.message).to.equal('The given address is not yours');\n    })\n    .finally(() => {\n      expect(active.dataSocket).not.to.exist;\n    });\n  });\n\n  it('destroys existing connection, then sets up a connection', function () {\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      const destroyFnSpy = sandbox.spy(active.dataSocket, 'destroy');\n\n      return active.setupConnection(host, PORT)\n      .then(() => {\n        expect(destroyFnSpy.callCount).to.equal(1);\n        expect(active.dataSocket).to.exist;\n      });\n    });\n  });\n\n  it('waits for connection', function () {\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      expect(active.dataSocket).to.exist;\n      return active.waitForConnection();\n    })\n    .then((dataSocket) => {\n      expect(dataSocket.connected).to.equal(true);\n      expect(dataSocket instanceof net.Socket).to.equal(true);\n      expect(dataSocket instanceof tls.TLSSocket).to.equal(false);\n    });\n  });\n\n  it('upgrades to a secure connection', function () {\n    mockConnection.secure = true;\n    mockConnection.server = {\n      options: {\n        tls: {}\n      }\n    };\n\n    return active.setupConnection(host, PORT)\n    .then(() => {\n      expect(active.dataSocket).to.exist;\n      return active.waitForConnection();\n    })\n    .then((dataSocket) => {\n      expect(dataSocket.connected).to.equal(true);\n      expect(dataSocket instanceof net.Socket).to.equal(true);\n      expect(dataSocket instanceof tls.TLSSocket).to.equal(true);\n    });\n  });\n});\n"], "filenames": ["src/commands/registration/eprt.js", "src/commands/registration/epsv.js", "src/commands/registration/pasv.js", "src/commands/registration/port.js", "src/connector/active.js", "src/connector/base.js", "test/commands/registration/eprt.spec.js", "test/commands/registration/epsv.spec.js", "test/commands/registration/opts.spec.js", "test/connector/active.spec.js"], "buggy_code_start_loc": [11, 5, 28, 20, 2, 32, 26, 28, 32, 16], "buggy_code_end_loc": [19, 11, 29, 21, 29, 33, 27, 29, 33, 53], "fixing_code_start_loc": [11, 5, 28, 20, 3, 32, 26, 28, 32, 16], "fixing_code_end_loc": [23, 16, 29, 21, 36, 33, 27, 29, 33, 72], "type": "CWE-918", "message": "ftp-srv is an npm package which is a modern and extensible FTP server designed to be simple yet configurable. In ftp-srv before versions 2.19.6, 3.1.2, and 4.3.4 are vulnerable to Server-Side Request Forgery. The PORT command allows arbitrary IPs which can be used to cause the server to make a connection elsewhere. A possible workaround is blocking the PORT through the configuration. This issue is fixed in version2 2.19.6, 3.1.2, and 4.3.4. More information can be found on the linked advisory.", "other": {"cve": {"id": "CVE-2020-15152", "sourceIdentifier": "security-advisories@github.com", "published": "2020-08-17T22:15:12.627", "lastModified": "2021-05-05T14:02:23.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ftp-srv is an npm package which is a modern and extensible FTP server designed to be simple yet configurable. In ftp-srv before versions 2.19.6, 3.1.2, and 4.3.4 are vulnerable to Server-Side Request Forgery. The PORT command allows arbitrary IPs which can be used to cause the server to make a connection elsewhere. A possible workaround is blocking the PORT through the configuration. This issue is fixed in version2 2.19.6, 3.1.2, and 4.3.4. More information can be found on the linked advisory."}, {"lang": "es", "value": "ftp-srv es un paquete npm que es un moderno y extensible servidor FTP dise\u00f1ado para ser simple pero configurable. En ftp-srv antes de las versiones 2.19.6, 3.1.2, y 4.3.4 son vulnerables a la falsificaci\u00f3n de solicitudes del lado del servidor. El comando PORT permite IPs arbitrarias que pueden ser usadas para hacer que el servidor haga una conexi\u00f3n en otro lugar. Una posible soluci\u00f3n es bloquear el PUERTO a trav\u00e9s de la configuraci\u00f3n. Este problema est\u00e1 solucionado en las versiones 2.19.6, 3.1.2 y 4.3.4. Puede encontrar m\u00e1s informaci\u00f3n en el aviso vinculado"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-918"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-918"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ftp-srv_project:ftp-srv:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "2.19.6", "matchCriteriaId": "F5D90734-6B6E-4C5F-B0D5-9B4C4FAA8648"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ftp-srv_project:ftp-srv:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "3.0.0", "versionEndExcluding": "3.1.2", "matchCriteriaId": "4A020A63-F973-4E4C-9CF2-2B8F79234570"}, {"vulnerable": true, "criteria": "cpe:2.3:a:ftp-srv_project:ftp-srv:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "4.0.0", "versionEndExcluding": "4.3.4", "matchCriteriaId": "B1A73879-F682-4506-91E9-E0957E37C4EE"}]}]}], "references": [{"url": "https://github.com/autovance/ftp-srv/commit/e449e75219d918c400dec65b4b0759f60476abca", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/autovance/ftp-srv/security/advisories/GHSA-jw37-5gqr-cf9j", "source": "security-advisories@github.com", "tags": ["Mitigation", "Patch", "Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/ftp-srv", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/autovance/ftp-srv/commit/e449e75219d918c400dec65b4b0759f60476abca"}}