{"buggy_code": ["/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j;\n\nimport java.io.StringReader;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.dom4j.io.SAXReader;\nimport org.dom4j.rule.Pattern;\n\nimport org.jaxen.VariableContext;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * <code>DocumentHelper</code> is a collection of helper methods for using\n * DOM4J.\n *\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan </a>\n * @version $Revision: 1.26 $\n */\n@SuppressWarnings(\"unused\")\npublic final class DocumentHelper {\n    private DocumentHelper() {\n    }\n\n    private static DocumentFactory getDocumentFactory() {\n        return DocumentFactory.getInstance();\n    }\n\n    // Static helper methods\n    public static Document createDocument() {\n        return getDocumentFactory().createDocument();\n    }\n\n    public static Document createDocument(Element rootElement) {\n        return getDocumentFactory().createDocument(rootElement);\n    }\n\n    public static Element createElement(QName qname) {\n        return getDocumentFactory().createElement(qname);\n    }\n\n    public static Element createElement(String name) {\n        return getDocumentFactory().createElement(name);\n    }\n\n    public static Attribute createAttribute(Element owner, QName qname,\n            String value) {\n        return getDocumentFactory().createAttribute(owner, qname, value);\n    }\n\n    public static Attribute createAttribute(Element owner, String name,\n            String value) {\n        return getDocumentFactory().createAttribute(owner, name, value);\n    }\n\n    public static CDATA createCDATA(String text) {\n        return DocumentFactory.getInstance().createCDATA(text);\n    }\n\n    public static Comment createComment(String text) {\n        return DocumentFactory.getInstance().createComment(text);\n    }\n\n    public static Text createText(String text) {\n        return DocumentFactory.getInstance().createText(text);\n    }\n\n    public static Entity createEntity(String name, String text) {\n        return DocumentFactory.getInstance().createEntity(name, text);\n    }\n\n    public static Namespace createNamespace(String prefix, String uri) {\n        return DocumentFactory.getInstance().createNamespace(prefix, uri);\n    }\n\n    public static ProcessingInstruction createProcessingInstruction(String pi,\n            String d) {\n        return getDocumentFactory().createProcessingInstruction(pi, d);\n    }\n\n    public static ProcessingInstruction createProcessingInstruction(String pi,\n            Map<String, String> data) {\n        return getDocumentFactory().createProcessingInstruction(pi, data);\n    }\n\n    public static QName createQName(String localName, Namespace namespace) {\n        return getDocumentFactory().createQName(localName, namespace);\n    }\n\n    public static QName createQName(String localName) {\n        return getDocumentFactory().createQName(localName);\n    }\n\n    /**\n     * <p>\n     * <code>createXPath</code> parses an XPath expression and creates a new\n     * XPath <code>XPath</code> instance using the singleton {@link\n     * DocumentFactory}.\n     * </p>\n     * \n     * @param xpathExpression\n     *            is the XPath expression to create\n     * \n     * @return a new <code>XPath</code> instance\n     * \n     * @throws InvalidXPathException\n     *             if the XPath expression is invalid\n     */\n    public static XPath createXPath(String xpathExpression)\n            throws InvalidXPathException {\n        return getDocumentFactory().createXPath(xpathExpression);\n    }\n\n    /**\n     * <p>\n     * <code>createXPath</code> parses an XPath expression and creates a new\n     * XPath <code>XPath</code> instance using the singleton {@link\n     * DocumentFactory}.\n     * </p>\n     * \n     * @param xpathExpression\n     *            is the XPath expression to create\n     * @param context\n     *            is the variable context to use when evaluating the XPath\n     * \n     * @return a new <code>XPath</code> instance\n     * \n     * @throws InvalidXPathException\n     *             if the XPath expression is invalid\n     */\n    public static XPath createXPath(String xpathExpression,\n            VariableContext context) throws InvalidXPathException {\n        return getDocumentFactory().createXPath(xpathExpression, context);\n    }\n\n    /**\n     * <p>\n     * <code>createXPathFilter</code> parses a NodeFilter from the given XPath\n     * filter expression using the singleton {@link DocumentFactory}. XPath\n     * filter expressions occur within XPath expressions such as\n     * <code>self::node()[ filterExpression ]</code>\n     * </p>\n     * \n     * @param xpathFilterExpression\n     *            is the XPath filter expression to create\n     * \n     * @return a new <code>NodeFilter</code> instance\n     */\n    public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n        return getDocumentFactory().createXPathFilter(xpathFilterExpression);\n    }\n\n    /**\n     * <p>\n     * <code>createPattern</code> parses the given XPath expression to create\n     * an XSLT style {@link Pattern}instance which can then be used in an XSLT\n     * processing model.\n     * </p>\n     * \n     * @param xpathPattern\n     *            is the XPath pattern expression to create\n     * \n     * @return a new <code>Pattern</code> instance\n     */\n    public static Pattern createPattern(String xpathPattern) {\n        return getDocumentFactory().createPattern(xpathPattern);\n    }\n\n    /**\n     * <p>\n     * <code>selectNodes</code> performs the given XPath expression on the\n     * {@link List}of {@link Node}instances appending all the results together\n     * into a single list.\n     * </p>\n     * \n     * @param xpathFilterExpression\n     *            is the XPath filter expression to evaluate\n     * @param nodes\n     *            is the list of nodes on which to evalute the XPath\n     * \n     * @return the results of all the XPath evaluations as a single list\n     */\n    public static List<Node> selectNodes(String xpathFilterExpression, List<Node> nodes) {\n        XPath xpath = createXPath(xpathFilterExpression);\n\n        return xpath.selectNodes(nodes);\n    }\n\n    /**\n     * <p>\n     * <code>selectNodes</code> performs the given XPath expression on the\n     * {@link List}of {@link Node}instances appending all the results together\n     * into a single list.\n     * </p>\n     * \n     * @param xpathFilterExpression\n     *            is the XPath filter expression to evaluate\n     * @param node\n     *            is the Node on which to evalute the XPath\n     * \n     * @return the results of all the XPath evaluations as a single list\n     */\n    public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n        XPath xpath = createXPath(xpathFilterExpression);\n\n        return xpath.selectNodes(node);\n    }\n\n    /**\n     * <p>\n     * <code>sort</code> sorts the given List of Nodes using an XPath\n     * expression as a {@link java.util.Comparator}.\n     * </p>\n     * \n     * @param list\n     *            is the list of Nodes to sort\n     * @param xpathExpression\n     *            is the XPath expression used for comparison\n     */\n    public static void sort(List<Node> list, String xpathExpression) {\n        XPath xpath = createXPath(xpathExpression);\n        xpath.sort(list);\n    }\n\n    /**\n     * <p>\n     * <code>sort</code> sorts the given List of Nodes using an XPath\n     * expression as a {@link java.util.Comparator}and optionally removing\n     * duplicates.\n     * </p>\n     * \n     * @param list\n     *            is the list of Nodes to sort\n     * @param expression\n     *            is the XPath expression used for comparison\n     * @param distinct\n     *            if true then duplicate values (using the sortXPath for\n     *            comparisions) will be removed from the List\n     */\n    public static void sort(List<Node> list, String expression, boolean distinct) {\n        XPath xpath = createXPath(expression);\n        xpath.sort(list, distinct);\n    }\n\n    /**\n     * <p>\n     * <code>parseText</code> parses the given text as an XML document and\n     * returns the newly created Document.\n     * </p>\n     *\n     * Loading external DTD and entities is disabled (if it is possible) for security reasons.\n     * \n     * @param text\n     *            the XML text to be parsed\n     * \n     * @return a newly parsed Document\n     * \n     * @throws DocumentException\n     *             if the document could not be parsed\n     */\n    public static Document parseText(String text) throws DocumentException {\n        SAXReader reader = new SAXReader();\n        try {\n            reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n            reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n            reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n        } catch (SAXException e) {\n            //Parse with external resources downloading allowed.\n        }\n\n        String encoding = getEncoding(text);\n\n        InputSource source = new InputSource(new StringReader(text));\n        source.setEncoding(encoding);\n\n        Document result = reader.read(source);\n\n        // if the XML parser doesn't provide a way to retrieve the encoding,\n        // specify it manually\n        if (result.getXMLEncoding() == null) {\n            result.setXMLEncoding(encoding);\n        }\n\n        return result;\n    }\n\n    private static String getEncoding(String text) {\n        String result = null;\n\n        String xml = text.trim();\n\n        if (xml.startsWith(\"<?xml\")) {\n            int end = xml.indexOf(\"?>\");\n            String sub = xml.substring(0, end);\n            StringTokenizer tokens = new StringTokenizer(sub, \" =\\\"\\'\");\n\n            while (tokens.hasMoreTokens()) {\n                String token = tokens.nextToken();\n\n                if (\"encoding\".equals(token)) {\n                    if (tokens.hasMoreTokens()) {\n                        result = tokens.nextToken();\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * <p>\n     * makeElement\n     * </p>\n     * a helper method which navigates from the given Document or Element node\n     * to some Element using the path expression, creating any necessary\n     * elements along the way. For example the path <code>a/b/c</code> would\n     * get the first child &lt;a&gt; element, which would be created if it did\n     * not exist, then the next child &lt;b&gt; and so on until finally a\n     * &lt;c&gt; element is returned.\n     * \n     * @param source\n     *            is the Element or Document to start navigating from\n     * @param path\n     *            is a simple path expression, seperated by '/' which denotes\n     *            the path from the source to the resulting element such as\n     *            a/b/c\n     * \n     * @return the first Element on the given path which either already existed\n     *         on the path or were created by this method.\n     */\n    public static Element makeElement(Branch source, String path) {\n        StringTokenizer tokens = new StringTokenizer(path, \"/\");\n        Element parent;\n\n        if (source instanceof Document) {\n            Document document = (Document) source;\n            parent = document.getRootElement();\n\n            // lets throw a NoSuchElementException\n            // if we are given an empty path\n            String name = tokens.nextToken();\n\n            if (parent == null) {\n                parent = document.addElement(name);\n            }\n        } else {\n            parent = (Element) source;\n        }\n\n        Element element = null;\n\n        while (tokens.hasMoreTokens()) {\n            String name = tokens.nextToken();\n\n            if (name.indexOf(':') > 0) {\n                element = parent.element(parent.getQName(name));\n            } else {\n                element = parent.element(name);\n            }\n\n            if (element == null) {\n                element = parent.addElement(name);\n            }\n\n            parent = element;\n        }\n\n        return element;\n    }\n}\n\n/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n * \n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n * \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n * \n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n * \n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n * \n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */\n", "/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j.io;\n\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * <p>\n * <code>SAXHelper</code> contains some helper methods for working with SAX\n * and XMLReader objects.\n * </p>\n * \n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.18 $\n */\nclass SAXHelper {\n    private static boolean loggedWarning = true;\n\n    protected SAXHelper() {\n    }\n\n    public static boolean setParserProperty(XMLReader reader,\n            String propertyName, Object value) {\n        try {\n            reader.setProperty(propertyName, value);\n\n            return true;\n        } catch (SAXNotSupportedException e) {\n            // ignore\n        } catch (SAXNotRecognizedException e) {\n            // ignore\n        }\n\n        return false;\n    }\n\n    public static boolean setParserFeature(XMLReader reader,\n            String featureName, boolean value) {\n        try {\n            reader.setFeature(featureName, value);\n\n            return true;\n        } catch (SAXNotSupportedException e) {\n            // ignore\n        } catch (SAXNotRecognizedException e) {\n            // ignore\n        }\n\n        return false;\n    }\n\n    /**\n     * Creats a default XMLReader via the org.xml.sax.driver system property or\n     * JAXP if the system property is not set.\n     * \n     * @param validating\n     *            DOCUMENT ME!\n     * \n     * @return DOCUMENT ME!\n     * \n     * @throws SAXException\n     *             DOCUMENT ME!\n     */\n    public static XMLReader createXMLReader(boolean validating)\n            throws SAXException {\n        XMLReader reader = null;\n\n        if (reader == null) {\n            reader = createXMLReaderViaJAXP(validating, true);\n        }\n\n        if (reader == null) {\n            try {\n                reader = XMLReaderFactory.createXMLReader();\n            } catch (Exception e) {\n                if (isVerboseErrorReporting()) {\n                    // log all exceptions as warnings and carry\n                    // on as we have a default SAX parser we can use\n                    System.out.println(\"Warning: Caught exception attempting \"\n                            + \"to use SAX to load a SAX XMLReader \");\n                    System.out.println(\"Warning: Exception was: \" + e);\n                    System.out\n                            .println(\"Warning: I will print the stack trace \"\n                                    + \"then carry on using the default \"\n                                    + \"SAX parser\");\n                    e.printStackTrace();\n                }\n\n                throw new SAXException(e);\n            }\n        }\n\n        if (reader == null) {\n            throw new SAXException(\"Couldn't create SAX reader\");\n        }\n\n        // configure namespace support\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/features/namespaces\", true);\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/features/namespace-prefixes\", false);\n\n        // external entites\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/properties/external-general-entities\", false);\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/properties/external-parameter-entities\", false);\n\n        // external DTD\n        SAXHelper.setParserFeature(reader,\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\n        // use Locator2 if possible\n        SAXHelper.setParserFeature(reader,\"http://xml.org/sax/features/use-locator2\", true);\n\n        return reader;\n    }\n\n    /**\n     * This method attempts to use JAXP to locate the SAX2 XMLReader\n     * implementation. This method uses reflection to avoid being dependent\n     * directly on the JAXP classes.\n     * \n     * @param validating\n     *            DOCUMENT ME!\n     * @param namespaceAware\n     *            DOCUMENT ME!\n     * \n     * @return DOCUMENT ME!\n     */\n    protected static XMLReader createXMLReaderViaJAXP(boolean validating,\n            boolean namespaceAware) {\n        // try use JAXP to load the XMLReader...\n        try {\n            return JAXPHelper.createXMLReader(validating, namespaceAware);\n        } catch (Throwable e) {\n            if (!loggedWarning) {\n                loggedWarning = true;\n\n                if (isVerboseErrorReporting()) {\n                    // log all exceptions as warnings and carry\n                    // on as we have a default SAX parser we can use\n                    System.out.println(\"Warning: Caught exception attempting \"\n                            + \"to use JAXP to load a SAX XMLReader\");\n                    System.out.println(\"Warning: Exception was: \" + e);\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        return null;\n    }\n\n    protected static boolean isVerboseErrorReporting() {\n        try {\n            String flag = System.getProperty(\"org.dom4j.verbose\");\n\n            if ((flag != null) && flag.equalsIgnoreCase(\"true\")) {\n                return true;\n            }\n        } catch (Exception e) {\n            // in case a security exception\n            // happens in an applet or similar JVM\n        }\n\n        return true;\n    }\n}\n\n/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n * \n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n * \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n * \n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n * \n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n * \n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */\n", "/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j.io;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.net.URL;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.DocumentFactory;\nimport org.dom4j.ElementHandler;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLFilter;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\n/**\n * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n *\n * The actual SAX parser that is used by this class is configurable so you can\n * use your favourite SAX parser if you wish. DOM4J comes configured with its\n * own SAX parser so you do not need to worry about configuring the SAX parser.\n *\n * To explicitly configure the SAX parser that is used via Java code you can use\n * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n * #setXMLReaderClassName(String)} methods.\n *\n * If the parser is not specified explicitly then the standard SAX policy of\n * using the <code>org.xml.sax.driver</code> system property is used to\n * determine the implementation class of {@link XMLReader}.\n *\n * If the <code>org.xml.sax.driver</code> system property is not defined then\n * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n * creating a JAXP SAXParser an informational message is output and then the\n * default (Aelfred) SAX parser is used instead.\n *\n * If you are trying to use JAXP to explicitly set your SAX parser and are\n * experiencing problems, you can turn on verbose error reporting by defining\n * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n * output a more detailed description of why JAXP could not find a SAX parser\n *\n * For more information on JAXP please go to <a\n * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n *\n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.58 $\n */\npublic class SAXReader {\n    private static final String SAX_STRING_INTERNING = \n            \"http://xml.org/sax/features/string-interning\";\n    private static final String SAX_DECL_HANDLER =\n            \"http://xml.org/sax/properties/declaration-handler\";\n    private static final String SAX_LEXICAL_HANDLER = \n            \"http://xml.org/sax/properties/lexical-handler\";\n    private static final String SAX_LEXICALHANDLER = \n            \"http://xml.org/sax/handlers/LexicalHandler\";\n\n    /** <code>DocumentFactory</code> used to create new document objects */\n    private DocumentFactory factory;\n\n    /** <code>XMLReader</code> used to parse the SAX events */\n    private XMLReader xmlReader;\n\n    /** Whether validation should occur */\n    private boolean validating;\n\n    /** DispatchHandler to call when each <code>Element</code> is encountered */\n    private DispatchHandler dispatchHandler;\n\n    /** ErrorHandler class to use */\n    private ErrorHandler errorHandler;\n\n    /** The entity resolver */\n    private EntityResolver entityResolver;\n\n    /** Should element & attribute names and namespace URIs be interned? */\n    private boolean stringInternEnabled = true;\n\n    /** Should internal DTD declarations be expanded into a List in the DTD */\n    private boolean includeInternalDTDDeclarations = false;\n\n    /** Should external DTD declarations be expanded into a List in the DTD */\n    private boolean includeExternalDTDDeclarations = false;\n\n    /** Whether adjacent text nodes should be merged */\n    private boolean mergeAdjacentText = false;\n\n    /** Holds value of property stripWhitespaceText. */\n    private boolean stripWhitespaceText = false;\n\n    /** Should we ignore comments */\n    private boolean ignoreComments = false;\n\n    /** Encoding of InputSource - null means system default encoding */\n    private String encoding = null;\n\n    // private boolean includeExternalGeneralEntities = false;\n    // private boolean includeExternalParameterEntities = false;\n\n    /** The SAX filter used to filter SAX events */\n    private XMLFilter xmlFilter;\n\n    public SAXReader() {\n    }\n\n    public SAXReader(boolean validating) {\n        this.validating = validating;\n    }\n\n    public SAXReader(DocumentFactory factory) {\n        this.factory = factory;\n    }\n\n    public SAXReader(DocumentFactory factory, boolean validating) {\n        this.factory = factory;\n        this.validating = validating;\n    }\n\n    public SAXReader(XMLReader xmlReader) {\n        this.xmlReader = xmlReader;\n    }\n\n    public SAXReader(XMLReader xmlReader, boolean validating) {\n        this.xmlReader = xmlReader;\n        this.validating = validating;\n    }\n\n    public SAXReader(String xmlReaderClassName) throws SAXException {\n        if (xmlReaderClassName != null) {\n            this.xmlReader = XMLReaderFactory\n                    .createXMLReader(xmlReaderClassName);\n        }\n    }\n\n    public SAXReader(String xmlReaderClassName, boolean validating)\n            throws SAXException {\n        if (xmlReaderClassName != null) {\n            this.xmlReader = XMLReaderFactory\n                    .createXMLReader(xmlReaderClassName);\n        }\n\n        this.validating = validating;\n    }\n\n    /**\n     * Allows a SAX property to be set on the underlying SAX parser. This can be\n     * useful to set parser-specific properties such as the location of schema\n     * or DTD resources. Though use this method with caution as it has the\n     * possibility of breaking the standard behaviour. An alternative to calling\n     * this method is to correctly configure an XMLReader object instance and\n     * call the {@link #setXMLReader(XMLReader)}method\n     * \n     * @param name\n     *            is the SAX property name\n     * @param value\n     *            is the value of the SAX property\n     * \n     * @throws SAXException\n     *             if the XMLReader could not be created or the property could\n     *             not be changed.\n     */\n    public void setProperty(String name, Object value) throws SAXException {\n        getXMLReader().setProperty(name, value);\n    }\n\n    /**\n     * Sets a SAX feature on the underlying SAX parser. This can be useful to\n     * set parser-specific features. Though use this method with caution as it\n     * has the possibility of breaking the standard behaviour. An alternative to\n     * calling this method is to correctly configure an XMLReader object\n     * instance and call the {@link #setXMLReader(XMLReader)}method\n     * \n     * @param name\n     *            is the SAX feature name\n     * @param value\n     *            is the value of the SAX feature\n     * \n     * @throws SAXException\n     *             if the XMLReader could not be created or the feature could\n     *             not be changed.\n     */\n    public void setFeature(String name, boolean value) throws SAXException {\n        getXMLReader().setFeature(name, value);\n    }\n\n    /**\n     * <p>\n     * Reads a Document from the given <code>File</code>\n     * </p>\n     * \n     * @param file\n     *            is the <code>File</code> to read from.\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(File file) throws DocumentException {\n        try {\n            /*\n             * We cannot convert the file to an URL because if the filename\n             * contains '#' characters, there will be problems with the URL in\n             * the InputSource (because a URL like\n             * http://myhost.com/index#anchor is treated the same as\n             * http://myhost.com/index) Thanks to Christian Oetterli\n             */\n            InputSource source = new InputSource(new FileInputStream(file));\n            if (this.encoding != null) {\n                source.setEncoding(this.encoding);\n            }\n            String path = file.getAbsolutePath();\n\n            if (path != null) {\n                // Code taken from Ant FileUtils\n                StringBuffer sb = new StringBuffer(\"file://\");\n\n                // add an extra slash for filesystems with drive-specifiers\n                if (!path.startsWith(File.separator)) {\n                    sb.append(\"/\");\n                }\n\n                path = path.replace('\\\\', '/');\n                sb.append(path);\n\n                source.setSystemId(sb.toString());\n            }\n\n            return read(source);\n        } catch (FileNotFoundException e) {\n            throw new DocumentException(e.getMessage(), e);\n        }\n    }\n\n    /**\n     * <p>\n     * Reads a Document from the given <code>URL</code> using SAX\n     * </p>\n     * \n     * @param url\n     *            <code>URL</code> to read from.\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(URL url) throws DocumentException {\n        String systemID = url.toExternalForm();\n\n        InputSource source = new InputSource(systemID);\n        if (this.encoding != null) {\n            source.setEncoding(this.encoding);\n        }\n\n        return read(source);\n    }\n\n    /**\n     * <p>\n     * Reads a Document from the given URL or filename using SAX.\n     * </p>\n     * \n     * <p>\n     * If the systemId contains a <code>':'</code> character then it is\n     * assumed to be a URL otherwise its assumed to be a file name. If you want\n     * finer grained control over this mechansim then please explicitly pass in\n     * either a {@link URL}or a {@link File}instance instead of a {@link\n     * String} to denote the source of the document.\n     * </p>\n     * \n     * @param systemId\n     *            is a URL for a document or a file name.\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(String systemId) throws DocumentException {\n        InputSource source = new InputSource(systemId);\n        if (this.encoding != null) {\n            source.setEncoding(this.encoding);\n        }\n\n        return read(source);\n    }\n\n    /**\n     * <p>\n     * Reads a Document from the given stream using SAX\n     * </p>\n     * \n     * @param in\n     *            <code>InputStream</code> to read from.\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(InputStream in) throws DocumentException {\n        InputSource source = new InputSource(in);\n        if (this.encoding != null) {\n            source.setEncoding(this.encoding);\n        }\n\n        return read(source);\n    }\n\n    /**\n     * Reads a Document from the given <code>Reader</code> using SAX\n     *\n     * @param reader\n     *            is the reader for the input\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(Reader reader) throws DocumentException {\n        InputSource source = new InputSource(reader);\n        if (this.encoding != null) {\n            source.setEncoding(this.encoding);\n        }\n\n        return read(source);\n    }\n\n    /**\n     * <p>\n     * Reads a Document from the given stream using SAX\n     * </p>\n     * \n     * @param in\n     *            <code>InputStream</code> to read from.\n     * @param systemId\n     *            is the URI for the input\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(InputStream in, String systemId)\n            throws DocumentException {\n        InputSource source = new InputSource(in);\n        source.setSystemId(systemId);\n        if (this.encoding != null) {\n            source.setEncoding(this.encoding);\n        }\n\n        return read(source);\n    }\n\n    /**\n     * <p>\n     * Reads a Document from the given <code>Reader</code> using SAX\n     * </p>\n     * \n     * @param reader\n     *            is the reader for the input\n     * @param systemId\n     *            is the URI for the input\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(Reader reader, String systemId)\n            throws DocumentException {\n        InputSource source = new InputSource(reader);\n        source.setSystemId(systemId);\n        if (this.encoding != null) {\n            source.setEncoding(this.encoding);\n        }\n\n        return read(source);\n    }\n\n    /**\n     * <p>\n     * Reads a Document from the given <code>InputSource</code> using SAX\n     * </p>\n     * \n     * @param in\n     *            <code>InputSource</code> to read from.\n     * \n     * @return the newly created Document instance\n     * \n     * @throws DocumentException\n     *             if an error occurs during parsing.\n     */\n    public Document read(InputSource in) throws DocumentException {\n        try {\n            XMLReader reader = getXMLReader();\n\n            reader = installXMLFilter(reader);\n\n            EntityResolver thatEntityResolver = this.entityResolver;\n\n            if (thatEntityResolver == null) {\n                thatEntityResolver = createDefaultEntityResolver(in\n                        .getSystemId());\n                this.entityResolver = thatEntityResolver;\n            }\n\n            reader.setEntityResolver(thatEntityResolver);\n\n            SAXContentHandler contentHandler = createContentHandler(reader);\n            contentHandler.setEntityResolver(thatEntityResolver);\n            contentHandler.setInputSource(in);\n\n            boolean internal = isIncludeInternalDTDDeclarations();\n            boolean external = isIncludeExternalDTDDeclarations();\n\n            contentHandler.setIncludeInternalDTDDeclarations(internal);\n            contentHandler.setIncludeExternalDTDDeclarations(external);\n            contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n            contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n            contentHandler.setIgnoreComments(isIgnoreComments());\n            reader.setContentHandler(contentHandler);\n\n            configureReader(reader, contentHandler);\n\n            reader.parse(in);\n\n            return contentHandler.getDocument();\n        } catch (Exception e) {\n            if (e instanceof SAXParseException) {\n                // e.printStackTrace();\n                SAXParseException parseException = (SAXParseException) e;\n                String systemId = parseException.getSystemId();\n\n                if (systemId == null) {\n                    systemId = \"\";\n                }\n\n                String message = \"Error on line \"\n                        + parseException.getLineNumber() + \" of document \"\n                        + systemId + \" : \" + parseException.getMessage();\n\n                throw new DocumentException(message, e);\n            } else {\n                throw new DocumentException(e.getMessage(), e);\n            }\n        }\n    }\n\n    // Properties\n    // -------------------------------------------------------------------------\n\n    /**\n     * DOCUMENT ME!\n     * \n     * @return the validation mode, true if validating will be done otherwise\n     *         false.\n     */\n    public boolean isValidating() {\n        return validating;\n    }\n\n    /**\n     * Sets the validation mode.\n     * \n     * @param validation\n     *            indicates whether or not validation should occur.\n     */\n    public void setValidation(boolean validation) {\n        this.validating = validation;\n    }\n\n    /**\n     * DOCUMENT ME!\n     * \n     * @return whether internal DTD declarations should be expanded into the\n     *         DocumentType object or not.\n     */\n    public boolean isIncludeInternalDTDDeclarations() {\n        return includeInternalDTDDeclarations;\n    }\n\n    /**\n     * Sets whether internal DTD declarations should be expanded into the\n     * DocumentType object or not.\n     * \n     * @param include\n     *            whether or not DTD declarations should be expanded and\n     *            included into the DocumentType object.\n     */\n    public void setIncludeInternalDTDDeclarations(boolean include) {\n        this.includeInternalDTDDeclarations = include;\n    }\n\n    /**\n     * DOCUMENT ME!\n     * \n     * @return whether external DTD declarations should be expanded into the\n     *         DocumentType object or not.\n     */\n    public boolean isIncludeExternalDTDDeclarations() {\n        return includeExternalDTDDeclarations;\n    }\n\n    /**\n     * Sets whether DTD external declarations should be expanded into the\n     * DocumentType object or not.\n     * \n     * @param include\n     *            whether or not DTD declarations should be expanded and\n     *            included into the DocumentType object.\n     */\n    public void setIncludeExternalDTDDeclarations(boolean include) {\n        this.includeExternalDTDDeclarations = include;\n    }\n\n    /**\n     * Sets whether String interning is enabled or disabled for element &amp;\n     * attribute names and namespace URIs. This proprety is enabled by default.\n     * \n     * @return DOCUMENT ME!\n     */\n    public boolean isStringInternEnabled() {\n        return stringInternEnabled;\n    }\n\n    /**\n     * Sets whether String interning is enabled or disabled for element &amp;\n     * attribute names and namespace URIs\n     * \n     * @param stringInternEnabled\n     *            DOCUMENT ME!\n     */\n    public void setStringInternEnabled(boolean stringInternEnabled) {\n        this.stringInternEnabled = stringInternEnabled;\n    }\n\n    /**\n     * Returns whether adjacent text nodes should be merged together.\n     * \n     * @return Value of property mergeAdjacentText.\n     */\n    public boolean isMergeAdjacentText() {\n        return mergeAdjacentText;\n    }\n\n    /**\n     * Sets whether or not adjacent text nodes should be merged together when\n     * parsing.\n     * \n     * @param mergeAdjacentText\n     *            New value of property mergeAdjacentText.\n     */\n    public void setMergeAdjacentText(boolean mergeAdjacentText) {\n        this.mergeAdjacentText = mergeAdjacentText;\n    }\n\n    /**\n     * Sets whether whitespace between element start and end tags should be\n     * ignored\n     * \n     * @return Value of property stripWhitespaceText.\n     */\n    public boolean isStripWhitespaceText() {\n        return stripWhitespaceText;\n    }\n\n    /**\n     * Sets whether whitespace between element start and end tags should be\n     * ignored.\n     * \n     * @param stripWhitespaceText\n     *            New value of property stripWhitespaceText.\n     */\n    public void setStripWhitespaceText(boolean stripWhitespaceText) {\n        this.stripWhitespaceText = stripWhitespaceText;\n    }\n\n    /**\n     * Returns whether we should ignore comments or not.\n     * \n     * @return boolean\n     */\n    public boolean isIgnoreComments() {\n        return ignoreComments;\n    }\n\n    /**\n     * Sets whether we should ignore comments or not.\n     * \n     * @param ignoreComments\n     *            whether we should ignore comments or not.\n     */\n    public void setIgnoreComments(boolean ignoreComments) {\n        this.ignoreComments = ignoreComments;\n    }\n\n    /**\n     * DOCUMENT ME!\n     * \n     * @return the <code>DocumentFactory</code> used to create document\n     *         objects\n     */\n    public DocumentFactory getDocumentFactory() {\n        if (factory == null) {\n            factory = DocumentFactory.getInstance();\n        }\n\n        return factory;\n    }\n\n    /**\n     * <p>\n     * This sets the <code>DocumentFactory</code> used to create new\n     * documents. This method allows the building of custom DOM4J tree objects\n     * to be implemented easily using a custom derivation of\n     * {@link DocumentFactory}\n     * </p>\n     * \n     * @param documentFactory\n     *            <code>DocumentFactory</code> used to create DOM4J objects\n     */\n    public void setDocumentFactory(DocumentFactory documentFactory) {\n        this.factory = documentFactory;\n    }\n\n    /**\n     * DOCUMENT ME!\n     * \n     * @return the <code>ErrorHandler</code> used by SAX\n     */\n    public ErrorHandler getErrorHandler() {\n        return errorHandler;\n    }\n\n    /**\n     * Sets the <code>ErrorHandler</code> used by the SAX\n     * <code>XMLReader</code>.\n     * \n     * @param errorHandler\n     *            is the <code>ErrorHandler</code> used by SAX\n     */\n    public void setErrorHandler(ErrorHandler errorHandler) {\n        this.errorHandler = errorHandler;\n    }\n\n    /**\n     * Returns the current entity resolver used to resolve entities\n     * \n     * @return DOCUMENT ME!\n     */\n    public EntityResolver getEntityResolver() {\n        return entityResolver;\n    }\n\n    /**\n     * Sets the entity resolver used to resolve entities.\n     * \n     * @param entityResolver\n     *            DOCUMENT ME!\n     */\n    public void setEntityResolver(EntityResolver entityResolver) {\n        this.entityResolver = entityResolver;\n    }\n\n    /**\n     * DOCUMENT ME!\n     * \n     * @return the <code>XMLReader</code> used to parse SAX events\n     * \n     * @throws SAXException\n     *             DOCUMENT ME!\n     */\n    public XMLReader getXMLReader() throws SAXException {\n        if (xmlReader == null) {\n            xmlReader = createXMLReader();\n        }\n\n        return xmlReader;\n    }\n\n    /**\n     * Sets the <code>XMLReader</code> used to parse SAX events\n     * \n     * @param reader\n     *            is the <code>XMLReader</code> to parse SAX events\n     */\n    public void setXMLReader(XMLReader reader) {\n        this.xmlReader = reader;\n    }\n\n    /**\n     * Returns encoding used for InputSource (null means system default\n     * encoding)\n     * \n     * @return encoding used for InputSource\n     * \n     */\n    public String getEncoding() {\n        return encoding;\n    }\n\n    /**\n     * Sets encoding used for InputSource (null means system default encoding)\n     * \n     * @param encoding\n     *            is encoding used for InputSource\n     */\n    public void setEncoding(String encoding) {\n        this.encoding = encoding;\n    }\n\n    /**\n     * Sets the class name of the <code>XMLReader</code> to be used to parse\n     * SAX events.\n     * \n     * @param xmlReaderClassName\n     *            is the class name of the <code>XMLReader</code> to parse SAX\n     *            events\n     * \n     * @throws SAXException\n     *             DOCUMENT ME!\n     */\n    public void setXMLReaderClassName(String xmlReaderClassName)\n            throws SAXException {\n        setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n    }\n\n    /**\n     * Adds the <code>ElementHandler</code> to be called when the specified\n     * path is encounted.\n     * \n     * @param path\n     *            is the path to be handled\n     * @param handler\n     *            is the <code>ElementHandler</code> to be called by the event\n     *            based processor.\n     */\n    public void addHandler(String path, ElementHandler handler) {\n        getDispatchHandler().addHandler(path, handler);\n    }\n\n    /**\n     * Removes the <code>ElementHandler</code> from the event based processor,\n     * for the specified path.\n     * \n     * @param path\n     *            is the path to remove the <code>ElementHandler</code> for.\n     */\n    public void removeHandler(String path) {\n        getDispatchHandler().removeHandler(path);\n    }\n\n    /**\n     * When multiple <code>ElementHandler</code> instances have been\n     * registered, this will set a default <code>ElementHandler</code> to be\n     * called for any path which does <b>NOT </b> have a handler registered.\n     * \n     * @param handler\n     *            is the <code>ElementHandler</code> to be called by the event\n     *            based processor.\n     */\n    public void setDefaultHandler(ElementHandler handler) {\n        getDispatchHandler().setDefaultHandler(handler);\n    }\n\n    /**\n     * This method clears out all the existing handlers and default handler\n     * setting things back as if no handler existed. Useful when reusing an\n     * object instance.\n     */\n    public void resetHandlers() {\n        getDispatchHandler().resetHandlers();\n    }\n\n    /**\n     * Returns the SAX filter being used to filter SAX events.\n     * \n     * @return the SAX filter being used or null if no SAX filter is installed\n     */\n    public XMLFilter getXMLFilter() {\n        return xmlFilter;\n    }\n\n    /**\n     * Sets the SAX filter to be used when filtering SAX events\n     * \n     * @param filter\n     *            is the SAX filter to use or null to disable filtering\n     */\n    public void setXMLFilter(XMLFilter filter) {\n        this.xmlFilter = filter;\n    }\n\n    // Implementation methods\n    // -------------------------------------------------------------------------\n\n    /**\n     * Installs any XMLFilter objects required to allow the SAX event stream to\n     * be filtered and preprocessed before it gets to dom4j.\n     * \n     * @param reader\n     *            DOCUMENT ME!\n     * \n     * @return the new XMLFilter if applicable or the original XMLReader if no\n     *         filter is being used.\n     */\n    protected XMLReader installXMLFilter(XMLReader reader) {\n        XMLFilter filter = getXMLFilter();\n\n        if (filter != null) {\n            // find the root XMLFilter\n            XMLFilter root = filter;\n\n            while (true) {\n                XMLReader parent = root.getParent();\n\n                if (parent instanceof XMLFilter) {\n                    root = (XMLFilter) parent;\n                } else {\n                    break;\n                }\n            }\n\n            root.setParent(reader);\n\n            return filter;\n        }\n\n        return reader;\n    }\n\n    protected DispatchHandler getDispatchHandler() {\n        if (dispatchHandler == null) {\n            dispatchHandler = new DispatchHandler();\n        }\n\n        return dispatchHandler;\n    }\n\n    protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n        this.dispatchHandler = dispatchHandler;\n    }\n\n    /**\n     * Factory Method to allow alternate methods of creating and configuring\n     * XMLReader objects\n     * \n     * @return DOCUMENT ME!\n     * \n     * @throws SAXException\n     *             DOCUMENT ME!\n     */\n    protected XMLReader createXMLReader() throws SAXException {\n        return SAXHelper.createXMLReader(isValidating());\n    }\n\n    /**\n     * Configures the XMLReader before use\n     * \n     * @param reader\n     *            DOCUMENT ME!\n     * @param handler\n     *            DOCUMENT ME!\n     * \n     * @throws DocumentException\n     *             DOCUMENT ME!\n     */\n    protected void configureReader(XMLReader reader, DefaultHandler handler)\n            throws DocumentException {\n        // configure lexical handling\n        SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n\n        // try alternate property just in case\n        SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n\n        // register the DeclHandler\n        if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n            SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n        }\n\n        // string interning\n        SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n                isStringInternEnabled());\n\n        try {\n            // configure validation support\n            reader.setFeature(\"http://xml.org/sax/features/validation\",\n                    isValidating());\n\n            if (errorHandler != null) {\n                reader.setErrorHandler(errorHandler);\n            } else {\n                reader.setErrorHandler(handler);\n            }\n        } catch (Exception e) {\n            if (isValidating()) {\n                throw new DocumentException(\"Validation not supported for\"\n                        + \" XMLReader: \" + reader, e);\n            }\n        }\n    }\n\n    /**\n     * Factory Method to allow user derived SAXContentHandler objects to be used\n     * \n     * @param reader\n     *            DOCUMENT ME!\n     * \n     * @return DOCUMENT ME!\n     */\n    protected SAXContentHandler createContentHandler(XMLReader reader) {\n        return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n    }\n\n    protected EntityResolver createDefaultEntityResolver(String systemId) {\n        String prefix = null;\n\n        if ((systemId != null) && (systemId.length() > 0)) {\n            int idx = systemId.lastIndexOf('/');\n\n            if (idx > 0) {\n                prefix = systemId.substring(0, idx + 1);\n            }\n        }\n\n        return new SAXEntityResolver(prefix);\n    }\n\n    protected static class SAXEntityResolver implements EntityResolver,\n            Serializable {\n        protected String uriPrefix;\n\n        public SAXEntityResolver(String uriPrefix) {\n            this.uriPrefix = uriPrefix;\n        }\n\n        public InputSource resolveEntity(String publicId, String systemId) {\n            // try create a relative URI reader...\n            if ((systemId != null) && (systemId.length() > 0)) {\n                if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n                    systemId = uriPrefix + systemId;\n                }\n            }\n\n            return new InputSource(systemId);\n        }\n    }\n}\n\n/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n * \n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n * \n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n * \n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n * \n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n * \n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n * \n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n * \n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */\n"], "fixing_code": ["/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j;\n\nimport java.io.StringReader;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.StringTokenizer;\n\nimport org.dom4j.io.SAXReader;\nimport org.dom4j.rule.Pattern;\n\nimport org.jaxen.VariableContext;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\n\n/**\n * <code>DocumentHelper</code> is a collection of helper methods for using\n * DOM4J.\n *\n * @author <a href=\"mailto:jstrachan@apache.org\">James Strachan </a>\n * @version $Revision: 1.26 $\n */\n@SuppressWarnings(\"unused\")\npublic final class DocumentHelper {\n    private DocumentHelper() {\n    }\n\n    private static DocumentFactory getDocumentFactory() {\n        return DocumentFactory.getInstance();\n    }\n\n    // Static helper methods\n    public static Document createDocument() {\n        return getDocumentFactory().createDocument();\n    }\n\n    public static Document createDocument(Element rootElement) {\n        return getDocumentFactory().createDocument(rootElement);\n    }\n\n    public static Element createElement(QName qname) {\n        return getDocumentFactory().createElement(qname);\n    }\n\n    public static Element createElement(String name) {\n        return getDocumentFactory().createElement(name);\n    }\n\n    public static Attribute createAttribute(Element owner, QName qname,\n            String value) {\n        return getDocumentFactory().createAttribute(owner, qname, value);\n    }\n\n    public static Attribute createAttribute(Element owner, String name,\n            String value) {\n        return getDocumentFactory().createAttribute(owner, name, value);\n    }\n\n    public static CDATA createCDATA(String text) {\n        return DocumentFactory.getInstance().createCDATA(text);\n    }\n\n    public static Comment createComment(String text) {\n        return DocumentFactory.getInstance().createComment(text);\n    }\n\n    public static Text createText(String text) {\n        return DocumentFactory.getInstance().createText(text);\n    }\n\n    public static Entity createEntity(String name, String text) {\n        return DocumentFactory.getInstance().createEntity(name, text);\n    }\n\n    public static Namespace createNamespace(String prefix, String uri) {\n        return DocumentFactory.getInstance().createNamespace(prefix, uri);\n    }\n\n    public static ProcessingInstruction createProcessingInstruction(String pi,\n            String d) {\n        return getDocumentFactory().createProcessingInstruction(pi, d);\n    }\n\n    public static ProcessingInstruction createProcessingInstruction(String pi,\n            Map<String, String> data) {\n        return getDocumentFactory().createProcessingInstruction(pi, data);\n    }\n\n    public static QName createQName(String localName, Namespace namespace) {\n        return getDocumentFactory().createQName(localName, namespace);\n    }\n\n    public static QName createQName(String localName) {\n        return getDocumentFactory().createQName(localName);\n    }\n\n    /**\n     * <p>\n     * <code>createXPath</code> parses an XPath expression and creates a new\n     * XPath <code>XPath</code> instance using the singleton {@link\n     * DocumentFactory}.\n     * </p>\n     *\n     * @param xpathExpression\n     *            is the XPath expression to create\n     *\n     * @return a new <code>XPath</code> instance\n     *\n     * @throws InvalidXPathException\n     *             if the XPath expression is invalid\n     */\n    public static XPath createXPath(String xpathExpression)\n            throws InvalidXPathException {\n        return getDocumentFactory().createXPath(xpathExpression);\n    }\n\n    /**\n     * <p>\n     * <code>createXPath</code> parses an XPath expression and creates a new\n     * XPath <code>XPath</code> instance using the singleton {@link\n     * DocumentFactory}.\n     * </p>\n     *\n     * @param xpathExpression\n     *            is the XPath expression to create\n     * @param context\n     *            is the variable context to use when evaluating the XPath\n     *\n     * @return a new <code>XPath</code> instance\n     *\n     * @throws InvalidXPathException\n     *             if the XPath expression is invalid\n     */\n    public static XPath createXPath(String xpathExpression,\n            VariableContext context) throws InvalidXPathException {\n        return getDocumentFactory().createXPath(xpathExpression, context);\n    }\n\n    /**\n     * <p>\n     * <code>createXPathFilter</code> parses a NodeFilter from the given XPath\n     * filter expression using the singleton {@link DocumentFactory}. XPath\n     * filter expressions occur within XPath expressions such as\n     * <code>self::node()[ filterExpression ]</code>\n     * </p>\n     *\n     * @param xpathFilterExpression\n     *            is the XPath filter expression to create\n     *\n     * @return a new <code>NodeFilter</code> instance\n     */\n    public static NodeFilter createXPathFilter(String xpathFilterExpression) {\n        return getDocumentFactory().createXPathFilter(xpathFilterExpression);\n    }\n\n    /**\n     * <p>\n     * <code>createPattern</code> parses the given XPath expression to create\n     * an XSLT style {@link Pattern}instance which can then be used in an XSLT\n     * processing model.\n     * </p>\n     *\n     * @param xpathPattern\n     *            is the XPath pattern expression to create\n     *\n     * @return a new <code>Pattern</code> instance\n     */\n    public static Pattern createPattern(String xpathPattern) {\n        return getDocumentFactory().createPattern(xpathPattern);\n    }\n\n    /**\n     * <p>\n     * <code>selectNodes</code> performs the given XPath expression on the\n     * {@link List}of {@link Node}instances appending all the results together\n     * into a single list.\n     * </p>\n     *\n     * @param xpathFilterExpression\n     *            is the XPath filter expression to evaluate\n     * @param nodes\n     *            is the list of nodes on which to evalute the XPath\n     *\n     * @return the results of all the XPath evaluations as a single list\n     */\n    public static List<Node> selectNodes(String xpathFilterExpression, List<Node> nodes) {\n        XPath xpath = createXPath(xpathFilterExpression);\n\n        return xpath.selectNodes(nodes);\n    }\n\n    /**\n     * <p>\n     * <code>selectNodes</code> performs the given XPath expression on the\n     * {@link List}of {@link Node}instances appending all the results together\n     * into a single list.\n     * </p>\n     *\n     * @param xpathFilterExpression\n     *            is the XPath filter expression to evaluate\n     * @param node\n     *            is the Node on which to evalute the XPath\n     *\n     * @return the results of all the XPath evaluations as a single list\n     */\n    public static List<Node> selectNodes(String xpathFilterExpression, Node node) {\n        XPath xpath = createXPath(xpathFilterExpression);\n\n        return xpath.selectNodes(node);\n    }\n\n    /**\n     * <p>\n     * <code>sort</code> sorts the given List of Nodes using an XPath\n     * expression as a {@link java.util.Comparator}.\n     * </p>\n     *\n     * @param list\n     *            is the list of Nodes to sort\n     * @param xpathExpression\n     *            is the XPath expression used for comparison\n     */\n    public static void sort(List<Node> list, String xpathExpression) {\n        XPath xpath = createXPath(xpathExpression);\n        xpath.sort(list);\n    }\n\n    /**\n     * <p>\n     * <code>sort</code> sorts the given List of Nodes using an XPath\n     * expression as a {@link java.util.Comparator}and optionally removing\n     * duplicates.\n     * </p>\n     *\n     * @param list\n     *            is the list of Nodes to sort\n     * @param expression\n     *            is the XPath expression used for comparison\n     * @param distinct\n     *            if true then duplicate values (using the sortXPath for\n     *            comparisions) will be removed from the List\n     */\n    public static void sort(List<Node> list, String expression, boolean distinct) {\n        XPath xpath = createXPath(expression);\n        xpath.sort(list, distinct);\n    }\n\n    /**\n     * <p>\n     * <code>parseText</code> parses the given text as an XML document and\n     * returns the newly created Document.\n     * </p>\n     *\n     * Loading external DTD and entities is disabled (if it is possible) for security reasons.\n     *\n     * @param text\n     *            the XML text to be parsed\n     *\n     * @return a newly parsed Document\n     *\n     * @throws DocumentException\n     *             if the document could not be parsed\n     */\n    public static Document parseText(String text) throws DocumentException {\n        SAXReader reader = SAXReader.createDefault();\n\n        String encoding = getEncoding(text);\n\n        InputSource source = new InputSource(new StringReader(text));\n        source.setEncoding(encoding);\n\n        Document result = reader.read(source);\n\n        // if the XML parser doesn't provide a way to retrieve the encoding,\n        // specify it manually\n        if (result.getXMLEncoding() == null) {\n            result.setXMLEncoding(encoding);\n        }\n\n        return result;\n    }\n\n    private static String getEncoding(String text) {\n        String result = null;\n\n        String xml = text.trim();\n\n        if (xml.startsWith(\"<?xml\")) {\n            int end = xml.indexOf(\"?>\");\n            String sub = xml.substring(0, end);\n            StringTokenizer tokens = new StringTokenizer(sub, \" =\\\"\\'\");\n\n            while (tokens.hasMoreTokens()) {\n                String token = tokens.nextToken();\n\n                if (\"encoding\".equals(token)) {\n                    if (tokens.hasMoreTokens()) {\n                        result = tokens.nextToken();\n                    }\n\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * <p>\n     * makeElement\n     * </p>\n     * a helper method which navigates from the given Document or Element node\n     * to some Element using the path expression, creating any necessary\n     * elements along the way. For example the path <code>a/b/c</code> would\n     * get the first child &lt;a&gt; element, which would be created if it did\n     * not exist, then the next child &lt;b&gt; and so on until finally a\n     * &lt;c&gt; element is returned.\n     *\n     * @param source\n     *            is the Element or Document to start navigating from\n     * @param path\n     *            is a simple path expression, seperated by '/' which denotes\n     *            the path from the source to the resulting element such as\n     *            a/b/c\n     *\n     * @return the first Element on the given path which either already existed\n     *         on the path or were created by this method.\n     */\n    public static Element makeElement(Branch source, String path) {\n        StringTokenizer tokens = new StringTokenizer(path, \"/\");\n        Element parent;\n\n        if (source instanceof Document) {\n            Document document = (Document) source;\n            parent = document.getRootElement();\n\n            // lets throw a NoSuchElementException\n            // if we are given an empty path\n            String name = tokens.nextToken();\n\n            if (parent == null) {\n                parent = document.addElement(name);\n            }\n        } else {\n            parent = (Element) source;\n        }\n\n        Element element = null;\n\n        while (tokens.hasMoreTokens()) {\n            String name = tokens.nextToken();\n\n            if (name.indexOf(':') > 0) {\n                element = parent.element(parent.getQName(name));\n            } else {\n                element = parent.element(name);\n            }\n\n            if (element == null) {\n                element = parent.addElement(name);\n            }\n\n            parent = element;\n        }\n\n        return element;\n    }\n}\n\n/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n *\n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n *\n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n *\n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n *\n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */\n", "/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j.io;\n\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport javax.xml.parsers.SAXParserFactory;\n\n/**\n * <p>\n * <code>SAXHelper</code> contains some helper methods for working with SAX\n * and XMLReader objects.\n * </p>\n *\n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.18 $\n */\nclass SAXHelper {\n    private static boolean loggedWarning = true;\n\n    protected SAXHelper() {\n    }\n\n    public static boolean setParserProperty(XMLReader reader,\n            String propertyName, Object value) {\n        try {\n            reader.setProperty(propertyName, value);\n\n            return true;\n        } catch (SAXNotSupportedException e) {\n            // ignore\n        } catch (SAXNotRecognizedException e) {\n            // ignore\n        }\n\n        return false;\n    }\n\n    public static boolean setParserFeature(XMLReader reader,\n            String featureName, boolean value) {\n        try {\n            reader.setFeature(featureName, value);\n\n            return true;\n        } catch (SAXNotSupportedException e) {\n            // ignore\n        } catch (SAXNotRecognizedException e) {\n            // ignore\n        }\n\n        return false;\n    }\n\n    /**\n     * Creats a default XMLReader via the org.xml.sax.driver system property or\n     * JAXP if the system property is not set.\n     *\n     * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n     * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n     *\n     * <pre>\n     * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n     * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n     * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n     * </pre>\n     *\n     * @param validating\n     *            DOCUMENT ME!\n     *\n     * @return DOCUMENT ME!\n     *\n     * @throws SAXException\n     *             DOCUMENT ME!\n     */\n    public static XMLReader createXMLReader(boolean validating)\n            throws SAXException {\n        XMLReader reader = null;\n\n        if (reader == null) {\n            reader = createXMLReaderViaJAXP(validating, true);\n        }\n\n        if (reader == null) {\n            try {\n                reader = XMLReaderFactory.createXMLReader();\n            } catch (Exception e) {\n                if (isVerboseErrorReporting()) {\n                    // log all exceptions as warnings and carry\n                    // on as we have a default SAX parser we can use\n                    System.out.println(\"Warning: Caught exception attempting \"\n                            + \"to use SAX to load a SAX XMLReader \");\n                    System.out.println(\"Warning: Exception was: \" + e);\n                    System.out\n                            .println(\"Warning: I will print the stack trace \"\n                                    + \"then carry on using the default \"\n                                    + \"SAX parser\");\n                    e.printStackTrace();\n                }\n\n                throw new SAXException(e);\n            }\n        }\n\n        if (reader == null) {\n            throw new SAXException(\"Couldn't create SAX reader\");\n        }\n\n        // configure namespace support\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/features/namespaces\", true);\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/features/namespace-prefixes\", false);\n\n        // external entites\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/properties/external-general-entities\", false);\n        SAXHelper.setParserFeature(reader, \"http://xml.org/sax/properties/external-parameter-entities\", false);\n\n        // external DTD\n        SAXHelper.setParserFeature(reader,\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n\n\n        // use Locator2 if possible\n        SAXHelper.setParserFeature(reader,\"http://xml.org/sax/features/use-locator2\", true);\n\n        return reader;\n    }\n\n    /**\n     * This method attempts to use JAXP to locate the SAX2 XMLReader\n     * implementation. This method uses reflection to avoid being dependent\n     * directly on the JAXP classes.\n     *\n     * @param validating\n     *            DOCUMENT ME!\n     * @param namespaceAware\n     *            DOCUMENT ME!\n     *\n     * @return DOCUMENT ME!\n     */\n    protected static XMLReader createXMLReaderViaJAXP(boolean validating,\n            boolean namespaceAware) {\n        // try use JAXP to load the XMLReader...\n        try {\n            return JAXPHelper.createXMLReader(validating, namespaceAware);\n        } catch (Throwable e) {\n            if (!loggedWarning) {\n                loggedWarning = true;\n\n                if (isVerboseErrorReporting()) {\n                    // log all exceptions as warnings and carry\n                    // on as we have a default SAX parser we can use\n                    System.out.println(\"Warning: Caught exception attempting \"\n                            + \"to use JAXP to load a SAX XMLReader\");\n                    System.out.println(\"Warning: Exception was: \" + e);\n                    e.printStackTrace();\n                }\n            }\n        }\n\n        return null;\n    }\n\n    protected static boolean isVerboseErrorReporting() {\n        try {\n            String flag = System.getProperty(\"org.dom4j.verbose\");\n\n            if ((flag != null) && flag.equalsIgnoreCase(\"true\")) {\n                return true;\n            }\n        } catch (Exception e) {\n            // in case a security exception\n            // happens in an applet or similar JVM\n        }\n\n        return true;\n    }\n}\n\n/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n *\n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n *\n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n *\n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n *\n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */\n", "/*\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n *\n * This software is open source.\n * See the bottom of this file for the licence.\n */\n\npackage org.dom4j.io;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.InputStream;\nimport java.io.Reader;\nimport java.io.Serializable;\nimport java.net.URL;\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.DocumentFactory;\nimport org.dom4j.ElementHandler;\n\nimport org.xml.sax.EntityResolver;\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\nimport org.xml.sax.XMLFilter;\nimport org.xml.sax.XMLReader;\nimport org.xml.sax.helpers.DefaultHandler;\nimport org.xml.sax.helpers.XMLReaderFactory;\n\nimport javax.xml.parsers.SAXParserFactory;\n\n/**\n * <code>SAXReader</code> creates a DOM4J tree from SAX parsing events.\n * <p>\n * The actual SAX parser that is used by this class is configurable so you can\n * use your favourite SAX parser if you wish. DOM4J comes configured with its\n * own SAX parser so you do not need to worry about configuring the SAX parser.\n * <p>\n * To explicitly configure the SAX parser that is used via Java code you can use\n * a constructor or use the {@link #setXMLReader(XMLReader)}or {@link\n * #setXMLReaderClassName(String)} methods.\n * <p>\n * If the parser is not specified explicitly then the standard SAX policy of\n * using the <code>org.xml.sax.driver</code> system property is used to\n * determine the implementation class of {@link XMLReader}.\n * <p>\n * If the <code>org.xml.sax.driver</code> system property is not defined then\n * JAXP is used via reflection (so that DOM4J is not explicitly dependent on the\n * JAXP classes) to load the JAXP configured SAXParser. If there is any error\n * creating a JAXP SAXParser an informational message is output and then the\n * default (Aelfred) SAX parser is used instead.\n * <p>\n * If you are trying to use JAXP to explicitly set your SAX parser and are\n * experiencing problems, you can turn on verbose error reporting by defining\n * the system property <code>org.dom4j.verbose</code> to be \"true\" which will\n * output a more detailed description of why JAXP could not find a SAX parser\n * <p>\n * For more information on JAXP please go to <a\n * href=\"http://java.sun.com/xml/\">Sun's Java &amp; XML site </a>\n *\n * @author <a href=\"mailto:james.strachan@metastuff.com\">James Strachan </a>\n * @version $Revision: 1.58 $\n */\npublic class SAXReader {\n  private static final String SAX_STRING_INTERNING =\n          \"http://xml.org/sax/features/string-interning\";\n  private static final String SAX_DECL_HANDLER =\n          \"http://xml.org/sax/properties/declaration-handler\";\n  private static final String SAX_LEXICAL_HANDLER =\n          \"http://xml.org/sax/properties/lexical-handler\";\n  private static final String SAX_LEXICALHANDLER =\n          \"http://xml.org/sax/handlers/LexicalHandler\";\n\n  /**\n   * <code>DocumentFactory</code> used to create new document objects\n   */\n  private DocumentFactory factory;\n\n  /**\n   * <code>XMLReader</code> used to parse the SAX events\n   */\n  private XMLReader xmlReader;\n\n  /**\n   * Whether validation should occur\n   */\n  private boolean validating;\n\n  /**\n   * DispatchHandler to call when each <code>Element</code> is encountered\n   */\n  private DispatchHandler dispatchHandler;\n\n  /**\n   * ErrorHandler class to use\n   */\n  private ErrorHandler errorHandler;\n\n  /**\n   * The entity resolver\n   */\n  private EntityResolver entityResolver;\n\n  /**\n   * Should element & attribute names and namespace URIs be interned?\n   */\n  private boolean stringInternEnabled = true;\n\n  /**\n   * Should internal DTD declarations be expanded into a List in the DTD\n   */\n  private boolean includeInternalDTDDeclarations = false;\n\n  /**\n   * Should external DTD declarations be expanded into a List in the DTD\n   */\n  private boolean includeExternalDTDDeclarations = false;\n\n  /**\n   * Whether adjacent text nodes should be merged\n   */\n  private boolean mergeAdjacentText = false;\n\n  /**\n   * Holds value of property stripWhitespaceText.\n   */\n  private boolean stripWhitespaceText = false;\n\n  /**\n   * Should we ignore comments\n   */\n  private boolean ignoreComments = false;\n\n  /**\n   * Encoding of InputSource - null means system default encoding\n   */\n  private String encoding = null;\n\n  // private boolean includeExternalGeneralEntities = false;\n  // private boolean includeExternalParameterEntities = false;\n\n  /**\n   * The SAX filter used to filter SAX events\n   *\n   * @since 2.1.2\n   */\n  private XMLFilter xmlFilter;\n\n  public static SAXReader createDefault() {\n    SAXReader reader = new SAXReader();\n    try {\n      reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n      reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n      reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n    } catch (SAXException e) {\n      // nothing to do, incompatible reader\n    }\n    return reader;\n  }\n\n  /**\n   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n   *\n   * <pre>\n   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n   * </pre>\n   */\n  public SAXReader() {\n  }\n\n  /**\n   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n   *\n   * <pre>\n   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n   * </pre>\n   *\n   * @param validating\n   */\n  public SAXReader(boolean validating) {\n    this.validating = validating;\n  }\n\n  /**\n   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n   *\n   * <pre>\n   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n   * </pre>\n   *\n   * @param factory\n   */\n  public SAXReader(DocumentFactory factory) {\n    this.factory = factory;\n  }\n\n  /**\n   * This method internally calls {@link SAXParserFactory}{@code .newInstance().newSAXParser().getXMLReader()} or {@link XMLReaderFactory#createXMLReader()}.\n   * Be sure to configure returned reader if the default configuration does not suit you. Consider setting the following properties:\n   *\n   * <pre>\n   * reader.setFeature(\"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n   * reader.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n   * </pre>\n   *\n   * @param factory\n   * @param validating\n   */\n  public SAXReader(DocumentFactory factory, boolean validating) {\n    this.factory = factory;\n    this.validating = validating;\n  }\n\n  public SAXReader(XMLReader xmlReader) {\n    this.xmlReader = xmlReader;\n  }\n\n  public SAXReader(XMLReader xmlReader, boolean validating) {\n    this.xmlReader = xmlReader;\n    this.validating = validating;\n  }\n\n  public SAXReader(String xmlReaderClassName) throws SAXException {\n    if (xmlReaderClassName != null) {\n      this.xmlReader = XMLReaderFactory\n              .createXMLReader(xmlReaderClassName);\n    }\n  }\n\n  public SAXReader(String xmlReaderClassName, boolean validating)\n          throws SAXException {\n    if (xmlReaderClassName != null) {\n      this.xmlReader = XMLReaderFactory\n              .createXMLReader(xmlReaderClassName);\n    }\n\n    this.validating = validating;\n  }\n\n  /**\n   * Allows a SAX property to be set on the underlying SAX parser. This can be\n   * useful to set parser-specific properties such as the location of schema\n   * or DTD resources. Though use this method with caution as it has the\n   * possibility of breaking the standard behaviour. An alternative to calling\n   * this method is to correctly configure an XMLReader object instance and\n   * call the {@link #setXMLReader(XMLReader)}method\n   *\n   * @param name  is the SAX property name\n   * @param value is the value of the SAX property\n   * @throws SAXException if the XMLReader could not be created or the property could\n   *                      not be changed.\n   */\n  public void setProperty(String name, Object value) throws SAXException {\n    getXMLReader().setProperty(name, value);\n  }\n\n  /**\n   * Sets a SAX feature on the underlying SAX parser. This can be useful to\n   * set parser-specific features. Though use this method with caution as it\n   * has the possibility of breaking the standard behaviour. An alternative to\n   * calling this method is to correctly configure an XMLReader object\n   * instance and call the {@link #setXMLReader(XMLReader)}method\n   *\n   * @param name  is the SAX feature name\n   * @param value is the value of the SAX feature\n   * @throws SAXException if the XMLReader could not be created or the feature could\n   *                      not be changed.\n   */\n  public void setFeature(String name, boolean value) throws SAXException {\n    getXMLReader().setFeature(name, value);\n  }\n\n  /**\n   * <p>\n   * Reads a Document from the given <code>File</code>\n   * </p>\n   *\n   * @param file is the <code>File</code> to read from.\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(File file) throws DocumentException {\n    try {\n      /*\n       * We cannot convert the file to an URL because if the filename\n       * contains '#' characters, there will be problems with the URL in\n       * the InputSource (because a URL like\n       * http://myhost.com/index#anchor is treated the same as\n       * http://myhost.com/index) Thanks to Christian Oetterli\n       */\n      InputSource source = new InputSource(new FileInputStream(file));\n      if (this.encoding != null) {\n        source.setEncoding(this.encoding);\n      }\n      String path = file.getAbsolutePath();\n\n      if (path != null) {\n        // Code taken from Ant FileUtils\n        StringBuffer sb = new StringBuffer(\"file://\");\n\n        // add an extra slash for filesystems with drive-specifiers\n        if (!path.startsWith(File.separator)) {\n          sb.append(\"/\");\n        }\n\n        path = path.replace('\\\\', '/');\n        sb.append(path);\n\n        source.setSystemId(sb.toString());\n      }\n\n      return read(source);\n    } catch (FileNotFoundException e) {\n      throw new DocumentException(e.getMessage(), e);\n    }\n  }\n\n  /**\n   * <p>\n   * Reads a Document from the given <code>URL</code> using SAX\n   * </p>\n   *\n   * @param url <code>URL</code> to read from.\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(URL url) throws DocumentException {\n    String systemID = url.toExternalForm();\n\n    InputSource source = new InputSource(systemID);\n    if (this.encoding != null) {\n      source.setEncoding(this.encoding);\n    }\n\n    return read(source);\n  }\n\n  /**\n   * <p>\n   * Reads a Document from the given URL or filename using SAX.\n   * </p>\n   *\n   * <p>\n   * If the systemId contains a <code>':'</code> character then it is\n   * assumed to be a URL otherwise its assumed to be a file name. If you want\n   * finer grained control over this mechansim then please explicitly pass in\n   * either a {@link URL}or a {@link File}instance instead of a {@link\n   * String} to denote the source of the document.\n   * </p>\n   *\n   * @param systemId is a URL for a document or a file name.\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(String systemId) throws DocumentException {\n    InputSource source = new InputSource(systemId);\n    if (this.encoding != null) {\n      source.setEncoding(this.encoding);\n    }\n\n    return read(source);\n  }\n\n  /**\n   * <p>\n   * Reads a Document from the given stream using SAX\n   * </p>\n   *\n   * @param in <code>InputStream</code> to read from.\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(InputStream in) throws DocumentException {\n    InputSource source = new InputSource(in);\n    if (this.encoding != null) {\n      source.setEncoding(this.encoding);\n    }\n\n    return read(source);\n  }\n\n  /**\n   * Reads a Document from the given <code>Reader</code> using SAX\n   *\n   * @param reader is the reader for the input\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(Reader reader) throws DocumentException {\n    InputSource source = new InputSource(reader);\n    if (this.encoding != null) {\n      source.setEncoding(this.encoding);\n    }\n\n    return read(source);\n  }\n\n  /**\n   * <p>\n   * Reads a Document from the given stream using SAX\n   * </p>\n   *\n   * @param in       <code>InputStream</code> to read from.\n   * @param systemId is the URI for the input\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(InputStream in, String systemId)\n          throws DocumentException {\n    InputSource source = new InputSource(in);\n    source.setSystemId(systemId);\n    if (this.encoding != null) {\n      source.setEncoding(this.encoding);\n    }\n\n    return read(source);\n  }\n\n  /**\n   * <p>\n   * Reads a Document from the given <code>Reader</code> using SAX\n   * </p>\n   *\n   * @param reader   is the reader for the input\n   * @param systemId is the URI for the input\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(Reader reader, String systemId)\n          throws DocumentException {\n    InputSource source = new InputSource(reader);\n    source.setSystemId(systemId);\n    if (this.encoding != null) {\n      source.setEncoding(this.encoding);\n    }\n\n    return read(source);\n  }\n\n  /**\n   * <p>\n   * Reads a Document from the given <code>InputSource</code> using SAX\n   * </p>\n   *\n   * @param in <code>InputSource</code> to read from.\n   * @return the newly created Document instance\n   * @throws DocumentException if an error occurs during parsing.\n   */\n  public Document read(InputSource in) throws DocumentException {\n    try {\n      XMLReader reader = getXMLReader();\n\n      reader = installXMLFilter(reader);\n\n      EntityResolver thatEntityResolver = this.entityResolver;\n\n      if (thatEntityResolver == null) {\n        thatEntityResolver = createDefaultEntityResolver(in\n                .getSystemId());\n        this.entityResolver = thatEntityResolver;\n      }\n\n      reader.setEntityResolver(thatEntityResolver);\n\n      SAXContentHandler contentHandler = createContentHandler(reader);\n      contentHandler.setEntityResolver(thatEntityResolver);\n      contentHandler.setInputSource(in);\n\n      boolean internal = isIncludeInternalDTDDeclarations();\n      boolean external = isIncludeExternalDTDDeclarations();\n\n      contentHandler.setIncludeInternalDTDDeclarations(internal);\n      contentHandler.setIncludeExternalDTDDeclarations(external);\n      contentHandler.setMergeAdjacentText(isMergeAdjacentText());\n      contentHandler.setStripWhitespaceText(isStripWhitespaceText());\n      contentHandler.setIgnoreComments(isIgnoreComments());\n      reader.setContentHandler(contentHandler);\n\n      configureReader(reader, contentHandler);\n\n      reader.parse(in);\n\n      return contentHandler.getDocument();\n    } catch (Exception e) {\n      if (e instanceof SAXParseException) {\n        // e.printStackTrace();\n        SAXParseException parseException = (SAXParseException) e;\n        String systemId = parseException.getSystemId();\n\n        if (systemId == null) {\n          systemId = \"\";\n        }\n\n        String message = \"Error on line \"\n                + parseException.getLineNumber() + \" of document \"\n                + systemId + \" : \" + parseException.getMessage();\n\n        throw new DocumentException(message, e);\n      } else {\n        throw new DocumentException(e.getMessage(), e);\n      }\n    }\n  }\n\n  // Properties\n  // -------------------------------------------------------------------------\n\n  /**\n   * DOCUMENT ME!\n   *\n   * @return the validation mode, true if validating will be done otherwise\n   * false.\n   */\n  public boolean isValidating() {\n    return validating;\n  }\n\n  /**\n   * Sets the validation mode.\n   *\n   * @param validation indicates whether or not validation should occur.\n   */\n  public void setValidation(boolean validation) {\n    this.validating = validation;\n  }\n\n  /**\n   * DOCUMENT ME!\n   *\n   * @return whether internal DTD declarations should be expanded into the\n   * DocumentType object or not.\n   */\n  public boolean isIncludeInternalDTDDeclarations() {\n    return includeInternalDTDDeclarations;\n  }\n\n  /**\n   * Sets whether internal DTD declarations should be expanded into the\n   * DocumentType object or not.\n   *\n   * @param include whether or not DTD declarations should be expanded and\n   *                included into the DocumentType object.\n   */\n  public void setIncludeInternalDTDDeclarations(boolean include) {\n    this.includeInternalDTDDeclarations = include;\n  }\n\n  /**\n   * DOCUMENT ME!\n   *\n   * @return whether external DTD declarations should be expanded into the\n   * DocumentType object or not.\n   */\n  public boolean isIncludeExternalDTDDeclarations() {\n    return includeExternalDTDDeclarations;\n  }\n\n  /**\n   * Sets whether DTD external declarations should be expanded into the\n   * DocumentType object or not.\n   *\n   * @param include whether or not DTD declarations should be expanded and\n   *                included into the DocumentType object.\n   */\n  public void setIncludeExternalDTDDeclarations(boolean include) {\n    this.includeExternalDTDDeclarations = include;\n  }\n\n  /**\n   * Sets whether String interning is enabled or disabled for element &amp;\n   * attribute names and namespace URIs. This proprety is enabled by default.\n   *\n   * @return DOCUMENT ME!\n   */\n  public boolean isStringInternEnabled() {\n    return stringInternEnabled;\n  }\n\n  /**\n   * Sets whether String interning is enabled or disabled for element &amp;\n   * attribute names and namespace URIs\n   *\n   * @param stringInternEnabled DOCUMENT ME!\n   */\n  public void setStringInternEnabled(boolean stringInternEnabled) {\n    this.stringInternEnabled = stringInternEnabled;\n  }\n\n  /**\n   * Returns whether adjacent text nodes should be merged together.\n   *\n   * @return Value of property mergeAdjacentText.\n   */\n  public boolean isMergeAdjacentText() {\n    return mergeAdjacentText;\n  }\n\n  /**\n   * Sets whether or not adjacent text nodes should be merged together when\n   * parsing.\n   *\n   * @param mergeAdjacentText New value of property mergeAdjacentText.\n   */\n  public void setMergeAdjacentText(boolean mergeAdjacentText) {\n    this.mergeAdjacentText = mergeAdjacentText;\n  }\n\n  /**\n   * Sets whether whitespace between element start and end tags should be\n   * ignored\n   *\n   * @return Value of property stripWhitespaceText.\n   */\n  public boolean isStripWhitespaceText() {\n    return stripWhitespaceText;\n  }\n\n  /**\n   * Sets whether whitespace between element start and end tags should be\n   * ignored.\n   *\n   * @param stripWhitespaceText New value of property stripWhitespaceText.\n   */\n  public void setStripWhitespaceText(boolean stripWhitespaceText) {\n    this.stripWhitespaceText = stripWhitespaceText;\n  }\n\n  /**\n   * Returns whether we should ignore comments or not.\n   *\n   * @return boolean\n   */\n  public boolean isIgnoreComments() {\n    return ignoreComments;\n  }\n\n  /**\n   * Sets whether we should ignore comments or not.\n   *\n   * @param ignoreComments whether we should ignore comments or not.\n   */\n  public void setIgnoreComments(boolean ignoreComments) {\n    this.ignoreComments = ignoreComments;\n  }\n\n  /**\n   * DOCUMENT ME!\n   *\n   * @return the <code>DocumentFactory</code> used to create document\n   * objects\n   */\n  public DocumentFactory getDocumentFactory() {\n    if (factory == null) {\n      factory = DocumentFactory.getInstance();\n    }\n\n    return factory;\n  }\n\n  /**\n   * <p>\n   * This sets the <code>DocumentFactory</code> used to create new\n   * documents. This method allows the building of custom DOM4J tree objects\n   * to be implemented easily using a custom derivation of\n   * {@link DocumentFactory}\n   * </p>\n   *\n   * @param documentFactory <code>DocumentFactory</code> used to create DOM4J objects\n   */\n  public void setDocumentFactory(DocumentFactory documentFactory) {\n    this.factory = documentFactory;\n  }\n\n  /**\n   * DOCUMENT ME!\n   *\n   * @return the <code>ErrorHandler</code> used by SAX\n   */\n  public ErrorHandler getErrorHandler() {\n    return errorHandler;\n  }\n\n  /**\n   * Sets the <code>ErrorHandler</code> used by the SAX\n   * <code>XMLReader</code>.\n   *\n   * @param errorHandler is the <code>ErrorHandler</code> used by SAX\n   */\n  public void setErrorHandler(ErrorHandler errorHandler) {\n    this.errorHandler = errorHandler;\n  }\n\n  /**\n   * Returns the current entity resolver used to resolve entities\n   *\n   * @return DOCUMENT ME!\n   */\n  public EntityResolver getEntityResolver() {\n    return entityResolver;\n  }\n\n  /**\n   * Sets the entity resolver used to resolve entities.\n   *\n   * @param entityResolver DOCUMENT ME!\n   */\n  public void setEntityResolver(EntityResolver entityResolver) {\n    this.entityResolver = entityResolver;\n  }\n\n  /**\n   * DOCUMENT ME!\n   *\n   * @return the <code>XMLReader</code> used to parse SAX events\n   * @throws SAXException DOCUMENT ME!\n   */\n  public XMLReader getXMLReader() throws SAXException {\n    if (xmlReader == null) {\n      xmlReader = createXMLReader();\n    }\n\n    return xmlReader;\n  }\n\n  /**\n   * Sets the <code>XMLReader</code> used to parse SAX events\n   *\n   * @param reader is the <code>XMLReader</code> to parse SAX events\n   */\n  public void setXMLReader(XMLReader reader) {\n    this.xmlReader = reader;\n  }\n\n  /**\n   * Returns encoding used for InputSource (null means system default\n   * encoding)\n   *\n   * @return encoding used for InputSource\n   */\n  public String getEncoding() {\n    return encoding;\n  }\n\n  /**\n   * Sets encoding used for InputSource (null means system default encoding)\n   *\n   * @param encoding is encoding used for InputSource\n   */\n  public void setEncoding(String encoding) {\n    this.encoding = encoding;\n  }\n\n  /**\n   * Sets the class name of the <code>XMLReader</code> to be used to parse\n   * SAX events.\n   *\n   * @param xmlReaderClassName is the class name of the <code>XMLReader</code> to parse SAX\n   *                           events\n   * @throws SAXException DOCUMENT ME!\n   */\n  public void setXMLReaderClassName(String xmlReaderClassName)\n          throws SAXException {\n    setXMLReader(XMLReaderFactory.createXMLReader(xmlReaderClassName));\n  }\n\n  /**\n   * Adds the <code>ElementHandler</code> to be called when the specified\n   * path is encounted.\n   *\n   * @param path    is the path to be handled\n   * @param handler is the <code>ElementHandler</code> to be called by the event\n   *                based processor.\n   */\n  public void addHandler(String path, ElementHandler handler) {\n    getDispatchHandler().addHandler(path, handler);\n  }\n\n  /**\n   * Removes the <code>ElementHandler</code> from the event based processor,\n   * for the specified path.\n   *\n   * @param path is the path to remove the <code>ElementHandler</code> for.\n   */\n  public void removeHandler(String path) {\n    getDispatchHandler().removeHandler(path);\n  }\n\n  /**\n   * When multiple <code>ElementHandler</code> instances have been\n   * registered, this will set a default <code>ElementHandler</code> to be\n   * called for any path which does <b>NOT </b> have a handler registered.\n   *\n   * @param handler is the <code>ElementHandler</code> to be called by the event\n   *                based processor.\n   */\n  public void setDefaultHandler(ElementHandler handler) {\n    getDispatchHandler().setDefaultHandler(handler);\n  }\n\n  /**\n   * This method clears out all the existing handlers and default handler\n   * setting things back as if no handler existed. Useful when reusing an\n   * object instance.\n   */\n  public void resetHandlers() {\n    getDispatchHandler().resetHandlers();\n  }\n\n  /**\n   * Returns the SAX filter being used to filter SAX events.\n   *\n   * @return the SAX filter being used or null if no SAX filter is installed\n   */\n  public XMLFilter getXMLFilter() {\n    return xmlFilter;\n  }\n\n  /**\n   * Sets the SAX filter to be used when filtering SAX events\n   *\n   * @param filter is the SAX filter to use or null to disable filtering\n   */\n  public void setXMLFilter(XMLFilter filter) {\n    this.xmlFilter = filter;\n  }\n\n  // Implementation methods\n  // -------------------------------------------------------------------------\n\n  /**\n   * Installs any XMLFilter objects required to allow the SAX event stream to\n   * be filtered and preprocessed before it gets to dom4j.\n   *\n   * @param reader DOCUMENT ME!\n   * @return the new XMLFilter if applicable or the original XMLReader if no\n   * filter is being used.\n   */\n  protected XMLReader installXMLFilter(XMLReader reader) {\n    XMLFilter filter = getXMLFilter();\n\n    if (filter != null) {\n      // find the root XMLFilter\n      XMLFilter root = filter;\n\n      while (true) {\n        XMLReader parent = root.getParent();\n\n        if (parent instanceof XMLFilter) {\n          root = (XMLFilter) parent;\n        } else {\n          break;\n        }\n      }\n\n      root.setParent(reader);\n\n      return filter;\n    }\n\n    return reader;\n  }\n\n  protected DispatchHandler getDispatchHandler() {\n    if (dispatchHandler == null) {\n      dispatchHandler = new DispatchHandler();\n    }\n\n    return dispatchHandler;\n  }\n\n  protected void setDispatchHandler(DispatchHandler dispatchHandler) {\n    this.dispatchHandler = dispatchHandler;\n  }\n\n  /**\n   * Factory Method to allow alternate methods of creating and configuring\n   * XMLReader objects\n   *\n   * @return DOCUMENT ME!\n   * @throws SAXException DOCUMENT ME!\n   */\n  protected XMLReader createXMLReader() throws SAXException {\n    return SAXHelper.createXMLReader(isValidating());\n  }\n\n  /**\n   * Configures the XMLReader before use\n   *\n   * @param reader  DOCUMENT ME!\n   * @param handler DOCUMENT ME!\n   * @throws DocumentException DOCUMENT ME!\n   */\n  protected void configureReader(XMLReader reader, DefaultHandler handler)\n          throws DocumentException {\n    // configure lexical handling\n    SAXHelper.setParserProperty(reader, SAX_LEXICALHANDLER, handler);\n\n    // try alternate property just in case\n    SAXHelper.setParserProperty(reader, SAX_LEXICAL_HANDLER, handler);\n\n    // register the DeclHandler\n    if (includeInternalDTDDeclarations || includeExternalDTDDeclarations) {\n      SAXHelper.setParserProperty(reader, SAX_DECL_HANDLER, handler);\n    }\n\n    // string interning\n    SAXHelper.setParserFeature(reader, SAX_STRING_INTERNING,\n            isStringInternEnabled());\n\n    try {\n      // configure validation support\n      reader.setFeature(\"http://xml.org/sax/features/validation\",\n              isValidating());\n\n      if (errorHandler != null) {\n        reader.setErrorHandler(errorHandler);\n      } else {\n        reader.setErrorHandler(handler);\n      }\n    } catch (Exception e) {\n      if (isValidating()) {\n        throw new DocumentException(\"Validation not supported for\"\n                + \" XMLReader: \" + reader, e);\n      }\n    }\n  }\n\n  /**\n   * Factory Method to allow user derived SAXContentHandler objects to be used\n   *\n   * @param reader DOCUMENT ME!\n   * @return DOCUMENT ME!\n   */\n  protected SAXContentHandler createContentHandler(XMLReader reader) {\n    return new SAXContentHandler(getDocumentFactory(), dispatchHandler);\n  }\n\n  protected EntityResolver createDefaultEntityResolver(String systemId) {\n    String prefix = null;\n\n    if ((systemId != null) && (systemId.length() > 0)) {\n      int idx = systemId.lastIndexOf('/');\n\n      if (idx > 0) {\n        prefix = systemId.substring(0, idx + 1);\n      }\n    }\n\n    return new SAXEntityResolver(prefix);\n  }\n\n  protected static class SAXEntityResolver implements EntityResolver,\n          Serializable {\n    protected String uriPrefix;\n\n    public SAXEntityResolver(String uriPrefix) {\n      this.uriPrefix = uriPrefix;\n    }\n\n    public InputSource resolveEntity(String publicId, String systemId) {\n      // try create a relative URI reader...\n      if ((systemId != null) && (systemId.length() > 0)) {\n        if ((uriPrefix != null) && (systemId.indexOf(':') <= 0)) {\n          systemId = uriPrefix + systemId;\n        }\n      }\n\n      return new InputSource(systemId);\n    }\n  }\n}\n\n/*\n * Redistribution and use of this software and associated documentation\n * (\"Software\"), with or without modification, are permitted provided that the\n * following conditions are met:\n *\n * 1. Redistributions of source code must retain copyright statements and\n * notices. Redistributions must also contain a copy of this document.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * 3. The name \"DOM4J\" must not be used to endorse or promote products derived\n * from this Software without prior written permission of MetaStuff, Ltd. For\n * written permission, please contact dom4j-info@metastuff.com.\n *\n * 4. Products derived from this Software may not be called \"DOM4J\" nor may\n * \"DOM4J\" appear in their names without prior written permission of MetaStuff,\n * Ltd. DOM4J is a registered trademark of MetaStuff, Ltd.\n *\n * 5. Due credit should be given to the DOM4J Project - http://www.dom4j.org\n *\n * THIS SOFTWARE IS PROVIDED BY METASTUFF, LTD. AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL METASTUFF, LTD. OR ITS CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n *\n * Copyright 2001-2005 (C) MetaStuff, Ltd. All Rights Reserved.\n */\n"], "filenames": ["src/main/java/org/dom4j/DocumentHelper.java", "src/main/java/org/dom4j/io/SAXHelper.java", "src/main/java/org/dom4j/io/SAXReader.java"], "buggy_code_start_loc": [110, 15, 32], "buggy_code_end_loc": [419, 209, 1004], "fixing_code_start_loc": [110, 16, 33], "fixing_code_end_loc": [412, 220, 1020], "type": "CWE-611", "message": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j.", "other": {"cve": {"id": "CVE-2020-10683", "sourceIdentifier": "cve@mitre.org", "published": "2020-05-01T19:15:12.927", "lastModified": "2022-07-25T18:15:17.327", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "dom4j before 2.0.3 and 2.1.x before 2.1.3 allows external DTDs and External Entities by default, which might enable XXE attacks. However, there is popular external documentation from OWASP showing how to enable the safe, non-default behavior in any application that uses dom4j."}, {"lang": "es", "value": "dom4j versiones anteriores a 2.0.3 y versiones 2.1.x anteriores a  2.1.3, permite DTDs y External Entities por defecto, lo que podr\u00eda permitir ataques de tipo XXE. Sin embargo, existe una documentaci\u00f3n externa popular de OWASP que muestra c\u00f3mo habilitar el comportamiento seguro no predeterminado en cualquier aplicaci\u00f3n que use dom4j."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:dom4j_project:dom4j:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.3", "matchCriteriaId": "1D7F74F1-B9EA-4659-9755-B23F7D747685"}, {"vulnerable": true, "criteria": "cpe:2.3:a:dom4j_project:dom4j:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.1.0", "versionEndExcluding": "2.1.3", "matchCriteriaId": "3C2C95BD-A005-44E2-ACE8-633505485D1B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:agile_plm:9.3.3:*:*:*:*:*:*:*", "matchCriteriaId": "D14ABF04-E460-4911-9C6C-B7BCEFE68E9D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:agile_plm:9.3.5:*:*:*:*:*:*:*", "matchCriteriaId": "ED43772F-D280-42F6-A292-7198284D6FE7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:application_testing_suite:13.3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "A125E817-F974-4509-872C-B71933F42AD1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:banking_platform:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndIncluding": "2.10.0", "matchCriteriaId": "3625D477-1338-46CB-90B1-7291D617DC39"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "E869C417-C0E6-4FC3-B406-45598A1D1906"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:business_process_management_suite:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "DFEFE2C0-7B98-44F9-B3AD-D6EC607E90DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_application_session_controller:3.9m0p1:*:*:*:*:*:*:*", "matchCriteriaId": "C6092C11-7779-451C-94F9-24FA2F2010FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_diameter_signaling_router:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndIncluding": "8.2.2", "matchCriteriaId": "526E2FE5-263F-416F-8628-6CD40B865780"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_unified_inventory_management:7.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "05AD47CC-8A6D-4AEC-B23E-701D3D649CC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_unified_inventory_management:7.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "539DA24F-E3E0-4455-84C6-A9D96CD601B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "9901F6BA-78D5-45B8-9409-07FF1C6DDD38"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:data_integrator:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "9FADE563-5AAA-42FF-B43F-35B20A2386C9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:documaker:*:*:*:*:*:*:*:*", "versionStartIncluding": "12.6.0", "versionEndIncluding": "12.6.4", "matchCriteriaId": "135D531C-A692-4BE3-AB8C-37BB0D35559A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:endeca_information_discovery_integrator:3.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "7E856B4A-6AE7-4317-921A-35B4D2048652"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_data_quality:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7DCC2C59-BB9B-4BD2-80A4-33B72737FA10"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_data_quality:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "36CF85A9-2C29-46E7-961E-8ADD0B5822CF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:enterprise_manager_base_platform:13.4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D26F3E23-F1A9-45E7-9E5F-0C0A24EE3783"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.6", "versionEndIncluding": "8.1.0", "matchCriteriaId": "021014B2-DC51-481C-BCFE-5857EFBDEDDA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:flexcube_core_banking:11.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "87416B3B-3B2B-486B-B931-19199EF07000"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:flexcube_core_banking:11.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "1102B6BC-D99E-4AC0-9375-FB8517A4A71F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:flexcube_core_banking:11.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "4D22386C-FEC4-4984-8E2A-8FE4796BEFBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:flexcube_core_banking:11.10.0:*:*:*:*:*:*:*", "matchCriteriaId": "B283B614-9E31-4148-8688-B0672B3A77B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:fusion_middleware:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "6329B1A2-75A8-4909-B4FB-77AC7232B6ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:health_sciences_empirica_signal:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "2051BA9E-E635-47D5-B942-8AC26E9487CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:health_sciences_information_manager:3.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "C666FA96-3809-475C-B68F-29E59BD51959"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_policy_administration_j2ee:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "48261B54-471D-4C03-AFF9-6F2EA8FA8EBB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_policy_administration_j2ee:10.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "64D4B80E-2B67-4BDC-9A3A-7BFDA171016A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_policy_administration_j2ee:10.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "33E0F28C-1FF3-4E12-AAE4-A765F4F81EC0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_policy_administration_j2ee:11.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "9A570E5E-A3BC-4E19-BC44-C28D8BC9A537"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_rules_palette:*:*:*:*:*:*:*:*", "versionStartIncluding": "11.1.0", "versionEndIncluding": "11.3.0", "matchCriteriaId": "5DEAB5CD-4223-4A43-AB9E-486113827A6C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_rules_palette:10.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "AEDF91E2-E7B5-40EE-B71F-C7D59F4021BD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_rules_palette:10.2.4:*:*:*:*:*:*:*", "matchCriteriaId": "9A94F93C-5828-4D78-9C48-20AC17E72B8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:insurance_rules_palette:11.0.2:*:*:*:*:*:*:*", "matchCriteriaId": "F3E25293-CB03-44CE-A8ED-04B3A0487A6A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:jdeveloper:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "335AB6A7-3B1F-4FA8-AF08-7D64C16C4B04"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "16.1.0.0", "versionEndIncluding": "16.2.20.1", "matchCriteriaId": "951CE1FD-CBFD-4724-919F-CF9B529F0BA5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "17.1.0.0", "versionEndIncluding": "17.12.17.1", "matchCriteriaId": "B89D2BCD-BA96-4DCF-A8B0-59989AD1BC87"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "18.1.0.0", "versionEndIncluding": "18.8.19.0", "matchCriteriaId": "18CE17D6-FC25-4FDA-AD28-BD8533C7513A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:primavera_p6_enterprise_project_portfolio_management:*:*:*:*:*:*:*:*", "versionStartIncluding": "19.12.0.0", "versionEndIncluding": "19.12.6.0", "matchCriteriaId": "5DE19678-FB27-4E29-A7BF-232141D52502"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:rapid_planning:12.1:*:*:*:*:*:*:*", "matchCriteriaId": "19A0F1AF-F2E6-44E7-8E2D-190E103B72D3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:rapid_planning:12.2:*:*:*:*:*:*:*", "matchCriteriaId": "6D53690D-3390-4A27-988A-709CD89DD05B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_customer_management_and_segmentation_foundation:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "CBEEB907-B163-43FF-86DE-4387123DCC4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_customer_management_and_segmentation_foundation:17.0:*:*:*:*:*:*:*", "matchCriteriaId": "A7FBF5C7-EC73-4CE4-8CB7-E9CF5705DB25"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_customer_management_and_segmentation_foundation:18.0:*:*:*:*:*:*:*", "matchCriteriaId": "36E16AEF-ACEB-413C-888C-8D250F65C180"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_customer_management_and_segmentation_foundation:19.0:*:*:*:*:*:*:*", "matchCriteriaId": "9EFAEA84-E376-40A2-8C9F-3E0676FEC527"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_integration_bus:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "42064F46-3012-4FB1-89BA-F13C2E4CBB6B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_integration_bus:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "F73E2EFA-0F43-4D92-8C7D-9E66811B76D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_order_broker:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "EE8CF045-09BB-4069-BCEC-496D5AE3B780"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_order_broker:16.0:*:*:*:*:*:*:*", "matchCriteriaId": "38E74E68-7F19-4EF3-AC00-3C249EAAA39E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_order_broker:18.0:*:*:*:*:*:*:*", "matchCriteriaId": "0783F0D1-8FAC-4BCA-A6F5-C5C60E86D56D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_order_broker:19.0:*:*:*:*:*:*:*", "matchCriteriaId": "BFB0BB58-04D3-409D-AECC-9633782F0E75"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_order_broker:19.1:*:*:*:*:*:*:*", "matchCriteriaId": "C7BD0D41-1BED-4C4F-95C8-8987C98908DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_price_management:14.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "47F3EA56-89AF-4AD5-BA19-D32DBDA087A7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_price_management:14.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "0791694C-9B4E-42EA-8F6C-899B43B6D769"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_price_management:15.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "312992F0-E65A-4E38-A44C-363A7E157CE4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_price_management:16.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "E1940FD6-39FA-4F92-9625-F215D8051E80"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:15.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "78D8F551-8DC8-4510-8350-AE6BC64748DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:16.0.6:*:*:*:*:*:*:*", "matchCriteriaId": "490B2C44-CECD-4551-B04F-4076D0E053C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:17.0.4:*:*:*:*:*:*:*", "matchCriteriaId": "DEC41EB8-73B4-4BDF-9321-F34EC0BAF9E6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:retail_xstore_point_of_service:18.0.3:*:*:*:*:*:*:*", "matchCriteriaId": "48EFC111-B01B-4C34-87E4-D6B2C40C0122"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:storagetek_tape_analytics_sw_tool:2.3:*:*:*:*:*:*:*", "matchCriteriaId": "E55B3AA9-69BE-4136-8C3A-FD0DDCD3FA4B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_framework:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.3.0.1.0", "versionEndIncluding": "4.3.0.6.0", "matchCriteriaId": "51309958-121D-4649-AB9A-EBFA3A49F7CB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_framework:2.2.0.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "D883EED9-CC64-479D-9C0A-35EB16F43AB4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_framework:4.2.0.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "5435B365-BFF3-4A9E-B45C-42D8F1E20FB7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_framework:4.2.0.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "1FAC3840-2CF8-44CE-81BB-EEEBDA00A34A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_framework:4.4.0.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "3F906F04-39E4-4BE4-8A73-9D058AAADB43"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:utilities_framework:4.4.0.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "7B393A82-476A-4270-A903-38ED4169E431"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:11.1.1.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "D7756147-7168-4E03-93EE-31379F6BE88E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:12.2.1.3.0:*:*:*:*:*:*:*", "matchCriteriaId": "D6A4F71A-4269-40FC-8F61-1D1301F2B728"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:webcenter_portal:12.2.1.4.0:*:*:*:*:*:*:*", "matchCriteriaId": "5A502118-5B2B-47AE-82EC-1999BD841103"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_api_services:-:*:*:*:*:*:*:*", "matchCriteriaId": "5EC98B22-FFAA-4B59-8E63-EBAA4336AD13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:oncommand_workflow_automation:-:*:*:*:*:*:*:*", "matchCriteriaId": "5735E553-9731-4AAC-BCFF-989377F817B3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snap_creator_framework:-:*:*:*:*:*:*:*", "matchCriteriaId": "9F4754FB-E3EB-454A-AB1A-AE3835C5350C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapcenter:-:*:*:*:*:*:*:*", "matchCriteriaId": "BDFB1169-41A0-4A86-8E4F-FDA9730B1E94"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapmanager:-:*:*:*:*:oracle:*:*", "matchCriteriaId": "26A2B713-7D6D-420A-93A4-E0D983C983DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:netapp:snapmanager:-:*:*:*:*:sap:*:*", "matchCriteriaId": "64DE38C8-94F1-4860-B045-F33928F676A8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-05/msg00061.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1694235", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/dom4j/dom4j/commit/a8228522a99a02146106672a34c104adbda5c658", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dom4j/dom4j/commits/version-2.0.3", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/dom4j/dom4j/issues/87", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/dom4j/dom4j/releases/tag/version-2.1.3", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r51f3f9801058e47153c0ad9bc6209d57a592fc0e7aefd787760911b8@%3Cdev.velocity.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r91c64cd51e68e97d524395474eaa25362d564572276b9917fcbf5c32@%3Cdev.velocity.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb1b990d7920ae0d50da5109b73b92bab736d46c9788dd4b135cb1a51@%3Cnotifications.freemarker.apache.org%3E", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200518-0002/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4575-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com//security-alerts/cpujul2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuApr2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujan2022.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2020.html", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "cve@mitre.org"}, {"url": "https://www.oracle.com/security-alerts/cpuoct2020.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuoct2021.html", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/dom4j/dom4j/commit/a8228522a99a02146106672a34c104adbda5c658"}}