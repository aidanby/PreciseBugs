{"buggy_code": ["/*\n * Pictor/PC Paint decoder\n * Copyright (c) 2010 Peter Ross <pross@xvid.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Pictor/PC Paint decoder\n */\n\n#include \"libavutil/imgutils.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"cga_data.h\"\n#include \"internal.h\"\n\ntypedef struct PicContext {\n    int width, height;\n    int nb_planes;\n    GetByteContext g;\n} PicContext;\n\nstatic void picmemset_8bpp(PicContext *s, AVFrame *frame, int value, int run,\n                           int *x, int *y)\n{\n    while (run > 0) {\n        uint8_t *d = frame->data[0] + *y * frame->linesize[0];\n        if (*x + run >= s->width) {\n            int n = s->width - *x;\n            memset(d + *x, value, n);\n            run -= n;\n            *x = 0;\n            *y -= 1;\n            if (*y < 0)\n                break;\n        } else {\n            memset(d + *x, value, run);\n            *x += run;\n            break;\n        }\n    }\n}\n\nstatic void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n                      int *x, int *y, int *plane, int bits_per_plane)\n{\n    uint8_t *d;\n    int shift = *plane * bits_per_plane;\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n    value   <<= shift;\n\n    while (run > 0) {\n        int j;\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n            d = frame->data[0] + *y * frame->linesize[0];\n            d[*x] |= (value >> j) & mask;\n            *x += 1;\n            if (*x == s->width) {\n                *y -= 1;\n                *x = 0;\n                if (*y < 0) {\n                   *y = s->height - 1;\n                   *plane += 1;\n                   value <<= bits_per_plane;\n                   mask  <<= bits_per_plane;\n                   if (*plane >= s->nb_planes)\n                       break;\n                }\n            }\n        }\n        run--;\n    }\n}\n\nstatic const uint8_t cga_mode45_index[6][4] = {\n    [0] = { 0, 3,  5,   7 }, // mode4, palette#1, low intensity\n    [1] = { 0, 2,  4,   6 }, // mode4, palette#2, low intensity\n    [2] = { 0, 3,  4,   7 }, // mode5, low intensity\n    [3] = { 0, 11, 13, 15 }, // mode4, palette#1, high intensity\n    [4] = { 0, 10, 12, 14 }, // mode4, palette#2, high intensity\n    [5] = { 0, 11, 12, 15 }, // mode5, high intensity\n};\n\nstatic int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PicContext *s = avctx->priv_data;\n    AVFrame *frame = data;\n    uint32_t *palette;\n    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;\n    int i, x, y, plane, tmp, ret, val;\n\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n\n    if (bytestream2_get_bytes_left(&s->g) < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (bytestream2_get_le16u(&s->g) != 0x1234)\n        return AVERROR_INVALIDDATA;\n\n    s->width       = bytestream2_get_le16u(&s->g);\n    s->height      = bytestream2_get_le16u(&s->g);\n    bytestream2_skip(&s->g, 4);\n    tmp            = bytestream2_get_byteu(&s->g);\n    bits_per_plane = tmp & 0xF;\n    s->nb_planes   = (tmp >> 4) + 1;\n    bpp            = bits_per_plane * s->nb_planes;\n    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {\n        avpriv_request_sample(avctx, \"Unsupported bit depth\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {\n        bytestream2_skip(&s->g, 2);\n        etype = bytestream2_get_le16(&s->g);\n        esize = bytestream2_get_le16(&s->g);\n        if (bytestream2_get_bytes_left(&s->g) < esize)\n            return AVERROR_INVALIDDATA;\n    } else {\n        etype = -1;\n        esize = 0;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    if (av_image_check_size(s->width, s->height, 0, avctx) < 0)\n        return -1;\n    if (s->width != avctx->width && s->height != avctx->height) {\n        ret = ff_set_dimensions(avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n    }\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n    memset(frame->data[0], 0, s->height * frame->linesize[0]);\n    frame->pict_type           = AV_PICTURE_TYPE_I;\n    frame->palette_has_changed = 1;\n\n    pos_after_pal = bytestream2_tell(&s->g) + esize;\n    palette = (uint32_t*)frame->data[1];\n    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {\n        int idx = bytestream2_get_byte(&s->g);\n        npal = 4;\n        for (i = 0; i < npal; i++)\n            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];\n    } else if (etype == 2) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];\n        }\n    } else if (etype == 3) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];\n        }\n    } else if (etype == 4 || etype == 5) {\n        npal = FFMIN(esize / 3, 256);\n        for (i = 0; i < npal; i++) {\n            palette[i] = bytestream2_get_be24(&s->g) << 2;\n            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;\n        }\n    } else {\n        if (bpp == 1) {\n            npal = 2;\n            palette[0] = 0xFF000000;\n            palette[1] = 0xFFFFFFFF;\n        } else if (bpp == 2) {\n            npal = 4;\n            for (i = 0; i < npal; i++)\n                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];\n        } else {\n            npal = 16;\n            memcpy(palette, ff_cga_palette, npal * 4);\n        }\n    }\n    // fill remaining palette entries\n    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);\n    // skip remaining palette bytes\n    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);\n\n    val = 0;\n    y = s->height - 1;\n    if (bytestream2_get_le16(&s->g)) {\n        x = 0;\n        plane = 0;\n        while (bytestream2_get_bytes_left(&s->g) >= 6) {\n            int stop_size, marker, t1, t2;\n\n            t1        = bytestream2_get_bytes_left(&s->g);\n            t2        = bytestream2_get_le16(&s->g);\n            stop_size = t1 - FFMIN(t1, t2);\n            // ignore uncompressed block size\n            bytestream2_skip(&s->g, 2);\n            marker    = bytestream2_get_byte(&s->g);\n\n            while (plane < s->nb_planes &&\n                   bytestream2_get_bytes_left(&s->g) > stop_size) {\n                int run = 1;\n                val = bytestream2_get_byte(&s->g);\n                if (val == marker) {\n                    run = bytestream2_get_byte(&s->g);\n                    if (run == 0)\n                        run = bytestream2_get_le16(&s->g);\n                    val = bytestream2_get_byte(&s->g);\n                }\n                if (!bytestream2_get_bytes_left(&s->g))\n                    break;\n\n                if (bits_per_plane == 8) {\n                    picmemset_8bpp(s, frame, val, run, &x, &y);\n                    if (y < 0)\n                        goto finish;\n                } else {\n                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);\n                }\n            }\n        }\n\n        if (x < avctx->width) {\n            int run = (y + 1) * avctx->width - x;\n            if (bits_per_plane == 8)\n                picmemset_8bpp(s, frame, val, run, &x, &y);\n            else\n                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);\n        }\n    } else {\n        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {\n            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));\n            bytestream2_skip(&s->g, avctx->width);\n            y--;\n        }\n    }\nfinish:\n\n    *got_frame      = 1;\n    return avpkt->size;\n}\n\nAVCodec ff_pictor_decoder = {\n    .name           = \"pictor\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Pictor/PC Paint\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_PICTOR,\n    .priv_data_size = sizeof(PicContext),\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n};\n"], "fixing_code": ["/*\n * Pictor/PC Paint decoder\n * Copyright (c) 2010 Peter Ross <pross@xvid.org>\n *\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n/**\n * @file\n * Pictor/PC Paint decoder\n */\n\n#include \"libavutil/imgutils.h\"\n#include \"avcodec.h\"\n#include \"bytestream.h\"\n#include \"cga_data.h\"\n#include \"internal.h\"\n\ntypedef struct PicContext {\n    int width, height;\n    int nb_planes;\n    GetByteContext g;\n} PicContext;\n\nstatic void picmemset_8bpp(PicContext *s, AVFrame *frame, int value, int run,\n                           int *x, int *y)\n{\n    while (run > 0) {\n        uint8_t *d = frame->data[0] + *y * frame->linesize[0];\n        if (*x + run >= s->width) {\n            int n = s->width - *x;\n            memset(d + *x, value, n);\n            run -= n;\n            *x = 0;\n            *y -= 1;\n            if (*y < 0)\n                break;\n        } else {\n            memset(d + *x, value, run);\n            *x += run;\n            break;\n        }\n    }\n}\n\nstatic void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n                      int *x, int *y, int *plane, int bits_per_plane)\n{\n    uint8_t *d;\n    int shift = *plane * bits_per_plane;\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n    value   <<= shift;\n\n    while (run > 0) {\n        int j;\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n            d = frame->data[0] + *y * frame->linesize[0];\n            d[*x] |= (value >> j) & mask;\n            *x += 1;\n            if (*x == s->width) {\n                *y -= 1;\n                *x = 0;\n                if (*y < 0) {\n                   *y = s->height - 1;\n                   *plane += 1;\n                   value <<= bits_per_plane;\n                   mask  <<= bits_per_plane;\n                   if (*plane >= s->nb_planes)\n                       break;\n                }\n            }\n        }\n        run--;\n    }\n}\n\nstatic const uint8_t cga_mode45_index[6][4] = {\n    [0] = { 0, 3,  5,   7 }, // mode4, palette#1, low intensity\n    [1] = { 0, 2,  4,   6 }, // mode4, palette#2, low intensity\n    [2] = { 0, 3,  4,   7 }, // mode5, low intensity\n    [3] = { 0, 11, 13, 15 }, // mode4, palette#1, high intensity\n    [4] = { 0, 10, 12, 14 }, // mode4, palette#2, high intensity\n    [5] = { 0, 11, 12, 15 }, // mode5, high intensity\n};\n\nstatic int decode_frame(AVCodecContext *avctx,\n                        void *data, int *got_frame,\n                        AVPacket *avpkt)\n{\n    PicContext *s = avctx->priv_data;\n    AVFrame *frame = data;\n    uint32_t *palette;\n    int bits_per_plane, bpp, etype, esize, npal, pos_after_pal;\n    int i, x, y, plane, tmp, ret, val;\n\n    bytestream2_init(&s->g, avpkt->data, avpkt->size);\n\n    if (bytestream2_get_bytes_left(&s->g) < 11)\n        return AVERROR_INVALIDDATA;\n\n    if (bytestream2_get_le16u(&s->g) != 0x1234)\n        return AVERROR_INVALIDDATA;\n\n    s->width       = bytestream2_get_le16u(&s->g);\n    s->height      = bytestream2_get_le16u(&s->g);\n    bytestream2_skip(&s->g, 4);\n    tmp            = bytestream2_get_byteu(&s->g);\n    bits_per_plane = tmp & 0xF;\n    s->nb_planes   = (tmp >> 4) + 1;\n    bpp            = bits_per_plane * s->nb_planes;\n    if (bits_per_plane > 8 || bpp < 1 || bpp > 32) {\n        avpriv_request_sample(avctx, \"Unsupported bit depth\");\n        return AVERROR_PATCHWELCOME;\n    }\n\n    if (bytestream2_peek_byte(&s->g) == 0xFF || bpp == 1 || bpp == 4 || bpp == 8) {\n        bytestream2_skip(&s->g, 2);\n        etype = bytestream2_get_le16(&s->g);\n        esize = bytestream2_get_le16(&s->g);\n        if (bytestream2_get_bytes_left(&s->g) < esize)\n            return AVERROR_INVALIDDATA;\n    } else {\n        etype = -1;\n        esize = 0;\n    }\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    if (av_image_check_size(s->width, s->height, 0, avctx) < 0)\n        return -1;\n    if (s->width != avctx->width || s->height != avctx->height) {\n        ret = ff_set_dimensions(avctx, s->width, s->height);\n        if (ret < 0)\n            return ret;\n    }\n\n    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0)\n        return ret;\n    memset(frame->data[0], 0, s->height * frame->linesize[0]);\n    frame->pict_type           = AV_PICTURE_TYPE_I;\n    frame->palette_has_changed = 1;\n\n    pos_after_pal = bytestream2_tell(&s->g) + esize;\n    palette = (uint32_t*)frame->data[1];\n    if (etype == 1 && esize > 1 && bytestream2_peek_byte(&s->g) < 6) {\n        int idx = bytestream2_get_byte(&s->g);\n        npal = 4;\n        for (i = 0; i < npal; i++)\n            palette[i] = ff_cga_palette[ cga_mode45_index[idx][i] ];\n    } else if (etype == 2) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_cga_palette[FFMIN(pal_idx, 15)];\n        }\n    } else if (etype == 3) {\n        npal = FFMIN(esize, 16);\n        for (i = 0; i < npal; i++) {\n            int pal_idx = bytestream2_get_byte(&s->g);\n            palette[i]  = ff_ega_palette[FFMIN(pal_idx, 63)];\n        }\n    } else if (etype == 4 || etype == 5) {\n        npal = FFMIN(esize / 3, 256);\n        for (i = 0; i < npal; i++) {\n            palette[i] = bytestream2_get_be24(&s->g) << 2;\n            palette[i] |= 0xFFU << 24 | palette[i] >> 6 & 0x30303;\n        }\n    } else {\n        if (bpp == 1) {\n            npal = 2;\n            palette[0] = 0xFF000000;\n            palette[1] = 0xFFFFFFFF;\n        } else if (bpp == 2) {\n            npal = 4;\n            for (i = 0; i < npal; i++)\n                palette[i] = ff_cga_palette[ cga_mode45_index[0][i] ];\n        } else {\n            npal = 16;\n            memcpy(palette, ff_cga_palette, npal * 4);\n        }\n    }\n    // fill remaining palette entries\n    memset(palette + npal, 0, AVPALETTE_SIZE - npal * 4);\n    // skip remaining palette bytes\n    bytestream2_seek(&s->g, pos_after_pal, SEEK_SET);\n\n    val = 0;\n    y = s->height - 1;\n    if (bytestream2_get_le16(&s->g)) {\n        x = 0;\n        plane = 0;\n        while (bytestream2_get_bytes_left(&s->g) >= 6) {\n            int stop_size, marker, t1, t2;\n\n            t1        = bytestream2_get_bytes_left(&s->g);\n            t2        = bytestream2_get_le16(&s->g);\n            stop_size = t1 - FFMIN(t1, t2);\n            // ignore uncompressed block size\n            bytestream2_skip(&s->g, 2);\n            marker    = bytestream2_get_byte(&s->g);\n\n            while (plane < s->nb_planes &&\n                   bytestream2_get_bytes_left(&s->g) > stop_size) {\n                int run = 1;\n                val = bytestream2_get_byte(&s->g);\n                if (val == marker) {\n                    run = bytestream2_get_byte(&s->g);\n                    if (run == 0)\n                        run = bytestream2_get_le16(&s->g);\n                    val = bytestream2_get_byte(&s->g);\n                }\n                if (!bytestream2_get_bytes_left(&s->g))\n                    break;\n\n                if (bits_per_plane == 8) {\n                    picmemset_8bpp(s, frame, val, run, &x, &y);\n                    if (y < 0)\n                        goto finish;\n                } else {\n                    picmemset(s, frame, val, run, &x, &y, &plane, bits_per_plane);\n                }\n            }\n        }\n\n        if (x < avctx->width) {\n            int run = (y + 1) * avctx->width - x;\n            if (bits_per_plane == 8)\n                picmemset_8bpp(s, frame, val, run, &x, &y);\n            else\n                picmemset(s, frame, val, run / (8 / bits_per_plane), &x, &y, &plane, bits_per_plane);\n        }\n    } else {\n        while (y >= 0 && bytestream2_get_bytes_left(&s->g) > 0) {\n            memcpy(frame->data[0] + y * frame->linesize[0], s->g.buffer, FFMIN(avctx->width, bytestream2_get_bytes_left(&s->g)));\n            bytestream2_skip(&s->g, avctx->width);\n            y--;\n        }\n    }\nfinish:\n\n    *got_frame      = 1;\n    return avpkt->size;\n}\n\nAVCodec ff_pictor_decoder = {\n    .name           = \"pictor\",\n    .long_name      = NULL_IF_CONFIG_SMALL(\"Pictor/PC Paint\"),\n    .type           = AVMEDIA_TYPE_VIDEO,\n    .id             = AV_CODEC_ID_PICTOR,\n    .priv_data_size = sizeof(PicContext),\n    .decode         = decode_frame,\n    .capabilities   = AV_CODEC_CAP_DR1,\n};\n"], "filenames": ["libavcodec/pictordec.c"], "buggy_code_start_loc": [145], "buggy_code_end_loc": [146], "fixing_code_start_loc": [145], "fixing_code_end_loc": [146], "type": "CWE-787", "message": "FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c.", "other": {"cve": {"id": "CVE-2017-7862", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-14T04:59:00.447", "lastModified": "2018-11-27T11:29:02.737", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "FFmpeg before 2017-02-07 has an out-of-bounds write caused by a heap-based buffer overflow related to the decode_frame function in libavcodec/pictordec.c."}, {"lang": "es", "value": "FFmpeg en versiones anteriores a 07-02-2017 tiene una escritura fuera de l\u00edmites provocado por un desbordamiento de b\u00fafer basado en memoria din\u00e1mica en relaci\u00f3n con la funci\u00f3n decode_frame en libavcodec/pictordec.c"}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.8.10", "matchCriteriaId": "E0E1F413-9BBA-4CDD-8162-0E550316B36A"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-4012", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/97676", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=559", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FFmpeg/FFmpeg/commit/8c2ea3030af7b40a3c4275696fb5c76cdb80950a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201811-19", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/8c2ea3030af7b40a3c4275696fb5c76cdb80950a"}}