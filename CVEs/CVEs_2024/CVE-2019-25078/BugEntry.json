{"buggy_code": ["// Copyright (C) 2007 Manu Garg.\n// Author: Manu Garg <manugarg@gmail.com>\n//\n// pacparser is a library that provides methods to parse proxy auto-config\n// (PAC) files. Please read README file included with this package for more\n// information about this library.\n//\n// pacparser is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3 of the License, or (at your option) any later version.\n\n// pacparser is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n\n#include <errno.h>\n#include <jsapi.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#ifdef XP_UNIX\n#include <unistd.h>\n#include <sys/socket.h>                // for AF_INET\n#include <netdb.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#endif\n\n#include \"pac_utils.h\"\n#include \"pacparser.h\"\n\n#define MAX_IP_RESULTS 10\n\nstatic char *myip = NULL;\n\n// Default error printer function.\nstatic int\t\t// Number of characters printed, negative value in case of output error.\n_default_error_printer(const char *fmt, va_list argp)\n{\n  return vfprintf(stderr, fmt, argp);\n}\n\n// File level variable to hold error printer function pointer.\nstatic pacparser_error_printer error_printer_func = &_default_error_printer;\n\n// Set error printer to a user defined function.\nvoid\npacparser_set_error_printer(pacparser_error_printer func)\n{\n  error_printer_func = func;\n}\n\nstatic int print_error(const char *fmt, ...)\n{\n  int ret;\n  va_list args;\n  va_start(args, fmt);\n  ret = (*error_printer_func)(fmt, args);\n  va_end(args);\n  return ret;\n}\n\nstatic int\n_debug(void) {\n  if(getenv(\"PACPARSER_DEBUG\")) return 1;\n  return 0;\n}\n\n// Utility function to read a file into string.\nstatic char *                      // File content in string or NULL if failed.\nread_file_into_str(const char *filename)\n{\n  char *str;\n  int file_size;\n  FILE *fptr;\n  int records_read;\n  if (!(fptr = fopen(filename, \"r\"))) goto error1;\n  if ((fseek(fptr, 0L, SEEK_END) != 0)) goto error2;\n  if (!(file_size=ftell(fptr))) goto error2;\n  if ((fseek(fptr, 0L, SEEK_SET) != 0)) goto error2;\n  if (!(str = (char*) malloc(file_size+1))) goto error2;\n  if (!(records_read=fread(str, 1, file_size, fptr))) {\n    free(str);\n    goto error2;\n  }\n  str[records_read] = '\\0';\n  fclose(fptr);\n  return str;\nerror2:\n  fclose(fptr);\nerror1:\n  return NULL;\n}\n\nstatic void\nprint_jserror(JSContext *cx, const char *message, JSErrorReport *report)\n{\n  print_error(\"JSERROR: %s:%d:\\n    %s\\n\",\n\t      (report->filename ? report->filename : \"NULL\"), report->lineno,\n\t      message);\n}\n\n// DNS Resolve function; used by other routines.\n// This function is used by dnsResolve, dnsResolveEx, myIpAddress,\n// myIpAddressEx.\nstatic int\nresolve_host(const char *hostname, char *ipaddr_list, int max_results,\n             int req_ai_family)\n{\n  struct addrinfo hints;\n  struct addrinfo *result;\n  struct addrinfo *ai;\n  char ipaddr[INET6_ADDRSTRLEN];\n  int error;\n\n  // Truncate ipaddr_list to an empty string.\n  ipaddr_list[0] = '\\0';\n\n#ifdef _WIN32\n  // On windows, we need to initialize the winsock dll first.\n  WSADATA WsaData;\n  WSAStartup(MAKEWORD(2,0), &WsaData);\n#endif\n\n  memset(&hints, 0, sizeof(struct addrinfo));\n\n  hints.ai_family = req_ai_family;\n  hints.ai_socktype = SOCK_STREAM;\n\n  error = getaddrinfo(hostname, NULL, &hints, &result);\n  if (error) return error;\n  int i = 0;\n  for(ai = result; ai != NULL && i < max_results; ai = ai->ai_next, i++) {\n    getnameinfo(ai->ai_addr, ai->ai_addrlen, ipaddr, sizeof(ipaddr), NULL, 0,\n                NI_NUMERICHOST);\n    if (ipaddr_list[0] == '\\0') sprintf(ipaddr_list, \"%s\", ipaddr);\n    else sprintf(ipaddr_list, \"%s;%s\", ipaddr_list, ipaddr);\n  }\n  freeaddrinfo(result);\n#ifdef _WIN32\n  WSACleanup();\n#endif\n  return 0;\n}\n\n// dnsResolve in JS context; not available in core JavaScript.\n// returns javascript null if not able to resolve.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\ndns_resolve(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\n{\n  char* name = JS_GetStringBytes(JS_ValueToString(cx, argv[0]));\n  char* out;\n  char ipaddr[INET6_ADDRSTRLEN] = \"\";\n\n  // Return null on failure.\n  if(resolve_host(name, ipaddr, 1, AF_INET)) {\n    *rval = JSVAL_NULL;\n    return JS_TRUE;\n  }\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// dnsResolveEx in JS context; not available in core JavaScript.\n// returns javascript null if not able to resolve.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\ndns_resolve_ex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,\n               jsval *rval)\n{\n  char* name = JS_GetStringBytes(JS_ValueToString(cx, argv[0]));\n  char* out;\n  char ipaddr[INET6_ADDRSTRLEN * MAX_IP_RESULTS + MAX_IP_RESULTS] = \"\";\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  // Return \"\" on failure.\n  if(resolve_host(name, ipaddr, MAX_IP_RESULTS, AF_UNSPEC)) {\n    strcpy(out, \"\");\n  }\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// myIpAddress in JS context; not available in core JavaScript.\n// returns 127.0.0.1 if not able to determine local ip.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\nmy_ip(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\n{\n  char ipaddr[INET6_ADDRSTRLEN];\n  char* out;\n\n  if (myip)                  // If my (client's) IP address is already set.\n    strcpy(ipaddr, myip);\n  else {\n    char name[256];\n    gethostname(name, sizeof(name));\n    if (resolve_host(name, ipaddr, 1, AF_INET)) {\n      strcpy(ipaddr, \"127.0.0.1\");\n    }\n  }\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// myIpAddressEx in JS context; not available in core JavaScript.\n// returns 127.0.0.1 if not able to determine local ip.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\nmy_ip_ex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\n{\n  char ipaddr[INET6_ADDRSTRLEN * MAX_IP_RESULTS + MAX_IP_RESULTS];\n  char* out;\n\n  if (myip)                  // If my (client's) IP address is already set.\n    strcpy(ipaddr, myip);\n  else {\n    char name[256];\n    gethostname(name, sizeof(name));\n    if (resolve_host(name, ipaddr, MAX_IP_RESULTS, AF_UNSPEC)) {\n      strcpy(ipaddr, \"\");\n    }\n  }\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// Define some JS context related variables.\nstatic JSRuntime *rt = NULL;\nstatic JSContext *cx = NULL;\nstatic JSObject *global = NULL;\nstatic JSClass global_class = {\n    \"global\",0,\n    JS_PropertyStub,JS_PropertyStub,JS_PropertyStub,JS_PropertyStub,\n    JS_EnumerateStub,JS_ResolveStub,JS_ConvertStub,JS_FinalizeStub\n};\n\n// Set my (client's) IP address to a custom value.\nint\npacparser_setmyip(const char *ip)\n{\n  if (strlen(ip) > INET6_ADDRSTRLEN) {\n    fprintf(stderr, \"pacparser_setmyip: IP too long: %s\\n\", ip);\n    return 0;\n  }\n\n  myip = malloc(strlen(ip) +1);         // Allocate space just to be sure.\n  strcpy(myip, ip);\n  return 1;\n}\n\n// Decprecated: This function doesn't do anything.\n//\n// This function doesn't do anything. Microsoft exntensions are now enabled by\n// default.\nvoid\npacparser_enable_microsoft_extensions()\n{\n  return;\n}\n\n// Initialize PAC parser.\n//\n// - Initializes JavaScript engine,\n// - Exports dns_functions (defined above) to JavaScript context.\n// - Sets error reporting function to print_jserror,\n// - Evaluates JavaScript code in pacUtils variable defined in pac_utils.h.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_init()\n{\n  jsval rval;\n  char *error_prefix = \"pacparser.c: pacparser_init:\";\n  // Initialize JS engine\n  if (!(rt = JS_NewRuntime(8L * 1024L * 1024L)) ||\n      !(cx = JS_NewContext(rt, 8192)) ||\n      !(global = JS_NewObject(cx, &global_class, NULL, NULL)) ||\n      !JS_InitStandardClasses(cx, global)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Could not initialize  JavaScript \"\n\t\t  \"runtime.\");\n    return 0;\n  }\n  JS_SetErrorReporter(cx, print_jserror);\n  // Export our functions to Javascript engine\n  if (!JS_DefineFunction(cx, global, \"dnsResolve\", dns_resolve, 1, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not define dnsResolve in JS context.\");\n    return 0;\n  }\n  if (!JS_DefineFunction(cx, global, \"myIpAddress\", my_ip, 0, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not define myIpAddress in JS context.\");\n    return 0;\n  }\n  if (!JS_DefineFunction(cx, global, \"dnsResolveEx\", dns_resolve_ex, 1, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n      \"Could not define dnsResolveEx in JS context.\");\n    return 0;\n  }\n  if (!JS_DefineFunction(cx, global, \"myIpAddressEx\", my_ip_ex, 0, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not define myIpAddressEx in JS context.\");\n    return 0;\n  }\n  // Evaluate pacUtils. Utility functions required to parse pac files.\n  if (!JS_EvaluateScript(cx,           // JS engine context\n                         global,       // global object\n                         pacUtils,     // this is defined in pac_utils.h\n                         strlen(pacUtils),\n                         NULL,         // filename (NULL in this case)\n                         1,            // line number, used for reporting.\n                         &rval)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not evaluate pacUtils defined in pac_utils.h.\");\n    return 0;\n  }\n  if (_debug()) print_error(\"DEBUG: Pacparser Initalized.\\n\");\n  return 1;\n}\n\n// Parses the given PAC script string.\n//\n// Evaulates the given PAC script string in the JavaScript context created\n// by pacparser_init.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_parse_pac_string(const char *script)\n{\n  jsval rval;\n  char *error_prefix = \"pacparser.c: pacparser_parse_pac_string:\";\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return 0;\n  }\n  if (!JS_EvaluateScript(cx,\n                         global,\n                         script,       // Script read from pacfile\n                         strlen(script),\n                         \"PAC script\",\n                         1,\n                         &rval)) {     // If script evaluation failed\n    print_error(\"%s %s\\n\", error_prefix, \"Failed to evaluate the pac script.\");\n    if (_debug()) print_error(\"DEBUG: Failed to parse the PAC script:\\n%s\\n\",\n\t\t\t\tscript);\n    return 0;\n  }\n  if (_debug()) print_error(\"DEBUG: Parsed the PAC script.\\n\");\n  return 1;\n}\n\n// Parses the given PAC file.\n//\n// reads the given PAC file and evaluates it in the JavaScript context created\n// by pacparser_init.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_parse_pac_file(const char *pacfile)\n{\n  char *script = NULL;\n\n  if ((script = read_file_into_str(pacfile)) == NULL) {\n    print_error(\"pacparser.c: pacparser_parse_pac: %s: %s: %s\\n\",\n            \"Could not read the pacfile: \", pacfile, strerror(errno));\n    return 0;\n  }\n\n  int result = pacparser_parse_pac_string(script);\n  if (script != NULL) free(script);\n\n  if (_debug()) {\n    if(result) print_error(\"DEBUG: Parsed the PAC file: %s\\n\", pacfile);\n    else print_error(\"DEBUG: Could not parse the PAC file: %s\\n\", pacfile);\n  }\n\n  return result;\n}\n\n// Parses PAC file (same as pacparser_parse_pac_file)\n//\n// (Deprecated) Use pacparser_parse_pac_file instead.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_parse_pac(const char *pacfile)\n{\n  return pacparser_parse_pac_file(pacfile);\n}\n\n// Finds proxy for the given URL and Host.\n//\n// If JavaScript engine is intialized and findProxyForURL function is defined,\n// it evaluates code findProxyForURL(url,host) in JavaScript context and\n// returns the result.\nchar *                                  // Proxy string or NULL if failed.\npacparser_find_proxy(const char *url, const char *host)\n{\n  char *error_prefix = \"pacparser.c: pacparser_find_proxy:\";\n  if (_debug()) print_error(\"DEBUG: Finding proxy for URL: %s and Host:\"\n                        \" %s\\n\", url, host);\n  jsval rval;\n  char *script;\n  if (url == NULL || (strcmp(url, \"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"URL not defined\");\n    return NULL;\n  }\n  if (host == NULL || (strcmp(host,\"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Host not defined\");\n    return NULL;\n  }\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return NULL;\n  }\n  // Test if findProxyForURL is defined.\n  script = \"typeof(findProxyForURL);\";\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval);\n  if (strcmp(\"function\", JS_GetStringBytes(JS_ValueToString(cx, rval))) != 0) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Javascript function findProxyForURL not defined.\");\n    return NULL;\n  }\n\n  // URL-encode \"'\" as we use single quotes to stick the URL into a temporary script.\n  char *sanitized_url = str_replace(url, \"'\", \"%27\");\n  // Hostname shouldn't have single quotes in them\n  if (strchr(host, '\\'')) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t\"Invalid hostname: hostname can't have single quotes.\");\n    return NULL;\n  }\n\n  script = (char*) malloc(32 + strlen(url) + strlen(host));\n  script[0] = '\\0';\n  strcat(script, \"findProxyForURL('\");\n  strcat(script, sanitized_url);\n  strcat(script, \"', '\");\n  strcat(script, host);\n  strcat(script, \"')\");\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  if (!JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Problem in executing findProxyForURL.\");\n    free(sanitized_url);\n    free(script);\n    return NULL;\n  }\n  free(sanitized_url);\n  free(script);\n  return JS_GetStringBytes(JS_ValueToString(cx, rval));\n}\n\n// Destroys JavaSctipt Engine.\nvoid\npacparser_cleanup()\n{\n  // Reinitliaze config variables.\n  myip = NULL;\n  if (cx) {\n    JS_DestroyContext(cx);\n    cx = NULL;\n  }\n  if (rt) {\n    JS_DestroyRuntime(rt);\n    rt = NULL;\n  }\n  if (!cx && !rt) JS_ShutDown();\n  global = NULL;\n  if (_debug()) print_error(\"DEBUG: Pacparser destroyed.\\n\");\n}\n\n// Finds proxy for the given PAC file, url and host.\n//\n// This function is a wrapper around functions pacparser_init,\n// pacparser_parse_pac, pacparser_find_proxy and pacparser_cleanup. If you just\n// want to find out proxy a given set of pac file, url and host, this is the\n// function to call.\nchar *                                  // Proxy string or NULL if failed.\npacparser_just_find_proxy(const char *pacfile,\n                         const char *url,\n                         const char *host)\n{\n  char *proxy;\n  char *out;\n  int initialized_here = 0;\n  char *error_prefix = \"pacparser.c: pacparser_just_find_proxy:\";\n  if (!global) {\n    if (!pacparser_init()) {\n      print_error(\"%s %s\\n\", error_prefix, \"Could not initialize pacparser\");\n      return NULL;\n    }\n    initialized_here = 1;\n  }\n  if (!pacparser_parse_pac(pacfile)) {\n    print_error(\"%s %s %s\\n\", error_prefix, \"Could not parse pacfile\",\n\t\t  pacfile);\n    if (initialized_here) pacparser_cleanup();\n    return NULL;\n  }\n  if (!(out = pacparser_find_proxy(url, host))) {\n    print_error(\"%s %s %s\\n\", error_prefix,\n\t\t  \"Could not determine proxy for url\", url);\n    if (initialized_here) pacparser_cleanup();\n    return NULL;\n  }\n  proxy = (char*) malloc(strlen(out) + 1);\n  strcpy(proxy, out);\n  if (initialized_here) pacparser_cleanup();\n  return proxy;\n}\n\n#define QUOTEME_(x) #x\n#define QUOTEME(x) QUOTEME_(x)\n\nchar* pacparser_version(void) {\n#ifndef VERSION\n  print_error(\"WARNING: VERSION not defined.\");\n  return \"\";\n#endif\n  return QUOTEME(VERSION);\n}\n"], "fixing_code": ["// Copyright (C) 2007 Manu Garg.\n// Author: Manu Garg <manugarg@gmail.com>\n//\n// pacparser is a library that provides methods to parse proxy auto-config\n// (PAC) files. Please read README file included with this package for more\n// information about this library.\n//\n// pacparser is free software; you can redistribute it and/or\n// modify it under the terms of the GNU Lesser General Public\n// License as published by the Free Software Foundation; either\n// version 3 of the License, or (at your option) any later version.\n\n// pacparser is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n// Lesser General Public License for more details.\n\n// You should have received a copy of the GNU Lesser General Public\n// License along with this library; if not, write to the Free Software\n// Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA\n\n#include <errno.h>\n#include <jsapi.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#ifdef XP_UNIX\n#include <unistd.h>\n#include <sys/socket.h>                // for AF_INET\n#include <netdb.h>\n#endif\n\n#ifdef _WIN32\n#include <winsock2.h>\n#include <ws2tcpip.h>\n#endif\n\n#include \"pac_utils.h\"\n#include \"pacparser.h\"\n\n#define MAX_IP_RESULTS 10\n\nstatic char *myip = NULL;\n\n// Default error printer function.\nstatic int\t\t// Number of characters printed, negative value in case of output error.\n_default_error_printer(const char *fmt, va_list argp)\n{\n  return vfprintf(stderr, fmt, argp);\n}\n\n// File level variable to hold error printer function pointer.\nstatic pacparser_error_printer error_printer_func = &_default_error_printer;\n\n// Set error printer to a user defined function.\nvoid\npacparser_set_error_printer(pacparser_error_printer func)\n{\n  error_printer_func = func;\n}\n\nstatic int print_error(const char *fmt, ...)\n{\n  int ret;\n  va_list args;\n  va_start(args, fmt);\n  ret = (*error_printer_func)(fmt, args);\n  va_end(args);\n  return ret;\n}\n\nstatic int\n_debug(void) {\n  if(getenv(\"PACPARSER_DEBUG\")) return 1;\n  return 0;\n}\n\n// Utility function to read a file into string.\nstatic char *                      // File content in string or NULL if failed.\nread_file_into_str(const char *filename)\n{\n  char *str;\n  int file_size;\n  FILE *fptr;\n  int records_read;\n  if (!(fptr = fopen(filename, \"r\"))) goto error1;\n  if ((fseek(fptr, 0L, SEEK_END) != 0)) goto error2;\n  if (!(file_size=ftell(fptr))) goto error2;\n  if ((fseek(fptr, 0L, SEEK_SET) != 0)) goto error2;\n  if (!(str = (char*) malloc(file_size+1))) goto error2;\n  if (!(records_read=fread(str, 1, file_size, fptr))) {\n    free(str);\n    goto error2;\n  }\n  str[records_read] = '\\0';\n  fclose(fptr);\n  return str;\nerror2:\n  fclose(fptr);\nerror1:\n  return NULL;\n}\n\nstatic void\nprint_jserror(JSContext *cx, const char *message, JSErrorReport *report)\n{\n  print_error(\"JSERROR: %s:%d:\\n    %s\\n\",\n\t      (report->filename ? report->filename : \"NULL\"), report->lineno,\n\t      message);\n}\n\n// DNS Resolve function; used by other routines.\n// This function is used by dnsResolve, dnsResolveEx, myIpAddress,\n// myIpAddressEx.\nstatic int\nresolve_host(const char *hostname, char *ipaddr_list, int max_results,\n             int req_ai_family)\n{\n  struct addrinfo hints;\n  struct addrinfo *result;\n  struct addrinfo *ai;\n  char ipaddr[INET6_ADDRSTRLEN];\n  int error;\n\n  // Truncate ipaddr_list to an empty string.\n  ipaddr_list[0] = '\\0';\n\n#ifdef _WIN32\n  // On windows, we need to initialize the winsock dll first.\n  WSADATA WsaData;\n  WSAStartup(MAKEWORD(2,0), &WsaData);\n#endif\n\n  memset(&hints, 0, sizeof(struct addrinfo));\n\n  hints.ai_family = req_ai_family;\n  hints.ai_socktype = SOCK_STREAM;\n\n  error = getaddrinfo(hostname, NULL, &hints, &result);\n  if (error) return error;\n  int i = 0;\n  for(ai = result; ai != NULL && i < max_results; ai = ai->ai_next, i++) {\n    getnameinfo(ai->ai_addr, ai->ai_addrlen, ipaddr, sizeof(ipaddr), NULL, 0,\n                NI_NUMERICHOST);\n    if (ipaddr_list[0] == '\\0') sprintf(ipaddr_list, \"%s\", ipaddr);\n    else sprintf(ipaddr_list, \"%s;%s\", ipaddr_list, ipaddr);\n  }\n  freeaddrinfo(result);\n#ifdef _WIN32\n  WSACleanup();\n#endif\n  return 0;\n}\n\n// dnsResolve in JS context; not available in core JavaScript.\n// returns javascript null if not able to resolve.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\ndns_resolve(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\n{\n  char* name = JS_GetStringBytes(JS_ValueToString(cx, argv[0]));\n  char* out;\n  char ipaddr[INET6_ADDRSTRLEN] = \"\";\n\n  // Return null on failure.\n  if(resolve_host(name, ipaddr, 1, AF_INET)) {\n    *rval = JSVAL_NULL;\n    return JS_TRUE;\n  }\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// dnsResolveEx in JS context; not available in core JavaScript.\n// returns javascript null if not able to resolve.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\ndns_resolve_ex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv,\n               jsval *rval)\n{\n  char* name = JS_GetStringBytes(JS_ValueToString(cx, argv[0]));\n  char* out;\n  char ipaddr[INET6_ADDRSTRLEN * MAX_IP_RESULTS + MAX_IP_RESULTS] = \"\";\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  // Return \"\" on failure.\n  if(resolve_host(name, ipaddr, MAX_IP_RESULTS, AF_UNSPEC)) {\n    strcpy(out, \"\");\n  }\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// myIpAddress in JS context; not available in core JavaScript.\n// returns 127.0.0.1 if not able to determine local ip.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\nmy_ip(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\n{\n  char ipaddr[INET6_ADDRSTRLEN];\n  char* out;\n\n  if (myip)                  // If my (client's) IP address is already set.\n    strcpy(ipaddr, myip);\n  else {\n    char name[256];\n    gethostname(name, sizeof(name));\n    if (resolve_host(name, ipaddr, 1, AF_INET)) {\n      strcpy(ipaddr, \"127.0.0.1\");\n    }\n  }\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// myIpAddressEx in JS context; not available in core JavaScript.\n// returns 127.0.0.1 if not able to determine local ip.\nstatic JSBool                                  // JS_TRUE or JS_FALSE\nmy_ip_ex(JSContext *cx, JSObject *obj, uintN argc, jsval *argv, jsval *rval)\n{\n  char ipaddr[INET6_ADDRSTRLEN * MAX_IP_RESULTS + MAX_IP_RESULTS];\n  char* out;\n\n  if (myip)                  // If my (client's) IP address is already set.\n    strcpy(ipaddr, myip);\n  else {\n    char name[256];\n    gethostname(name, sizeof(name));\n    if (resolve_host(name, ipaddr, MAX_IP_RESULTS, AF_UNSPEC)) {\n      strcpy(ipaddr, \"\");\n    }\n  }\n\n  out = JS_malloc(cx, strlen(ipaddr) + 1);\n  strcpy(out, ipaddr);\n  JSString *str = JS_NewString(cx, out, strlen(out));\n  *rval = STRING_TO_JSVAL(str);\n  return JS_TRUE;\n}\n\n// Define some JS context related variables.\nstatic JSRuntime *rt = NULL;\nstatic JSContext *cx = NULL;\nstatic JSObject *global = NULL;\nstatic JSClass global_class = {\n    \"global\",0,\n    JS_PropertyStub,JS_PropertyStub,JS_PropertyStub,JS_PropertyStub,\n    JS_EnumerateStub,JS_ResolveStub,JS_ConvertStub,JS_FinalizeStub\n};\n\n// Set my (client's) IP address to a custom value.\nint\npacparser_setmyip(const char *ip)\n{\n  if (strlen(ip) > INET6_ADDRSTRLEN) {\n    fprintf(stderr, \"pacparser_setmyip: IP too long: %s\\n\", ip);\n    return 0;\n  }\n\n  myip = malloc(strlen(ip) +1);         // Allocate space just to be sure.\n  strcpy(myip, ip);\n  return 1;\n}\n\n// Decprecated: This function doesn't do anything.\n//\n// This function doesn't do anything. Microsoft exntensions are now enabled by\n// default.\nvoid\npacparser_enable_microsoft_extensions()\n{\n  return;\n}\n\n// Initialize PAC parser.\n//\n// - Initializes JavaScript engine,\n// - Exports dns_functions (defined above) to JavaScript context.\n// - Sets error reporting function to print_jserror,\n// - Evaluates JavaScript code in pacUtils variable defined in pac_utils.h.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_init()\n{\n  jsval rval;\n  char *error_prefix = \"pacparser.c: pacparser_init:\";\n  // Initialize JS engine\n  if (!(rt = JS_NewRuntime(8L * 1024L * 1024L)) ||\n      !(cx = JS_NewContext(rt, 8192)) ||\n      !(global = JS_NewObject(cx, &global_class, NULL, NULL)) ||\n      !JS_InitStandardClasses(cx, global)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Could not initialize  JavaScript \"\n\t\t  \"runtime.\");\n    return 0;\n  }\n  JS_SetErrorReporter(cx, print_jserror);\n  // Export our functions to Javascript engine\n  if (!JS_DefineFunction(cx, global, \"dnsResolve\", dns_resolve, 1, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not define dnsResolve in JS context.\");\n    return 0;\n  }\n  if (!JS_DefineFunction(cx, global, \"myIpAddress\", my_ip, 0, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not define myIpAddress in JS context.\");\n    return 0;\n  }\n  if (!JS_DefineFunction(cx, global, \"dnsResolveEx\", dns_resolve_ex, 1, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n      \"Could not define dnsResolveEx in JS context.\");\n    return 0;\n  }\n  if (!JS_DefineFunction(cx, global, \"myIpAddressEx\", my_ip_ex, 0, 0)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not define myIpAddressEx in JS context.\");\n    return 0;\n  }\n  // Evaluate pacUtils. Utility functions required to parse pac files.\n  if (!JS_EvaluateScript(cx,           // JS engine context\n                         global,       // global object\n                         pacUtils,     // this is defined in pac_utils.h\n                         strlen(pacUtils),\n                         NULL,         // filename (NULL in this case)\n                         1,            // line number, used for reporting.\n                         &rval)) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Could not evaluate pacUtils defined in pac_utils.h.\");\n    return 0;\n  }\n  if (_debug()) print_error(\"DEBUG: Pacparser Initalized.\\n\");\n  return 1;\n}\n\n// Parses the given PAC script string.\n//\n// Evaulates the given PAC script string in the JavaScript context created\n// by pacparser_init.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_parse_pac_string(const char *script)\n{\n  jsval rval;\n  char *error_prefix = \"pacparser.c: pacparser_parse_pac_string:\";\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return 0;\n  }\n  if (!JS_EvaluateScript(cx,\n                         global,\n                         script,       // Script read from pacfile\n                         strlen(script),\n                         \"PAC script\",\n                         1,\n                         &rval)) {     // If script evaluation failed\n    print_error(\"%s %s\\n\", error_prefix, \"Failed to evaluate the pac script.\");\n    if (_debug()) print_error(\"DEBUG: Failed to parse the PAC script:\\n%s\\n\",\n\t\t\t\tscript);\n    return 0;\n  }\n  if (_debug()) print_error(\"DEBUG: Parsed the PAC script.\\n\");\n  return 1;\n}\n\n// Parses the given PAC file.\n//\n// reads the given PAC file and evaluates it in the JavaScript context created\n// by pacparser_init.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_parse_pac_file(const char *pacfile)\n{\n  char *script = NULL;\n\n  if ((script = read_file_into_str(pacfile)) == NULL) {\n    print_error(\"pacparser.c: pacparser_parse_pac: %s: %s: %s\\n\",\n            \"Could not read the pacfile: \", pacfile, strerror(errno));\n    return 0;\n  }\n\n  int result = pacparser_parse_pac_string(script);\n  if (script != NULL) free(script);\n\n  if (_debug()) {\n    if(result) print_error(\"DEBUG: Parsed the PAC file: %s\\n\", pacfile);\n    else print_error(\"DEBUG: Could not parse the PAC file: %s\\n\", pacfile);\n  }\n\n  return result;\n}\n\n// Parses PAC file (same as pacparser_parse_pac_file)\n//\n// (Deprecated) Use pacparser_parse_pac_file instead.\nint                                     // 0 (=Failure) or 1 (=Success)\npacparser_parse_pac(const char *pacfile)\n{\n  return pacparser_parse_pac_file(pacfile);\n}\n\n// Finds proxy for the given URL and Host.\n//\n// If JavaScript engine is intialized and findProxyForURL function is defined,\n// it evaluates code findProxyForURL(url,host) in JavaScript context and\n// returns the result.\nchar *                                  // Proxy string or NULL if failed.\npacparser_find_proxy(const char *url, const char *host)\n{\n  char *error_prefix = \"pacparser.c: pacparser_find_proxy:\";\n  if (_debug()) print_error(\"DEBUG: Finding proxy for URL: %s and Host:\"\n                        \" %s\\n\", url, host);\n  jsval rval;\n  char *script;\n  if (url == NULL || (strcmp(url, \"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"URL not defined\");\n    return NULL;\n  }\n  if (host == NULL || (strcmp(host,\"\") == 0)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Host not defined\");\n    return NULL;\n  }\n  if (cx == NULL || global == NULL) {\n    print_error(\"%s %s\\n\", error_prefix, \"Pac parser is not initialized.\");\n    return NULL;\n  }\n  // Test if findProxyForURL is defined.\n  script = \"typeof(findProxyForURL);\";\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval);\n  if (strcmp(\"function\", JS_GetStringBytes(JS_ValueToString(cx, rval))) != 0) {\n    print_error(\"%s %s\\n\", error_prefix,\n\t\t  \"Javascript function findProxyForURL not defined.\");\n    return NULL;\n  }\n\n  // URL-encode \"'\" as we use single quotes to stick the URL into a temporary script.\n  char *sanitized_url = str_replace(url, \"'\", \"%27\");\n  // Hostname shouldn't have single quotes in them\n  if (strchr(host, '\\'')) {\n    print_error(\"%s %s\\n\", error_prefix,\n      \"Invalid hostname: hostname can't have single quotes.\");\n    return NULL;\n  }\n\n  script = (char*) malloc(32 + strlen(sanitized_url) + strlen(host));\n  script[0] = '\\0';\n  strcat(script, \"findProxyForURL('\");\n  strcat(script, sanitized_url);\n  strcat(script, \"', '\");\n  strcat(script, host);\n  strcat(script, \"')\");\n  if (_debug()) print_error(\"DEBUG: Executing JavaScript: %s\\n\", script);\n  if (!JS_EvaluateScript(cx, global, script, strlen(script), NULL, 1, &rval)) {\n    print_error(\"%s %s\\n\", error_prefix, \"Problem in executing findProxyForURL.\");\n    free(sanitized_url);\n    free(script);\n    return NULL;\n  }\n  free(sanitized_url);\n  free(script);\n  return JS_GetStringBytes(JS_ValueToString(cx, rval));\n}\n\n// Destroys JavaSctipt Engine.\nvoid\npacparser_cleanup()\n{\n  // Reinitliaze config variables.\n  myip = NULL;\n  if (cx) {\n    JS_DestroyContext(cx);\n    cx = NULL;\n  }\n  if (rt) {\n    JS_DestroyRuntime(rt);\n    rt = NULL;\n  }\n  if (!cx && !rt) JS_ShutDown();\n  global = NULL;\n  if (_debug()) print_error(\"DEBUG: Pacparser destroyed.\\n\");\n}\n\n// Finds proxy for the given PAC file, url and host.\n//\n// This function is a wrapper around functions pacparser_init,\n// pacparser_parse_pac, pacparser_find_proxy and pacparser_cleanup. If you just\n// want to find out proxy a given set of pac file, url and host, this is the\n// function to call.\nchar *                                  // Proxy string or NULL if failed.\npacparser_just_find_proxy(const char *pacfile,\n                         const char *url,\n                         const char *host)\n{\n  char *proxy;\n  char *out;\n  int initialized_here = 0;\n  char *error_prefix = \"pacparser.c: pacparser_just_find_proxy:\";\n  if (!global) {\n    if (!pacparser_init()) {\n      print_error(\"%s %s\\n\", error_prefix, \"Could not initialize pacparser\");\n      return NULL;\n    }\n    initialized_here = 1;\n  }\n  if (!pacparser_parse_pac(pacfile)) {\n    print_error(\"%s %s %s\\n\", error_prefix, \"Could not parse pacfile\",\n\t\t  pacfile);\n    if (initialized_here) pacparser_cleanup();\n    return NULL;\n  }\n  if (!(out = pacparser_find_proxy(url, host))) {\n    print_error(\"%s %s %s\\n\", error_prefix,\n\t\t  \"Could not determine proxy for url\", url);\n    if (initialized_here) pacparser_cleanup();\n    return NULL;\n  }\n  proxy = (char*) malloc(strlen(out) + 1);\n  strcpy(proxy, out);\n  if (initialized_here) pacparser_cleanup();\n  return proxy;\n}\n\n#define QUOTEME_(x) #x\n#define QUOTEME(x) QUOTEME_(x)\n\nchar* pacparser_version(void) {\n#ifndef VERSION\n  print_error(\"WARNING: VERSION not defined.\");\n  return \"\";\n#endif\n  return QUOTEME(VERSION);\n}\n"], "filenames": ["src/pacparser.c"], "buggy_code_start_loc": [445], "buggy_code_end_loc": [450], "fixing_code_start_loc": [445], "fixing_code_end_loc": [450], "type": "CWE-120", "message": "A vulnerability classified as problematic was found in pacparser up to 1.3.x. Affected by this vulnerability is the function pacparser_find_proxy of the file src/pacparser.c. The manipulation of the argument url leads to buffer overflow. Attacking locally is a requirement. Upgrading to version 1.4.0 is able to address this issue. The name of the patch is 853e8f45607cb07b877ffd270c63dbcdd5201ad9. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-215443.", "other": {"cve": {"id": "CVE-2019-25078", "sourceIdentifier": "cna@vuldb.com", "published": "2022-12-13T18:15:10.157", "lastModified": "2022-12-19T16:25:15.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability classified as problematic was found in pacparser up to 1.3.x. Affected by this vulnerability is the function pacparser_find_proxy of the file src/pacparser.c. The manipulation of the argument url leads to buffer overflow. Attacking locally is a requirement. Upgrading to version 1.4.0 is able to address this issue. The name of the patch is 853e8f45607cb07b877ffd270c63dbcdd5201ad9. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-215443."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-119"}, {"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:pacparser_project:pacparser:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.4.0", "matchCriteriaId": "68CF258C-6303-4570-9D18-E674D93FA800"}]}]}], "references": [{"url": "https://github.com/manugarg/pacparser/commit/853e8f45607cb07b877ffd270c63dbcdd5201ad9", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/manugarg/pacparser/issues/99", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/manugarg/pacparser/releases/tag/v1.4.0", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.215443", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/manugarg/pacparser/commit/853e8f45607cb07b877ffd270c63dbcdd5201ad9"}}