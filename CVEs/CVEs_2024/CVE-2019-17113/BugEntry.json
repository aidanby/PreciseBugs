{"buggy_code": ["/*\n * libopenmpt_modplug.c\n * --------------------\n * Purpose: libopenmpt emulation of the libmodplug interface\n * Notes  : (currently none)\n * Authors: OpenMPT Devs\n * The OpenMPT source code is released under the BSD license. Read LICENSE for more details.\n */\n\n#ifndef NO_LIBMODPLUG\n\n#ifdef LIBOPENMPT_BUILD_DLL\n#undef LIBOPENMPT_BUILD_DLL\n#endif\n\n#ifdef _MSC_VER\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#endif /* _MSC_VER */\n\n#include \"libopenmpt.h\"\n\n#include <limits.h>\n#include <math.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MODPLUG_BUILD\n#ifdef _MSC_VER\n#ifdef MPT_BUILD_MSVC_SHARED\n#define DLL_EXPORT\n#endif /* MPT_BUILD_MSVC_SHARED */\n#ifdef MPT_BUILD_MSVC_STATIC\n#define MODPLUG_STATIC\n#endif /* MPT_BUILD_MSVC_STATIC */\n#endif /* _MSC_VER */\n#ifdef _MSC_VER\n#define LIBOPENMPT_MODPLUG_API\n#else /* !_MSC_VER */\n#define LIBOPENMPT_MODPLUG_API LIBOPENMPT_API_HELPER_EXPORT\n#endif /* _MSC_VER */\n#include \"libmodplug/modplug.h\"\n\n/* from libmodplug/sndfile.h */\n/* header is not c clean */\n#define MIXING_ATTENUATION 4\n#define MOD_TYPE_NONE\t\t0x0\n#define MOD_TYPE_MOD\t\t0x1\n#define MOD_TYPE_S3M\t\t0x2\n#define MOD_TYPE_XM\t\t0x4\n#define MOD_TYPE_MED\t\t0x8\n#define MOD_TYPE_MTM\t\t0x10\n#define MOD_TYPE_IT\t\t0x20\n#define MOD_TYPE_669\t\t0x40\n#define MOD_TYPE_ULT\t\t0x80\n#define MOD_TYPE_STM\t\t0x100\n#define MOD_TYPE_FAR\t\t0x200\n#define MOD_TYPE_WAV\t\t0x400\n#define MOD_TYPE_AMF\t\t0x800\n#define MOD_TYPE_AMS\t\t0x1000\n#define MOD_TYPE_DSM\t\t0x2000\n#define MOD_TYPE_MDL\t\t0x4000\n#define MOD_TYPE_OKT\t\t0x8000\n#define MOD_TYPE_MID\t\t0x10000\n#define MOD_TYPE_DMF\t\t0x20000\n#define MOD_TYPE_PTM\t\t0x40000\n#define MOD_TYPE_DBM\t\t0x80000\n#define MOD_TYPE_MT2\t\t0x100000\n#define MOD_TYPE_AMF0\t\t0x200000\n#define MOD_TYPE_PSM\t\t0x400000\n#define MOD_TYPE_J2B\t\t0x800000\n#define MOD_TYPE_ABC\t\t0x1000000\n#define MOD_TYPE_PAT\t\t0x2000000\n#define MOD_TYPE_UMX\t\t0x80000000 // Fake type\n\n#define BUFFER_COUNT 1024\n\nstruct _ModPlugFile {\n\topenmpt_module* mod;\n\tsigned short* buf;\n\tsigned int* mixerbuf;\n\tchar* name;\n\tchar* message;\n\tModPlug_Settings settings;\n\tModPlugMixerProc mixerproc;\n\tModPlugNote** patterns;\n};\n\nstatic ModPlug_Settings globalsettings = {\n\tMODPLUG_ENABLE_OVERSAMPLING|MODPLUG_ENABLE_NOISE_REDUCTION,\n\t2,\n\t16,\n\t44100,\n\tMODPLUG_RESAMPLE_LINEAR,\n\t128,\n\t256,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0\n};\n\nstatic int32_t modplugresamplingmode_to_filterlength(int mode)\n{\n\tif(mode<0){\n\t\treturn 1;\n\t}\n\tswitch(mode){\n\tcase MODPLUG_RESAMPLE_NEAREST: return 1; break;\n\tcase MODPLUG_RESAMPLE_LINEAR: return 2; break;\n\tcase MODPLUG_RESAMPLE_SPLINE: return 4; break;\n\tcase MODPLUG_RESAMPLE_FIR: return 8; break;\n\t}\n\treturn 8;\n}\n\nLIBOPENMPT_MODPLUG_API ModPlugFile* ModPlug_Load(const void* data, int size)\n{\n\tModPlugFile* file = malloc(sizeof(ModPlugFile));\n\tconst char* name = NULL;\n\tconst char* message = NULL;\n\tif(!file) return NULL;\n\tmemset(file,0,sizeof(ModPlugFile));\n\tmemcpy(&file->settings,&globalsettings,sizeof(ModPlug_Settings));\n\tfile->mod = openmpt_module_create_from_memory2(data,size,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\n\tif(!file->mod){\n\t\tfree(file);\n\t\treturn NULL;\n\t}\n\tfile->buf = malloc(BUFFER_COUNT*sizeof(signed short)*4);\n\tif(!file->buf){\n\t\topenmpt_module_destroy(file->mod);\n\t\tfree(file);\n\t\treturn NULL;\n\t}\n\topenmpt_module_set_repeat_count(file->mod,file->settings.mLoopCount);\n\tname = openmpt_module_get_metadata(file->mod,\"title\");\n\tif(name){\n\t\tfile->name = malloc(strlen(name)+1);\n\t\tif(file->name){\n\t\t\tstrcpy(file->name,name);\n\t\t}\n\t\topenmpt_free_string(name);\n\t\tname = NULL;\n\t}else{\n\t\tfile->name = malloc(strlen(\"\")+1);\n\t\tif(file->name){\n\t\t\tstrcpy(file->name,\"\");\n\t\t}\n\t}\n\tmessage = openmpt_module_get_metadata(file->mod,\"message\");\n\tif(message){\n\t\tfile->message = malloc(strlen(message)+1);\n\t\tif(file->message){\n\t\t\tstrcpy(file->message,message);\n\t\t}\n\t\topenmpt_free_string(message);\n\t\tmessage = NULL;\n\t}else{\n\t\tfile->message = malloc(strlen(\"\")+1);\n\t\tif(file->message){\n\t\t\tstrcpy(file->message,\"\");\n\t\t}\n\t}\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_STEREOSEPARATION_PERCENT,file->settings.mStereoSeparation*100/128);\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_INTERPOLATIONFILTER_LENGTH,modplugresamplingmode_to_filterlength(file->settings.mResamplingMode));\n\treturn file;\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_Unload(ModPlugFile* file)\n{\n\tint p;\n\tif(!file) return;\n\tif(file->patterns){\n\t\tfor(p=0;p<openmpt_module_get_num_patterns(file->mod);p++){\n\t\t\tif(file->patterns[p]){\n\t\t\t\tfree(file->patterns[p]);\n\t\t\t\tfile->patterns[p] = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(file->patterns);\n\t\tfile->patterns = NULL;\n\t}\n\tif(file->mixerbuf){\n\t\tfree(file->mixerbuf);\n\t\tfile->mixerbuf = NULL;\n\t}\n\topenmpt_module_destroy(file->mod);\n\tfile->mod = NULL;\n\tfree(file->name);\n\tfile->name = NULL;\n\tfree(file->message);\n\tfile->message = NULL;\n\tfree(file->buf);\n\tfile->buf = NULL;\n\tfree(file);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_Read(ModPlugFile* file, void* buffer, int size)\n{\n\tint framesize;\n\tint framecount;\n\tint frames;\n\tint rendered;\n\tint frame;\n\tint channel;\n\tint totalrendered;\n\tsigned short* in;\n\tsigned int* mixbuf;\n\tunsigned char* buf8;\n\tsigned short* buf16;\n\tsigned int* buf32;\n\tif(!file) return 0;\n\tframesize = file->settings.mBits/8*file->settings.mChannels;\n\tframecount = size/framesize;\n\tbuf8 = buffer;\n\tbuf16 = buffer;\n\tbuf32 = buffer;\n\ttotalrendered = 0;\n\twhile(framecount>0){\n\t\tframes = framecount;\n\t\tif(frames>BUFFER_COUNT){\n\t\t\tframes = BUFFER_COUNT;\n\t\t}\n\t\tif(file->settings.mChannels==1){\n\t\t\trendered = (int)openmpt_module_read_mono(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0]);\n\t\t}else if(file->settings.mChannels==2){\n\t\t\trendered = (int)openmpt_module_read_stereo(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0],&file->buf[frames*1]);\n\t\t}else if(file->settings.mChannels==4){\n\t\t\trendered = (int)openmpt_module_read_quad(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0],&file->buf[frames*1],&file->buf[frames*2],&file->buf[frames*3]);\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t\tin = file->buf;\n\t\tif(file->mixerproc&&file->mixerbuf){\n\t\t\tmixbuf=file->mixerbuf;\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*mixbuf = in[frames*channel+frame]<<(32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tmixbuf++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfile->mixerproc(file->mixerbuf,file->settings.mChannels*frames,file->settings.mChannels);\n\t\t\tmixbuf=file->mixerbuf;\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\tin[frames*channel+frame] = *mixbuf>>(32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tmixbuf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(file->settings.mBits==8){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf8 = in[frames*channel+frame]/256+0x80;\n\t\t\t\t\tbuf8++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(file->settings.mBits==16){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf16 = in[frames*channel+frame];\n\t\t\t\t\tbuf16++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(file->settings.mBits==32){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf32 = in[frames*channel+frame] << (32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tbuf32++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t\ttotalrendered += rendered;\n\t\tframecount -= frames;\n\t\tif(!rendered) break;\n\t}\n\tmemset(((char*)buffer)+totalrendered*framesize,0,size-totalrendered*framesize);\n\treturn totalrendered*framesize;\n}\n\nLIBOPENMPT_MODPLUG_API const char* ModPlug_GetName(ModPlugFile* file)\n{\n\tif(!file) return NULL;\n\treturn file->name;\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetLength(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn (int)(openmpt_module_get_duration_seconds(file->mod)*1000.0);\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_Seek(ModPlugFile* file, int millisecond)\n{\n\tif(!file) return;\n\topenmpt_module_set_position_seconds(file->mod,(double)millisecond*0.001);\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_GetSettings(ModPlug_Settings* settings)\n{\n\tif(!settings) return;\n\tmemcpy(settings,&globalsettings,sizeof(ModPlug_Settings));\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_SetSettings(const ModPlug_Settings* settings)\n{\n\tif(!settings) return;\n\tmemcpy(&globalsettings,settings,sizeof(ModPlug_Settings));\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_GetMasterVolume(ModPlugFile* file)\n{\n\tint32_t val;\n\tif(!file) return 0;\n\tval = 0;\n\tif(!openmpt_module_get_render_param(file->mod,OPENMPT_MODULE_RENDER_MASTERGAIN_MILLIBEL,&val)) return 128;\n\treturn (unsigned int)(128.0*pow(10.0,val*0.0005));\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_SetMasterVolume(ModPlugFile* file,unsigned int cvol)\n{\n\tif(!file) return;\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_MASTERGAIN_MILLIBEL,(int32_t)(2000.0*log10(cvol/128.0)));\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentSpeed(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_speed(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentTempo(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_tempo(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentOrder(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_order(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentPattern(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_pattern(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentRow(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_row(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetPlayingChannels(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_playing_channels(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_SeekOrder(ModPlugFile* file,int order)\n{\n\tif(!file) return;\n\topenmpt_module_set_position_order_row(file->mod,order,0);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetModuleType(ModPlugFile* file)\n{\n\tconst char* type;\n\tint retval;\n\tif(!file) return 0;\n\ttype = openmpt_module_get_metadata(file->mod,\"type\");\n\tretval = MOD_TYPE_NONE;\n\tif(!type){\n\t\treturn retval;\n\t}\n\tif(!strcmp(type,\"mod\")){\n\t\tretval = MOD_TYPE_MOD;\n\t}else if(!strcmp(type,\"s3m\")){\n\t\tretval = MOD_TYPE_S3M;\n\t}else if(!strcmp(type,\"xm\")){\n\t\tretval = MOD_TYPE_XM;\n\t}else if(!strcmp(type,\"med\")){\n\t\tretval = MOD_TYPE_MED;\n\t}else if(!strcmp(type,\"mtm\")){\n\t\tretval = MOD_TYPE_MTM;\n\t}else if(!strcmp(type,\"it\")){\n\t\tretval = MOD_TYPE_IT;\n\t}else if(!strcmp(type,\"669\")){\n\t\tretval = MOD_TYPE_669;\n\t}else if(!strcmp(type,\"ult\")){\n\t\tretval = MOD_TYPE_ULT;\n\t}else if(!strcmp(type,\"stm\")){\n\t\tretval = MOD_TYPE_STM;\n\t}else if(!strcmp(type,\"far\")){\n\t\tretval = MOD_TYPE_FAR;\n\t}else if(!strcmp(type,\"s3m\")){\n\t\tretval = MOD_TYPE_WAV;\n\t}else if(!strcmp(type,\"amf\")){\n\t\tretval = MOD_TYPE_AMF;\n\t}else if(!strcmp(type,\"ams\")){\n\t\tretval = MOD_TYPE_AMS;\n\t}else if(!strcmp(type,\"dsm\")){\n\t\tretval = MOD_TYPE_DSM;\n\t}else if(!strcmp(type,\"mdl\")){\n\t\tretval = MOD_TYPE_MDL;\n\t}else if(!strcmp(type,\"okt\")){\n\t\tretval = MOD_TYPE_OKT;\n\t}else if(!strcmp(type,\"mid\")){\n\t\tretval = MOD_TYPE_MID;\n\t}else if(!strcmp(type,\"dmf\")){\n\t\tretval = MOD_TYPE_DMF;\n\t}else if(!strcmp(type,\"ptm\")){\n\t\tretval = MOD_TYPE_PTM;\n\t}else if(!strcmp(type,\"dbm\")){\n\t\tretval = MOD_TYPE_DBM;\n\t}else if(!strcmp(type,\"mt2\")){\n\t\tretval = MOD_TYPE_MT2;\n\t}else if(!strcmp(type,\"amf0\")){\n\t\tretval = MOD_TYPE_AMF0;\n\t}else if(!strcmp(type,\"psm\")){\n\t\tretval = MOD_TYPE_PSM;\n\t}else if(!strcmp(type,\"j2b\")){\n\t\tretval = MOD_TYPE_J2B;\n\t}else if(!strcmp(type,\"abc\")){\n\t\tretval = MOD_TYPE_ABC;\n\t}else if(!strcmp(type,\"pat\")){\n\t\tretval = MOD_TYPE_PAT;\n\t}else if(!strcmp(type,\"umx\")){\n\t\tretval = MOD_TYPE_UMX;\n\t}else{\n\t\tretval = MOD_TYPE_IT; /* fallback, most complex type */\n\t}\n\topenmpt_free_string(type);\n\treturn retval;\n}\n\nLIBOPENMPT_MODPLUG_API char* ModPlug_GetMessage(ModPlugFile* file)\n{\n\tif(!file) return NULL;\n\treturn file->message;\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumInstruments(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_instruments(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumSamples(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_samples(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumPatterns(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_patterns(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_channels(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tunsigned int retval;\n\tsize_t tmpretval;\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tif(!str){\n\t\tif(buff){\n\t\t\t*buff = '\\0';\n\t\t}\n\t\treturn 0;\n\t}\n\ttmpretval = strlen(str);\n\tif(tmpretval>=INT_MAX){\n\t\ttmpretval = INT_MAX-1;\n\t}\n\tretval = (int)tmpretval;\n\tif(buff){\n\t\tmemcpy(buff,str,retval+1);\n\t\tbuff[retval] = '\\0';\n\t}\n\topenmpt_free_string(str);\n\treturn retval;\n}\n\nLIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)\n{\n\tint c;\n\tint r;\n\tint numr;\n\tint numc;\n\tModPlugNote note;\n\tif(!file) return NULL;\n\tif(numrows){\n\t\t*numrows = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\t}\n\tif(pattern<0||pattern>=openmpt_module_get_num_patterns(file->mod)){\n\t\treturn NULL;\n\t}\n\tif(!file->patterns){\n\t\tfile->patterns = malloc(sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t\tif(!file->patterns) return NULL;\n\t\tmemset(file->patterns,0,sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t}\n\tif(!file->patterns[pattern]){\n\t\tfile->patterns[pattern] = malloc(sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t\tif(!file->patterns[pattern]) return NULL;\n\t\tmemset(file->patterns[pattern],0,sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t}\n\tnumr = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\tnumc = openmpt_module_get_num_channels(file->mod);\n\tfor(r=0;r<numr;r++){\n\t\tfor(c=0;c<numc;c++){\n\t\t\tmemset(&note,0,sizeof(ModPlugNote));\n\t\t\tnote.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);\n\t\t\tnote.Instrument = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_INSTRUMENT);\n\t\t\tnote.VolumeEffect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUMEEFFECT);\n\t\t\tnote.Effect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_EFFECT);\n\t\t\tnote.Volume = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUME);\n\t\t\tnote.Parameter = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_PARAMETER);\n\t\t\tmemcpy(&file->patterns[pattern][r*numc+c],&note,sizeof(ModPlugNote));\n\t\t}\n\t}\n\treturn file->patterns[pattern];\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_InitMixerCallback(ModPlugFile* file,ModPlugMixerProc proc)\n{\n\tif(!file) return;\n\tif(!file->mixerbuf){\n\t\tfile->mixerbuf = malloc(BUFFER_COUNT*sizeof(signed int)*4);\n\t}\n\tfile->mixerproc = proc;\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)\n{\n\tif(!file) return;\n\tfile->mixerproc = NULL;\n\tif(file->mixerbuf){\n\t\tfree(file->mixerbuf);\n\t\tfile->mixerbuf = NULL;\n\t}\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportS3M(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportS3M(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportXM(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportXM(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportMOD(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportMOD(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportIT(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportIT(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\n#endif /* NO_LIBMODPLUG */\n"], "fixing_code": ["/*\n * libopenmpt_modplug.c\n * --------------------\n * Purpose: libopenmpt emulation of the libmodplug interface\n * Notes  : (currently none)\n * Authors: OpenMPT Devs\n * The OpenMPT source code is released under the BSD license. Read LICENSE for more details.\n */\n\n#ifndef NO_LIBMODPLUG\n\n#ifdef LIBOPENMPT_BUILD_DLL\n#undef LIBOPENMPT_BUILD_DLL\n#endif\n\n#ifdef _MSC_VER\n#ifndef _CRT_SECURE_NO_WARNINGS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n#endif /* _MSC_VER */\n\n#include \"libopenmpt.h\"\n\n#include <limits.h>\n#include <math.h>\n#include <memory.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MODPLUG_BUILD\n#ifdef _MSC_VER\n#ifdef MPT_BUILD_MSVC_SHARED\n#define DLL_EXPORT\n#endif /* MPT_BUILD_MSVC_SHARED */\n#ifdef MPT_BUILD_MSVC_STATIC\n#define MODPLUG_STATIC\n#endif /* MPT_BUILD_MSVC_STATIC */\n#endif /* _MSC_VER */\n#ifdef _MSC_VER\n#define LIBOPENMPT_MODPLUG_API\n#else /* !_MSC_VER */\n#define LIBOPENMPT_MODPLUG_API LIBOPENMPT_API_HELPER_EXPORT\n#endif /* _MSC_VER */\n#include \"libmodplug/modplug.h\"\n\n/* from libmodplug/sndfile.h */\n/* header is not c clean */\n#define MIXING_ATTENUATION 4\n#define MOD_TYPE_NONE\t\t0x0\n#define MOD_TYPE_MOD\t\t0x1\n#define MOD_TYPE_S3M\t\t0x2\n#define MOD_TYPE_XM\t\t0x4\n#define MOD_TYPE_MED\t\t0x8\n#define MOD_TYPE_MTM\t\t0x10\n#define MOD_TYPE_IT\t\t0x20\n#define MOD_TYPE_669\t\t0x40\n#define MOD_TYPE_ULT\t\t0x80\n#define MOD_TYPE_STM\t\t0x100\n#define MOD_TYPE_FAR\t\t0x200\n#define MOD_TYPE_WAV\t\t0x400\n#define MOD_TYPE_AMF\t\t0x800\n#define MOD_TYPE_AMS\t\t0x1000\n#define MOD_TYPE_DSM\t\t0x2000\n#define MOD_TYPE_MDL\t\t0x4000\n#define MOD_TYPE_OKT\t\t0x8000\n#define MOD_TYPE_MID\t\t0x10000\n#define MOD_TYPE_DMF\t\t0x20000\n#define MOD_TYPE_PTM\t\t0x40000\n#define MOD_TYPE_DBM\t\t0x80000\n#define MOD_TYPE_MT2\t\t0x100000\n#define MOD_TYPE_AMF0\t\t0x200000\n#define MOD_TYPE_PSM\t\t0x400000\n#define MOD_TYPE_J2B\t\t0x800000\n#define MOD_TYPE_ABC\t\t0x1000000\n#define MOD_TYPE_PAT\t\t0x2000000\n#define MOD_TYPE_UMX\t\t0x80000000 // Fake type\n\n#define BUFFER_COUNT 1024\n\nstruct _ModPlugFile {\n\topenmpt_module* mod;\n\tsigned short* buf;\n\tsigned int* mixerbuf;\n\tchar* name;\n\tchar* message;\n\tModPlug_Settings settings;\n\tModPlugMixerProc mixerproc;\n\tModPlugNote** patterns;\n};\n\nstatic ModPlug_Settings globalsettings = {\n\tMODPLUG_ENABLE_OVERSAMPLING|MODPLUG_ENABLE_NOISE_REDUCTION,\n\t2,\n\t16,\n\t44100,\n\tMODPLUG_RESAMPLE_LINEAR,\n\t128,\n\t256,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0,\n\t0\n};\n\nstatic int32_t modplugresamplingmode_to_filterlength(int mode)\n{\n\tif(mode<0){\n\t\treturn 1;\n\t}\n\tswitch(mode){\n\tcase MODPLUG_RESAMPLE_NEAREST: return 1; break;\n\tcase MODPLUG_RESAMPLE_LINEAR: return 2; break;\n\tcase MODPLUG_RESAMPLE_SPLINE: return 4; break;\n\tcase MODPLUG_RESAMPLE_FIR: return 8; break;\n\t}\n\treturn 8;\n}\n\nLIBOPENMPT_MODPLUG_API ModPlugFile* ModPlug_Load(const void* data, int size)\n{\n\tModPlugFile* file = malloc(sizeof(ModPlugFile));\n\tconst char* name = NULL;\n\tconst char* message = NULL;\n\tif(!file) return NULL;\n\tmemset(file,0,sizeof(ModPlugFile));\n\tmemcpy(&file->settings,&globalsettings,sizeof(ModPlug_Settings));\n\tfile->mod = openmpt_module_create_from_memory2(data,size,NULL,NULL,NULL,NULL,NULL,NULL,NULL);\n\tif(!file->mod){\n\t\tfree(file);\n\t\treturn NULL;\n\t}\n\tfile->buf = malloc(BUFFER_COUNT*sizeof(signed short)*4);\n\tif(!file->buf){\n\t\topenmpt_module_destroy(file->mod);\n\t\tfree(file);\n\t\treturn NULL;\n\t}\n\topenmpt_module_set_repeat_count(file->mod,file->settings.mLoopCount);\n\tname = openmpt_module_get_metadata(file->mod,\"title\");\n\tif(name){\n\t\tfile->name = malloc(strlen(name)+1);\n\t\tif(file->name){\n\t\t\tstrcpy(file->name,name);\n\t\t}\n\t\topenmpt_free_string(name);\n\t\tname = NULL;\n\t}else{\n\t\tfile->name = malloc(strlen(\"\")+1);\n\t\tif(file->name){\n\t\t\tstrcpy(file->name,\"\");\n\t\t}\n\t}\n\tmessage = openmpt_module_get_metadata(file->mod,\"message\");\n\tif(message){\n\t\tfile->message = malloc(strlen(message)+1);\n\t\tif(file->message){\n\t\t\tstrcpy(file->message,message);\n\t\t}\n\t\topenmpt_free_string(message);\n\t\tmessage = NULL;\n\t}else{\n\t\tfile->message = malloc(strlen(\"\")+1);\n\t\tif(file->message){\n\t\t\tstrcpy(file->message,\"\");\n\t\t}\n\t}\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_STEREOSEPARATION_PERCENT,file->settings.mStereoSeparation*100/128);\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_INTERPOLATIONFILTER_LENGTH,modplugresamplingmode_to_filterlength(file->settings.mResamplingMode));\n\treturn file;\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_Unload(ModPlugFile* file)\n{\n\tint p;\n\tif(!file) return;\n\tif(file->patterns){\n\t\tfor(p=0;p<openmpt_module_get_num_patterns(file->mod);p++){\n\t\t\tif(file->patterns[p]){\n\t\t\t\tfree(file->patterns[p]);\n\t\t\t\tfile->patterns[p] = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(file->patterns);\n\t\tfile->patterns = NULL;\n\t}\n\tif(file->mixerbuf){\n\t\tfree(file->mixerbuf);\n\t\tfile->mixerbuf = NULL;\n\t}\n\topenmpt_module_destroy(file->mod);\n\tfile->mod = NULL;\n\tfree(file->name);\n\tfile->name = NULL;\n\tfree(file->message);\n\tfile->message = NULL;\n\tfree(file->buf);\n\tfile->buf = NULL;\n\tfree(file);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_Read(ModPlugFile* file, void* buffer, int size)\n{\n\tint framesize;\n\tint framecount;\n\tint frames;\n\tint rendered;\n\tint frame;\n\tint channel;\n\tint totalrendered;\n\tsigned short* in;\n\tsigned int* mixbuf;\n\tunsigned char* buf8;\n\tsigned short* buf16;\n\tsigned int* buf32;\n\tif(!file) return 0;\n\tframesize = file->settings.mBits/8*file->settings.mChannels;\n\tframecount = size/framesize;\n\tbuf8 = buffer;\n\tbuf16 = buffer;\n\tbuf32 = buffer;\n\ttotalrendered = 0;\n\twhile(framecount>0){\n\t\tframes = framecount;\n\t\tif(frames>BUFFER_COUNT){\n\t\t\tframes = BUFFER_COUNT;\n\t\t}\n\t\tif(file->settings.mChannels==1){\n\t\t\trendered = (int)openmpt_module_read_mono(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0]);\n\t\t}else if(file->settings.mChannels==2){\n\t\t\trendered = (int)openmpt_module_read_stereo(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0],&file->buf[frames*1]);\n\t\t}else if(file->settings.mChannels==4){\n\t\t\trendered = (int)openmpt_module_read_quad(file->mod,file->settings.mFrequency,frames,&file->buf[frames*0],&file->buf[frames*1],&file->buf[frames*2],&file->buf[frames*3]);\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t\tin = file->buf;\n\t\tif(file->mixerproc&&file->mixerbuf){\n\t\t\tmixbuf=file->mixerbuf;\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*mixbuf = in[frames*channel+frame]<<(32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tmixbuf++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfile->mixerproc(file->mixerbuf,file->settings.mChannels*frames,file->settings.mChannels);\n\t\t\tmixbuf=file->mixerbuf;\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\tin[frames*channel+frame] = *mixbuf>>(32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tmixbuf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(file->settings.mBits==8){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf8 = in[frames*channel+frame]/256+0x80;\n\t\t\t\t\tbuf8++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(file->settings.mBits==16){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf16 = in[frames*channel+frame];\n\t\t\t\t\tbuf16++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else if(file->settings.mBits==32){\n\t\t\tfor(frame=0;frame<frames;frame++){\n\t\t\t\tfor(channel=0;channel<file->settings.mChannels;channel++){\n\t\t\t\t\t*buf32 = in[frames*channel+frame] << (32-16-1-MIXING_ATTENUATION);\n\t\t\t\t\tbuf32++;\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\treturn 0;\n\t\t}\n\t\ttotalrendered += rendered;\n\t\tframecount -= frames;\n\t\tif(!rendered) break;\n\t}\n\tmemset(((char*)buffer)+totalrendered*framesize,0,size-totalrendered*framesize);\n\treturn totalrendered*framesize;\n}\n\nLIBOPENMPT_MODPLUG_API const char* ModPlug_GetName(ModPlugFile* file)\n{\n\tif(!file) return NULL;\n\treturn file->name;\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetLength(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn (int)(openmpt_module_get_duration_seconds(file->mod)*1000.0);\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_Seek(ModPlugFile* file, int millisecond)\n{\n\tif(!file) return;\n\topenmpt_module_set_position_seconds(file->mod,(double)millisecond*0.001);\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_GetSettings(ModPlug_Settings* settings)\n{\n\tif(!settings) return;\n\tmemcpy(settings,&globalsettings,sizeof(ModPlug_Settings));\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_SetSettings(const ModPlug_Settings* settings)\n{\n\tif(!settings) return;\n\tmemcpy(&globalsettings,settings,sizeof(ModPlug_Settings));\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_GetMasterVolume(ModPlugFile* file)\n{\n\tint32_t val;\n\tif(!file) return 0;\n\tval = 0;\n\tif(!openmpt_module_get_render_param(file->mod,OPENMPT_MODULE_RENDER_MASTERGAIN_MILLIBEL,&val)) return 128;\n\treturn (unsigned int)(128.0*pow(10.0,val*0.0005));\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_SetMasterVolume(ModPlugFile* file,unsigned int cvol)\n{\n\tif(!file) return;\n\topenmpt_module_set_render_param(file->mod,OPENMPT_MODULE_RENDER_MASTERGAIN_MILLIBEL,(int32_t)(2000.0*log10(cvol/128.0)));\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentSpeed(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_speed(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentTempo(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_tempo(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentOrder(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_order(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentPattern(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_pattern(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetCurrentRow(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_row(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetPlayingChannels(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_current_playing_channels(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_SeekOrder(ModPlugFile* file,int order)\n{\n\tif(!file) return;\n\topenmpt_module_set_position_order_row(file->mod,order,0);\n}\n\nLIBOPENMPT_MODPLUG_API int ModPlug_GetModuleType(ModPlugFile* file)\n{\n\tconst char* type;\n\tint retval;\n\tif(!file) return 0;\n\ttype = openmpt_module_get_metadata(file->mod,\"type\");\n\tretval = MOD_TYPE_NONE;\n\tif(!type){\n\t\treturn retval;\n\t}\n\tif(!strcmp(type,\"mod\")){\n\t\tretval = MOD_TYPE_MOD;\n\t}else if(!strcmp(type,\"s3m\")){\n\t\tretval = MOD_TYPE_S3M;\n\t}else if(!strcmp(type,\"xm\")){\n\t\tretval = MOD_TYPE_XM;\n\t}else if(!strcmp(type,\"med\")){\n\t\tretval = MOD_TYPE_MED;\n\t}else if(!strcmp(type,\"mtm\")){\n\t\tretval = MOD_TYPE_MTM;\n\t}else if(!strcmp(type,\"it\")){\n\t\tretval = MOD_TYPE_IT;\n\t}else if(!strcmp(type,\"669\")){\n\t\tretval = MOD_TYPE_669;\n\t}else if(!strcmp(type,\"ult\")){\n\t\tretval = MOD_TYPE_ULT;\n\t}else if(!strcmp(type,\"stm\")){\n\t\tretval = MOD_TYPE_STM;\n\t}else if(!strcmp(type,\"far\")){\n\t\tretval = MOD_TYPE_FAR;\n\t}else if(!strcmp(type,\"s3m\")){\n\t\tretval = MOD_TYPE_WAV;\n\t}else if(!strcmp(type,\"amf\")){\n\t\tretval = MOD_TYPE_AMF;\n\t}else if(!strcmp(type,\"ams\")){\n\t\tretval = MOD_TYPE_AMS;\n\t}else if(!strcmp(type,\"dsm\")){\n\t\tretval = MOD_TYPE_DSM;\n\t}else if(!strcmp(type,\"mdl\")){\n\t\tretval = MOD_TYPE_MDL;\n\t}else if(!strcmp(type,\"okt\")){\n\t\tretval = MOD_TYPE_OKT;\n\t}else if(!strcmp(type,\"mid\")){\n\t\tretval = MOD_TYPE_MID;\n\t}else if(!strcmp(type,\"dmf\")){\n\t\tretval = MOD_TYPE_DMF;\n\t}else if(!strcmp(type,\"ptm\")){\n\t\tretval = MOD_TYPE_PTM;\n\t}else if(!strcmp(type,\"dbm\")){\n\t\tretval = MOD_TYPE_DBM;\n\t}else if(!strcmp(type,\"mt2\")){\n\t\tretval = MOD_TYPE_MT2;\n\t}else if(!strcmp(type,\"amf0\")){\n\t\tretval = MOD_TYPE_AMF0;\n\t}else if(!strcmp(type,\"psm\")){\n\t\tretval = MOD_TYPE_PSM;\n\t}else if(!strcmp(type,\"j2b\")){\n\t\tretval = MOD_TYPE_J2B;\n\t}else if(!strcmp(type,\"abc\")){\n\t\tretval = MOD_TYPE_ABC;\n\t}else if(!strcmp(type,\"pat\")){\n\t\tretval = MOD_TYPE_PAT;\n\t}else if(!strcmp(type,\"umx\")){\n\t\tretval = MOD_TYPE_UMX;\n\t}else{\n\t\tretval = MOD_TYPE_IT; /* fallback, most complex type */\n\t}\n\topenmpt_free_string(type);\n\treturn retval;\n}\n\nLIBOPENMPT_MODPLUG_API char* ModPlug_GetMessage(ModPlugFile* file)\n{\n\tif(!file) return NULL;\n\treturn file->message;\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumInstruments(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_instruments(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumSamples(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_samples(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumPatterns(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_patterns(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_NumChannels(ModPlugFile* file)\n{\n\tif(!file) return 0;\n\treturn openmpt_module_get_num_channels(file->mod);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_SampleName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tchar buf[32];\n\tif(!file) return 0;\n\tstr = openmpt_module_get_sample_name(file->mod,qual-1);\n\tmemset(buf,0,32);\n\tif(str){\n\t\tstrncpy(buf,str,31);\n\t\topenmpt_free_string(str);\n\t}\n\tif(buff){\n\t\tstrncpy(buff,buf,32);\n\t}\n\treturn (unsigned int)strlen(buf);\n}\n\nLIBOPENMPT_MODPLUG_API unsigned int ModPlug_InstrumentName(ModPlugFile* file, unsigned int qual, char* buff)\n{\n\tconst char* str;\n\tchar buf[32];\n\tif(!file) return 0;\n\tstr = openmpt_module_get_instrument_name(file->mod,qual-1);\n\tmemset(buf,0,32);\n\tif(str){\n\t\tstrncpy(buf,str,31);\n\t\topenmpt_free_string(str);\n\t}\n\tif(buff){\n\t\tstrncpy(buff,buf,32);\n\t}\n\treturn (unsigned int)strlen(buf);\n}\n\nLIBOPENMPT_MODPLUG_API ModPlugNote* ModPlug_GetPattern(ModPlugFile* file, int pattern, unsigned int* numrows)\n{\n\tint c;\n\tint r;\n\tint numr;\n\tint numc;\n\tModPlugNote note;\n\tif(!file) return NULL;\n\tif(numrows){\n\t\t*numrows = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\t}\n\tif(pattern<0||pattern>=openmpt_module_get_num_patterns(file->mod)){\n\t\treturn NULL;\n\t}\n\tif(!file->patterns){\n\t\tfile->patterns = malloc(sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t\tif(!file->patterns) return NULL;\n\t\tmemset(file->patterns,0,sizeof(ModPlugNote*)*openmpt_module_get_pattern_num_rows(file->mod,pattern));\n\t}\n\tif(!file->patterns[pattern]){\n\t\tfile->patterns[pattern] = malloc(sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t\tif(!file->patterns[pattern]) return NULL;\n\t\tmemset(file->patterns[pattern],0,sizeof(ModPlugNote)*openmpt_module_get_pattern_num_rows(file->mod,pattern)*openmpt_module_get_num_channels(file->mod));\n\t}\n\tnumr = openmpt_module_get_pattern_num_rows(file->mod,pattern);\n\tnumc = openmpt_module_get_num_channels(file->mod);\n\tfor(r=0;r<numr;r++){\n\t\tfor(c=0;c<numc;c++){\n\t\t\tmemset(&note,0,sizeof(ModPlugNote));\n\t\t\tnote.Note = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_NOTE);\n\t\t\tnote.Instrument = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_INSTRUMENT);\n\t\t\tnote.VolumeEffect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUMEEFFECT);\n\t\t\tnote.Effect = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_EFFECT);\n\t\t\tnote.Volume = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_VOLUME);\n\t\t\tnote.Parameter = openmpt_module_get_pattern_row_channel_command(file->mod,pattern,r,c,OPENMPT_MODULE_COMMAND_PARAMETER);\n\t\t\tmemcpy(&file->patterns[pattern][r*numc+c],&note,sizeof(ModPlugNote));\n\t\t}\n\t}\n\treturn file->patterns[pattern];\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_InitMixerCallback(ModPlugFile* file,ModPlugMixerProc proc)\n{\n\tif(!file) return;\n\tif(!file->mixerbuf){\n\t\tfile->mixerbuf = malloc(BUFFER_COUNT*sizeof(signed int)*4);\n\t}\n\tfile->mixerproc = proc;\n}\n\nLIBOPENMPT_MODPLUG_API void ModPlug_UnloadMixerCallback(ModPlugFile* file)\n{\n\tif(!file) return;\n\tfile->mixerproc = NULL;\n\tif(file->mixerbuf){\n\t\tfree(file->mixerbuf);\n\t\tfile->mixerbuf = NULL;\n\t}\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportS3M(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportS3M(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportXM(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportXM(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportMOD(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportMOD(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\nLIBOPENMPT_MODPLUG_API char ModPlug_ExportIT(ModPlugFile* file, const char* filepath)\n{\n\t(void)file;\n\t/* not implemented */\n\tfprintf(stderr,\"libopenmpt-modplug: error: ModPlug_ExportIT(%s) not implemented.\\n\",filepath);\n\treturn 0;\n}\n\n#endif /* NO_LIBMODPLUG */\n"], "filenames": ["libopenmpt/libopenmpt_modplug.c"], "buggy_code_start_loc": [481], "buggy_code_end_loc": [528], "fixing_code_start_loc": [481], "fixing_code_end_loc": [510], "type": "CWE-120", "message": "In libopenmpt before 0.3.19 and 0.4.x before 0.4.9, ModPlug_InstrumentName and ModPlug_SampleName in libopenmpt_modplug.c do not restrict the lengths of libmodplug output-buffer strings in the C API, leading to a buffer overflow.", "other": {"cve": {"id": "CVE-2019-17113", "sourceIdentifier": "cve@mitre.org", "published": "2019-10-04T00:15:10.747", "lastModified": "2020-08-02T01:15:10.910", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In libopenmpt before 0.3.19 and 0.4.x before 0.4.9, ModPlug_InstrumentName and ModPlug_SampleName in libopenmpt_modplug.c do not restrict the lengths of libmodplug output-buffer strings in the C API, leading to a buffer overflow."}, {"lang": "es", "value": "En libopenmpt versiones anteriores a 0.3.19 y versiones 0.4.x anteriores a 0.4.9, las funciones ModPlug_InstrumentName y ModPlug_SampleName en el archivo libopenmpt_modplug.c, no restringen las longitudes de las cadenas de salida del buffer de libmodplug en la API C, conllevando a un desbordamiento del b\u00fafer."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openmpt:libopenmpt:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.3.19", "matchCriteriaId": "607ACD5A-5D62-48E6-ACD5-A281D9D635D6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:openmpt:libopenmpt:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.4.0", "versionEndExcluding": "0.4.9", "matchCriteriaId": "08134F65-87AA-4081-B96A-B962F51BDD39"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00035.html", "source": "cve@mitre.org"}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-10/msg00044.html", "source": "cve@mitre.org"}, {"url": "https://github.com/OpenMPT/openmpt/commit/927688ddab43c2b203569de79407a899e734fabe", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenMPT/openmpt/compare/libopenmpt-0.3.18...libopenmpt-0.3.19", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/OpenMPT/openmpt/compare/libopenmpt-0.4.8...libopenmpt-0.4.9", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00003.html", "source": "cve@mitre.org"}, {"url": "https://source.openmpt.org/browse/openmpt/trunk/OpenMPT/?op=revision&rev=12127&peg=12127", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4729", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/OpenMPT/openmpt/commit/927688ddab43c2b203569de79407a899e734fabe"}}