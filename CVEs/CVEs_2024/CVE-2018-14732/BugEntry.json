{"buggy_code": ["'use strict';\n\n/* eslint func-names: off */\nrequire('./polyfills');\n\nconst fs = require('fs');\nconst http = require('http');\nconst path = require('path');\nconst url = require('url');\nconst chokidar = require('chokidar');\nconst compress = require('compression');\nconst del = require('del');\nconst express = require('express');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst ip = require('ip');\nconst killable = require('killable');\nconst serveIndex = require('serve-index');\nconst historyApiFallback = require('connect-history-api-fallback');\nconst selfsigned = require('selfsigned');\nconst sockjs = require('sockjs');\nconst spdy = require('spdy');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst createLog = require('./createLog');\nconst OptionsValidationError = require('./OptionsValidationError');\nconst optionsSchema = require('./optionsSchema.json');\n\nconst clientStats = { all: false, assets: true, warnings: true, errors: true, errorDetails: false, hash: true };\n\nfunction Server(compiler, options, _log) {\n  // Default options\n  if (!options) options = {};\n  this.log = _log || createLog(options);\n\n  const validationErrors = webpack.validateSchema(optionsSchema, options);\n  if (validationErrors.length) {\n    throw new OptionsValidationError(validationErrors);\n  }\n\n  if (options.lazy && !options.filename) {\n    throw new Error(\"'filename' option must be set in lazy mode.\");\n  }\n\n  this.hot = options.hot || options.hotOnly;\n  this.headers = options.headers;\n  this.clientLogLevel = options.clientLogLevel;\n  this.clientOverlay = options.overlay;\n  this.progress = options.progress;\n  this.disableHostCheck = !!options.disableHostCheck;\n  this.publicHost = options.public;\n  this.allowedHosts = options.allowedHosts;\n  this.sockets = [];\n  this.contentBaseWatchers = [];\n  this.watchOptions = options.watchOptions || {};\n\n  // Listening for events\n  const invalidPlugin = () => {\n    this.sockWrite(this.sockets, 'invalid');\n  };\n  if (this.progress) {\n    const progressPlugin = new webpack.ProgressPlugin((percent, msg, addInfo) => {\n      percent = Math.floor(percent * 100);\n      if (percent === 100) msg = 'Compilation completed';\n      if (addInfo) msg = `${msg} (${addInfo})`;\n      this.sockWrite(this.sockets, 'progress-update', { percent, msg });\n    });\n    progressPlugin.apply(compiler);\n  }\n\n  const addCompilerHooks = (comp) => {\n    comp.hooks.compile.tap('webpack-dev-server', invalidPlugin);\n    comp.hooks.invalid.tap('webpack-dev-server', invalidPlugin);\n    comp.hooks.done.tap('webpack-dev-server', (stats) => {\n      this._sendStats(this.sockets, stats.toJson(clientStats));\n      this._stats = stats;\n    });\n  };\n  if (compiler.compilers) {\n    compiler.compilers.forEach(addCompilerHooks);\n  } else {\n    addCompilerHooks(compiler);\n  }\n\n  // Init express server\n  const app = this.app = new express(); // eslint-disable-line\n\n  app.all('*', (req, res, next) => { // eslint-disable-line\n    if (this.checkHost(req.headers)) { return next(); }\n    res.send('Invalid Host header');\n  });\n\n  const wdmOptions = { logLevel: this.log.options.level };\n\n  // middleware for serving webpack bundle\n  this.middleware = webpackDevMiddleware(compiler, Object.assign({}, options, wdmOptions));\n\n  app.get('/__webpack_dev_server__/live.bundle.js', (req, res) => {\n    res.setHeader('Content-Type', 'application/javascript');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'live.bundle.js')).pipe(res);\n  });\n\n  app.get('/__webpack_dev_server__/sockjs.bundle.js', (req, res) => {\n    res.setHeader('Content-Type', 'application/javascript');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'sockjs.bundle.js')).pipe(res);\n  });\n\n  app.get('/webpack-dev-server.js', (req, res) => {\n    res.setHeader('Content-Type', 'application/javascript');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'index.bundle.js')).pipe(res);\n  });\n\n  app.get('/webpack-dev-server/*', (req, res) => {\n    res.setHeader('Content-Type', 'text/html');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'live.html')).pipe(res);\n  });\n\n  app.get('/webpack-dev-server', (req, res) => {\n    res.setHeader('Content-Type', 'text/html');\n    res.write('<!DOCTYPE html><html><head><meta charset=\"utf-8\"/></head><body>');\n    const outputPath = this.middleware.getFilenameFromUrl(options.publicPath || '/');\n    const filesystem = this.middleware.fileSystem;\n\n    function writeDirectory(baseUrl, basePath) {\n      const content = filesystem.readdirSync(basePath);\n      res.write('<ul>');\n      content.forEach((item) => {\n        const p = `${basePath}/${item}`;\n        if (filesystem.statSync(p).isFile()) {\n          res.write('<li><a href=\"');\n          res.write(baseUrl + item);\n          res.write('\">');\n          res.write(item);\n          res.write('</a></li>');\n          if (/\\.js$/.test(item)) {\n            const htmlItem = item.substr(0, item.length - 3);\n            res.write('<li><a href=\"');\n            res.write(baseUrl + htmlItem);\n            res.write('\">');\n            res.write(htmlItem);\n            res.write('</a> (magic html for ');\n            res.write(item);\n            res.write(') (<a href=\"');\n            res.write(baseUrl.replace(/(^(https?:\\/\\/[^\\/]+)?\\/)/, \"$1webpack-dev-server/\") + htmlItem); // eslint-disable-line\n            res.write('\">webpack-dev-server</a>)</li>');\n          }\n        } else {\n          res.write('<li>');\n          res.write(item);\n          res.write('<br>');\n          writeDirectory(`${baseUrl + item}/`, p);\n          res.write('</li>');\n        }\n      });\n      res.write('</ul>');\n    }\n    writeDirectory(options.publicPath || '/', outputPath);\n    res.end('</body></html>');\n  });\n\n  let contentBase;\n  if (options.contentBase !== undefined) { // eslint-disable-line\n    contentBase = options.contentBase; // eslint-disable-line\n  } else {\n    contentBase = process.cwd();\n  }\n\n  // Keep track of websocket proxies for external websocket upgrade.\n  const websocketProxies = [];\n\n  const features = {\n    compress() {\n      if (options.compress) {\n        // Enable gzip compression.\n        app.use(compress());\n      }\n    },\n\n    proxy() {\n      if (options.proxy) {\n        /**\n          * Assume a proxy configuration specified as:\n          * proxy: {\n          *   'context': { options }\n          * }\n          * OR\n          * proxy: {\n          *   'context': 'target'\n          * }\n          */\n        if (!Array.isArray(options.proxy)) {\n          options.proxy = Object.keys(options.proxy).map((context) => {\n            let proxyOptions;\n            // For backwards compatibility reasons.\n            const correctedContext = context.replace(/^\\*$/, '**').replace(/\\/\\*$/, '');\n\n            if (typeof options.proxy[context] === 'string') {\n              proxyOptions = {\n                context: correctedContext,\n                target: options.proxy[context]\n              };\n            } else {\n              proxyOptions = Object.assign({}, options.proxy[context]);\n              proxyOptions.context = correctedContext;\n            }\n            proxyOptions.logLevel = proxyOptions.logLevel || 'warn';\n\n            return proxyOptions;\n          });\n        }\n\n        const getProxyMiddleware = (proxyConfig) => {\n          const context = proxyConfig.context || proxyConfig.path;\n\n          // It is possible to use the `bypass` method without a `target`.\n          // However, the proxy middleware has no use in this case, and will fail to instantiate.\n          if (proxyConfig.target) {\n            return httpProxyMiddleware(context, proxyConfig);\n          }\n        };\n\n        /**\n        * Assume a proxy configuration specified as:\n        * proxy: [\n        *   {\n        *     context: ...,\n        *     ...options...\n        *   },\n        *   // or:\n        *   function() {\n        *     return {\n        *       context: ...,\n        *       ...options...\n        *     };\n        *   }\n        * ]\n        */\n        options.proxy.forEach((proxyConfigOrCallback) => {\n          let proxyConfig;\n          let proxyMiddleware;\n\n          if (typeof proxyConfigOrCallback === 'function') {\n            proxyConfig = proxyConfigOrCallback();\n          } else {\n            proxyConfig = proxyConfigOrCallback;\n          }\n\n          proxyMiddleware = getProxyMiddleware(proxyConfig);\n          if (proxyConfig.ws) {\n            websocketProxies.push(proxyMiddleware);\n          }\n\n          app.use((req, res, next) => {\n            if (typeof proxyConfigOrCallback === 'function') {\n              const newProxyConfig = proxyConfigOrCallback();\n              if (newProxyConfig !== proxyConfig) {\n                proxyConfig = newProxyConfig;\n                proxyMiddleware = getProxyMiddleware(proxyConfig);\n              }\n            }\n            const bypass = typeof proxyConfig.bypass === 'function';\n            // eslint-disable-next-line\n            const bypassUrl = bypass && proxyConfig.bypass(req, res, proxyConfig) || false;\n\n            if (bypassUrl) {\n              req.url = bypassUrl;\n              next();\n            } else if (proxyMiddleware) {\n              return proxyMiddleware(req, res, next);\n            } else {\n              next();\n            }\n          });\n        });\n      }\n    },\n\n    historyApiFallback() {\n      if (options.historyApiFallback) {\n        // Fall back to /index.html if nothing else matches.\n        app.use(historyApiFallback(typeof options.historyApiFallback === 'object' ? options.historyApiFallback : null));\n      }\n    },\n\n    contentBaseFiles: () => {\n      if (Array.isArray(contentBase)) {\n        contentBase.forEach((item) => {\n          app.get('*', express.static(item));\n        });\n      } else if (/^(https?:)?\\/\\//.test(contentBase)) {\n        this.log.warn('Using a URL as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');\n        this.log.warn('proxy: {\\n\\t\"*\": \"<your current contentBase configuration>\"\\n}'); // eslint-disable-line quotes\n        // Redirect every request to contentBase\n        app.get('*', (req, res) => {\n          res.writeHead(302, {\n            Location: contentBase + req.path + (req._parsedUrl.search || '')\n          });\n          res.end();\n        });\n      } else if (typeof contentBase === 'number') {\n        this.log.warn('Using a number as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');\n        this.log.warn('proxy: {\\n\\t\"*\": \"//localhost:<your current contentBase configuration>\"\\n}'); // eslint-disable-line quotes\n        // Redirect every request to the port contentBase\n        app.get('*', (req, res) => {\n          res.writeHead(302, {\n            Location: `//localhost:${contentBase}${req.path}${req._parsedUrl.search || ''}`\n          });\n          res.end();\n        });\n      } else {\n        // route content request\n        app.get('*', express.static(contentBase, options.staticOptions));\n      }\n    },\n\n    contentBaseIndex() {\n      if (Array.isArray(contentBase)) {\n        contentBase.forEach((item) => {\n          app.get('*', serveIndex(item));\n        });\n      } else if (!/^(https?:)?\\/\\//.test(contentBase) && typeof contentBase !== 'number') {\n        app.get('*', serveIndex(contentBase));\n      }\n    },\n\n    watchContentBase: () => {\n      if (/^(https?:)?\\/\\//.test(contentBase) || typeof contentBase === 'number') {\n        throw new Error('Watching remote files is not supported.');\n      } else if (Array.isArray(contentBase)) {\n        contentBase.forEach((item) => {\n          this._watch(item);\n        });\n      } else {\n        this._watch(contentBase);\n      }\n    },\n\n    before: () => {\n      if (typeof options.before === 'function') {\n        options.before(app, this);\n      }\n    },\n\n    middleware: () => {\n      // include our middleware to ensure it is able to handle '/index.html' request after redirect\n      app.use(this.middleware);\n    },\n\n    after: () => {\n      if (typeof options.after === 'function') { options.after(app, this); }\n    },\n\n    headers: () => {\n      app.all('*', this.setContentHeaders.bind(this));\n    },\n\n    magicHtml: () => {\n      app.get('*', this.serveMagicHtml.bind(this));\n    },\n\n    setup: () => {\n      if (typeof options.setup === 'function') {\n        this.log.warn('The `setup` option is deprecated and will be removed in v3. Please update your config to use `before`');\n        options.setup(app, this);\n      }\n    }\n  };\n\n  const defaultFeatures = ['before', 'setup', 'headers', 'middleware'];\n  if (options.proxy) { defaultFeatures.push('proxy', 'middleware'); }\n  if (contentBase !== false) { defaultFeatures.push('contentBaseFiles'); }\n  if (options.watchContentBase) { defaultFeatures.push('watchContentBase'); }\n  if (options.historyApiFallback) {\n    defaultFeatures.push('historyApiFallback', 'middleware');\n    if (contentBase !== false) { defaultFeatures.push('contentBaseFiles'); }\n  }\n  defaultFeatures.push('magicHtml');\n  if (contentBase !== false) { defaultFeatures.push('contentBaseIndex'); }\n  // compress is placed last and uses unshift so that it will be the first middleware used\n  if (options.compress) { defaultFeatures.unshift('compress'); }\n  if (options.after) { defaultFeatures.push('after'); }\n\n  (options.features || defaultFeatures).forEach((feature) => {\n    features[feature]();\n  });\n\n  if (options.https) {\n    // for keep supporting CLI parameters\n    if (typeof options.https === 'boolean') {\n      options.https = {\n        key: options.key,\n        cert: options.cert,\n        ca: options.ca,\n        pfx: options.pfx,\n        passphrase: options.pfxPassphrase,\n        requestCert: options.requestCert || false\n      };\n    }\n\n    let fakeCert;\n    if (!options.https.key || !options.https.cert) {\n      // Use a self-signed certificate if no certificate was configured.\n      // Cycle certs every 24 hours\n      const certPath = path.join(__dirname, '../ssl/server.pem');\n      let certExists = fs.existsSync(certPath);\n\n      if (certExists) {\n        const certStat = fs.statSync(certPath);\n        const certTtl = 1000 * 60 * 60 * 24;\n        const now = new Date();\n\n        // cert is more than 30 days old, kill it with fire\n        if ((now - certStat.ctime) / certTtl > 30) {\n          this.log.info('SSL Certificate is more than 30 days old. Removing.');\n          del.sync([certPath], { force: true });\n          certExists = false;\n        }\n      }\n\n      if (!certExists) {\n        this.log.info('Generating SSL Certificate');\n        const attrs = [{ name: 'commonName', value: 'localhost' }];\n        const pems = selfsigned.generate(attrs, {\n          algorithm: 'sha256',\n          days: 30,\n          keySize: 2048,\n          extensions: [{\n            name: 'basicConstraints',\n            cA: true\n          }, {\n            name: 'keyUsage',\n            keyCertSign: true,\n            digitalSignature: true,\n            nonRepudiation: true,\n            keyEncipherment: true,\n            dataEncipherment: true\n          }, {\n            name: 'subjectAltName',\n            altNames: [\n              {\n                // type 2 is DNS\n                type: 2,\n                value: 'localhost'\n              },\n              {\n                type: 2,\n                value: 'localhost.localdomain'\n              },\n              {\n                type: 2,\n                value: 'lvh.me'\n              },\n              {\n                type: 2,\n                value: '*.lvh.me'\n              },\n              {\n                type: 2,\n                value: '[::1]'\n              },\n              {\n                // type 7 is IP\n                type: 7,\n                ip: '127.0.0.1'\n              },\n              {\n                type: 7,\n                ip: 'fe80::1'\n              }\n            ]\n          }]\n        });\n\n        fs.writeFileSync(certPath, pems.private + pems.cert, { encoding: 'utf-8' });\n      }\n      fakeCert = fs.readFileSync(certPath);\n    }\n\n    options.https.key = options.https.key || fakeCert;\n    options.https.cert = options.https.cert || fakeCert;\n\n    if (!options.https.spdy) {\n      options.https.spdy = {\n        protocols: ['h2', 'http/1.1']\n      };\n    }\n\n    this.listeningApp = spdy.createServer(options.https, app);\n  } else {\n    this.listeningApp = http.createServer(app);\n  }\n\n  killable(this.listeningApp);\n\n  // Proxy websockets without the initial http request\n  // https://github.com/chimurai/http-proxy-middleware#external-websocket-upgrade\n  websocketProxies.forEach(function (wsProxy) {\n    this.listeningApp.on('upgrade', wsProxy.upgrade);\n  }, this);\n}\n\nServer.prototype.use = function () {\n  // eslint-disable-next-line\n  this.app.use.apply(this.app, arguments);\n};\n\nServer.prototype.setContentHeaders = function (req, res, next) {\n  if (this.headers) {\n    for (const name in this.headers) { // eslint-disable-line\n      res.setHeader(name, this.headers[name]);\n    }\n  }\n\n  next();\n};\n\nServer.prototype.checkHost = function (headers) {\n  // allow user to opt-out this security check, at own risk\n  if (this.disableHostCheck) return true;\n\n  // get the Host header and extract hostname\n  // we don't care about port not matching\n  const hostHeader = headers.host;\n  if (!hostHeader) return false;\n\n  // use the node url-parser to retrieve the hostname from the host-header.\n  const hostname = url.parse(`//${hostHeader}`, false, true).hostname;\n\n  // always allow requests with explicit IPv4 or IPv6-address.\n  // A note on IPv6 addresses: hostHeader will always contain the brackets denoting\n  // an IPv6-address in URLs, these are removed from the hostname in url.parse(),\n  // so we have the pure IPv6-address in hostname.\n  if (ip.isV4Format(hostname) || ip.isV6Format(hostname)) return true;\n\n  // always allow localhost host, for convience\n  if (hostname === 'localhost') return true;\n\n  // allow if hostname is in allowedHosts\n  if (this.allowedHosts && this.allowedHosts.length) {\n    for (let hostIdx = 0; hostIdx < this.allowedHosts.length; hostIdx++) {\n      const allowedHost = this.allowedHosts[hostIdx];\n      if (allowedHost === hostname) return true;\n\n      // support \".\" as a subdomain wildcard\n      // e.g. \".example.com\" will allow \"example.com\", \"www.example.com\", \"subdomain.example.com\", etc\n      if (allowedHost[0] === '.') {\n        // \"example.com\"\n        if (hostname === allowedHost.substring(1)) return true;\n        // \"*.example.com\"\n        if (hostname.endsWith(allowedHost)) return true;\n      }\n    }\n  }\n\n  // allow hostname of listening adress\n  if (hostname === this.listenHostname) return true;\n\n  // also allow public hostname if provided\n  if (typeof this.publicHost === 'string') {\n    const idxPublic = this.publicHost.indexOf(':');\n    const publicHostname = idxPublic >= 0 ? this.publicHost.substr(0, idxPublic) : this.publicHost;\n    if (hostname === publicHostname) return true;\n  }\n\n  // disallow\n  return false;\n};\n\n// delegate listen call and init sockjs\nServer.prototype.listen = function (port, hostname, fn) {\n  this.listenHostname = hostname;\n  const returnValue = this.listeningApp.listen(port, hostname, (err) => {\n    const sockServer = sockjs.createServer({\n      // Use provided up-to-date sockjs-client\n      sockjs_url: '/__webpack_dev_server__/sockjs.bundle.js',\n      // Limit useless logs\n      log: (severity, line) => {\n        if (severity === 'error') {\n          this.log.error(line);\n        } else {\n          this.log.debug(line);\n        }\n      }\n    });\n\n    sockServer.on('connection', (conn) => {\n      if (!conn) return;\n      if (!this.checkHost(conn.headers)) {\n        this.sockWrite([conn], 'error', 'Invalid Host header');\n        conn.close();\n        return;\n      }\n      this.sockets.push(conn);\n\n      conn.on('close', () => {\n        const connIndex = this.sockets.indexOf(conn);\n        if (connIndex >= 0) {\n          this.sockets.splice(connIndex, 1);\n        }\n      });\n\n      if (this.clientLogLevel) { this.sockWrite([conn], 'log-level', this.clientLogLevel); }\n\n      if (this.progress) { this.sockWrite([conn], 'progress', this.progress); }\n\n      if (this.clientOverlay) { this.sockWrite([conn], 'overlay', this.clientOverlay); }\n\n      if (this.hot) this.sockWrite([conn], 'hot');\n\n      if (!this._stats) return;\n      this._sendStats([conn], this._stats.toJson(clientStats), true);\n    });\n\n    sockServer.installHandlers(this.listeningApp, {\n      prefix: '/sockjs-node'\n    });\n\n    if (fn) {\n      fn.call(this.listeningApp, err);\n    }\n  });\n\n  return returnValue;\n};\n\nServer.prototype.close = function (callback) {\n  this.sockets.forEach((sock) => {\n    sock.close();\n  });\n  this.sockets = [];\n\n  this.contentBaseWatchers.forEach((watcher) => {\n    watcher.close();\n  });\n  this.contentBaseWatchers = [];\n\n  this.listeningApp.kill(() => {\n    this.middleware.close(callback);\n  });\n};\n\nServer.prototype.sockWrite = function (sockets, type, data) {\n  sockets.forEach((sock) => {\n    sock.write(JSON.stringify({\n      type,\n      data\n    }));\n  });\n};\n\nServer.prototype.serveMagicHtml = function (req, res, next) {\n  const _path = req.path;\n  try {\n    if (!this.middleware.fileSystem.statSync(this.middleware.getFilenameFromUrl(`${_path}.js`)).isFile()) { return next(); }\n    // Serve a page that executes the javascript\n    res.write('<!DOCTYPE html><html><head><meta charset=\"utf-8\"/></head><body><script type=\"text/javascript\" charset=\"utf-8\" src=\"');\n    res.write(_path);\n    res.write('.js');\n    res.write(req._parsedUrl.search || '');\n    res.end('\"></script></body></html>');\n  } catch (e) {\n    return next();\n  }\n};\n\n// send stats to a socket or multiple sockets\nServer.prototype._sendStats = function (sockets, stats, force) {\n  if (!force &&\n  stats &&\n  (!stats.errors || stats.errors.length === 0) &&\n  stats.assets &&\n  stats.assets.every(asset => !asset.emitted)\n  ) { return this.sockWrite(sockets, 'still-ok'); }\n  this.sockWrite(sockets, 'hash', stats.hash);\n  if (stats.errors.length > 0) { this.sockWrite(sockets, 'errors', stats.errors); } else if (stats.warnings.length > 0) { this.sockWrite(sockets, 'warnings', stats.warnings); } else { this.sockWrite(sockets, 'ok'); }\n};\n\nServer.prototype._watch = function (watchPath) {\n  // duplicate the same massaging of options that watchpack performs\n  // https://github.com/webpack/watchpack/blob/master/lib/DirectoryWatcher.js#L49\n  // this isn't an elegant solution, but we'll improve it in the future\n  const usePolling = this.watchOptions.poll ? true : undefined; // eslint-disable-line no-undefined\n  const interval = typeof this.watchOptions.poll === 'number' ? this.watchOptions.poll : undefined; // eslint-disable-line no-undefined\n  const options = {\n    ignoreInitial: true,\n    persistent: true,\n    followSymlinks: false,\n    depth: 0,\n    atomic: false,\n    alwaysStat: true,\n    ignorePermissionErrors: true,\n    ignored: this.watchOptions.ignored,\n    usePolling,\n    interval\n  };\n  const watcher = chokidar.watch(watchPath, options).on('change', () => {\n    this.sockWrite(this.sockets, 'content-changed');\n  });\n\n  this.contentBaseWatchers.push(watcher);\n};\n\nServer.prototype.invalidate = function () {\n  if (this.middleware) this.middleware.invalidate();\n};\n\n// Export this logic, so that other implementations, like task-runners can use it\nServer.addDevServerEntrypoints = require('./util/addDevServerEntrypoints');\n\nmodule.exports = Server;\n"], "fixing_code": ["'use strict';\n\n/* eslint func-names: off */\nrequire('./polyfills');\n\nconst fs = require('fs');\nconst http = require('http');\nconst path = require('path');\nconst url = require('url');\nconst chokidar = require('chokidar');\nconst compress = require('compression');\nconst del = require('del');\nconst express = require('express');\nconst httpProxyMiddleware = require('http-proxy-middleware');\nconst ip = require('ip');\nconst killable = require('killable');\nconst serveIndex = require('serve-index');\nconst historyApiFallback = require('connect-history-api-fallback');\nconst selfsigned = require('selfsigned');\nconst sockjs = require('sockjs');\nconst spdy = require('spdy');\nconst webpack = require('webpack');\nconst webpackDevMiddleware = require('webpack-dev-middleware');\nconst createLog = require('./createLog');\nconst OptionsValidationError = require('./OptionsValidationError');\nconst optionsSchema = require('./optionsSchema.json');\n\nconst clientStats = { all: false, assets: true, warnings: true, errors: true, errorDetails: false, hash: true };\n\nfunction Server(compiler, options, _log) {\n  // Default options\n  if (!options) options = {};\n  this.log = _log || createLog(options);\n\n  const validationErrors = webpack.validateSchema(optionsSchema, options);\n  if (validationErrors.length) {\n    throw new OptionsValidationError(validationErrors);\n  }\n\n  if (options.lazy && !options.filename) {\n    throw new Error(\"'filename' option must be set in lazy mode.\");\n  }\n\n  this.hot = options.hot || options.hotOnly;\n  this.headers = options.headers;\n  this.clientLogLevel = options.clientLogLevel;\n  this.clientOverlay = options.overlay;\n  this.progress = options.progress;\n  this.disableHostCheck = !!options.disableHostCheck;\n  this.publicHost = options.public;\n  this.allowedHosts = options.allowedHosts;\n  this.sockets = [];\n  this.contentBaseWatchers = [];\n  this.watchOptions = options.watchOptions || {};\n\n  // Listening for events\n  const invalidPlugin = () => {\n    this.sockWrite(this.sockets, 'invalid');\n  };\n  if (this.progress) {\n    const progressPlugin = new webpack.ProgressPlugin((percent, msg, addInfo) => {\n      percent = Math.floor(percent * 100);\n      if (percent === 100) msg = 'Compilation completed';\n      if (addInfo) msg = `${msg} (${addInfo})`;\n      this.sockWrite(this.sockets, 'progress-update', { percent, msg });\n    });\n    progressPlugin.apply(compiler);\n  }\n\n  const addCompilerHooks = (comp) => {\n    comp.hooks.compile.tap('webpack-dev-server', invalidPlugin);\n    comp.hooks.invalid.tap('webpack-dev-server', invalidPlugin);\n    comp.hooks.done.tap('webpack-dev-server', (stats) => {\n      this._sendStats(this.sockets, stats.toJson(clientStats));\n      this._stats = stats;\n    });\n  };\n  if (compiler.compilers) {\n    compiler.compilers.forEach(addCompilerHooks);\n  } else {\n    addCompilerHooks(compiler);\n  }\n\n  // Init express server\n  const app = this.app = new express(); // eslint-disable-line\n\n  app.all('*', (req, res, next) => { // eslint-disable-line\n    if (this.checkHost(req.headers)) { return next(); }\n    res.send('Invalid Host header');\n  });\n\n  const wdmOptions = { logLevel: this.log.options.level };\n\n  // middleware for serving webpack bundle\n  this.middleware = webpackDevMiddleware(compiler, Object.assign({}, options, wdmOptions));\n\n  app.get('/__webpack_dev_server__/live.bundle.js', (req, res) => {\n    res.setHeader('Content-Type', 'application/javascript');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'live.bundle.js')).pipe(res);\n  });\n\n  app.get('/__webpack_dev_server__/sockjs.bundle.js', (req, res) => {\n    res.setHeader('Content-Type', 'application/javascript');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'sockjs.bundle.js')).pipe(res);\n  });\n\n  app.get('/webpack-dev-server.js', (req, res) => {\n    res.setHeader('Content-Type', 'application/javascript');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'index.bundle.js')).pipe(res);\n  });\n\n  app.get('/webpack-dev-server/*', (req, res) => {\n    res.setHeader('Content-Type', 'text/html');\n    fs.createReadStream(path.join(__dirname, '..', 'client', 'live.html')).pipe(res);\n  });\n\n  app.get('/webpack-dev-server', (req, res) => {\n    res.setHeader('Content-Type', 'text/html');\n    res.write('<!DOCTYPE html><html><head><meta charset=\"utf-8\"/></head><body>');\n    const outputPath = this.middleware.getFilenameFromUrl(options.publicPath || '/');\n    const filesystem = this.middleware.fileSystem;\n\n    function writeDirectory(baseUrl, basePath) {\n      const content = filesystem.readdirSync(basePath);\n      res.write('<ul>');\n      content.forEach((item) => {\n        const p = `${basePath}/${item}`;\n        if (filesystem.statSync(p).isFile()) {\n          res.write('<li><a href=\"');\n          res.write(baseUrl + item);\n          res.write('\">');\n          res.write(item);\n          res.write('</a></li>');\n          if (/\\.js$/.test(item)) {\n            const htmlItem = item.substr(0, item.length - 3);\n            res.write('<li><a href=\"');\n            res.write(baseUrl + htmlItem);\n            res.write('\">');\n            res.write(htmlItem);\n            res.write('</a> (magic html for ');\n            res.write(item);\n            res.write(') (<a href=\"');\n            res.write(baseUrl.replace(/(^(https?:\\/\\/[^\\/]+)?\\/)/, \"$1webpack-dev-server/\") + htmlItem); // eslint-disable-line\n            res.write('\">webpack-dev-server</a>)</li>');\n          }\n        } else {\n          res.write('<li>');\n          res.write(item);\n          res.write('<br>');\n          writeDirectory(`${baseUrl + item}/`, p);\n          res.write('</li>');\n        }\n      });\n      res.write('</ul>');\n    }\n    writeDirectory(options.publicPath || '/', outputPath);\n    res.end('</body></html>');\n  });\n\n  let contentBase;\n  if (options.contentBase !== undefined) { // eslint-disable-line\n    contentBase = options.contentBase; // eslint-disable-line\n  } else {\n    contentBase = process.cwd();\n  }\n\n  // Keep track of websocket proxies for external websocket upgrade.\n  const websocketProxies = [];\n\n  const features = {\n    compress() {\n      if (options.compress) {\n        // Enable gzip compression.\n        app.use(compress());\n      }\n    },\n\n    proxy() {\n      if (options.proxy) {\n        /**\n          * Assume a proxy configuration specified as:\n          * proxy: {\n          *   'context': { options }\n          * }\n          * OR\n          * proxy: {\n          *   'context': 'target'\n          * }\n          */\n        if (!Array.isArray(options.proxy)) {\n          options.proxy = Object.keys(options.proxy).map((context) => {\n            let proxyOptions;\n            // For backwards compatibility reasons.\n            const correctedContext = context.replace(/^\\*$/, '**').replace(/\\/\\*$/, '');\n\n            if (typeof options.proxy[context] === 'string') {\n              proxyOptions = {\n                context: correctedContext,\n                target: options.proxy[context]\n              };\n            } else {\n              proxyOptions = Object.assign({}, options.proxy[context]);\n              proxyOptions.context = correctedContext;\n            }\n            proxyOptions.logLevel = proxyOptions.logLevel || 'warn';\n\n            return proxyOptions;\n          });\n        }\n\n        const getProxyMiddleware = (proxyConfig) => {\n          const context = proxyConfig.context || proxyConfig.path;\n\n          // It is possible to use the `bypass` method without a `target`.\n          // However, the proxy middleware has no use in this case, and will fail to instantiate.\n          if (proxyConfig.target) {\n            return httpProxyMiddleware(context, proxyConfig);\n          }\n        };\n\n        /**\n        * Assume a proxy configuration specified as:\n        * proxy: [\n        *   {\n        *     context: ...,\n        *     ...options...\n        *   },\n        *   // or:\n        *   function() {\n        *     return {\n        *       context: ...,\n        *       ...options...\n        *     };\n        *   }\n        * ]\n        */\n        options.proxy.forEach((proxyConfigOrCallback) => {\n          let proxyConfig;\n          let proxyMiddleware;\n\n          if (typeof proxyConfigOrCallback === 'function') {\n            proxyConfig = proxyConfigOrCallback();\n          } else {\n            proxyConfig = proxyConfigOrCallback;\n          }\n\n          proxyMiddleware = getProxyMiddleware(proxyConfig);\n          if (proxyConfig.ws) {\n            websocketProxies.push(proxyMiddleware);\n          }\n\n          app.use((req, res, next) => {\n            if (typeof proxyConfigOrCallback === 'function') {\n              const newProxyConfig = proxyConfigOrCallback();\n              if (newProxyConfig !== proxyConfig) {\n                proxyConfig = newProxyConfig;\n                proxyMiddleware = getProxyMiddleware(proxyConfig);\n              }\n            }\n            const bypass = typeof proxyConfig.bypass === 'function';\n            // eslint-disable-next-line\n            const bypassUrl = bypass && proxyConfig.bypass(req, res, proxyConfig) || false;\n\n            if (bypassUrl) {\n              req.url = bypassUrl;\n              next();\n            } else if (proxyMiddleware) {\n              return proxyMiddleware(req, res, next);\n            } else {\n              next();\n            }\n          });\n        });\n      }\n    },\n\n    historyApiFallback() {\n      if (options.historyApiFallback) {\n        // Fall back to /index.html if nothing else matches.\n        app.use(historyApiFallback(typeof options.historyApiFallback === 'object' ? options.historyApiFallback : null));\n      }\n    },\n\n    contentBaseFiles: () => {\n      if (Array.isArray(contentBase)) {\n        contentBase.forEach((item) => {\n          app.get('*', express.static(item));\n        });\n      } else if (/^(https?:)?\\/\\//.test(contentBase)) {\n        this.log.warn('Using a URL as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');\n        this.log.warn('proxy: {\\n\\t\"*\": \"<your current contentBase configuration>\"\\n}'); // eslint-disable-line quotes\n        // Redirect every request to contentBase\n        app.get('*', (req, res) => {\n          res.writeHead(302, {\n            Location: contentBase + req.path + (req._parsedUrl.search || '')\n          });\n          res.end();\n        });\n      } else if (typeof contentBase === 'number') {\n        this.log.warn('Using a number as contentBase is deprecated and will be removed in the next major version. Please use the proxy option instead.');\n        this.log.warn('proxy: {\\n\\t\"*\": \"//localhost:<your current contentBase configuration>\"\\n}'); // eslint-disable-line quotes\n        // Redirect every request to the port contentBase\n        app.get('*', (req, res) => {\n          res.writeHead(302, {\n            Location: `//localhost:${contentBase}${req.path}${req._parsedUrl.search || ''}`\n          });\n          res.end();\n        });\n      } else {\n        // route content request\n        app.get('*', express.static(contentBase, options.staticOptions));\n      }\n    },\n\n    contentBaseIndex() {\n      if (Array.isArray(contentBase)) {\n        contentBase.forEach((item) => {\n          app.get('*', serveIndex(item));\n        });\n      } else if (!/^(https?:)?\\/\\//.test(contentBase) && typeof contentBase !== 'number') {\n        app.get('*', serveIndex(contentBase));\n      }\n    },\n\n    watchContentBase: () => {\n      if (/^(https?:)?\\/\\//.test(contentBase) || typeof contentBase === 'number') {\n        throw new Error('Watching remote files is not supported.');\n      } else if (Array.isArray(contentBase)) {\n        contentBase.forEach((item) => {\n          this._watch(item);\n        });\n      } else {\n        this._watch(contentBase);\n      }\n    },\n\n    before: () => {\n      if (typeof options.before === 'function') {\n        options.before(app, this);\n      }\n    },\n\n    middleware: () => {\n      // include our middleware to ensure it is able to handle '/index.html' request after redirect\n      app.use(this.middleware);\n    },\n\n    after: () => {\n      if (typeof options.after === 'function') { options.after(app, this); }\n    },\n\n    headers: () => {\n      app.all('*', this.setContentHeaders.bind(this));\n    },\n\n    magicHtml: () => {\n      app.get('*', this.serveMagicHtml.bind(this));\n    },\n\n    setup: () => {\n      if (typeof options.setup === 'function') {\n        this.log.warn('The `setup` option is deprecated and will be removed in v3. Please update your config to use `before`');\n        options.setup(app, this);\n      }\n    }\n  };\n\n  const defaultFeatures = ['before', 'setup', 'headers', 'middleware'];\n  if (options.proxy) { defaultFeatures.push('proxy', 'middleware'); }\n  if (contentBase !== false) { defaultFeatures.push('contentBaseFiles'); }\n  if (options.watchContentBase) { defaultFeatures.push('watchContentBase'); }\n  if (options.historyApiFallback) {\n    defaultFeatures.push('historyApiFallback', 'middleware');\n    if (contentBase !== false) { defaultFeatures.push('contentBaseFiles'); }\n  }\n  defaultFeatures.push('magicHtml');\n  if (contentBase !== false) { defaultFeatures.push('contentBaseIndex'); }\n  // compress is placed last and uses unshift so that it will be the first middleware used\n  if (options.compress) { defaultFeatures.unshift('compress'); }\n  if (options.after) { defaultFeatures.push('after'); }\n\n  (options.features || defaultFeatures).forEach((feature) => {\n    features[feature]();\n  });\n\n  if (options.https) {\n    // for keep supporting CLI parameters\n    if (typeof options.https === 'boolean') {\n      options.https = {\n        key: options.key,\n        cert: options.cert,\n        ca: options.ca,\n        pfx: options.pfx,\n        passphrase: options.pfxPassphrase,\n        requestCert: options.requestCert || false\n      };\n    }\n\n    let fakeCert;\n    if (!options.https.key || !options.https.cert) {\n      // Use a self-signed certificate if no certificate was configured.\n      // Cycle certs every 24 hours\n      const certPath = path.join(__dirname, '../ssl/server.pem');\n      let certExists = fs.existsSync(certPath);\n\n      if (certExists) {\n        const certStat = fs.statSync(certPath);\n        const certTtl = 1000 * 60 * 60 * 24;\n        const now = new Date();\n\n        // cert is more than 30 days old, kill it with fire\n        if ((now - certStat.ctime) / certTtl > 30) {\n          this.log.info('SSL Certificate is more than 30 days old. Removing.');\n          del.sync([certPath], { force: true });\n          certExists = false;\n        }\n      }\n\n      if (!certExists) {\n        this.log.info('Generating SSL Certificate');\n        const attrs = [{ name: 'commonName', value: 'localhost' }];\n        const pems = selfsigned.generate(attrs, {\n          algorithm: 'sha256',\n          days: 30,\n          keySize: 2048,\n          extensions: [{\n            name: 'basicConstraints',\n            cA: true\n          }, {\n            name: 'keyUsage',\n            keyCertSign: true,\n            digitalSignature: true,\n            nonRepudiation: true,\n            keyEncipherment: true,\n            dataEncipherment: true\n          }, {\n            name: 'subjectAltName',\n            altNames: [\n              {\n                // type 2 is DNS\n                type: 2,\n                value: 'localhost'\n              },\n              {\n                type: 2,\n                value: 'localhost.localdomain'\n              },\n              {\n                type: 2,\n                value: 'lvh.me'\n              },\n              {\n                type: 2,\n                value: '*.lvh.me'\n              },\n              {\n                type: 2,\n                value: '[::1]'\n              },\n              {\n                // type 7 is IP\n                type: 7,\n                ip: '127.0.0.1'\n              },\n              {\n                type: 7,\n                ip: 'fe80::1'\n              }\n            ]\n          }]\n        });\n\n        fs.writeFileSync(certPath, pems.private + pems.cert, { encoding: 'utf-8' });\n      }\n      fakeCert = fs.readFileSync(certPath);\n    }\n\n    options.https.key = options.https.key || fakeCert;\n    options.https.cert = options.https.cert || fakeCert;\n\n    if (!options.https.spdy) {\n      options.https.spdy = {\n        protocols: ['h2', 'http/1.1']\n      };\n    }\n\n    this.listeningApp = spdy.createServer(options.https, app);\n  } else {\n    this.listeningApp = http.createServer(app);\n  }\n\n  killable(this.listeningApp);\n\n  // Proxy websockets without the initial http request\n  // https://github.com/chimurai/http-proxy-middleware#external-websocket-upgrade\n  websocketProxies.forEach(function (wsProxy) {\n    this.listeningApp.on('upgrade', wsProxy.upgrade);\n  }, this);\n}\n\nServer.prototype.use = function () {\n  // eslint-disable-next-line\n  this.app.use.apply(this.app, arguments);\n};\n\nServer.prototype.setContentHeaders = function (req, res, next) {\n  if (this.headers) {\n    for (const name in this.headers) { // eslint-disable-line\n      res.setHeader(name, this.headers[name]);\n    }\n  }\n\n  next();\n};\n\nServer.prototype.checkHost = function (headers, headerToCheck) {\n  // allow user to opt-out this security check, at own risk\n  if (this.disableHostCheck) return true;\n\n  if (!headerToCheck) headerToCheck = \"host\";\n\n  // get the Host header and extract hostname\n  // we don't care about port not matching\n  const hostHeader = headers[headerToCheck];\n  if (!hostHeader) return false;\n\n  // use the node url-parser to retrieve the hostname from the host-header.\n  const hostname = url.parse(`//${hostHeader}`, false, true).hostname;\n\n  // always allow requests with explicit IPv4 or IPv6-address.\n  // A note on IPv6 addresses: hostHeader will always contain the brackets denoting\n  // an IPv6-address in URLs, these are removed from the hostname in url.parse(),\n  // so we have the pure IPv6-address in hostname.\n  if (ip.isV4Format(hostname) || ip.isV6Format(hostname)) return true;\n\n  // always allow localhost host, for convience\n  if (hostname === 'localhost') return true;\n\n  // allow if hostname is in allowedHosts\n  if (this.allowedHosts && this.allowedHosts.length) {\n    for (let hostIdx = 0; hostIdx < this.allowedHosts.length; hostIdx++) {\n      const allowedHost = this.allowedHosts[hostIdx];\n      if (allowedHost === hostname) return true;\n\n      // support \".\" as a subdomain wildcard\n      // e.g. \".example.com\" will allow \"example.com\", \"www.example.com\", \"subdomain.example.com\", etc\n      if (allowedHost[0] === '.') {\n        // \"example.com\"\n        if (hostname === allowedHost.substring(1)) return true;\n        // \"*.example.com\"\n        if (hostname.endsWith(allowedHost)) return true;\n      }\n    }\n  }\n\n  // allow hostname of listening adress\n  if (hostname === this.listenHostname) return true;\n\n  // also allow public hostname if provided\n  if (typeof this.publicHost === 'string') {\n    const idxPublic = this.publicHost.indexOf(':');\n    const publicHostname = idxPublic >= 0 ? this.publicHost.substr(0, idxPublic) : this.publicHost;\n    if (hostname === publicHostname) return true;\n  }\n\n  // disallow\n  return false;\n};\n\n// delegate listen call and init sockjs\nServer.prototype.listen = function (port, hostname, fn) {\n  this.listenHostname = hostname;\n  const returnValue = this.listeningApp.listen(port, hostname, (err) => {\n    const sockServer = sockjs.createServer({\n      // Use provided up-to-date sockjs-client\n      sockjs_url: '/__webpack_dev_server__/sockjs.bundle.js',\n      // Limit useless logs\n      log: (severity, line) => {\n        if (severity === 'error') {\n          this.log.error(line);\n        } else {\n          this.log.debug(line);\n        }\n      }\n    });\n\n    sockServer.on('connection', (conn) => {\n      if (!conn) return;\n      if (!this.checkHost(conn.headers)) {\n        this.sockWrite([conn], 'error', 'Invalid Host header');\n        conn.close();\n        return;\n      }\n      if (!this.checkHost(conn.headers, \"origin\")) {\n        this.sockWrite([conn], 'error', 'Invalid Origin header');\n        conn.close();\n        return;\n      }\n      this.sockets.push(conn);\n\n      conn.on('close', () => {\n        const connIndex = this.sockets.indexOf(conn);\n        if (connIndex >= 0) {\n          this.sockets.splice(connIndex, 1);\n        }\n      });\n\n      if (this.clientLogLevel) { this.sockWrite([conn], 'log-level', this.clientLogLevel); }\n\n      if (this.progress) { this.sockWrite([conn], 'progress', this.progress); }\n\n      if (this.clientOverlay) { this.sockWrite([conn], 'overlay', this.clientOverlay); }\n\n      if (this.hot) this.sockWrite([conn], 'hot');\n\n      if (!this._stats) return;\n      this._sendStats([conn], this._stats.toJson(clientStats), true);\n    });\n\n    sockServer.installHandlers(this.listeningApp, {\n      prefix: '/sockjs-node'\n    });\n\n    if (fn) {\n      fn.call(this.listeningApp, err);\n    }\n  });\n\n  return returnValue;\n};\n\nServer.prototype.close = function (callback) {\n  this.sockets.forEach((sock) => {\n    sock.close();\n  });\n  this.sockets = [];\n\n  this.contentBaseWatchers.forEach((watcher) => {\n    watcher.close();\n  });\n  this.contentBaseWatchers = [];\n\n  this.listeningApp.kill(() => {\n    this.middleware.close(callback);\n  });\n};\n\nServer.prototype.sockWrite = function (sockets, type, data) {\n  sockets.forEach((sock) => {\n    sock.write(JSON.stringify({\n      type,\n      data\n    }));\n  });\n};\n\nServer.prototype.serveMagicHtml = function (req, res, next) {\n  const _path = req.path;\n  try {\n    if (!this.middleware.fileSystem.statSync(this.middleware.getFilenameFromUrl(`${_path}.js`)).isFile()) { return next(); }\n    // Serve a page that executes the javascript\n    res.write('<!DOCTYPE html><html><head><meta charset=\"utf-8\"/></head><body><script type=\"text/javascript\" charset=\"utf-8\" src=\"');\n    res.write(_path);\n    res.write('.js');\n    res.write(req._parsedUrl.search || '');\n    res.end('\"></script></body></html>');\n  } catch (e) {\n    return next();\n  }\n};\n\n// send stats to a socket or multiple sockets\nServer.prototype._sendStats = function (sockets, stats, force) {\n  if (!force &&\n  stats &&\n  (!stats.errors || stats.errors.length === 0) &&\n  stats.assets &&\n  stats.assets.every(asset => !asset.emitted)\n  ) { return this.sockWrite(sockets, 'still-ok'); }\n  this.sockWrite(sockets, 'hash', stats.hash);\n  if (stats.errors.length > 0) { this.sockWrite(sockets, 'errors', stats.errors); } else if (stats.warnings.length > 0) { this.sockWrite(sockets, 'warnings', stats.warnings); } else { this.sockWrite(sockets, 'ok'); }\n};\n\nServer.prototype._watch = function (watchPath) {\n  // duplicate the same massaging of options that watchpack performs\n  // https://github.com/webpack/watchpack/blob/master/lib/DirectoryWatcher.js#L49\n  // this isn't an elegant solution, but we'll improve it in the future\n  const usePolling = this.watchOptions.poll ? true : undefined; // eslint-disable-line no-undefined\n  const interval = typeof this.watchOptions.poll === 'number' ? this.watchOptions.poll : undefined; // eslint-disable-line no-undefined\n  const options = {\n    ignoreInitial: true,\n    persistent: true,\n    followSymlinks: false,\n    depth: 0,\n    atomic: false,\n    alwaysStat: true,\n    ignorePermissionErrors: true,\n    ignored: this.watchOptions.ignored,\n    usePolling,\n    interval\n  };\n  const watcher = chokidar.watch(watchPath, options).on('change', () => {\n    this.sockWrite(this.sockets, 'content-changed');\n  });\n\n  this.contentBaseWatchers.push(watcher);\n};\n\nServer.prototype.invalidate = function () {\n  if (this.middleware) this.middleware.invalidate();\n};\n\n// Export this logic, so that other implementations, like task-runners can use it\nServer.addDevServerEntrypoints = require('./util/addDevServerEntrypoints');\n\nmodule.exports = Server;\n"], "filenames": ["lib/Server.js"], "buggy_code_start_loc": [516], "buggy_code_end_loc": [588], "fixing_code_start_loc": [516], "fixing_code_end_loc": [596], "type": "CWE-20", "message": "An issue was discovered in lib/Server.js in webpack-dev-server before 3.1.6. Attackers are able to steal developer's code because the origin of requests is not checked by the WebSocket server, which is used for HMR (Hot Module Replacement). Anyone can receive the HMR message sent by the WebSocket server via a ws://127.0.0.1:8080/ connection from any origin.", "other": {"cve": {"id": "CVE-2018-14732", "sourceIdentifier": "cve@mitre.org", "published": "2018-09-21T17:29:05.373", "lastModified": "2019-08-01T12:14:39.407", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in lib/Server.js in webpack-dev-server before 3.1.6. Attackers are able to steal developer's code because the origin of requests is not checked by the WebSocket server, which is used for HMR (Hot Module Replacement). Anyone can receive the HMR message sent by the WebSocket server via a ws://127.0.0.1:8080/ connection from any origin."}, {"lang": "es", "value": "Se ha descubierto un problema en lib/Server.js en webpack-dev-server en versiones anteriores a la 3.1.6. Los atacantes pueden robar el c\u00f3digo del desarrollador porque el origen de las peticiones no es comprobado por el servidor WebSocket, utilizado para HMR (Hot Module Replacement). Cualquiera puede recibir el mensaje HMR enviado por el servidor WebSocket mediante una conexi\u00f3n ws://127.0.0.1:8080/ desde cualquier origen."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webpack.js:webpack-dev-server:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.6", "matchCriteriaId": "1E85B089-7EBB-4201-9F59-A3EB1C561D43"}]}]}], "references": [{"url": "https://blog.cal1.cn/post/Sniffing%20Codes%20in%20Hot%20Module%20Reloading%20Messages", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/webpack/webpack-dev-server/commit/f18e5adf123221a1015be63e1ca2491ca45b8d10", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/webpack/webpack-dev-server/issues/1445", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webpack/webpack-dev-server/commit/f18e5adf123221a1015be63e1ca2491ca45b8d10"}}