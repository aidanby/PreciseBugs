{"buggy_code": ["/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n'use strict';\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nvar SVGElement,\n\tSVGRenderer,\n\n\taddEvent = H.addEvent,\n\tanimate = H.animate,\n\tattr = H.attr,\n\tcharts = H.charts,\n\tcolor = H.color,\n\tcss = H.css,\n\tcreateElement = H.createElement,\n\tdefined = H.defined,\n\tdeg2rad = H.deg2rad,\n\tdestroyObjectProperties = H.destroyObjectProperties,\n\tdoc = H.doc,\n\teach = H.each,\n\textend = H.extend,\n\terase = H.erase,\n\tgrep = H.grep,\n\thasTouch = H.hasTouch,\n\tinArray = H.inArray,\n\tisArray = H.isArray,\n\tisFirefox = H.isFirefox,\n\tisMS = H.isMS,\n\tisObject = H.isObject,\n\tisString = H.isString,\n\tisWebKit = H.isWebKit,\n\tmerge = H.merge,\n\tnoop = H.noop,\n\tobjectEach = H.objectEach,\n\tpick = H.pick,\n\tpInt = H.pInt,\n\tremoveEvent = H.removeEvent,\n\tsplat = H.splat,\n\tstop = H.stop,\n\tsvg = H.svg,\n\tSVG_NS = H.SVG_NS,\n\tsymbolSizes = H.symbolSizes,\n\twin = H.win;\n\n/**\n * @typedef {Object} SVGDOMElement - An SVG DOM element.\n */\n/**\n * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n * rendering layer of Highcharts. Combined with the {@link\n * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation\n * in the charts or even in HTML pages without instanciating a chart. The\n * SVGElement can also wrap HTML labels, when `text` or `label` elements are\n * created with the `useHTML` parameter.\n *\n * The SVGElement instances are created through factory functions on the \n * {@link Highcharts.SVGRenderer} object, like\n * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link\n * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},\n * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link\n * Highcharts.SVGRenderer#g} and more.\n *\n * @class Highcharts.SVGElement\n */\nSVGElement = H.SVGElement = function () {\n\treturn this;\n};\nextend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {\n\n\t// Default base for animation\n\topacity: 1,\n\tSVG_NS: SVG_NS,\n\n\t/**\n\t * For labels, these CSS properties are applied to the `text` node directly.\n\t *\n\t * @private\n\t * @type {Array.<string>}\n\t */\n\ttextProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',\n\t\t'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',\n\t\t'textDecoration', 'textOverflow', 'textOutline'],\n\n\t/**\n\t * Initialize the SVG element. This function only exists to make the\n\t * initiation process overridable. It should not be called directly.\n\t *\n\t * @param  {SVGRenderer} renderer\n\t *         The SVGRenderer instance to initialize to.\n\t * @param  {String} nodeName\n\t *         The SVG node name.\n\t * \n\t */\n\tinit: function (renderer, nodeName) {\n\n\t\t/** \n\t\t * The primary DOM node. Each `SVGElement` instance wraps a main DOM\n\t\t * node, but may also represent more nodes.\n\t\t *\n\t\t * @name  element\n\t\t * @memberOf SVGElement\n\t\t * @type {SVGDOMNode|HTMLDOMNode}\n\t\t */\n\t\tthis.element = nodeName === 'span' ?\n\t\t\tcreateElement(nodeName) :\n\t\t\tdoc.createElementNS(this.SVG_NS, nodeName);\n\n\t\t/**\n\t\t * The renderer that the SVGElement belongs to.\n\t\t *\n\t\t * @name renderer\n\t\t * @memberOf SVGElement\n\t\t * @type {SVGRenderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\t},\n\n\t/**\n\t * Animate to given attributes or CSS properties.\n\t * \n\t * @param {SVGAttributes} params SVG attributes or CSS to animate.\n\t * @param {AnimationOptions} [options] Animation options.\n\t * @param {Function} [complete] Function to perform at the end of animation.\n\t *\n\t * @sample highcharts/members/element-on/\n\t *         Setting some attributes by animation\n\t * \n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\tanimate: function (params, options, complete) {\n\t\tvar animOptions = H.animObject(\n\t\t\tpick(options, this.renderer.globalAnimation, true)\n\t\t);\n\t\tif (animOptions.duration !== 0) {\n\t\t\t// allows using a callback with the global animation without\n\t\t\t// overwriting it\n\t\t\tif (complete) {\n\t\t\t\tanimOptions.complete = complete;\n\t\t\t}\n\t\t\tanimate(this, params, animOptions);\n\t\t} else {\n\t\t\tthis.attr(params, null, complete);\n\t\t\tif (animOptions.step) {\n\t\t\t\tanimOptions.step.call(this);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * @typedef {Object} GradientOptions\n\t * @property {Object} linearGradient Holds an object that defines the start\n\t *    position and the end position relative to the shape.\n\t * @property {Number} linearGradient.x1 Start horizontal position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Number} linearGradient.x2 End horizontal position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Number} linearGradient.y1 Start vertical position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Number} linearGradient.y2 End vertical position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Object} radialGradient Holds an object that defines the center\n\t *    position and the radius.\n\t * @property {Number} radialGradient.cx Center horizontal position relative\n\t *    to the shape. Ranges 0-1.\n\t * @property {Number} radialGradient.cy Center vertical position relative\n\t *    to the shape. Ranges 0-1.\n\t * @property {Number} radialGradient.r Radius relative to the shape. Ranges\n\t *    0-1.\n\t * @property {Array.<Array>} stops The first item in each tuple is the\n\t *    position in the gradient, where 0 is the start of the gradient and 1\n\t *    is the end of the gradient. Multiple stops can be applied. The second\n\t *    item is the color for each stop. This color can also be given in the\n\t *    rgba format.\n\t *\n\t * @example\n\t * // Linear gradient used as a color option\n\t * color: {\n\t *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },\n\t *         stops: [\n\t *             [0, '#003399'], // start\n\t *             [0.5, '#ffffff'], // middle\n\t *             [1, '#3366AA'] // end\n\t *         ]\n\t *     }\n\t * }\n\t */\n\t/**\n\t * Build and apply an SVG gradient out of a common JavaScript configuration\n\t * object. This function is called from the attribute setters.\n\t *\n\t * @private\n\t * @param {GradientOptions} color The gradient options structure.\n\t * @param {string} prop The property to apply, can either be `fill` or\n\t * `stroke`. \n\t * @param {SVGDOMElement} elem SVG DOM element to apply the gradient on.\n\t */\n\tcolorGradient: function (color, prop, elem) {\n\t\tvar renderer = this.renderer,\n\t\t\tcolorObject,\n\t\t\tgradName,\n\t\t\tgradAttr,\n\t\t\tradAttr,\n\t\t\tgradients,\n\t\t\tgradientObject,\n\t\t\tstops,\n\t\t\tstopColor,\n\t\t\tstopOpacity,\n\t\t\tradialReference,\n\t\t\tid,\n\t\t\tkey = [],\n\t\t\tvalue;\n\n\t\t// Apply linear or radial gradients\n\t\tif (color.radialGradient) {\n\t\t\tgradName = 'radialGradient';\n\t\t} else if (color.linearGradient) {\n\t\t\tgradName = 'linearGradient';\n\t\t}\n\n\t\tif (gradName) {\n\t\t\tgradAttr = color[gradName];\n\t\t\tgradients = renderer.gradients;\n\t\t\tstops = color.stops;\n\t\t\tradialReference = elem.radialReference;\n\n\t\t\t// Keep < 2.2 kompatibility\n\t\t\tif (isArray(gradAttr)) {\n\t\t\t\tcolor[gradName] = gradAttr = {\n\t\t\t\t\tx1: gradAttr[0],\n\t\t\t\t\ty1: gradAttr[1],\n\t\t\t\t\tx2: gradAttr[2],\n\t\t\t\t\ty2: gradAttr[3],\n\t\t\t\t\tgradientUnits: 'userSpaceOnUse'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Correct the radial gradient for the radial reference system\n\t\t\tif (\n\t\t\t\tgradName === 'radialGradient' &&\n\t\t\t\tradialReference &&\n\t\t\t\t!defined(gradAttr.gradientUnits)\n\t\t\t) {\n\t\t\t\tradAttr = gradAttr; // Save the radial attributes for updating\n\t\t\t\tgradAttr = merge(\n\t\t\t\t\tgradAttr,\n\t\t\t\t\trenderer.getRadialAttr(radialReference, radAttr),\n\t\t\t\t\t{ gradientUnits: 'userSpaceOnUse' }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Build the unique key to detect whether we need to create a new\n\t\t\t// element (#1282)\n\t\t\tobjectEach(gradAttr, function (val, n) {\n\t\t\t\tif (n !== 'id') {\n\t\t\t\t\tkey.push(n, val);\n\t\t\t\t}\n\t\t\t});\n\t\t\tobjectEach(stops, function (val) {\n\t\t\t\tkey.push(val);\n\t\t\t});\n\t\t\tkey = key.join(',');\n\n\t\t\t// Check if a gradient object with the same config object is created\n\t\t\t// within this renderer\n\t\t\tif (gradients[key]) {\n\t\t\t\tid = gradients[key].attr('id');\n\n\t\t\t} else {\n\n\t\t\t\t// Set the id and create the element\n\t\t\t\tgradAttr.id = id = H.uniqueKey();\n\t\t\t\tgradients[key] = gradientObject =\n\t\t\t\t\trenderer.createElement(gradName)\n\t\t\t\t\t\t.attr(gradAttr)\n\t\t\t\t\t\t.add(renderer.defs);\n\n\t\t\t\tgradientObject.radAttr = radAttr;\n\n\t\t\t\t// The gradient needs to keep a list of stops to be able to\n\t\t\t\t// destroy them\n\t\t\t\tgradientObject.stops = [];\n\t\t\t\teach(stops, function (stop) {\n\t\t\t\t\tvar stopObject;\n\t\t\t\t\tif (stop[1].indexOf('rgba') === 0) {\n\t\t\t\t\t\tcolorObject = H.color(stop[1]);\n\t\t\t\t\t\tstopColor = colorObject.get('rgb');\n\t\t\t\t\t\tstopOpacity = colorObject.get('a');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstopColor = stop[1];\n\t\t\t\t\t\tstopOpacity = 1;\n\t\t\t\t\t}\n\t\t\t\t\tstopObject = renderer.createElement('stop').attr({\n\t\t\t\t\t\toffset: stop[0],\n\t\t\t\t\t\t'stop-color': stopColor,\n\t\t\t\t\t\t'stop-opacity': stopOpacity\n\t\t\t\t\t}).add(gradientObject);\n\n\t\t\t\t\t// Add the stop element to the gradient\n\t\t\t\t\tgradientObject.stops.push(stopObject);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Set the reference to the gradient object\n\t\t\tvalue = 'url(' + renderer.url + '#' + id + ')';\n\t\t\telem.setAttribute(prop, value);\n\t\t\telem.gradient = key;\n\n\t\t\t// Allow the color to be concatenated into tooltips formatters etc.\n\t\t\t// (#2995)\n\t\t\tcolor.toString = function () {\n\t\t\t\treturn value;\n\t\t\t};\n\t\t}\n\t},\n\n\t/**\n\t * Apply a text outline through a custom CSS property, by copying the text\n\t * element and apply stroke to the copy. Used internally. Contrast checks\n\t * at http://jsfiddle.net/highcharts/43soe9m1/2/ .\n\t *\n\t * @private\n\t * @param {String} textOutline A custom CSS `text-outline` setting, defined\n\t *    by `width color`. \n\t * @example\n\t * // Specific color\n\t * text.css({\n\t *    textOutline: '1px black'\n\t * });\n\t * // Automatic contrast\n\t * text.css({\n\t *    color: '#000000', // black text\n\t *    textOutline: '1px contrast' // => white outline\n\t * });\n\t */\n\tapplyTextOutline: function (textOutline) {\n\t\tvar elem = this.element,\n\t\t\ttspans,\n\t\t\ttspan,\n\t\t\thasContrast = textOutline.indexOf('contrast') !== -1,\n\t\t\tstyles = {},\n\t\t\tcolor,\n\t\t\tstrokeWidth,\n\t\t\tfirstRealChild,\n\t\t\ti;\n\n\t\t// When the text shadow is set to contrast, use dark stroke for light\n\t\t// text and vice versa.\n\t\tif (hasContrast) {\n\t\t\tstyles.textOutline = textOutline = textOutline.replace(\n\t\t\t\t/contrast/g,\n\t\t\t\tthis.renderer.getContrast(elem.style.fill)\n\t\t\t);\n\t\t}\n\n\t\t// Extract the stroke width and color\n\t\ttextOutline = textOutline.split(' ');\n\t\tcolor = textOutline[textOutline.length - 1];\n\t\tstrokeWidth = textOutline[0];\n\n\t\tif (strokeWidth && strokeWidth !== 'none' && H.svg) {\n\n\t\t\tthis.fakeTS = true; // Fake text shadow\n\n\t\t\ttspans = [].slice.call(elem.getElementsByTagName('tspan'));\n\n\t\t\t// In order to get the right y position of the clone,\n\t\t\t// copy over the y setter\n\t\t\tthis.ySetter = this.xSetter;\n\n\t\t\t// Since the stroke is applied on center of the actual outline, we\n\t\t\t// need to double it to get the correct stroke-width outside the \n\t\t\t// glyphs.\n\t\t\tstrokeWidth = strokeWidth.replace(\n\t\t\t\t/(^[\\d\\.]+)(.*?)$/g,\n\t\t\t\tfunction (match, digit, unit) {\n\t\t\t\t\treturn (2 * digit) + unit;\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\t// Remove shadows from previous runs. Iterate from the end to\n\t\t\t// support removing items inside the cycle (#6472).\n\t\t\ti = tspans.length;\n\t\t\twhile (i--) {\n\t\t\t\ttspan = tspans[i];\n\t\t\t\tif (tspan.getAttribute('class') === 'highcharts-text-outline') {\n\t\t\t\t\t// Remove then erase\n\t\t\t\t\terase(tspans, elem.removeChild(tspan));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For each of the tspans, create a stroked copy behind it.\n\t\t\tfirstRealChild = elem.firstChild;\n\t\t\teach(tspans, function (tspan, y) {\n\t\t\t\tvar clone;\n\n\t\t\t\t// Let the first line start at the correct X position\n\t\t\t\tif (y === 0) {\n\t\t\t\t\ttspan.setAttribute('x', elem.getAttribute('x'));\n\t\t\t\t\ty = elem.getAttribute('y');\n\t\t\t\t\ttspan.setAttribute('y', y || 0);\n\t\t\t\t\tif (y === null) {\n\t\t\t\t\t\telem.setAttribute('y', 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create the clone and apply outline properties\n\t\t\t\tclone = tspan.cloneNode(1);\n\t\t\t\tattr(clone, {\n\t\t\t\t\t'class': 'highcharts-text-outline',\n\t\t\t\t\t'fill': color,\n\t\t\t\t\t'stroke': color,\n\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t'stroke-linejoin': 'round'\n\t\t\t\t});\n\t\t\t\telem.insertBefore(clone, firstRealChild);\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t *\n\t * @typedef {Object} SVGAttributes An object of key-value pairs for SVG\n\t *   attributes. Attributes in Highcharts elements for the most parts\n\t *   correspond to SVG, but some are specific to Highcharts, like `zIndex`,\n\t *   `rotation`, `rotationOriginX`, `rotationOriginY`, `translateX`,\n\t *   `translateY`, `scaleX` and `scaleY`. SVG attributes containing a hyphen\n\t *   are _not_ camel-cased, they should be quoted to preserve the hyphen.\n\t *   \n\t * @example\n\t * {\n\t *     'stroke': '#ff0000', // basic\n\t *     'stroke-width': 2, // hyphenated\n\t *     'rotation': 45 // custom\n\t *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n\t * }\n\t */\n\t/**\n\t * Apply native and custom attributes to the SVG elements.\n\t * \n\t * In order to set the rotation center for rotation, set x and y to 0 and\n\t * use `translateX` and `translateY` attributes to position the element\n\t * instead.\n\t *\n\t * Attributes frequently used in Highcharts are `fill`, `stroke`,\n\t * `stroke-width`.\n\t *\n\t * @param {SVGAttributes|String} hash - The native and custom SVG\n\t *    attributes. \n\t * @param {string} [val] - If the type of the first argument is `string`, \n\t *    the second can be a value, which will serve as a single attribute\n\t *    setter. If the first argument is a string and the second is undefined,\n\t *    the function serves as a getter and the current value of the property\n\t *    is returned.\n\t * @param {Function} [complete] - A callback function to execute after\n\t *    setting the attributes. This makes the function compliant and\n\t *    interchangeable with the {@link SVGElement#animate} function.\n\t * @param {boolean} [continueAnimation=true] Used internally when `.attr` is\n\t *    called as part of an animation step. Otherwise, calling `.attr` for an\n\t *    attribute will stop animation for that attribute.\n\t *    \n\t * @returns {SVGElement|string|number} If used as a setter, it returns the \n\t *    current {@link SVGElement} so the calls can be chained. If used as a \n\t *    getter, the current value of the attribute is returned.\n\t *\n\t * @sample highcharts/members/renderer-rect/\n\t *         Setting some attributes\n\t * \n\t * @example\n\t * // Set multiple attributes\n\t * element.attr({\n\t *     stroke: 'red',\n\t *     fill: 'blue',\n\t *     x: 10,\n\t *     y: 10\n\t * });\n\t *\n\t * // Set a single attribute\n\t * element.attr('stroke', 'red');\n\t *\n\t * // Get an attribute\n\t * element.attr('stroke'); // => 'red'\n\t * \n\t */\n\tattr: function (hash, val, complete, continueAnimation) {\n\t\tvar key,\n\t\t\telement = this.element,\n\t\t\thasSetSymbolSize,\n\t\t\tret = this,\n\t\t\tskipAttr,\n\t\t\tsetter;\n\n\t\t// single key-value pair\n\t\tif (typeof hash === 'string' && val !== undefined) {\n\t\t\tkey = hash;\n\t\t\thash = {};\n\t\t\thash[key] = val;\n\t\t}\n\n\t\t// used as a getter: first argument is a string, second is undefined\n\t\tif (typeof hash === 'string') {\n\t\t\tret = (this[hash + 'Getter'] || this._defaultGetter).call(\n\t\t\t\tthis,\n\t\t\t\thash,\n\t\t\t\telement\n\t\t\t);\n\n\t\t// setter\n\t\t} else {\n\n\t\t\tobjectEach(hash, function eachAttribute(val, key) {\n\t\t\t\tskipAttr = false;\n\t\t\t\t\n\t\t\t\t// Unless .attr is from the animator update, stop current\n\t\t\t\t// running animation of this property\n\t\t\t\tif (!continueAnimation) {\n\t\t\t\t\tstop(this, key);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Special handling of symbol attributes\n\t\t\t\tif (\n\t\t\t\t\tthis.symbolName &&\n\t\t\t\t\t/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/\n\t\t\t\t\t.test(key)\n\t\t\t\t) {\n\t\t\t\t\tif (!hasSetSymbolSize) {\n\t\t\t\t\t\tthis.symbolAttr(hash);\n\t\t\t\t\t\thasSetSymbolSize = true;\n\t\t\t\t\t}\n\t\t\t\t\tskipAttr = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.rotation && (key === 'x' || key === 'y')) {\n\t\t\t\t\tthis.doTransform = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!skipAttr) {\n\t\t\t\t\tsetter = this[key + 'Setter'] || this._defaultSetter;\n\t\t\t\t\tsetter.call(this, val, key, element);\n\t\t\t\t\t\n\t\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\t\t// Let the shadow follow the main element\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.shadows &&\n\t\t\t\t\t\t/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/\n\t\t\t\t\t\t\t.test(key)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.updateShadows(key, val, setter);\n\t\t\t\t\t}\n\t\t\t\t\t/*= } =*/\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\tthis.afterSetters();\n\t\t}\n\n\t\t// In accordance with animate, run a complete callback\n\t\tif (complete) {\n\t\t\tcomplete.call(this);\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t/**\n\t * This method is executed in the end of `attr()`, after setting all\n\t * attributes in the hash. In can be used to efficiently consolidate\n\t * multiple attributes in one SVG property -- e.g., translate, rotate and\n\t * scale are merged in one \"transform\" attribute in the SVG node.\n\t *\n\t * @private\n\t */\n\tafterSetters: function () {\n\t\t// Update transform. Do this outside the loop to prevent redundant\n\t\t// updating for batch setting of attributes.\n\t\tif (this.doTransform) {\n\t\t\tthis.updateTransform();\n\t\t\tthis.doTransform = false;\n\t\t}\n\t},\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * Update the shadow elements with new attributes.\n\t *\n\t * @private\n\t * @param {String} key - The attribute name.\n\t * @param {String|Number} value - The value of the attribute.\n\t * @param {Function} setter - The setter function, inherited from the\n\t *   parent wrapper\n\t * \n\t */\n\tupdateShadows: function (key, value, setter) {\n\t\tvar shadows = this.shadows,\n\t\t\ti = shadows.length;\n\n\t\twhile (i--) {\n\t\t\tsetter.call(\n\t\t\t\tshadows[i], \n\t\t\t\tkey === 'height' ?\n\t\t\t\t\tMath.max(value - (shadows[i].cutHeight || 0), 0) :\n\t\t\t\t\tkey === 'd' ? this.d : value, \n\t\t\t\tkey, \n\t\t\t\tshadows[i]\n\t\t\t);\n\t\t}\n\t},\n\t/*= } =*/\n\n\t/**\n\t * Add a class name to an element.\n\t *\n\t * @param {string} className - The new class name to add.\n\t * @param {boolean} [replace=false] - When true, the existing class name(s)\n\t *    will be overwritten with the new one. When false, the new one is\n\t *    added.\n\t * @returns {SVGElement} Return the SVG element for chainability.\n\t */\n\taddClass: function (className, replace) {\n\t\tvar currentClassName = this.attr('class') || '';\n\t\tif (currentClassName.indexOf(className) === -1) {\n\t\t\tif (!replace) {\n\t\t\t\tclassName = \n\t\t\t\t\t(currentClassName + (currentClassName ? ' ' : '') +\n\t\t\t\t\tclassName).replace('  ', ' ');\n\t\t\t}\n\t\t\tthis.attr('class', className);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Check if an element has the given class name.\n\t * @param  {string} className\n\t *         The class name to check for.\n\t * @return {Boolean}\n\t *         Whether the class name is found.\n\t */\n\thasClass: function (className) {\n\t\treturn inArray(\n\t\t\tclassName,\n\t\t\t(this.attr('class') || '').split(' ')\n\t\t) !== -1;\n\t},\n\n\t/**\n\t * Remove a class name from the element.\n\t * @param  {String|RegExp} className The class name to remove.\n\t * @return {SVGElement} Returns the SVG element for chainability.\n\t */\n\tremoveClass: function (className) {\n\t\treturn this.attr(\n\t\t\t'class',\n\t\t\t(this.attr('class') || '').replace(className, '')\n\t\t);\n\t},\n\n\t/**\n\t * If one of the symbol size affecting parameters are changed,\n\t * check all the others only once for each call to an element's\n\t * .attr() method\n\t * @param {Object} hash - The attributes to set.\n\t * @private\n\t */\n\tsymbolAttr: function (hash) {\n\t\tvar wrapper = this;\n\n\t\teach([\n\t\t\t'x',\n\t\t\t'y',\n\t\t\t'r',\n\t\t\t'start',\n\t\t\t'end',\n\t\t\t'width',\n\t\t\t'height',\n\t\t\t'innerR',\n\t\t\t'anchorX',\n\t\t\t'anchorY'\n\t\t], function (key) {\n\t\t\twrapper[key] = pick(hash[key], wrapper[key]);\n\t\t});\n\n\t\twrapper.attr({\n\t\t\td: wrapper.renderer.symbols[wrapper.symbolName](\n\t\t\t\twrapper.x,\n\t\t\t\twrapper.y,\n\t\t\t\twrapper.width,\n\t\t\t\twrapper.height,\n\t\t\t\twrapper\n\t\t\t)\n\t\t});\n\t},\n\n\t/**\n\t * Apply a clipping rectangle to this element.\n\t * \n\t * @param {ClipRect} [clipRect] - The clipping rectangle. If skipped, the\n\t *    current clip is removed.\n\t * @returns {SVGElement} Returns the SVG element to allow chaining.\n\t */\n\tclip: function (clipRect) {\n\t\treturn this.attr(\n\t\t\t'clip-path',\n\t\t\tclipRect ?\n\t\t\t\t'url(' + this.renderer.url + '#' + clipRect.id + ')' :\n\t\t\t\t'none'\n\t\t);\n\t},\n\n\t/**\n\t * Calculate the coordinates needed for drawing a rectangle crisply and\n\t * return the calculated attributes.\n\t * \n\t * @param {Object} rect - A rectangle.\n\t * @param {number} rect.x - The x position.\n\t * @param {number} rect.y - The y position.\n\t * @param {number} rect.width - The width.\n\t * @param {number} rect.height - The height.\n\t * @param {number} [strokeWidth] - The stroke width to consider when\n\t *    computing crisp positioning. It can also be set directly on the rect\n\t *    parameter.\n\t *\n\t * @returns {{x: Number, y: Number, width: Number, height: Number}} The\n\t *    modified rectangle arguments.\n\t */\n\tcrisp: function (rect, strokeWidth) {\n\n\t\tvar wrapper = this,\n\t\t\tnormalizer;\n\n\t\tstrokeWidth = strokeWidth || rect.strokeWidth || 0;\n\t\t// Math.round because strokeWidth can sometimes have roundoff errors\n\t\tnormalizer = Math.round(strokeWidth) % 2 / 2;\n\n\t\t// normalize for crisp edges\n\t\trect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n\t\trect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n\t\trect.width = Math.floor(\n\t\t\t(rect.width || wrapper.width || 0) - 2 * normalizer\n\t\t);\n\t\trect.height = Math.floor(\n\t\t\t(rect.height || wrapper.height || 0) - 2 * normalizer\n\t\t);\n\t\tif (defined(rect.strokeWidth)) {\n\t\t\trect.strokeWidth = strokeWidth;\n\t\t}\n\t\treturn rect;\n\t},\n\n\t/**\n\t * Set styles for the element. In addition to CSS styles supported by \n\t * native SVG and HTML elements, there are also some custom made for \n\t * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n\t * elements.\n\t * @param {CSSObject} styles The new CSS styles.\n\t * @returns {SVGElement} Return the SVG element for chaining.\n\t *\n\t * @sample highcharts/members/renderer-text-on-chart/\n\t *         Styled text\n\t */\n\tcss: function (styles) {\n\t\tvar oldStyles = this.styles,\n\t\t\tnewStyles = {},\n\t\t\telem = this.element,\n\t\t\ttextWidth,\n\t\t\tserializedCss = '',\n\t\t\thyphenate,\n\t\t\thasNew = !oldStyles,\n\t\t\t// These CSS properties are interpreted internally by the SVG\n\t\t\t// renderer, but are not supported by SVG and should not be added to\n\t\t\t// the DOM. In styled mode, no CSS should find its way to the DOM\n\t\t\t// whatsoever (#6173, #6474).\n\t\t\tsvgPseudoProps = ['textOutline', 'textOverflow', 'width'];\n\n\t\t// convert legacy\n\t\tif (styles && styles.color) {\n\t\t\tstyles.fill = styles.color;\n\t\t}\n\n\t\t// Filter out existing styles to increase performance (#2640)\n\t\tif (oldStyles) {\n\t\t\tobjectEach(styles, function (style, n) {\n\t\t\t\tif (style !== oldStyles[n]) {\n\t\t\t\t\tnewStyles[n] = style;\n\t\t\t\t\thasNew = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (hasNew) {\n\n\t\t\t// Merge the new styles with the old ones\n\t\t\tif (oldStyles) {\n\t\t\t\tstyles = extend(\n\t\t\t\t\toldStyles,\n\t\t\t\t\tnewStyles\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get the text width from style\n\t\t\ttextWidth = this.textWidth = (\n\t\t\t\tstyles &&\n\t\t\t\tstyles.width &&\n\t\t\t\tstyles.width !== 'auto' &&\n\t\t\t\telem.nodeName.toLowerCase() === 'text' &&\n\t\t\t\tpInt(styles.width)\n\t\t\t);\n\n\t\t\t// store object\n\t\t\tthis.styles = styles;\n\n\t\t\tif (textWidth && (!svg && this.renderer.forExport)) {\n\t\t\t\tdelete styles.width;\n\t\t\t}\n\n\t\t\t// Serialize and set style attribute\n\t\t\tif (elem.namespaceURI === this.SVG_NS) { // #7633\n\t\t\t\thyphenate = function (a, b) {\n\t\t\t\t\treturn '-' + b.toLowerCase();\n\t\t\t\t};\n\t\t\t\tobjectEach(styles, function (style, n) {\n\t\t\t\t\tif (inArray(n, svgPseudoProps) === -1) {\n\t\t\t\t\t\tserializedCss +=\n\t\t\t\t\t\tn.replace(/([A-Z])/g, hyphenate) + ':' +\n\t\t\t\t\t\tstyle + ';';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (serializedCss) {\n\t\t\t\t\tattr(elem, 'style', serializedCss); // #1881\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcss(elem, styles);\n\t\t\t}\n\n\n\t\t\tif (this.added) {\n\n\t\t\t\t// Rebuild text after added. Cache mechanisms in the buildText\n\t\t\t\t// will prevent building if there are no significant changes.\n\t\t\t\tif (this.element.nodeName === 'text') {\n\t\t\t\t\tthis.renderer.buildText(this);\n\t\t\t\t}\n\n\t\t\t\t// Apply text outline after added\n\t\t\t\tif (styles && styles.textOutline) {\n\t\t\t\t\tthis.applyTextOutline(styles.textOutline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * Get the current stroke width. In classic mode, the setter registers it \n\t * directly on the element.\n\t * @returns {number} The stroke width in pixels.\n\t * @ignore\n\t */\n\tstrokeWidth: function () {\n\t\treturn this['stroke-width'] || 0;\n\t},\n\n\t/*= } else { =*/\n\t/**\n\t * Get the computed style. Only in styled mode.\n\t * @param {string} prop - The property name to check for.\n\t * @returns {string} The current computed value.\n\t * @example\n\t * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'\n\t */\n\tgetStyle: function (prop) {\n\t\treturn win.getComputedStyle(this.element || this, '')\n\t\t\t.getPropertyValue(prop);\n\t},\n\n\t/**\n\t * Get the computed stroke width in pixel values. This is used extensively\n\t * when drawing shapes to ensure the shapes are rendered crisp and\n\t * positioned correctly relative to each other. Using\n\t * `shape-rendering: crispEdges` leaves us less control over positioning,\n\t * for example when we want to stack columns next to each other, or position\n\t * things pixel-perfectly within the plot box.\n\t *\n\t * The common pattern when placing a shape is:\n\t * * Create the SVGElement and add it to the DOM. In styled mode, it will\n\t *   now receive a stroke width from the style sheet. In classic mode we\n\t *   will add the `stroke-width` attribute.\n\t * * Read the computed `elem.strokeWidth()`.\n\t * * Place it based on the stroke width.\n\t *\n\t * @returns {Number} The stroke width in pixels. Even if the given stroke\n\t * widtch (in CSS or by attributes) is based on `em` or other units, the \n\t * pixel size is returned.\n\t */\n\tstrokeWidth: function () {\n\t\tvar val = this.getStyle('stroke-width'),\n\t\t\tret,\n\t\t\tdummy;\n\n\t\t// Read pixel values directly\n\t\tif (val.indexOf('px') === val.length - 2) {\n\t\t\tret = pInt(val);\n\n\t\t// Other values like em, pt etc need to be measured\n\t\t} else {\n\t\t\tdummy = doc.createElementNS(SVG_NS, 'rect');\n\t\t\tattr(dummy, {\n\t\t\t\t'width': val,\n\t\t\t\t'stroke-width': 0\n\t\t\t});\n\t\t\tthis.element.parentNode.appendChild(dummy);\n\t\t\tret = dummy.getBBox().width;\n\t\t\tdummy.parentNode.removeChild(dummy);\n\t\t}\n\t\treturn ret;\n\t},\n\t/*= } =*/\n\t/**\n\t * Add an event listener. This is a simple setter that replaces all other\n\t * events of the same type, opposed to the {@link Highcharts#addEvent}\n\t * function.\n\t * @param {string} eventType - The event type. If the type is `click`, \n\t *    Highcharts will internally translate it to a `touchstart` event on \n\t *    touch devices, to prevent the browser from waiting for a click event\n\t *    from firing.\n\t * @param {Function} handler - The handler callback.\n\t * @returns {SVGElement} The SVGElement for chaining.\n\t *\n\t * @sample highcharts/members/element-on/\n\t *         A clickable rectangle\n\t */\n\ton: function (eventType, handler) {\n\t\tvar svgElement = this,\n\t\t\telement = svgElement.element;\n\n\t\t// touch\n\t\tif (hasTouch && eventType === 'click') {\n\t\t\telement.ontouchstart = function (e) {\n\t\t\t\tsvgElement.touchEventFired = Date.now(); // #2269\n\t\t\t\te.preventDefault();\n\t\t\t\thandler.call(element, e);\n\t\t\t};\n\t\t\telement.onclick = function (e) {\n\t\t\t\tif (win.navigator.userAgent.indexOf('Android') === -1 ||\n\t\t\t\t\t\tDate.now() - (svgElement.touchEventFired || 0) > 1100) {\n\t\t\t\t\thandler.call(element, e);\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\t// simplest possible event model for internal use\n\t\t\telement['on' + eventType] = handler;\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Set the coordinates needed to draw a consistent radial gradient across\n\t * a shape regardless of positioning inside the chart. Used on pie slices\n\t * to make all the slices have the same radial reference point.\n\t *\n\t * @param {Array} coordinates The center reference. The format is\n\t *    `[centerX, centerY, diameter]` in pixels.\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\tsetRadialReference: function (coordinates) {\n\t\tvar existingGradient = this.renderer.gradients[this.element.gradient];\n\n\t\tthis.element.radialReference = coordinates;\n\n\t\t// On redrawing objects with an existing gradient, the gradient needs\n\t\t// to be repositioned (#3801)\n\t\tif (existingGradient && existingGradient.radAttr) {\n\t\t\texistingGradient.animate(\n\t\t\t\tthis.renderer.getRadialAttr(\n\t\t\t\t\tcoordinates,\n\t\t\t\t\texistingGradient.radAttr\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Move an object and its children by x and y values.\n\t * \n\t * @param {number} x - The x value.\n\t * @param {number} y - The y value.\n\t */\n\ttranslate: function (x, y) {\n\t\treturn this.attr({\n\t\t\ttranslateX: x,\n\t\t\ttranslateY: y\n\t\t});\n\t},\n\n\t/**\n\t * Invert a group, rotate and flip. This is used internally on inverted \n\t * charts, where the points and graphs are drawn as if not inverted, then\n\t * the series group elements are inverted.\n\t *\n\t * @param  {boolean} inverted\n\t *         Whether to invert or not. An inverted shape can be un-inverted by\n\t *         setting it to false.\n\t * @return {SVGElement}\n\t *         Return the SVGElement for chaining.\n\t */\n\tinvert: function (inverted) {\n\t\tvar wrapper = this;\n\t\twrapper.inverted = inverted;\n\t\twrapper.updateTransform();\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Update the transform attribute based on internal properties. Deals with\n\t * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n\t * attributes and updates the SVG `transform` attribute.\n\t * @private\n\t * \n\t */\n\tupdateTransform: function () {\n\t\tvar wrapper = this,\n\t\t\ttranslateX = wrapper.translateX || 0,\n\t\t\ttranslateY = wrapper.translateY || 0,\n\t\t\tscaleX = wrapper.scaleX,\n\t\t\tscaleY = wrapper.scaleY,\n\t\t\tinverted = wrapper.inverted,\n\t\t\trotation = wrapper.rotation,\n\t\t\tmatrix = wrapper.matrix,\n\t\t\telement = wrapper.element,\n\t\t\ttransform;\n\n\t\t// Flipping affects translate as adjustment for flipping around the\n\t\t// group's axis\n\t\tif (inverted) {\n\t\t\ttranslateX += wrapper.width;\n\t\t\ttranslateY += wrapper.height;\n\t\t}\n\n\t\t// Apply translate. Nearly all transformed elements have translation,\n\t\t// so instead of checking for translate = 0, do it always (#1767,\n\t\t// #1846).\n\t\ttransform = ['translate(' + translateX + ',' + translateY + ')'];\n\n\t\t// apply matrix\n\t\tif (defined(matrix)) {\n\t\t\ttransform.push(\n\t\t\t\t'matrix(' + matrix.join(',') + ')'\n\t\t\t);\n\t\t}\n\t\t\n\t\t// apply rotation\n\t\tif (inverted) {\n\t\t\ttransform.push('rotate(90) scale(-1,1)');\n\t\t} else if (rotation) { // text rotation\n\t\t\ttransform.push(\n\t\t\t\t'rotate(' + rotation + ' ' +\n\t\t\t\tpick(this.rotationOriginX, element.getAttribute('x'), 0) +\n\t\t\t\t' ' +\n\t\t\t\tpick(this.rotationOriginY, element.getAttribute('y') || 0) + ')'\n\t\t\t);\n\t\t}\n\n\t\t// apply scale\n\t\tif (defined(scaleX) || defined(scaleY)) {\n\t\t\ttransform.push(\n\t\t\t\t'scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')'\n\t\t\t);\n\t\t}\n\n\t\tif (transform.length) {\n\t\t\telement.setAttribute('transform', transform.join(' '));\n\t\t}\n\t},\n\n\t/**\n\t * Bring the element to the front. Alternatively, a new zIndex can be set.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t *\n\t * @sample highcharts/members/element-tofront/\n\t *         Click an element to bring it to front\n\t */\n\ttoFront: function () {\n\t\tvar element = this.element;\n\t\telement.parentNode.appendChild(element);\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Align the element relative to the chart or another box.\n\t * \n\t * @param {Object} [alignOptions] The alignment options. The function can be\n\t *   called without this parameter in order to re-align an element after the\n\t *   box has been updated.\n\t * @param {string} [alignOptions.align=left] Horizontal alignment. Can be\n\t *   one of `left`, `center` and `right`.\n\t * @param {string} [alignOptions.verticalAlign=top] Vertical alignment. Can\n\t *   be one of `top`, `middle` and `bottom`.\n\t * @param {number} [alignOptions.x=0] Horizontal pixel offset from\n\t *   alignment.\n\t * @param {number} [alignOptions.y=0] Vertical pixel offset from alignment.\n\t * @param {Boolean} [alignByTranslate=false] Use the `transform` attribute\n\t *   with translateX and translateY custom attributes to align this elements\n\t *   rather than `x` and `y` attributes.\n\t * @param {String|Object} box The box to align to, needs a width and height.\n\t *   When the box is a string, it refers to an object in the Renderer. For\n\t *   example, when box is `spacingBox`, it refers to `Renderer.spacingBox`\n\t *   which holds `width`, `height`, `x` and `y` properties.\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\talign: function (alignOptions, alignByTranslate, box) {\n\t\tvar align,\n\t\t\tvAlign,\n\t\t\tx,\n\t\t\ty,\n\t\t\tattribs = {},\n\t\t\talignTo,\n\t\t\trenderer = this.renderer,\n\t\t\talignedObjects = renderer.alignedObjects,\n\t\t\talignFactor,\n\t\t\tvAlignFactor;\n\n\t\t// First call on instanciate\n\t\tif (alignOptions) {\n\t\t\tthis.alignOptions = alignOptions;\n\t\t\tthis.alignByTranslate = alignByTranslate;\n\t\t\tif (!box || isString(box)) {\n\t\t\t\tthis.alignTo = alignTo = box || 'renderer';\n\t\t\t\t// prevent duplicates, like legendGroup after resize\n\t\t\t\terase(alignedObjects, this);\n\t\t\t\talignedObjects.push(this);\n\t\t\t\tbox = null; // reassign it below\n\t\t\t}\n\n\t\t// When called on resize, no arguments are supplied\n\t\t} else {\n\t\t\talignOptions = this.alignOptions;\n\t\t\talignByTranslate = this.alignByTranslate;\n\t\t\talignTo = this.alignTo;\n\t\t}\n\n\t\tbox = pick(box, renderer[alignTo], renderer);\n\n\t\t// Assign variables\n\t\talign = alignOptions.align;\n\t\tvAlign = alignOptions.verticalAlign;\n\t\tx = (box.x || 0) + (alignOptions.x || 0); // default: left align\n\t\ty = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n\t\t// Align\n\t\tif (align === 'right') {\n\t\t\talignFactor = 1;\n\t\t} else if (align === 'center') {\n\t\t\talignFactor = 2;\n\t\t}\n\t\tif (alignFactor) {\n\t\t\tx += (box.width - (alignOptions.width || 0)) / alignFactor;\n\t\t}\n\t\tattribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n\n\n\t\t// Vertical align\n\t\tif (vAlign === 'bottom') {\n\t\t\tvAlignFactor = 1;\n\t\t} else if (vAlign === 'middle') {\n\t\t\tvAlignFactor = 2;\n\t\t}\n\t\tif (vAlignFactor) {\n\t\t\ty += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n\t\t}\n\t\tattribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n\n\t\t// Animate only if already placed\n\t\tthis[this.placed ? 'animate' : 'attr'](attribs);\n\t\tthis.placed = true;\n\t\tthis.alignAttr = attribs;\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Get the bounding box (width, height, x and y) for the element. Generally\n\t * used to get rendered text size. Since this is called a lot in charts,\n\t * the results are cached based on text properties, in order to save DOM\n\t * traffic. The returned bounding box includes the rotation, so for example\n\t * a single text line of rotation 90 will report a greater height, and a\n\t * width corresponding to the line-height.\n\t *\n\t * @param {boolean} [reload] Skip the cache and get the updated DOM bouding\n\t *   box.\n\t * @param {number} [rot] Override the element's rotation. This is internally\n\t *   used on axis labels with a value of 0 to find out what the bounding box\n\t *   would be have been if it were not rotated.\n\t * @returns {Object} The bounding box with `x`, `y`, `width` and `height`\n\t * properties.\n\t *\n\t * @sample highcharts/members/renderer-on-chart/\n\t *         Draw a rectangle based on a text's bounding box\n\t */\n\tgetBBox: function (reload, rot) {\n\t\tvar wrapper = this,\n\t\t\tbBox, // = wrapper.bBox,\n\t\t\trenderer = wrapper.renderer,\n\t\t\twidth,\n\t\t\theight,\n\t\t\trotation,\n\t\t\trad,\n\t\t\telement = wrapper.element,\n\t\t\tstyles = wrapper.styles,\n\t\t\tfontSize,\n\t\t\ttextStr = wrapper.textStr,\n\t\t\ttoggleTextShadowShim,\n\t\t\tcache = renderer.cache,\n\t\t\tcacheKeys = renderer.cacheKeys,\n\t\t\tcacheKey;\n\n\t\trotation = pick(rot, wrapper.rotation);\n\t\trad = rotation * deg2rad;\n\n\t\t/*= if (build.classic) { =*/\n\t\tfontSize = styles && styles.fontSize;\n\t\t/*= } else { =*/\n\t\tfontSize = element &&\n\t\t\tSVGElement.prototype.getStyle.call(element, 'font-size');\n\t\t/*= } =*/\n\n\t\t// Avoid undefined and null (#7316)\n\t\tif (defined(textStr)) {\n\n\t\t\tcacheKey = textStr.toString();\n\t\t\t\n\t\t\t// Since numbers are monospaced, and numerical labels appear a lot\n\t\t\t// in a chart, we assume that a label of n characters has the same\n\t\t\t// bounding box as others of the same length. Unless there is inner\n\t\t\t// HTML in the label. In that case, leave the numbers as is (#5899).\n\t\t\tif (cacheKey.indexOf('<') === -1) {\n\t\t\t\tcacheKey = cacheKey.replace(/[0-9]/g, '0');\n\t\t\t}\n\n\t\t\t// Properties that affect bounding box\n\t\t\tcacheKey += [\n\t\t\t\t'',\n\t\t\t\trotation || 0,\n\t\t\t\tfontSize,\n\t\t\t\tstyles && styles.width,\n\t\t\t\tstyles && styles.textOverflow // #5968\n\t\t\t]\n\t\t\t.join(',');\n\n\t\t}\n\n\t\tif (cacheKey && !reload) {\n\t\t\tbBox = cache[cacheKey];\n\t\t}\n\n\t\t// No cache found\n\t\tif (!bBox) {\n\n\t\t\t// SVG elements\n\t\t\tif (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n\t\t\t\ttry { // Fails in Firefox if the container has display: none.\n\n\t\t\t\t\t// When the text shadow shim is used, we need to hide the\n\t\t\t\t\t// fake shadows to get the correct bounding box (#3872)\n\t\t\t\t\ttoggleTextShadowShim = this.fakeTS && function (display) {\n\t\t\t\t\t\teach(\n\t\t\t\t\t\t\telement.querySelectorAll(\n\t\t\t\t\t\t\t\t'.highcharts-text-outline'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction (tspan) {\n\t\t\t\t\t\t\t\ttspan.style.display = display;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t// Workaround for #3842, Firefox reporting wrong bounding\n\t\t\t\t\t// box for shadows\n\t\t\t\t\tif (toggleTextShadowShim) {\n\t\t\t\t\t\ttoggleTextShadowShim('none');\n\t\t\t\t\t}\n\n\t\t\t\t\tbBox = element.getBBox ?\n\t\t\t\t\t\t// SVG: use extend because IE9 is not allowed to change\n\t\t\t\t\t\t// width and height in case of rotation (below)\n\t\t\t\t\t\textend({}, element.getBBox()) : {\n\n\t\t\t\t\t\t\t// Legacy IE in export mode\n\t\t\t\t\t\t\twidth: element.offsetWidth,\n\t\t\t\t\t\t\theight: element.offsetHeight\n\t\t\t\t\t\t};\n\n\t\t\t\t\t// #3842\n\t\t\t\t\tif (toggleTextShadowShim) {\n\t\t\t\t\t\ttoggleTextShadowShim('');\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// If the bBox is not set, the try-catch block above failed. The\n\t\t\t\t// other condition is for Opera that returns a width of\n\t\t\t\t// -Infinity on hidden elements.\n\t\t\t\tif (!bBox || bBox.width < 0) {\n\t\t\t\t\tbBox = { width: 0, height: 0 };\n\t\t\t\t}\n\n\n\t\t\t// VML Renderer or useHTML within SVG\n\t\t\t} else {\n\n\t\t\t\tbBox = wrapper.htmlGetBBox();\n\n\t\t\t}\n\n\t\t\t// True SVG elements as well as HTML elements in modern browsers\n\t\t\t// using the .useHTML option need to compensated for rotation\n\t\t\tif (renderer.isSVG) {\n\t\t\t\twidth = bBox.width;\n\t\t\t\theight = bBox.height;\n\n\t\t\t\t// Workaround for wrong bounding box in IE, Edge and Chrome on\n\t\t\t\t// Windows. With Highcharts' default font, IE and Edge report\n\t\t\t\t// a box height of 16.899 and Chrome rounds it to 17. If this \n\t\t\t\t// stands uncorrected, it results in more padding added below\n\t\t\t\t// the text than above when adding a label border or background.\n\t\t\t\t// Also vertical positioning is affected.\n\t\t\t\t// http://jsfiddle.net/highcharts/em37nvuj/\n\t\t\t\t// (#1101, #1505, #1669, #2568, #6213).\n\t\t\t\tif (\n\t\t\t\t\tstyles &&\n\t\t\t\t\tstyles.fontSize === '11px' &&\n\t\t\t\t\tMath.round(height) === 17\n\t\t\t\t) {\n\t\t\t\t\tbBox.height = height = 14;\n\t\t\t\t}\n\n\t\t\t\t// Adjust for rotated text\n\t\t\t\tif (rotation) {\n\t\t\t\t\tbBox.width = Math.abs(height * Math.sin(rad)) +\n\t\t\t\t\t\tMath.abs(width * Math.cos(rad));\n\t\t\t\t\tbBox.height = Math.abs(height * Math.cos(rad)) +\n\t\t\t\t\t\tMath.abs(width * Math.sin(rad));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache it. When loading a chart in a hidden iframe in Firefox and\n\t\t\t// IE/Edge, the bounding box height is 0, so don't cache it (#5620).\n\t\t\tif (cacheKey && bBox.height > 0) {\n\n\t\t\t\t// Rotate (#4681)\n\t\t\t\twhile (cacheKeys.length > 250) {\n\t\t\t\t\tdelete cache[cacheKeys.shift()];\n\t\t\t\t}\n\n\t\t\t\tif (!cache[cacheKey]) {\n\t\t\t\t\tcacheKeys.push(cacheKey);\n\t\t\t\t}\n\t\t\t\tcache[cacheKey] = bBox;\n\t\t\t}\n\t\t}\n\t\treturn bBox;\n\t},\n\n\t/**\n\t * Show the element after it has been hidden. \n\t *\n\t * @param {boolean} [inherit=false] Set the visibility attribute to\n\t * `inherit` rather than `visible`. The difference is that an element with\n\t * `visibility=\"visible\"` will be visible even if the parent is hidden.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\tshow: function (inherit) {\n\t\treturn this.attr({ visibility: inherit ? 'inherit' : 'visible' });\n\t},\n\n\t/**\n\t * Hide the element, equivalent to setting the `visibility` attribute to\n\t * `hidden`.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\thide: function () {\n\t\treturn this.attr({ visibility: 'hidden' });\n\t},\n\n\t/**\n\t * Fade out an element by animating its opacity down to 0, and hide it on\n\t * complete. Used internally for the tooltip.\n\t * \n\t * @param {number} [duration=150] The fade duration in milliseconds.\n\t */\n\tfadeOut: function (duration) {\n\t\tvar elemWrapper = this;\n\t\telemWrapper.animate({\n\t\t\topacity: 0\n\t\t}, {\n\t\t\tduration: duration || 150,\n\t\t\tcomplete: function () {\n\t\t\t\t// #3088, assuming we're only using this for tooltips\n\t\t\t\telemWrapper.attr({ y: -9999 });\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Add the element to the DOM. All elements must be added this way.\n\t * \n\t * @param {SVGElement|SVGDOMElement} [parent] The parent item to add it to.\n\t *   If undefined, the element is added to the {@link\n\t *   Highcharts.SVGRenderer.box}.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t *\n\t * @sample highcharts/members/renderer-g - Elements added to a group\n\t */\n\tadd: function (parent) {\n\n\t\tvar renderer = this.renderer,\n\t\t\telement = this.element,\n\t\t\tinserted;\n\n\t\tif (parent) {\n\t\t\tthis.parentGroup = parent;\n\t\t}\n\n\t\t// mark as inverted\n\t\tthis.parentInverted = parent && parent.inverted;\n\n\t\t// build formatted text\n\t\tif (this.textStr !== undefined) {\n\t\t\trenderer.buildText(this);\n\t\t}\n\n\t\t// Mark as added\n\t\tthis.added = true;\n\n\t\t// If we're adding to renderer root, or other elements in the group\n\t\t// have a z index, we need to handle it\n\t\tif (!parent || parent.handleZ || this.zIndex) {\n\t\t\tinserted = this.zIndexSetter();\n\t\t}\n\n\t\t// If zIndex is not handled, append at the end\n\t\tif (!inserted) {\n\t\t\t(parent ? parent.element : renderer.box).appendChild(element);\n\t\t}\n\n\t\t// fire an event for internal hooks\n\t\tif (this.onAdd) {\n\t\t\tthis.onAdd();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Removes an element from the DOM.\n\t *\n\t * @private\n\t * @param {SVGDOMElement|HTMLDOMElement} element The DOM node to remove.\n\t */\n\tsafeRemoveChild: function (element) {\n\t\tvar parentNode = element.parentNode;\n\t\tif (parentNode) {\n\t\t\tparentNode.removeChild(element);\n\t\t}\n\t},\n\n\t/**\n\t * Destroy the element and element wrapper and clear up the DOM and event\n\t * hooks.\n\t *\n\t * \n\t */\n\tdestroy: function () {\n\t\tvar wrapper = this,\n\t\t\telement = wrapper.element || {},\n\t\t\tparentToClean =\n\t\t\t\twrapper.renderer.isSVG &&\n\t\t\t\telement.nodeName === 'SPAN' &&\n\t\t\t\twrapper.parentGroup,\n\t\t\tgrandParent,\n\t\t\townerSVGElement = element.ownerSVGElement,\n\t\t\ti,\n\t\t\tclipPath = wrapper.clipPath;\n\n\t\t// remove events\n\t\telement.onclick = element.onmouseout = element.onmouseover =\n\t\t\telement.onmousemove = element.point = null;\n\t\tstop(wrapper); // stop running animations\n\n\t\tif (clipPath && ownerSVGElement) {\n\t\t\t// Look for existing references to this clipPath and remove them\n\t\t\t// before destroying the element (#6196).\n\t\t\teach(\n\t\t\t\t// The upper case version is for Edge\n\t\t\t\townerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'),\n\t\t\t\tfunction (el) {\n\t\t\t\t\tvar clipPathAttr = el.getAttribute('clip-path'),\n\t\t\t\t\t\tclipPathId = clipPath.element.id;\n\t\t\t\t\t// Include the closing paranthesis in the test to rule out\n\t\t\t\t\t// id's from 10 and above (#6550). Edge puts quotes inside\n\t\t\t\t\t// the url, others not.\n\t\t\t\t\tif (\n\t\t\t\t\t\tclipPathAttr.indexOf('(#' + clipPathId + ')') > -1 ||\n\t\t\t\t\t\tclipPathAttr.indexOf('(\"#' + clipPathId + '\")') > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\tel.removeAttribute('clip-path');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\twrapper.clipPath = clipPath.destroy();\n\t\t}\n\n\t\t// Destroy stops in case this is a gradient object\n\t\tif (wrapper.stops) {\n\t\t\tfor (i = 0; i < wrapper.stops.length; i++) {\n\t\t\t\twrapper.stops[i] = wrapper.stops[i].destroy();\n\t\t\t}\n\t\t\twrapper.stops = null;\n\t\t}\n\n\t\t// remove element\n\t\twrapper.safeRemoveChild(element);\n\n\t\t/*= if (build.classic) { =*/\n\t\twrapper.destroyShadows();\n\t\t/*= } =*/\n\n\t\t// In case of useHTML, clean up empty containers emulating SVG groups\n\t\t// (#1960, #2393, #2697).\n\t\twhile (\n\t\t\tparentToClean &&\n\t\t\tparentToClean.div &&\n\t\t\tparentToClean.div.childNodes.length === 0\n\t\t) {\n\t\t\tgrandParent = parentToClean.parentGroup;\n\t\t\twrapper.safeRemoveChild(parentToClean.div);\n\t\t\tdelete parentToClean.div;\n\t\t\tparentToClean = grandParent;\n\t\t}\n\n\t\t// remove from alignObjects\n\t\tif (wrapper.alignTo) {\n\t\t\terase(wrapper.renderer.alignedObjects, wrapper);\n\t\t}\n\n\t\tobjectEach(wrapper, function (val, key) {\n\t\t\tdelete wrapper[key];\n\t\t});\n\n\t\treturn null;\n\t},\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * @typedef {Object} ShadowOptions\n\t * @property {string} [color=${palette.neutralColor100}] The shadow color.\n\t * @property {number} [offsetX=1] The horizontal offset from the element.\n\t * @property {number} [offsetY=1] The vertical offset from the element.\n\t * @property {number} [opacity=0.15] The shadow opacity.\n\t * @property {number} [width=3] The shadow width or distance from the\n\t *    element.\n\t */\n\t/**\n\t * Add a shadow to the element. Must be called after the element is added to\n\t * the DOM. In styled mode, this method is not used, instead use `defs` and\n\t * filters.\n\t * \n\t * @param {boolean|ShadowOptions} shadowOptions The shadow options. If\n\t *    `true`, the default options are applied. If `false`, the current\n\t *    shadow will be removed.\n\t * @param {SVGElement} [group] The SVG group element where the shadows will \n\t *    be applied. The default is to add it to the same parent as the current\n\t *    element. Internally, this is ised for pie slices, where all the\n\t *    shadows are added to an element behind all the slices.\n\t * @param {boolean} [cutOff] Used internally for column shadows.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t *\n\t * @example\n\t * renderer.rect(10, 100, 100, 100)\n\t *     .attr({ fill: 'red' })\n\t *     .shadow(true);\n\t */\n\tshadow: function (shadowOptions, group, cutOff) {\n\t\tvar shadows = [],\n\t\t\ti,\n\t\t\tshadow,\n\t\t\telement = this.element,\n\t\t\tstrokeWidth,\n\t\t\tshadowWidth,\n\t\t\tshadowElementOpacity,\n\n\t\t\t// compensate for inverted plot area\n\t\t\ttransform;\n\n\t\tif (!shadowOptions) {\n\t\t\tthis.destroyShadows();\n\t\t\n\t\t} else if (!this.shadows) {\n\t\t\tshadowWidth = pick(shadowOptions.width, 3);\n\t\t\tshadowElementOpacity = (shadowOptions.opacity || 0.15) /\n\t\t\t\tshadowWidth;\n\t\t\ttransform = this.parentInverted ?\n\t\t\t\t\t'(-1,-1)' :\n\t\t\t\t\t'(' + pick(shadowOptions.offsetX, 1) + ', ' +\n\t\t\t\t\t\tpick(shadowOptions.offsetY, 1) + ')';\n\t\t\tfor (i = 1; i <= shadowWidth; i++) {\n\t\t\t\tshadow = element.cloneNode(0);\n\t\t\t\tstrokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\t\t\t\tattr(shadow, {\n\t\t\t\t\t'isShadow': 'true',\n\t\t\t\t\t'stroke':\n\t\t\t\t\t\tshadowOptions.color || '${palette.neutralColor100}',\n\t\t\t\t\t'stroke-opacity': shadowElementOpacity * i,\n\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t'transform': 'translate' + transform,\n\t\t\t\t\t'fill': 'none'\n\t\t\t\t});\n\t\t\t\tif (cutOff) {\n\t\t\t\t\tattr(\n\t\t\t\t\t\tshadow,\n\t\t\t\t\t\t'height',\n\t\t\t\t\t\tMath.max(attr(shadow, 'height') - strokeWidth, 0)\n\t\t\t\t\t);\n\t\t\t\t\tshadow.cutHeight = strokeWidth;\n\t\t\t\t}\n\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.element.appendChild(shadow);\n\t\t\t\t} else if (element.parentNode) {\n\t\t\t\t\telement.parentNode.insertBefore(shadow, element);\n\t\t\t\t}\n\n\t\t\t\tshadows.push(shadow);\n\t\t\t}\n\n\t\t\tthis.shadows = shadows;\n\t\t}\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Destroy shadows on the element.\n\t * @private\n\t */\n\tdestroyShadows: function () {\n\t\teach(this.shadows || [], function (shadow) {\n\t\t\tthis.safeRemoveChild(shadow);\n\t\t}, this);\n\t\tthis.shadows = undefined;\n\t},\n\n\t/*= } =*/\n\n\txGetter: function (key) {\n\t\tif (this.element.nodeName === 'circle') {\n\t\t\tif (key === 'x') {\n\t\t\t\tkey = 'cx';\n\t\t\t} else if (key === 'y') {\n\t\t\t\tkey = 'cy';\n\t\t\t}\n\t\t}\n\t\treturn this._defaultGetter(key);\n\t},\n\n\t/**\n\t * Get the current value of an attribute or pseudo attribute, used mainly\n\t * for animation. Called internally from the {@link\n\t * Highcharts.SVGRenderer#attr}\n\t * function.\n\t *\n\t * @private\n\t */\n\t_defaultGetter: function (key) {\n\t\tvar ret = pick(\n\t\t\tthis[key + 'Value'], // align getter\n\t\t\tthis[key],\n\t\t\tthis.element ? this.element.getAttribute(key) : null,\n\t\t\t0\n\t\t);\n\n\t\tif (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n\t\t\tret = parseFloat(ret);\n\t\t}\n\t\treturn ret;\n\t},\n\n\n\tdSetter: function (value, key, element) {\n\t\tif (value && value.join) { // join path\n\t\t\tvalue = value.join(' ');\n\t\t}\n\t\tif (/(NaN| {2}|^$)/.test(value)) {\n\t\t\tvalue = 'M 0 0';\n\t\t}\n\n\t\t// Check for cache before resetting. Resetting causes disturbance in the\n\t\t// DOM, causing flickering in some cases in Edge/IE (#6747). Also\n\t\t// possible performance gain.\n\t\tif (this[key] !== value) {\n\t\t\telement.setAttribute(key, value);\n\t\t\tthis[key] = value;\n\t\t}\t\t\n\n\t},\n\t/*= if (build.classic) { =*/\n\tdashstyleSetter: function (value) {\n\t\tvar i,\n\t\t\tstrokeWidth = this['stroke-width'];\n\t\t\n\t\t// If \"inherit\", like maps in IE, assume 1 (#4981). With HC5 and the new\n\t\t// strokeWidth function, we should be able to use that instead.\n\t\tif (strokeWidth === 'inherit') {\n\t\t\tstrokeWidth = 1;\n\t\t}\n\t\tvalue = value && value.toLowerCase();\n\t\tif (value) {\n\t\t\tvalue = value\n\t\t\t\t.replace('shortdashdotdot', '3,1,1,1,1,1,')\n\t\t\t\t.replace('shortdashdot', '3,1,1,1')\n\t\t\t\t.replace('shortdot', '1,1,')\n\t\t\t\t.replace('shortdash', '3,1,')\n\t\t\t\t.replace('longdash', '8,3,')\n\t\t\t\t.replace(/dot/g, '1,3,')\n\t\t\t\t.replace('dash', '4,3,')\n\t\t\t\t.replace(/,$/, '')\n\t\t\t\t.split(','); // ending comma\n\n\t\t\ti = value.length;\n\t\t\twhile (i--) {\n\t\t\t\tvalue[i] = pInt(value[i]) * strokeWidth;\n\t\t\t}\n\t\t\tvalue = value.join(',')\n\t\t\t\t.replace(/NaN/g, 'none'); // #3226\n\t\t\tthis.element.setAttribute('stroke-dasharray', value);\n\t\t}\n\t},\n\t/*= } =*/\n\talignSetter: function (value) {\n\t\tvar convert = { left: 'start', center: 'middle', right: 'end' };\n\t\tthis.alignValue = value;\n\t\tthis.element.setAttribute('text-anchor', convert[value]);\n\t},\n\topacitySetter: function (value, key, element) {\t\t\n\t\tthis[key] = value;\t\t\n\t\telement.setAttribute(key, value);\t\t\n\t},\n\ttitleSetter: function (value) {\n\t\tvar titleNode = this.element.getElementsByTagName('title')[0];\n\t\tif (!titleNode) {\n\t\t\ttitleNode = doc.createElementNS(this.SVG_NS, 'title');\n\t\t\tthis.element.appendChild(titleNode);\n\t\t}\n\n\t\t// Remove text content if it exists\n\t\tif (titleNode.firstChild) {\n\t\t\ttitleNode.removeChild(titleNode.firstChild);\n\t\t}\n\n\t\ttitleNode.appendChild(\n\t\t\tdoc.createTextNode(\n\t\t\t\t// #3276, #3895\n\t\t\t\t(String(pick(value), ''))\n\t\t\t\t\t.replace(/<[^>]*>/g, '')\n\t\t\t\t\t.replace(/&lt;/g, '<')\n\t\t\t\t\t.replace(/&gt;/g, '>')\n\t\t\t)\n\t\t);\n\t},\n\ttextSetter: function (value) {\n\t\tif (value !== this.textStr) {\n\t\t\t// Delete bBox memo when the text changes\n\t\t\tdelete this.bBox;\n\n\t\t\tthis.textStr = value;\n\t\t\tif (this.added) {\n\t\t\t\tthis.renderer.buildText(this);\n\t\t\t}\n\t\t}\n\t},\n\tfillSetter: function (value, key, element) {\n\t\tif (typeof value === 'string') {\n\t\t\telement.setAttribute(key, value);\n\t\t} else if (value) {\n\t\t\tthis.colorGradient(value, key, element);\n\t\t}\n\t},\n\tvisibilitySetter: function (value, key, element) {\n\t\t// IE9-11 doesn't handle visibilty:inherit well, so we remove the\n\t\t// attribute instead (#2881, #3909)\n\t\tif (value === 'inherit') {\n\t\t\telement.removeAttribute(key);\n\t\t} else if (this[key] !== value) { // #6747\n\t\t\telement.setAttribute(key, value);\n\t\t}\n\t\tthis[key] = value;\n\t},\n\tzIndexSetter: function (value, key) {\n\t\tvar renderer = this.renderer,\n\t\t\tparentGroup = this.parentGroup,\n\t\t\tparentWrapper = parentGroup || renderer,\n\t\t\tparentNode = parentWrapper.element || renderer.box,\n\t\t\tchildNodes,\n\t\t\totherElement,\n\t\t\totherZIndex,\n\t\t\telement = this.element,\n\t\t\tinserted,\n\t\t\tundefinedOtherZIndex,\n\t\t\tsvgParent = parentNode === renderer.box,\n\t\t\trun = this.added,\n\t\t\ti;\n\n\t\tif (defined(value)) {\n\t\t\t// So we can read it for other elements in the group\n\t\t\telement.zIndex = value;\n\n\t\t\tvalue = +value;\n\t\t\tif (this[key] === value) { // Only update when needed (#3865)\n\t\t\t\trun = false;\n\t\t\t}\n\t\t\tthis[key] = value;\n\t\t}\n\n\t\t// Insert according to this and other elements' zIndex. Before .add() is\n\t\t// called, nothing is done. Then on add, or by later calls to\n\t\t// zIndexSetter, the node is placed on the right place in the DOM.\n\t\tif (run) {\n\t\t\tvalue = this.zIndex;\n\n\t\t\tif (value && parentGroup) {\n\t\t\t\tparentGroup.handleZ = true;\n\t\t\t}\n\n\t\t\tchildNodes = parentNode.childNodes;\n\t\t\tfor (i = childNodes.length - 1; i >= 0 && !inserted; i--) {\n\t\t\t\totherElement = childNodes[i];\n\t\t\t\totherZIndex = otherElement.zIndex;\n\t\t\t\tundefinedOtherZIndex = !defined(otherZIndex);\n\n\t\t\t\tif (otherElement !== element) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Negative zIndex versus no zIndex:\n\t\t\t\t\t\t// On all levels except the highest. If the parent is\n\t\t\t\t\t\t// <svg>, then we don't want to put items before <desc>\n\t\t\t\t\t\t// or <defs>\n\t\t\t\t\t\t(value < 0 && undefinedOtherZIndex && !svgParent && !i)\n\t\t\t\t\t) {\n\t\t\t\t\t\tparentNode.insertBefore(element, childNodes[i]);\n\t\t\t\t\t\tinserted = true;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t// Insert after the first element with a lower zIndex\n\t\t\t\t\t\tpInt(otherZIndex) <= value ||\n\t\t\t\t\t\t// If negative zIndex, add this before first undefined\n\t\t\t\t\t\t// zIndex element\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tundefinedOtherZIndex &&\n\t\t\t\t\t\t\t(!defined(value) || value >= 0)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tparentNode.insertBefore(\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\tchildNodes[i + 1] || null // null for oldIE export\n\t\t\t\t\t\t);\n\t\t\t\t\t\tinserted = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!inserted) {\n\t\t\t\tparentNode.insertBefore(\n\t\t\t\t\telement,\n\t\t\t\t\tchildNodes[svgParent ? 3 : 0] || null // null for oldIE\n\t\t\t\t);\n\t\t\t\tinserted = true;\n\t\t\t}\n\t\t}\n\t\treturn inserted;\n\t},\n\t_defaultSetter: function (value, key, element) {\n\t\telement.setAttribute(key, value);\n\t}\n});\n\n// Some shared setters and getters\nSVGElement.prototype.yGetter =\nSVGElement.prototype.xGetter;\nSVGElement.prototype.translateXSetter =\nSVGElement.prototype.translateYSetter =\nSVGElement.prototype.rotationSetter =\nSVGElement.prototype.verticalAlignSetter =\nSVGElement.prototype.rotationOriginXSetter =\nSVGElement.prototype.rotationOriginYSetter = \nSVGElement.prototype.scaleXSetter =\nSVGElement.prototype.scaleYSetter = \nSVGElement.prototype.matrixSetter = function (value, key) {\n\tthis[key] = value;\n\tthis.doTransform = true;\n};\n\n/*= if (build.classic) { =*/\n// WebKit and Batik have problems with a stroke-width of zero, so in this case\n// we remove the stroke attribute altogether. #1270, #1369, #3065, #3072.\nSVGElement.prototype['stroke-widthSetter'] =\nSVGElement.prototype.strokeSetter = function (value, key, element) {\n\tthis[key] = value;\n\t// Only apply the stroke attribute if the stroke width is defined and larger\n\t// than 0\n\tif (this.stroke && this['stroke-width']) {\n\t\t// Use prototype as instance may be overridden\n\t\tSVGElement.prototype.fillSetter.call(\n\t\t\tthis,\n\t\t\tthis.stroke,\n\t\t\t'stroke',\n\t\t\telement\n\t\t);\n\t\t\n\t\telement.setAttribute('stroke-width', this['stroke-width']);\n\t\tthis.hasStroke = true;\n\t} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n\t\telement.removeAttribute('stroke');\n\t\tthis.hasStroke = false;\n\t}\n};\n/*= } =*/\n\n/**\n * Allows direct access to the Highcharts rendering layer in order to draw\n * primitive shapes like circles, rectangles, paths or text directly on a chart,\n * or independent from any chart. The SVGRenderer represents a wrapper object\n * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`\n * module, it also brings vector graphics to IE <= 8.\n *\n * An existing chart's renderer can be accessed through {@link Chart.renderer}.\n * The renderer can also be used completely decoupled from a chart.\n *\n * @param {HTMLDOMElement} container - Where to put the SVG in the web page.\n * @param {number} width - The width of the SVG.\n * @param {number} height - The height of the SVG.\n * @param {boolean} [forExport=false] - Whether the rendered content is intended\n *   for export.\n * @param {boolean} [allowHTML=true] - Whether the renderer is allowed to\n *   include HTML text, which will be projected on top of the SVG.\n *\n * @example\n * // Use directly without a chart object.\n * var renderer = new Highcharts.Renderer(parentNode, 600, 400);\n *\n * @sample highcharts/members/renderer-on-chart\n *         Annotating a chart programmatically.\n * @sample highcharts/members/renderer-basic\n *         Independent SVG drawing.\n *\n * @class Highcharts.SVGRenderer\n */\nSVGRenderer = H.SVGRenderer = function () {\n\tthis.init.apply(this, arguments);\n};\nextend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {\n\t/**\n\t * A pointer to the renderer's associated Element class. The VMLRenderer\n\t * will have a pointer to VMLElement here.\n\t * @type {SVGElement}\n\t */\n\tElement: SVGElement,\n\tSVG_NS: SVG_NS,\n\t/**\n\t * Initialize the SVGRenderer. Overridable initiator function that takes\n\t * the same parameters as the constructor.\n\t */\n\tinit: function (container, width, height, style, forExport, allowHTML) {\n\t\tvar renderer = this,\n\t\t\tboxWrapper,\n\t\t\telement,\n\t\t\tdesc;\n\n\t\tboxWrapper = renderer.createElement('svg')\n\t\t\t.attr({\n\t\t\t\t'version': '1.1',\n\t\t\t\t'class': 'highcharts-root'\n\t\t\t})\n\t\t\t/*= if (build.classic) { =*/\n\t\t\t.css(this.getStyle(style))\n\t\t\t/*= } =*/;\n\t\telement = boxWrapper.element;\n\t\tcontainer.appendChild(element);\n\n\t\t// Always use ltr on the container, otherwise text-anchor will be\n\t\t// flipped and text appear outside labels, buttons, tooltip etc (#3482)\n\t\tattr(container, 'dir', 'ltr');\n\n\t\t// For browsers other than IE, add the namespace attribute (#1978)\n\t\tif (container.innerHTML.indexOf('xmlns') === -1) {\n\t\t\tattr(element, 'xmlns', this.SVG_NS);\n\t\t}\n\n\t\t// object properties\n\t\trenderer.isSVG = true;\n\n\t\t/** \n\t\t * The root `svg` node of the renderer.\n\t\t * @name box\n\t\t * @memberOf SVGRenderer\n\t\t * @type {SVGDOMElement}\n\t\t */\n\t\tthis.box = element;\n\t\t/** \n\t\t * The wrapper for the root `svg` node of the renderer.\n\t\t *\n\t\t * @name boxWrapper\n\t\t * @memberOf SVGRenderer\n\t\t * @type {SVGElement}\n\t\t */\n\t\tthis.boxWrapper = boxWrapper;\n\t\trenderer.alignedObjects = [];\n\n\t\t/**\n\t\t * Page url used for internal references.\n\t\t * @type {string}\n\t\t */\n\t\t// #24, #672, #1070\n\t\tthis.url = (\n\t\t\t\t(isFirefox || isWebKit) &&\n\t\t\t\tdoc.getElementsByTagName('base').length\n\t\t\t) ?\n\t\t\t\twin.location.href\n\t\t\t\t\t.replace(/#.*?$/, '') // remove the hash\n\t\t\t\t\t.replace(/<[^>]*>/g, '') // wing cut HTML\n\t\t\t\t\t// escape parantheses and quotes\n\t\t\t\t\t.replace(/([\\('\\)])/g, '\\\\$1')\n\t\t\t\t\t// replace spaces (needed for Safari only)\n\t\t\t\t\t.replace(/ /g, '%20') :\n\t\t\t\t'';\n\n\t\t// Add description\n\t\tdesc = this.createElement('desc').add();\n\t\tdesc.element.appendChild(\n\t\t\tdoc.createTextNode('Created with @product.name@ @product.version@')\n\t\t);\n\n\t\t/**\n\t\t * A pointer to the `defs` node of the root SVG.\n\t\t * @type {SVGElement}\n\t\t * @name defs\n\t\t * @memberOf SVGRenderer\n\t\t */\n\t\trenderer.defs = this.createElement('defs').add();\n\t\trenderer.allowHTML = allowHTML;\n\t\trenderer.forExport = forExport;\n\t\trenderer.gradients = {}; // Object where gradient SvgElements are stored\n\t\trenderer.cache = {}; // Cache for numerical bounding boxes\n\t\trenderer.cacheKeys = [];\n\t\trenderer.imgCount = 0;\n\n\t\trenderer.setSize(width, height, false);\n\n\t\t\n\n\t\t// Issue 110 workaround:\n\t\t// In Firefox, if a div is positioned by percentage, its pixel position\n\t\t// may land between pixels. The container itself doesn't display this,\n\t\t// but an SVG element inside this container will be drawn at subpixel\n\t\t// precision. In order to draw sharp lines, this must be compensated\n\t\t// for. This doesn't seem to work inside iframes though (like in\n\t\t// jsFiddle).\n\t\tvar subPixelFix, rect;\n\t\tif (isFirefox && container.getBoundingClientRect) {\n\t\t\tsubPixelFix = function () {\n\t\t\t\tcss(container, { left: 0, top: 0 });\n\t\t\t\trect = container.getBoundingClientRect();\n\t\t\t\tcss(container, {\n\t\t\t\t\tleft: (Math.ceil(rect.left) - rect.left) + 'px',\n\t\t\t\t\ttop: (Math.ceil(rect.top) - rect.top) + 'px'\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// run the fix now\n\t\t\tsubPixelFix();\n\n\t\t\t// run it on resize\n\t\t\trenderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);\n\t\t}\n\t},\n\t/*= if (!build.classic) { =*/\n\t/**\n\t * General method for adding a definition to the SVG `defs` tag. Can be used\n\t *   for gradients, fills, filters etc. Styled mode only. A hook for adding\n\t *   general definitions to the SVG's defs tag. Definitions can be\n\t *   referenced from the CSS by its `id`. Read more in\n\t *   [gradients, shadows and patterns]{@link http://www.highcharts.com/docs/\n\t *   chart-design-and-style/gradients-shadows-and-patterns}.\n\t *   Styled mode only.\n\t *\n\t * @param {Object} def - A serialized form of an SVG definition, including\n\t *   children\n\t *\n\t * @return {SVGElement} The inserted node. \n\t */\n\tdefinition: function (def) {\n\t\tvar ren = this;\n\n\t\tfunction recurse(config, parent) {\n\t\t\tvar ret;\n\t\t\teach(splat(config), function (item) {\n\t\t\t\tvar node = ren.createElement(item.tagName),\n\t\t\t\t\tattr = {};\n\n\t\t\t\t// Set attributes\n\t\t\t\tobjectEach(item, function (val, key) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tkey !== 'tagName' &&\n\t\t\t\t\t\tkey !== 'children' &&\n\t\t\t\t\t\tkey !== 'textContent'\n\t\t\t\t\t) {\n\t\t\t\t\t\tattr[key] = val;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tnode.attr(attr);\n\n\t\t\t\t// Add to the tree\n\t\t\t\tnode.add(parent || ren.defs);\n\n\t\t\t\t// Add text content\n\t\t\t\tif (item.textContent) {\n\t\t\t\t\tnode.element.appendChild(\n\t\t\t\t\t\tdoc.createTextNode(item.textContent)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Recurse\n\t\t\t\trecurse(item.children || [], node);\n\n\t\t\t\tret = node;\n\t\t\t});\n\n\t\t\t// Return last node added (on top level it's the only one)\n\t\t\treturn ret;\n\t\t}\n\t\treturn recurse(def);\n\t},\n\t/*= } =*/\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * Get the global style setting for the renderer.\n\t * @private\n\t * @param  {CSSObject} style - Style settings.\n\t * @return {CSSObject} The style settings mixed with defaults.\n\t */\n\tgetStyle: function (style) {\n\t\tthis.style = extend({\n\t\t\t\n\t\t\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", ' +\n\t\t\t\t'Arial, Helvetica, sans-serif',\n\t\t\tfontSize: '12px'\n\n\t\t}, style);\n\t\treturn this.style;\n\t},\n\t/**\n\t * Apply the global style on the renderer, mixed with the default styles.\n\t * \n\t * @param {CSSObject} style - CSS to apply.\n\t */\n\tsetStyle: function (style) {\n\t\tthis.boxWrapper.css(this.getStyle(style));\n\t},\n\t/*= } =*/\n\n\t/**\n\t * Detect whether the renderer is hidden. This happens when one of the\n\t * parent elements has `display: none`. Used internally to detect when we\n\t * needto render preliminarily in another div to get the text bounding boxes\n\t * right.\n\t *\n\t * @returns {boolean} True if it is hidden.\n\t */\n\tisHidden: function () { // #608\n\t\treturn !this.boxWrapper.getBBox().width;\n\t},\n\n\t/**\n\t * Destroys the renderer and its allocated members.\n\t */\n\tdestroy: function () {\n\t\tvar renderer = this,\n\t\t\trendererDefs = renderer.defs;\n\t\trenderer.box = null;\n\t\trenderer.boxWrapper = renderer.boxWrapper.destroy();\n\n\t\t// Call destroy on all gradient elements\n\t\tdestroyObjectProperties(renderer.gradients || {});\n\t\trenderer.gradients = null;\n\n\t\t// Defs are null in VMLRenderer\n\t\t// Otherwise, destroy them here.\n\t\tif (rendererDefs) {\n\t\t\trenderer.defs = rendererDefs.destroy();\n\t\t}\n\n\t\t// Remove sub pixel fix handler (#982)\n\t\tif (renderer.unSubPixelFix) {\n\t\t\trenderer.unSubPixelFix();\n\t\t}\n\n\t\trenderer.alignedObjects = null;\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Create a wrapper for an SVG element. Serves as a factory for \n\t * {@link SVGElement}, but this function is itself mostly called from \n\t * primitive factories like {@link SVGRenderer#path}, {@link\n\t * SVGRenderer#rect} or {@link SVGRenderer#text}.\n\t * \n\t * @param {string} nodeName - The node name, for example `rect`, `g` etc.\n\t * @returns {SVGElement} The generated SVGElement.\n\t */\n\tcreateElement: function (nodeName) {\n\t\tvar wrapper = new this.Element();\n\t\twrapper.init(this, nodeName);\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Dummy function for plugins, called every time the renderer is updated.\n\t * Prior to Highcharts 5, this was used for the canvg renderer.\n\t * @function\n\t */\n\tdraw: noop,\n\n\t/**\n\t * Get converted radial gradient attributes according to the radial\n\t * reference. Used internally from the {@link SVGElement#colorGradient}\n\t * function.\n\t *\n\t * @private\n\t */\n\tgetRadialAttr: function (radialReference, gradAttr) {\n\t\treturn {\n\t\t\tcx: (radialReference[0] - radialReference[2] / 2) +\n\t\t\t\tgradAttr.cx * radialReference[2],\n\t\t\tcy: (radialReference[1] - radialReference[2] / 2) +\n\t\t\t\tgradAttr.cy * radialReference[2],\n\t\t\tr: gradAttr.r * radialReference[2]\n\t\t};\n\t},\n\t\n\t/**\n\t * Extendable function to measure the tspan width.\n\t *\n\t * @private\n\t */\n\tgetSpanWidth: function (wrapper) {\n\t\treturn wrapper.getBBox(true).width;\n\t},\n\t\n\tapplyEllipsis: function (wrapper, tspan, text, width) {\n\t\tvar renderer = this,\n\t\t\trotation = wrapper.rotation,\n\t\t\tstr = text,\n\t\t\tcurrentIndex,\n\t\t\tminIndex = 0,\n\t\t\tmaxIndex = text.length,\n\t\t\tupdateTSpan = function (s) {\n\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\tif (s) {\n\t\t\t\t\ttspan.appendChild(doc.createTextNode(s));\n\t\t\t\t}\n\t\t\t},\n\t\t\tactualWidth,\n\t\t\twasTooLong;\n\t\twrapper.rotation = 0; // discard rotation when computing box\n\t\tactualWidth = renderer.getSpanWidth(wrapper, tspan);\n\t\twasTooLong = actualWidth > width;\n\t\tif (wasTooLong) {\n\t\t\twhile (minIndex <= maxIndex) {\n\t\t\t\tcurrentIndex = Math.ceil((minIndex + maxIndex) / 2);\n\t\t\t\tstr = text.substring(0, currentIndex) + '\\u2026';\n\t\t\t\tupdateTSpan(str);\n\t\t\t\tactualWidth = renderer.getSpanWidth(wrapper, tspan);\n\t\t\t\tif (minIndex === maxIndex) {\n\t\t\t\t\t// Complete\n\t\t\t\t\tminIndex = maxIndex + 1;\n\t\t\t\t} else if (actualWidth > width) {\n\t\t\t\t\t// Too large. Set max index to current.\n\t\t\t\t\tmaxIndex = currentIndex - 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Within width. Set min index to current.\n\t\t\t\t\tminIndex = currentIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If max index was 0 it means just ellipsis was also to large.\n\t\t\tif (maxIndex === 0) {\n\t\t\t\t// Remove ellipses.\n\t\t\t\tupdateTSpan('');\n\t\t\t}\n\t\t}\n\t\twrapper.rotation = rotation; // Apply rotation again.\n\t\treturn wasTooLong;\n\t},\n\n\t/**\n\t * A collection of characters mapped to HTML entities. When `useHTML` on an\n\t * element is true, these entities will be rendered correctly by HTML. In \n\t * the SVG pseudo-HTML, they need to be unescaped back to simple characters,\n\t * so for example `&lt;` will render as `<`.\n\t *\n\t * @example\n\t * // Add support for unescaping quotes\n\t * Highcharts.SVGRenderer.prototype.escapes['\"'] = '&quot;';\n\t * \n\t * @type {Object}\n\t */\n\tescapes: {\n\t\t'&': '&amp;',\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t\"'\": '&#39;', // eslint-disable-line quotes\n\t\t'\"': '&quot;'\n\t},\n\n\t/**\n\t * Parse a simple HTML string into SVG tspans. Called internally when text\n\t *   is set on an SVGElement. The function supports a subset of HTML tags,\n\t *   CSS text features like `width`, `text-overflow`, `white-space`, and\n\t *   also attributes like `href` and `style`.\n\t * @private\n\t * @param {SVGElement} wrapper The parent SVGElement.\n\t */\n\tbuildText: function (wrapper) {\n\t\tvar textNode = wrapper.element,\n\t\t\trenderer = this,\n\t\t\tforExport = renderer.forExport,\n\t\t\ttextStr = pick(wrapper.textStr, '').toString(),\n\t\t\thasMarkup = textStr.indexOf('<') !== -1,\n\t\t\tlines,\n\t\t\tchildNodes = textNode.childNodes,\n\t\t\tclsRegex,\n\t\t\tstyleRegex,\n\t\t\threfRegex,\n\t\t\twasTooLong,\n\t\t\tparentX = attr(textNode, 'x'),\n\t\t\ttextStyles = wrapper.styles,\n\t\t\twidth = wrapper.textWidth,\n\t\t\ttextLineHeight = textStyles && textStyles.lineHeight,\n\t\t\ttextOutline = textStyles && textStyles.textOutline,\n\t\t\tellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n\t\t\tnoWrap = textStyles && textStyles.whiteSpace === 'nowrap',\n\t\t\tfontSize = textStyles && textStyles.fontSize,\n\t\t\ttextCache,\n\t\t\tisSubsequentLine,\n\t\t\ti = childNodes.length,\n\t\t\ttempParent = width && !wrapper.added && this.box,\n\t\t\tgetLineHeight = function (tspan) {\n\t\t\t\tvar fontSizeStyle;\n\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\tfontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n\t\t\t\t\ttspan.style.fontSize :\n\t\t\t\t\t(fontSize || renderer.style.fontSize || 12);\n\t\t\t\t/*= } =*/\n\n\t\t\t\treturn textLineHeight ? \n\t\t\t\t\tpInt(textLineHeight) :\n\t\t\t\t\trenderer.fontMetrics(\n\t\t\t\t\t\tfontSizeStyle,\n\t\t\t\t\t\t// Get the computed size from parent if not explicit\n\t\t\t\t\t\ttspan.getAttribute('style') ? tspan : textNode\n\t\t\t\t\t).h;\n\t\t\t},\n\t\t\tunescapeEntities = function (inputStr, except) {\n\t\t\t\tobjectEach(renderer.escapes, function (value, key) {\n\t\t\t\t\tif (!except || inArray(value, except) === -1) {\n\t\t\t\t\t\tinputStr = inputStr.toString().replace(\n\t\t\t\t\t\t\tnew RegExp(value, 'g'), // eslint-disable-line security/detect-non-literal-regexp\n\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn inputStr;\n\t\t\t};\n\n\t\t// The buildText code is quite heavy, so if we're not changing something\n\t\t// that affects the text, skip it (#6113).\n\t\ttextCache = [\n\t\t\ttextStr,\n\t\t\tellipsis,\n\t\t\tnoWrap,\n\t\t\ttextLineHeight,\n\t\t\ttextOutline,\n\t\t\tfontSize,\n\t\t\twidth\n\t\t].join(',');\n\t\tif (textCache === wrapper.textCache) {\n\t\t\treturn;\n\t\t}\n\t\twrapper.textCache = textCache;\n\n\t\t// Remove old text\n\t\twhile (i--) {\n\t\t\ttextNode.removeChild(childNodes[i]);\n\t\t}\n\n\t\t// Skip tspans, add text directly to text node. The forceTSpan is a hook\n\t\t// used in text outline hack.\n\t\tif (\n\t\t\t!hasMarkup &&\n\t\t\t!textOutline &&\n\t\t\t!ellipsis &&\n\t\t\t!width &&\n\t\t\ttextStr.indexOf(' ') === -1\n\t\t) {\n\t\t\ttextNode.appendChild(doc.createTextNode(unescapeEntities(textStr)));\n\n\t\t// Complex strings, add more logic\n\t\t} else {\n\n\t\t\tclsRegex = /<.*class=\"([^\"]+)\".*>/;\n\t\t\tstyleRegex = /<.*style=\"([^\"]+)\".*>/;\n\t\t\threfRegex = /<.*href=\"([^\"]+)\".*>/;\n\n\t\t\tif (tempParent) {\n\t\t\t\t// attach it to the DOM to read offset width\n\t\t\t\ttempParent.appendChild(textNode);\n\t\t\t}\n\n\t\t\tif (hasMarkup) {\n\t\t\t\tlines = textStr\n\t\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\t\t.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n\t\t\t\t\t.replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n\t\t\t\t\t/*= } else { =*/\n\t\t\t\t\t.replace(\n\t\t\t\t\t\t/<(b|strong)>/g,\n\t\t\t\t\t\t'<span class=\"highcharts-strong\">'\n\t\t\t\t\t)\n\t\t\t\t\t.replace(\n\t\t\t\t\t\t/<(i|em)>/g,\n\t\t\t\t\t\t'<span class=\"highcharts-emphasized\">'\n\t\t\t\t\t)\n\t\t\t\t\t/*= } =*/\n\t\t\t\t\t.replace(/<a/g, '<span')\n\t\t\t\t\t.replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n\t\t\t\t\t.split(/<br.*?>/g);\n\n\t\t\t} else {\n\t\t\t\tlines = [textStr];\n\t\t\t}\n\n\n\t\t\t// Trim empty lines (#5261)\n\t\t\tlines = grep(lines, function (line) {\n\t\t\t\treturn line !== '';\n\t\t\t});\n\n\n\t\t\t// build the lines\n\t\t\teach(lines, function buildTextLines(line, lineNo) {\n\t\t\t\tvar spans,\n\t\t\t\t\tspanNo = 0;\n\t\t\t\tline = line\n\t\t\t\t\t// Trim to prevent useless/costly process on the spaces\n\t\t\t\t\t// (#5258)\n\t\t\t\t\t.replace(/^\\s+|\\s+$/g, '')\n\t\t\t\t\t.replace(/<span/g, '|||<span')\n\t\t\t\t\t.replace(/<\\/span>/g, '</span>|||');\n\t\t\t\tspans = line.split('|||');\n\n\t\t\t\teach(spans, function buildTextSpans(span) {\n\t\t\t\t\tif (span !== '' || spans.length === 1) {\n\t\t\t\t\t\tvar attributes = {},\n\t\t\t\t\t\t\ttspan = doc.createElementNS(\n\t\t\t\t\t\t\t\trenderer.SVG_NS,\n\t\t\t\t\t\t\t\t'tspan'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tspanCls,\n\t\t\t\t\t\t\tspanStyle; // #390\n\t\t\t\t\t\tif (clsRegex.test(span)) {\n\t\t\t\t\t\t\tspanCls = span.match(clsRegex)[1];\n\t\t\t\t\t\t\tattr(tspan, 'class', spanCls);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleRegex.test(span)) {\n\t\t\t\t\t\t\tspanStyle = span.match(styleRegex)[1].replace(\n\t\t\t\t\t\t\t\t/(;| |^)color([ :])/,\n\t\t\t\t\t\t\t\t'$1fill$2'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Not for export - #1529\n\t\t\t\t\t\tif (hrefRegex.test(span) && !forExport) {\n\t\t\t\t\t\t\tattr(\n\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t'onclick',\n\t\t\t\t\t\t\t\t'location.href=\\\"' +\n\t\t\t\t\t\t\t\t\tspan.match(hrefRegex)[1] + '\\\"'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tattr(tspan, 'class', 'highcharts-anchor');\n\t\t\t\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\t\t\t\tcss(tspan, { cursor: 'pointer' });\n\t\t\t\t\t\t\t/*= } =*/\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Strip away unsupported HTML tags (#7126)\n\t\t\t\t\t\tspan = unescapeEntities(\n\t\t\t\t\t\t\tspan.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, '') || ' '\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Nested tags aren't supported, and cause crash in\n\t\t\t\t\t\t// Safari (#1596)\n\t\t\t\t\t\tif (span !== ' ') {\n\n\t\t\t\t\t\t\t// add the text node\n\t\t\t\t\t\t\ttspan.appendChild(doc.createTextNode(span));\n\n\t\t\t\t\t\t\t// First span in a line, align it to the left\n\t\t\t\t\t\t\tif (!spanNo) {\n\t\t\t\t\t\t\t\tif (lineNo && parentX !== null) {\n\t\t\t\t\t\t\t\t\tattributes.x = parentX;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tattributes.dx = 0; // #16\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// add attributes\n\t\t\t\t\t\t\tattr(tspan, attributes);\n\n\t\t\t\t\t\t\t// Append it\n\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\n\t\t\t\t\t\t\t// first span on subsequent line, add the line\n\t\t\t\t\t\t\t// height\n\t\t\t\t\t\t\tif (!spanNo && isSubsequentLine) {\n\n\t\t\t\t\t\t\t\t// allow getting the right offset height in\n\t\t\t\t\t\t\t\t// exporting in IE\n\t\t\t\t\t\t\t\tif (!svg && forExport) {\n\t\t\t\t\t\t\t\t\tcss(tspan, { display: 'block' });\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the line height based on the font size of\n\t\t\t\t\t\t\t\t// either the text element or the tspan element\n\t\t\t\t\t\t\t\tattr(\n\t\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t\t'dy',\n\t\t\t\t\t\t\t\t\tgetLineHeight(tspan)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t// Experimental text wrapping based on\n\t\t\t\t\t\t\t// getSubstringLength\n\t\t\t\t\t\t\tif (width) {\n\t\t\t\t\t\t\t\tvar spans = renderer.breakText(wrapper, width);\n\n\t\t\t\t\t\t\t\teach(spans, function (span) {\n\n\t\t\t\t\t\t\t\t\tvar dy = getLineHeight(tspan);\n\t\t\t\t\t\t\t\t\ttspan = doc.createElementNS(\n\t\t\t\t\t\t\t\t\t\tSVG_NS,\n\t\t\t\t\t\t\t\t\t\t'tspan'\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\ttspan.appendChild(\n\t\t\t\t\t\t\t\t\t\tdoc.createTextNode(span)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tattr(tspan, {\n\t\t\t\t\t\t\t\t\t\tdy: dy,\n\t\t\t\t\t\t\t\t\t\tx: parentX\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (spanStyle) { // #390\n\t\t\t\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// */\n\n\t\t\t\t\t\t\t// Check width and apply soft breaks or ellipsis\n\t\t\t\t\t\t\tif (width) {\n\t\t\t\t\t\t\t\tvar words = span.replace(\n\t\t\t\t\t\t\t\t\t\t/([^\\^])-/g,\n\t\t\t\t\t\t\t\t\t\t'$1- '\n\t\t\t\t\t\t\t\t\t).split(' '), // #1273\n\t\t\t\t\t\t\t\t\thasWhiteSpace = (\n\t\t\t\t\t\t\t\t\t\tspans.length > 1 ||\n\t\t\t\t\t\t\t\t\t\tlineNo ||\n\t\t\t\t\t\t\t\t\t\t(words.length > 1 && !noWrap)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\ttooLong,\n\t\t\t\t\t\t\t\t\trest = [],\n\t\t\t\t\t\t\t\t\tactualWidth,\n\t\t\t\t\t\t\t\t\tdy = getLineHeight(tspan),\n\t\t\t\t\t\t\t\t\trotation = wrapper.rotation;\n\n\t\t\t\t\t\t\t\tif (ellipsis) {\n\t\t\t\t\t\t\t\t\twasTooLong = renderer.applyEllipsis(\n\t\t\t\t\t\t\t\t\t\twrapper,\n\t\t\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t\t\tspan,\n\t\t\t\t\t\t\t\t\t\twidth\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\t\t\t!ellipsis &&\n\t\t\t\t\t\t\t\t\thasWhiteSpace &&\n\t\t\t\t\t\t\t\t\t(words.length || rest.length)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// discard rotation when computing box\n\t\t\t\t\t\t\t\t\twrapper.rotation = 0; \n\t\t\t\t\t\t\t\t\tactualWidth = renderer.getSpanWidth(\n\t\t\t\t\t\t\t\t\t\twrapper,\n\t\t\t\t\t\t\t\t\t\ttspan\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\ttooLong = actualWidth > width;\n\n\t\t\t\t\t\t\t\t\t// For ellipsis, do a binary search for the \n\t\t\t\t\t\t\t\t\t// correct string length\n\t\t\t\t\t\t\t\t\tif (wasTooLong === undefined) {\n\t\t\t\t\t\t\t\t\t\twasTooLong = tooLong; // First time\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Looping down, this is the first word\n\t\t\t\t\t\t\t\t\t// sequence that is not too long, so we can\n\t\t\t\t\t\t\t\t\t// move on to build the next line.\n\t\t\t\t\t\t\t\t\tif (!tooLong || words.length === 1) {\n\t\t\t\t\t\t\t\t\t\twords = rest;\n\t\t\t\t\t\t\t\t\t\trest = [];\n\n\t\t\t\t\t\t\t\t\t\tif (words.length && !noWrap) {\n\t\t\t\t\t\t\t\t\t\t\ttspan = doc.createElementNS(\n\t\t\t\t\t\t\t\t\t\t\t\tSVG_NS,\n\t\t\t\t\t\t\t\t\t\t\t\t'tspan'\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tattr(tspan, {\n\t\t\t\t\t\t\t\t\t\t\t\tdy: dy,\n\t\t\t\t\t\t\t\t\t\t\t\tx: parentX\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tif (spanStyle) { // #390\n\t\t\t\t\t\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// a single word is pressing it out\n\t\t\t\t\t\t\t\t\t\tif (actualWidth > width) {\n\t\t\t\t\t\t\t\t\t\t\twidth = actualWidth;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else { // append to existing line tspan\n\t\t\t\t\t\t\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\t\t\t\t\t\t\trest.unshift(words.pop());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (words.length) {\n\t\t\t\t\t\t\t\t\t\ttspan.appendChild(\n\t\t\t\t\t\t\t\t\t\t\tdoc.createTextNode(\n\t\t\t\t\t\t\t\t\t\t\t\twords.join(' ')\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(/- /g, '-')\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrapper.rotation = rotation;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tspanNo++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// To avoid beginning lines that doesn't add to the textNode\n\t\t\t\t// (#6144)\n\t\t\t\tisSubsequentLine = (\n\t\t\t\t\tisSubsequentLine ||\n\t\t\t\t\ttextNode.childNodes.length\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tif (wasTooLong) {\n\t\t\t\twrapper.attr(\n\t\t\t\t\t'title',\n\t\t\t\t\tunescapeEntities(wrapper.textStr, ['&lt;', '&gt;']) // #7179\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (tempParent) {\n\t\t\t\ttempParent.removeChild(textNode);\n\t\t\t}\n\n\t\t\t// Apply the text outline\n\t\t\tif (textOutline && wrapper.applyTextOutline) {\n\t\t\t\twrapper.applyTextOutline(textOutline);\n\t\t\t}\n\t\t}\n\t},\n\n\n\n\t/*\n\tbreakText: function (wrapper, width) {\n\t\tvar bBox = wrapper.getBBox(),\n\t\t\tnode = wrapper.element,\n\t\t\tcharnum = node.textContent.length,\n\t\t\tstringWidth,\n\t\t\t// try this position first, based on average character width\n\t\t\tguessedLineCharLength = Math.round(width * charnum / bBox.width),\n\t\t\tpos = guessedLineCharLength,\n\t\t\tspans = [],\n\t\t\tincrement = 0,\n\t\t\tstartPos = 0,\n\t\t\tendPos,\n\t\t\tsafe = 0;\n\n\t\tif (bBox.width > width) {\n\t\t\twhile (startPos < charnum && safe < 100) {\n\n\t\t\t\twhile (endPos === undefined && safe < 100) {\n\t\t\t\t\tstringWidth = node.getSubStringLength(\n\t\t\t\t\t\tstartPos,\n\t\t\t\t\t\tpos - startPos\n\t\t\t\t\t);\n\n\t\t\t\t\tif (stringWidth <= width) {\n\t\t\t\t\t\tif (increment === -1) {\n\t\t\t\t\t\t\tendPos = pos;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tincrement = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (increment === 1) {\n\t\t\t\t\t\t\tendPos = pos - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tincrement = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos += increment;\n\t\t\t\t\tsafe++;\n\t\t\t\t}\n\n\t\t\t\tspans.push(\n\t\t\t\t\tnode.textContent.substr(startPos, endPos - startPos)\n\t\t\t\t);\n\n\t\t\t\tstartPos = endPos;\n\t\t\t\tpos = startPos + guessedLineCharLength;\n\t\t\t\tendPos = undefined;\t\t\t\n\t\t\t}\n\t\t}\n\n\t\treturn spans;\n\t},\n\t// */\n\n\t/**\n\t * Returns white for dark colors and black for bright colors.\n\t *\n\t * @param {ColorString} rgba - The color to get the contrast for.\n\t * @returns {string} The contrast color, either `#000000` or `#FFFFFF`.\n\t */\n\tgetContrast: function (rgba) {\n\t\trgba = color(rgba).rgba;\n\n\t\t// The threshold may be discussed. Here's a proposal for adding\n\t\t// different weight to the color channels (#6216)\n\t\t/*\n        rgba[0] *= 1; // red\n        rgba[1] *= 1.2; // green\n        rgba[2] *= 0.7; // blue\n        */\n\n\t\treturn rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';\n\t},\n\n\t/**\n\t * Create a button with preset states.\n\t * @param {string} text - The text or HTML to draw.\n\t * @param {number} x - The x position of the button's left side.\n\t * @param {number} y - The y position of the button's top side.\n\t * @param {Function} callback - The function to execute on button click or \n\t *    touch.\n\t * @param {SVGAttributes} [normalState] - SVG attributes for the normal\n\t *    state.\n\t * @param {SVGAttributes} [hoverState] - SVG attributes for the hover state.\n\t * @param {SVGAttributes} [pressedState] - SVG attributes for the pressed\n\t *    state.\n\t * @param {SVGAttributes} [disabledState] - SVG attributes for the disabled\n\t *    state.\n\t * @param {Symbol} [shape=rect] - The shape type.\n\t * @returns {SVGRenderer} The button element.\n\t */\n\tbutton: function (\n\t\ttext, \n\t\tx,\n\t\ty,\n\t\tcallback,\n\t\tnormalState,\n\t\thoverState,\n\t\tpressedState,\n\t\tdisabledState,\n\t\tshape\n\t) {\n\t\tvar label = this.label(\n\t\t\t\ttext,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tshape, \n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t'button'\n\t\t\t),\n\t\t\tcurState = 0;\n\n\t\t// Default, non-stylable attributes\n\t\tlabel.attr(merge({\n\t\t\t'padding': 8,\n\t\t\t'r': 2\n\t\t}, normalState));\n\n\t\t/*= if (build.classic) { =*/\n\t\t// Presentational\n\t\tvar normalStyle,\n\t\t\thoverStyle,\n\t\t\tpressedStyle,\n\t\t\tdisabledStyle;\n\n\t\t// Normal state - prepare the attributes\n\t\tnormalState = merge({\n\t\t\tfill: '${palette.neutralColor3}',\n\t\t\tstroke: '${palette.neutralColor20}',\n\t\t\t'stroke-width': 1,\n\t\t\tstyle: {\n\t\t\t\tcolor: '${palette.neutralColor80}',\n\t\t\t\tcursor: 'pointer',\n\t\t\t\tfontWeight: 'normal'\n\t\t\t}\n\t\t}, normalState);\n\t\tnormalStyle = normalState.style;\n\t\tdelete normalState.style;\n\n\t\t// Hover state\n\t\thoverState = merge(normalState, {\n\t\t\tfill: '${palette.neutralColor10}'\n\t\t}, hoverState);\n\t\thoverStyle = hoverState.style;\n\t\tdelete hoverState.style;\n\n\t\t// Pressed state\n\t\tpressedState = merge(normalState, {\n\t\t\tfill: '${palette.highlightColor10}',\n\t\t\tstyle: {\n\t\t\t\tcolor: '${palette.neutralColor100}',\n\t\t\t\tfontWeight: 'bold'\n\t\t\t}\n\t\t}, pressedState);\n\t\tpressedStyle = pressedState.style;\n\t\tdelete pressedState.style;\n\n\t\t// Disabled state\n\t\tdisabledState = merge(normalState, {\n\t\t\tstyle: {\n\t\t\t\tcolor: '${palette.neutralColor20}'\n\t\t\t}\n\t\t}, disabledState);\n\t\tdisabledStyle = disabledState.style;\n\t\tdelete disabledState.style;\n\t\t/*= } =*/\n\n\t\t// Add the events. IE9 and IE10 need mouseover and mouseout to funciton\n\t\t// (#667).\n\t\taddEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n\t\t\tif (curState !== 3) {\n\t\t\t\tlabel.setState(1);\n\t\t\t}\n\t\t});\n\t\taddEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n\t\t\tif (curState !== 3) {\n\t\t\t\tlabel.setState(curState);\n\t\t\t}\n\t\t});\n\n\t\tlabel.setState = function (state) {\n\t\t\t// Hover state is temporary, don't record it\n\t\t\tif (state !== 1) {\n\t\t\t\tlabel.state = curState = state;\n\t\t\t}\n\t\t\t// Update visuals\n\t\t\tlabel.removeClass(\n\t\t\t\t\t/highcharts-button-(normal|hover|pressed|disabled)/\n\t\t\t\t)\n\t\t\t\t.addClass(\n\t\t\t\t\t'highcharts-button-' +\n\t\t\t\t\t['normal', 'hover', 'pressed', 'disabled'][state || 0]\n\t\t\t\t);\n\t\t\t\n\t\t\t/*= if (build.classic) { =*/\n\t\t\tlabel.attr([\n\t\t\t\tnormalState,\n\t\t\t\thoverState,\n\t\t\t\tpressedState,\n\t\t\t\tdisabledState\n\t\t\t][state || 0])\n\t\t\t.css([\n\t\t\t\tnormalStyle,\n\t\t\t\thoverStyle,\n\t\t\t\tpressedStyle,\n\t\t\t\tdisabledStyle\n\t\t\t][state || 0]);\n\t\t\t/*= } =*/\n\t\t};\n\n\n\t\t/*= if (build.classic) { =*/\n\t\t// Presentational attributes\n\t\tlabel\n\t\t\t.attr(normalState)\n\t\t\t.css(extend({ cursor: 'default' }, normalStyle));\n\t\t/*= } =*/\n\n\t\treturn label\n\t\t\t.on('click', function (e) {\n\t\t\t\tif (curState !== 3) {\n\t\t\t\t\tcallback.call(label, e);\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\t/**\n\t * Make a straight line crisper by not spilling out to neighbour pixels.\n\t * \n\t * @param {Array} points - The original points on the format\n\t *                       `['M', 0, 0, 'L', 100, 0]`.\n\t * @param {number} width - The width of the line.\n\t * @returns {Array} The original points array, but modified to render\n\t * crisply.\n\t */\n\tcrispLine: function (points, width) {\n\t\t// normalize to a crisp line\n\t\tif (points[1] === points[4]) {\n\t\t\t// Substract due to #1129. Now bottom and left axis gridlines behave\n\t\t\t// the same.\n\t\t\tpoints[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);\n\t\t}\n\t\tif (points[2] === points[5]) {\n\t\t\tpoints[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);\n\t\t}\n\t\treturn points;\n\t},\n\n\n\t/**\n\t * Draw a path, wraps the SVG `path` element.\n\t * \n\t * @param {Array} [path] An SVG path definition in array form.\n\t * \n\t * @example\n\t * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])\n\t *     .attr({ stroke: '#ff00ff' })\n\t *     .add();\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-path-on-chart/\n\t *         Draw a path in a chart\n\t * @sample highcharts/members/renderer-path/\n\t *         Draw a path independent from a chart\n\t *\n\t *//**\n\t * Draw a path, wraps the SVG `path` element.\n\t * \n\t * @param {SVGAttributes} [attribs] The initial attributes.\n\t * @returns {SVGElement} The generated wrapper element.\n\t */\n\tpath: function (path) {\n\t\tvar attribs = {\n\t\t\t/*= if (build.classic) { =*/\n\t\t\tfill: 'none'\n\t\t\t/*= } =*/\n\t\t};\n\t\tif (isArray(path)) {\n\t\t\tattribs.d = path;\n\t\t} else if (isObject(path)) { // attributes\n\t\t\textend(attribs, path);\n\t\t}\n\t\treturn this.createElement('path').attr(attribs);\n\t},\n\n\t/**\n\t * Draw a circle, wraps the SVG `circle` element.\n\t * \n\t * @param {number} [x] The center x position.\n\t * @param {number} [y] The center y position.\n\t * @param {number} [r] The radius.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-circle/ Drawing a circle\n\t *//**\n\t * Draw a circle, wraps the SVG `circle` element.\n\t * \n\t * @param {SVGAttributes} [attribs] The initial attributes.\n\t * @returns {SVGElement} The generated wrapper element.\n\t */\n\tcircle: function (x, y, r) {\n\t\tvar attribs = isObject(x) ? x : { x: x, y: y, r: r },\n\t\t\twrapper = this.createElement('circle');\n\n\t\t// Setting x or y translates to cx and cy\n\t\twrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n\t\t\telement.setAttribute('c' + key, value);\n\t\t};\n\n\t\treturn wrapper.attr(attribs);\n\t},\n\n\t/**\n\t * Draw and return an arc.\n\t * @param {number} [x=0] Center X position.\n\t * @param {number} [y=0] Center Y position.\n\t * @param {number} [r=0] The outer radius of the arc.\n\t * @param {number} [innerR=0] Inner radius like used in donut charts.\n\t * @param {number} [start=0] The starting angle of the arc in radians, where\n\t *    0 is to the right and `-Math.PI/2` is up.\n\t * @param {number} [end=0] The ending angle of the arc in radians, where 0\n\t *    is to the right and `-Math.PI/2` is up.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-arc/\n\t *         Drawing an arc\n\t *//**\n\t * Draw and return an arc. Overloaded function that takes arguments object.\n\t * @param {SVGAttributes} attribs Initial SVG attributes.\n\t * @returns {SVGElement} The generated wrapper element.\n\t */\n\tarc: function (x, y, r, innerR, start, end) {\n\t\tvar arc,\n\t\t\toptions;\n\n\t\tif (isObject(x)) {\n\t\t\toptions = x;\n\t\t\ty = options.y;\n\t\t\tr = options.r;\n\t\t\tinnerR = options.innerR;\n\t\t\tstart = options.start;\n\t\t\tend = options.end;\n\t\t\tx = options.x;\n\t\t} else {\n\t\t\toptions = {\n\t\t\t\tinnerR: innerR,\n\t\t\t\tstart: start,\n\t\t\t\tend: end\n\t\t\t};\n\t\t}\n\n\t\t// Arcs are defined as symbols for the ability to set\n\t\t// attributes in attr and animate\n\t\tarc = this.symbol('arc', x, y, r, r, options);\n\t\tarc.r = r; // #959\n\t\treturn arc;\n\t},\n\n\t/**\n\t * Draw and return a rectangle.\n\t * @param {number} [x] Left position.\n\t * @param {number} [y] Top position.\n\t * @param {number} [width] Width of the rectangle.\n\t * @param {number} [height] Height of the rectangle.\n\t * @param {number} [r] Border corner radius.\n\t * @param {number} [strokeWidth] A stroke width can be supplied to allow\n\t *    crisp drawing.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *//**\n\t * Draw and return a rectangle.\n\t * @param  {SVGAttributes} [attributes]\n\t *         General SVG attributes for the rectangle.\n\t * @return {SVGElement}\n\t *         The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-rect-on-chart/\n\t *         Draw a rectangle in a chart\n\t * @sample highcharts/members/renderer-rect/\n\t *         Draw a rectangle independent from a chart\n\t */\n\trect: function (x, y, width, height, r, strokeWidth) {\n\n\t\tr = isObject(x) ? x.r : r;\n\n\t\tvar wrapper = this.createElement('rect'),\n\t\t\tattribs = isObject(x) ? x : x === undefined ? {} : {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: Math.max(width, 0),\n\t\t\t\theight: Math.max(height, 0)\n\t\t\t};\n\n\t\t/*= if (build.classic) { =*/\n\t\tif (strokeWidth !== undefined) {\n\t\t\tattribs.strokeWidth = strokeWidth;\n\t\t\tattribs = wrapper.crisp(attribs);\n\t\t}\n\t\tattribs.fill = 'none';\n\t\t/*= } =*/\n\n\t\tif (r) {\n\t\t\tattribs.r = r;\n\t\t}\n\n\t\twrapper.rSetter = function (value, key, element) {\n\t\t\tattr(element, {\n\t\t\t\trx: value,\n\t\t\t\try: value\n\t\t\t});\n\t\t};\n\n\t\treturn wrapper.attr(attribs);\n\t},\n\n\t/**\n\t * Resize the {@link SVGRenderer#box} and re-align all aligned child\n\t * elements.\n\t * @param  {number} width\n\t *         The new pixel width.\n\t * @param  {number} height\n\t *         The new pixel height.\n\t * @param  {Boolean|AnimationOptions} [animate=true]\n\t *         Whether and how to animate.\n\t */\n\tsetSize: function (width, height, animate) {\n\t\tvar renderer = this,\n\t\t\talignedObjects = renderer.alignedObjects,\n\t\t\ti = alignedObjects.length;\n\n\t\trenderer.width = width;\n\t\trenderer.height = height;\n\n\t\trenderer.boxWrapper.animate({\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t}, {\n\t\t\tstep: function () {\n\t\t\t\tthis.attr({\n\t\t\t\t\tviewBox: '0 0 ' + this.attr('width') + ' ' +\n\t\t\t\t\t\tthis.attr('height')\n\t\t\t\t});\n\t\t\t},\n\t\t\tduration: pick(animate, true) ? undefined : 0\n\t\t});\n\n\t\twhile (i--) {\n\t\t\talignedObjects[i].align();\n\t\t}\n\t},\n\n\t/**\n\t * Create and return an svg group element. Child\n\t * {@link Highcharts.SVGElement} objects are added to the group by using the\n\t * group as the first parameter\n\t * in {@link Highcharts.SVGElement#add|add()}.\n\t * \n\t * @param {string} [name] The group will be given a class name of\n\t * `highcharts-{name}`. This can be used for styling and scripting.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-g/\n\t *         Show and hide grouped objects\n\t */\n\tg: function (name) {\n\t\tvar elem = this.createElement('g');\n\t\treturn name ? elem.attr({ 'class': 'highcharts-' + name }) : elem;\n\t},\n\n\t/**\n\t * Display an image.\n\t * @param {string} src The image source.\n\t * @param {number} [x] The X position.\n\t * @param {number} [y] The Y position.\n\t * @param {number} [width] The image width. If omitted, it defaults to the \n\t *    image file width.\n\t * @param {number} [height] The image height. If omitted it defaults to the\n\t *    image file height.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-image-on-chart/\n\t *         Add an image in a chart\n\t * @sample highcharts/members/renderer-image/\n\t *         Add an image independent of a chart\n\t */\n\timage: function (src, x, y, width, height) {\n\t\tvar attribs = {\n\t\t\t\tpreserveAspectRatio: 'none'\n\t\t\t},\n\t\t\telemWrapper;\n\n\t\t// optional properties\n\t\tif (arguments.length > 1) {\n\t\t\textend(attribs, {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\telemWrapper = this.createElement('image').attr(attribs);\n\n\t\t// set the href in the xlink namespace\n\t\tif (elemWrapper.element.setAttributeNS) {\n\t\t\telemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n\t\t\t\t'href', src);\n\t\t} else {\n\t\t\t// could be exporting in IE\n\t\t\t// using href throws \"not supported\" in ie7 and under, requries\n\t\t\t// regex shim to fix later\n\t\t\telemWrapper.element.setAttribute('hc-svg-href', src);\n\t\t}\n\t\treturn elemWrapper;\n\t},\n\n\t/**\n\t * Draw a symbol out of pre-defined shape paths from\n\t * {@link SVGRenderer#symbols}.\n\t * It is used in Highcharts for point makers, which cake a `symbol` option,\n\t * and label and button backgrounds like in the tooltip and stock flags.\n\t *\n\t * @param {Symbol} symbol - The symbol name.\n\t * @param {number} x - The X coordinate for the top left position.\n\t * @param {number} y - The Y coordinate for the top left position.\n\t * @param {number} width - The pixel width.\n\t * @param {number} height - The pixel height.\n\t * @param {Object} [options] - Additional options, depending on the actual\n\t *    symbol drawn. \n\t * @param {number} [options.anchorX] - The anchor X position for the\n\t *    `callout` symbol. This is where the chevron points to.\n\t * @param {number} [options.anchorY] - The anchor Y position for the\n\t *    `callout` symbol. This is where the chevron points to.\n\t * @param {number} [options.end] - The end angle of an `arc` symbol.\n\t * @param {boolean} [options.open] - Whether to draw `arc` symbol open or\n\t *    closed.\n\t * @param {number} [options.r] - The radius of an `arc` symbol, or the\n\t *    border radius for the `callout` symbol.\n\t * @param {number} [options.start] - The start angle of an `arc` symbol.\n\t */\n\tsymbol: function (symbol, x, y, width, height, options) {\n\n\t\tvar ren = this,\n\t\t\tobj,\n\t\t\timageRegex = /^url\\((.*?)\\)$/,\n\t\t\tisImage = imageRegex.test(symbol),\n\t\t\tsym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),\n\t\t\t\n\n\t\t\t// get the symbol definition function\n\t\t\tsymbolFn = sym && this.symbols[sym],\n\n\t\t\t// check if there's a path defined for this symbol\n\t\t\tpath = defined(x) && symbolFn && symbolFn.call(\n\t\t\t\tthis.symbols,\n\t\t\t\tMath.round(x),\n\t\t\t\tMath.round(y),\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\toptions\n\t\t\t),\n\t\t\timageSrc,\n\t\t\tcenterImage;\n\n\t\tif (symbolFn) {\n\t\t\tobj = this.path(path);\n\n\t\t\t/*= if (build.classic) { =*/\n\t\t\tobj.attr('fill', 'none');\n\t\t\t/*= } =*/\n\t\t\t\n\t\t\t// expando properties for use in animate and attr\n\t\t\textend(obj, {\n\t\t\t\tsymbolName: sym,\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t\tif (options) {\n\t\t\t\textend(obj, options);\n\t\t\t}\n\n\n\t\t// Image symbols\n\t\t} else if (isImage) {\n\n\t\t\t\n\t\t\timageSrc = symbol.match(imageRegex)[1];\n\n\t\t\t// Create the image synchronously, add attribs async\n\t\t\tobj = this.image(imageSrc);\n\n\t\t\t// The image width is not always the same as the symbol width. The\n\t\t\t// image may be centered within the symbol, as is the case when\n\t\t\t// image shapes are used as label backgrounds, for example in flags.\n\t\t\tobj.imgwidth = pick(\n\t\t\t\tsymbolSizes[imageSrc] && symbolSizes[imageSrc].width,\n\t\t\t\toptions && options.width\n\t\t\t);\n\t\t\tobj.imgheight = pick(\n\t\t\t\tsymbolSizes[imageSrc] && symbolSizes[imageSrc].height,\n\t\t\t\toptions && options.height\n\t\t\t);\n\t\t\t/**\n\t\t\t * Set the size and position\n\t\t\t */\n\t\t\tcenterImage = function () {\n\t\t\t\tobj.attr({\n\t\t\t\t\twidth: obj.width,\n\t\t\t\t\theight: obj.height\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Width and height setters that take both the image's physical size\n\t\t\t * and the label size into consideration, and translates the image\n\t\t\t * to center within the label.\n\t\t\t */\n\t\t\teach(['width', 'height'], function (key) {\n\t\t\t\tobj[key + 'Setter'] = function (value, key) {\n\t\t\t\t\tvar attribs = {},\n\t\t\t\t\t\timgSize = this['img' + key],\n\t\t\t\t\t\ttrans = key === 'width' ? 'translateX' : 'translateY';\n\t\t\t\t\tthis[key] = value;\n\t\t\t\t\tif (defined(imgSize)) {\n\t\t\t\t\t\tif (this.element) {\n\t\t\t\t\t\t\tthis.element.setAttribute(key, imgSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!this.alignByTranslate) {\n\t\t\t\t\t\t\tattribs[trans] = ((this[key] || 0) - imgSize) / 2;\n\t\t\t\t\t\t\tthis.attr(attribs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\n\t\t\tif (defined(x)) {\n\t\t\t\tobj.attr({\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t});\n\t\t\t}\n\t\t\tobj.isImg = true;\n\n\t\t\tif (defined(obj.imgwidth) && defined(obj.imgheight)) {\n\t\t\t\tcenterImage();\n\t\t\t} else {\n\t\t\t\t// Initialize image to be 0 size so export will still function\n\t\t\t\t// if there's no cached sizes.\n\t\t\t\tobj.attr({ width: 0, height: 0 });\n\n\t\t\t\t// Create a dummy JavaScript image to get the width and height. \n\t\t\t\tcreateElement('img', {\n\t\t\t\t\tonload: function () {\n\n\t\t\t\t\t\tvar chart = charts[ren.chartIndex];\n\n\t\t\t\t\t\t// Special case for SVGs on IE11, the width is not\n\t\t\t\t\t\t// accessible until the image is part of the DOM\n\t\t\t\t\t\t// (#2854).\n\t\t\t\t\t\tif (this.width === 0) {\n\t\t\t\t\t\t\tcss(this, {\n\t\t\t\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\t\t\t\ttop: '-999em'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdoc.body.appendChild(this);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Center the image\n\t\t\t\t\t\tsymbolSizes[imageSrc] = { // Cache for next\t\n\t\t\t\t\t\t\twidth: this.width,\n\t\t\t\t\t\t\theight: this.height\n\t\t\t\t\t\t};\n\t\t\t\t\t\tobj.imgwidth = this.width;\n\t\t\t\t\t\tobj.imgheight = this.height;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (obj.element) {\n\t\t\t\t\t\t\tcenterImage();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Clean up after #2854 workaround.\n\t\t\t\t\t\tif (this.parentNode) {\n\t\t\t\t\t\t\tthis.parentNode.removeChild(this);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fire the load event when all external images are\n\t\t\t\t\t\t// loaded\n\t\t\t\t\t\tren.imgCount--;\n\t\t\t\t\t\tif (!ren.imgCount && chart && chart.onload) {\n\t\t\t\t\t\t\tchart.onload();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsrc: imageSrc\n\t\t\t\t});\n\t\t\t\tthis.imgCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t/**\n\t * @typedef {string} Symbol\n\t * \n\t * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,\n\t * `triangle`, `triangle-down`. Symbols are used internally for point\n\t * markers, button and label borders and backgrounds, or custom shapes.\n\t * Extendable by adding to {@link SVGRenderer#symbols}.\n\t */\n\t/**\n\t * An extendable collection of functions for defining symbol paths.\n\t */\n\tsymbols: {\n\t\t'circle': function (x, y, w, h) {\n\t\t\t// Return a full arc\n\t\t\treturn this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {\n\t\t\t\tstart: 0,\n\t\t\t\tend: Math.PI * 2,\n\t\t\t\topen: false\n\t\t\t});\n\t\t},\n\n\t\t'square': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x, y,\n\t\t\t\t'L', x + w, y,\n\t\t\t\tx + w, y + h,\n\t\t\t\tx, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\n\t\t'triangle': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x + w / 2, y,\n\t\t\t\t'L', x + w, y + h,\n\t\t\t\tx, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\n\t\t'triangle-down': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x, y,\n\t\t\t\t'L', x + w, y,\n\t\t\t\tx + w / 2, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\t\t'diamond': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x + w / 2, y,\n\t\t\t\t'L', x + w, y + h / 2,\n\t\t\t\tx + w / 2, y + h,\n\t\t\t\tx, y + h / 2,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\t\t'arc': function (x, y, w, h, options) {\n\t\t\tvar start = options.start,\n\t\t\t\trx = options.r || w,\n\t\t\t\try = options.r || h || w,\n\t\t\t\tproximity = 0.001,\n\t\t\t\tfullCircle = \n\t\t\t\t\tMath.abs(options.end - options.start - 2 * Math.PI) <\n\t\t\t\t\tproximity,\n\t\t\t\t// Substract a small number to prevent cos and sin of start and\n\t\t\t\t// end from becoming equal on 360 arcs (related: #1561)\n\t\t\t\tend = options.end - proximity, \n\t\t\t\tinnerRadius = options.innerR,\n\t\t\t\topen = pick(options.open, fullCircle),\n\t\t\t\tcosStart = Math.cos(start),\n\t\t\t\tsinStart = Math.sin(start),\n\t\t\t\tcosEnd = Math.cos(end),\n\t\t\t\tsinEnd = Math.sin(end),\n\t\t\t\t// Proximity takes care of rounding errors around PI (#6971)\n\t\t\t\tlongArc = options.end - start - Math.PI < proximity ? 0 : 1,\n\t\t\t\tarc;\n\n\t\t\tarc = [\n\t\t\t\t'M',\n\t\t\t\tx + rx * cosStart,\n\t\t\t\ty + ry * sinStart,\n\t\t\t\t'A', // arcTo\n\t\t\t\trx, // x radius\n\t\t\t\try, // y radius\n\t\t\t\t0, // slanting\n\t\t\t\tlongArc, // long or short arc\n\t\t\t\t1, // clockwise\n\t\t\t\tx + rx * cosEnd,\n\t\t\t\ty + ry * sinEnd\n\t\t\t];\n\n\t\t\tif (defined(innerRadius)) {\n\t\t\t\tarc.push(\n\t\t\t\t\topen ? 'M' : 'L',\n\t\t\t\t\tx + innerRadius * cosEnd,\n\t\t\t\t\ty + innerRadius * sinEnd,\n\t\t\t\t\t'A', // arcTo\n\t\t\t\t\tinnerRadius, // x radius\n\t\t\t\t\tinnerRadius, // y radius\n\t\t\t\t\t0, // slanting\n\t\t\t\t\tlongArc, // long or short arc\n\t\t\t\t\t0, // clockwise\n\t\t\t\t\tx + innerRadius * cosStart,\n\t\t\t\t\ty + innerRadius * sinStart\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tarc.push(open ? '' : 'Z'); // close\n\t\t\treturn arc;\n\t\t},\n\n\t\t/**\n\t\t * Callout shape used for default tooltips, also used for rounded\n\t\t * rectangles in VML\n\t\t */\n\t\tcallout: function (x, y, w, h, options) {\n\t\t\tvar arrowLength = 6,\n\t\t\t\thalfDistance = 6,\n\t\t\t\tr = Math.min((options && options.r) || 0, w, h),\n\t\t\t\tsafeDistance = r + halfDistance,\n\t\t\t\tanchorX = options && options.anchorX,\n\t\t\t\tanchorY = options && options.anchorY,\n\t\t\t\tpath;\n\n\t\t\tpath = [\n\t\t\t\t'M', x + r, y,\n\t\t\t\t'L', x + w - r, y, // top side\n\t\t\t\t'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n\t\t\t\t'L', x + w, y + h - r, // right side\n\t\t\t\t'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt\n\t\t\t\t'L', x + r, y + h, // bottom side\n\t\t\t\t'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n\t\t\t\t'L', x, y + r, // left side\n\t\t\t\t'C', x, y, x, y, x + r, y // top-left corner\n\t\t\t];\n\n\t\t\t// Anchor on right side\n\t\t\tif (anchorX && anchorX > w) {\n\n\t\t\t\t// Chevron\n\t\t\t\tif (\n\t\t\t\t\tanchorY > y + safeDistance &&\n\t\t\t\t\tanchorY < y + h - safeDistance\n\t\t\t\t) {\n\t\t\t\t\tpath.splice(13, 3,\n\t\t\t\t\t\t'L', x + w, anchorY - halfDistance,\n\t\t\t\t\t\tx + w + arrowLength, anchorY,\n\t\t\t\t\t\tx + w, anchorY + halfDistance,\n\t\t\t\t\t\tx + w, y + h - r\n\t\t\t\t\t);\n\n\t\t\t\t// Simple connector\n\t\t\t\t} else {\n\t\t\t\t\tpath.splice(13, 3,\n\t\t\t\t\t\t'L', x + w, h / 2,\n\t\t\t\t\t\tanchorX, anchorY,\n\t\t\t\t\t\tx + w, h / 2,\n\t\t\t\t\t\tx + w, y + h - r\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t// Anchor on left side\n\t\t\t} else if (anchorX && anchorX < 0) {\n\n\t\t\t\t// Chevron\n\t\t\t\tif (\n\t\t\t\t\tanchorY > y + safeDistance &&\n\t\t\t\t\tanchorY < y + h - safeDistance\n\t\t\t\t) {\n\t\t\t\t\tpath.splice(33, 3,\n\t\t\t\t\t\t'L', x, anchorY + halfDistance,\n\t\t\t\t\t\tx - arrowLength, anchorY,\n\t\t\t\t\t\tx, anchorY - halfDistance,\n\t\t\t\t\t\tx, y + r\n\t\t\t\t\t);\n\n\t\t\t\t// Simple connector\n\t\t\t\t} else {\n\t\t\t\t\tpath.splice(33, 3,\n\t\t\t\t\t\t'L', x, h / 2,\n\t\t\t\t\t\tanchorX, anchorY,\n\t\t\t\t\t\tx, h / 2,\n\t\t\t\t\t\tx, y + r\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if ( // replace bottom\n\t\t\t\tanchorY &&\n\t\t\t\tanchorY > h &&\n\t\t\t\tanchorX > x + safeDistance &&\n\t\t\t\tanchorX < x + w - safeDistance\n\t\t\t) { \n\t\t\t\tpath.splice(23, 3,\n\t\t\t\t\t'L', anchorX + halfDistance, y + h,\n\t\t\t\t\tanchorX, y + h + arrowLength,\n\t\t\t\t\tanchorX - halfDistance, y + h,\n\t\t\t\t\tx + r, y + h\n\t\t\t\t\t);\n\n\t\t\t} else if ( // replace top\n\t\t\t\tanchorY &&\n\t\t\t\tanchorY < 0 &&\n\t\t\t\tanchorX > x + safeDistance &&\n\t\t\t\tanchorX < x + w - safeDistance\n\t\t\t) {\n\t\t\t\tpath.splice(3, 3,\n\t\t\t\t\t'L', anchorX - halfDistance, y,\n\t\t\t\t\tanchorX, y - arrowLength,\n\t\t\t\t\tanchorX + halfDistance, y,\n\t\t\t\t\tw - r, y\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\treturn path;\n\t\t}\n\t},\n\n\t/**\n\t * @typedef {SVGElement} ClipRect - A clipping rectangle that can be applied\n\t * to one or more {@link SVGElement} instances. It is instanciated with the\n\t * {@link SVGRenderer#clipRect} function and applied with the {@link \n\t * SVGElement#clip} function.\n\t *\n\t * @example\n\t * var circle = renderer.circle(100, 100, 100)\n\t *     .attr({ fill: 'red' })\n\t *     .add();\n\t * var clipRect = renderer.clipRect(100, 100, 100, 100);\n\t *\n\t * // Leave only the lower right quarter visible\n\t * circle.clip(clipRect);\n\t */\n\t/**\n\t * Define a clipping rectangle. The clipping rectangle is later applied\n\t * to {@link SVGElement} objects through the {@link SVGElement#clip}\n\t * function.\n\t * \n\t * @param {String} id\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} width\n\t * @param {number} height\n\t * @returns {ClipRect} A clipping rectangle.\n\t *\n\t * @example\n\t * var circle = renderer.circle(100, 100, 100)\n\t *     .attr({ fill: 'red' })\n\t *     .add();\n\t * var clipRect = renderer.clipRect(100, 100, 100, 100);\n\t *\n\t * // Leave only the lower right quarter visible\n\t * circle.clip(clipRect);\n\t */\n\tclipRect: function (x, y, width, height) {\n\t\tvar wrapper,\n\t\t\tid = H.uniqueKey(),\n\n\t\t\tclipPath = this.createElement('clipPath').attr({\n\t\t\t\tid: id\n\t\t\t}).add(this.defs);\n\n\t\twrapper = this.rect(x, y, width, height, 0).add(clipPath);\n\t\twrapper.id = id;\n\t\twrapper.clipPath = clipPath;\n\t\twrapper.count = 0;\n\n\t\treturn wrapper;\n\t},\n\n\n\n\n\n\t/**\n\t * Draw text. The text can contain a subset of HTML, like spans and anchors\n\t * and some basic text styling of these. For more advanced features like\n\t * border and background, use {@link Highcharts.SVGRenderer#label} instead.\n\t * To update the text after render, run `text.attr({ text: 'New text' })`.\n\t * @param  {String} str\n\t *         The text of (subset) HTML to draw.\n\t * @param  {number} x\n\t *         The x position of the text's lower left corner.\n\t * @param  {number} y\n\t *         The y position of the text's lower left corner.\n\t * @param  {Boolean} [useHTML=false]\n\t *         Use HTML to render the text.\n\t *\n\t * @return {SVGElement} The text object.\n\t *\n\t * @sample highcharts/members/renderer-text-on-chart/\n\t *         Annotate the chart freely\n\t * @sample highcharts/members/renderer-on-chart/\n\t *         Annotate with a border and in response to the data\n\t * @sample highcharts/members/renderer-text/\n\t *         Formatted text\n\t */\n\ttext: function (str, x, y, useHTML) {\n\n\t\t// declare variables\n\t\tvar renderer = this,\n\t\t\twrapper,\n\t\t\tattribs = {};\n\n\t\tif (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n\t\t\treturn renderer.html(str, x, y);\n\t\t}\n\n\t\tattribs.x = Math.round(x || 0); // X always needed for line-wrap logic\n\t\tif (y) {\n\t\t\tattribs.y = Math.round(y);\n\t\t}\n\t\tif (str || str === 0) {\n\t\t\tattribs.text = str;\n\t\t}\n\n\t\twrapper = renderer.createElement('text')\n\t\t\t.attr(attribs);\n\n\t\tif (!useHTML) {\n\t\t\twrapper.xSetter = function (value, key, element) {\n\t\t\t\tvar tspans = element.getElementsByTagName('tspan'),\n\t\t\t\t\ttspan,\n\t\t\t\t\tparentVal = element.getAttribute(key),\n\t\t\t\t\ti;\n\t\t\t\tfor (i = 0; i < tspans.length; i++) {\n\t\t\t\t\ttspan = tspans[i];\n\t\t\t\t\t// If the x values are equal, the tspan represents a\n\t\t\t\t\t// linebreak\n\t\t\t\t\tif (tspan.getAttribute(key) === parentVal) {\n\t\t\t\t\t\ttspan.setAttribute(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telement.setAttribute(key, value);\n\t\t\t};\n\t\t}\n\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Utility to return the baseline offset and total line height from the font\n\t * size.\n\t *\n\t * @param {?string} fontSize The current font size to inspect. If not given,\n\t *   the font size will be found from the DOM element.\n\t * @param {SVGElement|SVGDOMElement} [elem] The element to inspect for a\n\t *   current font size.\n\t * @returns {Object} An object containing `h`: the line height, `b`: the\n\t * baseline relative to the top of the box, and `f`: the font size.\n\t */\n\tfontMetrics: function (fontSize, elem) {\n\t\tvar lineHeight,\n\t\t\tbaseline;\n\n\t\t/*= if (build.classic) { =*/\n\t\tfontSize = fontSize ||\n\t\t\t// When the elem is a DOM element (#5932)\n\t\t\t(elem && elem.style && elem.style.fontSize) ||\n\t\t\t// Fall back on the renderer style default\n\t\t\t(this.style && this.style.fontSize);\n\n\t\t/*= } else { =*/\n\t\tfontSize = elem && SVGElement.prototype.getStyle.call(\n\t\t\telem,\n\t\t\t'font-size'\n\t\t);\n\t\t/*= } =*/\n\n\t\t// Handle different units\n\t\tif (/px/.test(fontSize)) {\n\t\t\tfontSize = pInt(fontSize);\n\t\t} else if (/em/.test(fontSize)) {\n\t\t\t// The em unit depends on parent items\n\t\t\tfontSize = parseFloat(fontSize) *\n\t\t\t\t(elem ? this.fontMetrics(null, elem.parentNode).f : 16);\n\t\t} else {\n\t\t\tfontSize = 12;\n\t\t}\n\n\t\t// Empirical values found by comparing font size and bounding box\n\t\t// height. Applies to the default font family.\n\t\t// http://jsfiddle.net/highcharts/7xvn7/\n\t\tlineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n\t\tbaseline = Math.round(lineHeight * 0.8);\n\n\t\treturn {\n\t\t\th: lineHeight,\n\t\t\tb: baseline,\n\t\t\tf: fontSize\n\t\t};\n\t},\n\n\t/**\n\t * Correct X and Y positioning of a label for rotation (#1764).\n\t *\n\t * @private\n\t */\n\trotCorr: function (baseline, rotation, alterY) {\n\t\tvar y = baseline;\n\t\tif (rotation && alterY) {\n\t\t\ty = Math.max(y * Math.cos(rotation * deg2rad), 4);\n\t\t}\n\t\treturn {\n\t\t\tx: (-baseline / 3) * Math.sin(rotation * deg2rad),\n\t\t\ty: y\n\t\t};\n\t},\n\n\t/**\n\t * Draw a label, which is an extended text element with support for border\n\t * and background. Highcharts creates a `g` element with a text and a `path`\n\t * or `rect` inside, to make it behave somewhat like a HTML div. Border and\n\t * background are set through `stroke`, `stroke-width` and `fill` attributes\n\t * using the {@link Highcharts.SVGElement#attr|attr} method. To update the\n\t * text after render, run `label.attr({ text: 'New text' })`.\n\t * \n\t * @param  {string} str\n\t *         The initial text string or (subset) HTML to render.\n\t * @param  {number} x\n\t *         The x position of the label's left side.\n\t * @param  {number} y\n\t *         The y position of the label's top side or baseline, depending on\n\t *         the `baseline` parameter.\n\t * @param  {String} shape\n\t *         The shape of the label's border/background, if any. Defaults to\n\t *         `rect`. Other possible values are `callout` or other shapes\n\t *         defined in {@link Highcharts.SVGRenderer#symbols}.\n\t * @param  {number} anchorX\n\t *         In case the `shape` has a pointer, like a flag, this is the\n\t *         coordinates it should be pinned to.\n\t * @param  {number} anchorY\n\t *         In case the `shape` has a pointer, like a flag, this is the\n\t *         coordinates it should be pinned to.\n\t * @param  {Boolean} baseline\n\t *         Whether to position the label relative to the text baseline,\n\t *\t       like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the\n\t *\t       upper border of the rectangle.\n\t * @param  {String} className\n\t *         Class name for the group.\n\t *\n\t * @return {SVGElement}\n\t *         The generated label.\n\t *\n\t * @sample highcharts/members/renderer-label-on-chart/\n\t *         A label on the chart\n\t */\n\tlabel: function (\n\t\tstr,\n\t\tx,\n\t\ty,\n\t\tshape,\n\t\tanchorX,\n\t\tanchorY,\n\t\tuseHTML,\n\t\tbaseline,\n\t\tclassName\n\t) {\n\n\t\tvar renderer = this,\n\t\t\twrapper = renderer.g(className !== 'button' && 'label'),\n\t\t\ttext = wrapper.text = renderer.text('', 0, 0, useHTML)\n\t\t\t\t.attr({\n\t\t\t\t\tzIndex: 1\n\t\t\t\t}),\n\t\t\tbox,\n\t\t\tbBox,\n\t\t\talignFactor = 0,\n\t\t\tpadding = 3,\n\t\t\tpaddingLeft = 0,\n\t\t\twidth,\n\t\t\theight,\n\t\t\twrapperX,\n\t\t\twrapperY,\n\t\t\ttextAlign,\n\t\t\tdeferredAttr = {},\n\t\t\tstrokeWidth,\n\t\t\tbaselineOffset,\n\t\t\thasBGImage = /^url\\((.*?)\\)$/.test(shape),\n\t\t\tneedsBox = hasBGImage,\n\t\t\tgetCrispAdjust,\n\t\t\tupdateBoxSize,\n\t\t\tupdateTextPadding,\n\t\t\tboxAttr;\n\n\t\tif (className) {\n\t\t\twrapper.addClass('highcharts-' + className);\n\t\t}\n\n\t\t/*= if (!build.classic) { =*/\n\t\tneedsBox = true; // for styling\n\t\tgetCrispAdjust = function () {\n\t\t\treturn box.strokeWidth() % 2 / 2;\n\t\t};\n\t\t/*= } else { =*/\n\t\tneedsBox = hasBGImage;\n\t\tgetCrispAdjust = function () {\n\t\t\treturn (strokeWidth || 0) % 2 / 2;\n\t\t};\n\n\t\t/*= } =*/\n\n\t\t/**\n\t\t * This function runs after the label is added to the DOM (when the\n\t\t * bounding box is available), and after the text of the label is\n\t\t * updated to detect the new bounding box and reflect it in the border\n\t\t * box.\n\t\t */\n\t\tupdateBoxSize = function () {\n\t\t\tvar style = text.element.style,\n\t\t\t\tcrispAdjust,\n\t\t\t\tattribs = {};\n\n\t\t\tbBox = (\n\t\t\t\t(width === undefined || height === undefined || textAlign) &&\n\t\t\t\tdefined(text.textStr) &&\n\t\t\t\ttext.getBBox()\n\t\t\t); // #3295 && 3514 box failure when string equals 0\n\t\t\twrapper.width = (\n\t\t\t\t(width || bBox.width || 0) +\n\t\t\t\t2 * padding +\n\t\t\t\tpaddingLeft\n\t\t\t);\n\t\t\twrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n\t\t\t// Update the label-scoped y offset\n\t\t\tbaselineOffset = padding +\n\t\t\t\trenderer.fontMetrics(style && style.fontSize, text).b;\n\n\n\t\t\tif (needsBox) {\n\n\t\t\t\t// Create the border box if it is not already present\n\t\t\t\tif (!box) {\n\t\t\t\t\t// Symbol definition exists (#5324)\n\t\t\t\t\twrapper.box = box = renderer.symbols[shape] || hasBGImage ? \n\t\t\t\t\t\trenderer.symbol(shape) :\n\t\t\t\t\t\trenderer.rect();\n\t\t\t\t\t\n\t\t\t\t\tbox.addClass( // Don't use label className for buttons\n\t\t\t\t\t\t(className === 'button' ? '' : 'highcharts-label-box') +\n\t\t\t\t\t\t(className ? ' highcharts-' + className + '-box' : '')\n\t\t\t\t\t);\n\n\t\t\t\t\tbox.add(wrapper);\n\n\t\t\t\t\tcrispAdjust = getCrispAdjust();\n\t\t\t\t\tattribs.x = crispAdjust;\n\t\t\t\t\tattribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n\t\t\t\t}\n\n\t\t\t\t// Apply the box attributes\n\t\t\t\tattribs.width = Math.round(wrapper.width);\n\t\t\t\tattribs.height = Math.round(wrapper.height);\n\t\t\t\t\n\t\t\t\tbox.attr(extend(attribs, deferredAttr));\n\t\t\t\tdeferredAttr = {};\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * This function runs after setting text or padding, but only if padding\n\t\t * is changed\n\t\t */\n\t\tupdateTextPadding = function () {\n\t\t\tvar textX = paddingLeft + padding,\n\t\t\t\ttextY;\n\n\t\t\t// determin y based on the baseline\n\t\t\ttextY = baseline ? 0 : baselineOffset;\n\n\t\t\t// compensate for alignment\n\t\t\tif (\n\t\t\t\tdefined(width) &&\n\t\t\t\tbBox &&\n\t\t\t\t(textAlign === 'center' || textAlign === 'right')\n\t\t\t) {\n\t\t\t\ttextX += { center: 0.5, right: 1 }[textAlign] *\n\t\t\t\t\t(width - bBox.width);\n\t\t\t}\n\n\t\t\t// update if anything changed\n\t\t\tif (textX !== text.x || textY !== text.y) {\n\t\t\t\ttext.attr('x', textX);\n\t\t\t\tif (textY !== undefined) {\n\t\t\t\t\ttext.attr('y', textY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// record current values\n\t\t\ttext.x = textX;\n\t\t\ttext.y = textY;\n\t\t};\n\n\t\t/**\n\t\t * Set a box attribute, or defer it if the box is not yet created\n\t\t * @param {Object} key\n\t\t * @param {Object} value\n\t\t */\n\t\tboxAttr = function (key, value) {\n\t\t\tif (box) {\n\t\t\t\tbox.attr(key, value);\n\t\t\t} else {\n\t\t\t\tdeferredAttr[key] = value;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * After the text element is added, get the desired size of the border\n\t\t * box and add it before the text in the DOM.\n\t\t */\n\t\twrapper.onAdd = function () {\n\t\t\ttext.add(wrapper);\n\t\t\twrapper.attr({\n\t\t\t\t// Alignment is available now  (#3295, 0 not rendered if given\n\t\t\t\t// as a value)\n\t\t\t\ttext: (str || str === 0) ? str : '',\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\n\t\t\tif (box && defined(anchorX)) {\n\t\t\t\twrapper.attr({\n\t\t\t\t\tanchorX: anchorX,\n\t\t\t\t\tanchorY: anchorY\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t\t * Add specific attribute setters.\n\t\t */\n\n\t\t// only change local variables\n\t\twrapper.widthSetter = function (value) {\n\t\t\twidth = H.isNumber(value) ? value : null; // width:auto => null\n\t\t};\n\t\twrapper.heightSetter = function (value) {\n\t\t\theight = value;\n\t\t};\n\t\twrapper['text-alignSetter'] = function (value) {\n\t\t\ttextAlign = value;\n\t\t};\n\t\twrapper.paddingSetter =  function (value) {\n\t\t\tif (defined(value) && value !== padding) {\n\t\t\t\tpadding = wrapper.padding = value;\n\t\t\t\tupdateTextPadding();\n\t\t\t}\n\t\t};\n\t\twrapper.paddingLeftSetter =  function (value) {\n\t\t\tif (defined(value) && value !== paddingLeft) {\n\t\t\t\tpaddingLeft = value;\n\t\t\t\tupdateTextPadding();\n\t\t\t}\n\t\t};\n\n\n\t\t// change local variable and prevent setting attribute on the group\n\t\twrapper.alignSetter = function (value) {\n\t\t\tvalue = { left: 0, center: 0.5, right: 1 }[value];\n\t\t\tif (value !== alignFactor) {\n\t\t\t\talignFactor = value;\n\t\t\t\t// Bounding box exists, means we're dynamically changing\n\t\t\t\tif (bBox) {\n\t\t\t\t\twrapper.attr({ x: wrapperX }); // #5134\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// apply these to the box and the text alike\n\t\twrapper.textSetter = function (value) {\n\t\t\tif (value !== undefined) {\n\t\t\t\ttext.textSetter(value);\n\t\t\t}\n\t\t\tupdateBoxSize();\n\t\t\tupdateTextPadding();\n\t\t};\n\n\t\t// apply these to the box but not to the text\n\t\twrapper['stroke-widthSetter'] = function (value, key) {\n\t\t\tif (value) {\n\t\t\t\tneedsBox = true;\n\t\t\t}\n\t\t\tstrokeWidth = this['stroke-width'] = value;\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\t/*= if (!build.classic) { =*/\n\t\twrapper.rSetter = function (value, key) {\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\t/*= } else { =*/\n\t\twrapper.strokeSetter =\n\t\twrapper.fillSetter =\n\t\twrapper.rSetter = function (value, key) {\n\t\t\tif (key !== 'r') {\n\t\t\t\tif (key === 'fill' && value) {\n\t\t\t\t\tneedsBox = true;\n\t\t\t\t}\n\t\t\t\t// for animation getter (#6776)\n\t\t\t\twrapper[key] = value;\n\t\t\t}\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\t/*= } =*/\n\t\twrapper.anchorXSetter = function (value, key) {\n\t\t\tanchorX = wrapper.anchorX = value;\n\t\t\tboxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n\t\t};\n\t\twrapper.anchorYSetter = function (value, key) {\n\t\t\tanchorY = wrapper.anchorY = value;\n\t\t\tboxAttr(key, value - wrapperY);\n\t\t};\n\n\t\t// rename attributes\n\t\twrapper.xSetter = function (value) {\n\t\t\twrapper.x = value; // for animation getter\n\t\t\tif (alignFactor) {\n\t\t\t\tvalue -= alignFactor * ((width || bBox.width) + 2 * padding);\n\n\t\t\t\t// Force animation even when setting to the same value (#7898)\n\t\t\t\twrapper['forceAnimate:x'] = true;\n\t\t\t}\n\t\t\twrapperX = Math.round(value);\n\t\t\twrapper.attr('translateX', wrapperX);\n\t\t};\n\t\twrapper.ySetter = function (value) {\n\t\t\twrapperY = wrapper.y = Math.round(value);\n\t\t\twrapper.attr('translateY', wrapperY);\n\t\t};\n\n\t\t// Redirect certain methods to either the box or the text\n\t\tvar baseCss = wrapper.css;\n\t\treturn extend(wrapper, {\n\t\t\t/**\n\t\t\t * Pick up some properties and apply them to the text instead of the\n\t\t\t * wrapper.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tcss: function (styles) {\n\t\t\t\tif (styles) {\n\t\t\t\t\tvar textStyles = {};\n\t\t\t\t\t// Create a copy to avoid altering the original object\n\t\t\t\t\t// (#537)\n\t\t\t\t\tstyles = merge(styles); \n\t\t\t\t\teach(wrapper.textProps, function (prop) {\n\t\t\t\t\t\tif (styles[prop] !== undefined) {\n\t\t\t\t\t\t\ttextStyles[prop] = styles[prop];\n\t\t\t\t\t\t\tdelete styles[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ttext.css(textStyles);\n\t\t\t\t}\n\t\t\t\treturn baseCss.call(wrapper, styles);\n\t\t\t},\n\t\t\t/**\n\t\t\t * Return the bounding box of the box, not the group.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tgetBBox: function () {\n\t\t\t\treturn {\n\t\t\t\t\twidth: bBox.width + 2 * padding,\n\t\t\t\t\theight: bBox.height + 2 * padding,\n\t\t\t\t\tx: bBox.x - padding,\n\t\t\t\t\ty: bBox.y - padding\n\t\t\t\t};\n\t\t\t},\n\t\t\t/*= if (build.classic) { =*/\n\t\t\t/**\n\t\t\t * Apply the shadow to the box.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tshadow: function (b) {\n\t\t\t\tif (b) {\n\t\t\t\t\tupdateBoxSize();\n\t\t\t\t\tif (box) {\n\t\t\t\t\t\tbox.shadow(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn wrapper;\n\t\t\t},\n\t\t\t/*= } =*/\n\t\t\t/**\n\t\t\t * Destroy and release memory.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tdestroy: function () {\n\t\t\t\t\n\t\t\t\t// Added by button implementation\n\t\t\t\tremoveEvent(wrapper.element, 'mouseenter');\n\t\t\t\tremoveEvent(wrapper.element, 'mouseleave');\n\n\t\t\t\tif (text) {\n\t\t\t\t\ttext = text.destroy();\n\t\t\t\t}\n\t\t\t\tif (box) {\n\t\t\t\t\tbox = box.destroy();\n\t\t\t\t}\n\t\t\t\t// Call base implementation to destroy the rest\n\t\t\t\tSVGElement.prototype.destroy.call(wrapper);\n\n\t\t\t\t// Release local pointers (#1298)\n\t\t\t\twrapper =\n\t\t\t\trenderer =\n\t\t\t\tupdateBoxSize =\n\t\t\t\tupdateTextPadding =\n\t\t\t\tboxAttr = null;\n\t\t\t}\n\t\t});\n\t}\n}); // end SVGRenderer\n\n\n// general renderer\nH.Renderer = SVGRenderer;\n", "{\n  \"name\": \"highcharts\",\n  \"version\": \"6.0.7\",\n  \"description\": \"JavaScript charting framework\",\n  \"main\": \"lib/highcharts\",\n  \"author\": \"Highsoft AS <support@highcharts.com> (http://www.highcharts.com/about)\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/highcharts/highcharts.git\"\n  },\n  \"bugs\": \"https://github.com/highcharts/highcharts/issues\",\n  \"homepage\": \"http://www.highcharts.com\",\n  \"keywords\": [\n    \"charts\",\n    \"graphs\",\n    \"visualization\",\n    \"data\",\n    \"browserify\",\n    \"webpack\"\n  ],\n  \"files\": [\n    \"errors\",\n    \"gfx\",\n    \"js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"precommit\": \"lint-staged && gulp test\",\n    \"post-merge\": \"gulp styles && gulp scripts\"\n  },\n  \"devDependencies\": {\n    \"babel-plugin-transform-es2015-arrow-functions\": \"^6.8.0\",\n    \"browserify\": \"^12.0.2\",\n    \"closurecompiler\": \"^1.6.1\",\n    \"colors\": \"~1.1.2\",\n    \"eslint\": \"3.12.2\",\n    \"eslint-plugin-highcharts\": \"file:tools/eslint-plugin-highcharts\",\n    \"eslint-plugin-security\": \"^1.4.0\",\n    \"fs-extra\": \"^2.1.2\",\n    \"gifencoder\": \"^1.1.0\",\n    \"google-closure-compiler-js\": \"^20160916.0.0\",\n    \"grunt\": \"^0.4.5\",\n    \"grunt-jslint\": \"^1.1.12\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-jsdoc3\": \"^1.0.1\",\n    \"gzip-size\": \"^3.0.0\",\n    \"highcharts-api-doc-gen\": \"github:highcharts/api-docs\",\n    \"highcharts-assembler\": \"github:highcharts/highcharts-assembler#v1.0.25\",\n    \"husky\": \"^0.14.3\",\n    \"js-yaml\": \"^3.10.0\",\n    \"karma\": \"^1.7.1\",\n    \"karma-browserstack-launcher\": \"^1.3.0\",\n    \"karma-chrome-launcher\": \"^2.2.0\",\n    \"karma-edge-launcher\": \"^0.4.2\",\n    \"karma-firefox-launcher\": \"^1.0.1\",\n    \"karma-generic-preprocessor\": \"^1.1.0\",\n    \"karma-ie-launcher\": \"^1.0.0\",\n    \"karma-qunit\": \"^1.2.1\",\n    \"karma-safari-launcher\": \"^1.0.0\",\n    \"lint-staged\": \"^4.2.3\",\n    \"lolex\": \"^2.1.3\",\n    \"node-sass\": \"^4.5.3\",\n    \"pixelmatch\": \"^4.0.2\",\n    \"png-js\": \"^0.1.1\",\n    \"pngjs\": \"^3.3.0\",\n    \"qunitjs\": \"^2.4.0\",\n    \"request\": \"^2.81.0\",\n    \"requirejs\": \"^2.3.3\",\n    \"vinyl-ftp\": \"^0.4.5\",\n    \"webpack\": \"^1.15.0\",\n    \"xml2js\": \"^0.4.17\",\n    \"yargs\": \"^3.32.0\"\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      \"eslint\",\n      \"git add\"\n    ]\n  },\n  \"license\": \"SEE LICENSE IN <license.txt>\",\n  \"dependencies\": {\n    \"aws-sdk\": \"^2.94.0\",\n    \"babel-runtime\": \"^6.20.0\",\n    \"glob\": \"^7.1.2\",\n    \"taffydb\": \"^2.7.3\"\n  }\n}\n", "QUnit.test('titleSetter', function (assert) {\n    var chart = Highcharts.chart('container', {\n        }),\n        str = 'The quick brown fox<br> jumps over the lazy dog',\n        newTitle = 'Quick brown fox',\n        text = chart.renderer.text(str, 100, 100).css({ width: 100, textOverflow: 'ellipsis' }).add();\n\n    assert.strictEqual(\n        text.element.getElementsByTagName('title')[0].textContent, // Ideally there should be a titleGetter. text.attr('title')\n        str.replace('<br>', ''),\n        'Text element has a correct title. #5211'\n    );\n\n    // Update the title tag with a shorter text\n    text.attr('title', newTitle);\n    assert.strictEqual(\n        text.element.getElementsByTagName('title')[0].textContent, // Ideally there should be a titleGetter. text.attr('title')\n        newTitle,\n        'Text element title has been updated. #5211'\n    );\n});\n\nQUnit.test('getBBox with useHTML (#5899)', function (assert) {\n    var ren = new Highcharts.Renderer(\n        document.getElementById('container'),\n        600,\n        400\n    );\n\n    var text = ren.text(\n        '<div style=\"width: 500px\">Styled div</div>',\n        20,\n        20,\n        true\n    )\n    .add();\n\n    assert.strictEqual(\n        text.getBBox().width,\n        500,\n        'Initial bounding box'\n    );\n\n    text.attr({\n        text: '<div style=\"width: 400px\">Styled div</div>'\n    });\n\n    assert.strictEqual(\n        text.getBBox().width,\n        400,\n        'Updated bounding box'\n    );\n\n    text.attr({\n        text: null\n    });\n\n    assert.strictEqual(\n        text.getBBox().width,\n        0,\n        'Null text works fine (#7316)'\n    );\n});\n\nQUnit.test('textOverflow: ellipsis.', function (assert) {\n    var chart = Highcharts.chart('container', {}),\n        width = 50,\n        style = {\n            textOverflow: 'ellipsis',\n            width: width + 'px'\n        },\n        text1 = chart.renderer.text('01234567', 0, 100).css(style).add(),\n        text2 = chart.renderer.text('012345678', 0, 120).css(style).add();\n    assert.strictEqual(\n        text1.getBBox().width < width,\n        true,\n        'Width of text is lower than style.width'\n    );\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent.slice(-1),\n        '\\u2026',\n        'Ellipsis was added to text node.'\n    );\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent,\n        text2.element.childNodes[0].textContent,\n        'Consistent result between different strings. #6258'\n    );\n    // TODO 0px does not work, because ellipsis and breaks are not applied\n    // when width is considered falsy.\n    style.width = '1px';\n    text1.destroy();\n    text1 = chart.renderer.text('01234567', 0, 100).css(style).add();\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent,\n        '',\n        'Width was too small for ellipsis.'\n    );\n\n    /**\n     * Rotation. Width determines the length of a rotated text\n     */\n    text1.destroy();\n    text2.destroy();\n    style.width = '50px';\n    text1 = chart.renderer.text('01234567', 0, 100).attr({\n        rotation: 90\n    }).css(style).add();\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent.slice(-1),\n        '\\u2026',\n        'Ellipsis was added to text node which has rotation.'\n    );\n    assert.strictEqual(\n        text1.getBBox().height < width,\n        true,\n        'Height of text is lower than style.width'\n    );\n});\n\nQUnit.test('BBox for mulitiple lines', function (assert) {\n    var ren = new Highcharts.Renderer(\n        document.getElementById('container'),\n        200,\n        200\n    );\n\n    var lab = ren.label('<span></span><br/>line<br/>line', 20, 20)\n        .css({\n            color: '#f00'\n        })\n        .attr({\n            fill: 'rgba(0, 100, 0, 0.75)',\n            padding: 0\n        })\n        .add();\n\n    assert.strictEqual(\n        lab.element.getAttribute('dy'),\n        null,\n        \"Frist line shouldn't have dy (#6144) - visually the red text fits in the green box.\"\n    );\n});\n\nQUnit.test('HTML', function (assert) {\n    var ren = new Highcharts.SVGRenderer(\n        document.getElementById('container'),\n        500,\n        500\n    );\n\n    var text = ren.text('Hello &amp; &lt;tag&gt;', 10, 30).add();\n\n    assert.strictEqual(\n        text.element.textContent,\n        'Hello & <tag>',\n        'HTML entities decoded correctly'\n    );\n\n    text = ren.text('a < b and c > d', 10, 60).add();\n    assert.strictEqual(\n        text.element.textContent,\n        'a < b and c > d',\n        'Tags don\\'t start with spaces (#7126)'\n    );\n\n    var html = ren.text('useHTML', 100, 100, true).add();\n    assert.close(\n        html.element.offsetLeft,\n        100,\n        1,\n        'Left offset should reflect initial position'\n    );\n    assert.close(\n        html.element.offsetHeight + html.element.offsetTop,\n        100,\n        10,\n        'Top offset should reflect initial position'\n    );\n});\n\nQUnit.test('Dir rtl (#3482)', function (assert) {\n    document.getElementById('container').setAttribute('dir', 'rtl');\n    var ren = new Highcharts.Renderer(\n        document.getElementById('container'),\n        600,\n        400\n    );\n\n    var label = ren.label('Hello', 100, 100)\n        .attr({\n            stroke: 'blue',\n            'stroke-width': 1,\n            padding: 0\n        })\n        .add();\n\n    assert.close(\n        label.text.element.getBBox().x,\n        0,\n        2,\n        'Label sits nicely inside box'\n    );\n\n    document.getElementById('container').removeAttribute('dir');\n});\n"], "fixing_code": ["/**\n * (c) 2010-2017 Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n\n'use strict';\nimport H from './Globals.js';\nimport './Utilities.js';\nimport './Color.js';\nvar SVGElement,\n\tSVGRenderer,\n\n\taddEvent = H.addEvent,\n\tanimate = H.animate,\n\tattr = H.attr,\n\tcharts = H.charts,\n\tcolor = H.color,\n\tcss = H.css,\n\tcreateElement = H.createElement,\n\tdefined = H.defined,\n\tdeg2rad = H.deg2rad,\n\tdestroyObjectProperties = H.destroyObjectProperties,\n\tdoc = H.doc,\n\teach = H.each,\n\textend = H.extend,\n\terase = H.erase,\n\tgrep = H.grep,\n\thasTouch = H.hasTouch,\n\tinArray = H.inArray,\n\tisArray = H.isArray,\n\tisFirefox = H.isFirefox,\n\tisMS = H.isMS,\n\tisObject = H.isObject,\n\tisString = H.isString,\n\tisWebKit = H.isWebKit,\n\tmerge = H.merge,\n\tnoop = H.noop,\n\tobjectEach = H.objectEach,\n\tpick = H.pick,\n\tpInt = H.pInt,\n\tremoveEvent = H.removeEvent,\n\tsplat = H.splat,\n\tstop = H.stop,\n\tsvg = H.svg,\n\tSVG_NS = H.SVG_NS,\n\tsymbolSizes = H.symbolSizes,\n\twin = H.win;\n\n/**\n * @typedef {Object} SVGDOMElement - An SVG DOM element.\n */\n/**\n * The SVGElement prototype is a JavaScript wrapper for SVG elements used in the\n * rendering layer of Highcharts. Combined with the {@link\n * Highcharts.SVGRenderer} object, these prototypes allow freeform annotation\n * in the charts or even in HTML pages without instanciating a chart. The\n * SVGElement can also wrap HTML labels, when `text` or `label` elements are\n * created with the `useHTML` parameter.\n *\n * The SVGElement instances are created through factory functions on the \n * {@link Highcharts.SVGRenderer} object, like\n * [rect]{@link Highcharts.SVGRenderer#rect}, [path]{@link\n * Highcharts.SVGRenderer#path}, [text]{@link Highcharts.SVGRenderer#text},\n * [label]{@link Highcharts.SVGRenderer#label}, [g]{@link\n * Highcharts.SVGRenderer#g} and more.\n *\n * @class Highcharts.SVGElement\n */\nSVGElement = H.SVGElement = function () {\n\treturn this;\n};\nextend(SVGElement.prototype, /** @lends Highcharts.SVGElement.prototype */ {\n\n\t// Default base for animation\n\topacity: 1,\n\tSVG_NS: SVG_NS,\n\n\t/**\n\t * For labels, these CSS properties are applied to the `text` node directly.\n\t *\n\t * @private\n\t * @type {Array.<string>}\n\t */\n\ttextProps: ['direction', 'fontSize', 'fontWeight', 'fontFamily',\n\t\t'fontStyle', 'color', 'lineHeight', 'width', 'textAlign',\n\t\t'textDecoration', 'textOverflow', 'textOutline'],\n\n\t/**\n\t * Initialize the SVG element. This function only exists to make the\n\t * initiation process overridable. It should not be called directly.\n\t *\n\t * @param  {SVGRenderer} renderer\n\t *         The SVGRenderer instance to initialize to.\n\t * @param  {String} nodeName\n\t *         The SVG node name.\n\t * \n\t */\n\tinit: function (renderer, nodeName) {\n\n\t\t/** \n\t\t * The primary DOM node. Each `SVGElement` instance wraps a main DOM\n\t\t * node, but may also represent more nodes.\n\t\t *\n\t\t * @name  element\n\t\t * @memberOf SVGElement\n\t\t * @type {SVGDOMNode|HTMLDOMNode}\n\t\t */\n\t\tthis.element = nodeName === 'span' ?\n\t\t\tcreateElement(nodeName) :\n\t\t\tdoc.createElementNS(this.SVG_NS, nodeName);\n\n\t\t/**\n\t\t * The renderer that the SVGElement belongs to.\n\t\t *\n\t\t * @name renderer\n\t\t * @memberOf SVGElement\n\t\t * @type {SVGRenderer}\n\t\t */\n\t\tthis.renderer = renderer;\n\t},\n\n\t/**\n\t * Animate to given attributes or CSS properties.\n\t * \n\t * @param {SVGAttributes} params SVG attributes or CSS to animate.\n\t * @param {AnimationOptions} [options] Animation options.\n\t * @param {Function} [complete] Function to perform at the end of animation.\n\t *\n\t * @sample highcharts/members/element-on/\n\t *         Setting some attributes by animation\n\t * \n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\tanimate: function (params, options, complete) {\n\t\tvar animOptions = H.animObject(\n\t\t\tpick(options, this.renderer.globalAnimation, true)\n\t\t);\n\t\tif (animOptions.duration !== 0) {\n\t\t\t// allows using a callback with the global animation without\n\t\t\t// overwriting it\n\t\t\tif (complete) {\n\t\t\t\tanimOptions.complete = complete;\n\t\t\t}\n\t\t\tanimate(this, params, animOptions);\n\t\t} else {\n\t\t\tthis.attr(params, null, complete);\n\t\t\tif (animOptions.step) {\n\t\t\t\tanimOptions.step.call(this);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * @typedef {Object} GradientOptions\n\t * @property {Object} linearGradient Holds an object that defines the start\n\t *    position and the end position relative to the shape.\n\t * @property {Number} linearGradient.x1 Start horizontal position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Number} linearGradient.x2 End horizontal position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Number} linearGradient.y1 Start vertical position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Number} linearGradient.y2 End vertical position of the\n\t *    gradient. Ranges 0-1.\n\t * @property {Object} radialGradient Holds an object that defines the center\n\t *    position and the radius.\n\t * @property {Number} radialGradient.cx Center horizontal position relative\n\t *    to the shape. Ranges 0-1.\n\t * @property {Number} radialGradient.cy Center vertical position relative\n\t *    to the shape. Ranges 0-1.\n\t * @property {Number} radialGradient.r Radius relative to the shape. Ranges\n\t *    0-1.\n\t * @property {Array.<Array>} stops The first item in each tuple is the\n\t *    position in the gradient, where 0 is the start of the gradient and 1\n\t *    is the end of the gradient. Multiple stops can be applied. The second\n\t *    item is the color for each stop. This color can also be given in the\n\t *    rgba format.\n\t *\n\t * @example\n\t * // Linear gradient used as a color option\n\t * color: {\n\t *     linearGradient: { x1: 0, x2: 0, y1: 0, y2: 1 },\n\t *         stops: [\n\t *             [0, '#003399'], // start\n\t *             [0.5, '#ffffff'], // middle\n\t *             [1, '#3366AA'] // end\n\t *         ]\n\t *     }\n\t * }\n\t */\n\t/**\n\t * Build and apply an SVG gradient out of a common JavaScript configuration\n\t * object. This function is called from the attribute setters.\n\t *\n\t * @private\n\t * @param {GradientOptions} color The gradient options structure.\n\t * @param {string} prop The property to apply, can either be `fill` or\n\t * `stroke`. \n\t * @param {SVGDOMElement} elem SVG DOM element to apply the gradient on.\n\t */\n\tcolorGradient: function (color, prop, elem) {\n\t\tvar renderer = this.renderer,\n\t\t\tcolorObject,\n\t\t\tgradName,\n\t\t\tgradAttr,\n\t\t\tradAttr,\n\t\t\tgradients,\n\t\t\tgradientObject,\n\t\t\tstops,\n\t\t\tstopColor,\n\t\t\tstopOpacity,\n\t\t\tradialReference,\n\t\t\tid,\n\t\t\tkey = [],\n\t\t\tvalue;\n\n\t\t// Apply linear or radial gradients\n\t\tif (color.radialGradient) {\n\t\t\tgradName = 'radialGradient';\n\t\t} else if (color.linearGradient) {\n\t\t\tgradName = 'linearGradient';\n\t\t}\n\n\t\tif (gradName) {\n\t\t\tgradAttr = color[gradName];\n\t\t\tgradients = renderer.gradients;\n\t\t\tstops = color.stops;\n\t\t\tradialReference = elem.radialReference;\n\n\t\t\t// Keep < 2.2 kompatibility\n\t\t\tif (isArray(gradAttr)) {\n\t\t\t\tcolor[gradName] = gradAttr = {\n\t\t\t\t\tx1: gradAttr[0],\n\t\t\t\t\ty1: gradAttr[1],\n\t\t\t\t\tx2: gradAttr[2],\n\t\t\t\t\ty2: gradAttr[3],\n\t\t\t\t\tgradientUnits: 'userSpaceOnUse'\n\t\t\t\t};\n\t\t\t}\n\n\t\t\t// Correct the radial gradient for the radial reference system\n\t\t\tif (\n\t\t\t\tgradName === 'radialGradient' &&\n\t\t\t\tradialReference &&\n\t\t\t\t!defined(gradAttr.gradientUnits)\n\t\t\t) {\n\t\t\t\tradAttr = gradAttr; // Save the radial attributes for updating\n\t\t\t\tgradAttr = merge(\n\t\t\t\t\tgradAttr,\n\t\t\t\t\trenderer.getRadialAttr(radialReference, radAttr),\n\t\t\t\t\t{ gradientUnits: 'userSpaceOnUse' }\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Build the unique key to detect whether we need to create a new\n\t\t\t// element (#1282)\n\t\t\tobjectEach(gradAttr, function (val, n) {\n\t\t\t\tif (n !== 'id') {\n\t\t\t\t\tkey.push(n, val);\n\t\t\t\t}\n\t\t\t});\n\t\t\tobjectEach(stops, function (val) {\n\t\t\t\tkey.push(val);\n\t\t\t});\n\t\t\tkey = key.join(',');\n\n\t\t\t// Check if a gradient object with the same config object is created\n\t\t\t// within this renderer\n\t\t\tif (gradients[key]) {\n\t\t\t\tid = gradients[key].attr('id');\n\n\t\t\t} else {\n\n\t\t\t\t// Set the id and create the element\n\t\t\t\tgradAttr.id = id = H.uniqueKey();\n\t\t\t\tgradients[key] = gradientObject =\n\t\t\t\t\trenderer.createElement(gradName)\n\t\t\t\t\t\t.attr(gradAttr)\n\t\t\t\t\t\t.add(renderer.defs);\n\n\t\t\t\tgradientObject.radAttr = radAttr;\n\n\t\t\t\t// The gradient needs to keep a list of stops to be able to\n\t\t\t\t// destroy them\n\t\t\t\tgradientObject.stops = [];\n\t\t\t\teach(stops, function (stop) {\n\t\t\t\t\tvar stopObject;\n\t\t\t\t\tif (stop[1].indexOf('rgba') === 0) {\n\t\t\t\t\t\tcolorObject = H.color(stop[1]);\n\t\t\t\t\t\tstopColor = colorObject.get('rgb');\n\t\t\t\t\t\tstopOpacity = colorObject.get('a');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstopColor = stop[1];\n\t\t\t\t\t\tstopOpacity = 1;\n\t\t\t\t\t}\n\t\t\t\t\tstopObject = renderer.createElement('stop').attr({\n\t\t\t\t\t\toffset: stop[0],\n\t\t\t\t\t\t'stop-color': stopColor,\n\t\t\t\t\t\t'stop-opacity': stopOpacity\n\t\t\t\t\t}).add(gradientObject);\n\n\t\t\t\t\t// Add the stop element to the gradient\n\t\t\t\t\tgradientObject.stops.push(stopObject);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Set the reference to the gradient object\n\t\t\tvalue = 'url(' + renderer.url + '#' + id + ')';\n\t\t\telem.setAttribute(prop, value);\n\t\t\telem.gradient = key;\n\n\t\t\t// Allow the color to be concatenated into tooltips formatters etc.\n\t\t\t// (#2995)\n\t\t\tcolor.toString = function () {\n\t\t\t\treturn value;\n\t\t\t};\n\t\t}\n\t},\n\n\t/**\n\t * Apply a text outline through a custom CSS property, by copying the text\n\t * element and apply stroke to the copy. Used internally. Contrast checks\n\t * at http://jsfiddle.net/highcharts/43soe9m1/2/ .\n\t *\n\t * @private\n\t * @param {String} textOutline A custom CSS `text-outline` setting, defined\n\t *    by `width color`. \n\t * @example\n\t * // Specific color\n\t * text.css({\n\t *    textOutline: '1px black'\n\t * });\n\t * // Automatic contrast\n\t * text.css({\n\t *    color: '#000000', // black text\n\t *    textOutline: '1px contrast' // => white outline\n\t * });\n\t */\n\tapplyTextOutline: function (textOutline) {\n\t\tvar elem = this.element,\n\t\t\ttspans,\n\t\t\ttspan,\n\t\t\thasContrast = textOutline.indexOf('contrast') !== -1,\n\t\t\tstyles = {},\n\t\t\tcolor,\n\t\t\tstrokeWidth,\n\t\t\tfirstRealChild,\n\t\t\ti;\n\n\t\t// When the text shadow is set to contrast, use dark stroke for light\n\t\t// text and vice versa.\n\t\tif (hasContrast) {\n\t\t\tstyles.textOutline = textOutline = textOutline.replace(\n\t\t\t\t/contrast/g,\n\t\t\t\tthis.renderer.getContrast(elem.style.fill)\n\t\t\t);\n\t\t}\n\n\t\t// Extract the stroke width and color\n\t\ttextOutline = textOutline.split(' ');\n\t\tcolor = textOutline[textOutline.length - 1];\n\t\tstrokeWidth = textOutline[0];\n\n\t\tif (strokeWidth && strokeWidth !== 'none' && H.svg) {\n\n\t\t\tthis.fakeTS = true; // Fake text shadow\n\n\t\t\ttspans = [].slice.call(elem.getElementsByTagName('tspan'));\n\n\t\t\t// In order to get the right y position of the clone,\n\t\t\t// copy over the y setter\n\t\t\tthis.ySetter = this.xSetter;\n\n\t\t\t// Since the stroke is applied on center of the actual outline, we\n\t\t\t// need to double it to get the correct stroke-width outside the \n\t\t\t// glyphs.\n\t\t\tstrokeWidth = strokeWidth.replace(\n\t\t\t\t/(^[\\d\\.]+)(.*?)$/g,\n\t\t\t\tfunction (match, digit, unit) {\n\t\t\t\t\treturn (2 * digit) + unit;\n\t\t\t\t}\n\t\t\t);\n\t\t\t\n\t\t\t// Remove shadows from previous runs. Iterate from the end to\n\t\t\t// support removing items inside the cycle (#6472).\n\t\t\ti = tspans.length;\n\t\t\twhile (i--) {\n\t\t\t\ttspan = tspans[i];\n\t\t\t\tif (tspan.getAttribute('class') === 'highcharts-text-outline') {\n\t\t\t\t\t// Remove then erase\n\t\t\t\t\terase(tspans, elem.removeChild(tspan));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// For each of the tspans, create a stroked copy behind it.\n\t\t\tfirstRealChild = elem.firstChild;\n\t\t\teach(tspans, function (tspan, y) {\n\t\t\t\tvar clone;\n\n\t\t\t\t// Let the first line start at the correct X position\n\t\t\t\tif (y === 0) {\n\t\t\t\t\ttspan.setAttribute('x', elem.getAttribute('x'));\n\t\t\t\t\ty = elem.getAttribute('y');\n\t\t\t\t\ttspan.setAttribute('y', y || 0);\n\t\t\t\t\tif (y === null) {\n\t\t\t\t\t\telem.setAttribute('y', 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Create the clone and apply outline properties\n\t\t\t\tclone = tspan.cloneNode(1);\n\t\t\t\tattr(clone, {\n\t\t\t\t\t'class': 'highcharts-text-outline',\n\t\t\t\t\t'fill': color,\n\t\t\t\t\t'stroke': color,\n\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t'stroke-linejoin': 'round'\n\t\t\t\t});\n\t\t\t\telem.insertBefore(clone, firstRealChild);\n\t\t\t});\n\t\t}\n\t},\n\n\t/**\n\t *\n\t * @typedef {Object} SVGAttributes An object of key-value pairs for SVG\n\t *   attributes. Attributes in Highcharts elements for the most parts\n\t *   correspond to SVG, but some are specific to Highcharts, like `zIndex`,\n\t *   `rotation`, `rotationOriginX`, `rotationOriginY`, `translateX`,\n\t *   `translateY`, `scaleX` and `scaleY`. SVG attributes containing a hyphen\n\t *   are _not_ camel-cased, they should be quoted to preserve the hyphen.\n\t *   \n\t * @example\n\t * {\n\t *     'stroke': '#ff0000', // basic\n\t *     'stroke-width': 2, // hyphenated\n\t *     'rotation': 45 // custom\n\t *     'd': ['M', 10, 10, 'L', 30, 30, 'z'] // path definition, note format\n\t * }\n\t */\n\t/**\n\t * Apply native and custom attributes to the SVG elements.\n\t * \n\t * In order to set the rotation center for rotation, set x and y to 0 and\n\t * use `translateX` and `translateY` attributes to position the element\n\t * instead.\n\t *\n\t * Attributes frequently used in Highcharts are `fill`, `stroke`,\n\t * `stroke-width`.\n\t *\n\t * @param {SVGAttributes|String} hash - The native and custom SVG\n\t *    attributes. \n\t * @param {string} [val] - If the type of the first argument is `string`, \n\t *    the second can be a value, which will serve as a single attribute\n\t *    setter. If the first argument is a string and the second is undefined,\n\t *    the function serves as a getter and the current value of the property\n\t *    is returned.\n\t * @param {Function} [complete] - A callback function to execute after\n\t *    setting the attributes. This makes the function compliant and\n\t *    interchangeable with the {@link SVGElement#animate} function.\n\t * @param {boolean} [continueAnimation=true] Used internally when `.attr` is\n\t *    called as part of an animation step. Otherwise, calling `.attr` for an\n\t *    attribute will stop animation for that attribute.\n\t *    \n\t * @returns {SVGElement|string|number} If used as a setter, it returns the \n\t *    current {@link SVGElement} so the calls can be chained. If used as a \n\t *    getter, the current value of the attribute is returned.\n\t *\n\t * @sample highcharts/members/renderer-rect/\n\t *         Setting some attributes\n\t * \n\t * @example\n\t * // Set multiple attributes\n\t * element.attr({\n\t *     stroke: 'red',\n\t *     fill: 'blue',\n\t *     x: 10,\n\t *     y: 10\n\t * });\n\t *\n\t * // Set a single attribute\n\t * element.attr('stroke', 'red');\n\t *\n\t * // Get an attribute\n\t * element.attr('stroke'); // => 'red'\n\t * \n\t */\n\tattr: function (hash, val, complete, continueAnimation) {\n\t\tvar key,\n\t\t\telement = this.element,\n\t\t\thasSetSymbolSize,\n\t\t\tret = this,\n\t\t\tskipAttr,\n\t\t\tsetter;\n\n\t\t// single key-value pair\n\t\tif (typeof hash === 'string' && val !== undefined) {\n\t\t\tkey = hash;\n\t\t\thash = {};\n\t\t\thash[key] = val;\n\t\t}\n\n\t\t// used as a getter: first argument is a string, second is undefined\n\t\tif (typeof hash === 'string') {\n\t\t\tret = (this[hash + 'Getter'] || this._defaultGetter).call(\n\t\t\t\tthis,\n\t\t\t\thash,\n\t\t\t\telement\n\t\t\t);\n\n\t\t// setter\n\t\t} else {\n\n\t\t\tobjectEach(hash, function eachAttribute(val, key) {\n\t\t\t\tskipAttr = false;\n\t\t\t\t\n\t\t\t\t// Unless .attr is from the animator update, stop current\n\t\t\t\t// running animation of this property\n\t\t\t\tif (!continueAnimation) {\n\t\t\t\t\tstop(this, key);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Special handling of symbol attributes\n\t\t\t\tif (\n\t\t\t\t\tthis.symbolName &&\n\t\t\t\t\t/^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)$/\n\t\t\t\t\t.test(key)\n\t\t\t\t) {\n\t\t\t\t\tif (!hasSetSymbolSize) {\n\t\t\t\t\t\tthis.symbolAttr(hash);\n\t\t\t\t\t\thasSetSymbolSize = true;\n\t\t\t\t\t}\n\t\t\t\t\tskipAttr = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (this.rotation && (key === 'x' || key === 'y')) {\n\t\t\t\t\tthis.doTransform = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (!skipAttr) {\n\t\t\t\t\tsetter = this[key + 'Setter'] || this._defaultSetter;\n\t\t\t\t\tsetter.call(this, val, key, element);\n\t\t\t\t\t\n\t\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\t\t// Let the shadow follow the main element\n\t\t\t\t\tif (\n\t\t\t\t\t\tthis.shadows &&\n\t\t\t\t\t\t/^(width|height|visibility|x|y|d|transform|cx|cy|r)$/\n\t\t\t\t\t\t\t.test(key)\n\t\t\t\t\t) {\n\t\t\t\t\t\tthis.updateShadows(key, val, setter);\n\t\t\t\t\t}\n\t\t\t\t\t/*= } =*/\n\t\t\t\t}\n\t\t\t}, this);\n\n\t\t\tthis.afterSetters();\n\t\t}\n\n\t\t// In accordance with animate, run a complete callback\n\t\tif (complete) {\n\t\t\tcomplete.call(this);\n\t\t}\n\n\t\treturn ret;\n\t},\n\n\t/**\n\t * This method is executed in the end of `attr()`, after setting all\n\t * attributes in the hash. In can be used to efficiently consolidate\n\t * multiple attributes in one SVG property -- e.g., translate, rotate and\n\t * scale are merged in one \"transform\" attribute in the SVG node.\n\t *\n\t * @private\n\t */\n\tafterSetters: function () {\n\t\t// Update transform. Do this outside the loop to prevent redundant\n\t\t// updating for batch setting of attributes.\n\t\tif (this.doTransform) {\n\t\t\tthis.updateTransform();\n\t\t\tthis.doTransform = false;\n\t\t}\n\t},\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * Update the shadow elements with new attributes.\n\t *\n\t * @private\n\t * @param {String} key - The attribute name.\n\t * @param {String|Number} value - The value of the attribute.\n\t * @param {Function} setter - The setter function, inherited from the\n\t *   parent wrapper\n\t * \n\t */\n\tupdateShadows: function (key, value, setter) {\n\t\tvar shadows = this.shadows,\n\t\t\ti = shadows.length;\n\n\t\twhile (i--) {\n\t\t\tsetter.call(\n\t\t\t\tshadows[i], \n\t\t\t\tkey === 'height' ?\n\t\t\t\t\tMath.max(value - (shadows[i].cutHeight || 0), 0) :\n\t\t\t\t\tkey === 'd' ? this.d : value, \n\t\t\t\tkey, \n\t\t\t\tshadows[i]\n\t\t\t);\n\t\t}\n\t},\n\t/*= } =*/\n\n\t/**\n\t * Add a class name to an element.\n\t *\n\t * @param {string} className - The new class name to add.\n\t * @param {boolean} [replace=false] - When true, the existing class name(s)\n\t *    will be overwritten with the new one. When false, the new one is\n\t *    added.\n\t * @returns {SVGElement} Return the SVG element for chainability.\n\t */\n\taddClass: function (className, replace) {\n\t\tvar currentClassName = this.attr('class') || '';\n\t\tif (currentClassName.indexOf(className) === -1) {\n\t\t\tif (!replace) {\n\t\t\t\tclassName = \n\t\t\t\t\t(currentClassName + (currentClassName ? ' ' : '') +\n\t\t\t\t\tclassName).replace('  ', ' ');\n\t\t\t}\n\t\t\tthis.attr('class', className);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Check if an element has the given class name.\n\t * @param  {string} className\n\t *         The class name to check for.\n\t * @return {Boolean}\n\t *         Whether the class name is found.\n\t */\n\thasClass: function (className) {\n\t\treturn inArray(\n\t\t\tclassName,\n\t\t\t(this.attr('class') || '').split(' ')\n\t\t) !== -1;\n\t},\n\n\t/**\n\t * Remove a class name from the element.\n\t * @param  {String|RegExp} className The class name to remove.\n\t * @return {SVGElement} Returns the SVG element for chainability.\n\t */\n\tremoveClass: function (className) {\n\t\treturn this.attr(\n\t\t\t'class',\n\t\t\t(this.attr('class') || '').replace(className, '')\n\t\t);\n\t},\n\n\t/**\n\t * If one of the symbol size affecting parameters are changed,\n\t * check all the others only once for each call to an element's\n\t * .attr() method\n\t * @param {Object} hash - The attributes to set.\n\t * @private\n\t */\n\tsymbolAttr: function (hash) {\n\t\tvar wrapper = this;\n\n\t\teach([\n\t\t\t'x',\n\t\t\t'y',\n\t\t\t'r',\n\t\t\t'start',\n\t\t\t'end',\n\t\t\t'width',\n\t\t\t'height',\n\t\t\t'innerR',\n\t\t\t'anchorX',\n\t\t\t'anchorY'\n\t\t], function (key) {\n\t\t\twrapper[key] = pick(hash[key], wrapper[key]);\n\t\t});\n\n\t\twrapper.attr({\n\t\t\td: wrapper.renderer.symbols[wrapper.symbolName](\n\t\t\t\twrapper.x,\n\t\t\t\twrapper.y,\n\t\t\t\twrapper.width,\n\t\t\t\twrapper.height,\n\t\t\t\twrapper\n\t\t\t)\n\t\t});\n\t},\n\n\t/**\n\t * Apply a clipping rectangle to this element.\n\t * \n\t * @param {ClipRect} [clipRect] - The clipping rectangle. If skipped, the\n\t *    current clip is removed.\n\t * @returns {SVGElement} Returns the SVG element to allow chaining.\n\t */\n\tclip: function (clipRect) {\n\t\treturn this.attr(\n\t\t\t'clip-path',\n\t\t\tclipRect ?\n\t\t\t\t'url(' + this.renderer.url + '#' + clipRect.id + ')' :\n\t\t\t\t'none'\n\t\t);\n\t},\n\n\t/**\n\t * Calculate the coordinates needed for drawing a rectangle crisply and\n\t * return the calculated attributes.\n\t * \n\t * @param {Object} rect - A rectangle.\n\t * @param {number} rect.x - The x position.\n\t * @param {number} rect.y - The y position.\n\t * @param {number} rect.width - The width.\n\t * @param {number} rect.height - The height.\n\t * @param {number} [strokeWidth] - The stroke width to consider when\n\t *    computing crisp positioning. It can also be set directly on the rect\n\t *    parameter.\n\t *\n\t * @returns {{x: Number, y: Number, width: Number, height: Number}} The\n\t *    modified rectangle arguments.\n\t */\n\tcrisp: function (rect, strokeWidth) {\n\n\t\tvar wrapper = this,\n\t\t\tnormalizer;\n\n\t\tstrokeWidth = strokeWidth || rect.strokeWidth || 0;\n\t\t// Math.round because strokeWidth can sometimes have roundoff errors\n\t\tnormalizer = Math.round(strokeWidth) % 2 / 2;\n\n\t\t// normalize for crisp edges\n\t\trect.x = Math.floor(rect.x || wrapper.x || 0) + normalizer;\n\t\trect.y = Math.floor(rect.y || wrapper.y || 0) + normalizer;\n\t\trect.width = Math.floor(\n\t\t\t(rect.width || wrapper.width || 0) - 2 * normalizer\n\t\t);\n\t\trect.height = Math.floor(\n\t\t\t(rect.height || wrapper.height || 0) - 2 * normalizer\n\t\t);\n\t\tif (defined(rect.strokeWidth)) {\n\t\t\trect.strokeWidth = strokeWidth;\n\t\t}\n\t\treturn rect;\n\t},\n\n\t/**\n\t * Set styles for the element. In addition to CSS styles supported by \n\t * native SVG and HTML elements, there are also some custom made for \n\t * Highcharts, like `width`, `ellipsis` and `textOverflow` for SVG text\n\t * elements.\n\t * @param {CSSObject} styles The new CSS styles.\n\t * @returns {SVGElement} Return the SVG element for chaining.\n\t *\n\t * @sample highcharts/members/renderer-text-on-chart/\n\t *         Styled text\n\t */\n\tcss: function (styles) {\n\t\tvar oldStyles = this.styles,\n\t\t\tnewStyles = {},\n\t\t\telem = this.element,\n\t\t\ttextWidth,\n\t\t\tserializedCss = '',\n\t\t\thyphenate,\n\t\t\thasNew = !oldStyles,\n\t\t\t// These CSS properties are interpreted internally by the SVG\n\t\t\t// renderer, but are not supported by SVG and should not be added to\n\t\t\t// the DOM. In styled mode, no CSS should find its way to the DOM\n\t\t\t// whatsoever (#6173, #6474).\n\t\t\tsvgPseudoProps = ['textOutline', 'textOverflow', 'width'];\n\n\t\t// convert legacy\n\t\tif (styles && styles.color) {\n\t\t\tstyles.fill = styles.color;\n\t\t}\n\n\t\t// Filter out existing styles to increase performance (#2640)\n\t\tif (oldStyles) {\n\t\t\tobjectEach(styles, function (style, n) {\n\t\t\t\tif (style !== oldStyles[n]) {\n\t\t\t\t\tnewStyles[n] = style;\n\t\t\t\t\thasNew = true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (hasNew) {\n\n\t\t\t// Merge the new styles with the old ones\n\t\t\tif (oldStyles) {\n\t\t\t\tstyles = extend(\n\t\t\t\t\toldStyles,\n\t\t\t\t\tnewStyles\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// Get the text width from style\n\t\t\ttextWidth = this.textWidth = (\n\t\t\t\tstyles &&\n\t\t\t\tstyles.width &&\n\t\t\t\tstyles.width !== 'auto' &&\n\t\t\t\telem.nodeName.toLowerCase() === 'text' &&\n\t\t\t\tpInt(styles.width)\n\t\t\t);\n\n\t\t\t// store object\n\t\t\tthis.styles = styles;\n\n\t\t\tif (textWidth && (!svg && this.renderer.forExport)) {\n\t\t\t\tdelete styles.width;\n\t\t\t}\n\n\t\t\t// Serialize and set style attribute\n\t\t\tif (elem.namespaceURI === this.SVG_NS) { // #7633\n\t\t\t\thyphenate = function (a, b) {\n\t\t\t\t\treturn '-' + b.toLowerCase();\n\t\t\t\t};\n\t\t\t\tobjectEach(styles, function (style, n) {\n\t\t\t\t\tif (inArray(n, svgPseudoProps) === -1) {\n\t\t\t\t\t\tserializedCss +=\n\t\t\t\t\t\tn.replace(/([A-Z])/g, hyphenate) + ':' +\n\t\t\t\t\t\tstyle + ';';\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif (serializedCss) {\n\t\t\t\t\tattr(elem, 'style', serializedCss); // #1881\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcss(elem, styles);\n\t\t\t}\n\n\n\t\t\tif (this.added) {\n\n\t\t\t\t// Rebuild text after added. Cache mechanisms in the buildText\n\t\t\t\t// will prevent building if there are no significant changes.\n\t\t\t\tif (this.element.nodeName === 'text') {\n\t\t\t\t\tthis.renderer.buildText(this);\n\t\t\t\t}\n\n\t\t\t\t// Apply text outline after added\n\t\t\t\tif (styles && styles.textOutline) {\n\t\t\t\t\tthis.applyTextOutline(styles.textOutline);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * Get the current stroke width. In classic mode, the setter registers it \n\t * directly on the element.\n\t * @returns {number} The stroke width in pixels.\n\t * @ignore\n\t */\n\tstrokeWidth: function () {\n\t\treturn this['stroke-width'] || 0;\n\t},\n\n\t/*= } else { =*/\n\t/**\n\t * Get the computed style. Only in styled mode.\n\t * @param {string} prop - The property name to check for.\n\t * @returns {string} The current computed value.\n\t * @example\n\t * chart.series[0].points[0].graphic.getStyle('stroke-width'); // => '1px'\n\t */\n\tgetStyle: function (prop) {\n\t\treturn win.getComputedStyle(this.element || this, '')\n\t\t\t.getPropertyValue(prop);\n\t},\n\n\t/**\n\t * Get the computed stroke width in pixel values. This is used extensively\n\t * when drawing shapes to ensure the shapes are rendered crisp and\n\t * positioned correctly relative to each other. Using\n\t * `shape-rendering: crispEdges` leaves us less control over positioning,\n\t * for example when we want to stack columns next to each other, or position\n\t * things pixel-perfectly within the plot box.\n\t *\n\t * The common pattern when placing a shape is:\n\t * * Create the SVGElement and add it to the DOM. In styled mode, it will\n\t *   now receive a stroke width from the style sheet. In classic mode we\n\t *   will add the `stroke-width` attribute.\n\t * * Read the computed `elem.strokeWidth()`.\n\t * * Place it based on the stroke width.\n\t *\n\t * @returns {Number} The stroke width in pixels. Even if the given stroke\n\t * widtch (in CSS or by attributes) is based on `em` or other units, the \n\t * pixel size is returned.\n\t */\n\tstrokeWidth: function () {\n\t\tvar val = this.getStyle('stroke-width'),\n\t\t\tret,\n\t\t\tdummy;\n\n\t\t// Read pixel values directly\n\t\tif (val.indexOf('px') === val.length - 2) {\n\t\t\tret = pInt(val);\n\n\t\t// Other values like em, pt etc need to be measured\n\t\t} else {\n\t\t\tdummy = doc.createElementNS(SVG_NS, 'rect');\n\t\t\tattr(dummy, {\n\t\t\t\t'width': val,\n\t\t\t\t'stroke-width': 0\n\t\t\t});\n\t\t\tthis.element.parentNode.appendChild(dummy);\n\t\t\tret = dummy.getBBox().width;\n\t\t\tdummy.parentNode.removeChild(dummy);\n\t\t}\n\t\treturn ret;\n\t},\n\t/*= } =*/\n\t/**\n\t * Add an event listener. This is a simple setter that replaces all other\n\t * events of the same type, opposed to the {@link Highcharts#addEvent}\n\t * function.\n\t * @param {string} eventType - The event type. If the type is `click`, \n\t *    Highcharts will internally translate it to a `touchstart` event on \n\t *    touch devices, to prevent the browser from waiting for a click event\n\t *    from firing.\n\t * @param {Function} handler - The handler callback.\n\t * @returns {SVGElement} The SVGElement for chaining.\n\t *\n\t * @sample highcharts/members/element-on/\n\t *         A clickable rectangle\n\t */\n\ton: function (eventType, handler) {\n\t\tvar svgElement = this,\n\t\t\telement = svgElement.element;\n\n\t\t// touch\n\t\tif (hasTouch && eventType === 'click') {\n\t\t\telement.ontouchstart = function (e) {\n\t\t\t\tsvgElement.touchEventFired = Date.now(); // #2269\n\t\t\t\te.preventDefault();\n\t\t\t\thandler.call(element, e);\n\t\t\t};\n\t\t\telement.onclick = function (e) {\n\t\t\t\tif (win.navigator.userAgent.indexOf('Android') === -1 ||\n\t\t\t\t\t\tDate.now() - (svgElement.touchEventFired || 0) > 1100) {\n\t\t\t\t\thandler.call(element, e);\n\t\t\t\t}\n\t\t\t};\n\t\t} else {\n\t\t\t// simplest possible event model for internal use\n\t\t\telement['on' + eventType] = handler;\n\t\t}\n\t\treturn this;\n\t},\n\n\t/**\n\t * Set the coordinates needed to draw a consistent radial gradient across\n\t * a shape regardless of positioning inside the chart. Used on pie slices\n\t * to make all the slices have the same radial reference point.\n\t *\n\t * @param {Array} coordinates The center reference. The format is\n\t *    `[centerX, centerY, diameter]` in pixels.\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\tsetRadialReference: function (coordinates) {\n\t\tvar existingGradient = this.renderer.gradients[this.element.gradient];\n\n\t\tthis.element.radialReference = coordinates;\n\n\t\t// On redrawing objects with an existing gradient, the gradient needs\n\t\t// to be repositioned (#3801)\n\t\tif (existingGradient && existingGradient.radAttr) {\n\t\t\texistingGradient.animate(\n\t\t\t\tthis.renderer.getRadialAttr(\n\t\t\t\t\tcoordinates,\n\t\t\t\t\texistingGradient.radAttr\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Move an object and its children by x and y values.\n\t * \n\t * @param {number} x - The x value.\n\t * @param {number} y - The y value.\n\t */\n\ttranslate: function (x, y) {\n\t\treturn this.attr({\n\t\t\ttranslateX: x,\n\t\t\ttranslateY: y\n\t\t});\n\t},\n\n\t/**\n\t * Invert a group, rotate and flip. This is used internally on inverted \n\t * charts, where the points and graphs are drawn as if not inverted, then\n\t * the series group elements are inverted.\n\t *\n\t * @param  {boolean} inverted\n\t *         Whether to invert or not. An inverted shape can be un-inverted by\n\t *         setting it to false.\n\t * @return {SVGElement}\n\t *         Return the SVGElement for chaining.\n\t */\n\tinvert: function (inverted) {\n\t\tvar wrapper = this;\n\t\twrapper.inverted = inverted;\n\t\twrapper.updateTransform();\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Update the transform attribute based on internal properties. Deals with\n\t * the custom `translateX`, `translateY`, `rotation`, `scaleX` and `scaleY`\n\t * attributes and updates the SVG `transform` attribute.\n\t * @private\n\t * \n\t */\n\tupdateTransform: function () {\n\t\tvar wrapper = this,\n\t\t\ttranslateX = wrapper.translateX || 0,\n\t\t\ttranslateY = wrapper.translateY || 0,\n\t\t\tscaleX = wrapper.scaleX,\n\t\t\tscaleY = wrapper.scaleY,\n\t\t\tinverted = wrapper.inverted,\n\t\t\trotation = wrapper.rotation,\n\t\t\tmatrix = wrapper.matrix,\n\t\t\telement = wrapper.element,\n\t\t\ttransform;\n\n\t\t// Flipping affects translate as adjustment for flipping around the\n\t\t// group's axis\n\t\tif (inverted) {\n\t\t\ttranslateX += wrapper.width;\n\t\t\ttranslateY += wrapper.height;\n\t\t}\n\n\t\t// Apply translate. Nearly all transformed elements have translation,\n\t\t// so instead of checking for translate = 0, do it always (#1767,\n\t\t// #1846).\n\t\ttransform = ['translate(' + translateX + ',' + translateY + ')'];\n\n\t\t// apply matrix\n\t\tif (defined(matrix)) {\n\t\t\ttransform.push(\n\t\t\t\t'matrix(' + matrix.join(',') + ')'\n\t\t\t);\n\t\t}\n\t\t\n\t\t// apply rotation\n\t\tif (inverted) {\n\t\t\ttransform.push('rotate(90) scale(-1,1)');\n\t\t} else if (rotation) { // text rotation\n\t\t\ttransform.push(\n\t\t\t\t'rotate(' + rotation + ' ' +\n\t\t\t\tpick(this.rotationOriginX, element.getAttribute('x'), 0) +\n\t\t\t\t' ' +\n\t\t\t\tpick(this.rotationOriginY, element.getAttribute('y') || 0) + ')'\n\t\t\t);\n\t\t}\n\n\t\t// apply scale\n\t\tif (defined(scaleX) || defined(scaleY)) {\n\t\t\ttransform.push(\n\t\t\t\t'scale(' + pick(scaleX, 1) + ' ' + pick(scaleY, 1) + ')'\n\t\t\t);\n\t\t}\n\n\t\tif (transform.length) {\n\t\t\telement.setAttribute('transform', transform.join(' '));\n\t\t}\n\t},\n\n\t/**\n\t * Bring the element to the front. Alternatively, a new zIndex can be set.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t *\n\t * @sample highcharts/members/element-tofront/\n\t *         Click an element to bring it to front\n\t */\n\ttoFront: function () {\n\t\tvar element = this.element;\n\t\telement.parentNode.appendChild(element);\n\t\treturn this;\n\t},\n\n\n\t/**\n\t * Align the element relative to the chart or another box.\n\t * \n\t * @param {Object} [alignOptions] The alignment options. The function can be\n\t *   called without this parameter in order to re-align an element after the\n\t *   box has been updated.\n\t * @param {string} [alignOptions.align=left] Horizontal alignment. Can be\n\t *   one of `left`, `center` and `right`.\n\t * @param {string} [alignOptions.verticalAlign=top] Vertical alignment. Can\n\t *   be one of `top`, `middle` and `bottom`.\n\t * @param {number} [alignOptions.x=0] Horizontal pixel offset from\n\t *   alignment.\n\t * @param {number} [alignOptions.y=0] Vertical pixel offset from alignment.\n\t * @param {Boolean} [alignByTranslate=false] Use the `transform` attribute\n\t *   with translateX and translateY custom attributes to align this elements\n\t *   rather than `x` and `y` attributes.\n\t * @param {String|Object} box The box to align to, needs a width and height.\n\t *   When the box is a string, it refers to an object in the Renderer. For\n\t *   example, when box is `spacingBox`, it refers to `Renderer.spacingBox`\n\t *   which holds `width`, `height`, `x` and `y` properties.\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\talign: function (alignOptions, alignByTranslate, box) {\n\t\tvar align,\n\t\t\tvAlign,\n\t\t\tx,\n\t\t\ty,\n\t\t\tattribs = {},\n\t\t\talignTo,\n\t\t\trenderer = this.renderer,\n\t\t\talignedObjects = renderer.alignedObjects,\n\t\t\talignFactor,\n\t\t\tvAlignFactor;\n\n\t\t// First call on instanciate\n\t\tif (alignOptions) {\n\t\t\tthis.alignOptions = alignOptions;\n\t\t\tthis.alignByTranslate = alignByTranslate;\n\t\t\tif (!box || isString(box)) {\n\t\t\t\tthis.alignTo = alignTo = box || 'renderer';\n\t\t\t\t// prevent duplicates, like legendGroup after resize\n\t\t\t\terase(alignedObjects, this);\n\t\t\t\talignedObjects.push(this);\n\t\t\t\tbox = null; // reassign it below\n\t\t\t}\n\n\t\t// When called on resize, no arguments are supplied\n\t\t} else {\n\t\t\talignOptions = this.alignOptions;\n\t\t\talignByTranslate = this.alignByTranslate;\n\t\t\talignTo = this.alignTo;\n\t\t}\n\n\t\tbox = pick(box, renderer[alignTo], renderer);\n\n\t\t// Assign variables\n\t\talign = alignOptions.align;\n\t\tvAlign = alignOptions.verticalAlign;\n\t\tx = (box.x || 0) + (alignOptions.x || 0); // default: left align\n\t\ty = (box.y || 0) + (alignOptions.y || 0); // default: top align\n\n\t\t// Align\n\t\tif (align === 'right') {\n\t\t\talignFactor = 1;\n\t\t} else if (align === 'center') {\n\t\t\talignFactor = 2;\n\t\t}\n\t\tif (alignFactor) {\n\t\t\tx += (box.width - (alignOptions.width || 0)) / alignFactor;\n\t\t}\n\t\tattribs[alignByTranslate ? 'translateX' : 'x'] = Math.round(x);\n\n\n\t\t// Vertical align\n\t\tif (vAlign === 'bottom') {\n\t\t\tvAlignFactor = 1;\n\t\t} else if (vAlign === 'middle') {\n\t\t\tvAlignFactor = 2;\n\t\t}\n\t\tif (vAlignFactor) {\n\t\t\ty += (box.height - (alignOptions.height || 0)) / vAlignFactor;\n\t\t}\n\t\tattribs[alignByTranslate ? 'translateY' : 'y'] = Math.round(y);\n\n\t\t// Animate only if already placed\n\t\tthis[this.placed ? 'animate' : 'attr'](attribs);\n\t\tthis.placed = true;\n\t\tthis.alignAttr = attribs;\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Get the bounding box (width, height, x and y) for the element. Generally\n\t * used to get rendered text size. Since this is called a lot in charts,\n\t * the results are cached based on text properties, in order to save DOM\n\t * traffic. The returned bounding box includes the rotation, so for example\n\t * a single text line of rotation 90 will report a greater height, and a\n\t * width corresponding to the line-height.\n\t *\n\t * @param {boolean} [reload] Skip the cache and get the updated DOM bouding\n\t *   box.\n\t * @param {number} [rot] Override the element's rotation. This is internally\n\t *   used on axis labels with a value of 0 to find out what the bounding box\n\t *   would be have been if it were not rotated.\n\t * @returns {Object} The bounding box with `x`, `y`, `width` and `height`\n\t * properties.\n\t *\n\t * @sample highcharts/members/renderer-on-chart/\n\t *         Draw a rectangle based on a text's bounding box\n\t */\n\tgetBBox: function (reload, rot) {\n\t\tvar wrapper = this,\n\t\t\tbBox, // = wrapper.bBox,\n\t\t\trenderer = wrapper.renderer,\n\t\t\twidth,\n\t\t\theight,\n\t\t\trotation,\n\t\t\trad,\n\t\t\telement = wrapper.element,\n\t\t\tstyles = wrapper.styles,\n\t\t\tfontSize,\n\t\t\ttextStr = wrapper.textStr,\n\t\t\ttoggleTextShadowShim,\n\t\t\tcache = renderer.cache,\n\t\t\tcacheKeys = renderer.cacheKeys,\n\t\t\tcacheKey;\n\n\t\trotation = pick(rot, wrapper.rotation);\n\t\trad = rotation * deg2rad;\n\n\t\t/*= if (build.classic) { =*/\n\t\tfontSize = styles && styles.fontSize;\n\t\t/*= } else { =*/\n\t\tfontSize = element &&\n\t\t\tSVGElement.prototype.getStyle.call(element, 'font-size');\n\t\t/*= } =*/\n\n\t\t// Avoid undefined and null (#7316)\n\t\tif (defined(textStr)) {\n\n\t\t\tcacheKey = textStr.toString();\n\t\t\t\n\t\t\t// Since numbers are monospaced, and numerical labels appear a lot\n\t\t\t// in a chart, we assume that a label of n characters has the same\n\t\t\t// bounding box as others of the same length. Unless there is inner\n\t\t\t// HTML in the label. In that case, leave the numbers as is (#5899).\n\t\t\tif (cacheKey.indexOf('<') === -1) {\n\t\t\t\tcacheKey = cacheKey.replace(/[0-9]/g, '0');\n\t\t\t}\n\n\t\t\t// Properties that affect bounding box\n\t\t\tcacheKey += [\n\t\t\t\t'',\n\t\t\t\trotation || 0,\n\t\t\t\tfontSize,\n\t\t\t\tstyles && styles.width,\n\t\t\t\tstyles && styles.textOverflow // #5968\n\t\t\t]\n\t\t\t.join(',');\n\n\t\t}\n\n\t\tif (cacheKey && !reload) {\n\t\t\tbBox = cache[cacheKey];\n\t\t}\n\n\t\t// No cache found\n\t\tif (!bBox) {\n\n\t\t\t// SVG elements\n\t\t\tif (element.namespaceURI === wrapper.SVG_NS || renderer.forExport) {\n\t\t\t\ttry { // Fails in Firefox if the container has display: none.\n\n\t\t\t\t\t// When the text shadow shim is used, we need to hide the\n\t\t\t\t\t// fake shadows to get the correct bounding box (#3872)\n\t\t\t\t\ttoggleTextShadowShim = this.fakeTS && function (display) {\n\t\t\t\t\t\teach(\n\t\t\t\t\t\t\telement.querySelectorAll(\n\t\t\t\t\t\t\t\t'.highcharts-text-outline'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tfunction (tspan) {\n\t\t\t\t\t\t\t\ttspan.style.display = display;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t);\n\t\t\t\t\t};\n\n\t\t\t\t\t// Workaround for #3842, Firefox reporting wrong bounding\n\t\t\t\t\t// box for shadows\n\t\t\t\t\tif (toggleTextShadowShim) {\n\t\t\t\t\t\ttoggleTextShadowShim('none');\n\t\t\t\t\t}\n\n\t\t\t\t\tbBox = element.getBBox ?\n\t\t\t\t\t\t// SVG: use extend because IE9 is not allowed to change\n\t\t\t\t\t\t// width and height in case of rotation (below)\n\t\t\t\t\t\textend({}, element.getBBox()) : {\n\n\t\t\t\t\t\t\t// Legacy IE in export mode\n\t\t\t\t\t\t\twidth: element.offsetWidth,\n\t\t\t\t\t\t\theight: element.offsetHeight\n\t\t\t\t\t\t};\n\n\t\t\t\t\t// #3842\n\t\t\t\t\tif (toggleTextShadowShim) {\n\t\t\t\t\t\ttoggleTextShadowShim('');\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\n\t\t\t\t// If the bBox is not set, the try-catch block above failed. The\n\t\t\t\t// other condition is for Opera that returns a width of\n\t\t\t\t// -Infinity on hidden elements.\n\t\t\t\tif (!bBox || bBox.width < 0) {\n\t\t\t\t\tbBox = { width: 0, height: 0 };\n\t\t\t\t}\n\n\n\t\t\t// VML Renderer or useHTML within SVG\n\t\t\t} else {\n\n\t\t\t\tbBox = wrapper.htmlGetBBox();\n\n\t\t\t}\n\n\t\t\t// True SVG elements as well as HTML elements in modern browsers\n\t\t\t// using the .useHTML option need to compensated for rotation\n\t\t\tif (renderer.isSVG) {\n\t\t\t\twidth = bBox.width;\n\t\t\t\theight = bBox.height;\n\n\t\t\t\t// Workaround for wrong bounding box in IE, Edge and Chrome on\n\t\t\t\t// Windows. With Highcharts' default font, IE and Edge report\n\t\t\t\t// a box height of 16.899 and Chrome rounds it to 17. If this \n\t\t\t\t// stands uncorrected, it results in more padding added below\n\t\t\t\t// the text than above when adding a label border or background.\n\t\t\t\t// Also vertical positioning is affected.\n\t\t\t\t// http://jsfiddle.net/highcharts/em37nvuj/\n\t\t\t\t// (#1101, #1505, #1669, #2568, #6213).\n\t\t\t\tif (\n\t\t\t\t\tstyles &&\n\t\t\t\t\tstyles.fontSize === '11px' &&\n\t\t\t\t\tMath.round(height) === 17\n\t\t\t\t) {\n\t\t\t\t\tbBox.height = height = 14;\n\t\t\t\t}\n\n\t\t\t\t// Adjust for rotated text\n\t\t\t\tif (rotation) {\n\t\t\t\t\tbBox.width = Math.abs(height * Math.sin(rad)) +\n\t\t\t\t\t\tMath.abs(width * Math.cos(rad));\n\t\t\t\t\tbBox.height = Math.abs(height * Math.cos(rad)) +\n\t\t\t\t\t\tMath.abs(width * Math.sin(rad));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Cache it. When loading a chart in a hidden iframe in Firefox and\n\t\t\t// IE/Edge, the bounding box height is 0, so don't cache it (#5620).\n\t\t\tif (cacheKey && bBox.height > 0) {\n\n\t\t\t\t// Rotate (#4681)\n\t\t\t\twhile (cacheKeys.length > 250) {\n\t\t\t\t\tdelete cache[cacheKeys.shift()];\n\t\t\t\t}\n\n\t\t\t\tif (!cache[cacheKey]) {\n\t\t\t\t\tcacheKeys.push(cacheKey);\n\t\t\t\t}\n\t\t\t\tcache[cacheKey] = bBox;\n\t\t\t}\n\t\t}\n\t\treturn bBox;\n\t},\n\n\t/**\n\t * Show the element after it has been hidden. \n\t *\n\t * @param {boolean} [inherit=false] Set the visibility attribute to\n\t * `inherit` rather than `visible`. The difference is that an element with\n\t * `visibility=\"visible\"` will be visible even if the parent is hidden.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\tshow: function (inherit) {\n\t\treturn this.attr({ visibility: inherit ? 'inherit' : 'visible' });\n\t},\n\n\t/**\n\t * Hide the element, equivalent to setting the `visibility` attribute to\n\t * `hidden`.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t */\n\thide: function () {\n\t\treturn this.attr({ visibility: 'hidden' });\n\t},\n\n\t/**\n\t * Fade out an element by animating its opacity down to 0, and hide it on\n\t * complete. Used internally for the tooltip.\n\t * \n\t * @param {number} [duration=150] The fade duration in milliseconds.\n\t */\n\tfadeOut: function (duration) {\n\t\tvar elemWrapper = this;\n\t\telemWrapper.animate({\n\t\t\topacity: 0\n\t\t}, {\n\t\t\tduration: duration || 150,\n\t\t\tcomplete: function () {\n\t\t\t\t// #3088, assuming we're only using this for tooltips\n\t\t\t\telemWrapper.attr({ y: -9999 });\n\t\t\t}\n\t\t});\n\t},\n\n\t/**\n\t * Add the element to the DOM. All elements must be added this way.\n\t * \n\t * @param {SVGElement|SVGDOMElement} [parent] The parent item to add it to.\n\t *   If undefined, the element is added to the {@link\n\t *   Highcharts.SVGRenderer.box}.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t *\n\t * @sample highcharts/members/renderer-g - Elements added to a group\n\t */\n\tadd: function (parent) {\n\n\t\tvar renderer = this.renderer,\n\t\t\telement = this.element,\n\t\t\tinserted;\n\n\t\tif (parent) {\n\t\t\tthis.parentGroup = parent;\n\t\t}\n\n\t\t// mark as inverted\n\t\tthis.parentInverted = parent && parent.inverted;\n\n\t\t// build formatted text\n\t\tif (this.textStr !== undefined) {\n\t\t\trenderer.buildText(this);\n\t\t}\n\n\t\t// Mark as added\n\t\tthis.added = true;\n\n\t\t// If we're adding to renderer root, or other elements in the group\n\t\t// have a z index, we need to handle it\n\t\tif (!parent || parent.handleZ || this.zIndex) {\n\t\t\tinserted = this.zIndexSetter();\n\t\t}\n\n\t\t// If zIndex is not handled, append at the end\n\t\tif (!inserted) {\n\t\t\t(parent ? parent.element : renderer.box).appendChild(element);\n\t\t}\n\n\t\t// fire an event for internal hooks\n\t\tif (this.onAdd) {\n\t\t\tthis.onAdd();\n\t\t}\n\n\t\treturn this;\n\t},\n\n\t/**\n\t * Removes an element from the DOM.\n\t *\n\t * @private\n\t * @param {SVGDOMElement|HTMLDOMElement} element The DOM node to remove.\n\t */\n\tsafeRemoveChild: function (element) {\n\t\tvar parentNode = element.parentNode;\n\t\tif (parentNode) {\n\t\t\tparentNode.removeChild(element);\n\t\t}\n\t},\n\n\t/**\n\t * Destroy the element and element wrapper and clear up the DOM and event\n\t * hooks.\n\t *\n\t * \n\t */\n\tdestroy: function () {\n\t\tvar wrapper = this,\n\t\t\telement = wrapper.element || {},\n\t\t\tparentToClean =\n\t\t\t\twrapper.renderer.isSVG &&\n\t\t\t\telement.nodeName === 'SPAN' &&\n\t\t\t\twrapper.parentGroup,\n\t\t\tgrandParent,\n\t\t\townerSVGElement = element.ownerSVGElement,\n\t\t\ti,\n\t\t\tclipPath = wrapper.clipPath;\n\n\t\t// remove events\n\t\telement.onclick = element.onmouseout = element.onmouseover =\n\t\t\telement.onmousemove = element.point = null;\n\t\tstop(wrapper); // stop running animations\n\n\t\tif (clipPath && ownerSVGElement) {\n\t\t\t// Look for existing references to this clipPath and remove them\n\t\t\t// before destroying the element (#6196).\n\t\t\teach(\n\t\t\t\t// The upper case version is for Edge\n\t\t\t\townerSVGElement.querySelectorAll('[clip-path],[CLIP-PATH]'),\n\t\t\t\tfunction (el) {\n\t\t\t\t\tvar clipPathAttr = el.getAttribute('clip-path'),\n\t\t\t\t\t\tclipPathId = clipPath.element.id;\n\t\t\t\t\t// Include the closing paranthesis in the test to rule out\n\t\t\t\t\t// id's from 10 and above (#6550). Edge puts quotes inside\n\t\t\t\t\t// the url, others not.\n\t\t\t\t\tif (\n\t\t\t\t\t\tclipPathAttr.indexOf('(#' + clipPathId + ')') > -1 ||\n\t\t\t\t\t\tclipPathAttr.indexOf('(\"#' + clipPathId + '\")') > -1\n\t\t\t\t\t) {\n\t\t\t\t\t\tel.removeAttribute('clip-path');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\twrapper.clipPath = clipPath.destroy();\n\t\t}\n\n\t\t// Destroy stops in case this is a gradient object\n\t\tif (wrapper.stops) {\n\t\t\tfor (i = 0; i < wrapper.stops.length; i++) {\n\t\t\t\twrapper.stops[i] = wrapper.stops[i].destroy();\n\t\t\t}\n\t\t\twrapper.stops = null;\n\t\t}\n\n\t\t// remove element\n\t\twrapper.safeRemoveChild(element);\n\n\t\t/*= if (build.classic) { =*/\n\t\twrapper.destroyShadows();\n\t\t/*= } =*/\n\n\t\t// In case of useHTML, clean up empty containers emulating SVG groups\n\t\t// (#1960, #2393, #2697).\n\t\twhile (\n\t\t\tparentToClean &&\n\t\t\tparentToClean.div &&\n\t\t\tparentToClean.div.childNodes.length === 0\n\t\t) {\n\t\t\tgrandParent = parentToClean.parentGroup;\n\t\t\twrapper.safeRemoveChild(parentToClean.div);\n\t\t\tdelete parentToClean.div;\n\t\t\tparentToClean = grandParent;\n\t\t}\n\n\t\t// remove from alignObjects\n\t\tif (wrapper.alignTo) {\n\t\t\terase(wrapper.renderer.alignedObjects, wrapper);\n\t\t}\n\n\t\tobjectEach(wrapper, function (val, key) {\n\t\t\tdelete wrapper[key];\n\t\t});\n\n\t\treturn null;\n\t},\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * @typedef {Object} ShadowOptions\n\t * @property {string} [color=${palette.neutralColor100}] The shadow color.\n\t * @property {number} [offsetX=1] The horizontal offset from the element.\n\t * @property {number} [offsetY=1] The vertical offset from the element.\n\t * @property {number} [opacity=0.15] The shadow opacity.\n\t * @property {number} [width=3] The shadow width or distance from the\n\t *    element.\n\t */\n\t/**\n\t * Add a shadow to the element. Must be called after the element is added to\n\t * the DOM. In styled mode, this method is not used, instead use `defs` and\n\t * filters.\n\t * \n\t * @param {boolean|ShadowOptions} shadowOptions The shadow options. If\n\t *    `true`, the default options are applied. If `false`, the current\n\t *    shadow will be removed.\n\t * @param {SVGElement} [group] The SVG group element where the shadows will \n\t *    be applied. The default is to add it to the same parent as the current\n\t *    element. Internally, this is ised for pie slices, where all the\n\t *    shadows are added to an element behind all the slices.\n\t * @param {boolean} [cutOff] Used internally for column shadows.\n\t *\n\t * @returns {SVGElement} Returns the SVGElement for chaining.\n\t *\n\t * @example\n\t * renderer.rect(10, 100, 100, 100)\n\t *     .attr({ fill: 'red' })\n\t *     .shadow(true);\n\t */\n\tshadow: function (shadowOptions, group, cutOff) {\n\t\tvar shadows = [],\n\t\t\ti,\n\t\t\tshadow,\n\t\t\telement = this.element,\n\t\t\tstrokeWidth,\n\t\t\tshadowWidth,\n\t\t\tshadowElementOpacity,\n\n\t\t\t// compensate for inverted plot area\n\t\t\ttransform;\n\n\t\tif (!shadowOptions) {\n\t\t\tthis.destroyShadows();\n\t\t\n\t\t} else if (!this.shadows) {\n\t\t\tshadowWidth = pick(shadowOptions.width, 3);\n\t\t\tshadowElementOpacity = (shadowOptions.opacity || 0.15) /\n\t\t\t\tshadowWidth;\n\t\t\ttransform = this.parentInverted ?\n\t\t\t\t\t'(-1,-1)' :\n\t\t\t\t\t'(' + pick(shadowOptions.offsetX, 1) + ', ' +\n\t\t\t\t\t\tpick(shadowOptions.offsetY, 1) + ')';\n\t\t\tfor (i = 1; i <= shadowWidth; i++) {\n\t\t\t\tshadow = element.cloneNode(0);\n\t\t\t\tstrokeWidth = (shadowWidth * 2) + 1 - (2 * i);\n\t\t\t\tattr(shadow, {\n\t\t\t\t\t'isShadow': 'true',\n\t\t\t\t\t'stroke':\n\t\t\t\t\t\tshadowOptions.color || '${palette.neutralColor100}',\n\t\t\t\t\t'stroke-opacity': shadowElementOpacity * i,\n\t\t\t\t\t'stroke-width': strokeWidth,\n\t\t\t\t\t'transform': 'translate' + transform,\n\t\t\t\t\t'fill': 'none'\n\t\t\t\t});\n\t\t\t\tif (cutOff) {\n\t\t\t\t\tattr(\n\t\t\t\t\t\tshadow,\n\t\t\t\t\t\t'height',\n\t\t\t\t\t\tMath.max(attr(shadow, 'height') - strokeWidth, 0)\n\t\t\t\t\t);\n\t\t\t\t\tshadow.cutHeight = strokeWidth;\n\t\t\t\t}\n\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.element.appendChild(shadow);\n\t\t\t\t} else if (element.parentNode) {\n\t\t\t\t\telement.parentNode.insertBefore(shadow, element);\n\t\t\t\t}\n\n\t\t\t\tshadows.push(shadow);\n\t\t\t}\n\n\t\t\tthis.shadows = shadows;\n\t\t}\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Destroy shadows on the element.\n\t * @private\n\t */\n\tdestroyShadows: function () {\n\t\teach(this.shadows || [], function (shadow) {\n\t\t\tthis.safeRemoveChild(shadow);\n\t\t}, this);\n\t\tthis.shadows = undefined;\n\t},\n\n\t/*= } =*/\n\n\txGetter: function (key) {\n\t\tif (this.element.nodeName === 'circle') {\n\t\t\tif (key === 'x') {\n\t\t\t\tkey = 'cx';\n\t\t\t} else if (key === 'y') {\n\t\t\t\tkey = 'cy';\n\t\t\t}\n\t\t}\n\t\treturn this._defaultGetter(key);\n\t},\n\n\t/**\n\t * Get the current value of an attribute or pseudo attribute, used mainly\n\t * for animation. Called internally from the {@link\n\t * Highcharts.SVGRenderer#attr}\n\t * function.\n\t *\n\t * @private\n\t */\n\t_defaultGetter: function (key) {\n\t\tvar ret = pick(\n\t\t\tthis[key + 'Value'], // align getter\n\t\t\tthis[key],\n\t\t\tthis.element ? this.element.getAttribute(key) : null,\n\t\t\t0\n\t\t);\n\n\t\tif (/^[\\-0-9\\.]+$/.test(ret)) { // is numerical\n\t\t\tret = parseFloat(ret);\n\t\t}\n\t\treturn ret;\n\t},\n\n\n\tdSetter: function (value, key, element) {\n\t\tif (value && value.join) { // join path\n\t\t\tvalue = value.join(' ');\n\t\t}\n\t\tif (/(NaN| {2}|^$)/.test(value)) {\n\t\t\tvalue = 'M 0 0';\n\t\t}\n\n\t\t// Check for cache before resetting. Resetting causes disturbance in the\n\t\t// DOM, causing flickering in some cases in Edge/IE (#6747). Also\n\t\t// possible performance gain.\n\t\tif (this[key] !== value) {\n\t\t\telement.setAttribute(key, value);\n\t\t\tthis[key] = value;\n\t\t}\t\t\n\n\t},\n\t/*= if (build.classic) { =*/\n\tdashstyleSetter: function (value) {\n\t\tvar i,\n\t\t\tstrokeWidth = this['stroke-width'];\n\t\t\n\t\t// If \"inherit\", like maps in IE, assume 1 (#4981). With HC5 and the new\n\t\t// strokeWidth function, we should be able to use that instead.\n\t\tif (strokeWidth === 'inherit') {\n\t\t\tstrokeWidth = 1;\n\t\t}\n\t\tvalue = value && value.toLowerCase();\n\t\tif (value) {\n\t\t\tvalue = value\n\t\t\t\t.replace('shortdashdotdot', '3,1,1,1,1,1,')\n\t\t\t\t.replace('shortdashdot', '3,1,1,1')\n\t\t\t\t.replace('shortdot', '1,1,')\n\t\t\t\t.replace('shortdash', '3,1,')\n\t\t\t\t.replace('longdash', '8,3,')\n\t\t\t\t.replace(/dot/g, '1,3,')\n\t\t\t\t.replace('dash', '4,3,')\n\t\t\t\t.replace(/,$/, '')\n\t\t\t\t.split(','); // ending comma\n\n\t\t\ti = value.length;\n\t\t\twhile (i--) {\n\t\t\t\tvalue[i] = pInt(value[i]) * strokeWidth;\n\t\t\t}\n\t\t\tvalue = value.join(',')\n\t\t\t\t.replace(/NaN/g, 'none'); // #3226\n\t\t\tthis.element.setAttribute('stroke-dasharray', value);\n\t\t}\n\t},\n\t/*= } =*/\n\talignSetter: function (value) {\n\t\tvar convert = { left: 'start', center: 'middle', right: 'end' };\n\t\tthis.alignValue = value;\n\t\tthis.element.setAttribute('text-anchor', convert[value]);\n\t},\n\topacitySetter: function (value, key, element) {\t\t\n\t\tthis[key] = value;\t\t\n\t\telement.setAttribute(key, value);\t\t\n\t},\n\ttitleSetter: function (value) {\n\t\tvar titleNode = this.element.getElementsByTagName('title')[0];\n\t\tif (!titleNode) {\n\t\t\ttitleNode = doc.createElementNS(this.SVG_NS, 'title');\n\t\t\tthis.element.appendChild(titleNode);\n\t\t}\n\n\t\t// Remove text content if it exists\n\t\tif (titleNode.firstChild) {\n\t\t\ttitleNode.removeChild(titleNode.firstChild);\n\t\t}\n\n\t\ttitleNode.appendChild(\n\t\t\tdoc.createTextNode(\n\t\t\t\t// #3276, #3895\n\t\t\t\t(String(pick(value), ''))\n\t\t\t\t\t.replace(/<[^>]*>/g, '')\n\t\t\t\t\t.replace(/&lt;/g, '<')\n\t\t\t\t\t.replace(/&gt;/g, '>')\n\t\t\t)\n\t\t);\n\t},\n\ttextSetter: function (value) {\n\t\tif (value !== this.textStr) {\n\t\t\t// Delete bBox memo when the text changes\n\t\t\tdelete this.bBox;\n\n\t\t\tthis.textStr = value;\n\t\t\tif (this.added) {\n\t\t\t\tthis.renderer.buildText(this);\n\t\t\t}\n\t\t}\n\t},\n\tfillSetter: function (value, key, element) {\n\t\tif (typeof value === 'string') {\n\t\t\telement.setAttribute(key, value);\n\t\t} else if (value) {\n\t\t\tthis.colorGradient(value, key, element);\n\t\t}\n\t},\n\tvisibilitySetter: function (value, key, element) {\n\t\t// IE9-11 doesn't handle visibilty:inherit well, so we remove the\n\t\t// attribute instead (#2881, #3909)\n\t\tif (value === 'inherit') {\n\t\t\telement.removeAttribute(key);\n\t\t} else if (this[key] !== value) { // #6747\n\t\t\telement.setAttribute(key, value);\n\t\t}\n\t\tthis[key] = value;\n\t},\n\tzIndexSetter: function (value, key) {\n\t\tvar renderer = this.renderer,\n\t\t\tparentGroup = this.parentGroup,\n\t\t\tparentWrapper = parentGroup || renderer,\n\t\t\tparentNode = parentWrapper.element || renderer.box,\n\t\t\tchildNodes,\n\t\t\totherElement,\n\t\t\totherZIndex,\n\t\t\telement = this.element,\n\t\t\tinserted,\n\t\t\tundefinedOtherZIndex,\n\t\t\tsvgParent = parentNode === renderer.box,\n\t\t\trun = this.added,\n\t\t\ti;\n\n\t\tif (defined(value)) {\n\t\t\t// So we can read it for other elements in the group\n\t\t\telement.zIndex = value;\n\n\t\t\tvalue = +value;\n\t\t\tif (this[key] === value) { // Only update when needed (#3865)\n\t\t\t\trun = false;\n\t\t\t}\n\t\t\tthis[key] = value;\n\t\t}\n\n\t\t// Insert according to this and other elements' zIndex. Before .add() is\n\t\t// called, nothing is done. Then on add, or by later calls to\n\t\t// zIndexSetter, the node is placed on the right place in the DOM.\n\t\tif (run) {\n\t\t\tvalue = this.zIndex;\n\n\t\t\tif (value && parentGroup) {\n\t\t\t\tparentGroup.handleZ = true;\n\t\t\t}\n\n\t\t\tchildNodes = parentNode.childNodes;\n\t\t\tfor (i = childNodes.length - 1; i >= 0 && !inserted; i--) {\n\t\t\t\totherElement = childNodes[i];\n\t\t\t\totherZIndex = otherElement.zIndex;\n\t\t\t\tundefinedOtherZIndex = !defined(otherZIndex);\n\n\t\t\t\tif (otherElement !== element) {\n\t\t\t\t\tif (\n\t\t\t\t\t\t// Negative zIndex versus no zIndex:\n\t\t\t\t\t\t// On all levels except the highest. If the parent is\n\t\t\t\t\t\t// <svg>, then we don't want to put items before <desc>\n\t\t\t\t\t\t// or <defs>\n\t\t\t\t\t\t(value < 0 && undefinedOtherZIndex && !svgParent && !i)\n\t\t\t\t\t) {\n\t\t\t\t\t\tparentNode.insertBefore(element, childNodes[i]);\n\t\t\t\t\t\tinserted = true;\n\t\t\t\t\t} else if (\n\t\t\t\t\t\t// Insert after the first element with a lower zIndex\n\t\t\t\t\t\tpInt(otherZIndex) <= value ||\n\t\t\t\t\t\t// If negative zIndex, add this before first undefined\n\t\t\t\t\t\t// zIndex element\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tundefinedOtherZIndex &&\n\t\t\t\t\t\t\t(!defined(value) || value >= 0)\n\t\t\t\t\t\t)\n\t\t\t\t\t) {\n\t\t\t\t\t\tparentNode.insertBefore(\n\t\t\t\t\t\t\telement,\n\t\t\t\t\t\t\tchildNodes[i + 1] || null // null for oldIE export\n\t\t\t\t\t\t);\n\t\t\t\t\t\tinserted = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!inserted) {\n\t\t\t\tparentNode.insertBefore(\n\t\t\t\t\telement,\n\t\t\t\t\tchildNodes[svgParent ? 3 : 0] || null // null for oldIE\n\t\t\t\t);\n\t\t\t\tinserted = true;\n\t\t\t}\n\t\t}\n\t\treturn inserted;\n\t},\n\t_defaultSetter: function (value, key, element) {\n\t\telement.setAttribute(key, value);\n\t}\n});\n\n// Some shared setters and getters\nSVGElement.prototype.yGetter =\nSVGElement.prototype.xGetter;\nSVGElement.prototype.translateXSetter =\nSVGElement.prototype.translateYSetter =\nSVGElement.prototype.rotationSetter =\nSVGElement.prototype.verticalAlignSetter =\nSVGElement.prototype.rotationOriginXSetter =\nSVGElement.prototype.rotationOriginYSetter = \nSVGElement.prototype.scaleXSetter =\nSVGElement.prototype.scaleYSetter = \nSVGElement.prototype.matrixSetter = function (value, key) {\n\tthis[key] = value;\n\tthis.doTransform = true;\n};\n\n/*= if (build.classic) { =*/\n// WebKit and Batik have problems with a stroke-width of zero, so in this case\n// we remove the stroke attribute altogether. #1270, #1369, #3065, #3072.\nSVGElement.prototype['stroke-widthSetter'] =\nSVGElement.prototype.strokeSetter = function (value, key, element) {\n\tthis[key] = value;\n\t// Only apply the stroke attribute if the stroke width is defined and larger\n\t// than 0\n\tif (this.stroke && this['stroke-width']) {\n\t\t// Use prototype as instance may be overridden\n\t\tSVGElement.prototype.fillSetter.call(\n\t\t\tthis,\n\t\t\tthis.stroke,\n\t\t\t'stroke',\n\t\t\telement\n\t\t);\n\t\t\n\t\telement.setAttribute('stroke-width', this['stroke-width']);\n\t\tthis.hasStroke = true;\n\t} else if (key === 'stroke-width' && value === 0 && this.hasStroke) {\n\t\telement.removeAttribute('stroke');\n\t\tthis.hasStroke = false;\n\t}\n};\n/*= } =*/\n\n/**\n * Allows direct access to the Highcharts rendering layer in order to draw\n * primitive shapes like circles, rectangles, paths or text directly on a chart,\n * or independent from any chart. The SVGRenderer represents a wrapper object\n * for SVG in modern browsers. Through the VMLRenderer, part of the `oldie.js`\n * module, it also brings vector graphics to IE <= 8.\n *\n * An existing chart's renderer can be accessed through {@link Chart.renderer}.\n * The renderer can also be used completely decoupled from a chart.\n *\n * @param {HTMLDOMElement} container - Where to put the SVG in the web page.\n * @param {number} width - The width of the SVG.\n * @param {number} height - The height of the SVG.\n * @param {boolean} [forExport=false] - Whether the rendered content is intended\n *   for export.\n * @param {boolean} [allowHTML=true] - Whether the renderer is allowed to\n *   include HTML text, which will be projected on top of the SVG.\n *\n * @example\n * // Use directly without a chart object.\n * var renderer = new Highcharts.Renderer(parentNode, 600, 400);\n *\n * @sample highcharts/members/renderer-on-chart\n *         Annotating a chart programmatically.\n * @sample highcharts/members/renderer-basic\n *         Independent SVG drawing.\n *\n * @class Highcharts.SVGRenderer\n */\nSVGRenderer = H.SVGRenderer = function () {\n\tthis.init.apply(this, arguments);\n};\nextend(SVGRenderer.prototype, /** @lends Highcharts.SVGRenderer.prototype */ {\n\t/**\n\t * A pointer to the renderer's associated Element class. The VMLRenderer\n\t * will have a pointer to VMLElement here.\n\t * @type {SVGElement}\n\t */\n\tElement: SVGElement,\n\tSVG_NS: SVG_NS,\n\t/**\n\t * Initialize the SVGRenderer. Overridable initiator function that takes\n\t * the same parameters as the constructor.\n\t */\n\tinit: function (container, width, height, style, forExport, allowHTML) {\n\t\tvar renderer = this,\n\t\t\tboxWrapper,\n\t\t\telement,\n\t\t\tdesc;\n\n\t\tboxWrapper = renderer.createElement('svg')\n\t\t\t.attr({\n\t\t\t\t'version': '1.1',\n\t\t\t\t'class': 'highcharts-root'\n\t\t\t})\n\t\t\t/*= if (build.classic) { =*/\n\t\t\t.css(this.getStyle(style))\n\t\t\t/*= } =*/;\n\t\telement = boxWrapper.element;\n\t\tcontainer.appendChild(element);\n\n\t\t// Always use ltr on the container, otherwise text-anchor will be\n\t\t// flipped and text appear outside labels, buttons, tooltip etc (#3482)\n\t\tattr(container, 'dir', 'ltr');\n\n\t\t// For browsers other than IE, add the namespace attribute (#1978)\n\t\tif (container.innerHTML.indexOf('xmlns') === -1) {\n\t\t\tattr(element, 'xmlns', this.SVG_NS);\n\t\t}\n\n\t\t// object properties\n\t\trenderer.isSVG = true;\n\n\t\t/** \n\t\t * The root `svg` node of the renderer.\n\t\t * @name box\n\t\t * @memberOf SVGRenderer\n\t\t * @type {SVGDOMElement}\n\t\t */\n\t\tthis.box = element;\n\t\t/** \n\t\t * The wrapper for the root `svg` node of the renderer.\n\t\t *\n\t\t * @name boxWrapper\n\t\t * @memberOf SVGRenderer\n\t\t * @type {SVGElement}\n\t\t */\n\t\tthis.boxWrapper = boxWrapper;\n\t\trenderer.alignedObjects = [];\n\n\t\t/**\n\t\t * Page url used for internal references.\n\t\t * @type {string}\n\t\t */\n\t\t// #24, #672, #1070\n\t\tthis.url = (\n\t\t\t\t(isFirefox || isWebKit) &&\n\t\t\t\tdoc.getElementsByTagName('base').length\n\t\t\t) ?\n\t\t\t\twin.location.href\n\t\t\t\t\t.replace(/#.*?$/, '') // remove the hash\n\t\t\t\t\t.replace(/<[^>]*>/g, '') // wing cut HTML\n\t\t\t\t\t// escape parantheses and quotes\n\t\t\t\t\t.replace(/([\\('\\)])/g, '\\\\$1')\n\t\t\t\t\t// replace spaces (needed for Safari only)\n\t\t\t\t\t.replace(/ /g, '%20') :\n\t\t\t\t'';\n\n\t\t// Add description\n\t\tdesc = this.createElement('desc').add();\n\t\tdesc.element.appendChild(\n\t\t\tdoc.createTextNode('Created with @product.name@ @product.version@')\n\t\t);\n\n\t\t/**\n\t\t * A pointer to the `defs` node of the root SVG.\n\t\t * @type {SVGElement}\n\t\t * @name defs\n\t\t * @memberOf SVGRenderer\n\t\t */\n\t\trenderer.defs = this.createElement('defs').add();\n\t\trenderer.allowHTML = allowHTML;\n\t\trenderer.forExport = forExport;\n\t\trenderer.gradients = {}; // Object where gradient SvgElements are stored\n\t\trenderer.cache = {}; // Cache for numerical bounding boxes\n\t\trenderer.cacheKeys = [];\n\t\trenderer.imgCount = 0;\n\n\t\trenderer.setSize(width, height, false);\n\n\t\t\n\n\t\t// Issue 110 workaround:\n\t\t// In Firefox, if a div is positioned by percentage, its pixel position\n\t\t// may land between pixels. The container itself doesn't display this,\n\t\t// but an SVG element inside this container will be drawn at subpixel\n\t\t// precision. In order to draw sharp lines, this must be compensated\n\t\t// for. This doesn't seem to work inside iframes though (like in\n\t\t// jsFiddle).\n\t\tvar subPixelFix, rect;\n\t\tif (isFirefox && container.getBoundingClientRect) {\n\t\t\tsubPixelFix = function () {\n\t\t\t\tcss(container, { left: 0, top: 0 });\n\t\t\t\trect = container.getBoundingClientRect();\n\t\t\t\tcss(container, {\n\t\t\t\t\tleft: (Math.ceil(rect.left) - rect.left) + 'px',\n\t\t\t\t\ttop: (Math.ceil(rect.top) - rect.top) + 'px'\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t// run the fix now\n\t\t\tsubPixelFix();\n\n\t\t\t// run it on resize\n\t\t\trenderer.unSubPixelFix = addEvent(win, 'resize', subPixelFix);\n\t\t}\n\t},\n\t/*= if (!build.classic) { =*/\n\t/**\n\t * General method for adding a definition to the SVG `defs` tag. Can be used\n\t *   for gradients, fills, filters etc. Styled mode only. A hook for adding\n\t *   general definitions to the SVG's defs tag. Definitions can be\n\t *   referenced from the CSS by its `id`. Read more in\n\t *   [gradients, shadows and patterns]{@link http://www.highcharts.com/docs/\n\t *   chart-design-and-style/gradients-shadows-and-patterns}.\n\t *   Styled mode only.\n\t *\n\t * @param {Object} def - A serialized form of an SVG definition, including\n\t *   children\n\t *\n\t * @return {SVGElement} The inserted node. \n\t */\n\tdefinition: function (def) {\n\t\tvar ren = this;\n\n\t\tfunction recurse(config, parent) {\n\t\t\tvar ret;\n\t\t\teach(splat(config), function (item) {\n\t\t\t\tvar node = ren.createElement(item.tagName),\n\t\t\t\t\tattr = {};\n\n\t\t\t\t// Set attributes\n\t\t\t\tobjectEach(item, function (val, key) {\n\t\t\t\t\tif (\n\t\t\t\t\t\tkey !== 'tagName' &&\n\t\t\t\t\t\tkey !== 'children' &&\n\t\t\t\t\t\tkey !== 'textContent'\n\t\t\t\t\t) {\n\t\t\t\t\t\tattr[key] = val;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tnode.attr(attr);\n\n\t\t\t\t// Add to the tree\n\t\t\t\tnode.add(parent || ren.defs);\n\n\t\t\t\t// Add text content\n\t\t\t\tif (item.textContent) {\n\t\t\t\t\tnode.element.appendChild(\n\t\t\t\t\t\tdoc.createTextNode(item.textContent)\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Recurse\n\t\t\t\trecurse(item.children || [], node);\n\n\t\t\t\tret = node;\n\t\t\t});\n\n\t\t\t// Return last node added (on top level it's the only one)\n\t\t\treturn ret;\n\t\t}\n\t\treturn recurse(def);\n\t},\n\t/*= } =*/\n\n\t/*= if (build.classic) { =*/\n\t/**\n\t * Get the global style setting for the renderer.\n\t * @private\n\t * @param  {CSSObject} style - Style settings.\n\t * @return {CSSObject} The style settings mixed with defaults.\n\t */\n\tgetStyle: function (style) {\n\t\tthis.style = extend({\n\t\t\t\n\t\t\tfontFamily: '\"Lucida Grande\", \"Lucida Sans Unicode\", ' +\n\t\t\t\t'Arial, Helvetica, sans-serif',\n\t\t\tfontSize: '12px'\n\n\t\t}, style);\n\t\treturn this.style;\n\t},\n\t/**\n\t * Apply the global style on the renderer, mixed with the default styles.\n\t * \n\t * @param {CSSObject} style - CSS to apply.\n\t */\n\tsetStyle: function (style) {\n\t\tthis.boxWrapper.css(this.getStyle(style));\n\t},\n\t/*= } =*/\n\n\t/**\n\t * Detect whether the renderer is hidden. This happens when one of the\n\t * parent elements has `display: none`. Used internally to detect when we\n\t * needto render preliminarily in another div to get the text bounding boxes\n\t * right.\n\t *\n\t * @returns {boolean} True if it is hidden.\n\t */\n\tisHidden: function () { // #608\n\t\treturn !this.boxWrapper.getBBox().width;\n\t},\n\n\t/**\n\t * Destroys the renderer and its allocated members.\n\t */\n\tdestroy: function () {\n\t\tvar renderer = this,\n\t\t\trendererDefs = renderer.defs;\n\t\trenderer.box = null;\n\t\trenderer.boxWrapper = renderer.boxWrapper.destroy();\n\n\t\t// Call destroy on all gradient elements\n\t\tdestroyObjectProperties(renderer.gradients || {});\n\t\trenderer.gradients = null;\n\n\t\t// Defs are null in VMLRenderer\n\t\t// Otherwise, destroy them here.\n\t\tif (rendererDefs) {\n\t\t\trenderer.defs = rendererDefs.destroy();\n\t\t}\n\n\t\t// Remove sub pixel fix handler (#982)\n\t\tif (renderer.unSubPixelFix) {\n\t\t\trenderer.unSubPixelFix();\n\t\t}\n\n\t\trenderer.alignedObjects = null;\n\n\t\treturn null;\n\t},\n\n\t/**\n\t * Create a wrapper for an SVG element. Serves as a factory for \n\t * {@link SVGElement}, but this function is itself mostly called from \n\t * primitive factories like {@link SVGRenderer#path}, {@link\n\t * SVGRenderer#rect} or {@link SVGRenderer#text}.\n\t * \n\t * @param {string} nodeName - The node name, for example `rect`, `g` etc.\n\t * @returns {SVGElement} The generated SVGElement.\n\t */\n\tcreateElement: function (nodeName) {\n\t\tvar wrapper = new this.Element();\n\t\twrapper.init(this, nodeName);\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Dummy function for plugins, called every time the renderer is updated.\n\t * Prior to Highcharts 5, this was used for the canvg renderer.\n\t * @function\n\t */\n\tdraw: noop,\n\n\t/**\n\t * Get converted radial gradient attributes according to the radial\n\t * reference. Used internally from the {@link SVGElement#colorGradient}\n\t * function.\n\t *\n\t * @private\n\t */\n\tgetRadialAttr: function (radialReference, gradAttr) {\n\t\treturn {\n\t\t\tcx: (radialReference[0] - radialReference[2] / 2) +\n\t\t\t\tgradAttr.cx * radialReference[2],\n\t\t\tcy: (radialReference[1] - radialReference[2] / 2) +\n\t\t\t\tgradAttr.cy * radialReference[2],\n\t\t\tr: gradAttr.r * radialReference[2]\n\t\t};\n\t},\n\t\n\t/**\n\t * Extendable function to measure the tspan width.\n\t *\n\t * @private\n\t */\n\tgetSpanWidth: function (wrapper) {\n\t\treturn wrapper.getBBox(true).width;\n\t},\n\t\n\tapplyEllipsis: function (wrapper, tspan, text, width) {\n\t\tvar renderer = this,\n\t\t\trotation = wrapper.rotation,\n\t\t\tstr = text,\n\t\t\tcurrentIndex,\n\t\t\tminIndex = 0,\n\t\t\tmaxIndex = text.length,\n\t\t\tupdateTSpan = function (s) {\n\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\tif (s) {\n\t\t\t\t\ttspan.appendChild(doc.createTextNode(s));\n\t\t\t\t}\n\t\t\t},\n\t\t\tactualWidth,\n\t\t\twasTooLong;\n\t\twrapper.rotation = 0; // discard rotation when computing box\n\t\tactualWidth = renderer.getSpanWidth(wrapper, tspan);\n\t\twasTooLong = actualWidth > width;\n\t\tif (wasTooLong) {\n\t\t\twhile (minIndex <= maxIndex) {\n\t\t\t\tcurrentIndex = Math.ceil((minIndex + maxIndex) / 2);\n\t\t\t\tstr = text.substring(0, currentIndex) + '\\u2026';\n\t\t\t\tupdateTSpan(str);\n\t\t\t\tactualWidth = renderer.getSpanWidth(wrapper, tspan);\n\t\t\t\tif (minIndex === maxIndex) {\n\t\t\t\t\t// Complete\n\t\t\t\t\tminIndex = maxIndex + 1;\n\t\t\t\t} else if (actualWidth > width) {\n\t\t\t\t\t// Too large. Set max index to current.\n\t\t\t\t\tmaxIndex = currentIndex - 1;\n\t\t\t\t} else {\n\t\t\t\t\t// Within width. Set min index to current.\n\t\t\t\t\tminIndex = currentIndex;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If max index was 0 it means just ellipsis was also to large.\n\t\t\tif (maxIndex === 0) {\n\t\t\t\t// Remove ellipses.\n\t\t\t\tupdateTSpan('');\n\t\t\t}\n\t\t}\n\t\twrapper.rotation = rotation; // Apply rotation again.\n\t\treturn wasTooLong;\n\t},\n\n\t/**\n\t * A collection of characters mapped to HTML entities. When `useHTML` on an\n\t * element is true, these entities will be rendered correctly by HTML. In \n\t * the SVG pseudo-HTML, they need to be unescaped back to simple characters,\n\t * so for example `&lt;` will render as `<`.\n\t *\n\t * @example\n\t * // Add support for unescaping quotes\n\t * Highcharts.SVGRenderer.prototype.escapes['\"'] = '&quot;';\n\t * \n\t * @type {Object}\n\t */\n\tescapes: {\n\t\t'&': '&amp;',\n\t\t'<': '&lt;',\n\t\t'>': '&gt;',\n\t\t\"'\": '&#39;', // eslint-disable-line quotes\n\t\t'\"': '&quot;'\n\t},\n\n\t/**\n\t * Parse a simple HTML string into SVG tspans. Called internally when text\n\t *   is set on an SVGElement. The function supports a subset of HTML tags,\n\t *   CSS text features like `width`, `text-overflow`, `white-space`, and\n\t *   also attributes like `href` and `style`.\n\t * @private\n\t * @param {SVGElement} wrapper The parent SVGElement.\n\t */\n\tbuildText: function (wrapper) {\n\t\tvar textNode = wrapper.element,\n\t\t\trenderer = this,\n\t\t\tforExport = renderer.forExport,\n\t\t\ttextStr = pick(wrapper.textStr, '').toString(),\n\t\t\thasMarkup = textStr.indexOf('<') !== -1,\n\t\t\tlines,\n\t\t\tchildNodes = textNode.childNodes,\n\t\t\twasTooLong,\n\t\t\tparentX = attr(textNode, 'x'),\n\t\t\ttextStyles = wrapper.styles,\n\t\t\twidth = wrapper.textWidth,\n\t\t\ttextLineHeight = textStyles && textStyles.lineHeight,\n\t\t\ttextOutline = textStyles && textStyles.textOutline,\n\t\t\tellipsis = textStyles && textStyles.textOverflow === 'ellipsis',\n\t\t\tnoWrap = textStyles && textStyles.whiteSpace === 'nowrap',\n\t\t\tfontSize = textStyles && textStyles.fontSize,\n\t\t\ttextCache,\n\t\t\tisSubsequentLine,\n\t\t\ti = childNodes.length,\n\t\t\ttempParent = width && !wrapper.added && this.box,\n\t\t\tgetLineHeight = function (tspan) {\n\t\t\t\tvar fontSizeStyle;\n\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\tfontSizeStyle = /(px|em)$/.test(tspan && tspan.style.fontSize) ?\n\t\t\t\t\ttspan.style.fontSize :\n\t\t\t\t\t(fontSize || renderer.style.fontSize || 12);\n\t\t\t\t/*= } =*/\n\n\t\t\t\treturn textLineHeight ? \n\t\t\t\t\tpInt(textLineHeight) :\n\t\t\t\t\trenderer.fontMetrics(\n\t\t\t\t\t\tfontSizeStyle,\n\t\t\t\t\t\t// Get the computed size from parent if not explicit\n\t\t\t\t\t\ttspan.getAttribute('style') ? tspan : textNode\n\t\t\t\t\t).h;\n\t\t\t},\n\t\t\tunescapeEntities = function (inputStr, except) {\n\t\t\t\tobjectEach(renderer.escapes, function (value, key) {\n\t\t\t\t\tif (!except || inArray(value, except) === -1) {\n\t\t\t\t\t\tinputStr = inputStr.toString().replace(\n\t\t\t\t\t\t\tnew RegExp(value, 'g'), // eslint-disable-line security/detect-non-literal-regexp\n\t\t\t\t\t\t\tkey\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn inputStr;\n\t\t\t},\n\t\t\tparseAttribute = function (s, attr) {\n\t\t\t\tvar start,\n\t\t\t\t\tdelimiter;\n\n\t\t\t\tstart = s.indexOf('<');\n\t\t\t\ts = s.substring(start, s.indexOf('>') - start);\n\n\t\t\t\tstart = s.indexOf(attr + '=');\n\t\t\t\tif (start !== -1) {\n\t\t\t\t\tstart = start + attr.length + 1;\n\t\t\t\t\tdelimiter = s.charAt(start);\n\t\t\t\t\tif (delimiter === '\"' || delimiter === \"'\") { // eslint-disable-line quotes\n\t\t\t\t\t\ts = s.substring(start + 1);\n\t\t\t\t\t\treturn s.substring(0, s.indexOf(delimiter));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t// The buildText code is quite heavy, so if we're not changing something\n\t\t// that affects the text, skip it (#6113).\n\t\ttextCache = [\n\t\t\ttextStr,\n\t\t\tellipsis,\n\t\t\tnoWrap,\n\t\t\ttextLineHeight,\n\t\t\ttextOutline,\n\t\t\tfontSize,\n\t\t\twidth\n\t\t].join(',');\n\t\tif (textCache === wrapper.textCache) {\n\t\t\treturn;\n\t\t}\n\t\twrapper.textCache = textCache;\n\n\t\t// Remove old text\n\t\twhile (i--) {\n\t\t\ttextNode.removeChild(childNodes[i]);\n\t\t}\n\n\t\t// Skip tspans, add text directly to text node. The forceTSpan is a hook\n\t\t// used in text outline hack.\n\t\tif (\n\t\t\t!hasMarkup &&\n\t\t\t!textOutline &&\n\t\t\t!ellipsis &&\n\t\t\t!width &&\n\t\t\ttextStr.indexOf(' ') === -1\n\t\t) {\n\t\t\ttextNode.appendChild(doc.createTextNode(unescapeEntities(textStr)));\n\n\t\t// Complex strings, add more logic\n\t\t} else {\n\n\t\t\tif (tempParent) {\n\t\t\t\t// attach it to the DOM to read offset width\n\t\t\t\ttempParent.appendChild(textNode);\n\t\t\t}\n\n\t\t\tif (hasMarkup) {\n\t\t\t\tlines = textStr\n\t\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\t\t.replace(/<(b|strong)>/g, '<span style=\"font-weight:bold\">')\n\t\t\t\t\t.replace(/<(i|em)>/g, '<span style=\"font-style:italic\">')\n\t\t\t\t\t/*= } else { =*/\n\t\t\t\t\t.replace(\n\t\t\t\t\t\t/<(b|strong)>/g,\n\t\t\t\t\t\t'<span class=\"highcharts-strong\">'\n\t\t\t\t\t)\n\t\t\t\t\t.replace(\n\t\t\t\t\t\t/<(i|em)>/g,\n\t\t\t\t\t\t'<span class=\"highcharts-emphasized\">'\n\t\t\t\t\t)\n\t\t\t\t\t/*= } =*/\n\t\t\t\t\t.replace(/<a/g, '<span')\n\t\t\t\t\t.replace(/<\\/(b|strong|i|em|a)>/g, '</span>')\n\t\t\t\t\t.split(/<br.*?>/g);\n\n\t\t\t} else {\n\t\t\t\tlines = [textStr];\n\t\t\t}\n\n\n\t\t\t// Trim empty lines (#5261)\n\t\t\tlines = grep(lines, function (line) {\n\t\t\t\treturn line !== '';\n\t\t\t});\n\n\n\t\t\t// build the lines\n\t\t\teach(lines, function buildTextLines(line, lineNo) {\n\t\t\t\tvar spans,\n\t\t\t\t\tspanNo = 0;\n\t\t\t\tline = line\n\t\t\t\t\t// Trim to prevent useless/costly process on the spaces\n\t\t\t\t\t// (#5258)\n\t\t\t\t\t.replace(/^\\s+|\\s+$/g, '')\n\t\t\t\t\t.replace(/<span/g, '|||<span')\n\t\t\t\t\t.replace(/<\\/span>/g, '</span>|||');\n\t\t\t\tspans = line.split('|||');\n\n\t\t\t\teach(spans, function buildTextSpans(span) {\n\t\t\t\t\tif (span !== '' || spans.length === 1) {\n\t\t\t\t\t\tvar attributes = {},\n\t\t\t\t\t\t\ttspan = doc.createElementNS(\n\t\t\t\t\t\t\t\trenderer.SVG_NS,\n\t\t\t\t\t\t\t\t'tspan'\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tclassAttribute,\n\t\t\t\t\t\t\tstyleAttribute, // #390\n\t\t\t\t\t\t\threfAttribute;\n\t\t\t\t\t\t\n\t\t\t\t\t\tclassAttribute = parseAttribute(span, 'class');\n\t\t\t\t\t\tif (classAttribute) {\n\t\t\t\t\t\t\tattr(tspan, 'class', classAttribute);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstyleAttribute = parseAttribute(span, 'style');\n\t\t\t\t\t\tif (styleAttribute) {\n\t\t\t\t\t\t\tstyleAttribute = styleAttribute.replace(\n\t\t\t\t\t\t\t\t/(;| |^)color([ :])/,\n\t\t\t\t\t\t\t\t'$1fill$2'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tattr(tspan, 'style', styleAttribute);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Not for export - #1529\n\t\t\t\t\t\threfAttribute = parseAttribute(span, 'href');\n\t\t\t\t\t\tif (hrefAttribute && !forExport) {\n\t\t\t\t\t\t\tattr(\n\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t'onclick',\n\t\t\t\t\t\t\t\t'location.href=\\\"' + hrefAttribute + '\\\"'\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tattr(tspan, 'class', 'highcharts-anchor');\n\t\t\t\t\t\t\t/*= if (build.classic) { =*/\n\t\t\t\t\t\t\tcss(tspan, { cursor: 'pointer' });\n\t\t\t\t\t\t\t/*= } =*/\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Strip away unsupported HTML tags (#7126)\n\t\t\t\t\t\tspan = unescapeEntities(\n\t\t\t\t\t\t\tspan.replace(/<[a-zA-Z\\/](.|\\n)*?>/g, '') || ' '\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// Nested tags aren't supported, and cause crash in\n\t\t\t\t\t\t// Safari (#1596)\n\t\t\t\t\t\tif (span !== ' ') {\n\n\t\t\t\t\t\t\t// add the text node\n\t\t\t\t\t\t\ttspan.appendChild(doc.createTextNode(span));\n\n\t\t\t\t\t\t\t// First span in a line, align it to the left\n\t\t\t\t\t\t\tif (!spanNo) {\n\t\t\t\t\t\t\t\tif (lineNo && parentX !== null) {\n\t\t\t\t\t\t\t\t\tattributes.x = parentX;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tattributes.dx = 0; // #16\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// add attributes\n\t\t\t\t\t\t\tattr(tspan, attributes);\n\n\t\t\t\t\t\t\t// Append it\n\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\n\t\t\t\t\t\t\t// first span on subsequent line, add the line\n\t\t\t\t\t\t\t// height\n\t\t\t\t\t\t\tif (!spanNo && isSubsequentLine) {\n\n\t\t\t\t\t\t\t\t// allow getting the right offset height in\n\t\t\t\t\t\t\t\t// exporting in IE\n\t\t\t\t\t\t\t\tif (!svg && forExport) {\n\t\t\t\t\t\t\t\t\tcss(tspan, { display: 'block' });\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Set the line height based on the font size of\n\t\t\t\t\t\t\t\t// either the text element or the tspan element\n\t\t\t\t\t\t\t\tattr(\n\t\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t\t'dy',\n\t\t\t\t\t\t\t\t\tgetLineHeight(tspan)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\t// Experimental text wrapping based on\n\t\t\t\t\t\t\t// getSubstringLength\n\t\t\t\t\t\t\tif (width) {\n\t\t\t\t\t\t\t\tvar spans = renderer.breakText(wrapper, width);\n\n\t\t\t\t\t\t\t\teach(spans, function (span) {\n\n\t\t\t\t\t\t\t\t\tvar dy = getLineHeight(tspan);\n\t\t\t\t\t\t\t\t\ttspan = doc.createElementNS(\n\t\t\t\t\t\t\t\t\t\tSVG_NS,\n\t\t\t\t\t\t\t\t\t\t'tspan'\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\ttspan.appendChild(\n\t\t\t\t\t\t\t\t\t\tdoc.createTextNode(span)\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tattr(tspan, {\n\t\t\t\t\t\t\t\t\t\tdy: dy,\n\t\t\t\t\t\t\t\t\t\tx: parentX\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\tif (spanStyle) { // #390\n\t\t\t\t\t\t\t\t\t\tattr(tspan, 'style', spanStyle);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// */\n\n\t\t\t\t\t\t\t// Check width and apply soft breaks or ellipsis\n\t\t\t\t\t\t\tif (width) {\n\t\t\t\t\t\t\t\tvar words = span.replace(\n\t\t\t\t\t\t\t\t\t\t/([^\\^])-/g,\n\t\t\t\t\t\t\t\t\t\t'$1- '\n\t\t\t\t\t\t\t\t\t).split(' '), // #1273\n\t\t\t\t\t\t\t\t\thasWhiteSpace = (\n\t\t\t\t\t\t\t\t\t\tspans.length > 1 ||\n\t\t\t\t\t\t\t\t\t\tlineNo ||\n\t\t\t\t\t\t\t\t\t\t(words.length > 1 && !noWrap)\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\t\ttooLong,\n\t\t\t\t\t\t\t\t\trest = [],\n\t\t\t\t\t\t\t\t\tactualWidth,\n\t\t\t\t\t\t\t\t\tdy = getLineHeight(tspan),\n\t\t\t\t\t\t\t\t\trotation = wrapper.rotation;\n\n\t\t\t\t\t\t\t\tif (ellipsis) {\n\t\t\t\t\t\t\t\t\twasTooLong = renderer.applyEllipsis(\n\t\t\t\t\t\t\t\t\t\twrapper,\n\t\t\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t\t\tspan,\n\t\t\t\t\t\t\t\t\t\twidth\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\twhile (\n\t\t\t\t\t\t\t\t\t!ellipsis &&\n\t\t\t\t\t\t\t\t\thasWhiteSpace &&\n\t\t\t\t\t\t\t\t\t(words.length || rest.length)\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t// discard rotation when computing box\n\t\t\t\t\t\t\t\t\twrapper.rotation = 0; \n\t\t\t\t\t\t\t\t\tactualWidth = renderer.getSpanWidth(\n\t\t\t\t\t\t\t\t\t\twrapper,\n\t\t\t\t\t\t\t\t\t\ttspan\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\ttooLong = actualWidth > width;\n\n\t\t\t\t\t\t\t\t\t// For ellipsis, do a binary search for the \n\t\t\t\t\t\t\t\t\t// correct string length\n\t\t\t\t\t\t\t\t\tif (wasTooLong === undefined) {\n\t\t\t\t\t\t\t\t\t\twasTooLong = tooLong; // First time\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Looping down, this is the first word\n\t\t\t\t\t\t\t\t\t// sequence that is not too long, so we can\n\t\t\t\t\t\t\t\t\t// move on to build the next line.\n\t\t\t\t\t\t\t\t\tif (!tooLong || words.length === 1) {\n\t\t\t\t\t\t\t\t\t\twords = rest;\n\t\t\t\t\t\t\t\t\t\trest = [];\n\n\t\t\t\t\t\t\t\t\t\tif (words.length && !noWrap) {\n\t\t\t\t\t\t\t\t\t\t\ttspan = doc.createElementNS(\n\t\t\t\t\t\t\t\t\t\t\t\tSVG_NS,\n\t\t\t\t\t\t\t\t\t\t\t\t'tspan'\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\tattr(tspan, {\n\t\t\t\t\t\t\t\t\t\t\t\tdy: dy,\n\t\t\t\t\t\t\t\t\t\t\t\tx: parentX\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t\tif (styleAttribute) { // #390\n\t\t\t\t\t\t\t\t\t\t\t\tattr(\n\t\t\t\t\t\t\t\t\t\t\t\t\ttspan,\n\t\t\t\t\t\t\t\t\t\t\t\t\t'style',\n\t\t\t\t\t\t\t\t\t\t\t\t\tstyleAttribute\n\t\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\ttextNode.appendChild(tspan);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// a single word is pressing it out\n\t\t\t\t\t\t\t\t\t\tif (actualWidth > width) {\n\t\t\t\t\t\t\t\t\t\t\twidth = actualWidth;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else { // append to existing line tspan\n\t\t\t\t\t\t\t\t\t\ttspan.removeChild(tspan.firstChild);\n\t\t\t\t\t\t\t\t\t\trest.unshift(words.pop());\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (words.length) {\n\t\t\t\t\t\t\t\t\t\ttspan.appendChild(\n\t\t\t\t\t\t\t\t\t\t\tdoc.createTextNode(\n\t\t\t\t\t\t\t\t\t\t\t\twords.join(' ')\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(/- /g, '-')\n\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twrapper.rotation = rotation;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tspanNo++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// To avoid beginning lines that doesn't add to the textNode\n\t\t\t\t// (#6144)\n\t\t\t\tisSubsequentLine = (\n\t\t\t\t\tisSubsequentLine ||\n\t\t\t\t\ttextNode.childNodes.length\n\t\t\t\t);\n\t\t\t});\n\n\t\t\tif (wasTooLong) {\n\t\t\t\twrapper.attr(\n\t\t\t\t\t'title',\n\t\t\t\t\tunescapeEntities(wrapper.textStr, ['&lt;', '&gt;']) // #7179\n\t\t\t\t);\n\t\t\t}\n\t\t\tif (tempParent) {\n\t\t\t\ttempParent.removeChild(textNode);\n\t\t\t}\n\n\t\t\t// Apply the text outline\n\t\t\tif (textOutline && wrapper.applyTextOutline) {\n\t\t\t\twrapper.applyTextOutline(textOutline);\n\t\t\t}\n\t\t}\n\t},\n\n\n\n\t/*\n\tbreakText: function (wrapper, width) {\n\t\tvar bBox = wrapper.getBBox(),\n\t\t\tnode = wrapper.element,\n\t\t\tcharnum = node.textContent.length,\n\t\t\tstringWidth,\n\t\t\t// try this position first, based on average character width\n\t\t\tguessedLineCharLength = Math.round(width * charnum / bBox.width),\n\t\t\tpos = guessedLineCharLength,\n\t\t\tspans = [],\n\t\t\tincrement = 0,\n\t\t\tstartPos = 0,\n\t\t\tendPos,\n\t\t\tsafe = 0;\n\n\t\tif (bBox.width > width) {\n\t\t\twhile (startPos < charnum && safe < 100) {\n\n\t\t\t\twhile (endPos === undefined && safe < 100) {\n\t\t\t\t\tstringWidth = node.getSubStringLength(\n\t\t\t\t\t\tstartPos,\n\t\t\t\t\t\tpos - startPos\n\t\t\t\t\t);\n\n\t\t\t\t\tif (stringWidth <= width) {\n\t\t\t\t\t\tif (increment === -1) {\n\t\t\t\t\t\t\tendPos = pos;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tincrement = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (increment === 1) {\n\t\t\t\t\t\t\tendPos = pos - 1;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tincrement = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpos += increment;\n\t\t\t\t\tsafe++;\n\t\t\t\t}\n\n\t\t\t\tspans.push(\n\t\t\t\t\tnode.textContent.substr(startPos, endPos - startPos)\n\t\t\t\t);\n\n\t\t\t\tstartPos = endPos;\n\t\t\t\tpos = startPos + guessedLineCharLength;\n\t\t\t\tendPos = undefined;\t\t\t\n\t\t\t}\n\t\t}\n\n\t\treturn spans;\n\t},\n\t// */\n\n\t/**\n\t * Returns white for dark colors and black for bright colors.\n\t *\n\t * @param {ColorString} rgba - The color to get the contrast for.\n\t * @returns {string} The contrast color, either `#000000` or `#FFFFFF`.\n\t */\n\tgetContrast: function (rgba) {\n\t\trgba = color(rgba).rgba;\n\n\t\t// The threshold may be discussed. Here's a proposal for adding\n\t\t// different weight to the color channels (#6216)\n\t\t/*\n        rgba[0] *= 1; // red\n        rgba[1] *= 1.2; // green\n        rgba[2] *= 0.7; // blue\n        */\n\n\t\treturn rgba[0] + rgba[1] + rgba[2] > 2 * 255 ? '#000000' : '#FFFFFF';\n\t},\n\n\t/**\n\t * Create a button with preset states.\n\t * @param {string} text - The text or HTML to draw.\n\t * @param {number} x - The x position of the button's left side.\n\t * @param {number} y - The y position of the button's top side.\n\t * @param {Function} callback - The function to execute on button click or \n\t *    touch.\n\t * @param {SVGAttributes} [normalState] - SVG attributes for the normal\n\t *    state.\n\t * @param {SVGAttributes} [hoverState] - SVG attributes for the hover state.\n\t * @param {SVGAttributes} [pressedState] - SVG attributes for the pressed\n\t *    state.\n\t * @param {SVGAttributes} [disabledState] - SVG attributes for the disabled\n\t *    state.\n\t * @param {Symbol} [shape=rect] - The shape type.\n\t * @returns {SVGRenderer} The button element.\n\t */\n\tbutton: function (\n\t\ttext, \n\t\tx,\n\t\ty,\n\t\tcallback,\n\t\tnormalState,\n\t\thoverState,\n\t\tpressedState,\n\t\tdisabledState,\n\t\tshape\n\t) {\n\t\tvar label = this.label(\n\t\t\t\ttext,\n\t\t\t\tx,\n\t\t\t\ty,\n\t\t\t\tshape, \n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\tnull,\n\t\t\t\t'button'\n\t\t\t),\n\t\t\tcurState = 0;\n\n\t\t// Default, non-stylable attributes\n\t\tlabel.attr(merge({\n\t\t\t'padding': 8,\n\t\t\t'r': 2\n\t\t}, normalState));\n\n\t\t/*= if (build.classic) { =*/\n\t\t// Presentational\n\t\tvar normalStyle,\n\t\t\thoverStyle,\n\t\t\tpressedStyle,\n\t\t\tdisabledStyle;\n\n\t\t// Normal state - prepare the attributes\n\t\tnormalState = merge({\n\t\t\tfill: '${palette.neutralColor3}',\n\t\t\tstroke: '${palette.neutralColor20}',\n\t\t\t'stroke-width': 1,\n\t\t\tstyle: {\n\t\t\t\tcolor: '${palette.neutralColor80}',\n\t\t\t\tcursor: 'pointer',\n\t\t\t\tfontWeight: 'normal'\n\t\t\t}\n\t\t}, normalState);\n\t\tnormalStyle = normalState.style;\n\t\tdelete normalState.style;\n\n\t\t// Hover state\n\t\thoverState = merge(normalState, {\n\t\t\tfill: '${palette.neutralColor10}'\n\t\t}, hoverState);\n\t\thoverStyle = hoverState.style;\n\t\tdelete hoverState.style;\n\n\t\t// Pressed state\n\t\tpressedState = merge(normalState, {\n\t\t\tfill: '${palette.highlightColor10}',\n\t\t\tstyle: {\n\t\t\t\tcolor: '${palette.neutralColor100}',\n\t\t\t\tfontWeight: 'bold'\n\t\t\t}\n\t\t}, pressedState);\n\t\tpressedStyle = pressedState.style;\n\t\tdelete pressedState.style;\n\n\t\t// Disabled state\n\t\tdisabledState = merge(normalState, {\n\t\t\tstyle: {\n\t\t\t\tcolor: '${palette.neutralColor20}'\n\t\t\t}\n\t\t}, disabledState);\n\t\tdisabledStyle = disabledState.style;\n\t\tdelete disabledState.style;\n\t\t/*= } =*/\n\n\t\t// Add the events. IE9 and IE10 need mouseover and mouseout to funciton\n\t\t// (#667).\n\t\taddEvent(label.element, isMS ? 'mouseover' : 'mouseenter', function () {\n\t\t\tif (curState !== 3) {\n\t\t\t\tlabel.setState(1);\n\t\t\t}\n\t\t});\n\t\taddEvent(label.element, isMS ? 'mouseout' : 'mouseleave', function () {\n\t\t\tif (curState !== 3) {\n\t\t\t\tlabel.setState(curState);\n\t\t\t}\n\t\t});\n\n\t\tlabel.setState = function (state) {\n\t\t\t// Hover state is temporary, don't record it\n\t\t\tif (state !== 1) {\n\t\t\t\tlabel.state = curState = state;\n\t\t\t}\n\t\t\t// Update visuals\n\t\t\tlabel.removeClass(\n\t\t\t\t\t/highcharts-button-(normal|hover|pressed|disabled)/\n\t\t\t\t)\n\t\t\t\t.addClass(\n\t\t\t\t\t'highcharts-button-' +\n\t\t\t\t\t['normal', 'hover', 'pressed', 'disabled'][state || 0]\n\t\t\t\t);\n\t\t\t\n\t\t\t/*= if (build.classic) { =*/\n\t\t\tlabel.attr([\n\t\t\t\tnormalState,\n\t\t\t\thoverState,\n\t\t\t\tpressedState,\n\t\t\t\tdisabledState\n\t\t\t][state || 0])\n\t\t\t.css([\n\t\t\t\tnormalStyle,\n\t\t\t\thoverStyle,\n\t\t\t\tpressedStyle,\n\t\t\t\tdisabledStyle\n\t\t\t][state || 0]);\n\t\t\t/*= } =*/\n\t\t};\n\n\n\t\t/*= if (build.classic) { =*/\n\t\t// Presentational attributes\n\t\tlabel\n\t\t\t.attr(normalState)\n\t\t\t.css(extend({ cursor: 'default' }, normalStyle));\n\t\t/*= } =*/\n\n\t\treturn label\n\t\t\t.on('click', function (e) {\n\t\t\t\tif (curState !== 3) {\n\t\t\t\t\tcallback.call(label, e);\n\t\t\t\t}\n\t\t\t});\n\t},\n\n\t/**\n\t * Make a straight line crisper by not spilling out to neighbour pixels.\n\t * \n\t * @param {Array} points - The original points on the format\n\t *                       `['M', 0, 0, 'L', 100, 0]`.\n\t * @param {number} width - The width of the line.\n\t * @returns {Array} The original points array, but modified to render\n\t * crisply.\n\t */\n\tcrispLine: function (points, width) {\n\t\t// normalize to a crisp line\n\t\tif (points[1] === points[4]) {\n\t\t\t// Substract due to #1129. Now bottom and left axis gridlines behave\n\t\t\t// the same.\n\t\t\tpoints[1] = points[4] = Math.round(points[1]) - (width % 2 / 2);\n\t\t}\n\t\tif (points[2] === points[5]) {\n\t\t\tpoints[2] = points[5] = Math.round(points[2]) + (width % 2 / 2);\n\t\t}\n\t\treturn points;\n\t},\n\n\n\t/**\n\t * Draw a path, wraps the SVG `path` element.\n\t * \n\t * @param {Array} [path] An SVG path definition in array form.\n\t * \n\t * @example\n\t * var path = renderer.path(['M', 10, 10, 'L', 30, 30, 'z'])\n\t *     .attr({ stroke: '#ff00ff' })\n\t *     .add();\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-path-on-chart/\n\t *         Draw a path in a chart\n\t * @sample highcharts/members/renderer-path/\n\t *         Draw a path independent from a chart\n\t *\n\t *//**\n\t * Draw a path, wraps the SVG `path` element.\n\t * \n\t * @param {SVGAttributes} [attribs] The initial attributes.\n\t * @returns {SVGElement} The generated wrapper element.\n\t */\n\tpath: function (path) {\n\t\tvar attribs = {\n\t\t\t/*= if (build.classic) { =*/\n\t\t\tfill: 'none'\n\t\t\t/*= } =*/\n\t\t};\n\t\tif (isArray(path)) {\n\t\t\tattribs.d = path;\n\t\t} else if (isObject(path)) { // attributes\n\t\t\textend(attribs, path);\n\t\t}\n\t\treturn this.createElement('path').attr(attribs);\n\t},\n\n\t/**\n\t * Draw a circle, wraps the SVG `circle` element.\n\t * \n\t * @param {number} [x] The center x position.\n\t * @param {number} [y] The center y position.\n\t * @param {number} [r] The radius.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-circle/ Drawing a circle\n\t *//**\n\t * Draw a circle, wraps the SVG `circle` element.\n\t * \n\t * @param {SVGAttributes} [attribs] The initial attributes.\n\t * @returns {SVGElement} The generated wrapper element.\n\t */\n\tcircle: function (x, y, r) {\n\t\tvar attribs = isObject(x) ? x : { x: x, y: y, r: r },\n\t\t\twrapper = this.createElement('circle');\n\n\t\t// Setting x or y translates to cx and cy\n\t\twrapper.xSetter = wrapper.ySetter = function (value, key, element) {\n\t\t\telement.setAttribute('c' + key, value);\n\t\t};\n\n\t\treturn wrapper.attr(attribs);\n\t},\n\n\t/**\n\t * Draw and return an arc.\n\t * @param {number} [x=0] Center X position.\n\t * @param {number} [y=0] Center Y position.\n\t * @param {number} [r=0] The outer radius of the arc.\n\t * @param {number} [innerR=0] Inner radius like used in donut charts.\n\t * @param {number} [start=0] The starting angle of the arc in radians, where\n\t *    0 is to the right and `-Math.PI/2` is up.\n\t * @param {number} [end=0] The ending angle of the arc in radians, where 0\n\t *    is to the right and `-Math.PI/2` is up.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-arc/\n\t *         Drawing an arc\n\t *//**\n\t * Draw and return an arc. Overloaded function that takes arguments object.\n\t * @param {SVGAttributes} attribs Initial SVG attributes.\n\t * @returns {SVGElement} The generated wrapper element.\n\t */\n\tarc: function (x, y, r, innerR, start, end) {\n\t\tvar arc,\n\t\t\toptions;\n\n\t\tif (isObject(x)) {\n\t\t\toptions = x;\n\t\t\ty = options.y;\n\t\t\tr = options.r;\n\t\t\tinnerR = options.innerR;\n\t\t\tstart = options.start;\n\t\t\tend = options.end;\n\t\t\tx = options.x;\n\t\t} else {\n\t\t\toptions = {\n\t\t\t\tinnerR: innerR,\n\t\t\t\tstart: start,\n\t\t\t\tend: end\n\t\t\t};\n\t\t}\n\n\t\t// Arcs are defined as symbols for the ability to set\n\t\t// attributes in attr and animate\n\t\tarc = this.symbol('arc', x, y, r, r, options);\n\t\tarc.r = r; // #959\n\t\treturn arc;\n\t},\n\n\t/**\n\t * Draw and return a rectangle.\n\t * @param {number} [x] Left position.\n\t * @param {number} [y] Top position.\n\t * @param {number} [width] Width of the rectangle.\n\t * @param {number} [height] Height of the rectangle.\n\t * @param {number} [r] Border corner radius.\n\t * @param {number} [strokeWidth] A stroke width can be supplied to allow\n\t *    crisp drawing.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *//**\n\t * Draw and return a rectangle.\n\t * @param  {SVGAttributes} [attributes]\n\t *         General SVG attributes for the rectangle.\n\t * @return {SVGElement}\n\t *         The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-rect-on-chart/\n\t *         Draw a rectangle in a chart\n\t * @sample highcharts/members/renderer-rect/\n\t *         Draw a rectangle independent from a chart\n\t */\n\trect: function (x, y, width, height, r, strokeWidth) {\n\n\t\tr = isObject(x) ? x.r : r;\n\n\t\tvar wrapper = this.createElement('rect'),\n\t\t\tattribs = isObject(x) ? x : x === undefined ? {} : {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: Math.max(width, 0),\n\t\t\t\theight: Math.max(height, 0)\n\t\t\t};\n\n\t\t/*= if (build.classic) { =*/\n\t\tif (strokeWidth !== undefined) {\n\t\t\tattribs.strokeWidth = strokeWidth;\n\t\t\tattribs = wrapper.crisp(attribs);\n\t\t}\n\t\tattribs.fill = 'none';\n\t\t/*= } =*/\n\n\t\tif (r) {\n\t\t\tattribs.r = r;\n\t\t}\n\n\t\twrapper.rSetter = function (value, key, element) {\n\t\t\tattr(element, {\n\t\t\t\trx: value,\n\t\t\t\try: value\n\t\t\t});\n\t\t};\n\n\t\treturn wrapper.attr(attribs);\n\t},\n\n\t/**\n\t * Resize the {@link SVGRenderer#box} and re-align all aligned child\n\t * elements.\n\t * @param  {number} width\n\t *         The new pixel width.\n\t * @param  {number} height\n\t *         The new pixel height.\n\t * @param  {Boolean|AnimationOptions} [animate=true]\n\t *         Whether and how to animate.\n\t */\n\tsetSize: function (width, height, animate) {\n\t\tvar renderer = this,\n\t\t\talignedObjects = renderer.alignedObjects,\n\t\t\ti = alignedObjects.length;\n\n\t\trenderer.width = width;\n\t\trenderer.height = height;\n\n\t\trenderer.boxWrapper.animate({\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t}, {\n\t\t\tstep: function () {\n\t\t\t\tthis.attr({\n\t\t\t\t\tviewBox: '0 0 ' + this.attr('width') + ' ' +\n\t\t\t\t\t\tthis.attr('height')\n\t\t\t\t});\n\t\t\t},\n\t\t\tduration: pick(animate, true) ? undefined : 0\n\t\t});\n\n\t\twhile (i--) {\n\t\t\talignedObjects[i].align();\n\t\t}\n\t},\n\n\t/**\n\t * Create and return an svg group element. Child\n\t * {@link Highcharts.SVGElement} objects are added to the group by using the\n\t * group as the first parameter\n\t * in {@link Highcharts.SVGElement#add|add()}.\n\t * \n\t * @param {string} [name] The group will be given a class name of\n\t * `highcharts-{name}`. This can be used for styling and scripting.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-g/\n\t *         Show and hide grouped objects\n\t */\n\tg: function (name) {\n\t\tvar elem = this.createElement('g');\n\t\treturn name ? elem.attr({ 'class': 'highcharts-' + name }) : elem;\n\t},\n\n\t/**\n\t * Display an image.\n\t * @param {string} src The image source.\n\t * @param {number} [x] The X position.\n\t * @param {number} [y] The Y position.\n\t * @param {number} [width] The image width. If omitted, it defaults to the \n\t *    image file width.\n\t * @param {number} [height] The image height. If omitted it defaults to the\n\t *    image file height.\n\t * @returns {SVGElement} The generated wrapper element.\n\t *\n\t * @sample highcharts/members/renderer-image-on-chart/\n\t *         Add an image in a chart\n\t * @sample highcharts/members/renderer-image/\n\t *         Add an image independent of a chart\n\t */\n\timage: function (src, x, y, width, height) {\n\t\tvar attribs = {\n\t\t\t\tpreserveAspectRatio: 'none'\n\t\t\t},\n\t\t\telemWrapper;\n\n\t\t// optional properties\n\t\tif (arguments.length > 1) {\n\t\t\textend(attribs, {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t}\n\n\t\telemWrapper = this.createElement('image').attr(attribs);\n\n\t\t// set the href in the xlink namespace\n\t\tif (elemWrapper.element.setAttributeNS) {\n\t\t\telemWrapper.element.setAttributeNS('http://www.w3.org/1999/xlink',\n\t\t\t\t'href', src);\n\t\t} else {\n\t\t\t// could be exporting in IE\n\t\t\t// using href throws \"not supported\" in ie7 and under, requries\n\t\t\t// regex shim to fix later\n\t\t\telemWrapper.element.setAttribute('hc-svg-href', src);\n\t\t}\n\t\treturn elemWrapper;\n\t},\n\n\t/**\n\t * Draw a symbol out of pre-defined shape paths from\n\t * {@link SVGRenderer#symbols}.\n\t * It is used in Highcharts for point makers, which cake a `symbol` option,\n\t * and label and button backgrounds like in the tooltip and stock flags.\n\t *\n\t * @param {Symbol} symbol - The symbol name.\n\t * @param {number} x - The X coordinate for the top left position.\n\t * @param {number} y - The Y coordinate for the top left position.\n\t * @param {number} width - The pixel width.\n\t * @param {number} height - The pixel height.\n\t * @param {Object} [options] - Additional options, depending on the actual\n\t *    symbol drawn. \n\t * @param {number} [options.anchorX] - The anchor X position for the\n\t *    `callout` symbol. This is where the chevron points to.\n\t * @param {number} [options.anchorY] - The anchor Y position for the\n\t *    `callout` symbol. This is where the chevron points to.\n\t * @param {number} [options.end] - The end angle of an `arc` symbol.\n\t * @param {boolean} [options.open] - Whether to draw `arc` symbol open or\n\t *    closed.\n\t * @param {number} [options.r] - The radius of an `arc` symbol, or the\n\t *    border radius for the `callout` symbol.\n\t * @param {number} [options.start] - The start angle of an `arc` symbol.\n\t */\n\tsymbol: function (symbol, x, y, width, height, options) {\n\n\t\tvar ren = this,\n\t\t\tobj,\n\t\t\timageRegex = /^url\\((.*?)\\)$/,\n\t\t\tisImage = imageRegex.test(symbol),\n\t\t\tsym = !isImage && (this.symbols[symbol] ? symbol : 'circle'),\n\t\t\t\n\n\t\t\t// get the symbol definition function\n\t\t\tsymbolFn = sym && this.symbols[sym],\n\n\t\t\t// check if there's a path defined for this symbol\n\t\t\tpath = defined(x) && symbolFn && symbolFn.call(\n\t\t\t\tthis.symbols,\n\t\t\t\tMath.round(x),\n\t\t\t\tMath.round(y),\n\t\t\t\twidth,\n\t\t\t\theight,\n\t\t\t\toptions\n\t\t\t),\n\t\t\timageSrc,\n\t\t\tcenterImage;\n\n\t\tif (symbolFn) {\n\t\t\tobj = this.path(path);\n\n\t\t\t/*= if (build.classic) { =*/\n\t\t\tobj.attr('fill', 'none');\n\t\t\t/*= } =*/\n\t\t\t\n\t\t\t// expando properties for use in animate and attr\n\t\t\textend(obj, {\n\t\t\t\tsymbolName: sym,\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\twidth: width,\n\t\t\t\theight: height\n\t\t\t});\n\t\t\tif (options) {\n\t\t\t\textend(obj, options);\n\t\t\t}\n\n\n\t\t// Image symbols\n\t\t} else if (isImage) {\n\n\t\t\t\n\t\t\timageSrc = symbol.match(imageRegex)[1];\n\n\t\t\t// Create the image synchronously, add attribs async\n\t\t\tobj = this.image(imageSrc);\n\n\t\t\t// The image width is not always the same as the symbol width. The\n\t\t\t// image may be centered within the symbol, as is the case when\n\t\t\t// image shapes are used as label backgrounds, for example in flags.\n\t\t\tobj.imgwidth = pick(\n\t\t\t\tsymbolSizes[imageSrc] && symbolSizes[imageSrc].width,\n\t\t\t\toptions && options.width\n\t\t\t);\n\t\t\tobj.imgheight = pick(\n\t\t\t\tsymbolSizes[imageSrc] && symbolSizes[imageSrc].height,\n\t\t\t\toptions && options.height\n\t\t\t);\n\t\t\t/**\n\t\t\t * Set the size and position\n\t\t\t */\n\t\t\tcenterImage = function () {\n\t\t\t\tobj.attr({\n\t\t\t\t\twidth: obj.width,\n\t\t\t\t\theight: obj.height\n\t\t\t\t});\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * Width and height setters that take both the image's physical size\n\t\t\t * and the label size into consideration, and translates the image\n\t\t\t * to center within the label.\n\t\t\t */\n\t\t\teach(['width', 'height'], function (key) {\n\t\t\t\tobj[key + 'Setter'] = function (value, key) {\n\t\t\t\t\tvar attribs = {},\n\t\t\t\t\t\timgSize = this['img' + key],\n\t\t\t\t\t\ttrans = key === 'width' ? 'translateX' : 'translateY';\n\t\t\t\t\tthis[key] = value;\n\t\t\t\t\tif (defined(imgSize)) {\n\t\t\t\t\t\tif (this.element) {\n\t\t\t\t\t\t\tthis.element.setAttribute(key, imgSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!this.alignByTranslate) {\n\t\t\t\t\t\t\tattribs[trans] = ((this[key] || 0) - imgSize) / 2;\n\t\t\t\t\t\t\tthis.attr(attribs);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t\t\n\n\t\t\tif (defined(x)) {\n\t\t\t\tobj.attr({\n\t\t\t\t\tx: x,\n\t\t\t\t\ty: y\n\t\t\t\t});\n\t\t\t}\n\t\t\tobj.isImg = true;\n\n\t\t\tif (defined(obj.imgwidth) && defined(obj.imgheight)) {\n\t\t\t\tcenterImage();\n\t\t\t} else {\n\t\t\t\t// Initialize image to be 0 size so export will still function\n\t\t\t\t// if there's no cached sizes.\n\t\t\t\tobj.attr({ width: 0, height: 0 });\n\n\t\t\t\t// Create a dummy JavaScript image to get the width and height. \n\t\t\t\tcreateElement('img', {\n\t\t\t\t\tonload: function () {\n\n\t\t\t\t\t\tvar chart = charts[ren.chartIndex];\n\n\t\t\t\t\t\t// Special case for SVGs on IE11, the width is not\n\t\t\t\t\t\t// accessible until the image is part of the DOM\n\t\t\t\t\t\t// (#2854).\n\t\t\t\t\t\tif (this.width === 0) {\n\t\t\t\t\t\t\tcss(this, {\n\t\t\t\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\t\t\t\ttop: '-999em'\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tdoc.body.appendChild(this);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Center the image\n\t\t\t\t\t\tsymbolSizes[imageSrc] = { // Cache for next\t\n\t\t\t\t\t\t\twidth: this.width,\n\t\t\t\t\t\t\theight: this.height\n\t\t\t\t\t\t};\n\t\t\t\t\t\tobj.imgwidth = this.width;\n\t\t\t\t\t\tobj.imgheight = this.height;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (obj.element) {\n\t\t\t\t\t\t\tcenterImage();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Clean up after #2854 workaround.\n\t\t\t\t\t\tif (this.parentNode) {\n\t\t\t\t\t\t\tthis.parentNode.removeChild(this);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Fire the load event when all external images are\n\t\t\t\t\t\t// loaded\n\t\t\t\t\t\tren.imgCount--;\n\t\t\t\t\t\tif (!ren.imgCount && chart && chart.onload) {\n\t\t\t\t\t\t\tchart.onload();\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\tsrc: imageSrc\n\t\t\t\t});\n\t\t\t\tthis.imgCount++;\n\t\t\t}\n\t\t}\n\n\t\treturn obj;\n\t},\n\n\t/**\n\t * @typedef {string} Symbol\n\t * \n\t * Can be one of `arc`, `callout`, `circle`, `diamond`, `square`,\n\t * `triangle`, `triangle-down`. Symbols are used internally for point\n\t * markers, button and label borders and backgrounds, or custom shapes.\n\t * Extendable by adding to {@link SVGRenderer#symbols}.\n\t */\n\t/**\n\t * An extendable collection of functions for defining symbol paths.\n\t */\n\tsymbols: {\n\t\t'circle': function (x, y, w, h) {\n\t\t\t// Return a full arc\n\t\t\treturn this.arc(x + w / 2, y + h / 2, w / 2, h / 2, {\n\t\t\t\tstart: 0,\n\t\t\t\tend: Math.PI * 2,\n\t\t\t\topen: false\n\t\t\t});\n\t\t},\n\n\t\t'square': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x, y,\n\t\t\t\t'L', x + w, y,\n\t\t\t\tx + w, y + h,\n\t\t\t\tx, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\n\t\t'triangle': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x + w / 2, y,\n\t\t\t\t'L', x + w, y + h,\n\t\t\t\tx, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\n\t\t'triangle-down': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x, y,\n\t\t\t\t'L', x + w, y,\n\t\t\t\tx + w / 2, y + h,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\t\t'diamond': function (x, y, w, h) {\n\t\t\treturn [\n\t\t\t\t'M', x + w / 2, y,\n\t\t\t\t'L', x + w, y + h / 2,\n\t\t\t\tx + w / 2, y + h,\n\t\t\t\tx, y + h / 2,\n\t\t\t\t'Z'\n\t\t\t];\n\t\t},\n\t\t'arc': function (x, y, w, h, options) {\n\t\t\tvar start = options.start,\n\t\t\t\trx = options.r || w,\n\t\t\t\try = options.r || h || w,\n\t\t\t\tproximity = 0.001,\n\t\t\t\tfullCircle = \n\t\t\t\t\tMath.abs(options.end - options.start - 2 * Math.PI) <\n\t\t\t\t\tproximity,\n\t\t\t\t// Substract a small number to prevent cos and sin of start and\n\t\t\t\t// end from becoming equal on 360 arcs (related: #1561)\n\t\t\t\tend = options.end - proximity, \n\t\t\t\tinnerRadius = options.innerR,\n\t\t\t\topen = pick(options.open, fullCircle),\n\t\t\t\tcosStart = Math.cos(start),\n\t\t\t\tsinStart = Math.sin(start),\n\t\t\t\tcosEnd = Math.cos(end),\n\t\t\t\tsinEnd = Math.sin(end),\n\t\t\t\t// Proximity takes care of rounding errors around PI (#6971)\n\t\t\t\tlongArc = options.end - start - Math.PI < proximity ? 0 : 1,\n\t\t\t\tarc;\n\n\t\t\tarc = [\n\t\t\t\t'M',\n\t\t\t\tx + rx * cosStart,\n\t\t\t\ty + ry * sinStart,\n\t\t\t\t'A', // arcTo\n\t\t\t\trx, // x radius\n\t\t\t\try, // y radius\n\t\t\t\t0, // slanting\n\t\t\t\tlongArc, // long or short arc\n\t\t\t\t1, // clockwise\n\t\t\t\tx + rx * cosEnd,\n\t\t\t\ty + ry * sinEnd\n\t\t\t];\n\n\t\t\tif (defined(innerRadius)) {\n\t\t\t\tarc.push(\n\t\t\t\t\topen ? 'M' : 'L',\n\t\t\t\t\tx + innerRadius * cosEnd,\n\t\t\t\t\ty + innerRadius * sinEnd,\n\t\t\t\t\t'A', // arcTo\n\t\t\t\t\tinnerRadius, // x radius\n\t\t\t\t\tinnerRadius, // y radius\n\t\t\t\t\t0, // slanting\n\t\t\t\t\tlongArc, // long or short arc\n\t\t\t\t\t0, // clockwise\n\t\t\t\t\tx + innerRadius * cosStart,\n\t\t\t\t\ty + innerRadius * sinStart\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tarc.push(open ? '' : 'Z'); // close\n\t\t\treturn arc;\n\t\t},\n\n\t\t/**\n\t\t * Callout shape used for default tooltips, also used for rounded\n\t\t * rectangles in VML\n\t\t */\n\t\tcallout: function (x, y, w, h, options) {\n\t\t\tvar arrowLength = 6,\n\t\t\t\thalfDistance = 6,\n\t\t\t\tr = Math.min((options && options.r) || 0, w, h),\n\t\t\t\tsafeDistance = r + halfDistance,\n\t\t\t\tanchorX = options && options.anchorX,\n\t\t\t\tanchorY = options && options.anchorY,\n\t\t\t\tpath;\n\n\t\t\tpath = [\n\t\t\t\t'M', x + r, y,\n\t\t\t\t'L', x + w - r, y, // top side\n\t\t\t\t'C', x + w, y, x + w, y, x + w, y + r, // top-right corner\n\t\t\t\t'L', x + w, y + h - r, // right side\n\t\t\t\t'C', x + w, y + h, x + w, y + h, x + w - r, y + h, // bottom-rgt\n\t\t\t\t'L', x + r, y + h, // bottom side\n\t\t\t\t'C', x, y + h, x, y + h, x, y + h - r, // bottom-left corner\n\t\t\t\t'L', x, y + r, // left side\n\t\t\t\t'C', x, y, x, y, x + r, y // top-left corner\n\t\t\t];\n\n\t\t\t// Anchor on right side\n\t\t\tif (anchorX && anchorX > w) {\n\n\t\t\t\t// Chevron\n\t\t\t\tif (\n\t\t\t\t\tanchorY > y + safeDistance &&\n\t\t\t\t\tanchorY < y + h - safeDistance\n\t\t\t\t) {\n\t\t\t\t\tpath.splice(13, 3,\n\t\t\t\t\t\t'L', x + w, anchorY - halfDistance,\n\t\t\t\t\t\tx + w + arrowLength, anchorY,\n\t\t\t\t\t\tx + w, anchorY + halfDistance,\n\t\t\t\t\t\tx + w, y + h - r\n\t\t\t\t\t);\n\n\t\t\t\t// Simple connector\n\t\t\t\t} else {\n\t\t\t\t\tpath.splice(13, 3,\n\t\t\t\t\t\t'L', x + w, h / 2,\n\t\t\t\t\t\tanchorX, anchorY,\n\t\t\t\t\t\tx + w, h / 2,\n\t\t\t\t\t\tx + w, y + h - r\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t// Anchor on left side\n\t\t\t} else if (anchorX && anchorX < 0) {\n\n\t\t\t\t// Chevron\n\t\t\t\tif (\n\t\t\t\t\tanchorY > y + safeDistance &&\n\t\t\t\t\tanchorY < y + h - safeDistance\n\t\t\t\t) {\n\t\t\t\t\tpath.splice(33, 3,\n\t\t\t\t\t\t'L', x, anchorY + halfDistance,\n\t\t\t\t\t\tx - arrowLength, anchorY,\n\t\t\t\t\t\tx, anchorY - halfDistance,\n\t\t\t\t\t\tx, y + r\n\t\t\t\t\t);\n\n\t\t\t\t// Simple connector\n\t\t\t\t} else {\n\t\t\t\t\tpath.splice(33, 3,\n\t\t\t\t\t\t'L', x, h / 2,\n\t\t\t\t\t\tanchorX, anchorY,\n\t\t\t\t\t\tx, h / 2,\n\t\t\t\t\t\tx, y + r\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if ( // replace bottom\n\t\t\t\tanchorY &&\n\t\t\t\tanchorY > h &&\n\t\t\t\tanchorX > x + safeDistance &&\n\t\t\t\tanchorX < x + w - safeDistance\n\t\t\t) { \n\t\t\t\tpath.splice(23, 3,\n\t\t\t\t\t'L', anchorX + halfDistance, y + h,\n\t\t\t\t\tanchorX, y + h + arrowLength,\n\t\t\t\t\tanchorX - halfDistance, y + h,\n\t\t\t\t\tx + r, y + h\n\t\t\t\t\t);\n\n\t\t\t} else if ( // replace top\n\t\t\t\tanchorY &&\n\t\t\t\tanchorY < 0 &&\n\t\t\t\tanchorX > x + safeDistance &&\n\t\t\t\tanchorX < x + w - safeDistance\n\t\t\t) {\n\t\t\t\tpath.splice(3, 3,\n\t\t\t\t\t'L', anchorX - halfDistance, y,\n\t\t\t\t\tanchorX, y - arrowLength,\n\t\t\t\t\tanchorX + halfDistance, y,\n\t\t\t\t\tw - r, y\n\t\t\t\t);\n\t\t\t}\n\t\t\t\n\t\t\treturn path;\n\t\t}\n\t},\n\n\t/**\n\t * @typedef {SVGElement} ClipRect - A clipping rectangle that can be applied\n\t * to one or more {@link SVGElement} instances. It is instanciated with the\n\t * {@link SVGRenderer#clipRect} function and applied with the {@link \n\t * SVGElement#clip} function.\n\t *\n\t * @example\n\t * var circle = renderer.circle(100, 100, 100)\n\t *     .attr({ fill: 'red' })\n\t *     .add();\n\t * var clipRect = renderer.clipRect(100, 100, 100, 100);\n\t *\n\t * // Leave only the lower right quarter visible\n\t * circle.clip(clipRect);\n\t */\n\t/**\n\t * Define a clipping rectangle. The clipping rectangle is later applied\n\t * to {@link SVGElement} objects through the {@link SVGElement#clip}\n\t * function.\n\t * \n\t * @param {String} id\n\t * @param {number} x\n\t * @param {number} y\n\t * @param {number} width\n\t * @param {number} height\n\t * @returns {ClipRect} A clipping rectangle.\n\t *\n\t * @example\n\t * var circle = renderer.circle(100, 100, 100)\n\t *     .attr({ fill: 'red' })\n\t *     .add();\n\t * var clipRect = renderer.clipRect(100, 100, 100, 100);\n\t *\n\t * // Leave only the lower right quarter visible\n\t * circle.clip(clipRect);\n\t */\n\tclipRect: function (x, y, width, height) {\n\t\tvar wrapper,\n\t\t\tid = H.uniqueKey(),\n\n\t\t\tclipPath = this.createElement('clipPath').attr({\n\t\t\t\tid: id\n\t\t\t}).add(this.defs);\n\n\t\twrapper = this.rect(x, y, width, height, 0).add(clipPath);\n\t\twrapper.id = id;\n\t\twrapper.clipPath = clipPath;\n\t\twrapper.count = 0;\n\n\t\treturn wrapper;\n\t},\n\n\n\n\n\n\t/**\n\t * Draw text. The text can contain a subset of HTML, like spans and anchors\n\t * and some basic text styling of these. For more advanced features like\n\t * border and background, use {@link Highcharts.SVGRenderer#label} instead.\n\t * To update the text after render, run `text.attr({ text: 'New text' })`.\n\t * @param  {String} str\n\t *         The text of (subset) HTML to draw.\n\t * @param  {number} x\n\t *         The x position of the text's lower left corner.\n\t * @param  {number} y\n\t *         The y position of the text's lower left corner.\n\t * @param  {Boolean} [useHTML=false]\n\t *         Use HTML to render the text.\n\t *\n\t * @return {SVGElement} The text object.\n\t *\n\t * @sample highcharts/members/renderer-text-on-chart/\n\t *         Annotate the chart freely\n\t * @sample highcharts/members/renderer-on-chart/\n\t *         Annotate with a border and in response to the data\n\t * @sample highcharts/members/renderer-text/\n\t *         Formatted text\n\t */\n\ttext: function (str, x, y, useHTML) {\n\n\t\t// declare variables\n\t\tvar renderer = this,\n\t\t\twrapper,\n\t\t\tattribs = {};\n\n\t\tif (useHTML && (renderer.allowHTML || !renderer.forExport)) {\n\t\t\treturn renderer.html(str, x, y);\n\t\t}\n\n\t\tattribs.x = Math.round(x || 0); // X always needed for line-wrap logic\n\t\tif (y) {\n\t\t\tattribs.y = Math.round(y);\n\t\t}\n\t\tif (str || str === 0) {\n\t\t\tattribs.text = str;\n\t\t}\n\n\t\twrapper = renderer.createElement('text')\n\t\t\t.attr(attribs);\n\n\t\tif (!useHTML) {\n\t\t\twrapper.xSetter = function (value, key, element) {\n\t\t\t\tvar tspans = element.getElementsByTagName('tspan'),\n\t\t\t\t\ttspan,\n\t\t\t\t\tparentVal = element.getAttribute(key),\n\t\t\t\t\ti;\n\t\t\t\tfor (i = 0; i < tspans.length; i++) {\n\t\t\t\t\ttspan = tspans[i];\n\t\t\t\t\t// If the x values are equal, the tspan represents a\n\t\t\t\t\t// linebreak\n\t\t\t\t\tif (tspan.getAttribute(key) === parentVal) {\n\t\t\t\t\t\ttspan.setAttribute(key, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telement.setAttribute(key, value);\n\t\t\t};\n\t\t}\n\n\t\treturn wrapper;\n\t},\n\n\t/**\n\t * Utility to return the baseline offset and total line height from the font\n\t * size.\n\t *\n\t * @param {?string} fontSize The current font size to inspect. If not given,\n\t *   the font size will be found from the DOM element.\n\t * @param {SVGElement|SVGDOMElement} [elem] The element to inspect for a\n\t *   current font size.\n\t * @returns {Object} An object containing `h`: the line height, `b`: the\n\t * baseline relative to the top of the box, and `f`: the font size.\n\t */\n\tfontMetrics: function (fontSize, elem) {\n\t\tvar lineHeight,\n\t\t\tbaseline;\n\n\t\t/*= if (build.classic) { =*/\n\t\tfontSize = fontSize ||\n\t\t\t// When the elem is a DOM element (#5932)\n\t\t\t(elem && elem.style && elem.style.fontSize) ||\n\t\t\t// Fall back on the renderer style default\n\t\t\t(this.style && this.style.fontSize);\n\n\t\t/*= } else { =*/\n\t\tfontSize = elem && SVGElement.prototype.getStyle.call(\n\t\t\telem,\n\t\t\t'font-size'\n\t\t);\n\t\t/*= } =*/\n\n\t\t// Handle different units\n\t\tif (/px/.test(fontSize)) {\n\t\t\tfontSize = pInt(fontSize);\n\t\t} else if (/em/.test(fontSize)) {\n\t\t\t// The em unit depends on parent items\n\t\t\tfontSize = parseFloat(fontSize) *\n\t\t\t\t(elem ? this.fontMetrics(null, elem.parentNode).f : 16);\n\t\t} else {\n\t\t\tfontSize = 12;\n\t\t}\n\n\t\t// Empirical values found by comparing font size and bounding box\n\t\t// height. Applies to the default font family.\n\t\t// http://jsfiddle.net/highcharts/7xvn7/\n\t\tlineHeight = fontSize < 24 ? fontSize + 3 : Math.round(fontSize * 1.2);\n\t\tbaseline = Math.round(lineHeight * 0.8);\n\n\t\treturn {\n\t\t\th: lineHeight,\n\t\t\tb: baseline,\n\t\t\tf: fontSize\n\t\t};\n\t},\n\n\t/**\n\t * Correct X and Y positioning of a label for rotation (#1764).\n\t *\n\t * @private\n\t */\n\trotCorr: function (baseline, rotation, alterY) {\n\t\tvar y = baseline;\n\t\tif (rotation && alterY) {\n\t\t\ty = Math.max(y * Math.cos(rotation * deg2rad), 4);\n\t\t}\n\t\treturn {\n\t\t\tx: (-baseline / 3) * Math.sin(rotation * deg2rad),\n\t\t\ty: y\n\t\t};\n\t},\n\n\t/**\n\t * Draw a label, which is an extended text element with support for border\n\t * and background. Highcharts creates a `g` element with a text and a `path`\n\t * or `rect` inside, to make it behave somewhat like a HTML div. Border and\n\t * background are set through `stroke`, `stroke-width` and `fill` attributes\n\t * using the {@link Highcharts.SVGElement#attr|attr} method. To update the\n\t * text after render, run `label.attr({ text: 'New text' })`.\n\t * \n\t * @param  {string} str\n\t *         The initial text string or (subset) HTML to render.\n\t * @param  {number} x\n\t *         The x position of the label's left side.\n\t * @param  {number} y\n\t *         The y position of the label's top side or baseline, depending on\n\t *         the `baseline` parameter.\n\t * @param  {String} shape\n\t *         The shape of the label's border/background, if any. Defaults to\n\t *         `rect`. Other possible values are `callout` or other shapes\n\t *         defined in {@link Highcharts.SVGRenderer#symbols}.\n\t * @param  {number} anchorX\n\t *         In case the `shape` has a pointer, like a flag, this is the\n\t *         coordinates it should be pinned to.\n\t * @param  {number} anchorY\n\t *         In case the `shape` has a pointer, like a flag, this is the\n\t *         coordinates it should be pinned to.\n\t * @param  {Boolean} baseline\n\t *         Whether to position the label relative to the text baseline,\n\t *\t       like {@link Highcharts.SVGRenderer#text|renderer.text}, or to the\n\t *\t       upper border of the rectangle.\n\t * @param  {String} className\n\t *         Class name for the group.\n\t *\n\t * @return {SVGElement}\n\t *         The generated label.\n\t *\n\t * @sample highcharts/members/renderer-label-on-chart/\n\t *         A label on the chart\n\t */\n\tlabel: function (\n\t\tstr,\n\t\tx,\n\t\ty,\n\t\tshape,\n\t\tanchorX,\n\t\tanchorY,\n\t\tuseHTML,\n\t\tbaseline,\n\t\tclassName\n\t) {\n\n\t\tvar renderer = this,\n\t\t\twrapper = renderer.g(className !== 'button' && 'label'),\n\t\t\ttext = wrapper.text = renderer.text('', 0, 0, useHTML)\n\t\t\t\t.attr({\n\t\t\t\t\tzIndex: 1\n\t\t\t\t}),\n\t\t\tbox,\n\t\t\tbBox,\n\t\t\talignFactor = 0,\n\t\t\tpadding = 3,\n\t\t\tpaddingLeft = 0,\n\t\t\twidth,\n\t\t\theight,\n\t\t\twrapperX,\n\t\t\twrapperY,\n\t\t\ttextAlign,\n\t\t\tdeferredAttr = {},\n\t\t\tstrokeWidth,\n\t\t\tbaselineOffset,\n\t\t\thasBGImage = /^url\\((.*?)\\)$/.test(shape),\n\t\t\tneedsBox = hasBGImage,\n\t\t\tgetCrispAdjust,\n\t\t\tupdateBoxSize,\n\t\t\tupdateTextPadding,\n\t\t\tboxAttr;\n\n\t\tif (className) {\n\t\t\twrapper.addClass('highcharts-' + className);\n\t\t}\n\n\t\t/*= if (!build.classic) { =*/\n\t\tneedsBox = true; // for styling\n\t\tgetCrispAdjust = function () {\n\t\t\treturn box.strokeWidth() % 2 / 2;\n\t\t};\n\t\t/*= } else { =*/\n\t\tneedsBox = hasBGImage;\n\t\tgetCrispAdjust = function () {\n\t\t\treturn (strokeWidth || 0) % 2 / 2;\n\t\t};\n\n\t\t/*= } =*/\n\n\t\t/**\n\t\t * This function runs after the label is added to the DOM (when the\n\t\t * bounding box is available), and after the text of the label is\n\t\t * updated to detect the new bounding box and reflect it in the border\n\t\t * box.\n\t\t */\n\t\tupdateBoxSize = function () {\n\t\t\tvar style = text.element.style,\n\t\t\t\tcrispAdjust,\n\t\t\t\tattribs = {};\n\n\t\t\tbBox = (\n\t\t\t\t(width === undefined || height === undefined || textAlign) &&\n\t\t\t\tdefined(text.textStr) &&\n\t\t\t\ttext.getBBox()\n\t\t\t); // #3295 && 3514 box failure when string equals 0\n\t\t\twrapper.width = (\n\t\t\t\t(width || bBox.width || 0) +\n\t\t\t\t2 * padding +\n\t\t\t\tpaddingLeft\n\t\t\t);\n\t\t\twrapper.height = (height || bBox.height || 0) + 2 * padding;\n\n\t\t\t// Update the label-scoped y offset\n\t\t\tbaselineOffset = padding +\n\t\t\t\trenderer.fontMetrics(style && style.fontSize, text).b;\n\n\n\t\t\tif (needsBox) {\n\n\t\t\t\t// Create the border box if it is not already present\n\t\t\t\tif (!box) {\n\t\t\t\t\t// Symbol definition exists (#5324)\n\t\t\t\t\twrapper.box = box = renderer.symbols[shape] || hasBGImage ? \n\t\t\t\t\t\trenderer.symbol(shape) :\n\t\t\t\t\t\trenderer.rect();\n\t\t\t\t\t\n\t\t\t\t\tbox.addClass( // Don't use label className for buttons\n\t\t\t\t\t\t(className === 'button' ? '' : 'highcharts-label-box') +\n\t\t\t\t\t\t(className ? ' highcharts-' + className + '-box' : '')\n\t\t\t\t\t);\n\n\t\t\t\t\tbox.add(wrapper);\n\n\t\t\t\t\tcrispAdjust = getCrispAdjust();\n\t\t\t\t\tattribs.x = crispAdjust;\n\t\t\t\t\tattribs.y = (baseline ? -baselineOffset : 0) + crispAdjust;\n\t\t\t\t}\n\n\t\t\t\t// Apply the box attributes\n\t\t\t\tattribs.width = Math.round(wrapper.width);\n\t\t\t\tattribs.height = Math.round(wrapper.height);\n\t\t\t\t\n\t\t\t\tbox.attr(extend(attribs, deferredAttr));\n\t\t\t\tdeferredAttr = {};\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * This function runs after setting text or padding, but only if padding\n\t\t * is changed\n\t\t */\n\t\tupdateTextPadding = function () {\n\t\t\tvar textX = paddingLeft + padding,\n\t\t\t\ttextY;\n\n\t\t\t// determin y based on the baseline\n\t\t\ttextY = baseline ? 0 : baselineOffset;\n\n\t\t\t// compensate for alignment\n\t\t\tif (\n\t\t\t\tdefined(width) &&\n\t\t\t\tbBox &&\n\t\t\t\t(textAlign === 'center' || textAlign === 'right')\n\t\t\t) {\n\t\t\t\ttextX += { center: 0.5, right: 1 }[textAlign] *\n\t\t\t\t\t(width - bBox.width);\n\t\t\t}\n\n\t\t\t// update if anything changed\n\t\t\tif (textX !== text.x || textY !== text.y) {\n\t\t\t\ttext.attr('x', textX);\n\t\t\t\tif (textY !== undefined) {\n\t\t\t\t\ttext.attr('y', textY);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// record current values\n\t\t\ttext.x = textX;\n\t\t\ttext.y = textY;\n\t\t};\n\n\t\t/**\n\t\t * Set a box attribute, or defer it if the box is not yet created\n\t\t * @param {Object} key\n\t\t * @param {Object} value\n\t\t */\n\t\tboxAttr = function (key, value) {\n\t\t\tif (box) {\n\t\t\t\tbox.attr(key, value);\n\t\t\t} else {\n\t\t\t\tdeferredAttr[key] = value;\n\t\t\t}\n\t\t};\n\n\t\t/**\n\t\t * After the text element is added, get the desired size of the border\n\t\t * box and add it before the text in the DOM.\n\t\t */\n\t\twrapper.onAdd = function () {\n\t\t\ttext.add(wrapper);\n\t\t\twrapper.attr({\n\t\t\t\t// Alignment is available now  (#3295, 0 not rendered if given\n\t\t\t\t// as a value)\n\t\t\t\ttext: (str || str === 0) ? str : '',\n\t\t\t\tx: x,\n\t\t\t\ty: y\n\t\t\t});\n\n\t\t\tif (box && defined(anchorX)) {\n\t\t\t\twrapper.attr({\n\t\t\t\t\tanchorX: anchorX,\n\t\t\t\t\tanchorY: anchorY\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t/*\n\t\t * Add specific attribute setters.\n\t\t */\n\n\t\t// only change local variables\n\t\twrapper.widthSetter = function (value) {\n\t\t\twidth = H.isNumber(value) ? value : null; // width:auto => null\n\t\t};\n\t\twrapper.heightSetter = function (value) {\n\t\t\theight = value;\n\t\t};\n\t\twrapper['text-alignSetter'] = function (value) {\n\t\t\ttextAlign = value;\n\t\t};\n\t\twrapper.paddingSetter =  function (value) {\n\t\t\tif (defined(value) && value !== padding) {\n\t\t\t\tpadding = wrapper.padding = value;\n\t\t\t\tupdateTextPadding();\n\t\t\t}\n\t\t};\n\t\twrapper.paddingLeftSetter =  function (value) {\n\t\t\tif (defined(value) && value !== paddingLeft) {\n\t\t\t\tpaddingLeft = value;\n\t\t\t\tupdateTextPadding();\n\t\t\t}\n\t\t};\n\n\n\t\t// change local variable and prevent setting attribute on the group\n\t\twrapper.alignSetter = function (value) {\n\t\t\tvalue = { left: 0, center: 0.5, right: 1 }[value];\n\t\t\tif (value !== alignFactor) {\n\t\t\t\talignFactor = value;\n\t\t\t\t// Bounding box exists, means we're dynamically changing\n\t\t\t\tif (bBox) {\n\t\t\t\t\twrapper.attr({ x: wrapperX }); // #5134\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// apply these to the box and the text alike\n\t\twrapper.textSetter = function (value) {\n\t\t\tif (value !== undefined) {\n\t\t\t\ttext.textSetter(value);\n\t\t\t}\n\t\t\tupdateBoxSize();\n\t\t\tupdateTextPadding();\n\t\t};\n\n\t\t// apply these to the box but not to the text\n\t\twrapper['stroke-widthSetter'] = function (value, key) {\n\t\t\tif (value) {\n\t\t\t\tneedsBox = true;\n\t\t\t}\n\t\t\tstrokeWidth = this['stroke-width'] = value;\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\t/*= if (!build.classic) { =*/\n\t\twrapper.rSetter = function (value, key) {\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\t/*= } else { =*/\n\t\twrapper.strokeSetter =\n\t\twrapper.fillSetter =\n\t\twrapper.rSetter = function (value, key) {\n\t\t\tif (key !== 'r') {\n\t\t\t\tif (key === 'fill' && value) {\n\t\t\t\t\tneedsBox = true;\n\t\t\t\t}\n\t\t\t\t// for animation getter (#6776)\n\t\t\t\twrapper[key] = value;\n\t\t\t}\n\t\t\tboxAttr(key, value);\n\t\t};\n\t\t/*= } =*/\n\t\twrapper.anchorXSetter = function (value, key) {\n\t\t\tanchorX = wrapper.anchorX = value;\n\t\t\tboxAttr(key, Math.round(value) - getCrispAdjust() - wrapperX);\n\t\t};\n\t\twrapper.anchorYSetter = function (value, key) {\n\t\t\tanchorY = wrapper.anchorY = value;\n\t\t\tboxAttr(key, value - wrapperY);\n\t\t};\n\n\t\t// rename attributes\n\t\twrapper.xSetter = function (value) {\n\t\t\twrapper.x = value; // for animation getter\n\t\t\tif (alignFactor) {\n\t\t\t\tvalue -= alignFactor * ((width || bBox.width) + 2 * padding);\n\n\t\t\t\t// Force animation even when setting to the same value (#7898)\n\t\t\t\twrapper['forceAnimate:x'] = true;\n\t\t\t}\n\t\t\twrapperX = Math.round(value);\n\t\t\twrapper.attr('translateX', wrapperX);\n\t\t};\n\t\twrapper.ySetter = function (value) {\n\t\t\twrapperY = wrapper.y = Math.round(value);\n\t\t\twrapper.attr('translateY', wrapperY);\n\t\t};\n\n\t\t// Redirect certain methods to either the box or the text\n\t\tvar baseCss = wrapper.css;\n\t\treturn extend(wrapper, {\n\t\t\t/**\n\t\t\t * Pick up some properties and apply them to the text instead of the\n\t\t\t * wrapper.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tcss: function (styles) {\n\t\t\t\tif (styles) {\n\t\t\t\t\tvar textStyles = {};\n\t\t\t\t\t// Create a copy to avoid altering the original object\n\t\t\t\t\t// (#537)\n\t\t\t\t\tstyles = merge(styles); \n\t\t\t\t\teach(wrapper.textProps, function (prop) {\n\t\t\t\t\t\tif (styles[prop] !== undefined) {\n\t\t\t\t\t\t\ttextStyles[prop] = styles[prop];\n\t\t\t\t\t\t\tdelete styles[prop];\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\ttext.css(textStyles);\n\t\t\t\t}\n\t\t\t\treturn baseCss.call(wrapper, styles);\n\t\t\t},\n\t\t\t/**\n\t\t\t * Return the bounding box of the box, not the group.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tgetBBox: function () {\n\t\t\t\treturn {\n\t\t\t\t\twidth: bBox.width + 2 * padding,\n\t\t\t\t\theight: bBox.height + 2 * padding,\n\t\t\t\t\tx: bBox.x - padding,\n\t\t\t\t\ty: bBox.y - padding\n\t\t\t\t};\n\t\t\t},\n\t\t\t/*= if (build.classic) { =*/\n\t\t\t/**\n\t\t\t * Apply the shadow to the box.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tshadow: function (b) {\n\t\t\t\tif (b) {\n\t\t\t\t\tupdateBoxSize();\n\t\t\t\t\tif (box) {\n\t\t\t\t\t\tbox.shadow(b);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn wrapper;\n\t\t\t},\n\t\t\t/*= } =*/\n\t\t\t/**\n\t\t\t * Destroy and release memory.\n\t\t\t * @ignore\n\t\t\t */\n\t\t\tdestroy: function () {\n\t\t\t\t\n\t\t\t\t// Added by button implementation\n\t\t\t\tremoveEvent(wrapper.element, 'mouseenter');\n\t\t\t\tremoveEvent(wrapper.element, 'mouseleave');\n\n\t\t\t\tif (text) {\n\t\t\t\t\ttext = text.destroy();\n\t\t\t\t}\n\t\t\t\tif (box) {\n\t\t\t\t\tbox = box.destroy();\n\t\t\t\t}\n\t\t\t\t// Call base implementation to destroy the rest\n\t\t\t\tSVGElement.prototype.destroy.call(wrapper);\n\n\t\t\t\t// Release local pointers (#1298)\n\t\t\t\twrapper =\n\t\t\t\trenderer =\n\t\t\t\tupdateBoxSize =\n\t\t\t\tupdateTextPadding =\n\t\t\t\tboxAttr = null;\n\t\t\t}\n\t\t});\n\t}\n}); // end SVGRenderer\n\n\n// general renderer\nH.Renderer = SVGRenderer;\n", "{\n  \"name\": \"highcharts\",\n  \"version\": \"6.0.7\",\n  \"description\": \"JavaScript charting framework\",\n  \"main\": \"lib/highcharts\",\n  \"author\": \"Highsoft AS <support@highcharts.com> (http://www.highcharts.com/about)\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/highcharts/highcharts.git\"\n  },\n  \"bugs\": \"https://github.com/highcharts/highcharts/issues\",\n  \"homepage\": \"http://www.highcharts.com\",\n  \"keywords\": [\n    \"charts\",\n    \"graphs\",\n    \"visualization\",\n    \"data\",\n    \"browserify\",\n    \"webpack\"\n  ],\n  \"files\": [\n    \"errors\",\n    \"gfx\",\n    \"js\",\n    \"lib\"\n  ],\n  \"scripts\": {\n    \"precommit\": \"lint-staged && gulp test\",\n    \"post-merge\": \"gulp styles && gulp scripts\"\n  },\n  \"devDependencies\": {\n    \"babel-plugin-transform-es2015-arrow-functions\": \"^6.8.0\",\n    \"browserify\": \"^12.0.2\",\n    \"closurecompiler\": \"^1.6.1\",\n    \"colors\": \"~1.1.2\",\n    \"eslint\": \"3.12.2\",\n    \"eslint-plugin-highcharts\": \"file:tools/eslint-plugin-highcharts\",\n    \"eslint-plugin-security\": \"^1.4.0\",\n    \"fs-extra\": \"^2.1.2\",\n    \"gifencoder\": \"^1.1.0\",\n    \"google-closure-compiler-js\": \"^20160916.0.0\",\n    \"grunt\": \"^0.4.5\",\n    \"grunt-jslint\": \"^1.1.12\",\n    \"gulp\": \"^3.9.1\",\n    \"gulp-jsdoc3\": \"^1.0.1\",\n    \"gzip-size\": \"^3.0.0\",\n    \"highcharts-api-doc-gen\": \"github:highcharts/api-docs\",\n    \"highcharts-assembler\": \"github:highcharts/highcharts-assembler#v1.0.25\",\n    \"husky\": \"^0.14.3\",\n    \"js-yaml\": \"^3.10.0\",\n    \"karma\": \"^1.7.1\",\n    \"karma-browserstack-launcher\": \"^1.3.0\",\n    \"karma-chrome-launcher\": \"^2.2.0\",\n    \"karma-edge-launcher\": \"^0.4.2\",\n    \"karma-firefox-launcher\": \"^1.0.1\",\n    \"karma-generic-preprocessor\": \"^1.1.0\",\n    \"karma-ie-launcher\": \"^1.0.0\",\n    \"karma-qunit\": \"^1.2.1\",\n    \"karma-safari-launcher\": \"^1.0.0\",\n    \"lint-staged\": \"^4.2.3\",\n    \"lolex\": \"^2.1.3\",\n    \"node-sass\": \"^4.5.3\",\n    \"pixelmatch\": \"^4.0.2\",\n    \"png-js\": \"^0.1.1\",\n    \"pngjs\": \"^3.3.0\",\n    \"qunitjs\": \"^2.4.0\",\n    \"request\": \"^2.81.0\",\n    \"requirejs\": \"^2.3.3\",\n    \"vinyl-ftp\": \"^0.4.5\",\n    \"webpack\": \"^1.15.0\",\n    \"xml2js\": \"^0.4.17\",\n    \"yargs\": \"^3.32.0\"\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      \"eslint\",\n      \"git add\"\n    ]\n  },\n  \"license\": \"SEE LICENSE IN <license.txt>\",\n  \"dependencies\": {\n    \"aws-sdk\": \"^2.94.0\",\n    \"babel-runtime\": \"^6.20.0\",\n    \"glob\": \"^7.1.2\",\n    \"safe-regex\": \"^1.1.0\",\n    \"taffydb\": \"^2.7.3\"\n  }\n}\n", "QUnit.test('titleSetter', function (assert) {\n    var chart = Highcharts.chart('container', {\n        }),\n        str = 'The quick brown fox<br> jumps over the lazy dog',\n        newTitle = 'Quick brown fox',\n        text = chart.renderer.text(str, 100, 100).css({ width: 100, textOverflow: 'ellipsis' }).add();\n\n    assert.strictEqual(\n        text.element.getElementsByTagName('title')[0].textContent, // Ideally there should be a titleGetter. text.attr('title')\n        str.replace('<br>', ''),\n        'Text element has a correct title. #5211'\n    );\n\n    // Update the title tag with a shorter text\n    text.attr('title', newTitle);\n    assert.strictEqual(\n        text.element.getElementsByTagName('title')[0].textContent, // Ideally there should be a titleGetter. text.attr('title')\n        newTitle,\n        'Text element title has been updated. #5211'\n    );\n});\n\nQUnit.test('getBBox with useHTML (#5899)', function (assert) {\n    var ren = new Highcharts.Renderer(\n        document.getElementById('container'),\n        600,\n        400\n    );\n\n    var text = ren.text(\n        '<div style=\"width: 500px\">Styled div</div>',\n        20,\n        20,\n        true\n    )\n    .add();\n\n    assert.strictEqual(\n        text.getBBox().width,\n        500,\n        'Initial bounding box'\n    );\n\n    text.attr({\n        text: '<div style=\"width: 400px\">Styled div</div>'\n    });\n\n    assert.strictEqual(\n        text.getBBox().width,\n        400,\n        'Updated bounding box'\n    );\n\n    text.attr({\n        text: null\n    });\n\n    assert.strictEqual(\n        text.getBBox().width,\n        0,\n        'Null text works fine (#7316)'\n    );\n});\n\nQUnit.test('textOverflow: ellipsis.', function (assert) {\n    var chart = Highcharts.chart('container', {}),\n        width = 50,\n        style = {\n            textOverflow: 'ellipsis',\n            width: width + 'px'\n        },\n        text1 = chart.renderer.text('01234567', 0, 100).css(style).add(),\n        text2 = chart.renderer.text('012345678', 0, 120).css(style).add();\n    assert.strictEqual(\n        text1.getBBox().width < width,\n        true,\n        'Width of text is lower than style.width'\n    );\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent.slice(-1),\n        '\\u2026',\n        'Ellipsis was added to text node.'\n    );\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent,\n        text2.element.childNodes[0].textContent,\n        'Consistent result between different strings. #6258'\n    );\n    // TODO 0px does not work, because ellipsis and breaks are not applied\n    // when width is considered falsy.\n    style.width = '1px';\n    text1.destroy();\n    text1 = chart.renderer.text('01234567', 0, 100).css(style).add();\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent,\n        '',\n        'Width was too small for ellipsis.'\n    );\n\n    /**\n     * Rotation. Width determines the length of a rotated text\n     */\n    text1.destroy();\n    text2.destroy();\n    style.width = '50px';\n    text1 = chart.renderer.text('01234567', 0, 100).attr({\n        rotation: 90\n    }).css(style).add();\n    assert.strictEqual(\n        text1.element.childNodes[0].textContent.slice(-1),\n        '\\u2026',\n        'Ellipsis was added to text node which has rotation.'\n    );\n    assert.strictEqual(\n        text1.getBBox().height < width,\n        true,\n        'Height of text is lower than style.width'\n    );\n});\n\nQUnit.test('BBox for mulitiple lines', function (assert) {\n    var ren = new Highcharts.Renderer(\n        document.getElementById('container'),\n        200,\n        200\n    );\n\n    var lab = ren.label('<span></span><br/>line<br/>line', 20, 20)\n        .css({\n            color: '#f00'\n        })\n        .attr({\n            fill: 'rgba(0, 100, 0, 0.75)',\n            padding: 0\n        })\n        .add();\n\n    assert.strictEqual(\n        lab.element.getAttribute('dy'),\n        null,\n        \"Frist line shouldn't have dy (#6144) - visually the red text fits in the green box.\"\n    );\n});\n\nQUnit.test('HTML', function (assert) {\n    var ren = new Highcharts.SVGRenderer(\n        document.getElementById('container'),\n        500,\n        500\n    );\n\n    var text = ren.text('Hello &amp; &lt;tag&gt;', 10, 30).add();\n\n    assert.strictEqual(\n        text.element.textContent,\n        'Hello & <tag>',\n        'HTML entities decoded correctly'\n    );\n\n    text = ren.text('a < b and c > d', 10, 60).add();\n    assert.strictEqual(\n        text.element.textContent,\n        'a < b and c > d',\n        'Tags don\\'t start with spaces (#7126)'\n    );\n\n    var html = ren.text('useHTML', 100, 100, true).add();\n    assert.close(\n        html.element.offsetLeft,\n        100,\n        1,\n        'Left offset should reflect initial position'\n    );\n    assert.close(\n        html.element.offsetHeight + html.element.offsetTop,\n        100,\n        10,\n        'Top offset should reflect initial position'\n    );\n});\n\nQUnit.test('Dir rtl (#3482)', function (assert) {\n    document.getElementById('container').setAttribute('dir', 'rtl');\n    var ren = new Highcharts.Renderer(\n        document.getElementById('container'),\n        600,\n        400\n    );\n\n    var label = ren.label('Hello', 100, 100)\n        .attr({\n            stroke: 'blue',\n            'stroke-width': 1,\n            padding: 0\n        })\n        .add();\n\n    assert.close(\n        label.text.element.getBBox().x,\n        0,\n        2,\n        'Label sits nicely inside box'\n    );\n\n    document.getElementById('container').removeAttribute('dir');\n});\n\nQUnit.test('Attributes', function (assert) {\n    var ren = new Highcharts.Renderer(\n        document.getElementById('container'),\n        600,\n        400\n    );\n\n    var text = ren\n        .text(\n            'The quick brown fox jumps <span class=\"red\">over</span> the lazy dog',\n            20,\n            20\n        )\n        .add();\n\n    assert.strictEqual(\n        text.element.childNodes[1].getAttribute('class'),\n        'red',\n        'Double quotes, red span should be picked up'\n    );\n\n    text = ren\n        .text(\n            \"The quick brown fox jumps <span class='red'>over</span> the lazy dog\",\n            20,\n            20\n        )\n        .add();\n\n    assert.strictEqual(\n        text.element.childNodes[1].getAttribute('class'),\n        'red',\n        'Single quotes, red span should be picked up'\n    );\n});\n"], "filenames": ["js/parts/SvgRenderer.js", "package.json", "samples/unit-tests/svgrenderer/text/demo.js"], "buggy_code_start_loc": [2351, 84, 206], "buggy_code_end_loc": [2654, 84, 206], "fixing_code_start_loc": [2350, 85, 207], "fixing_code_end_loc": [2672, 86, 243], "type": "CWE-185", "message": "In js/parts/SvgRenderer.js in Highcharts JS before 6.1.0, the use of backtracking regular expressions permitted an attacker to conduct a denial of service attack against the SVGRenderer component, aka ReDoS.", "other": {"cve": {"id": "CVE-2018-20801", "sourceIdentifier": "cve@mitre.org", "published": "2019-03-14T16:29:00.243", "lastModified": "2019-07-15T11:15:10.577", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In js/parts/SvgRenderer.js in Highcharts JS before 6.1.0, the use of backtracking regular expressions permitted an attacker to conduct a denial of service attack against the SVGRenderer component, aka ReDoS."}, {"lang": "es", "value": "En js/parts/SvgRenderer.js en Highcharts JS, en versiones anteriores a la 6.1.0, el uso de expresiones regulares de backtracking permit\u00eda que un atacante llevase a cabo un ataque de denegaci\u00f3n de servicio contra el componente SVGRenderer, tambi\u00e9n conocido como ReDoS."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-185"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:highcharts:highcharts:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1.0", "matchCriteriaId": "A3679E49-1D6E-44A9-9B4A-5BC7E15CE851"}]}]}], "references": [{"url": "https://github.com/highcharts/highcharts/commit/7c547e1e0f5e4379f94396efd559a566668c0dfa", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20190715-0001/", "source": "cve@mitre.org"}, {"url": "https://snyk.io/vuln/npm:highcharts:20180225", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/highcharts/highcharts/commit/7c547e1e0f5e4379f94396efd559a566668c0dfa"}}