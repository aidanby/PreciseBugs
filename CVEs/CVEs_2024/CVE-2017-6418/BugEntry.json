{"buggy_code": ["/*\n *  Copyright (C) 2015 Cisco Systems, Inc. and/or its affiliates. All rights reserved.\n *  Copyright (C) 2007-2008 Sourcefire, Inc.\n *\n *  Authors: Nigel Horne\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA 02110-1301, USA.\n *\n * TODO: Optimise messageExport, decodeLine, messageIsEncoding\n */\n\n#if HAVE_CONFIG_H\n#include \"clamav-config.h\"\n#endif\n\n#ifdef CL_THREAD_SAFE\n#ifndef\t_REENTRANT\n#define\t_REENTRANT\t/* for Solaris 2.8 */\n#endif\n#endif\n\n#ifdef\tC_DARWIN\n#include <sys/types.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#ifdef\tHAVE_STRINGS_H\n#include <strings.h>\n#endif\n#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n\n#ifdef\tCL_THREAD_SAFE\n#include <pthread.h>\n#endif\n\n#include \"others.h\"\n#include \"str.h\"\n#include \"filetypes.h\"\n\n#include \"mbox.h\"\n#include \"clamav.h\"\n#include \"json_api.h\"\n\n#ifndef isblank\n#define isblank(c)\t(((c) == ' ') || ((c) == '\\t'))\n#endif\n\n#define\tRFC2045LENGTH\t76\t/* maximum number of characters on a line */\n\n#ifdef\tHAVE_STDBOOL_H\n#include <stdbool.h>\n#else\n#ifdef\tFALSE\ntypedef\tunsigned\tchar\tbool;\n#else\ntypedef enum\t{ FALSE = 0, TRUE = 1 } bool;\n#endif\n#endif\n\nstatic\tint\tmessageHasArgument(const message *m, const char *variable);\nstatic\tvoid\tmessageIsEncoding(message *m);\nstatic unsigned char *decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(char), bool isFast);\nstatic\tvoid\tsanitiseBase64(char *s);\n#ifdef\t__GNUC__\nstatic\tunsigned\tchar\thex(char c)\t__attribute__((const));\nstatic\tunsigned\tchar\tbase64(char c)\t__attribute__((const));\nstatic\tunsigned\tchar\tuudecode(char c)\t__attribute__((const));\n#else\nstatic\tunsigned\tchar\thex(char c);\nstatic\tunsigned\tchar\tbase64(char c);\nstatic\tunsigned\tchar\tuudecode(char c);\n#endif\nstatic\tconst\tchar\t*messageGetArgument(const message *m, int arg);\nstatic\tvoid\t*messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), void (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void (*setCTX)(void *, cli_ctx *), int destroy_text);\nstatic\tint\tusefulArg(const char *arg);\nstatic\tvoid\tmessageDedup(message *m);\nstatic\tchar\t*rfc2231(const char *in);\nstatic\tint\tsimil(const char *str1, const char *str2);\n\n/*\n * These maps are ordered in decreasing likelyhood of their appearance\n * in an e-mail. Probably these should be in a table...\n */\nstatic\tconst\tstruct\tencoding_map {\n\tconst\tchar\t*string;\n\tencoding_type\ttype;\n} encoding_map[] = {\t/* rfc2045 */\n\t{\t\"7bit\",\t\t\tNOENCODING\t},\n\t{\t\"text/plain\",\t\tNOENCODING\t},\n\t{\t\"quoted-printable\",\tQUOTEDPRINTABLE\t},\t/* rfc2045 */\n\t{\t\"base64\",\t\tBASE64\t\t},\t/* rfc2045 */\n\t{\t\"8bit\",\t\t\tEIGHTBIT\t},\n\t{\t\"binary\",\t\tBINARY\t\t},\n\t{\t\"x-uuencode\",\t\tUUENCODE\t},\t/* uuencode(5) */\n\t{\t\"x-yencode\",\t\tYENCODE\t\t},\n\t{\t\"x-binhex\",\t\tBINHEX\t\t},\n\t{\t\"us-ascii\",\t\tNOENCODING\t},\t/* incorrect */\n\t{\t\"x-uue\",\t\tUUENCODE\t},\t/* incorrect */\n\t{\t\"uuencode\",\t\tUUENCODE\t},\t/* incorrect */\n\t{\tNULL,\t\t\tNOENCODING\t}\n};\n\nstatic\tconst\tstruct\tmime_map {\n\tconst\tchar\t*string;\n\tmime_type\ttype;\n} mime_map[] = {\n\t{\t\"text\",\t\t\tTEXT\t\t},\n\t{\t\"multipart\",\t\tMULTIPART\t},\n\t{\t\"application\",\t\tAPPLICATION\t},\n\t{\t\"audio\",\t\tAUDIO\t\t},\n\t{\t\"image\",\t\tIMAGE\t\t},\n\t{\t\"message\",\t\tMESSAGE\t\t},\n\t{\t\"video\",\t\tVIDEO\t\t},\n\t{\tNULL,\t\t\tTEXT\t\t}\n};\n\n/*\n * See RFC2045, section 6.8, table 1\n */\nstatic const unsigned char base64Table[256] = {\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,62,255,255,255,63,\n\t52,53,54,55,56,57,58,59,60,61,255,255,255,0,255,255,\n\t255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,\n\t15,16,17,18,19,20,21,22,23,24,25,255,255,255,255,255,\n\t255,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,\n\t41,42,43,44,45,46,47,48,49,50,51,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255\n};\n\nmessage *\nmessageCreate(void)\n{\n\tmessage *m = (message *)cli_calloc(1, sizeof(message));\n\n\tif(m)\n\t\tm->mimeType = NOMIME;\n\n\treturn m;\n}\n\nvoid\nmessageDestroy(message *m)\n{\n\tassert(m != NULL);\n\n\tmessageReset(m);\n\n\tfree(m);\n}\n\nvoid\nmessageReset(message *m)\n{\n\tint i;\n\n\tassert(m != NULL);\n\n\tif(m->mimeSubtype)\n\t\tfree(m->mimeSubtype);\n\n\tif(m->mimeDispositionType)\n\t\tfree(m->mimeDispositionType);\n\n\tif(m->mimeArguments) {\n\t\tfor(i = 0; i < m->numberOfArguments; i++)\n\t\t\tfree(m->mimeArguments[i]);\n\t\tfree(m->mimeArguments);\n\t}\n\n\tif(m->body_first)\n\t\ttextDestroy(m->body_first);\n\n\tassert(m->base64chars == 0);\n\n\tif(m->encodingTypes) {\n\t\tassert(m->numberOfEncTypes > 0);\n\t\tfree(m->encodingTypes);\n\t}\n\n#if HAVE_JSON\n\tif(m->jobj)\n\t\tcli_json_delobj(m->jobj);\n#endif\n\n\tmemset(m, '\\0', sizeof(message));\n\tm->mimeType = NOMIME;\n}\n\n/*\n * Handle the Content-Type header. The syntax is in RFC1341.\n * Return success (1) or failure (0). Failure only happens when it's an\n * unknown type and we've already received a known type, or we've received an\n * empty type. If we receive an unknown type by itself we default to application\n */\nint\nmessageSetMimeType(message *mess, const char *type)\n{\n#ifdef\tCL_THREAD_SAFE\n\tstatic pthread_mutex_t mime_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\tconst struct mime_map *m;\n\tint typeval;\n\tstatic table_t *mime_table;\n\n\tassert(mess != NULL);\n\tif(type == NULL) {\n\t\tcli_dbgmsg(\"Empty content-type field\\n\");\n\t\treturn 0;\n\t}\n\n\tcli_dbgmsg(\"messageSetMimeType: '%s'\\n\", type);\n\n\t/* Ignore leading spaces */\n\twhile(!isalpha(*type))\n\t\tif(*type++ == '\\0')\n\t\t\treturn 0;\n\n#ifdef\tCL_THREAD_SAFE\n\tpthread_mutex_lock(&mime_mutex);\n#endif\n\tif(mime_table == NULL) {\n\t\tmime_table = tableCreate();\n\t\tif(mime_table == NULL) {\n#ifdef\tCL_THREAD_SAFE\n\t\t\tpthread_mutex_unlock(&mime_mutex);\n#endif\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(m = mime_map; m->string; m++)\n\t\t\tif(!tableInsert(mime_table, m->string, m->type)) {\n\t\t\t\ttableDestroy(mime_table);\n\t\t\t\tmime_table = NULL;\n#ifdef\tCL_THREAD_SAFE\n\t\t\t\tpthread_mutex_unlock(&mime_mutex);\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n#ifdef\tCL_THREAD_SAFE\n\tpthread_mutex_unlock(&mime_mutex);\n#endif\n\n\ttypeval = tableFind(mime_table, type);\n\n\tif(typeval != -1) {\n\t\tmess->mimeType = (mime_type)typeval;\n\t\treturn 1;\n\t}\n\tif(mess->mimeType == NOMIME) {\n\t\tif(strncasecmp(type, \"x-\", 2) == 0)\n\t\t\tmess->mimeType = MEXTENSION;\n\t\telse {\n\t\t\t/*\n\t\t\t * Force scanning of strange messages\n\t\t\t */\n\t\t\tif(strcasecmp(type, \"plain\") == 0) {\n\t\t\t\tcli_dbgmsg(\"Incorrect MIME type: `plain', set to Text\\n\");\n\t\t\t\tmess->mimeType = TEXT;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Don't handle broken e-mail probably sending\n\t\t\t\t *\tContent-Type: plain/text\n\t\t\t\t * instead of\n\t\t\t\t *\tContent-Type: text/plain\n\t\t\t\t * as an attachment\n\t\t\t\t */\n\t\t\t\tint highestSimil = 0, t = -1;\n\t\t\t\tconst char *closest = NULL;\n\n\t\t\t\tfor(m = mime_map; m->string; m++) {\n\t\t\t\t\tconst int s = simil(m->string, type);\n\n\t\t\t\t\tif(s > highestSimil) {\n\t\t\t\t\t\thighestSimil = s;\n\t\t\t\t\t\tclosest = m->string;\n\t\t\t\t\t\tt = m->type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(highestSimil >= 50) {\n\t\t\t\t\tcli_dbgmsg(\"Unknown MIME type \\\"%s\\\" - guessing as %s (%d%% certainty)\\n\",\n\t\t\t\t\t\ttype, closest,\n\t\t\t\t\t\thighestSimil);\n\t\t\t\t\tmess->mimeType = (mime_type)t;\n\t\t\t\t} else {\n\t\t\t\t\tcli_dbgmsg(\"Unknown MIME type: `%s', set to Application - if you believe this file contains a virus, submit it to www.clamav.net\\n\", type);\n\t\t\t\t\tmess->mimeType = APPLICATION;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nmime_type\nmessageGetMimeType(const message *m)\n{\n\tassert(m != NULL);\n\n\treturn m->mimeType;\n}\n\nvoid\nmessageSetMimeSubtype(message *m, const char *subtype)\n{\n\tassert(m != NULL);\n\n\tif(subtype == NULL) {\n\t\t/*\n\t\t * Handle broken content-type lines, e.g.\n\t\t *\tContent-Type: text/\n\t\t */\n\t\tcli_dbgmsg(\"Empty content subtype\\n\");\n\t\tsubtype = \"\";\n\t}\n\n\tif(m->mimeSubtype)\n\t\tfree(m->mimeSubtype);\n\n\tm->mimeSubtype = cli_strdup(subtype);\n}\n\nconst char *\nmessageGetMimeSubtype(const message *m)\n{\n\treturn (m->mimeSubtype) ? m->mimeSubtype : \"\";\n}\n\nvoid\nmessageSetDispositionType(message *m, const char *disptype)\n{\n\tassert(m != NULL);\n\n\tif(m->mimeDispositionType)\n\t\tfree(m->mimeDispositionType);\n\tif(disptype == NULL) {\n\t\tm->mimeDispositionType = NULL;\n\t\treturn;\n\t}\n\n\t/*\n\t * It's broken for there to be an entry such as \"Content-Disposition:\"\n\t * However some spam and viruses are rather broken, it's a sign\n\t * that something is wrong if we get that - maybe we should force a\n\t * scan of this part\n\t */\n\twhile(*disptype && isspace((int)*disptype))\n\t\tdisptype++;\n\tif(*disptype) {\n\t\tm->mimeDispositionType = cli_strdup(disptype);\n\t\tif(m->mimeDispositionType)\n\t\t\tstrstrip(m->mimeDispositionType);\n\t} else\n\t\tm->mimeDispositionType = NULL;\n}\n\nconst char *\nmessageGetDispositionType(const message *m)\n{\n\treturn (m->mimeDispositionType) ? m->mimeDispositionType : \"\";\n}\n\n/*\n * TODO:\n *\tArguments are held on a per message basis, they should be held on\n * a per section basis. Otherwise what happens if two sections have two\n * different values for charset? Probably doesn't matter for the use this\n * code will be given, but will need fixing if this code is used elsewhere\n */\nvoid\nmessageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\n\tassert(m != NULL);\n\n\tif(arg == NULL)\n\t\treturn;\t/* Note: this is not an error condition */\n\n\twhile(isspace(*arg))\n\t\targ++;\n\n\tif(*arg == '\\0')\n\t\t/* Empty argument? Probably a broken mail client... */\n\t\treturn;\n\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\n\tif(!usefulArg(arg))\n\t\treturn;\n\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t/* already in there */\n\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\t/* problem inside rfc2231() */\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\t/*\n\t\t\t * FIXME: Bounce message handling is corrupting the in\n\t\t\t * core copies of headers\n\t\t\t */\n\t\t\tcli_dbgmsg(\"Possible data corruption fixed\\n\");\n\t\t\tp[8] = '=';\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * This is terribly broken from an RFC point of view but is useful\n\t * for catching viruses which have a filename but no type of\n\t * mime. By pretending defaulting to an application rather than\n\t * to nomime we can ensure they're saved and scanned\n\t */\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}\n\n/*\n * Add in all the arguments.\n * Cope with:\n *\tname=\"foo bar.doc\"\n *\tcharset=foo name=bar\n */\nvoid\nmessageAddArguments(message *m, const char *s)\n{\n\tconst char *string = s;\n\n\tcli_dbgmsg(\"Add arguments '%s'\\n\", string);\n\n\tassert(string != NULL);\n\n\twhile(*string) {\n\t\tconst char *key, *cptr;\n\t\tchar *data, *field;\n        size_t datasz=0;\n\n\t\tif(isspace(*string & 0xff) || (*string == ';')) {\n\t\t\tstring++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = string;\n\n\t\tdata = strchr(string, '=');\n\n\t\t/*\n\t\t * Some spam breaks RFC2045 by using ':' instead of '='\n\t\t * e.g.:\n\t\t *\tContent-Type: text/html; charset:ISO-8859-1\n\t\t * should be:\n\t\t *\tContent-type: text/html; charset=ISO-8859-1\n\t\t *\n\t\t * We give up with lines that are completely broken because\n\t\t * we don't have ESP and don't know what was meant to be there.\n\t\t * It's unlikely to really be a problem.\n\t\t */\n\t\tif(data == NULL)\n\t\t\tdata = strchr(string, ':');\n\n\t\tif(data == NULL) {\n\t\t\t/*\n\t\t\t * Completely broken, give up\n\t\t\t */\n\t\t\tcli_dbgmsg(\"Can't parse header \\\"%s\\\"\\n\", s);\n\t\t\treturn;\n\t\t}\n\n\t\tstring = &data[1];\n\n\t\t/*\n\t\t * Handle white space to the right of the equals sign\n\t\t * This breaks RFC2045 which has:\n\t\t *\tparameter := attribute \"=\" value\n\t\t *\tattribute := token   ; case-insensitive\n\t\t *\ttoken  :=  1*<any (ASCII) CHAR except SPACE, CTLs,\n\t\t *\t\tor tspecials>\n\t\t * But too many MUAs ignore this\n\t\t */\n\t\twhile(isspace(*string) && (*string != '\\0'))\n\t\t\tstring++;\n\n\t\tcptr = string++;\n\n\t\tif(strlen(key) == 0)\n\t\t\tcontinue;\n\n\t\tif(*cptr == '\"') {\n\t\t\tchar *ptr, *kcopy;\n\n\t\t\t/*\n\t\t\t * The field is in quotes, so look for the\n\t\t\t * closing quotes\n\t\t\t */\n\t\t\tkcopy = cli_strdup(key);\n\n\t\t\tif(kcopy == NULL)\n\t\t\t\treturn;\n\n\t\t\tptr = strchr(kcopy, '=');\n\t\t\tif(ptr == NULL) {\n\t\t\t\tptr = strchr(kcopy, ':');\n                if (ptr == NULL) {\n                    cli_dbgmsg(\"Can't parse header \\\"%s\\\"\\n\", s);\n                    free(kcopy);\n                    return;\n                }\n            }\n\n\t\t\t*ptr = '\\0';\n\n\t\t\tstring = strchr(++cptr, '\"');\n\n\t\t\tif(string == NULL) {\n\t\t\t\tcli_dbgmsg(\"Unbalanced quote character in \\\"%s\\\"\\n\", s);\n\t\t\t\tstring = \"\";\n\t\t\t} else\n\t\t\t\tstring++;\n\n\t\t\tif(!usefulArg(kcopy)) {\n\t\t\t\tfree(kcopy);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdata = cli_strdup(cptr);\n\n\t\t\tptr = (data) ? strchr(data, '\"') : NULL;\n\t\t\tif(ptr == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Weird e-mail header such as:\n\t\t\t\t * Content-Type: application/octet-stream; name=\"\n\t\t\t\t * \"\n\t\t\t\t * Content-Transfer-Encoding: base64\n\t\t\t\t * Content-Disposition: attachment; filename=\"\n\t\t\t\t * \"\n\t\t\t\t *\n\t\t\t\t * TODO: the file should still be saved and\n\t\t\t\t * virus checked\n\t\t\t\t */\n\t\t\t\tcli_dbgmsg(\"Can't parse header \\\"%s\\\" - if you believe this file contains a virus, submit it to www.clamav.net\\n\", s);\n\t\t\t\tif(data)\n\t\t\t\t\tfree(data);\n\t\t\t\tfree(kcopy);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t*ptr = '\\0';\n\n            datasz = strlen(kcopy) + strlen(data) + 2;\n\t\t\tfield = cli_realloc(kcopy, strlen(kcopy) + strlen(data) + 2);\n\t\t\tif(field) {\n                cli_strlcat(field, \"=\", datasz);\n                cli_strlcat(field, data, datasz);\n\t\t\t} else {\n\t\t\t\tfree(kcopy);\n            }\n\t\t\tfree(data);\n\t\t} else {\n\t\t\tsize_t len;\n\n\t\t\tif(*cptr == '\\0') {\n\t\t\t\tcli_dbgmsg(\"Ignoring empty field in \\\"%s\\\"\\n\", s);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The field is not in quotes, so look for the closing\n\t\t\t * white space\n\t\t\t */\n\t\t\twhile((*string != '\\0') && !isspace(*string))\n\t\t\t\tstring++;\n\n\t\t\tlen = (size_t)string - (size_t)key + 1;\n\t\t\tfield = cli_malloc(len);\n\n\t\t\tif(field) {\n\t\t\t\tmemcpy(field, key, len - 1);\n\t\t\t\tfield[len - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t\tif(field) {\n\t\t\tmessageAddArgument(m, field);\n\t\t\tfree(field);\n\t\t}\n\t}\n}\n\nstatic const char *\nmessageGetArgument(const message *m, int arg)\n{\n\tassert(m != NULL);\n\tassert(arg >= 0);\n\tassert(arg < m->numberOfArguments);\n\n\treturn (m->mimeArguments[arg]) ? m->mimeArguments[arg] : \"\";\n}\n\n/*\n * Find a MIME variable from the header and return a COPY to the value of that\n * variable. The caller must free the copy\n */\nchar *\nmessageFindArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\n\tlen = strlen(variable);\n\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageFindArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif((*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n\t\t\t\t/* Remove any quote characters */\n\t\t\t\tchar *ret = cli_strdup(++ptr);\n\t\t\t\tchar *p;\n\n\t\t\t\tif(ret == NULL)\n\t\t\t\t\treturn NULL;\n\n\t\t\t\t/*\n\t\t\t\t * fix un-quoting of boundary strings from\n\t\t\t\t * header, occurs if boundary was given as\n\t\t\t\t *\t'boundary=\"_Test_\";'\n\t\t\t\t *\n\t\t\t\t * At least two quotes in string, assume\n\t\t\t\t * quoted argument\n\t\t\t\t * end string at next quote\n\t\t\t\t */\n\t\t\t\tif((p = strchr(ret, '\"')) != NULL) {\n\t\t\t\t\tret[strlen(ret) - 1] = '\\0';\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn cli_strdup(ptr);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nchar *\nmessageGetFilename(const message *m)\n{\n\tchar *filename = (char *)messageFindArgument(m, \"filename\");\n\n\tif(filename)\n\t\treturn filename;\n\n\treturn (char *)messageFindArgument(m, \"name\");\n}\n\n/* Returns true or false */\nstatic int\nmessageHasArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\n\tlen = strlen(variable);\n\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageHasArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageHasArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nmessageHasFilename(const message *m)\n{\n\treturn messageHasArgument(m, \"filename\") || messageHasArgument(m, \"file\");\n}\n\nvoid\nmessageSetEncoding(message *m, const char *enctype)\n{\n\tconst struct encoding_map *e;\n\tint i;\n\tchar *type;\n\n\tassert(m != NULL);\n\tassert(enctype != NULL);\n\n\t/*m->encodingType = EEXTENSION;*/\n\n\twhile(isblank(*enctype))\n\t\tenctype++;\n\n\tcli_dbgmsg(\"messageSetEncoding: '%s'\\n\", enctype);\n\n\tif(strcasecmp(enctype, \"8 bit\") == 0) {\n\t\tcli_dbgmsg(\"Broken content-transfer-encoding: '8 bit' changed to '8bit'\\n\");\n\t\tenctype = \"8bit\";\n\t}\n\n\t/*\n\t * Iterate through\n\t *\tContent-Transfer-Encoding: base64 binary\n\t * cli_strtok's fieldno counts from 0\n\t */\n\ti = 0;\n\twhile((type = cli_strtok(enctype, i++, \" \\t\")) != NULL) {\n\t\tint highestSimil = 0;\n\t\tconst char *closest = NULL;\n\n\t\tfor(e = encoding_map; e->string; e++) {\n\t\t\tint sim;\n\t\t\tconst char lowertype = tolower(type[0]);\n\n\t\t\tif((lowertype != tolower(e->string[0])) && (lowertype != 'x'))\n\t\t\t\t/*\n\t\t\t\t * simil is expensive, I'm yet to encounter only\n\t\t\t\t * one example of a missent encoding when the\n\t\t\t\t * first character was wrong, so lets assume no\n\t\t\t\t * match to save the call.\n\t\t\t\t *\n\t\t\t\t * That example was quoted-printable sent as\n\t\t\t\t * X-quoted-printable.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\n\t\t\tif(strcmp(e->string, \"uuencode\") == 0)\n\t\t\t\t/*\n\t\t\t\t * No need to test here - fast track visa will have\n\t\t\t\t * handled uuencoded files\n\t\t\t\t */\n\t\t\t\tcontinue;\n\n\t\t\tsim = simil(type, e->string);\n\n\t\t\tif(sim == 100) {\n\t\t\t\tint j;\n\t\t\t\tencoding_type *et;\n\n\t\t\t\tfor(j = 0; j < m->numberOfEncTypes; j++)\n\t\t\t\t\tif(m->encodingTypes[j] == e->type)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif(j < m->numberOfEncTypes) {\n\t\t\t\t\tcli_dbgmsg(\"Ignoring duplicate encoding mechanism '%s'\\n\",\n\t\t\t\t\t\ttype);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tet = (encoding_type *)cli_realloc(m->encodingTypes, (m->numberOfEncTypes + 1) * sizeof(encoding_type));\n\t\t\t\tif(et == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tm->encodingTypes = et;\n\t\t\t\tm->encodingTypes[m->numberOfEncTypes++] = e->type;\n\n\t\t\t\tcli_dbgmsg(\"Encoding type %d is \\\"%s\\\"\\n\", m->numberOfEncTypes, type);\n\t\t\t\tbreak;\n\t\t\t} else if(sim > highestSimil) {\n\t\t\t\tclosest = e->string;\n\t\t\t\thighestSimil = sim;\n\t\t\t}\n\t\t}\n\n\t\tif(e->string == NULL) {\n\t\t\t/*\n\t\t\t * The stated encoding type is illegal, so we\n\t\t\t * use a best guess of what it should be.\n\t\t\t *\n\t\t\t * 50% is arbitary. For example 7bi will match as\n\t\t\t * 66% certain to be 7bit\n\t\t\t */\n\t\t\tif(highestSimil >= 50) {\n\t\t\t\tcli_dbgmsg(\"Unknown encoding type \\\"%s\\\" - guessing as %s (%u%% certainty)\\n\",\n\t\t\t\t\ttype, closest, highestSimil);\n\t\t\t\tmessageSetEncoding(m, closest);\n\t\t\t} else {\n\t\t\t\tcli_dbgmsg(\"Unknown encoding type \\\"%s\\\" - if you believe this file contains a virus, submit it to www.clamav.net\\n\", type);\n\t\t\t\t/*\n\t\t\t\t * Err on the side of safety, enable all\n\t\t\t\t * decoding modules\n\t\t\t\t */\n\t\t\t\tmessageSetEncoding(m, \"base64\");\n\t\t\t\tmessageSetEncoding(m, \"quoted-printable\");\n\t\t\t}\n\t\t}\n\n\t\tfree(type);\n\t}\n}\n\nencoding_type\nmessageGetEncoding(const message *m)\n{\n\tassert(m != NULL);\n\n\tif(m->numberOfEncTypes == 0)\n\t\treturn NOENCODING;\n\treturn m->encodingTypes[0];\n}\n\nint\nmessageAddLine(message *m, line_t *line)\n{\n\tassert(m != NULL);\n\n\tif(m->body_first == NULL)\n\t\tm->body_last = m->body_first = (text *)cli_malloc(sizeof(text));\n\telse {\n\t\tm->body_last->t_next = (text *)cli_malloc(sizeof(text));\n\t\tm->body_last = m->body_last->t_next;\n\t}\n\n\tif(m->body_last == NULL) {\n        cli_errmsg(\"messageAddLine: out of memory for m->body_last\\n\");\n\t\treturn -1;\n    }\n\n\tm->body_last->t_next = NULL;\n\n\tif(line && lineGetData(line)) {\n\t\tm->body_last->t_line = lineLink(line);\n\n\t\tmessageIsEncoding(m);\n\t} else\n\t\tm->body_last->t_line = NULL;\n\n\treturn 1;\n}\n\n/*\n * Add the given line to the end of the given message\n * If needed a copy of the given line is taken which the caller must free\n * Line must not be terminated by a \\n\n */\nint\nmessageAddStr(message *m, const char *data)\n{\n\tline_t *repeat = NULL;\n\n\tassert(m != NULL);\n\n\tif(data) {\n\t\tif(*data == '\\0')\n\t\t\tdata = NULL;\n\t\telse {\n\t\t\t/*\n\t\t\t * If it's only white space, just store one space to\n\t\t\t * save memory. You must store something since it may\n\t\t\t * be a header line\n\t\t\t */\n\t\t\tint iswhite = 1;\n\t\t\tconst char *p;\n\n\t\t\tfor(p = data; *p; p++)\n\t\t\t\tif(((*p) & 0x80) || !isspace(*p)) {\n\t\t\t\t\tiswhite = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(iswhite) {\n\t\t\t\t/*cli_dbgmsg(\"messageAddStr: empty line: '%s'\\n\", data);*/\n\t\t\t\tdata = \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\tif(m->body_first == NULL)\n\t\tm->body_last = m->body_first = (text *)cli_malloc(sizeof(text));\n\telse {\n\t\tassert(m->body_last != NULL);\n\t\tif((data == NULL) && (m->body_last->t_line == NULL))\n\t\t\t/*\n\t\t\t * Although this would save time and RAM, some\n\t\t\t * phish signatures have been built which need the\n\t\t\t * blank lines\n\t\t\t */\n\t\t\tif(messageGetMimeType(m) != TEXT)\n\t\t\t\t/* don't save two blank lines in sucession */\n\t\t\t\treturn 1;\n\n\t\tm->body_last->t_next = (text *)cli_malloc(sizeof(text));\n\t\tif(m->body_last->t_next == NULL) {\n\t\t\tmessageDedup(m);\n\t\t\tm->body_last->t_next = (text *)cli_malloc(sizeof(text));\n\t\t\tif(m->body_last->t_next == NULL) {\n\t\t\t\tcli_errmsg(\"messageAddStr: out of memory\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif(data && m->body_last->t_line && (strcmp(data, lineGetData(m->body_last->t_line)) == 0))\n\t\t\trepeat = m->body_last->t_line;\n\t\tm->body_last = m->body_last->t_next;\n\t}\n\n\tif(m->body_last == NULL) {\n\t\tcli_errmsg(\"messageAddStr: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tm->body_last->t_next = NULL;\n\n\tif(data && *data) {\n\t\tif(repeat)\n\t\t\tm->body_last->t_line = lineLink(repeat);\n\t\telse {\n\t\t\tm->body_last->t_line = lineCreate(data);\n\n\t\t\tif(m->body_last->t_line == NULL) {\n\t\t\t\tmessageDedup(m);\n\t\t\t\tm->body_last->t_line = lineCreate(data);\n\n\t\t\t\tif(m->body_last->t_line == NULL) {\n\t\t\t\t\tcli_errmsg(\"messageAddStr: out of memory\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* cli_chomp(m->body_last->t_text); */\n\t\t\tmessageIsEncoding(m);\n\t\t}\n\t} else\n\t\tm->body_last->t_line = NULL;\n\n\treturn 1;\n}\n\n/*\n * Add the given line to the start of the given message\n * A copy of the given line is taken which the caller must free\n * Line must not be terminated by a \\n\n */\nint\nmessageAddStrAtTop(message *m, const char *data)\n{\n\ttext *oldfirst;\n\n\tassert(m != NULL);\n\n\tif(m->body_first == NULL)\n\t\treturn messageAddLine(m, lineCreate(data));\n\n\toldfirst = m->body_first;\n\tm->body_first = (text *)cli_malloc(sizeof(text));\n\tif(m->body_first == NULL) {\n\t\tm->body_first = oldfirst;\n\t\treturn -1;\n\t}\n\n\tm->body_first->t_next = oldfirst;\n\tm->body_first->t_line = lineCreate((data) ? data : \"\");\n\n\tif(m->body_first->t_line == NULL) {\n\t\tcli_errmsg(\"messageAddStrAtTop: out of memory\\n\");\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n/*\n * Put the contents of the given text at the end of the current object.\n * Can be used either to move a text object into a message, or to move a\n * message's text into another message only moving from a given offset.\n * The given text emptied; it can be used again if needed, though be warned that\n * it will have an empty line at the start.\n * Returns 0 for failure, 1 for success\n */\nint\nmessageMoveText(message *m, text *t, message *old_message)\n{\n\tint rc;\n\n\tif(m->body_first == NULL) {\n\t\tif(old_message) {\n\t\t\ttext *u;\n\t\t\t/*\n\t\t\t * t is within old_message which is about to be\n\t\t\t * destroyed\n\t\t\t */\n\t\t\tassert(old_message->body_first != NULL);\n\n\t\t\tm->body_first = t;\n\t\t\tfor(u = old_message->body_first; u != t;) {\n\t\t\t\ttext *next;\n\n\t\t\t\tif(u->t_line)\n\t\t\t\t\tlineUnlink(u->t_line);\n\t\t\t\tnext = u->t_next;\n\n\t\t\t\tfree(u);\n\t\t\t\tu = next;\n\n\t\t\t\tif(u == NULL) {\n\t\t\t\t\tcli_dbgmsg(\"messageMoveText sanity check: t not within old_message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(old_message->body_last->t_next == NULL);\n\n\t\t\tm->body_last = old_message->body_last;\n\t\t\told_message->body_first = old_message->body_last = NULL;\n\n\t\t\t/* Do any pointers need to be reset? */\n\t\t\tif((old_message->bounce == NULL) &&\n\t\t\t   (old_message->encoding == NULL) &&\n\t\t\t   (old_message->binhex == NULL) &&\n\t\t\t   (old_message->yenc == NULL))\n\t\t\t\treturn 0;\n\n\t\t\tm->body_last = m->body_first;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tm->body_last = m->body_first = textMove(NULL, t);\n\t\t\tif(m->body_first == NULL)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\trc = 0;\n\t\t}\n\t} else {\n\t\tm->body_last = textMove(m->body_last, t);\n\t\tif(m->body_last == NULL) {\n\t\t\trc = -1;\n\t\t\tm->body_last = m->body_first;\n\t\t} else\n\t\t\trc = 0;\n\t}\n\n\twhile(m->body_last->t_next) {\n\t\tm->body_last = m->body_last->t_next;\n\t\tif(m->body_last->t_line)\n\t\t\tmessageIsEncoding(m);\n\t}\n\n\treturn rc;\n}\n\n/*\n * See if the last line marks the start of a non MIME inclusion that\n * will need to be scanned\n */\nstatic void\nmessageIsEncoding(message *m)\n{\n\tstatic const char encoding[] = \"Content-Transfer-Encoding\";\n\tstatic const char binhex[] = \"(This file must be converted with BinHex 4.0)\";\n\tconst char *line = lineGetData(m->body_last->t_line);\n\n\t/*if(m->ctx == NULL)\n\t\tcli_dbgmsg(\"messageIsEncoding, ctx == NULL\\n\");*/\n\n\tif((m->encoding == NULL) &&\n\t   (strncasecmp(line, encoding, sizeof(encoding) - 1) == 0) &&\n\t   (strstr(line, \"7bit\") == NULL))\n\t\tm->encoding = m->body_last;\n\telse if((m->bounce == NULL) && m->ctx &&\n\t\t(strncasecmp(line, \"Received: \", 10) == 0) &&\n\t\t(cli_filetype((const unsigned char *)line, strlen(line), m->ctx->engine) == CL_TYPE_MAIL))\n\t\t\tm->bounce = m->body_last;\n\t\t/* Not needed with fast track visa technology */\n\t/*else if((m->uuencode == NULL) && isuuencodebegin(line))\n\t\tm->uuencode = m->body_last;*/\n\telse if((m->binhex == NULL) &&\n\t\tstrstr(line, \"BinHex\") &&\n\t\t(simil(line, binhex) > 90))\n\t\t\t/*\n\t\t\t * Look for close matches for BinHex, but\n\t\t\t * simil() is expensive so only do it if it's\n\t\t\t * likely to be found\n\t\t\t */\n\t\t\tm->binhex = m->body_last;\n\telse if((m->yenc == NULL) && (strncmp(line, \"=ybegin line=\", 13) == 0))\n\t\tm->yenc = m->body_last;\n}\n\n/*\n * Returns a pointer to the body of the message. Note that it does NOT return\n * a copy of the data\n */\ntext *\nmessageGetBody(message *m)\n{\n\tassert(m != NULL);\n\treturn m->body_first;\n}\n\n/*\n * Export a message using the given export routines\n *\n * TODO: It really should export into an array, one\n * for each encoding algorithm. However, what it does is it returns the\n * last item that was exported. That's sufficient for now.\n */\nstatic void *\nmessageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), void (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void(*setCTX)(void *, cli_ctx *), int destroy_text)\n{\n\tvoid *ret;\n\ttext *t_line;\n\tchar *filename;\n\tint i;\n\n\tassert(m != NULL);\n\n\tif(messageGetBody(m) == NULL)\n\t\treturn NULL;\n\n\tret = (*create)();\n\n\tif(ret == NULL)\n\t\treturn NULL;\n\n\tcli_dbgmsg(\"messageExport: numberOfEncTypes == %d\\n\", m->numberOfEncTypes);\n\n\tif(m->numberOfEncTypes == 0) {\n\t\t/*\n\t\t * Fast copy\n\t\t */\n\t\tcli_dbgmsg(\"messageExport: Entering fast copy mode\\n\");\n\n#if\t0\n\t\tfilename = messageGetFilename(m);\n\n\t\tif(filename == NULL) {\n\t\t\tcli_dbgmsg(\"Unencoded attachment sent with no filename\\n\");\n\t\t\tmessageAddArgument(m, \"name=attachment\");\n\t\t} else if((strcmp(filename, \"textportion\") != 0) && (strcmp(filename, \"mixedtextportion\") != 0))\n\t\t\t/*\n\t\t\t * Some virus attachments don't say how they've\n\t\t\t * been encoded. We assume base64\n\t\t\t */\n\t\t\tmessageSetEncoding(m, \"base64\");\n#else\n\t\tfilename = (char *)messageFindArgument(m, \"filename\");\n\t\tif(filename == NULL) {\n\t\t\tfilename = (char *)messageFindArgument(m, \"name\");\n\n\t\t\tif(filename == NULL) {\n\t\t\t\tcli_dbgmsg(\"Unencoded attachment sent with no filename\\n\");\n\t\t\t\tmessageAddArgument(m, \"name=attachment\");\n\t\t\t} else\n\t\t\t\t/*\n\t\t\t\t * Some virus attachments don't say how they've\n\t\t\t\t * been encoded. We assume base64.\n\t\t\t\t * RFC says encoding should be 7-bit.\n\t\t\t\t */\n\t\t\t\tmessageSetEncoding(m, \"7-bit\");\n\t\t}\n#endif\n\n\t\t(*setFilename)(ret, dir, (filename && *filename) ? filename : \"attachment\");\n\n\t\tif(filename)\n\t\t\tfree((char *)filename);\n\n\t\tif(m->numberOfEncTypes == 0)\n\t\t\treturn exportText(messageGetBody(m), ret, destroy_text);\n\t}\n\n\tif(setCTX && m->ctx)\n\t\t(*setCTX)(ret, m->ctx);\n\n\tfor(i = 0; i < m->numberOfEncTypes; i++) {\n\t\tencoding_type enctype = m->encodingTypes[i];\n\t\tsize_t size;\n\n\t\tif(i > 0) {\n\t\t\tvoid *newret;\n\n\t\t\tnewret = (*create)();\n\t\t\tif(newret == NULL) {\n\t\t\t\tcli_dbgmsg(\"Not all decoding algorithms were run\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t(*destroy)(ret);\n\t\t\tret = newret;\n\t\t}\n\t\tcli_dbgmsg(\"messageExport: enctype %d is %d\\n\", i, (int)enctype);\n\t\t/*\n\t\t * Find the filename to decode\n\t\t */\n\t\tif(((enctype == YENCODE) || (i == 0)) && yEncBegin(m)) {\n\t\t\tconst char *f;\n\n\t\t\t/*\n\t\t\t * TODO: handle multipart yEnc encoded files\n\t\t\t */\n\t\t\tt_line = yEncBegin(m);\n\t\t\tf = lineGetData(t_line->t_line);\n\n\t\t\tif((filename = strstr(f, \" name=\")) != NULL) {\n\t\t\t\tfilename = cli_strdup(&filename[6]);\n\t\t\t\tif(filename) {\n\t\t\t\t\tcli_chomp(filename);\n\t\t\t\t\tstrstrip(filename);\n\t\t\t\t\tcli_dbgmsg(\"Set yEnc filename to \\\"%s\\\"\\n\", filename);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(*setFilename)(ret, dir, (filename && *filename) ? filename : \"attachment\");\n\t\t\tif(filename) {\n\t\t\t\tfree((char *)filename);\n\t\t\t\tfilename = NULL;\n\t\t\t}\n\t\t\tt_line = t_line->t_next;\n\t\t\tenctype = YENCODE;\n\t\t\tm->yenc = NULL;\n\t\t} else {\n\t\t\tif(enctype == UUENCODE) {\n\t\t\t\t/*\n\t\t\t\t * The body will have been stripped out by the\n\t\t\t\t * fast track visa system. Treat as plain/text,\n\t\t\t\t * which means we'll still scan for funnies\n\t\t\t\t * outside of the uuencoded portion.\n\t\t\t\t */\n\t\t\t\tcli_dbgmsg(\"messageExport: treat uuencode as text/plain\\n\");\n\t\t\t\tenctype = m->encodingTypes[i] = NOENCODING;\n\t\t\t}\n\t\t\tfilename = messageGetFilename(m);\n\n\t\t\tif(filename == NULL) {\n\t\t\t\tcli_dbgmsg(\"Attachment sent with no filename\\n\");\n\t\t\t\tmessageAddArgument(m, \"name=attachment\");\n\t\t\t} else if(enctype == NOENCODING)\n\t\t\t\t/*\n\t\t\t\t * Some virus attachments don't say how\n\t\t\t\t * they've been encoded. We assume\n\t\t\t\t * base64.\n\t\t\t\t *\n\t\t\t\t * FIXME: don't do this if it's a fall\n\t\t\t\t * through from uuencode\n\t\t\t\t */\n\t\t\t\tmessageSetEncoding(m, \"base64\");\n\n\t\t\t(*setFilename)(ret, dir, (filename && *filename) ? filename : \"attachment\");\n\n\t\t\tt_line = messageGetBody(m);\n\t\t}\n\n\t\tif(filename)\n\t\t\tfree((char *)filename);\n\n\t\t/*\n\t\t * t_line should now point to the first (encoded) line of the\n\t\t * message\n\t\t */\n\t\tif(t_line == NULL) {\n\t\t\tcli_dbgmsg(\"Empty attachment not saved\\n\");\n\t\t\t(*destroy)(ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(enctype == NOENCODING) {\n\t\t\t/*\n\t\t\t * Fast copy\n\t\t\t */\n\t\t\tif(i == m->numberOfEncTypes - 1) {\n\t\t\t\t/* last one */\n\t\t\t\t(void)exportText(t_line, ret, destroy_text);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(void)exportText(t_line, ret, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize = 0;\n\t\tdo {\n\t\t\tunsigned char smallbuf[1024];\n\t\t\tunsigned char *uptr, *data;\n\t\t\tconst char *line = lineGetData(t_line->t_line);\n\t\t\tunsigned char *bigbuf;\n\t\t\tsize_t datasize;\n\n\t\t\tif(enctype == YENCODE) {\n\t\t\t\tif(line == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(strncmp(line, \"=yend \", 6) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Add two bytes for '\\n' and '\\0'\n\t\t\t */\n\t\t\tdatasize = (line) ? strlen(line) + 2 : 0;\n\n\t\t\tif(datasize >= sizeof(smallbuf))\n\t\t\t\tdata = bigbuf = (unsigned char *)cli_malloc(datasize);\n\t\t\telse {\n\t\t\t\tbigbuf = NULL;\n\t\t\t\tdata = smallbuf;\n\t\t\t\tdatasize = sizeof(smallbuf);\n\t\t\t}\n\n\t\t\tuptr = decodeLine(m, enctype, line, data, datasize);\n\t\t\tif(uptr == NULL) {\n\t\t\t\tif(data == bigbuf)\n\t\t\t\t\tfree(data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(uptr != data) {\n\t\t\t\tassert((size_t)(uptr - data) < datasize);\n\t\t\t\t(*addData)(ret, data, (size_t)(uptr - data));\n\t\t\t\tsize += (size_t)(uptr - data);\n\t\t\t}\n\n\t\t\tif(data == bigbuf)\n\t\t\t\tfree(data);\n\n\t\t\t/*\n\t\t\t * According to RFC2045, '=' is used to pad out\n\t\t\t * the last byte and should be used as evidence\n\t\t\t * of the end of the data. Some mail clients\n\t\t\t * annoyingly then put plain text after the '='\n\t\t\t * byte and viruses exploit this bug. Sigh\n\t\t\t */\n\t\t\t/*if(enctype == BASE64)\n\t\t\t\tif(strchr(line, '='))\n\t\t\t\t\tbreak;*/\n\t\t\tif(line && destroy_text && (i == m->numberOfEncTypes - 1)) {\n\t\t\t\tlineUnlink(t_line->t_line);\n\t\t\t\tt_line->t_line = NULL;\n\t\t\t}\n\t\t} while((t_line = t_line->t_next) != NULL);\n\n\t\tcli_dbgmsg(\"Exported %lu bytes using enctype %d\\n\",\n\t\t\t(unsigned long)size, (int)enctype);\n\n\t\t/* Verify we have nothing left to flush out */\n\t\tif(m->base64chars) {\n\t\t\tunsigned char data[4];\n\t\t\tunsigned char *ptr;\n\n\t\t\tptr = base64Flush(m, data);\n\t\t\tif(ptr)\n\t\t\t\t(*addData)(ret, data, (size_t)(ptr - data));\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nunsigned char *\nbase64Flush(message *m, unsigned char *buf)\n{\n\tcli_dbgmsg(\"%d trailing bytes to export\\n\", m->base64chars);\n\n\tif(m->base64chars) {\n\t\tunsigned char *ret = decode(m, NULL, buf, base64, FALSE);\n\n\t\tm->base64chars = 0;\n\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nint messageSavePartial(message *m, const char *dir, const char *md5id, unsigned part)\n{\n\tchar fullname[1024];\n\tfileblob *fb;\n\tunsigned long time_val;\n\n\tcli_dbgmsg(\"messageSavePartial\\n\");\n\ttime_val  = time(NULL);\n\tsnprintf(fullname, 1024, \"%s\"PATHSEP\"clamav-partial-%lu_%s-%u\", dir, time_val, md5id, part);\n\n\tfb = messageExport(m, fullname,\n\t\t(void *(*)(void))fileblobCreate,\n\t\t(void(*)(void *))fileblobDestroy,\n\t\t(void(*)(void *, const char *, const char *))fileblobPartialSet,\n\t\t(void(*)(void *, const unsigned char *, size_t))fileblobAddData,\n\t\t(void *(*)(text *, void *, int))textToFileblob,\n\t\t(void(*)(void *, cli_ctx *))fileblobSetCTX,\n\t\t0);\n\tif(!fb)\n\t\treturn CL_EFORMAT;\n\tfileblobDestroy(fb);\n\treturn CL_SUCCESS;\n}\n\n/*\n * Decode and transfer the contents of the message into a fileblob\n * The caller must free the returned fileblob\n */\nfileblob *\nmessageToFileblob(message *m, const char *dir, int destroy)\n{\n\tfileblob *fb;\n\n\tcli_dbgmsg(\"messageToFileblob\\n\");\n\tfb = messageExport(m, dir,\n\t\t(void *(*)(void))fileblobCreate,\n\t\t(void(*)(void *))fileblobDestroy,\n\t\t(void(*)(void *, const char *, const char *))fileblobSetFilename,\n\t\t(void(*)(void *, const unsigned char *, size_t))fileblobAddData,\n\t\t(void *(*)(text *, void *, int))textToFileblob,\n\t\t(void(*)(void *, cli_ctx *))fileblobSetCTX,\n\t\tdestroy);\n\tif(destroy && m->body_first) {\n\t\ttextDestroy(m->body_first);\n\t\tm->body_first = m->body_last = NULL;\n\t}\n\treturn fb;\n}\n\n/*\n * Decode and transfer the contents of the message into a closed blob\n * The caller must free the returned blob\n */\nblob *\nmessageToBlob(message *m, int destroy)\n{\n\tblob *b;\n\n\tcli_dbgmsg(\"messageToBlob\\n\");\n\n\tb = messageExport(m, NULL,\n\t\t(void *(*)(void))blobCreate,\n\t\t(void(*)(void *))blobDestroy,\n\t\t(void(*)(void *, const char *, const char *))blobSetFilename,\n\t\t(void(*)(void *, const unsigned char *, size_t))blobAddData,\n\t\t(void *(*)(text *, void *, int))textToBlob,\n\t\t(void(*)(void *, cli_ctx *))NULL,\n\t\tdestroy);\n\n\tif(destroy && m->body_first) {\n\t\ttextDestroy(m->body_first);\n\t\tm->body_first = m->body_last = NULL;\n\t}\n\treturn b;\n}\n\n/*\n * Decode and transfer the contents of the message into a text area\n * The caller must free the returned text\n */\ntext *\nmessageToText(message *m)\n{\n\tint i;\n\ttext *first = NULL, *last = NULL;\n\tconst text *t_line;\n\n\tassert(m != NULL);\n\n\tif(m->numberOfEncTypes == 0) {\n\t\t/*\n\t\t * Fast copy\n\t\t */\n\t\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next) {\n\t\t\tif(first == NULL)\n\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\telse {\n\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\tlast = last->t_next;\n\t\t\t}\n\n\t\t\tif(last == NULL) {\n\t\t\t\tif(first)\n\t\t\t\t\ttextDestroy(first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif(t_line->t_line)\n\t\t\t\tlast->t_line = lineLink(t_line->t_line);\n\t\t\telse\n\t\t\t\tlast->t_line = NULL;\t/* empty line */\n\t\t}\n\t\tif(last)\n\t\t\tlast->t_next = NULL;\n\n\t\treturn first;\n\t}\n\t/*\n\t * Scan over the data a number of times once for each claimed encoding\n\t * type\n\t */\n\tfor(i = 0; i < m->numberOfEncTypes; i++) {\n\t\tconst encoding_type enctype = m->encodingTypes[i];\n\n\t\tcli_dbgmsg(\"messageToText: export transfer method %d = %d\\n\",\n\t\t\ti, (int)enctype);\n\n\t\tswitch(enctype) {\n\t\t\tcase NOENCODING:\n\t\t\tcase BINARY:\n\t\t\tcase EIGHTBIT:\n\t\t\t\t/*\n\t\t\t\t * Fast copy\n\t\t\t\t */\n\t\t\t\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next) {\n\t\t\t\t\tif(first == NULL)\n\t\t\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\t\t\telse if (last) {\n\t\t\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\t\t\tlast = last->t_next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(last == NULL) {\n\t\t\t\t\t\tif(first) {\n\t\t\t\t\t\t\ttextDestroy(first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(t_line->t_line)\n\t\t\t\t\t\tlast->t_line = lineLink(t_line->t_line);\n\t\t\t\t\telse\n\t\t\t\t\t\tlast->t_line = NULL;\t/* empty line */\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase UUENCODE:\n\t\t\t\tcli_warnmsg(\"messageToText: Unexpected attempt to handle uuencoded file\\n\");\n\t\t\t\tif(first) {\n\t\t\t\t\tif(last)\n\t\t\t\t\t\tlast->t_next = NULL;\n\t\t\t\t\ttextDestroy(first);\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\tcase YENCODE:\n\t\t\t\tt_line = yEncBegin(m);\n\n\t\t\t\tif(t_line == NULL) {\n\t\t\t\t\t/*cli_warnmsg(\"YENCODED attachment is missing begin statement\\n\");*/\n\t\t\t\t\tif(first) {\n\t\t\t\t\t\tif(last)\n\t\t\t\t\t\t\tlast->t_next = NULL;\n\t\t\t\t\t\ttextDestroy(first);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tt_line = t_line->t_next;\n\t\t\tdefault:\n\t\t\t\tif((i == 0) && binhexBegin(m))\n\t\t\t\t\tcli_warnmsg(\"Binhex messages not supported yet.\\n\");\n\t\t\t\tt_line = messageGetBody(m);\n\t\t}\n\n\t\tfor(; t_line; t_line = t_line->t_next) {\n\t\t\tunsigned char data[1024];\n\t\t\tunsigned char *uptr;\n\t\t\tconst char *line = lineGetData(t_line->t_line);\n\n\t\t\tif(enctype == BASE64)\n\t\t\t\t/*\n\t\t\t\t * ignore blanks - breaks RFC which is\n\t\t\t\t * probably the point!\n\t\t\t\t */\n\t\t\t\tif(line == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\tassert((line == NULL) || (strlen(line) <= sizeof(data)));\n\n\t\t\tuptr = decodeLine(m, enctype, line, data, sizeof(data));\n\n\t\t\tif(uptr == NULL)\n\t\t\t\tbreak;\n\n\t\t\tassert(uptr <= &data[sizeof(data)]);\n\n\t\t\tif(first == NULL)\n\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\telse if (last) {\n\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\tlast = last->t_next;\n\t\t\t}\n\n\t\t\tif(last == NULL)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the decoded line is the same as the encoded\n\t\t\t * there's no need to take a copy, just link it.\n\t\t\t * Note that the comparison is done without the\n\t\t\t * trailing newline that the decoding routine may have\n\t\t\t * added - that's why there's a strncmp rather than a\n\t\t\t * strcmp - that'd be bad for MIME decoders, but is OK\n\t\t\t * for AV software\n\t\t\t */\n\t\t\tif((data[0] == '\\n') || (data[0] == '\\0'))\n\t\t\t\tlast->t_line = NULL;\n\t\t\telse if(line && (strncmp((const char *)data, line, strlen(line)) == 0)) {\n#ifdef\tCL_DEBUG\n\t\t\t\tcli_dbgmsg(\"messageToText: decoded line is the same(%s)\\n\", data);\n#endif\n\t\t\t\tlast->t_line = lineLink(t_line->t_line);\n\t\t\t} else\n\t\t\t\tlast->t_line = lineCreate((char *)data);\n\n\t\t\tif(line && enctype == BASE64)\n\t\t\t\tif(strchr(line, '='))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif(m->base64chars) {\n\t\t\tunsigned char data[4];\n\n\t\t\tmemset(data, '\\0', sizeof(data));\n\t\t\tif(decode(m, NULL, data, base64, FALSE) && data[0]) {\n\t\t\t\tif(first == NULL)\n\t\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\t\telse if (last) {\n\t\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\t\tlast = last->t_next;\n\t\t\t\t}\n\n\t\t\t\tif(last != NULL)\n\t\t\t\t\tlast->t_line = lineCreate((char *)data);\n\t\t\t}\n\t\t\tm->base64chars = 0;\n\t\t}\n\t}\n\n\tif(last)\n\t\tlast->t_next = NULL;\n\n\treturn first;\n}\n\ntext *\nyEncBegin(message *m)\n{\n\treturn m->yenc;\n}\n\n/*\n * Scan to find the BINHEX message (if any)\n */\n#if\t0\nconst text *\nbinhexBegin(message *m)\n{\n\tconst text *t_line;\n\n\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)\n\t\tif(strcasecmp(t_line->t_text, \"(This file must be converted with BinHex 4.0)\") == 0)\n\t\t\treturn t_line;\n\n\treturn NULL;\n}\n#else\ntext *\nbinhexBegin(message *m)\n{\n\treturn m->binhex;\n}\n#endif\n\n/*\n * Scan to find a bounce message. There is no standard for these, not\n * even a convention, so don't expect this to be foolproof\n */\n#if\t0\ntext *\nbounceBegin(message *m)\n{\n\tconst text *t_line;\n\n\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)\n\t\tif(cli_filetype(t_line->t_text, strlen(t_line->t_text)) == CL_TYPE_MAIL)\n\t\t\treturn t_line;\n\n\treturn NULL;\n}\n#else\ntext *\nbounceBegin(message *m)\n{\n\treturn m->bounce;\n}\n#endif\n\n/*\n * If a message doesn't not contain another message which could be harmful\n * it is deemed to be safe.\n *\n * TODO: ensure nothing can get through this\n *\n * TODO: check to see if we need to\n * find anything else, perhaps anything\n * from the RFC821 table?\n */\n#if\t0\nint\nmessageIsAllText(const message *m)\n{\n\tconst text *t;\n\n\tfor(t = messageGetBody(m); t; t = t->t_next)\n\t\tif(strncasecmp(t->t_text,\n\t\t\t\"Content-Transfer-Encoding\",\n\t\t\tstrlen(\"Content-Transfer-Encoding\")) == 0)\n\t\t\t\treturn 0;\n\n\treturn 1;\n}\n#else\ntext *\nencodingLine(message *m)\n{\n\treturn m->encoding;\n}\n#endif\n\n/*\n * Decode a line and add it to a buffer, return the end of the buffer\n * to help appending callers. There is no new line at the end of \"line\"\n *\n * len is sizeof(ptr)\n */\nunsigned char *\ndecodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, size_t buflen)\n{\n\tsize_t len, reallen;\n\tbool softbreak;\n\tchar *p2, *copy;\n\tchar base64buf[RFC2045LENGTH + 1];\n\n\t/*cli_dbgmsg(\"decodeLine(et = %d buflen = %u)\\n\", (int)et, buflen);*/\n\n\tassert(m != NULL);\n\tassert(buf != NULL);\n\n\tswitch(et) {\n\t\tcase BINARY:\n\t\t\t/*\n\t\t\t * TODO: find out what this is, encoded as binary??\n\t\t\t */\n\t\t\t/* fall through */\n\t\tcase NOENCODING:\n\t\tcase EIGHTBIT:\n\t\tdefault:\t/* unknown encoding type - try our best */\n\t\t\tif(line)\t/* empty line? */\n\t\t\t\tbuf = (unsigned char *)cli_strrcpy((char *)buf, line);\n\t\t\t/* Put the new line back in */\n\t\t\treturn (unsigned char *)cli_strrcpy((char *)buf, \"\\n\");\n\n\t\tcase QUOTEDPRINTABLE:\n\t\t\tif(line == NULL) {\t/* empty line */\n\t\t\t\t*buf++ = '\\n';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsoftbreak = FALSE;\n\t\t\twhile(buflen && *line) {\n\t\t\t\tif(*line == '=') {\n\t\t\t\t\tunsigned char byte;\n\n\t\t\t\t\tif((*++line == '\\0') || (*line == '\\n')) {\n\t\t\t\t\t\tsoftbreak = TRUE;\n\t\t\t\t\t\t/* soft line break */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbyte = hex(*line);\n\n\t\t\t\t\tif((*++line == '\\0') || (*line == '\\n')) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * broken e-mail, not\n\t\t\t\t\t\t * adhering to RFC2045\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*buf++ = byte;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Handle messages that use a broken\n\t\t\t\t\t * quoted-printable encoding of\n\t\t\t\t\t * href=\\\"http://, instead of =3D\n\t\t\t\t\t */\n\t\t\t\t\tif(byte != '=')\n\t\t\t\t\t\tbyte = (byte << 4) | hex(*line);\n\t\t\t\t\telse\n\t\t\t\t\t\tline -= 2;\n\n\t\t\t\t\t*buf++ = byte;\n\t\t\t\t} else\n\t\t\t\t\t*buf++ = *line;\n\t\t\t\t++line;\n\t\t\t\t--buflen;\n\t\t\t}\n\t\t\tif(!softbreak)\n\t\t\t\t/* Put the new line back in */\n\t\t\t\t*buf++ = '\\n';\n\t\t\tbreak;\n\n\t\tcase BASE64:\n\t\t\tif(line == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * RFC2045 sets the maximum length to 76 bytes\n\t\t\t * but many e-mail clients ignore that\n\t\t\t */\n\t\t\tif(strlen(line) < sizeof(base64buf)) {\n\t\t\t\tstrcpy(base64buf, line);\n\t\t\t\tcopy = base64buf;\n\t\t\t} else {\n\t\t\t\tcopy = cli_strdup(line);\n\t\t\t\tif(copy == NULL)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp2 = strchr(copy, '=');\n\t\t\tif(p2)\n\t\t\t\t*p2 = '\\0';\n\n\t\t\tsanitiseBase64(copy);\n\n\t\t\t/*\n\t\t\t * Klez doesn't always put \"=\" on the last line\n\t\t\t */\n\t\t\tbuf = decode(m, copy, buf, base64, (p2 == NULL) && ((strlen(copy) & 3) == 0));\n\n\t\t\tif(copy != base64buf)\n\t\t\t\tfree(copy);\n\t\t\tbreak;\n\n\t\tcase UUENCODE:\n\t\t\tassert(m->base64chars == 0);\n\n\t\t\tif((line == NULL) || (*line == '\\0'))\t/* empty line */\n\t\t\t\tbreak;\n\t\t\tif(strcasecmp(line, \"end\") == 0)\n\t\t\t\tbreak;\n\t\t\tif(isuuencodebegin(line))\n\t\t\t\tbreak;\n\n\t\t\tif((line[0] & 0x3F) == ' ')\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * reallen contains the number of bytes that were\n\t\t\t *\tencoded\n\t\t\t */\n\t\t\treallen = (size_t)uudecode(*line++);\n\t\t\tif(reallen <= 0)\n\t\t\t\tbreak;\n\t\t\tif(reallen > 62)\n\t\t\t\tbreak;\n\t\t\tlen = strlen(line);\n\n\t\t\tif((len > buflen) || (reallen > len))\n\t\t\t\t/*\n\t\t\t\t * In practice this should never occur since\n\t\t\t\t * the maximum length of a uuencoded line is\n\t\t\t\t * 62 characters\n\t\t\t\t */\n\t\t\t\tcli_dbgmsg(\"uudecode: buffer overflow stopped, attempting to ignore but decoding may fail\\n\");\n\t\t\telse {\n\t\t\t\t(void)decode(m, line, buf, uudecode, (len & 3) == 0);\n\t\t\t\tbuf = &buf[reallen];\n\t\t\t}\n\t\t\tm->base64chars = 0;\t/* this happens with broken uuencoded files */\n\t\t\tbreak;\n\t\tcase YENCODE:\n\t\t\tif((line == NULL) || (*line == '\\0'))\t/* empty line */\n\t\t\t\tbreak;\n\t\t\tif(strncmp(line, \"=yend \", 6) == 0)\n\t\t\t\tbreak;\n\n\t\t\twhile(*line)\n\t\t\t\tif(*line == '=') {\n\t\t\t\t\tif(*++line == '\\0')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*buf++ = ((*line++ - 64) & 255);\n\t\t\t\t} else\n\t\t\t\t\t*buf++ = ((*line++ - 42) & 255);\n\t\t\tbreak;\n\t}\n\n\t*buf = '\\0';\n\treturn buf;\n}\n\n/*\n * Remove the non base64 characters such as spaces from a string. Spaces\n * shouldn't appear mid string in base64 files, but some broken mail clients\n * ignore such errors rather than discarding the mail, and virus writers\n * exploit this bug\n */\nstatic void\nsanitiseBase64(char *s)\n{\n\tcli_dbgmsg(\"sanitiseBase64 '%s'\\n\", s);\n\twhile(*s)\n\t\tif(base64Table[(unsigned int)(*s & 0xFF)] == 255) {\n\t\t\tchar *p1;\n\n\t\t\tfor(p1 = s; p1[0] != '\\0'; p1++)\n\t\t\t\tp1[0] = p1[1];\n\t\t} else\n\t\t\ts++;\n}\n\n/*\n * Returns one byte after the end of the decoded data in \"out\"\n *\n * Update m->base64chars with the last few bytes of data that we haven't\n * decoded. After the last line is found, decode will be called with in = NULL\n * to flush these out\n */\nstatic unsigned char *\ndecode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(char), bool isFast)\n{\n\tunsigned char b1, b2, b3, b4;\n\tunsigned char cb1, cb2, cb3;\t/* carried over from last line */\n\n\t/*cli_dbgmsg(\"decode %s (len %d isFast %d base64chars %d)\\n\", in,\n\t\tin ? strlen(in) : 0,\n\t\tisFast, m->base64chars);*/\n\n\tcb1 = cb2 = cb3 = '\\0';\n\n\tswitch(m->base64chars) {\n\t\tcase 3:\n\t\t\tcb3 = m->base64_3;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tcb2 = m->base64_2;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tcb1 = m->base64_1;\n\t\t\tisFast = FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(m->base64chars <= 3);\n\t}\n\n\tif(isFast)\n\t\t/* Fast decoding if not last line */\n\t\twhile(*in) {\n\t\t\tb1 = (*decoder)(*in++);\n\t\t\tb2 = (*decoder)(*in++);\n\t\t\tb3 = (*decoder)(*in++);\n\t\t\t/*\n\t\t\t * Put this line here to help on some compilers which\n\t\t\t * can make use of some architecure's ability to\n\t\t\t * multiprocess when different variables can be\n\t\t\t * updated at the same time - here b3 is used in\n\t\t\t * one line, b1/b2 in the next and b4 in the next after\n\t\t\t * that, b3 and b4 rely on in but b1/b2 don't\n\t\t\t */\n\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\tb4 = (*decoder)(*in++);\n\t\t\t*out++ = (b2 << 4) | ((b3 >> 2) & 0xF);\n\t\t\t*out++ = (b3 << 6) | (b4 & 0x3F);\n\t\t}\n\telse if(in == NULL) {\t/* flush */\n\t\tint nbytes;\n\n\t\tif(m->base64chars == 0)\n\t\t\treturn out;\n\n\t\tcli_dbgmsg(\"base64chars = %d (%c %c %c)\\n\", m->base64chars,\n\t\t\tisalnum(cb1) ? cb1 : '@',\n\t\t\tisalnum(cb2) ? cb2 : '@',\n\t\t\tisalnum(cb3) ? cb3 : '@');\n\n\t\tm->base64chars--;\n\t\tb1 = cb1;\n\t\tnbytes = 1;\n\n\t\tif(m->base64chars) {\n\t\t\tm->base64chars--;\n\t\t\tb2 = cb2;\n\n\t\t\tif(m->base64chars) {\n\t\t\t\tnbytes = 2;\n\t\t\t\tm->base64chars--;\n\t\t\t\tb3 = cb3;\n\t\t\t\tnbytes = 3;\n\t\t\t} else if(b2)\n\t\t\t\tnbytes = 2;\n\t\t}\n\n\t\tswitch(nbytes) {\n\t\t\tcase 3:\n\t\t\t\tb4 = '\\0';\n\t\t\t\t/* fall through */\n\t\t\tcase 4:\n\t\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\t\t*out++ = (b2 << 4) | ((b3 >> 2) & 0xF);\n\t\t\t\tif((nbytes == 4) || (b3&0x3))\n\t\t\t\t\t*out++ = (b3 << 6) | (b4 & 0x3F);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\t\tif((b2 << 4) & 0xFF)\n\t\t\t\t\t*out++ = b2 << 4;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t*out++ = b1 << 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t}\n\t} else while(*in) {\n\t\tint nbytes;\n\n\t\tif(m->base64chars) {\n\t\t\tm->base64chars--;\n\t\t\tb1 = cb1;\n\t\t} else\n\t\t\tb1 = (*decoder)(*in++);\n\n\t\tif(*in == '\\0') {\n\t\t\tb2 = '\\0';\n\t\t\tnbytes = 1;\n\t\t} else {\n\t\t\tif(m->base64chars) {\n\t\t\t\tm->base64chars--;\n\t\t\t\tb2 = cb2;\n\t\t\t} else\n\t\t\t\tb2 = (*decoder)(*in++);\n\n\t\t\tif(*in == '\\0') {\n\t\t\t\tb3 = '\\0';\n\t\t\t\tnbytes = 2;\n\t\t\t} else {\n\t\t\t\tif(m->base64chars) {\n\t\t\t\t\tm->base64chars--;\n\t\t\t\t\tb3 = cb3;\n\t\t\t\t} else\n\t\t\t\t\tb3 = (*decoder)(*in++);\n\n\t\t\t\tif(*in == '\\0') {\n\t\t\t\t\tb4 = '\\0';\n\t\t\t\t\tnbytes = 3;\n\t\t\t\t} else {\n\t\t\t\t\tb4 = (*decoder)(*in++);\n\t\t\t\t\tnbytes = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch(nbytes) {\n\t\t\tcase 4:\n\t\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\t\t*out++ = (b2 << 4) | ((b3 >> 2) & 0xF);\n\t\t\t\t*out++ = (b3 << 6) | (b4 & 0x3F);\n\t\t\t\tcontinue;\n\t\t\tcase 3:\n\t\t\t\tm->base64_3 = b3;\n\t\t\tcase 2:\n\t\t\t\tm->base64_2 = b2;\n\t\t\tcase 1:\n\t\t\t\tm->base64_1 = b1;\n\t\t\t\tm->base64chars = nbytes;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t}\n\t\tbreak;\t/* nbytes != 4 => EOL */\n\t}\n\treturn out;\n}\n\nstatic unsigned char\nhex(char c)\n{\n\tif(isdigit(c))\n\t\treturn c - '0';\n\tif((c >= 'A') && (c <= 'F'))\n\t\treturn c - 'A' + 10;\n\tif((c >= 'a') && (c <= 'f'))\n\t\treturn c - 'a' + 10;\n\tcli_dbgmsg(\"Illegal hex character '%c'\\n\", c);\n\n\t/*\n\t * Some mails (notably some spam) break RFC2045 by failing to encode\n\t * the '=' character\n\t */\n\treturn '=';\n}\n\nstatic unsigned char\nbase64(char c)\n{\n\tconst unsigned char ret = base64Table[(unsigned int)(c & 0xFF)];\n\n\tif(ret == 255) {\n\t\t/*cli_dbgmsg(\"Illegal character <%c> in base64 encoding\\n\", c);*/\n\t\treturn 63;\n\t}\n\treturn ret;\n}\n\nstatic unsigned char\nuudecode(char c)\n{\n\treturn c - ' ';\n}\n\n/*\n * These are the only arguments we're interested in.\n * Do 'fgrep messageFindArgument *.c' if you don't believe me!\n * It's probably not good doing this since each time a new\n * messageFindArgument is added I need to remember to look here,\n * but it can save a lot of memory...\n */\nstatic int\nusefulArg(const char *arg)\n{\n\tif((strncasecmp(arg, \"name\", 4) != 0) &&\n\t   (strncasecmp(arg, \"filename\", 8) != 0) &&\n\t   (strncasecmp(arg, \"boundary\", 8) != 0) &&\n\t   (strncasecmp(arg, \"protocol\", 8) != 0) &&\n\t   (strncasecmp(arg, \"id\", 2) != 0) &&\n\t   (strncasecmp(arg, \"number\", 6) != 0) &&\n\t   (strncasecmp(arg, \"total\", 5) != 0) &&\n\t   (strncasecmp(arg, \"type\", 4) != 0)) {\n\t\tcli_dbgmsg(\"Discarding unwanted argument '%s'\\n\", arg);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid\nmessageSetCTX(message *m, cli_ctx *ctx)\n{\n\tm->ctx = ctx;\n}\n\nint\nmessageContainsVirus(const message *m)\n{\n\treturn m->isInfected ? TRUE : FALSE;\n}\n\n/*\n * We've run out of memory. Try to recover some by\n * deduping the message\n *\n * FIXME: this can take a long time. The real solution is for system admins\n *\tto refrain from setting ulimits too low, then this routine won't be\n *\tcalled\n */\nstatic void\nmessageDedup(message *m)\n{\n\tconst text *t1;\n\tsize_t saved = 0;\n\n\tcli_dbgmsg(\"messageDedup\\n\");\n\n\tt1 = m->dedupedThisFar ? m->dedupedThisFar : m->body_first;\n\n\tfor(t1 = m->body_first; t1; t1 = t1->t_next) {\n\t\tconst char *d1;\n\t\ttext *t2;\n\t\tline_t *l1;\n\t\tunsigned int r1;\n\n\t\tif(saved >= 100*1000)\n\t\t\tbreak;\t/* that's enough */\n\t\tl1 = t1->t_line;\n\t\tif(l1 == NULL)\n\t\t\tcontinue;\n\t\td1 = lineGetData(l1);\n\t\tif(strlen(d1) < 8)\n\t\t\tcontinue;\t/* wouldn't recover many bytes */\n\n\t\tr1 = (unsigned int)lineGetRefCount(l1);\n\t\tif(r1 == 255)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't want to foul up any pointers\n\t\t */\n\t\tif(t1 == m->encoding)\n\t\t\tcontinue;\n\t\tif(t1 == m->bounce)\n\t\t\tcontinue;\n\t\tif(t1 == m->binhex)\n\t\t\tcontinue;\n\t\tif(t1 == m->yenc)\n\t\t\tcontinue;\n\n\t\tfor(t2 = t1->t_next; t2; t2 = t2->t_next) {\n\t\t\tconst char *d2;\n\t\t\tline_t *l2 = t2->t_line;\n\n\t\t\tif(l2 == NULL)\n\t\t\t\tcontinue;\n\t\t\td2 = lineGetData(l2);\n\t\t\tif(d1 == d2)\n\t\t\t\t/* already linked */\n\t\t\t\tcontinue;\n\t\t\tif(strcmp(d1, d2) == 0) {\n\t\t\t\tif(lineUnlink(l2) == NULL)\n\t\t\t\t\tsaved += strlen(d1) + 1;\n\t\t\t\tt2->t_line = lineLink(l1);\n\t\t\t\tif(t2->t_line == NULL) {\n\t\t\t\t\tcli_errmsg(\"messageDedup: out of memory\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(++r1 == 255)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcli_dbgmsg(\"messageDedup reclaimed %lu bytes\\n\", (unsigned long)saved);\n\tm->dedupedThisFar = t1;\n}\n\n/*\n * Handle RFC2231 encoding. Returns a malloc'd buffer that the caller must\n * free, or NULL on error.\n *\n * TODO: Currently only handles paragraph 4 of RFC2231 e.g.\n *\t protocol*=ansi-x3.4-1968''application%2Fpgp-signature;\n */\nstatic char *\nrfc2231(const char *in)\n{\n\tconst char *ptr;\n\tchar *ret, *out;\n\tenum { LANGUAGE, CHARSET, CONTENTS } field;\n\n\tif(strstr(in, \"*0*=\") != NULL) {\n\t\tchar *p;\n\n\t\t/* Don't handle continuations, decode what we can */\n\t\tp = ret = cli_malloc(strlen(in) + 16);\n\t\tif(ret == NULL) {\n            cli_errmsg(\"rfc2331: out of memory, unable to proceed\\n\");\n\t\t\treturn NULL;\n        }\n\n\t\tdo {\n\t\t\tswitch(*in) {\n\t\t\t\tdefault:\n\t\t\t\t\t*p++ = *in++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '*':\n\t\t\t\t\tdo\n\t\t\t\t\t\tin++;\n\t\t\t\t\twhile((*in != '*') && *in);\n\t\t\t\t\tif(*in) {\n\t\t\t\t\t\tin++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '=':\n\t\t\t\t\t/*strcpy(p, in);*/\n\t\t\t\t\tstrcpy(p, \"=rfc2231failure\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while(*in);\n\n\t\tcli_dbgmsg(\"RFC2231 parameter continuations are not yet handled, returning \\\"%s\\\"\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tptr = strstr(in, \"*0=\");\n\tif(ptr != NULL)\n\t\t/*\n\t\t * Parameter continuation, with no continuation\n\t\t * Thunderbird 1.5 (and possibly other versions) does this\n\t\t */\n\t\tfield = CONTENTS;\n\telse {\n\t\tptr = strstr(in, \"*=\");\n\t\tfield = LANGUAGE;\n\t}\n\n\tif(ptr == NULL) {\t/* quick return */\n\t\tout = ret = cli_strdup(in);\n\t\twhile(*out)\n\t\t\t*out++ &= 0x7F;\n\t\treturn ret;\n\t}\n\n\tcli_dbgmsg(\"rfc2231 '%s'\\n\", in);\n\n\tret = cli_malloc(strlen(in) + 1);\n\n\tif(ret == NULL) {\n        cli_errmsg(\"rfc2331: out of memory for ret\\n\");\n\t\treturn NULL;\n    }\n\n\t/*\n\t * memcpy(out, in, (ptr - in));\n\t * out = &out[ptr - in];\n\t * in = ptr;\n\t */\n\tout = ret;\n\twhile(in != ptr)\n\t\t*out++ = *in++;\n\n\t*out++ = '=';\n\n\twhile(*ptr++ != '=')\n\t\t;\n\n\t/*\n\t * We don't do anything with the language and character set, just skip\n\t * over them!\n\t */\n\twhile(*ptr) {\n\t\tswitch(field) {\n\t\t\tcase LANGUAGE:\n\t\t\t\tif(*ptr == '\\'')\n\t\t\t\t\tfield = CHARSET;\n\t\t\t\tbreak;\n\t\t\tcase CHARSET:\n\t\t\t\tif(*ptr == '\\'')\n\t\t\t\t\tfield = CONTENTS;\n\t\t\t\tbreak;\n\t\t\tcase CONTENTS:\n\t\t\t\tif(*ptr == '%') {\n\t\t\t\t\tunsigned char byte;\n\n\t\t\t\t\tif((*++ptr == '\\0') || (*ptr == '\\n'))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tbyte = hex(*ptr);\n\n\t\t\t\t\tif((*++ptr == '\\0') || (*ptr == '\\n')) {\n\t\t\t\t\t\t*out++ = byte;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbyte <<= 4;\n\t\t\t\t\tbyte += hex(*ptr);\n\t\t\t\t\t*out++ = byte;\n\t\t\t\t} else\n\t\t\t\t\t*out++ = *ptr;\n\t\t}\n\t\tif(*ptr++ == '\\0')\n\t\t\t/*\n\t\t\t * Incorrect message that has just one character after\n\t\t\t * a '%'.\n\t\t\t * FIXME: stash something in out that would, for example\n\t\t\t *\ttreat %2 as %02, assuming field == CONTENTS\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tif(field != CONTENTS) {\n\t\tfree(ret);\n\t\tcli_dbgmsg(\"Invalid RFC2231 header: '%s'\\n\", in);\n\t\treturn cli_strdup(\"\");\n\t}\n\n\t*out = '\\0';\n\n\tcli_dbgmsg(\"rfc2231 returns '%s'\\n\", ret);\n\n\treturn ret;\n}\n\n/*\n * common/simil:\n *\tFrom Computing Magazine 20/8/92\n * Returns %ge number from 0 to 100 - how similar are 2 strings?\n * 100 for exact match, < for error\n */\nstruct\tpstr_list {\t/* internal stack */\n\tchar\t*d1;\n\tstruct\tpstr_list\t*next;\n};\n\n#define\tOUT_OF_MEMORY\t(-2)\n#define\tFAILURE\t(-3)\n#define\tSUCCESS\t(-4)\n#define\tARRAY_OVERFLOW\t(-5)\ntypedef\tstruct\tpstr_list\tELEMENT1;\ntypedef\tELEMENT1\t\t*LINK1;\n\nstatic\tint\tpush(LINK1 *top, const char *string);\nstatic\tint\tpop(LINK1 *top, char *buffer);\nstatic\tunsigned\tint\tcompare(char *ls1, char **rs1, char *ls2, char **rs2);\n\n#define\tMAX_PATTERN_SIZ\t50\t/* maximum string lengths */\n\nstatic int\nsimil(const char *str1, const char *str2)\n{\n\tLINK1 top = NULL;\n\tunsigned int score = 0;\n\tsize_t common, total;\n\tsize_t len1, len2;\n\tchar *rs1 = NULL, *rs2 = NULL;\n\tchar *s1, *s2;\n\tchar ls1[MAX_PATTERN_SIZ], ls2[MAX_PATTERN_SIZ];\n\n\tif(strcasecmp(str1, str2) == 0)\n\t\treturn 100;\n\n\tif((s1 = cli_strdup(str1)) == NULL)\n\t\treturn OUT_OF_MEMORY;\n\tif((s2 = cli_strdup(str2)) == NULL) {\n\t\tfree(s1);\n\t\treturn OUT_OF_MEMORY;\n\t}\n\n\tif(((total = strstrip(s1)) > MAX_PATTERN_SIZ - 1) || ((len2 = strstrip(s2)) > MAX_PATTERN_SIZ - 1)) {\n\t\tfree(s1);\n\t\tfree(s2);\n\t\treturn ARRAY_OVERFLOW;\n\t}\n\n\ttotal += len2;\n\n\tif((push(&top, s1) == OUT_OF_MEMORY) ||\n\t   (push(&top, s2) == OUT_OF_MEMORY)) {\n\t\tfree(s1);\n\t\tfree(s2);\n\t\treturn OUT_OF_MEMORY;\n\t}\n\n\twhile(pop(&top, ls2) == SUCCESS) {\n\t\tpop(&top, ls1);\n\t\tcommon = compare(ls1, &rs1, ls2, &rs2);\n\t\tif(common > 0) {\n\t\t\tscore += (unsigned int)common;\n\t\t\tlen1 = strlen(ls1);\n\t\t\tlen2 = strlen(ls2);\n\n\t\t\tif((len1 > 1 && len2 >= 1) || (len2 > 1 && len1 >= 1))\n\t\t\t\tif((push(&top, ls1) == OUT_OF_MEMORY) || (push(&top, ls2) == OUT_OF_MEMORY)) {\n\t\t\t\t\tfree(s1);\n\t\t\t\t\tfree(s2);\n\t\t\t\t\treturn OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\tlen1 = strlen(rs1);\n\t\t\tlen2 = strlen(rs2);\n\n\t\t\tif((len1 > 1 && len2 >= 1) || (len2 > 1 && len1 >= 1))\n\t\t\t\tif((push(&top, rs1) == OUT_OF_MEMORY) || (push(&top, rs2) == OUT_OF_MEMORY)) {\n\t\t\t\t\tfree(s1);\n\t\t\t\t\tfree(s2);\n\t\t\t\t\treturn OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t}\n\t}\n\tfree(s1);\n\tfree(s2);\n\treturn (total > 0) ? ((score * 200) / total) : 0;\n}\n\nstatic unsigned int\ncompare(char *ls1, char **rs1, char *ls2, char **rs2)\n{\n\tunsigned int common, maxchars = 0;\n\tbool some_similarity = FALSE;\n\tchar *s1, *s2;\n\tchar *maxs1 = NULL, *maxs2 = NULL, *maxe1 = NULL, *maxe2 = NULL;\n\tchar *cs1, *cs2, *start1, *end1, *end2;\n\n\tend1 = ls1 + strlen(ls1);\n\tend2 = ls2 + strlen(ls2);\n\tstart1 = ls1;\n\n\tfor(;;) {\n\t\ts1 = start1;\n\t\ts2 = ls2;\n\n\t\tif(s1 < end1) {\n\t\t\twhile(s1 < end1 && s2 < end2) {\n\t\t\t\tif(tolower(*s1) == tolower(*s2)) {\n\t\t\t\t\tsome_similarity = TRUE;\n\t\t\t\t\tcs1 = s1;\n\t\t\t\t\tcs2 = s2;\n\t\t\t\t\tcommon = 0;\n\t\t\t\t\tdo\n\t\t\t\t\t\tif(s1 == end1 || s2 == end2)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts1++;\n\t\t\t\t\t\t\ts2++;\n\t\t\t\t\t\t\tcommon++;\n\t\t\t\t\t\t}\n\t\t\t\t\twhile(tolower(*s1) == tolower(*s2));\n\n\t\t\t\t\tif(common > maxchars) {\n\t\t\t\t\t\tunsigned int diff = common - maxchars;\n\t\t\t\t\t\tmaxchars = common;\n\t\t\t\t\t\tmaxs1 = cs1;\n\t\t\t\t\t\tmaxs2 = cs2;\n\t\t\t\t\t\tmaxe1 = s1;\n\t\t\t\t\t\tmaxe2 = s2;\n\t\t\t\t\t\tend1 -= diff;\n\t\t\t\t\t\tend2 -= diff;\n\t\t\t\t\t} else\n\t\t\t\t\t\ts1 -= common;\n\t\t\t\t} else\n\t\t\t\t\ts2++;\n\t\t\t}\n\t\t\tstart1++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif(some_similarity) {\n\t\t*maxs1 = '\\0';\n\t\t*maxs2 = '\\0';\n\t\t*rs1 = maxe1;\n\t\t*rs2 = maxe2;\n\t}\n\treturn maxchars;\n}\n\nstatic int\npush(LINK1 *top, const char *string)\n{\n\tLINK1 element;\n\n\tif((element = (LINK1)cli_malloc(sizeof(ELEMENT1))) == NULL)\n\t\treturn OUT_OF_MEMORY;\n\tif((element->d1 = cli_strdup(string)) == NULL) {\n\t\tfree (element);\n\t\treturn OUT_OF_MEMORY;\n\t}\n\telement->next = *top;\n\t*top = element;\n\n\treturn SUCCESS;\n}\n\nstatic int\npop(LINK1 *top, char *buffer)\n{\n\tLINK1 t1;\n\n\tif((t1 = *top) != NULL) {\n\t\t(void)strcpy(buffer, t1->d1);\n\t\t*top = t1->next;\n\t\tfree(t1->d1);\n\t\tfree((char *)t1);\n\t\treturn SUCCESS;\n\t}\n\treturn FAILURE;\n}\n\n/*\n * Have we found a line that is a start of a uuencoded file (see uuencode(5))?\n */\nint\nisuuencodebegin(const char *line)\n{\n\tif(line[0] != 'b')\t/* quick check */\n\t\treturn 0;\n\n\tif(strlen(line) < 10)\n\t\treturn 0;\n\n\treturn (strncasecmp(line, \"begin \", 6) == 0) &&\n\t\tisdigit(line[6]) && isdigit(line[7]) &&\n\t\tisdigit(line[8]) && (line[9] == ' ');\n}\n\n#if HAVE_JSON\njson_object *messageGetJObj(message *m)\n{\n\tassert(m != NULL);\n\n\tif(m->jobj == NULL)\n\t\tm->jobj = cli_jsonobj(NULL, NULL);\n\n\treturn m->jobj;\n}\n#endif\n"], "fixing_code": ["/*\n *  Copyright (C) 2015 Cisco Systems, Inc. and/or its affiliates. All rights reserved.\n *  Copyright (C) 2007-2008 Sourcefire, Inc.\n *\n *  Authors: Nigel Horne\n *\n *  This program is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License version 2 as\n *  published by the Free Software Foundation.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,\n *  MA 02110-1301, USA.\n *\n * TODO: Optimise messageExport, decodeLine, messageIsEncoding\n */\n\n#if HAVE_CONFIG_H\n#include \"clamav-config.h\"\n#endif\n\n#ifdef CL_THREAD_SAFE\n#ifndef\t_REENTRANT\n#define\t_REENTRANT\t/* for Solaris 2.8 */\n#endif\n#endif\n\n#ifdef\tC_DARWIN\n#include <sys/types.h>\n#endif\n#include <stdlib.h>\n#include <string.h>\n#ifdef\tHAVE_STRINGS_H\n#include <strings.h>\n#endif\n#include <assert.h>\n#include <ctype.h>\n#include <stdio.h>\n\n#ifdef\tCL_THREAD_SAFE\n#include <pthread.h>\n#endif\n\n#include \"others.h\"\n#include \"str.h\"\n#include \"filetypes.h\"\n\n#include \"mbox.h\"\n#include \"clamav.h\"\n#include \"json_api.h\"\n\n#ifndef isblank\n#define isblank(c)\t(((c) == ' ') || ((c) == '\\t'))\n#endif\n\n#define\tRFC2045LENGTH\t76\t/* maximum number of characters on a line */\n\n#ifdef\tHAVE_STDBOOL_H\n#include <stdbool.h>\n#else\n#ifdef\tFALSE\ntypedef\tunsigned\tchar\tbool;\n#else\ntypedef enum\t{ FALSE = 0, TRUE = 1 } bool;\n#endif\n#endif\n\nstatic\tint\tmessageHasArgument(const message *m, const char *variable);\nstatic\tvoid\tmessageIsEncoding(message *m);\nstatic unsigned char *decode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(char), bool isFast);\nstatic\tvoid\tsanitiseBase64(char *s);\n#ifdef\t__GNUC__\nstatic\tunsigned\tchar\thex(char c)\t__attribute__((const));\nstatic\tunsigned\tchar\tbase64(char c)\t__attribute__((const));\nstatic\tunsigned\tchar\tuudecode(char c)\t__attribute__((const));\n#else\nstatic\tunsigned\tchar\thex(char c);\nstatic\tunsigned\tchar\tbase64(char c);\nstatic\tunsigned\tchar\tuudecode(char c);\n#endif\nstatic\tconst\tchar\t*messageGetArgument(const message *m, int arg);\nstatic\tvoid\t*messageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), void (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void (*setCTX)(void *, cli_ctx *), int destroy_text);\nstatic\tint\tusefulArg(const char *arg);\nstatic\tvoid\tmessageDedup(message *m);\nstatic\tchar\t*rfc2231(const char *in);\nstatic\tint\tsimil(const char *str1, const char *str2);\n\n/*\n * These maps are ordered in decreasing likelyhood of their appearance\n * in an e-mail. Probably these should be in a table...\n */\nstatic\tconst\tstruct\tencoding_map {\n\tconst\tchar\t*string;\n\tencoding_type\ttype;\n} encoding_map[] = {\t/* rfc2045 */\n\t{\t\"7bit\",\t\t\tNOENCODING\t},\n\t{\t\"text/plain\",\t\tNOENCODING\t},\n\t{\t\"quoted-printable\",\tQUOTEDPRINTABLE\t},\t/* rfc2045 */\n\t{\t\"base64\",\t\tBASE64\t\t},\t/* rfc2045 */\n\t{\t\"8bit\",\t\t\tEIGHTBIT\t},\n\t{\t\"binary\",\t\tBINARY\t\t},\n\t{\t\"x-uuencode\",\t\tUUENCODE\t},\t/* uuencode(5) */\n\t{\t\"x-yencode\",\t\tYENCODE\t\t},\n\t{\t\"x-binhex\",\t\tBINHEX\t\t},\n\t{\t\"us-ascii\",\t\tNOENCODING\t},\t/* incorrect */\n\t{\t\"x-uue\",\t\tUUENCODE\t},\t/* incorrect */\n\t{\t\"uuencode\",\t\tUUENCODE\t},\t/* incorrect */\n\t{\tNULL,\t\t\tNOENCODING\t}\n};\n\nstatic\tconst\tstruct\tmime_map {\n\tconst\tchar\t*string;\n\tmime_type\ttype;\n} mime_map[] = {\n\t{\t\"text\",\t\t\tTEXT\t\t},\n\t{\t\"multipart\",\t\tMULTIPART\t},\n\t{\t\"application\",\t\tAPPLICATION\t},\n\t{\t\"audio\",\t\tAUDIO\t\t},\n\t{\t\"image\",\t\tIMAGE\t\t},\n\t{\t\"message\",\t\tMESSAGE\t\t},\n\t{\t\"video\",\t\tVIDEO\t\t},\n\t{\tNULL,\t\t\tTEXT\t\t}\n};\n\n/*\n * See RFC2045, section 6.8, table 1\n */\nstatic const unsigned char base64Table[256] = {\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,62,255,255,255,63,\n\t52,53,54,55,56,57,58,59,60,61,255,255,255,0,255,255,\n\t255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,\n\t15,16,17,18,19,20,21,22,23,24,25,255,255,255,255,255,\n\t255,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,\n\t41,42,43,44,45,46,47,48,49,50,51,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n\t255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255\n};\n\nmessage *\nmessageCreate(void)\n{\n\tmessage *m = (message *)cli_calloc(1, sizeof(message));\n\n\tif(m)\n\t\tm->mimeType = NOMIME;\n\n\treturn m;\n}\n\nvoid\nmessageDestroy(message *m)\n{\n\tassert(m != NULL);\n\n\tmessageReset(m);\n\n\tfree(m);\n}\n\nvoid\nmessageReset(message *m)\n{\n\tint i;\n\n\tassert(m != NULL);\n\n\tif(m->mimeSubtype)\n\t\tfree(m->mimeSubtype);\n\n\tif(m->mimeDispositionType)\n\t\tfree(m->mimeDispositionType);\n\n\tif(m->mimeArguments) {\n\t\tfor(i = 0; i < m->numberOfArguments; i++)\n\t\t\tfree(m->mimeArguments[i]);\n\t\tfree(m->mimeArguments);\n\t}\n\n\tif(m->body_first)\n\t\ttextDestroy(m->body_first);\n\n\tassert(m->base64chars == 0);\n\n\tif(m->encodingTypes) {\n\t\tassert(m->numberOfEncTypes > 0);\n\t\tfree(m->encodingTypes);\n\t}\n\n#if HAVE_JSON\n\tif(m->jobj)\n\t\tcli_json_delobj(m->jobj);\n#endif\n\n\tmemset(m, '\\0', sizeof(message));\n\tm->mimeType = NOMIME;\n}\n\n/*\n * Handle the Content-Type header. The syntax is in RFC1341.\n * Return success (1) or failure (0). Failure only happens when it's an\n * unknown type and we've already received a known type, or we've received an\n * empty type. If we receive an unknown type by itself we default to application\n */\nint\nmessageSetMimeType(message *mess, const char *type)\n{\n#ifdef\tCL_THREAD_SAFE\n\tstatic pthread_mutex_t mime_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\tconst struct mime_map *m;\n\tint typeval;\n\tstatic table_t *mime_table;\n\n\tassert(mess != NULL);\n\tif(type == NULL) {\n\t\tcli_dbgmsg(\"Empty content-type field\\n\");\n\t\treturn 0;\n\t}\n\n\tcli_dbgmsg(\"messageSetMimeType: '%s'\\n\", type);\n\n\t/* Ignore leading spaces */\n\twhile(!isalpha(*type))\n\t\tif(*type++ == '\\0')\n\t\t\treturn 0;\n\n#ifdef\tCL_THREAD_SAFE\n\tpthread_mutex_lock(&mime_mutex);\n#endif\n\tif(mime_table == NULL) {\n\t\tmime_table = tableCreate();\n\t\tif(mime_table == NULL) {\n#ifdef\tCL_THREAD_SAFE\n\t\t\tpthread_mutex_unlock(&mime_mutex);\n#endif\n\t\t\treturn 0;\n\t\t}\n\n\t\tfor(m = mime_map; m->string; m++)\n\t\t\tif(!tableInsert(mime_table, m->string, m->type)) {\n\t\t\t\ttableDestroy(mime_table);\n\t\t\t\tmime_table = NULL;\n#ifdef\tCL_THREAD_SAFE\n\t\t\t\tpthread_mutex_unlock(&mime_mutex);\n#endif\n\t\t\t\treturn 0;\n\t\t\t}\n\t}\n#ifdef\tCL_THREAD_SAFE\n\tpthread_mutex_unlock(&mime_mutex);\n#endif\n\n\ttypeval = tableFind(mime_table, type);\n\n\tif(typeval != -1) {\n\t\tmess->mimeType = (mime_type)typeval;\n\t\treturn 1;\n\t}\n\tif(mess->mimeType == NOMIME) {\n\t\tif(strncasecmp(type, \"x-\", 2) == 0)\n\t\t\tmess->mimeType = MEXTENSION;\n\t\telse {\n\t\t\t/*\n\t\t\t * Force scanning of strange messages\n\t\t\t */\n\t\t\tif(strcasecmp(type, \"plain\") == 0) {\n\t\t\t\tcli_dbgmsg(\"Incorrect MIME type: `plain', set to Text\\n\");\n\t\t\t\tmess->mimeType = TEXT;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Don't handle broken e-mail probably sending\n\t\t\t\t *\tContent-Type: plain/text\n\t\t\t\t * instead of\n\t\t\t\t *\tContent-Type: text/plain\n\t\t\t\t * as an attachment\n\t\t\t\t */\n\t\t\t\tint highestSimil = 0, t = -1;\n\t\t\t\tconst char *closest = NULL;\n\n\t\t\t\tfor(m = mime_map; m->string; m++) {\n\t\t\t\t\tconst int s = simil(m->string, type);\n\n\t\t\t\t\tif(s > highestSimil) {\n\t\t\t\t\t\thighestSimil = s;\n\t\t\t\t\t\tclosest = m->string;\n\t\t\t\t\t\tt = m->type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(highestSimil >= 50) {\n\t\t\t\t\tcli_dbgmsg(\"Unknown MIME type \\\"%s\\\" - guessing as %s (%d%% certainty)\\n\",\n\t\t\t\t\t\ttype, closest,\n\t\t\t\t\t\thighestSimil);\n\t\t\t\t\tmess->mimeType = (mime_type)t;\n\t\t\t\t} else {\n\t\t\t\t\tcli_dbgmsg(\"Unknown MIME type: `%s', set to Application - if you believe this file contains a virus, submit it to www.clamav.net\\n\", type);\n\t\t\t\t\tmess->mimeType = APPLICATION;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nmime_type\nmessageGetMimeType(const message *m)\n{\n\tassert(m != NULL);\n\n\treturn m->mimeType;\n}\n\nvoid\nmessageSetMimeSubtype(message *m, const char *subtype)\n{\n\tassert(m != NULL);\n\n\tif(subtype == NULL) {\n\t\t/*\n\t\t * Handle broken content-type lines, e.g.\n\t\t *\tContent-Type: text/\n\t\t */\n\t\tcli_dbgmsg(\"Empty content subtype\\n\");\n\t\tsubtype = \"\";\n\t}\n\n\tif(m->mimeSubtype)\n\t\tfree(m->mimeSubtype);\n\n\tm->mimeSubtype = cli_strdup(subtype);\n}\n\nconst char *\nmessageGetMimeSubtype(const message *m)\n{\n\treturn (m->mimeSubtype) ? m->mimeSubtype : \"\";\n}\n\nvoid\nmessageSetDispositionType(message *m, const char *disptype)\n{\n\tassert(m != NULL);\n\n\tif(m->mimeDispositionType)\n\t\tfree(m->mimeDispositionType);\n\tif(disptype == NULL) {\n\t\tm->mimeDispositionType = NULL;\n\t\treturn;\n\t}\n\n\t/*\n\t * It's broken for there to be an entry such as \"Content-Disposition:\"\n\t * However some spam and viruses are rather broken, it's a sign\n\t * that something is wrong if we get that - maybe we should force a\n\t * scan of this part\n\t */\n\twhile(*disptype && isspace((int)*disptype))\n\t\tdisptype++;\n\tif(*disptype) {\n\t\tm->mimeDispositionType = cli_strdup(disptype);\n\t\tif(m->mimeDispositionType)\n\t\t\tstrstrip(m->mimeDispositionType);\n\t} else\n\t\tm->mimeDispositionType = NULL;\n}\n\nconst char *\nmessageGetDispositionType(const message *m)\n{\n\treturn (m->mimeDispositionType) ? m->mimeDispositionType : \"\";\n}\n\n/*\n * TODO:\n *\tArguments are held on a per message basis, they should be held on\n * a per section basis. Otherwise what happens if two sections have two\n * different values for charset? Probably doesn't matter for the use this\n * code will be given, but will need fixing if this code is used elsewhere\n */\nvoid\nmessageAddArgument(message *m, const char *arg)\n{\n\tint offset;\n\tchar *p;\n\n\tassert(m != NULL);\n\n\tif(arg == NULL)\n\t\treturn;\t/* Note: this is not an error condition */\n\n\twhile(isspace(*arg))\n\t\targ++;\n\n\tif(*arg == '\\0')\n\t\t/* Empty argument? Probably a broken mail client... */\n\t\treturn;\n\n\tcli_dbgmsg(\"messageAddArgument, arg='%s'\\n\", arg);\n\n\tif(!usefulArg(arg))\n\t\treturn;\n\n\tfor(offset = 0; offset < m->numberOfArguments; offset++)\n\t\tif(m->mimeArguments[offset] == NULL)\n\t\t\tbreak;\n\t\telse if(strcasecmp(arg, m->mimeArguments[offset]) == 0)\n\t\t\treturn;\t/* already in there */\n\n\tif(offset == m->numberOfArguments) {\n\t\tchar **q;\n\n\t\tm->numberOfArguments++;\n\t\tq = (char **)cli_realloc(m->mimeArguments, m->numberOfArguments * sizeof(char *));\n\t\tif(q == NULL) {\n\t\t\tm->numberOfArguments--;\n\t\t\treturn;\n\t\t}\n\t\tm->mimeArguments = q;\n\t}\n\n\tp = m->mimeArguments[offset] = rfc2231(arg);\n\tif(!p) {\n\t\t/* problem inside rfc2231() */\n\t\tcli_dbgmsg(\"messageAddArgument, error from rfc2231()\\n\");\n\t\treturn;\n\t}\n\n\tif(strchr(p, '=') == NULL) {\n\t\tif(strncmp(p, \"filename\", 8) == 0) {\n\t\t\t/*\n\t\t\t * FIXME: Bounce message handling is corrupting the in\n\t\t\t * core copies of headers\n\t\t\t */\n                        if (strlen(p) > 8) {\n                            cli_dbgmsg(\"Possible data corruption fixed\\n\");\n                            p[8] = '=';\n                        } else {\n                            cli_dbgmsg(\"Possible data corruption not fixed\\n\");\n                        }\n\t\t} else {\n\t\t\tif(*p)\n\t\t\t\tcli_dbgmsg(\"messageAddArgument, '%s' contains no '='\\n\", p);\n\t\t\tfree(m->mimeArguments[offset]);\n\t\t\tm->mimeArguments[offset] = NULL;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * This is terribly broken from an RFC point of view but is useful\n\t * for catching viruses which have a filename but no type of\n\t * mime. By pretending defaulting to an application rather than\n\t * to nomime we can ensure they're saved and scanned\n\t */\n\tif((strncasecmp(p, \"filename=\", 9) == 0) || (strncasecmp(p, \"name=\", 5) == 0))\n\t\tif(messageGetMimeType(m) == NOMIME) {\n\t\t\tcli_dbgmsg(\"Force mime encoding to application\\n\");\n\t\t\tmessageSetMimeType(m, \"application\");\n\t\t}\n}\n\n/*\n * Add in all the arguments.\n * Cope with:\n *\tname=\"foo bar.doc\"\n *\tcharset=foo name=bar\n */\nvoid\nmessageAddArguments(message *m, const char *s)\n{\n\tconst char *string = s;\n\n\tcli_dbgmsg(\"Add arguments '%s'\\n\", string);\n\n\tassert(string != NULL);\n\n\twhile(*string) {\n\t\tconst char *key, *cptr;\n\t\tchar *data, *field;\n        size_t datasz=0;\n\n\t\tif(isspace(*string & 0xff) || (*string == ';')) {\n\t\t\tstring++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey = string;\n\n\t\tdata = strchr(string, '=');\n\n\t\t/*\n\t\t * Some spam breaks RFC2045 by using ':' instead of '='\n\t\t * e.g.:\n\t\t *\tContent-Type: text/html; charset:ISO-8859-1\n\t\t * should be:\n\t\t *\tContent-type: text/html; charset=ISO-8859-1\n\t\t *\n\t\t * We give up with lines that are completely broken because\n\t\t * we don't have ESP and don't know what was meant to be there.\n\t\t * It's unlikely to really be a problem.\n\t\t */\n\t\tif(data == NULL)\n\t\t\tdata = strchr(string, ':');\n\n\t\tif(data == NULL) {\n\t\t\t/*\n\t\t\t * Completely broken, give up\n\t\t\t */\n\t\t\tcli_dbgmsg(\"Can't parse header \\\"%s\\\"\\n\", s);\n\t\t\treturn;\n\t\t}\n\n\t\tstring = &data[1];\n\n\t\t/*\n\t\t * Handle white space to the right of the equals sign\n\t\t * This breaks RFC2045 which has:\n\t\t *\tparameter := attribute \"=\" value\n\t\t *\tattribute := token   ; case-insensitive\n\t\t *\ttoken  :=  1*<any (ASCII) CHAR except SPACE, CTLs,\n\t\t *\t\tor tspecials>\n\t\t * But too many MUAs ignore this\n\t\t */\n\t\twhile(isspace(*string) && (*string != '\\0'))\n\t\t\tstring++;\n\n\t\tcptr = string++;\n\n\t\tif(strlen(key) == 0)\n\t\t\tcontinue;\n\n\t\tif(*cptr == '\"') {\n\t\t\tchar *ptr, *kcopy;\n\n\t\t\t/*\n\t\t\t * The field is in quotes, so look for the\n\t\t\t * closing quotes\n\t\t\t */\n\t\t\tkcopy = cli_strdup(key);\n\n\t\t\tif(kcopy == NULL)\n\t\t\t\treturn;\n\n\t\t\tptr = strchr(kcopy, '=');\n\t\t\tif(ptr == NULL) {\n\t\t\t\tptr = strchr(kcopy, ':');\n                if (ptr == NULL) {\n                    cli_dbgmsg(\"Can't parse header \\\"%s\\\"\\n\", s);\n                    free(kcopy);\n                    return;\n                }\n            }\n\n\t\t\t*ptr = '\\0';\n\n\t\t\tstring = strchr(++cptr, '\"');\n\n\t\t\tif(string == NULL) {\n\t\t\t\tcli_dbgmsg(\"Unbalanced quote character in \\\"%s\\\"\\n\", s);\n\t\t\t\tstring = \"\";\n\t\t\t} else\n\t\t\t\tstring++;\n\n\t\t\tif(!usefulArg(kcopy)) {\n\t\t\t\tfree(kcopy);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdata = cli_strdup(cptr);\n\n\t\t\tptr = (data) ? strchr(data, '\"') : NULL;\n\t\t\tif(ptr == NULL) {\n\t\t\t\t/*\n\t\t\t\t * Weird e-mail header such as:\n\t\t\t\t * Content-Type: application/octet-stream; name=\"\n\t\t\t\t * \"\n\t\t\t\t * Content-Transfer-Encoding: base64\n\t\t\t\t * Content-Disposition: attachment; filename=\"\n\t\t\t\t * \"\n\t\t\t\t *\n\t\t\t\t * TODO: the file should still be saved and\n\t\t\t\t * virus checked\n\t\t\t\t */\n\t\t\t\tcli_dbgmsg(\"Can't parse header \\\"%s\\\" - if you believe this file contains a virus, submit it to www.clamav.net\\n\", s);\n\t\t\t\tif(data)\n\t\t\t\t\tfree(data);\n\t\t\t\tfree(kcopy);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t*ptr = '\\0';\n\n            datasz = strlen(kcopy) + strlen(data) + 2;\n\t\t\tfield = cli_realloc(kcopy, strlen(kcopy) + strlen(data) + 2);\n\t\t\tif(field) {\n                cli_strlcat(field, \"=\", datasz);\n                cli_strlcat(field, data, datasz);\n\t\t\t} else {\n\t\t\t\tfree(kcopy);\n            }\n\t\t\tfree(data);\n\t\t} else {\n\t\t\tsize_t len;\n\n\t\t\tif(*cptr == '\\0') {\n\t\t\t\tcli_dbgmsg(\"Ignoring empty field in \\\"%s\\\"\\n\", s);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * The field is not in quotes, so look for the closing\n\t\t\t * white space\n\t\t\t */\n\t\t\twhile((*string != '\\0') && !isspace(*string))\n\t\t\t\tstring++;\n\n\t\t\tlen = (size_t)string - (size_t)key + 1;\n\t\t\tfield = cli_malloc(len);\n\n\t\t\tif(field) {\n\t\t\t\tmemcpy(field, key, len - 1);\n\t\t\t\tfield[len - 1] = '\\0';\n\t\t\t}\n\t\t}\n\t\tif(field) {\n\t\t\tmessageAddArgument(m, field);\n\t\t\tfree(field);\n\t\t}\n\t}\n}\n\nstatic const char *\nmessageGetArgument(const message *m, int arg)\n{\n\tassert(m != NULL);\n\tassert(arg >= 0);\n\tassert(arg < m->numberOfArguments);\n\n\treturn (m->mimeArguments[arg]) ? m->mimeArguments[arg] : \"\";\n}\n\n/*\n * Find a MIME variable from the header and return a COPY to the value of that\n * variable. The caller must free the copy\n */\nchar *\nmessageFindArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\n\tlen = strlen(variable);\n\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageFindArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageFindArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif((strlen(ptr) > 2) && (*++ptr == '\"') && (strchr(&ptr[1], '\"') != NULL)) {\n\t\t\t\t/* Remove any quote characters */\n\t\t\t\tchar *ret = cli_strdup(++ptr);\n\t\t\t\tchar *p;\n\n\t\t\t\tif(ret == NULL)\n\t\t\t\t\treturn NULL;\n\n\t\t\t\t/*\n\t\t\t\t * fix un-quoting of boundary strings from\n\t\t\t\t * header, occurs if boundary was given as\n\t\t\t\t *\t'boundary=\"_Test_\";'\n\t\t\t\t *\n\t\t\t\t * At least two quotes in string, assume\n\t\t\t\t * quoted argument\n\t\t\t\t * end string at next quote\n\t\t\t\t */\n\t\t\t\tif((p = strchr(ret, '\"')) != NULL) {\n\t\t\t\t\tret[strlen(ret) - 1] = '\\0';\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\treturn cli_strdup(ptr);\n\t\t}\n\t}\n\treturn NULL;\n}\n\nchar *\nmessageGetFilename(const message *m)\n{\n\tchar *filename = (char *)messageFindArgument(m, \"filename\");\n\n\tif(filename)\n\t\treturn filename;\n\n\treturn (char *)messageFindArgument(m, \"name\");\n}\n\n/* Returns true or false */\nstatic int\nmessageHasArgument(const message *m, const char *variable)\n{\n\tint i;\n\tsize_t len;\n\n\tassert(m != NULL);\n\tassert(variable != NULL);\n\n\tlen = strlen(variable);\n\n\tfor(i = 0; i < m->numberOfArguments; i++) {\n\t\tconst char *ptr;\n\n\t\tptr = messageGetArgument(m, i);\n\t\tif((ptr == NULL) || (*ptr == '\\0'))\n\t\t\tcontinue;\n#ifdef\tCL_DEBUG\n\t\tcli_dbgmsg(\"messageHasArgument: compare %lu bytes of %s with %s\\n\",\n\t\t\t(unsigned long)len, variable, ptr);\n#endif\n\t\tif(strncasecmp(ptr, variable, len) == 0) {\n\t\t\tptr = &ptr[len];\n\t\t\twhile(isspace(*ptr))\n\t\t\t\tptr++;\n\t\t\tif(*ptr != '=') {\n\t\t\t\tcli_dbgmsg(\"messageHasArgument: no '=' sign found in MIME header '%s' (%s)\\n\", variable, messageGetArgument(m, i));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint\nmessageHasFilename(const message *m)\n{\n\treturn messageHasArgument(m, \"filename\") || messageHasArgument(m, \"file\");\n}\n\nvoid\nmessageSetEncoding(message *m, const char *enctype)\n{\n\tconst struct encoding_map *e;\n\tint i;\n\tchar *type;\n\n\tassert(m != NULL);\n\tassert(enctype != NULL);\n\n\t/*m->encodingType = EEXTENSION;*/\n\n\twhile(isblank(*enctype))\n\t\tenctype++;\n\n\tcli_dbgmsg(\"messageSetEncoding: '%s'\\n\", enctype);\n\n\tif(strcasecmp(enctype, \"8 bit\") == 0) {\n\t\tcli_dbgmsg(\"Broken content-transfer-encoding: '8 bit' changed to '8bit'\\n\");\n\t\tenctype = \"8bit\";\n\t}\n\n\t/*\n\t * Iterate through\n\t *\tContent-Transfer-Encoding: base64 binary\n\t * cli_strtok's fieldno counts from 0\n\t */\n\ti = 0;\n\twhile((type = cli_strtok(enctype, i++, \" \\t\")) != NULL) {\n\t\tint highestSimil = 0;\n\t\tconst char *closest = NULL;\n\n\t\tfor(e = encoding_map; e->string; e++) {\n\t\t\tint sim;\n\t\t\tconst char lowertype = tolower(type[0]);\n\n\t\t\tif((lowertype != tolower(e->string[0])) && (lowertype != 'x'))\n\t\t\t\t/*\n\t\t\t\t * simil is expensive, I'm yet to encounter only\n\t\t\t\t * one example of a missent encoding when the\n\t\t\t\t * first character was wrong, so lets assume no\n\t\t\t\t * match to save the call.\n\t\t\t\t *\n\t\t\t\t * That example was quoted-printable sent as\n\t\t\t\t * X-quoted-printable.\n\t\t\t\t */\n\t\t\t\tcontinue;\n\n\t\t\tif(strcmp(e->string, \"uuencode\") == 0)\n\t\t\t\t/*\n\t\t\t\t * No need to test here - fast track visa will have\n\t\t\t\t * handled uuencoded files\n\t\t\t\t */\n\t\t\t\tcontinue;\n\n\t\t\tsim = simil(type, e->string);\n\n\t\t\tif(sim == 100) {\n\t\t\t\tint j;\n\t\t\t\tencoding_type *et;\n\n\t\t\t\tfor(j = 0; j < m->numberOfEncTypes; j++)\n\t\t\t\t\tif(m->encodingTypes[j] == e->type)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\tif(j < m->numberOfEncTypes) {\n\t\t\t\t\tcli_dbgmsg(\"Ignoring duplicate encoding mechanism '%s'\\n\",\n\t\t\t\t\t\ttype);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tet = (encoding_type *)cli_realloc(m->encodingTypes, (m->numberOfEncTypes + 1) * sizeof(encoding_type));\n\t\t\t\tif(et == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tm->encodingTypes = et;\n\t\t\t\tm->encodingTypes[m->numberOfEncTypes++] = e->type;\n\n\t\t\t\tcli_dbgmsg(\"Encoding type %d is \\\"%s\\\"\\n\", m->numberOfEncTypes, type);\n\t\t\t\tbreak;\n\t\t\t} else if(sim > highestSimil) {\n\t\t\t\tclosest = e->string;\n\t\t\t\thighestSimil = sim;\n\t\t\t}\n\t\t}\n\n\t\tif(e->string == NULL) {\n\t\t\t/*\n\t\t\t * The stated encoding type is illegal, so we\n\t\t\t * use a best guess of what it should be.\n\t\t\t *\n\t\t\t * 50% is arbitary. For example 7bi will match as\n\t\t\t * 66% certain to be 7bit\n\t\t\t */\n\t\t\tif(highestSimil >= 50) {\n\t\t\t\tcli_dbgmsg(\"Unknown encoding type \\\"%s\\\" - guessing as %s (%u%% certainty)\\n\",\n\t\t\t\t\ttype, closest, highestSimil);\n\t\t\t\tmessageSetEncoding(m, closest);\n\t\t\t} else {\n\t\t\t\tcli_dbgmsg(\"Unknown encoding type \\\"%s\\\" - if you believe this file contains a virus, submit it to www.clamav.net\\n\", type);\n\t\t\t\t/*\n\t\t\t\t * Err on the side of safety, enable all\n\t\t\t\t * decoding modules\n\t\t\t\t */\n\t\t\t\tmessageSetEncoding(m, \"base64\");\n\t\t\t\tmessageSetEncoding(m, \"quoted-printable\");\n\t\t\t}\n\t\t}\n\n\t\tfree(type);\n\t}\n}\n\nencoding_type\nmessageGetEncoding(const message *m)\n{\n\tassert(m != NULL);\n\n\tif(m->numberOfEncTypes == 0)\n\t\treturn NOENCODING;\n\treturn m->encodingTypes[0];\n}\n\nint\nmessageAddLine(message *m, line_t *line)\n{\n\tassert(m != NULL);\n\n\tif(m->body_first == NULL)\n\t\tm->body_last = m->body_first = (text *)cli_malloc(sizeof(text));\n\telse {\n\t\tm->body_last->t_next = (text *)cli_malloc(sizeof(text));\n\t\tm->body_last = m->body_last->t_next;\n\t}\n\n\tif(m->body_last == NULL) {\n        cli_errmsg(\"messageAddLine: out of memory for m->body_last\\n\");\n\t\treturn -1;\n    }\n\n\tm->body_last->t_next = NULL;\n\n\tif(line && lineGetData(line)) {\n\t\tm->body_last->t_line = lineLink(line);\n\n\t\tmessageIsEncoding(m);\n\t} else\n\t\tm->body_last->t_line = NULL;\n\n\treturn 1;\n}\n\n/*\n * Add the given line to the end of the given message\n * If needed a copy of the given line is taken which the caller must free\n * Line must not be terminated by a \\n\n */\nint\nmessageAddStr(message *m, const char *data)\n{\n\tline_t *repeat = NULL;\n\n\tassert(m != NULL);\n\n\tif(data) {\n\t\tif(*data == '\\0')\n\t\t\tdata = NULL;\n\t\telse {\n\t\t\t/*\n\t\t\t * If it's only white space, just store one space to\n\t\t\t * save memory. You must store something since it may\n\t\t\t * be a header line\n\t\t\t */\n\t\t\tint iswhite = 1;\n\t\t\tconst char *p;\n\n\t\t\tfor(p = data; *p; p++)\n\t\t\t\tif(((*p) & 0x80) || !isspace(*p)) {\n\t\t\t\t\tiswhite = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\tif(iswhite) {\n\t\t\t\t/*cli_dbgmsg(\"messageAddStr: empty line: '%s'\\n\", data);*/\n\t\t\t\tdata = \" \";\n\t\t\t}\n\t\t}\n\t}\n\n\tif(m->body_first == NULL)\n\t\tm->body_last = m->body_first = (text *)cli_malloc(sizeof(text));\n\telse {\n\t\tassert(m->body_last != NULL);\n\t\tif((data == NULL) && (m->body_last->t_line == NULL))\n\t\t\t/*\n\t\t\t * Although this would save time and RAM, some\n\t\t\t * phish signatures have been built which need the\n\t\t\t * blank lines\n\t\t\t */\n\t\t\tif(messageGetMimeType(m) != TEXT)\n\t\t\t\t/* don't save two blank lines in sucession */\n\t\t\t\treturn 1;\n\n\t\tm->body_last->t_next = (text *)cli_malloc(sizeof(text));\n\t\tif(m->body_last->t_next == NULL) {\n\t\t\tmessageDedup(m);\n\t\t\tm->body_last->t_next = (text *)cli_malloc(sizeof(text));\n\t\t\tif(m->body_last->t_next == NULL) {\n\t\t\t\tcli_errmsg(\"messageAddStr: out of memory\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif(data && m->body_last->t_line && (strcmp(data, lineGetData(m->body_last->t_line)) == 0))\n\t\t\trepeat = m->body_last->t_line;\n\t\tm->body_last = m->body_last->t_next;\n\t}\n\n\tif(m->body_last == NULL) {\n\t\tcli_errmsg(\"messageAddStr: out of memory\\n\");\n\t\treturn -1;\n\t}\n\n\tm->body_last->t_next = NULL;\n\n\tif(data && *data) {\n\t\tif(repeat)\n\t\t\tm->body_last->t_line = lineLink(repeat);\n\t\telse {\n\t\t\tm->body_last->t_line = lineCreate(data);\n\n\t\t\tif(m->body_last->t_line == NULL) {\n\t\t\t\tmessageDedup(m);\n\t\t\t\tm->body_last->t_line = lineCreate(data);\n\n\t\t\t\tif(m->body_last->t_line == NULL) {\n\t\t\t\t\tcli_errmsg(\"messageAddStr: out of memory\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* cli_chomp(m->body_last->t_text); */\n\t\t\tmessageIsEncoding(m);\n\t\t}\n\t} else\n\t\tm->body_last->t_line = NULL;\n\n\treturn 1;\n}\n\n/*\n * Add the given line to the start of the given message\n * A copy of the given line is taken which the caller must free\n * Line must not be terminated by a \\n\n */\nint\nmessageAddStrAtTop(message *m, const char *data)\n{\n\ttext *oldfirst;\n\n\tassert(m != NULL);\n\n\tif(m->body_first == NULL)\n\t\treturn messageAddLine(m, lineCreate(data));\n\n\toldfirst = m->body_first;\n\tm->body_first = (text *)cli_malloc(sizeof(text));\n\tif(m->body_first == NULL) {\n\t\tm->body_first = oldfirst;\n\t\treturn -1;\n\t}\n\n\tm->body_first->t_next = oldfirst;\n\tm->body_first->t_line = lineCreate((data) ? data : \"\");\n\n\tif(m->body_first->t_line == NULL) {\n\t\tcli_errmsg(\"messageAddStrAtTop: out of memory\\n\");\n\t\treturn -1;\n\t}\n\treturn 1;\n}\n\n/*\n * Put the contents of the given text at the end of the current object.\n * Can be used either to move a text object into a message, or to move a\n * message's text into another message only moving from a given offset.\n * The given text emptied; it can be used again if needed, though be warned that\n * it will have an empty line at the start.\n * Returns 0 for failure, 1 for success\n */\nint\nmessageMoveText(message *m, text *t, message *old_message)\n{\n\tint rc;\n\n\tif(m->body_first == NULL) {\n\t\tif(old_message) {\n\t\t\ttext *u;\n\t\t\t/*\n\t\t\t * t is within old_message which is about to be\n\t\t\t * destroyed\n\t\t\t */\n\t\t\tassert(old_message->body_first != NULL);\n\n\t\t\tm->body_first = t;\n\t\t\tfor(u = old_message->body_first; u != t;) {\n\t\t\t\ttext *next;\n\n\t\t\t\tif(u->t_line)\n\t\t\t\t\tlineUnlink(u->t_line);\n\t\t\t\tnext = u->t_next;\n\n\t\t\t\tfree(u);\n\t\t\t\tu = next;\n\n\t\t\t\tif(u == NULL) {\n\t\t\t\t\tcli_dbgmsg(\"messageMoveText sanity check: t not within old_message\\n\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(old_message->body_last->t_next == NULL);\n\n\t\t\tm->body_last = old_message->body_last;\n\t\t\told_message->body_first = old_message->body_last = NULL;\n\n\t\t\t/* Do any pointers need to be reset? */\n\t\t\tif((old_message->bounce == NULL) &&\n\t\t\t   (old_message->encoding == NULL) &&\n\t\t\t   (old_message->binhex == NULL) &&\n\t\t\t   (old_message->yenc == NULL))\n\t\t\t\treturn 0;\n\n\t\t\tm->body_last = m->body_first;\n\t\t\trc = 0;\n\t\t} else {\n\t\t\tm->body_last = m->body_first = textMove(NULL, t);\n\t\t\tif(m->body_first == NULL)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\trc = 0;\n\t\t}\n\t} else {\n\t\tm->body_last = textMove(m->body_last, t);\n\t\tif(m->body_last == NULL) {\n\t\t\trc = -1;\n\t\t\tm->body_last = m->body_first;\n\t\t} else\n\t\t\trc = 0;\n\t}\n\n\twhile(m->body_last->t_next) {\n\t\tm->body_last = m->body_last->t_next;\n\t\tif(m->body_last->t_line)\n\t\t\tmessageIsEncoding(m);\n\t}\n\n\treturn rc;\n}\n\n/*\n * See if the last line marks the start of a non MIME inclusion that\n * will need to be scanned\n */\nstatic void\nmessageIsEncoding(message *m)\n{\n\tstatic const char encoding[] = \"Content-Transfer-Encoding\";\n\tstatic const char binhex[] = \"(This file must be converted with BinHex 4.0)\";\n\tconst char *line = lineGetData(m->body_last->t_line);\n\n\t/*if(m->ctx == NULL)\n\t\tcli_dbgmsg(\"messageIsEncoding, ctx == NULL\\n\");*/\n\n\tif((m->encoding == NULL) &&\n\t   (strncasecmp(line, encoding, sizeof(encoding) - 1) == 0) &&\n\t   (strstr(line, \"7bit\") == NULL))\n\t\tm->encoding = m->body_last;\n\telse if((m->bounce == NULL) && m->ctx &&\n\t\t(strncasecmp(line, \"Received: \", 10) == 0) &&\n\t\t(cli_filetype((const unsigned char *)line, strlen(line), m->ctx->engine) == CL_TYPE_MAIL))\n\t\t\tm->bounce = m->body_last;\n\t\t/* Not needed with fast track visa technology */\n\t/*else if((m->uuencode == NULL) && isuuencodebegin(line))\n\t\tm->uuencode = m->body_last;*/\n\telse if((m->binhex == NULL) &&\n\t\tstrstr(line, \"BinHex\") &&\n\t\t(simil(line, binhex) > 90))\n\t\t\t/*\n\t\t\t * Look for close matches for BinHex, but\n\t\t\t * simil() is expensive so only do it if it's\n\t\t\t * likely to be found\n\t\t\t */\n\t\t\tm->binhex = m->body_last;\n\telse if((m->yenc == NULL) && (strncmp(line, \"=ybegin line=\", 13) == 0))\n\t\tm->yenc = m->body_last;\n}\n\n/*\n * Returns a pointer to the body of the message. Note that it does NOT return\n * a copy of the data\n */\ntext *\nmessageGetBody(message *m)\n{\n\tassert(m != NULL);\n\treturn m->body_first;\n}\n\n/*\n * Export a message using the given export routines\n *\n * TODO: It really should export into an array, one\n * for each encoding algorithm. However, what it does is it returns the\n * last item that was exported. That's sufficient for now.\n */\nstatic void *\nmessageExport(message *m, const char *dir, void *(*create)(void), void (*destroy)(void *), void (*setFilename)(void *, const char *, const char *), void (*addData)(void *, const unsigned char *, size_t), void *(*exportText)(text *, void *, int), void(*setCTX)(void *, cli_ctx *), int destroy_text)\n{\n\tvoid *ret;\n\ttext *t_line;\n\tchar *filename;\n\tint i;\n\n\tassert(m != NULL);\n\n\tif(messageGetBody(m) == NULL)\n\t\treturn NULL;\n\n\tret = (*create)();\n\n\tif(ret == NULL)\n\t\treturn NULL;\n\n\tcli_dbgmsg(\"messageExport: numberOfEncTypes == %d\\n\", m->numberOfEncTypes);\n\n\tif(m->numberOfEncTypes == 0) {\n\t\t/*\n\t\t * Fast copy\n\t\t */\n\t\tcli_dbgmsg(\"messageExport: Entering fast copy mode\\n\");\n\n#if\t0\n\t\tfilename = messageGetFilename(m);\n\n\t\tif(filename == NULL) {\n\t\t\tcli_dbgmsg(\"Unencoded attachment sent with no filename\\n\");\n\t\t\tmessageAddArgument(m, \"name=attachment\");\n\t\t} else if((strcmp(filename, \"textportion\") != 0) && (strcmp(filename, \"mixedtextportion\") != 0))\n\t\t\t/*\n\t\t\t * Some virus attachments don't say how they've\n\t\t\t * been encoded. We assume base64\n\t\t\t */\n\t\t\tmessageSetEncoding(m, \"base64\");\n#else\n\t\tfilename = (char *)messageFindArgument(m, \"filename\");\n\t\tif(filename == NULL) {\n\t\t\tfilename = (char *)messageFindArgument(m, \"name\");\n\n\t\t\tif(filename == NULL) {\n\t\t\t\tcli_dbgmsg(\"Unencoded attachment sent with no filename\\n\");\n\t\t\t\tmessageAddArgument(m, \"name=attachment\");\n\t\t\t} else\n\t\t\t\t/*\n\t\t\t\t * Some virus attachments don't say how they've\n\t\t\t\t * been encoded. We assume base64.\n\t\t\t\t * RFC says encoding should be 7-bit.\n\t\t\t\t */\n\t\t\t\tmessageSetEncoding(m, \"7-bit\");\n\t\t}\n#endif\n\n\t\t(*setFilename)(ret, dir, (filename && *filename) ? filename : \"attachment\");\n\n\t\tif(filename)\n\t\t\tfree((char *)filename);\n\n\t\tif(m->numberOfEncTypes == 0)\n\t\t\treturn exportText(messageGetBody(m), ret, destroy_text);\n\t}\n\n\tif(setCTX && m->ctx)\n\t\t(*setCTX)(ret, m->ctx);\n\n\tfor(i = 0; i < m->numberOfEncTypes; i++) {\n\t\tencoding_type enctype = m->encodingTypes[i];\n\t\tsize_t size;\n\n\t\tif(i > 0) {\n\t\t\tvoid *newret;\n\n\t\t\tnewret = (*create)();\n\t\t\tif(newret == NULL) {\n\t\t\t\tcli_dbgmsg(\"Not all decoding algorithms were run\\n\");\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t(*destroy)(ret);\n\t\t\tret = newret;\n\t\t}\n\t\tcli_dbgmsg(\"messageExport: enctype %d is %d\\n\", i, (int)enctype);\n\t\t/*\n\t\t * Find the filename to decode\n\t\t */\n\t\tif(((enctype == YENCODE) || (i == 0)) && yEncBegin(m)) {\n\t\t\tconst char *f;\n\n\t\t\t/*\n\t\t\t * TODO: handle multipart yEnc encoded files\n\t\t\t */\n\t\t\tt_line = yEncBegin(m);\n\t\t\tf = lineGetData(t_line->t_line);\n\n\t\t\tif((filename = strstr(f, \" name=\")) != NULL) {\n\t\t\t\tfilename = cli_strdup(&filename[6]);\n\t\t\t\tif(filename) {\n\t\t\t\t\tcli_chomp(filename);\n\t\t\t\t\tstrstrip(filename);\n\t\t\t\t\tcli_dbgmsg(\"Set yEnc filename to \\\"%s\\\"\\n\", filename);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t(*setFilename)(ret, dir, (filename && *filename) ? filename : \"attachment\");\n\t\t\tif(filename) {\n\t\t\t\tfree((char *)filename);\n\t\t\t\tfilename = NULL;\n\t\t\t}\n\t\t\tt_line = t_line->t_next;\n\t\t\tenctype = YENCODE;\n\t\t\tm->yenc = NULL;\n\t\t} else {\n\t\t\tif(enctype == UUENCODE) {\n\t\t\t\t/*\n\t\t\t\t * The body will have been stripped out by the\n\t\t\t\t * fast track visa system. Treat as plain/text,\n\t\t\t\t * which means we'll still scan for funnies\n\t\t\t\t * outside of the uuencoded portion.\n\t\t\t\t */\n\t\t\t\tcli_dbgmsg(\"messageExport: treat uuencode as text/plain\\n\");\n\t\t\t\tenctype = m->encodingTypes[i] = NOENCODING;\n\t\t\t}\n\t\t\tfilename = messageGetFilename(m);\n\n\t\t\tif(filename == NULL) {\n\t\t\t\tcli_dbgmsg(\"Attachment sent with no filename\\n\");\n\t\t\t\tmessageAddArgument(m, \"name=attachment\");\n\t\t\t} else if(enctype == NOENCODING)\n\t\t\t\t/*\n\t\t\t\t * Some virus attachments don't say how\n\t\t\t\t * they've been encoded. We assume\n\t\t\t\t * base64.\n\t\t\t\t *\n\t\t\t\t * FIXME: don't do this if it's a fall\n\t\t\t\t * through from uuencode\n\t\t\t\t */\n\t\t\t\tmessageSetEncoding(m, \"base64\");\n\n\t\t\t(*setFilename)(ret, dir, (filename && *filename) ? filename : \"attachment\");\n\n\t\t\tt_line = messageGetBody(m);\n\t\t}\n\n\t\tif(filename)\n\t\t\tfree((char *)filename);\n\n\t\t/*\n\t\t * t_line should now point to the first (encoded) line of the\n\t\t * message\n\t\t */\n\t\tif(t_line == NULL) {\n\t\t\tcli_dbgmsg(\"Empty attachment not saved\\n\");\n\t\t\t(*destroy)(ret);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tif(enctype == NOENCODING) {\n\t\t\t/*\n\t\t\t * Fast copy\n\t\t\t */\n\t\t\tif(i == m->numberOfEncTypes - 1) {\n\t\t\t\t/* last one */\n\t\t\t\t(void)exportText(t_line, ret, destroy_text);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t(void)exportText(t_line, ret, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\tsize = 0;\n\t\tdo {\n\t\t\tunsigned char smallbuf[1024];\n\t\t\tunsigned char *uptr, *data;\n\t\t\tconst char *line = lineGetData(t_line->t_line);\n\t\t\tunsigned char *bigbuf;\n\t\t\tsize_t datasize;\n\n\t\t\tif(enctype == YENCODE) {\n\t\t\t\tif(line == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(strncmp(line, \"=yend \", 6) == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Add two bytes for '\\n' and '\\0'\n\t\t\t */\n\t\t\tdatasize = (line) ? strlen(line) + 2 : 0;\n\n\t\t\tif(datasize >= sizeof(smallbuf))\n\t\t\t\tdata = bigbuf = (unsigned char *)cli_malloc(datasize);\n\t\t\telse {\n\t\t\t\tbigbuf = NULL;\n\t\t\t\tdata = smallbuf;\n\t\t\t\tdatasize = sizeof(smallbuf);\n\t\t\t}\n\n\t\t\tuptr = decodeLine(m, enctype, line, data, datasize);\n\t\t\tif(uptr == NULL) {\n\t\t\t\tif(data == bigbuf)\n\t\t\t\t\tfree(data);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(uptr != data) {\n\t\t\t\tassert((size_t)(uptr - data) < datasize);\n\t\t\t\t(*addData)(ret, data, (size_t)(uptr - data));\n\t\t\t\tsize += (size_t)(uptr - data);\n\t\t\t}\n\n\t\t\tif(data == bigbuf)\n\t\t\t\tfree(data);\n\n\t\t\t/*\n\t\t\t * According to RFC2045, '=' is used to pad out\n\t\t\t * the last byte and should be used as evidence\n\t\t\t * of the end of the data. Some mail clients\n\t\t\t * annoyingly then put plain text after the '='\n\t\t\t * byte and viruses exploit this bug. Sigh\n\t\t\t */\n\t\t\t/*if(enctype == BASE64)\n\t\t\t\tif(strchr(line, '='))\n\t\t\t\t\tbreak;*/\n\t\t\tif(line && destroy_text && (i == m->numberOfEncTypes - 1)) {\n\t\t\t\tlineUnlink(t_line->t_line);\n\t\t\t\tt_line->t_line = NULL;\n\t\t\t}\n\t\t} while((t_line = t_line->t_next) != NULL);\n\n\t\tcli_dbgmsg(\"Exported %lu bytes using enctype %d\\n\",\n\t\t\t(unsigned long)size, (int)enctype);\n\n\t\t/* Verify we have nothing left to flush out */\n\t\tif(m->base64chars) {\n\t\t\tunsigned char data[4];\n\t\t\tunsigned char *ptr;\n\n\t\t\tptr = base64Flush(m, data);\n\t\t\tif(ptr)\n\t\t\t\t(*addData)(ret, data, (size_t)(ptr - data));\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nunsigned char *\nbase64Flush(message *m, unsigned char *buf)\n{\n\tcli_dbgmsg(\"%d trailing bytes to export\\n\", m->base64chars);\n\n\tif(m->base64chars) {\n\t\tunsigned char *ret = decode(m, NULL, buf, base64, FALSE);\n\n\t\tm->base64chars = 0;\n\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\nint messageSavePartial(message *m, const char *dir, const char *md5id, unsigned part)\n{\n\tchar fullname[1024];\n\tfileblob *fb;\n\tunsigned long time_val;\n\n\tcli_dbgmsg(\"messageSavePartial\\n\");\n\ttime_val  = time(NULL);\n\tsnprintf(fullname, 1024, \"%s\"PATHSEP\"clamav-partial-%lu_%s-%u\", dir, time_val, md5id, part);\n\n\tfb = messageExport(m, fullname,\n\t\t(void *(*)(void))fileblobCreate,\n\t\t(void(*)(void *))fileblobDestroy,\n\t\t(void(*)(void *, const char *, const char *))fileblobPartialSet,\n\t\t(void(*)(void *, const unsigned char *, size_t))fileblobAddData,\n\t\t(void *(*)(text *, void *, int))textToFileblob,\n\t\t(void(*)(void *, cli_ctx *))fileblobSetCTX,\n\t\t0);\n\tif(!fb)\n\t\treturn CL_EFORMAT;\n\tfileblobDestroy(fb);\n\treturn CL_SUCCESS;\n}\n\n/*\n * Decode and transfer the contents of the message into a fileblob\n * The caller must free the returned fileblob\n */\nfileblob *\nmessageToFileblob(message *m, const char *dir, int destroy)\n{\n\tfileblob *fb;\n\n\tcli_dbgmsg(\"messageToFileblob\\n\");\n\tfb = messageExport(m, dir,\n\t\t(void *(*)(void))fileblobCreate,\n\t\t(void(*)(void *))fileblobDestroy,\n\t\t(void(*)(void *, const char *, const char *))fileblobSetFilename,\n\t\t(void(*)(void *, const unsigned char *, size_t))fileblobAddData,\n\t\t(void *(*)(text *, void *, int))textToFileblob,\n\t\t(void(*)(void *, cli_ctx *))fileblobSetCTX,\n\t\tdestroy);\n\tif(destroy && m->body_first) {\n\t\ttextDestroy(m->body_first);\n\t\tm->body_first = m->body_last = NULL;\n\t}\n\treturn fb;\n}\n\n/*\n * Decode and transfer the contents of the message into a closed blob\n * The caller must free the returned blob\n */\nblob *\nmessageToBlob(message *m, int destroy)\n{\n\tblob *b;\n\n\tcli_dbgmsg(\"messageToBlob\\n\");\n\n\tb = messageExport(m, NULL,\n\t\t(void *(*)(void))blobCreate,\n\t\t(void(*)(void *))blobDestroy,\n\t\t(void(*)(void *, const char *, const char *))blobSetFilename,\n\t\t(void(*)(void *, const unsigned char *, size_t))blobAddData,\n\t\t(void *(*)(text *, void *, int))textToBlob,\n\t\t(void(*)(void *, cli_ctx *))NULL,\n\t\tdestroy);\n\n\tif(destroy && m->body_first) {\n\t\ttextDestroy(m->body_first);\n\t\tm->body_first = m->body_last = NULL;\n\t}\n\treturn b;\n}\n\n/*\n * Decode and transfer the contents of the message into a text area\n * The caller must free the returned text\n */\ntext *\nmessageToText(message *m)\n{\n\tint i;\n\ttext *first = NULL, *last = NULL;\n\tconst text *t_line;\n\n\tassert(m != NULL);\n\n\tif(m->numberOfEncTypes == 0) {\n\t\t/*\n\t\t * Fast copy\n\t\t */\n\t\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next) {\n\t\t\tif(first == NULL)\n\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\telse {\n\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\tlast = last->t_next;\n\t\t\t}\n\n\t\t\tif(last == NULL) {\n\t\t\t\tif(first)\n\t\t\t\t\ttextDestroy(first);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif(t_line->t_line)\n\t\t\t\tlast->t_line = lineLink(t_line->t_line);\n\t\t\telse\n\t\t\t\tlast->t_line = NULL;\t/* empty line */\n\t\t}\n\t\tif(last)\n\t\t\tlast->t_next = NULL;\n\n\t\treturn first;\n\t}\n\t/*\n\t * Scan over the data a number of times once for each claimed encoding\n\t * type\n\t */\n\tfor(i = 0; i < m->numberOfEncTypes; i++) {\n\t\tconst encoding_type enctype = m->encodingTypes[i];\n\n\t\tcli_dbgmsg(\"messageToText: export transfer method %d = %d\\n\",\n\t\t\ti, (int)enctype);\n\n\t\tswitch(enctype) {\n\t\t\tcase NOENCODING:\n\t\t\tcase BINARY:\n\t\t\tcase EIGHTBIT:\n\t\t\t\t/*\n\t\t\t\t * Fast copy\n\t\t\t\t */\n\t\t\t\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next) {\n\t\t\t\t\tif(first == NULL)\n\t\t\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\t\t\telse if (last) {\n\t\t\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\t\t\tlast = last->t_next;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(last == NULL) {\n\t\t\t\t\t\tif(first) {\n\t\t\t\t\t\t\ttextDestroy(first);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn NULL;\n\t\t\t\t\t}\n\t\t\t\t\tif(t_line->t_line)\n\t\t\t\t\t\tlast->t_line = lineLink(t_line->t_line);\n\t\t\t\t\telse\n\t\t\t\t\t\tlast->t_line = NULL;\t/* empty line */\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\tcase UUENCODE:\n\t\t\t\tcli_warnmsg(\"messageToText: Unexpected attempt to handle uuencoded file\\n\");\n\t\t\t\tif(first) {\n\t\t\t\t\tif(last)\n\t\t\t\t\t\tlast->t_next = NULL;\n\t\t\t\t\ttextDestroy(first);\n\t\t\t\t}\n\t\t\t\treturn NULL;\n\t\t\tcase YENCODE:\n\t\t\t\tt_line = yEncBegin(m);\n\n\t\t\t\tif(t_line == NULL) {\n\t\t\t\t\t/*cli_warnmsg(\"YENCODED attachment is missing begin statement\\n\");*/\n\t\t\t\t\tif(first) {\n\t\t\t\t\t\tif(last)\n\t\t\t\t\t\t\tlast->t_next = NULL;\n\t\t\t\t\t\ttextDestroy(first);\n\t\t\t\t\t}\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\tt_line = t_line->t_next;\n\t\t\tdefault:\n\t\t\t\tif((i == 0) && binhexBegin(m))\n\t\t\t\t\tcli_warnmsg(\"Binhex messages not supported yet.\\n\");\n\t\t\t\tt_line = messageGetBody(m);\n\t\t}\n\n\t\tfor(; t_line; t_line = t_line->t_next) {\n\t\t\tunsigned char data[1024];\n\t\t\tunsigned char *uptr;\n\t\t\tconst char *line = lineGetData(t_line->t_line);\n\n\t\t\tif(enctype == BASE64)\n\t\t\t\t/*\n\t\t\t\t * ignore blanks - breaks RFC which is\n\t\t\t\t * probably the point!\n\t\t\t\t */\n\t\t\t\tif(line == NULL)\n\t\t\t\t\tcontinue;\n\n\t\t\tassert((line == NULL) || (strlen(line) <= sizeof(data)));\n\n\t\t\tuptr = decodeLine(m, enctype, line, data, sizeof(data));\n\n\t\t\tif(uptr == NULL)\n\t\t\t\tbreak;\n\n\t\t\tassert(uptr <= &data[sizeof(data)]);\n\n\t\t\tif(first == NULL)\n\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\telse if (last) {\n\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\tlast = last->t_next;\n\t\t\t}\n\n\t\t\tif(last == NULL)\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * If the decoded line is the same as the encoded\n\t\t\t * there's no need to take a copy, just link it.\n\t\t\t * Note that the comparison is done without the\n\t\t\t * trailing newline that the decoding routine may have\n\t\t\t * added - that's why there's a strncmp rather than a\n\t\t\t * strcmp - that'd be bad for MIME decoders, but is OK\n\t\t\t * for AV software\n\t\t\t */\n\t\t\tif((data[0] == '\\n') || (data[0] == '\\0'))\n\t\t\t\tlast->t_line = NULL;\n\t\t\telse if(line && (strncmp((const char *)data, line, strlen(line)) == 0)) {\n#ifdef\tCL_DEBUG\n\t\t\t\tcli_dbgmsg(\"messageToText: decoded line is the same(%s)\\n\", data);\n#endif\n\t\t\t\tlast->t_line = lineLink(t_line->t_line);\n\t\t\t} else\n\t\t\t\tlast->t_line = lineCreate((char *)data);\n\n\t\t\tif(line && enctype == BASE64)\n\t\t\t\tif(strchr(line, '='))\n\t\t\t\t\tbreak;\n\t\t}\n\t\tif(m->base64chars) {\n\t\t\tunsigned char data[4];\n\n\t\t\tmemset(data, '\\0', sizeof(data));\n\t\t\tif(decode(m, NULL, data, base64, FALSE) && data[0]) {\n\t\t\t\tif(first == NULL)\n\t\t\t\t\tfirst = last = cli_malloc(sizeof(text));\n\t\t\t\telse if (last) {\n\t\t\t\t\tlast->t_next = cli_malloc(sizeof(text));\n\t\t\t\t\tlast = last->t_next;\n\t\t\t\t}\n\n\t\t\t\tif(last != NULL)\n\t\t\t\t\tlast->t_line = lineCreate((char *)data);\n\t\t\t}\n\t\t\tm->base64chars = 0;\n\t\t}\n\t}\n\n\tif(last)\n\t\tlast->t_next = NULL;\n\n\treturn first;\n}\n\ntext *\nyEncBegin(message *m)\n{\n\treturn m->yenc;\n}\n\n/*\n * Scan to find the BINHEX message (if any)\n */\n#if\t0\nconst text *\nbinhexBegin(message *m)\n{\n\tconst text *t_line;\n\n\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)\n\t\tif(strcasecmp(t_line->t_text, \"(This file must be converted with BinHex 4.0)\") == 0)\n\t\t\treturn t_line;\n\n\treturn NULL;\n}\n#else\ntext *\nbinhexBegin(message *m)\n{\n\treturn m->binhex;\n}\n#endif\n\n/*\n * Scan to find a bounce message. There is no standard for these, not\n * even a convention, so don't expect this to be foolproof\n */\n#if\t0\ntext *\nbounceBegin(message *m)\n{\n\tconst text *t_line;\n\n\tfor(t_line = messageGetBody(m); t_line; t_line = t_line->t_next)\n\t\tif(cli_filetype(t_line->t_text, strlen(t_line->t_text)) == CL_TYPE_MAIL)\n\t\t\treturn t_line;\n\n\treturn NULL;\n}\n#else\ntext *\nbounceBegin(message *m)\n{\n\treturn m->bounce;\n}\n#endif\n\n/*\n * If a message doesn't not contain another message which could be harmful\n * it is deemed to be safe.\n *\n * TODO: ensure nothing can get through this\n *\n * TODO: check to see if we need to\n * find anything else, perhaps anything\n * from the RFC821 table?\n */\n#if\t0\nint\nmessageIsAllText(const message *m)\n{\n\tconst text *t;\n\n\tfor(t = messageGetBody(m); t; t = t->t_next)\n\t\tif(strncasecmp(t->t_text,\n\t\t\t\"Content-Transfer-Encoding\",\n\t\t\tstrlen(\"Content-Transfer-Encoding\")) == 0)\n\t\t\t\treturn 0;\n\n\treturn 1;\n}\n#else\ntext *\nencodingLine(message *m)\n{\n\treturn m->encoding;\n}\n#endif\n\n/*\n * Decode a line and add it to a buffer, return the end of the buffer\n * to help appending callers. There is no new line at the end of \"line\"\n *\n * len is sizeof(ptr)\n */\nunsigned char *\ndecodeLine(message *m, encoding_type et, const char *line, unsigned char *buf, size_t buflen)\n{\n\tsize_t len, reallen;\n\tbool softbreak;\n\tchar *p2, *copy;\n\tchar base64buf[RFC2045LENGTH + 1];\n\n\t/*cli_dbgmsg(\"decodeLine(et = %d buflen = %u)\\n\", (int)et, buflen);*/\n\n\tassert(m != NULL);\n\tassert(buf != NULL);\n\n\tswitch(et) {\n\t\tcase BINARY:\n\t\t\t/*\n\t\t\t * TODO: find out what this is, encoded as binary??\n\t\t\t */\n\t\t\t/* fall through */\n\t\tcase NOENCODING:\n\t\tcase EIGHTBIT:\n\t\tdefault:\t/* unknown encoding type - try our best */\n\t\t\tif(line)\t/* empty line? */\n\t\t\t\tbuf = (unsigned char *)cli_strrcpy((char *)buf, line);\n\t\t\t/* Put the new line back in */\n\t\t\treturn (unsigned char *)cli_strrcpy((char *)buf, \"\\n\");\n\n\t\tcase QUOTEDPRINTABLE:\n\t\t\tif(line == NULL) {\t/* empty line */\n\t\t\t\t*buf++ = '\\n';\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tsoftbreak = FALSE;\n\t\t\twhile(buflen && *line) {\n\t\t\t\tif(*line == '=') {\n\t\t\t\t\tunsigned char byte;\n\n\t\t\t\t\tif((*++line == '\\0') || (*line == '\\n')) {\n\t\t\t\t\t\tsoftbreak = TRUE;\n\t\t\t\t\t\t/* soft line break */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbyte = hex(*line);\n\n\t\t\t\t\tif((*++line == '\\0') || (*line == '\\n')) {\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * broken e-mail, not\n\t\t\t\t\t\t * adhering to RFC2045\n\t\t\t\t\t\t */\n\t\t\t\t\t\t*buf++ = byte;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t/*\n\t\t\t\t\t * Handle messages that use a broken\n\t\t\t\t\t * quoted-printable encoding of\n\t\t\t\t\t * href=\\\"http://, instead of =3D\n\t\t\t\t\t */\n\t\t\t\t\tif(byte != '=')\n\t\t\t\t\t\tbyte = (byte << 4) | hex(*line);\n\t\t\t\t\telse\n\t\t\t\t\t\tline -= 2;\n\n\t\t\t\t\t*buf++ = byte;\n\t\t\t\t} else\n\t\t\t\t\t*buf++ = *line;\n\t\t\t\t++line;\n\t\t\t\t--buflen;\n\t\t\t}\n\t\t\tif(!softbreak)\n\t\t\t\t/* Put the new line back in */\n\t\t\t\t*buf++ = '\\n';\n\t\t\tbreak;\n\n\t\tcase BASE64:\n\t\t\tif(line == NULL)\n\t\t\t\tbreak;\n\t\t\t/*\n\t\t\t * RFC2045 sets the maximum length to 76 bytes\n\t\t\t * but many e-mail clients ignore that\n\t\t\t */\n\t\t\tif(strlen(line) < sizeof(base64buf)) {\n\t\t\t\tstrcpy(base64buf, line);\n\t\t\t\tcopy = base64buf;\n\t\t\t} else {\n\t\t\t\tcopy = cli_strdup(line);\n\t\t\t\tif(copy == NULL)\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tp2 = strchr(copy, '=');\n\t\t\tif(p2)\n\t\t\t\t*p2 = '\\0';\n\n\t\t\tsanitiseBase64(copy);\n\n\t\t\t/*\n\t\t\t * Klez doesn't always put \"=\" on the last line\n\t\t\t */\n\t\t\tbuf = decode(m, copy, buf, base64, (p2 == NULL) && ((strlen(copy) & 3) == 0));\n\n\t\t\tif(copy != base64buf)\n\t\t\t\tfree(copy);\n\t\t\tbreak;\n\n\t\tcase UUENCODE:\n\t\t\tassert(m->base64chars == 0);\n\n\t\t\tif((line == NULL) || (*line == '\\0'))\t/* empty line */\n\t\t\t\tbreak;\n\t\t\tif(strcasecmp(line, \"end\") == 0)\n\t\t\t\tbreak;\n\t\t\tif(isuuencodebegin(line))\n\t\t\t\tbreak;\n\n\t\t\tif((line[0] & 0x3F) == ' ')\n\t\t\t\tbreak;\n\n\t\t\t/*\n\t\t\t * reallen contains the number of bytes that were\n\t\t\t *\tencoded\n\t\t\t */\n\t\t\treallen = (size_t)uudecode(*line++);\n\t\t\tif(reallen <= 0)\n\t\t\t\tbreak;\n\t\t\tif(reallen > 62)\n\t\t\t\tbreak;\n\t\t\tlen = strlen(line);\n\n\t\t\tif((len > buflen) || (reallen > len))\n\t\t\t\t/*\n\t\t\t\t * In practice this should never occur since\n\t\t\t\t * the maximum length of a uuencoded line is\n\t\t\t\t * 62 characters\n\t\t\t\t */\n\t\t\t\tcli_dbgmsg(\"uudecode: buffer overflow stopped, attempting to ignore but decoding may fail\\n\");\n\t\t\telse {\n\t\t\t\t(void)decode(m, line, buf, uudecode, (len & 3) == 0);\n\t\t\t\tbuf = &buf[reallen];\n\t\t\t}\n\t\t\tm->base64chars = 0;\t/* this happens with broken uuencoded files */\n\t\t\tbreak;\n\t\tcase YENCODE:\n\t\t\tif((line == NULL) || (*line == '\\0'))\t/* empty line */\n\t\t\t\tbreak;\n\t\t\tif(strncmp(line, \"=yend \", 6) == 0)\n\t\t\t\tbreak;\n\n\t\t\twhile(*line)\n\t\t\t\tif(*line == '=') {\n\t\t\t\t\tif(*++line == '\\0')\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t*buf++ = ((*line++ - 64) & 255);\n\t\t\t\t} else\n\t\t\t\t\t*buf++ = ((*line++ - 42) & 255);\n\t\t\tbreak;\n\t}\n\n\t*buf = '\\0';\n\treturn buf;\n}\n\n/*\n * Remove the non base64 characters such as spaces from a string. Spaces\n * shouldn't appear mid string in base64 files, but some broken mail clients\n * ignore such errors rather than discarding the mail, and virus writers\n * exploit this bug\n */\nstatic void\nsanitiseBase64(char *s)\n{\n\tcli_dbgmsg(\"sanitiseBase64 '%s'\\n\", s);\n\twhile(*s)\n\t\tif(base64Table[(unsigned int)(*s & 0xFF)] == 255) {\n\t\t\tchar *p1;\n\n\t\t\tfor(p1 = s; p1[0] != '\\0'; p1++)\n\t\t\t\tp1[0] = p1[1];\n\t\t} else\n\t\t\ts++;\n}\n\n/*\n * Returns one byte after the end of the decoded data in \"out\"\n *\n * Update m->base64chars with the last few bytes of data that we haven't\n * decoded. After the last line is found, decode will be called with in = NULL\n * to flush these out\n */\nstatic unsigned char *\ndecode(message *m, const char *in, unsigned char *out, unsigned char (*decoder)(char), bool isFast)\n{\n\tunsigned char b1, b2, b3, b4;\n\tunsigned char cb1, cb2, cb3;\t/* carried over from last line */\n\n\t/*cli_dbgmsg(\"decode %s (len %d isFast %d base64chars %d)\\n\", in,\n\t\tin ? strlen(in) : 0,\n\t\tisFast, m->base64chars);*/\n\n\tcb1 = cb2 = cb3 = '\\0';\n\n\tswitch(m->base64chars) {\n\t\tcase 3:\n\t\t\tcb3 = m->base64_3;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 2:\n\t\t\tcb2 = m->base64_2;\n\t\t\t/* FALLTHROUGH */\n\t\tcase 1:\n\t\t\tcb1 = m->base64_1;\n\t\t\tisFast = FALSE;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tassert(m->base64chars <= 3);\n\t}\n\n\tif(isFast)\n\t\t/* Fast decoding if not last line */\n\t\twhile(*in) {\n\t\t\tb1 = (*decoder)(*in++);\n\t\t\tb2 = (*decoder)(*in++);\n\t\t\tb3 = (*decoder)(*in++);\n\t\t\t/*\n\t\t\t * Put this line here to help on some compilers which\n\t\t\t * can make use of some architecure's ability to\n\t\t\t * multiprocess when different variables can be\n\t\t\t * updated at the same time - here b3 is used in\n\t\t\t * one line, b1/b2 in the next and b4 in the next after\n\t\t\t * that, b3 and b4 rely on in but b1/b2 don't\n\t\t\t */\n\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\tb4 = (*decoder)(*in++);\n\t\t\t*out++ = (b2 << 4) | ((b3 >> 2) & 0xF);\n\t\t\t*out++ = (b3 << 6) | (b4 & 0x3F);\n\t\t}\n\telse if(in == NULL) {\t/* flush */\n\t\tint nbytes;\n\n\t\tif(m->base64chars == 0)\n\t\t\treturn out;\n\n\t\tcli_dbgmsg(\"base64chars = %d (%c %c %c)\\n\", m->base64chars,\n\t\t\tisalnum(cb1) ? cb1 : '@',\n\t\t\tisalnum(cb2) ? cb2 : '@',\n\t\t\tisalnum(cb3) ? cb3 : '@');\n\n\t\tm->base64chars--;\n\t\tb1 = cb1;\n\t\tnbytes = 1;\n\n\t\tif(m->base64chars) {\n\t\t\tm->base64chars--;\n\t\t\tb2 = cb2;\n\n\t\t\tif(m->base64chars) {\n\t\t\t\tnbytes = 2;\n\t\t\t\tm->base64chars--;\n\t\t\t\tb3 = cb3;\n\t\t\t\tnbytes = 3;\n\t\t\t} else if(b2)\n\t\t\t\tnbytes = 2;\n\t\t}\n\n\t\tswitch(nbytes) {\n\t\t\tcase 3:\n\t\t\t\tb4 = '\\0';\n\t\t\t\t/* fall through */\n\t\t\tcase 4:\n\t\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\t\t*out++ = (b2 << 4) | ((b3 >> 2) & 0xF);\n\t\t\t\tif((nbytes == 4) || (b3&0x3))\n\t\t\t\t\t*out++ = (b3 << 6) | (b4 & 0x3F);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\t\tif((b2 << 4) & 0xFF)\n\t\t\t\t\t*out++ = b2 << 4;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t*out++ = b1 << 2;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t}\n\t} else while(*in) {\n\t\tint nbytes;\n\n\t\tif(m->base64chars) {\n\t\t\tm->base64chars--;\n\t\t\tb1 = cb1;\n\t\t} else\n\t\t\tb1 = (*decoder)(*in++);\n\n\t\tif(*in == '\\0') {\n\t\t\tb2 = '\\0';\n\t\t\tnbytes = 1;\n\t\t} else {\n\t\t\tif(m->base64chars) {\n\t\t\t\tm->base64chars--;\n\t\t\t\tb2 = cb2;\n\t\t\t} else\n\t\t\t\tb2 = (*decoder)(*in++);\n\n\t\t\tif(*in == '\\0') {\n\t\t\t\tb3 = '\\0';\n\t\t\t\tnbytes = 2;\n\t\t\t} else {\n\t\t\t\tif(m->base64chars) {\n\t\t\t\t\tm->base64chars--;\n\t\t\t\t\tb3 = cb3;\n\t\t\t\t} else\n\t\t\t\t\tb3 = (*decoder)(*in++);\n\n\t\t\t\tif(*in == '\\0') {\n\t\t\t\t\tb4 = '\\0';\n\t\t\t\t\tnbytes = 3;\n\t\t\t\t} else {\n\t\t\t\t\tb4 = (*decoder)(*in++);\n\t\t\t\t\tnbytes = 4;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch(nbytes) {\n\t\t\tcase 4:\n\t\t\t\t*out++ = (b1 << 2) | ((b2 >> 4) & 0x3);\n\t\t\t\t*out++ = (b2 << 4) | ((b3 >> 2) & 0xF);\n\t\t\t\t*out++ = (b3 << 6) | (b4 & 0x3F);\n\t\t\t\tcontinue;\n\t\t\tcase 3:\n\t\t\t\tm->base64_3 = b3;\n\t\t\tcase 2:\n\t\t\t\tm->base64_2 = b2;\n\t\t\tcase 1:\n\t\t\t\tm->base64_1 = b1;\n\t\t\t\tm->base64chars = nbytes;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t}\n\t\tbreak;\t/* nbytes != 4 => EOL */\n\t}\n\treturn out;\n}\n\nstatic unsigned char\nhex(char c)\n{\n\tif(isdigit(c))\n\t\treturn c - '0';\n\tif((c >= 'A') && (c <= 'F'))\n\t\treturn c - 'A' + 10;\n\tif((c >= 'a') && (c <= 'f'))\n\t\treturn c - 'a' + 10;\n\tcli_dbgmsg(\"Illegal hex character '%c'\\n\", c);\n\n\t/*\n\t * Some mails (notably some spam) break RFC2045 by failing to encode\n\t * the '=' character\n\t */\n\treturn '=';\n}\n\nstatic unsigned char\nbase64(char c)\n{\n\tconst unsigned char ret = base64Table[(unsigned int)(c & 0xFF)];\n\n\tif(ret == 255) {\n\t\t/*cli_dbgmsg(\"Illegal character <%c> in base64 encoding\\n\", c);*/\n\t\treturn 63;\n\t}\n\treturn ret;\n}\n\nstatic unsigned char\nuudecode(char c)\n{\n\treturn c - ' ';\n}\n\n/*\n * These are the only arguments we're interested in.\n * Do 'fgrep messageFindArgument *.c' if you don't believe me!\n * It's probably not good doing this since each time a new\n * messageFindArgument is added I need to remember to look here,\n * but it can save a lot of memory...\n */\nstatic int\nusefulArg(const char *arg)\n{\n\tif((strncasecmp(arg, \"name\", 4) != 0) &&\n\t   (strncasecmp(arg, \"filename\", 8) != 0) &&\n\t   (strncasecmp(arg, \"boundary\", 8) != 0) &&\n\t   (strncasecmp(arg, \"protocol\", 8) != 0) &&\n\t   (strncasecmp(arg, \"id\", 2) != 0) &&\n\t   (strncasecmp(arg, \"number\", 6) != 0) &&\n\t   (strncasecmp(arg, \"total\", 5) != 0) &&\n\t   (strncasecmp(arg, \"type\", 4) != 0)) {\n\t\tcli_dbgmsg(\"Discarding unwanted argument '%s'\\n\", arg);\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nvoid\nmessageSetCTX(message *m, cli_ctx *ctx)\n{\n\tm->ctx = ctx;\n}\n\nint\nmessageContainsVirus(const message *m)\n{\n\treturn m->isInfected ? TRUE : FALSE;\n}\n\n/*\n * We've run out of memory. Try to recover some by\n * deduping the message\n *\n * FIXME: this can take a long time. The real solution is for system admins\n *\tto refrain from setting ulimits too low, then this routine won't be\n *\tcalled\n */\nstatic void\nmessageDedup(message *m)\n{\n\tconst text *t1;\n\tsize_t saved = 0;\n\n\tcli_dbgmsg(\"messageDedup\\n\");\n\n\tt1 = m->dedupedThisFar ? m->dedupedThisFar : m->body_first;\n\n\tfor(t1 = m->body_first; t1; t1 = t1->t_next) {\n\t\tconst char *d1;\n\t\ttext *t2;\n\t\tline_t *l1;\n\t\tunsigned int r1;\n\n\t\tif(saved >= 100*1000)\n\t\t\tbreak;\t/* that's enough */\n\t\tl1 = t1->t_line;\n\t\tif(l1 == NULL)\n\t\t\tcontinue;\n\t\td1 = lineGetData(l1);\n\t\tif(strlen(d1) < 8)\n\t\t\tcontinue;\t/* wouldn't recover many bytes */\n\n\t\tr1 = (unsigned int)lineGetRefCount(l1);\n\t\tif(r1 == 255)\n\t\t\tcontinue;\n\t\t/*\n\t\t * We don't want to foul up any pointers\n\t\t */\n\t\tif(t1 == m->encoding)\n\t\t\tcontinue;\n\t\tif(t1 == m->bounce)\n\t\t\tcontinue;\n\t\tif(t1 == m->binhex)\n\t\t\tcontinue;\n\t\tif(t1 == m->yenc)\n\t\t\tcontinue;\n\n\t\tfor(t2 = t1->t_next; t2; t2 = t2->t_next) {\n\t\t\tconst char *d2;\n\t\t\tline_t *l2 = t2->t_line;\n\n\t\t\tif(l2 == NULL)\n\t\t\t\tcontinue;\n\t\t\td2 = lineGetData(l2);\n\t\t\tif(d1 == d2)\n\t\t\t\t/* already linked */\n\t\t\t\tcontinue;\n\t\t\tif(strcmp(d1, d2) == 0) {\n\t\t\t\tif(lineUnlink(l2) == NULL)\n\t\t\t\t\tsaved += strlen(d1) + 1;\n\t\t\t\tt2->t_line = lineLink(l1);\n\t\t\t\tif(t2->t_line == NULL) {\n\t\t\t\t\tcli_errmsg(\"messageDedup: out of memory\\n\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(++r1 == 255)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcli_dbgmsg(\"messageDedup reclaimed %lu bytes\\n\", (unsigned long)saved);\n\tm->dedupedThisFar = t1;\n}\n\n/*\n * Handle RFC2231 encoding. Returns a malloc'd buffer that the caller must\n * free, or NULL on error.\n *\n * TODO: Currently only handles paragraph 4 of RFC2231 e.g.\n *\t protocol*=ansi-x3.4-1968''application%2Fpgp-signature;\n */\nstatic char *\nrfc2231(const char *in)\n{\n\tconst char *ptr;\n\tchar *ret, *out;\n\tenum { LANGUAGE, CHARSET, CONTENTS } field;\n\n\tif(strstr(in, \"*0*=\") != NULL) {\n\t\tchar *p;\n\n\t\t/* Don't handle continuations, decode what we can */\n\t\tp = ret = cli_malloc(strlen(in) + 16);\n\t\tif(ret == NULL) {\n            cli_errmsg(\"rfc2331: out of memory, unable to proceed\\n\");\n\t\t\treturn NULL;\n        }\n\n\t\tdo {\n\t\t\tswitch(*in) {\n\t\t\t\tdefault:\n\t\t\t\t\t*p++ = *in++;\n\t\t\t\t\tcontinue;\n\t\t\t\tcase '*':\n\t\t\t\t\tdo\n\t\t\t\t\t\tin++;\n\t\t\t\t\twhile((*in != '*') && *in);\n\t\t\t\t\tif(*in) {\n\t\t\t\t\t\tin++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t*p = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\tcase '=':\n\t\t\t\t\t/*strcpy(p, in);*/\n\t\t\t\t\tstrcpy(p, \"=rfc2231failure\");\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t} while(*in);\n\n\t\tcli_dbgmsg(\"RFC2231 parameter continuations are not yet handled, returning \\\"%s\\\"\\n\",\n\t\t\tret);\n\t\treturn ret;\n\t}\n\n\tptr = strstr(in, \"*0=\");\n\tif(ptr != NULL)\n\t\t/*\n\t\t * Parameter continuation, with no continuation\n\t\t * Thunderbird 1.5 (and possibly other versions) does this\n\t\t */\n\t\tfield = CONTENTS;\n\telse {\n\t\tptr = strstr(in, \"*=\");\n\t\tfield = LANGUAGE;\n\t}\n\n\tif(ptr == NULL) {\t/* quick return */\n\t\tout = ret = cli_strdup(in);\n\t\twhile(*out)\n\t\t\t*out++ &= 0x7F;\n\t\treturn ret;\n\t}\n\n\tcli_dbgmsg(\"rfc2231 '%s'\\n\", in);\n\n\tret = cli_malloc(strlen(in) + 1);\n\n\tif(ret == NULL) {\n        cli_errmsg(\"rfc2331: out of memory for ret\\n\");\n\t\treturn NULL;\n    }\n\n\t/*\n\t * memcpy(out, in, (ptr - in));\n\t * out = &out[ptr - in];\n\t * in = ptr;\n\t */\n\tout = ret;\n\twhile(in != ptr)\n\t\t*out++ = *in++;\n\n\t*out++ = '=';\n\n\twhile(*ptr++ != '=')\n\t\t;\n\n\t/*\n\t * We don't do anything with the language and character set, just skip\n\t * over them!\n\t */\n\twhile(*ptr) {\n\t\tswitch(field) {\n\t\t\tcase LANGUAGE:\n\t\t\t\tif(*ptr == '\\'')\n\t\t\t\t\tfield = CHARSET;\n\t\t\t\tbreak;\n\t\t\tcase CHARSET:\n\t\t\t\tif(*ptr == '\\'')\n\t\t\t\t\tfield = CONTENTS;\n\t\t\t\tbreak;\n\t\t\tcase CONTENTS:\n\t\t\t\tif(*ptr == '%') {\n\t\t\t\t\tunsigned char byte;\n\n\t\t\t\t\tif((*++ptr == '\\0') || (*ptr == '\\n'))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tbyte = hex(*ptr);\n\n\t\t\t\t\tif((*++ptr == '\\0') || (*ptr == '\\n')) {\n\t\t\t\t\t\t*out++ = byte;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tbyte <<= 4;\n\t\t\t\t\tbyte += hex(*ptr);\n\t\t\t\t\t*out++ = byte;\n\t\t\t\t} else\n\t\t\t\t\t*out++ = *ptr;\n\t\t}\n\t\tif(*ptr++ == '\\0')\n\t\t\t/*\n\t\t\t * Incorrect message that has just one character after\n\t\t\t * a '%'.\n\t\t\t * FIXME: stash something in out that would, for example\n\t\t\t *\ttreat %2 as %02, assuming field == CONTENTS\n\t\t\t */\n\t\t\tbreak;\n\t}\n\n\tif(field != CONTENTS) {\n\t\tfree(ret);\n\t\tcli_dbgmsg(\"Invalid RFC2231 header: '%s'\\n\", in);\n\t\treturn cli_strdup(\"\");\n\t}\n\n\t*out = '\\0';\n\n\tcli_dbgmsg(\"rfc2231 returns '%s'\\n\", ret);\n\n\treturn ret;\n}\n\n/*\n * common/simil:\n *\tFrom Computing Magazine 20/8/92\n * Returns %ge number from 0 to 100 - how similar are 2 strings?\n * 100 for exact match, < for error\n */\nstruct\tpstr_list {\t/* internal stack */\n\tchar\t*d1;\n\tstruct\tpstr_list\t*next;\n};\n\n#define\tOUT_OF_MEMORY\t(-2)\n#define\tFAILURE\t(-3)\n#define\tSUCCESS\t(-4)\n#define\tARRAY_OVERFLOW\t(-5)\ntypedef\tstruct\tpstr_list\tELEMENT1;\ntypedef\tELEMENT1\t\t*LINK1;\n\nstatic\tint\tpush(LINK1 *top, const char *string);\nstatic\tint\tpop(LINK1 *top, char *buffer);\nstatic\tunsigned\tint\tcompare(char *ls1, char **rs1, char *ls2, char **rs2);\n\n#define\tMAX_PATTERN_SIZ\t50\t/* maximum string lengths */\n\nstatic int\nsimil(const char *str1, const char *str2)\n{\n\tLINK1 top = NULL;\n\tunsigned int score = 0;\n\tsize_t common, total;\n\tsize_t len1, len2;\n\tchar *rs1 = NULL, *rs2 = NULL;\n\tchar *s1, *s2;\n\tchar ls1[MAX_PATTERN_SIZ], ls2[MAX_PATTERN_SIZ];\n\n\tif(strcasecmp(str1, str2) == 0)\n\t\treturn 100;\n\n\tif((s1 = cli_strdup(str1)) == NULL)\n\t\treturn OUT_OF_MEMORY;\n\tif((s2 = cli_strdup(str2)) == NULL) {\n\t\tfree(s1);\n\t\treturn OUT_OF_MEMORY;\n\t}\n\n\tif(((total = strstrip(s1)) > MAX_PATTERN_SIZ - 1) || ((len2 = strstrip(s2)) > MAX_PATTERN_SIZ - 1)) {\n\t\tfree(s1);\n\t\tfree(s2);\n\t\treturn ARRAY_OVERFLOW;\n\t}\n\n\ttotal += len2;\n\n\tif((push(&top, s1) == OUT_OF_MEMORY) ||\n\t   (push(&top, s2) == OUT_OF_MEMORY)) {\n\t\tfree(s1);\n\t\tfree(s2);\n\t\treturn OUT_OF_MEMORY;\n\t}\n\n\twhile(pop(&top, ls2) == SUCCESS) {\n\t\tpop(&top, ls1);\n\t\tcommon = compare(ls1, &rs1, ls2, &rs2);\n\t\tif(common > 0) {\n\t\t\tscore += (unsigned int)common;\n\t\t\tlen1 = strlen(ls1);\n\t\t\tlen2 = strlen(ls2);\n\n\t\t\tif((len1 > 1 && len2 >= 1) || (len2 > 1 && len1 >= 1))\n\t\t\t\tif((push(&top, ls1) == OUT_OF_MEMORY) || (push(&top, ls2) == OUT_OF_MEMORY)) {\n\t\t\t\t\tfree(s1);\n\t\t\t\t\tfree(s2);\n\t\t\t\t\treturn OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t\tlen1 = strlen(rs1);\n\t\t\tlen2 = strlen(rs2);\n\n\t\t\tif((len1 > 1 && len2 >= 1) || (len2 > 1 && len1 >= 1))\n\t\t\t\tif((push(&top, rs1) == OUT_OF_MEMORY) || (push(&top, rs2) == OUT_OF_MEMORY)) {\n\t\t\t\t\tfree(s1);\n\t\t\t\t\tfree(s2);\n\t\t\t\t\treturn OUT_OF_MEMORY;\n\t\t\t\t}\n\t\t}\n\t}\n\tfree(s1);\n\tfree(s2);\n\treturn (total > 0) ? ((score * 200) / total) : 0;\n}\n\nstatic unsigned int\ncompare(char *ls1, char **rs1, char *ls2, char **rs2)\n{\n\tunsigned int common, maxchars = 0;\n\tbool some_similarity = FALSE;\n\tchar *s1, *s2;\n\tchar *maxs1 = NULL, *maxs2 = NULL, *maxe1 = NULL, *maxe2 = NULL;\n\tchar *cs1, *cs2, *start1, *end1, *end2;\n\n\tend1 = ls1 + strlen(ls1);\n\tend2 = ls2 + strlen(ls2);\n\tstart1 = ls1;\n\n\tfor(;;) {\n\t\ts1 = start1;\n\t\ts2 = ls2;\n\n\t\tif(s1 < end1) {\n\t\t\twhile(s1 < end1 && s2 < end2) {\n\t\t\t\tif(tolower(*s1) == tolower(*s2)) {\n\t\t\t\t\tsome_similarity = TRUE;\n\t\t\t\t\tcs1 = s1;\n\t\t\t\t\tcs2 = s2;\n\t\t\t\t\tcommon = 0;\n\t\t\t\t\tdo\n\t\t\t\t\t\tif(s1 == end1 || s2 == end2)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\ts1++;\n\t\t\t\t\t\t\ts2++;\n\t\t\t\t\t\t\tcommon++;\n\t\t\t\t\t\t}\n\t\t\t\t\twhile(tolower(*s1) == tolower(*s2));\n\n\t\t\t\t\tif(common > maxchars) {\n\t\t\t\t\t\tunsigned int diff = common - maxchars;\n\t\t\t\t\t\tmaxchars = common;\n\t\t\t\t\t\tmaxs1 = cs1;\n\t\t\t\t\t\tmaxs2 = cs2;\n\t\t\t\t\t\tmaxe1 = s1;\n\t\t\t\t\t\tmaxe2 = s2;\n\t\t\t\t\t\tend1 -= diff;\n\t\t\t\t\t\tend2 -= diff;\n\t\t\t\t\t} else\n\t\t\t\t\t\ts1 -= common;\n\t\t\t\t} else\n\t\t\t\t\ts2++;\n\t\t\t}\n\t\t\tstart1++;\n\t\t} else\n\t\t\tbreak;\n\t}\n\tif(some_similarity) {\n\t\t*maxs1 = '\\0';\n\t\t*maxs2 = '\\0';\n\t\t*rs1 = maxe1;\n\t\t*rs2 = maxe2;\n\t}\n\treturn maxchars;\n}\n\nstatic int\npush(LINK1 *top, const char *string)\n{\n\tLINK1 element;\n\n\tif((element = (LINK1)cli_malloc(sizeof(ELEMENT1))) == NULL)\n\t\treturn OUT_OF_MEMORY;\n\tif((element->d1 = cli_strdup(string)) == NULL) {\n\t\tfree (element);\n\t\treturn OUT_OF_MEMORY;\n\t}\n\telement->next = *top;\n\t*top = element;\n\n\treturn SUCCESS;\n}\n\nstatic int\npop(LINK1 *top, char *buffer)\n{\n\tLINK1 t1;\n\n\tif((t1 = *top) != NULL) {\n\t\t(void)strcpy(buffer, t1->d1);\n\t\t*top = t1->next;\n\t\tfree(t1->d1);\n\t\tfree((char *)t1);\n\t\treturn SUCCESS;\n\t}\n\treturn FAILURE;\n}\n\n/*\n * Have we found a line that is a start of a uuencoded file (see uuencode(5))?\n */\nint\nisuuencodebegin(const char *line)\n{\n\tif(line[0] != 'b')\t/* quick check */\n\t\treturn 0;\n\n\tif(strlen(line) < 10)\n\t\treturn 0;\n\n\treturn (strncasecmp(line, \"begin \", 6) == 0) &&\n\t\tisdigit(line[6]) && isdigit(line[7]) &&\n\t\tisdigit(line[8]) && (line[9] == ' ');\n}\n\n#if HAVE_JSON\njson_object *messageGetJObj(message *m)\n{\n\tassert(m != NULL);\n\n\tif(m->jobj == NULL)\n\t\tm->jobj = cli_jsonobj(NULL, NULL);\n\n\treturn m->jobj;\n}\n#endif\n"], "filenames": ["libclamav/message.c"], "buggy_code_start_loc": [448], "buggy_code_end_loc": [686], "fixing_code_start_loc": [448], "fixing_code_end_loc": [690], "type": "CWE-125", "message": "libclamav/message.c in ClamAV 0.99.2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted e-mail message.", "other": {"cve": {"id": "CVE-2017-6418", "sourceIdentifier": "cve@mitre.org", "published": "2017-08-07T03:29:00.227", "lastModified": "2018-10-21T10:29:09.597", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "libclamav/message.c in ClamAV 0.99.2 allows remote attackers to cause a denial of service (out-of-bounds read) via a crafted e-mail message."}, {"lang": "es", "value": "Libclamav/message.c en la versi\u00f3n 0.99.2 de ClamAV permite a atacantes remotos causar una denegaci\u00f3n de servicio (lectura fuera de l\u00edmites) utilizando un mensaje de correo electr\u00f3nico manipulado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:clamav:clamav:0.99.2:*:*:*:*:*:*:*", "matchCriteriaId": "5643323C-F44D-4F04-A710-D25EA28D301F"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/100154", "source": "cve@mitre.org"}, {"url": "https://bugzilla.clamav.net/show_bug.cgi?id=11797", "source": "cve@mitre.org", "tags": ["Permissions Required"]}, {"url": "https://github.com/varsleak/varsleak-vul/blob/master/clamav-vul/heap-overflow/clamav_email_crash.md", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/vrtadmin/clamav-devel/commit/586a5180287262070637c8943f2f7efd652e4a2c", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/201804-16", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/vrtadmin/clamav-devel/commit/586a5180287262070637c8943f2f7efd652e4a2c"}}