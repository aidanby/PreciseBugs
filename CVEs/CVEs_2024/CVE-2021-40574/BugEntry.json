{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / text import filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\n\n\ntypedef struct __txtin_ctx GF_TXTIn;\n\nstruct __txtin_ctx\n{\n\t//opts\n\tu32 width, height, txtx, txty, fontsize;\n\ts32 zorder;\n\tconst char *fontname, *lang, *ttml_zero;\n\tBool nodefbox, noflush, webvtt, ttml_embed;\n\tu32 timescale;\n\tGF_Fraction fps;\n\ts32 ttml_dur;\n\n\n\tGF_FilterPid *ipid, *opid;\n\tchar *file_name;\n\tu32 fmt;\n\tu32 playstate;\n\t//0: not seeking, 1: seek request pending, 2: seek configured, discarding packets up until start_range\n\tu32 seek_state;\n\tDouble start_range;\n\n\tBool is_setup;\n\n\tGF_Err (*text_process)(GF_Filter *filter, GF_TXTIn *ctx);\n\n\ts32 unicode_type;\n\n\tFILE *src;\n\n\tGF_BitStream *bs_w;\n\tBool first_samp;\n\tBool hdr_parsed;\n\n\t//state vars for srt\n\tu32 state, default_color;\n\tGF_TextSample *samp;\n\tu64 start, end, prev_end;\n\tu32 curLine;\n\tGF_StyleRecord style;\n\n\t//WebVTT state\n\tGF_WebVTTParser *vttparser;\n\n\t//TTXT state\n\tGF_DOMParser *parser;\n\tu32 cur_child_idx, nb_children, last_desc_idx;\n\tGF_List *text_descs;\n\tBool last_sample_empty;\n\tu64 last_sample_duration;\n\t//TTML state is the same as ttxt plus the timescale and start (webvtt) for cts compute\n\tu32 txml_timescale;\n\tu32 current_tt_interval;\n\n\t//TTML state\n\tGF_XMLNode *root_working_copy, *body_node;\n\tGF_DOMParser *parser_working_copy;\n\tBool non_compliant_ttml;\n\tu32 tick_rate, ttml_fps_num, ttml_fps_den, ttml_sfps;\n\tGF_List *ttml_resources;\n\tGF_List *div_nodes_list;\n\tBool has_images;\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t//SWF text\n\tSWFReader *swf_parse;\n\tBool do_suspend;\n#endif\n\n\n\tGF_List *intervals;\n};\n\ntypedef struct\n{\n\tu32 size;\n\tu8 *data;\n\tBool global;\n} TTMLRes;\n\ntypedef struct\n{\n\ts64 begin, end;\n\tGF_List *resources;\n} TTMLInterval;\n\n\nenum\n{\n\tGF_TXTIN_MODE_NONE = 0,\n\tGF_TXTIN_MODE_SRT,\n\tGF_TXTIN_MODE_SUB,\n\tGF_TXTIN_MODE_TTXT,\n\tGF_TXTIN_MODE_TEXML,\n\tGF_TXTIN_MODE_WEBVTT,\n\tGF_TXTIN_MODE_TTML,\n\tGF_TXTIN_MODE_SWF_SVG,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n \n\ns32 gf_text_get_utf_type(FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) gf_fread(BOM, 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tif (BOM[0]<0x80) {\n\t\tgf_fseek(in_src, 0, SEEK_SET);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\nstatic void ttxt_dom_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)cbk;\n\tctx->end = count;\n}\n\nstatic GF_Err gf_text_guess_format(const char *filename, u32 *fmt)\n{\n\tchar szLine[2048];\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) gf_fread(szUTF, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) gf_fread(szLine, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\t\t\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t*fmt = GF_TXTIN_MODE_NONE;\n\tif ((szLine[0]=='{') && strstr(szLine, \"}{\")) *fmt = GF_TXTIN_MODE_SUB;\n\telse if (szLine[0] == '<') {\n\t\tchar *ext = gf_file_ext_start(filename);\n\t\tif (!strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (!strnicmp(ext, \".ttml\", 5)) *fmt = GF_TXTIN_MODE_TTML;\n\t\text = strstr(szLine, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!gf_fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TXTIN_MODE_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (strstr(szLine, \"tt\")) *fmt = GF_TXTIN_MODE_TTML;\n\t}\n\telse if (strstr(szLine, \"WEBVTT\") )\n\t\t*fmt = GF_TXTIN_MODE_WEBVTT;\n\telse if (strstr(szLine, \" --> \") )\n\t\t*fmt = GF_TXTIN_MODE_SRT; /* might want to change the default to WebVTT */\n\n\telse if (!strncmp(szLine, \"FWS\", 3) || !strncmp(szLine, \"CWS\", 3))\n\t\t*fmt = GF_TXTIN_MODE_SWF_SVG;\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}\n\n\nstatic void txtin_probe_duration(GF_TXTIn *ctx)\n{\n\tGF_Fraction64 dur;\n\tdur.num = 0;\n\n\tif (ctx->fmt == GF_TXTIN_MODE_SWF_SVG) {\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\tu32 frame_count, frame_rate;\n\t\tgf_swf_get_duration(ctx->swf_parse, &frame_rate, &frame_count);\n\t\tif (frame_count) {\n\t\t\tGF_Fraction64 tdur;\n\t\t\ttdur.num = frame_count;\n\t\t\ttdur.den = frame_rate;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(tdur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n#endif\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_SRT) || (ctx->fmt == GF_TXTIN_MODE_WEBVTT)  || (ctx->fmt == GF_TXTIN_MODE_SUB)) {\n\t\tu64 pos = gf_ftell(ctx->src);\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t\twhile (!gf_feof(ctx->src)) {\n\t\t\tu64 end;\n\t\t\tchar szLine[2048];\n\t\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\t\tif (!sOK) break;\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->fmt == GF_TXTIN_MODE_SUB) {\n\t\t\t\tchar szText[2048];\n\t\t\t\tu32 sframe, eframe;\n\t\t\t\tif (sscanf(szLine, \"{%d}{%d}%2047s\", &sframe, &eframe, szText) == 3) {\n\t\t\t\t\tif (ctx->fps.den)\n\t\t\t\t\t\tend = 1000 * eframe * ctx->fps.num / ctx->fps.den;\n\t\t\t\t\telse\n\t\t\t\t\t\tend = 1000 * eframe / 25;\n\t\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 eh, em, es, ems;\n\t\t\t\tchar *start = strstr(szLine, \"-->\");\n\t\t\t\tif (!start) continue;\n\t\t\t\twhile (start[0] && ((start[0] == ' ') || (start[0] == '\\t'))) start++;\n\n\t\t\t\tif (sscanf(start, \"%u:%u:%u,%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\t\teh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t}\n\t\t}\n\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) || (ctx->fmt == GF_TXTIN_MODE_TEXML)) {\n\t\tu32 i=0;\n\t\tGF_XMLNode *node, *root = gf_xml_dom_get_root(ctx->parser);\n\t\twhile ((node = gf_list_enum(root->content, &i))) {\n\t\t\tu32 j;\n\t\t\tu64 duration;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*sample text*/\n\t\t\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) && strcmp(node->name, \"TextSample\")) continue;\n\t\t\telse if ((ctx->fmt == GF_TXTIN_MODE_TEXML) && strcmp(node->name, \"sample\")) continue;\n\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tu64 ts=0;\n\t\t\t\tif (ctx->fmt == GF_TXTIN_MODE_TTXT) {\n\t\t\t\t\tif (strcmp(att->name, \"sampleTime\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t\tif (ts > (u64) dur.num) dur.num = (s64) ts;\n\t\t\t\t} else {\n\t\t\t\t\tif (strcmp(att->name, \"duration\")) continue;\n\t\t\t\t\tduration = atoi(att->value);\n\t\t\t\t\tdur.num += (s32) ( (1000 * duration) / ctx->txml_timescale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ctx->fmt == GF_TXTIN_MODE_TTML) {\n\t\tu32 i=0, k=0;\n\t\tGF_XMLNode *div_node;\n\n\t\twhile ((div_node = gf_list_enum(ctx->div_nodes_list, &k))) {\n\t\t\tGF_XMLNode *node;\n\t\t\twhile ((node = gf_list_enum(div_node->content, &i))) {\n\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\tGF_XMLAttribute *att;\n\t\t\t\tu32 h, m, s, ms, p_idx=0;\n\t\t\t\tu64 ts_end=0;\n\t\t\t\th = m = s = ms = 0;\n\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &p_idx))) {\n\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//or under a <span>\n\t\t\t\tp_idx = 0;\n\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(node->content, &p_idx))) {\n\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\t\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ts_end > (u64) dur.num) dur.num = (s64) ts_end;\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Duration probing not supported for format %d\\n\", ctx->fmt));\n}\n\nstatic GF_Err txtin_setup_srt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 ID, OCR_ES_ID, dsi_len, file_size;\n\tu8 *dsi;\n\tGF_TextSampleDescriptor *sd;\n\n\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\tif (!ctx->src) return GF_URL_ERROR;\n\n\tfile_size = (u32) gf_fsize(ctx->src);\n\n\tctx->unicode_type = gf_text_get_utf_type(ctx->src);\n\tif (ctx->unicode_type<0) {\n\t\tgf_fclose(ctx->src);\n\t\tctx->src = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\tsd->font_count = 1;\n\tsd->fonts[0].fontID = 1;\n\tsd->fonts[0].fontName = gf_strdup(ctx->fontname ? ctx->fontname : \"Serif\");\n\tsd->back_color = 0x00000000;\t/*transparent*/\n\tsd->default_style.fontID = 1;\n\tsd->default_style.font_size = ctx->fontsize;\n\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\tsd->default_style.style_flags = 0;\n\tsd->horiz_justif = 1; /*center of scene*/\n\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\tif (ctx->nodefbox) {\n\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t} else if ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\tsd->default_pos.left = ctx->txtx;\n\t\tsd->default_pos.top = ctx->txty;\n\t\tsd->default_pos.right = ctx->width + sd->default_pos.left;\n\t\tsd->default_pos.bottom = ctx->height + sd->default_pos.top;\n\t}\n\n\t/*store attribs*/\n\tctx->style = sd->default_style;\n\tgf_odf_tx3g_write(sd, &dsi, &dsi_len);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_len) );\n\n\tgf_odf_desc_del((GF_Descriptor *)sd);\n\n\tctx->default_color = ctx->style.text_color;\n\tctx->samp = gf_isom_new_text_sample();\n\tctx->state = 0;\n\tctx->end = ctx->prev_end = ctx->start = 0;\n\tctx->first_samp = GF_TRUE;\n\tctx->curLine = 0;\n\n\ttxtin_probe_duration(ctx);\n\treturn GF_OK;\n}\n\nstatic void txtin_process_send_text_sample(GF_TXTIn *ctx, GF_TextSample *txt_samp, u64 ts, u32 duration, Bool is_rap)\n{\n\tGF_FilterPacket *dst_pck;\n\tu8 *pck_data;\n\tu32 size;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble end = (Double) (ts+duration);\n\t\tend /= 1000;\n\t\tif (end < ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\tsize = gf_isom_text_sample_size(txt_samp);\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &pck_data);\n\tif (!dst_pck) return;\n\n\tgf_bs_reassign_buffer(ctx->bs_w, pck_data, size);\n\tgf_isom_text_sample_write_bs(txt_samp, ctx->bs_w);\n\n\tts = gf_timestamp_rescale(ts, 1000, ctx->timescale);\n\tduration = (u32) gf_timestamp_rescale(duration, 1000, ctx->timescale);\n\n\tgf_filter_pck_set_sap(dst_pck, is_rap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\tgf_filter_pck_set_cts(dst_pck, ts);\n\tgf_filter_pck_set_duration(dst_pck, duration);\n\n\tgf_filter_pck_send(dst_pck);\n}\n\nstatic GF_Err txtin_process_srt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 i;\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len, char_line, j, rem_styles;\n\tBool set_start_char, set_end_char, rem_color;\n\tu32 line, len;\n\tchar szLine[2048], szText[2048], *ptr;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\n\tif (ctx->seek_state == 1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\twhile (1) {\n\t\tBool is_empty = GF_FALSE;\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\n\t\tif (sOK) {\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->unicode_type<=1) is_empty = strlen(szLine) ? GF_FALSE : GF_TRUE;\n\t\t\telse is_empty =  (!szLine[0] && !szLine[1]) ? GF_TRUE : GF_FALSE;\n\t\t}\n\n\t\tif (!sOK || is_empty) {\n\t\t\tu32 utf_inc = (ctx->unicode_type<=1) ? 1 : 2;\n\t\t\tu32 nb_empty = utf_inc;\n\t\t\tu32 pos = (u32) gf_ftell(ctx->src);\n\t\t\tif (ctx->state) {\n\t\t\t\twhile (!gf_feof(ctx->src)) {\n\t\t\t\t\tsOK = gf_text_get_utf8_line(szLine+nb_empty, 2048-nb_empty, ctx->src, ctx->unicode_type);\n\t\t\t\t\tif (sOK) REM_TRAIL_MARKS((szLine+nb_empty), \"\\r\\n\\t \")\n\n\t\t\t\t\tif (!sOK) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (!strlen(szLine+nb_empty)) {\n\t\t\t\t\t\tnb_empty+=utf_inc;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (\tsscanf(szLine+nb_empty, \"%u\", &line) == 1) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 k;\n\t\t\t\t\t\tfor (k=0; k<nb_empty; k++) szLine[k] = '\\n';\n\t\t\t\t\t\tgoto force_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->style.text_color = 0xFFFFFFFF;\n\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\tif (txt_line) {\n\t\t\t\tif (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {\n\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );\n\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->state<=2) {\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);\n\t\t\t\t\tctx->prev_end = ctx->end;\n\t\t\t\t}\n\t\t\t\ttxt_line = 0;\n\t\t\t\tchar_len = 0;\n\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\t\tgf_isom_text_reset(ctx->samp);\n\n\t\t\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\t\t\t}\n\t\t\tctx->state = 0;\n\t\t\tif (!sOK) break;\n\t\t\tcontinue;\n\t\t}\n\nforce_line:\n\t\tswitch (ctx->state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SRT formatting - expecting number got \\\"%s\\\"\\n\", szLine));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (line != ctx->curLine + 1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Corrupted SRT frame %d after frame %d\\n\", line, ctx->curLine));\n\t\t\t}\n\t\t\tctx->curLine = line;\n\t\t\tctx->state = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tif (sscanf(szLine, \"%u:%u:%u.%u --> %u:%u:%u.%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\t\tsh = eh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\tif (sscanf(szLine, \"%u:%u.%u --> %u:%u.%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Error scanning SRT frame %d timing\\n\", ctx->curLine));\n\t\t\t\t    \t\tctx->state = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->start = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (ctx->start < ctx->end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\\n\", ctx->curLine, ctx->start, ctx->end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t}\n\n\t\t\tctx->end = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (ctx->first_samp && (ctx->start > 0)) {\n\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->state = 2;\n\t\t\tif (ctx->end <= ctx->prev_end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\\n\", ctx->curLine, ctx->end, ctx->prev_end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t\tctx->state = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tctx->first_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(ctx->samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tptr = (char *) szLine;\n\t\t\t{\n\t\t\t\tsize_t _len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\t\t\t\tif (_len == (size_t) -1) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Invalid UTF data (line %d)\\n\", ctx->curLine));\n\t\t\t\t\tctx->state = 0;\n\t\t\t\t}\n\t\t\t\tlen = (u32) _len;\n\t\t\t}\n\t\t\ti=j=0;\n\t\t\trem_styles = 0;\n\t\t\trem_color = 0;\n\t\t\twhile (i<len) {\n\t\t\t\tu32 font_style = 0;\n\t\t\t\tu32 style_nb_chars = 0;\n\t\t\t\tu32 style_def_type = 0;\n\n\t\t\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\t\t\tstyle_nb_chars = 3;\n\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t}\n\t\t\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\tstyle_nb_chars = 4;\n\t\t\t\t}\n\t\t\t\telse if (uniLine[i]=='<')  {\n\t\t\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\t\t\tsize_t alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\t\t\tszLine[alen] = 0;\n\t\t\t\t\tstrlwr(szLine);\n\t\t\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\t\t\tif (a_sep) a_sep = strchr(a_sep, '\"');\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tchar *e_sep = strchr(a_sep+1, '\"');\n\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\t\t\tfont_style = gf_color_parse(a_sep+1);\n\t\t\t\t\t\t\t\te_sep[0] = '\"';\n\t\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\n\n\t\t\t\t\telse if (!strncmp(szLine, \"<strike>\", 8) ) {\n\t\t\t\t\t\tstyle_nb_chars = 8;\n\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</strike>\", 9) ) {\n\t\t\t\t\t\tstyle_nb_chars = 9;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\t\t\t\t\t//skip unknown\n\t\t\t\t\telse {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + a_sep - szLine);\n\t\t\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/*start of new style*/\n\t\t\t\tif (style_def_type==1)  {\n\t\t\t\t\t/*store prev style*/\n\t\t\t\t\tif (set_end_char) {\n\t\t\t\t\t\tassert(set_start_char);\n\t\t\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t\t\tset_end_char = set_start_char = GF_FALSE;\n\t\t\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t\t\t\trem_styles = 0;\n\t\t\t\t\t\tif (rem_color) {\n\t\t\t\t\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\t\t\t\t\trem_color = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (set_start_char && (ctx->style.startCharOffset != j)) {\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tif (ctx->style.style_flags) gf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t\t}\n\t\t\t\t\tswitch (uniLine[i+1]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\tctx->style.text_color = font_style;\n\t\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*end of prev style*/\n\t\t\t\tif (style_def_type==2)  {\n\t\t\t\t\tswitch (uniLine[i+2]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trem_color = 1;\n\t\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+=style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*store style*/\n\t\t\t\tif (set_end_char) {\n\t\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t\t\trem_styles = 0;\n\t\t\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\n\t\t\t\tuniText[j] = uniLine[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*store last style*/\n\t\t\tif (set_end_char) {\n\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t}\n\n\t\t\tchar_line = j;\n\t\t\tuniText[j] = 0;\n\n\t\t\tsptr = (u16 *) uniText;\n\t\t\tlen = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\n\t\t\tgf_isom_text_add_text(ctx->samp, szText, len);\n\t\t\tchar_len += char_line;\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\n\t/*final flush*/\t\n\tif (ctx->end && ! ctx->noflush) {\n\t\tgf_isom_text_reset(ctx->samp);\n\t\ttxtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);\n\t\tctx->end = 0;\n\t}\n\tgf_isom_text_reset(ctx->samp);\n\n\treturn GF_EOS;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_TXTIn *ctx;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_LOG(e ? GF_LOG_WARNING : GF_LOG_INFO, GF_LOG_AUTHOR, (\"[TXTIn] WebVTT line %s: %s\\n\", line, message) );\n\treturn e;\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!ctx->hdr_parsed) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *) config, (u32) (1+strlen(config)) ) );\n\t\tctx->hdr_parsed = GF_TRUE;\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\t}\n}\n\nstatic void gf_webvtt_flush_sample(void *user, GF_WebVTTSample *samp)\n{\n\tu64 start, end;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tGF_ISOSample *s;\n\n\tstart = gf_webvtt_sample_get_start(samp);\n\tend = gf_webvtt_sample_get_end(samp);\n\n\tif (ctx->seek_state==2) {\n\t\tDouble tsend = (Double) end;\n\t\ttsend /= 1000;\n\t\tif (tsend<ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\ts = gf_isom_webvtt_to_sample(samp);\n\tif (s) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, s->dataLength, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, s->data, s->dataLength);\n\t\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale * start / 1000) );\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\n\t\t\tif (end && (end>=start) ) {\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) (ctx->timescale * (end-start) / 1000) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n\n\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\n}\n\nstatic GF_Err txtin_webvtt_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, file_size, w, h;\n\tBool is_srt;\n\tchar *ext;\n\n\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\tif (!ctx->src) return GF_URL_ERROR;\n\n\tfile_size = (u32) gf_fsize(ctx->src);\n\n\tctx->unicode_type = gf_text_get_utf_type(ctx->src);\n\tif (ctx->unicode_type<0) {\n\t\tgf_fclose(ctx->src);\n\t\tctx->src = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\text = gf_file_ext_start(ctx->file_name);\n\tis_srt = (ext && !strnicmp(ext, \".srt\", 4)) ? GF_TRUE : GF_FALSE;\n\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_WEBVTT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tw = ctx->width;\n\th = ctx->height;\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tctx->vttparser = gf_webvtt_parser_new();\n\n\te = gf_webvtt_parser_init(ctx->vttparser, ctx->src, ctx->unicode_type, is_srt, ctx, gf_webvtt_import_report, gf_webvtt_flush_sample, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(ctx->vttparser);\n\t\tctx->vttparser = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT parser init error %s\\n\", gf_error_to_string(e) ));\n\t}\n\t//get the header\n\te = gf_webvtt_parser_parse(ctx->vttparser);\n\n\ttxtin_probe_duration(ctx);\n\treturn e;\n}\n\nstatic GF_Err txtin_process_webvtt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_webvtt_setup(filter, ctx);\n\t}\n\tif (!ctx->vttparser) return GF_NOT_SUPPORTED;\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_webvtt_parser_restart(ctx->vttparser);\n\t}\n\n\te = gf_webvtt_parser_parse(ctx->vttparser);\n\tif (e < GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT process error %s\\n\", gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = 1; //!state;\n\t\t\t} else {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **out_body_node)\n{\n\tu32 idx = 0;\n\tGF_XMLNode *node = NULL;\n\t*out_body_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\t*out_body_node = node;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\tu32 body_num;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic s64 ttml_get_timestamp(GF_TXTIn *ctx, char *value)\n{\n\tu32 h, m, s, ms, f, sf;\n\ts64 ts = -1;\n\tu32 len = (u32) strlen(value);\n\n\t//tick metrick - cannot be fractional\n\tif (len && (value[len-1]=='t')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atoi(value) * 1000);\n\t\tvalue[len-1] = 't';\n\t\tif (ctx->tick_rate)\n\t\t\tts /= ctx->tick_rate;\n\t}\n\t//hours metric, can be fractional\n\telse if (len && (value[len-1]=='h')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 3600);\n\t\tvalue[len-1] = 'h';\n\t}\n\t//minutes metric, can be fractional\n\telse if (len && (value[len-1]=='m')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 60);\n\t\tvalue[len-1] = 'm';\n\t}\n\telse if (len && (value[len-1]=='s')) {\n\t\t//milliseconds metric, can be fractional but we work at 1ms clock resolution anyway\n\t\tif ((len > 1) && (value[len-2]=='m')) {\n\t\t\tvalue[len-2] = 0;\n\t\t\tts = (s64) (atof(value));\n\t\t\tvalue[len-2] = 'm';\n\t\t}\n\t\t//seconds metric, can be fractional\n\t\telse {\n\t\t\tvalue[len-1] = 0;\n\t\t\tts = (s64) (atof(value) * 1000);\n\t\t\tvalue[len-1] = 's';\n\t\t}\n\t}\n\t//frames metric, can be fractional\n\telse if (len && (value[len-1]=='f')) {\n\t\tf = sf = 0;\n\t\tvalue[len-1] = 0;\n\t\tif (sscanf(value, \"%u.%u\", &f, &sf) != 2) {\n\t\t\tsscanf(value, \"%u\", &f);\n\t\t\tsf = 0;\n\t\t}\n\t\tvalue[len-1] = 'f';\n\n\t\tif (!ctx->ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\tctx->ttml_fps_num = 25;\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\tif (sf && !ctx->ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\tctx->ttml_sfps = 1;\n\t\t}\n\t\tts = ((s64) 1000 * f * ctx->ttml_fps_den) / ctx->ttml_fps_num;\n\t\tif (sf)\n\t\t\tts += ((s64) 1000 * sf * ctx->ttml_fps_den / ctx->ttml_sfps) / ctx->ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000+ms;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u.%u\", &h, &m, &s, &f, &sf) == 5) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (!ctx->ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\tctx->ttml_fps_num = 25;\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\tif (!ctx->ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\tctx->ttml_sfps = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * ctx->ttml_fps_den) / ctx->ttml_fps_num;\n\t\tts += ((s64) 1000 * sf * ctx->ttml_fps_den / ctx->ttml_sfps) / ctx->ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (!ctx->ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\tctx->ttml_fps_num = 25;\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * ctx->ttml_fps_den) / ctx->ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t}\n\treturn ts;\n}\n\nstatic GF_Err ttml_push_interval(GF_TXTIn *ctx, s64 begin, s64 end, TTMLInterval **out_interval)\n{\n\tu32 i;\n\tTTMLInterval *interval;\n\tif (begin==-1) return GF_OK;\n\tif (end==-1) return GF_OK;\n\n\tif (end < begin) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", begin, end));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tinterval = NULL;\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tinterval = gf_list_get(ctx->intervals, i);\n\n\t\t//generate a single sample for the input, merge interval\n\t\tif (ctx->ttml_dur>=0) {\n\t\t\tif (interval->begin > begin) interval->begin = begin;\n\t\t\tif (interval->end < end) interval->end = end;\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//contained, do nothing\n\t\tif ((begin>=interval->begin) && (end<=interval->end)) {\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//not overlapping\n\t\tif ((end < interval->begin) || (begin > interval->end))\n\t\t\tcontinue;\n\n\t\t//new interval starts before current and end after, remove current and push extended interval\n\t\tif ((begin < interval->end) && (end > interval->end)) {\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t\t//new interval starts before current and end before, remove current and push rewinded\n\t\tif ((begin < interval->end) && (end <= interval->end)) {\n\t\t\tend = interval->end;\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t}\n\t//need a new interval\n\tGF_SAFEALLOC(interval, TTMLInterval);\n\tinterval->begin = begin;\n\tinterval->end = end;\n\t*out_interval = interval;\n\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tTTMLInterval *an_interval = gf_list_get(ctx->intervals, i);\n\t\tif (an_interval->begin > interval->begin) {\n\t\t\treturn gf_list_insert(ctx->intervals, interval, i);\n\t\t}\n\t}\n\treturn gf_list_add(ctx->intervals, interval);\n}\n\nstatic void ttml_reset_intervals(GF_TXTIn *ctx)\n{\n\twhile (gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *ival = gf_list_pop_back(ctx->intervals);\n\t\tif (ival->resources) {\n\t\t\twhile (gf_list_count(ival->resources)) {\n\t\t\t\tTTMLRes *ires = gf_list_pop_back(ival->resources);\n\t\t\t\tif (!ires->global) {\n\t\t\t\t\tgf_free(ires->data);\n\t\t\t\t\tgf_free(ires);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(ival->resources);\n\t\t}\n\t\tgf_free(ival);\n\t}\n}\n\n#include <gpac/base_coding.h>\n\nstatic GF_Err ttml_push_res(GF_TXTIn *ctx, TTMLInterval *interval, u8 *f_data, u32 f_size)\n{\n\tGF_Err e;\n\tTTMLRes *res;\n\tGF_List *res_list;\n\tif (interval) {\n\t\tif (!interval->resources) {\n\t\t\tif (ctx->ttml_resources)\n\t\t\t\tinterval->resources = gf_list_clone(ctx->ttml_resources);\n\t\t\telse\n\t\t\t\tinterval->resources = gf_list_new();\n\t\t}\n\t\tres_list = interval->resources;\n\t} else {\n\t\tif (!ctx->ttml_resources) {\n\t\t\tctx->ttml_resources = gf_list_new();\n\t\t}\n\t\tres_list = ctx->ttml_resources;\n\t}\n\tif (!res_list) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tGF_SAFEALLOC(res, TTMLRes)\n\tif (!res) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tres->size = f_size;\n\tres->data = f_data;\n\tif (!interval)\n\t\tres->global = GF_TRUE;\n\n\te = gf_list_add(res_list, res);\n\tif (e) {\n\t\tgf_free(res);\n\t\tgf_free(f_data);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_push_resources(GF_TXTIn *ctx, TTMLInterval *interval, GF_XMLNode *node, GF_XMLNode *parent_source_node)\n{\n\tu32 i;\n\tchar szURN[1024];\n\tu8 *f_data;\n\tu32 f_size;\n\tu32 idx;\n\tGF_Err e;\n\tGF_XMLAttribute *att, *data_type = NULL;\n\tGF_XMLNode *child;\n\tBool is_source = GF_FALSE;\n\tBool is_data = GF_FALSE;\n\tBool check_src = GF_FALSE;\n\n\tif (!ctx->ttml_embed)\n\t\treturn GF_OK;\n\n\tif (!strcmp(node->name, \"source\")) {\n\t\tis_source = GF_TRUE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\telse if (!strcmp(node->name, \"data\")) {\n\t\tis_data = parent_source_node ? GF_TRUE : GF_FALSE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\t//we don't embed chunks\n\telse if (!strcmp(node->name, \"chunk\")) {\n\t\treturn GF_OK;\n\t}\n\telse if (!strcmp(node->name, \"audio\") || !strcmp(node->name, \"font\") || !strcmp(node->name, \"image\")) {\n\t\tcheck_src = GF_TRUE;\n\t}\n\n\tif (check_src) {\n\t\ti = 0;\n\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\t\tchar *url;\n\t\t\tif (!att->value) continue;\n\t\t\tif (is_data && !strcmp(att->name, \"type\")) {\n\t\t\t\tdata_type = att;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(att->name, \"src\")) continue;\n\t\t\tif (att->value[0]=='#') continue;\n\n\t\t\tif (!strncmp(att->value, \"file://\", 7)) {}\n\t\t\telse if (strstr(att->value, \"://\"))\n\t\t\t\tcontinue;\n\n\t\t\turl = gf_url_concatenate(ctx->file_name, att->value);\n\t\t\t//embed image\n\t\t\te = gf_file_load_data(url, &f_data, &f_size);\n\t\t\tgf_free(url);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tgf_free(att->value);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\t\t\tatt->value = gf_strdup(szURN);\n\t\t\tif (!att->value) return GF_OUT_OF_MEM;\n\n\t\t\tctx->has_images = GF_TRUE;\n\t\t}\n\t}\n\n\ti = 0;\n\twhile ( (child = (GF_XMLNode*) gf_list_enum(node->content, &i))) {\n\t\tif (child->type) {\n\t\t\tif (!is_data) continue;\n\t\t\tu8 *data = child->name;\n\t\t\tu32 ilen = (u32) strlen(data);\n\t\t\tf_size = 3*ilen/4;\n\t\t\tf_data = gf_malloc(sizeof(u8) * f_size);\n\n\t\t\tf_size = gf_base64_decode(data, ilen, f_data, f_size);\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\n\t\t\tGF_SAFEALLOC(att, GF_XMLAttribute)\n\t\t\tif (att) {\n\t\t\t\tatt->name = gf_strdup(\"src\");\n\t\t\t\tatt->value = gf_strdup(szURN);\n\t\t\t\tgf_list_add(parent_source_node->attributes, att);\n\t\t\t}\n\t\t\tif (!att || !att->value || !att->name) return GF_OUT_OF_MEM;\n\t\t\tif (data_type) {\n\t\t\t\tgf_list_del_item(node->attributes, data_type);\n\t\t\t\tgf_list_add(parent_source_node->attributes, data_type);\n\t\t\t}\n\t\t\tgf_xml_dom_node_reset(parent_source_node, GF_FALSE, GF_TRUE);\n\t\t\tctx->has_images = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\te = ttml_push_resources(ctx, interval, child, is_source ? node : NULL);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_rewrite_timestamp(GF_TXTIn *ctx, s64 ttml_zero, GF_XMLAttribute *att, s64 *value, Bool *drop)\n{\n\tu64 v;\n\tchar szTS[21];\n\tu32 h, m, s, ms;\n\t*value = ttml_get_timestamp(ctx, att->value);\n\tif (!ttml_zero)\n\t\treturn GF_OK;\n\n\tif (*value < ttml_zero) {\n\t\t*drop = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\t*value -= ttml_zero;\n\tv = (u64) (*value / 1000);\n\th = (u32) (v / 3600);\n\tm = (u32) (v - h*60) / 60;\n\ts = (u32) (v - h*3600 - m*60);\n\tms = (*value) % 1000;\n\n\tsnprintf(szTS, 20, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\tszTS[20] = 0;\n\tgf_free(att->value);\n\tatt->value = gf_strdup(szTS);\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_setup_intervals(GF_TXTIn *ctx)\n{\n\tu32 k, i, nb_divs;\n\ts64 ttml_zero_ms = 0;\n\tGF_Err e;\n\tGF_XMLNode *root;\n\n\tif (!ctx->intervals)\n\t\tctx->intervals = gf_list_new();\n\telse\n\t\tttml_reset_intervals(ctx);\n\n\tctx->has_images = GF_FALSE;\n\troot = ctx->root_working_copy;\n\tfor (k=0; k<gf_list_count(root->content); k++) {\n\t\tGF_XMLNode *head = (GF_XMLNode*)gf_list_get(root->content, k);\n\t\tif (head->type) continue;\n\t\tif (strcmp(head->name, \"head\")) continue;\n\t\tttml_push_resources(ctx, NULL, head, NULL);\n\t\tbreak;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (ctx->ttml_zero) {\n\t\tif (ctx->ttml_zero[0]=='T')\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero+1);\n\t\telse\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero);\n\t}\n\n\tnb_divs = gf_list_count(ctx->div_nodes_list);\n\tfor (i=0; i<nb_divs; i++) {\n\t\tu32 nb_children;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, i);\n\t\tnb_children = gf_list_count(div_node->content);\n\n\t\tfor (k=0; k<nb_children; k++) {\n\t\t\tTTMLInterval *ival=NULL;\n\t\t\tu32 p_idx;\n\t\t\tBool drop = GF_FALSE;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tGF_XMLNode *p_node;\n\t\t\ts64 begin=-1, end=-1;\n\t\t\tGF_XMLNode *adiv_child = (GF_XMLNode*)gf_list_get(div_node->content, k);\n\t\t\tif (adiv_child->type) continue;\n\t\t\te = gf_xml_get_element_check_namespace(adiv_child, \"p\", root->ns);\n\t\t\tif (e) continue;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(adiv_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &begin, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &end, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drop) {\n\t\t\t\tgf_xml_dom_node_del(adiv_child);\n\t\t\t\tgf_list_rem(div_node->content, k);\n\t\t\t\tk--;\n\t\t\t\tnb_children--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\te = ttml_push_interval(ctx, begin, end, &ival);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_resources(ctx, ival, adiv_child, NULL);\n\t\t\tif (e) return e;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(adiv_child->content, &p_idx))) {\n\t\t\t\ts64 s_begin=-1, s_end=-1;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e) continue;\n\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_begin, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_end, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = ttml_push_interval(ctx, s_begin, s_end, &ival);\n\t\t\t\tif (e) return e;\n\n\t\t\t\te = ttml_push_resources(ctx, ival, p_node, NULL);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *interval;\n\t\tGF_SAFEALLOC(interval, TTMLInterval);\n\t\tinterval->begin = interval->end = 0;\n\t\tgf_list_add(ctx->intervals, interval);\n\t}\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_PARSER, GF_LOG_DEBUG)) {\n\t\tfor (k=0; k<gf_list_count(ctx->intervals); k++) {\n\t\t\tTTMLInterval *ival = gf_list_get(ctx->intervals, k);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] Interval %d: \"LLU\"-\"LLU\"\\n\", k+1, ival->begin, ival->end));\n\t\t}\n\t}\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_ttml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 i, nb_children, ID;\n\tu64 file_size;\n\ts32 sub_fps_num, sub_fps_den;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root, *node, *body_node;\n\tconst char *lang = ctx->lang;\n\n\n\tctx->is_setup = GF_TRUE;\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: Line %d - %s. Abort.\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tctx->is_setup = GF_TRUE;\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (!root) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: no root XML element found. Abort.\\n\"));\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) != GF_OK) {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] TTML EBU-TTD detected\\n\"));\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\n\t/*** root (including language) ***/\n\tsub_fps_num = 0;\n\tsub_fps_den = 0;\n\ti=0;\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tconst char *att_name;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML] Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tatt_name = strchr(att->name, ':');\n\t\tif (att_name) att_name++;\n\t\telse att_name = att->name;\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] XML Namespace %s not recognized, expecting %s\\n\", att->name, att->value, TTML_NAMESPACE));\n\t\t\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att->name, \"xml:lang\") && att->value && strlen(att->value)) {\n\t\t\tlang = att->value;\n\t\t}\n\t\telse if (!strcmp(att_name, \"tickRate\") && att->value) {\n\t\t\tctx->tick_rate = atoi(att->value);\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRate\") && att->value) {\n\t\t\tctx->ttml_fps_num = atoi(att->value);\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRateMultiplier\") && att->value) {\n\t\t\tchar *sep = strchr(att->value, ' ');\n\t\t\tif (!sep) sep = strchr(att->value, '\\t');\n\t\t\tif (sep) {\n\t\t\t\tu8 c = sep[0];\n\t\t\t\tsep[0] = 0;\n\t\t\t\tsub_fps_num = atoi(sep);\n\t\t\t\tsep[0] = c;\n\t\t\t\twhile ((sep[0]==' ') || (sep[0]=='\\t'))\n\t\t\t\t\tsep++;\n\t\t\t\tsub_fps_den = atoi(sep);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att_name, \"subFrameRate\") && att->value) {\n\t\t\tctx->ttml_sfps = atoi(att->value);\n\t\t}\n\t}\n\n\tif (sub_fps_num && sub_fps_den && ctx->ttml_fps_num) {\n\t\tctx->ttml_fps_num *= sub_fps_num;\n\t\tctx->ttml_fps_den = sub_fps_den;\n\t}\n\n\t//locate body\n\tnb_children = gf_list_count(root->content);\n\tbody_node = NULL;\n\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e == GF_OK) {\n\t\t\tif (body_node) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\"));\n\t\t\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tbody_node = node;\n\t\t}\n\t}\n\tif (!body_node) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"body\\\" element not found, assuming empty doc\\n\"));\n\t}\n\n\tif (!ctx->div_nodes_list) {\n\t\tctx->div_nodes_list = gf_list_new();\n\t\tif (!ctx->div_nodes_list) return GF_OUT_OF_MEM;\n\t} else {\n\t\tgf_list_reset(ctx->div_nodes_list);\n\t}\n\n\tif (body_node) {\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(body_node->content, &i))) {\n\t\t\tif (!node->type) {\n\t\t\t\te = gf_xml_get_element_check_namespace(node, \"div\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_add(ctx->div_nodes_list, node);\n\t\t}\n\t}\n\tfile_size = ctx->end;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SUBS_XML) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( lang) );\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:xmlns\", &PROP_STRING(TTML_NAMESPACE) );\n\n\t/*** body ***/\n\tctx->parser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser_working_copy, ctx->file_name, NULL, NULL);\n\tassert (e == GF_OK);\n\tctx->root_working_copy = gf_xml_dom_get_root(ctx->parser_working_copy);\n\tassert(ctx->root_working_copy);\n\n\tif (body_node) {\n\t\t/*remove all the sample entries (instances in body) entries from the working copy, we will add each sample in this clone DOM  to create full XML of each sample*/\n\t\tebu_ttd_remove_samples(ctx->root_working_copy, &ctx->body_node);\n\t\tif (!ctx->body_node) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t} else {\n\t\tctx->body_node = NULL;\n\t}\n\n\tctx->current_tt_interval = 0;\n\n\tctx->last_sample_duration = 0;\n\tctx->end = 0;\n\tctx->first_samp = GF_TRUE;\n\n\ttxtin_probe_duration(ctx);\n\n\te = ttml_setup_intervals(ctx);\n\tif (e) return e;\n\n\tif (ctx->has_images) {\n\t\tchar *mime_cfg = \"application/ttml+xml;codecs=im1i\";\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\t} else {\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", NULL);\n\t}\n\treturn GF_OK;\n}\n\nstatic Bool ttml_check_range(TTMLInterval *interval, s64 ts_begin, s64 ts_end)\n{\n\t//if in current interval, push node\n\tif ((ts_begin != -1) && (ts_end != -1) && ((ts_begin>=interval->begin) && (ts_end<=interval->end))\n\t) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin not set, end set: in range if end less than interval end range\n\telse if ((ts_begin==-1) && (ts_end != -1) && (ts_end<=interval->end)) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin set, end not set: in range if begin greater than interval begin range\n\telse if ((ts_begin!=-1) && (ts_end==-1) && (ts_begin>=interval->begin)) {\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic GF_Err gf_text_process_ttml(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tGF_XMLNode *root;\n\tu32 i, nb_res_interval=0, k, nb_div_nodes;\n\tchar *samp_text=NULL;\n\tGF_List *emb_resources = NULL;\n\tTTMLInterval *interval;\n\tBool sample_empty = GF_TRUE;\n\n\tif (!ctx->is_setup) return gf_text_ttml_setup(filter, ctx);\n\tif (ctx->non_compliant_ttml || !ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->current_tt_interval = 0;\n\t}\n\n\tinterval = gf_list_get(ctx->intervals, ctx->current_tt_interval);\n\tif (!interval) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", ctx->last_sample_duration, ctx->end));\n\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tctx->current_tt_interval++;\n\n\temb_resources = interval->resources ? interval->resources : ctx->ttml_resources;\n\tnb_res_interval = gf_list_count(emb_resources);\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tnb_div_nodes = gf_list_count(ctx->div_nodes_list);\n\tfor (k=0; k<nb_div_nodes; k++) {\n\t\tBool has_content = GF_FALSE;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, k);\n\t\tu32 nb_children = gf_list_count(div_node->content);\n\n\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\n\t\tfor (i=0; i < nb_children; i++) {\n\t\t\tGF_XMLNode *p_node;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tu32 p_idx = 0;\n\t\t\ts64 ts_begin = -1, ts_end = -1;\n\t\t\tBool in_range;\n\t\t\tGF_XMLNode *div_child = (GF_XMLNode*)gf_list_get(div_node->content, i);\n\t\t\tif (div_child->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_xml_get_element_check_namespace(div_child, \"p\", root->ns);\n\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", div_child->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\t//sample is either in the <p> ...\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_end = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\tif (in_range) {\n\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t}\n\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\tassert(e == GF_OK);\n\t\t\t\thas_content = GF_TRUE;\n\t\t\t}\n\n\t\t\t//or under a <span>\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_child->content, &p_idx))) {\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", p_node->name));\n\t\t\t\t}\n\t\t\t\telse if (e)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tts_begin = ts_end = -1;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_end = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*append the entire <p> and break (we cannot split the text content)*/\n\t\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\t\tif (in_range) {\n\t\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t\t}\n\t\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\thas_content = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (has_content) {\n\t\t\tGF_XMLNode *last_child = (GF_XMLNode*) gf_list_last(div_node->content);\n\t\t\tif (last_child && last_child->type) {\n\t\t\t\tgf_xml_dom_append_child(copy_div_node, last_child);\n\t\t\t}\n\t\t\tsample_empty = GF_FALSE;\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!ctx->body_node)\n\t\tsample_empty = GF_FALSE;\n\n\tif (! sample_empty) {\n\t\tsamp_text = gf_xml_dom_serialize_root((GF_XMLNode*)ctx->root_working_copy, GF_FALSE, GF_FALSE);\n\n\t\tfor (k=0; k<nb_div_nodes; k++) {\n\t\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\t\t\tif (!copy_div_node->type)\n\t\t\t\tgf_list_reset(copy_div_node->content);\n\t\t}\n\t}\n\n\tif (samp_text) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu32 txt_len;\n\t\tu32 res_len = 0;\n\t\tchar *txt_str;\n\n\n\t\tif (interval->begin < (s64) ctx->end) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] Error computing overlapped intervals! \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", interval->begin, ctx->end));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttxt_str = ttxt_parse_string(samp_text, GF_TRUE);\n\t\tif (!txt_str) txt_str = \"\";\n\t\ttxt_len = (u32) strlen(txt_str);\n\n\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\tres_len += res->size;\n\t\t}\n\n\t\tif (ctx->first_samp) {\n\t\t\tinterval->begin = 0; /*in MP4 we must start at T=0*/\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t}\n\n\t\tctx->last_sample_duration = interval->end - interval->begin;\n\n\t\tctx->end = interval->end;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", interval->begin, interval->end, interval->end - ctx->end, ctx->last_sample_duration, ctx->end));\n\n\t\tif (ctx->seek_state==2) {\n\t\t\tDouble end = (Double) interval->end;\n\t\t\tend /= ctx->timescale;\n\t\t\tif (end<ctx->start_range) skip_pck = GF_TRUE;\n\t\t\telse ctx->seek_state = 0;\n\t\t}\n\n\t\tif (!skip_pck) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, txt_len+res_len, &pck_data);\n\t\t\tif (!pck) {\n\t\t\t\tgf_free(samp_text);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(pck_data, txt_str, txt_len);\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->ttml_dur>0) {\n\t\t\t\tgf_filter_pck_set_cts(pck, 0);\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) ctx->ttml_dur);\n\t\t\t\tctx->last_sample_duration = (u64) ctx->ttml_dur * 1000 / ctx->timescale;\n\t\t\t} else {\n\t\t\t\tgf_filter_pck_set_cts(pck, (ctx->timescale * interval->begin)/1000);\n\t\t\t\tif (interval->end >= interval->begin) {\n\t\t\t\t\tgf_filter_pck_set_duration(pck, (u32) ((ctx->timescale * (interval->end - interval->begin) )/1000) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res_len) {\n\t\t\t\tGF_BitStream *subs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tu8 *subs_data;\n\t\t\t\tu32 subs_size;\n\t\t\t\t//subs 0\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u32(subs, txt_len);\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\n\t\t\t\tpck_data += txt_len;\n\t\t\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\t\t\tmemcpy(pck_data, res->data, res->size);\n\t\t\t\t\tpck_data += res->size;\n\n\t\t\t\t\t//subs >0\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u32(subs, res->size);\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(subs, &subs_data, &subs_size);\n\t\t\t\tgf_bs_del(subs);\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_data, subs_size) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_free(samp_text);\n\t\tsamp_text = NULL;\n\t} else {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] empty sample (begin=\"LLD\", end=\"LLD\"). Skip.\\n\", interval->begin, interval->end));\n\t}\n\n\treturn GF_OK;\n\n\nexit:\n\tif (!ctx->non_compliant_ttml) {\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\n\t\tgf_filter_pck_send(pck);\n\t}\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tctx->do_suspend = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const u8 *data, u32 length, Bool isHeader)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (isHeader) {\n\t\tif (!ctx->hdr_parsed) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *)data, (u32) ( strlen(data)+1 ) )  );\n\t\t\tctx->hdr_parsed = GF_TRUE;\n\t\t}\n\t} else if (!ctx->seek_state) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, data, length);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_swf_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID;\n\n\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\te = gf_swf_read_header(ctx->swf_parse);\n\tif (e) return e;\n\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SIMPLE_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n//\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_UINT(file_size) );\n\n\t//patch for old arch\n\tctx->width = FIX2INT(ctx->swf_parse->width);\n\tctx->height = FIX2INT(ctx->swf_parse->height);\n\tif (!ctx->width && !ctx->height) {\n\t\tctx->width = 400;\n\t\tctx->height = 60;\n\t}\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(\"image/svg+xml\") );\n\n#ifndef GPAC_DISABLE_SVG\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] swf -> svg not fully migrated, using SWF flags 0 and no flatten angle. Patch welcome\\n\"));\n\te = swf_to_svg_init(ctx->swf_parse, 0, 0);\n#endif\n\n\t//SWF->BIFS is handled in ctx loader, no need to define it here\n\ttxtin_probe_duration(ctx);\n\n\treturn e;\n}\n\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e=GF_OK;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn gf_text_swf_setup(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_swf_reader_del(ctx->swf_parse);\n\t\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\t\tgf_swf_read_header(ctx->swf_parse);\n\t\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\t}\n\n\tctx->do_suspend = GF_FALSE;\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(ctx->swf_parse);\n\t\tif (ctx->do_suspend) return GF_OK;\n\t}\n\tif (e==GF_EOS) {\n\t\tif (ctx->swf_parse->finalize) {\n\t\t\tctx->swf_parse->finalize(ctx->swf_parse);\n\t\t\tctx->swf_parse->finalize = NULL;\n\t\t}\n\t}\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\n#ifndef GPAC_DISABLE_ZLIB\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import file.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tDouble ts_scale;\n\tchar szLine[2048], szTime[20], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tif (ctx->fps.den && ctx->fps.num) {\n\t\tts_scale = ((Double) ctx->fps.num) / ctx->fps.den;\n\t} else {\n\t\tts_scale = 25;\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\\n\", line, szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->start = atoi(szTime);\n\t\tif (ctx->start < ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\\n\", line, ctx->start, ctx->end));\n\t\t\tctx->start = ctx->end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\\n\", szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->end = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->start && ctx->first_samp) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\n\t\tif (ctx->prev_end) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}\n\n\n\nstatic u32 ttxt_get_color(char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Warning: color badly formatted %s\\n\", val));\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nstatic void ttxt_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nstatic void ttxt_parse_text_style(GF_TXTIn *ctx, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = ctx->fontsize ;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\tif (strstr(att->value, \"Strikethrough\")) style->style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t}\n\t}\n}\n\nstatic GF_Err txtin_setup_ttxt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 j, k, ID, OCR_ES_ID;\n\tu64 file_size;\n\tGF_XMLNode *root, *ext;\n\tGF_PropertyValue *dcd;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTXT file: Line %d - %s\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser)));\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->end = 0;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\n\tctx->nb_children = gf_list_count(root->content);\n\n\tctx->cur_child_idx = 0;\n\tfor (ctx->cur_child_idx=0; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tw = ctx->width;\n\t\t\th = ctx->height;\n\t\t\ttx = ctx->txtx;\n\t\t\tty = ctx->txty;\n\t\t\tlayer = ctx->zorder;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id) {\n\t\t\t\tgf_filter_pid_set_property_str(ctx->opid, \"tref:chap\", &PROP_UINT(tref_id) );\n\t\t\t}\n\n\t\t\tif (w) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\t\t\tif (h) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\t\t\tif (tx) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(tx) );\n\t\t\tif (ty) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(ty) );\n\t\t\tif (layer) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\t\t\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(ctx, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->nodefbox) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tGF_SAFEALLOC(dcd, GF_PropertyValue);\n\t\t\t\t\tif (dcd) {\n\t\t\t\t\t\tdcd->type = GF_PROP_DATA;\n\n\t\t\t\t\t\tgf_odf_tx3g_write(&td, &dcd->value.data.ptr, &dcd->value.data.size);\n\t\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\t\tgf_list_add(ctx->text_descs, dcd);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx->text_descs) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - text stream header not found or empty\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tdcd = gf_list_get(ctx->text_descs, 0);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\tctx->last_desc_idx = 1;\n\n\tctx->first_samp = GF_TRUE;\n\tctx->last_sample_empty = GF_FALSE;\n\tctx->last_sample_duration = 0;\n\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_ttxt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 j, k;\n\tGF_XMLNode *root, *ext;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_ttxt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_TextSample * samp;\n\t\tu32 ts, descIndex;\n\t\tBool has_text = GF_FALSE;\n\t\tGF_XMLAttribute *att;\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*sample text*/\n\t\telse if (strcmp(node->name, \"TextSample\")) continue;\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tts = 0;\n\t\tdescIndex = 1;\n\t\tctx->last_sample_empty = GF_TRUE;\n\n\t\tj=0;\n\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t} else {\n\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(att->value, GF_TRUE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, ttxt_get_color(att->value));\n\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t}\n\n\t\t/*get all modifiers*/\n\t\tj=0;\n\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(ext->name, GF_FALSE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\tif (ext->type) continue;\n\n\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\tGF_StyleRecord r;\n\t\t\t\tttxt_parse_text_style(ctx, ext, &r);\n\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\tGF_BoxRecord r;\n\t\t\t\tttxt_parse_text_box(ext, &r);\n\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tchar *url, *url_tt;\n\t\t\t\tstart = end = 0;\n\t\t\t\turl = url_tt = NULL;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\tif (url) gf_free(url);\n\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\tu32 startTime;\n\t\t\t\tGF_XMLNode *krok;\n\t\t\t\tstartTime = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\tk=0;\n\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tendTime = 0;\n\t\t\t\t\tm=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!descIndex) descIndex = 1;\n\t\tif (descIndex != ctx->last_desc_idx) {\n\t\t\tGF_PropertyValue *dcd;\n\t\t\tctx->last_desc_idx = descIndex;\n\t\t\tdcd = gf_list_get(ctx->text_descs, descIndex-1);\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\t\t}\n\n\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\tif (ts && ctx->first_samp) {\n\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, firstsamp, 0, 0, GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t}\n\t\tctx->first_samp = GF_FALSE;\n\n\t\ttxtin_process_send_text_sample(ctx, samp, ts, 0, GF_TRUE);\n\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tif (ctx->last_sample_empty) {\n\t\t\tctx->last_sample_duration = ts - ctx->last_sample_duration;\n\t\t} else {\n\t\t\tctx->last_sample_duration = ts;\n\t\t}\n\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (ctx->last_sample_empty) {\n\t\t//this is a bit ugly, in regular streaming mode we don't want to remove empty samples\n\t\t//howvere the last one can be removed, adjusting the duration of the previous one.\n\t\t//doing this here is problematic if the loader is sent a new ttxt file, we would have a cue termination sample\n\t\t//we therefore share that info through pid, and let the final user (muxer& co) decide what to do\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:rem_last\", &PROP_BOOL(GF_TRUE) );\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t}\n\n\treturn GF_EOS;\n}\n\n\nstatic u32 tx3g_get_color(char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Warning: color badly formatted\\n\"));\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nstatic void tx3g_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic GF_Err txtin_texml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, i;\n\tu64 file_size;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tgf_xml_dom_del(ctx->parser);\n\t\tctx->parser = NULL;\n\t\treturn e;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->txml_timescale = 600;\n\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) ctx->width = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) ctx->height = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) ctx->zorder = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timeScale\")) ctx->txml_timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\tctx->txtx = (u32) fx;\n\t\t\tctx->txty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tOCR_ES_ID = ID = 0;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_ISOM_SUBTYPE_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\n\tctx->nb_children = gf_list_count(root->content);\n\tctx->cur_child_idx = 0;\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_texml(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 j, k;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\tBool probe_first_desc_only = GF_FALSE;\n\n\tif (!ctx->is_setup) {\n\t\tGF_Err e;\n\n\t\tctx->is_setup = GF_TRUE;\n\t\te = txtin_texml_setup(filter, ctx);\n\t\tif (e) return e;\n\t\tprobe_first_desc_only = GF_TRUE;\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate && !probe_first_desc_only) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t\tctx->start = 0;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node, *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tu64 duration;\n\t\tu32 nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (probe_first_desc_only && ctx->text_descs && gf_list_count(ctx->text_descs))\n\t\t\treturn GF_OK;\n\n\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\tnode = (GF_XMLNode*)gf_list_get(root->content, ctx->cur_child_idx);\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_TRUE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tu8 *dsi;\n\t\t\t\tu32 dsi_len, stsd_idx;\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable ? ftable->name : NULL;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"strikethrough\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = ctx->txty;\n\t\t\t\t\ttd.default_pos.left = ctx->txtx;\n\t\t\t\t\ttd.default_pos.right = ctx->width;\n\t\t\t\t\ttd.default_pos.bottom = ctx->height;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup( ctx->fontname ? ctx->fontname : \"Serif\");\n\t\t\t\t}\n\n\t\t\t\tgf_odf_tx3g_write(&td, &dsi, &dsi_len);\n\t\t\t\tstsd_idx = 0;\n\t\t\t\tfor (k=0; ctx->text_descs && k<gf_list_count(ctx->text_descs); k++) {\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, k);\n\t\t\t\t\tif (d->value.data.size != dsi_len) continue;\n\t\t\t\t\tif (! memcmp(d->value.data.ptr, dsi, dsi_len)) {\n\t\t\t\t\t\tstsd_idx = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stsd_idx) {\n\t\t\t\t\tgf_free(dsi);\n\t\t\t\t} else {\n\t\t\t\t\tGF_PropertyValue *d;\n\t\t\t\t\tGF_SAFEALLOC(d, GF_PropertyValue);\n\t\t\t\t\tif (!d) return GF_OUT_OF_MEM;\n\t\t\t\t\td->type = GF_PROP_DATA;\n\t\t\t\t\td->value.data.ptr = dsi;\n\t\t\t\t\td->value.data.size = dsi_len;\n\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\tgf_list_add(ctx->text_descs, d);\n\t\t\t\t\tstsd_idx = gf_list_count(ctx->text_descs);\n\t\t\t\t}\n\t\t\t\tif (stsd_idx != ctx->last_desc_idx) {\n\t\t\t\t\tctx->last_desc_idx = stsd_idx;\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, stsd_idx-1);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, d);\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\n\t\t\t\tif (probe_first_desc_only)\n\t\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, tx3g_get_color(att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (ctx->start*ctx->timescale)/ctx->txml_timescale, (u32) (duration*ctx->timescale)/ctx->txml_timescale, isRAP);\n\t\t\tctx->start += duration;\n\t\t\tgf_isom_delete_text_sample(samp);\n\n\t\t}\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\treturn GF_EOS;\n}\n\n\nstatic GF_Err txtin_process(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tGF_Err e;\n\tBool start, end;\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\treturn GF_OK;\n\t}\n\tgf_filter_pck_get_framing(pck, &start, &end);\n\tif (!end) {\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\treturn GF_OK;\n\t}\n\t//file is loaded\n\n\te = ctx->text_process(filter, ctx);\n\n\n\tif (e==GF_EOS) {\n\t\t//keep input alive until end of stream, so that we keep getting called\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tif (gf_filter_pid_is_eos(ctx->ipid))\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t}\n\treturn e;\n}\n\nstatic void ttxtin_reset(GF_TXTIn *ctx)\n{\n\tif (ctx->samp) gf_isom_delete_text_sample(ctx->samp);\n\tctx->samp = NULL;\n\tif (ctx->src) gf_fclose(ctx->src);\n\tctx->src = NULL;\n\tif (ctx->vttparser) gf_webvtt_parser_del(ctx->vttparser);\n\tctx->vttparser = NULL;\n\tif (ctx->parser) gf_xml_dom_del(ctx->parser);\n\tctx->parser = NULL;\n\tif (ctx->parser_working_copy) gf_xml_dom_del(ctx->parser_working_copy);\n\tctx->parser_working_copy = NULL;\n}\n\nstatic GF_Err txtin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_Err e;\n\tconst char *src = NULL;\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tconst GF_PropertyValue *prop;\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\t//we must have a file path\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\tif (prop && prop->value.string) src = prop->value.string;\n\tif (!src)\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (!ctx->ipid) {\n\t\tGF_FilterEvent fevt;\n\t\tctx->ipid = pid;\n\n\t\t//we work with full file only, send a play event on source to indicate that\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_PLAY, pid);\n\t\tfevt.play.start_range = 0;\n\t\tfevt.base.on_pid = ctx->ipid;\n\t\tfevt.play.full_file_only = GF_TRUE;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\tctx->file_name = gf_strdup(src);\n\t} else {\n\t\tif (pid != ctx->ipid) {\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (!strcmp(ctx->file_name, src)) return GF_OK;\n\n\t\tttxtin_reset(ctx);\n\t\tctx->is_setup = GF_FALSE;\n\t\tgf_free(ctx->file_name);\n\t\tctx->file_name = gf_strdup(src);\n\t}\n\t//guess type\n\te = gf_text_guess_format(ctx->file_name, &ctx->fmt);\n\tif (e) return e;\n\tif (!ctx->fmt) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTLoad] Unknown text format for %s\\n\", ctx->file_name));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (ctx->webvtt && (ctx->fmt == GF_TXTIN_MODE_SRT))\n\t\tctx->fmt = GF_TXTIN_MODE_WEBVTT;\n\n\tswitch (ctx->fmt) {\n\tcase GF_TXTIN_MODE_SRT:\n\t\tctx->text_process = txtin_process_srt;\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TXTIN_MODE_WEBVTT:\n\t\tctx->text_process = txtin_process_webvtt;\n\t\tbreak;\n#endif\n\tcase GF_TXTIN_MODE_TTXT:\n\t\tctx->text_process = txtin_process_ttxt;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TEXML:\n\t\tctx->text_process = txtin_process_texml;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_SUB:\n\t\tctx->text_process = gf_text_process_sub;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TTML:\n\t\tctx->text_process = gf_text_process_ttml;\n\t\tbreak;\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_TXTIN_MODE_SWF_SVG:\n\t\tctx->text_process = gf_text_process_swf;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool txtin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (ctx->playstate==1) return GF_TRUE;\n\t\tctx->playstate = 1;\n\t\tif ((ctx->start_range < 0.1) && (evt->play.start_range<0.1)) return GF_TRUE;\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->seek_state = 1;\n\t\t//cancel play event, we work with full file\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->playstate = 2;\n\t\t//cancel play event, we work with full file\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_Err txtin_initialize(GF_Filter *filter)\n{\n\tchar data[1];\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tctx->bs_w = gf_bs_new(data, 1, GF_BITSTREAM_WRITE);\n\n\treturn GF_OK;\n}\n\nvoid txtin_finalize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\n\tttxtin_reset(ctx);\n\tif (ctx->bs_w) gf_bs_del(ctx->bs_w);\n\n\tif (ctx->text_descs) {\n\t\twhile (gf_list_count(ctx->text_descs)) {\n\t\t\tGF_PropertyValue *p = gf_list_pop_back(ctx->text_descs);\n\t\t\tgf_free(p->value.data.ptr);\n\t\t\tgf_free(p);\n\t\t}\n\t\tgf_list_del(ctx->text_descs);\n\t}\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tgf_swf_reader_del(ctx->swf_parse);\n#endif\n\n\tif (ctx->intervals) {\n\t\tttml_reset_intervals(ctx);\n\t\tgf_list_del(ctx->intervals);\n\t}\n\tif (ctx->ttml_resources) {\n\t\twhile (gf_list_count(ctx->ttml_resources)) {\n\t\t\tTTMLRes *ires = gf_list_pop_back(ctx->ttml_resources);\n\t\t\tgf_free(ires->data);\n\t\t\tgf_free(ires);\n\t\t}\n\t\tgf_list_del(ctx->ttml_resources);\n\t}\n\tif (ctx->div_nodes_list)\n\t\tgf_list_del(ctx->div_nodes_list);\n\n\tif (ctx->file_name) gf_free(ctx->file_name);\n}\n\n\nstatic const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)\n{\n\tchar *dst = NULL;\n\tu8 *res;\n\n\tres = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);\n\tif (res) data = res;\n\n#define PROBE_OK(_score, _mime) \\\n\t\t*score = _score;\\\n\t\tif (dst) gf_free(dst);\\\n\t\treturn _mime; \\\n\n\n\tif (!strncmp(data, \"WEBVTT\", 6)) {\n\t\tPROBE_OK(GF_FPROBE_SUPPORTED, \"subtitle/vtt\")\n\t}\n\tif (strstr(data, \" --> \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/srt\")\n\t}\n\tif (!strncmp(data, \"FWS\", 3) || !strncmp(data, \"CWS\", 3)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"application/x-shockwave-flash\")\n\t}\n\n\tif ((data[0]=='{') && strstr(data, \"}{\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/sub\")\n\n\t}\n\t/*XML formats*/\n\tif (!strstr(data, \"?>\") ) {\n\t\tif (dst) gf_free(dst);\n\t\treturn NULL;\n\t}\n\n\tif (strstr(data, \"<x-quicktime-tx3g\") || strstr(data, \"<text3GTrack\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"quicktime/text\")\n\t}\n\tif (strstr(data, \"TextStream\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttxt\")\n\t}\n\tif (strstr(data, \"<tt \") || strstr(data, \":tt \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttml\")\n\t}\n\n\tif (dst) gf_free(dst);\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability TXTInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"srt|ttxt|sub|vtt|txml|ttml|swf\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"x-subtitle/srt|subtitle/srt|text/srt|x-subtitle/sub|subtitle/sub|text/sub|x-subtitle/ttxt|subtitle/ttxt|text/ttxt|x-subtitle/vtt|subtitle/vtt|text/vtt|x-quicktime/text|quicktime/text|subtitle/ttml|text/ttml|application/xml+ttml|application/x-shockwave-flash\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SUBS_XML),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs TXTInArgs[] =\n{\n\t{ OFFS(webvtt), \"force WebVTT import of SRT files\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nodefbox), \"skip default text box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noflush), \"skip final sample flush for srt\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fontname), \"default font to use\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{ OFFS(lang), \"default language to use\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(width), \"default width of text area, set to 0 to resolve against visual PIDs\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(height), \"default height of text area, set to 0 to resolve against visual PIDs\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txtx), \"default horizontal offset of text area: -1 (left), 0 (center) or 1 (right)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txty), \"default vertical offset of text area: -1 (bottom), 0 (center) or 1 (top)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(zorder), \"default z-order of the PID\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(timescale), \"default timescale of the PID\", GF_PROP_UINT, \"1000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_dur), \"force single sample mode - see filter help\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_embed), \"force embedding TTML resources - see filter help\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_zero), \"set subtitle zero time for TTML - see filter help\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\nGF_FilterRegister TXTInRegister = {\n\t.name = \"txtin\",\n\tGF_FS_SET_DESCRIPTION(\"Subtitle loader\")\n\tGF_FS_SET_HELP(\"This filter reads subtitle data from input file PID to produce subtitle frames on a single PID.\\n\"\n\t\"The filter supports the following formats:\\n\"\n\t\"- SRT: https://en.wikipedia.org/wiki/SubRip\\n\"\n\t\"- WebVTT: https://www.w3.org/TR/webvtt1/\\n\"\n\t\"- TTXT: https://wiki.gpac.io/TTXT-Format-Documentation\\n\"\n\t\"- QT 3GPP Text XML (TexML): Apple QT6, likely deprecated\\n\"\n\t\"- TTML: https://www.w3.org/TR/ttml2/\\n\"\n\t\"- SUB: one subtitle per line formatted as `{start_frame}{end_frame}text`\\n\"\n\t\"\\n\"\n\t\"Input files must be in UTF-8 or UTF-16 format, with or without BOM.\\n\"\n\t\"The internal frame format is: \\n\"\n\t\"- WebVTT (and srt if desired): ISO/IEC 14496-30 VTT cues\\n\"\n\t\"- TTML: ISO/IEC 14496-30 XML subtitles\\n\"\n\t\"- Others: 3GPP/QT Timed Text\\n\"\n\t\"\\n\"\n\t\"# TTML Support\\n\"\n\t\"The [-ttml_dur]() option controls how TTML are split into packets:\\n\"\n\t\"- if negative (default), TTML document is split in independent time segments by inspecting all overlapping subtitles in the body\\n\"\n\t\"- if 0, the input document is not split, forwarded as a single frame with `CTS` matching the first active time in document and a duration equal to the document duration\\n\"\n\t\"- if >0, the input document is not split, forwarded as a single frame with `CTS=0` and the specified duration in `timescale` units.\\n\"\n\t\"\\n\"\n\t\"By default, media resources are kept as declared in TTML2 documents.\\n\"\n\t\"[-ttml_embed]() can be used to embed inside the TTML sample the resources in `<head>` or `<body>`.\\n\"\n\t\"- for `<source>`, `<image>`, `<audio>`, `<font>`, local URIs indicated in `src` will be loaded and `src` rewritten.\\n\"\n\t\"- for `<data>` with base64 coding, the data will be decoded, `<data>` element removed and parent <source> rewritten with `src` attribute inserted.\\n\"\n\t\"\\nThe embedded data is added as a subsample to the TTML frame, and the referring elements will use `src=urn:mpeg:14496-30:N` with `N` the index of the subsample.\\n\"\n\t\"\\n\"\n\t\"A `subtitle zero` may be specified using [-ttml_zero](). This will remove all subtitles before the given time `T0`, and rewrite each subtitle begin/end `T` to `T-T0` using millisecond accuracy.\\n\"\n\t\"Warning: Original time formatting (tick, frames/subframe ...) will be lost when this option is used, converted to `HH:MM:SS.ms`.\\n\"\n\t\"\\n\"\n\t\"The subtitle zero time **must** be prefixed with `T` when the option is not set as a global argument:\\n\"\n\t\"EX gpac -i test.ttml:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml:sopt:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX gpac -i test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\n\n\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = TXTInArgs,\n\tSETCAPS(TXTInCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = txtin_initialize,\n\t.finalize = txtin_finalize\n};\n\n\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn &TXTInRegister;\n}\n\n\n#else\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2021\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / text import filter\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n\n#include <gpac/filters.h>\n#include <gpac/constants.h>\n#include <gpac/utf.h>\n#include <gpac/xml.h>\n#include <gpac/token.h>\n#include <gpac/color.h>\n#include <gpac/internal/media_dev.h>\n#include <gpac/internal/isomedia_dev.h>\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n/* SWF Importer */\n#include <gpac/internal/swf_dev.h>\n#endif\n\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\n#define TTML_NAMESPACE \"http://www.w3.org/ns/ttml\"\n\n#define CHECK_STR(__str)\t\\\n\tif (!__str) { \\\n\t\te = gf_import_message(import, GF_BAD_PARAM, \"Invalid XML formatting (line %d)\", parser.line);\t\\\n\t\tgoto exit;\t\\\n\t}\n\n\ntypedef struct __txtin_ctx GF_TXTIn;\n\nstruct __txtin_ctx\n{\n\t//opts\n\tu32 width, height, txtx, txty, fontsize;\n\ts32 zorder;\n\tconst char *fontname, *lang, *ttml_zero;\n\tBool nodefbox, noflush, webvtt, ttml_embed;\n\tu32 timescale;\n\tGF_Fraction fps;\n\ts32 ttml_dur;\n\n\n\tGF_FilterPid *ipid, *opid;\n\tchar *file_name;\n\tu32 fmt;\n\tu32 playstate;\n\t//0: not seeking, 1: seek request pending, 2: seek configured, discarding packets up until start_range\n\tu32 seek_state;\n\tDouble start_range;\n\n\tBool is_setup;\n\n\tGF_Err (*text_process)(GF_Filter *filter, GF_TXTIn *ctx);\n\n\ts32 unicode_type;\n\n\tFILE *src;\n\n\tGF_BitStream *bs_w;\n\tBool first_samp;\n\tBool hdr_parsed;\n\n\t//state vars for srt\n\tu32 state, default_color;\n\tGF_TextSample *samp;\n\tu64 start, end, prev_end;\n\tu32 curLine;\n\tGF_StyleRecord style;\n\n\t//WebVTT state\n\tGF_WebVTTParser *vttparser;\n\n\t//TTXT state\n\tGF_DOMParser *parser;\n\tu32 cur_child_idx, nb_children, last_desc_idx;\n\tGF_List *text_descs;\n\tBool last_sample_empty;\n\tu64 last_sample_duration;\n\t//TTML state is the same as ttxt plus the timescale and start (webvtt) for cts compute\n\tu32 txml_timescale;\n\tu32 current_tt_interval;\n\n\t//TTML state\n\tGF_XMLNode *root_working_copy, *body_node;\n\tGF_DOMParser *parser_working_copy;\n\tBool non_compliant_ttml;\n\tu32 tick_rate, ttml_fps_num, ttml_fps_den, ttml_sfps;\n\tGF_List *ttml_resources;\n\tGF_List *div_nodes_list;\n\tBool has_images;\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t//SWF text\n\tSWFReader *swf_parse;\n\tBool do_suspend;\n#endif\n\n\n\tGF_List *intervals;\n};\n\ntypedef struct\n{\n\tu32 size;\n\tu8 *data;\n\tBool global;\n} TTMLRes;\n\ntypedef struct\n{\n\ts64 begin, end;\n\tGF_List *resources;\n} TTMLInterval;\n\n\nenum\n{\n\tGF_TXTIN_MODE_NONE = 0,\n\tGF_TXTIN_MODE_SRT,\n\tGF_TXTIN_MODE_SUB,\n\tGF_TXTIN_MODE_TTXT,\n\tGF_TXTIN_MODE_TEXML,\n\tGF_TXTIN_MODE_WEBVTT,\n\tGF_TXTIN_MODE_TTML,\n\tGF_TXTIN_MODE_SWF_SVG,\n};\n\n#define REM_TRAIL_MARKS(__str, __sep) while (1) {\t\\\n\t\tu32 _len = (u32) strlen(__str);\t\t\\\n\t\tif (!_len) break;\t\\\n\t\t_len--;\t\t\t\t\\\n\t\tif (strchr(__sep, __str[_len])) __str[_len] = 0;\t\\\n\t\telse break;\t\\\n\t}\t\\\n \n\ns32 gf_text_get_utf_type(FILE *in_src)\n{\n\tu32 read;\n\tunsigned char BOM[5];\n\tread = (u32) gf_fread(BOM, 5, in_src);\n\tif ((s32) read < 1)\n\t\treturn -1;\n\n\tif ((BOM[0]==0xFF) && (BOM[1]==0xFE)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 3;\n\t}\n\tif ((BOM[0]==0xFE) && (BOM[1]==0xFF)) {\n\t\t/*UTF32 not supported*/\n\t\tif (!BOM[2] && !BOM[3]) return -1;\n\t\tgf_fseek(in_src, 2, SEEK_SET);\n\t\treturn 2;\n\t} else if ((BOM[0]==0xEF) && (BOM[1]==0xBB) && (BOM[2]==0xBF)) {\n\t\tgf_fseek(in_src, 3, SEEK_SET);\n\t\treturn 1;\n\t}\n\tif (BOM[0]<0x80) {\n\t\tgf_fseek(in_src, 0, SEEK_SET);\n\t\treturn 0;\n\t}\n\treturn -1;\n}\nstatic void ttxt_dom_progress(void *cbk, u64 cur_samp, u64 count)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)cbk;\n\tctx->end = count;\n}\n\nstatic GF_Err gf_text_guess_format(const char *filename, u32 *fmt)\n{\n\tchar szLine[2048];\n\tu32 val;\n\ts32 uni_type;\n\tFILE *test = gf_fopen(filename, \"rb\");\n\tif (!test) return GF_URL_ERROR;\n\tuni_type = gf_text_get_utf_type(test);\n\n\tif (uni_type>1) {\n\t\tconst u16 *sptr;\n\t\tchar szUTF[1024];\n\t\tu32 read = (u32) gf_fread(szUTF, 1023, test);\n\t\tif ((s32) read < 0) {\n\t\t\tgf_fclose(test);\n\t\t\treturn GF_IO_ERR;\n\t\t}\n\t\tszUTF[read]=0;\n\t\tsptr = (u16*)szUTF;\n\t\t/*read = (u32) */gf_utf8_wcstombs(szLine, read, &sptr);\n\t} else {\n\t\tval = (u32) gf_fread(szLine, 1024, test);\n\t\tif ((s32) val<0) return GF_IO_ERR;\n\t\t\n\t\tszLine[val]=0;\n\t}\n\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t*fmt = GF_TXTIN_MODE_NONE;\n\tif ((szLine[0]=='{') && strstr(szLine, \"}{\")) *fmt = GF_TXTIN_MODE_SUB;\n\telse if (szLine[0] == '<') {\n\t\tchar *ext = gf_file_ext_start(filename);\n\t\tif (!strnicmp(ext, \".ttxt\", 5)) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (!strnicmp(ext, \".ttml\", 5)) *fmt = GF_TXTIN_MODE_TTML;\n\t\text = strstr(szLine, \"?>\");\n\t\tif (ext) ext += 2;\n\t\tif (ext && !ext[0]) {\n\t\t\tif (!gf_fgets(szLine, 2048, test))\n\t\t\t\tszLine[0] = '\\0';\n\t\t}\n\t\tif (strstr(szLine, \"x-quicktime-tx3g\") || strstr(szLine, \"text3GTrack\")) *fmt = GF_TXTIN_MODE_TEXML;\n\t\telse if (strstr(szLine, \"TextStream\")) *fmt = GF_TXTIN_MODE_TTXT;\n\t\telse if (strstr(szLine, \"tt\")) *fmt = GF_TXTIN_MODE_TTML;\n\t}\n\telse if (strstr(szLine, \"WEBVTT\") )\n\t\t*fmt = GF_TXTIN_MODE_WEBVTT;\n\telse if (strstr(szLine, \" --> \") )\n\t\t*fmt = GF_TXTIN_MODE_SRT; /* might want to change the default to WebVTT */\n\n\telse if (!strncmp(szLine, \"FWS\", 3) || !strncmp(szLine, \"CWS\", 3))\n\t\t*fmt = GF_TXTIN_MODE_SWF_SVG;\n\n\tgf_fclose(test);\n\treturn GF_OK;\n}\n\n\n\nchar *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}\n\n\nstatic void txtin_probe_duration(GF_TXTIn *ctx)\n{\n\tGF_Fraction64 dur;\n\tdur.num = 0;\n\n\tif (ctx->fmt == GF_TXTIN_MODE_SWF_SVG) {\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\t\tu32 frame_count, frame_rate;\n\t\tgf_swf_get_duration(ctx->swf_parse, &frame_rate, &frame_count);\n\t\tif (frame_count) {\n\t\t\tGF_Fraction64 tdur;\n\t\t\ttdur.num = frame_count;\n\t\t\ttdur.den = frame_rate;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(tdur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n#endif\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_SRT) || (ctx->fmt == GF_TXTIN_MODE_WEBVTT)  || (ctx->fmt == GF_TXTIN_MODE_SUB)) {\n\t\tu64 pos = gf_ftell(ctx->src);\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t\twhile (!gf_feof(ctx->src)) {\n\t\t\tu64 end;\n\t\t\tchar szLine[2048];\n\t\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\t\tif (!sOK) break;\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->fmt == GF_TXTIN_MODE_SUB) {\n\t\t\t\tchar szText[2048];\n\t\t\t\tu32 sframe, eframe;\n\t\t\t\tif (sscanf(szLine, \"{%d}{%d}%2047s\", &sframe, &eframe, szText) == 3) {\n\t\t\t\t\tif (ctx->fps.den)\n\t\t\t\t\t\tend = 1000 * eframe * ctx->fps.num / ctx->fps.den;\n\t\t\t\t\telse\n\t\t\t\t\t\tend = 1000 * eframe / 25;\n\t\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tu32 eh, em, es, ems;\n\t\t\t\tchar *start = strstr(szLine, \"-->\");\n\t\t\t\tif (!start) continue;\n\t\t\t\twhile (start[0] && ((start[0] == ' ') || (start[0] == '\\t'))) start++;\n\n\t\t\t\tif (sscanf(start, \"%u:%u:%u,%u\", &eh, &em, &es, &ems) != 4) {\n\t\t\t\t\teh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u\", &em, &es, &ems) != 3) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tend = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t\tif (end > (u64) dur.num) dur.num = (s64) end;\n\t\t\t}\n\t\t}\n\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) || (ctx->fmt == GF_TXTIN_MODE_TEXML)) {\n\t\tu32 i=0;\n\t\tGF_XMLNode *node, *root = gf_xml_dom_get_root(ctx->parser);\n\t\twhile ((node = gf_list_enum(root->content, &i))) {\n\t\t\tu32 j;\n\t\t\tu64 duration;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tif (node->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*sample text*/\n\t\t\tif ((ctx->fmt == GF_TXTIN_MODE_TTXT) && strcmp(node->name, \"TextSample\")) continue;\n\t\t\telse if ((ctx->fmt == GF_TXTIN_MODE_TEXML) && strcmp(node->name, \"sample\")) continue;\n\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tu64 ts=0;\n\t\t\t\tif (ctx->fmt == GF_TXTIN_MODE_TTXT) {\n\t\t\t\t\tif (strcmp(att->name, \"sampleTime\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t\t}\n\t\t\t\t\tif (ts > (u64) dur.num) dur.num = (s64) ts;\n\t\t\t\t} else {\n\t\t\t\t\tif (strcmp(att->name, \"duration\")) continue;\n\t\t\t\t\tduration = atoi(att->value);\n\t\t\t\t\tdur.num += (s32) ( (1000 * duration) / ctx->txml_timescale);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\n\tif (ctx->fmt == GF_TXTIN_MODE_TTML) {\n\t\tu32 i=0, k=0;\n\t\tGF_XMLNode *div_node;\n\n\t\twhile ((div_node = gf_list_enum(ctx->div_nodes_list, &k))) {\n\t\t\tGF_XMLNode *node;\n\t\t\twhile ((node = gf_list_enum(div_node->content, &i))) {\n\t\t\t\tGF_XMLNode *p_node;\n\t\t\t\tGF_XMLAttribute *att;\n\t\t\t\tu32 h, m, s, ms, p_idx=0;\n\t\t\t\tu64 ts_end=0;\n\t\t\t\th = m = s = ms = 0;\n\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &p_idx))) {\n\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\n\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//or under a <span>\n\t\t\t\tp_idx = 0;\n\t\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(node->content, &p_idx))) {\n\t\t\t\t\tu32 span_idx = 0;\n\t\t\t\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\t\tif (strcmp(att->name, \"end\")) continue;\n\t\t\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000+ms;\n\t\t\t\t\t\t} else if (sscanf(att->value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\t\t\t\t\t\tts_end = (h*3600 + m*60+s)*1000;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ts_end > (u64) dur.num) dur.num = (s64) ts_end;\n\t\t\t}\n\t\t}\n\t\tif (dur.num) {\n\t\t\tdur.den = 1000;\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DURATION, &PROP_FRAC64(dur));\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_PLAYBACK_MODE, &PROP_UINT(GF_PLAYBACK_MODE_FASTFORWARD ) );\n\t\t}\n\t\treturn;\n\t}\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Duration probing not supported for format %d\\n\", ctx->fmt));\n}\n\nstatic GF_Err txtin_setup_srt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 ID, OCR_ES_ID, dsi_len, file_size;\n\tu8 *dsi;\n\tGF_TextSampleDescriptor *sd;\n\n\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\tif (!ctx->src) return GF_URL_ERROR;\n\n\tfile_size = (u32) gf_fsize(ctx->src);\n\n\tctx->unicode_type = gf_text_get_utf_type(ctx->src);\n\tif (ctx->unicode_type<0) {\n\t\tgf_fclose(ctx->src);\n\t\tctx->src = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tsd = (GF_TextSampleDescriptor*)gf_odf_desc_new(GF_ODF_TX3G_TAG);\n\tsd->fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\tsd->font_count = 1;\n\tsd->fonts[0].fontID = 1;\n\tsd->fonts[0].fontName = gf_strdup(ctx->fontname ? ctx->fontname : \"Serif\");\n\tsd->back_color = 0x00000000;\t/*transparent*/\n\tsd->default_style.fontID = 1;\n\tsd->default_style.font_size = ctx->fontsize;\n\tsd->default_style.text_color = 0xFFFFFFFF;\t/*white*/\n\tsd->default_style.style_flags = 0;\n\tsd->horiz_justif = 1; /*center of scene*/\n\tsd->vert_justif = (s8) -1;\t/*bottom of scene*/\n\n\tif (ctx->nodefbox) {\n\t\tsd->default_pos.top = sd->default_pos.left = sd->default_pos.right = sd->default_pos.bottom = 0;\n\t} else if ((sd->default_pos.bottom==sd->default_pos.top) || (sd->default_pos.right==sd->default_pos.left)) {\n\t\tsd->default_pos.left = ctx->txtx;\n\t\tsd->default_pos.top = ctx->txty;\n\t\tsd->default_pos.right = ctx->width + sd->default_pos.left;\n\t\tsd->default_pos.bottom = ctx->height + sd->default_pos.top;\n\t}\n\n\t/*store attribs*/\n\tctx->style = sd->default_style;\n\tgf_odf_tx3g_write(sd, &dsi, &dsi_len);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA_NO_COPY(dsi, dsi_len) );\n\n\tgf_odf_desc_del((GF_Descriptor *)sd);\n\n\tctx->default_color = ctx->style.text_color;\n\tctx->samp = gf_isom_new_text_sample();\n\tctx->state = 0;\n\tctx->end = ctx->prev_end = ctx->start = 0;\n\tctx->first_samp = GF_TRUE;\n\tctx->curLine = 0;\n\n\ttxtin_probe_duration(ctx);\n\treturn GF_OK;\n}\n\nstatic void txtin_process_send_text_sample(GF_TXTIn *ctx, GF_TextSample *txt_samp, u64 ts, u32 duration, Bool is_rap)\n{\n\tGF_FilterPacket *dst_pck;\n\tu8 *pck_data;\n\tu32 size;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble end = (Double) (ts+duration);\n\t\tend /= 1000;\n\t\tif (end < ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\tsize = gf_isom_text_sample_size(txt_samp);\n\n\tdst_pck = gf_filter_pck_new_alloc(ctx->opid, size, &pck_data);\n\tif (!dst_pck) return;\n\n\tgf_bs_reassign_buffer(ctx->bs_w, pck_data, size);\n\tgf_isom_text_sample_write_bs(txt_samp, ctx->bs_w);\n\n\tts = gf_timestamp_rescale(ts, 1000, ctx->timescale);\n\tduration = (u32) gf_timestamp_rescale(duration, 1000, ctx->timescale);\n\n\tgf_filter_pck_set_sap(dst_pck, is_rap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\tgf_filter_pck_set_cts(dst_pck, ts);\n\tgf_filter_pck_set_duration(dst_pck, duration);\n\n\tgf_filter_pck_send(dst_pck);\n}\n\nstatic GF_Err txtin_process_srt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 i;\n\tu32 sh, sm, ss, sms, eh, em, es, ems, txt_line, char_len, char_line, j, rem_styles;\n\tBool set_start_char, set_end_char, rem_color;\n\tu32 line, len;\n\tchar szLine[2048], szText[2048], *ptr;\n\tunsigned short uniLine[5000], uniText[5000], *sptr;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\ttxt_line = 0;\n\tset_start_char = set_end_char = GF_FALSE;\n\tchar_len = 0;\n\n\tif (ctx->seek_state == 1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\twhile (1) {\n\t\tBool is_empty = GF_FALSE;\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\n\t\tif (sOK) {\n\t\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\t\tif (ctx->unicode_type<=1) is_empty = strlen(szLine) ? GF_FALSE : GF_TRUE;\n\t\t\telse is_empty =  (!szLine[0] && !szLine[1]) ? GF_TRUE : GF_FALSE;\n\t\t}\n\n\t\tif (!sOK || is_empty) {\n\t\t\tu32 utf_inc = (ctx->unicode_type<=1) ? 1 : 2;\n\t\t\tu32 nb_empty = utf_inc;\n\t\t\tu32 pos = (u32) gf_ftell(ctx->src);\n\t\t\tif (ctx->state) {\n\t\t\t\twhile (!gf_feof(ctx->src)) {\n\t\t\t\t\tsOK = gf_text_get_utf8_line(szLine+nb_empty, 2048-nb_empty, ctx->src, ctx->unicode_type);\n\t\t\t\t\tif (sOK) REM_TRAIL_MARKS((szLine+nb_empty), \"\\r\\n\\t \")\n\n\t\t\t\t\tif (!sOK) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if (!strlen(szLine+nb_empty)) {\n\t\t\t\t\t\tnb_empty+=utf_inc;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (\tsscanf(szLine+nb_empty, \"%u\", &line) == 1) {\n\t\t\t\t\t\tgf_fseek(ctx->src, pos, SEEK_SET);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 k;\n\t\t\t\t\t\tfor (k=0; k<nb_empty; k++) szLine[k] = '\\n';\n\t\t\t\t\t\tgoto force_line;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->style.text_color = 0xFFFFFFFF;\n\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\tif (txt_line) {\n\t\t\t\tif (ctx->prev_end && (ctx->start != ctx->prev_end) && (ctx->state<=2)) {\n\t\t\t\t\tGF_TextSample * empty_samp = gf_isom_new_text_sample();\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, empty_samp, ctx->prev_end, (u32) (ctx->start - ctx->prev_end), GF_TRUE );\n\t\t\t\t\tgf_isom_delete_text_sample(empty_samp);\n\t\t\t\t}\n\n\t\t\t\tif (ctx->state<=2) {\n\t\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp,  ctx->start, (u32) (ctx->end -  ctx->start), GF_TRUE);\n\t\t\t\t\tctx->prev_end = ctx->end;\n\t\t\t\t}\n\t\t\t\ttxt_line = 0;\n\t\t\t\tchar_len = 0;\n\t\t\t\tset_start_char = set_end_char = GF_FALSE;\n\t\t\t\tctx->style.startCharOffset = ctx->style.endCharOffset = 0;\n\t\t\t\tgf_isom_text_reset(ctx->samp);\n\n\t\t\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\t\t\t}\n\t\t\tctx->state = 0;\n\t\t\tif (!sOK) break;\n\t\t\tcontinue;\n\t\t}\n\nforce_line:\n\t\tswitch (ctx->state) {\n\t\tcase 0:\n\t\t\tif (sscanf(szLine, \"%u\", &line) != 1) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SRT formatting - expecting number got \\\"%s\\\"\\n\", szLine));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (line != ctx->curLine + 1) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Corrupted SRT frame %d after frame %d\\n\", line, ctx->curLine));\n\t\t\t}\n\t\t\tctx->curLine = line;\n\t\t\tctx->state = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (sscanf(szLine, \"%u:%u:%u,%u --> %u:%u:%u,%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\tif (sscanf(szLine, \"%u:%u:%u.%u --> %u:%u:%u.%u\", &sh, &sm, &ss, &sms, &eh, &em, &es, &ems) != 8) {\n\t\t\t\t\tsh = eh = 0;\n\t\t\t\t\tif (sscanf(szLine, \"%u:%u,%u --> %u:%u,%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\tif (sscanf(szLine, \"%u:%u.%u --> %u:%u.%u\", &sm, &ss, &sms, &em, &es, &ems) != 6) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Error scanning SRT frame %d timing\\n\", ctx->curLine));\n\t\t\t\t    \t\tctx->state = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tctx->start = (3600*sh + 60*sm + ss)*1000 + sms;\n\t\t\tif (ctx->start < ctx->end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d - starts \"LLD\" ms is before end of previous one \"LLD\" ms - adjusting time stamps\\n\", ctx->curLine, ctx->start, ctx->end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t}\n\n\t\t\tctx->end = (3600*eh + 60*em + es)*1000 + ems;\n\t\t\t/*make stream start at 0 by inserting a fake AU*/\n\t\t\tif (ctx->first_samp && (ctx->start > 0)) {\n\t\t\t\ttxtin_process_send_text_sample(ctx, ctx->samp, 0, (u32) ctx->start, GF_TRUE);\n\t\t\t}\n\t\t\tctx->style.style_flags = 0;\n\t\t\tctx->state = 2;\n\t\t\tif (ctx->end <= ctx->prev_end) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Overlapping SRT frame %d end \"LLD\" is at or before previous end \"LLD\" - removing\\n\", ctx->curLine, ctx->end, ctx->prev_end));\n\t\t\t\tctx->start = ctx->end;\n\t\t\t\tctx->state = 3;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t/*reset only when text is present*/\n\t\t\tctx->first_samp = GF_FALSE;\n\n\t\t\t/*go to line*/\n\t\t\tif (txt_line) {\n\t\t\t\tgf_isom_text_add_text(ctx->samp, \"\\n\", 1);\n\t\t\t\tchar_len += 1;\n\t\t\t}\n\n\t\t\tptr = (char *) szLine;\n\t\t\t{\n\t\t\t\tsize_t _len = gf_utf8_mbstowcs(uniLine, 5000, (const char **) &ptr);\n\t\t\t\tif (_len == (size_t) -1) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Invalid UTF data (line %d)\\n\", ctx->curLine));\n\t\t\t\t\tctx->state = 0;\n\t\t\t\t}\n\t\t\t\tlen = (u32) _len;\n\t\t\t}\n\t\t\ti=j=0;\n\t\t\trem_styles = 0;\n\t\t\trem_color = 0;\n\t\t\twhile (i<len) {\n\t\t\t\tu32 font_style = 0;\n\t\t\t\tu32 style_nb_chars = 0;\n\t\t\t\tu32 style_def_type = 0;\n\n\t\t\t\tif ( (uniLine[i]=='<') && (uniLine[i+2]=='>')) {\n\t\t\t\t\tstyle_nb_chars = 3;\n\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t}\n\t\t\t\telse if ( (uniLine[i]=='<') && (uniLine[i+1]=='/') && (uniLine[i+3]=='>')) {\n\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\tstyle_nb_chars = 4;\n\t\t\t\t}\n\t\t\t\telse if (uniLine[i]=='<')  {\n\t\t\t\t\tconst unsigned short* src = uniLine + i;\n\t\t\t\t\tsize_t alen = gf_utf8_wcstombs(szLine, 2048, (const unsigned short**) & src);\n\t\t\t\t\tszLine[alen] = 0;\n\t\t\t\t\tstrlwr(szLine);\n\t\t\t\t\tif (!strncmp(szLine, \"<font \", 6) ) {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \"color\");\n\t\t\t\t\t\tif (a_sep) a_sep = strchr(a_sep, '\"');\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tchar *e_sep = strchr(a_sep+1, '\"');\n\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\te_sep[0] = 0;\n\t\t\t\t\t\t\t\tfont_style = gf_color_parse(a_sep+1);\n\t\t\t\t\t\t\t\te_sep[0] = '\"';\n\t\t\t\t\t\t\t\te_sep = strchr(e_sep+1, '>');\n\t\t\t\t\t\t\t\tif (e_sep) {\n\t\t\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + e_sep - szLine);\n\t\t\t\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</font>\", 7) ) {\n\t\t\t\t\t\tstyle_nb_chars = 7;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\n\n\t\t\t\t\telse if (!strncmp(szLine, \"<strike>\", 8) ) {\n\t\t\t\t\t\tstyle_nb_chars = 8;\n\t\t\t\t\t\tstyle_def_type = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strncmp(szLine, \"</strike>\", 9) ) {\n\t\t\t\t\t\tstyle_nb_chars = 9;\n\t\t\t\t\t\tstyle_def_type = 2;\n\t\t\t\t\t\tfont_style = 0xFFFFFFFF;\n\t\t\t\t\t}\n\t\t\t\t\t//skip unknown\n\t\t\t\t\telse {\n\t\t\t\t\t\tchar *a_sep = strstr(szLine, \">\");\n\t\t\t\t\t\tif (a_sep) {\n\t\t\t\t\t\t\tstyle_nb_chars = (u32) (1 + a_sep - szLine);\n\t\t\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t/*start of new style*/\n\t\t\t\tif (style_def_type==1)  {\n\t\t\t\t\t/*store prev style*/\n\t\t\t\t\tif (set_end_char) {\n\t\t\t\t\t\tassert(set_start_char);\n\t\t\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t\t\tset_end_char = set_start_char = GF_FALSE;\n\t\t\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t\t\t\trem_styles = 0;\n\t\t\t\t\t\tif (rem_color) {\n\t\t\t\t\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\t\t\t\t\trem_color = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (set_start_char && (ctx->style.startCharOffset != j)) {\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tif (ctx->style.style_flags) gf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t\t}\n\t\t\t\t\tswitch (uniLine[i+1]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tctx->style.style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\tctx->style.text_color = font_style;\n\t\t\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ti += style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t/*end of prev style*/\n\t\t\t\tif (style_def_type==2)  {\n\t\t\t\t\tswitch (uniLine[i+2]) {\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'i':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'u':\n\t\t\t\t\tcase 'U':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 's':\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\trem_styles |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'f':\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tif (font_style) {\n\t\t\t\t\t\t\trem_color = 1;\n\t\t\t\t\t\t\tset_end_char = GF_TRUE;\n\t\t\t\t\t\t\tctx->style.endCharOffset = char_len + j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti+=style_nb_chars;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/*store style*/\n\t\t\t\tif (set_end_char) {\n\t\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t\t\trem_styles = 0;\n\t\t\t\t\tctx->style.text_color = ctx->default_color;\n\t\t\t\t\trem_color = 0;\n\t\t\t\t}\n\n\t\t\t\tuniText[j] = uniLine[i];\n\t\t\t\tj++;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\t/*store last style*/\n\t\t\tif (set_end_char) {\n\t\t\t\tgf_isom_text_add_style(ctx->samp, &ctx->style);\n\t\t\t\tset_end_char = GF_FALSE;\n\t\t\t\tset_start_char = GF_TRUE;\n\t\t\t\tctx->style.startCharOffset = char_len + j;\n\t\t\t\tctx->style.style_flags &= ~rem_styles;\n\t\t\t}\n\n\t\t\tchar_line = j;\n\t\t\tuniText[j] = 0;\n\n\t\t\tsptr = (u16 *) uniText;\n\t\t\tlen = (u32) gf_utf8_wcstombs(szText, 5000, (const u16 **) &sptr);\n\n\t\t\tgf_isom_text_add_text(ctx->samp, szText, len);\n\t\t\tchar_len += char_line;\n\t\t\ttxt_line ++;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\n\t/*final flush*/\t\n\tif (ctx->end && ! ctx->noflush) {\n\t\tgf_isom_text_reset(ctx->samp);\n\t\ttxtin_process_send_text_sample(ctx, ctx->samp, ctx->end, 0, GF_TRUE);\n\t\tctx->end = 0;\n\t}\n\tgf_isom_text_reset(ctx->samp);\n\n\treturn GF_EOS;\n}\n\n/* Structure used to pass importer and track data to the parsers without exposing the GF_MediaImporter structure\n   used by WebVTT and Flash->SVG */\ntypedef struct {\n\tGF_TXTIn *ctx;\n\tu32 timescale;\n\tu32 track;\n\tu32 descriptionIndex;\n} GF_ISOFlusher;\n\n#ifndef GPAC_DISABLE_VTT\n\nstatic GF_Err gf_webvtt_import_report(void *user, GF_Err e, char *message, const char *line)\n{\n\tGF_LOG(e ? GF_LOG_WARNING : GF_LOG_INFO, GF_LOG_AUTHOR, (\"[TXTIn] WebVTT line %s: %s\\n\", line, message) );\n\treturn e;\n}\n\nstatic void gf_webvtt_import_header(void *user, const char *config)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tif (!ctx->hdr_parsed) {\n\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *) config, (u32) (1+strlen(config)) ) );\n\t\tctx->hdr_parsed = GF_TRUE;\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\t}\n}\n\nstatic void gf_webvtt_flush_sample(void *user, GF_WebVTTSample *samp)\n{\n\tu64 start, end;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\tGF_ISOSample *s;\n\n\tstart = gf_webvtt_sample_get_start(samp);\n\tend = gf_webvtt_sample_get_end(samp);\n\n\tif (ctx->seek_state==2) {\n\t\tDouble tsend = (Double) end;\n\t\ttsend /= 1000;\n\t\tif (tsend<ctx->start_range) return;\n\t\tctx->seek_state = 0;\n\t}\n\n\ts = gf_isom_webvtt_to_sample(samp);\n\tif (s) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, s->dataLength, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, s->data, s->dataLength);\n\t\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale * start / 1000) );\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\n\t\t\tif (end && (end>=start) ) {\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) (ctx->timescale * (end-start) / 1000) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_isom_sample_del(&s);\n\t}\n\tgf_webvtt_sample_del(samp);\n\n\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tgf_webvtt_parser_suspend(ctx->vttparser);\n\n}\n\nstatic GF_Err txtin_webvtt_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, file_size, w, h;\n\tBool is_srt;\n\tchar *ext;\n\n\tctx->src = gf_fopen(ctx->file_name, \"rb\");\n\tif (!ctx->src) return GF_URL_ERROR;\n\n\tfile_size = (u32) gf_fsize(ctx->src);\n\n\tctx->unicode_type = gf_text_get_utf_type(ctx->src);\n\tif (ctx->unicode_type<0) {\n\t\tgf_fclose(ctx->src);\n\t\tctx->src = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Unsupported SRT UTF encoding\\n\"));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\text = gf_file_ext_start(ctx->file_name);\n\tis_srt = (ext && !strnicmp(ext, \".srt\", 4)) ? GF_TRUE : GF_FALSE;\n\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_WEBVTT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tw = ctx->width;\n\th = ctx->height;\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tctx->vttparser = gf_webvtt_parser_new();\n\n\te = gf_webvtt_parser_init(ctx->vttparser, ctx->src, ctx->unicode_type, is_srt, ctx, gf_webvtt_import_report, gf_webvtt_flush_sample, gf_webvtt_import_header);\n\tif (e != GF_OK) {\n\t\tgf_webvtt_parser_del(ctx->vttparser);\n\t\tctx->vttparser = NULL;\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT parser init error %s\\n\", gf_error_to_string(e) ));\n\t}\n\t//get the header\n\te = gf_webvtt_parser_parse(ctx->vttparser);\n\n\ttxtin_probe_duration(ctx);\n\treturn e;\n}\n\nstatic GF_Err txtin_process_webvtt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_webvtt_setup(filter, ctx);\n\t}\n\tif (!ctx->vttparser) return GF_NOT_SUPPORTED;\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_webvtt_parser_restart(ctx->vttparser);\n\t}\n\n\te = gf_webvtt_parser_parse(ctx->vttparser);\n\tif (e < GF_OK) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] WebVTT process error %s\\n\", gf_error_to_string(e) ));\n\t}\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_VTT*/\n\nstatic char *ttxt_parse_string(char *str, Bool strip_lines)\n{\n\tu32 i=0;\n\tu32 k=0;\n\tu32 len = (u32) strlen(str);\n\tu32 state = 0;\n\n\tif (!strip_lines) {\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif ((str[i] == '\\r') && (str[i+1] == '\\n')) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t\tstr[k]=0;\n\t\treturn str;\n\t}\n\n\tif (str[0]!='\\'') return str;\n\tfor (i=0; i<len; i++) {\n\t\tif (str[i] == '\\'') {\n\n\t\t\tif (!state) {\n\t\t\t\tif (k) {\n\t\t\t\t\tstr[k]='\\n';\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t\tstate = 1; //!state;\n\t\t\t} else {\n\t\t\t\tif ( (i+1==len) ||\n\t\t\t\t        ((str[i+1]==' ') || (str[i+1]=='\\n') || (str[i+1]=='\\r') || (str[i+1]=='\\t') || (str[i+1]=='\\''))\n\t\t\t\t   ) {\n\t\t\t\t\tstate = !state;\n\t\t\t\t} else {\n\t\t\t\t\tstr[k] = str[i];\n\t\t\t\t\tk++;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (state) {\n\t\t\tstr[k] = str[i];\n\t\t\tk++;\n\t\t}\n\t}\n\tstr[k]=0;\n\treturn str;\n}\n\nstatic void ebu_ttd_remove_samples(GF_XMLNode *root, GF_XMLNode **out_body_node)\n{\n\tu32 idx = 0;\n\tGF_XMLNode *node = NULL;\n\t*out_body_node = NULL;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &idx))) {\n\t\tif (!strcmp(node->name, \"body\")) {\n\t\t\tGF_XMLNode *body_node;\n\t\t\tu32 body_idx = 0;\n\t\t\t*out_body_node = node;\n\t\t\twhile ( (body_node = (GF_XMLNode*)gf_list_enum(node->content, &body_idx))) {\n\t\t\t\tif (!strcmp(body_node->name, \"div\")) {\n\t\t\t\t\tu32 body_num;\n\t\t\t\t\tbody_num = gf_list_count(body_node->content);\n\t\t\t\t\twhile (body_num--) {\n\t\t\t\t\t\tGF_XMLNode *content_node = (GF_XMLNode*)gf_list_get(body_node->content, 0);\n\t\t\t\t\t\tassert(gf_list_find(body_node->content, content_node) == 0);\n\t\t\t\t\t\tgf_list_rem(body_node->content, 0);\n\t\t\t\t\t\tgf_xml_dom_node_del(content_node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic s64 ttml_get_timestamp(GF_TXTIn *ctx, char *value)\n{\n\tu32 h, m, s, ms, f, sf;\n\ts64 ts = -1;\n\tu32 len = (u32) strlen(value);\n\n\t//tick metrick - cannot be fractional\n\tif (len && (value[len-1]=='t')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atoi(value) * 1000);\n\t\tvalue[len-1] = 't';\n\t\tif (ctx->tick_rate)\n\t\t\tts /= ctx->tick_rate;\n\t}\n\t//hours metric, can be fractional\n\telse if (len && (value[len-1]=='h')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 3600);\n\t\tvalue[len-1] = 'h';\n\t}\n\t//minutes metric, can be fractional\n\telse if (len && (value[len-1]=='m')) {\n\t\tvalue[len-1] = 0;\n\t\tts = (s64) (atof(value) * 1000 * 60);\n\t\tvalue[len-1] = 'm';\n\t}\n\telse if (len && (value[len-1]=='s')) {\n\t\t//milliseconds metric, can be fractional but we work at 1ms clock resolution anyway\n\t\tif ((len > 1) && (value[len-2]=='m')) {\n\t\t\tvalue[len-2] = 0;\n\t\t\tts = (s64) (atof(value));\n\t\t\tvalue[len-2] = 'm';\n\t\t}\n\t\t//seconds metric, can be fractional\n\t\telse {\n\t\t\tvalue[len-1] = 0;\n\t\t\tts = (s64) (atof(value) * 1000);\n\t\t\tvalue[len-1] = 's';\n\t\t}\n\t}\n\t//frames metric, can be fractional\n\telse if (len && (value[len-1]=='f')) {\n\t\tf = sf = 0;\n\t\tvalue[len-1] = 0;\n\t\tif (sscanf(value, \"%u.%u\", &f, &sf) != 2) {\n\t\t\tsscanf(value, \"%u\", &f);\n\t\t\tsf = 0;\n\t\t}\n\t\tvalue[len-1] = 'f';\n\n\t\tif (!ctx->ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\tctx->ttml_fps_num = 25;\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\tif (sf && !ctx->ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\tctx->ttml_sfps = 1;\n\t\t}\n\t\tts = ((s64) 1000 * f * ctx->ttml_fps_den) / ctx->ttml_fps_num;\n\t\tif (sf)\n\t\t\tts += ((s64) 1000 * sf * ctx->ttml_fps_den / ctx->ttml_sfps) / ctx->ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000+ms;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u.%u\", &h, &m, &s, &f, &sf) == 5) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (!ctx->ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\tctx->ttml_fps_num = 25;\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\tif (!ctx->ttml_sfps) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates subframes but no subFrameRate set, assuming 1\\n\"));\n\t\t\tctx->ttml_sfps = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * ctx->ttml_fps_den) / ctx->ttml_fps_num;\n\t\tts += ((s64) 1000 * sf * ctx->ttml_fps_den / ctx->ttml_sfps) / ctx->ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u:%u\", &h, &m, &s, &f) == 4) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t\tif (!ctx->ttml_fps_num) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] time indicates frames but no frame rate set, assuming 25 FPS\\n\"));\n\t\t\tctx->ttml_fps_num = 25;\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\tts += ((s64) 1000 * f * ctx->ttml_fps_den) / ctx->ttml_fps_num;\n\t}\n\telse if (sscanf(value, \"%u:%u:%u\", &h, &m, &s) == 3) {\n\t\tts = (h*3600 + m*60+s)*1000;\n\t}\n\treturn ts;\n}\n\nstatic GF_Err ttml_push_interval(GF_TXTIn *ctx, s64 begin, s64 end, TTMLInterval **out_interval)\n{\n\tu32 i;\n\tTTMLInterval *interval;\n\tif (begin==-1) return GF_OK;\n\tif (end==-1) return GF_OK;\n\n\tif (end < begin) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] invalid timings: \\\"begin\\\"=\"LLD\" , \\\"end\\\"=\"LLD\". Abort.\\n\", begin, end));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tinterval = NULL;\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tinterval = gf_list_get(ctx->intervals, i);\n\n\t\t//generate a single sample for the input, merge interval\n\t\tif (ctx->ttml_dur>=0) {\n\t\t\tif (interval->begin > begin) interval->begin = begin;\n\t\t\tif (interval->end < end) interval->end = end;\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//contained, do nothing\n\t\tif ((begin>=interval->begin) && (end<=interval->end)) {\n\t\t\t*out_interval = interval;\n\t\t\treturn GF_OK;\n\t\t}\n\t\t//not overlapping\n\t\tif ((end < interval->begin) || (begin > interval->end))\n\t\t\tcontinue;\n\n\t\t//new interval starts before current and end after, remove current and push extended interval\n\t\tif ((begin < interval->end) && (end > interval->end)) {\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t\t//new interval starts before current and end before, remove current and push rewinded\n\t\tif ((begin < interval->end) && (end <= interval->end)) {\n\t\t\tend = interval->end;\n\t\t\tif (begin>interval->begin)\n\t\t\t\tbegin = interval->begin;\n\t\t\tgf_list_rem(ctx->intervals, i);\n\t\t\tgf_free(interval);\n\t\t\treturn ttml_push_interval(ctx, begin, end, out_interval);\n\t\t}\n\t}\n\t//need a new interval\n\tGF_SAFEALLOC(interval, TTMLInterval);\n\tinterval->begin = begin;\n\tinterval->end = end;\n\t*out_interval = interval;\n\n\tfor (i=0; i<gf_list_count(ctx->intervals); i++) {\n\t\tTTMLInterval *an_interval = gf_list_get(ctx->intervals, i);\n\t\tif (an_interval->begin > interval->begin) {\n\t\t\treturn gf_list_insert(ctx->intervals, interval, i);\n\t\t}\n\t}\n\treturn gf_list_add(ctx->intervals, interval);\n}\n\nstatic void ttml_reset_intervals(GF_TXTIn *ctx)\n{\n\twhile (gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *ival = gf_list_pop_back(ctx->intervals);\n\t\tif (ival->resources) {\n\t\t\twhile (gf_list_count(ival->resources)) {\n\t\t\t\tTTMLRes *ires = gf_list_pop_back(ival->resources);\n\t\t\t\tif (!ires->global) {\n\t\t\t\t\tgf_free(ires->data);\n\t\t\t\t\tgf_free(ires);\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_del(ival->resources);\n\t\t}\n\t\tgf_free(ival);\n\t}\n}\n\n#include <gpac/base_coding.h>\n\nstatic GF_Err ttml_push_res(GF_TXTIn *ctx, TTMLInterval *interval, u8 *f_data, u32 f_size)\n{\n\tGF_Err e;\n\tTTMLRes *res;\n\tGF_List *res_list;\n\tif (interval) {\n\t\tif (!interval->resources) {\n\t\t\tif (ctx->ttml_resources)\n\t\t\t\tinterval->resources = gf_list_clone(ctx->ttml_resources);\n\t\t\telse\n\t\t\t\tinterval->resources = gf_list_new();\n\t\t}\n\t\tres_list = interval->resources;\n\t} else {\n\t\tif (!ctx->ttml_resources) {\n\t\t\tctx->ttml_resources = gf_list_new();\n\t\t}\n\t\tres_list = ctx->ttml_resources;\n\t}\n\tif (!res_list) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tGF_SAFEALLOC(res, TTMLRes)\n\tif (!res) {\n\t\tgf_free(f_data);\n\t\treturn GF_OUT_OF_MEM;\n\t}\n\tres->size = f_size;\n\tres->data = f_data;\n\tif (!interval)\n\t\tres->global = GF_TRUE;\n\n\te = gf_list_add(res_list, res);\n\tif (e) {\n\t\tgf_free(res);\n\t\tgf_free(f_data);\n\t\treturn e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_push_resources(GF_TXTIn *ctx, TTMLInterval *interval, GF_XMLNode *node, GF_XMLNode *parent_source_node)\n{\n\tu32 i;\n\tchar szURN[1024];\n\tu8 *f_data;\n\tu32 f_size;\n\tu32 idx;\n\tGF_Err e;\n\tGF_XMLAttribute *att, *data_type = NULL;\n\tGF_XMLNode *child;\n\tBool is_source = GF_FALSE;\n\tBool is_data = GF_FALSE;\n\tBool check_src = GF_FALSE;\n\n\tif (!ctx->ttml_embed)\n\t\treturn GF_OK;\n\n\tif (!strcmp(node->name, \"source\")) {\n\t\tis_source = GF_TRUE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\telse if (!strcmp(node->name, \"data\")) {\n\t\tis_data = parent_source_node ? GF_TRUE : GF_FALSE;\n\t\tcheck_src = GF_TRUE;\n\t}\n\t//we don't embed chunks\n\telse if (!strcmp(node->name, \"chunk\")) {\n\t\treturn GF_OK;\n\t}\n\telse if (!strcmp(node->name, \"audio\") || !strcmp(node->name, \"font\") || !strcmp(node->name, \"image\")) {\n\t\tcheck_src = GF_TRUE;\n\t}\n\n\tif (check_src) {\n\t\ti = 0;\n\t\twhile ( (att = (GF_XMLAttribute*)gf_list_enum(node->attributes, &i))) {\n\t\t\tchar *url;\n\t\t\tif (!att->value) continue;\n\t\t\tif (is_data && !strcmp(att->name, \"type\")) {\n\t\t\t\tdata_type = att;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(att->name, \"src\")) continue;\n\t\t\tif (att->value[0]=='#') continue;\n\n\t\t\tif (!strncmp(att->value, \"file://\", 7)) {}\n\t\t\telse if (strstr(att->value, \"://\"))\n\t\t\t\tcontinue;\n\n\t\t\turl = gf_url_concatenate(ctx->file_name, att->value);\n\t\t\t//embed image\n\t\t\te = gf_file_load_data(url, &f_data, &f_size);\n\t\t\tgf_free(url);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tgf_free(att->value);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\t\t\tatt->value = gf_strdup(szURN);\n\t\t\tif (!att->value) return GF_OUT_OF_MEM;\n\n\t\t\tctx->has_images = GF_TRUE;\n\t\t}\n\t}\n\n\ti = 0;\n\twhile ( (child = (GF_XMLNode*) gf_list_enum(node->content, &i))) {\n\t\tif (child->type) {\n\t\t\tif (!is_data) continue;\n\t\t\tu8 *data = child->name;\n\t\t\tu32 ilen = (u32) strlen(data);\n\t\t\tf_size = 3*ilen/4;\n\t\t\tf_data = gf_malloc(sizeof(u8) * f_size);\n\n\t\t\tf_size = gf_base64_decode(data, ilen, f_data, f_size);\n\n\t\t\te = ttml_push_res(ctx, interval, f_data, f_size);\n\t\t\tif (e) return e;\n\n\t\t\tidx = gf_list_count(interval ? interval->resources : ctx->ttml_resources);\n\t\t\tsprintf(szURN, \"urn:mpeg:14496-30:%d\", idx);\n\n\t\t\tGF_SAFEALLOC(att, GF_XMLAttribute)\n\t\t\tif (att) {\n\t\t\t\tatt->name = gf_strdup(\"src\");\n\t\t\t\tatt->value = gf_strdup(szURN);\n\t\t\t\tgf_list_add(parent_source_node->attributes, att);\n\t\t\t}\n\t\t\tif (!att || !att->value || !att->name) return GF_OUT_OF_MEM;\n\t\t\tif (data_type) {\n\t\t\t\tgf_list_del_item(node->attributes, data_type);\n\t\t\t\tgf_list_add(parent_source_node->attributes, data_type);\n\t\t\t}\n\t\t\tgf_xml_dom_node_reset(parent_source_node, GF_FALSE, GF_TRUE);\n\t\t\tctx->has_images = GF_TRUE;\n\t\t\treturn GF_OK;\n\t\t}\n\n\t\te = ttml_push_resources(ctx, interval, child, is_source ? node : NULL);\n\t\tif (e) return e;\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_rewrite_timestamp(GF_TXTIn *ctx, s64 ttml_zero, GF_XMLAttribute *att, s64 *value, Bool *drop)\n{\n\tu64 v;\n\tchar szTS[21];\n\tu32 h, m, s, ms;\n\t*value = ttml_get_timestamp(ctx, att->value);\n\tif (!ttml_zero)\n\t\treturn GF_OK;\n\n\tif (*value < ttml_zero) {\n\t\t*drop = GF_TRUE;\n\t\treturn GF_OK;\n\t}\n\n\t*value -= ttml_zero;\n\tv = (u64) (*value / 1000);\n\th = (u32) (v / 3600);\n\tm = (u32) (v - h*60) / 60;\n\ts = (u32) (v - h*3600 - m*60);\n\tms = (*value) % 1000;\n\n\tsnprintf(szTS, 20, \"%02d:%02d:%02d.%03d\", h, m, s, ms);\n\tszTS[20] = 0;\n\tgf_free(att->value);\n\tatt->value = gf_strdup(szTS);\n\treturn GF_OK;\n}\n\nstatic GF_Err ttml_setup_intervals(GF_TXTIn *ctx)\n{\n\tu32 k, i, nb_divs;\n\ts64 ttml_zero_ms = 0;\n\tGF_Err e;\n\tGF_XMLNode *root;\n\n\tif (!ctx->intervals)\n\t\tctx->intervals = gf_list_new();\n\telse\n\t\tttml_reset_intervals(ctx);\n\n\tctx->has_images = GF_FALSE;\n\troot = ctx->root_working_copy;\n\tfor (k=0; k<gf_list_count(root->content); k++) {\n\t\tGF_XMLNode *head = (GF_XMLNode*)gf_list_get(root->content, k);\n\t\tif (head->type) continue;\n\t\tif (strcmp(head->name, \"head\")) continue;\n\t\tttml_push_resources(ctx, NULL, head, NULL);\n\t\tbreak;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (ctx->ttml_zero) {\n\t\tif (ctx->ttml_zero[0]=='T')\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero+1);\n\t\telse\n\t\t\tttml_zero_ms = ttml_get_timestamp(ctx, (char *) ctx->ttml_zero);\n\t}\n\n\tnb_divs = gf_list_count(ctx->div_nodes_list);\n\tfor (i=0; i<nb_divs; i++) {\n\t\tu32 nb_children;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, i);\n\t\tnb_children = gf_list_count(div_node->content);\n\n\t\tfor (k=0; k<nb_children; k++) {\n\t\t\tTTMLInterval *ival=NULL;\n\t\t\tu32 p_idx;\n\t\t\tBool drop = GF_FALSE;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tGF_XMLNode *p_node;\n\t\t\ts64 begin=-1, end=-1;\n\t\t\tGF_XMLNode *adiv_child = (GF_XMLNode*)gf_list_get(div_node->content, k);\n\t\t\tif (adiv_child->type) continue;\n\t\t\te = gf_xml_get_element_check_namespace(adiv_child, \"p\", root->ns);\n\t\t\tif (e) continue;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(adiv_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &begin, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, p_att, &end, &drop);\n\t\t\t\t\tif (e) return e;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (drop) {\n\t\t\t\tgf_xml_dom_node_del(adiv_child);\n\t\t\t\tgf_list_rem(div_node->content, k);\n\t\t\t\tk--;\n\t\t\t\tnb_children--;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\te = ttml_push_interval(ctx, begin, end, &ival);\n\t\t\tif (e) return e;\n\n\t\t\te = ttml_push_resources(ctx, ival, adiv_child, NULL);\n\t\t\tif (e) return e;\n\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(adiv_child->content, &p_idx))) {\n\t\t\t\ts64 s_begin=-1, s_end=-1;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e) continue;\n\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_begin, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\te = ttml_rewrite_timestamp(ctx, ttml_zero_ms, span_att, &s_end, &drop);\n\t\t\t\t\t\tif (e) return e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\te = ttml_push_interval(ctx, s_begin, s_end, &ival);\n\t\t\t\tif (e) return e;\n\n\t\t\t\te = ttml_push_resources(ctx, ival, p_node, NULL);\n\t\t\t\tif (e) return e;\n\t\t\t}\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!gf_list_count(ctx->intervals)) {\n\t\tTTMLInterval *interval;\n\t\tGF_SAFEALLOC(interval, TTMLInterval);\n\t\tinterval->begin = interval->end = 0;\n\t\tgf_list_add(ctx->intervals, interval);\n\t}\n\n#ifndef GPAC_DISABLE_LOG\n\tif (gf_log_tool_level_on(GF_LOG_PARSER, GF_LOG_DEBUG)) {\n\t\tfor (k=0; k<gf_list_count(ctx->intervals); k++) {\n\t\t\tTTMLInterval *ival = gf_list_get(ctx->intervals, k);\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] Interval %d: \"LLU\"-\"LLU\"\\n\", k+1, ival->begin, ival->end));\n\t\t}\n\t}\n#endif\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_ttml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 i, nb_children, ID;\n\tu64 file_size;\n\ts32 sub_fps_num, sub_fps_den;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root, *node, *body_node;\n\tconst char *lang = ctx->lang;\n\n\n\tctx->is_setup = GF_TRUE;\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: Line %d - %s. Abort.\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tctx->is_setup = GF_TRUE;\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\tif (!root) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTML file: no root XML element found. Abort.\\n\"));\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*look for TTML*/\n\tif (gf_xml_get_element_check_namespace(root, \"tt\", NULL) != GF_OK) {\n\t\tif (root->ns) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s:%s\\\" (check your namespaces)\\n\", root->ns, root->name));\n\t\t} else {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"TTML file not recognized: root element is \\\"%s\\\"\\n\", root->name));\n\t\t}\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TXTIn] TTML EBU-TTD detected\\n\"));\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\n\t/*** root (including language) ***/\n\tsub_fps_num = 0;\n\tsub_fps_den = 0;\n\ti=0;\n\twhile ( (att = (GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tconst char *att_name;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML] Found root attribute name %s, value %s\\n\", att->name, att->value));\n\n\t\tatt_name = strchr(att->name, ':');\n\t\tif (att_name) att_name++;\n\t\telse att_name = att->name;\n\n\t\tif (!strcmp(att->name, \"xmlns\")) {\n\t\t\tif (strcmp(att->value, TTML_NAMESPACE)) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML] XML Namespace %s not recognized, expecting %s\\n\", att->name, att->value, TTML_NAMESPACE));\n\t\t\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att->name, \"xml:lang\") && att->value && strlen(att->value)) {\n\t\t\tlang = att->value;\n\t\t}\n\t\telse if (!strcmp(att_name, \"tickRate\") && att->value) {\n\t\t\tctx->tick_rate = atoi(att->value);\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRate\") && att->value) {\n\t\t\tctx->ttml_fps_num = atoi(att->value);\n\t\t\tctx->ttml_fps_den = 1;\n\t\t}\n\t\telse if (!strcmp(att_name, \"frameRateMultiplier\") && att->value) {\n\t\t\tchar *sep = strchr(att->value, ' ');\n\t\t\tif (!sep) sep = strchr(att->value, '\\t');\n\t\t\tif (sep) {\n\t\t\t\tu8 c = sep[0];\n\t\t\t\tsep[0] = 0;\n\t\t\t\tsub_fps_num = atoi(sep);\n\t\t\t\tsep[0] = c;\n\t\t\t\twhile ((sep[0]==' ') || (sep[0]=='\\t'))\n\t\t\t\t\tsep++;\n\t\t\t\tsub_fps_den = atoi(sep);\n\t\t\t}\n\t\t}\n\t\telse if (!strcmp(att_name, \"subFrameRate\") && att->value) {\n\t\t\tctx->ttml_sfps = atoi(att->value);\n\t\t}\n\t}\n\n\tif (sub_fps_num && sub_fps_den && ctx->ttml_fps_num) {\n\t\tctx->ttml_fps_num *= sub_fps_num;\n\t\tctx->ttml_fps_den = sub_fps_den;\n\t}\n\n\t//locate body\n\tnb_children = gf_list_count(root->content);\n\tbody_node = NULL;\n\n\ti=0;\n\twhile ( (node = (GF_XMLNode*)gf_list_enum(root->content, &i))) {\n\t\tif (node->type) {\n\t\t\tnb_children--;\n\t\t\tcontinue;\n\t\t}\n\t\te = gf_xml_get_element_check_namespace(node, \"body\", root->ns);\n\t\tif (e == GF_BAD_PARAM) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t} else if (e == GF_OK) {\n\t\t\tif (body_node) {\n\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"body\\\" element. Abort.\\n\"));\n\t\t\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t}\n\t\t\tbody_node = node;\n\t\t}\n\t}\n\tif (!body_node) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] \\\"body\\\" element not found, assuming empty doc\\n\"));\n\t}\n\n\tif (!ctx->div_nodes_list) {\n\t\tctx->div_nodes_list = gf_list_new();\n\t\tif (!ctx->div_nodes_list) return GF_OUT_OF_MEM;\n\t} else {\n\t\tgf_list_reset(ctx->div_nodes_list);\n\t}\n\n\tif (body_node) {\n\t\ti=0;\n\t\twhile ( (node = (GF_XMLNode*)gf_list_enum(body_node->content, &i))) {\n\t\t\tif (!node->type) {\n\t\t\t\te = gf_xml_get_element_check_namespace(node, \"div\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", node->name));\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_list_add(ctx->div_nodes_list, node);\n\t\t}\n\t}\n\tfile_size = ctx->end;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SUBS_XML) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( lang) );\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:xmlns\", &PROP_STRING(TTML_NAMESPACE) );\n\n\t/*** body ***/\n\tctx->parser_working_copy = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser_working_copy, ctx->file_name, NULL, NULL);\n\tassert (e == GF_OK);\n\tctx->root_working_copy = gf_xml_dom_get_root(ctx->parser_working_copy);\n\tassert(ctx->root_working_copy);\n\n\tif (body_node) {\n\t\t/*remove all the sample entries (instances in body) entries from the working copy, we will add each sample in this clone DOM  to create full XML of each sample*/\n\t\tebu_ttd_remove_samples(ctx->root_working_copy, &ctx->body_node);\n\t\tif (!ctx->body_node) {\n\t\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t}\n\t} else {\n\t\tctx->body_node = NULL;\n\t}\n\n\tctx->current_tt_interval = 0;\n\n\tctx->last_sample_duration = 0;\n\tctx->end = 0;\n\tctx->first_samp = GF_TRUE;\n\n\ttxtin_probe_duration(ctx);\n\n\te = ttml_setup_intervals(ctx);\n\tif (e) return e;\n\n\tif (ctx->has_images) {\n\t\tchar *mime_cfg = \"application/ttml+xml;codecs=im1i\";\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(mime_cfg) );\n\t} else {\n\t\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", NULL);\n\t}\n\treturn GF_OK;\n}\n\nstatic Bool ttml_check_range(TTMLInterval *interval, s64 ts_begin, s64 ts_end)\n{\n\t//if in current interval, push node\n\tif ((ts_begin != -1) && (ts_end != -1) && ((ts_begin>=interval->begin) && (ts_end<=interval->end))\n\t) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin not set, end set: in range if end less than interval end range\n\telse if ((ts_begin==-1) && (ts_end != -1) && (ts_end<=interval->end)) {\n\t\treturn GF_TRUE;\n\t}\n\t//begin set, end not set: in range if begin greater than interval begin range\n\telse if ((ts_begin!=-1) && (ts_end==-1) && (ts_begin>=interval->begin)) {\n\t\treturn GF_TRUE;\n\t}\n\treturn GF_FALSE;\n}\n\nstatic GF_Err gf_text_process_ttml(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tGF_XMLNode *root;\n\tu32 i, nb_res_interval=0, k, nb_div_nodes;\n\tchar *samp_text=NULL;\n\tGF_List *emb_resources = NULL;\n\tTTMLInterval *interval;\n\tBool sample_empty = GF_TRUE;\n\n\tif (!ctx->is_setup) return gf_text_ttml_setup(filter, ctx);\n\tif (ctx->non_compliant_ttml || !ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->current_tt_interval = 0;\n\t}\n\n\tinterval = gf_list_get(ctx->intervals, ctx->current_tt_interval);\n\tif (!interval) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"[TTML EBU-TTD] last_sample_duration=\"LLU\", last_sample_end=\"LLU\"\\n\", ctx->last_sample_duration, ctx->end));\n\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t\tgf_filter_pid_set_eos(ctx->opid);\n\t\treturn GF_EOS;\n\t}\n\tctx->current_tt_interval++;\n\n\temb_resources = interval->resources ? interval->resources : ctx->ttml_resources;\n\tnb_res_interval = gf_list_count(emb_resources);\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tnb_div_nodes = gf_list_count(ctx->div_nodes_list);\n\tfor (k=0; k<nb_div_nodes; k++) {\n\t\tBool has_content = GF_FALSE;\n\t\tGF_XMLNode *div_node = gf_list_get(ctx->div_nodes_list, k);\n\t\tu32 nb_children = gf_list_count(div_node->content);\n\n\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\n\t\tfor (i=0; i < nb_children; i++) {\n\t\t\tGF_XMLNode *p_node;\n\t\t\tGF_XMLAttribute *p_att;\n\t\t\tu32 p_idx = 0;\n\t\t\ts64 ts_begin = -1, ts_end = -1;\n\t\t\tBool in_range;\n\t\t\tGF_XMLNode *div_child = (GF_XMLNode*)gf_list_get(div_node->content, i);\n\t\t\tif (div_child->type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\te = gf_xml_get_element_check_namespace(div_child, \"p\", root->ns);\n\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", div_child->name));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\n\t\t\t//sample is either in the <p> ...\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_att = (GF_XMLAttribute*)gf_list_enum(div_child->attributes, &p_idx))) {\n\t\t\t\tif (!strcmp(p_att->name, \"begin\")) {\n\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t} else if (!strcmp(p_att->name, \"end\")) {\n\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute. Abort.\\n\"));\n\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t\tts_end = ttml_get_timestamp(ctx, p_att->value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\tif (in_range) {\n\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t}\n\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\tassert(e == GF_OK);\n\t\t\t\thas_content = GF_TRUE;\n\t\t\t}\n\n\t\t\t//or under a <span>\n\t\t\tp_idx = 0;\n\t\t\twhile ( (p_node = (GF_XMLNode*)gf_list_enum(div_child->content, &p_idx))) {\n\t\t\t\tu32 span_idx = 0;\n\t\t\t\tGF_XMLAttribute *span_att;\n\t\t\t\te = gf_xml_get_element_check_namespace(p_node, \"span\", root->ns);\n\t\t\t\tif (e == GF_BAD_PARAM) {\n\t\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] ignored \\\"%s\\\" node, check your namespaces\\n\", p_node->name));\n\t\t\t\t}\n\t\t\t\telse if (e)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tts_begin = ts_end = -1;\n\t\t\t\twhile ( (span_att = (GF_XMLAttribute*)gf_list_enum(p_node->attributes, &span_idx))) {\n\t\t\t\t\tif (!strcmp(span_att->name, \"begin\")) {\n\t\t\t\t\t\tif (ts_begin != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"begin\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_begin = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t} else if (!strcmp(span_att->name, \"end\")) {\n\t\t\t\t\t\tif (ts_end != -1) {\n\t\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] duplicated \\\"end\\\" attribute under <span>. Abort.\\n\"));\n\t\t\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tts_end = ttml_get_timestamp(ctx, span_att->value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*append the entire <p> and break (we cannot split the text content)*/\n\t\t\t\tin_range = ttml_check_range(interval, ts_begin, ts_end);\n\t\t\t\tif (in_range) {\n\t\t\t\t\tGF_XMLNode *prev_child = i ? (GF_XMLNode*) gf_list_get(div_node->content, i-1) : NULL;\n\t\t\t\t\tif (prev_child && prev_child->type) {\n\t\t\t\t\t\tgf_xml_dom_append_child(copy_div_node, prev_child);\n\t\t\t\t\t}\n\t\t\t\t\te = gf_xml_dom_append_child(copy_div_node, div_child);\n\t\t\t\t\tassert(e == GF_OK);\n\t\t\t\t\thas_content = GF_TRUE;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (has_content) {\n\t\t\tGF_XMLNode *last_child = (GF_XMLNode*) gf_list_last(div_node->content);\n\t\t\tif (last_child && last_child->type) {\n\t\t\t\tgf_xml_dom_append_child(copy_div_node, last_child);\n\t\t\t}\n\t\t\tsample_empty = GF_FALSE;\n\t\t}\n\t}\n\n\t//empty doc\n\tif (!ctx->body_node)\n\t\tsample_empty = GF_FALSE;\n\n\tif (! sample_empty) {\n\t\tsamp_text = gf_xml_dom_serialize_root((GF_XMLNode*)ctx->root_working_copy, GF_FALSE, GF_FALSE);\n\n\t\tfor (k=0; k<nb_div_nodes; k++) {\n\t\t\tGF_XMLNode *copy_div_node = gf_list_get(ctx->body_node->content, k);\n\t\t\tif (!copy_div_node->type)\n\t\t\t\tgf_list_reset(copy_div_node->content);\n\t\t}\n\t}\n\n\tif (samp_text) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tBool skip_pck = GF_FALSE;\n\t\tu32 txt_len;\n\t\tu32 res_len = 0;\n\t\tchar *txt_str;\n\n\n\t\tif (interval->begin < (s64) ctx->end) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TTML EBU-TTD] Error computing overlapped intervals! \\\"begin\\\" is \"LLD\" , last \\\"end\\\" was \"LLD\". Abort.\\n\", interval->begin, ctx->end));\n\t\t\te = GF_NOT_SUPPORTED;\n\t\t\tgoto exit;\n\t\t}\n\n\t\ttxt_str = ttxt_parse_string(samp_text, GF_TRUE);\n\t\tif (!txt_str) txt_str = \"\";\n\t\ttxt_len = (u32) strlen(txt_str);\n\n\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\tres_len += res->size;\n\t\t}\n\n\t\tif (ctx->first_samp) {\n\t\t\tinterval->begin = 0; /*in MP4 we must start at T=0*/\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t}\n\n\t\tctx->last_sample_duration = interval->end - interval->begin;\n\n\t\tctx->end = interval->end;\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_PARSER, (\"ts_begin=\"LLD\", ts_end=\"LLD\", last_sample_duration=\"LLU\" (real duration: \"LLU\"), last_sample_end=\"LLU\"\\n\", interval->begin, interval->end, interval->end - ctx->end, ctx->last_sample_duration, ctx->end));\n\n\t\tif (ctx->seek_state==2) {\n\t\t\tDouble end = (Double) interval->end;\n\t\t\tend /= ctx->timescale;\n\t\t\tif (end<ctx->start_range) skip_pck = GF_TRUE;\n\t\t\telse ctx->seek_state = 0;\n\t\t}\n\n\t\tif (!skip_pck) {\n\t\t\tpck = gf_filter_pck_new_alloc(ctx->opid, txt_len+res_len, &pck_data);\n\t\t\tif (!pck) {\n\t\t\t\tgf_free(samp_text);\n\t\t\t\treturn GF_OUT_OF_MEM;\n\t\t\t}\n\t\t\tmemcpy(pck_data, txt_str, txt_len);\n\t\t\tgf_filter_pck_set_sap(pck, GF_FILTER_SAP_1);\n\n\t\t\tif (ctx->ttml_dur>0) {\n\t\t\t\tgf_filter_pck_set_cts(pck, 0);\n\t\t\t\tgf_filter_pck_set_duration(pck, (u32) ctx->ttml_dur);\n\t\t\t\tctx->last_sample_duration = (u64) ctx->ttml_dur * 1000 / ctx->timescale;\n\t\t\t} else {\n\t\t\t\tgf_filter_pck_set_cts(pck, (ctx->timescale * interval->begin)/1000);\n\t\t\t\tif (interval->end >= interval->begin) {\n\t\t\t\t\tgf_filter_pck_set_duration(pck, (u32) ((ctx->timescale * (interval->end - interval->begin) )/1000) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res_len) {\n\t\t\t\tGF_BitStream *subs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);\n\t\t\t\tu8 *subs_data;\n\t\t\t\tu32 subs_size;\n\t\t\t\t//subs 0\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u32(subs, txt_len);\n\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\tgf_bs_write_u8(subs, 0);\n\n\t\t\t\tpck_data += txt_len;\n\t\t\t\tfor (i=0; i<nb_res_interval; i++) {\n\t\t\t\t\tTTMLRes *res = gf_list_get(emb_resources, i);\n\t\t\t\t\tmemcpy(pck_data, res->data, res->size);\n\t\t\t\t\tpck_data += res->size;\n\n\t\t\t\t\t//subs >0\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u32(subs, res->size);\n\t\t\t\t\tgf_bs_write_u32(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t\tgf_bs_write_u8(subs, 0);\n\t\t\t\t}\n\t\t\t\tgf_bs_get_content(subs, &subs_data, &subs_size);\n\t\t\t\tgf_bs_del(subs);\n\t\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PCK_SUBS, &PROP_DATA_NO_COPY(subs_data, subs_size) );\n\t\t\t}\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\n\t\tgf_free(samp_text);\n\t\tsamp_text = NULL;\n\t} else {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TTML EBU-TTD] empty sample (begin=\"LLD\", end=\"LLD\"). Skip.\\n\", interval->begin, interval->end));\n\t}\n\n\treturn GF_OK;\n\n\nexit:\n\tif (!ctx->non_compliant_ttml) {\n\t\tctx->non_compliant_ttml = GF_TRUE;\n\t\tgf_filter_pid_set_discard(ctx->ipid, GF_TRUE);\n\t}\n\treturn e;\n}\n\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\nstatic GF_Err swf_svg_add_iso_sample(void *user, const u8 *data, u32 length, u64 timestamp, Bool isRap)\n{\n\tGF_FilterPacket *pck;\n\tu8 *pck_data;\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (ctx->seek_state==2) {\n\t\tDouble ts = (Double) timestamp;\n\t\tts/=1000;\n\t\tif (ts<ctx->start_range) return GF_OK;\n\t\tctx->seek_state = 0;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\tif (pck) {\n\t\tmemcpy(pck_data, data, length);\n\t\tgf_filter_pck_set_cts(pck, (u64) (ctx->timescale*timestamp/1000) );\n\t\tgf_filter_pck_set_sap(pck, isRap ? GF_FILTER_SAP_1 : GF_FILTER_SAP_NONE);\n\t\tgf_filter_pck_set_framing(pck, GF_TRUE, GF_FALSE);\n\n\t\tgf_filter_pck_send(pck);\n\t}\n\n\tif (gf_filter_pid_would_block(ctx->opid))\n\t\tctx->do_suspend = GF_TRUE;\n\treturn GF_OK;\n}\n\nstatic GF_Err swf_svg_add_iso_header(void *user, const u8 *data, u32 length, Bool isHeader)\n{\n\tGF_TXTIn *ctx = (GF_TXTIn *)user;\n\n\tif (isHeader) {\n\t\tif (!ctx->hdr_parsed) {\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, &PROP_DATA((char *)data, (u32) ( strlen(data)+1 ) )  );\n\t\t\tctx->hdr_parsed = GF_TRUE;\n\t\t}\n\t} else if (!ctx->seek_state) {\n\t\tGF_FilterPacket *pck;\n\t\tu8 *pck_data;\n\t\tpck = gf_filter_pck_new_alloc(ctx->opid, length, &pck_data);\n\t\tif (pck) {\n\t\t\tmemcpy(pck_data, data, length);\n\t\t\tgf_filter_pck_set_framing(pck, GF_FALSE, GF_TRUE);\n\n\t\t\tgf_filter_pck_send(pck);\n\t\t}\n\t}\n\treturn GF_OK;\n}\n\nstatic GF_Err gf_text_swf_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID;\n\n\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\te = gf_swf_read_header(ctx->swf_parse);\n\tif (e) return e;\n\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_SIMPLE_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n//\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_UINT(file_size) );\n\n\t//patch for old arch\n\tctx->width = FIX2INT(ctx->swf_parse->width);\n\tctx->height = FIX2INT(ctx->swf_parse->height);\n\tif (!ctx->width && !ctx->height) {\n\t\tctx->width = 400;\n\t\tctx->height = 60;\n\t}\n\tID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\tgf_filter_pid_set_property_str(ctx->opid, \"meta:mime\", &PROP_STRING(\"image/svg+xml\") );\n\n#ifndef GPAC_DISABLE_SVG\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] swf -> svg not fully migrated, using SWF flags 0 and no flatten angle. Patch welcome\\n\"));\n\te = swf_to_svg_init(ctx->swf_parse, 0, 0);\n#endif\n\n\t//SWF->BIFS is handled in ctx loader, no need to define it here\n\ttxtin_probe_duration(ctx);\n\n\treturn e;\n}\n\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e=GF_OK;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn gf_text_swf_setup(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_swf_reader_del(ctx->swf_parse);\n\t\tctx->swf_parse = gf_swf_reader_new(NULL, ctx->file_name);\n\t\tgf_swf_read_header(ctx->swf_parse);\n\t\tgf_swf_reader_set_user_mode(ctx->swf_parse, ctx, swf_svg_add_iso_sample, swf_svg_add_iso_header);\n\t}\n\n\tctx->do_suspend = GF_FALSE;\n\t/*parse all tags*/\n\twhile (e == GF_OK) {\n\t\te = swf_parse_tag(ctx->swf_parse);\n\t\tif (ctx->do_suspend) return GF_OK;\n\t}\n\tif (e==GF_EOS) {\n\t\tif (ctx->swf_parse->finalize) {\n\t\t\tctx->swf_parse->finalize(ctx->swf_parse);\n\t\t\tctx->swf_parse->finalize = NULL;\n\t\t}\n\t}\n\treturn e;\n}\n/* end of SWF Importer */\n\n#else\n\n#ifndef GPAC_DISABLE_ZLIB\nstatic GF_Err gf_text_process_swf(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"Warning: GPAC was compiled without SWF import support, can't import file.\\n\"));\n\treturn GF_NOT_SUPPORTED;\n}\n#endif\n\n\n#endif /*GPAC_DISABLE_SWF_IMPORT*/\n\nstatic GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tDouble ts_scale;\n\tchar szLine[2048], szTime[20], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tif (ctx->fps.den && ctx->fps.num) {\n\t\tts_scale = ((Double) ctx->fps.num) / ctx->fps.den;\n\t} else {\n\t\tts_scale = 25;\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\\n\", line, szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t\tif (i>=19)\n\t\t\t\tbreak;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->start = atoi(szTime);\n\t\tif (ctx->start < ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\\n\", line, ctx->start, ctx->end));\n\t\t\tctx->start = ctx->end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\\n\", szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->end = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->start && ctx->first_samp) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\n\t\tif (ctx->prev_end) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}\n\n\n\nstatic u32 ttxt_get_color(char *val)\n{\n\tu32 r, g, b, a, res;\n\tr = g = b = a = 0;\n\tif (sscanf(val, \"%x %x %x %x\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Warning: color badly formatted %s\\n\", val));\n\t}\n\tres = (a&0xFF);\n\tres<<=8;\n\tres |= (r&0xFF);\n\tres<<=8;\n\tres |= (g&0xFF);\n\tres<<=8;\n\tres |= (b&0xFF);\n\treturn res;\n}\n\nstatic void ttxt_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"top\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"bottom\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"left\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"right\")) box->right = atoi(att->value);\n\t}\n}\n\nstatic void ttxt_parse_text_style(GF_TXTIn *ctx, GF_XMLNode *n, GF_StyleRecord *style)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(style, 0, sizeof(GF_StyleRecord));\n\tstyle->fontID = 1;\n\tstyle->font_size = ctx->fontsize ;\n\tstyle->text_color = 0xFFFFFFFF;\n\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"fromChar\")) style->startCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"toChar\")) style->endCharOffset = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontID\")) style->fontID = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"fontSize\")) style->font_size = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"color\")) style->text_color = ttxt_get_color(att->value);\n\t\telse if (!stricmp(att->name, \"styles\")) {\n\t\t\tif (strstr(att->value, \"Bold\")) style->style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\tif (strstr(att->value, \"Italic\")) style->style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\tif (strstr(att->value, \"Underlined\")) style->style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\tif (strstr(att->value, \"Strikethrough\")) style->style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t}\n\t}\n}\n\nstatic GF_Err txtin_setup_ttxt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 j, k, ID, OCR_ES_ID;\n\tu64 file_size;\n\tGF_XMLNode *root, *ext;\n\tGF_PropertyValue *dcd;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TTXT file: Line %d - %s\\n\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser)));\n\t\treturn e;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tif (strcmp(root->name, \"TextStream\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - expecting \\\"TextStream\\\" got %s\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->end = 0;\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\tOCR_ES_ID = ID = 0;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_CODECID_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\n\tctx->nb_children = gf_list_count(root->content);\n\n\tctx->cur_child_idx = 0;\n\tfor (ctx->cur_child_idx=0; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strcmp(node->name, \"TextStreamHeader\")) {\n\t\t\tGF_XMLNode *sdesc;\n\t\t\ts32 w, h, tx, ty, layer;\n\t\t\tu32 tref_id;\n\t\t\tGF_XMLAttribute *att;\n\t\t\tw = ctx->width;\n\t\t\th = ctx->height;\n\t\t\ttx = ctx->txtx;\n\t\t\tty = ctx->txty;\n\t\t\tlayer = ctx->zorder;\n\t\t\ttref_id = 0;\n\n\t\t\tj=0;\n\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\t\tif (!strcmp(att->name, \"width\")) w = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"height\")) h = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"layer\")) layer = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_x\")) tx = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"translation_y\")) ty = atoi(att->value);\n\t\t\t\telse if (!strcmp(att->name, \"trefID\")) tref_id = atoi(att->value);\n\t\t\t}\n\n\t\t\tif (tref_id) {\n\t\t\t\tgf_filter_pid_set_property_str(ctx->opid, \"tref:chap\", &PROP_UINT(tref_id) );\n\t\t\t}\n\n\t\t\tif (w) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(w) );\n\t\t\tif (h) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(h) );\n\t\t\tif (tx) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(tx) );\n\t\t\tif (ty) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TRANS_X, &PROP_UINT(ty) );\n\t\t\tif (layer) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\t\t\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\t\t\tj=0;\n\t\t\twhile ( (sdesc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\t\tif (sdesc->type) continue;\n\n\t\t\t\tif (!strcmp(sdesc->name, \"TextSampleDescription\")) {\n\t\t\t\t\tGF_TextSampleDescriptor td;\n\t\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(sdesc->attributes, &k))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"backColor\")) td.back_color = ttxt_get_color(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"verticalText\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"fillTextRegion\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_FILL_REGION;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"continuousKaraoke\") && !stricmp(att->value, \"yes\") ) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scroll\")) {\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"inout\")) td.displayFlags |= GF_TXT_SCROLL_IN | GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"in\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"out\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (!strcmp(att->name, \"scrollMode\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\tif (!stricmp(att->value, \"Credits\")) scroll_mode = GF_TXT_SCROLL_CREDITS;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Marquee\")) scroll_mode = GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Right\")) scroll_mode = GF_TXT_SCROLL_RIGHT;\n\t\t\t\t\t\t\telse if (!stricmp(att->value, \"Down\")) scroll_mode = GF_TXT_SCROLL_DOWN;\n\t\t\t\t\t\t\ttd.displayFlags |= ((scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tk=0;\n\t\t\t\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(sdesc->content, &k))) {\n\t\t\t\t\t\tif (ext->type) continue;\n\t\t\t\t\t\tif (!strcmp(ext->name, \"TextBox\")) ttxt_parse_text_box(ext, &td.default_pos);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"Style\")) ttxt_parse_text_style(ctx, ext, &td.default_style);\n\t\t\t\t\t\telse if (!strcmp(ext->name, \"FontTable\")) {\n\t\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\t\tu32 z=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(ext->content, &z))) {\n\t\t\t\t\t\t\t\tu32 m;\n\t\t\t\t\t\t\t\tif (ftable->type || strcmp(ftable->name, \"FontTableEntry\")) continue;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &m))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"fontID\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"fontName\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (ctx->nodefbox) {\n\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = td.default_pos.right = td.default_pos.bottom = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\t\t\ttd.default_pos.top = td.default_pos.left = 0;\n\t\t\t\t\t\t\ttd.default_pos.right = w;\n\t\t\t\t\t\t\ttd.default_pos.bottom = h;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!td.fonts) {\n\t\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\t\ttd.fonts[0].fontName = gf_strdup(\"Serif\");\n\t\t\t\t\t}\n\t\t\t\t\tGF_SAFEALLOC(dcd, GF_PropertyValue);\n\t\t\t\t\tif (dcd) {\n\t\t\t\t\t\tdcd->type = GF_PROP_DATA;\n\n\t\t\t\t\t\tgf_odf_tx3g_write(&td, &dcd->value.data.ptr, &dcd->value.data.size);\n\t\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\t\tgf_list_add(ctx->text_descs, dcd);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\t\tgf_free(td.fonts);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!ctx->text_descs) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid Timed Text file - text stream header not found or empty\\n\"));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tdcd = gf_list_get(ctx->text_descs, 0);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\tctx->last_desc_idx = 1;\n\n\tctx->first_samp = GF_TRUE;\n\tctx->last_sample_empty = GF_FALSE;\n\tctx->last_sample_duration = 0;\n\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_ttxt(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 j, k;\n\tGF_XMLNode *root, *ext;\n\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_ttxt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t}\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_TextSample * samp;\n\t\tu32 ts, descIndex;\n\t\tBool has_text = GF_FALSE;\n\t\tGF_XMLAttribute *att;\n\t\tGF_XMLNode *node = (GF_XMLNode*) gf_list_get(root->content, ctx->cur_child_idx);\n\n\t\tif (node->type) {\n\t\t\tcontinue;\n\t\t}\n\t\t/*sample text*/\n\t\telse if (strcmp(node->name, \"TextSample\")) continue;\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tts = 0;\n\t\tdescIndex = 1;\n\t\tctx->last_sample_empty = GF_TRUE;\n\n\t\tj=0;\n\t\twhile ( (att=(GF_XMLAttribute*)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"sampleTime\")) {\n\t\t\t\tu32 h, m, s, ms;\n\t\t\t\tif (sscanf(att->value, \"%u:%u:%u.%u\", &h, &m, &s, &ms) == 4) {\n\t\t\t\t\tts = (h*3600 + m*60 + s)*1000 + ms;\n\t\t\t\t} else {\n\t\t\t\t\tts = (u32) (atof(att->value) * 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"sampleDescriptionIndex\")) descIndex = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"text\")) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(att->value, GF_TRUE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, (u32) (1000*atoi(att->value)));\n\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, ttxt_get_color(att->value));\n\t\t\telse if (!strcmp(att->name, \"wrap\") && !strcmp(att->value, \"Automatic\")) gf_isom_text_set_wrap(samp, 0x01);\n\t\t}\n\n\t\t/*get all modifiers*/\n\t\tj=0;\n\t\twhile ( (ext=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (!has_text && (ext->type==GF_XML_TEXT_TYPE)) {\n\t\t\t\tu32 len;\n\t\t\t\tchar *str = ttxt_parse_string(ext->name, GF_FALSE);\n\t\t\t\tlen = (u32) strlen(str);\n\t\t\t\tgf_isom_text_add_text(samp, str, len);\n\t\t\t\tctx->last_sample_empty = len ? GF_FALSE : GF_TRUE;\n\t\t\t\thas_text = GF_TRUE;\n\t\t\t}\n\t\t\tif (ext->type) continue;\n\n\t\t\tif (!stricmp(ext->name, \"Style\")) {\n\t\t\t\tGF_StyleRecord r;\n\t\t\t\tttxt_parse_text_style(ctx, ext, &r);\n\t\t\t\tgf_isom_text_add_style(samp, &r);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"TextBox\")) {\n\t\t\t\tGF_BoxRecord r;\n\t\t\t\tttxt_parse_text_box(ext, &r);\n\t\t\t\tgf_isom_text_set_box(samp, r.top, r.left, r.bottom, r.right);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Highlight\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Blinking\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"HyperLink\")) {\n\t\t\t\tu16 start, end;\n\t\t\t\tchar *url, *url_tt;\n\t\t\t\tstart = end = 0;\n\t\t\t\turl = url_tt = NULL;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URL\")) url = gf_strdup(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\")) url_tt = gf_strdup(att->value);\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\tif (url) gf_free(url);\n\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t}\n\t\t\telse if (!stricmp(ext->name, \"Karaoke\")) {\n\t\t\t\tu32 startTime;\n\t\t\t\tGF_XMLNode *krok;\n\t\t\t\tstartTime = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(ext->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) startTime = (u32) (1000*atof(att->value));\n\t\t\t\t}\n\t\t\t\tgf_isom_text_add_karaoke(samp, startTime);\n\t\t\t\tk=0;\n\t\t\t\twhile ( (krok=(GF_XMLNode*)gf_list_enum(ext->content, &k))) {\n\t\t\t\t\tu16 start, end;\n\t\t\t\t\tu32 endTime, m;\n\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\tif (strcmp(krok->name, \"KaraokeRange\")) continue;\n\t\t\t\t\tstart = end = 0;\n\t\t\t\t\tendTime = 0;\n\t\t\t\t\tm=0;\n\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &m))) {\n\t\t\t\t\t\tif (!strcmp(att->name, \"fromChar\")) start = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"toChar\")) end = atoi(att->value);\n\t\t\t\t\t\telse if (!strcmp(att->name, \"endTime\")) endTime = (u32) (1000*atof(att->value));\n\t\t\t\t\t}\n\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, endTime, start, end);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!descIndex) descIndex = 1;\n\t\tif (descIndex != ctx->last_desc_idx) {\n\t\t\tGF_PropertyValue *dcd;\n\t\t\tctx->last_desc_idx = descIndex;\n\t\t\tdcd = gf_list_get(ctx->text_descs, descIndex-1);\n\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, dcd);\n\t\t}\n\n\t\t/*in MP4 we must start at T=0, so add an empty sample*/\n\t\tif (ts && ctx->first_samp) {\n\t\t\tGF_TextSample * firstsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, firstsamp, 0, 0, GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(firstsamp);\n\t\t}\n\t\tctx->first_samp = GF_FALSE;\n\n\t\ttxtin_process_send_text_sample(ctx, samp, ts, 0, GF_TRUE);\n\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tif (ctx->last_sample_empty) {\n\t\t\tctx->last_sample_duration = ts - ctx->last_sample_duration;\n\t\t} else {\n\t\t\tctx->last_sample_duration = ts;\n\t\t}\n\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\tif (ctx->last_sample_empty) {\n\t\t//this is a bit ugly, in regular streaming mode we don't want to remove empty samples\n\t\t//howvere the last one can be removed, adjusting the duration of the previous one.\n\t\t//doing this here is problematic if the loader is sent a new ttxt file, we would have a cue termination sample\n\t\t//we therefore share that info through pid, and let the final user (muxer& co) decide what to do\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:rem_last\", &PROP_BOOL(GF_TRUE) );\n\t\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT((u32) ctx->last_sample_duration) );\n\t}\n\n\treturn GF_EOS;\n}\n\n\nstatic u32 tx3g_get_color(char *value)\n{\n\tu32 r, g, b, a;\n\tu32 res, v;\n\tr = g = b = a = 0;\n\tif (sscanf(value, \"%u%%, %u%%, %u%%, %u%%\", &r, &g, &b, &a) != 4) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"Warning: color badly formatted\\n\"));\n\t}\n\tv = (u32) (a*255/100);\n\tres = (v&0xFF);\n\tres<<=8;\n\tv = (u32) (r*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (g*255/100);\n\tres |= (v&0xFF);\n\tres<<=8;\n\tv = (u32) (b*255/100);\n\tres |= (v&0xFF);\n\treturn res;\n}\n\nstatic void tx3g_parse_text_box(GF_XMLNode *n, GF_BoxRecord *box)\n{\n\tu32 i=0;\n\tGF_XMLAttribute *att;\n\tmemset(box, 0, sizeof(GF_BoxRecord));\n\twhile ((att=(GF_XMLAttribute *)gf_list_enum(n->attributes, &i))) {\n\t\tif (!stricmp(att->name, \"x\")) box->left = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"y\")) box->top = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"height\")) box->bottom = atoi(att->value);\n\t\telse if (!stricmp(att->name, \"width\")) box->right = atoi(att->value);\n\t}\n}\n\ntypedef struct\n{\n\tu32 id;\n\tu32 pos;\n} Marker;\n\n#define GET_MARKER_POS(_val, __isend) \\\n\t{\t\\\n\t\tu32 i, __m = atoi(att->value);\t\\\n\t\t_val = 0;\t\\\n\t\tfor (i=0; i<nb_marks; i++) { if (__m==marks[i].id) { _val = marks[i].pos; /*if (__isend) _val--; */break; } }\t \\\n\t}\n\n\nstatic GF_Err txtin_texml_setup(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tGF_Err e;\n\tu32 ID, OCR_ES_ID, i;\n\tu64 file_size;\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\n\tctx->parser = gf_xml_dom_new();\n\te = gf_xml_dom_parse(ctx->parser, ctx->file_name, ttxt_dom_progress, ctx);\n\tif (e) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Error parsing TeXML file: Line %d - %s\", gf_xml_dom_get_line(ctx->parser), gf_xml_dom_get_error(ctx->parser) ));\n\t\tgf_xml_dom_del(ctx->parser);\n\t\tctx->parser = NULL;\n\t\treturn e;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tif (strcmp(root->name, \"text3GTrack\")) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Invalid QT TeXML file - expecting root \\\"text3GTrack\\\" got \\\"%s\\\"\", root->name));\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tfile_size = ctx->end;\n\tctx->txml_timescale = 600;\n\n\ti=0;\n\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(root->attributes, &i))) {\n\t\tif (!strcmp(att->name, \"trackWidth\")) ctx->width = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"trackHeight\")) ctx->height = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"layer\")) ctx->zorder = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"timeScale\")) ctx->txml_timescale = atoi(att->value);\n\t\telse if (!strcmp(att->name, \"transform\")) {\n\t\t\tFloat fx, fy;\n\t\t\tsscanf(att->value, \"translate(%f,%f)\", &fx, &fy);\n\t\t\tctx->txtx = (u32) fx;\n\t\t\tctx->txty = (u32) fy;\n\t\t}\n\t}\n\n\t/*setup track in 3GP format directly (no ES desc)*/\n\tOCR_ES_ID = ID = 0;\n\tif (!ctx->timescale) ctx->timescale = 1000;\n\n\tif (!ctx->opid) ctx->opid = gf_filter_pid_new(filter);\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_STREAM_TYPE, &PROP_UINT(GF_STREAM_TEXT) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CODECID, &PROP_UINT(GF_ISOM_SUBTYPE_TX3G) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_TIMESCALE, &PROP_UINT(ctx->timescale) );\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DOWN_SIZE, &PROP_LONGUINT(file_size) );\n\n\n\tif (!ID) ID = 1;\n\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ID, &PROP_UINT(ID) );\n\tif (OCR_ES_ID) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_CLOCK_ID, &PROP_UINT(OCR_ES_ID) );\n\tif (ctx->width) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_WIDTH, &PROP_UINT(ctx->width) );\n\tif (ctx->height) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_HEIGHT, &PROP_UINT(ctx->height) );\n\tif (ctx->zorder) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_ZORDER, &PROP_SINT(ctx->zorder) );\n\tif (ctx->lang) gf_filter_pid_set_property(ctx->opid, GF_PROP_PID_LANGUAGE, &PROP_STRING( ctx->lang) );\n\n\n\tctx->nb_children = gf_list_count(root->content);\n\tctx->cur_child_idx = 0;\n\ttxtin_probe_duration(ctx);\n\n\treturn GF_OK;\n}\n\nstatic GF_Err txtin_process_texml(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 j, k;\n\tGF_StyleRecord styles[50];\n\tMarker marks[50];\n\tGF_XMLAttribute *att;\n\tGF_XMLNode *root;\n\tBool probe_first_desc_only = GF_FALSE;\n\n\tif (!ctx->is_setup) {\n\t\tGF_Err e;\n\n\t\tctx->is_setup = GF_TRUE;\n\t\te = txtin_texml_setup(filter, ctx);\n\t\tif (e) return e;\n\t\tprobe_first_desc_only = GF_TRUE;\n\t}\n\tif (!ctx->opid) return GF_NON_COMPLIANT_BITSTREAM;\n\tif (!ctx->playstate && !probe_first_desc_only) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tctx->cur_child_idx = 0;\n\t\tctx->start = 0;\n\t}\n\n\troot = gf_xml_dom_get_root(ctx->parser);\n\n\tfor (; ctx->cur_child_idx < ctx->nb_children; ctx->cur_child_idx++) {\n\t\tGF_XMLNode *node, *desc;\n\t\tGF_TextSampleDescriptor td;\n\t\tGF_TextSample * samp = NULL;\n\t\tu64 duration;\n\t\tu32 nb_styles, nb_marks;\n\t\tBool isRAP, same_style, same_box;\n\n\t\tif (probe_first_desc_only && ctx->text_descs && gf_list_count(ctx->text_descs))\n\t\t\treturn GF_OK;\n\n\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\tnode = (GF_XMLNode*)gf_list_get(root->content, ctx->cur_child_idx);\n\t\tif (node->type) continue;\n\t\tif (strcmp(node->name, \"sample\")) continue;\n\n\t\tisRAP = GF_TRUE;\n\t\tduration = 1000;\n\t\tj=0;\n\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(node->attributes, &j))) {\n\t\t\tif (!strcmp(att->name, \"duration\")) duration = atoi(att->value);\n\t\t\telse if (!strcmp(att->name, \"keyframe\")) isRAP = (!stricmp(att->value, \"true\") ? GF_TRUE : GF_FALSE);\n\t\t}\n\t\tnb_styles = 0;\n\t\tnb_marks = 0;\n\t\tsame_style = same_box = GF_FALSE;\n\t\tj=0;\n\t\twhile ((desc=(GF_XMLNode*)gf_list_enum(node->content, &j))) {\n\t\t\tif (desc->type) continue;\n\n\t\t\tif (!strcmp(desc->name, \"description\")) {\n\t\t\t\tu8 *dsi;\n\t\t\t\tu32 dsi_len, stsd_idx;\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tmemset(&td, 0, sizeof(GF_TextSampleDescriptor));\n\t\t\t\ttd.tag = GF_ODF_TEXT_CFG_TAG;\n\t\t\t\ttd.vert_justif = (s8) -1;\n\t\t\t\ttd.default_style.fontID = 1;\n\t\t\t\ttd.default_style.font_size = ctx->fontsize;\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"horizontalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.horiz_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"right\")) td.horiz_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"left\")) td.horiz_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"verticalJustification\")) {\n\t\t\t\t\t\tif (!stricmp(att->value, \"center\")) td.vert_justif = 1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"bottom\")) td.vert_justif = (s8) -1;\n\t\t\t\t\t\telse if (!stricmp(att->value, \"top\")) td.vert_justif = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(att->name, \"backgroundColor\")) td.back_color = tx3g_get_color(att->value);\n\t\t\t\t\telse if (!strcmp(att->name, \"displayFlags\")) {\n\t\t\t\t\t\tBool rev_scroll = GF_FALSE;\n\t\t\t\t\t\tif (strstr(att->value, \"scroll\")) {\n\t\t\t\t\t\t\tu32 scroll_mode = 0;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollIn\")) td.displayFlags |= GF_TXT_SCROLL_IN;\n\t\t\t\t\t\t\tif (strstr(att->value, \"scrollOut\")) td.displayFlags |= GF_TXT_SCROLL_OUT;\n\t\t\t\t\t\t\tif (strstr(att->value, \"reverse\")) rev_scroll = GF_TRUE;\n\t\t\t\t\t\t\tif (strstr(att->value, \"horizontal\")) scroll_mode = rev_scroll ? GF_TXT_SCROLL_RIGHT : GF_TXT_SCROLL_MARQUEE;\n\t\t\t\t\t\t\telse scroll_mode = (rev_scroll ? GF_TXT_SCROLL_DOWN : GF_TXT_SCROLL_CREDITS);\n\t\t\t\t\t\t\ttd.displayFlags |= (scroll_mode<<7) & GF_TXT_SCROLL_DIRECTION;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*TODO FIXME: check in QT doc !!*/\n\t\t\t\t\t\tif (strstr(att->value, \"writeTextVertically\")) td.displayFlags |= GF_TXT_VERTICAL;\n\t\t\t\t\t\tif (!strcmp(att->name, \"continuousKaraoke\")) td.displayFlags |= GF_TXT_KARAOKE;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"defaultTextBox\")) tx3g_parse_text_box(sub, &td.default_pos);\n\t\t\t\t\telse if (!strcmp(sub->name, \"fontTable\")) {\n\t\t\t\t\t\tGF_XMLNode *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((ftable=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (ftable->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(ftable->name, \"font\")) {\n\t\t\t\t\t\t\t\tu32 n=0;\n\t\t\t\t\t\t\t\ttd.font_count += 1;\n\t\t\t\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_realloc(td.fonts, sizeof(GF_FontRecord)*td.font_count);\n\t\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(ftable->attributes, &n))) {\n\t\t\t\t\t\t\t\t\tif (!stricmp(att->name, \"id\")) td.fonts[td.font_count-1].fontID = atoi(att->value);\n\t\t\t\t\t\t\t\t\telse if (!stricmp(att->name, \"name\")) td.fonts[td.font_count-1].fontName = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (!strcmp(sub->name, \"sharedStyles\")) {\n\t\t\t\t\t\tGF_XMLNode *style, *ftable;\n\t\t\t\t\t\tu32 m=0;\n\t\t\t\t\t\twhile ((style=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (style->type) continue;\n\t\t\t\t\t\t\tif (!strcmp(style->name, \"style\")) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (style) {\n\t\t\t\t\t\t\tchar *cur;\n\t\t\t\t\t\t\ts32 start=0;\n\t\t\t\t\t\t\tchar css_style[1024], css_val[1024];\n\t\t\t\t\t\t\tmemset(&styles[nb_styles], 0, sizeof(GF_StyleRecord));\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(style->attributes, &m))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) styles[nb_styles].startCharOffset = atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm=0;\n\t\t\t\t\t\t\twhile ( (ftable=(GF_XMLNode*)gf_list_enum(style->content, &m))) {\n\t\t\t\t\t\t\t\tif (ftable->type) break;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcur = ftable ? ftable->name : NULL;\n\t\t\t\t\t\t\twhile (cur) {\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, 0, \"{:\", \" \", css_style, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tstart = gf_token_get_strip(cur, start, \":}\", \" \", css_val, 1024);\n\t\t\t\t\t\t\t\tif (start <0) break;\n\t\t\t\t\t\t\t\tcur = strchr(cur+start, '{');\n\n\t\t\t\t\t\t\t\tif (!strcmp(css_style, \"font-table\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tstyles[nb_styles].fontID = atoi(css_val);\n\t\t\t\t\t\t\t\t\tfor (z=0; z<td.font_count; z++) {\n\t\t\t\t\t\t\t\t\t\tif (td.fonts[z].fontID == styles[nb_styles].fontID)\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-size\")) styles[nb_styles].font_size = atoi(css_val);\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-style\") && !strcmp(css_val, \"italic\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_ITALIC;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"font-weight\") && !strcmp(css_val, \"bold\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_BOLD;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"underline\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_UNDERLINED;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"text-decoration\") && !strcmp(css_val, \"strikethrough\")) styles[nb_styles].style_flags |= GF_TXT_STYLE_STRIKETHROUGH;\n\t\t\t\t\t\t\t\telse if (!strcmp(css_style, \"color\")) styles[nb_styles].text_color = tx3g_get_color(css_val);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!nb_styles) td.default_style = styles[0];\n\t\t\t\t\t\t\tnb_styles++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif ((td.default_pos.bottom==td.default_pos.top) || (td.default_pos.right==td.default_pos.left)) {\n\t\t\t\t\ttd.default_pos.top = ctx->txty;\n\t\t\t\t\ttd.default_pos.left = ctx->txtx;\n\t\t\t\t\ttd.default_pos.right = ctx->width;\n\t\t\t\t\ttd.default_pos.bottom = ctx->height;\n\t\t\t\t}\n\t\t\t\tif (!td.fonts) {\n\t\t\t\t\ttd.font_count = 1;\n\t\t\t\t\ttd.fonts = (GF_FontRecord*)gf_malloc(sizeof(GF_FontRecord));\n\t\t\t\t\ttd.fonts[0].fontID = 1;\n\t\t\t\t\ttd.fonts[0].fontName = gf_strdup( ctx->fontname ? ctx->fontname : \"Serif\");\n\t\t\t\t}\n\n\t\t\t\tgf_odf_tx3g_write(&td, &dsi, &dsi_len);\n\t\t\t\tstsd_idx = 0;\n\t\t\t\tfor (k=0; ctx->text_descs && k<gf_list_count(ctx->text_descs); k++) {\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, k);\n\t\t\t\t\tif (d->value.data.size != dsi_len) continue;\n\t\t\t\t\tif (! memcmp(d->value.data.ptr, dsi, dsi_len)) {\n\t\t\t\t\t\tstsd_idx = k+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (stsd_idx) {\n\t\t\t\t\tgf_free(dsi);\n\t\t\t\t} else {\n\t\t\t\t\tGF_PropertyValue *d;\n\t\t\t\t\tGF_SAFEALLOC(d, GF_PropertyValue);\n\t\t\t\t\tif (!d) return GF_OUT_OF_MEM;\n\t\t\t\t\td->type = GF_PROP_DATA;\n\t\t\t\t\td->value.data.ptr = dsi;\n\t\t\t\t\td->value.data.size = dsi_len;\n\t\t\t\t\tif (!ctx->text_descs) ctx->text_descs = gf_list_new();\n\t\t\t\t\tgf_list_add(ctx->text_descs, d);\n\t\t\t\t\tstsd_idx = gf_list_count(ctx->text_descs);\n\t\t\t\t}\n\t\t\t\tif (stsd_idx != ctx->last_desc_idx) {\n\t\t\t\t\tctx->last_desc_idx = stsd_idx;\n\t\t\t\t\tGF_PropertyValue *d = gf_list_get(ctx->text_descs, stsd_idx-1);\n\t\t\t\t\tgf_filter_pid_set_property(ctx->opid, GF_PROP_PID_DECODER_CONFIG, d);\n\t\t\t\t}\n\n\t\t\t\tfor (k=0; k<td.font_count; k++) gf_free(td.fonts[k].fontName);\n\t\t\t\tgf_free(td.fonts);\n\n\t\t\t\tif (probe_first_desc_only)\n\t\t\t\t\treturn GF_OK;\n\t\t\t}\n\t\t\telse if (!strcmp(desc->name, \"sampleData\")) {\n\t\t\t\tGF_XMLNode *sub;\n\t\t\t\tu16 start, end;\n\t\t\t\tu32 styleID;\n\t\t\t\tu32 nb_chars, txt_len, m;\n\t\t\t\tnb_chars = 0;\n\n\t\t\t\tsamp = gf_isom_new_text_sample();\n\n\t\t\t\tk=0;\n\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(desc->attributes, &k))) {\n\t\t\t\t\tif (!strcmp(att->name, \"targetEncoding\") && !strcmp(att->value, \"utf16\")) ;//is_utf16 = 1;\n\t\t\t\t\telse if (!strcmp(att->name, \"scrollDelay\")) gf_isom_text_set_scroll_delay(samp, atoi(att->value) );\n\t\t\t\t\telse if (!strcmp(att->name, \"highlightColor\")) gf_isom_text_set_highlight_color(samp, tx3g_get_color(att->value));\n\t\t\t\t}\n\t\t\t\tstart = end = 0;\n\t\t\t\tk=0;\n\t\t\t\twhile ((sub=(GF_XMLNode*)gf_list_enum(desc->content, &k))) {\n\t\t\t\t\tif (sub->type) continue;\n\t\t\t\t\tif (!strcmp(sub->name, \"text\")) {\n\t\t\t\t\t\tGF_XMLNode *text;\n\t\t\t\t\t\tstyleID = 0;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"styleID\")) styleID = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttxt_len = 0;\n\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((text=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tif (!text->type) {\n\t\t\t\t\t\t\t\tif (!strcmp(text->name, \"marker\")) {\n\t\t\t\t\t\t\t\t\tu32 z;\n\t\t\t\t\t\t\t\t\tmemset(&marks[nb_marks], 0, sizeof(Marker));\n\t\t\t\t\t\t\t\t\tmarks[nb_marks].pos = nb_chars+txt_len;\n\n\t\t\t\t\t\t\t\t\tz = 0;\n\t\t\t\t\t\t\t\t\twhile ( (att=(GF_XMLAttribute *)gf_list_enum(text->attributes, &z))) {\n\t\t\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"id\")) marks[nb_marks].id = atoi(att->value);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tnb_marks++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (text->type==GF_XML_TEXT_TYPE) {\n\t\t\t\t\t\t\t\ttxt_len += (u32) strlen(text->name);\n\t\t\t\t\t\t\t\tgf_isom_text_add_text(samp, text->name, (u32) strlen(text->name));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (styleID && (!same_style || (td.default_style.startCharOffset != styleID))) {\n\t\t\t\t\t\t\tGF_StyleRecord st = td.default_style;\n\t\t\t\t\t\t\tfor (m=0; m<nb_styles; m++) {\n\t\t\t\t\t\t\t\tif (styles[m].startCharOffset==styleID) {\n\t\t\t\t\t\t\t\t\tst = styles[m];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tst.startCharOffset = nb_chars;\n\t\t\t\t\t\t\tst.endCharOffset = nb_chars + txt_len;\n\t\t\t\t\t\t\tgf_isom_text_add_style(samp, &st);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnb_chars += txt_len;\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"highlight\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_highlight(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"blink\")) {\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_blink(samp, start, end);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"link\")) {\n\t\t\t\t\t\tchar *url, *url_tt;\n\t\t\t\t\t\turl = url_tt = NULL;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URL\") || !strcmp(att->name, \"href\")) url = gf_strdup(att->value);\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"URLToolTip\") || !strcmp(att->name, \"altString\")) url_tt = gf_strdup(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_hyperlink(samp, url, url_tt, start, end);\n\t\t\t\t\t\tif (url) gf_free(url);\n\t\t\t\t\t\tif (url_tt) gf_free(url_tt);\n\t\t\t\t\t}\n\t\t\t\t\telse if (!stricmp(sub->name, \"karaoke\")) {\n\t\t\t\t\t\tu32 time = 0;\n\t\t\t\t\t\tGF_XMLNode *krok;\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(sub->attributes, &m))) {\n\t\t\t\t\t\t\tif (!strcmp(att->name, \"startTime\")) time = atoi(att->value);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgf_isom_text_add_karaoke(samp, time);\n\t\t\t\t\t\tm=0;\n\t\t\t\t\t\twhile ((krok=(GF_XMLNode*)gf_list_enum(sub->content, &m))) {\n\t\t\t\t\t\t\tu32 u=0;\n\t\t\t\t\t\t\tif (krok->type) continue;\n\t\t\t\t\t\t\tif (strcmp(krok->name, \"run\")) continue;\n\t\t\t\t\t\t\tstart = end = 0;\n\t\t\t\t\t\t\twhile ((att=(GF_XMLAttribute *)gf_list_enum(krok->attributes, &u))) {\n\t\t\t\t\t\t\t\tif (!strcmp(att->name, \"startMarker\")) GET_MARKER_POS(start, 0)\n\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"endMarker\")) GET_MARKER_POS(end, 1)\n\t\t\t\t\t\t\t\t\t\telse if (!strcmp(att->name, \"duration\")) time += atoi(att->value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgf_isom_text_set_karaoke_segment(samp, time, start, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/*OK, let's add the sample*/\n\t\tif (samp) {\n\t\t\tif (!same_box) gf_isom_text_set_box(samp, td.default_pos.top, td.default_pos.left, td.default_pos.bottom, td.default_pos.right);\n//\t\t\tif (!same_style) gf_isom_text_add_style(samp, &td.default_style);\n\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (ctx->start*ctx->timescale)/ctx->txml_timescale, (u32) (duration*ctx->timescale)/ctx->txml_timescale, isRAP);\n\t\t\tctx->start += duration;\n\t\t\tgf_isom_delete_text_sample(samp);\n\n\t\t}\n\t\tif (gf_filter_pid_would_block(ctx->opid)) {\n\t\t\tctx->cur_child_idx++;\n\t\t\treturn GF_OK;\n\t\t}\n\t}\n\n\treturn GF_EOS;\n}\n\n\nstatic GF_Err txtin_process(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tGF_FilterPacket *pck;\n\tGF_Err e;\n\tBool start, end;\n\tpck = gf_filter_pid_get_packet(ctx->ipid);\n\tif (!pck) {\n\t\treturn GF_OK;\n\t}\n\tgf_filter_pck_get_framing(pck, &start, &end);\n\tif (!end) {\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\treturn GF_OK;\n\t}\n\t//file is loaded\n\n\te = ctx->text_process(filter, ctx);\n\n\n\tif (e==GF_EOS) {\n\t\t//keep input alive until end of stream, so that we keep getting called\n\t\tgf_filter_pid_drop_packet(ctx->ipid);\n\t\tif (gf_filter_pid_is_eos(ctx->ipid))\n\t\t\tgf_filter_pid_set_eos(ctx->opid);\n\t}\n\treturn e;\n}\n\nstatic void ttxtin_reset(GF_TXTIn *ctx)\n{\n\tif (ctx->samp) gf_isom_delete_text_sample(ctx->samp);\n\tctx->samp = NULL;\n\tif (ctx->src) gf_fclose(ctx->src);\n\tctx->src = NULL;\n\tif (ctx->vttparser) gf_webvtt_parser_del(ctx->vttparser);\n\tctx->vttparser = NULL;\n\tif (ctx->parser) gf_xml_dom_del(ctx->parser);\n\tctx->parser = NULL;\n\tif (ctx->parser_working_copy) gf_xml_dom_del(ctx->parser_working_copy);\n\tctx->parser_working_copy = NULL;\n}\n\nstatic GF_Err txtin_configure_pid(GF_Filter *filter, GF_FilterPid *pid, Bool is_remove)\n{\n\tGF_Err e;\n\tconst char *src = NULL;\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tconst GF_PropertyValue *prop;\n\n\tif (is_remove) {\n\t\tctx->ipid = NULL;\n\t\treturn GF_OK;\n\t}\n\n\tif (! gf_filter_pid_check_caps(pid))\n\t\treturn GF_NOT_SUPPORTED;\n\n\t//we must have a file path\n\tprop = gf_filter_pid_get_property(pid, GF_PROP_PID_FILEPATH);\n\tif (prop && prop->value.string) src = prop->value.string;\n\tif (!src)\n\t\treturn GF_NOT_SUPPORTED;\n\n\tif (!ctx->ipid) {\n\t\tGF_FilterEvent fevt;\n\t\tctx->ipid = pid;\n\n\t\t//we work with full file only, send a play event on source to indicate that\n\t\tGF_FEVT_INIT(fevt, GF_FEVT_PLAY, pid);\n\t\tfevt.play.start_range = 0;\n\t\tfevt.base.on_pid = ctx->ipid;\n\t\tfevt.play.full_file_only = GF_TRUE;\n\t\tgf_filter_pid_send_event(ctx->ipid, &fevt);\n\t\tctx->file_name = gf_strdup(src);\n\t} else {\n\t\tif (pid != ctx->ipid) {\n\t\t\treturn GF_REQUIRES_NEW_INSTANCE;\n\t\t}\n\t\tif (!strcmp(ctx->file_name, src)) return GF_OK;\n\n\t\tttxtin_reset(ctx);\n\t\tctx->is_setup = GF_FALSE;\n\t\tgf_free(ctx->file_name);\n\t\tctx->file_name = gf_strdup(src);\n\t}\n\t//guess type\n\te = gf_text_guess_format(ctx->file_name, &ctx->fmt);\n\tif (e) return e;\n\tif (!ctx->fmt) {\n\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTLoad] Unknown text format for %s\\n\", ctx->file_name));\n\t\treturn GF_NOT_SUPPORTED;\n\t}\n\n\tif (ctx->webvtt && (ctx->fmt == GF_TXTIN_MODE_SRT))\n\t\tctx->fmt = GF_TXTIN_MODE_WEBVTT;\n\n\tswitch (ctx->fmt) {\n\tcase GF_TXTIN_MODE_SRT:\n\t\tctx->text_process = txtin_process_srt;\n\t\tbreak;\n#ifndef GPAC_DISABLE_VTT\n\tcase GF_TXTIN_MODE_WEBVTT:\n\t\tctx->text_process = txtin_process_webvtt;\n\t\tbreak;\n#endif\n\tcase GF_TXTIN_MODE_TTXT:\n\t\tctx->text_process = txtin_process_ttxt;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TEXML:\n\t\tctx->text_process = txtin_process_texml;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_SUB:\n\t\tctx->text_process = gf_text_process_sub;\n\t\tbreak;\n\tcase GF_TXTIN_MODE_TTML:\n\t\tctx->text_process = gf_text_process_ttml;\n\t\tbreak;\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tcase GF_TXTIN_MODE_SWF_SVG:\n\t\tctx->text_process = gf_text_process_swf;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn GF_BAD_PARAM;\n\t}\n\n\treturn GF_OK;\n}\n\nstatic Bool txtin_process_event(GF_Filter *filter, const GF_FilterEvent *evt)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tswitch (evt->base.type) {\n\tcase GF_FEVT_PLAY:\n\t\tif (ctx->playstate==1) return GF_TRUE;\n\t\tctx->playstate = 1;\n\t\tif ((ctx->start_range < 0.1) && (evt->play.start_range<0.1)) return GF_TRUE;\n\t\tctx->start_range = evt->play.start_range;\n\t\tctx->seek_state = 1;\n\t\t//cancel play event, we work with full file\n\t\treturn GF_TRUE;\n\n\tcase GF_FEVT_STOP:\n\t\tctx->playstate = 2;\n\t\t//cancel play event, we work with full file\n\t\treturn GF_TRUE;\n\tdefault:\n\t\treturn GF_FALSE;\n\t}\n\treturn GF_FALSE;\n}\n\nGF_Err txtin_initialize(GF_Filter *filter)\n{\n\tchar data[1];\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\tctx->bs_w = gf_bs_new(data, 1, GF_BITSTREAM_WRITE);\n\n\treturn GF_OK;\n}\n\nvoid txtin_finalize(GF_Filter *filter)\n{\n\tGF_TXTIn *ctx = gf_filter_get_udta(filter);\n\n\tttxtin_reset(ctx);\n\tif (ctx->bs_w) gf_bs_del(ctx->bs_w);\n\n\tif (ctx->text_descs) {\n\t\twhile (gf_list_count(ctx->text_descs)) {\n\t\t\tGF_PropertyValue *p = gf_list_pop_back(ctx->text_descs);\n\t\t\tgf_free(p->value.data.ptr);\n\t\t\tgf_free(p);\n\t\t}\n\t\tgf_list_del(ctx->text_descs);\n\t}\n#ifndef GPAC_DISABLE_SWF_IMPORT\n\tgf_swf_reader_del(ctx->swf_parse);\n#endif\n\n\tif (ctx->intervals) {\n\t\tttml_reset_intervals(ctx);\n\t\tgf_list_del(ctx->intervals);\n\t}\n\tif (ctx->ttml_resources) {\n\t\twhile (gf_list_count(ctx->ttml_resources)) {\n\t\t\tTTMLRes *ires = gf_list_pop_back(ctx->ttml_resources);\n\t\t\tgf_free(ires->data);\n\t\t\tgf_free(ires);\n\t\t}\n\t\tgf_list_del(ctx->ttml_resources);\n\t}\n\tif (ctx->div_nodes_list)\n\t\tgf_list_del(ctx->div_nodes_list);\n\n\tif (ctx->file_name) gf_free(ctx->file_name);\n}\n\n\nstatic const char *txtin_probe_data(const u8 *data, u32 data_size, GF_FilterProbeScore *score)\n{\n\tchar *dst = NULL;\n\tu8 *res;\n\n\tres = gf_utf_get_utf8_string_from_bom((char *)data, data_size, &dst);\n\tif (res) data = res;\n\n#define PROBE_OK(_score, _mime) \\\n\t\t*score = _score;\\\n\t\tif (dst) gf_free(dst);\\\n\t\treturn _mime; \\\n\n\n\tif (!strncmp(data, \"WEBVTT\", 6)) {\n\t\tPROBE_OK(GF_FPROBE_SUPPORTED, \"subtitle/vtt\")\n\t}\n\tif (strstr(data, \" --> \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/srt\")\n\t}\n\tif (!strncmp(data, \"FWS\", 3) || !strncmp(data, \"CWS\", 3)) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"application/x-shockwave-flash\")\n\t}\n\n\tif ((data[0]=='{') && strstr(data, \"}{\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/sub\")\n\n\t}\n\t/*XML formats*/\n\tif (!strstr(data, \"?>\") ) {\n\t\tif (dst) gf_free(dst);\n\t\treturn NULL;\n\t}\n\n\tif (strstr(data, \"<x-quicktime-tx3g\") || strstr(data, \"<text3GTrack\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"quicktime/text\")\n\t}\n\tif (strstr(data, \"TextStream\")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttxt\")\n\t}\n\tif (strstr(data, \"<tt \") || strstr(data, \":tt \")) {\n\t\tPROBE_OK(GF_FPROBE_MAYBE_SUPPORTED, \"subtitle/ttml\")\n\t}\n\n\tif (dst) gf_free(dst);\n\treturn NULL;\n}\n\nstatic const GF_FilterCapability TXTInCaps[] =\n{\n\tCAP_UINT(GF_CAPS_INPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_FILE),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_FILE_EXT, \"srt|ttxt|sub|vtt|txml|ttml|swf\"),\n\tCAP_STRING(GF_CAPS_INPUT, GF_PROP_PID_MIME, \"x-subtitle/srt|subtitle/srt|text/srt|x-subtitle/sub|subtitle/sub|text/sub|x-subtitle/ttxt|subtitle/ttxt|text/ttxt|x-subtitle/vtt|subtitle/vtt|text/vtt|x-quicktime/text|quicktime/text|subtitle/ttml|text/ttml|application/xml+ttml|application/x-shockwave-flash\"),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_STREAM_TYPE, GF_STREAM_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_TX3G),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SIMPLE_TEXT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_WEBVTT),\n\tCAP_UINT(GF_CAPS_OUTPUT, GF_PROP_PID_CODECID, GF_CODECID_SUBS_XML),\n};\n\n#define OFFS(_n)\t#_n, offsetof(GF_TXTIn, _n)\n\nstatic const GF_FilterArgs TXTInArgs[] =\n{\n\t{ OFFS(webvtt), \"force WebVTT import of SRT files\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(nodefbox), \"skip default text box\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(noflush), \"skip final sample flush for srt\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(fontname), \"default font to use\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(fontsize), \"default font size\", GF_PROP_UINT, \"18\", NULL, 0},\n\t{ OFFS(lang), \"default language to use\", GF_PROP_STRING, NULL, NULL, 0},\n\t{ OFFS(width), \"default width of text area, set to 0 to resolve against visual PIDs\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(height), \"default height of text area, set to 0 to resolve against visual PIDs\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txtx), \"default horizontal offset of text area: -1 (left), 0 (center) or 1 (right)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(txty), \"default vertical offset of text area: -1 (bottom), 0 (center) or 1 (top)\", GF_PROP_UINT, \"0\", NULL, 0},\n\t{ OFFS(zorder), \"default z-order of the PID\", GF_PROP_SINT, \"0\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(timescale), \"default timescale of the PID\", GF_PROP_UINT, \"1000\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_dur), \"force single sample mode - see filter help\", GF_PROP_SINT, \"-1\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_embed), \"force embedding TTML resources - see filter help\", GF_PROP_BOOL, \"false\", NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{ OFFS(ttml_zero), \"set subtitle zero time for TTML - see filter help\", GF_PROP_STRING, NULL, NULL, GF_FS_ARG_HINT_ADVANCED},\n\t{0}\n};\n\nGF_FilterRegister TXTInRegister = {\n\t.name = \"txtin\",\n\tGF_FS_SET_DESCRIPTION(\"Subtitle loader\")\n\tGF_FS_SET_HELP(\"This filter reads subtitle data from input file PID to produce subtitle frames on a single PID.\\n\"\n\t\"The filter supports the following formats:\\n\"\n\t\"- SRT: https://en.wikipedia.org/wiki/SubRip\\n\"\n\t\"- WebVTT: https://www.w3.org/TR/webvtt1/\\n\"\n\t\"- TTXT: https://wiki.gpac.io/TTXT-Format-Documentation\\n\"\n\t\"- QT 3GPP Text XML (TexML): Apple QT6, likely deprecated\\n\"\n\t\"- TTML: https://www.w3.org/TR/ttml2/\\n\"\n\t\"- SUB: one subtitle per line formatted as `{start_frame}{end_frame}text`\\n\"\n\t\"\\n\"\n\t\"Input files must be in UTF-8 or UTF-16 format, with or without BOM.\\n\"\n\t\"The internal frame format is: \\n\"\n\t\"- WebVTT (and srt if desired): ISO/IEC 14496-30 VTT cues\\n\"\n\t\"- TTML: ISO/IEC 14496-30 XML subtitles\\n\"\n\t\"- Others: 3GPP/QT Timed Text\\n\"\n\t\"\\n\"\n\t\"# TTML Support\\n\"\n\t\"The [-ttml_dur]() option controls how TTML are split into packets:\\n\"\n\t\"- if negative (default), TTML document is split in independent time segments by inspecting all overlapping subtitles in the body\\n\"\n\t\"- if 0, the input document is not split, forwarded as a single frame with `CTS` matching the first active time in document and a duration equal to the document duration\\n\"\n\t\"- if >0, the input document is not split, forwarded as a single frame with `CTS=0` and the specified duration in `timescale` units.\\n\"\n\t\"\\n\"\n\t\"By default, media resources are kept as declared in TTML2 documents.\\n\"\n\t\"[-ttml_embed]() can be used to embed inside the TTML sample the resources in `<head>` or `<body>`.\\n\"\n\t\"- for `<source>`, `<image>`, `<audio>`, `<font>`, local URIs indicated in `src` will be loaded and `src` rewritten.\\n\"\n\t\"- for `<data>` with base64 coding, the data will be decoded, `<data>` element removed and parent <source> rewritten with `src` attribute inserted.\\n\"\n\t\"\\nThe embedded data is added as a subsample to the TTML frame, and the referring elements will use `src=urn:mpeg:14496-30:N` with `N` the index of the subsample.\\n\"\n\t\"\\n\"\n\t\"A `subtitle zero` may be specified using [-ttml_zero](). This will remove all subtitles before the given time `T0`, and rewrite each subtitle begin/end `T` to `T-T0` using millisecond accuracy.\\n\"\n\t\"Warning: Original time formatting (tick, frames/subframe ...) will be lost when this option is used, converted to `HH:MM:SS.ms`.\\n\"\n\t\"\\n\"\n\t\"The subtitle zero time **must** be prefixed with `T` when the option is not set as a global argument:\\n\"\n\t\"EX gpac -i test.ttml:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml:sopt:ttml_zero=T10:00:00 [...]\\n\"\n\t\"EX gpac -i test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\t\"EX MP4Box -add test.ttml --ttml_zero=10:00:00 [...]\\n\"\n\n\n\n\t)\n\n\t.private_size = sizeof(GF_TXTIn),\n\t.flags = GF_FS_REG_MAIN_THREAD,\n\t.args = TXTInArgs,\n\tSETCAPS(TXTInCaps),\n\t.process = txtin_process,\n\t.configure_pid = txtin_configure_pid,\n\t.process_event = txtin_process_event,\n\t.probe_data = txtin_probe_data,\n\t.initialize = txtin_initialize,\n\t.finalize = txtin_finalize\n};\n\n\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn &TXTInRegister;\n}\n\n\n#else\nconst GF_FilterRegister *txtin_register(GF_FilterSession *session)\n{\n\treturn NULL;\n}\n#endif // GPAC_DISABLE_ISOM_WRITE\n\n"], "filenames": ["src/filters/load_text.c"], "buggy_code_start_loc": [258], "buggy_code_end_loc": [2340], "fixing_code_start_loc": [258], "fixing_code_end_loc": [2343], "type": "CWE-415", "message": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.", "other": {"cve": {"id": "CVE-2021-40574", "sourceIdentifier": "cve@mitre.org", "published": "2022-01-13T19:15:08.317", "lastModified": "2023-05-27T04:15:17.057", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges."}, {"lang": "es", "value": "El binario MP4Box en Gpac versi\u00f3n 1.0.1, presenta una vulnerabilidad de doble liberaci\u00f3n en la funci\u00f3n gf_text_get_utf8_line en el archivo load_text.c, que permite a atacantes causar una denegaci\u00f3n de servicio, incluso ejecuci\u00f3n de c\u00f3digo y escalada de privilegios"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-415"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:1.0.1:*:*:*:*:*:*:*", "matchCriteriaId": "82DD2D40-0A05-48FD-940D-32B4D8B51AB3"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/30ac5e5236b790accd1f25347eebf2dc8c6c1bcb", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/gpac/gpac/issues/1897", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/30ac5e5236b790accd1f25347eebf2dc8c6c1bcb"}}