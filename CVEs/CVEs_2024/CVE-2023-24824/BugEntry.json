{"buggy_code": ["#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define CMARK_NO_SHORT_NAMES\n#include \"cmark-gfm.h\"\n#include \"node.h\"\n#include \"../extensions/cmark-gfm-core-extensions.h\"\n\n#include \"harness.h\"\n#include \"cplusplus.h\"\n\n#define UTF8_REPL \"\\xEF\\xBF\\xBD\"\n\nstatic const cmark_node_type node_types[] = {\n    CMARK_NODE_DOCUMENT,  CMARK_NODE_BLOCK_QUOTE, CMARK_NODE_LIST,\n    CMARK_NODE_ITEM,      CMARK_NODE_CODE_BLOCK,  CMARK_NODE_HTML_BLOCK,\n    CMARK_NODE_PARAGRAPH, CMARK_NODE_HEADING,     CMARK_NODE_THEMATIC_BREAK,\n    CMARK_NODE_TEXT,      CMARK_NODE_SOFTBREAK,   CMARK_NODE_LINEBREAK,\n    CMARK_NODE_CODE,      CMARK_NODE_HTML_INLINE, CMARK_NODE_EMPH,\n    CMARK_NODE_STRONG,    CMARK_NODE_LINK,        CMARK_NODE_IMAGE};\nstatic const int num_node_types = sizeof(node_types) / sizeof(*node_types);\n\nstatic void test_md_to_html(test_batch_runner *runner, const char *markdown,\n                            const char *expected_html, const char *msg);\n\nstatic void test_content(test_batch_runner *runner, cmark_node_type type,\n                         unsigned int *allowed_content);\n\nstatic void test_char(test_batch_runner *runner, int valid, const char *utf8,\n                      const char *msg);\n\nstatic void test_incomplete_char(test_batch_runner *runner, const char *utf8,\n                                 const char *msg);\n\nstatic void test_continuation_byte(test_batch_runner *runner, const char *utf8);\n\nstatic void version(test_batch_runner *runner) {\n  INT_EQ(runner, cmark_version(), CMARK_GFM_VERSION, \"cmark_version\");\n  STR_EQ(runner, cmark_version_string(), CMARK_GFM_VERSION_STRING,\n         \"cmark_version_string\");\n}\n\nstatic void constructor(test_batch_runner *runner) {\n  for (int i = 0; i < num_node_types; ++i) {\n    cmark_node_type type = node_types[i];\n    cmark_node *node = cmark_node_new(type);\n    OK(runner, node != NULL, \"new type %d\", type);\n    INT_EQ(runner, cmark_node_get_type(node), type, \"get_type %d\", type);\n\n    switch (node->type) {\n    case CMARK_NODE_HEADING:\n      INT_EQ(runner, cmark_node_get_heading_level(node), 1,\n             \"default heading level is 1\");\n      node->as.heading.level = 1;\n      break;\n\n    case CMARK_NODE_LIST:\n      INT_EQ(runner, cmark_node_get_list_type(node), CMARK_BULLET_LIST,\n             \"default is list type is bullet\");\n      INT_EQ(runner, cmark_node_get_list_delim(node), CMARK_NO_DELIM,\n             \"default is list delim is NO_DELIM\");\n      INT_EQ(runner, cmark_node_get_list_start(node), 0,\n             \"default is list start is 0\");\n      INT_EQ(runner, cmark_node_get_list_tight(node), 0,\n             \"default is list is loose\");\n      break;\n\n    default:\n      break;\n    }\n\n    cmark_node_free(node);\n  }\n}\n\nstatic void accessors(test_batch_runner *runner) {\n  static const char markdown[] = \"## Header\\n\"\n                                 \"\\n\"\n                                 \"* Item 1\\n\"\n                                 \"* Item 2\\n\"\n                                 \"\\n\"\n                                 \"2. Item 1\\n\"\n                                 \"\\n\"\n                                 \"3. Item 2\\n\"\n                                 \"\\n\"\n                                 \"``` lang\\n\"\n                                 \"fenced\\n\"\n                                 \"```\\n\"\n                                 \"    code\\n\"\n                                 \"\\n\"\n                                 \"<div>html</div>\\n\"\n                                 \"\\n\"\n                                 \"[link](url 'title')\\n\";\n\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  // Getters\n\n  cmark_node *heading = cmark_node_first_child(doc);\n  INT_EQ(runner, cmark_node_get_heading_level(heading), 2, \"get_heading_level\");\n\n  cmark_node *bullet_list = cmark_node_next(heading);\n  INT_EQ(runner, cmark_node_get_list_type(bullet_list), CMARK_BULLET_LIST,\n         \"get_list_type bullet\");\n  INT_EQ(runner, cmark_node_get_list_tight(bullet_list), 1,\n         \"get_list_tight tight\");\n\n  cmark_node *ordered_list = cmark_node_next(bullet_list);\n  INT_EQ(runner, cmark_node_get_list_type(ordered_list), CMARK_ORDERED_LIST,\n         \"get_list_type ordered\");\n  INT_EQ(runner, cmark_node_get_list_delim(ordered_list), CMARK_PERIOD_DELIM,\n         \"get_list_delim ordered\");\n  INT_EQ(runner, cmark_node_get_list_start(ordered_list), 2, \"get_list_start\");\n  INT_EQ(runner, cmark_node_get_list_tight(ordered_list), 0,\n         \"get_list_tight loose\");\n\n  cmark_node *fenced = cmark_node_next(ordered_list);\n  STR_EQ(runner, cmark_node_get_literal(fenced), \"fenced\\n\",\n         \"get_literal fenced code\");\n  STR_EQ(runner, cmark_node_get_fence_info(fenced), \"lang\", \"get_fence_info\");\n\n  cmark_node *code = cmark_node_next(fenced);\n  STR_EQ(runner, cmark_node_get_literal(code), \"code\\n\",\n         \"get_literal indented code\");\n\n  cmark_node *html = cmark_node_next(code);\n  STR_EQ(runner, cmark_node_get_literal(html), \"<div>html</div>\\n\",\n         \"get_literal html\");\n\n  cmark_node *paragraph = cmark_node_next(html);\n  INT_EQ(runner, cmark_node_get_start_line(paragraph), 17, \"get_start_line\");\n  INT_EQ(runner, cmark_node_get_start_column(paragraph), 1, \"get_start_column\");\n  INT_EQ(runner, cmark_node_get_end_line(paragraph), 17, \"get_end_line\");\n\n  cmark_node *link = cmark_node_first_child(paragraph);\n  STR_EQ(runner, cmark_node_get_url(link), \"url\", \"get_url\");\n  STR_EQ(runner, cmark_node_get_title(link), \"title\", \"get_title\");\n\n  cmark_node *string = cmark_node_first_child(link);\n  STR_EQ(runner, cmark_node_get_literal(string), \"link\", \"get_literal string\");\n\n  // Setters\n\n  OK(runner, cmark_node_set_heading_level(heading, 3), \"set_heading_level\");\n\n  OK(runner, cmark_node_set_list_type(bullet_list, CMARK_ORDERED_LIST),\n     \"set_list_type ordered\");\n  OK(runner, cmark_node_set_list_delim(bullet_list, CMARK_PAREN_DELIM),\n     \"set_list_delim paren\");\n  OK(runner, cmark_node_set_list_start(bullet_list, 3), \"set_list_start\");\n  OK(runner, cmark_node_set_list_tight(bullet_list, 0), \"set_list_tight loose\");\n\n  OK(runner, cmark_node_set_list_type(ordered_list, CMARK_BULLET_LIST),\n     \"set_list_type bullet\");\n  OK(runner, cmark_node_set_list_tight(ordered_list, 1),\n     \"set_list_tight tight\");\n\n  OK(runner, cmark_node_set_literal(code, \"CODE\\n\"),\n     \"set_literal indented code\");\n\n  OK(runner, cmark_node_set_literal(fenced, \"FENCED\\n\"),\n     \"set_literal fenced code\");\n  OK(runner, cmark_node_set_fence_info(fenced, \"LANG\"), \"set_fence_info\");\n\n  OK(runner, cmark_node_set_literal(html, \"<div>HTML</div>\\n\"),\n     \"set_literal html\");\n\n  OK(runner, cmark_node_set_url(link, \"URL\"), \"set_url\");\n  OK(runner, cmark_node_set_title(link, \"TITLE\"), \"set_title\");\n\n  OK(runner, cmark_node_set_literal(string, \"prefix-LINK\"),\n     \"set_literal string\");\n\n  // Set literal to suffix of itself (issue #139).\n  const char *literal = cmark_node_get_literal(string);\n  OK(runner, cmark_node_set_literal(string, literal + sizeof(\"prefix\")),\n     \"set_literal suffix\");\n\n  char *rendered_html = cmark_render_html(doc, CMARK_OPT_DEFAULT | CMARK_OPT_UNSAFE, NULL);\n  static const char expected_html[] =\n      \"<h3>Header</h3>\\n\"\n      \"<ol start=\\\"3\\\">\\n\"\n      \"<li>\\n\"\n      \"<p>Item 1</p>\\n\"\n      \"</li>\\n\"\n      \"<li>\\n\"\n      \"<p>Item 2</p>\\n\"\n      \"</li>\\n\"\n      \"</ol>\\n\"\n      \"<ul>\\n\"\n      \"<li>Item 1</li>\\n\"\n      \"<li>Item 2</li>\\n\"\n      \"</ul>\\n\"\n      \"<pre><code class=\\\"language-LANG\\\">FENCED\\n\"\n      \"</code></pre>\\n\"\n      \"<pre><code>CODE\\n\"\n      \"</code></pre>\\n\"\n      \"<div>HTML</div>\\n\"\n      \"<p><a href=\\\"URL\\\" title=\\\"TITLE\\\">LINK</a></p>\\n\";\n  STR_EQ(runner, rendered_html, expected_html, \"setters work\");\n  free(rendered_html);\n\n  // Getter errors\n\n  INT_EQ(runner, cmark_node_get_heading_level(bullet_list), 0,\n         \"get_heading_level error\");\n  INT_EQ(runner, cmark_node_get_list_type(heading), CMARK_NO_LIST,\n         \"get_list_type error\");\n  INT_EQ(runner, cmark_node_get_list_start(code), 0, \"get_list_start error\");\n  INT_EQ(runner, cmark_node_get_list_tight(fenced), 0, \"get_list_tight error\");\n  OK(runner, cmark_node_get_literal(ordered_list) == NULL, \"get_literal error\");\n  OK(runner, cmark_node_get_fence_info(paragraph) == NULL,\n     \"get_fence_info error\");\n  OK(runner, cmark_node_get_url(html) == NULL, \"get_url error\");\n  OK(runner, cmark_node_get_title(heading) == NULL, \"get_title error\");\n\n  // Setter errors\n\n  OK(runner, !cmark_node_set_heading_level(bullet_list, 3),\n     \"set_heading_level error\");\n  OK(runner, !cmark_node_set_list_type(heading, CMARK_ORDERED_LIST),\n     \"set_list_type error\");\n  OK(runner, !cmark_node_set_list_start(code, 3), \"set_list_start error\");\n  OK(runner, !cmark_node_set_list_tight(fenced, 0), \"set_list_tight error\");\n  OK(runner, !cmark_node_set_literal(ordered_list, \"content\\n\"),\n     \"set_literal error\");\n  OK(runner, !cmark_node_set_fence_info(paragraph, \"lang\"),\n     \"set_fence_info error\");\n  OK(runner, !cmark_node_set_url(html, \"url\"), \"set_url error\");\n  OK(runner, !cmark_node_set_title(heading, \"title\"), \"set_title error\");\n\n  OK(runner, !cmark_node_set_heading_level(heading, 0),\n     \"set_heading_level too small\");\n  OK(runner, !cmark_node_set_heading_level(heading, 7),\n     \"set_heading_level too large\");\n  OK(runner, !cmark_node_set_list_type(bullet_list, CMARK_NO_LIST),\n     \"set_list_type invalid\");\n  OK(runner, !cmark_node_set_list_start(bullet_list, -1),\n     \"set_list_start negative\");\n\n  cmark_node_free(doc);\n}\n\nstatic void node_check(test_batch_runner *runner) {\n  // Construct an incomplete tree.\n  cmark_node *doc = cmark_node_new(CMARK_NODE_DOCUMENT);\n  cmark_node *p1 = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  cmark_node *p2 = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  doc->first_child = p1;\n  p1->next = p2;\n\n  INT_EQ(runner, cmark_node_check(doc, NULL), 4, \"node_check works\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"node_check fixes tree\");\n\n  cmark_node_free(doc);\n}\n\nstatic void iterator(test_batch_runner *runner) {\n  cmark_node *doc = cmark_parse_document(\"> a *b*\\n\\nc\", 10, CMARK_OPT_DEFAULT);\n  int parnodes = 0;\n  cmark_event_type ev_type;\n  cmark_iter *iter = cmark_iter_new(doc);\n  cmark_node *cur;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (cur->type == CMARK_NODE_PARAGRAPH && ev_type == CMARK_EVENT_ENTER) {\n      parnodes += 1;\n    }\n  }\n  INT_EQ(runner, parnodes, 2, \"iterate correctly counts paragraphs\");\n\n  cmark_iter_free(iter);\n  cmark_node_free(doc);\n}\n\nstatic void iterator_delete(test_batch_runner *runner) {\n  static const char md[] = \"a *b* c\\n\"\n                           \"\\n\"\n                           \"* item1\\n\"\n                           \"* item2\\n\"\n                           \"\\n\"\n                           \"a `b` c\\n\"\n                           \"\\n\"\n                           \"* item1\\n\"\n                           \"* item2\\n\";\n  cmark_node *doc = cmark_parse_document(md, sizeof(md) - 1, CMARK_OPT_DEFAULT);\n  cmark_iter *iter = cmark_iter_new(doc);\n  cmark_event_type ev_type;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cmark_node *node = cmark_iter_get_node(iter);\n    // Delete list, emph, and code nodes.\n    if ((ev_type == CMARK_EVENT_EXIT && node->type == CMARK_NODE_LIST) ||\n        (ev_type == CMARK_EVENT_EXIT && node->type == CMARK_NODE_EMPH) ||\n        (ev_type == CMARK_EVENT_ENTER && node->type == CMARK_NODE_CODE)) {\n      cmark_node_free(node);\n    }\n  }\n\n  char *html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  static const char expected[] = \"<p>a  c</p>\\n\"\n                                 \"<p>a  c</p>\\n\";\n  STR_EQ(runner, html, expected, \"iterate and delete nodes\");\n\n  free(html);\n  cmark_iter_free(iter);\n  cmark_node_free(doc);\n}\n\nstatic void create_tree(test_batch_runner *runner) {\n  char *html;\n  cmark_node *doc = cmark_node_new(CMARK_NODE_DOCUMENT);\n\n  cmark_node *p = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  OK(runner, !cmark_node_insert_before(doc, p), \"insert before root fails\");\n  OK(runner, !cmark_node_insert_after(doc, p), \"insert after root fails\");\n  OK(runner, cmark_node_append_child(doc, p), \"append1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"append1 consistent\");\n  OK(runner, cmark_node_parent(p) == doc, \"node_parent\");\n\n  cmark_node *emph = cmark_node_new(CMARK_NODE_EMPH);\n  OK(runner, cmark_node_prepend_child(p, emph), \"prepend1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"prepend1 consistent\");\n\n  cmark_node *str1 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str1, \"Hello, \");\n  OK(runner, cmark_node_prepend_child(p, str1), \"prepend2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"prepend2 consistent\");\n\n  cmark_node *str3 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str3, \"!\");\n  OK(runner, cmark_node_append_child(p, str3), \"append2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"append2 consistent\");\n\n  cmark_node *str2 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str2, \"world\");\n  OK(runner, cmark_node_append_child(emph, str2), \"append3\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"append3 consistent\");\n\n  html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p>Hello, <em>world</em>!</p>\\n\", \"render_html\");\n  free(html);\n\n  OK(runner, cmark_node_insert_before(str1, str3), \"ins before1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins before1 consistent\");\n  // 31e\n  OK(runner, cmark_node_first_child(p) == str3, \"ins before1 works\");\n\n  OK(runner, cmark_node_insert_before(str1, emph), \"ins before2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins before2 consistent\");\n  // 3e1\n  OK(runner, cmark_node_last_child(p) == str1, \"ins before2 works\");\n\n  OK(runner, cmark_node_insert_after(str1, str3), \"ins after1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins after1 consistent\");\n  // e13\n  OK(runner, cmark_node_next(str1) == str3, \"ins after1 works\");\n\n  OK(runner, cmark_node_insert_after(str1, emph), \"ins after2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins after2 consistent\");\n  // 1e3\n  OK(runner, cmark_node_previous(emph) == str1, \"ins after2 works\");\n\n  cmark_node *str4 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str4, \"brzz\");\n  OK(runner, cmark_node_replace(str1, str4), \"replace\");\n  // The replaced node is not freed\n  cmark_node_free(str1);\n\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"replace consistent\");\n  OK(runner, cmark_node_previous(emph) == str4, \"replace works\");\n  INT_EQ(runner, cmark_node_replace(p, str4), 0, \"replace str for p fails\");\n\n  cmark_node_unlink(emph);\n\n  html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p>brzz!</p>\\n\", \"render_html after shuffling\");\n  free(html);\n\n  cmark_node_free(doc);\n\n  // TODO: Test that the contents of an unlinked inline are valid\n  // after the parent block was destroyed. This doesn't work so far.\n  cmark_node_free(emph);\n}\n\nstatic void custom_nodes(test_batch_runner *runner) {\n  char *html;\n  char *man;\n  cmark_node *doc = cmark_node_new(CMARK_NODE_DOCUMENT);\n  cmark_node *p = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  cmark_node_append_child(doc, p);\n  cmark_node *ci = cmark_node_new(CMARK_NODE_CUSTOM_INLINE);\n  cmark_node *str1 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str1, \"Hello\");\n  OK(runner, cmark_node_append_child(ci, str1), \"append1\");\n  OK(runner, cmark_node_set_on_enter(ci, \"<ON ENTER|\"), \"set_on_enter\");\n  OK(runner, cmark_node_set_on_exit(ci, \"|ON EXIT>\"), \"set_on_exit\");\n  STR_EQ(runner, cmark_node_get_on_enter(ci), \"<ON ENTER|\", \"get_on_enter\");\n  STR_EQ(runner, cmark_node_get_on_exit(ci), \"|ON EXIT>\", \"get_on_exit\");\n  cmark_node_append_child(p, ci);\n  cmark_node *cb = cmark_node_new(CMARK_NODE_CUSTOM_BLOCK);\n  cmark_node_set_on_enter(cb, \"<on enter|\");\n  // leave on_exit unset\n  STR_EQ(runner, cmark_node_get_on_exit(cb), \"\", \"get_on_exit (empty)\");\n  cmark_node_append_child(doc, cb);\n\n  html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p><ON ENTER|Hello|ON EXIT></p>\\n<on enter|\\n\",\n         \"render_html\");\n  free(html);\n\n  man = cmark_render_man(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, man, \".PP\\n<ON ENTER|Hello|ON EXIT>\\n<on enter|\\n\",\n         \"render_man\");\n  free(man);\n\n  cmark_node_free(doc);\n}\n\nvoid hierarchy(test_batch_runner *runner) {\n  cmark_node *bquote1 = cmark_node_new(CMARK_NODE_BLOCK_QUOTE);\n  cmark_node *bquote2 = cmark_node_new(CMARK_NODE_BLOCK_QUOTE);\n  cmark_node *bquote3 = cmark_node_new(CMARK_NODE_BLOCK_QUOTE);\n\n  OK(runner, cmark_node_append_child(bquote1, bquote2), \"append bquote2\");\n  OK(runner, cmark_node_append_child(bquote2, bquote3), \"append bquote3\");\n  OK(runner, !cmark_node_append_child(bquote3, bquote3),\n     \"adding a node as child of itself fails\");\n  OK(runner, !cmark_node_append_child(bquote3, bquote1),\n     \"adding a parent as child fails\");\n\n  cmark_node_free(bquote1);\n\n  unsigned int list_item_flag[] = {CMARK_NODE_ITEM, 0};\n  unsigned int top_level_blocks[] = {\n    CMARK_NODE_BLOCK_QUOTE, CMARK_NODE_LIST,\n    CMARK_NODE_CODE_BLOCK, CMARK_NODE_HTML_BLOCK,\n    CMARK_NODE_PARAGRAPH, CMARK_NODE_HEADING,\n    CMARK_NODE_THEMATIC_BREAK, 0};\n  unsigned int all_inlines[] = {\n    CMARK_NODE_TEXT, CMARK_NODE_SOFTBREAK,\n    CMARK_NODE_LINEBREAK, CMARK_NODE_CODE,\n    CMARK_NODE_HTML_INLINE, CMARK_NODE_EMPH,\n    CMARK_NODE_STRONG, CMARK_NODE_LINK,\n    CMARK_NODE_IMAGE, 0};\n\n  test_content(runner, CMARK_NODE_DOCUMENT, top_level_blocks);\n  test_content(runner, CMARK_NODE_BLOCK_QUOTE, top_level_blocks);\n  test_content(runner, CMARK_NODE_LIST, list_item_flag);\n  test_content(runner, CMARK_NODE_ITEM, top_level_blocks);\n  test_content(runner, CMARK_NODE_CODE_BLOCK, 0);\n  test_content(runner, CMARK_NODE_HTML_BLOCK, 0);\n  test_content(runner, CMARK_NODE_PARAGRAPH, all_inlines);\n  test_content(runner, CMARK_NODE_HEADING, all_inlines);\n  test_content(runner, CMARK_NODE_THEMATIC_BREAK, 0);\n  test_content(runner, CMARK_NODE_TEXT, 0);\n  test_content(runner, CMARK_NODE_SOFTBREAK, 0);\n  test_content(runner, CMARK_NODE_LINEBREAK, 0);\n  test_content(runner, CMARK_NODE_CODE, 0);\n  test_content(runner, CMARK_NODE_HTML_INLINE, 0);\n  test_content(runner, CMARK_NODE_EMPH, all_inlines);\n  test_content(runner, CMARK_NODE_STRONG, all_inlines);\n  test_content(runner, CMARK_NODE_LINK, all_inlines);\n  test_content(runner, CMARK_NODE_IMAGE, all_inlines);\n}\n\nstatic void test_content(test_batch_runner *runner, cmark_node_type type,\n                         unsigned int *allowed_content) {\n  cmark_node *node = cmark_node_new(type);\n\n  for (int i = 0; i < num_node_types; ++i) {\n    cmark_node_type child_type = node_types[i];\n    cmark_node *child = cmark_node_new(child_type);\n\n    int got = cmark_node_append_child(node, child);\n    int expected = 0;\n    if (allowed_content)\n        for (unsigned int *p = allowed_content; *p; ++p)\n            expected |= *p == (unsigned int)child_type;\n\n    INT_EQ(runner, got, expected, \"add %d as child of %d\", child_type, type);\n\n    cmark_node_free(child);\n  }\n\n  cmark_node_free(node);\n}\n\nstatic void parser(test_batch_runner *runner) {\n  test_md_to_html(runner, \"No newline\", \"<p>No newline</p>\\n\",\n                  \"document without trailing newline\");\n}\n\nstatic void render_html(test_batch_runner *runner) {\n  char *html;\n\n  static const char markdown[] = \"foo *bar*\\n\"\n                                 \"\\n\"\n                                 \"paragraph 2\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  cmark_node *paragraph = cmark_node_first_child(doc);\n  html = cmark_render_html(paragraph, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p>foo <em>bar</em></p>\\n\", \"render single paragraph\");\n  free(html);\n\n  cmark_node *string = cmark_node_first_child(paragraph);\n  html = cmark_render_html(string, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"foo \", \"render single inline\");\n  free(html);\n\n  cmark_node *emph = cmark_node_next(string);\n  html = cmark_render_html(emph, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<em>bar</em>\", \"render inline with children\");\n  free(html);\n\n  cmark_node_free(doc);\n}\n\nstatic void render_xml(test_batch_runner *runner) {\n  char *xml;\n\n  static const char markdown[] = \"foo *bar*\\n\"\n                                 \"\\n\"\n                                 \"paragraph 2\\n\"\n                                 \"\\n\"\n                                 \"```\\ncode\\n```\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<document xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                      \"  <paragraph>\\n\"\n                      \"    <text xml:space=\\\"preserve\\\">foo </text>\\n\"\n                      \"    <emph>\\n\"\n                      \"      <text xml:space=\\\"preserve\\\">bar</text>\\n\"\n                      \"    </emph>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"  <paragraph>\\n\"\n                      \"    <text xml:space=\\\"preserve\\\">paragraph 2</text>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"  <code_block xml:space=\\\"preserve\\\">code\\n\"\n                      \"</code_block>\\n\"\n                      \"</document>\\n\",\n         \"render document\");\n  free(xml);\n  cmark_node *paragraph = cmark_node_first_child(doc);\n  xml = cmark_render_xml(paragraph, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<paragraph sourcepos=\\\"1:1-1:9\\\">\\n\"\n                      \"  <text sourcepos=\\\"1:1-1:4\\\" xml:space=\\\"preserve\\\">foo </text>\\n\"\n                      \"  <emph sourcepos=\\\"1:5-1:9\\\">\\n\"\n                      \"    <text sourcepos=\\\"1:6-1:8\\\" xml:space=\\\"preserve\\\">bar</text>\\n\"\n                      \"  </emph>\\n\"\n                      \"</paragraph>\\n\",\n         \"render first paragraph with source pos\");\n  free(xml);\n  cmark_node_free(doc);\n}\n\nstatic void render_man(test_batch_runner *runner) {\n  char *man;\n\n  static const char markdown[] = \"foo *bar*\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  man = cmark_render_man(doc, CMARK_OPT_DEFAULT, 20);\n  STR_EQ(runner, man, \".PP\\n\"\n                      \"foo \\\\f[I]bar\\\\f[]\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"Lorem ipsum dolor\\n\"\n                      \"sit amet,\\n\"\n                      \"consectetur\\n\"\n                      \"adipiscing elit,\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"sed do eiusmod\\n\"\n                      \"tempor incididunt ut\\n\"\n                      \"labore et dolore\\n\"\n                      \"magna aliqua.\\n\",\n         \"render document with wrapping\");\n  free(man);\n  man = cmark_render_man(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, man, \".PP\\n\"\n                      \"foo \\\\f[I]bar\\\\f[]\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"Lorem ipsum dolor sit amet,\\n\"\n                      \"consectetur adipiscing elit,\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"sed do eiusmod tempor incididunt\\n\"\n                      \"ut labore et dolore magna aliqua.\\n\",\n         \"render document without wrapping\");\n  free(man);\n  cmark_node_free(doc);\n}\n\nstatic void render_latex(test_batch_runner *runner) {\n  char *latex;\n\n  static const char markdown[] = \"foo *bar* $%\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  latex = cmark_render_latex(doc, CMARK_OPT_DEFAULT, 20);\n  STR_EQ(runner, latex, \"foo \\\\emph{bar} \\\\$\\\\%\\n\"\n                        \"\\n\"\n                        \"\\\\begin{itemize}\\n\"\n                        \"\\\\item Lorem ipsum\\n\"\n                        \"dolor sit amet,\\n\"\n                        \"consectetur\\n\"\n                        \"adipiscing elit,\\n\"\n                        \"\\n\"\n                        \"\\\\item sed do eiusmod\\n\"\n                        \"tempor incididunt ut\\n\"\n                        \"labore et dolore\\n\"\n                        \"magna aliqua.\\n\"\n                        \"\\n\"\n                        \"\\\\end{itemize}\\n\",\n         \"render document with wrapping\");\n  free(latex);\n  latex = cmark_render_latex(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, latex, \"foo \\\\emph{bar} \\\\$\\\\%\\n\"\n                        \"\\n\"\n                        \"\\\\begin{itemize}\\n\"\n                        \"\\\\item Lorem ipsum dolor sit amet,\\n\"\n                        \"consectetur adipiscing elit,\\n\"\n                        \"\\n\"\n                        \"\\\\item sed do eiusmod tempor incididunt\\n\"\n                        \"ut labore et dolore magna aliqua.\\n\"\n                        \"\\n\"\n                        \"\\\\end{itemize}\\n\",\n         \"render document without wrapping\");\n  free(latex);\n  cmark_node_free(doc);\n}\n\nstatic void render_commonmark(test_batch_runner *runner) {\n  char *commonmark;\n\n  static const char markdown[] = \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  commonmark = cmark_render_commonmark(doc, CMARK_OPT_DEFAULT, 26);\n  STR_EQ(runner, commonmark, \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit\\n\"\n                             \"    amet, consectetur\\n\"\n                             \"    adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor\\n\"\n                             \"    incididunt ut labore\\n\"\n                             \"    et dolore magna\\n\"\n                             \"    aliqua.\\n\",\n         \"render document with wrapping\");\n  free(commonmark);\n  commonmark = cmark_render_commonmark(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, commonmark, \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit amet,\\n\"\n                             \"    consectetur adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor incididunt\\n\"\n                             \"    ut labore et dolore magna aliqua.\\n\",\n         \"render document without wrapping\");\n  free(commonmark);\n\n  cmark_node *text = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(text, \"Hi\");\n  commonmark = cmark_render_commonmark(text, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, commonmark, \"Hi\\n\", \"render single inline node\");\n  free(commonmark);\n\n  cmark_node_free(text);\n  cmark_node_free(doc);\n}\n\nstatic void render_plaintext(test_batch_runner *runner) {\n  char *plaintext;\n\n  static const char markdown[] = \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  plaintext = cmark_render_plaintext(doc, CMARK_OPT_DEFAULT, 26);\n  STR_EQ(runner, plaintext, \"- foo bar *bar*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit\\n\"\n                             \"    amet, consectetur\\n\"\n                             \"    adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor\\n\"\n                             \"    incididunt ut labore\\n\"\n                             \"    et dolore magna\\n\"\n                             \"    aliqua.\\n\",\n         \"render document with wrapping\");\n  free(plaintext);\n  plaintext = cmark_render_plaintext(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, plaintext, \"- foo bar *bar*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit amet,\\n\"\n                             \"    consectetur adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor incididunt\\n\"\n                             \"    ut labore et dolore magna aliqua.\\n\",\n         \"render document without wrapping\");\n  free(plaintext);\n\n  cmark_node *text = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(text, \"Hi\");\n  plaintext = cmark_render_plaintext(text, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, plaintext, \"Hi\\n\", \"render single inline node\");\n  free(plaintext);\n\n  cmark_node_free(text);\n  cmark_node_free(doc);\n}\n\nstatic void utf8(test_batch_runner *runner) {\n  // Ranges\n  test_char(runner, 1, \"\\x01\", \"valid utf8 01\");\n  test_char(runner, 1, \"\\x7F\", \"valid utf8 7F\");\n  test_char(runner, 0, \"\\x80\", \"invalid utf8 80\");\n  test_char(runner, 0, \"\\xBF\", \"invalid utf8 BF\");\n  test_char(runner, 0, \"\\xC0\\x80\", \"invalid utf8 C080\");\n  test_char(runner, 0, \"\\xC1\\xBF\", \"invalid utf8 C1BF\");\n  test_char(runner, 1, \"\\xC2\\x80\", \"valid utf8 C280\");\n  test_char(runner, 1, \"\\xDF\\xBF\", \"valid utf8 DFBF\");\n  test_char(runner, 0, \"\\xE0\\x80\\x80\", \"invalid utf8 E08080\");\n  test_char(runner, 0, \"\\xE0\\x9F\\xBF\", \"invalid utf8 E09FBF\");\n  test_char(runner, 1, \"\\xE0\\xA0\\x80\", \"valid utf8 E0A080\");\n  test_char(runner, 1, \"\\xED\\x9F\\xBF\", \"valid utf8 ED9FBF\");\n  test_char(runner, 0, \"\\xED\\xA0\\x80\", \"invalid utf8 EDA080\");\n  test_char(runner, 0, \"\\xED\\xBF\\xBF\", \"invalid utf8 EDBFBF\");\n  test_char(runner, 0, \"\\xF0\\x80\\x80\\x80\", \"invalid utf8 F0808080\");\n  test_char(runner, 0, \"\\xF0\\x8F\\xBF\\xBF\", \"invalid utf8 F08FBFBF\");\n  test_char(runner, 1, \"\\xF0\\x90\\x80\\x80\", \"valid utf8 F0908080\");\n  test_char(runner, 1, \"\\xF4\\x8F\\xBF\\xBF\", \"valid utf8 F48FBFBF\");\n  test_char(runner, 0, \"\\xF4\\x90\\x80\\x80\", \"invalid utf8 F4908080\");\n  test_char(runner, 0, \"\\xF7\\xBF\\xBF\\xBF\", \"invalid utf8 F7BFBFBF\");\n  test_char(runner, 0, \"\\xF8\", \"invalid utf8 F8\");\n  test_char(runner, 0, \"\\xFF\", \"invalid utf8 FF\");\n\n  // Incomplete byte sequences at end of input\n  test_incomplete_char(runner, \"\\xE0\\xA0\", \"invalid utf8 E0A0\");\n  test_incomplete_char(runner, \"\\xF0\\x90\\x80\", \"invalid utf8 F09080\");\n\n  // Invalid continuation bytes\n  test_continuation_byte(runner, \"\\xC2\\x80\");\n  test_continuation_byte(runner, \"\\xE0\\xA0\\x80\");\n  test_continuation_byte(runner, \"\\xF0\\x90\\x80\\x80\");\n\n  // Test string containing null character\n  static const char string_with_null[] = \"((((\\0))))\";\n  char *html = cmark_markdown_to_html(\n      string_with_null, sizeof(string_with_null) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<p>((((\" UTF8_REPL \"))))</p>\\n\", \"utf8 with U+0000\");\n  free(html);\n\n  // Test NUL followed by newline\n  static const char string_with_nul_lf[] = \"```\\n\\0\\n```\\n\";\n  html = cmark_markdown_to_html(\n      string_with_nul_lf, sizeof(string_with_nul_lf) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<pre><code>\\xef\\xbf\\xbd\\n</code></pre>\\n\",\n         \"utf8 with \\\\0\\\\n\");\n  free(html);\n\n  // Test byte-order marker\n  static const char string_with_bom[] = \"\\xef\\xbb\\xbf# Hello\\n\";\n  html = cmark_markdown_to_html(\n      string_with_bom, sizeof(string_with_bom) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<h1>Hello</h1>\\n\", \"utf8 with BOM\");\n  free(html);\n}\n\nstatic void test_char(test_batch_runner *runner, int valid, const char *utf8,\n                      const char *msg) {\n  char buf[20];\n  sprintf(buf, \"((((%s))))\", utf8);\n\n  if (valid) {\n    char expected[30];\n    sprintf(expected, \"<p>((((%s))))</p>\\n\", utf8);\n    test_md_to_html(runner, buf, expected, msg);\n  } else {\n    test_md_to_html(runner, buf, \"<p>((((\" UTF8_REPL \"))))</p>\\n\", msg);\n  }\n}\n\nstatic void test_incomplete_char(test_batch_runner *runner, const char *utf8,\n                                 const char *msg) {\n  char buf[20];\n  sprintf(buf, \"----%s\", utf8);\n  test_md_to_html(runner, buf, \"<p>----\" UTF8_REPL \"</p>\\n\", msg);\n}\n\nstatic void test_continuation_byte(test_batch_runner *runner,\n                                   const char *utf8) {\n  size_t len = strlen(utf8);\n\n  for (size_t pos = 1; pos < len; ++pos) {\n    char buf[20];\n    sprintf(buf, \"((((%s))))\", utf8);\n    buf[4 + pos] = '\\x20';\n\n    char expected[50];\n    strcpy(expected, \"<p>((((\" UTF8_REPL \"\\x20\");\n    for (size_t i = pos + 1; i < len; ++i) {\n      strcat(expected, UTF8_REPL);\n    }\n    strcat(expected, \"))))</p>\\n\");\n\n    char *html =\n        cmark_markdown_to_html(buf, strlen(buf), CMARK_OPT_VALIDATE_UTF8);\n    STR_EQ(runner, html, expected, \"invalid utf8 continuation byte %d/%d\", pos,\n           len);\n    free(html);\n  }\n}\n\nstatic void line_endings(test_batch_runner *runner) {\n  // Test list with different line endings\n  static const char list_with_endings[] = \"- a\\n- b\\r\\n- c\\r- d\";\n  char *html = cmark_markdown_to_html(\n      list_with_endings, sizeof(list_with_endings) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html,\n         \"<ul>\\n<li>a</li>\\n<li>b</li>\\n<li>c</li>\\n<li>d</li>\\n</ul>\\n\",\n         \"list with different line endings\");\n  free(html);\n\n  static const char crlf_lines[] = \"line\\r\\nline\\r\\n\";\n  html = cmark_markdown_to_html(crlf_lines, sizeof(crlf_lines) - 1,\n                                CMARK_OPT_DEFAULT | CMARK_OPT_HARDBREAKS);\n  STR_EQ(runner, html, \"<p>line<br />\\nline</p>\\n\",\n         \"crlf endings with CMARK_OPT_HARDBREAKS\");\n  free(html);\n  html = cmark_markdown_to_html(crlf_lines, sizeof(crlf_lines) - 1,\n                                CMARK_OPT_DEFAULT | CMARK_OPT_NOBREAKS);\n  STR_EQ(runner, html, \"<p>line line</p>\\n\",\n         \"crlf endings with CMARK_OPT_NOBREAKS\");\n  free(html);\n\n  static const char no_line_ending[] = \"```\\nline\\n```\";\n  html = cmark_markdown_to_html(no_line_ending, sizeof(no_line_ending) - 1,\n                                CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<pre><code>line\\n</code></pre>\\n\",\n         \"fenced code block with no final newline\");\n  free(html);\n}\n\nstatic void numeric_entities(test_batch_runner *runner) {\n  test_md_to_html(runner, \"&#0;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0\");\n  test_md_to_html(runner, \"&#55295;\", \"<p>\\xED\\x9F\\xBF</p>\\n\",\n                  \"Valid numeric entity 0xD7FF\");\n  test_md_to_html(runner, \"&#xD800;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0xD800\");\n  test_md_to_html(runner, \"&#xDFFF;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0xDFFF\");\n  test_md_to_html(runner, \"&#57344;\", \"<p>\\xEE\\x80\\x80</p>\\n\",\n                  \"Valid numeric entity 0xE000\");\n  test_md_to_html(runner, \"&#x10FFFF;\", \"<p>\\xF4\\x8F\\xBF\\xBF</p>\\n\",\n                  \"Valid numeric entity 0x10FFFF\");\n  test_md_to_html(runner, \"&#x110000;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0x110000\");\n  test_md_to_html(runner, \"&#x80000000;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0x80000000\");\n  test_md_to_html(runner, \"&#xFFFFFFFF;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0xFFFFFFFF\");\n  test_md_to_html(runner, \"&#99999999;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 99999999\");\n\n  test_md_to_html(runner, \"&#;\", \"<p>&amp;#;</p>\\n\",\n                  \"Min decimal entity length\");\n  test_md_to_html(runner, \"&#x;\", \"<p>&amp;#x;</p>\\n\",\n                  \"Min hexadecimal entity length\");\n  test_md_to_html(runner, \"&#999999999;\", \"<p>&amp;#999999999;</p>\\n\",\n                  \"Max decimal entity length\");\n  test_md_to_html(runner, \"&#x000000041;\", \"<p>&amp;#x000000041;</p>\\n\",\n                  \"Max hexadecimal entity length\");\n}\n\nstatic void test_safe(test_batch_runner *runner) {\n  // Test safe mode\n  static const char raw_html[] = \"<div>\\nhi\\n</div>\\n\\n<a>hi</\"\n                                 \"a>\\n[link](JAVAscript:alert('hi'))\\n![image](\"\n                                 \"file:my.js)\\n\";\n  char *html = cmark_markdown_to_html(raw_html, sizeof(raw_html) - 1,\n                                      CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<!-- raw HTML omitted -->\\n<p><!-- raw HTML omitted \"\n                       \"-->hi<!-- raw HTML omitted -->\\n<a \"\n                       \"href=\\\"\\\">link</a>\\n<img src=\\\"\\\" alt=\\\"image\\\" \"\n                       \"/></p>\\n\",\n         \"input with raw HTML and dangerous links\");\n  free(html);\n}\n\nstatic void test_md_to_html(test_batch_runner *runner, const char *markdown,\n                            const char *expected_html, const char *msg) {\n  char *html = cmark_markdown_to_html(markdown, strlen(markdown),\n                                      CMARK_OPT_VALIDATE_UTF8);\n  STR_EQ(runner, html, expected_html, msg);\n  free(html);\n}\n\nstatic void test_feed_across_line_ending(test_batch_runner *runner) {\n  // See #117\n  cmark_parser *parser = cmark_parser_new(CMARK_OPT_DEFAULT);\n  cmark_parser_feed(parser, \"line1\\r\", 6);\n  cmark_parser_feed(parser, \"\\nline2\\r\\n\", 8);\n  cmark_node *document = cmark_parser_finish(parser);\n  OK(runner, document->first_child->next == NULL, \"document has one paragraph\");\n  cmark_parser_free(parser);\n  cmark_node_free(document);\n}\n\n#if !defined(_WIN32) || defined(__CYGWIN__)\n#  include <sys/time.h>\nstatic struct timeval _before, _after;\nstatic int _timing;\n#  define START_TIMING() \\\n       gettimeofday(&_before, NULL)\n\n#  define END_TIMING() \\\n        do { \\\n          gettimeofday(&_after, NULL); \\\n          _timing = (_after.tv_sec - _before.tv_sec) * 1000 + (_after.tv_usec - _before.tv_usec) / 1000; \\\n        } while (0)\n\n#  define TIMING _timing\n#else\n#  define START_TIMING()\n#  define END_TIMING()\n#  define TIMING 0\n#endif\n\nstatic void test_pathological_regressions(test_batch_runner *runner) {\n  {\n    // I don't care what the output is, so long as it doesn't take too long.\n    char path[] = \"[a](b\";\n    char *input = (char *)calloc(1, (sizeof(path) - 1) * 50000);\n    for (int i = 0; i < 50000; ++i)\n      memcpy(input + i * (sizeof(path) - 1), path, sizeof(path) - 1);\n\n    START_TIMING();\n    char *html = cmark_markdown_to_html(input, (sizeof(path) - 1) * 50000,\n                                        CMARK_OPT_VALIDATE_UTF8);\n    END_TIMING();\n    free(html);\n    free(input);\n\n    OK(runner, TIMING < 1000, \"takes less than 1000ms to run\");\n  }\n\n  {\n    char path[] = \"[a](<b\";\n    char *input = (char *)calloc(1, (sizeof(path) - 1) * 50000);\n    for (int i = 0; i < 50000; ++i)\n      memcpy(input + i * (sizeof(path) - 1), path, sizeof(path) - 1);\n\n    START_TIMING();\n    char *html = cmark_markdown_to_html(input, (sizeof(path) - 1) * 50000,\n                                        CMARK_OPT_VALIDATE_UTF8);\n    END_TIMING();\n    free(html);\n    free(input);\n\n    OK(runner, TIMING < 1000, \"takes less than 1000ms to run\");\n  }\n}\n\nstatic void source_pos(test_batch_runner *runner) {\n  static const char markdown[] =\n    \"# Hi *there*.\\n\"\n    \"\\n\"\n    \"Hello &ldquo; <http://www.google.com>\\n\"\n    \"there `hi` -- [okay](www.google.com (ok)).\\n\"\n    \"\\n\"\n    \"> 1. Okay.\\n\"\n    \">    Sure.\\n\"\n    \">\\n\"\n    \"> 2. Yes, okay.\\n\"\n    \">    ![ok](hi \\\"yes\\\")\\n\";\n\n  cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n  char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<document sourcepos=\\\"1:1-10:20\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                      \"  <heading sourcepos=\\\"1:1-1:13\\\" level=\\\"1\\\">\\n\"\n                      \"    <text sourcepos=\\\"1:3-1:5\\\" xml:space=\\\"preserve\\\">Hi </text>\\n\"\n                      \"    <emph sourcepos=\\\"1:6-1:12\\\">\\n\"\n                      \"      <text sourcepos=\\\"1:7-1:11\\\" xml:space=\\\"preserve\\\">there</text>\\n\"\n                      \"    </emph>\\n\"\n                      \"    <text sourcepos=\\\"1:13-1:13\\\" xml:space=\\\"preserve\\\">.</text>\\n\"\n                      \"  </heading>\\n\"\n                      \"  <paragraph sourcepos=\\\"3:1-4:42\\\">\\n\"\n                      \"    <text sourcepos=\\\"3:1-3:14\\\" xml:space=\\\"preserve\\\">Hello \\xe2\\x80\\x9c </text>\\n\"\n                      \"    <link sourcepos=\\\"3:15-3:37\\\" destination=\\\"http://www.google.com\\\" title=\\\"\\\">\\n\"\n                      \"      <text sourcepos=\\\"3:16-3:36\\\" xml:space=\\\"preserve\\\">http://www.google.com</text>\\n\"\n                      \"    </link>\\n\"\n                      \"    <softbreak />\\n\"\n                      \"    <text sourcepos=\\\"4:1-4:6\\\" xml:space=\\\"preserve\\\">there </text>\\n\"\n                      \"    <code sourcepos=\\\"4:8-4:9\\\" xml:space=\\\"preserve\\\">hi</code>\\n\"\n                      \"    <text sourcepos=\\\"4:11-4:14\\\" xml:space=\\\"preserve\\\"> -- </text>\\n\"\n                      \"    <link sourcepos=\\\"4:15-4:41\\\" destination=\\\"www.google.com\\\" title=\\\"ok\\\">\\n\"\n                      \"      <text sourcepos=\\\"4:16-4:19\\\" xml:space=\\\"preserve\\\">okay</text>\\n\"\n                      \"    </link>\\n\"\n                      \"    <text sourcepos=\\\"4:42-4:42\\\" xml:space=\\\"preserve\\\">.</text>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"  <block_quote sourcepos=\\\"6:1-10:20\\\">\\n\"\n                      \"    <list sourcepos=\\\"6:3-10:20\\\" type=\\\"ordered\\\" start=\\\"1\\\" delim=\\\"period\\\" tight=\\\"false\\\">\\n\"\n                      \"      <item sourcepos=\\\"6:3-8:1\\\">\\n\"\n                      \"        <paragraph sourcepos=\\\"6:6-7:10\\\">\\n\"\n                      \"          <text sourcepos=\\\"6:6-6:10\\\" xml:space=\\\"preserve\\\">Okay.</text>\\n\"\n                      \"          <softbreak />\\n\"\n                      \"          <text sourcepos=\\\"7:6-7:10\\\" xml:space=\\\"preserve\\\">Sure.</text>\\n\"\n                      \"        </paragraph>\\n\"\n                      \"      </item>\\n\"\n                      \"      <item sourcepos=\\\"9:3-10:20\\\">\\n\"\n                      \"        <paragraph sourcepos=\\\"9:6-10:20\\\">\\n\"\n                      \"          <text sourcepos=\\\"9:6-9:15\\\" xml:space=\\\"preserve\\\">Yes, okay.</text>\\n\"\n                      \"          <softbreak />\\n\"\n                      \"          <image sourcepos=\\\"10:6-10:20\\\" destination=\\\"hi\\\" title=\\\"yes\\\">\\n\"\n                      \"            <text sourcepos=\\\"10:8-10:9\\\" xml:space=\\\"preserve\\\">ok</text>\\n\"\n                      \"          </image>\\n\"\n                      \"        </paragraph>\\n\"\n                      \"      </item>\\n\"\n                      \"    </list>\\n\"\n                      \"  </block_quote>\\n\"\n                      \"</document>\\n\",\n         \"sourcepos are as expected\");\n  free(xml);\n  cmark_node_free(doc);\n}\n\nstatic void source_pos_inlines(test_batch_runner *runner) {\n  {\n    static const char markdown[] =\n      \"*first*\\n\"\n      \"second\\n\";\n\n    cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n    char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n    STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                        \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                        \"<document sourcepos=\\\"1:1-2:6\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                        \"  <paragraph sourcepos=\\\"1:1-2:6\\\">\\n\"\n                        \"    <emph sourcepos=\\\"1:1-1:7\\\">\\n\"\n                        \"      <text sourcepos=\\\"1:2-1:6\\\" xml:space=\\\"preserve\\\">first</text>\\n\"\n                        \"    </emph>\\n\"\n                        \"    <softbreak />\\n\"\n                        \"    <text sourcepos=\\\"2:1-2:6\\\" xml:space=\\\"preserve\\\">second</text>\\n\"\n                        \"  </paragraph>\\n\"\n                        \"</document>\\n\",\n                        \"sourcepos are as expected\");\n    free(xml);\n    cmark_node_free(doc);\n  }\n  {\n    static const char markdown[] =\n      \"*first\\n\"\n      \"second*\\n\";\n\n    cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n    char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n    STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                        \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                        \"<document sourcepos=\\\"1:1-2:7\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                        \"  <paragraph sourcepos=\\\"1:1-2:7\\\">\\n\"\n                        \"    <emph sourcepos=\\\"1:1-2:7\\\">\\n\"\n                        \"      <text sourcepos=\\\"1:2-1:6\\\" xml:space=\\\"preserve\\\">first</text>\\n\"\n                        \"      <softbreak />\\n\"\n                        \"      <text sourcepos=\\\"2:1-2:6\\\" xml:space=\\\"preserve\\\">second</text>\\n\"\n                        \"    </emph>\\n\"\n                        \"  </paragraph>\\n\"\n                        \"</document>\\n\",\n                        \"sourcepos are as expected\");\n    free(xml);\n    cmark_node_free(doc);\n  }\n}\n\nstatic void ref_source_pos(test_batch_runner *runner) {\n  static const char markdown[] =\n    \"Let's try [reference] links.\\n\"\n    \"\\n\"\n    \"[reference]: https://github.com (GitHub)\\n\";\n\n  cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n  char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<document sourcepos=\\\"1:1-3:40\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                      \"  <paragraph sourcepos=\\\"1:1-1:28\\\">\\n\"\n                      \"    <text sourcepos=\\\"1:1-1:10\\\" xml:space=\\\"preserve\\\">Let's try </text>\\n\"\n                      \"    <link sourcepos=\\\"1:11-1:21\\\" destination=\\\"https://github.com\\\" title=\\\"GitHub\\\">\\n\"\n                      \"      <text sourcepos=\\\"1:12-1:20\\\" xml:space=\\\"preserve\\\">reference</text>\\n\"\n                      \"    </link>\\n\"\n                      \"    <text sourcepos=\\\"1:22-1:28\\\" xml:space=\\\"preserve\\\"> links.</text>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"</document>\\n\",\n         \"sourcepos are as expected\");\n  free(xml);\n  cmark_node_free(doc);\n}\n\nint main() {\n  int retval;\n  test_batch_runner *runner = test_batch_runner_new();\n\n  version(runner);\n  constructor(runner);\n  accessors(runner);\n  node_check(runner);\n  iterator(runner);\n  iterator_delete(runner);\n  create_tree(runner);\n  custom_nodes(runner);\n  hierarchy(runner);\n  parser(runner);\n  render_html(runner);\n  render_xml(runner);\n  render_man(runner);\n  render_latex(runner);\n  render_commonmark(runner);\n  render_plaintext(runner);\n  utf8(runner);\n  line_endings(runner);\n  numeric_entities(runner);\n  test_cplusplus(runner);\n  test_safe(runner);\n  test_feed_across_line_ending(runner);\n  test_pathological_regressions(runner);\n  source_pos(runner);\n  source_pos_inlines(runner);\n  ref_source_pos(runner);\n\n  test_print_summary(runner);\n  retval = test_ok(runner) ? 0 : 1;\n  free(runner);\n\n  return retval;\n}\n", "#include <cmark-gfm-extension_api.h>\n#include <html.h>\n#include <inlines.h>\n#include <parser.h>\n#include <references.h>\n#include <string.h>\n#include <render.h>\n\n#include \"ext_scanners.h\"\n#include \"strikethrough.h\"\n#include \"table.h\"\n#include \"cmark-gfm-core-extensions.h\"\n\n// Custom node flag, initialized in `create_table_extension`.\nstatic cmark_node_internal_flags CMARK_NODE__TABLE_VISITED;\n\ncmark_node_type CMARK_NODE_TABLE, CMARK_NODE_TABLE_ROW,\n    CMARK_NODE_TABLE_CELL;\n\ntypedef struct {\n  cmark_strbuf *buf;\n  int start_offset, end_offset, internal_offset;\n} node_cell;\n\ntypedef struct {\n  uint16_t n_columns;\n  int paragraph_offset;\n  node_cell *cells;\n} table_row;\n\ntypedef struct {\n  uint16_t n_columns;\n  uint8_t *alignments;\n} node_table;\n\ntypedef struct {\n  bool is_header;\n} node_table_row;\n\nstatic void free_table_cell(cmark_mem *mem, node_cell *cell) {\n  cmark_strbuf_free((cmark_strbuf *)cell->buf);\n  mem->free(cell->buf);\n}\n\nstatic void free_row_cells(cmark_mem *mem, table_row *row) {\n  while (row->n_columns > 0) {\n    free_table_cell(mem, &row->cells[--row->n_columns]);\n  }\n  mem->free(row->cells);\n  row->cells = NULL;\n}\n\nstatic void free_table_row(cmark_mem *mem, table_row *row) {\n  if (!row)\n    return;\n\n  free_row_cells(mem, row);\n  mem->free(row);\n}\n\nstatic void free_node_table(cmark_mem *mem, void *ptr) {\n  node_table *t = (node_table *)ptr;\n  mem->free(t->alignments);\n  mem->free(t);\n}\n\nstatic void free_node_table_row(cmark_mem *mem, void *ptr) {\n  mem->free(ptr);\n}\n\nstatic int get_n_table_columns(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return -1;\n\n  return (int)((node_table *)node->as.opaque)->n_columns;\n}\n\nstatic int set_n_table_columns(cmark_node *node, uint16_t n_columns) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->n_columns = n_columns;\n  return 1;\n}\n\nstatic uint8_t *get_table_alignments(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nstatic int set_table_alignments(cmark_node *node, uint8_t *alignments) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->alignments = alignments;\n  return 1;\n}\n\nstatic cmark_strbuf *unescape_pipes(cmark_mem *mem, unsigned char *string, bufsize_t len)\n{\n  cmark_strbuf *res = (cmark_strbuf *)mem->calloc(1, sizeof(cmark_strbuf));\n  bufsize_t r, w;\n\n  cmark_strbuf_init(mem, res, len + 1);\n  cmark_strbuf_put(res, string, len);\n  cmark_strbuf_putc(res, '\\0');\n\n  for (r = 0, w = 0; r < len; ++r) {\n    if (res->ptr[r] == '\\\\' && res->ptr[r + 1] == '|')\n      r++;\n\n    res->ptr[w++] = res->ptr[r];\n  }\n\n  cmark_strbuf_truncate(res, w);\n\n  return res;\n}\n\n// Adds a new cell to the end of the row. A pointer to the new cell is returned\n// for the caller to initialize.\nstatic node_cell* append_row_cell(cmark_mem *mem, table_row *row) {\n  const uint32_t n_columns = row->n_columns + 1;\n  // realloc when n_columns is a power of 2\n  if ((n_columns & (n_columns-1)) == 0) {\n    // make sure we never wrap row->n_columns\n    // offset will != len and our exit will clean up as intended\n    if (n_columns > UINT16_MAX) {\n      return NULL;\n    }\n    // Use realloc to double the size of the buffer.\n    row->cells = (node_cell *)mem->realloc(row->cells, (2 * n_columns - 1) * sizeof(node_cell));\n  }\n  row->n_columns = (uint16_t)n_columns;\n  return &row->cells[n_columns-1];\n}\n\nstatic table_row *row_from_string(cmark_syntax_extension *self,\n                                  cmark_parser *parser, unsigned char *string,\n                                  int len) {\n  // Parses a single table row. It has the following form:\n  // `delim? table_cell (delim table_cell)* delim? newline`\n  // Note that cells are allowed to be empty.\n  //\n  // From the GitHub-flavored Markdown specification:\n  //\n  // > Each row consists of cells containing arbitrary text, in which inlines\n  // > are parsed, separated by pipes (|). A leading and trailing pipe is also\n  // > recommended for clarity of reading, and if there\u2019s otherwise parsing\n  // > ambiguity.\n\n  table_row *row = NULL;\n  bufsize_t cell_matched = 1, pipe_matched = 1, offset;\n  int expect_more_cells = 1;\n  int row_end_offset = 0;\n  int int_overflow_abort = 0;\n\n  row = (table_row *)parser->mem->calloc(1, sizeof(table_row));\n  row->n_columns = 0;\n  row->cells = NULL;\n\n  // Scan past the (optional) leading pipe.\n  offset = scan_table_cell_end(string, len, 0);\n\n  // Parse the cells of the row. Stop if we reach the end of the input, or if we\n  // cannot detect any more cells.\n  while (offset < len && expect_more_cells) {\n    cell_matched = scan_table_cell(string, len, offset);\n    pipe_matched = scan_table_cell_end(string, len, offset + cell_matched);\n\n    if (cell_matched || pipe_matched) {\n      // We are guaranteed to have a cell, since (1) either we found some\n      // content and cell_matched, or (2) we found an empty cell followed by a\n      // pipe.\n      cmark_strbuf *cell_buf = unescape_pipes(parser->mem, string + offset,\n          cell_matched);\n      cmark_strbuf_trim(cell_buf);\n\n      node_cell *cell = append_row_cell(parser->mem, row);\n      if (!cell) {\n        int_overflow_abort = 1;\n        cmark_strbuf_free(cell_buf);\n        parser->mem->free(cell_buf);\n        break;\n      }\n      cell->buf = cell_buf;\n      cell->start_offset = offset;\n      cell->end_offset = offset + cell_matched - 1;\n      cell->internal_offset = 0;\n\n      while (cell->start_offset > row->paragraph_offset && string[cell->start_offset - 1] != '|') {\n        --cell->start_offset;\n        ++cell->internal_offset;\n      }\n    }\n\n    offset += cell_matched + pipe_matched;\n\n    if (pipe_matched) {\n      expect_more_cells = 1;\n    } else {\n      // We've scanned the last cell. Check if we have reached the end of the row\n      row_end_offset = scan_table_row_end(string, len, offset);\n      offset += row_end_offset;\n\n      // If the end of the row is not the end of the input,\n      // the row is not a real row but potentially part of the paragraph\n      // preceding the table.\n      if (row_end_offset && offset != len) {\n        row->paragraph_offset = offset;\n\n        free_row_cells(parser->mem, row);\n\n        // Scan past the (optional) leading pipe.\n        offset += scan_table_cell_end(string, len, offset);\n\n        expect_more_cells = 1;\n      } else {\n        expect_more_cells = 0;\n      }\n    }\n  }\n\n  if (offset != len || row->n_columns == 0 || int_overflow_abort) {\n    free_table_row(parser->mem, row);\n    row = NULL;\n  }\n\n  return row;\n}\n\nstatic void try_inserting_table_header_paragraph(cmark_parser *parser,\n                                                 cmark_node *parent_container,\n                                                 unsigned char *parent_string,\n                                                 int paragraph_offset) {\n  cmark_node *paragraph;\n  cmark_strbuf *paragraph_content;\n\n  paragraph = cmark_node_new_with_mem(CMARK_NODE_PARAGRAPH, parser->mem);\n\n  paragraph_content = unescape_pipes(parser->mem, parent_string, paragraph_offset);\n  cmark_strbuf_trim(paragraph_content);\n  cmark_node_set_string_content(paragraph, (char *) paragraph_content->ptr);\n  cmark_strbuf_free(paragraph_content);\n  parser->mem->free(paragraph_content);\n\n  if (!cmark_node_insert_before(parent_container, paragraph)) {\n    parser->mem->free(paragraph);\n  }\n}\n\nstatic cmark_node *try_opening_table_header(cmark_syntax_extension *self,\n                                            cmark_parser *parser,\n                                            cmark_node *parent_container,\n                                            unsigned char *input, int len) {\n  cmark_node *table_header;\n  table_row *header_row = NULL;\n  table_row *marker_row = NULL;\n  node_table_row *ntr;\n  const char *parent_string;\n  uint16_t i;\n\n  if (parent_container->flags & CMARK_NODE__TABLE_VISITED) {\n    return parent_container;\n  }\n\n  if (!scan_table_start(input, len, cmark_parser_get_first_nonspace(parser))) {\n    return parent_container;\n  }\n\n  // Since scan_table_start was successful, we must have a marker row.\n  marker_row = row_from_string(self, parser,\n                               input + cmark_parser_get_first_nonspace(parser),\n                               len - cmark_parser_get_first_nonspace(parser));\n  // assert may be optimized out, don't rely on it for security boundaries\n  if (!marker_row) {\n      return parent_container;\n  }\n  \n  assert(marker_row);\n\n  cmark_arena_push();\n\n  // Check for a matching header row. We call `row_from_string` with the entire\n  // (potentially long) parent container as input, but this should be safe since\n  // `row_from_string` bails out early if it does not find a row.\n  parent_string = cmark_node_get_string_content(parent_container);\n  header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                               (int)strlen(parent_string));\n  if (!header_row || header_row->n_columns != marker_row->n_columns) {\n    free_table_row(parser->mem, marker_row);\n    free_table_row(parser->mem, header_row);\n    cmark_arena_pop();\n    parent_container->flags |= CMARK_NODE__TABLE_VISITED;\n    return parent_container;\n  }\n\n  if (cmark_arena_pop()) {\n    marker_row = row_from_string(\n        self, parser, input + cmark_parser_get_first_nonspace(parser),\n        len - cmark_parser_get_first_nonspace(parser));\n    header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                                 (int)strlen(parent_string));\n    // row_from_string can return NULL, add additional check to ensure n_columns match\n    if (!marker_row || !header_row || header_row->n_columns != marker_row->n_columns) {\n        free_table_row(parser->mem, marker_row);\n        free_table_row(parser->mem, header_row);\n        return parent_container;\n    }\n  }\n\n  if (!cmark_node_set_type(parent_container, CMARK_NODE_TABLE)) {\n    free_table_row(parser->mem, header_row);\n    free_table_row(parser->mem, marker_row);\n    return parent_container;\n  }\n\n  if (header_row->paragraph_offset) {\n    try_inserting_table_header_paragraph(parser, parent_container, (unsigned char *)parent_string,\n                                         header_row->paragraph_offset);\n  }\n\n  cmark_node_set_syntax_extension(parent_container, self);\n  parent_container->as.opaque = parser->mem->calloc(1, sizeof(node_table));\n  set_n_table_columns(parent_container, header_row->n_columns);\n\n  // allocate alignments based on marker_row->n_columns\n  // since we populate the alignments array based on marker_row->cells\n  uint8_t *alignments =\n      (uint8_t *)parser->mem->calloc(marker_row->n_columns, sizeof(uint8_t));\n  for (i = 0; i < marker_row->n_columns; ++i) {\n    node_cell *node = &marker_row->cells[i];\n    bool left = node->buf->ptr[0] == ':', right = node->buf->ptr[node->buf->size - 1] == ':';\n\n    if (left && right)\n      alignments[i] = 'c';\n    else if (left)\n      alignments[i] = 'l';\n    else if (right)\n      alignments[i] = 'r';\n  }\n  set_table_alignments(parent_container, alignments);\n\n  table_header =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_header, self);\n  table_header->end_column = parent_container->start_column + (int)strlen(parent_string) - 2;\n  table_header->start_line = table_header->end_line = parent_container->start_line;\n\n  table_header->as.opaque = ntr = (node_table_row *)parser->mem->calloc(1, sizeof(node_table_row));\n  ntr->is_header = true;\n\n  {\n    for (i = 0; i < header_row->n_columns; ++i) {\n      node_cell *cell = &header_row->cells[i];\n      cmark_node *header_cell = cmark_parser_add_child(parser, table_header,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      header_cell->start_line = header_cell->end_line = parent_container->start_line;\n      header_cell->internal_offset = cell->internal_offset;\n      header_cell->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(header_cell, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(header_cell, self);\n    }\n  }\n\n  cmark_parser_advance_offset(\n      parser, (char *)input,\n      (int)strlen((char *)input) - 1 - cmark_parser_get_offset(parser), false);\n\n  free_table_row(parser->mem, header_row);\n  free_table_row(parser->mem, marker_row);\n  return parent_container;\n}\n\nstatic cmark_node *try_opening_table_row(cmark_syntax_extension *self,\n                                         cmark_parser *parser,\n                                         cmark_node *parent_container,\n                                         unsigned char *input, int len) {\n  cmark_node *table_row_block;\n  table_row *row;\n\n  if (cmark_parser_is_blank(parser))\n    return NULL;\n\n  table_row_block =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_row_block, self);\n  table_row_block->end_column = parent_container->end_column;\n  table_row_block->as.opaque = parser->mem->calloc(1, sizeof(node_table_row));\n\n  row = row_from_string(self, parser, input + cmark_parser_get_first_nonspace(parser),\n      len - cmark_parser_get_first_nonspace(parser));\n\n  if (!row) {\n      // clean up the dangling node\n      cmark_node_free(table_row_block);\n      return NULL;\n  }\n\n  {\n    int i, table_columns = get_n_table_columns(parent_container);\n\n    for (i = 0; i < row->n_columns && i < table_columns; ++i) {\n      node_cell *cell = &row->cells[i];\n      cmark_node *node = cmark_parser_add_child(parser, table_row_block,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      node->internal_offset = cell->internal_offset;\n      node->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(node, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(node, self);\n    }\n\n    for (; i < table_columns; ++i) {\n      cmark_node *node = cmark_parser_add_child(\n          parser, table_row_block, CMARK_NODE_TABLE_CELL, 0);\n      cmark_node_set_syntax_extension(node, self);\n    }\n  }\n\n  free_table_row(parser->mem, row);\n\n  cmark_parser_advance_offset(parser, (char *)input,\n                              len - 1 - cmark_parser_get_offset(parser), false);\n\n  return table_row_block;\n}\n\nstatic cmark_node *try_opening_table_block(cmark_syntax_extension *self,\n                                           int indented, cmark_parser *parser,\n                                           cmark_node *parent_container,\n                                           unsigned char *input, int len) {\n  cmark_node_type parent_type = cmark_node_get_type(parent_container);\n\n  if (!indented && parent_type == CMARK_NODE_PARAGRAPH) {\n    return try_opening_table_header(self, parser, parent_container, input, len);\n  } else if (!indented && parent_type == CMARK_NODE_TABLE) {\n    return try_opening_table_row(self, parser, parent_container, input, len);\n  }\n\n  return NULL;\n}\n\nstatic int matches(cmark_syntax_extension *self, cmark_parser *parser,\n                   unsigned char *input, int len,\n                   cmark_node *parent_container) {\n  int res = 0;\n\n  if (cmark_node_get_type(parent_container) == CMARK_NODE_TABLE) {\n    cmark_arena_push();\n    table_row *new_row = row_from_string(\n        self, parser, input + cmark_parser_get_first_nonspace(parser),\n        len - cmark_parser_get_first_nonspace(parser));\n    if (new_row && new_row->n_columns)\n      res = 1;\n    free_table_row(parser->mem, new_row);\n    cmark_arena_pop();\n  }\n\n  return res;\n}\n\nstatic const char *get_type_string(cmark_syntax_extension *self,\n                                   cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return \"table\";\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (((node_table_row *)node->as.opaque)->is_header)\n      return \"table_header\";\n    else\n      return \"table_row\";\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return \"table_cell\";\n  }\n\n  return \"<unknown>\";\n}\n\nstatic int can_contain(cmark_syntax_extension *extension, cmark_node *node,\n                       cmark_node_type child_type) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return child_type == CMARK_NODE_TABLE_ROW;\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    return child_type == CMARK_NODE_TABLE_CELL;\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return child_type == CMARK_NODE_TEXT || child_type == CMARK_NODE_CODE ||\n           child_type == CMARK_NODE_EMPH || child_type == CMARK_NODE_STRONG ||\n           child_type == CMARK_NODE_LINK || child_type == CMARK_NODE_IMAGE ||\n           child_type == CMARK_NODE_STRIKETHROUGH ||\n           child_type == CMARK_NODE_HTML_INLINE ||\n           child_type == CMARK_NODE_FOOTNOTE_REFERENCE;\n  }\n  return false;\n}\n\nstatic int contains_inlines(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  return node->type == CMARK_NODE_TABLE_CELL;\n}\n\nstatic void commonmark_render(cmark_syntax_extension *extension,\n                              cmark_renderer *renderer, cmark_node *node,\n                              cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    renderer->blankline(renderer);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"|\", false, LITERAL);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (entering) {\n      renderer->out(renderer, node, \" \", false, LITERAL);\n    } else {\n      renderer->out(renderer, node, \" |\", false, LITERAL);\n      if (((node_table_row *)node->parent->as.opaque)->is_header &&\n          !node->next) {\n        int i;\n        uint8_t *alignments = get_table_alignments(node->parent->parent);\n        uint16_t n_cols =\n            ((node_table *)node->parent->parent->as.opaque)->n_columns;\n        renderer->cr(renderer);\n        renderer->out(renderer, node, \"|\", false, LITERAL);\n        for (i = 0; i < n_cols; i++) {\n          switch (alignments[i]) {\n          case 0:   renderer->out(renderer, node, \" --- |\", false, LITERAL); break;\n          case 'l': renderer->out(renderer, node, \" :-- |\", false, LITERAL); break;\n          case 'c': renderer->out(renderer, node, \" :-: |\", false, LITERAL); break;\n          case 'r': renderer->out(renderer, node, \" --: |\", false, LITERAL); break;\n          }\n        }\n        renderer->cr(renderer);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void latex_render(cmark_syntax_extension *extension,\n                         cmark_renderer *renderer, cmark_node *node,\n                         cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{table}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{tabular}{\", false, LITERAL);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n      for (i = 0; i < n_cols; i++) {\n        switch(alignments[i]) {\n        case 0:\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n      renderer->out(renderer, node, \"}\", false, LITERAL);\n      renderer->cr(renderer);\n    } else {\n      renderer->out(renderer, node, \"\\\\end{tabular}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\end{table}\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering) {\n      if (node->next) {\n        renderer->out(renderer, node, \" & \", false, LITERAL);\n      } else {\n        renderer->out(renderer, node, \" \\\\\\\\\", false, LITERAL);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic const char *xml_attr(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (cmark_gfm_extensions_get_table_row_is_header(node->parent)) {\n      uint8_t *alignments = get_table_alignments(node->parent->parent);\n      int i = 0;\n      cmark_node *n;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n      switch (alignments[i]) {\n      case 'l': return \" align=\\\"left\\\"\";\n      case 'c': return \" align=\\\"center\\\"\";\n      case 'r': return \" align=\\\"right\\\"\";\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic void man_render(cmark_syntax_extension *extension,\n                       cmark_renderer *renderer, cmark_node *node,\n                       cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \".TS\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"tab(@);\", false, LITERAL);\n      renderer->cr(renderer);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n\n      for (i = 0; i < n_cols; i++) {\n        switch (alignments[i]) {\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 0:\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n\n      if (n_cols) {\n        renderer->out(renderer, node, \".\", false, LITERAL);\n        renderer->cr(renderer);\n      }\n    } else {\n      renderer->out(renderer, node, \".TE\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering && node->next) {\n      renderer->out(renderer, node, \"@\", false, LITERAL);\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void html_table_add_align(cmark_strbuf* html, const char* align, int options) {\n  if (options & CMARK_OPT_TABLE_PREFER_STYLE_ATTRIBUTES) {\n    cmark_strbuf_puts(html, \" style=\\\"text-align: \");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  } else {\n    cmark_strbuf_puts(html, \" align=\\\"\");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  }\n}\n\nstruct html_table_state {\n  unsigned need_closing_table_body : 1;\n  unsigned in_table_header : 1;\n};\n\nstatic void html_render(cmark_syntax_extension *extension,\n                        cmark_html_renderer *renderer, cmark_node *node,\n                        cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n  cmark_strbuf *html = renderer->html;\n  cmark_node *n;\n\n  // XXX: we just monopolise renderer->opaque.\n  struct html_table_state *table_state =\n      (struct html_table_state *)&renderer->opaque;\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"<table\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n      table_state->need_closing_table_body = false;\n    } else {\n      if (table_state->need_closing_table_body) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</tbody>\");\n        cmark_html_render_cr(html);\n      }\n      table_state->need_closing_table_body = false;\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</table>\");\n      cmark_html_render_cr(html);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        table_state->in_table_header = 1;\n        cmark_strbuf_puts(html, \"<thead>\");\n        cmark_html_render_cr(html);\n      } else if (!table_state->need_closing_table_body) {\n        cmark_strbuf_puts(html, \"<tbody>\");\n        cmark_html_render_cr(html);\n        table_state->need_closing_table_body = 1;\n      }\n      cmark_strbuf_puts(html, \"<tr\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</tr>\");\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</thead>\");\n        table_state->in_table_header = false;\n      }\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    uint8_t *alignments = get_table_alignments(node->parent->parent);\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"<th\");\n      } else {\n        cmark_strbuf_puts(html, \"<td\");\n      }\n\n      int i = 0;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n\n      switch (alignments[i]) {\n      case 'l': html_table_add_align(html, \"left\", options); break;\n      case 'c': html_table_add_align(html, \"center\", options); break;\n      case 'r': html_table_add_align(html, \"right\", options); break;\n      }\n\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"</th>\");\n      } else {\n        cmark_strbuf_puts(html, \"</td>\");\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void opaque_alloc(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table));\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table_row));\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    node->as.opaque = mem->calloc(1, sizeof(node_cell));\n  }\n}\n\nstatic void opaque_free(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    free_node_table(mem, node->as.opaque);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    free_node_table_row(mem, node->as.opaque);\n  }\n}\n\nstatic int escape(cmark_syntax_extension *self, cmark_node *node, int c) {\n  return\n    node->type != CMARK_NODE_TABLE &&\n    node->type != CMARK_NODE_TABLE_ROW &&\n    node->type != CMARK_NODE_TABLE_CELL &&\n    c == '|';\n}\n\ncmark_syntax_extension *create_table_extension(void) {\n  cmark_syntax_extension *self = cmark_syntax_extension_new(\"table\");\n\n  cmark_register_node_flag(&CMARK_NODE__TABLE_VISITED);\n  cmark_syntax_extension_set_match_block_func(self, matches);\n  cmark_syntax_extension_set_open_block_func(self, try_opening_table_block);\n  cmark_syntax_extension_set_get_type_string_func(self, get_type_string);\n  cmark_syntax_extension_set_can_contain_func(self, can_contain);\n  cmark_syntax_extension_set_contains_inlines_func(self, contains_inlines);\n  cmark_syntax_extension_set_commonmark_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_plaintext_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_latex_render_func(self, latex_render);\n  cmark_syntax_extension_set_xml_attr_func(self, xml_attr);\n  cmark_syntax_extension_set_man_render_func(self, man_render);\n  cmark_syntax_extension_set_html_render_func(self, html_render);\n  cmark_syntax_extension_set_opaque_alloc_func(self, opaque_alloc);\n  cmark_syntax_extension_set_opaque_free_func(self, opaque_free);\n  cmark_syntax_extension_set_commonmark_escape_func(self, escape);\n  CMARK_NODE_TABLE = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_ROW = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_CELL = cmark_syntax_extension_add_node(0);\n\n  return self;\n}\n\nuint16_t cmark_gfm_extensions_get_table_columns(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->n_columns;\n}\n\nuint8_t *cmark_gfm_extensions_get_table_alignments(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nint cmark_gfm_extensions_set_table_columns(cmark_node *node, uint16_t n_columns) {\n  return set_n_table_columns(node, n_columns);\n}\n\nint cmark_gfm_extensions_set_table_alignments(cmark_node *node, uint16_t ncols, uint8_t *alignments) {\n  uint8_t *a = (uint8_t *)cmark_node_mem(node)->calloc(1, ncols);\n  memcpy(a, alignments, ncols);\n  return set_table_alignments(node, a);\n}\n\nint cmark_gfm_extensions_get_table_row_is_header(cmark_node *node)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  return ((node_table_row *)node->as.opaque)->is_header;\n}\n\nint cmark_gfm_extensions_set_table_row_is_header(cmark_node *node, int is_header)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  ((node_table_row *)node->as.opaque)->is_header = (is_header != 0);\n  return 1;\n}\n", "/**\n * Block parsing implementation.\n *\n * For a high-level overview of the block parsing process,\n * see http://spec.commonmark.org/0.24/#phase-1-block-structure\n */\n\n#include <stdlib.h>\n#include <assert.h>\n#include <stdio.h>\n#include <limits.h>\n\n#include \"cmark_ctype.h\"\n#include \"syntax_extension.h\"\n#include \"config.h\"\n#include \"parser.h\"\n#include \"cmark-gfm.h\"\n#include \"node.h\"\n#include \"references.h\"\n#include \"utf8.h\"\n#include \"scanners.h\"\n#include \"inlines.h\"\n#include \"houdini.h\"\n#include \"buffer.h\"\n#include \"footnotes.h\"\n\n#define CODE_INDENT 4\n#define TAB_STOP 4\n\n#ifndef MIN\n#define MIN(x, y) ((x < y) ? x : y)\n#endif\n\n#define peek_at(i, n) (i)->data[n]\n\nstatic bool S_last_line_blank(const cmark_node *node) {\n  return (node->flags & CMARK_NODE__LAST_LINE_BLANK) != 0;\n}\n\nstatic bool S_last_line_checked(const cmark_node *node) {\n  return (node->flags & CMARK_NODE__LAST_LINE_CHECKED) != 0;\n}\n\nstatic CMARK_INLINE cmark_node_type S_type(const cmark_node *node) {\n  return (cmark_node_type)node->type;\n}\n\nstatic void S_set_last_line_blank(cmark_node *node, bool is_blank) {\n  if (is_blank)\n    node->flags |= CMARK_NODE__LAST_LINE_BLANK;\n  else\n    node->flags &= ~CMARK_NODE__LAST_LINE_BLANK;\n}\n\nstatic void S_set_last_line_checked(cmark_node *node) {\n  node->flags |= CMARK_NODE__LAST_LINE_CHECKED;\n}\n\nstatic CMARK_INLINE bool S_is_line_end_char(char c) {\n  return (c == '\\n' || c == '\\r');\n}\n\nstatic CMARK_INLINE bool S_is_space_or_tab(char c) {\n  return (c == ' ' || c == '\\t');\n}\n\nstatic void S_parser_feed(cmark_parser *parser, const unsigned char *buffer,\n                          size_t len, bool eof);\n\nstatic void S_process_line(cmark_parser *parser, const unsigned char *buffer,\n                           bufsize_t bytes);\n\nstatic cmark_node *make_block(cmark_mem *mem, cmark_node_type tag,\n                              int start_line, int start_column) {\n  cmark_node *e;\n\n  e = (cmark_node *)mem->calloc(1, sizeof(*e));\n  cmark_strbuf_init(mem, &e->content, 32);\n  e->type = (uint16_t)tag;\n  e->flags = CMARK_NODE__OPEN;\n  e->start_line = start_line;\n  e->start_column = start_column;\n  e->end_line = start_line;\n\n  return e;\n}\n\n// Create a root document node.\nstatic cmark_node *make_document(cmark_mem *mem) {\n  cmark_node *e = make_block(mem, CMARK_NODE_DOCUMENT, 1, 1);\n  return e;\n}\n\nint cmark_parser_attach_syntax_extension(cmark_parser *parser,\n                                         cmark_syntax_extension *extension) {\n  parser->syntax_extensions = cmark_llist_append(parser->mem, parser->syntax_extensions, extension);\n  if (extension->match_inline || extension->insert_inline_from_delim) {\n    parser->inline_syntax_extensions = cmark_llist_append(\n      parser->mem, parser->inline_syntax_extensions, extension);\n  }\n\n  return 1;\n}\n\nstatic void cmark_parser_dispose(cmark_parser *parser) {\n  if (parser->root)\n    cmark_node_free(parser->root);\n\n  if (parser->refmap)\n    cmark_map_free(parser->refmap);\n}\n\nstatic void cmark_parser_reset(cmark_parser *parser) {\n  cmark_llist *saved_exts = parser->syntax_extensions;\n  cmark_llist *saved_inline_exts = parser->inline_syntax_extensions;\n  int saved_options = parser->options;\n  cmark_mem *saved_mem = parser->mem;\n\n  cmark_parser_dispose(parser);\n\n  memset(parser, 0, sizeof(cmark_parser));\n  parser->mem = saved_mem;\n\n  cmark_strbuf_init(parser->mem, &parser->curline, 256);\n  cmark_strbuf_init(parser->mem, &parser->linebuf, 0);\n\n  cmark_node *document = make_document(parser->mem);\n\n  parser->refmap = cmark_reference_map_new(parser->mem);\n  parser->root = document;\n  parser->current = document;\n\n  parser->syntax_extensions = saved_exts;\n  parser->inline_syntax_extensions = saved_inline_exts;\n  parser->options = saved_options;\n}\n\ncmark_parser *cmark_parser_new_with_mem(int options, cmark_mem *mem) {\n  cmark_parser *parser = (cmark_parser *)mem->calloc(1, sizeof(cmark_parser));\n  parser->mem = mem;\n  parser->options = options;\n  cmark_parser_reset(parser);\n  return parser;\n}\n\ncmark_parser *cmark_parser_new(int options) {\n  extern cmark_mem CMARK_DEFAULT_MEM_ALLOCATOR;\n  return cmark_parser_new_with_mem(options, &CMARK_DEFAULT_MEM_ALLOCATOR);\n}\n\nvoid cmark_parser_free(cmark_parser *parser) {\n  cmark_mem *mem = parser->mem;\n  cmark_parser_dispose(parser);\n  cmark_strbuf_free(&parser->curline);\n  cmark_strbuf_free(&parser->linebuf);\n  cmark_llist_free(parser->mem, parser->syntax_extensions);\n  cmark_llist_free(parser->mem, parser->inline_syntax_extensions);\n  mem->free(parser);\n}\n\nstatic cmark_node *finalize(cmark_parser *parser, cmark_node *b);\n\n// Returns true if line has only space characters, else false.\nstatic bool is_blank(cmark_strbuf *s, bufsize_t offset) {\n  while (offset < s->size) {\n    switch (s->ptr[offset]) {\n    case '\\r':\n    case '\\n':\n      return true;\n    case ' ':\n      offset++;\n      break;\n    case '\\t':\n      offset++;\n      break;\n    default:\n      return false;\n    }\n  }\n\n  return true;\n}\n\nstatic CMARK_INLINE bool accepts_lines(cmark_node_type block_type) {\n  return (block_type == CMARK_NODE_PARAGRAPH ||\n          block_type == CMARK_NODE_HEADING ||\n          block_type == CMARK_NODE_CODE_BLOCK);\n}\n\nstatic CMARK_INLINE bool contains_inlines(cmark_node *node) {\n  if (node->extension && node->extension->contains_inlines_func) {\n    return node->extension->contains_inlines_func(node->extension, node) != 0;\n  }\n\n  return (node->type == CMARK_NODE_PARAGRAPH ||\n          node->type == CMARK_NODE_HEADING);\n}\n\nstatic void add_line(cmark_node *node, cmark_chunk *ch, cmark_parser *parser) {\n  int chars_to_tab;\n  int i;\n  assert(node->flags & CMARK_NODE__OPEN);\n  if (parser->partially_consumed_tab) {\n    parser->offset += 1; // skip over tab\n    // add space characters:\n    chars_to_tab = TAB_STOP - (parser->column % TAB_STOP);\n    for (i = 0; i < chars_to_tab; i++) {\n      cmark_strbuf_putc(&node->content, ' ');\n    }\n  }\n  cmark_strbuf_put(&node->content, ch->data + parser->offset,\n                   ch->len - parser->offset);\n}\n\nstatic void remove_trailing_blank_lines(cmark_strbuf *ln) {\n  bufsize_t i;\n  unsigned char c;\n\n  for (i = ln->size - 1; i >= 0; --i) {\n    c = ln->ptr[i];\n\n    if (c != ' ' && c != '\\t' && !S_is_line_end_char(c))\n      break;\n  }\n\n  if (i < 0) {\n    cmark_strbuf_clear(ln);\n    return;\n  }\n\n  for (; i < ln->size; ++i) {\n    c = ln->ptr[i];\n\n    if (!S_is_line_end_char(c))\n      continue;\n\n    cmark_strbuf_truncate(ln, i);\n    break;\n  }\n}\n\n// Check to see if a node ends with a blank line, descending\n// if needed into lists and sublists.\nstatic bool S_ends_with_blank_line(cmark_node *node) {\n  if (S_last_line_checked(node)) {\n    return(S_last_line_blank(node));\n  } else if ((S_type(node) == CMARK_NODE_LIST ||\n              S_type(node) == CMARK_NODE_ITEM) && node->last_child) {\n    S_set_last_line_checked(node);\n    return(S_ends_with_blank_line(node->last_child));\n  } else {\n    S_set_last_line_checked(node);\n    return (S_last_line_blank(node));\n  }\n}\n\n// returns true if content remains after link defs are resolved.\nstatic bool resolve_reference_link_definitions(\n\t\tcmark_parser *parser,\n                cmark_node *b) {\n  bufsize_t pos;\n  cmark_strbuf *node_content = &b->content;\n  cmark_chunk chunk = {node_content->ptr, node_content->size, 0};\n  while (chunk.len && chunk.data[0] == '[' &&\n         (pos = cmark_parse_reference_inline(parser->mem, &chunk,\n\t\t\t\t\t     parser->refmap))) {\n\n    chunk.data += pos;\n    chunk.len -= pos;\n  }\n  cmark_strbuf_drop(node_content, (node_content->size - chunk.len));\n  return !is_blank(&b->content, 0);\n}\n\nstatic cmark_node *finalize(cmark_parser *parser, cmark_node *b) {\n  bufsize_t pos;\n  cmark_node *item;\n  cmark_node *subitem;\n  cmark_node *parent;\n  bool has_content;\n\n  parent = b->parent;\n  assert(b->flags &\n         CMARK_NODE__OPEN); // shouldn't call finalize on closed blocks\n  b->flags &= ~CMARK_NODE__OPEN;\n\n  if (parser->curline.size == 0) {\n    // end of input - line number has not been incremented\n    b->end_line = parser->line_number;\n    b->end_column = parser->last_line_length;\n  } else if (S_type(b) == CMARK_NODE_DOCUMENT ||\n             (S_type(b) == CMARK_NODE_CODE_BLOCK && b->as.code.fenced) ||\n             (S_type(b) == CMARK_NODE_HEADING && b->as.heading.setext)) {\n    b->end_line = parser->line_number;\n    b->end_column = parser->curline.size;\n    if (b->end_column && parser->curline.ptr[b->end_column - 1] == '\\n')\n      b->end_column -= 1;\n    if (b->end_column && parser->curline.ptr[b->end_column - 1] == '\\r')\n      b->end_column -= 1;\n  } else {\n    b->end_line = parser->line_number - 1;\n    b->end_column = parser->last_line_length;\n  }\n\n  cmark_strbuf *node_content = &b->content;\n\n  switch (S_type(b)) {\n  case CMARK_NODE_PARAGRAPH:\n  {\n    has_content = resolve_reference_link_definitions(parser, b);\n    if (!has_content) {\n      // remove blank node (former reference def)\n      cmark_node_free(b);\n    }\n    break;\n  }\n\n  case CMARK_NODE_CODE_BLOCK:\n    if (!b->as.code.fenced) { // indented code\n      remove_trailing_blank_lines(node_content);\n      cmark_strbuf_putc(node_content, '\\n');\n    } else {\n      // first line of contents becomes info\n      for (pos = 0; pos < node_content->size; ++pos) {\n        if (S_is_line_end_char(node_content->ptr[pos]))\n          break;\n      }\n      assert(pos < node_content->size);\n\n      cmark_strbuf tmp = CMARK_BUF_INIT(parser->mem);\n      houdini_unescape_html_f(&tmp, node_content->ptr, pos);\n      cmark_strbuf_trim(&tmp);\n      cmark_strbuf_unescape(&tmp);\n      b->as.code.info = cmark_chunk_buf_detach(&tmp);\n\n      if (node_content->ptr[pos] == '\\r')\n        pos += 1;\n      if (node_content->ptr[pos] == '\\n')\n        pos += 1;\n      cmark_strbuf_drop(node_content, pos);\n    }\n    b->as.code.literal = cmark_chunk_buf_detach(node_content);\n    break;\n\n  case CMARK_NODE_HTML_BLOCK:\n    b->as.literal = cmark_chunk_buf_detach(node_content);\n    break;\n\n  case CMARK_NODE_LIST:      // determine tight/loose status\n    b->as.list.tight = true; // tight by default\n    item = b->first_child;\n\n    while (item) {\n      // check for non-final non-empty list item ending with blank line:\n      if (S_last_line_blank(item) && item->next) {\n        b->as.list.tight = false;\n        break;\n      }\n      // recurse into children of list item, to see if there are\n      // spaces between them:\n      subitem = item->first_child;\n      while (subitem) {\n        if ((item->next || subitem->next) &&\n            S_ends_with_blank_line(subitem)) {\n          b->as.list.tight = false;\n          break;\n        }\n        subitem = subitem->next;\n      }\n      if (!(b->as.list.tight)) {\n        break;\n      }\n      item = item->next;\n    }\n\n    break;\n\n  default:\n    break;\n  }\n\n  return parent;\n}\n\n// Add a node as child of another.  Return pointer to child.\nstatic cmark_node *add_child(cmark_parser *parser, cmark_node *parent,\n                             cmark_node_type block_type, int start_column) {\n  assert(parent);\n\n  // if 'parent' isn't the kind of node that can accept this child,\n  // then back up til we hit a node that can.\n  while (!cmark_node_can_contain_type(parent, block_type)) {\n    parent = finalize(parser, parent);\n  }\n\n  cmark_node *child =\n      make_block(parser->mem, block_type, parser->line_number, start_column);\n  child->parent = parent;\n\n  if (parent->last_child) {\n    parent->last_child->next = child;\n    child->prev = parent->last_child;\n  } else {\n    parent->first_child = child;\n    child->prev = NULL;\n  }\n  parent->last_child = child;\n  return child;\n}\n\nvoid cmark_manage_extensions_special_characters(cmark_parser *parser, int add) {\n  cmark_llist *tmp_ext;\n\n  for (tmp_ext = parser->inline_syntax_extensions; tmp_ext; tmp_ext=tmp_ext->next) {\n    cmark_syntax_extension *ext = (cmark_syntax_extension *) tmp_ext->data;\n    cmark_llist *tmp_char;\n    for (tmp_char = ext->special_inline_chars; tmp_char; tmp_char=tmp_char->next) {\n      unsigned char c = (unsigned char)(size_t)tmp_char->data;\n      if (add)\n        cmark_inlines_add_special_character(c, ext->emphasis);\n      else\n        cmark_inlines_remove_special_character(c, ext->emphasis);\n    }\n  }\n}\n\n// Walk through node and all children, recursively, parsing\n// string content into inline content where appropriate.\nstatic void process_inlines(cmark_parser *parser,\n                            cmark_map *refmap, int options) {\n  cmark_iter *iter = cmark_iter_new(parser->root);\n  cmark_node *cur;\n  cmark_event_type ev_type;\n\n  cmark_manage_extensions_special_characters(parser, true);\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (ev_type == CMARK_EVENT_ENTER) {\n      if (contains_inlines(cur)) {\n        cmark_parse_inlines(parser, cur, refmap, options);\n      }\n    }\n  }\n\n  cmark_manage_extensions_special_characters(parser, false);\n\n  cmark_iter_free(iter);\n}\n\nstatic int sort_footnote_by_ix(const void *_a, const void *_b) {\n  cmark_footnote *a = *(cmark_footnote **)_a;\n  cmark_footnote *b = *(cmark_footnote **)_b;\n  return (int)a->ix - (int)b->ix;\n}\n\nstatic void process_footnotes(cmark_parser *parser) {\n  // * Collect definitions in a map.\n  // * Iterate the references in the document in order, assigning indices to\n  //   definitions in the order they're seen.\n  // * Write out the footnotes at the bottom of the document in index order.\n\n  cmark_map *map = cmark_footnote_map_new(parser->mem);\n\n  cmark_iter *iter = cmark_iter_new(parser->root);\n  cmark_node *cur;\n  cmark_event_type ev_type;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (ev_type == CMARK_EVENT_EXIT && cur->type == CMARK_NODE_FOOTNOTE_DEFINITION) {\n      cmark_footnote_create(map, cur);\n    }\n  }\n\n  cmark_iter_free(iter);\n  iter = cmark_iter_new(parser->root);\n  unsigned int ix = 0;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (ev_type == CMARK_EVENT_EXIT && cur->type == CMARK_NODE_FOOTNOTE_REFERENCE) {\n      cmark_footnote *footnote = (cmark_footnote *)cmark_map_lookup(map, &cur->as.literal);\n      if (footnote) {\n        if (!footnote->ix)\n          footnote->ix = ++ix;\n\n        // store a reference to this footnote reference's footnote definition\n        // this is used by renderers when generating label ids\n        cur->parent_footnote_def = footnote->node;\n\n        // keep track of a) count of how many times this footnote def has been\n        // referenced, and b) which reference index this footnote ref is at.\n        // this is used by renderers when generating links and backreferences.\n        cur->footnote.ref_ix = ++footnote->node->footnote.def_count;\n\n        char n[32];\n        snprintf(n, sizeof(n), \"%d\", footnote->ix);\n        cmark_chunk_free(parser->mem, &cur->as.literal);\n        cmark_strbuf buf = CMARK_BUF_INIT(parser->mem);\n        cmark_strbuf_puts(&buf, n);\n\n        cur->as.literal = cmark_chunk_buf_detach(&buf);\n      } else {\n        cmark_node *text = (cmark_node *)parser->mem->calloc(1, sizeof(*text));\n        cmark_strbuf_init(parser->mem, &text->content, 0);\n        text->type = (uint16_t) CMARK_NODE_TEXT;\n\n        cmark_strbuf buf = CMARK_BUF_INIT(parser->mem);\n        cmark_strbuf_puts(&buf, \"[^\");\n        cmark_strbuf_put(&buf, cur->as.literal.data, cur->as.literal.len);\n        cmark_strbuf_putc(&buf, ']');\n\n        text->as.literal = cmark_chunk_buf_detach(&buf);\n        cmark_node_insert_after(cur, text);\n        cmark_node_free(cur);\n      }\n    }\n  }\n\n  cmark_iter_free(iter);\n\n  if (map->sorted) {\n    qsort(map->sorted, map->size, sizeof(cmark_map_entry *), sort_footnote_by_ix);\n    for (unsigned int i = 0; i < map->size; ++i) {\n      cmark_footnote *footnote = (cmark_footnote *)map->sorted[i];\n      if (!footnote->ix) {\n        cmark_node_unlink(footnote->node);\n        continue;\n      }\n      cmark_node_append_child(parser->root, footnote->node);\n      footnote->node = NULL;\n    }\n  }\n\n  cmark_unlink_footnotes_map(map);\n  cmark_map_free(map);\n}\n\n// Attempts to parse a list item marker (bullet or enumerated).\n// On success, returns length of the marker, and populates\n// data with the details.  On failure, returns 0.\nstatic bufsize_t parse_list_marker(cmark_mem *mem, cmark_chunk *input,\n                                   bufsize_t pos, bool interrupts_paragraph,\n                                   cmark_list **dataptr) {\n  unsigned char c;\n  bufsize_t startpos;\n  cmark_list *data;\n  bufsize_t i;\n\n  startpos = pos;\n  c = peek_at(input, pos);\n\n  if (c == '*' || c == '-' || c == '+') {\n    pos++;\n    if (!cmark_isspace(peek_at(input, pos))) {\n      return 0;\n    }\n\n    if (interrupts_paragraph) {\n      i = pos;\n      // require non-blank content after list marker:\n      while (S_is_space_or_tab(peek_at(input, i))) {\n        i++;\n      }\n      if (peek_at(input, i) == '\\n') {\n        return 0;\n      }\n    }\n\n    data = (cmark_list *)mem->calloc(1, sizeof(*data));\n    data->marker_offset = 0; // will be adjusted later\n    data->list_type = CMARK_BULLET_LIST;\n    data->bullet_char = c;\n    data->start = 0;\n    data->delimiter = CMARK_NO_DELIM;\n    data->tight = false;\n  } else if (cmark_isdigit(c)) {\n    int start = 0;\n    int digits = 0;\n\n    do {\n      start = (10 * start) + (peek_at(input, pos) - '0');\n      pos++;\n      digits++;\n      // We limit to 9 digits to avoid overflow,\n      // assuming max int is 2^31 - 1\n      // This also seems to be the limit for 'start' in some browsers.\n    } while (digits < 9 && cmark_isdigit(peek_at(input, pos)));\n\n    if (interrupts_paragraph && start != 1) {\n      return 0;\n    }\n    c = peek_at(input, pos);\n    if (c == '.' || c == ')') {\n      pos++;\n      if (!cmark_isspace(peek_at(input, pos))) {\n        return 0;\n      }\n      if (interrupts_paragraph) {\n        // require non-blank content after list marker:\n        i = pos;\n        while (S_is_space_or_tab(peek_at(input, i))) {\n          i++;\n        }\n        if (S_is_line_end_char(peek_at(input, i))) {\n          return 0;\n        }\n      }\n\n      data = (cmark_list *)mem->calloc(1, sizeof(*data));\n      data->marker_offset = 0; // will be adjusted later\n      data->list_type = CMARK_ORDERED_LIST;\n      data->bullet_char = 0;\n      data->start = start;\n      data->delimiter = (c == '.' ? CMARK_PERIOD_DELIM : CMARK_PAREN_DELIM);\n      data->tight = false;\n    } else {\n      return 0;\n    }\n  } else {\n    return 0;\n  }\n\n  *dataptr = data;\n  return (pos - startpos);\n}\n\n// Return 1 if list item belongs in list, else 0.\nstatic int lists_match(cmark_list *list_data, cmark_list *item_data) {\n  return (list_data->list_type == item_data->list_type &&\n          list_data->delimiter == item_data->delimiter &&\n          // list_data->marker_offset == item_data.marker_offset &&\n          list_data->bullet_char == item_data->bullet_char);\n}\n\nstatic cmark_node *finalize_document(cmark_parser *parser) {\n  while (parser->current != parser->root) {\n    parser->current = finalize(parser, parser->current);\n  }\n\n  finalize(parser, parser->root);\n\n  // Limit total size of extra content created from reference links to\n  // document size to avoid superlinear growth. Always allow 100KB.\n  if (parser->total_size > 100000)\n    parser->refmap->max_ref_size = parser->total_size;\n  else\n    parser->refmap->max_ref_size = 100000;\n\n  process_inlines(parser, parser->refmap, parser->options);\n  if (parser->options & CMARK_OPT_FOOTNOTES)\n    process_footnotes(parser);\n\n  return parser->root;\n}\n\ncmark_node *cmark_parse_file(FILE *f, int options) {\n  unsigned char buffer[4096];\n  cmark_parser *parser = cmark_parser_new(options);\n  size_t bytes;\n  cmark_node *document;\n\n  while ((bytes = fread(buffer, 1, sizeof(buffer), f)) > 0) {\n    bool eof = bytes < sizeof(buffer);\n    S_parser_feed(parser, buffer, bytes, eof);\n    if (eof) {\n      break;\n    }\n  }\n\n  document = cmark_parser_finish(parser);\n  cmark_parser_free(parser);\n  return document;\n}\n\ncmark_node *cmark_parse_document(const char *buffer, size_t len, int options) {\n  cmark_parser *parser = cmark_parser_new(options);\n  cmark_node *document;\n\n  S_parser_feed(parser, (const unsigned char *)buffer, len, true);\n\n  document = cmark_parser_finish(parser);\n  cmark_parser_free(parser);\n  return document;\n}\n\nvoid cmark_parser_feed(cmark_parser *parser, const char *buffer, size_t len) {\n  S_parser_feed(parser, (const unsigned char *)buffer, len, false);\n}\n\nvoid cmark_parser_feed_reentrant(cmark_parser *parser, const char *buffer, size_t len) {\n  cmark_strbuf saved_linebuf;\n\n  cmark_strbuf_init(parser->mem, &saved_linebuf, 0);\n  cmark_strbuf_puts(&saved_linebuf, cmark_strbuf_cstr(&parser->linebuf));\n  cmark_strbuf_clear(&parser->linebuf);\n\n  S_parser_feed(parser, (const unsigned char *)buffer, len, true);\n\n  cmark_strbuf_sets(&parser->linebuf, cmark_strbuf_cstr(&saved_linebuf));\n  cmark_strbuf_free(&saved_linebuf);\n}\n\nstatic void S_parser_feed(cmark_parser *parser, const unsigned char *buffer,\n                          size_t len, bool eof) {\n  const unsigned char *end = buffer + len;\n  static const uint8_t repl[] = {239, 191, 189};\n\n  if (len > UINT_MAX - parser->total_size)\n    parser->total_size = UINT_MAX;\n  else\n    parser->total_size += len;\n\n  if (parser->last_buffer_ended_with_cr && *buffer == '\\n') {\n    // skip NL if last buffer ended with CR ; see #117\n    buffer++;\n  }\n  parser->last_buffer_ended_with_cr = false;\n  while (buffer < end) {\n    const unsigned char *eol;\n    bufsize_t chunk_len;\n    bool process = false;\n    for (eol = buffer; eol < end; ++eol) {\n      if (S_is_line_end_char(*eol)) {\n        process = true;\n        break;\n      }\n      if (*eol == '\\0' && eol < end) {\n        break;\n      }\n    }\n    if (eol >= end && eof) {\n      process = true;\n    }\n\n    chunk_len = (bufsize_t)(eol - buffer);\n    if (process) {\n      if (parser->linebuf.size > 0) {\n        cmark_strbuf_put(&parser->linebuf, buffer, chunk_len);\n        S_process_line(parser, parser->linebuf.ptr, parser->linebuf.size);\n        cmark_strbuf_clear(&parser->linebuf);\n      } else {\n        S_process_line(parser, buffer, chunk_len);\n      }\n    } else {\n      if (eol < end && *eol == '\\0') {\n        // omit NULL byte\n        cmark_strbuf_put(&parser->linebuf, buffer, chunk_len);\n        // add replacement character\n        cmark_strbuf_put(&parser->linebuf, repl, 3);\n      } else {\n        cmark_strbuf_put(&parser->linebuf, buffer, chunk_len);\n      }\n    }\n\n    buffer += chunk_len;\n    if (buffer < end) {\n      if (*buffer == '\\0') {\n        // skip over NULL\n        buffer++;\n      } else {\n        // skip over line ending characters\n        if (*buffer == '\\r') {\n          buffer++;\n          if (buffer == end)\n            parser->last_buffer_ended_with_cr = true;\n        }\n        if (buffer < end && *buffer == '\\n')\n          buffer++;\n      }\n    }\n  }\n}\n\nstatic void chop_trailing_hashtags(cmark_chunk *ch) {\n  bufsize_t n, orig_n;\n\n  cmark_chunk_rtrim(ch);\n  orig_n = n = ch->len - 1;\n\n  // if string ends in space followed by #s, remove these:\n  while (n >= 0 && peek_at(ch, n) == '#')\n    n--;\n\n  // Check for a space before the final #s:\n  if (n != orig_n && n >= 0 && S_is_space_or_tab(peek_at(ch, n))) {\n    ch->len = n;\n    cmark_chunk_rtrim(ch);\n  }\n}\n\n// Check for thematic break.  On failure, return 0 and update\n// thematic_break_kill_pos with the index at which the\n// parse fails.  On success, return length of match.\n// \"...three or more hyphens, asterisks,\n// or underscores on a line by themselves. If you wish, you may use\n// spaces between the hyphens or asterisks.\"\nstatic int S_scan_thematic_break(cmark_parser *parser, cmark_chunk *input,\n                                 bufsize_t offset) {\n  bufsize_t i;\n  char c;\n  char nextc = '\\0';\n  int count;\n  i = offset;\n  c = peek_at(input, i);\n  if (!(c == '*' || c == '_' || c == '-')) {\n    parser->thematic_break_kill_pos = i;\n    return 0;\n  }\n  count = 1;\n  while ((nextc = peek_at(input, ++i))) {\n    if (nextc == c) {\n      count++;\n    } else if (nextc != ' ' && nextc != '\\t') {\n      break;\n    }\n  }\n  if (count >= 3 && (nextc == '\\r' || nextc == '\\n')) {\n    return (i - offset) + 1;\n  } else {\n    parser->thematic_break_kill_pos = i;\n    return 0;\n  }\n}\n\n// Find first nonspace character from current offset, setting\n// parser->first_nonspace, parser->first_nonspace_column,\n// parser->indent, and parser->blank. Does not advance parser->offset.\nstatic void S_find_first_nonspace(cmark_parser *parser, cmark_chunk *input) {\n  char c;\n  int chars_to_tab = TAB_STOP - (parser->column % TAB_STOP);\n\n  if (parser->first_nonspace <= parser->offset) {\n    parser->first_nonspace = parser->offset;\n    parser->first_nonspace_column = parser->column;\n    while ((c = peek_at(input, parser->first_nonspace))) {\n      if (c == ' ') {\n        parser->first_nonspace += 1;\n        parser->first_nonspace_column += 1;\n        chars_to_tab = chars_to_tab - 1;\n        if (chars_to_tab == 0) {\n          chars_to_tab = TAB_STOP;\n        }\n      } else if (c == '\\t') {\n        parser->first_nonspace += 1;\n        parser->first_nonspace_column += chars_to_tab;\n        chars_to_tab = TAB_STOP;\n      } else {\n        break;\n      }\n    }\n  }\n\n  parser->indent = parser->first_nonspace_column - parser->column;\n  parser->blank = S_is_line_end_char(peek_at(input, parser->first_nonspace));\n}\n\n// Advance parser->offset and parser->column.  parser->offset is the\n// byte position in input; parser->column is a virtual column number\n// that takes into account tabs. (Multibyte characters are not taken\n// into account, because the Markdown line prefixes we are interested in\n// analyzing are entirely ASCII.)  The count parameter indicates\n// how far to advance the offset.  If columns is true, then count\n// indicates a number of columns; otherwise, a number of bytes.\n// If advancing a certain number of columns partially consumes\n// a tab character, parser->partially_consumed_tab is set to true.\nstatic void S_advance_offset(cmark_parser *parser, cmark_chunk *input,\n                             bufsize_t count, bool columns) {\n  char c;\n  int chars_to_tab;\n  int chars_to_advance;\n  while (count > 0 && (c = peek_at(input, parser->offset))) {\n    if (c == '\\t') {\n      chars_to_tab = TAB_STOP - (parser->column % TAB_STOP);\n      if (columns) {\n        parser->partially_consumed_tab = chars_to_tab > count;\n        chars_to_advance = MIN(count, chars_to_tab);\n        parser->column += chars_to_advance;\n        parser->offset += (parser->partially_consumed_tab ? 0 : 1);\n        count -= chars_to_advance;\n      } else {\n        parser->partially_consumed_tab = false;\n        parser->column += chars_to_tab;\n        parser->offset += 1;\n        count -= 1;\n      }\n    } else {\n      parser->partially_consumed_tab = false;\n      parser->offset += 1;\n      parser->column += 1; // assume ascii; block starts are ascii\n      count -= 1;\n    }\n  }\n}\n\nstatic bool S_last_child_is_open(cmark_node *container) {\n  return container->last_child &&\n         (container->last_child->flags & CMARK_NODE__OPEN);\n}\n\nstatic bool parse_block_quote_prefix(cmark_parser *parser, cmark_chunk *input) {\n  bool res = false;\n  bufsize_t matched = 0;\n\n  matched =\n      parser->indent <= 3 && peek_at(input, parser->first_nonspace) == '>';\n  if (matched) {\n\n    S_advance_offset(parser, input, parser->indent + 1, true);\n\n    if (S_is_space_or_tab(peek_at(input, parser->offset))) {\n      S_advance_offset(parser, input, 1, true);\n    }\n\n    res = true;\n  }\n  return res;\n}\n\nstatic bool parse_footnote_definition_block_prefix(cmark_parser *parser, cmark_chunk *input,\n                                                   cmark_node *container) {\n  if (parser->indent >= 4) {\n    S_advance_offset(parser, input, 4, true);\n    return true;\n  } else if (input->len > 0 && (input->data[0] == '\\n' || (input->data[0] == '\\r' && input->data[1] == '\\n'))) {\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool parse_node_item_prefix(cmark_parser *parser, cmark_chunk *input,\n                                   cmark_node *container) {\n  bool res = false;\n\n  if (parser->indent >=\n      container->as.list.marker_offset + container->as.list.padding) {\n    S_advance_offset(parser, input, container->as.list.marker_offset +\n                                        container->as.list.padding,\n                     true);\n    res = true;\n  } else if (parser->blank && container->first_child != NULL) {\n    // if container->first_child is NULL, then the opening line\n    // of the list item was blank after the list marker; in this\n    // case, we are done with the list item.\n    S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                     false);\n    res = true;\n  }\n  return res;\n}\n\nstatic bool parse_code_block_prefix(cmark_parser *parser, cmark_chunk *input,\n                                    cmark_node *container,\n                                    bool *should_continue) {\n  bool res = false;\n\n  if (!container->as.code.fenced) { // indented\n    if (parser->indent >= CODE_INDENT) {\n      S_advance_offset(parser, input, CODE_INDENT, true);\n      res = true;\n    } else if (parser->blank) {\n      S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                       false);\n      res = true;\n    }\n  } else { // fenced\n    bufsize_t matched = 0;\n\n    if (parser->indent <= 3 && (peek_at(input, parser->first_nonspace) ==\n                                container->as.code.fence_char)) {\n      matched = scan_close_code_fence(input, parser->first_nonspace);\n    }\n\n    if (matched >= container->as.code.fence_length) {\n      // closing fence - and since we're at\n      // the end of a line, we can stop processing it:\n      *should_continue = false;\n      S_advance_offset(parser, input, matched, false);\n      parser->current = finalize(parser, container);\n    } else {\n      // skip opt. spaces of fence parser->offset\n      int i = container->as.code.fence_offset;\n\n      while (i > 0 && S_is_space_or_tab(peek_at(input, parser->offset))) {\n        S_advance_offset(parser, input, 1, true);\n        i--;\n      }\n      res = true;\n    }\n  }\n\n  return res;\n}\n\nstatic bool parse_html_block_prefix(cmark_parser *parser,\n                                    cmark_node *container) {\n  bool res = false;\n  int html_block_type = container->as.html_block_type;\n\n  assert(html_block_type >= 1 && html_block_type <= 7);\n  switch (html_block_type) {\n  case 1:\n  case 2:\n  case 3:\n  case 4:\n  case 5:\n    // these types of blocks can accept blanks\n    res = true;\n    break;\n  case 6:\n  case 7:\n    res = !parser->blank;\n    break;\n  }\n\n  return res;\n}\n\nstatic bool parse_extension_block(cmark_parser *parser,\n                                  cmark_node *container,\n                                  cmark_chunk *input)\n{\n  bool res = false;\n\n  if (container->extension->last_block_matches) {\n    if (container->extension->last_block_matches(\n        container->extension, parser, input->data, input->len, container))\n      res = true;\n  }\n\n  return res;\n}\n\n/**\n * For each containing node, try to parse the associated line start.\n *\n * Will not close unmatched blocks, as we may have a lazy continuation\n * line -> http://spec.commonmark.org/0.24/#lazy-continuation-line\n *\n * Returns: The last matching node, or NULL\n */\nstatic cmark_node *check_open_blocks(cmark_parser *parser, cmark_chunk *input,\n                                     bool *all_matched) {\n  bool should_continue = true;\n  *all_matched = false;\n  cmark_node *container = parser->root;\n  cmark_node_type cont_type;\n\n  while (S_last_child_is_open(container)) {\n    container = container->last_child;\n    cont_type = S_type(container);\n\n    S_find_first_nonspace(parser, input);\n\n    if (container->extension) {\n      if (!parse_extension_block(parser, container, input))\n        goto done;\n      continue;\n    }\n\n    switch (cont_type) {\n    case CMARK_NODE_BLOCK_QUOTE:\n      if (!parse_block_quote_prefix(parser, input))\n        goto done;\n      break;\n    case CMARK_NODE_ITEM:\n      if (!parse_node_item_prefix(parser, input, container))\n        goto done;\n      break;\n    case CMARK_NODE_CODE_BLOCK:\n      if (!parse_code_block_prefix(parser, input, container, &should_continue))\n        goto done;\n      break;\n    case CMARK_NODE_HEADING:\n      // a heading can never contain more than one line\n      goto done;\n    case CMARK_NODE_HTML_BLOCK:\n      if (!parse_html_block_prefix(parser, container))\n        goto done;\n      break;\n    case CMARK_NODE_PARAGRAPH:\n      if (parser->blank)\n        goto done;\n      break;\n\t\tcase CMARK_NODE_FOOTNOTE_DEFINITION:\n\t\t\tif (!parse_footnote_definition_block_prefix(parser, input, container))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n    default:\n      break;\n    }\n  }\n\n  *all_matched = true;\n\ndone:\n  if (!*all_matched) {\n    container = container->parent; // back up to last matching node\n  }\n\n  if (!should_continue) {\n    container = NULL;\n  }\n\n  return container;\n}\n\nstatic void open_new_blocks(cmark_parser *parser, cmark_node **container,\n                            cmark_chunk *input, bool all_matched) {\n  bool indented;\n  cmark_list *data = NULL;\n  bool maybe_lazy = S_type(parser->current) == CMARK_NODE_PARAGRAPH;\n  cmark_node_type cont_type = S_type(*container);\n  bufsize_t matched = 0;\n  int lev = 0;\n  bool save_partially_consumed_tab;\n  bool has_content;\n  int save_offset;\n  int save_column;\n\n  while (cont_type != CMARK_NODE_CODE_BLOCK &&\n         cont_type != CMARK_NODE_HTML_BLOCK) {\n\n    S_find_first_nonspace(parser, input);\n    indented = parser->indent >= CODE_INDENT;\n\n    if (!indented && peek_at(input, parser->first_nonspace) == '>') {\n\n      bufsize_t blockquote_startpos = parser->first_nonspace;\n\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + 1 - parser->offset, false);\n      // optional following character\n      if (S_is_space_or_tab(peek_at(input, parser->offset))) {\n        S_advance_offset(parser, input, 1, true);\n      }\n      *container = add_child(parser, *container, CMARK_NODE_BLOCK_QUOTE,\n                             blockquote_startpos + 1);\n\n    } else if (!indented && (matched = scan_atx_heading_start(\n                                 input, parser->first_nonspace))) {\n      bufsize_t hashpos;\n      int level = 0;\n      bufsize_t heading_startpos = parser->first_nonspace;\n\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + matched - parser->offset,\n                       false);\n      *container = add_child(parser, *container, CMARK_NODE_HEADING,\n                             heading_startpos + 1);\n\n      hashpos = cmark_chunk_strchr(input, '#', parser->first_nonspace);\n\n      while (peek_at(input, hashpos) == '#') {\n        level++;\n        hashpos++;\n      }\n\n      (*container)->as.heading.level = level;\n      (*container)->as.heading.setext = false;\n      (*container)->internal_offset = matched;\n\n    } else if (!indented && (matched = scan_open_code_fence(\n                                 input, parser->first_nonspace))) {\n      *container = add_child(parser, *container, CMARK_NODE_CODE_BLOCK,\n                             parser->first_nonspace + 1);\n      (*container)->as.code.fenced = true;\n      (*container)->as.code.fence_char = peek_at(input, parser->first_nonspace);\n      (*container)->as.code.fence_length = (matched > 255) ? 255 : (uint8_t)matched;\n      (*container)->as.code.fence_offset =\n          (int8_t)(parser->first_nonspace - parser->offset);\n      (*container)->as.code.info = cmark_chunk_literal(\"\");\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + matched - parser->offset,\n                       false);\n\n    } else if (!indented && ((matched = scan_html_block_start(\n                                  input, parser->first_nonspace)) ||\n                             (cont_type != CMARK_NODE_PARAGRAPH &&\n                              (matched = scan_html_block_start_7(\n                                   input, parser->first_nonspace))))) {\n      *container = add_child(parser, *container, CMARK_NODE_HTML_BLOCK,\n                             parser->first_nonspace + 1);\n      (*container)->as.html_block_type = matched;\n      // note, we don't adjust parser->offset because the tag is part of the\n      // text\n    } else if (!indented && cont_type == CMARK_NODE_PARAGRAPH &&\n               (lev =\n                    scan_setext_heading_line(input, parser->first_nonspace))) {\n      // finalize paragraph, resolving reference links\n      has_content = resolve_reference_link_definitions(parser, *container);\n\n      if (has_content) {\n\n        (*container)->type = (uint16_t)CMARK_NODE_HEADING;\n        (*container)->as.heading.level = lev;\n        (*container)->as.heading.setext = true;\n        S_advance_offset(parser, input, input->len - 1 - parser->offset, false);\n      }\n    } else if (!indented &&\n               !(cont_type == CMARK_NODE_PARAGRAPH && !all_matched) &&\n\t       (parser->thematic_break_kill_pos <= parser->first_nonspace) &&\n               (matched = S_scan_thematic_break(parser, input, parser->first_nonspace))) {\n      // it's only now that we know the line is not part of a setext heading:\n      *container = add_child(parser, *container, CMARK_NODE_THEMATIC_BREAK,\n                             parser->first_nonspace + 1);\n      S_advance_offset(parser, input, input->len - 1 - parser->offset, false);\n    } else if (!indented &&\n               parser->options & CMARK_OPT_FOOTNOTES &&\n               (matched = scan_footnote_definition(input, parser->first_nonspace))) {\n      cmark_chunk c = cmark_chunk_dup(input, parser->first_nonspace + 2, matched - 2);\n      cmark_chunk_to_cstr(parser->mem, &c);\n\n      while (c.data[c.len - 1] != ']')\n        --c.len;\n      --c.len;\n\n      S_advance_offset(parser, input, parser->first_nonspace + matched - parser->offset, false);\n      *container = add_child(parser, *container, CMARK_NODE_FOOTNOTE_DEFINITION, parser->first_nonspace + matched + 1);\n      (*container)->as.literal = c;\n\n      (*container)->internal_offset = matched;\n    } else if ((!indented || cont_type == CMARK_NODE_LIST) &&\n\t       parser->indent < 4 &&\n               (matched = parse_list_marker(\n                    parser->mem, input, parser->first_nonspace,\n                    (*container)->type == CMARK_NODE_PARAGRAPH, &data))) {\n\n      // Note that we can have new list items starting with >= 4\n      // spaces indent, as long as the list container is still open.\n      int i = 0;\n\n      // compute padding:\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + matched - parser->offset,\n                       false);\n\n      save_partially_consumed_tab = parser->partially_consumed_tab;\n      save_offset = parser->offset;\n      save_column = parser->column;\n\n      while (parser->column - save_column <= 5 &&\n             S_is_space_or_tab(peek_at(input, parser->offset))) {\n        S_advance_offset(parser, input, 1, true);\n      }\n\n      i = parser->column - save_column;\n      if (i >= 5 || i < 1 ||\n          // only spaces after list marker:\n          S_is_line_end_char(peek_at(input, parser->offset))) {\n        data->padding = matched + 1;\n        parser->offset = save_offset;\n        parser->column = save_column;\n        parser->partially_consumed_tab = save_partially_consumed_tab;\n        if (i > 0) {\n          S_advance_offset(parser, input, 1, true);\n        }\n      } else {\n        data->padding = matched + i;\n      }\n\n      // check container; if it's a list, see if this list item\n      // can continue the list; otherwise, create a list container.\n\n      data->marker_offset = parser->indent;\n\n      if (cont_type != CMARK_NODE_LIST ||\n          !lists_match(&((*container)->as.list), data)) {\n        *container = add_child(parser, *container, CMARK_NODE_LIST,\n                               parser->first_nonspace + 1);\n\n        memcpy(&((*container)->as.list), data, sizeof(*data));\n      }\n\n      // add the list item\n      *container = add_child(parser, *container, CMARK_NODE_ITEM,\n                             parser->first_nonspace + 1);\n      /* TODO: static */\n      memcpy(&((*container)->as.list), data, sizeof(*data));\n      parser->mem->free(data);\n    } else if (indented && !maybe_lazy && !parser->blank) {\n      S_advance_offset(parser, input, CODE_INDENT, true);\n      *container = add_child(parser, *container, CMARK_NODE_CODE_BLOCK,\n                             parser->offset + 1);\n      (*container)->as.code.fenced = false;\n      (*container)->as.code.fence_char = 0;\n      (*container)->as.code.fence_length = 0;\n      (*container)->as.code.fence_offset = 0;\n      (*container)->as.code.info = cmark_chunk_literal(\"\");\n    } else {\n      cmark_llist *tmp;\n      cmark_node *new_container = NULL;\n\n      for (tmp = parser->syntax_extensions; tmp; tmp=tmp->next) {\n        cmark_syntax_extension *ext = (cmark_syntax_extension *) tmp->data;\n\n        if (ext->try_opening_block) {\n          new_container = ext->try_opening_block(\n              ext, indented, parser, *container, input->data, input->len);\n\n          if (new_container) {\n            *container = new_container;\n            break;\n          }\n        }\n      }\n\n      if (!new_container) {\n        break;\n      }\n    }\n\n    if (accepts_lines(S_type(*container))) {\n      // if it's a line container, it can't contain other containers\n      break;\n    }\n\n    cont_type = S_type(*container);\n    maybe_lazy = false;\n  }\n}\n\nstatic void add_text_to_container(cmark_parser *parser, cmark_node *container,\n                                  cmark_node *last_matched_container,\n                                  cmark_chunk *input) {\n  cmark_node *tmp;\n  // what remains at parser->offset is a text line.  add the text to the\n  // appropriate container.\n\n  S_find_first_nonspace(parser, input);\n\n  if (parser->blank && container->last_child)\n    S_set_last_line_blank(container->last_child, true);\n\n  // block quote lines are never blank as they start with >\n  // and we don't count blanks in fenced code for purposes of tight/loose\n  // lists or breaking out of lists.  we also don't set last_line_blank\n  // on an empty list item.\n  const cmark_node_type ctype = S_type(container);\n  const bool last_line_blank =\n      (parser->blank && ctype != CMARK_NODE_BLOCK_QUOTE &&\n       ctype != CMARK_NODE_HEADING && ctype != CMARK_NODE_THEMATIC_BREAK &&\n       !(ctype == CMARK_NODE_CODE_BLOCK && container->as.code.fenced) &&\n       !(ctype == CMARK_NODE_ITEM && container->first_child == NULL &&\n         container->start_line == parser->line_number));\n\n  S_set_last_line_blank(container, last_line_blank);\n\n  tmp = container;\n  while (tmp->parent) {\n    S_set_last_line_blank(tmp->parent, false);\n    tmp = tmp->parent;\n  }\n\n  // If the last line processed belonged to a paragraph node,\n  // and we didn't match all of the line prefixes for the open containers,\n  // and we didn't start any new containers,\n  // and the line isn't blank,\n  // then treat this as a \"lazy continuation line\" and add it to\n  // the open paragraph.\n  if (parser->current != last_matched_container &&\n      container == last_matched_container && !parser->blank &&\n      S_type(parser->current) == CMARK_NODE_PARAGRAPH) {\n    add_line(parser->current, input, parser);\n  } else { // not a lazy continuation\n    // Finalize any blocks that were not matched and set cur to container:\n    while (parser->current != last_matched_container) {\n      parser->current = finalize(parser, parser->current);\n      assert(parser->current != NULL);\n    }\n\n    if (S_type(container) == CMARK_NODE_CODE_BLOCK) {\n      add_line(container, input, parser);\n    } else if (S_type(container) == CMARK_NODE_HTML_BLOCK) {\n      add_line(container, input, parser);\n\n      int matches_end_condition;\n      switch (container->as.html_block_type) {\n      case 1:\n        // </script>, </style>, </pre>\n        matches_end_condition =\n            scan_html_block_end_1(input, parser->first_nonspace);\n        break;\n      case 2:\n        // -->\n        matches_end_condition =\n            scan_html_block_end_2(input, parser->first_nonspace);\n        break;\n      case 3:\n        // ?>\n        matches_end_condition =\n            scan_html_block_end_3(input, parser->first_nonspace);\n        break;\n      case 4:\n        // >\n        matches_end_condition =\n            scan_html_block_end_4(input, parser->first_nonspace);\n        break;\n      case 5:\n        // ]]>\n        matches_end_condition =\n            scan_html_block_end_5(input, parser->first_nonspace);\n        break;\n      default:\n        matches_end_condition = 0;\n        break;\n      }\n\n      if (matches_end_condition) {\n        container = finalize(parser, container);\n        assert(parser->current != NULL);\n      }\n    } else if (parser->blank) {\n      // ??? do nothing\n    } else if (accepts_lines(S_type(container))) {\n      if (S_type(container) == CMARK_NODE_HEADING &&\n          container->as.heading.setext == false) {\n        chop_trailing_hashtags(input);\n      }\n      S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                       false);\n      add_line(container, input, parser);\n    } else {\n      // create paragraph container for line\n      container = add_child(parser, container, CMARK_NODE_PARAGRAPH,\n                            parser->first_nonspace + 1);\n      S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                       false);\n      add_line(container, input, parser);\n    }\n\n    parser->current = container;\n  }\n}\n\n/* See http://spec.commonmark.org/0.24/#phase-1-block-structure */\nstatic void S_process_line(cmark_parser *parser, const unsigned char *buffer,\n                           bufsize_t bytes) {\n  cmark_node *last_matched_container;\n  bool all_matched = true;\n  cmark_node *container;\n  cmark_chunk input;\n  cmark_node *current;\n\n  cmark_strbuf_clear(&parser->curline);\n\n  if (parser->options & CMARK_OPT_VALIDATE_UTF8)\n    cmark_utf8proc_check(&parser->curline, buffer, bytes);\n  else\n    cmark_strbuf_put(&parser->curline, buffer, bytes);\n\n  bytes = parser->curline.size;\n\n  // ensure line ends with a newline:\n  if (bytes == 0 || !S_is_line_end_char(parser->curline.ptr[bytes - 1]))\n    cmark_strbuf_putc(&parser->curline, '\\n');\n\n  parser->offset = 0;\n  parser->column = 0;\n  parser->first_nonspace = 0;\n  parser->first_nonspace_column = 0;\n  parser->thematic_break_kill_pos = 0;\n  parser->indent = 0;\n  parser->blank = false;\n  parser->partially_consumed_tab = false;\n\n  input.data = parser->curline.ptr;\n  input.len = parser->curline.size;\n  input.alloc = 0;\n\n  // Skip UTF-8 BOM.\n  if (parser->line_number == 0 &&\n      input.len >= 3 &&\n      memcmp(input.data, \"\\xef\\xbb\\xbf\", 3) == 0)\n    parser->offset += 3;\n\n  parser->line_number++;\n\n  last_matched_container = check_open_blocks(parser, &input, &all_matched);\n\n  if (!last_matched_container)\n    goto finished;\n\n  container = last_matched_container;\n\n  current = parser->current;\n\n  open_new_blocks(parser, &container, &input, all_matched);\n\n  /* parser->current might have changed if feed_reentrant was called */\n  if (current == parser->current)\n  add_text_to_container(parser, container, last_matched_container, &input);\n\nfinished:\n  parser->last_line_length = input.len;\n  if (parser->last_line_length &&\n      input.data[parser->last_line_length - 1] == '\\n')\n    parser->last_line_length -= 1;\n  if (parser->last_line_length &&\n      input.data[parser->last_line_length - 1] == '\\r')\n    parser->last_line_length -= 1;\n\n  cmark_strbuf_clear(&parser->curline);\n}\n\ncmark_node *cmark_parser_finish(cmark_parser *parser) {\n  cmark_node *res;\n  cmark_llist *extensions;\n\n  /* Parser was already finished once */\n  if (parser->root == NULL)\n    return NULL;\n\n  if (parser->linebuf.size) {\n    S_process_line(parser, parser->linebuf.ptr, parser->linebuf.size);\n    cmark_strbuf_clear(&parser->linebuf);\n  }\n\n  finalize_document(parser);\n\n  cmark_consolidate_text_nodes(parser->root);\n\n  cmark_strbuf_free(&parser->curline);\n  cmark_strbuf_free(&parser->linebuf);\n\n#if CMARK_DEBUG_NODES\n  if (cmark_node_check(parser->root, stderr)) {\n    abort();\n  }\n#endif\n\n  for (extensions = parser->syntax_extensions; extensions; extensions = extensions->next) {\n    cmark_syntax_extension *ext = (cmark_syntax_extension *) extensions->data;\n    if (ext->postprocess_func) {\n      cmark_node *processed = ext->postprocess_func(ext, parser, parser->root);\n      if (processed)\n        parser->root = processed;\n    }\n  }\n\n  res = parser->root;\n  parser->root = NULL;\n\n  cmark_parser_reset(parser);\n\n  return res;\n}\n\nint cmark_parser_get_line_number(cmark_parser *parser) {\n  return parser->line_number;\n}\n\nbufsize_t cmark_parser_get_offset(cmark_parser *parser) {\n  return parser->offset;\n}\n\nbufsize_t cmark_parser_get_column(cmark_parser *parser) {\n  return parser->column;\n}\n\nint cmark_parser_get_first_nonspace(cmark_parser *parser) {\n  return parser->first_nonspace;\n}\n\nint cmark_parser_get_first_nonspace_column(cmark_parser *parser) {\n  return parser->first_nonspace_column;\n}\n\nint cmark_parser_get_indent(cmark_parser *parser) {\n  return parser->indent;\n}\n\nint cmark_parser_is_blank(cmark_parser *parser) {\n  return parser->blank;\n}\n\nint cmark_parser_has_partially_consumed_tab(cmark_parser *parser) {\n  return parser->partially_consumed_tab;\n}\n\nint cmark_parser_get_last_line_length(cmark_parser *parser) {\n  return parser->last_line_length;\n}\n\ncmark_node *cmark_parser_add_child(cmark_parser *parser,\n                                   cmark_node   *parent,\n                                   cmark_node_type block_type,\n                                   int start_column) {\n  return add_child(parser, parent, block_type, start_column);\n}\n\nvoid cmark_parser_advance_offset(cmark_parser *parser,\n                                 const char *input,\n                                 int count,\n                                 int columns) {\n  cmark_chunk input_chunk = cmark_chunk_literal(input);\n\n  S_advance_offset(parser, &input_chunk, count, columns != 0);\n}\n\nvoid cmark_parser_set_backslash_ispunct_func(cmark_parser *parser,\n                                             cmark_ispunct_func func) {\n  parser->backslash_ispunct = func;\n}\n\ncmark_llist *cmark_parser_get_syntax_extensions(cmark_parser *parser) {\n  return parser->syntax_extensions;\n}\n", "#ifndef CMARK_GFM_H\n#define CMARK_GFM_H\n\n#include <stdio.h>\n#include <stdint.h>\n#include \"cmark-gfm_export.h\"\n#include \"cmark-gfm_version.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/** # NAME\n *\n * **cmark-gfm** - CommonMark parsing, manipulating, and rendering\n */\n\n/** # DESCRIPTION\n *\n * ## Simple Interface\n */\n\n/** Convert 'text' (assumed to be a UTF-8 encoded string with length\n * 'len') from CommonMark Markdown to HTML, returning a null-terminated,\n * UTF-8-encoded string. It is the caller's responsibility\n * to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_markdown_to_html(const char *text, size_t len, int options);\n\n/** ## Node Structure\n */\n\n#define CMARK_NODE_TYPE_PRESENT (0x8000)\n#define CMARK_NODE_TYPE_BLOCK (CMARK_NODE_TYPE_PRESENT | 0x0000)\n#define CMARK_NODE_TYPE_INLINE (CMARK_NODE_TYPE_PRESENT | 0x4000)\n#define CMARK_NODE_TYPE_MASK (0xc000)\n#define CMARK_NODE_VALUE_MASK (0x3fff)\n\ntypedef enum {\n  /* Error status */\n  CMARK_NODE_NONE = 0x0000,\n\n  /* Block */\n  CMARK_NODE_DOCUMENT       = CMARK_NODE_TYPE_BLOCK | 0x0001,\n  CMARK_NODE_BLOCK_QUOTE    = CMARK_NODE_TYPE_BLOCK | 0x0002,\n  CMARK_NODE_LIST           = CMARK_NODE_TYPE_BLOCK | 0x0003,\n  CMARK_NODE_ITEM           = CMARK_NODE_TYPE_BLOCK | 0x0004,\n  CMARK_NODE_CODE_BLOCK     = CMARK_NODE_TYPE_BLOCK | 0x0005,\n  CMARK_NODE_HTML_BLOCK     = CMARK_NODE_TYPE_BLOCK | 0x0006,\n  CMARK_NODE_CUSTOM_BLOCK   = CMARK_NODE_TYPE_BLOCK | 0x0007,\n  CMARK_NODE_PARAGRAPH      = CMARK_NODE_TYPE_BLOCK | 0x0008,\n  CMARK_NODE_HEADING        = CMARK_NODE_TYPE_BLOCK | 0x0009,\n  CMARK_NODE_THEMATIC_BREAK = CMARK_NODE_TYPE_BLOCK | 0x000a,\n  CMARK_NODE_FOOTNOTE_DEFINITION = CMARK_NODE_TYPE_BLOCK | 0x000b,\n\n  /* Inline */\n  CMARK_NODE_TEXT          = CMARK_NODE_TYPE_INLINE | 0x0001,\n  CMARK_NODE_SOFTBREAK     = CMARK_NODE_TYPE_INLINE | 0x0002,\n  CMARK_NODE_LINEBREAK     = CMARK_NODE_TYPE_INLINE | 0x0003,\n  CMARK_NODE_CODE          = CMARK_NODE_TYPE_INLINE | 0x0004,\n  CMARK_NODE_HTML_INLINE   = CMARK_NODE_TYPE_INLINE | 0x0005,\n  CMARK_NODE_CUSTOM_INLINE = CMARK_NODE_TYPE_INLINE | 0x0006,\n  CMARK_NODE_EMPH          = CMARK_NODE_TYPE_INLINE | 0x0007,\n  CMARK_NODE_STRONG        = CMARK_NODE_TYPE_INLINE | 0x0008,\n  CMARK_NODE_LINK          = CMARK_NODE_TYPE_INLINE | 0x0009,\n  CMARK_NODE_IMAGE         = CMARK_NODE_TYPE_INLINE | 0x000a,\n  CMARK_NODE_FOOTNOTE_REFERENCE = CMARK_NODE_TYPE_INLINE | 0x000b,\n} cmark_node_type;\n\nextern cmark_node_type CMARK_NODE_LAST_BLOCK;\nextern cmark_node_type CMARK_NODE_LAST_INLINE;\n\n/* For backwards compatibility: */\n#define CMARK_NODE_HEADER CMARK_NODE_HEADING\n#define CMARK_NODE_HRULE CMARK_NODE_THEMATIC_BREAK\n#define CMARK_NODE_HTML CMARK_NODE_HTML_BLOCK\n#define CMARK_NODE_INLINE_HTML CMARK_NODE_HTML_INLINE\n\ntypedef enum {\n  CMARK_NO_LIST,\n  CMARK_BULLET_LIST,\n  CMARK_ORDERED_LIST\n} cmark_list_type;\n\ntypedef enum {\n  CMARK_NO_DELIM,\n  CMARK_PERIOD_DELIM,\n  CMARK_PAREN_DELIM\n} cmark_delim_type;\n\ntypedef struct cmark_node cmark_node;\ntypedef struct cmark_parser cmark_parser;\ntypedef struct cmark_iter cmark_iter;\ntypedef struct cmark_syntax_extension cmark_syntax_extension;\n\n/**\n * ## Custom memory allocator support\n */\n\n/** Defines the memory allocation functions to be used by CMark\n * when parsing and allocating a document tree\n */\ntypedef struct cmark_mem {\n  void *(*calloc)(size_t, size_t);\n  void *(*realloc)(void *, size_t);\n  void (*free)(void *);\n} cmark_mem;\n\n/** The default memory allocator; uses the system's calloc,\n * realloc and free.\n */\nCMARK_GFM_EXPORT\ncmark_mem *cmark_get_default_mem_allocator(void);\n\n/** An arena allocator; uses system calloc to allocate large\n * slabs of memory.  Memory in these slabs is not reused at all.\n */\nCMARK_GFM_EXPORT\ncmark_mem *cmark_get_arena_mem_allocator(void);\n\n/** Resets the arena allocator, quickly returning all used memory\n * to the operating system.\n */\nCMARK_GFM_EXPORT\nvoid cmark_arena_reset(void);\n\n/** Callback for freeing user data with a 'cmark_mem' context.\n */\ntypedef void (*cmark_free_func) (cmark_mem *mem, void *user_data);\n\n\n/*\n * ## Basic data structures\n *\n * To keep dependencies to the strict minimum, libcmark implements\n * its own versions of \"classic\" data structures.\n */\n\n/**\n * ### Linked list\n */\n\n/** A generic singly linked list.\n */\ntypedef struct _cmark_llist\n{\n  struct _cmark_llist *next;\n  void         *data;\n} cmark_llist;\n\n/** Append an element to the linked list, return the possibly modified\n * head of the list.\n */\nCMARK_GFM_EXPORT\ncmark_llist * cmark_llist_append    (cmark_mem         * mem,\n                                     cmark_llist       * head,\n                                     void              * data);\n\n/** Free the list starting with 'head', calling 'free_func' with the\n *  data pointer of each of its elements\n */\nCMARK_GFM_EXPORT\nvoid          cmark_llist_free_full (cmark_mem         * mem,\n                                     cmark_llist       * head,\n                                     cmark_free_func     free_func);\n\n/** Free the list starting with 'head'\n */\nCMARK_GFM_EXPORT\nvoid          cmark_llist_free      (cmark_mem         * mem,\n                                     cmark_llist       * head);\n\n/**\n * ## Creating and Destroying Nodes\n */\n\n/** Creates a new node of type 'type'.  Note that the node may have\n * other required properties, which it is the caller's responsibility\n * to assign.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_new(cmark_node_type type);\n\n/** Same as `cmark_node_new`, but explicitly listing the memory\n * allocator used to allocate the node.  Note:  be sure to use the same\n * allocator for every node in a tree, or bad things can happen.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_new_with_mem(cmark_node_type type,\n                                                 cmark_mem *mem);\n\nCMARK_GFM_EXPORT cmark_node *cmark_node_new_with_ext(cmark_node_type type,\n                                                cmark_syntax_extension *extension);\n\nCMARK_GFM_EXPORT cmark_node *cmark_node_new_with_mem_and_ext(cmark_node_type type,\n                                                cmark_mem *mem,\n                                                cmark_syntax_extension *extension);\n\n/** Frees the memory allocated for a node and any children.\n */\nCMARK_GFM_EXPORT void cmark_node_free(cmark_node *node);\n\n/**\n * ## Tree Traversal\n */\n\n/** Returns the next node in the sequence after 'node', or NULL if\n * there is none.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_next(cmark_node *node);\n\n/** Returns the previous node in the sequence after 'node', or NULL if\n * there is none.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_previous(cmark_node *node);\n\n/** Returns the parent of 'node', or NULL if there is none.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_parent(cmark_node *node);\n\n/** Returns the first child of 'node', or NULL if 'node' has no children.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_first_child(cmark_node *node);\n\n/** Returns the last child of 'node', or NULL if 'node' has no children.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_last_child(cmark_node *node);\n\n/** Returns the footnote reference of 'node', or NULL if 'node' doesn't have a\n * footnote reference.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_parent_footnote_def(cmark_node *node);\n\n/**\n * ## Iterator\n *\n * An iterator will walk through a tree of nodes, starting from a root\n * node, returning one node at a time, together with information about\n * whether the node is being entered or exited.  The iterator will\n * first descend to a child node, if there is one.  When there is no\n * child, the iterator will go to the next sibling.  When there is no\n * next sibling, the iterator will return to the parent (but with\n * a 'cmark_event_type' of `CMARK_EVENT_EXIT`).  The iterator will\n * return `CMARK_EVENT_DONE` when it reaches the root node again.\n * One natural application is an HTML renderer, where an `ENTER` event\n * outputs an open tag and an `EXIT` event outputs a close tag.\n * An iterator might also be used to transform an AST in some systematic\n * way, for example, turning all level-3 headings into regular paragraphs.\n *\n *     void\n *     usage_example(cmark_node *root) {\n *         cmark_event_type ev_type;\n *         cmark_iter *iter = cmark_iter_new(root);\n *\n *         while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n *             cmark_node *cur = cmark_iter_get_node(iter);\n *             // Do something with `cur` and `ev_type`\n *         }\n *\n *         cmark_iter_free(iter);\n *     }\n *\n * Iterators will never return `EXIT` events for leaf nodes, which are nodes\n * of type:\n *\n * * CMARK_NODE_HTML_BLOCK\n * * CMARK_NODE_THEMATIC_BREAK\n * * CMARK_NODE_CODE_BLOCK\n * * CMARK_NODE_TEXT\n * * CMARK_NODE_SOFTBREAK\n * * CMARK_NODE_LINEBREAK\n * * CMARK_NODE_CODE\n * * CMARK_NODE_HTML_INLINE\n *\n * Nodes must only be modified after an `EXIT` event, or an `ENTER` event for\n * leaf nodes.\n */\n\ntypedef enum {\n  CMARK_EVENT_NONE,\n  CMARK_EVENT_DONE,\n  CMARK_EVENT_ENTER,\n  CMARK_EVENT_EXIT\n} cmark_event_type;\n\n/** Creates a new iterator starting at 'root'.  The current node and event\n * type are undefined until 'cmark_iter_next' is called for the first time.\n * The memory allocated for the iterator should be released using\n * 'cmark_iter_free' when it is no longer needed.\n */\nCMARK_GFM_EXPORT\ncmark_iter *cmark_iter_new(cmark_node *root);\n\n/** Frees the memory allocated for an iterator.\n */\nCMARK_GFM_EXPORT\nvoid cmark_iter_free(cmark_iter *iter);\n\n/** Advances to the next node and returns the event type (`CMARK_EVENT_ENTER`,\n * `CMARK_EVENT_EXIT` or `CMARK_EVENT_DONE`).\n */\nCMARK_GFM_EXPORT\ncmark_event_type cmark_iter_next(cmark_iter *iter);\n\n/** Returns the current node.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_iter_get_node(cmark_iter *iter);\n\n/** Returns the current event type.\n */\nCMARK_GFM_EXPORT\ncmark_event_type cmark_iter_get_event_type(cmark_iter *iter);\n\n/** Returns the root node.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_iter_get_root(cmark_iter *iter);\n\n/** Resets the iterator so that the current node is 'current' and\n * the event type is 'event_type'.  The new current node must be a\n * descendant of the root node or the root node itself.\n */\nCMARK_GFM_EXPORT\nvoid cmark_iter_reset(cmark_iter *iter, cmark_node *current,\n                      cmark_event_type event_type);\n\n/**\n * ## Accessors\n */\n\n/** Returns the user data of 'node'.\n */\nCMARK_GFM_EXPORT void *cmark_node_get_user_data(cmark_node *node);\n\n/** Sets arbitrary user data for 'node'.  Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_user_data(cmark_node *node, void *user_data);\n\n/** Set free function for user data */\nCMARK_GFM_EXPORT\nint cmark_node_set_user_data_free_func(cmark_node *node,\n                                        cmark_free_func free_func);\n\n/** Returns the type of 'node', or `CMARK_NODE_NONE` on error.\n */\nCMARK_GFM_EXPORT cmark_node_type cmark_node_get_type(cmark_node *node);\n\n/** Like 'cmark_node_get_type', but returns a string representation\n    of the type, or `\"<unknown>\"`.\n */\nCMARK_GFM_EXPORT\nconst char *cmark_node_get_type_string(cmark_node *node);\n\n/** Returns the string contents of 'node', or an empty\n    string if none is set.  Returns NULL if called on a\n    node that does not have string content.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_literal(cmark_node *node);\n\n/** Sets the string contents of 'node'.  Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_literal(cmark_node *node, const char *content);\n\n/** Returns the heading level of 'node', or 0 if 'node' is not a heading.\n */\nCMARK_GFM_EXPORT int cmark_node_get_heading_level(cmark_node *node);\n\n/* For backwards compatibility */\n#define cmark_node_get_header_level cmark_node_get_heading_level\n#define cmark_node_set_header_level cmark_node_set_heading_level\n\n/** Sets the heading level of 'node', returning 1 on success and 0 on error.\n */\nCMARK_GFM_EXPORT int cmark_node_set_heading_level(cmark_node *node, int level);\n\n/** Returns the list type of 'node', or `CMARK_NO_LIST` if 'node'\n * is not a list.\n */\nCMARK_GFM_EXPORT cmark_list_type cmark_node_get_list_type(cmark_node *node);\n\n/** Sets the list type of 'node', returning 1 on success and 0 on error.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_type(cmark_node *node,\n                                          cmark_list_type type);\n\n/** Returns the list delimiter type of 'node', or `CMARK_NO_DELIM` if 'node'\n * is not a list.\n */\nCMARK_GFM_EXPORT cmark_delim_type cmark_node_get_list_delim(cmark_node *node);\n\n/** Sets the list delimiter type of 'node', returning 1 on success and 0\n * on error.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_delim(cmark_node *node,\n                                           cmark_delim_type delim);\n\n/** Returns starting number of 'node', if it is an ordered list, otherwise 0.\n */\nCMARK_GFM_EXPORT int cmark_node_get_list_start(cmark_node *node);\n\n/** Sets starting number of 'node', if it is an ordered list. Returns 1\n * on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_start(cmark_node *node, int start);\n\n/** Returns 1 if 'node' is a tight list, 0 otherwise.\n */\nCMARK_GFM_EXPORT int cmark_node_get_list_tight(cmark_node *node);\n\n/** Sets the \"tightness\" of a list.  Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_tight(cmark_node *node, int tight);\n\n/** Returns the info string from a fenced code block.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_fence_info(cmark_node *node);\n\n/** Sets the info string in a fenced code block, returning 1 on\n * success and 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_fence_info(cmark_node *node, const char *info);\n\n/** Sets code blocks fencing details\n */\nCMARK_GFM_EXPORT int cmark_node_set_fenced(cmark_node * node, int fenced,\n    int length, int offset, char character);\n\n/** Returns code blocks fencing details\n */\nCMARK_GFM_EXPORT int cmark_node_get_fenced(cmark_node *node, int *length, int *offset, char *character);\n\n/** Returns the URL of a link or image 'node', or an empty string\n    if no URL is set.  Returns NULL if called on a node that is\n    not a link or image.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_url(cmark_node *node);\n\n/** Sets the URL of a link or image 'node'. Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_url(cmark_node *node, const char *url);\n\n/** Returns the title of a link or image 'node', or an empty\n    string if no title is set.  Returns NULL if called on a node\n    that is not a link or image.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_title(cmark_node *node);\n\n/** Sets the title of a link or image 'node'. Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_title(cmark_node *node, const char *title);\n\n/** Returns the literal \"on enter\" text for a custom 'node', or\n    an empty string if no on_enter is set.  Returns NULL if called\n    on a non-custom node.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_on_enter(cmark_node *node);\n\n/** Sets the literal text to render \"on enter\" for a custom 'node'.\n    Any children of the node will be rendered after this text.\n    Returns 1 on success 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_on_enter(cmark_node *node,\n                                         const char *on_enter);\n\n/** Returns the literal \"on exit\" text for a custom 'node', or\n    an empty string if no on_exit is set.  Returns NULL if\n    called on a non-custom node.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_on_exit(cmark_node *node);\n\n/** Sets the literal text to render \"on exit\" for a custom 'node'.\n    Any children of the node will be rendered before this text.\n    Returns 1 on success 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_on_exit(cmark_node *node, const char *on_exit);\n\n/** Returns the line on which 'node' begins.\n */\nCMARK_GFM_EXPORT int cmark_node_get_start_line(cmark_node *node);\n\n/** Returns the column at which 'node' begins.\n */\nCMARK_GFM_EXPORT int cmark_node_get_start_column(cmark_node *node);\n\n/** Returns the line on which 'node' ends.\n */\nCMARK_GFM_EXPORT int cmark_node_get_end_line(cmark_node *node);\n\n/** Returns the column at which 'node' ends.\n */\nCMARK_GFM_EXPORT int cmark_node_get_end_column(cmark_node *node);\n\n/**\n * ## Tree Manipulation\n */\n\n/** Unlinks a 'node', removing it from the tree, but not freeing its\n * memory.  (Use 'cmark_node_free' for that.)\n */\nCMARK_GFM_EXPORT void cmark_node_unlink(cmark_node *node);\n\n/** Inserts 'sibling' before 'node'.  Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_insert_before(cmark_node *node,\n                                          cmark_node *sibling);\n\n/** Inserts 'sibling' after 'node'. Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_insert_after(cmark_node *node, cmark_node *sibling);\n\n/** Replaces 'oldnode' with 'newnode' and unlinks 'oldnode' (but does\n * not free its memory).\n * Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_replace(cmark_node *oldnode, cmark_node *newnode);\n\n/** Adds 'child' to the beginning of the children of 'node'.\n * Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_prepend_child(cmark_node *node, cmark_node *child);\n\n/** Adds 'child' to the end of the children of 'node'.\n * Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_append_child(cmark_node *node, cmark_node *child);\n\n/** Consolidates adjacent text nodes.\n */\nCMARK_GFM_EXPORT void cmark_consolidate_text_nodes(cmark_node *root);\n\n/** Ensures a node and all its children own their own chunk memory.\n */\nCMARK_GFM_EXPORT void cmark_node_own(cmark_node *root);\n\n/**\n * ## Parsing\n *\n * Simple interface:\n *\n *     cmark_node *document = cmark_parse_document(\"Hello *world*\", 13,\n *                                                 CMARK_OPT_DEFAULT);\n *\n * Streaming interface:\n *\n *     cmark_parser *parser = cmark_parser_new(CMARK_OPT_DEFAULT);\n *     FILE *fp = fopen(\"myfile.md\", \"rb\");\n *     while ((bytes = fread(buffer, 1, sizeof(buffer), fp)) > 0) {\n *     \t   cmark_parser_feed(parser, buffer, bytes);\n *     \t   if (bytes < sizeof(buffer)) {\n *     \t       break;\n *     \t   }\n *     }\n *     document = cmark_parser_finish(parser);\n *     cmark_parser_free(parser);\n */\n\n/** Creates a new parser object.\n */\nCMARK_GFM_EXPORT\ncmark_parser *cmark_parser_new(int options);\n\n/** Creates a new parser object with the given memory allocator\n */\nCMARK_GFM_EXPORT\ncmark_parser *cmark_parser_new_with_mem(int options, cmark_mem *mem);\n\n/** Frees memory allocated for a parser object.\n */\nCMARK_GFM_EXPORT\nvoid cmark_parser_free(cmark_parser *parser);\n\n/** Feeds a string of length 'len' to 'parser'.\n */\nCMARK_GFM_EXPORT\nvoid cmark_parser_feed(cmark_parser *parser, const char *buffer, size_t len);\n\n/** Finish parsing and return a pointer to a tree of nodes.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_parser_finish(cmark_parser *parser);\n\n/** Parse a CommonMark document in 'buffer' of length 'len'.\n * Returns a pointer to a tree of nodes.  The memory allocated for\n * the node tree should be released using 'cmark_node_free'\n * when it is no longer needed.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_parse_document(const char *buffer, size_t len, int options);\n\n/** Parse a CommonMark document in file 'f', returning a pointer to\n * a tree of nodes.  The memory allocated for the node tree should be\n * released using 'cmark_node_free' when it is no longer needed.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_parse_file(FILE *f, int options);\n\n/**\n * ## Rendering\n */\n\n/** Render a 'node' tree as XML.  It is the caller's responsibility\n * to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_xml(cmark_node *root, int options);\n\n/** As for 'cmark_render_xml', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_xml_with_mem(cmark_node *root, int options, cmark_mem *mem);\n\n/** Render a 'node' tree as an HTML fragment.  It is up to the user\n * to add an appropriate header and footer. It is the caller's\n * responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_html(cmark_node *root, int options, cmark_llist *extensions);\n\n/** As for 'cmark_render_html', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_html_with_mem(cmark_node *root, int options, cmark_llist *extensions, cmark_mem *mem);\n\n/** Render a 'node' tree as a groff man page, without the header.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_man(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_man', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_man_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/** Render a 'node' tree as a commonmark document.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_commonmark(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_commonmark', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_commonmark_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/** Render a 'node' tree as a plain text document.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_plaintext(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_plaintext', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_plaintext_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/** Render a 'node' tree as a LaTeX document.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_latex(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_latex', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_latex_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/**\n * ## Options\n */\n\n/** Default options.\n */\n#define CMARK_OPT_DEFAULT 0\n\n/**\n * ### Options affecting rendering\n */\n\n/** Include a `data-sourcepos` attribute on all block elements.\n */\n#define CMARK_OPT_SOURCEPOS (1 << 1)\n\n/** Render `softbreak` elements as hard line breaks.\n */\n#define CMARK_OPT_HARDBREAKS (1 << 2)\n\n/** `CMARK_OPT_SAFE` is defined here for API compatibility,\n    but it no longer has any effect. \"Safe\" mode is now the default:\n    set `CMARK_OPT_UNSAFE` to disable it.\n */\n#define CMARK_OPT_SAFE (1 << 3)\n\n/** Render raw HTML and unsafe links (`javascript:`, `vbscript:`,\n * `file:`, and `data:`, except for `image/png`, `image/gif`,\n * `image/jpeg`, or `image/webp` mime types).  By default,\n * raw HTML is replaced by a placeholder HTML comment. Unsafe\n * links are replaced by empty strings.\n */\n#define CMARK_OPT_UNSAFE (1 << 17)\n\n/** Render `softbreak` elements as spaces.\n */\n#define CMARK_OPT_NOBREAKS (1 << 4)\n\n/**\n * ### Options affecting parsing\n */\n\n/** Legacy option (no effect).\n */\n#define CMARK_OPT_NORMALIZE (1 << 8)\n\n/** Validate UTF-8 in the input before parsing, replacing illegal\n * sequences with the replacement character U+FFFD.\n */\n#define CMARK_OPT_VALIDATE_UTF8 (1 << 9)\n\n/** Convert straight quotes to curly, --- to em dashes, -- to en dashes.\n */\n#define CMARK_OPT_SMART (1 << 10)\n\n/** Use GitHub-style <pre lang=\"x\"> tags for code blocks instead of <pre><code\n * class=\"language-x\">.\n */\n#define CMARK_OPT_GITHUB_PRE_LANG (1 << 11)\n\n/** Be liberal in interpreting inline HTML tags.\n */\n#define CMARK_OPT_LIBERAL_HTML_TAG (1 << 12)\n\n/** Parse footnotes.\n */\n#define CMARK_OPT_FOOTNOTES (1 << 13)\n\n/** Only parse strikethroughs if surrounded by exactly 2 tildes.\n * Gives some compatibility with redcarpet.\n */\n#define CMARK_OPT_STRIKETHROUGH_DOUBLE_TILDE (1 << 14)\n\n/** Use style attributes to align table cells instead of align attributes.\n */\n#define CMARK_OPT_TABLE_PREFER_STYLE_ATTRIBUTES (1 << 15)\n\n/** Include the remainder of the info string in code blocks in\n * a separate attribute.\n */\n#define CMARK_OPT_FULL_INFO_STRING (1 << 16)\n\n/**\n * ## Version information\n */\n\n/** The library version as integer for runtime checks. Also available as\n * macro CMARK_VERSION for compile time checks.\n *\n * * Bits 16-23 contain the major version.\n * * Bits 8-15 contain the minor version.\n * * Bits 0-7 contain the patchlevel.\n *\n * In hexadecimal format, the number 0x010203 represents version 1.2.3.\n */\nCMARK_GFM_EXPORT\nint cmark_version(void);\n\n/** The library version string for runtime checks. Also available as\n * macro CMARK_VERSION_STRING for compile time checks.\n */\nCMARK_GFM_EXPORT\nconst char *cmark_version_string(void);\n\n/** # AUTHORS\n *\n * John MacFarlane, Vicent Marti,  K\u0101rlis Ga\u0146\u0123is, Nick Wellnhofer.\n */\n\n#ifndef CMARK_NO_SHORT_NAMES\n#define NODE_DOCUMENT CMARK_NODE_DOCUMENT\n#define NODE_BLOCK_QUOTE CMARK_NODE_BLOCK_QUOTE\n#define NODE_LIST CMARK_NODE_LIST\n#define NODE_ITEM CMARK_NODE_ITEM\n#define NODE_CODE_BLOCK CMARK_NODE_CODE_BLOCK\n#define NODE_HTML_BLOCK CMARK_NODE_HTML_BLOCK\n#define NODE_CUSTOM_BLOCK CMARK_NODE_CUSTOM_BLOCK\n#define NODE_PARAGRAPH CMARK_NODE_PARAGRAPH\n#define NODE_HEADING CMARK_NODE_HEADING\n#define NODE_HEADER CMARK_NODE_HEADER\n#define NODE_THEMATIC_BREAK CMARK_NODE_THEMATIC_BREAK\n#define NODE_HRULE CMARK_NODE_HRULE\n#define NODE_TEXT CMARK_NODE_TEXT\n#define NODE_SOFTBREAK CMARK_NODE_SOFTBREAK\n#define NODE_LINEBREAK CMARK_NODE_LINEBREAK\n#define NODE_CODE CMARK_NODE_CODE\n#define NODE_HTML_INLINE CMARK_NODE_HTML_INLINE\n#define NODE_CUSTOM_INLINE CMARK_NODE_CUSTOM_INLINE\n#define NODE_EMPH CMARK_NODE_EMPH\n#define NODE_STRONG CMARK_NODE_STRONG\n#define NODE_LINK CMARK_NODE_LINK\n#define NODE_IMAGE CMARK_NODE_IMAGE\n#define BULLET_LIST CMARK_BULLET_LIST\n#define ORDERED_LIST CMARK_ORDERED_LIST\n#define PERIOD_DELIM CMARK_PERIOD_DELIM\n#define PAREN_DELIM CMARK_PAREN_DELIM\n#endif\n\ntypedef int32_t bufsize_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#include <stdlib.h>\n#include <string.h>\n\n#include \"config.h\"\n#include \"node.h\"\n#include \"syntax_extension.h\"\n\nstatic void S_node_unlink(cmark_node *node);\n\n#define NODE_MEM(node) cmark_node_mem(node)\n\nvoid cmark_register_node_flag(cmark_node_internal_flags *flags) {\n  static cmark_node_internal_flags nextflag = CMARK_NODE__REGISTER_FIRST;\n\n  // flags should be a pointer to a global variable and this function\n  // should only be called once to initialize its value.\n  if (*flags) {\n    fprintf(stderr, \"flag initialization error in cmark_register_node_flag\\n\");\n    abort();\n  }\n\n  // Check that we haven't run out of bits.\n  if (nextflag == 0) {\n    fprintf(stderr, \"too many flags in cmark_register_node_flag\\n\");\n    abort();\n  }\n\n  *flags = nextflag;\n  nextflag <<= 1;\n}\n\nvoid cmark_init_standard_node_flags() {}\n\nbool cmark_node_can_contain_type(cmark_node *node, cmark_node_type child_type) {\n  if (child_type == CMARK_NODE_DOCUMENT) {\n      return false;\n    }\n\n  if (node->extension && node->extension->can_contain_func) {\n    return node->extension->can_contain_func(node->extension, node, child_type) != 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_DOCUMENT:\n  case CMARK_NODE_BLOCK_QUOTE:\n  case CMARK_NODE_FOOTNOTE_DEFINITION:\n  case CMARK_NODE_ITEM:\n    return CMARK_NODE_TYPE_BLOCK_P(child_type) && child_type != CMARK_NODE_ITEM;\n\n  case CMARK_NODE_LIST:\n    return child_type == CMARK_NODE_ITEM;\n\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return true;\n\n  case CMARK_NODE_PARAGRAPH:\n  case CMARK_NODE_HEADING:\n  case CMARK_NODE_EMPH:\n  case CMARK_NODE_STRONG:\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n  case CMARK_NODE_CUSTOM_INLINE:\n    return CMARK_NODE_TYPE_INLINE_P(child_type);\n\n  default:\n    break;\n  }\n\n  return false;\n}\n\nstatic bool S_can_contain(cmark_node *node, cmark_node *child) {\n  cmark_node *cur;\n\n  if (node == NULL || child == NULL) {\n    return false;\n  }\n  if (NODE_MEM(node) != NODE_MEM(child)) {\n    return 0;\n  }\n\n  // Verify that child is not an ancestor of node or equal to node.\n  cur = node;\n  do {\n    if (cur == child) {\n      return false;\n    }\n    cur = cur->parent;\n  } while (cur != NULL);\n\n  return cmark_node_can_contain_type(node, (cmark_node_type) child->type);\n}\n\ncmark_node *cmark_node_new_with_mem_and_ext(cmark_node_type type, cmark_mem *mem, cmark_syntax_extension *extension) {\n  cmark_node *node = (cmark_node *)mem->calloc(1, sizeof(*node));\n  cmark_strbuf_init(mem, &node->content, 0);\n  node->type = (uint16_t)type;\n  node->extension = extension;\n\n  switch (node->type) {\n  case CMARK_NODE_HEADING:\n    node->as.heading.level = 1;\n    break;\n\n  case CMARK_NODE_LIST: {\n    cmark_list *list = &node->as.list;\n    list->list_type = CMARK_BULLET_LIST;\n    list->start = 0;\n    list->tight = false;\n    break;\n  }\n\n  default:\n    break;\n  }\n\n  if (node->extension && node->extension->opaque_alloc_func) {\n    node->extension->opaque_alloc_func(node->extension, mem, node);\n  }\n\n  return node;\n}\n\ncmark_node *cmark_node_new_with_ext(cmark_node_type type, cmark_syntax_extension *extension) {\n  extern cmark_mem CMARK_DEFAULT_MEM_ALLOCATOR;\n  return cmark_node_new_with_mem_and_ext(type, &CMARK_DEFAULT_MEM_ALLOCATOR, extension);\n}\n\ncmark_node *cmark_node_new_with_mem(cmark_node_type type, cmark_mem *mem)\n{\n  return cmark_node_new_with_mem_and_ext(type, mem, NULL);\n}\n\ncmark_node *cmark_node_new(cmark_node_type type) {\n  return cmark_node_new_with_ext(type, NULL);\n}\n\nstatic void free_node_as(cmark_node *node) {\n  switch (node->type) {\n    case CMARK_NODE_CODE_BLOCK:\n    cmark_chunk_free(NODE_MEM(node), &node->as.code.info);\n    cmark_chunk_free(NODE_MEM(node), &node->as.code.literal);\n      break;\n    case CMARK_NODE_TEXT:\n    case CMARK_NODE_HTML_INLINE:\n    case CMARK_NODE_CODE:\n    case CMARK_NODE_HTML_BLOCK:\n    case CMARK_NODE_FOOTNOTE_REFERENCE:\n    case CMARK_NODE_FOOTNOTE_DEFINITION:\n    cmark_chunk_free(NODE_MEM(node), &node->as.literal);\n      break;\n    case CMARK_NODE_LINK:\n    case CMARK_NODE_IMAGE:\n    cmark_chunk_free(NODE_MEM(node), &node->as.link.url);\n    cmark_chunk_free(NODE_MEM(node), &node->as.link.title);\n      break;\n    case CMARK_NODE_CUSTOM_BLOCK:\n    case CMARK_NODE_CUSTOM_INLINE:\n    cmark_chunk_free(NODE_MEM(node), &node->as.custom.on_enter);\n    cmark_chunk_free(NODE_MEM(node), &node->as.custom.on_exit);\n      break;\n    default:\n      break;\n    }\n}\n\n// Free a cmark_node list and any children.\nstatic void S_free_nodes(cmark_node *e) {\n  cmark_node *next;\n  while (e != NULL) {\n    cmark_strbuf_free(&e->content);\n\n    if (e->user_data && e->user_data_free_func)\n      e->user_data_free_func(NODE_MEM(e), e->user_data);\n\n    if (e->as.opaque && e->extension && e->extension->opaque_free_func)\n      e->extension->opaque_free_func(e->extension, NODE_MEM(e), e);\n\n    free_node_as(e);\n\n    if (e->last_child) {\n      // Splice children into list\n      e->last_child->next = e->next;\n      e->next = e->first_child;\n    }\n    next = e->next;\n    NODE_MEM(e)->free(e);\n    e = next;\n  }\n}\n\nvoid cmark_node_free(cmark_node *node) {\n  S_node_unlink(node);\n  node->next = NULL;\n  S_free_nodes(node);\n}\n\ncmark_node_type cmark_node_get_type(cmark_node *node) {\n  if (node == NULL) {\n    return CMARK_NODE_NONE;\n  } else {\n    return (cmark_node_type)node->type;\n  }\n}\n\nint cmark_node_set_type(cmark_node * node, cmark_node_type type) {\n  cmark_node_type initial_type;\n\n  if (type == node->type)\n    return 1;\n\n  initial_type = (cmark_node_type) node->type;\n  node->type = (uint16_t)type;\n\n  if (!S_can_contain(node->parent, node)) {\n    node->type = (uint16_t)initial_type;\n    return 0;\n  }\n\n  /* We rollback the type to free the union members appropriately */\n  node->type = (uint16_t)initial_type;\n  free_node_as(node);\n\n  node->type = (uint16_t)type;\n\n  return 1;\n}\n\nconst char *cmark_node_get_type_string(cmark_node *node) {\n  if (node == NULL) {\n    return \"NONE\";\n  }\n\n  if (node->extension && node->extension->get_type_string_func) {\n    return node->extension->get_type_string_func(node->extension, node);\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_NONE:\n    return \"none\";\n  case CMARK_NODE_DOCUMENT:\n    return \"document\";\n  case CMARK_NODE_BLOCK_QUOTE:\n    return \"block_quote\";\n  case CMARK_NODE_LIST:\n    return \"list\";\n  case CMARK_NODE_ITEM:\n    return \"item\";\n  case CMARK_NODE_CODE_BLOCK:\n    return \"code_block\";\n  case CMARK_NODE_HTML_BLOCK:\n    return \"html_block\";\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return \"custom_block\";\n  case CMARK_NODE_PARAGRAPH:\n    return \"paragraph\";\n  case CMARK_NODE_HEADING:\n    return \"heading\";\n  case CMARK_NODE_THEMATIC_BREAK:\n    return \"thematic_break\";\n  case CMARK_NODE_TEXT:\n    return \"text\";\n  case CMARK_NODE_SOFTBREAK:\n    return \"softbreak\";\n  case CMARK_NODE_LINEBREAK:\n    return \"linebreak\";\n  case CMARK_NODE_CODE:\n    return \"code\";\n  case CMARK_NODE_HTML_INLINE:\n    return \"html_inline\";\n  case CMARK_NODE_CUSTOM_INLINE:\n    return \"custom_inline\";\n  case CMARK_NODE_EMPH:\n    return \"emph\";\n  case CMARK_NODE_STRONG:\n    return \"strong\";\n  case CMARK_NODE_LINK:\n    return \"link\";\n  case CMARK_NODE_IMAGE:\n    return \"image\";\n  }\n\n  return \"<unknown>\";\n}\n\ncmark_node *cmark_node_next(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->next;\n  }\n}\n\ncmark_node *cmark_node_previous(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->prev;\n  }\n}\n\ncmark_node *cmark_node_parent(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->parent;\n  }\n}\n\ncmark_node *cmark_node_first_child(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->first_child;\n  }\n}\n\ncmark_node *cmark_node_last_child(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->last_child;\n  }\n}\n\ncmark_node *cmark_node_parent_footnote_def(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->parent_footnote_def;\n  }\n}\n\nvoid *cmark_node_get_user_data(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->user_data;\n  }\n}\n\nint cmark_node_set_user_data(cmark_node *node, void *user_data) {\n  if (node == NULL) {\n    return 0;\n  }\n  node->user_data = user_data;\n  return 1;\n}\n\nint cmark_node_set_user_data_free_func(cmark_node *node,\n                                        cmark_free_func free_func) {\n  if (node == NULL) {\n    return 0;\n  }\n  node->user_data_free_func = free_func;\n  return 1;\n}\n\nconst char *cmark_node_get_literal(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HTML_BLOCK:\n  case CMARK_NODE_TEXT:\n  case CMARK_NODE_HTML_INLINE:\n  case CMARK_NODE_CODE:\n  case CMARK_NODE_FOOTNOTE_REFERENCE:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.literal);\n\n  case CMARK_NODE_CODE_BLOCK:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.code.literal);\n\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_literal(cmark_node *node, const char *content) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HTML_BLOCK:\n  case CMARK_NODE_TEXT:\n  case CMARK_NODE_HTML_INLINE:\n  case CMARK_NODE_CODE:\n  case CMARK_NODE_FOOTNOTE_REFERENCE:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.literal, content);\n    return 1;\n\n  case CMARK_NODE_CODE_BLOCK:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.code.literal, content);\n    return 1;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_string_content(cmark_node *node) {\n  return (char *) node->content.ptr;\n}\n\nint cmark_node_set_string_content(cmark_node *node, const char *content) {\n  cmark_strbuf_sets(&node->content, content);\n  return true;\n}\n\nint cmark_node_get_heading_level(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HEADING:\n    return node->as.heading.level;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nint cmark_node_set_heading_level(cmark_node *node, int level) {\n  if (node == NULL || level < 1 || level > 6) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HEADING:\n    node->as.heading.level = level;\n    return 1;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\ncmark_list_type cmark_node_get_list_type(cmark_node *node) {\n  if (node == NULL) {\n    return CMARK_NO_LIST;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.list_type;\n  } else {\n    return CMARK_NO_LIST;\n  }\n}\n\nint cmark_node_set_list_type(cmark_node *node, cmark_list_type type) {\n  if (!(type == CMARK_BULLET_LIST || type == CMARK_ORDERED_LIST)) {\n    return 0;\n  }\n\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.list_type = type;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\ncmark_delim_type cmark_node_get_list_delim(cmark_node *node) {\n  if (node == NULL) {\n    return CMARK_NO_DELIM;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.delimiter;\n  } else {\n    return CMARK_NO_DELIM;\n  }\n}\n\nint cmark_node_set_list_delim(cmark_node *node, cmark_delim_type delim) {\n  if (!(delim == CMARK_PERIOD_DELIM || delim == CMARK_PAREN_DELIM)) {\n    return 0;\n  }\n\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.delimiter = delim;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_get_list_start(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.start;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_set_list_start(cmark_node *node, int start) {\n  if (node == NULL || start < 0) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.start = start;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_get_list_tight(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.tight;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_set_list_tight(cmark_node *node, int tight) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.tight = tight == 1;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nconst char *cmark_node_get_fence_info(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.code.info);\n  } else {\n    return NULL;\n  }\n}\n\nint cmark_node_set_fence_info(cmark_node *node, const char *info) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.code.info, info);\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_get_fenced(cmark_node *node, int *length, int *offset, char *character) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    *length = node->as.code.fence_length;\n    *offset = node->as.code.fence_offset;\n    *character = node->as.code.fence_char;\n    return node->as.code.fenced;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_set_fenced(cmark_node * node, int fenced,\n    int length, int offset, char character) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    node->as.code.fenced = (int8_t)fenced;\n    node->as.code.fence_length = (uint8_t)length;\n    node->as.code.fence_offset = (uint8_t)offset;\n    node->as.code.fence_char = character;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nconst char *cmark_node_get_url(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.link.url);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_url(cmark_node *node, const char *url) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.link.url, url);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_title(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.link.title);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_title(cmark_node *node, const char *title) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.link.title, title);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_on_enter(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.custom.on_enter);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_on_enter(cmark_node *node, const char *on_enter) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.custom.on_enter, on_enter);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_on_exit(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.custom.on_exit);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_on_exit(cmark_node *node, const char *on_exit) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.custom.on_exit, on_exit);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\ncmark_syntax_extension *cmark_node_get_syntax_extension(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return node->extension;\n}\n\nint cmark_node_set_syntax_extension(cmark_node *node, cmark_syntax_extension *extension) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  node->extension = extension;\n  return 1;\n}\n\nint cmark_node_get_start_line(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->start_line;\n}\n\nint cmark_node_get_start_column(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->start_column;\n}\n\nint cmark_node_get_end_line(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->end_line;\n}\n\nint cmark_node_get_end_column(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->end_column;\n}\n\n// Unlink a node without adjusting its next, prev, and parent pointers.\nstatic void S_node_unlink(cmark_node *node) {\n  if (node == NULL) {\n    return;\n  }\n\n  if (node->prev) {\n    node->prev->next = node->next;\n  }\n  if (node->next) {\n    node->next->prev = node->prev;\n  }\n\n  // Adjust first_child and last_child of parent.\n  cmark_node *parent = node->parent;\n  if (parent) {\n    if (parent->first_child == node) {\n      parent->first_child = node->next;\n    }\n    if (parent->last_child == node) {\n      parent->last_child = node->prev;\n    }\n  }\n}\n\nvoid cmark_node_unlink(cmark_node *node) {\n  S_node_unlink(node);\n\n  node->next = NULL;\n  node->prev = NULL;\n  node->parent = NULL;\n}\n\nint cmark_node_insert_before(cmark_node *node, cmark_node *sibling) {\n  if (node == NULL || sibling == NULL) {\n    return 0;\n  }\n\n  if (!node->parent || !S_can_contain(node->parent, sibling)) {\n    return 0;\n  }\n\n  S_node_unlink(sibling);\n\n  cmark_node *old_prev = node->prev;\n\n  // Insert 'sibling' between 'old_prev' and 'node'.\n  if (old_prev) {\n    old_prev->next = sibling;\n  }\n  sibling->prev = old_prev;\n  sibling->next = node;\n  node->prev = sibling;\n\n  // Set new parent.\n  cmark_node *parent = node->parent;\n  sibling->parent = parent;\n\n  // Adjust first_child of parent if inserted as first child.\n  if (parent && !old_prev) {\n    parent->first_child = sibling;\n  }\n\n  return 1;\n}\n\nint cmark_node_insert_after(cmark_node *node, cmark_node *sibling) {\n  if (node == NULL || sibling == NULL) {\n    return 0;\n  }\n\n  if (!node->parent || !S_can_contain(node->parent, sibling)) {\n    return 0;\n  }\n\n  S_node_unlink(sibling);\n\n  cmark_node *old_next = node->next;\n\n  // Insert 'sibling' between 'node' and 'old_next'.\n  if (old_next) {\n    old_next->prev = sibling;\n  }\n  sibling->next = old_next;\n  sibling->prev = node;\n  node->next = sibling;\n\n  // Set new parent.\n  cmark_node *parent = node->parent;\n  sibling->parent = parent;\n\n  // Adjust last_child of parent if inserted as last child.\n  if (parent && !old_next) {\n    parent->last_child = sibling;\n  }\n\n  return 1;\n}\n\nint cmark_node_replace(cmark_node *oldnode, cmark_node *newnode) {\n  if (!cmark_node_insert_before(oldnode, newnode)) {\n    return 0;\n  }\n  cmark_node_unlink(oldnode);\n  return 1;\n}\n\nint cmark_node_prepend_child(cmark_node *node, cmark_node *child) {\n  if (!S_can_contain(node, child)) {\n    return 0;\n  }\n\n  S_node_unlink(child);\n\n  cmark_node *old_first_child = node->first_child;\n\n  child->next = old_first_child;\n  child->prev = NULL;\n  child->parent = node;\n  node->first_child = child;\n\n  if (old_first_child) {\n    old_first_child->prev = child;\n  } else {\n    // Also set last_child if node previously had no children.\n    node->last_child = child;\n  }\n\n  return 1;\n}\n\nint cmark_node_append_child(cmark_node *node, cmark_node *child) {\n  if (!S_can_contain(node, child)) {\n    return 0;\n  }\n\n  S_node_unlink(child);\n\n  cmark_node *old_last_child = node->last_child;\n\n  child->next = NULL;\n  child->prev = old_last_child;\n  child->parent = node;\n  node->last_child = child;\n\n  if (old_last_child) {\n    old_last_child->next = child;\n  } else {\n    // Also set first_child if node previously had no children.\n    node->first_child = child;\n  }\n\n  return 1;\n}\n\nstatic void S_print_error(FILE *out, cmark_node *node, const char *elem) {\n  if (out == NULL) {\n    return;\n  }\n  fprintf(out, \"Invalid '%s' in node type %s at %d:%d\\n\", elem,\n          cmark_node_get_type_string(node), node->start_line,\n          node->start_column);\n}\n\nint cmark_node_check(cmark_node *node, FILE *out) {\n  cmark_node *cur;\n  int errors = 0;\n\n  if (!node) {\n    return 0;\n  }\n\n  cur = node;\n  for (;;) {\n    if (cur->first_child) {\n      if (cur->first_child->prev != NULL) {\n        S_print_error(out, cur->first_child, \"prev\");\n        cur->first_child->prev = NULL;\n        ++errors;\n      }\n      if (cur->first_child->parent != cur) {\n        S_print_error(out, cur->first_child, \"parent\");\n        cur->first_child->parent = cur;\n        ++errors;\n      }\n      cur = cur->first_child;\n      continue;\n    }\n\n  next_sibling:\n    if (cur == node) {\n      break;\n    }\n    if (cur->next) {\n      if (cur->next->prev != cur) {\n        S_print_error(out, cur->next, \"prev\");\n        cur->next->prev = cur;\n        ++errors;\n      }\n      if (cur->next->parent != cur->parent) {\n        S_print_error(out, cur->next, \"parent\");\n        cur->next->parent = cur->parent;\n        ++errors;\n      }\n      cur = cur->next;\n      continue;\n    }\n\n    if (cur->parent->last_child != cur) {\n      S_print_error(out, cur->parent, \"last_child\");\n      cur->parent->last_child = cur;\n      ++errors;\n    }\n    cur = cur->parent;\n    goto next_sibling;\n  }\n\n  return errors;\n}\n", "#ifndef CMARK_NODE_H\n#define CMARK_NODE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdio.h>\n#include <stdint.h>\n\n#include \"cmark-gfm.h\"\n#include \"cmark-gfm-extension_api.h\"\n#include \"buffer.h\"\n#include \"chunk.h\"\n\ntypedef struct {\n  cmark_list_type list_type;\n  int marker_offset;\n  int padding;\n  int start;\n  cmark_delim_type delimiter;\n  unsigned char bullet_char;\n  bool tight;\n  bool checked; // For task list extension\n} cmark_list;\n\ntypedef struct {\n  cmark_chunk info;\n  cmark_chunk literal;\n  uint8_t fence_length;\n  uint8_t fence_offset;\n  unsigned char fence_char;\n  int8_t fenced;\n} cmark_code;\n\ntypedef struct {\n  int level;\n  bool setext;\n} cmark_heading;\n\ntypedef struct {\n  cmark_chunk url;\n  cmark_chunk title;\n} cmark_link;\n\ntypedef struct {\n  cmark_chunk on_enter;\n  cmark_chunk on_exit;\n} cmark_custom;\n\nenum cmark_node__internal_flags {\n  CMARK_NODE__OPEN = (1 << 0),\n  CMARK_NODE__LAST_LINE_BLANK = (1 << 1),\n  CMARK_NODE__LAST_LINE_CHECKED = (1 << 2),\n\n  // Extensions can register custom flags by calling `cmark_register_node_flag`.\n  // This is the starting value for the custom flags.\n  CMARK_NODE__REGISTER_FIRST = (1 << 3),\n};\n\ntypedef uint16_t cmark_node_internal_flags;\n\nstruct cmark_node {\n  cmark_strbuf content;\n\n  struct cmark_node *next;\n  struct cmark_node *prev;\n  struct cmark_node *parent;\n  struct cmark_node *first_child;\n  struct cmark_node *last_child;\n\n  void *user_data;\n  cmark_free_func user_data_free_func;\n\n  int start_line;\n  int start_column;\n  int end_line;\n  int end_column;\n  int internal_offset;\n  uint16_t type;\n  cmark_node_internal_flags flags;\n\n  cmark_syntax_extension *extension;\n\n  union {\n    int ref_ix;\n    int def_count;\n  } footnote;\n\n  cmark_node *parent_footnote_def;\n\n  union {\n    cmark_chunk literal;\n    cmark_list list;\n    cmark_code code;\n    cmark_heading heading;\n    cmark_link link;\n    cmark_custom custom;\n    int html_block_type;\n    void *opaque;\n  } as;\n};\n\n/**\n * Syntax extensions can use this function to register a custom node\n * flag. The flags are stored in the `flags` field of the `cmark_node`\n * struct. The `flags` parameter should be the address of a global variable\n * which will store the flag value.\n */\nCMARK_GFM_EXPORT\nvoid cmark_register_node_flag(cmark_node_internal_flags *flags);\n\n/**\n * DEPRECATED.\n *\n * This function was added in cmark-gfm version 0.29.0.gfm.7, and was\n * required to be called at program start time, which caused\n * backwards-compatibility issues in applications that use cmark-gfm as a\n * library. It is now a no-op.\n */\nCMARK_GFM_EXPORT\nvoid cmark_init_standard_node_flags();\n\nstatic CMARK_INLINE cmark_mem *cmark_node_mem(cmark_node *node) {\n  return node->content.mem;\n}\nCMARK_GFM_EXPORT int cmark_node_check(cmark_node *node, FILE *out);\n\nstatic CMARK_INLINE bool CMARK_NODE_TYPE_BLOCK_P(cmark_node_type node_type) {\n\treturn (node_type & CMARK_NODE_TYPE_MASK) == CMARK_NODE_TYPE_BLOCK;\n}\n\nstatic CMARK_INLINE bool CMARK_NODE_BLOCK_P(cmark_node *node) {\n\treturn node != NULL && CMARK_NODE_TYPE_BLOCK_P((cmark_node_type) node->type);\n}\n\nstatic CMARK_INLINE bool CMARK_NODE_TYPE_INLINE_P(cmark_node_type node_type) {\n\treturn (node_type & CMARK_NODE_TYPE_MASK) == CMARK_NODE_TYPE_INLINE;\n}\n\nstatic CMARK_INLINE bool CMARK_NODE_INLINE_P(cmark_node *node) {\n\treturn node != NULL && CMARK_NODE_TYPE_INLINE_P((cmark_node_type) node->type);\n}\n\nCMARK_GFM_EXPORT bool cmark_node_can_contain_type(cmark_node *node, cmark_node_type child_type);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#ifndef CMARK_PARSER_H\n#define CMARK_PARSER_H\n\n#include <stdio.h>\n#include \"references.h\"\n#include \"node.h\"\n#include \"buffer.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define MAX_LINK_LABEL_LENGTH 1000\n\nstruct cmark_parser {\n  struct cmark_mem *mem;\n  /* A hashtable of urls in the current document for cross-references */\n  struct cmark_map *refmap;\n  /* The root node of the parser, always a CMARK_NODE_DOCUMENT */\n  struct cmark_node *root;\n  /* The last open block after a line is fully processed */\n  struct cmark_node *current;\n  /* See the documentation for cmark_parser_get_line_number() in cmark.h */\n  int line_number;\n  /* See the documentation for cmark_parser_get_offset() in cmark.h */\n  bufsize_t offset;\n  /* See the documentation for cmark_parser_get_column() in cmark.h */\n  bufsize_t column;\n  /* See the documentation for cmark_parser_get_first_nonspace() in cmark.h */\n  bufsize_t first_nonspace;\n  /* See the documentation for cmark_parser_get_first_nonspace_column() in cmark.h */\n  bufsize_t first_nonspace_column;\n  bufsize_t thematic_break_kill_pos;\n  /* See the documentation for cmark_parser_get_indent() in cmark.h */\n  int indent;\n  /* See the documentation for cmark_parser_is_blank() in cmark.h */\n  bool blank;\n  /* See the documentation for cmark_parser_has_partially_consumed_tab() in cmark.h */\n  bool partially_consumed_tab;\n  /* Contains the currently processed line */\n  cmark_strbuf curline;\n  /* See the documentation for cmark_parser_get_last_line_length() in cmark.h */\n  bufsize_t last_line_length;\n  /* FIXME: not sure about the difference with curline */\n  cmark_strbuf linebuf;\n  /* Options set by the user, see the Options section in cmark.h */\n  int options;\n  bool last_buffer_ended_with_cr;\n  size_t total_size;\n  cmark_llist *syntax_extensions;\n  cmark_llist *inline_syntax_extensions;\n  cmark_ispunct_func backslash_ispunct;\n};\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#include <stdlib.h>\n#include <assert.h>\n\n#include \"cmark-gfm.h\"\n#include \"syntax_extension.h\"\n#include \"buffer.h\"\n\nextern cmark_mem CMARK_DEFAULT_MEM_ALLOCATOR;\n\nstatic cmark_mem *_mem = &CMARK_DEFAULT_MEM_ALLOCATOR;\n\nvoid cmark_syntax_extension_free(cmark_mem *mem, cmark_syntax_extension *extension) {\n  if (extension->free_function && extension->priv) {\n    extension->free_function(mem, extension->priv);\n  }\n\n  cmark_llist_free(mem, extension->special_inline_chars);\n  mem->free(extension->name);\n  mem->free(extension);\n}\n\ncmark_syntax_extension *cmark_syntax_extension_new(const char *name) {\n  cmark_syntax_extension *res = (cmark_syntax_extension *) _mem->calloc(1, sizeof(cmark_syntax_extension));\n  res->name = (char *) _mem->calloc(1, sizeof(char) * (strlen(name)) + 1);\n  strcpy(res->name, name);\n  return res;\n}\n\ncmark_node_type cmark_syntax_extension_add_node(int is_inline) {\n  cmark_node_type *ref = !is_inline ? &CMARK_NODE_LAST_BLOCK : &CMARK_NODE_LAST_INLINE;\n\n  if ((*ref & CMARK_NODE_VALUE_MASK) == CMARK_NODE_VALUE_MASK) {\n    assert(false);\n    return (cmark_node_type) 0;\n  }\n\n  return *ref = (cmark_node_type) ((int) *ref + 1);\n}\n\nvoid cmark_syntax_extension_set_emphasis(cmark_syntax_extension *extension,\n                                         int emphasis) {\n  extension->emphasis = emphasis == 1;\n}\n\nvoid cmark_syntax_extension_set_open_block_func(cmark_syntax_extension *extension,\n                                                cmark_open_block_func func) {\n  extension->try_opening_block = func;\n}\n\nvoid cmark_syntax_extension_set_match_block_func(cmark_syntax_extension *extension,\n                                                 cmark_match_block_func func) {\n  extension->last_block_matches = func;\n}\n\nvoid cmark_syntax_extension_set_match_inline_func(cmark_syntax_extension *extension,\n                                                  cmark_match_inline_func func) {\n  extension->match_inline = func;\n}\n\nvoid cmark_syntax_extension_set_inline_from_delim_func(cmark_syntax_extension *extension,\n                                                       cmark_inline_from_delim_func func) {\n  extension->insert_inline_from_delim = func;\n}\n\nvoid cmark_syntax_extension_set_special_inline_chars(cmark_syntax_extension *extension,\n                                                     cmark_llist *special_chars) {\n  extension->special_inline_chars = special_chars;\n}\n\nvoid cmark_syntax_extension_set_get_type_string_func(cmark_syntax_extension *extension,\n                                                     cmark_get_type_string_func func) {\n  extension->get_type_string_func = func;\n}\n\nvoid cmark_syntax_extension_set_can_contain_func(cmark_syntax_extension *extension,\n                                                 cmark_can_contain_func func) {\n  extension->can_contain_func = func;\n}\n\nvoid cmark_syntax_extension_set_contains_inlines_func(cmark_syntax_extension *extension,\n                                                      cmark_contains_inlines_func func) {\n  extension->contains_inlines_func = func;\n}\n\nvoid cmark_syntax_extension_set_commonmark_render_func(cmark_syntax_extension *extension,\n                                                       cmark_common_render_func func) {\n  extension->commonmark_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_plaintext_render_func(cmark_syntax_extension *extension,\n                                                      cmark_common_render_func func) {\n  extension->plaintext_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_latex_render_func(cmark_syntax_extension *extension,\n                                                  cmark_common_render_func func) {\n  extension->latex_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_xml_attr_func(cmark_syntax_extension *extension,\n                                              cmark_xml_attr_func func) {\n  extension->xml_attr_func = func;\n}\n\nvoid cmark_syntax_extension_set_man_render_func(cmark_syntax_extension *extension,\n                                                cmark_common_render_func func) {\n  extension->man_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_html_render_func(cmark_syntax_extension *extension,\n                                                 cmark_html_render_func func) {\n  extension->html_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_html_filter_func(cmark_syntax_extension *extension,\n                                                 cmark_html_filter_func func) {\n  extension->html_filter_func = func;\n}\n\nvoid cmark_syntax_extension_set_postprocess_func(cmark_syntax_extension *extension,\n                                                 cmark_postprocess_func func) {\n  extension->postprocess_func = func;\n}\n\nvoid cmark_syntax_extension_set_private(cmark_syntax_extension *extension,\n                                        void *priv,\n                                        cmark_free_func free_func) {\n  extension->priv = priv;\n  extension->free_function = free_func;\n}\n\nvoid *cmark_syntax_extension_get_private(cmark_syntax_extension *extension) {\n    return extension->priv;\n}\n\nvoid cmark_syntax_extension_set_opaque_alloc_func(cmark_syntax_extension *extension,\n                                                  cmark_opaque_alloc_func func) {\n  extension->opaque_alloc_func = func;\n}\n\nvoid cmark_syntax_extension_set_opaque_free_func(cmark_syntax_extension *extension,\n                                                 cmark_opaque_free_func func) {\n  extension->opaque_free_func = func;\n}\n\nvoid cmark_syntax_extension_set_commonmark_escape_func(cmark_syntax_extension *extension,\n                                                       cmark_commonmark_escape_func func) {\n  extension->commonmark_escape_func = func;\n}\n"], "fixing_code": ["#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define CMARK_NO_SHORT_NAMES\n#include \"cmark-gfm.h\"\n#include \"node.h\"\n#include \"../extensions/cmark-gfm-core-extensions.h\"\n\n#include \"harness.h\"\n#include \"cplusplus.h\"\n\n#define UTF8_REPL \"\\xEF\\xBF\\xBD\"\n\nstatic const cmark_node_type node_types[] = {\n    CMARK_NODE_DOCUMENT,  CMARK_NODE_BLOCK_QUOTE, CMARK_NODE_LIST,\n    CMARK_NODE_ITEM,      CMARK_NODE_CODE_BLOCK,  CMARK_NODE_HTML_BLOCK,\n    CMARK_NODE_PARAGRAPH, CMARK_NODE_HEADING,     CMARK_NODE_THEMATIC_BREAK,\n    CMARK_NODE_TEXT,      CMARK_NODE_SOFTBREAK,   CMARK_NODE_LINEBREAK,\n    CMARK_NODE_CODE,      CMARK_NODE_HTML_INLINE, CMARK_NODE_EMPH,\n    CMARK_NODE_STRONG,    CMARK_NODE_LINK,        CMARK_NODE_IMAGE};\nstatic const int num_node_types = sizeof(node_types) / sizeof(*node_types);\n\nstatic void test_md_to_html(test_batch_runner *runner, const char *markdown,\n                            const char *expected_html, const char *msg);\n\nstatic void test_content(test_batch_runner *runner, cmark_node_type type,\n                         unsigned int *allowed_content);\n\nstatic void test_char(test_batch_runner *runner, int valid, const char *utf8,\n                      const char *msg);\n\nstatic void test_incomplete_char(test_batch_runner *runner, const char *utf8,\n                                 const char *msg);\n\nstatic void test_continuation_byte(test_batch_runner *runner, const char *utf8);\n\nstatic void version(test_batch_runner *runner) {\n  INT_EQ(runner, cmark_version(), CMARK_GFM_VERSION, \"cmark_version\");\n  STR_EQ(runner, cmark_version_string(), CMARK_GFM_VERSION_STRING,\n         \"cmark_version_string\");\n}\n\nstatic void constructor(test_batch_runner *runner) {\n  for (int i = 0; i < num_node_types; ++i) {\n    cmark_node_type type = node_types[i];\n    cmark_node *node = cmark_node_new(type);\n    OK(runner, node != NULL, \"new type %d\", type);\n    INT_EQ(runner, cmark_node_get_type(node), type, \"get_type %d\", type);\n\n    switch (node->type) {\n    case CMARK_NODE_HEADING:\n      INT_EQ(runner, cmark_node_get_heading_level(node), 1,\n             \"default heading level is 1\");\n      node->as.heading.level = 1;\n      break;\n\n    case CMARK_NODE_LIST:\n      INT_EQ(runner, cmark_node_get_list_type(node), CMARK_BULLET_LIST,\n             \"default is list type is bullet\");\n      INT_EQ(runner, cmark_node_get_list_delim(node), CMARK_NO_DELIM,\n             \"default is list delim is NO_DELIM\");\n      INT_EQ(runner, cmark_node_get_list_start(node), 0,\n             \"default is list start is 0\");\n      INT_EQ(runner, cmark_node_get_list_tight(node), 0,\n             \"default is list is loose\");\n      break;\n\n    default:\n      break;\n    }\n\n    cmark_node_free(node);\n  }\n}\n\nstatic void accessors(test_batch_runner *runner) {\n  static const char markdown[] = \"## Header\\n\"\n                                 \"\\n\"\n                                 \"* Item 1\\n\"\n                                 \"* Item 2\\n\"\n                                 \"\\n\"\n                                 \"2. Item 1\\n\"\n                                 \"\\n\"\n                                 \"3. Item 2\\n\"\n                                 \"\\n\"\n                                 \"``` lang\\n\"\n                                 \"fenced\\n\"\n                                 \"```\\n\"\n                                 \"    code\\n\"\n                                 \"\\n\"\n                                 \"<div>html</div>\\n\"\n                                 \"\\n\"\n                                 \"[link](url 'title')\\n\";\n\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  // Getters\n\n  cmark_node *heading = cmark_node_first_child(doc);\n  INT_EQ(runner, cmark_node_get_heading_level(heading), 2, \"get_heading_level\");\n\n  cmark_node *bullet_list = cmark_node_next(heading);\n  INT_EQ(runner, cmark_node_get_list_type(bullet_list), CMARK_BULLET_LIST,\n         \"get_list_type bullet\");\n  INT_EQ(runner, cmark_node_get_list_tight(bullet_list), 1,\n         \"get_list_tight tight\");\n\n  cmark_node *ordered_list = cmark_node_next(bullet_list);\n  INT_EQ(runner, cmark_node_get_list_type(ordered_list), CMARK_ORDERED_LIST,\n         \"get_list_type ordered\");\n  INT_EQ(runner, cmark_node_get_list_delim(ordered_list), CMARK_PERIOD_DELIM,\n         \"get_list_delim ordered\");\n  INT_EQ(runner, cmark_node_get_list_start(ordered_list), 2, \"get_list_start\");\n  INT_EQ(runner, cmark_node_get_list_tight(ordered_list), 0,\n         \"get_list_tight loose\");\n\n  cmark_node *fenced = cmark_node_next(ordered_list);\n  STR_EQ(runner, cmark_node_get_literal(fenced), \"fenced\\n\",\n         \"get_literal fenced code\");\n  STR_EQ(runner, cmark_node_get_fence_info(fenced), \"lang\", \"get_fence_info\");\n\n  cmark_node *code = cmark_node_next(fenced);\n  STR_EQ(runner, cmark_node_get_literal(code), \"code\\n\",\n         \"get_literal indented code\");\n\n  cmark_node *html = cmark_node_next(code);\n  STR_EQ(runner, cmark_node_get_literal(html), \"<div>html</div>\\n\",\n         \"get_literal html\");\n\n  cmark_node *paragraph = cmark_node_next(html);\n  INT_EQ(runner, cmark_node_get_start_line(paragraph), 17, \"get_start_line\");\n  INT_EQ(runner, cmark_node_get_start_column(paragraph), 1, \"get_start_column\");\n  INT_EQ(runner, cmark_node_get_end_line(paragraph), 17, \"get_end_line\");\n\n  cmark_node *link = cmark_node_first_child(paragraph);\n  STR_EQ(runner, cmark_node_get_url(link), \"url\", \"get_url\");\n  STR_EQ(runner, cmark_node_get_title(link), \"title\", \"get_title\");\n\n  cmark_node *string = cmark_node_first_child(link);\n  STR_EQ(runner, cmark_node_get_literal(string), \"link\", \"get_literal string\");\n\n  // Setters\n\n  OK(runner, cmark_node_set_heading_level(heading, 3), \"set_heading_level\");\n\n  OK(runner, cmark_node_set_list_type(bullet_list, CMARK_ORDERED_LIST),\n     \"set_list_type ordered\");\n  OK(runner, cmark_node_set_list_delim(bullet_list, CMARK_PAREN_DELIM),\n     \"set_list_delim paren\");\n  OK(runner, cmark_node_set_list_start(bullet_list, 3), \"set_list_start\");\n  OK(runner, cmark_node_set_list_tight(bullet_list, 0), \"set_list_tight loose\");\n\n  OK(runner, cmark_node_set_list_type(ordered_list, CMARK_BULLET_LIST),\n     \"set_list_type bullet\");\n  OK(runner, cmark_node_set_list_tight(ordered_list, 1),\n     \"set_list_tight tight\");\n\n  OK(runner, cmark_node_set_literal(code, \"CODE\\n\"),\n     \"set_literal indented code\");\n\n  OK(runner, cmark_node_set_literal(fenced, \"FENCED\\n\"),\n     \"set_literal fenced code\");\n  OK(runner, cmark_node_set_fence_info(fenced, \"LANG\"), \"set_fence_info\");\n\n  OK(runner, cmark_node_set_literal(html, \"<div>HTML</div>\\n\"),\n     \"set_literal html\");\n\n  OK(runner, cmark_node_set_url(link, \"URL\"), \"set_url\");\n  OK(runner, cmark_node_set_title(link, \"TITLE\"), \"set_title\");\n\n  OK(runner, cmark_node_set_literal(string, \"prefix-LINK\"),\n     \"set_literal string\");\n\n  // Set literal to suffix of itself (issue #139).\n  const char *literal = cmark_node_get_literal(string);\n  OK(runner, cmark_node_set_literal(string, literal + sizeof(\"prefix\")),\n     \"set_literal suffix\");\n\n  char *rendered_html = cmark_render_html(doc, CMARK_OPT_DEFAULT | CMARK_OPT_UNSAFE, NULL);\n  static const char expected_html[] =\n      \"<h3>Header</h3>\\n\"\n      \"<ol start=\\\"3\\\">\\n\"\n      \"<li>\\n\"\n      \"<p>Item 1</p>\\n\"\n      \"</li>\\n\"\n      \"<li>\\n\"\n      \"<p>Item 2</p>\\n\"\n      \"</li>\\n\"\n      \"</ol>\\n\"\n      \"<ul>\\n\"\n      \"<li>Item 1</li>\\n\"\n      \"<li>Item 2</li>\\n\"\n      \"</ul>\\n\"\n      \"<pre><code class=\\\"language-LANG\\\">FENCED\\n\"\n      \"</code></pre>\\n\"\n      \"<pre><code>CODE\\n\"\n      \"</code></pre>\\n\"\n      \"<div>HTML</div>\\n\"\n      \"<p><a href=\\\"URL\\\" title=\\\"TITLE\\\">LINK</a></p>\\n\";\n  STR_EQ(runner, rendered_html, expected_html, \"setters work\");\n  free(rendered_html);\n\n  // Getter errors\n\n  INT_EQ(runner, cmark_node_get_heading_level(bullet_list), 0,\n         \"get_heading_level error\");\n  INT_EQ(runner, cmark_node_get_list_type(heading), CMARK_NO_LIST,\n         \"get_list_type error\");\n  INT_EQ(runner, cmark_node_get_list_start(code), 0, \"get_list_start error\");\n  INT_EQ(runner, cmark_node_get_list_tight(fenced), 0, \"get_list_tight error\");\n  OK(runner, cmark_node_get_literal(ordered_list) == NULL, \"get_literal error\");\n  OK(runner, cmark_node_get_fence_info(paragraph) == NULL,\n     \"get_fence_info error\");\n  OK(runner, cmark_node_get_url(html) == NULL, \"get_url error\");\n  OK(runner, cmark_node_get_title(heading) == NULL, \"get_title error\");\n\n  // Setter errors\n\n  OK(runner, !cmark_node_set_heading_level(bullet_list, 3),\n     \"set_heading_level error\");\n  OK(runner, !cmark_node_set_list_type(heading, CMARK_ORDERED_LIST),\n     \"set_list_type error\");\n  OK(runner, !cmark_node_set_list_start(code, 3), \"set_list_start error\");\n  OK(runner, !cmark_node_set_list_tight(fenced, 0), \"set_list_tight error\");\n  OK(runner, !cmark_node_set_literal(ordered_list, \"content\\n\"),\n     \"set_literal error\");\n  OK(runner, !cmark_node_set_fence_info(paragraph, \"lang\"),\n     \"set_fence_info error\");\n  OK(runner, !cmark_node_set_url(html, \"url\"), \"set_url error\");\n  OK(runner, !cmark_node_set_title(heading, \"title\"), \"set_title error\");\n\n  OK(runner, !cmark_node_set_heading_level(heading, 0),\n     \"set_heading_level too small\");\n  OK(runner, !cmark_node_set_heading_level(heading, 7),\n     \"set_heading_level too large\");\n  OK(runner, !cmark_node_set_list_type(bullet_list, CMARK_NO_LIST),\n     \"set_list_type invalid\");\n  OK(runner, !cmark_node_set_list_start(bullet_list, -1),\n     \"set_list_start negative\");\n\n  cmark_node_free(doc);\n}\n\nstatic void node_check(test_batch_runner *runner) {\n  // Construct an incomplete tree.\n  cmark_node *doc = cmark_node_new(CMARK_NODE_DOCUMENT);\n  cmark_node *p1 = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  cmark_node *p2 = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  doc->first_child = p1;\n  p1->next = p2;\n\n  INT_EQ(runner, cmark_node_check(doc, NULL), 4, \"node_check works\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"node_check fixes tree\");\n\n  cmark_node_free(doc);\n}\n\nstatic void iterator(test_batch_runner *runner) {\n  cmark_node *doc = cmark_parse_document(\"> a *b*\\n\\nc\", 10, CMARK_OPT_DEFAULT);\n  int parnodes = 0;\n  cmark_event_type ev_type;\n  cmark_iter *iter = cmark_iter_new(doc);\n  cmark_node *cur;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (cur->type == CMARK_NODE_PARAGRAPH && ev_type == CMARK_EVENT_ENTER) {\n      parnodes += 1;\n    }\n  }\n  INT_EQ(runner, parnodes, 2, \"iterate correctly counts paragraphs\");\n\n  cmark_iter_free(iter);\n  cmark_node_free(doc);\n}\n\nstatic void iterator_delete(test_batch_runner *runner) {\n  static const char md[] = \"a *b* c\\n\"\n                           \"\\n\"\n                           \"* item1\\n\"\n                           \"* item2\\n\"\n                           \"\\n\"\n                           \"a `b` c\\n\"\n                           \"\\n\"\n                           \"* item1\\n\"\n                           \"* item2\\n\";\n  cmark_node *doc = cmark_parse_document(md, sizeof(md) - 1, CMARK_OPT_DEFAULT);\n  cmark_iter *iter = cmark_iter_new(doc);\n  cmark_event_type ev_type;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cmark_node *node = cmark_iter_get_node(iter);\n    // Delete list, emph, and code nodes.\n    if ((ev_type == CMARK_EVENT_EXIT && node->type == CMARK_NODE_LIST) ||\n        (ev_type == CMARK_EVENT_EXIT && node->type == CMARK_NODE_EMPH) ||\n        (ev_type == CMARK_EVENT_ENTER && node->type == CMARK_NODE_CODE)) {\n      cmark_node_free(node);\n    }\n  }\n\n  char *html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  static const char expected[] = \"<p>a  c</p>\\n\"\n                                 \"<p>a  c</p>\\n\";\n  STR_EQ(runner, html, expected, \"iterate and delete nodes\");\n\n  free(html);\n  cmark_iter_free(iter);\n  cmark_node_free(doc);\n}\n\nstatic void create_tree(test_batch_runner *runner) {\n  char *html;\n  cmark_node *doc = cmark_node_new(CMARK_NODE_DOCUMENT);\n\n  cmark_node *p = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  OK(runner, !cmark_node_insert_before(doc, p), \"insert before root fails\");\n  OK(runner, !cmark_node_insert_after(doc, p), \"insert after root fails\");\n  OK(runner, cmark_node_append_child(doc, p), \"append1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"append1 consistent\");\n  OK(runner, cmark_node_parent(p) == doc, \"node_parent\");\n\n  cmark_node *emph = cmark_node_new(CMARK_NODE_EMPH);\n  OK(runner, cmark_node_prepend_child(p, emph), \"prepend1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"prepend1 consistent\");\n\n  cmark_node *str1 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str1, \"Hello, \");\n  OK(runner, cmark_node_prepend_child(p, str1), \"prepend2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"prepend2 consistent\");\n\n  cmark_node *str3 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str3, \"!\");\n  OK(runner, cmark_node_append_child(p, str3), \"append2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"append2 consistent\");\n\n  cmark_node *str2 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str2, \"world\");\n  OK(runner, cmark_node_append_child(emph, str2), \"append3\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"append3 consistent\");\n\n  html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p>Hello, <em>world</em>!</p>\\n\", \"render_html\");\n  free(html);\n\n  OK(runner, cmark_node_insert_before(str1, str3), \"ins before1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins before1 consistent\");\n  // 31e\n  OK(runner, cmark_node_first_child(p) == str3, \"ins before1 works\");\n\n  OK(runner, cmark_node_insert_before(str1, emph), \"ins before2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins before2 consistent\");\n  // 3e1\n  OK(runner, cmark_node_last_child(p) == str1, \"ins before2 works\");\n\n  OK(runner, cmark_node_insert_after(str1, str3), \"ins after1\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins after1 consistent\");\n  // e13\n  OK(runner, cmark_node_next(str1) == str3, \"ins after1 works\");\n\n  OK(runner, cmark_node_insert_after(str1, emph), \"ins after2\");\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"ins after2 consistent\");\n  // 1e3\n  OK(runner, cmark_node_previous(emph) == str1, \"ins after2 works\");\n\n  cmark_node *str4 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str4, \"brzz\");\n  OK(runner, cmark_node_replace(str1, str4), \"replace\");\n  // The replaced node is not freed\n  cmark_node_free(str1);\n\n  INT_EQ(runner, cmark_node_check(doc, NULL), 0, \"replace consistent\");\n  OK(runner, cmark_node_previous(emph) == str4, \"replace works\");\n  INT_EQ(runner, cmark_node_replace(p, str4), 0, \"replace str for p fails\");\n\n  cmark_node_unlink(emph);\n\n  html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p>brzz!</p>\\n\", \"render_html after shuffling\");\n  free(html);\n\n  cmark_node_free(doc);\n\n  // TODO: Test that the contents of an unlinked inline are valid\n  // after the parent block was destroyed. This doesn't work so far.\n  cmark_node_free(emph);\n}\n\nstatic void custom_nodes(test_batch_runner *runner) {\n  char *html;\n  char *man;\n  cmark_node *doc = cmark_node_new(CMARK_NODE_DOCUMENT);\n  cmark_node *p = cmark_node_new(CMARK_NODE_PARAGRAPH);\n  cmark_node_append_child(doc, p);\n  cmark_node *ci = cmark_node_new(CMARK_NODE_CUSTOM_INLINE);\n  cmark_node *str1 = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(str1, \"Hello\");\n  OK(runner, cmark_node_append_child(ci, str1), \"append1\");\n  OK(runner, cmark_node_set_on_enter(ci, \"<ON ENTER|\"), \"set_on_enter\");\n  OK(runner, cmark_node_set_on_exit(ci, \"|ON EXIT>\"), \"set_on_exit\");\n  STR_EQ(runner, cmark_node_get_on_enter(ci), \"<ON ENTER|\", \"get_on_enter\");\n  STR_EQ(runner, cmark_node_get_on_exit(ci), \"|ON EXIT>\", \"get_on_exit\");\n  cmark_node_append_child(p, ci);\n  cmark_node *cb = cmark_node_new(CMARK_NODE_CUSTOM_BLOCK);\n  cmark_node_set_on_enter(cb, \"<on enter|\");\n  // leave on_exit unset\n  STR_EQ(runner, cmark_node_get_on_exit(cb), \"\", \"get_on_exit (empty)\");\n  cmark_node_append_child(doc, cb);\n\n  html = cmark_render_html(doc, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p><ON ENTER|Hello|ON EXIT></p>\\n<on enter|\\n\",\n         \"render_html\");\n  free(html);\n\n  man = cmark_render_man(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, man, \".PP\\n<ON ENTER|Hello|ON EXIT>\\n<on enter|\\n\",\n         \"render_man\");\n  free(man);\n\n  cmark_node_free(doc);\n}\n\nvoid hierarchy(test_batch_runner *runner) {\n  cmark_node *bquote1 = cmark_node_new(CMARK_NODE_BLOCK_QUOTE);\n  cmark_node *bquote2 = cmark_node_new(CMARK_NODE_BLOCK_QUOTE);\n  cmark_node *bquote3 = cmark_node_new(CMARK_NODE_BLOCK_QUOTE);\n\n  OK(runner, cmark_node_append_child(bquote1, bquote2), \"append bquote2\");\n  OK(runner, cmark_node_append_child(bquote2, bquote3), \"append bquote3\");\n  OK(runner, !cmark_node_append_child(bquote3, bquote3),\n     \"adding a node as child of itself fails\");\n  OK(runner, !cmark_node_append_child(bquote3, bquote1),\n     \"adding a parent as child fails\");\n\n  cmark_node_free(bquote1);\n\n  unsigned int list_item_flag[] = {CMARK_NODE_ITEM, 0};\n  unsigned int top_level_blocks[] = {\n    CMARK_NODE_BLOCK_QUOTE, CMARK_NODE_LIST,\n    CMARK_NODE_CODE_BLOCK, CMARK_NODE_HTML_BLOCK,\n    CMARK_NODE_PARAGRAPH, CMARK_NODE_HEADING,\n    CMARK_NODE_THEMATIC_BREAK, 0};\n  unsigned int all_inlines[] = {\n    CMARK_NODE_TEXT, CMARK_NODE_SOFTBREAK,\n    CMARK_NODE_LINEBREAK, CMARK_NODE_CODE,\n    CMARK_NODE_HTML_INLINE, CMARK_NODE_EMPH,\n    CMARK_NODE_STRONG, CMARK_NODE_LINK,\n    CMARK_NODE_IMAGE, 0};\n\n  test_content(runner, CMARK_NODE_DOCUMENT, top_level_blocks);\n  test_content(runner, CMARK_NODE_BLOCK_QUOTE, top_level_blocks);\n  test_content(runner, CMARK_NODE_LIST, list_item_flag);\n  test_content(runner, CMARK_NODE_ITEM, top_level_blocks);\n  test_content(runner, CMARK_NODE_CODE_BLOCK, 0);\n  test_content(runner, CMARK_NODE_HTML_BLOCK, 0);\n  test_content(runner, CMARK_NODE_PARAGRAPH, all_inlines);\n  test_content(runner, CMARK_NODE_HEADING, all_inlines);\n  test_content(runner, CMARK_NODE_THEMATIC_BREAK, 0);\n  test_content(runner, CMARK_NODE_TEXT, 0);\n  test_content(runner, CMARK_NODE_SOFTBREAK, 0);\n  test_content(runner, CMARK_NODE_LINEBREAK, 0);\n  test_content(runner, CMARK_NODE_CODE, 0);\n  test_content(runner, CMARK_NODE_HTML_INLINE, 0);\n  test_content(runner, CMARK_NODE_EMPH, all_inlines);\n  test_content(runner, CMARK_NODE_STRONG, all_inlines);\n  test_content(runner, CMARK_NODE_LINK, all_inlines);\n  test_content(runner, CMARK_NODE_IMAGE, all_inlines);\n}\n\nstatic void test_content(test_batch_runner *runner, cmark_node_type type,\n                         unsigned int *allowed_content) {\n  cmark_node *node = cmark_node_new(type);\n\n  for (int i = 0; i < num_node_types; ++i) {\n    cmark_node_type child_type = node_types[i];\n    cmark_node *child = cmark_node_new(child_type);\n\n    int got = cmark_node_append_child(node, child);\n    int expected = 0;\n    if (allowed_content)\n        for (unsigned int *p = allowed_content; *p; ++p)\n            expected |= *p == (unsigned int)child_type;\n\n    INT_EQ(runner, got, expected, \"add %d as child of %d\", child_type, type);\n\n    cmark_node_free(child);\n  }\n\n  cmark_node_free(node);\n}\n\nstatic void parser(test_batch_runner *runner) {\n  test_md_to_html(runner, \"No newline\", \"<p>No newline</p>\\n\",\n                  \"document without trailing newline\");\n}\n\nstatic void render_html(test_batch_runner *runner) {\n  char *html;\n\n  static const char markdown[] = \"foo *bar*\\n\"\n                                 \"\\n\"\n                                 \"paragraph 2\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  cmark_node *paragraph = cmark_node_first_child(doc);\n  html = cmark_render_html(paragraph, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<p>foo <em>bar</em></p>\\n\", \"render single paragraph\");\n  free(html);\n\n  cmark_node *string = cmark_node_first_child(paragraph);\n  html = cmark_render_html(string, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"foo \", \"render single inline\");\n  free(html);\n\n  cmark_node *emph = cmark_node_next(string);\n  html = cmark_render_html(emph, CMARK_OPT_DEFAULT, NULL);\n  STR_EQ(runner, html, \"<em>bar</em>\", \"render inline with children\");\n  free(html);\n\n  cmark_node_free(doc);\n}\n\nstatic void render_xml(test_batch_runner *runner) {\n  char *xml;\n\n  static const char markdown[] = \"foo *bar*\\n\"\n                                 \"\\n\"\n                                 \"paragraph 2\\n\"\n                                 \"\\n\"\n                                 \"```\\ncode\\n```\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<document xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                      \"  <paragraph>\\n\"\n                      \"    <text xml:space=\\\"preserve\\\">foo </text>\\n\"\n                      \"    <emph>\\n\"\n                      \"      <text xml:space=\\\"preserve\\\">bar</text>\\n\"\n                      \"    </emph>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"  <paragraph>\\n\"\n                      \"    <text xml:space=\\\"preserve\\\">paragraph 2</text>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"  <code_block xml:space=\\\"preserve\\\">code\\n\"\n                      \"</code_block>\\n\"\n                      \"</document>\\n\",\n         \"render document\");\n  free(xml);\n  cmark_node *paragraph = cmark_node_first_child(doc);\n  xml = cmark_render_xml(paragraph, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<paragraph sourcepos=\\\"1:1-1:9\\\">\\n\"\n                      \"  <text sourcepos=\\\"1:1-1:4\\\" xml:space=\\\"preserve\\\">foo </text>\\n\"\n                      \"  <emph sourcepos=\\\"1:5-1:9\\\">\\n\"\n                      \"    <text sourcepos=\\\"1:6-1:8\\\" xml:space=\\\"preserve\\\">bar</text>\\n\"\n                      \"  </emph>\\n\"\n                      \"</paragraph>\\n\",\n         \"render first paragraph with source pos\");\n  free(xml);\n  cmark_node_free(doc);\n}\n\nstatic void render_man(test_batch_runner *runner) {\n  char *man;\n\n  static const char markdown[] = \"foo *bar*\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  man = cmark_render_man(doc, CMARK_OPT_DEFAULT, 20);\n  STR_EQ(runner, man, \".PP\\n\"\n                      \"foo \\\\f[I]bar\\\\f[]\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"Lorem ipsum dolor\\n\"\n                      \"sit amet,\\n\"\n                      \"consectetur\\n\"\n                      \"adipiscing elit,\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"sed do eiusmod\\n\"\n                      \"tempor incididunt ut\\n\"\n                      \"labore et dolore\\n\"\n                      \"magna aliqua.\\n\",\n         \"render document with wrapping\");\n  free(man);\n  man = cmark_render_man(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, man, \".PP\\n\"\n                      \"foo \\\\f[I]bar\\\\f[]\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"Lorem ipsum dolor sit amet,\\n\"\n                      \"consectetur adipiscing elit,\\n\"\n                      \".IP \\\\[bu] 2\\n\"\n                      \"sed do eiusmod tempor incididunt\\n\"\n                      \"ut labore et dolore magna aliqua.\\n\",\n         \"render document without wrapping\");\n  free(man);\n  cmark_node_free(doc);\n}\n\nstatic void render_latex(test_batch_runner *runner) {\n  char *latex;\n\n  static const char markdown[] = \"foo *bar* $%\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  latex = cmark_render_latex(doc, CMARK_OPT_DEFAULT, 20);\n  STR_EQ(runner, latex, \"foo \\\\emph{bar} \\\\$\\\\%\\n\"\n                        \"\\n\"\n                        \"\\\\begin{itemize}\\n\"\n                        \"\\\\item Lorem ipsum\\n\"\n                        \"dolor sit amet,\\n\"\n                        \"consectetur\\n\"\n                        \"adipiscing elit,\\n\"\n                        \"\\n\"\n                        \"\\\\item sed do eiusmod\\n\"\n                        \"tempor incididunt ut\\n\"\n                        \"labore et dolore\\n\"\n                        \"magna aliqua.\\n\"\n                        \"\\n\"\n                        \"\\\\end{itemize}\\n\",\n         \"render document with wrapping\");\n  free(latex);\n  latex = cmark_render_latex(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, latex, \"foo \\\\emph{bar} \\\\$\\\\%\\n\"\n                        \"\\n\"\n                        \"\\\\begin{itemize}\\n\"\n                        \"\\\\item Lorem ipsum dolor sit amet,\\n\"\n                        \"consectetur adipiscing elit,\\n\"\n                        \"\\n\"\n                        \"\\\\item sed do eiusmod tempor incididunt\\n\"\n                        \"ut labore et dolore magna aliqua.\\n\"\n                        \"\\n\"\n                        \"\\\\end{itemize}\\n\",\n         \"render document without wrapping\");\n  free(latex);\n  cmark_node_free(doc);\n}\n\nstatic void render_commonmark(test_batch_runner *runner) {\n  char *commonmark;\n\n  static const char markdown[] = \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  commonmark = cmark_render_commonmark(doc, CMARK_OPT_DEFAULT, 26);\n  STR_EQ(runner, commonmark, \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit\\n\"\n                             \"    amet, consectetur\\n\"\n                             \"    adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor\\n\"\n                             \"    incididunt ut labore\\n\"\n                             \"    et dolore magna\\n\"\n                             \"    aliqua.\\n\",\n         \"render document with wrapping\");\n  free(commonmark);\n  commonmark = cmark_render_commonmark(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, commonmark, \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit amet,\\n\"\n                             \"    consectetur adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor incididunt\\n\"\n                             \"    ut labore et dolore magna aliqua.\\n\",\n         \"render document without wrapping\");\n  free(commonmark);\n\n  cmark_node *text = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(text, \"Hi\");\n  commonmark = cmark_render_commonmark(text, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, commonmark, \"Hi\\n\", \"render single inline node\");\n  free(commonmark);\n\n  cmark_node_free(text);\n  cmark_node_free(doc);\n}\n\nstatic void render_plaintext(test_batch_runner *runner) {\n  char *plaintext;\n\n  static const char markdown[] = \"> \\\\- foo *bar* \\\\*bar\\\\*\\n\"\n                                 \"\\n\"\n                                 \"- Lorem ipsum dolor sit amet,\\n\"\n                                 \"  consectetur adipiscing elit,\\n\"\n                                 \"- sed do eiusmod tempor incididunt\\n\"\n                                 \"  ut labore et dolore magna aliqua.\\n\";\n  cmark_node *doc =\n      cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n\n  plaintext = cmark_render_plaintext(doc, CMARK_OPT_DEFAULT, 26);\n  STR_EQ(runner, plaintext, \"- foo bar *bar*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit\\n\"\n                             \"    amet, consectetur\\n\"\n                             \"    adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor\\n\"\n                             \"    incididunt ut labore\\n\"\n                             \"    et dolore magna\\n\"\n                             \"    aliqua.\\n\",\n         \"render document with wrapping\");\n  free(plaintext);\n  plaintext = cmark_render_plaintext(doc, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, plaintext, \"- foo bar *bar*\\n\"\n                             \"\\n\"\n                             \"  - Lorem ipsum dolor sit amet,\\n\"\n                             \"    consectetur adipiscing elit,\\n\"\n                             \"  - sed do eiusmod tempor incididunt\\n\"\n                             \"    ut labore et dolore magna aliqua.\\n\",\n         \"render document without wrapping\");\n  free(plaintext);\n\n  cmark_node *text = cmark_node_new(CMARK_NODE_TEXT);\n  cmark_node_set_literal(text, \"Hi\");\n  plaintext = cmark_render_plaintext(text, CMARK_OPT_DEFAULT, 0);\n  STR_EQ(runner, plaintext, \"Hi\\n\", \"render single inline node\");\n  free(plaintext);\n\n  cmark_node_free(text);\n  cmark_node_free(doc);\n}\n\nstatic void utf8(test_batch_runner *runner) {\n  // Ranges\n  test_char(runner, 1, \"\\x01\", \"valid utf8 01\");\n  test_char(runner, 1, \"\\x7F\", \"valid utf8 7F\");\n  test_char(runner, 0, \"\\x80\", \"invalid utf8 80\");\n  test_char(runner, 0, \"\\xBF\", \"invalid utf8 BF\");\n  test_char(runner, 0, \"\\xC0\\x80\", \"invalid utf8 C080\");\n  test_char(runner, 0, \"\\xC1\\xBF\", \"invalid utf8 C1BF\");\n  test_char(runner, 1, \"\\xC2\\x80\", \"valid utf8 C280\");\n  test_char(runner, 1, \"\\xDF\\xBF\", \"valid utf8 DFBF\");\n  test_char(runner, 0, \"\\xE0\\x80\\x80\", \"invalid utf8 E08080\");\n  test_char(runner, 0, \"\\xE0\\x9F\\xBF\", \"invalid utf8 E09FBF\");\n  test_char(runner, 1, \"\\xE0\\xA0\\x80\", \"valid utf8 E0A080\");\n  test_char(runner, 1, \"\\xED\\x9F\\xBF\", \"valid utf8 ED9FBF\");\n  test_char(runner, 0, \"\\xED\\xA0\\x80\", \"invalid utf8 EDA080\");\n  test_char(runner, 0, \"\\xED\\xBF\\xBF\", \"invalid utf8 EDBFBF\");\n  test_char(runner, 0, \"\\xF0\\x80\\x80\\x80\", \"invalid utf8 F0808080\");\n  test_char(runner, 0, \"\\xF0\\x8F\\xBF\\xBF\", \"invalid utf8 F08FBFBF\");\n  test_char(runner, 1, \"\\xF0\\x90\\x80\\x80\", \"valid utf8 F0908080\");\n  test_char(runner, 1, \"\\xF4\\x8F\\xBF\\xBF\", \"valid utf8 F48FBFBF\");\n  test_char(runner, 0, \"\\xF4\\x90\\x80\\x80\", \"invalid utf8 F4908080\");\n  test_char(runner, 0, \"\\xF7\\xBF\\xBF\\xBF\", \"invalid utf8 F7BFBFBF\");\n  test_char(runner, 0, \"\\xF8\", \"invalid utf8 F8\");\n  test_char(runner, 0, \"\\xFF\", \"invalid utf8 FF\");\n\n  // Incomplete byte sequences at end of input\n  test_incomplete_char(runner, \"\\xE0\\xA0\", \"invalid utf8 E0A0\");\n  test_incomplete_char(runner, \"\\xF0\\x90\\x80\", \"invalid utf8 F09080\");\n\n  // Invalid continuation bytes\n  test_continuation_byte(runner, \"\\xC2\\x80\");\n  test_continuation_byte(runner, \"\\xE0\\xA0\\x80\");\n  test_continuation_byte(runner, \"\\xF0\\x90\\x80\\x80\");\n\n  // Test string containing null character\n  static const char string_with_null[] = \"((((\\0))))\";\n  char *html = cmark_markdown_to_html(\n      string_with_null, sizeof(string_with_null) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<p>((((\" UTF8_REPL \"))))</p>\\n\", \"utf8 with U+0000\");\n  free(html);\n\n  // Test NUL followed by newline\n  static const char string_with_nul_lf[] = \"```\\n\\0\\n```\\n\";\n  html = cmark_markdown_to_html(\n      string_with_nul_lf, sizeof(string_with_nul_lf) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<pre><code>\\xef\\xbf\\xbd\\n</code></pre>\\n\",\n         \"utf8 with \\\\0\\\\n\");\n  free(html);\n\n  // Test byte-order marker\n  static const char string_with_bom[] = \"\\xef\\xbb\\xbf# Hello\\n\";\n  html = cmark_markdown_to_html(\n      string_with_bom, sizeof(string_with_bom) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<h1>Hello</h1>\\n\", \"utf8 with BOM\");\n  free(html);\n}\n\nstatic void test_char(test_batch_runner *runner, int valid, const char *utf8,\n                      const char *msg) {\n  char buf[20];\n  sprintf(buf, \"((((%s))))\", utf8);\n\n  if (valid) {\n    char expected[30];\n    sprintf(expected, \"<p>((((%s))))</p>\\n\", utf8);\n    test_md_to_html(runner, buf, expected, msg);\n  } else {\n    test_md_to_html(runner, buf, \"<p>((((\" UTF8_REPL \"))))</p>\\n\", msg);\n  }\n}\n\nstatic void test_incomplete_char(test_batch_runner *runner, const char *utf8,\n                                 const char *msg) {\n  char buf[20];\n  sprintf(buf, \"----%s\", utf8);\n  test_md_to_html(runner, buf, \"<p>----\" UTF8_REPL \"</p>\\n\", msg);\n}\n\nstatic void test_continuation_byte(test_batch_runner *runner,\n                                   const char *utf8) {\n  size_t len = strlen(utf8);\n\n  for (size_t pos = 1; pos < len; ++pos) {\n    char buf[20];\n    sprintf(buf, \"((((%s))))\", utf8);\n    buf[4 + pos] = '\\x20';\n\n    char expected[50];\n    strcpy(expected, \"<p>((((\" UTF8_REPL \"\\x20\");\n    for (size_t i = pos + 1; i < len; ++i) {\n      strcat(expected, UTF8_REPL);\n    }\n    strcat(expected, \"))))</p>\\n\");\n\n    char *html =\n        cmark_markdown_to_html(buf, strlen(buf), CMARK_OPT_VALIDATE_UTF8);\n    STR_EQ(runner, html, expected, \"invalid utf8 continuation byte %d/%d\", pos,\n           len);\n    free(html);\n  }\n}\n\nstatic void line_endings(test_batch_runner *runner) {\n  // Test list with different line endings\n  static const char list_with_endings[] = \"- a\\n- b\\r\\n- c\\r- d\";\n  char *html = cmark_markdown_to_html(\n      list_with_endings, sizeof(list_with_endings) - 1, CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html,\n         \"<ul>\\n<li>a</li>\\n<li>b</li>\\n<li>c</li>\\n<li>d</li>\\n</ul>\\n\",\n         \"list with different line endings\");\n  free(html);\n\n  static const char crlf_lines[] = \"line\\r\\nline\\r\\n\";\n  html = cmark_markdown_to_html(crlf_lines, sizeof(crlf_lines) - 1,\n                                CMARK_OPT_DEFAULT | CMARK_OPT_HARDBREAKS);\n  STR_EQ(runner, html, \"<p>line<br />\\nline</p>\\n\",\n         \"crlf endings with CMARK_OPT_HARDBREAKS\");\n  free(html);\n  html = cmark_markdown_to_html(crlf_lines, sizeof(crlf_lines) - 1,\n                                CMARK_OPT_DEFAULT | CMARK_OPT_NOBREAKS);\n  STR_EQ(runner, html, \"<p>line line</p>\\n\",\n         \"crlf endings with CMARK_OPT_NOBREAKS\");\n  free(html);\n\n  static const char no_line_ending[] = \"```\\nline\\n```\";\n  html = cmark_markdown_to_html(no_line_ending, sizeof(no_line_ending) - 1,\n                                CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<pre><code>line\\n</code></pre>\\n\",\n         \"fenced code block with no final newline\");\n  free(html);\n}\n\nstatic void numeric_entities(test_batch_runner *runner) {\n  test_md_to_html(runner, \"&#0;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0\");\n  test_md_to_html(runner, \"&#55295;\", \"<p>\\xED\\x9F\\xBF</p>\\n\",\n                  \"Valid numeric entity 0xD7FF\");\n  test_md_to_html(runner, \"&#xD800;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0xD800\");\n  test_md_to_html(runner, \"&#xDFFF;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0xDFFF\");\n  test_md_to_html(runner, \"&#57344;\", \"<p>\\xEE\\x80\\x80</p>\\n\",\n                  \"Valid numeric entity 0xE000\");\n  test_md_to_html(runner, \"&#x10FFFF;\", \"<p>\\xF4\\x8F\\xBF\\xBF</p>\\n\",\n                  \"Valid numeric entity 0x10FFFF\");\n  test_md_to_html(runner, \"&#x110000;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0x110000\");\n  test_md_to_html(runner, \"&#x80000000;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0x80000000\");\n  test_md_to_html(runner, \"&#xFFFFFFFF;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 0xFFFFFFFF\");\n  test_md_to_html(runner, \"&#99999999;\", \"<p>\" UTF8_REPL \"</p>\\n\",\n                  \"Invalid numeric entity 99999999\");\n\n  test_md_to_html(runner, \"&#;\", \"<p>&amp;#;</p>\\n\",\n                  \"Min decimal entity length\");\n  test_md_to_html(runner, \"&#x;\", \"<p>&amp;#x;</p>\\n\",\n                  \"Min hexadecimal entity length\");\n  test_md_to_html(runner, \"&#999999999;\", \"<p>&amp;#999999999;</p>\\n\",\n                  \"Max decimal entity length\");\n  test_md_to_html(runner, \"&#x000000041;\", \"<p>&amp;#x000000041;</p>\\n\",\n                  \"Max hexadecimal entity length\");\n}\n\nstatic void test_safe(test_batch_runner *runner) {\n  // Test safe mode\n  static const char raw_html[] = \"<div>\\nhi\\n</div>\\n\\n<a>hi</\"\n                                 \"a>\\n[link](JAVAscript:alert('hi'))\\n![image](\"\n                                 \"file:my.js)\\n\";\n  char *html = cmark_markdown_to_html(raw_html, sizeof(raw_html) - 1,\n                                      CMARK_OPT_DEFAULT);\n  STR_EQ(runner, html, \"<!-- raw HTML omitted -->\\n<p><!-- raw HTML omitted \"\n                       \"-->hi<!-- raw HTML omitted -->\\n<a \"\n                       \"href=\\\"\\\">link</a>\\n<img src=\\\"\\\" alt=\\\"image\\\" \"\n                       \"/></p>\\n\",\n         \"input with raw HTML and dangerous links\");\n  free(html);\n}\n\nstatic void test_md_to_html(test_batch_runner *runner, const char *markdown,\n                            const char *expected_html, const char *msg) {\n  char *html = cmark_markdown_to_html(markdown, strlen(markdown),\n                                      CMARK_OPT_VALIDATE_UTF8);\n  STR_EQ(runner, html, expected_html, msg);\n  free(html);\n}\n\nstatic void test_feed_across_line_ending(test_batch_runner *runner) {\n  // See #117\n  cmark_parser *parser = cmark_parser_new(CMARK_OPT_DEFAULT);\n  cmark_parser_feed(parser, \"line1\\r\", 6);\n  cmark_parser_feed(parser, \"\\nline2\\r\\n\", 8);\n  cmark_node *document = cmark_parser_finish(parser);\n  OK(runner, document->first_child->next == NULL, \"document has one paragraph\");\n  cmark_parser_free(parser);\n  cmark_node_free(document);\n}\n\n#if !defined(_WIN32) || defined(__CYGWIN__)\n#  include <sys/time.h>\nstatic struct timeval _before, _after;\nstatic int _timing;\n#  define START_TIMING() \\\n       gettimeofday(&_before, NULL)\n\n#  define END_TIMING() \\\n        do { \\\n          gettimeofday(&_after, NULL); \\\n          _timing = (_after.tv_sec - _before.tv_sec) * 1000 + (_after.tv_usec - _before.tv_usec) / 1000; \\\n        } while (0)\n\n#  define TIMING _timing\n#else\n#  define START_TIMING()\n#  define END_TIMING()\n#  define TIMING 0\n#endif\n\nstatic void test_pathological_regressions(test_batch_runner *runner) {\n  {\n    // I don't care what the output is, so long as it doesn't take too long.\n    char path[] = \"[a](b\";\n    char *input = (char *)calloc(1, (sizeof(path) - 1) * 50000);\n    for (int i = 0; i < 50000; ++i)\n      memcpy(input + i * (sizeof(path) - 1), path, sizeof(path) - 1);\n\n    START_TIMING();\n    char *html = cmark_markdown_to_html(input, (sizeof(path) - 1) * 50000,\n                                        CMARK_OPT_VALIDATE_UTF8);\n    END_TIMING();\n    free(html);\n    free(input);\n\n    OK(runner, TIMING < 1000, \"takes less than 1000ms to run\");\n  }\n\n  {\n    char path[] = \"[a](<b\";\n    char *input = (char *)calloc(1, (sizeof(path) - 1) * 50000);\n    for (int i = 0; i < 50000; ++i)\n      memcpy(input + i * (sizeof(path) - 1), path, sizeof(path) - 1);\n\n    START_TIMING();\n    char *html = cmark_markdown_to_html(input, (sizeof(path) - 1) * 50000,\n                                        CMARK_OPT_VALIDATE_UTF8);\n    END_TIMING();\n    free(html);\n    free(input);\n\n    OK(runner, TIMING < 1000, \"takes less than 1000ms to run\");\n  }\n}\n\nstatic void source_pos(test_batch_runner *runner) {\n  static const char markdown[] =\n    \"# Hi *there*.\\n\"\n    \"\\n\"\n    \"Hello &ldquo; <http://www.google.com>\\n\"\n    \"there `hi` -- [okay](www.google.com (ok)).\\n\"\n    \"\\n\"\n    \"> 1. Okay.\\n\"\n    \">    Sure.\\n\"\n    \">\\n\"\n    \"> 2. Yes, okay.\\n\"\n    \">    ![ok](hi \\\"yes\\\")\\n\";\n\n  cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n  char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<document sourcepos=\\\"1:1-10:20\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                      \"  <heading sourcepos=\\\"1:1-1:13\\\" level=\\\"1\\\">\\n\"\n                      \"    <text sourcepos=\\\"1:3-1:5\\\" xml:space=\\\"preserve\\\">Hi </text>\\n\"\n                      \"    <emph sourcepos=\\\"1:6-1:12\\\">\\n\"\n                      \"      <text sourcepos=\\\"1:7-1:11\\\" xml:space=\\\"preserve\\\">there</text>\\n\"\n                      \"    </emph>\\n\"\n                      \"    <text sourcepos=\\\"1:13-1:13\\\" xml:space=\\\"preserve\\\">.</text>\\n\"\n                      \"  </heading>\\n\"\n                      \"  <paragraph sourcepos=\\\"3:1-4:42\\\">\\n\"\n                      \"    <text sourcepos=\\\"3:1-3:14\\\" xml:space=\\\"preserve\\\">Hello \\xe2\\x80\\x9c </text>\\n\"\n                      \"    <link sourcepos=\\\"3:15-3:37\\\" destination=\\\"http://www.google.com\\\" title=\\\"\\\">\\n\"\n                      \"      <text sourcepos=\\\"3:16-3:36\\\" xml:space=\\\"preserve\\\">http://www.google.com</text>\\n\"\n                      \"    </link>\\n\"\n                      \"    <softbreak />\\n\"\n                      \"    <text sourcepos=\\\"4:1-4:6\\\" xml:space=\\\"preserve\\\">there </text>\\n\"\n                      \"    <code sourcepos=\\\"4:8-4:9\\\" xml:space=\\\"preserve\\\">hi</code>\\n\"\n                      \"    <text sourcepos=\\\"4:11-4:14\\\" xml:space=\\\"preserve\\\"> -- </text>\\n\"\n                      \"    <link sourcepos=\\\"4:15-4:41\\\" destination=\\\"www.google.com\\\" title=\\\"ok\\\">\\n\"\n                      \"      <text sourcepos=\\\"4:16-4:19\\\" xml:space=\\\"preserve\\\">okay</text>\\n\"\n                      \"    </link>\\n\"\n                      \"    <text sourcepos=\\\"4:42-4:42\\\" xml:space=\\\"preserve\\\">.</text>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"  <block_quote sourcepos=\\\"6:1-10:20\\\">\\n\"\n                      \"    <list sourcepos=\\\"6:3-10:20\\\" type=\\\"ordered\\\" start=\\\"1\\\" delim=\\\"period\\\" tight=\\\"false\\\">\\n\"\n                      \"      <item sourcepos=\\\"6:3-8:1\\\">\\n\"\n                      \"        <paragraph sourcepos=\\\"6:6-7:10\\\">\\n\"\n                      \"          <text sourcepos=\\\"6:6-6:10\\\" xml:space=\\\"preserve\\\">Okay.</text>\\n\"\n                      \"          <softbreak />\\n\"\n                      \"          <text sourcepos=\\\"7:6-7:10\\\" xml:space=\\\"preserve\\\">Sure.</text>\\n\"\n                      \"        </paragraph>\\n\"\n                      \"      </item>\\n\"\n                      \"      <item sourcepos=\\\"9:3-10:20\\\">\\n\"\n                      \"        <paragraph sourcepos=\\\"9:6-10:20\\\">\\n\"\n                      \"          <text sourcepos=\\\"9:6-9:15\\\" xml:space=\\\"preserve\\\">Yes, okay.</text>\\n\"\n                      \"          <softbreak />\\n\"\n                      \"          <image sourcepos=\\\"10:6-10:20\\\" destination=\\\"hi\\\" title=\\\"yes\\\">\\n\"\n                      \"            <text sourcepos=\\\"10:8-10:9\\\" xml:space=\\\"preserve\\\">ok</text>\\n\"\n                      \"          </image>\\n\"\n                      \"        </paragraph>\\n\"\n                      \"      </item>\\n\"\n                      \"    </list>\\n\"\n                      \"  </block_quote>\\n\"\n                      \"</document>\\n\",\n         \"sourcepos are as expected\");\n  free(xml);\n  cmark_node_free(doc);\n}\n\nstatic void source_pos_inlines(test_batch_runner *runner) {\n  {\n    static const char markdown[] =\n      \"*first*\\n\"\n      \"second\\n\";\n\n    cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n    char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n    STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                        \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                        \"<document sourcepos=\\\"1:1-2:6\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                        \"  <paragraph sourcepos=\\\"1:1-2:6\\\">\\n\"\n                        \"    <emph sourcepos=\\\"1:1-1:7\\\">\\n\"\n                        \"      <text sourcepos=\\\"1:2-1:6\\\" xml:space=\\\"preserve\\\">first</text>\\n\"\n                        \"    </emph>\\n\"\n                        \"    <softbreak />\\n\"\n                        \"    <text sourcepos=\\\"2:1-2:6\\\" xml:space=\\\"preserve\\\">second</text>\\n\"\n                        \"  </paragraph>\\n\"\n                        \"</document>\\n\",\n                        \"sourcepos are as expected\");\n    free(xml);\n    cmark_node_free(doc);\n  }\n  {\n    static const char markdown[] =\n      \"*first\\n\"\n      \"second*\\n\";\n\n    cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n    char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n    STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                        \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                        \"<document sourcepos=\\\"1:1-2:7\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                        \"  <paragraph sourcepos=\\\"1:1-2:7\\\">\\n\"\n                        \"    <emph sourcepos=\\\"1:1-2:7\\\">\\n\"\n                        \"      <text sourcepos=\\\"1:2-1:6\\\" xml:space=\\\"preserve\\\">first</text>\\n\"\n                        \"      <softbreak />\\n\"\n                        \"      <text sourcepos=\\\"2:1-2:6\\\" xml:space=\\\"preserve\\\">second</text>\\n\"\n                        \"    </emph>\\n\"\n                        \"  </paragraph>\\n\"\n                        \"</document>\\n\",\n                        \"sourcepos are as expected\");\n    free(xml);\n    cmark_node_free(doc);\n  }\n}\n\nstatic void ref_source_pos(test_batch_runner *runner) {\n  static const char markdown[] =\n    \"Let's try [reference] links.\\n\"\n    \"\\n\"\n    \"[reference]: https://github.com (GitHub)\\n\";\n\n  cmark_node *doc = cmark_parse_document(markdown, sizeof(markdown) - 1, CMARK_OPT_DEFAULT);\n  char *xml = cmark_render_xml(doc, CMARK_OPT_DEFAULT | CMARK_OPT_SOURCEPOS);\n  STR_EQ(runner, xml, \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\"\n                      \"<!DOCTYPE document SYSTEM \\\"CommonMark.dtd\\\">\\n\"\n                      \"<document sourcepos=\\\"1:1-3:40\\\" xmlns=\\\"http://commonmark.org/xml/1.0\\\">\\n\"\n                      \"  <paragraph sourcepos=\\\"1:1-1:28\\\">\\n\"\n                      \"    <text sourcepos=\\\"1:1-1:10\\\" xml:space=\\\"preserve\\\">Let's try </text>\\n\"\n                      \"    <link sourcepos=\\\"1:11-1:21\\\" destination=\\\"https://github.com\\\" title=\\\"GitHub\\\">\\n\"\n                      \"      <text sourcepos=\\\"1:12-1:20\\\" xml:space=\\\"preserve\\\">reference</text>\\n\"\n                      \"    </link>\\n\"\n                      \"    <text sourcepos=\\\"1:22-1:28\\\" xml:space=\\\"preserve\\\"> links.</text>\\n\"\n                      \"  </paragraph>\\n\"\n                      \"</document>\\n\",\n         \"sourcepos are as expected\");\n  free(xml);\n  cmark_node_free(doc);\n}\n\nint main() {\n  int retval;\n  test_batch_runner *runner = test_batch_runner_new();\n\n  cmark_enable_safety_checks(true);\n  version(runner);\n  constructor(runner);\n  accessors(runner);\n  node_check(runner);\n  iterator(runner);\n  iterator_delete(runner);\n  create_tree(runner);\n  custom_nodes(runner);\n  hierarchy(runner);\n  parser(runner);\n  render_html(runner);\n  render_xml(runner);\n  render_man(runner);\n  render_latex(runner);\n  render_commonmark(runner);\n  render_plaintext(runner);\n  utf8(runner);\n  line_endings(runner);\n  numeric_entities(runner);\n  test_cplusplus(runner);\n  test_safe(runner);\n  test_feed_across_line_ending(runner);\n  test_pathological_regressions(runner);\n  source_pos(runner);\n  source_pos_inlines(runner);\n  ref_source_pos(runner);\n\n  test_print_summary(runner);\n  retval = test_ok(runner) ? 0 : 1;\n  free(runner);\n\n  return retval;\n}\n", "#include <cmark-gfm-extension_api.h>\n#include <html.h>\n#include <inlines.h>\n#include <parser.h>\n#include <references.h>\n#include <string.h>\n#include <render.h>\n\n#include \"ext_scanners.h\"\n#include \"strikethrough.h\"\n#include \"table.h\"\n#include \"cmark-gfm-core-extensions.h\"\n\n// Custom node flag, initialized in `create_table_extension`.\nstatic cmark_node_internal_flags CMARK_NODE__TABLE_VISITED;\n\ncmark_node_type CMARK_NODE_TABLE, CMARK_NODE_TABLE_ROW,\n    CMARK_NODE_TABLE_CELL;\n\ntypedef struct {\n  cmark_strbuf *buf;\n  int start_offset, end_offset, internal_offset;\n} node_cell;\n\ntypedef struct {\n  uint16_t n_columns;\n  int paragraph_offset;\n  node_cell *cells;\n} table_row;\n\ntypedef struct {\n  uint16_t n_columns;\n  uint8_t *alignments;\n} node_table;\n\ntypedef struct {\n  bool is_header;\n} node_table_row;\n\nstatic void free_table_cell(cmark_mem *mem, node_cell *cell) {\n  cmark_strbuf_free((cmark_strbuf *)cell->buf);\n  mem->free(cell->buf);\n}\n\nstatic void free_row_cells(cmark_mem *mem, table_row *row) {\n  while (row->n_columns > 0) {\n    free_table_cell(mem, &row->cells[--row->n_columns]);\n  }\n  mem->free(row->cells);\n  row->cells = NULL;\n}\n\nstatic void free_table_row(cmark_mem *mem, table_row *row) {\n  if (!row)\n    return;\n\n  free_row_cells(mem, row);\n  mem->free(row);\n}\n\nstatic void free_node_table(cmark_mem *mem, void *ptr) {\n  node_table *t = (node_table *)ptr;\n  mem->free(t->alignments);\n  mem->free(t);\n}\n\nstatic void free_node_table_row(cmark_mem *mem, void *ptr) {\n  mem->free(ptr);\n}\n\nstatic int get_n_table_columns(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return -1;\n\n  return (int)((node_table *)node->as.opaque)->n_columns;\n}\n\nstatic int set_n_table_columns(cmark_node *node, uint16_t n_columns) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->n_columns = n_columns;\n  return 1;\n}\n\nstatic uint8_t *get_table_alignments(cmark_node *node) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nstatic int set_table_alignments(cmark_node *node, uint8_t *alignments) {\n  if (!node || node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  ((node_table *)node->as.opaque)->alignments = alignments;\n  return 1;\n}\n\nstatic cmark_strbuf *unescape_pipes(cmark_mem *mem, unsigned char *string, bufsize_t len)\n{\n  cmark_strbuf *res = (cmark_strbuf *)mem->calloc(1, sizeof(cmark_strbuf));\n  bufsize_t r, w;\n\n  cmark_strbuf_init(mem, res, len + 1);\n  cmark_strbuf_put(res, string, len);\n  cmark_strbuf_putc(res, '\\0');\n\n  for (r = 0, w = 0; r < len; ++r) {\n    if (res->ptr[r] == '\\\\' && res->ptr[r + 1] == '|')\n      r++;\n\n    res->ptr[w++] = res->ptr[r];\n  }\n\n  cmark_strbuf_truncate(res, w);\n\n  return res;\n}\n\n// Adds a new cell to the end of the row. A pointer to the new cell is returned\n// for the caller to initialize.\nstatic node_cell* append_row_cell(cmark_mem *mem, table_row *row) {\n  const uint32_t n_columns = row->n_columns + 1;\n  // realloc when n_columns is a power of 2\n  if ((n_columns & (n_columns-1)) == 0) {\n    // make sure we never wrap row->n_columns\n    // offset will != len and our exit will clean up as intended\n    if (n_columns > UINT16_MAX) {\n      return NULL;\n    }\n    // Use realloc to double the size of the buffer.\n    row->cells = (node_cell *)mem->realloc(row->cells, (2 * n_columns - 1) * sizeof(node_cell));\n  }\n  row->n_columns = (uint16_t)n_columns;\n  return &row->cells[n_columns-1];\n}\n\nstatic table_row *row_from_string(cmark_syntax_extension *self,\n                                  cmark_parser *parser, unsigned char *string,\n                                  int len) {\n  // Parses a single table row. It has the following form:\n  // `delim? table_cell (delim table_cell)* delim? newline`\n  // Note that cells are allowed to be empty.\n  //\n  // From the GitHub-flavored Markdown specification:\n  //\n  // > Each row consists of cells containing arbitrary text, in which inlines\n  // > are parsed, separated by pipes (|). A leading and trailing pipe is also\n  // > recommended for clarity of reading, and if there\u2019s otherwise parsing\n  // > ambiguity.\n\n  table_row *row = NULL;\n  bufsize_t cell_matched = 1, pipe_matched = 1, offset;\n  int expect_more_cells = 1;\n  int row_end_offset = 0;\n  int int_overflow_abort = 0;\n\n  row = (table_row *)parser->mem->calloc(1, sizeof(table_row));\n  row->n_columns = 0;\n  row->cells = NULL;\n\n  // Scan past the (optional) leading pipe.\n  offset = scan_table_cell_end(string, len, 0);\n\n  // Parse the cells of the row. Stop if we reach the end of the input, or if we\n  // cannot detect any more cells.\n  while (offset < len && expect_more_cells) {\n    cell_matched = scan_table_cell(string, len, offset);\n    pipe_matched = scan_table_cell_end(string, len, offset + cell_matched);\n\n    if (cell_matched || pipe_matched) {\n      // We are guaranteed to have a cell, since (1) either we found some\n      // content and cell_matched, or (2) we found an empty cell followed by a\n      // pipe.\n      cmark_strbuf *cell_buf = unescape_pipes(parser->mem, string + offset,\n          cell_matched);\n      cmark_strbuf_trim(cell_buf);\n\n      node_cell *cell = append_row_cell(parser->mem, row);\n      if (!cell) {\n        int_overflow_abort = 1;\n        cmark_strbuf_free(cell_buf);\n        parser->mem->free(cell_buf);\n        break;\n      }\n      cell->buf = cell_buf;\n      cell->start_offset = offset;\n      cell->end_offset = offset + cell_matched - 1;\n      cell->internal_offset = 0;\n\n      while (cell->start_offset > row->paragraph_offset && string[cell->start_offset - 1] != '|') {\n        --cell->start_offset;\n        ++cell->internal_offset;\n      }\n    }\n\n    offset += cell_matched + pipe_matched;\n\n    if (pipe_matched) {\n      expect_more_cells = 1;\n    } else {\n      // We've scanned the last cell. Check if we have reached the end of the row\n      row_end_offset = scan_table_row_end(string, len, offset);\n      offset += row_end_offset;\n\n      // If the end of the row is not the end of the input,\n      // the row is not a real row but potentially part of the paragraph\n      // preceding the table.\n      if (row_end_offset && offset != len) {\n        row->paragraph_offset = offset;\n\n        free_row_cells(parser->mem, row);\n\n        // Scan past the (optional) leading pipe.\n        offset += scan_table_cell_end(string, len, offset);\n\n        expect_more_cells = 1;\n      } else {\n        expect_more_cells = 0;\n      }\n    }\n  }\n\n  if (offset != len || row->n_columns == 0 || int_overflow_abort) {\n    free_table_row(parser->mem, row);\n    row = NULL;\n  }\n\n  return row;\n}\n\nstatic void try_inserting_table_header_paragraph(cmark_parser *parser,\n                                                 cmark_node *parent_container,\n                                                 unsigned char *parent_string,\n                                                 int paragraph_offset) {\n  cmark_node *paragraph;\n  cmark_strbuf *paragraph_content;\n\n  paragraph = cmark_node_new_with_mem(CMARK_NODE_PARAGRAPH, parser->mem);\n\n  paragraph_content = unescape_pipes(parser->mem, parent_string, paragraph_offset);\n  cmark_strbuf_trim(paragraph_content);\n  cmark_node_set_string_content(paragraph, (char *) paragraph_content->ptr);\n  cmark_strbuf_free(paragraph_content);\n  parser->mem->free(paragraph_content);\n\n  if (!cmark_node_insert_before(parent_container, paragraph)) {\n    parser->mem->free(paragraph);\n  }\n}\n\nstatic cmark_node *try_opening_table_header(cmark_syntax_extension *self,\n                                            cmark_parser *parser,\n                                            cmark_node *parent_container,\n                                            unsigned char *input, int len) {\n  cmark_node *table_header;\n  table_row *header_row = NULL;\n  table_row *marker_row = NULL;\n  node_table_row *ntr;\n  const char *parent_string;\n  uint16_t i;\n\n  if (parent_container->flags & CMARK_NODE__TABLE_VISITED) {\n    return parent_container;\n  }\n\n  if (!scan_table_start(input, len, cmark_parser_get_first_nonspace(parser))) {\n    return parent_container;\n  }\n\n  // Since scan_table_start was successful, we must have a marker row.\n  marker_row = row_from_string(self, parser,\n                               input + cmark_parser_get_first_nonspace(parser),\n                               len - cmark_parser_get_first_nonspace(parser));\n  // assert may be optimized out, don't rely on it for security boundaries\n  if (!marker_row) {\n      return parent_container;\n  }\n  \n  assert(marker_row);\n\n  cmark_arena_push();\n\n  // Check for a matching header row. We call `row_from_string` with the entire\n  // (potentially long) parent container as input, but this should be safe since\n  // `row_from_string` bails out early if it does not find a row.\n  parent_string = cmark_node_get_string_content(parent_container);\n  header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                               (int)strlen(parent_string));\n  if (!header_row || header_row->n_columns != marker_row->n_columns) {\n    free_table_row(parser->mem, marker_row);\n    free_table_row(parser->mem, header_row);\n    cmark_arena_pop();\n    parent_container->flags |= CMARK_NODE__TABLE_VISITED;\n    return parent_container;\n  }\n\n  if (cmark_arena_pop()) {\n    marker_row = row_from_string(\n        self, parser, input + cmark_parser_get_first_nonspace(parser),\n        len - cmark_parser_get_first_nonspace(parser));\n    header_row = row_from_string(self, parser, (unsigned char *)parent_string,\n                                 (int)strlen(parent_string));\n    // row_from_string can return NULL, add additional check to ensure n_columns match\n    if (!marker_row || !header_row || header_row->n_columns != marker_row->n_columns) {\n        free_table_row(parser->mem, marker_row);\n        free_table_row(parser->mem, header_row);\n        return parent_container;\n    }\n  }\n\n  assert(cmark_node_get_type(parent_container) == CMARK_NODE_PARAGRAPH);\n  if (!cmark_node_set_type(parent_container, CMARK_NODE_TABLE)) {\n    free_table_row(parser->mem, header_row);\n    free_table_row(parser->mem, marker_row);\n    return parent_container;\n  }\n\n  // Update the node counts after parent_container changed type.\n  assert(parent_container->next == NULL);\n  decr_open_block_count(parser, CMARK_NODE_PARAGRAPH);\n  incr_open_block_count(parser, CMARK_NODE_TABLE);\n\n  if (header_row->paragraph_offset) {\n    try_inserting_table_header_paragraph(parser, parent_container, (unsigned char *)parent_string,\n                                         header_row->paragraph_offset);\n  }\n\n  cmark_node_set_syntax_extension(parent_container, self);\n  parent_container->as.opaque = parser->mem->calloc(1, sizeof(node_table));\n  set_n_table_columns(parent_container, header_row->n_columns);\n\n  // allocate alignments based on marker_row->n_columns\n  // since we populate the alignments array based on marker_row->cells\n  uint8_t *alignments =\n      (uint8_t *)parser->mem->calloc(marker_row->n_columns, sizeof(uint8_t));\n  for (i = 0; i < marker_row->n_columns; ++i) {\n    node_cell *node = &marker_row->cells[i];\n    bool left = node->buf->ptr[0] == ':', right = node->buf->ptr[node->buf->size - 1] == ':';\n\n    if (left && right)\n      alignments[i] = 'c';\n    else if (left)\n      alignments[i] = 'l';\n    else if (right)\n      alignments[i] = 'r';\n  }\n  set_table_alignments(parent_container, alignments);\n\n  table_header =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_header, self);\n  table_header->end_column = parent_container->start_column + (int)strlen(parent_string) - 2;\n  table_header->start_line = table_header->end_line = parent_container->start_line;\n\n  table_header->as.opaque = ntr = (node_table_row *)parser->mem->calloc(1, sizeof(node_table_row));\n  ntr->is_header = true;\n\n  {\n    for (i = 0; i < header_row->n_columns; ++i) {\n      node_cell *cell = &header_row->cells[i];\n      cmark_node *header_cell = cmark_parser_add_child(parser, table_header,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      header_cell->start_line = header_cell->end_line = parent_container->start_line;\n      header_cell->internal_offset = cell->internal_offset;\n      header_cell->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(header_cell, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(header_cell, self);\n    }\n  }\n\n  cmark_parser_advance_offset(\n      parser, (char *)input,\n      (int)strlen((char *)input) - 1 - cmark_parser_get_offset(parser), false);\n\n  free_table_row(parser->mem, header_row);\n  free_table_row(parser->mem, marker_row);\n  return parent_container;\n}\n\nstatic cmark_node *try_opening_table_row(cmark_syntax_extension *self,\n                                         cmark_parser *parser,\n                                         cmark_node *parent_container,\n                                         unsigned char *input, int len) {\n  cmark_node *table_row_block;\n  table_row *row;\n\n  if (cmark_parser_is_blank(parser))\n    return NULL;\n\n  table_row_block =\n      cmark_parser_add_child(parser, parent_container, CMARK_NODE_TABLE_ROW,\n                             parent_container->start_column);\n  cmark_node_set_syntax_extension(table_row_block, self);\n  table_row_block->end_column = parent_container->end_column;\n  table_row_block->as.opaque = parser->mem->calloc(1, sizeof(node_table_row));\n\n  row = row_from_string(self, parser, input + cmark_parser_get_first_nonspace(parser),\n      len - cmark_parser_get_first_nonspace(parser));\n\n  if (!row) {\n      // clean up the dangling node\n      cmark_node_free(table_row_block);\n      return NULL;\n  }\n\n  {\n    int i, table_columns = get_n_table_columns(parent_container);\n\n    for (i = 0; i < row->n_columns && i < table_columns; ++i) {\n      node_cell *cell = &row->cells[i];\n      cmark_node *node = cmark_parser_add_child(parser, table_row_block,\n          CMARK_NODE_TABLE_CELL, parent_container->start_column + cell->start_offset);\n      node->internal_offset = cell->internal_offset;\n      node->end_column = parent_container->start_column + cell->end_offset;\n      cmark_node_set_string_content(node, (char *) cell->buf->ptr);\n      cmark_node_set_syntax_extension(node, self);\n    }\n\n    for (; i < table_columns; ++i) {\n      cmark_node *node = cmark_parser_add_child(\n          parser, table_row_block, CMARK_NODE_TABLE_CELL, 0);\n      cmark_node_set_syntax_extension(node, self);\n    }\n  }\n\n  free_table_row(parser->mem, row);\n\n  cmark_parser_advance_offset(parser, (char *)input,\n                              len - 1 - cmark_parser_get_offset(parser), false);\n\n  return table_row_block;\n}\n\nstatic cmark_node *try_opening_table_block(cmark_syntax_extension *self,\n                                           int indented, cmark_parser *parser,\n                                           cmark_node *parent_container,\n                                           unsigned char *input, int len) {\n  cmark_node_type parent_type = cmark_node_get_type(parent_container);\n\n  if (!indented && parent_type == CMARK_NODE_PARAGRAPH) {\n    return try_opening_table_header(self, parser, parent_container, input, len);\n  } else if (!indented && parent_type == CMARK_NODE_TABLE) {\n    return try_opening_table_row(self, parser, parent_container, input, len);\n  }\n\n  return NULL;\n}\n\nstatic int matches(cmark_syntax_extension *self, cmark_parser *parser,\n                   unsigned char *input, int len,\n                   cmark_node *parent_container) {\n  int res = 0;\n\n  if (cmark_node_get_type(parent_container) == CMARK_NODE_TABLE) {\n    cmark_arena_push();\n    table_row *new_row = row_from_string(\n        self, parser, input + cmark_parser_get_first_nonspace(parser),\n        len - cmark_parser_get_first_nonspace(parser));\n    if (new_row && new_row->n_columns)\n      res = 1;\n    free_table_row(parser->mem, new_row);\n    cmark_arena_pop();\n  }\n\n  return res;\n}\n\nstatic const char *get_type_string(cmark_syntax_extension *self,\n                                   cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return \"table\";\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (((node_table_row *)node->as.opaque)->is_header)\n      return \"table_header\";\n    else\n      return \"table_row\";\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return \"table_cell\";\n  }\n\n  return \"<unknown>\";\n}\n\nstatic int can_contain(cmark_syntax_extension *extension, cmark_node *node,\n                       cmark_node_type child_type) {\n  if (node->type == CMARK_NODE_TABLE) {\n    return child_type == CMARK_NODE_TABLE_ROW;\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    return child_type == CMARK_NODE_TABLE_CELL;\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    return child_type == CMARK_NODE_TEXT || child_type == CMARK_NODE_CODE ||\n           child_type == CMARK_NODE_EMPH || child_type == CMARK_NODE_STRONG ||\n           child_type == CMARK_NODE_LINK || child_type == CMARK_NODE_IMAGE ||\n           child_type == CMARK_NODE_STRIKETHROUGH ||\n           child_type == CMARK_NODE_HTML_INLINE ||\n           child_type == CMARK_NODE_FOOTNOTE_REFERENCE;\n  }\n  return false;\n}\n\nstatic int contains_inlines(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  return node->type == CMARK_NODE_TABLE_CELL;\n}\n\nstatic void commonmark_render(cmark_syntax_extension *extension,\n                              cmark_renderer *renderer, cmark_node *node,\n                              cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    renderer->blankline(renderer);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"|\", false, LITERAL);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (entering) {\n      renderer->out(renderer, node, \" \", false, LITERAL);\n    } else {\n      renderer->out(renderer, node, \" |\", false, LITERAL);\n      if (((node_table_row *)node->parent->as.opaque)->is_header &&\n          !node->next) {\n        int i;\n        uint8_t *alignments = get_table_alignments(node->parent->parent);\n        uint16_t n_cols =\n            ((node_table *)node->parent->parent->as.opaque)->n_columns;\n        renderer->cr(renderer);\n        renderer->out(renderer, node, \"|\", false, LITERAL);\n        for (i = 0; i < n_cols; i++) {\n          switch (alignments[i]) {\n          case 0:   renderer->out(renderer, node, \" --- |\", false, LITERAL); break;\n          case 'l': renderer->out(renderer, node, \" :-- |\", false, LITERAL); break;\n          case 'c': renderer->out(renderer, node, \" :-: |\", false, LITERAL); break;\n          case 'r': renderer->out(renderer, node, \" --: |\", false, LITERAL); break;\n          }\n        }\n        renderer->cr(renderer);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void latex_render(cmark_syntax_extension *extension,\n                         cmark_renderer *renderer, cmark_node *node,\n                         cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{table}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\begin{tabular}{\", false, LITERAL);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n      for (i = 0; i < n_cols; i++) {\n        switch(alignments[i]) {\n        case 0:\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n      renderer->out(renderer, node, \"}\", false, LITERAL);\n      renderer->cr(renderer);\n    } else {\n      renderer->out(renderer, node, \"\\\\end{tabular}\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"\\\\end{table}\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering) {\n      if (node->next) {\n        renderer->out(renderer, node, \" & \", false, LITERAL);\n      } else {\n        renderer->out(renderer, node, \" \\\\\\\\\", false, LITERAL);\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic const char *xml_attr(cmark_syntax_extension *extension,\n                            cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (cmark_gfm_extensions_get_table_row_is_header(node->parent)) {\n      uint8_t *alignments = get_table_alignments(node->parent->parent);\n      int i = 0;\n      cmark_node *n;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n      switch (alignments[i]) {\n      case 'l': return \" align=\\\"left\\\"\";\n      case 'c': return \" align=\\\"center\\\"\";\n      case 'r': return \" align=\\\"right\\\"\";\n      }\n    }\n  }\n\n  return NULL;\n}\n\nstatic void man_render(cmark_syntax_extension *extension,\n                       cmark_renderer *renderer, cmark_node *node,\n                       cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      int i;\n      uint16_t n_cols;\n      uint8_t *alignments = get_table_alignments(node);\n\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \".TS\", false, LITERAL);\n      renderer->cr(renderer);\n      renderer->out(renderer, node, \"tab(@);\", false, LITERAL);\n      renderer->cr(renderer);\n\n      n_cols = ((node_table *)node->as.opaque)->n_columns;\n\n      for (i = 0; i < n_cols; i++) {\n        switch (alignments[i]) {\n        case 'l':\n          renderer->out(renderer, node, \"l\", false, LITERAL);\n          break;\n        case 0:\n        case 'c':\n          renderer->out(renderer, node, \"c\", false, LITERAL);\n          break;\n        case 'r':\n          renderer->out(renderer, node, \"r\", false, LITERAL);\n          break;\n        }\n      }\n\n      if (n_cols) {\n        renderer->out(renderer, node, \".\", false, LITERAL);\n        renderer->cr(renderer);\n      }\n    } else {\n      renderer->out(renderer, node, \".TE\", false, LITERAL);\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (!entering) {\n      renderer->cr(renderer);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    if (!entering && node->next) {\n      renderer->out(renderer, node, \"@\", false, LITERAL);\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void html_table_add_align(cmark_strbuf* html, const char* align, int options) {\n  if (options & CMARK_OPT_TABLE_PREFER_STYLE_ATTRIBUTES) {\n    cmark_strbuf_puts(html, \" style=\\\"text-align: \");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  } else {\n    cmark_strbuf_puts(html, \" align=\\\"\");\n    cmark_strbuf_puts(html, align);\n    cmark_strbuf_puts(html, \"\\\"\");\n  }\n}\n\nstruct html_table_state {\n  unsigned need_closing_table_body : 1;\n  unsigned in_table_header : 1;\n};\n\nstatic void html_render(cmark_syntax_extension *extension,\n                        cmark_html_renderer *renderer, cmark_node *node,\n                        cmark_event_type ev_type, int options) {\n  bool entering = (ev_type == CMARK_EVENT_ENTER);\n  cmark_strbuf *html = renderer->html;\n  cmark_node *n;\n\n  // XXX: we just monopolise renderer->opaque.\n  struct html_table_state *table_state =\n      (struct html_table_state *)&renderer->opaque;\n\n  if (node->type == CMARK_NODE_TABLE) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"<table\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n      table_state->need_closing_table_body = false;\n    } else {\n      if (table_state->need_closing_table_body) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</tbody>\");\n        cmark_html_render_cr(html);\n      }\n      table_state->need_closing_table_body = false;\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</table>\");\n      cmark_html_render_cr(html);\n    }\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        table_state->in_table_header = 1;\n        cmark_strbuf_puts(html, \"<thead>\");\n        cmark_html_render_cr(html);\n      } else if (!table_state->need_closing_table_body) {\n        cmark_strbuf_puts(html, \"<tbody>\");\n        cmark_html_render_cr(html);\n        table_state->need_closing_table_body = 1;\n      }\n      cmark_strbuf_puts(html, \"<tr\");\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      cmark_html_render_cr(html);\n      cmark_strbuf_puts(html, \"</tr>\");\n      if (((node_table_row *)node->as.opaque)->is_header) {\n        cmark_html_render_cr(html);\n        cmark_strbuf_puts(html, \"</thead>\");\n        table_state->in_table_header = false;\n      }\n    }\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    uint8_t *alignments = get_table_alignments(node->parent->parent);\n    if (entering) {\n      cmark_html_render_cr(html);\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"<th\");\n      } else {\n        cmark_strbuf_puts(html, \"<td\");\n      }\n\n      int i = 0;\n      for (n = node->parent->first_child; n; n = n->next, ++i)\n        if (n == node)\n          break;\n\n      switch (alignments[i]) {\n      case 'l': html_table_add_align(html, \"left\", options); break;\n      case 'c': html_table_add_align(html, \"center\", options); break;\n      case 'r': html_table_add_align(html, \"right\", options); break;\n      }\n\n      cmark_html_render_sourcepos(node, html, options);\n      cmark_strbuf_putc(html, '>');\n    } else {\n      if (table_state->in_table_header) {\n        cmark_strbuf_puts(html, \"</th>\");\n      } else {\n        cmark_strbuf_puts(html, \"</td>\");\n      }\n    }\n  } else {\n    assert(false);\n  }\n}\n\nstatic void opaque_alloc(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table));\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    node->as.opaque = mem->calloc(1, sizeof(node_table_row));\n  } else if (node->type == CMARK_NODE_TABLE_CELL) {\n    node->as.opaque = mem->calloc(1, sizeof(node_cell));\n  }\n}\n\nstatic void opaque_free(cmark_syntax_extension *self, cmark_mem *mem, cmark_node *node) {\n  if (node->type == CMARK_NODE_TABLE) {\n    free_node_table(mem, node->as.opaque);\n  } else if (node->type == CMARK_NODE_TABLE_ROW) {\n    free_node_table_row(mem, node->as.opaque);\n  }\n}\n\nstatic int escape(cmark_syntax_extension *self, cmark_node *node, int c) {\n  return\n    node->type != CMARK_NODE_TABLE &&\n    node->type != CMARK_NODE_TABLE_ROW &&\n    node->type != CMARK_NODE_TABLE_CELL &&\n    c == '|';\n}\n\ncmark_syntax_extension *create_table_extension(void) {\n  cmark_syntax_extension *self = cmark_syntax_extension_new(\"table\");\n\n  cmark_register_node_flag(&CMARK_NODE__TABLE_VISITED);\n  cmark_syntax_extension_set_match_block_func(self, matches);\n  cmark_syntax_extension_set_open_block_func(self, try_opening_table_block);\n  cmark_syntax_extension_set_get_type_string_func(self, get_type_string);\n  cmark_syntax_extension_set_can_contain_func(self, can_contain);\n  cmark_syntax_extension_set_contains_inlines_func(self, contains_inlines);\n  cmark_syntax_extension_set_commonmark_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_plaintext_render_func(self, commonmark_render);\n  cmark_syntax_extension_set_latex_render_func(self, latex_render);\n  cmark_syntax_extension_set_xml_attr_func(self, xml_attr);\n  cmark_syntax_extension_set_man_render_func(self, man_render);\n  cmark_syntax_extension_set_html_render_func(self, html_render);\n  cmark_syntax_extension_set_opaque_alloc_func(self, opaque_alloc);\n  cmark_syntax_extension_set_opaque_free_func(self, opaque_free);\n  cmark_syntax_extension_set_commonmark_escape_func(self, escape);\n  CMARK_NODE_TABLE = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_ROW = cmark_syntax_extension_add_node(0);\n  CMARK_NODE_TABLE_CELL = cmark_syntax_extension_add_node(0);\n\n  return self;\n}\n\nuint16_t cmark_gfm_extensions_get_table_columns(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->n_columns;\n}\n\nuint8_t *cmark_gfm_extensions_get_table_alignments(cmark_node *node) {\n  if (node->type != CMARK_NODE_TABLE)\n    return 0;\n\n  return ((node_table *)node->as.opaque)->alignments;\n}\n\nint cmark_gfm_extensions_set_table_columns(cmark_node *node, uint16_t n_columns) {\n  return set_n_table_columns(node, n_columns);\n}\n\nint cmark_gfm_extensions_set_table_alignments(cmark_node *node, uint16_t ncols, uint8_t *alignments) {\n  uint8_t *a = (uint8_t *)cmark_node_mem(node)->calloc(1, ncols);\n  memcpy(a, alignments, ncols);\n  return set_table_alignments(node, a);\n}\n\nint cmark_gfm_extensions_get_table_row_is_header(cmark_node *node)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  return ((node_table_row *)node->as.opaque)->is_header;\n}\n\nint cmark_gfm_extensions_set_table_row_is_header(cmark_node *node, int is_header)\n{\n  if (!node || node->type != CMARK_NODE_TABLE_ROW)\n    return 0;\n\n  ((node_table_row *)node->as.opaque)->is_header = (is_header != 0);\n  return 1;\n}\n", "/**\n * Block parsing implementation.\n *\n * For a high-level overview of the block parsing process,\n * see http://spec.commonmark.org/0.24/#phase-1-block-structure\n */\n\n#include <stdlib.h>\n#include <assert.h>\n#include <stdio.h>\n#include <limits.h>\n\n#include \"cmark_ctype.h\"\n#include \"syntax_extension.h\"\n#include \"config.h\"\n#include \"parser.h\"\n#include \"cmark-gfm.h\"\n#include \"node.h\"\n#include \"references.h\"\n#include \"utf8.h\"\n#include \"scanners.h\"\n#include \"inlines.h\"\n#include \"houdini.h\"\n#include \"buffer.h\"\n#include \"footnotes.h\"\n\n#define CODE_INDENT 4\n#define TAB_STOP 4\n\n#ifndef MIN\n#define MIN(x, y) ((x < y) ? x : y)\n#endif\n\n#define peek_at(i, n) (i)->data[n]\n\nstatic bool S_last_line_blank(const cmark_node *node) {\n  return (node->flags & CMARK_NODE__LAST_LINE_BLANK) != 0;\n}\n\nstatic bool S_last_line_checked(const cmark_node *node) {\n  return (node->flags & CMARK_NODE__LAST_LINE_CHECKED) != 0;\n}\n\nstatic CMARK_INLINE cmark_node_type S_type(const cmark_node *node) {\n  return (cmark_node_type)node->type;\n}\n\nstatic void S_set_last_line_blank(cmark_node *node, bool is_blank) {\n  if (is_blank)\n    node->flags |= CMARK_NODE__LAST_LINE_BLANK;\n  else\n    node->flags &= ~CMARK_NODE__LAST_LINE_BLANK;\n}\n\nstatic void S_set_last_line_checked(cmark_node *node) {\n  node->flags |= CMARK_NODE__LAST_LINE_CHECKED;\n}\n\nstatic CMARK_INLINE bool S_is_line_end_char(char c) {\n  return (c == '\\n' || c == '\\r');\n}\n\nstatic CMARK_INLINE bool S_is_space_or_tab(char c) {\n  return (c == ' ' || c == '\\t');\n}\n\nstatic void S_parser_feed(cmark_parser *parser, const unsigned char *buffer,\n                          size_t len, bool eof);\n\nstatic void S_process_line(cmark_parser *parser, const unsigned char *buffer,\n                           bufsize_t bytes);\n\nstatic void subtract_open_block_counts(cmark_parser *parser, cmark_node *node) {\n  do {\n    decr_open_block_count(parser, S_type(node));\n    node->flags &= ~CMARK_NODE__OPEN_BLOCK;\n    node = node->last_child;\n  } while (node);\n}\n\nstatic void add_open_block_counts(cmark_parser *parser, cmark_node *node) {\n  do {\n    incr_open_block_count(parser, S_type(node));\n    node->flags |= CMARK_NODE__OPEN_BLOCK;\n    node = node->last_child;\n  } while (node);\n}\n\nstatic cmark_node *make_block(cmark_mem *mem, cmark_node_type tag,\n                              int start_line, int start_column) {\n  cmark_node *e;\n\n  e = (cmark_node *)mem->calloc(1, sizeof(*e));\n  cmark_strbuf_init(mem, &e->content, 32);\n  e->type = (uint16_t)tag;\n  e->flags = CMARK_NODE__OPEN;\n  e->start_line = start_line;\n  e->start_column = start_column;\n  e->end_line = start_line;\n\n  return e;\n}\n\n// Create a root document node.\nstatic cmark_node *make_document(cmark_mem *mem) {\n  cmark_node *e = make_block(mem, CMARK_NODE_DOCUMENT, 1, 1);\n  return e;\n}\n\nint cmark_parser_attach_syntax_extension(cmark_parser *parser,\n                                         cmark_syntax_extension *extension) {\n  parser->syntax_extensions = cmark_llist_append(parser->mem, parser->syntax_extensions, extension);\n  if (extension->match_inline || extension->insert_inline_from_delim) {\n    parser->inline_syntax_extensions = cmark_llist_append(\n      parser->mem, parser->inline_syntax_extensions, extension);\n  }\n\n  return 1;\n}\n\nstatic void cmark_parser_dispose(cmark_parser *parser) {\n  if (parser->root)\n    cmark_node_free(parser->root);\n\n  if (parser->refmap)\n    cmark_map_free(parser->refmap);\n}\n\nstatic void cmark_parser_reset(cmark_parser *parser) {\n  cmark_llist *saved_exts = parser->syntax_extensions;\n  cmark_llist *saved_inline_exts = parser->inline_syntax_extensions;\n  int saved_options = parser->options;\n  cmark_mem *saved_mem = parser->mem;\n\n  cmark_parser_dispose(parser);\n\n  memset(parser, 0, sizeof(cmark_parser));\n  parser->mem = saved_mem;\n\n  cmark_strbuf_init(parser->mem, &parser->curline, 256);\n  cmark_strbuf_init(parser->mem, &parser->linebuf, 0);\n\n  cmark_node *document = make_document(parser->mem);\n\n  parser->refmap = cmark_reference_map_new(parser->mem);\n  parser->root = document;\n  parser->current = document;\n  add_open_block_counts(parser, document);\n\n  parser->syntax_extensions = saved_exts;\n  parser->inline_syntax_extensions = saved_inline_exts;\n  parser->options = saved_options;\n}\n\ncmark_parser *cmark_parser_new_with_mem(int options, cmark_mem *mem) {\n  cmark_parser *parser = (cmark_parser *)mem->calloc(1, sizeof(cmark_parser));\n  parser->mem = mem;\n  parser->options = options;\n  cmark_parser_reset(parser);\n  return parser;\n}\n\ncmark_parser *cmark_parser_new(int options) {\n  extern cmark_mem CMARK_DEFAULT_MEM_ALLOCATOR;\n  return cmark_parser_new_with_mem(options, &CMARK_DEFAULT_MEM_ALLOCATOR);\n}\n\nvoid cmark_parser_free(cmark_parser *parser) {\n  cmark_mem *mem = parser->mem;\n  cmark_parser_dispose(parser);\n  cmark_strbuf_free(&parser->curline);\n  cmark_strbuf_free(&parser->linebuf);\n  cmark_llist_free(parser->mem, parser->syntax_extensions);\n  cmark_llist_free(parser->mem, parser->inline_syntax_extensions);\n  mem->free(parser);\n}\n\nstatic cmark_node *finalize(cmark_parser *parser, cmark_node *b);\n\n// Returns true if line has only space characters, else false.\nstatic bool is_blank(cmark_strbuf *s, bufsize_t offset) {\n  while (offset < s->size) {\n    switch (s->ptr[offset]) {\n    case '\\r':\n    case '\\n':\n      return true;\n    case ' ':\n      offset++;\n      break;\n    case '\\t':\n      offset++;\n      break;\n    default:\n      return false;\n    }\n  }\n\n  return true;\n}\n\nstatic CMARK_INLINE bool accepts_lines(cmark_node_type block_type) {\n  return (block_type == CMARK_NODE_PARAGRAPH ||\n          block_type == CMARK_NODE_HEADING ||\n          block_type == CMARK_NODE_CODE_BLOCK);\n}\n\nstatic CMARK_INLINE bool contains_inlines(cmark_node *node) {\n  if (node->extension && node->extension->contains_inlines_func) {\n    return node->extension->contains_inlines_func(node->extension, node) != 0;\n  }\n\n  return (node->type == CMARK_NODE_PARAGRAPH ||\n          node->type == CMARK_NODE_HEADING);\n}\n\nstatic void add_line(cmark_node *node, cmark_chunk *ch, cmark_parser *parser) {\n  int chars_to_tab;\n  int i;\n  assert(node->flags & CMARK_NODE__OPEN);\n  if (parser->partially_consumed_tab) {\n    parser->offset += 1; // skip over tab\n    // add space characters:\n    chars_to_tab = TAB_STOP - (parser->column % TAB_STOP);\n    for (i = 0; i < chars_to_tab; i++) {\n      cmark_strbuf_putc(&node->content, ' ');\n    }\n  }\n  cmark_strbuf_put(&node->content, ch->data + parser->offset,\n                   ch->len - parser->offset);\n}\n\nstatic void remove_trailing_blank_lines(cmark_strbuf *ln) {\n  bufsize_t i;\n  unsigned char c;\n\n  for (i = ln->size - 1; i >= 0; --i) {\n    c = ln->ptr[i];\n\n    if (c != ' ' && c != '\\t' && !S_is_line_end_char(c))\n      break;\n  }\n\n  if (i < 0) {\n    cmark_strbuf_clear(ln);\n    return;\n  }\n\n  for (; i < ln->size; ++i) {\n    c = ln->ptr[i];\n\n    if (!S_is_line_end_char(c))\n      continue;\n\n    cmark_strbuf_truncate(ln, i);\n    break;\n  }\n}\n\n// Check to see if a node ends with a blank line, descending\n// if needed into lists and sublists.\nstatic bool S_ends_with_blank_line(cmark_node *node) {\n  while (true) {\n    if (S_last_line_checked(node)) {\n      return(S_last_line_blank(node));\n    } else if ((S_type(node) == CMARK_NODE_LIST ||\n                S_type(node) == CMARK_NODE_ITEM) && node->last_child) {\n      S_set_last_line_checked(node);\n      node = node->last_child;\n      continue;\n    } else {\n      S_set_last_line_checked(node);\n      return (S_last_line_blank(node));\n    }\n  }\n}\n\n// returns true if content remains after link defs are resolved.\nstatic bool resolve_reference_link_definitions(\n\t\tcmark_parser *parser,\n                cmark_node *b) {\n  bufsize_t pos;\n  cmark_strbuf *node_content = &b->content;\n  cmark_chunk chunk = {node_content->ptr, node_content->size, 0};\n  while (chunk.len && chunk.data[0] == '[' &&\n         (pos = cmark_parse_reference_inline(parser->mem, &chunk,\n\t\t\t\t\t     parser->refmap))) {\n\n    chunk.data += pos;\n    chunk.len -= pos;\n  }\n  cmark_strbuf_drop(node_content, (node_content->size - chunk.len));\n  return !is_blank(&b->content, 0);\n}\n\nstatic cmark_node *finalize(cmark_parser *parser, cmark_node *b) {\n  bufsize_t pos;\n  cmark_node *item;\n  cmark_node *subitem;\n  cmark_node *parent;\n  bool has_content;\n\n  parent = b->parent;\n  assert(b->flags &\n         CMARK_NODE__OPEN); // shouldn't call finalize on closed blocks\n  b->flags &= ~CMARK_NODE__OPEN;\n\n  if (parser->curline.size == 0) {\n    // end of input - line number has not been incremented\n    b->end_line = parser->line_number;\n    b->end_column = parser->last_line_length;\n  } else if (S_type(b) == CMARK_NODE_DOCUMENT ||\n             (S_type(b) == CMARK_NODE_CODE_BLOCK && b->as.code.fenced) ||\n             (S_type(b) == CMARK_NODE_HEADING && b->as.heading.setext)) {\n    b->end_line = parser->line_number;\n    b->end_column = parser->curline.size;\n    if (b->end_column && parser->curline.ptr[b->end_column - 1] == '\\n')\n      b->end_column -= 1;\n    if (b->end_column && parser->curline.ptr[b->end_column - 1] == '\\r')\n      b->end_column -= 1;\n  } else {\n    b->end_line = parser->line_number - 1;\n    b->end_column = parser->last_line_length;\n  }\n\n  cmark_strbuf *node_content = &b->content;\n\n  switch (S_type(b)) {\n  case CMARK_NODE_PARAGRAPH:\n  {\n    has_content = resolve_reference_link_definitions(parser, b);\n    if (!has_content) {\n      // remove blank node (former reference def)\n      if (b->flags & CMARK_NODE__OPEN_BLOCK) {\n        decr_open_block_count(parser, S_type(b));\n        if (b->prev) {\n          add_open_block_counts(parser, b->prev);\n        }\n      }\n      cmark_node_free(b);\n    }\n    break;\n  }\n\n  case CMARK_NODE_CODE_BLOCK:\n    if (!b->as.code.fenced) { // indented code\n      remove_trailing_blank_lines(node_content);\n      cmark_strbuf_putc(node_content, '\\n');\n    } else {\n      // first line of contents becomes info\n      for (pos = 0; pos < node_content->size; ++pos) {\n        if (S_is_line_end_char(node_content->ptr[pos]))\n          break;\n      }\n      assert(pos < node_content->size);\n\n      cmark_strbuf tmp = CMARK_BUF_INIT(parser->mem);\n      houdini_unescape_html_f(&tmp, node_content->ptr, pos);\n      cmark_strbuf_trim(&tmp);\n      cmark_strbuf_unescape(&tmp);\n      b->as.code.info = cmark_chunk_buf_detach(&tmp);\n\n      if (node_content->ptr[pos] == '\\r')\n        pos += 1;\n      if (node_content->ptr[pos] == '\\n')\n        pos += 1;\n      cmark_strbuf_drop(node_content, pos);\n    }\n    b->as.code.literal = cmark_chunk_buf_detach(node_content);\n    break;\n\n  case CMARK_NODE_HTML_BLOCK:\n    b->as.literal = cmark_chunk_buf_detach(node_content);\n    break;\n\n  case CMARK_NODE_LIST:      // determine tight/loose status\n    b->as.list.tight = true; // tight by default\n    item = b->first_child;\n\n    while (item) {\n      // check for non-final non-empty list item ending with blank line:\n      if (S_last_line_blank(item) && item->next) {\n        b->as.list.tight = false;\n        break;\n      }\n      // recurse into children of list item, to see if there are\n      // spaces between them:\n      subitem = item->first_child;\n      while (subitem) {\n        if ((item->next || subitem->next) &&\n            S_ends_with_blank_line(subitem)) {\n          b->as.list.tight = false;\n          break;\n        }\n        subitem = subitem->next;\n      }\n      if (!(b->as.list.tight)) {\n        break;\n      }\n      item = item->next;\n    }\n\n    break;\n\n  default:\n    break;\n  }\n\n  return parent;\n}\n\n// Recalculates the number of open blocks. Returns true if it matches what's currently stored\n// in parser. (Used to check that the counts in parser, which are updated incrementally, are\n// correct.)\nbool check_open_block_counts(cmark_parser *parser) {\n  cmark_parser tmp_parser = {0}; // Only used for its open_block_counts and total_open_blocks fields.\n  add_open_block_counts(&tmp_parser, parser->root);\n  return\n    tmp_parser.total_open_blocks == parser->total_open_blocks &&\n    memcmp(tmp_parser.open_block_counts, parser->open_block_counts, sizeof(parser->open_block_counts)) == 0;\n}\n\n// Add a node as child of another.  Return pointer to child.\nstatic cmark_node *add_child(cmark_parser *parser, cmark_node *parent,\n                             cmark_node_type block_type, int start_column) {\n  assert(parent);\n\n  // if 'parent' isn't the kind of node that can accept this child,\n  // then back up til we hit a node that can.\n  while (!cmark_node_can_contain_type(parent, block_type)) {\n    parent = finalize(parser, parent);\n  }\n\n  cmark_node *child =\n      make_block(parser->mem, block_type, parser->line_number, start_column);\n  child->parent = parent;\n\n  if (parent->last_child) {\n    parent->last_child->next = child;\n    child->prev = parent->last_child;\n    subtract_open_block_counts(parser, parent->last_child);\n  } else {\n    parent->first_child = child;\n    child->prev = NULL;\n  }\n  parent->last_child = child;\n  add_open_block_counts(parser, child);\n\n  return child;\n}\n\nvoid cmark_manage_extensions_special_characters(cmark_parser *parser, int add) {\n  cmark_llist *tmp_ext;\n\n  for (tmp_ext = parser->inline_syntax_extensions; tmp_ext; tmp_ext=tmp_ext->next) {\n    cmark_syntax_extension *ext = (cmark_syntax_extension *) tmp_ext->data;\n    cmark_llist *tmp_char;\n    for (tmp_char = ext->special_inline_chars; tmp_char; tmp_char=tmp_char->next) {\n      unsigned char c = (unsigned char)(size_t)tmp_char->data;\n      if (add)\n        cmark_inlines_add_special_character(c, ext->emphasis);\n      else\n        cmark_inlines_remove_special_character(c, ext->emphasis);\n    }\n  }\n}\n\n// Walk through node and all children, recursively, parsing\n// string content into inline content where appropriate.\nstatic void process_inlines(cmark_parser *parser,\n                            cmark_map *refmap, int options) {\n  cmark_iter *iter = cmark_iter_new(parser->root);\n  cmark_node *cur;\n  cmark_event_type ev_type;\n\n  cmark_manage_extensions_special_characters(parser, true);\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (ev_type == CMARK_EVENT_ENTER) {\n      if (contains_inlines(cur)) {\n        cmark_parse_inlines(parser, cur, refmap, options);\n      }\n    }\n  }\n\n  cmark_manage_extensions_special_characters(parser, false);\n\n  cmark_iter_free(iter);\n}\n\nstatic int sort_footnote_by_ix(const void *_a, const void *_b) {\n  cmark_footnote *a = *(cmark_footnote **)_a;\n  cmark_footnote *b = *(cmark_footnote **)_b;\n  return (int)a->ix - (int)b->ix;\n}\n\nstatic void process_footnotes(cmark_parser *parser) {\n  // * Collect definitions in a map.\n  // * Iterate the references in the document in order, assigning indices to\n  //   definitions in the order they're seen.\n  // * Write out the footnotes at the bottom of the document in index order.\n\n  cmark_map *map = cmark_footnote_map_new(parser->mem);\n\n  cmark_iter *iter = cmark_iter_new(parser->root);\n  cmark_node *cur;\n  cmark_event_type ev_type;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (ev_type == CMARK_EVENT_EXIT && cur->type == CMARK_NODE_FOOTNOTE_DEFINITION) {\n      cmark_footnote_create(map, cur);\n    }\n  }\n\n  cmark_iter_free(iter);\n  iter = cmark_iter_new(parser->root);\n  unsigned int ix = 0;\n\n  while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n    cur = cmark_iter_get_node(iter);\n    if (ev_type == CMARK_EVENT_EXIT && cur->type == CMARK_NODE_FOOTNOTE_REFERENCE) {\n      cmark_footnote *footnote = (cmark_footnote *)cmark_map_lookup(map, &cur->as.literal);\n      if (footnote) {\n        if (!footnote->ix)\n          footnote->ix = ++ix;\n\n        // store a reference to this footnote reference's footnote definition\n        // this is used by renderers when generating label ids\n        cur->parent_footnote_def = footnote->node;\n\n        // keep track of a) count of how many times this footnote def has been\n        // referenced, and b) which reference index this footnote ref is at.\n        // this is used by renderers when generating links and backreferences.\n        cur->footnote.ref_ix = ++footnote->node->footnote.def_count;\n\n        char n[32];\n        snprintf(n, sizeof(n), \"%d\", footnote->ix);\n        cmark_chunk_free(parser->mem, &cur->as.literal);\n        cmark_strbuf buf = CMARK_BUF_INIT(parser->mem);\n        cmark_strbuf_puts(&buf, n);\n\n        cur->as.literal = cmark_chunk_buf_detach(&buf);\n      } else {\n        cmark_node *text = (cmark_node *)parser->mem->calloc(1, sizeof(*text));\n        cmark_strbuf_init(parser->mem, &text->content, 0);\n        text->type = (uint16_t) CMARK_NODE_TEXT;\n\n        cmark_strbuf buf = CMARK_BUF_INIT(parser->mem);\n        cmark_strbuf_puts(&buf, \"[^\");\n        cmark_strbuf_put(&buf, cur->as.literal.data, cur->as.literal.len);\n        cmark_strbuf_putc(&buf, ']');\n\n        text->as.literal = cmark_chunk_buf_detach(&buf);\n        cmark_node_insert_after(cur, text);\n        cmark_node_free(cur);\n      }\n    }\n  }\n\n  cmark_iter_free(iter);\n\n  if (map->sorted) {\n    qsort(map->sorted, map->size, sizeof(cmark_map_entry *), sort_footnote_by_ix);\n    for (unsigned int i = 0; i < map->size; ++i) {\n      cmark_footnote *footnote = (cmark_footnote *)map->sorted[i];\n      if (!footnote->ix) {\n        cmark_node_unlink(footnote->node);\n        continue;\n      }\n      cmark_node_append_child(parser->root, footnote->node);\n      footnote->node = NULL;\n    }\n  }\n\n  cmark_unlink_footnotes_map(map);\n  cmark_map_free(map);\n}\n\n// Attempts to parse a list item marker (bullet or enumerated).\n// On success, returns length of the marker, and populates\n// data with the details.  On failure, returns 0.\nstatic bufsize_t parse_list_marker(cmark_mem *mem, cmark_chunk *input,\n                                   bufsize_t pos, bool interrupts_paragraph,\n                                   cmark_list **dataptr) {\n  unsigned char c;\n  bufsize_t startpos;\n  cmark_list *data;\n  bufsize_t i;\n\n  startpos = pos;\n  c = peek_at(input, pos);\n\n  if (c == '*' || c == '-' || c == '+') {\n    pos++;\n    if (!cmark_isspace(peek_at(input, pos))) {\n      return 0;\n    }\n\n    if (interrupts_paragraph) {\n      i = pos;\n      // require non-blank content after list marker:\n      while (S_is_space_or_tab(peek_at(input, i))) {\n        i++;\n      }\n      if (peek_at(input, i) == '\\n') {\n        return 0;\n      }\n    }\n\n    data = (cmark_list *)mem->calloc(1, sizeof(*data));\n    data->marker_offset = 0; // will be adjusted later\n    data->list_type = CMARK_BULLET_LIST;\n    data->bullet_char = c;\n    data->start = 0;\n    data->delimiter = CMARK_NO_DELIM;\n    data->tight = false;\n  } else if (cmark_isdigit(c)) {\n    int start = 0;\n    int digits = 0;\n\n    do {\n      start = (10 * start) + (peek_at(input, pos) - '0');\n      pos++;\n      digits++;\n      // We limit to 9 digits to avoid overflow,\n      // assuming max int is 2^31 - 1\n      // This also seems to be the limit for 'start' in some browsers.\n    } while (digits < 9 && cmark_isdigit(peek_at(input, pos)));\n\n    if (interrupts_paragraph && start != 1) {\n      return 0;\n    }\n    c = peek_at(input, pos);\n    if (c == '.' || c == ')') {\n      pos++;\n      if (!cmark_isspace(peek_at(input, pos))) {\n        return 0;\n      }\n      if (interrupts_paragraph) {\n        // require non-blank content after list marker:\n        i = pos;\n        while (S_is_space_or_tab(peek_at(input, i))) {\n          i++;\n        }\n        if (S_is_line_end_char(peek_at(input, i))) {\n          return 0;\n        }\n      }\n\n      data = (cmark_list *)mem->calloc(1, sizeof(*data));\n      data->marker_offset = 0; // will be adjusted later\n      data->list_type = CMARK_ORDERED_LIST;\n      data->bullet_char = 0;\n      data->start = start;\n      data->delimiter = (c == '.' ? CMARK_PERIOD_DELIM : CMARK_PAREN_DELIM);\n      data->tight = false;\n    } else {\n      return 0;\n    }\n  } else {\n    return 0;\n  }\n\n  *dataptr = data;\n  return (pos - startpos);\n}\n\n// Return 1 if list item belongs in list, else 0.\nstatic int lists_match(cmark_list *list_data, cmark_list *item_data) {\n  return (list_data->list_type == item_data->list_type &&\n          list_data->delimiter == item_data->delimiter &&\n          // list_data->marker_offset == item_data.marker_offset &&\n          list_data->bullet_char == item_data->bullet_char);\n}\n\nstatic cmark_node *finalize_document(cmark_parser *parser) {\n  while (parser->current != parser->root) {\n    parser->current = finalize(parser, parser->current);\n  }\n\n  finalize(parser, parser->root);\n\n  // Limit total size of extra content created from reference links to\n  // document size to avoid superlinear growth. Always allow 100KB.\n  if (parser->total_size > 100000)\n    parser->refmap->max_ref_size = parser->total_size;\n  else\n    parser->refmap->max_ref_size = 100000;\n\n  process_inlines(parser, parser->refmap, parser->options);\n  if (parser->options & CMARK_OPT_FOOTNOTES)\n    process_footnotes(parser);\n\n  return parser->root;\n}\n\ncmark_node *cmark_parse_file(FILE *f, int options) {\n  unsigned char buffer[4096];\n  cmark_parser *parser = cmark_parser_new(options);\n  size_t bytes;\n  cmark_node *document;\n\n  while ((bytes = fread(buffer, 1, sizeof(buffer), f)) > 0) {\n    bool eof = bytes < sizeof(buffer);\n    S_parser_feed(parser, buffer, bytes, eof);\n    if (eof) {\n      break;\n    }\n  }\n\n  document = cmark_parser_finish(parser);\n  cmark_parser_free(parser);\n  return document;\n}\n\ncmark_node *cmark_parse_document(const char *buffer, size_t len, int options) {\n  cmark_parser *parser = cmark_parser_new(options);\n  cmark_node *document;\n\n  S_parser_feed(parser, (const unsigned char *)buffer, len, true);\n\n  document = cmark_parser_finish(parser);\n  cmark_parser_free(parser);\n  return document;\n}\n\nvoid cmark_parser_feed(cmark_parser *parser, const char *buffer, size_t len) {\n  S_parser_feed(parser, (const unsigned char *)buffer, len, false);\n}\n\nvoid cmark_parser_feed_reentrant(cmark_parser *parser, const char *buffer, size_t len) {\n  cmark_strbuf saved_linebuf;\n\n  cmark_strbuf_init(parser->mem, &saved_linebuf, 0);\n  cmark_strbuf_puts(&saved_linebuf, cmark_strbuf_cstr(&parser->linebuf));\n  cmark_strbuf_clear(&parser->linebuf);\n\n  S_parser_feed(parser, (const unsigned char *)buffer, len, true);\n\n  cmark_strbuf_sets(&parser->linebuf, cmark_strbuf_cstr(&saved_linebuf));\n  cmark_strbuf_free(&saved_linebuf);\n}\n\nstatic void S_parser_feed(cmark_parser *parser, const unsigned char *buffer,\n                          size_t len, bool eof) {\n  const unsigned char *end = buffer + len;\n  static const uint8_t repl[] = {239, 191, 189};\n\n  if (len > UINT_MAX - parser->total_size)\n    parser->total_size = UINT_MAX;\n  else\n    parser->total_size += len;\n\n  if (parser->last_buffer_ended_with_cr && *buffer == '\\n') {\n    // skip NL if last buffer ended with CR ; see #117\n    buffer++;\n  }\n  parser->last_buffer_ended_with_cr = false;\n  while (buffer < end) {\n    const unsigned char *eol;\n    bufsize_t chunk_len;\n    bool process = false;\n    for (eol = buffer; eol < end; ++eol) {\n      if (S_is_line_end_char(*eol)) {\n        process = true;\n        break;\n      }\n      if (*eol == '\\0' && eol < end) {\n        break;\n      }\n    }\n    if (eol >= end && eof) {\n      process = true;\n    }\n\n    chunk_len = (bufsize_t)(eol - buffer);\n    if (process) {\n      if (parser->linebuf.size > 0) {\n        cmark_strbuf_put(&parser->linebuf, buffer, chunk_len);\n        S_process_line(parser, parser->linebuf.ptr, parser->linebuf.size);\n        cmark_strbuf_clear(&parser->linebuf);\n      } else {\n        S_process_line(parser, buffer, chunk_len);\n      }\n    } else {\n      if (eol < end && *eol == '\\0') {\n        // omit NULL byte\n        cmark_strbuf_put(&parser->linebuf, buffer, chunk_len);\n        // add replacement character\n        cmark_strbuf_put(&parser->linebuf, repl, 3);\n      } else {\n        cmark_strbuf_put(&parser->linebuf, buffer, chunk_len);\n      }\n    }\n\n    buffer += chunk_len;\n    if (buffer < end) {\n      if (*buffer == '\\0') {\n        // skip over NULL\n        buffer++;\n      } else {\n        // skip over line ending characters\n        if (*buffer == '\\r') {\n          buffer++;\n          if (buffer == end)\n            parser->last_buffer_ended_with_cr = true;\n        }\n        if (buffer < end && *buffer == '\\n')\n          buffer++;\n      }\n    }\n  }\n}\n\nstatic void chop_trailing_hashtags(cmark_chunk *ch) {\n  bufsize_t n, orig_n;\n\n  cmark_chunk_rtrim(ch);\n  orig_n = n = ch->len - 1;\n\n  // if string ends in space followed by #s, remove these:\n  while (n >= 0 && peek_at(ch, n) == '#')\n    n--;\n\n  // Check for a space before the final #s:\n  if (n != orig_n && n >= 0 && S_is_space_or_tab(peek_at(ch, n))) {\n    ch->len = n;\n    cmark_chunk_rtrim(ch);\n  }\n}\n\n// Check for thematic break.  On failure, return 0 and update\n// thematic_break_kill_pos with the index at which the\n// parse fails.  On success, return length of match.\n// \"...three or more hyphens, asterisks,\n// or underscores on a line by themselves. If you wish, you may use\n// spaces between the hyphens or asterisks.\"\nstatic int S_scan_thematic_break(cmark_parser *parser, cmark_chunk *input,\n                                 bufsize_t offset) {\n  bufsize_t i;\n  char c;\n  char nextc = '\\0';\n  int count;\n  i = offset;\n  c = peek_at(input, i);\n  if (!(c == '*' || c == '_' || c == '-')) {\n    parser->thematic_break_kill_pos = i;\n    return 0;\n  }\n  count = 1;\n  while ((nextc = peek_at(input, ++i))) {\n    if (nextc == c) {\n      count++;\n    } else if (nextc != ' ' && nextc != '\\t') {\n      break;\n    }\n  }\n  if (count >= 3 && (nextc == '\\r' || nextc == '\\n')) {\n    return (i - offset) + 1;\n  } else {\n    parser->thematic_break_kill_pos = i;\n    return 0;\n  }\n}\n\n// Find first nonspace character from current offset, setting\n// parser->first_nonspace, parser->first_nonspace_column,\n// parser->indent, and parser->blank. Does not advance parser->offset.\nstatic void S_find_first_nonspace(cmark_parser *parser, cmark_chunk *input) {\n  char c;\n  int chars_to_tab = TAB_STOP - (parser->column % TAB_STOP);\n\n  if (parser->first_nonspace <= parser->offset) {\n    parser->first_nonspace = parser->offset;\n    parser->first_nonspace_column = parser->column;\n    while ((c = peek_at(input, parser->first_nonspace))) {\n      if (c == ' ') {\n        parser->first_nonspace += 1;\n        parser->first_nonspace_column += 1;\n        chars_to_tab = chars_to_tab - 1;\n        if (chars_to_tab == 0) {\n          chars_to_tab = TAB_STOP;\n        }\n      } else if (c == '\\t') {\n        parser->first_nonspace += 1;\n        parser->first_nonspace_column += chars_to_tab;\n        chars_to_tab = TAB_STOP;\n      } else {\n        break;\n      }\n    }\n  }\n\n  parser->indent = parser->first_nonspace_column - parser->column;\n  parser->blank = S_is_line_end_char(peek_at(input, parser->first_nonspace));\n}\n\n// Advance parser->offset and parser->column.  parser->offset is the\n// byte position in input; parser->column is a virtual column number\n// that takes into account tabs. (Multibyte characters are not taken\n// into account, because the Markdown line prefixes we are interested in\n// analyzing are entirely ASCII.)  The count parameter indicates\n// how far to advance the offset.  If columns is true, then count\n// indicates a number of columns; otherwise, a number of bytes.\n// If advancing a certain number of columns partially consumes\n// a tab character, parser->partially_consumed_tab is set to true.\nstatic void S_advance_offset(cmark_parser *parser, cmark_chunk *input,\n                             bufsize_t count, bool columns) {\n  char c;\n  int chars_to_tab;\n  int chars_to_advance;\n  while (count > 0 && (c = peek_at(input, parser->offset))) {\n    if (c == '\\t') {\n      chars_to_tab = TAB_STOP - (parser->column % TAB_STOP);\n      if (columns) {\n        parser->partially_consumed_tab = chars_to_tab > count;\n        chars_to_advance = MIN(count, chars_to_tab);\n        parser->column += chars_to_advance;\n        parser->offset += (parser->partially_consumed_tab ? 0 : 1);\n        count -= chars_to_advance;\n      } else {\n        parser->partially_consumed_tab = false;\n        parser->column += chars_to_tab;\n        parser->offset += 1;\n        count -= 1;\n      }\n    } else {\n      parser->partially_consumed_tab = false;\n      parser->offset += 1;\n      parser->column += 1; // assume ascii; block starts are ascii\n      count -= 1;\n    }\n  }\n}\n\nstatic bool S_last_child_is_open(cmark_node *container) {\n  return container->last_child &&\n         (container->last_child->flags & CMARK_NODE__OPEN);\n}\n\nstatic bool parse_block_quote_prefix(cmark_parser *parser, cmark_chunk *input) {\n  bool res = false;\n  bufsize_t matched = 0;\n\n  matched =\n      parser->indent <= 3 && peek_at(input, parser->first_nonspace) == '>';\n  if (matched) {\n\n    S_advance_offset(parser, input, parser->indent + 1, true);\n\n    if (S_is_space_or_tab(peek_at(input, parser->offset))) {\n      S_advance_offset(parser, input, 1, true);\n    }\n\n    res = true;\n  }\n  return res;\n}\n\nstatic bool parse_footnote_definition_block_prefix(cmark_parser *parser, cmark_chunk *input,\n                                                   cmark_node *container) {\n  if (parser->indent >= 4) {\n    S_advance_offset(parser, input, 4, true);\n    return true;\n  } else if (input->len > 0 && (input->data[0] == '\\n' || (input->data[0] == '\\r' && input->data[1] == '\\n'))) {\n    return true;\n  }\n\n  return false;\n}\n\nstatic bool parse_node_item_prefix(cmark_parser *parser, cmark_chunk *input,\n                                   cmark_node *container) {\n  bool res = false;\n\n  if (parser->indent >=\n      container->as.list.marker_offset + container->as.list.padding) {\n    S_advance_offset(parser, input, container->as.list.marker_offset +\n                                        container->as.list.padding,\n                     true);\n    res = true;\n  } else if (parser->blank && container->first_child != NULL) {\n    // if container->first_child is NULL, then the opening line\n    // of the list item was blank after the list marker; in this\n    // case, we are done with the list item.\n    S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                     false);\n    res = true;\n  }\n  return res;\n}\n\nstatic bool parse_code_block_prefix(cmark_parser *parser, cmark_chunk *input,\n                                    cmark_node *container,\n                                    bool *should_continue) {\n  bool res = false;\n\n  if (!container->as.code.fenced) { // indented\n    if (parser->indent >= CODE_INDENT) {\n      S_advance_offset(parser, input, CODE_INDENT, true);\n      res = true;\n    } else if (parser->blank) {\n      S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                       false);\n      res = true;\n    }\n  } else { // fenced\n    bufsize_t matched = 0;\n\n    if (parser->indent <= 3 && (peek_at(input, parser->first_nonspace) ==\n                                container->as.code.fence_char)) {\n      matched = scan_close_code_fence(input, parser->first_nonspace);\n    }\n\n    if (matched >= container->as.code.fence_length) {\n      // closing fence - and since we're at\n      // the end of a line, we can stop processing it:\n      *should_continue = false;\n      S_advance_offset(parser, input, matched, false);\n      parser->current = finalize(parser, container);\n    } else {\n      // skip opt. spaces of fence parser->offset\n      int i = container->as.code.fence_offset;\n\n      while (i > 0 && S_is_space_or_tab(peek_at(input, parser->offset))) {\n        S_advance_offset(parser, input, 1, true);\n        i--;\n      }\n      res = true;\n    }\n  }\n\n  return res;\n}\n\nstatic bool parse_html_block_prefix(cmark_parser *parser,\n                                    cmark_node *container) {\n  bool res = false;\n  int html_block_type = container->as.html_block_type;\n\n  assert(html_block_type >= 1 && html_block_type <= 7);\n  switch (html_block_type) {\n  case 1:\n  case 2:\n  case 3:\n  case 4:\n  case 5:\n    // these types of blocks can accept blanks\n    res = true;\n    break;\n  case 6:\n  case 7:\n    res = !parser->blank;\n    break;\n  }\n\n  return res;\n}\n\nstatic bool parse_extension_block(cmark_parser *parser,\n                                  cmark_node *container,\n                                  cmark_chunk *input)\n{\n  bool res = false;\n\n  if (container->extension->last_block_matches) {\n    if (container->extension->last_block_matches(\n        container->extension, parser, input->data, input->len, container))\n      res = true;\n  }\n\n  return res;\n}\n\n/**\n * For each containing node, try to parse the associated line start.\n *\n * Will not close unmatched blocks, as we may have a lazy continuation\n * line -> http://spec.commonmark.org/0.24/#lazy-continuation-line\n *\n * Returns: The last matching node, or NULL\n */\nstatic cmark_node *check_open_blocks(cmark_parser *parser, cmark_chunk *input,\n                                     bool *all_matched) {\n  bool should_continue = true;\n  *all_matched = false;\n  cmark_node *container = parser->root;\n  cmark_node_type cont_type;\n  cmark_parser tmp_parser; // Only used for its open_block_counts and total_open_blocks fields.\n  memcpy(tmp_parser.open_block_counts, parser->open_block_counts, sizeof(parser->open_block_counts));\n  tmp_parser.total_open_blocks = parser->total_open_blocks;\n\n  assert(check_open_block_counts(parser));\n\n  while (S_last_child_is_open(container)) {\n    decr_open_block_count(&tmp_parser, S_type(container));\n    container = container->last_child;\n    cont_type = S_type(container);\n\n    S_find_first_nonspace(parser, input);\n\n    if (container->extension) {\n      if (!parse_extension_block(parser, container, input))\n        goto done;\n      continue;\n    }\n\n    // This block of code is a workaround for the quadratic performance\n    // issue described here (issue 2):\n    //\n    // https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh\n    //\n    // If the current line is empty then we might be able to skip directly\n    // to the end of the list of open blocks. To determine whether this is\n    // possible, we have been maintaining a count of the number of\n    // different types of open blocks. The main criterium is that every\n    // remaining block, except the last element of the list, is a LIST or\n    // ITEM. The code below checks the conditions, and if they're ok, skips\n    // forward to parser->current.\n    if (parser->blank && parser->indent == 0) {  // Current line is empty\n      // Make sure that parser->current doesn't point to a closed block.\n      if (parser->current->flags & CMARK_NODE__OPEN_BLOCK) {\n        if (parser->current->flags & CMARK_NODE__OPEN) {\n          const size_t n_list = read_open_block_count(&tmp_parser, CMARK_NODE_LIST);\n          const size_t n_item = read_open_block_count(&tmp_parser, CMARK_NODE_ITEM);\n          // At most one block can be something other than a LIST or ITEM.\n          if (n_list + n_item + 1 >= tmp_parser.total_open_blocks) {\n            // Check that parser->current is suitable for jumping to.\n            switch (S_type(parser->current)) {\n            case CMARK_NODE_LIST:\n            case CMARK_NODE_ITEM:\n              if (n_list + n_item != tmp_parser.total_open_blocks) {\n                if (parser->current->last_child == NULL) {\n                  // There's another node type somewhere in the middle of\n                  // the list, so don't attempt the optimization.\n                  break;\n                }\n              }\n              // fall through\n            case CMARK_NODE_CODE_BLOCK:\n            case CMARK_NODE_PARAGRAPH:\n            case CMARK_NODE_HTML_BLOCK:\n              // Jump to parser->current\n              container = parser->current;\n              cont_type = S_type(container);\n              break;\n            default:\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    switch (cont_type) {\n    case CMARK_NODE_BLOCK_QUOTE:\n      if (!parse_block_quote_prefix(parser, input))\n        goto done;\n      break;\n    case CMARK_NODE_ITEM:\n      if (!parse_node_item_prefix(parser, input, container))\n        goto done;\n      break;\n    case CMARK_NODE_CODE_BLOCK:\n      if (!parse_code_block_prefix(parser, input, container, &should_continue))\n        goto done;\n      break;\n    case CMARK_NODE_HEADING:\n      // a heading can never contain more than one line\n      goto done;\n    case CMARK_NODE_HTML_BLOCK:\n      if (!parse_html_block_prefix(parser, container))\n        goto done;\n      break;\n    case CMARK_NODE_PARAGRAPH:\n      if (parser->blank)\n        goto done;\n      break;\n\t\tcase CMARK_NODE_FOOTNOTE_DEFINITION:\n\t\t\tif (!parse_footnote_definition_block_prefix(parser, input, container))\n\t\t\t\tgoto done;\n\t\t\tbreak;\n    default:\n      break;\n    }\n  }\n\n  *all_matched = true;\n\ndone:\n  if (!*all_matched) {\n    container = container->parent; // back up to last matching node\n  }\n\n  if (!should_continue) {\n    container = NULL;\n  }\n\n  return container;\n}\n\nstatic void open_new_blocks(cmark_parser *parser, cmark_node **container,\n                            cmark_chunk *input, bool all_matched) {\n  bool indented;\n  cmark_list *data = NULL;\n  bool maybe_lazy = S_type(parser->current) == CMARK_NODE_PARAGRAPH;\n  cmark_node_type cont_type = S_type(*container);\n  bufsize_t matched = 0;\n  int lev = 0;\n  bool save_partially_consumed_tab;\n  bool has_content;\n  int save_offset;\n  int save_column;\n\n  while (cont_type != CMARK_NODE_CODE_BLOCK &&\n         cont_type != CMARK_NODE_HTML_BLOCK) {\n\n    S_find_first_nonspace(parser, input);\n    indented = parser->indent >= CODE_INDENT;\n\n    if (!indented && peek_at(input, parser->first_nonspace) == '>') {\n\n      bufsize_t blockquote_startpos = parser->first_nonspace;\n\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + 1 - parser->offset, false);\n      // optional following character\n      if (S_is_space_or_tab(peek_at(input, parser->offset))) {\n        S_advance_offset(parser, input, 1, true);\n      }\n      *container = add_child(parser, *container, CMARK_NODE_BLOCK_QUOTE,\n                             blockquote_startpos + 1);\n\n    } else if (!indented && (matched = scan_atx_heading_start(\n                                 input, parser->first_nonspace))) {\n      bufsize_t hashpos;\n      int level = 0;\n      bufsize_t heading_startpos = parser->first_nonspace;\n\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + matched - parser->offset,\n                       false);\n      *container = add_child(parser, *container, CMARK_NODE_HEADING,\n                             heading_startpos + 1);\n\n      hashpos = cmark_chunk_strchr(input, '#', parser->first_nonspace);\n\n      while (peek_at(input, hashpos) == '#') {\n        level++;\n        hashpos++;\n      }\n\n      (*container)->as.heading.level = level;\n      (*container)->as.heading.setext = false;\n      (*container)->internal_offset = matched;\n\n    } else if (!indented && (matched = scan_open_code_fence(\n                                 input, parser->first_nonspace))) {\n      *container = add_child(parser, *container, CMARK_NODE_CODE_BLOCK,\n                             parser->first_nonspace + 1);\n      (*container)->as.code.fenced = true;\n      (*container)->as.code.fence_char = peek_at(input, parser->first_nonspace);\n      (*container)->as.code.fence_length = (matched > 255) ? 255 : (uint8_t)matched;\n      (*container)->as.code.fence_offset =\n          (int8_t)(parser->first_nonspace - parser->offset);\n      (*container)->as.code.info = cmark_chunk_literal(\"\");\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + matched - parser->offset,\n                       false);\n\n    } else if (!indented && ((matched = scan_html_block_start(\n                                  input, parser->first_nonspace)) ||\n                             (cont_type != CMARK_NODE_PARAGRAPH &&\n                              (matched = scan_html_block_start_7(\n                                   input, parser->first_nonspace))))) {\n      *container = add_child(parser, *container, CMARK_NODE_HTML_BLOCK,\n                             parser->first_nonspace + 1);\n      (*container)->as.html_block_type = matched;\n      // note, we don't adjust parser->offset because the tag is part of the\n      // text\n    } else if (!indented && cont_type == CMARK_NODE_PARAGRAPH &&\n               (lev =\n                    scan_setext_heading_line(input, parser->first_nonspace))) {\n      // finalize paragraph, resolving reference links\n      has_content = resolve_reference_link_definitions(parser, *container);\n\n      if (has_content) {\n        cmark_node_set_type(*container, CMARK_NODE_HEADING);\n        decr_open_block_count(parser, CMARK_NODE_PARAGRAPH);\n        incr_open_block_count(parser, CMARK_NODE_HEADING);\n        (*container)->as.heading.level = lev;\n        (*container)->as.heading.setext = true;\n        S_advance_offset(parser, input, input->len - 1 - parser->offset, false);\n      }\n    } else if (!indented &&\n               !(cont_type == CMARK_NODE_PARAGRAPH && !all_matched) &&\n\t       (parser->thematic_break_kill_pos <= parser->first_nonspace) &&\n               (matched = S_scan_thematic_break(parser, input, parser->first_nonspace))) {\n      // it's only now that we know the line is not part of a setext heading:\n      *container = add_child(parser, *container, CMARK_NODE_THEMATIC_BREAK,\n                             parser->first_nonspace + 1);\n      S_advance_offset(parser, input, input->len - 1 - parser->offset, false);\n    } else if (!indented &&\n               parser->options & CMARK_OPT_FOOTNOTES &&\n               (matched = scan_footnote_definition(input, parser->first_nonspace))) {\n      cmark_chunk c = cmark_chunk_dup(input, parser->first_nonspace + 2, matched - 2);\n      cmark_chunk_to_cstr(parser->mem, &c);\n\n      while (c.data[c.len - 1] != ']')\n        --c.len;\n      --c.len;\n\n      S_advance_offset(parser, input, parser->first_nonspace + matched - parser->offset, false);\n      *container = add_child(parser, *container, CMARK_NODE_FOOTNOTE_DEFINITION, parser->first_nonspace + matched + 1);\n      (*container)->as.literal = c;\n\n      (*container)->internal_offset = matched;\n    } else if ((!indented || cont_type == CMARK_NODE_LIST) &&\n\t       parser->indent < 4 &&\n               (matched = parse_list_marker(\n                    parser->mem, input, parser->first_nonspace,\n                    (*container)->type == CMARK_NODE_PARAGRAPH, &data))) {\n\n      // Note that we can have new list items starting with >= 4\n      // spaces indent, as long as the list container is still open.\n      int i = 0;\n\n      // compute padding:\n      S_advance_offset(parser, input,\n                       parser->first_nonspace + matched - parser->offset,\n                       false);\n\n      save_partially_consumed_tab = parser->partially_consumed_tab;\n      save_offset = parser->offset;\n      save_column = parser->column;\n\n      while (parser->column - save_column <= 5 &&\n             S_is_space_or_tab(peek_at(input, parser->offset))) {\n        S_advance_offset(parser, input, 1, true);\n      }\n\n      i = parser->column - save_column;\n      if (i >= 5 || i < 1 ||\n          // only spaces after list marker:\n          S_is_line_end_char(peek_at(input, parser->offset))) {\n        data->padding = matched + 1;\n        parser->offset = save_offset;\n        parser->column = save_column;\n        parser->partially_consumed_tab = save_partially_consumed_tab;\n        if (i > 0) {\n          S_advance_offset(parser, input, 1, true);\n        }\n      } else {\n        data->padding = matched + i;\n      }\n\n      // check container; if it's a list, see if this list item\n      // can continue the list; otherwise, create a list container.\n\n      data->marker_offset = parser->indent;\n\n      if (cont_type != CMARK_NODE_LIST ||\n          !lists_match(&((*container)->as.list), data)) {\n        *container = add_child(parser, *container, CMARK_NODE_LIST,\n                               parser->first_nonspace + 1);\n\n        memcpy(&((*container)->as.list), data, sizeof(*data));\n      }\n\n      // add the list item\n      *container = add_child(parser, *container, CMARK_NODE_ITEM,\n                             parser->first_nonspace + 1);\n      /* TODO: static */\n      memcpy(&((*container)->as.list), data, sizeof(*data));\n      parser->mem->free(data);\n    } else if (indented && !maybe_lazy && !parser->blank) {\n      S_advance_offset(parser, input, CODE_INDENT, true);\n      *container = add_child(parser, *container, CMARK_NODE_CODE_BLOCK,\n                             parser->offset + 1);\n      (*container)->as.code.fenced = false;\n      (*container)->as.code.fence_char = 0;\n      (*container)->as.code.fence_length = 0;\n      (*container)->as.code.fence_offset = 0;\n      (*container)->as.code.info = cmark_chunk_literal(\"\");\n    } else {\n      cmark_llist *tmp;\n      cmark_node *new_container = NULL;\n\n      for (tmp = parser->syntax_extensions; tmp; tmp=tmp->next) {\n        cmark_syntax_extension *ext = (cmark_syntax_extension *) tmp->data;\n\n        if (ext->try_opening_block) {\n          new_container = ext->try_opening_block(\n              ext, indented, parser, *container, input->data, input->len);\n\n          if (new_container) {\n            *container = new_container;\n            break;\n          }\n        }\n      }\n\n      if (!new_container) {\n        break;\n      }\n    }\n\n    if (accepts_lines(S_type(*container))) {\n      // if it's a line container, it can't contain other containers\n      break;\n    }\n\n    cont_type = S_type(*container);\n    maybe_lazy = false;\n  }\n}\n\nstatic void add_text_to_container(cmark_parser *parser, cmark_node *container,\n                                  cmark_node *last_matched_container,\n                                  cmark_chunk *input) {\n  cmark_node *tmp;\n  // what remains at parser->offset is a text line.  add the text to the\n  // appropriate container.\n\n  S_find_first_nonspace(parser, input);\n\n  if (parser->blank && container->last_child)\n    S_set_last_line_blank(container->last_child, true);\n\n  // block quote lines are never blank as they start with >\n  // and we don't count blanks in fenced code for purposes of tight/loose\n  // lists or breaking out of lists.  we also don't set last_line_blank\n  // on an empty list item.\n  const cmark_node_type ctype = S_type(container);\n  const bool last_line_blank =\n      (parser->blank && ctype != CMARK_NODE_BLOCK_QUOTE &&\n       ctype != CMARK_NODE_HEADING && ctype != CMARK_NODE_THEMATIC_BREAK &&\n       !(ctype == CMARK_NODE_CODE_BLOCK && container->as.code.fenced) &&\n       !(ctype == CMARK_NODE_ITEM && container->first_child == NULL &&\n         container->start_line == parser->line_number));\n\n  S_set_last_line_blank(container, last_line_blank);\n\n  tmp = container;\n  while (tmp->parent && S_last_line_blank(tmp->parent)) {\n    S_set_last_line_blank(tmp->parent, false);\n    tmp = tmp->parent;\n  }\n\n  // If the last line processed belonged to a paragraph node,\n  // and we didn't match all of the line prefixes for the open containers,\n  // and we didn't start any new containers,\n  // and the line isn't blank,\n  // then treat this as a \"lazy continuation line\" and add it to\n  // the open paragraph.\n  if (parser->current != last_matched_container &&\n      container == last_matched_container && !parser->blank &&\n      S_type(parser->current) == CMARK_NODE_PARAGRAPH) {\n    add_line(parser->current, input, parser);\n  } else { // not a lazy continuation\n    // Finalize any blocks that were not matched and set cur to container:\n    while (parser->current != last_matched_container) {\n      parser->current = finalize(parser, parser->current);\n      assert(parser->current != NULL);\n    }\n\n    if (S_type(container) == CMARK_NODE_CODE_BLOCK) {\n      add_line(container, input, parser);\n    } else if (S_type(container) == CMARK_NODE_HTML_BLOCK) {\n      add_line(container, input, parser);\n\n      int matches_end_condition;\n      switch (container->as.html_block_type) {\n      case 1:\n        // </script>, </style>, </pre>\n        matches_end_condition =\n            scan_html_block_end_1(input, parser->first_nonspace);\n        break;\n      case 2:\n        // -->\n        matches_end_condition =\n            scan_html_block_end_2(input, parser->first_nonspace);\n        break;\n      case 3:\n        // ?>\n        matches_end_condition =\n            scan_html_block_end_3(input, parser->first_nonspace);\n        break;\n      case 4:\n        // >\n        matches_end_condition =\n            scan_html_block_end_4(input, parser->first_nonspace);\n        break;\n      case 5:\n        // ]]>\n        matches_end_condition =\n            scan_html_block_end_5(input, parser->first_nonspace);\n        break;\n      default:\n        matches_end_condition = 0;\n        break;\n      }\n\n      if (matches_end_condition) {\n        container = finalize(parser, container);\n        assert(parser->current != NULL);\n      }\n    } else if (parser->blank) {\n      // ??? do nothing\n    } else if (accepts_lines(S_type(container))) {\n      if (S_type(container) == CMARK_NODE_HEADING &&\n          container->as.heading.setext == false) {\n        chop_trailing_hashtags(input);\n      }\n      S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                       false);\n      add_line(container, input, parser);\n    } else {\n      // create paragraph container for line\n      container = add_child(parser, container, CMARK_NODE_PARAGRAPH,\n                            parser->first_nonspace + 1);\n      S_advance_offset(parser, input, parser->first_nonspace - parser->offset,\n                       false);\n      add_line(container, input, parser);\n    }\n\n    parser->current = container;\n  }\n}\n\n/* See http://spec.commonmark.org/0.24/#phase-1-block-structure */\nstatic void S_process_line(cmark_parser *parser, const unsigned char *buffer,\n                           bufsize_t bytes) {\n  cmark_node *last_matched_container;\n  bool all_matched = true;\n  cmark_node *container;\n  cmark_chunk input;\n  cmark_node *current;\n\n  cmark_strbuf_clear(&parser->curline);\n\n  if (parser->options & CMARK_OPT_VALIDATE_UTF8)\n    cmark_utf8proc_check(&parser->curline, buffer, bytes);\n  else\n    cmark_strbuf_put(&parser->curline, buffer, bytes);\n\n  bytes = parser->curline.size;\n\n  // ensure line ends with a newline:\n  if (bytes == 0 || !S_is_line_end_char(parser->curline.ptr[bytes - 1]))\n    cmark_strbuf_putc(&parser->curline, '\\n');\n\n  parser->offset = 0;\n  parser->column = 0;\n  parser->first_nonspace = 0;\n  parser->first_nonspace_column = 0;\n  parser->thematic_break_kill_pos = 0;\n  parser->indent = 0;\n  parser->blank = false;\n  parser->partially_consumed_tab = false;\n\n  input.data = parser->curline.ptr;\n  input.len = parser->curline.size;\n  input.alloc = 0;\n\n  // Skip UTF-8 BOM.\n  if (parser->line_number == 0 &&\n      input.len >= 3 &&\n      memcmp(input.data, \"\\xef\\xbb\\xbf\", 3) == 0)\n    parser->offset += 3;\n\n  parser->line_number++;\n\n  assert(parser->current->next == NULL);\n  last_matched_container = check_open_blocks(parser, &input, &all_matched);\n\n  if (!last_matched_container)\n    goto finished;\n\n  container = last_matched_container;\n\n  current = parser->current;\n\n  open_new_blocks(parser, &container, &input, all_matched);\n\n  /* parser->current might have changed if feed_reentrant was called */\n  if (current == parser->current)\n  add_text_to_container(parser, container, last_matched_container, &input);\n\nfinished:\n  parser->last_line_length = input.len;\n  if (parser->last_line_length &&\n      input.data[parser->last_line_length - 1] == '\\n')\n    parser->last_line_length -= 1;\n  if (parser->last_line_length &&\n      input.data[parser->last_line_length - 1] == '\\r')\n    parser->last_line_length -= 1;\n\n  cmark_strbuf_clear(&parser->curline);\n}\n\ncmark_node *cmark_parser_finish(cmark_parser *parser) {\n  cmark_node *res;\n  cmark_llist *extensions;\n\n  /* Parser was already finished once */\n  if (parser->root == NULL)\n    return NULL;\n\n  if (parser->linebuf.size) {\n    S_process_line(parser, parser->linebuf.ptr, parser->linebuf.size);\n    cmark_strbuf_clear(&parser->linebuf);\n  }\n\n  finalize_document(parser);\n\n  cmark_consolidate_text_nodes(parser->root);\n\n  cmark_strbuf_free(&parser->curline);\n  cmark_strbuf_free(&parser->linebuf);\n\n#if CMARK_DEBUG_NODES\n  if (cmark_node_check(parser->root, stderr)) {\n    abort();\n  }\n#endif\n\n  for (extensions = parser->syntax_extensions; extensions; extensions = extensions->next) {\n    cmark_syntax_extension *ext = (cmark_syntax_extension *) extensions->data;\n    if (ext->postprocess_func) {\n      cmark_node *processed = ext->postprocess_func(ext, parser, parser->root);\n      if (processed)\n        parser->root = processed;\n    }\n  }\n\n  res = parser->root;\n  parser->root = NULL;\n\n  cmark_parser_reset(parser);\n\n  return res;\n}\n\nint cmark_parser_get_line_number(cmark_parser *parser) {\n  return parser->line_number;\n}\n\nbufsize_t cmark_parser_get_offset(cmark_parser *parser) {\n  return parser->offset;\n}\n\nbufsize_t cmark_parser_get_column(cmark_parser *parser) {\n  return parser->column;\n}\n\nint cmark_parser_get_first_nonspace(cmark_parser *parser) {\n  return parser->first_nonspace;\n}\n\nint cmark_parser_get_first_nonspace_column(cmark_parser *parser) {\n  return parser->first_nonspace_column;\n}\n\nint cmark_parser_get_indent(cmark_parser *parser) {\n  return parser->indent;\n}\n\nint cmark_parser_is_blank(cmark_parser *parser) {\n  return parser->blank;\n}\n\nint cmark_parser_has_partially_consumed_tab(cmark_parser *parser) {\n  return parser->partially_consumed_tab;\n}\n\nint cmark_parser_get_last_line_length(cmark_parser *parser) {\n  return parser->last_line_length;\n}\n\ncmark_node *cmark_parser_add_child(cmark_parser *parser,\n                                   cmark_node   *parent,\n                                   cmark_node_type block_type,\n                                   int start_column) {\n  return add_child(parser, parent, block_type, start_column);\n}\n\nvoid cmark_parser_advance_offset(cmark_parser *parser,\n                                 const char *input,\n                                 int count,\n                                 int columns) {\n  cmark_chunk input_chunk = cmark_chunk_literal(input);\n\n  S_advance_offset(parser, &input_chunk, count, columns != 0);\n}\n\nvoid cmark_parser_set_backslash_ispunct_func(cmark_parser *parser,\n                                             cmark_ispunct_func func) {\n  parser->backslash_ispunct = func;\n}\n\ncmark_llist *cmark_parser_get_syntax_extensions(cmark_parser *parser) {\n  return parser->syntax_extensions;\n}\n", "#ifndef CMARK_GFM_H\n#define CMARK_GFM_H\n\n#include <stdio.h>\n#include <stdint.h>\n#include \"cmark-gfm_export.h\"\n#include \"cmark-gfm_version.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/** # NAME\n *\n * **cmark-gfm** - CommonMark parsing, manipulating, and rendering\n */\n\n/** # DESCRIPTION\n *\n * ## Simple Interface\n */\n\n/** Convert 'text' (assumed to be a UTF-8 encoded string with length\n * 'len') from CommonMark Markdown to HTML, returning a null-terminated,\n * UTF-8-encoded string. It is the caller's responsibility\n * to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_markdown_to_html(const char *text, size_t len, int options);\n\n/** ## Node Structure\n */\n\n#define CMARK_NODE_TYPE_PRESENT (0x8000)\n#define CMARK_NODE_TYPE_BLOCK (CMARK_NODE_TYPE_PRESENT | 0x0000)\n#define CMARK_NODE_TYPE_INLINE (CMARK_NODE_TYPE_PRESENT | 0x4000)\n#define CMARK_NODE_TYPE_MASK (0xc000)\n#define CMARK_NODE_VALUE_MASK (0x3fff)\n\n/**\n * This is the maximum number of block types (CMARK_NODE_DOCUMENT,\n * CMARK_NODE_HEADING, ...). It needs to be bigger than the number of\n * hardcoded block types (below) to allow for extensions (see\n * cmark_syntax_extension_add_node). But it also determines the size of the\n * open_block_counts array in the cmark_parser struct, so we don't want it\n * to be excessively large.\n */\n#define CMARK_NODE_TYPE_BLOCK_LIMIT 0x20\n\ntypedef enum {\n  /* Error status */\n  CMARK_NODE_NONE = 0x0000,\n\n  /* Block */\n  CMARK_NODE_DOCUMENT       = CMARK_NODE_TYPE_BLOCK | 0x0001,\n  CMARK_NODE_BLOCK_QUOTE    = CMARK_NODE_TYPE_BLOCK | 0x0002,\n  CMARK_NODE_LIST           = CMARK_NODE_TYPE_BLOCK | 0x0003,\n  CMARK_NODE_ITEM           = CMARK_NODE_TYPE_BLOCK | 0x0004,\n  CMARK_NODE_CODE_BLOCK     = CMARK_NODE_TYPE_BLOCK | 0x0005,\n  CMARK_NODE_HTML_BLOCK     = CMARK_NODE_TYPE_BLOCK | 0x0006,\n  CMARK_NODE_CUSTOM_BLOCK   = CMARK_NODE_TYPE_BLOCK | 0x0007,\n  CMARK_NODE_PARAGRAPH      = CMARK_NODE_TYPE_BLOCK | 0x0008,\n  CMARK_NODE_HEADING        = CMARK_NODE_TYPE_BLOCK | 0x0009,\n  CMARK_NODE_THEMATIC_BREAK = CMARK_NODE_TYPE_BLOCK | 0x000a,\n  CMARK_NODE_FOOTNOTE_DEFINITION = CMARK_NODE_TYPE_BLOCK | 0x000b,\n\n  /* Inline */\n  CMARK_NODE_TEXT          = CMARK_NODE_TYPE_INLINE | 0x0001,\n  CMARK_NODE_SOFTBREAK     = CMARK_NODE_TYPE_INLINE | 0x0002,\n  CMARK_NODE_LINEBREAK     = CMARK_NODE_TYPE_INLINE | 0x0003,\n  CMARK_NODE_CODE          = CMARK_NODE_TYPE_INLINE | 0x0004,\n  CMARK_NODE_HTML_INLINE   = CMARK_NODE_TYPE_INLINE | 0x0005,\n  CMARK_NODE_CUSTOM_INLINE = CMARK_NODE_TYPE_INLINE | 0x0006,\n  CMARK_NODE_EMPH          = CMARK_NODE_TYPE_INLINE | 0x0007,\n  CMARK_NODE_STRONG        = CMARK_NODE_TYPE_INLINE | 0x0008,\n  CMARK_NODE_LINK          = CMARK_NODE_TYPE_INLINE | 0x0009,\n  CMARK_NODE_IMAGE         = CMARK_NODE_TYPE_INLINE | 0x000a,\n  CMARK_NODE_FOOTNOTE_REFERENCE = CMARK_NODE_TYPE_INLINE | 0x000b,\n} cmark_node_type;\n\nextern cmark_node_type CMARK_NODE_LAST_BLOCK;\nextern cmark_node_type CMARK_NODE_LAST_INLINE;\n\n/* For backwards compatibility: */\n#define CMARK_NODE_HEADER CMARK_NODE_HEADING\n#define CMARK_NODE_HRULE CMARK_NODE_THEMATIC_BREAK\n#define CMARK_NODE_HTML CMARK_NODE_HTML_BLOCK\n#define CMARK_NODE_INLINE_HTML CMARK_NODE_HTML_INLINE\n\ntypedef enum {\n  CMARK_NO_LIST,\n  CMARK_BULLET_LIST,\n  CMARK_ORDERED_LIST\n} cmark_list_type;\n\ntypedef enum {\n  CMARK_NO_DELIM,\n  CMARK_PERIOD_DELIM,\n  CMARK_PAREN_DELIM\n} cmark_delim_type;\n\ntypedef struct cmark_node cmark_node;\ntypedef struct cmark_parser cmark_parser;\ntypedef struct cmark_iter cmark_iter;\ntypedef struct cmark_syntax_extension cmark_syntax_extension;\n\n/**\n * ## Custom memory allocator support\n */\n\n/** Defines the memory allocation functions to be used by CMark\n * when parsing and allocating a document tree\n */\ntypedef struct cmark_mem {\n  void *(*calloc)(size_t, size_t);\n  void *(*realloc)(void *, size_t);\n  void (*free)(void *);\n} cmark_mem;\n\n/** The default memory allocator; uses the system's calloc,\n * realloc and free.\n */\nCMARK_GFM_EXPORT\ncmark_mem *cmark_get_default_mem_allocator(void);\n\n/** An arena allocator; uses system calloc to allocate large\n * slabs of memory.  Memory in these slabs is not reused at all.\n */\nCMARK_GFM_EXPORT\ncmark_mem *cmark_get_arena_mem_allocator(void);\n\n/** Resets the arena allocator, quickly returning all used memory\n * to the operating system.\n */\nCMARK_GFM_EXPORT\nvoid cmark_arena_reset(void);\n\n/** Callback for freeing user data with a 'cmark_mem' context.\n */\ntypedef void (*cmark_free_func) (cmark_mem *mem, void *user_data);\n\n\n/*\n * ## Basic data structures\n *\n * To keep dependencies to the strict minimum, libcmark implements\n * its own versions of \"classic\" data structures.\n */\n\n/**\n * ### Linked list\n */\n\n/** A generic singly linked list.\n */\ntypedef struct _cmark_llist\n{\n  struct _cmark_llist *next;\n  void         *data;\n} cmark_llist;\n\n/** Append an element to the linked list, return the possibly modified\n * head of the list.\n */\nCMARK_GFM_EXPORT\ncmark_llist * cmark_llist_append    (cmark_mem         * mem,\n                                     cmark_llist       * head,\n                                     void              * data);\n\n/** Free the list starting with 'head', calling 'free_func' with the\n *  data pointer of each of its elements\n */\nCMARK_GFM_EXPORT\nvoid          cmark_llist_free_full (cmark_mem         * mem,\n                                     cmark_llist       * head,\n                                     cmark_free_func     free_func);\n\n/** Free the list starting with 'head'\n */\nCMARK_GFM_EXPORT\nvoid          cmark_llist_free      (cmark_mem         * mem,\n                                     cmark_llist       * head);\n\n/**\n * ## Creating and Destroying Nodes\n */\n\n/** Creates a new node of type 'type'.  Note that the node may have\n * other required properties, which it is the caller's responsibility\n * to assign.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_new(cmark_node_type type);\n\n/** Same as `cmark_node_new`, but explicitly listing the memory\n * allocator used to allocate the node.  Note:  be sure to use the same\n * allocator for every node in a tree, or bad things can happen.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_new_with_mem(cmark_node_type type,\n                                                 cmark_mem *mem);\n\nCMARK_GFM_EXPORT cmark_node *cmark_node_new_with_ext(cmark_node_type type,\n                                                cmark_syntax_extension *extension);\n\nCMARK_GFM_EXPORT cmark_node *cmark_node_new_with_mem_and_ext(cmark_node_type type,\n                                                cmark_mem *mem,\n                                                cmark_syntax_extension *extension);\n\n/** Frees the memory allocated for a node and any children.\n */\nCMARK_GFM_EXPORT void cmark_node_free(cmark_node *node);\n\n/**\n * ## Tree Traversal\n */\n\n/** Returns the next node in the sequence after 'node', or NULL if\n * there is none.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_next(cmark_node *node);\n\n/** Returns the previous node in the sequence after 'node', or NULL if\n * there is none.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_previous(cmark_node *node);\n\n/** Returns the parent of 'node', or NULL if there is none.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_parent(cmark_node *node);\n\n/** Returns the first child of 'node', or NULL if 'node' has no children.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_first_child(cmark_node *node);\n\n/** Returns the last child of 'node', or NULL if 'node' has no children.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_last_child(cmark_node *node);\n\n/** Returns the footnote reference of 'node', or NULL if 'node' doesn't have a\n * footnote reference.\n */\nCMARK_GFM_EXPORT cmark_node *cmark_node_parent_footnote_def(cmark_node *node);\n\n/**\n * ## Iterator\n *\n * An iterator will walk through a tree of nodes, starting from a root\n * node, returning one node at a time, together with information about\n * whether the node is being entered or exited.  The iterator will\n * first descend to a child node, if there is one.  When there is no\n * child, the iterator will go to the next sibling.  When there is no\n * next sibling, the iterator will return to the parent (but with\n * a 'cmark_event_type' of `CMARK_EVENT_EXIT`).  The iterator will\n * return `CMARK_EVENT_DONE` when it reaches the root node again.\n * One natural application is an HTML renderer, where an `ENTER` event\n * outputs an open tag and an `EXIT` event outputs a close tag.\n * An iterator might also be used to transform an AST in some systematic\n * way, for example, turning all level-3 headings into regular paragraphs.\n *\n *     void\n *     usage_example(cmark_node *root) {\n *         cmark_event_type ev_type;\n *         cmark_iter *iter = cmark_iter_new(root);\n *\n *         while ((ev_type = cmark_iter_next(iter)) != CMARK_EVENT_DONE) {\n *             cmark_node *cur = cmark_iter_get_node(iter);\n *             // Do something with `cur` and `ev_type`\n *         }\n *\n *         cmark_iter_free(iter);\n *     }\n *\n * Iterators will never return `EXIT` events for leaf nodes, which are nodes\n * of type:\n *\n * * CMARK_NODE_HTML_BLOCK\n * * CMARK_NODE_THEMATIC_BREAK\n * * CMARK_NODE_CODE_BLOCK\n * * CMARK_NODE_TEXT\n * * CMARK_NODE_SOFTBREAK\n * * CMARK_NODE_LINEBREAK\n * * CMARK_NODE_CODE\n * * CMARK_NODE_HTML_INLINE\n *\n * Nodes must only be modified after an `EXIT` event, or an `ENTER` event for\n * leaf nodes.\n */\n\ntypedef enum {\n  CMARK_EVENT_NONE,\n  CMARK_EVENT_DONE,\n  CMARK_EVENT_ENTER,\n  CMARK_EVENT_EXIT\n} cmark_event_type;\n\n/** Creates a new iterator starting at 'root'.  The current node and event\n * type are undefined until 'cmark_iter_next' is called for the first time.\n * The memory allocated for the iterator should be released using\n * 'cmark_iter_free' when it is no longer needed.\n */\nCMARK_GFM_EXPORT\ncmark_iter *cmark_iter_new(cmark_node *root);\n\n/** Frees the memory allocated for an iterator.\n */\nCMARK_GFM_EXPORT\nvoid cmark_iter_free(cmark_iter *iter);\n\n/** Advances to the next node and returns the event type (`CMARK_EVENT_ENTER`,\n * `CMARK_EVENT_EXIT` or `CMARK_EVENT_DONE`).\n */\nCMARK_GFM_EXPORT\ncmark_event_type cmark_iter_next(cmark_iter *iter);\n\n/** Returns the current node.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_iter_get_node(cmark_iter *iter);\n\n/** Returns the current event type.\n */\nCMARK_GFM_EXPORT\ncmark_event_type cmark_iter_get_event_type(cmark_iter *iter);\n\n/** Returns the root node.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_iter_get_root(cmark_iter *iter);\n\n/** Resets the iterator so that the current node is 'current' and\n * the event type is 'event_type'.  The new current node must be a\n * descendant of the root node or the root node itself.\n */\nCMARK_GFM_EXPORT\nvoid cmark_iter_reset(cmark_iter *iter, cmark_node *current,\n                      cmark_event_type event_type);\n\n/**\n * ## Accessors\n */\n\n/** Returns the user data of 'node'.\n */\nCMARK_GFM_EXPORT void *cmark_node_get_user_data(cmark_node *node);\n\n/** Sets arbitrary user data for 'node'.  Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_user_data(cmark_node *node, void *user_data);\n\n/** Set free function for user data */\nCMARK_GFM_EXPORT\nint cmark_node_set_user_data_free_func(cmark_node *node,\n                                        cmark_free_func free_func);\n\n/** Returns the type of 'node', or `CMARK_NODE_NONE` on error.\n */\nCMARK_GFM_EXPORT cmark_node_type cmark_node_get_type(cmark_node *node);\n\n/** Like 'cmark_node_get_type', but returns a string representation\n    of the type, or `\"<unknown>\"`.\n */\nCMARK_GFM_EXPORT\nconst char *cmark_node_get_type_string(cmark_node *node);\n\n/** Returns the string contents of 'node', or an empty\n    string if none is set.  Returns NULL if called on a\n    node that does not have string content.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_literal(cmark_node *node);\n\n/** Sets the string contents of 'node'.  Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_literal(cmark_node *node, const char *content);\n\n/** Returns the heading level of 'node', or 0 if 'node' is not a heading.\n */\nCMARK_GFM_EXPORT int cmark_node_get_heading_level(cmark_node *node);\n\n/* For backwards compatibility */\n#define cmark_node_get_header_level cmark_node_get_heading_level\n#define cmark_node_set_header_level cmark_node_set_heading_level\n\n/** Sets the heading level of 'node', returning 1 on success and 0 on error.\n */\nCMARK_GFM_EXPORT int cmark_node_set_heading_level(cmark_node *node, int level);\n\n/** Returns the list type of 'node', or `CMARK_NO_LIST` if 'node'\n * is not a list.\n */\nCMARK_GFM_EXPORT cmark_list_type cmark_node_get_list_type(cmark_node *node);\n\n/** Sets the list type of 'node', returning 1 on success and 0 on error.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_type(cmark_node *node,\n                                          cmark_list_type type);\n\n/** Returns the list delimiter type of 'node', or `CMARK_NO_DELIM` if 'node'\n * is not a list.\n */\nCMARK_GFM_EXPORT cmark_delim_type cmark_node_get_list_delim(cmark_node *node);\n\n/** Sets the list delimiter type of 'node', returning 1 on success and 0\n * on error.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_delim(cmark_node *node,\n                                           cmark_delim_type delim);\n\n/** Returns starting number of 'node', if it is an ordered list, otherwise 0.\n */\nCMARK_GFM_EXPORT int cmark_node_get_list_start(cmark_node *node);\n\n/** Sets starting number of 'node', if it is an ordered list. Returns 1\n * on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_start(cmark_node *node, int start);\n\n/** Returns 1 if 'node' is a tight list, 0 otherwise.\n */\nCMARK_GFM_EXPORT int cmark_node_get_list_tight(cmark_node *node);\n\n/** Sets the \"tightness\" of a list.  Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_list_tight(cmark_node *node, int tight);\n\n/** Returns the info string from a fenced code block.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_fence_info(cmark_node *node);\n\n/** Sets the info string in a fenced code block, returning 1 on\n * success and 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_fence_info(cmark_node *node, const char *info);\n\n/** Sets code blocks fencing details\n */\nCMARK_GFM_EXPORT int cmark_node_set_fenced(cmark_node * node, int fenced,\n    int length, int offset, char character);\n\n/** Returns code blocks fencing details\n */\nCMARK_GFM_EXPORT int cmark_node_get_fenced(cmark_node *node, int *length, int *offset, char *character);\n\n/** Returns the URL of a link or image 'node', or an empty string\n    if no URL is set.  Returns NULL if called on a node that is\n    not a link or image.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_url(cmark_node *node);\n\n/** Sets the URL of a link or image 'node'. Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_url(cmark_node *node, const char *url);\n\n/** Returns the title of a link or image 'node', or an empty\n    string if no title is set.  Returns NULL if called on a node\n    that is not a link or image.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_title(cmark_node *node);\n\n/** Sets the title of a link or image 'node'. Returns 1 on success,\n * 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_title(cmark_node *node, const char *title);\n\n/** Returns the literal \"on enter\" text for a custom 'node', or\n    an empty string if no on_enter is set.  Returns NULL if called\n    on a non-custom node.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_on_enter(cmark_node *node);\n\n/** Sets the literal text to render \"on enter\" for a custom 'node'.\n    Any children of the node will be rendered after this text.\n    Returns 1 on success 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_on_enter(cmark_node *node,\n                                         const char *on_enter);\n\n/** Returns the literal \"on exit\" text for a custom 'node', or\n    an empty string if no on_exit is set.  Returns NULL if\n    called on a non-custom node.\n */\nCMARK_GFM_EXPORT const char *cmark_node_get_on_exit(cmark_node *node);\n\n/** Sets the literal text to render \"on exit\" for a custom 'node'.\n    Any children of the node will be rendered before this text.\n    Returns 1 on success 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_set_on_exit(cmark_node *node, const char *on_exit);\n\n/** Returns the line on which 'node' begins.\n */\nCMARK_GFM_EXPORT int cmark_node_get_start_line(cmark_node *node);\n\n/** Returns the column at which 'node' begins.\n */\nCMARK_GFM_EXPORT int cmark_node_get_start_column(cmark_node *node);\n\n/** Returns the line on which 'node' ends.\n */\nCMARK_GFM_EXPORT int cmark_node_get_end_line(cmark_node *node);\n\n/** Returns the column at which 'node' ends.\n */\nCMARK_GFM_EXPORT int cmark_node_get_end_column(cmark_node *node);\n\n/**\n * ## Tree Manipulation\n */\n\n/** Unlinks a 'node', removing it from the tree, but not freeing its\n * memory.  (Use 'cmark_node_free' for that.)\n */\nCMARK_GFM_EXPORT void cmark_node_unlink(cmark_node *node);\n\n/** Inserts 'sibling' before 'node'.  Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_insert_before(cmark_node *node,\n                                          cmark_node *sibling);\n\n/** Inserts 'sibling' after 'node'. Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_insert_after(cmark_node *node, cmark_node *sibling);\n\n/** Replaces 'oldnode' with 'newnode' and unlinks 'oldnode' (but does\n * not free its memory).\n * Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_replace(cmark_node *oldnode, cmark_node *newnode);\n\n/** Adds 'child' to the beginning of the children of 'node'.\n * Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_prepend_child(cmark_node *node, cmark_node *child);\n\n/** Adds 'child' to the end of the children of 'node'.\n * Returns 1 on success, 0 on failure.\n */\nCMARK_GFM_EXPORT int cmark_node_append_child(cmark_node *node, cmark_node *child);\n\n/** Consolidates adjacent text nodes.\n */\nCMARK_GFM_EXPORT void cmark_consolidate_text_nodes(cmark_node *root);\n\n/** Ensures a node and all its children own their own chunk memory.\n */\nCMARK_GFM_EXPORT void cmark_node_own(cmark_node *root);\n\n/**\n * ## Parsing\n *\n * Simple interface:\n *\n *     cmark_node *document = cmark_parse_document(\"Hello *world*\", 13,\n *                                                 CMARK_OPT_DEFAULT);\n *\n * Streaming interface:\n *\n *     cmark_parser *parser = cmark_parser_new(CMARK_OPT_DEFAULT);\n *     FILE *fp = fopen(\"myfile.md\", \"rb\");\n *     while ((bytes = fread(buffer, 1, sizeof(buffer), fp)) > 0) {\n *     \t   cmark_parser_feed(parser, buffer, bytes);\n *     \t   if (bytes < sizeof(buffer)) {\n *     \t       break;\n *     \t   }\n *     }\n *     document = cmark_parser_finish(parser);\n *     cmark_parser_free(parser);\n */\n\n/** Creates a new parser object.\n */\nCMARK_GFM_EXPORT\ncmark_parser *cmark_parser_new(int options);\n\n/** Creates a new parser object with the given memory allocator\n */\nCMARK_GFM_EXPORT\ncmark_parser *cmark_parser_new_with_mem(int options, cmark_mem *mem);\n\n/** Frees memory allocated for a parser object.\n */\nCMARK_GFM_EXPORT\nvoid cmark_parser_free(cmark_parser *parser);\n\n/** Feeds a string of length 'len' to 'parser'.\n */\nCMARK_GFM_EXPORT\nvoid cmark_parser_feed(cmark_parser *parser, const char *buffer, size_t len);\n\n/** Finish parsing and return a pointer to a tree of nodes.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_parser_finish(cmark_parser *parser);\n\n/** Parse a CommonMark document in 'buffer' of length 'len'.\n * Returns a pointer to a tree of nodes.  The memory allocated for\n * the node tree should be released using 'cmark_node_free'\n * when it is no longer needed.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_parse_document(const char *buffer, size_t len, int options);\n\n/** Parse a CommonMark document in file 'f', returning a pointer to\n * a tree of nodes.  The memory allocated for the node tree should be\n * released using 'cmark_node_free' when it is no longer needed.\n */\nCMARK_GFM_EXPORT\ncmark_node *cmark_parse_file(FILE *f, int options);\n\n/**\n * ## Rendering\n */\n\n/** Render a 'node' tree as XML.  It is the caller's responsibility\n * to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_xml(cmark_node *root, int options);\n\n/** As for 'cmark_render_xml', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_xml_with_mem(cmark_node *root, int options, cmark_mem *mem);\n\n/** Render a 'node' tree as an HTML fragment.  It is up to the user\n * to add an appropriate header and footer. It is the caller's\n * responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_html(cmark_node *root, int options, cmark_llist *extensions);\n\n/** As for 'cmark_render_html', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_html_with_mem(cmark_node *root, int options, cmark_llist *extensions, cmark_mem *mem);\n\n/** Render a 'node' tree as a groff man page, without the header.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_man(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_man', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_man_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/** Render a 'node' tree as a commonmark document.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_commonmark(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_commonmark', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_commonmark_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/** Render a 'node' tree as a plain text document.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_plaintext(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_plaintext', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_plaintext_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/** Render a 'node' tree as a LaTeX document.\n * It is the caller's responsibility to free the returned buffer.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_latex(cmark_node *root, int options, int width);\n\n/** As for 'cmark_render_latex', but specifying the allocator to use for\n * the resulting string.\n */\nCMARK_GFM_EXPORT\nchar *cmark_render_latex_with_mem(cmark_node *root, int options, int width, cmark_mem *mem);\n\n/**\n * ## Options\n */\n\n/** Default options.\n */\n#define CMARK_OPT_DEFAULT 0\n\n/**\n * ### Options affecting rendering\n */\n\n/** Include a `data-sourcepos` attribute on all block elements.\n */\n#define CMARK_OPT_SOURCEPOS (1 << 1)\n\n/** Render `softbreak` elements as hard line breaks.\n */\n#define CMARK_OPT_HARDBREAKS (1 << 2)\n\n/** `CMARK_OPT_SAFE` is defined here for API compatibility,\n    but it no longer has any effect. \"Safe\" mode is now the default:\n    set `CMARK_OPT_UNSAFE` to disable it.\n */\n#define CMARK_OPT_SAFE (1 << 3)\n\n/** Render raw HTML and unsafe links (`javascript:`, `vbscript:`,\n * `file:`, and `data:`, except for `image/png`, `image/gif`,\n * `image/jpeg`, or `image/webp` mime types).  By default,\n * raw HTML is replaced by a placeholder HTML comment. Unsafe\n * links are replaced by empty strings.\n */\n#define CMARK_OPT_UNSAFE (1 << 17)\n\n/** Render `softbreak` elements as spaces.\n */\n#define CMARK_OPT_NOBREAKS (1 << 4)\n\n/**\n * ### Options affecting parsing\n */\n\n/** Legacy option (no effect).\n */\n#define CMARK_OPT_NORMALIZE (1 << 8)\n\n/** Validate UTF-8 in the input before parsing, replacing illegal\n * sequences with the replacement character U+FFFD.\n */\n#define CMARK_OPT_VALIDATE_UTF8 (1 << 9)\n\n/** Convert straight quotes to curly, --- to em dashes, -- to en dashes.\n */\n#define CMARK_OPT_SMART (1 << 10)\n\n/** Use GitHub-style <pre lang=\"x\"> tags for code blocks instead of <pre><code\n * class=\"language-x\">.\n */\n#define CMARK_OPT_GITHUB_PRE_LANG (1 << 11)\n\n/** Be liberal in interpreting inline HTML tags.\n */\n#define CMARK_OPT_LIBERAL_HTML_TAG (1 << 12)\n\n/** Parse footnotes.\n */\n#define CMARK_OPT_FOOTNOTES (1 << 13)\n\n/** Only parse strikethroughs if surrounded by exactly 2 tildes.\n * Gives some compatibility with redcarpet.\n */\n#define CMARK_OPT_STRIKETHROUGH_DOUBLE_TILDE (1 << 14)\n\n/** Use style attributes to align table cells instead of align attributes.\n */\n#define CMARK_OPT_TABLE_PREFER_STYLE_ATTRIBUTES (1 << 15)\n\n/** Include the remainder of the info string in code blocks in\n * a separate attribute.\n */\n#define CMARK_OPT_FULL_INFO_STRING (1 << 16)\n\n/**\n * ## Version information\n */\n\n/** The library version as integer for runtime checks. Also available as\n * macro CMARK_VERSION for compile time checks.\n *\n * * Bits 16-23 contain the major version.\n * * Bits 8-15 contain the minor version.\n * * Bits 0-7 contain the patchlevel.\n *\n * In hexadecimal format, the number 0x010203 represents version 1.2.3.\n */\nCMARK_GFM_EXPORT\nint cmark_version(void);\n\n/** The library version string for runtime checks. Also available as\n * macro CMARK_VERSION_STRING for compile time checks.\n */\nCMARK_GFM_EXPORT\nconst char *cmark_version_string(void);\n\n/** # AUTHORS\n *\n * John MacFarlane, Vicent Marti,  K\u0101rlis Ga\u0146\u0123is, Nick Wellnhofer.\n */\n\n#ifndef CMARK_NO_SHORT_NAMES\n#define NODE_DOCUMENT CMARK_NODE_DOCUMENT\n#define NODE_BLOCK_QUOTE CMARK_NODE_BLOCK_QUOTE\n#define NODE_LIST CMARK_NODE_LIST\n#define NODE_ITEM CMARK_NODE_ITEM\n#define NODE_CODE_BLOCK CMARK_NODE_CODE_BLOCK\n#define NODE_HTML_BLOCK CMARK_NODE_HTML_BLOCK\n#define NODE_CUSTOM_BLOCK CMARK_NODE_CUSTOM_BLOCK\n#define NODE_PARAGRAPH CMARK_NODE_PARAGRAPH\n#define NODE_HEADING CMARK_NODE_HEADING\n#define NODE_HEADER CMARK_NODE_HEADER\n#define NODE_THEMATIC_BREAK CMARK_NODE_THEMATIC_BREAK\n#define NODE_HRULE CMARK_NODE_HRULE\n#define NODE_TEXT CMARK_NODE_TEXT\n#define NODE_SOFTBREAK CMARK_NODE_SOFTBREAK\n#define NODE_LINEBREAK CMARK_NODE_LINEBREAK\n#define NODE_CODE CMARK_NODE_CODE\n#define NODE_HTML_INLINE CMARK_NODE_HTML_INLINE\n#define NODE_CUSTOM_INLINE CMARK_NODE_CUSTOM_INLINE\n#define NODE_EMPH CMARK_NODE_EMPH\n#define NODE_STRONG CMARK_NODE_STRONG\n#define NODE_LINK CMARK_NODE_LINK\n#define NODE_IMAGE CMARK_NODE_IMAGE\n#define BULLET_LIST CMARK_BULLET_LIST\n#define ORDERED_LIST CMARK_ORDERED_LIST\n#define PERIOD_DELIM CMARK_PERIOD_DELIM\n#define PAREN_DELIM CMARK_PAREN_DELIM\n#endif\n\ntypedef int32_t bufsize_t;\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#include <stdlib.h>\n#include <string.h>\n\n#include \"config.h\"\n#include \"node.h\"\n#include \"syntax_extension.h\"\n\n/**\n * Expensive safety checks are off by default, but can be enabled\n * by calling cmark_enable_safety_checks().\n */\nstatic bool enable_safety_checks = false;\n\nvoid cmark_enable_safety_checks(bool enable) {\n  enable_safety_checks = enable;\n}\n\nstatic void S_node_unlink(cmark_node *node);\n\n#define NODE_MEM(node) cmark_node_mem(node)\n\nvoid cmark_register_node_flag(cmark_node_internal_flags *flags) {\n  static cmark_node_internal_flags nextflag = CMARK_NODE__REGISTER_FIRST;\n\n  // flags should be a pointer to a global variable and this function\n  // should only be called once to initialize its value.\n  if (*flags) {\n    fprintf(stderr, \"flag initialization error in cmark_register_node_flag\\n\");\n    abort();\n  }\n\n  // Check that we haven't run out of bits.\n  if (nextflag == 0) {\n    fprintf(stderr, \"too many flags in cmark_register_node_flag\\n\");\n    abort();\n  }\n\n  *flags = nextflag;\n  nextflag <<= 1;\n}\n\nvoid cmark_init_standard_node_flags() {}\n\nbool cmark_node_can_contain_type(cmark_node *node, cmark_node_type child_type) {\n  if (child_type == CMARK_NODE_DOCUMENT) {\n      return false;\n    }\n\n  if (node->extension && node->extension->can_contain_func) {\n    return node->extension->can_contain_func(node->extension, node, child_type) != 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_DOCUMENT:\n  case CMARK_NODE_BLOCK_QUOTE:\n  case CMARK_NODE_FOOTNOTE_DEFINITION:\n  case CMARK_NODE_ITEM:\n    return CMARK_NODE_TYPE_BLOCK_P(child_type) && child_type != CMARK_NODE_ITEM;\n\n  case CMARK_NODE_LIST:\n    return child_type == CMARK_NODE_ITEM;\n\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return true;\n\n  case CMARK_NODE_PARAGRAPH:\n  case CMARK_NODE_HEADING:\n  case CMARK_NODE_EMPH:\n  case CMARK_NODE_STRONG:\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n  case CMARK_NODE_CUSTOM_INLINE:\n    return CMARK_NODE_TYPE_INLINE_P(child_type);\n\n  default:\n    break;\n  }\n\n  return false;\n}\n\nstatic bool S_can_contain(cmark_node *node, cmark_node *child) {\n  if (node == NULL || child == NULL) {\n    return false;\n  }\n  if (NODE_MEM(node) != NODE_MEM(child)) {\n    return 0;\n  }\n\n  if (enable_safety_checks) {\n    // Verify that child is not an ancestor of node or equal to node.\n    cmark_node *cur = node;\n    do {\n      if (cur == child) {\n        return false;\n      }\n      cur = cur->parent;\n    } while (cur != NULL);\n  }\n\n  return cmark_node_can_contain_type(node, (cmark_node_type) child->type);\n}\n\ncmark_node *cmark_node_new_with_mem_and_ext(cmark_node_type type, cmark_mem *mem, cmark_syntax_extension *extension) {\n  cmark_node *node = (cmark_node *)mem->calloc(1, sizeof(*node));\n  cmark_strbuf_init(mem, &node->content, 0);\n  node->type = (uint16_t)type;\n  node->extension = extension;\n\n  switch (node->type) {\n  case CMARK_NODE_HEADING:\n    node->as.heading.level = 1;\n    break;\n\n  case CMARK_NODE_LIST: {\n    cmark_list *list = &node->as.list;\n    list->list_type = CMARK_BULLET_LIST;\n    list->start = 0;\n    list->tight = false;\n    break;\n  }\n\n  default:\n    break;\n  }\n\n  if (node->extension && node->extension->opaque_alloc_func) {\n    node->extension->opaque_alloc_func(node->extension, mem, node);\n  }\n\n  return node;\n}\n\ncmark_node *cmark_node_new_with_ext(cmark_node_type type, cmark_syntax_extension *extension) {\n  extern cmark_mem CMARK_DEFAULT_MEM_ALLOCATOR;\n  return cmark_node_new_with_mem_and_ext(type, &CMARK_DEFAULT_MEM_ALLOCATOR, extension);\n}\n\ncmark_node *cmark_node_new_with_mem(cmark_node_type type, cmark_mem *mem)\n{\n  return cmark_node_new_with_mem_and_ext(type, mem, NULL);\n}\n\ncmark_node *cmark_node_new(cmark_node_type type) {\n  return cmark_node_new_with_ext(type, NULL);\n}\n\nstatic void free_node_as(cmark_node *node) {\n  switch (node->type) {\n    case CMARK_NODE_CODE_BLOCK:\n    cmark_chunk_free(NODE_MEM(node), &node->as.code.info);\n    cmark_chunk_free(NODE_MEM(node), &node->as.code.literal);\n      break;\n    case CMARK_NODE_TEXT:\n    case CMARK_NODE_HTML_INLINE:\n    case CMARK_NODE_CODE:\n    case CMARK_NODE_HTML_BLOCK:\n    case CMARK_NODE_FOOTNOTE_REFERENCE:\n    case CMARK_NODE_FOOTNOTE_DEFINITION:\n    cmark_chunk_free(NODE_MEM(node), &node->as.literal);\n      break;\n    case CMARK_NODE_LINK:\n    case CMARK_NODE_IMAGE:\n    cmark_chunk_free(NODE_MEM(node), &node->as.link.url);\n    cmark_chunk_free(NODE_MEM(node), &node->as.link.title);\n      break;\n    case CMARK_NODE_CUSTOM_BLOCK:\n    case CMARK_NODE_CUSTOM_INLINE:\n    cmark_chunk_free(NODE_MEM(node), &node->as.custom.on_enter);\n    cmark_chunk_free(NODE_MEM(node), &node->as.custom.on_exit);\n      break;\n    default:\n      break;\n    }\n}\n\n// Free a cmark_node list and any children.\nstatic void S_free_nodes(cmark_node *e) {\n  cmark_node *next;\n  while (e != NULL) {\n    cmark_strbuf_free(&e->content);\n\n    if (e->user_data && e->user_data_free_func)\n      e->user_data_free_func(NODE_MEM(e), e->user_data);\n\n    if (e->as.opaque && e->extension && e->extension->opaque_free_func)\n      e->extension->opaque_free_func(e->extension, NODE_MEM(e), e);\n\n    free_node_as(e);\n\n    if (e->last_child) {\n      // Splice children into list\n      e->last_child->next = e->next;\n      e->next = e->first_child;\n    }\n    next = e->next;\n    NODE_MEM(e)->free(e);\n    e = next;\n  }\n}\n\nvoid cmark_node_free(cmark_node *node) {\n  S_node_unlink(node);\n  node->next = NULL;\n  S_free_nodes(node);\n}\n\ncmark_node_type cmark_node_get_type(cmark_node *node) {\n  if (node == NULL) {\n    return CMARK_NODE_NONE;\n  } else {\n    return (cmark_node_type)node->type;\n  }\n}\n\nint cmark_node_set_type(cmark_node * node, cmark_node_type type) {\n  cmark_node_type initial_type;\n\n  if (type == node->type)\n    return 1;\n\n  initial_type = (cmark_node_type) node->type;\n  node->type = (uint16_t)type;\n\n  if (!S_can_contain(node->parent, node)) {\n    node->type = (uint16_t)initial_type;\n    return 0;\n  }\n\n  /* We rollback the type to free the union members appropriately */\n  node->type = (uint16_t)initial_type;\n  free_node_as(node);\n\n  node->type = (uint16_t)type;\n\n  return 1;\n}\n\nconst char *cmark_node_get_type_string(cmark_node *node) {\n  if (node == NULL) {\n    return \"NONE\";\n  }\n\n  if (node->extension && node->extension->get_type_string_func) {\n    return node->extension->get_type_string_func(node->extension, node);\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_NONE:\n    return \"none\";\n  case CMARK_NODE_DOCUMENT:\n    return \"document\";\n  case CMARK_NODE_BLOCK_QUOTE:\n    return \"block_quote\";\n  case CMARK_NODE_LIST:\n    return \"list\";\n  case CMARK_NODE_ITEM:\n    return \"item\";\n  case CMARK_NODE_CODE_BLOCK:\n    return \"code_block\";\n  case CMARK_NODE_HTML_BLOCK:\n    return \"html_block\";\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return \"custom_block\";\n  case CMARK_NODE_PARAGRAPH:\n    return \"paragraph\";\n  case CMARK_NODE_HEADING:\n    return \"heading\";\n  case CMARK_NODE_THEMATIC_BREAK:\n    return \"thematic_break\";\n  case CMARK_NODE_TEXT:\n    return \"text\";\n  case CMARK_NODE_SOFTBREAK:\n    return \"softbreak\";\n  case CMARK_NODE_LINEBREAK:\n    return \"linebreak\";\n  case CMARK_NODE_CODE:\n    return \"code\";\n  case CMARK_NODE_HTML_INLINE:\n    return \"html_inline\";\n  case CMARK_NODE_CUSTOM_INLINE:\n    return \"custom_inline\";\n  case CMARK_NODE_EMPH:\n    return \"emph\";\n  case CMARK_NODE_STRONG:\n    return \"strong\";\n  case CMARK_NODE_LINK:\n    return \"link\";\n  case CMARK_NODE_IMAGE:\n    return \"image\";\n  }\n\n  return \"<unknown>\";\n}\n\ncmark_node *cmark_node_next(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->next;\n  }\n}\n\ncmark_node *cmark_node_previous(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->prev;\n  }\n}\n\ncmark_node *cmark_node_parent(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->parent;\n  }\n}\n\ncmark_node *cmark_node_first_child(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->first_child;\n  }\n}\n\ncmark_node *cmark_node_last_child(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->last_child;\n  }\n}\n\ncmark_node *cmark_node_parent_footnote_def(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->parent_footnote_def;\n  }\n}\n\nvoid *cmark_node_get_user_data(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  } else {\n    return node->user_data;\n  }\n}\n\nint cmark_node_set_user_data(cmark_node *node, void *user_data) {\n  if (node == NULL) {\n    return 0;\n  }\n  node->user_data = user_data;\n  return 1;\n}\n\nint cmark_node_set_user_data_free_func(cmark_node *node,\n                                        cmark_free_func free_func) {\n  if (node == NULL) {\n    return 0;\n  }\n  node->user_data_free_func = free_func;\n  return 1;\n}\n\nconst char *cmark_node_get_literal(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HTML_BLOCK:\n  case CMARK_NODE_TEXT:\n  case CMARK_NODE_HTML_INLINE:\n  case CMARK_NODE_CODE:\n  case CMARK_NODE_FOOTNOTE_REFERENCE:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.literal);\n\n  case CMARK_NODE_CODE_BLOCK:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.code.literal);\n\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_literal(cmark_node *node, const char *content) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HTML_BLOCK:\n  case CMARK_NODE_TEXT:\n  case CMARK_NODE_HTML_INLINE:\n  case CMARK_NODE_CODE:\n  case CMARK_NODE_FOOTNOTE_REFERENCE:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.literal, content);\n    return 1;\n\n  case CMARK_NODE_CODE_BLOCK:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.code.literal, content);\n    return 1;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_string_content(cmark_node *node) {\n  return (char *) node->content.ptr;\n}\n\nint cmark_node_set_string_content(cmark_node *node, const char *content) {\n  cmark_strbuf_sets(&node->content, content);\n  return true;\n}\n\nint cmark_node_get_heading_level(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HEADING:\n    return node->as.heading.level;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nint cmark_node_set_heading_level(cmark_node *node, int level) {\n  if (node == NULL || level < 1 || level > 6) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_HEADING:\n    node->as.heading.level = level;\n    return 1;\n\n  default:\n    break;\n  }\n\n  return 0;\n}\n\ncmark_list_type cmark_node_get_list_type(cmark_node *node) {\n  if (node == NULL) {\n    return CMARK_NO_LIST;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.list_type;\n  } else {\n    return CMARK_NO_LIST;\n  }\n}\n\nint cmark_node_set_list_type(cmark_node *node, cmark_list_type type) {\n  if (!(type == CMARK_BULLET_LIST || type == CMARK_ORDERED_LIST)) {\n    return 0;\n  }\n\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.list_type = type;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\ncmark_delim_type cmark_node_get_list_delim(cmark_node *node) {\n  if (node == NULL) {\n    return CMARK_NO_DELIM;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.delimiter;\n  } else {\n    return CMARK_NO_DELIM;\n  }\n}\n\nint cmark_node_set_list_delim(cmark_node *node, cmark_delim_type delim) {\n  if (!(delim == CMARK_PERIOD_DELIM || delim == CMARK_PAREN_DELIM)) {\n    return 0;\n  }\n\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.delimiter = delim;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_get_list_start(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.start;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_set_list_start(cmark_node *node, int start) {\n  if (node == NULL || start < 0) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.start = start;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_get_list_tight(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    return node->as.list.tight;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_set_list_tight(cmark_node *node, int tight) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_LIST) {\n    node->as.list.tight = tight == 1;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nconst char *cmark_node_get_fence_info(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.code.info);\n  } else {\n    return NULL;\n  }\n}\n\nint cmark_node_set_fence_info(cmark_node *node, const char *info) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.code.info, info);\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_get_fenced(cmark_node *node, int *length, int *offset, char *character) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    *length = node->as.code.fence_length;\n    *offset = node->as.code.fence_offset;\n    *character = node->as.code.fence_char;\n    return node->as.code.fenced;\n  } else {\n    return 0;\n  }\n}\n\nint cmark_node_set_fenced(cmark_node * node, int fenced,\n    int length, int offset, char character) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  if (node->type == CMARK_NODE_CODE_BLOCK) {\n    node->as.code.fenced = (int8_t)fenced;\n    node->as.code.fence_length = (uint8_t)length;\n    node->as.code.fence_offset = (uint8_t)offset;\n    node->as.code.fence_char = character;\n    return 1;\n  } else {\n    return 0;\n  }\n}\n\nconst char *cmark_node_get_url(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.link.url);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_url(cmark_node *node, const char *url) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.link.url, url);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_title(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.link.title);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_title(cmark_node *node, const char *title) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_LINK:\n  case CMARK_NODE_IMAGE:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.link.title, title);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_on_enter(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.custom.on_enter);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_on_enter(cmark_node *node, const char *on_enter) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.custom.on_enter, on_enter);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\nconst char *cmark_node_get_on_exit(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    return cmark_chunk_to_cstr(NODE_MEM(node), &node->as.custom.on_exit);\n  default:\n    break;\n  }\n\n  return NULL;\n}\n\nint cmark_node_set_on_exit(cmark_node *node, const char *on_exit) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  switch (node->type) {\n  case CMARK_NODE_CUSTOM_INLINE:\n  case CMARK_NODE_CUSTOM_BLOCK:\n    cmark_chunk_set_cstr(NODE_MEM(node), &node->as.custom.on_exit, on_exit);\n    return 1;\n  default:\n    break;\n  }\n\n  return 0;\n}\n\ncmark_syntax_extension *cmark_node_get_syntax_extension(cmark_node *node) {\n  if (node == NULL) {\n    return NULL;\n  }\n\n  return node->extension;\n}\n\nint cmark_node_set_syntax_extension(cmark_node *node, cmark_syntax_extension *extension) {\n  if (node == NULL) {\n    return 0;\n  }\n\n  node->extension = extension;\n  return 1;\n}\n\nint cmark_node_get_start_line(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->start_line;\n}\n\nint cmark_node_get_start_column(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->start_column;\n}\n\nint cmark_node_get_end_line(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->end_line;\n}\n\nint cmark_node_get_end_column(cmark_node *node) {\n  if (node == NULL) {\n    return 0;\n  }\n  return node->end_column;\n}\n\n// Unlink a node without adjusting its next, prev, and parent pointers.\nstatic void S_node_unlink(cmark_node *node) {\n  if (node == NULL) {\n    return;\n  }\n\n  if (node->prev) {\n    node->prev->next = node->next;\n  }\n  if (node->next) {\n    node->next->prev = node->prev;\n  }\n\n  // Adjust first_child and last_child of parent.\n  cmark_node *parent = node->parent;\n  if (parent) {\n    if (parent->first_child == node) {\n      parent->first_child = node->next;\n    }\n    if (parent->last_child == node) {\n      parent->last_child = node->prev;\n    }\n  }\n}\n\nvoid cmark_node_unlink(cmark_node *node) {\n  S_node_unlink(node);\n\n  node->next = NULL;\n  node->prev = NULL;\n  node->parent = NULL;\n}\n\nint cmark_node_insert_before(cmark_node *node, cmark_node *sibling) {\n  if (node == NULL || sibling == NULL) {\n    return 0;\n  }\n\n  if (!node->parent || !S_can_contain(node->parent, sibling)) {\n    return 0;\n  }\n\n  S_node_unlink(sibling);\n\n  cmark_node *old_prev = node->prev;\n\n  // Insert 'sibling' between 'old_prev' and 'node'.\n  if (old_prev) {\n    old_prev->next = sibling;\n  }\n  sibling->prev = old_prev;\n  sibling->next = node;\n  node->prev = sibling;\n\n  // Set new parent.\n  cmark_node *parent = node->parent;\n  sibling->parent = parent;\n\n  // Adjust first_child of parent if inserted as first child.\n  if (parent && !old_prev) {\n    parent->first_child = sibling;\n  }\n\n  return 1;\n}\n\nint cmark_node_insert_after(cmark_node *node, cmark_node *sibling) {\n  if (node == NULL || sibling == NULL) {\n    return 0;\n  }\n\n  if (!node->parent || !S_can_contain(node->parent, sibling)) {\n    return 0;\n  }\n\n  S_node_unlink(sibling);\n\n  cmark_node *old_next = node->next;\n\n  // Insert 'sibling' between 'node' and 'old_next'.\n  if (old_next) {\n    old_next->prev = sibling;\n  }\n  sibling->next = old_next;\n  sibling->prev = node;\n  node->next = sibling;\n\n  // Set new parent.\n  cmark_node *parent = node->parent;\n  sibling->parent = parent;\n\n  // Adjust last_child of parent if inserted as last child.\n  if (parent && !old_next) {\n    parent->last_child = sibling;\n  }\n\n  return 1;\n}\n\nint cmark_node_replace(cmark_node *oldnode, cmark_node *newnode) {\n  if (!cmark_node_insert_before(oldnode, newnode)) {\n    return 0;\n  }\n  cmark_node_unlink(oldnode);\n  return 1;\n}\n\nint cmark_node_prepend_child(cmark_node *node, cmark_node *child) {\n  if (!S_can_contain(node, child)) {\n    return 0;\n  }\n\n  S_node_unlink(child);\n\n  cmark_node *old_first_child = node->first_child;\n\n  child->next = old_first_child;\n  child->prev = NULL;\n  child->parent = node;\n  node->first_child = child;\n\n  if (old_first_child) {\n    old_first_child->prev = child;\n  } else {\n    // Also set last_child if node previously had no children.\n    node->last_child = child;\n  }\n\n  return 1;\n}\n\nint cmark_node_append_child(cmark_node *node, cmark_node *child) {\n  if (!S_can_contain(node, child)) {\n    return 0;\n  }\n\n  S_node_unlink(child);\n\n  cmark_node *old_last_child = node->last_child;\n\n  child->next = NULL;\n  child->prev = old_last_child;\n  child->parent = node;\n  node->last_child = child;\n\n  if (old_last_child) {\n    old_last_child->next = child;\n  } else {\n    // Also set first_child if node previously had no children.\n    node->first_child = child;\n  }\n\n  return 1;\n}\n\nstatic void S_print_error(FILE *out, cmark_node *node, const char *elem) {\n  if (out == NULL) {\n    return;\n  }\n  fprintf(out, \"Invalid '%s' in node type %s at %d:%d\\n\", elem,\n          cmark_node_get_type_string(node), node->start_line,\n          node->start_column);\n}\n\nint cmark_node_check(cmark_node *node, FILE *out) {\n  cmark_node *cur;\n  int errors = 0;\n\n  if (!node) {\n    return 0;\n  }\n\n  cur = node;\n  for (;;) {\n    if (cur->first_child) {\n      if (cur->first_child->prev != NULL) {\n        S_print_error(out, cur->first_child, \"prev\");\n        cur->first_child->prev = NULL;\n        ++errors;\n      }\n      if (cur->first_child->parent != cur) {\n        S_print_error(out, cur->first_child, \"parent\");\n        cur->first_child->parent = cur;\n        ++errors;\n      }\n      cur = cur->first_child;\n      continue;\n    }\n\n  next_sibling:\n    if (cur == node) {\n      break;\n    }\n    if (cur->next) {\n      if (cur->next->prev != cur) {\n        S_print_error(out, cur->next, \"prev\");\n        cur->next->prev = cur;\n        ++errors;\n      }\n      if (cur->next->parent != cur->parent) {\n        S_print_error(out, cur->next, \"parent\");\n        cur->next->parent = cur->parent;\n        ++errors;\n      }\n      cur = cur->next;\n      continue;\n    }\n\n    if (cur->parent->last_child != cur) {\n      S_print_error(out, cur->parent, \"last_child\");\n      cur->parent->last_child = cur;\n      ++errors;\n    }\n    cur = cur->parent;\n    goto next_sibling;\n  }\n\n  return errors;\n}\n", "#ifndef CMARK_NODE_H\n#define CMARK_NODE_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#include <stdio.h>\n#include <stdint.h>\n\n#include \"cmark-gfm.h\"\n#include \"cmark-gfm-extension_api.h\"\n#include \"buffer.h\"\n#include \"chunk.h\"\n\ntypedef struct {\n  cmark_list_type list_type;\n  int marker_offset;\n  int padding;\n  int start;\n  cmark_delim_type delimiter;\n  unsigned char bullet_char;\n  bool tight;\n  bool checked; // For task list extension\n} cmark_list;\n\ntypedef struct {\n  cmark_chunk info;\n  cmark_chunk literal;\n  uint8_t fence_length;\n  uint8_t fence_offset;\n  unsigned char fence_char;\n  int8_t fenced;\n} cmark_code;\n\ntypedef struct {\n  int level;\n  bool setext;\n} cmark_heading;\n\ntypedef struct {\n  cmark_chunk url;\n  cmark_chunk title;\n} cmark_link;\n\ntypedef struct {\n  cmark_chunk on_enter;\n  cmark_chunk on_exit;\n} cmark_custom;\n\nenum cmark_node__internal_flags {\n  CMARK_NODE__OPEN = (1 << 0),\n  CMARK_NODE__OPEN_BLOCK = (1 << 1),\n  CMARK_NODE__LAST_LINE_BLANK = (1 << 2),\n  CMARK_NODE__LAST_LINE_CHECKED = (1 << 3),\n\n  // Extensions can register custom flags by calling `cmark_register_node_flag`.\n  // This is the starting value for the custom flags.\n  CMARK_NODE__REGISTER_FIRST = (1 << 4),\n};\n\ntypedef uint16_t cmark_node_internal_flags;\n\nstruct cmark_node {\n  cmark_strbuf content;\n\n  struct cmark_node *next;\n  struct cmark_node *prev;\n  struct cmark_node *parent;\n  struct cmark_node *first_child;\n  struct cmark_node *last_child;\n\n  void *user_data;\n  cmark_free_func user_data_free_func;\n\n  int start_line;\n  int start_column;\n  int end_line;\n  int end_column;\n  int internal_offset;\n  uint16_t type;\n  cmark_node_internal_flags flags;\n\n  cmark_syntax_extension *extension;\n\n  union {\n    int ref_ix;\n    int def_count;\n  } footnote;\n\n  cmark_node *parent_footnote_def;\n\n  union {\n    cmark_chunk literal;\n    cmark_list list;\n    cmark_code code;\n    cmark_heading heading;\n    cmark_link link;\n    cmark_custom custom;\n    int html_block_type;\n    void *opaque;\n  } as;\n};\n\n/**\n * Syntax extensions can use this function to register a custom node\n * flag. The flags are stored in the `flags` field of the `cmark_node`\n * struct. The `flags` parameter should be the address of a global variable\n * which will store the flag value.\n */\nCMARK_GFM_EXPORT\nvoid cmark_register_node_flag(cmark_node_internal_flags *flags);\n\n/**\n * DEPRECATED.\n *\n * This function was added in cmark-gfm version 0.29.0.gfm.7, and was\n * required to be called at program start time, which caused\n * backwards-compatibility issues in applications that use cmark-gfm as a\n * library. It is now a no-op.\n */\nCMARK_GFM_EXPORT\nvoid cmark_init_standard_node_flags();\n\nstatic CMARK_INLINE cmark_mem *cmark_node_mem(cmark_node *node) {\n  return node->content.mem;\n}\nCMARK_GFM_EXPORT int cmark_node_check(cmark_node *node, FILE *out);\n\nstatic CMARK_INLINE bool CMARK_NODE_TYPE_BLOCK_P(cmark_node_type node_type) {\n\treturn (node_type & CMARK_NODE_TYPE_MASK) == CMARK_NODE_TYPE_BLOCK;\n}\n\nstatic CMARK_INLINE bool CMARK_NODE_BLOCK_P(cmark_node *node) {\n\treturn node != NULL && CMARK_NODE_TYPE_BLOCK_P((cmark_node_type) node->type);\n}\n\nstatic CMARK_INLINE bool CMARK_NODE_TYPE_INLINE_P(cmark_node_type node_type) {\n\treturn (node_type & CMARK_NODE_TYPE_MASK) == CMARK_NODE_TYPE_INLINE;\n}\n\nstatic CMARK_INLINE bool CMARK_NODE_INLINE_P(cmark_node *node) {\n\treturn node != NULL && CMARK_NODE_TYPE_INLINE_P((cmark_node_type) node->type);\n}\n\nCMARK_GFM_EXPORT bool cmark_node_can_contain_type(cmark_node *node, cmark_node_type child_type);\n\n/**\n * Enable (or disable) extra safety checks. These extra checks cause\n * extra performance overhead (in some cases quadratic), so they are only\n * intended to be used during testing.\n */\nCMARK_GFM_EXPORT void cmark_enable_safety_checks(bool enable);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#ifndef CMARK_PARSER_H\n#define CMARK_PARSER_H\n\n#include <stdio.h>\n#include \"references.h\"\n#include \"node.h\"\n#include \"buffer.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define MAX_LINK_LABEL_LENGTH 1000\n\nstruct cmark_parser {\n  struct cmark_mem *mem;\n  /* A hashtable of urls in the current document for cross-references */\n  struct cmark_map *refmap;\n  /* The root node of the parser, always a CMARK_NODE_DOCUMENT */\n  struct cmark_node *root;\n  /* The last open block after a line is fully processed */\n  struct cmark_node *current;\n  /* See the documentation for cmark_parser_get_line_number() in cmark.h */\n  int line_number;\n  /* See the documentation for cmark_parser_get_offset() in cmark.h */\n  bufsize_t offset;\n  /* See the documentation for cmark_parser_get_column() in cmark.h */\n  bufsize_t column;\n  /* See the documentation for cmark_parser_get_first_nonspace() in cmark.h */\n  bufsize_t first_nonspace;\n  /* See the documentation for cmark_parser_get_first_nonspace_column() in cmark.h */\n  bufsize_t first_nonspace_column;\n  bufsize_t thematic_break_kill_pos;\n  /* See the documentation for cmark_parser_get_indent() in cmark.h */\n  int indent;\n  /* See the documentation for cmark_parser_is_blank() in cmark.h */\n  bool blank;\n  /* See the documentation for cmark_parser_has_partially_consumed_tab() in cmark.h */\n  bool partially_consumed_tab;\n  /* Contains the currently processed line */\n  cmark_strbuf curline;\n  /* See the documentation for cmark_parser_get_last_line_length() in cmark.h */\n  bufsize_t last_line_length;\n  /* FIXME: not sure about the difference with curline */\n  cmark_strbuf linebuf;\n  /* Options set by the user, see the Options section in cmark.h */\n  int options;\n  bool last_buffer_ended_with_cr;\n  size_t total_size;\n  cmark_llist *syntax_extensions;\n  cmark_llist *inline_syntax_extensions;\n  cmark_ispunct_func backslash_ispunct;\n\n  /**\n   * The \"open\" blocks are the blocks visited by the loop in\n   * check_open_blocks (blocks.c). I.e. the blocks in this list:\n   *\n   *   parser->root->last_child->...->last_child\n   *\n   * open_block_counts is used to keep track of how many of each type of\n   * node are currently in the open blocks list. Knowing these counts can\n   * sometimes help to end the loop in check_open_blocks early, improving\n   * efficiency.\n   *\n   * The count is stored at this offset: type - CMARK_NODE_TYPE_BLOCK - 1\n   * For example, CMARK_NODE_LIST (0x8003) is stored at offset 2.\n   */\n  size_t open_block_counts[CMARK_NODE_TYPE_BLOCK_LIMIT];\n  size_t total_open_blocks;\n};\n\nstatic CMARK_INLINE void incr_open_block_count(cmark_parser *parser, cmark_node_type type) {\n  assert(type > CMARK_NODE_TYPE_BLOCK);\n  assert(type <= CMARK_NODE_TYPE_BLOCK + CMARK_NODE_TYPE_BLOCK_LIMIT);\n  parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1]++;\n  parser->total_open_blocks++;\n}\n\nstatic CMARK_INLINE void decr_open_block_count(cmark_parser *parser, cmark_node_type type) {\n  assert(type > CMARK_NODE_TYPE_BLOCK);\n  assert(type <= CMARK_NODE_TYPE_BLOCK + CMARK_NODE_TYPE_BLOCK_LIMIT);\n  assert(parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1] > 0);\n  parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1]--;\n  assert(parser->total_open_blocks > 0);\n  parser->total_open_blocks--;\n}\n\nstatic CMARK_INLINE size_t read_open_block_count(cmark_parser *parser, cmark_node_type type) {\n  assert(type > CMARK_NODE_TYPE_BLOCK);\n  assert(type <= CMARK_NODE_TYPE_BLOCK + CMARK_NODE_TYPE_BLOCK_LIMIT);\n  return parser->open_block_counts[type - CMARK_NODE_TYPE_BLOCK - 1];\n}\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n", "#include <stdlib.h>\n#include <assert.h>\n\n#include \"cmark-gfm.h\"\n#include \"syntax_extension.h\"\n#include \"buffer.h\"\n\nextern cmark_mem CMARK_DEFAULT_MEM_ALLOCATOR;\n\nstatic cmark_mem *_mem = &CMARK_DEFAULT_MEM_ALLOCATOR;\n\nvoid cmark_syntax_extension_free(cmark_mem *mem, cmark_syntax_extension *extension) {\n  if (extension->free_function && extension->priv) {\n    extension->free_function(mem, extension->priv);\n  }\n\n  cmark_llist_free(mem, extension->special_inline_chars);\n  mem->free(extension->name);\n  mem->free(extension);\n}\n\ncmark_syntax_extension *cmark_syntax_extension_new(const char *name) {\n  cmark_syntax_extension *res = (cmark_syntax_extension *) _mem->calloc(1, sizeof(cmark_syntax_extension));\n  res->name = (char *) _mem->calloc(1, sizeof(char) * (strlen(name)) + 1);\n  strcpy(res->name, name);\n  return res;\n}\n\ncmark_node_type cmark_syntax_extension_add_node(int is_inline) {\n  cmark_node_type *ref = !is_inline ? &CMARK_NODE_LAST_BLOCK : &CMARK_NODE_LAST_INLINE;\n\n  if ((*ref & CMARK_NODE_VALUE_MASK) >= CMARK_NODE_TYPE_BLOCK_LIMIT) {\n    // This assertion will fail if you try to register more extensions than\n    // are currently allowed by CMARK_NODE_TYPE_BLOCK_MAXNUM. Try increasing\n    // the limit.\n    assert(false);\n    return (cmark_node_type) 0;\n  }\n\n  return *ref = (cmark_node_type) ((int) *ref + 1);\n}\n\nvoid cmark_syntax_extension_set_emphasis(cmark_syntax_extension *extension,\n                                         int emphasis) {\n  extension->emphasis = emphasis == 1;\n}\n\nvoid cmark_syntax_extension_set_open_block_func(cmark_syntax_extension *extension,\n                                                cmark_open_block_func func) {\n  extension->try_opening_block = func;\n}\n\nvoid cmark_syntax_extension_set_match_block_func(cmark_syntax_extension *extension,\n                                                 cmark_match_block_func func) {\n  extension->last_block_matches = func;\n}\n\nvoid cmark_syntax_extension_set_match_inline_func(cmark_syntax_extension *extension,\n                                                  cmark_match_inline_func func) {\n  extension->match_inline = func;\n}\n\nvoid cmark_syntax_extension_set_inline_from_delim_func(cmark_syntax_extension *extension,\n                                                       cmark_inline_from_delim_func func) {\n  extension->insert_inline_from_delim = func;\n}\n\nvoid cmark_syntax_extension_set_special_inline_chars(cmark_syntax_extension *extension,\n                                                     cmark_llist *special_chars) {\n  extension->special_inline_chars = special_chars;\n}\n\nvoid cmark_syntax_extension_set_get_type_string_func(cmark_syntax_extension *extension,\n                                                     cmark_get_type_string_func func) {\n  extension->get_type_string_func = func;\n}\n\nvoid cmark_syntax_extension_set_can_contain_func(cmark_syntax_extension *extension,\n                                                 cmark_can_contain_func func) {\n  extension->can_contain_func = func;\n}\n\nvoid cmark_syntax_extension_set_contains_inlines_func(cmark_syntax_extension *extension,\n                                                      cmark_contains_inlines_func func) {\n  extension->contains_inlines_func = func;\n}\n\nvoid cmark_syntax_extension_set_commonmark_render_func(cmark_syntax_extension *extension,\n                                                       cmark_common_render_func func) {\n  extension->commonmark_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_plaintext_render_func(cmark_syntax_extension *extension,\n                                                      cmark_common_render_func func) {\n  extension->plaintext_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_latex_render_func(cmark_syntax_extension *extension,\n                                                  cmark_common_render_func func) {\n  extension->latex_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_xml_attr_func(cmark_syntax_extension *extension,\n                                              cmark_xml_attr_func func) {\n  extension->xml_attr_func = func;\n}\n\nvoid cmark_syntax_extension_set_man_render_func(cmark_syntax_extension *extension,\n                                                cmark_common_render_func func) {\n  extension->man_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_html_render_func(cmark_syntax_extension *extension,\n                                                 cmark_html_render_func func) {\n  extension->html_render_func = func;\n}\n\nvoid cmark_syntax_extension_set_html_filter_func(cmark_syntax_extension *extension,\n                                                 cmark_html_filter_func func) {\n  extension->html_filter_func = func;\n}\n\nvoid cmark_syntax_extension_set_postprocess_func(cmark_syntax_extension *extension,\n                                                 cmark_postprocess_func func) {\n  extension->postprocess_func = func;\n}\n\nvoid cmark_syntax_extension_set_private(cmark_syntax_extension *extension,\n                                        void *priv,\n                                        cmark_free_func free_func) {\n  extension->priv = priv;\n  extension->free_function = free_func;\n}\n\nvoid *cmark_syntax_extension_get_private(cmark_syntax_extension *extension) {\n    return extension->priv;\n}\n\nvoid cmark_syntax_extension_set_opaque_alloc_func(cmark_syntax_extension *extension,\n                                                  cmark_opaque_alloc_func func) {\n  extension->opaque_alloc_func = func;\n}\n\nvoid cmark_syntax_extension_set_opaque_free_func(cmark_syntax_extension *extension,\n                                                 cmark_opaque_free_func func) {\n  extension->opaque_free_func = func;\n}\n\nvoid cmark_syntax_extension_set_commonmark_escape_func(cmark_syntax_extension *extension,\n                                                       cmark_commonmark_escape_func func) {\n  extension->commonmark_escape_func = func;\n}\n"], "filenames": ["api_test/main.c", "extensions/table.c", "src/blocks.c", "src/cmark-gfm.h", "src/node.c", "src/node.h", "src/parser.h", "src/syntax_extension.c"], "buggy_code_start_loc": [1135, 313, 72, 38, 6, 53, 52, 32], "buggy_code_end_loc": [1135, 318, 1480, 38, 90, 146, 53, 33], "fixing_code_start_loc": [1136, 314, 73, 39, 7, 53, 53, 32], "fixing_code_end_loc": [1137, 325, 1576, 49, 100, 155, 93, 36], "type": "CWE-400", "message": "cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering library and program in C. A polynomial time complexity issue in cmark-gfm may lead to unbounded resource exhaustion and subsequent denial of service. This CVE covers quadratic complexity issues when parsing text which leads with either large numbers of `>` or `-` characters. This issue has been addressed in version 0.29.0.gfm.10. Users are advised to upgrade. Users unable to upgrade should validate that their input comes from trusted sources.", "other": {"cve": {"id": "CVE-2023-24824", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-31T23:15:07.153", "lastModified": "2023-04-11T06:25:18.527", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "cmark-gfm is GitHub's fork of cmark, a CommonMark parsing and rendering library and program in C. A polynomial time complexity issue in cmark-gfm may lead to unbounded resource exhaustion and subsequent denial of service. This CVE covers quadratic complexity issues when parsing text which leads with either large numbers of `>` or `-` characters. This issue has been addressed in version 0.29.0.gfm.10. Users are advised to upgrade. Users unable to upgrade should validate that their input comes from trusted sources."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}, {"lang": "en", "value": "CWE-407"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:github:cmark-gfm:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.29.0.gfm.10.", "matchCriteriaId": "D388F6C5-34DD-4C62-9D86-0E10F97FC4EB"}]}]}], "references": [{"url": "https://github.com/github/cmark-gfm/commit/2300c1bd2c8226108885bf019655c4159cf26b59", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/github/cmark-gfm/security/advisories/GHSA-66g8-4hjf-77xh", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/github/cmark-gfm/commit/2300c1bd2c8226108885bf019655c4159cf26b59"}}