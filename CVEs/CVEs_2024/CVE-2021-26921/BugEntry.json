{"buggy_code": ["package session\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\toidc \"github.com/coreos/go-oidc\"\n\t\"github.com/dgrijalva/jwt-go/v4\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/argoproj/argo-cd/common\"\n\t\"github.com/argoproj/argo-cd/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/server/rbacpolicy\"\n\t\"github.com/argoproj/argo-cd/util/cache/appstate\"\n\t\"github.com/argoproj/argo-cd/util/dex\"\n\t\"github.com/argoproj/argo-cd/util/env\"\n\thttputil \"github.com/argoproj/argo-cd/util/http\"\n\tjwtutil \"github.com/argoproj/argo-cd/util/jwt\"\n\toidcutil \"github.com/argoproj/argo-cd/util/oidc\"\n\tpasswordutil \"github.com/argoproj/argo-cd/util/password\"\n\t\"github.com/argoproj/argo-cd/util/settings\"\n)\n\n// SessionManager generates and validates JWT tokens for login sessions.\ntype SessionManager struct {\n\tsettingsMgr                   *settings.SettingsManager\n\tprojectsLister                v1alpha1.AppProjectNamespaceLister\n\tclient                        *http.Client\n\tprov                          oidcutil.Provider\n\tstorage                       UserStateStorage\n\tsleep                         func(d time.Duration)\n\tverificationDelayNoiseEnabled bool\n}\n\ntype inMemoryUserStateStorage struct {\n\tattempts map[string]LoginAttempts\n}\n\nfunc NewInMemoryUserStateStorage() *inMemoryUserStateStorage {\n\treturn &inMemoryUserStateStorage{attempts: map[string]LoginAttempts{}}\n}\n\nfunc (storage *inMemoryUserStateStorage) GetLoginAttempts(attempts *map[string]LoginAttempts) error {\n\t*attempts = storage.attempts\n\treturn nil\n}\n\nfunc (storage *inMemoryUserStateStorage) SetLoginAttempts(attempts map[string]LoginAttempts) error {\n\tstorage.attempts = attempts\n\treturn nil\n}\n\ntype UserStateStorage interface {\n\tGetLoginAttempts(attempts *map[string]LoginAttempts) error\n\tSetLoginAttempts(attempts map[string]LoginAttempts) error\n}\n\n// LoginAttempts is a timestamped counter for failed login attempts\ntype LoginAttempts struct {\n\t// Time of the last failed login\n\tLastFailed time.Time `json:\"lastFailed\"`\n\t// Number of consecutive login failures\n\tFailCount int `json:\"failCount\"`\n}\n\nconst (\n\t// SessionManagerClaimsIssuer fills the \"iss\" field of the token.\n\tSessionManagerClaimsIssuer = \"argocd\"\n\n\t// invalidLoginError, for security purposes, doesn't say whether the username or password was invalid.  This does not mitigate the potential for timing attacks to determine which is which.\n\tinvalidLoginError         = \"Invalid username or password\"\n\tblankPasswordError        = \"Blank passwords are not allowed\"\n\taccountDisabled           = \"Account %s is disabled\"\n\tusernameTooLongError      = \"Username is too long (%d bytes max)\"\n\tuserDoesNotHaveCapability = \"Account %s does not have %s capability\"\n)\n\nconst (\n\t// Maximum length of username, too keep the cache's memory signature low\n\tmaxUsernameLength = 32\n\t// The default maximum session cache size\n\tdefaultMaxCacheSize = 1000\n\t// The default number of maximum login failures before delay kicks in\n\tdefaultMaxLoginFailures = 5\n\t// The default time in seconds for the failure window\n\tdefaultFailureWindow = 300\n\t// The password verification delay max\n\tverificationDelayNoiseMin = 500 * time.Millisecond\n\t// The password verification delay max\n\tverificationDelayNoiseMax = 1000 * time.Millisecond\n\n\t// environment variables to control rate limiter behaviour:\n\n\t// Max number of login failures before login delay kicks in\n\tenvLoginMaxFailCount = \"ARGOCD_SESSION_FAILURE_MAX_FAIL_COUNT\"\n\n\t// Number of maximum seconds the login is allowed to delay for. Default: 300 (5 minutes).\n\tenvLoginFailureWindowSeconds = \"ARGOCD_SESSION_FAILURE_WINDOW_SECONDS\"\n\n\t// Max number of stored usernames\n\tenvLoginMaxCacheSize = \"ARGOCD_SESSION_MAX_CACHE_SIZE\"\n)\n\nvar (\n\tInvalidLoginErr = status.Errorf(codes.Unauthenticated, invalidLoginError)\n)\n\n// Returns the maximum cache size as number of entries\nfunc getMaximumCacheSize() int {\n\treturn env.ParseNumFromEnv(envLoginMaxCacheSize, defaultMaxCacheSize, 1, math.MaxInt32)\n}\n\n// Returns the maximum number of login failures before login delay kicks in\nfunc getMaxLoginFailures() int {\n\treturn env.ParseNumFromEnv(envLoginMaxFailCount, defaultMaxLoginFailures, 1, math.MaxInt32)\n}\n\n// Returns the number of maximum seconds the login is allowed to delay for\nfunc getLoginFailureWindow() time.Duration {\n\treturn time.Duration(env.ParseNumFromEnv(envLoginFailureWindowSeconds, defaultFailureWindow, 0, math.MaxInt32))\n}\n\n// NewSessionManager creates a new session manager from Argo CD settings\nfunc NewSessionManager(settingsMgr *settings.SettingsManager, projectsLister v1alpha1.AppProjectNamespaceLister, dexServerAddr string, storage UserStateStorage) *SessionManager {\n\ts := SessionManager{\n\t\tsettingsMgr:                   settingsMgr,\n\t\tstorage:                       storage,\n\t\tsleep:                         time.Sleep,\n\t\tprojectsLister:                projectsLister,\n\t\tverificationDelayNoiseEnabled: true,\n\t}\n\tsettings, err := settingsMgr.GetSettings()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttlsConfig := settings.TLSConfig()\n\tif tlsConfig != nil {\n\t\ttlsConfig.InsecureSkipVerify = true\n\t}\n\ts.client = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t\tProxy:           http.ProxyFromEnvironment,\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t},\n\t}\n\tif settings.DexConfig != \"\" {\n\t\ts.client.Transport = dex.NewDexRewriteURLRoundTripper(dexServerAddr, s.client.Transport)\n\t}\n\tif os.Getenv(common.EnvVarSSODebug) == \"1\" {\n\t\ts.client.Transport = httputil.DebugTransport{T: s.client.Transport}\n\t}\n\n\treturn &s\n}\n\n// Create creates a new token for a given subject (user) and returns it as a string.\n// Passing a value of `0` for secondsBeforeExpiry creates a token that never expires.\n// The id parameter holds an optional unique JWT token identifier and stored as a standard claim \"jti\" in the JWT token.\nfunc (mgr *SessionManager) Create(subject string, secondsBeforeExpiry int64, id string) (string, error) {\n\t// Create a new token object, specifying signing method and the claims\n\t// you would like it to contain.\n\tnow := time.Now().UTC()\n\tclaims := jwt.StandardClaims{\n\t\tIssuedAt:  jwt.At(now),\n\t\tIssuer:    SessionManagerClaimsIssuer,\n\t\tNotBefore: jwt.At(now),\n\t\tSubject:   subject,\n\t\tID:        id,\n\t}\n\tif secondsBeforeExpiry > 0 {\n\t\texpires := now.Add(time.Duration(secondsBeforeExpiry) * time.Second)\n\t\tclaims.ExpiresAt = jwt.At(expires)\n\t}\n\n\treturn mgr.signClaims(claims)\n}\n\ntype standardClaims struct {\n\tAudience  jwt.ClaimStrings `json:\"aud,omitempty\"`\n\tExpiresAt int64            `json:\"exp,omitempty\"`\n\tID        string           `json:\"jti,omitempty\"`\n\tIssuedAt  int64            `json:\"iat,omitempty\"`\n\tIssuer    string           `json:\"iss,omitempty\"`\n\tNotBefore int64            `json:\"nbf,omitempty\"`\n\tSubject   string           `json:\"sub,omitempty\"`\n}\n\nfunc unixTimeOrZero(t *jwt.Time) int64 {\n\tif t == nil {\n\t\treturn 0\n\t}\n\treturn t.Unix()\n}\n\nfunc (mgr *SessionManager) signClaims(claims jwt.Claims) (string, error) {\n\t// log.Infof(\"Issuing claims: %v\", claims)\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// workaround for https://github.com/argoproj/argo-cd/issues/5217\n\t// According to https://tools.ietf.org/html/rfc7519#section-4.1.6 \"iat\" and other time fields must contain\n\t// number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time.\n\t// The https://github.com/dgrijalva/jwt-go marshals time as non integer.\n\treturn token.SignedString(settings.ServerSignature, jwt.WithMarshaller(func(ctx jwt.CodingContext, v interface{}) ([]byte, error) {\n\t\tif std, ok := v.(jwt.StandardClaims); ok {\n\t\t\treturn json.Marshal(standardClaims{\n\t\t\t\tAudience:  std.Audience,\n\t\t\t\tExpiresAt: unixTimeOrZero(std.ExpiresAt),\n\t\t\t\tID:        std.ID,\n\t\t\t\tIssuedAt:  unixTimeOrZero(std.IssuedAt),\n\t\t\t\tIssuer:    std.Issuer,\n\t\t\t\tNotBefore: unixTimeOrZero(std.NotBefore),\n\t\t\t\tSubject:   std.Subject,\n\t\t\t})\n\t\t}\n\t\treturn json.Marshal(v)\n\t}))\n}\n\n// Parse tries to parse the provided string and returns the token claims for local login.\nfunc (mgr *SessionManager) Parse(tokenString string) (jwt.Claims, error) {\n\t// Parse takes the token string and a function for looking up the key. The latter is especially\n\t// useful if you use multiple keys for your application.  The standard is to use 'kid' in the\n\t// head of the token to identify which key to use, but the parsed token (head and claims) is provided\n\t// to the callback, providing flexibility.\n\tvar claims jwt.MapClaims\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttoken, err := jwt.ParseWithClaims(tokenString, &claims, func(token *jwt.Token) (interface{}, error) {\n\t\t// Don't forget to validate the alg is what you expect:\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn settings.ServerSignature, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tissuedAt, err := jwtutil.IssuedAtTime(claims)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubject := jwtutil.StringField(claims, \"sub\")\n\tid := jwtutil.StringField(claims, \"jti\")\n\n\tif projName, role, ok := rbacpolicy.GetProjectRoleFromSubject(subject); ok {\n\t\tproj, err := mgr.projectsLister.Get(projName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t_, _, err = proj.GetJWTToken(role, issuedAt.Unix(), id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn token.Claims, nil\n\t}\n\n\taccount, err := mgr.settingsMgr.GetAccount(subject)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif id := jwtutil.StringField(claims, \"jti\"); id != \"\" && account.TokenIndex(id) == -1 {\n\t\treturn nil, fmt.Errorf(\"account %s does not have token with id %s\", subject, id)\n\t}\n\n\tif account.PasswordMtime != nil && issuedAt.Before(*account.PasswordMtime) {\n\t\treturn nil, fmt.Errorf(\"Account password has changed since token issued\")\n\t}\n\treturn token.Claims, nil\n}\n\n// GetLoginFailures retrieves the login failure information from the cache\nfunc (mgr *SessionManager) GetLoginFailures() map[string]LoginAttempts {\n\t// Get failures from the cache\n\tvar failures map[string]LoginAttempts\n\terr := mgr.storage.GetLoginAttempts(&failures)\n\tif err != nil {\n\t\tif err != appstate.ErrCacheMiss {\n\t\t\tlog.Errorf(\"Could not retrieve login attempts: %v\", err)\n\t\t}\n\t\tfailures = make(map[string]LoginAttempts)\n\t}\n\n\treturn failures\n}\n\nfunc expireOldFailedAttempts(maxAge time.Duration, failures *map[string]LoginAttempts) int {\n\texpiredCount := 0\n\tfor key, attempt := range *failures {\n\t\tif time.Since(attempt.LastFailed) > maxAge*time.Second {\n\t\t\texpiredCount += 1\n\t\t\tdelete(*failures, key)\n\t\t}\n\t}\n\treturn expiredCount\n}\n\n// Updates the failure count for a given username. If failed is true, increases the counter. Otherwise, sets counter back to 0.\nfunc (mgr *SessionManager) updateFailureCount(username string, failed bool) {\n\n\tfailures := mgr.GetLoginFailures()\n\n\t// Expire old entries in the cache if we have a failure window defined.\n\tif window := getLoginFailureWindow(); window > 0 {\n\t\tcount := expireOldFailedAttempts(window, &failures)\n\t\tif count > 0 {\n\t\t\tlog.Infof(\"Expired %d entries from session cache due to max age reached\", count)\n\t\t}\n\t}\n\n\t// If we exceed a certain cache size, we need to remove random entries to\n\t// prevent overbloating the cache with fake entries, as this could lead to\n\t// memory exhaustion and ultimately in a DoS. We remove a single entry to\n\t// replace it with the new one.\n\t//\n\t// Chances are that we remove the one that is under active attack, but this\n\t// chance is low (1:cache_size)\n\tif failed && len(failures) >= getMaximumCacheSize() {\n\t\tlog.Warnf(\"Session cache size exceeds %d entries, removing random entry\", getMaximumCacheSize())\n\t\tidx := rand.Intn(len(failures) - 1)\n\t\tvar rmUser string\n\t\ti := 0\n\t\tfor key := range failures {\n\t\t\tif i == idx {\n\t\t\t\trmUser = key\n\t\t\t\tdelete(failures, key)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\tlog.Infof(\"Deleted entry for user %s from cache\", rmUser)\n\t}\n\n\tattempt, ok := failures[username]\n\tif !ok {\n\t\tattempt = LoginAttempts{FailCount: 0}\n\t}\n\n\t// On login failure, increase fail count and update last failed timestamp.\n\t// On login success, remove the entry from the cache.\n\tif failed {\n\t\tattempt.FailCount += 1\n\t\tattempt.LastFailed = time.Now()\n\t\tfailures[username] = attempt\n\t\tlog.Warnf(\"User %s failed login %d time(s)\", username, attempt.FailCount)\n\t} else {\n\t\tif attempt.FailCount > 0 {\n\t\t\t// Forget username for cache size enforcement, since entry in cache was deleted\n\t\t\tdelete(failures, username)\n\t\t}\n\t}\n\n\terr := mgr.storage.SetLoginAttempts(failures)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not update login attempts: %v\", err)\n\t}\n\n}\n\n// Get the current login failure attempts for given username\nfunc (mgr *SessionManager) getFailureCount(username string) LoginAttempts {\n\tfailures := mgr.GetLoginFailures()\n\tattempt, ok := failures[username]\n\tif !ok {\n\t\tattempt = LoginAttempts{FailCount: 0}\n\t}\n\treturn attempt\n}\n\n// Calculate a login delay for the given login attempt\nfunc (mgr *SessionManager) exceededFailedLoginAttempts(attempt LoginAttempts) bool {\n\tmaxFails := getMaxLoginFailures()\n\tfailureWindow := getLoginFailureWindow()\n\n\t// Whether we are in the failure window for given attempt\n\tinWindow := func() bool {\n\t\tif failureWindow == 0 || time.Since(attempt.LastFailed).Seconds() <= float64(failureWindow) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t// If we reached max failed attempts within failure window, we need to calc the delay\n\tif attempt.FailCount >= maxFails && inWindow() {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// VerifyUsernamePassword verifies if a username/password combo is correct\nfunc (mgr *SessionManager) VerifyUsernamePassword(username string, password string) error {\n\tif password == \"\" {\n\t\treturn status.Errorf(codes.Unauthenticated, blankPasswordError)\n\t}\n\t// Enforce maximum length of username on local accounts\n\tif len(username) > maxUsernameLength {\n\t\treturn status.Errorf(codes.InvalidArgument, usernameTooLongError, maxUsernameLength)\n\t}\n\n\tstart := time.Now()\n\tif mgr.verificationDelayNoiseEnabled {\n\t\tdefer func() {\n\t\t\t// introduces random delay to protect from timing-based user enumeration attack\n\t\t\tdelayNanoseconds := verificationDelayNoiseMin.Nanoseconds() +\n\t\t\t\tint64(rand.Intn(int(verificationDelayNoiseMax.Nanoseconds()-verificationDelayNoiseMin.Nanoseconds())))\n\t\t\t\t// take into account amount of time spent since the request start\n\t\t\tdelayNanoseconds = delayNanoseconds - time.Since(start).Nanoseconds()\n\t\t\tif delayNanoseconds > 0 {\n\t\t\t\tmgr.sleep(time.Duration(delayNanoseconds))\n\t\t\t}\n\t\t}()\n\t}\n\n\tattempt := mgr.getFailureCount(username)\n\tif mgr.exceededFailedLoginAttempts(attempt) {\n\t\tlog.Warnf(\"User %s had too many failed logins (%d)\", username, attempt.FailCount)\n\t\treturn InvalidLoginErr\n\t}\n\n\taccount, err := mgr.settingsMgr.GetAccount(username)\n\tif err != nil {\n\t\tif errStatus, ok := status.FromError(err); ok && errStatus.Code() == codes.NotFound {\n\t\t\tmgr.updateFailureCount(username, true)\n\t\t\terr = InvalidLoginErr\n\t\t}\n\t\t// to prevent time-based user enumeration, we must perform a password\n\t\t// hash cycle to keep response time consistent (if the function were\n\t\t// to continue and not return here)\n\t\t_, _ = passwordutil.HashPassword(\"for_consistent_response_time\")\n\t\treturn err\n\t}\n\n\tvalid, _ := passwordutil.VerifyPassword(password, account.PasswordHash)\n\tif !valid {\n\t\tmgr.updateFailureCount(username, true)\n\t\treturn InvalidLoginErr\n\t}\n\n\tif !account.Enabled {\n\t\treturn status.Errorf(codes.Unauthenticated, accountDisabled, username)\n\t}\n\n\tif !account.HasCapability(settings.AccountCapabilityLogin) {\n\t\treturn status.Errorf(codes.Unauthenticated, userDoesNotHaveCapability, username, settings.AccountCapabilityLogin)\n\t}\n\tmgr.updateFailureCount(username, false)\n\treturn nil\n}\n\n// VerifyToken verifies if a token is correct. Tokens can be issued either from us or by an IDP.\n// We choose how to verify based on the issuer.\nfunc (mgr *SessionManager) VerifyToken(tokenString string) (jwt.Claims, error) {\n\tparser := &jwt.Parser{\n\t\tValidationHelper: jwt.NewValidationHelper(jwt.WithoutClaimsValidation()),\n\t}\n\tvar claims jwt.StandardClaims\n\t_, _, err := parser.ParseUnverified(tokenString, &claims)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch claims.Issuer {\n\tcase SessionManagerClaimsIssuer:\n\t\t// Argo CD signed token\n\t\treturn mgr.Parse(tokenString)\n\tdefault:\n\t\t// IDP signed token\n\t\tprov, err := mgr.provider()\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\n\t\t// Token must be verified for at least one audience\n\t\t// TODO(jannfis): Is this the right way? Shouldn't we know our audience and only validate for the correct one?\n\t\tvar idToken *oidc.IDToken\n\t\tfor _, aud := range claims.Audience {\n\t\t\tidToken, err = prov.Verify(aud, tokenString)\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\t\tvar claims jwt.MapClaims\n\t\terr = idToken.Claims(&claims)\n\t\treturn claims, err\n\t}\n}\n\nfunc (mgr *SessionManager) provider() (oidcutil.Provider, error) {\n\tif mgr.prov != nil {\n\t\treturn mgr.prov, nil\n\t}\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !settings.IsSSOConfigured() {\n\t\treturn nil, fmt.Errorf(\"SSO is not configured\")\n\t}\n\tmgr.prov = oidcutil.NewOIDCProvider(settings.IssuerURL(), mgr.client)\n\treturn mgr.prov, nil\n}\n\nfunc LoggedIn(ctx context.Context) bool {\n\treturn Sub(ctx) != \"\"\n}\n\n// Username is a helper to extract a human readable username from a context\nfunc Username(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tswitch jwtutil.StringField(mapClaims, \"iss\") {\n\tcase SessionManagerClaimsIssuer:\n\t\treturn jwtutil.StringField(mapClaims, \"sub\")\n\tdefault:\n\t\treturn jwtutil.StringField(mapClaims, \"email\")\n\t}\n}\n\nfunc Iss(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.StringField(mapClaims, \"iss\")\n}\n\nfunc Iat(ctx context.Context) (time.Time, error) {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn time.Time{}, errors.New(\"unable to extract token claims\")\n\t}\n\treturn jwtutil.IssuedAtTime(mapClaims)\n}\n\nfunc Sub(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.StringField(mapClaims, \"sub\")\n}\n\nfunc Groups(ctx context.Context, scopes []string) []string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn jwtutil.GetGroups(mapClaims, scopes)\n}\n\nfunc mapClaims(ctx context.Context) (jwt.MapClaims, bool) {\n\tclaims, ok := ctx.Value(\"claims\").(jwt.Claims)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\tmapClaims, err := jwtutil.MapClaims(claims)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\treturn mapClaims, true\n}\n", "package session\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go/v4\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\n\t\"github.com/argoproj/argo-cd/common\"\n\tappv1 \"github.com/argoproj/argo-cd/pkg/apis/application/v1alpha1\"\n\tapps \"github.com/argoproj/argo-cd/pkg/client/clientset/versioned/fake\"\n\t\"github.com/argoproj/argo-cd/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/test\"\n\t\"github.com/argoproj/argo-cd/util/errors\"\n\t\"github.com/argoproj/argo-cd/util/password\"\n\t\"github.com/argoproj/argo-cd/util/settings\"\n)\n\nfunc getProjLister(objects ...runtime.Object) v1alpha1.AppProjectNamespaceLister {\n\treturn test.NewFakeProjListerFromInterface(apps.NewSimpleClientset(objects...).ArgoprojV1alpha1().AppProjects(\"argocd\"))\n}\n\nfunc getKubeClient(pass string, enabled bool) *fake.Clientset {\n\tconst defaultSecretKey = \"Hello, world!\"\n\n\tbcrypt, err := password.HashPassword(pass)\n\terrors.CheckError(err)\n\n\treturn fake.NewSimpleClientset(&corev1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-cm\",\n\t\t\tNamespace: \"argocd\",\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{\n\t\t\t\"admin.enabled\": strconv.FormatBool(enabled),\n\t\t},\n\t}, &corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-secret\",\n\t\t\tNamespace: \"argocd\",\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   []byte(bcrypt),\n\t\t\t\"server.secretkey\": []byte(defaultSecretKey),\n\t\t},\n\t})\n}\n\nfunc newSessionManager(settingsMgr *settings.SettingsManager, projectLister v1alpha1.AppProjectNamespaceLister, storage UserStateStorage) *SessionManager {\n\tmgr := NewSessionManager(settingsMgr, projectLister, \"\", storage)\n\tmgr.verificationDelayNoiseEnabled = false\n\treturn mgr\n}\n\nfunc TestSessionManager_AdminToken(t *testing.T) {\n\tconst (\n\t\tdefaultSubject = \"admin\"\n\t)\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"pass\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\ttoken, err := mgr.Create(defaultSubject, 0, \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Could not create token: %v\", err)\n\t}\n\n\tclaims, err := mgr.Parse(token)\n\tif err != nil {\n\t\tt.Errorf(\"Could not parse token: %v\", err)\n\t}\n\n\tmapClaims := *(claims.(*jwt.MapClaims))\n\tsubject := mapClaims[\"sub\"].(string)\n\tif subject != \"admin\" {\n\t\tt.Errorf(\"Token claim subject \\\"%s\\\" does not match expected subject \\\"%s\\\".\", subject, defaultSubject)\n\t}\n}\n\nfunc TestSessionManager_ProjectToken(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"pass\", true), \"argocd\")\n\n\tt.Run(\"Valid Token\", func(t *testing.T) {\n\t\tproj := appv1.AppProject{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName:      \"default\",\n\t\t\t\tNamespace: \"argocd\",\n\t\t\t},\n\t\t\tSpec: appv1.AppProjectSpec{Roles: []appv1.ProjectRole{{Name: \"test\"}}},\n\t\t\tStatus: appv1.AppProjectStatus{JWTTokensByRole: map[string]appv1.JWTTokens{\n\t\t\t\t\"test\": {\n\t\t\t\t\tItems: []appv1.JWTToken{{ID: \"abc\", IssuedAt: time.Now().Unix(), ExpiresAt: 0}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}\n\t\tmgr := newSessionManager(settingsMgr, getProjLister(&proj), NewInMemoryUserStateStorage())\n\n\t\tjwtToken, err := mgr.Create(\"proj:default:test\", 100, \"abc\")\n\t\trequire.NoError(t, err)\n\n\t\t_, err = mgr.Parse(jwtToken)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"Token Revoked\", func(t *testing.T) {\n\t\tproj := appv1.AppProject{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName:      \"default\",\n\t\t\t\tNamespace: \"argocd\",\n\t\t\t},\n\t\t\tSpec: appv1.AppProjectSpec{Roles: []appv1.ProjectRole{{Name: \"test\"}}},\n\t\t}\n\n\t\tmgr := newSessionManager(settingsMgr, getProjLister(&proj), NewInMemoryUserStateStorage())\n\n\t\tjwtToken, err := mgr.Create(\"proj:default:test\", 10, \"\")\n\t\trequire.NoError(t, err)\n\n\t\t_, err = mgr.Parse(jwtToken)\n\t\trequire.Error(t, err)\n\n\t\tassert.Contains(t, err.Error(), \"does not exist in project 'default'\")\n\t})\n}\n\nvar loggedOutContext = context.Background()\n\n// nolint:staticcheck\nvar loggedInContext = context.WithValue(context.Background(), \"claims\", &jwt.MapClaims{\"iss\": \"qux\", \"sub\": \"foo\", \"email\": \"bar\", \"groups\": []string{\"baz\"}})\n\nfunc TestIss(t *testing.T) {\n\tassert.Empty(t, Iss(loggedOutContext))\n\tassert.Equal(t, \"qux\", Iss(loggedInContext))\n}\nfunc TestLoggedIn(t *testing.T) {\n\tassert.False(t, LoggedIn(loggedOutContext))\n\tassert.True(t, LoggedIn(loggedInContext))\n}\n\nfunc TestUsername(t *testing.T) {\n\tassert.Empty(t, Username(loggedOutContext))\n\tassert.Equal(t, \"bar\", Username(loggedInContext))\n}\n\nfunc TestSub(t *testing.T) {\n\tassert.Empty(t, Sub(loggedOutContext))\n\tassert.Equal(t, \"foo\", Sub(loggedInContext))\n}\n\nfunc TestGroups(t *testing.T) {\n\tassert.Empty(t, Groups(loggedOutContext, []string{\"groups\"}))\n\tassert.Equal(t, []string{\"baz\"}, Groups(loggedInContext, []string{\"groups\"}))\n}\n\nfunc TestVerifyUsernamePassword(t *testing.T) {\n\tconst password = \"password\"\n\n\tfor _, tc := range []struct {\n\t\tname     string\n\t\tdisabled bool\n\t\tuserName string\n\t\tpassword string\n\t\texpected error\n\t}{\n\t\t{\n\t\t\tname:     \"Success if userName and password is correct\",\n\t\t\tdisabled: false,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: password,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Return error if password is empty\",\n\t\t\tdisabled: false,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: \"\",\n\t\t\texpected: status.Errorf(codes.Unauthenticated, blankPasswordError),\n\t\t},\n\t\t{\n\t\t\tname:     \"Return error if password is not correct\",\n\t\t\tdisabled: false,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: \"foo\",\n\t\t\texpected: status.Errorf(codes.Unauthenticated, invalidLoginError),\n\t\t},\n\t\t{\n\t\t\tname:     \"Return error if disableAdmin is true\",\n\t\t\tdisabled: true,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: password,\n\t\t\texpected: status.Errorf(codes.Unauthenticated, accountDisabled, \"admin\"),\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(password, !tc.disabled), \"argocd\")\n\n\t\t\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\t\t\terr := mgr.VerifyUsernamePassword(tc.userName, tc.password)\n\n\t\t\tif tc.expected == nil {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.EqualError(t, err, tc.expected.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCacheValueGetters(t *testing.T) {\n\tt.Run(\"Default values\", func(t *testing.T) {\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\t})\n\n\tt.Run(\"Valid environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, \"5\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"5\")\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, 5, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, 5, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n\tt.Run(\"Invalid environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, \"invalid\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"invalid\")\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n\tt.Run(\"Less than allowed in environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, \"-1\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"-1\")\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n\tt.Run(\"Greater than allowed in environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, fmt.Sprintf(\"%d\", math.MaxInt32+1))\n\t\tos.Setenv(envLoginMaxCacheSize, fmt.Sprintf(\"%d\", math.MaxInt32+1))\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n}\n\nfunc TestLoginRateLimiter(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tstorage := NewInMemoryUserStateStorage()\n\n\tmgr := newSessionManager(settingsMgr, getProjLister(), storage)\n\n\tt.Run(\"Test login delay valid user\", func(t *testing.T) {\n\t\tfor i := 0; i < getMaxLoginFailures(); i++ {\n\t\t\terr := mgr.VerifyUsernamePassword(\"admin\", \"wrong\")\n\t\t\tassert.Error(t, err)\n\t\t}\n\n\t\t// The 11th time should fail even if password is right\n\t\t{\n\t\t\terr := mgr.VerifyUsernamePassword(\"admin\", \"password\")\n\t\t\tassert.Error(t, err)\n\t\t}\n\n\t\tstorage.attempts = map[string]LoginAttempts{}\n\t\t// Failed counter should have been reset, should validate immediately\n\t\t{\n\t\t\terr := mgr.VerifyUsernamePassword(\"admin\", \"password\")\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t})\n\n\tt.Run(\"Test login delay invalid user\", func(t *testing.T) {\n\t\tfor i := 0; i < getMaxLoginFailures(); i++ {\n\t\t\terr := mgr.VerifyUsernamePassword(\"invalid\", \"wrong\")\n\t\t\tassert.Error(t, err)\n\t\t}\n\n\t\terr := mgr.VerifyUsernamePassword(\"invalid\", \"wrong\")\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestMaxUsernameLength(t *testing.T) {\n\tusername := \"\"\n\tfor i := 0; i < maxUsernameLength+1; i++ {\n\t\tusername += \"a\"\n\t}\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\terr := mgr.VerifyUsernamePassword(username, \"password\")\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), fmt.Sprintf(usernameTooLongError, maxUsernameLength))\n}\n\nfunc TestMaxCacheSize(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\tinvalidUsers := []string{\"invalid1\", \"invalid2\", \"invalid3\", \"invalid4\", \"invalid5\", \"invalid6\", \"invalid7\"}\n\t// Temporarily decrease max cache size\n\tos.Setenv(envLoginMaxCacheSize, \"5\")\n\n\tfor _, user := range invalidUsers {\n\t\terr := mgr.VerifyUsernamePassword(user, \"password\")\n\t\tassert.Error(t, err)\n\t}\n\n\tassert.Len(t, mgr.GetLoginFailures(), 5)\n}\n\nfunc TestFailedAttemptsExpiry(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\tinvalidUsers := []string{\"invalid1\", \"invalid2\", \"invalid3\", \"invalid4\", \"invalid5\", \"invalid6\", \"invalid7\"}\n\n\tos.Setenv(envLoginFailureWindowSeconds, \"1\")\n\n\tfor _, user := range invalidUsers {\n\t\terr := mgr.VerifyUsernamePassword(user, \"password\")\n\t\tassert.Error(t, err)\n\t}\n\n\ttime.Sleep(2 * time.Second)\n\n\terr := mgr.VerifyUsernamePassword(\"invalid8\", \"password\")\n\tassert.Error(t, err)\n\tassert.Len(t, mgr.GetLoginFailures(), 1)\n\n\tos.Setenv(envLoginFailureWindowSeconds, \"\")\n}\n"], "fixing_code": ["package session\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n\n\toidc \"github.com/coreos/go-oidc\"\n\t\"github.com/dgrijalva/jwt-go/v4\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\n\t\"github.com/argoproj/argo-cd/common\"\n\t\"github.com/argoproj/argo-cd/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/server/rbacpolicy\"\n\t\"github.com/argoproj/argo-cd/util/cache/appstate\"\n\t\"github.com/argoproj/argo-cd/util/dex\"\n\t\"github.com/argoproj/argo-cd/util/env\"\n\thttputil \"github.com/argoproj/argo-cd/util/http\"\n\tjwtutil \"github.com/argoproj/argo-cd/util/jwt\"\n\toidcutil \"github.com/argoproj/argo-cd/util/oidc\"\n\tpasswordutil \"github.com/argoproj/argo-cd/util/password\"\n\t\"github.com/argoproj/argo-cd/util/settings\"\n)\n\n// SessionManager generates and validates JWT tokens for login sessions.\ntype SessionManager struct {\n\tsettingsMgr                   *settings.SettingsManager\n\tprojectsLister                v1alpha1.AppProjectNamespaceLister\n\tclient                        *http.Client\n\tprov                          oidcutil.Provider\n\tstorage                       UserStateStorage\n\tsleep                         func(d time.Duration)\n\tverificationDelayNoiseEnabled bool\n}\n\ntype inMemoryUserStateStorage struct {\n\tattempts map[string]LoginAttempts\n}\n\nfunc NewInMemoryUserStateStorage() *inMemoryUserStateStorage {\n\treturn &inMemoryUserStateStorage{attempts: map[string]LoginAttempts{}}\n}\n\nfunc (storage *inMemoryUserStateStorage) GetLoginAttempts(attempts *map[string]LoginAttempts) error {\n\t*attempts = storage.attempts\n\treturn nil\n}\n\nfunc (storage *inMemoryUserStateStorage) SetLoginAttempts(attempts map[string]LoginAttempts) error {\n\tstorage.attempts = attempts\n\treturn nil\n}\n\ntype UserStateStorage interface {\n\tGetLoginAttempts(attempts *map[string]LoginAttempts) error\n\tSetLoginAttempts(attempts map[string]LoginAttempts) error\n}\n\n// LoginAttempts is a timestamped counter for failed login attempts\ntype LoginAttempts struct {\n\t// Time of the last failed login\n\tLastFailed time.Time `json:\"lastFailed\"`\n\t// Number of consecutive login failures\n\tFailCount int `json:\"failCount\"`\n}\n\nconst (\n\t// SessionManagerClaimsIssuer fills the \"iss\" field of the token.\n\tSessionManagerClaimsIssuer = \"argocd\"\n\n\t// invalidLoginError, for security purposes, doesn't say whether the username or password was invalid.  This does not mitigate the potential for timing attacks to determine which is which.\n\tinvalidLoginError         = \"Invalid username or password\"\n\tblankPasswordError        = \"Blank passwords are not allowed\"\n\taccountDisabled           = \"Account %s is disabled\"\n\tusernameTooLongError      = \"Username is too long (%d bytes max)\"\n\tuserDoesNotHaveCapability = \"Account %s does not have %s capability\"\n)\n\nconst (\n\t// Maximum length of username, too keep the cache's memory signature low\n\tmaxUsernameLength = 32\n\t// The default maximum session cache size\n\tdefaultMaxCacheSize = 1000\n\t// The default number of maximum login failures before delay kicks in\n\tdefaultMaxLoginFailures = 5\n\t// The default time in seconds for the failure window\n\tdefaultFailureWindow = 300\n\t// The password verification delay max\n\tverificationDelayNoiseMin = 500 * time.Millisecond\n\t// The password verification delay max\n\tverificationDelayNoiseMax = 1000 * time.Millisecond\n\n\t// environment variables to control rate limiter behaviour:\n\n\t// Max number of login failures before login delay kicks in\n\tenvLoginMaxFailCount = \"ARGOCD_SESSION_FAILURE_MAX_FAIL_COUNT\"\n\n\t// Number of maximum seconds the login is allowed to delay for. Default: 300 (5 minutes).\n\tenvLoginFailureWindowSeconds = \"ARGOCD_SESSION_FAILURE_WINDOW_SECONDS\"\n\n\t// Max number of stored usernames\n\tenvLoginMaxCacheSize = \"ARGOCD_SESSION_MAX_CACHE_SIZE\"\n)\n\nvar (\n\tInvalidLoginErr = status.Errorf(codes.Unauthenticated, invalidLoginError)\n)\n\n// Returns the maximum cache size as number of entries\nfunc getMaximumCacheSize() int {\n\treturn env.ParseNumFromEnv(envLoginMaxCacheSize, defaultMaxCacheSize, 1, math.MaxInt32)\n}\n\n// Returns the maximum number of login failures before login delay kicks in\nfunc getMaxLoginFailures() int {\n\treturn env.ParseNumFromEnv(envLoginMaxFailCount, defaultMaxLoginFailures, 1, math.MaxInt32)\n}\n\n// Returns the number of maximum seconds the login is allowed to delay for\nfunc getLoginFailureWindow() time.Duration {\n\treturn time.Duration(env.ParseNumFromEnv(envLoginFailureWindowSeconds, defaultFailureWindow, 0, math.MaxInt32))\n}\n\n// NewSessionManager creates a new session manager from Argo CD settings\nfunc NewSessionManager(settingsMgr *settings.SettingsManager, projectsLister v1alpha1.AppProjectNamespaceLister, dexServerAddr string, storage UserStateStorage) *SessionManager {\n\ts := SessionManager{\n\t\tsettingsMgr:                   settingsMgr,\n\t\tstorage:                       storage,\n\t\tsleep:                         time.Sleep,\n\t\tprojectsLister:                projectsLister,\n\t\tverificationDelayNoiseEnabled: true,\n\t}\n\tsettings, err := settingsMgr.GetSettings()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\ttlsConfig := settings.TLSConfig()\n\tif tlsConfig != nil {\n\t\ttlsConfig.InsecureSkipVerify = true\n\t}\n\ts.client = &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tTLSClientConfig: tlsConfig,\n\t\t\tProxy:           http.ProxyFromEnvironment,\n\t\t\tDial: (&net.Dialer{\n\t\t\t\tTimeout:   30 * time.Second,\n\t\t\t\tKeepAlive: 30 * time.Second,\n\t\t\t}).Dial,\n\t\t\tTLSHandshakeTimeout:   10 * time.Second,\n\t\t\tExpectContinueTimeout: 1 * time.Second,\n\t\t},\n\t}\n\tif settings.DexConfig != \"\" {\n\t\ts.client.Transport = dex.NewDexRewriteURLRoundTripper(dexServerAddr, s.client.Transport)\n\t}\n\tif os.Getenv(common.EnvVarSSODebug) == \"1\" {\n\t\ts.client.Transport = httputil.DebugTransport{T: s.client.Transport}\n\t}\n\n\treturn &s\n}\n\n// Create creates a new token for a given subject (user) and returns it as a string.\n// Passing a value of `0` for secondsBeforeExpiry creates a token that never expires.\n// The id parameter holds an optional unique JWT token identifier and stored as a standard claim \"jti\" in the JWT token.\nfunc (mgr *SessionManager) Create(subject string, secondsBeforeExpiry int64, id string) (string, error) {\n\t// Create a new token object, specifying signing method and the claims\n\t// you would like it to contain.\n\tnow := time.Now().UTC()\n\tclaims := jwt.StandardClaims{\n\t\tIssuedAt:  jwt.At(now),\n\t\tIssuer:    SessionManagerClaimsIssuer,\n\t\tNotBefore: jwt.At(now),\n\t\tSubject:   subject,\n\t\tID:        id,\n\t}\n\tif secondsBeforeExpiry > 0 {\n\t\texpires := now.Add(time.Duration(secondsBeforeExpiry) * time.Second)\n\t\tclaims.ExpiresAt = jwt.At(expires)\n\t}\n\n\treturn mgr.signClaims(claims)\n}\n\ntype standardClaims struct {\n\tAudience  jwt.ClaimStrings `json:\"aud,omitempty\"`\n\tExpiresAt int64            `json:\"exp,omitempty\"`\n\tID        string           `json:\"jti,omitempty\"`\n\tIssuedAt  int64            `json:\"iat,omitempty\"`\n\tIssuer    string           `json:\"iss,omitempty\"`\n\tNotBefore int64            `json:\"nbf,omitempty\"`\n\tSubject   string           `json:\"sub,omitempty\"`\n}\n\nfunc unixTimeOrZero(t *jwt.Time) int64 {\n\tif t == nil {\n\t\treturn 0\n\t}\n\treturn t.Unix()\n}\n\nfunc (mgr *SessionManager) signClaims(claims jwt.Claims) (string, error) {\n\t// log.Infof(\"Issuing claims: %v\", claims)\n\ttoken := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\t// workaround for https://github.com/argoproj/argo-cd/issues/5217\n\t// According to https://tools.ietf.org/html/rfc7519#section-4.1.6 \"iat\" and other time fields must contain\n\t// number of seconds from 1970-01-01T00:00:00Z UTC until the specified UTC date/time.\n\t// The https://github.com/dgrijalva/jwt-go marshals time as non integer.\n\treturn token.SignedString(settings.ServerSignature, jwt.WithMarshaller(func(ctx jwt.CodingContext, v interface{}) ([]byte, error) {\n\t\tif std, ok := v.(jwt.StandardClaims); ok {\n\t\t\treturn json.Marshal(standardClaims{\n\t\t\t\tAudience:  std.Audience,\n\t\t\t\tExpiresAt: unixTimeOrZero(std.ExpiresAt),\n\t\t\t\tID:        std.ID,\n\t\t\t\tIssuedAt:  unixTimeOrZero(std.IssuedAt),\n\t\t\t\tIssuer:    std.Issuer,\n\t\t\t\tNotBefore: unixTimeOrZero(std.NotBefore),\n\t\t\t\tSubject:   std.Subject,\n\t\t\t})\n\t\t}\n\t\treturn json.Marshal(v)\n\t}))\n}\n\n// Parse tries to parse the provided string and returns the token claims for local login.\nfunc (mgr *SessionManager) Parse(tokenString string) (jwt.Claims, error) {\n\t// Parse takes the token string and a function for looking up the key. The latter is especially\n\t// useful if you use multiple keys for your application.  The standard is to use 'kid' in the\n\t// head of the token to identify which key to use, but the parsed token (head and claims) is provided\n\t// to the callback, providing flexibility.\n\tvar claims jwt.MapClaims\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttoken, err := jwt.ParseWithClaims(tokenString, &claims, func(token *jwt.Token) (interface{}, error) {\n\t\t// Don't forget to validate the alg is what you expect:\n\t\tif _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {\n\t\t\treturn nil, fmt.Errorf(\"Unexpected signing method: %v\", token.Header[\"alg\"])\n\t\t}\n\t\treturn settings.ServerSignature, nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tissuedAt, err := jwtutil.IssuedAtTime(claims)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tsubject := jwtutil.StringField(claims, \"sub\")\n\tid := jwtutil.StringField(claims, \"jti\")\n\n\tif projName, role, ok := rbacpolicy.GetProjectRoleFromSubject(subject); ok {\n\t\tproj, err := mgr.projectsLister.Get(projName)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t_, _, err = proj.GetJWTToken(role, issuedAt.Unix(), id)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\treturn token.Claims, nil\n\t}\n\n\taccount, err := mgr.settingsMgr.GetAccount(subject)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !account.Enabled {\n\t\treturn nil, fmt.Errorf(\"account %s is disabled\", subject)\n\t}\n\n\tif id := jwtutil.StringField(claims, \"jti\"); id != \"\" && account.TokenIndex(id) == -1 {\n\t\treturn nil, fmt.Errorf(\"account %s does not have token with id %s\", subject, id)\n\t}\n\n\tif account.PasswordMtime != nil && issuedAt.Before(*account.PasswordMtime) {\n\t\treturn nil, fmt.Errorf(\"Account password has changed since token issued\")\n\t}\n\treturn token.Claims, nil\n}\n\n// GetLoginFailures retrieves the login failure information from the cache\nfunc (mgr *SessionManager) GetLoginFailures() map[string]LoginAttempts {\n\t// Get failures from the cache\n\tvar failures map[string]LoginAttempts\n\terr := mgr.storage.GetLoginAttempts(&failures)\n\tif err != nil {\n\t\tif err != appstate.ErrCacheMiss {\n\t\t\tlog.Errorf(\"Could not retrieve login attempts: %v\", err)\n\t\t}\n\t\tfailures = make(map[string]LoginAttempts)\n\t}\n\n\treturn failures\n}\n\nfunc expireOldFailedAttempts(maxAge time.Duration, failures *map[string]LoginAttempts) int {\n\texpiredCount := 0\n\tfor key, attempt := range *failures {\n\t\tif time.Since(attempt.LastFailed) > maxAge*time.Second {\n\t\t\texpiredCount += 1\n\t\t\tdelete(*failures, key)\n\t\t}\n\t}\n\treturn expiredCount\n}\n\n// Updates the failure count for a given username. If failed is true, increases the counter. Otherwise, sets counter back to 0.\nfunc (mgr *SessionManager) updateFailureCount(username string, failed bool) {\n\n\tfailures := mgr.GetLoginFailures()\n\n\t// Expire old entries in the cache if we have a failure window defined.\n\tif window := getLoginFailureWindow(); window > 0 {\n\t\tcount := expireOldFailedAttempts(window, &failures)\n\t\tif count > 0 {\n\t\t\tlog.Infof(\"Expired %d entries from session cache due to max age reached\", count)\n\t\t}\n\t}\n\n\t// If we exceed a certain cache size, we need to remove random entries to\n\t// prevent overbloating the cache with fake entries, as this could lead to\n\t// memory exhaustion and ultimately in a DoS. We remove a single entry to\n\t// replace it with the new one.\n\t//\n\t// Chances are that we remove the one that is under active attack, but this\n\t// chance is low (1:cache_size)\n\tif failed && len(failures) >= getMaximumCacheSize() {\n\t\tlog.Warnf(\"Session cache size exceeds %d entries, removing random entry\", getMaximumCacheSize())\n\t\tidx := rand.Intn(len(failures) - 1)\n\t\tvar rmUser string\n\t\ti := 0\n\t\tfor key := range failures {\n\t\t\tif i == idx {\n\t\t\t\trmUser = key\n\t\t\t\tdelete(failures, key)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t\tlog.Infof(\"Deleted entry for user %s from cache\", rmUser)\n\t}\n\n\tattempt, ok := failures[username]\n\tif !ok {\n\t\tattempt = LoginAttempts{FailCount: 0}\n\t}\n\n\t// On login failure, increase fail count and update last failed timestamp.\n\t// On login success, remove the entry from the cache.\n\tif failed {\n\t\tattempt.FailCount += 1\n\t\tattempt.LastFailed = time.Now()\n\t\tfailures[username] = attempt\n\t\tlog.Warnf(\"User %s failed login %d time(s)\", username, attempt.FailCount)\n\t} else {\n\t\tif attempt.FailCount > 0 {\n\t\t\t// Forget username for cache size enforcement, since entry in cache was deleted\n\t\t\tdelete(failures, username)\n\t\t}\n\t}\n\n\terr := mgr.storage.SetLoginAttempts(failures)\n\tif err != nil {\n\t\tlog.Errorf(\"Could not update login attempts: %v\", err)\n\t}\n\n}\n\n// Get the current login failure attempts for given username\nfunc (mgr *SessionManager) getFailureCount(username string) LoginAttempts {\n\tfailures := mgr.GetLoginFailures()\n\tattempt, ok := failures[username]\n\tif !ok {\n\t\tattempt = LoginAttempts{FailCount: 0}\n\t}\n\treturn attempt\n}\n\n// Calculate a login delay for the given login attempt\nfunc (mgr *SessionManager) exceededFailedLoginAttempts(attempt LoginAttempts) bool {\n\tmaxFails := getMaxLoginFailures()\n\tfailureWindow := getLoginFailureWindow()\n\n\t// Whether we are in the failure window for given attempt\n\tinWindow := func() bool {\n\t\tif failureWindow == 0 || time.Since(attempt.LastFailed).Seconds() <= float64(failureWindow) {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\t// If we reached max failed attempts within failure window, we need to calc the delay\n\tif attempt.FailCount >= maxFails && inWindow() {\n\t\treturn true\n\t}\n\n\treturn false\n}\n\n// VerifyUsernamePassword verifies if a username/password combo is correct\nfunc (mgr *SessionManager) VerifyUsernamePassword(username string, password string) error {\n\tif password == \"\" {\n\t\treturn status.Errorf(codes.Unauthenticated, blankPasswordError)\n\t}\n\t// Enforce maximum length of username on local accounts\n\tif len(username) > maxUsernameLength {\n\t\treturn status.Errorf(codes.InvalidArgument, usernameTooLongError, maxUsernameLength)\n\t}\n\n\tstart := time.Now()\n\tif mgr.verificationDelayNoiseEnabled {\n\t\tdefer func() {\n\t\t\t// introduces random delay to protect from timing-based user enumeration attack\n\t\t\tdelayNanoseconds := verificationDelayNoiseMin.Nanoseconds() +\n\t\t\t\tint64(rand.Intn(int(verificationDelayNoiseMax.Nanoseconds()-verificationDelayNoiseMin.Nanoseconds())))\n\t\t\t\t// take into account amount of time spent since the request start\n\t\t\tdelayNanoseconds = delayNanoseconds - time.Since(start).Nanoseconds()\n\t\t\tif delayNanoseconds > 0 {\n\t\t\t\tmgr.sleep(time.Duration(delayNanoseconds))\n\t\t\t}\n\t\t}()\n\t}\n\n\tattempt := mgr.getFailureCount(username)\n\tif mgr.exceededFailedLoginAttempts(attempt) {\n\t\tlog.Warnf(\"User %s had too many failed logins (%d)\", username, attempt.FailCount)\n\t\treturn InvalidLoginErr\n\t}\n\n\taccount, err := mgr.settingsMgr.GetAccount(username)\n\tif err != nil {\n\t\tif errStatus, ok := status.FromError(err); ok && errStatus.Code() == codes.NotFound {\n\t\t\tmgr.updateFailureCount(username, true)\n\t\t\terr = InvalidLoginErr\n\t\t}\n\t\t// to prevent time-based user enumeration, we must perform a password\n\t\t// hash cycle to keep response time consistent (if the function were\n\t\t// to continue and not return here)\n\t\t_, _ = passwordutil.HashPassword(\"for_consistent_response_time\")\n\t\treturn err\n\t}\n\n\tvalid, _ := passwordutil.VerifyPassword(password, account.PasswordHash)\n\tif !valid {\n\t\tmgr.updateFailureCount(username, true)\n\t\treturn InvalidLoginErr\n\t}\n\n\tif !account.Enabled {\n\t\treturn status.Errorf(codes.Unauthenticated, accountDisabled, username)\n\t}\n\n\tif !account.HasCapability(settings.AccountCapabilityLogin) {\n\t\treturn status.Errorf(codes.Unauthenticated, userDoesNotHaveCapability, username, settings.AccountCapabilityLogin)\n\t}\n\tmgr.updateFailureCount(username, false)\n\treturn nil\n}\n\n// VerifyToken verifies if a token is correct. Tokens can be issued either from us or by an IDP.\n// We choose how to verify based on the issuer.\nfunc (mgr *SessionManager) VerifyToken(tokenString string) (jwt.Claims, error) {\n\tparser := &jwt.Parser{\n\t\tValidationHelper: jwt.NewValidationHelper(jwt.WithoutClaimsValidation()),\n\t}\n\tvar claims jwt.StandardClaims\n\t_, _, err := parser.ParseUnverified(tokenString, &claims)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tswitch claims.Issuer {\n\tcase SessionManagerClaimsIssuer:\n\t\t// Argo CD signed token\n\t\treturn mgr.Parse(tokenString)\n\tdefault:\n\t\t// IDP signed token\n\t\tprov, err := mgr.provider()\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\n\t\t// Token must be verified for at least one audience\n\t\t// TODO(jannfis): Is this the right way? Shouldn't we know our audience and only validate for the correct one?\n\t\tvar idToken *oidc.IDToken\n\t\tfor _, aud := range claims.Audience {\n\t\t\tidToken, err = prov.Verify(aud, tokenString)\n\t\t\tif err == nil {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif err != nil {\n\t\t\treturn claims, err\n\t\t}\n\t\tvar claims jwt.MapClaims\n\t\terr = idToken.Claims(&claims)\n\t\treturn claims, err\n\t}\n}\n\nfunc (mgr *SessionManager) provider() (oidcutil.Provider, error) {\n\tif mgr.prov != nil {\n\t\treturn mgr.prov, nil\n\t}\n\tsettings, err := mgr.settingsMgr.GetSettings()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif !settings.IsSSOConfigured() {\n\t\treturn nil, fmt.Errorf(\"SSO is not configured\")\n\t}\n\tmgr.prov = oidcutil.NewOIDCProvider(settings.IssuerURL(), mgr.client)\n\treturn mgr.prov, nil\n}\n\nfunc LoggedIn(ctx context.Context) bool {\n\treturn Sub(ctx) != \"\"\n}\n\n// Username is a helper to extract a human readable username from a context\nfunc Username(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\tswitch jwtutil.StringField(mapClaims, \"iss\") {\n\tcase SessionManagerClaimsIssuer:\n\t\treturn jwtutil.StringField(mapClaims, \"sub\")\n\tdefault:\n\t\treturn jwtutil.StringField(mapClaims, \"email\")\n\t}\n}\n\nfunc Iss(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.StringField(mapClaims, \"iss\")\n}\n\nfunc Iat(ctx context.Context) (time.Time, error) {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn time.Time{}, errors.New(\"unable to extract token claims\")\n\t}\n\treturn jwtutil.IssuedAtTime(mapClaims)\n}\n\nfunc Sub(ctx context.Context) string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn \"\"\n\t}\n\treturn jwtutil.StringField(mapClaims, \"sub\")\n}\n\nfunc Groups(ctx context.Context, scopes []string) []string {\n\tmapClaims, ok := mapClaims(ctx)\n\tif !ok {\n\t\treturn nil\n\t}\n\treturn jwtutil.GetGroups(mapClaims, scopes)\n}\n\nfunc mapClaims(ctx context.Context) (jwt.MapClaims, bool) {\n\tclaims, ok := ctx.Value(\"claims\").(jwt.Claims)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\tmapClaims, err := jwtutil.MapClaims(claims)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\treturn mapClaims, true\n}\n", "package session\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/dgrijalva/jwt-go/v4\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\n\t\"github.com/argoproj/argo-cd/common\"\n\tappv1 \"github.com/argoproj/argo-cd/pkg/apis/application/v1alpha1\"\n\tapps \"github.com/argoproj/argo-cd/pkg/client/clientset/versioned/fake\"\n\t\"github.com/argoproj/argo-cd/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/test\"\n\t\"github.com/argoproj/argo-cd/util/errors\"\n\t\"github.com/argoproj/argo-cd/util/password\"\n\t\"github.com/argoproj/argo-cd/util/settings\"\n)\n\nfunc getProjLister(objects ...runtime.Object) v1alpha1.AppProjectNamespaceLister {\n\treturn test.NewFakeProjListerFromInterface(apps.NewSimpleClientset(objects...).ArgoprojV1alpha1().AppProjects(\"argocd\"))\n}\n\nfunc getKubeClient(pass string, enabled bool) *fake.Clientset {\n\tconst defaultSecretKey = \"Hello, world!\"\n\n\tbcrypt, err := password.HashPassword(pass)\n\terrors.CheckError(err)\n\n\treturn fake.NewSimpleClientset(&corev1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-cm\",\n\t\t\tNamespace: \"argocd\",\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: map[string]string{\n\t\t\t\"admin.enabled\": strconv.FormatBool(enabled),\n\t\t},\n\t}, &corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-secret\",\n\t\t\tNamespace: \"argocd\",\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   []byte(bcrypt),\n\t\t\t\"server.secretkey\": []byte(defaultSecretKey),\n\t\t},\n\t})\n}\n\nfunc newSessionManager(settingsMgr *settings.SettingsManager, projectLister v1alpha1.AppProjectNamespaceLister, storage UserStateStorage) *SessionManager {\n\tmgr := NewSessionManager(settingsMgr, projectLister, \"\", storage)\n\tmgr.verificationDelayNoiseEnabled = false\n\treturn mgr\n}\n\nfunc TestSessionManager_AdminToken(t *testing.T) {\n\tconst (\n\t\tdefaultSubject = \"admin\"\n\t)\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"pass\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\ttoken, err := mgr.Create(defaultSubject, 0, \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Could not create token: %v\", err)\n\t}\n\n\tclaims, err := mgr.Parse(token)\n\tif err != nil {\n\t\tt.Errorf(\"Could not parse token: %v\", err)\n\t}\n\n\tmapClaims := *(claims.(*jwt.MapClaims))\n\tsubject := mapClaims[\"sub\"].(string)\n\tif subject != \"admin\" {\n\t\tt.Errorf(\"Token claim subject \\\"%s\\\" does not match expected subject \\\"%s\\\".\", subject, defaultSubject)\n\t}\n}\n\nfunc TestSessionManager_AdminToken_Deactivated(t *testing.T) {\n\tconst (\n\t\tdefaultSubject = \"admin\"\n\t)\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"pass\", false), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\ttoken, err := mgr.Create(defaultSubject, 0, \"\")\n\tif err != nil {\n\t\tt.Errorf(\"Could not create token: %v\", err)\n\t}\n\n\t_, err = mgr.Parse(token)\n\trequire.Error(t, err)\n\tassert.Contains(t, err.Error(), \"account admin is disabled\")\n}\n\nfunc TestSessionManager_ProjectToken(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"pass\", true), \"argocd\")\n\n\tt.Run(\"Valid Token\", func(t *testing.T) {\n\t\tproj := appv1.AppProject{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName:      \"default\",\n\t\t\t\tNamespace: \"argocd\",\n\t\t\t},\n\t\t\tSpec: appv1.AppProjectSpec{Roles: []appv1.ProjectRole{{Name: \"test\"}}},\n\t\t\tStatus: appv1.AppProjectStatus{JWTTokensByRole: map[string]appv1.JWTTokens{\n\t\t\t\t\"test\": {\n\t\t\t\t\tItems: []appv1.JWTToken{{ID: \"abc\", IssuedAt: time.Now().Unix(), ExpiresAt: 0}},\n\t\t\t\t},\n\t\t\t}},\n\t\t}\n\t\tmgr := newSessionManager(settingsMgr, getProjLister(&proj), NewInMemoryUserStateStorage())\n\n\t\tjwtToken, err := mgr.Create(\"proj:default:test\", 100, \"abc\")\n\t\trequire.NoError(t, err)\n\n\t\t_, err = mgr.Parse(jwtToken)\n\t\tassert.NoError(t, err)\n\t})\n\n\tt.Run(\"Token Revoked\", func(t *testing.T) {\n\t\tproj := appv1.AppProject{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName:      \"default\",\n\t\t\t\tNamespace: \"argocd\",\n\t\t\t},\n\t\t\tSpec: appv1.AppProjectSpec{Roles: []appv1.ProjectRole{{Name: \"test\"}}},\n\t\t}\n\n\t\tmgr := newSessionManager(settingsMgr, getProjLister(&proj), NewInMemoryUserStateStorage())\n\n\t\tjwtToken, err := mgr.Create(\"proj:default:test\", 10, \"\")\n\t\trequire.NoError(t, err)\n\n\t\t_, err = mgr.Parse(jwtToken)\n\t\trequire.Error(t, err)\n\n\t\tassert.Contains(t, err.Error(), \"does not exist in project 'default'\")\n\t})\n}\n\nvar loggedOutContext = context.Background()\n\n// nolint:staticcheck\nvar loggedInContext = context.WithValue(context.Background(), \"claims\", &jwt.MapClaims{\"iss\": \"qux\", \"sub\": \"foo\", \"email\": \"bar\", \"groups\": []string{\"baz\"}})\n\nfunc TestIss(t *testing.T) {\n\tassert.Empty(t, Iss(loggedOutContext))\n\tassert.Equal(t, \"qux\", Iss(loggedInContext))\n}\nfunc TestLoggedIn(t *testing.T) {\n\tassert.False(t, LoggedIn(loggedOutContext))\n\tassert.True(t, LoggedIn(loggedInContext))\n}\n\nfunc TestUsername(t *testing.T) {\n\tassert.Empty(t, Username(loggedOutContext))\n\tassert.Equal(t, \"bar\", Username(loggedInContext))\n}\n\nfunc TestSub(t *testing.T) {\n\tassert.Empty(t, Sub(loggedOutContext))\n\tassert.Equal(t, \"foo\", Sub(loggedInContext))\n}\n\nfunc TestGroups(t *testing.T) {\n\tassert.Empty(t, Groups(loggedOutContext, []string{\"groups\"}))\n\tassert.Equal(t, []string{\"baz\"}, Groups(loggedInContext, []string{\"groups\"}))\n}\n\nfunc TestVerifyUsernamePassword(t *testing.T) {\n\tconst password = \"password\"\n\n\tfor _, tc := range []struct {\n\t\tname     string\n\t\tdisabled bool\n\t\tuserName string\n\t\tpassword string\n\t\texpected error\n\t}{\n\t\t{\n\t\t\tname:     \"Success if userName and password is correct\",\n\t\t\tdisabled: false,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: password,\n\t\t\texpected: nil,\n\t\t},\n\t\t{\n\t\t\tname:     \"Return error if password is empty\",\n\t\t\tdisabled: false,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: \"\",\n\t\t\texpected: status.Errorf(codes.Unauthenticated, blankPasswordError),\n\t\t},\n\t\t{\n\t\t\tname:     \"Return error if password is not correct\",\n\t\t\tdisabled: false,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: \"foo\",\n\t\t\texpected: status.Errorf(codes.Unauthenticated, invalidLoginError),\n\t\t},\n\t\t{\n\t\t\tname:     \"Return error if disableAdmin is true\",\n\t\t\tdisabled: true,\n\t\t\tuserName: common.ArgoCDAdminUsername,\n\t\t\tpassword: password,\n\t\t\texpected: status.Errorf(codes.Unauthenticated, accountDisabled, \"admin\"),\n\t\t},\n\t} {\n\t\tt.Run(tc.name, func(t *testing.T) {\n\t\t\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(password, !tc.disabled), \"argocd\")\n\n\t\t\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\t\t\terr := mgr.VerifyUsernamePassword(tc.userName, tc.password)\n\n\t\t\tif tc.expected == nil {\n\t\t\t\tassert.Nil(t, err)\n\t\t\t} else {\n\t\t\t\tassert.EqualError(t, err, tc.expected.Error())\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestCacheValueGetters(t *testing.T) {\n\tt.Run(\"Default values\", func(t *testing.T) {\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\t})\n\n\tt.Run(\"Valid environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, \"5\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"5\")\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, 5, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, 5, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n\tt.Run(\"Invalid environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, \"invalid\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"invalid\")\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n\tt.Run(\"Less than allowed in environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, \"-1\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"-1\")\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n\tt.Run(\"Greater than allowed in environment overrides\", func(t *testing.T) {\n\t\tos.Setenv(envLoginMaxFailCount, fmt.Sprintf(\"%d\", math.MaxInt32+1))\n\t\tos.Setenv(envLoginMaxCacheSize, fmt.Sprintf(\"%d\", math.MaxInt32+1))\n\n\t\tmlf := getMaxLoginFailures()\n\t\tassert.Equal(t, defaultMaxLoginFailures, mlf)\n\n\t\tmcs := getMaximumCacheSize()\n\t\tassert.Equal(t, defaultMaxCacheSize, mcs)\n\n\t\tos.Setenv(envLoginMaxFailCount, \"\")\n\t\tos.Setenv(envLoginMaxCacheSize, \"\")\n\t})\n\n}\n\nfunc TestLoginRateLimiter(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tstorage := NewInMemoryUserStateStorage()\n\n\tmgr := newSessionManager(settingsMgr, getProjLister(), storage)\n\n\tt.Run(\"Test login delay valid user\", func(t *testing.T) {\n\t\tfor i := 0; i < getMaxLoginFailures(); i++ {\n\t\t\terr := mgr.VerifyUsernamePassword(\"admin\", \"wrong\")\n\t\t\tassert.Error(t, err)\n\t\t}\n\n\t\t// The 11th time should fail even if password is right\n\t\t{\n\t\t\terr := mgr.VerifyUsernamePassword(\"admin\", \"password\")\n\t\t\tassert.Error(t, err)\n\t\t}\n\n\t\tstorage.attempts = map[string]LoginAttempts{}\n\t\t// Failed counter should have been reset, should validate immediately\n\t\t{\n\t\t\terr := mgr.VerifyUsernamePassword(\"admin\", \"password\")\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t})\n\n\tt.Run(\"Test login delay invalid user\", func(t *testing.T) {\n\t\tfor i := 0; i < getMaxLoginFailures(); i++ {\n\t\t\terr := mgr.VerifyUsernamePassword(\"invalid\", \"wrong\")\n\t\t\tassert.Error(t, err)\n\t\t}\n\n\t\terr := mgr.VerifyUsernamePassword(\"invalid\", \"wrong\")\n\t\tassert.Error(t, err)\n\t})\n}\n\nfunc TestMaxUsernameLength(t *testing.T) {\n\tusername := \"\"\n\tfor i := 0; i < maxUsernameLength+1; i++ {\n\t\tusername += \"a\"\n\t}\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\terr := mgr.VerifyUsernamePassword(username, \"password\")\n\tassert.Error(t, err)\n\tassert.Contains(t, err.Error(), fmt.Sprintf(usernameTooLongError, maxUsernameLength))\n}\n\nfunc TestMaxCacheSize(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\tinvalidUsers := []string{\"invalid1\", \"invalid2\", \"invalid3\", \"invalid4\", \"invalid5\", \"invalid6\", \"invalid7\"}\n\t// Temporarily decrease max cache size\n\tos.Setenv(envLoginMaxCacheSize, \"5\")\n\n\tfor _, user := range invalidUsers {\n\t\terr := mgr.VerifyUsernamePassword(user, \"password\")\n\t\tassert.Error(t, err)\n\t}\n\n\tassert.Len(t, mgr.GetLoginFailures(), 5)\n}\n\nfunc TestFailedAttemptsExpiry(t *testing.T) {\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), getKubeClient(\"password\", true), \"argocd\")\n\tmgr := newSessionManager(settingsMgr, getProjLister(), NewInMemoryUserStateStorage())\n\n\tinvalidUsers := []string{\"invalid1\", \"invalid2\", \"invalid3\", \"invalid4\", \"invalid5\", \"invalid6\", \"invalid7\"}\n\n\tos.Setenv(envLoginFailureWindowSeconds, \"1\")\n\n\tfor _, user := range invalidUsers {\n\t\terr := mgr.VerifyUsernamePassword(user, \"password\")\n\t\tassert.Error(t, err)\n\t}\n\n\ttime.Sleep(2 * time.Second)\n\n\terr := mgr.VerifyUsernamePassword(\"invalid8\", \"password\")\n\tassert.Error(t, err)\n\tassert.Len(t, mgr.GetLoginFailures(), 1)\n\n\tos.Setenv(envLoginFailureWindowSeconds, \"\")\n}\n"], "filenames": ["util/session/sessionmanager.go", "util/session/sessionmanager_test.go"], "buggy_code_start_loc": [283, 92], "buggy_code_end_loc": [283, 92], "fixing_code_start_loc": [284, 93], "fixing_code_end_loc": [288, 110], "type": "CWE-613", "message": "In util/session/sessionmanager.go in Argo CD before 1.8.4, tokens continue to work even when the user account is disabled.", "other": {"cve": {"id": "CVE-2021-26921", "sourceIdentifier": "cve@mitre.org", "published": "2021-02-09T15:15:13.877", "lastModified": "2021-03-22T15:49:44.830", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In util/session/sessionmanager.go in Argo CD before 1.8.4, tokens continue to work even when the user account is disabled."}, {"lang": "es", "value": "En el archivo util/session/sessionmanager.go en Argo CD versiones anteriores a 1.8.4, los tokens contin\u00faan funcionando inclusive cuando la cuenta de usuario est\u00e1 deshabilitada"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-613"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo_continuous_delivery:*:*:*:*:*:kubernetes:*:*", "versionEndExcluding": "1.7.12", "matchCriteriaId": "216CE2E2-4C28-4A0E-B6C9-AE6273ED4BEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo_continuous_delivery:*:*:*:*:*:kubernetes:*:*", "versionStartIncluding": "1.8.0", "versionEndExcluding": "1.8.4", "matchCriteriaId": "F07A5D68-BDAC-45FE-8CFF-DAED0DEAA7E4"}]}]}], "references": [{"url": "https://github.com/argoproj/argo-cd/commit/f5b0db240b4e3abf18e97f6fd99096b4f9e94dc5", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/compare/v1.8.3...v1.8.4", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-9h6w-j7w4-jr52", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/argoproj/argo-cd/commit/f5b0db240b4e3abf18e97f6fd99096b4f9e94dc5"}}