{"buggy_code": ["/*\n * Copyright (C) 2003-2005 Tommi Maekitalo\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * As a special exception, you may use this file as part of a free\n * software library without restriction. Specifically, if other files\n * instantiate templates or use macros or inline functions from this\n * file, or you compile this file and link it with other files to\n * produce an executable, this file does not by itself cause the\n * resulting executable to be covered by the GNU General Public\n * License. This exception does not however invalidate any other\n * reasons why the executable file might be covered by the GNU Library\n * General Public License.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n\n#include <tnt/messageheaderparser.h>\n#include <tnt/httperror.h>\n#include <tnt/http.h>\n#include <cctype>\n#include <cxxtools/log.h>\n\nnamespace tnt\n{\n  namespace\n  {\n    std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }\n  }\n\n  log_define(\"tntnet.messageheader.parser\")\n\n  #define SET_STATE(new_state)  state = &Parser::new_state\n\n  bool Messageheader::Parser::state_0(char ch)\n  {\n    if (ch >= 33 && ch <= 126 && ch != ':')\n    {\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldname);\n    }\n    else if (ch == '\\n')\n      return true;\n    else if (ch == '\\r')\n      SET_STATE(state_cr);\n    else if (!std::isspace(ch))\n    {\n      log_warn(\"invalid character \" << chartoprint(ch));\n      failedFlag = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  bool Messageheader::Parser::state_cr(char ch)\n  {\n    if (ch != '\\n')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in state-cr\");\n      failedFlag = true;\n    }\n    return true;\n  }\n\n  bool Messageheader::Parser::state_fieldname(char ch)\n  {\n    if (ch == ':')            // Field-name:\n    {\n      checkHeaderspace(2);\n      *headerdataPtr++ = ch;\n      *headerdataPtr++ = '\\0';\n      fieldbodyPtr = headerdataPtr;\n      SET_STATE(state_fieldbody0);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(2);\n      *headerdataPtr++ = ':';\n      *headerdataPtr++ = '\\0';\n      fieldbodyPtr = headerdataPtr;\n      SET_STATE(state_fieldnamespace);\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldname\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldnamespace(char ch)\n  {\n    if (ch == ':')                   // \"Field-name :\"\n      SET_STATE(state_fieldbody0);\n    else if (!std::isspace(ch))\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldname-space\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody0(char ch)\n  {\n    if (ch == '\\r')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_cr);\n    }\n    else if (ch == '\\n')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_crlf);\n    }\n    else if (!std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody(char ch)\n  {\n    if (ch == '\\r')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_cr);\n    }\n    else if (ch == '\\n')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_crlf);\n    }\n    else\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody_cr(char ch)\n  {\n    if (ch == '\\n')\n      SET_STATE(state_fieldbody_crlf);\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody-cr\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      // continuation line\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_end_cr(char ch)\n  {\n    if (ch == '\\n')\n    {\n      if (header.onField(fieldnamePtr, fieldbodyPtr) == FAIL)\n      {\n        log_warn(\"invalid header \" << fieldnamePtr << ' ' << fieldbodyPtr);\n        failedFlag = true;\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in end-cr\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  void Messageheader::Parser::checkHeaderspace(unsigned chars) const\n  {\n    if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))\n      throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, \"header too large\");\n  }\n\n  void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }\n}\n"], "fixing_code": ["/*\n * Copyright (C) 2003-2005 Tommi Maekitalo\n * \n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n * \n * As a special exception, you may use this file as part of a free\n * software library without restriction. Specifically, if other files\n * instantiate templates or use macros or inline functions from this\n * file, or you compile this file and link it with other files to\n * produce an executable, this file does not by itself cause the\n * resulting executable to be covered by the GNU General Public\n * License. This exception does not however invalidate any other\n * reasons why the executable file might be covered by the GNU Library\n * General Public License.\n * \n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n * \n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n\n#include <tnt/messageheaderparser.h>\n#include <tnt/httperror.h>\n#include <tnt/http.h>\n#include <cctype>\n#include <cxxtools/log.h>\n\nnamespace tnt\n{\n  namespace\n  {\n    std::string chartoprint(char ch)\n    {\n      const static char hex[] = \"0123456789abcdef\";\n      if (std::isprint(ch))\n        return std::string(1, '\\'') + ch + '\\'';\n      else\n        return std::string(\"'\\\\x\") + hex[ch >> 4] + hex[ch & 0xf] + '\\'';\n    }\n  }\n\n  log_define(\"tntnet.messageheader.parser\")\n\n  #define SET_STATE(new_state)  state = &Parser::new_state\n\n  bool Messageheader::Parser::state_0(char ch)\n  {\n    if (ch >= 33 && ch <= 126 && ch != ':')\n    {\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldname);\n    }\n    else if (ch == '\\n')\n      return true;\n    else if (ch == '\\r')\n      SET_STATE(state_cr);\n    else if (!std::isspace(ch))\n    {\n      log_warn(\"invalid character \" << chartoprint(ch));\n      failedFlag = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  bool Messageheader::Parser::state_cr(char ch)\n  {\n    if (ch != '\\n')\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in state-cr\");\n      failedFlag = true;\n    }\n    return true;\n  }\n\n  bool Messageheader::Parser::state_fieldname(char ch)\n  {\n    if (ch == ':')            // Field-name:\n    {\n      checkHeaderspace(2);\n      *headerdataPtr++ = ch;\n      *headerdataPtr++ = '\\0';\n      fieldbodyPtr = headerdataPtr;\n      SET_STATE(state_fieldbody0);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    else if (std::isspace(ch))\n    {\n      checkHeaderspace(2);\n      *headerdataPtr++ = ':';\n      *headerdataPtr++ = '\\0';\n      fieldbodyPtr = headerdataPtr;\n      SET_STATE(state_fieldnamespace);\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldname\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldnamespace(char ch)\n  {\n    if (ch == ':')                   // \"Field-name :\"\n      SET_STATE(state_fieldbody0);\n    else if (!std::isspace(ch))\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldname-space\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody0(char ch)\n  {\n    if (ch == '\\r')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_cr);\n    }\n    else if (ch == '\\n')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_crlf);\n    }\n    else if (!std::isspace(ch))\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody(char ch)\n  {\n    if (ch == '\\r')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_cr);\n    }\n    else if (ch == '\\n')\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = '\\0';\n      SET_STATE(state_fieldbody_crlf);\n    }\n    else\n    {\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody_cr(char ch)\n  {\n    if (ch == '\\n')\n      SET_STATE(state_fieldbody_crlf);\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody-cr\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_fieldbody_crlf(char ch)\n  {\n    if (ch == '\\r')\n      SET_STATE(state_end_cr);\n    else if (ch == '\\n')\n    {\n      log_debug(\"header \" << fieldnamePtr << \": \" << fieldbodyPtr);\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:\n        case END:  return true;\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else if (std::isspace(ch))\n    {\n      // continuation line\n      checkHeaderspace(1);\n      *(headerdataPtr - 1) = '\\n';\n      *headerdataPtr++ = ch;\n      SET_STATE(state_fieldbody);\n    }\n    else if (ch >= 33 && ch <= 126)\n    {\n      switch (header.onField(fieldnamePtr, fieldbodyPtr))\n      {\n        case OK:   SET_STATE(state_fieldname);\n                   break;\n        case FAIL: failedFlag = true;\n                   log_warn(\"invalid character \" << chartoprint(ch) << \" in fieldbody\");\n                   break;\n        case END:  return true;\n                   break;\n      }\n\n      fieldnamePtr = headerdataPtr;\n      checkHeaderspace(1);\n      *headerdataPtr++ = ch;\n    }\n    return false;\n  }\n\n  bool Messageheader::Parser::state_end_cr(char ch)\n  {\n    if (ch == '\\n')\n    {\n      if (header.onField(fieldnamePtr, fieldbodyPtr) == FAIL)\n      {\n        log_warn(\"invalid header \" << fieldnamePtr << ' ' << fieldbodyPtr);\n        failedFlag = true;\n      }\n\n      *headerdataPtr = '\\0';\n      return true;\n    }\n    else\n    {\n      log_warn(\"invalid character \" << chartoprint(ch) << \" in end-cr\");\n      failedFlag = true;\n      return true;\n    }\n    return false;\n  }\n\n  void Messageheader::Parser::checkHeaderspace(unsigned chars) const\n  {\n    if (headerdataPtr + chars >= header.rawdata + sizeof(header.rawdata))\n    {\n      header.rawdata[sizeof(header.rawdata) - 1] = '\\0';\n      throw HttpError(HTTP_REQUEST_ENTITY_TOO_LARGE, \"header too large\");\n    }\n  }\n\n  void Messageheader::Parser::reset()\n  {\n    failedFlag = false;\n    headerdataPtr = header.rawdata;\n    SET_STATE(state_0);\n  }\n}\n"], "filenames": ["framework/common/messageheaderparser.cpp"], "buggy_code_start_loc": [206], "buggy_code_end_loc": [262], "fixing_code_start_loc": [207], "fixing_code_end_loc": [267], "type": "CWE-200", "message": "framework/common/messageheaderparser.cpp in Tntnet before 2.2.1 allows remote attackers to obtain sensitive information via a header that ends in \\n instead of \\r\\n, which prevents a null terminator from being added and causes Tntnet to include headers from other requests.", "other": {"cve": {"id": "CVE-2013-7299", "sourceIdentifier": "cve@mitre.org", "published": "2014-01-26T20:55:06.360", "lastModified": "2017-08-29T01:34:06.937", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "framework/common/messageheaderparser.cpp in Tntnet before 2.2.1 allows remote attackers to obtain sensitive information via a header that ends in \\n instead of \\r\\n, which prevents a null terminator from being added and causes Tntnet to include headers from other requests."}, {"lang": "es", "value": "framework/common/messageheaderparser.cpp en Tntnet antes de 2.2.1 permite a atacantes remotos obtener informaci\u00f3n sensible a trav\u00e9s de un encabezado que termina en \\ n en vez de \\ r \\ n, lo que impide que un terminador nulo se agregue y permite que Tntnet incluya encabezados de otras peticiones."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tntnet:tntnet:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.2", "matchCriteriaId": "8BA246A3-1811-4373-9386-8C93DBED63A8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tntnet:tntnet:2.0:*:*:*:*:*:*:*", "matchCriteriaId": "526DC6DD-760C-4EA7-B66A-F20BD8E57F73"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tntnet:tntnet:2.1:*:*:*:*:*:*:*", "matchCriteriaId": "80984BE5-0173-4311-A10E-DD7BE9DA0618"}]}]}], "references": [{"url": "http://lists.fedoraproject.org/pipermail/package-announce/2014-February/127746.html", "source": "cve@mitre.org"}, {"url": "http://seclists.org/oss-sec/2014/q1/112", "source": "cve@mitre.org"}, {"url": "http://seclists.org/oss-sec/2014/q1/116", "source": "cve@mitre.org"}, {"url": "http://www.securityfocus.com/bid/65025", "source": "cve@mitre.org"}, {"url": "http://www.tntnet.org/download/tntnet-2.2.1/Releasenotes-2.2.1.markdown", "source": "cve@mitre.org"}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/90565", "source": "cve@mitre.org"}, {"url": "https://github.com/maekitalo/tntnet/commit/9bd3b14042e12d84f39ea9f55731705ba516f525", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/maekitalo/tntnet/commit/9bd3b14042e12d84f39ea9f55731705ba516f525"}}