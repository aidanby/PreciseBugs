{"buggy_code": ["/*\n * Copyright (c) 2020, Ali Mohammad Pur <ali.mpfard@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <AK/Debug.h>\n#include <LibCrypto/NumberTheory/ModularFunctions.h>\n\nnamespace Crypto {\nnamespace NumberTheory {\n\nUnsignedBigInteger ModularInverse(const UnsignedBigInteger& a_, const UnsignedBigInteger& b)\n{\n    if (b == 1)\n        return { 1 };\n\n    UnsignedBigInteger one { 1 };\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_plus;\n    UnsignedBigInteger temp_minus;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n    UnsignedBigInteger d;\n\n    auto a = a_;\n    auto u = a;\n    if (a.words()[0] % 2 == 0) {\n        // u += b\n        UnsignedBigInteger::add_without_allocation(u, b, temp_plus);\n        u.set_to(temp_plus);\n    }\n\n    auto v = b;\n    UnsignedBigInteger x { 0 };\n\n    // d = b - 1\n    UnsignedBigInteger::subtract_without_allocation(b, one, d);\n\n    while (!(v == 1)) {\n        while (v < u) {\n            // u -= v\n            UnsignedBigInteger::subtract_without_allocation(u, v, temp_minus);\n            u.set_to(temp_minus);\n\n            // d += x\n            UnsignedBigInteger::add_without_allocation(d, x, temp_plus);\n            d.set_to(temp_plus);\n\n            while (u.words()[0] % 2 == 0) {\n                if (d.words()[0] % 2 == 1) {\n                    // d += b\n                    UnsignedBigInteger::add_without_allocation(d, b, temp_plus);\n                    d.set_to(temp_plus);\n                }\n\n                // u /= 2\n                UnsignedBigInteger::divide_u16_without_allocation(u, 2, temp_quotient, temp_remainder);\n                u.set_to(temp_quotient);\n\n                // d /= 2\n                UnsignedBigInteger::divide_u16_without_allocation(d, 2, temp_quotient, temp_remainder);\n                d.set_to(temp_quotient);\n            }\n        }\n\n        // v -= u\n        UnsignedBigInteger::subtract_without_allocation(v, u, temp_minus);\n        v.set_to(temp_minus);\n\n        // x += d\n        UnsignedBigInteger::add_without_allocation(x, d, temp_plus);\n        x.set_to(temp_plus);\n\n        while (v.words()[0] % 2 == 0) {\n            if (x.words()[0] % 2 == 1) {\n                // x += b\n                UnsignedBigInteger::add_without_allocation(x, b, temp_plus);\n                x.set_to(temp_plus);\n            }\n\n            // v /= 2\n            UnsignedBigInteger::divide_u16_without_allocation(v, 2, temp_quotient, temp_remainder);\n            v.set_to(temp_quotient);\n\n            // x /= 2\n            UnsignedBigInteger::divide_u16_without_allocation(x, 2, temp_quotient, temp_remainder);\n            x.set_to(temp_quotient);\n        }\n    }\n\n    // x % b\n    UnsignedBigInteger::divide_without_allocation(x, b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n    return temp_remainder;\n}\n\nUnsignedBigInteger ModularPower(const UnsignedBigInteger& b, const UnsignedBigInteger& e, const UnsignedBigInteger& m)\n{\n    if (m == 1)\n        return 0;\n\n    UnsignedBigInteger ep { e };\n    UnsignedBigInteger base { b };\n    UnsignedBigInteger exp { 1 };\n\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_multiply;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n\n    while (!(ep < 1)) {\n        if (ep.words()[0] % 2 == 1) {\n            // exp = (exp * base) % m;\n            UnsignedBigInteger::multiply_without_allocation(exp, base, temp_1, temp_2, temp_3, temp_4, temp_multiply);\n            UnsignedBigInteger::divide_without_allocation(temp_multiply, m, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n            exp.set_to(temp_remainder);\n        }\n\n        // ep = ep / 2;\n        UnsignedBigInteger::divide_u16_without_allocation(ep, 2, temp_quotient, temp_remainder);\n        ep.set_to(temp_quotient);\n\n        // base = (base * base) % m;\n        UnsignedBigInteger::multiply_without_allocation(base, base, temp_1, temp_2, temp_3, temp_4, temp_multiply);\n        UnsignedBigInteger::divide_without_allocation(temp_multiply, m, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n        base.set_to(temp_remainder);\n    }\n    return exp;\n}\n\nstatic void GCD_without_allocation(\n    const UnsignedBigInteger& a,\n    const UnsignedBigInteger& b,\n    UnsignedBigInteger& temp_a,\n    UnsignedBigInteger& temp_b,\n    UnsignedBigInteger& temp_1,\n    UnsignedBigInteger& temp_2,\n    UnsignedBigInteger& temp_3,\n    UnsignedBigInteger& temp_4,\n    UnsignedBigInteger& temp_quotient,\n    UnsignedBigInteger& temp_remainder,\n    UnsignedBigInteger& output)\n{\n    temp_a.set_to(a);\n    temp_b.set_to(b);\n    for (;;) {\n        if (temp_a == 0) {\n            output.set_to(temp_b);\n            return;\n        }\n\n        // temp_b %= temp_a\n        UnsignedBigInteger::divide_without_allocation(temp_b, temp_a, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n        temp_b.set_to(temp_remainder);\n        if (temp_b == 0) {\n            output.set_to(temp_a);\n            return;\n        }\n\n        // temp_a %= temp_b\n        UnsignedBigInteger::divide_without_allocation(temp_a, temp_b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n        temp_a.set_to(temp_remainder);\n    }\n}\n\nUnsignedBigInteger GCD(const UnsignedBigInteger& a, const UnsignedBigInteger& b)\n{\n    UnsignedBigInteger temp_a;\n    UnsignedBigInteger temp_b;\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n    UnsignedBigInteger output;\n\n    GCD_without_allocation(a, b, temp_a, temp_b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder, output);\n\n    return output;\n}\n\nUnsignedBigInteger LCM(const UnsignedBigInteger& a, const UnsignedBigInteger& b)\n{\n    UnsignedBigInteger temp_a;\n    UnsignedBigInteger temp_b;\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n    UnsignedBigInteger gcd_output;\n    UnsignedBigInteger output { 0 };\n\n    GCD_without_allocation(a, b, temp_a, temp_b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder, gcd_output);\n    if (gcd_output == 0) {\n#if NT_DEBUG\n        dbgln(\"GCD is zero\");\n#endif\n        return output;\n    }\n\n    // output = (a / gcd_output) * b\n    UnsignedBigInteger::divide_without_allocation(a, gcd_output, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n    UnsignedBigInteger::multiply_without_allocation(temp_quotient, b, temp_1, temp_2, temp_3, temp_4, output);\n\n    dbgln_if(NT_DEBUG, \"quot: {} rem: {} out: {}\", temp_quotient, temp_remainder, output);\n\n    return output;\n}\n\nstatic bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    // Written using Wikipedia:\n    // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Miller%E2%80%93Rabin_test\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        // n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto a : tests) {\n        // Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        // r \u2212 1 iterations.\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; // \"composite\"\n    }\n\n    return true; // \"probably prime\"\n}\n\nUnsignedBigInteger random_number(const UnsignedBigInteger& min, const UnsignedBigInteger& max_excluded)\n{\n    ASSERT(min < max_excluded);\n    auto range = max_excluded.minus(min);\n    UnsignedBigInteger base;\n    auto size = range.trimmed_length() * sizeof(u32) + 2;\n    // \"+2\" is intentional (see below).\n    // Also, if we're about to crash anyway, at least produce a nice error:\n    ASSERT(size < 8 * MiB);\n    u8 buf[size];\n    AK::fill_with_random(buf, size);\n    UnsignedBigInteger random { buf, size };\n    // At this point, `random` is a large number, in the range [0, 256^size).\n    // To get down to the actual range, we could just compute random % range.\n    // This introduces \"modulo bias\". However, since we added 2 to `size`,\n    // we know that the generated range is at least 65536 times as large as the\n    // required range! This means that the modulo bias is only 0.0015%, if all\n    // inputs are chosen adversarially. Let's hope this is good enough.\n    auto divmod = random.divided_by(range);\n    // The proper way to fix this is to restart if `divmod.quotient` is maximal.\n    return divmod.remainder.plus(min);\n}\n\nbool is_probably_prime(const UnsignedBigInteger& p)\n{\n    // Is it a small number?\n    if (p < 49) {\n        u32 p_value = p.words()[0];\n        // Is it a very small prime?\n        if (p_value == 2 || p_value == 3 || p_value == 5 || p_value == 7)\n            return true;\n        // Is it the multiple of a very small prime?\n        if (p_value % 2 == 0 || p_value % 3 == 0 || p_value % 5 == 0 || p_value % 7 == 0)\n            return false;\n        // Then it must be a prime, but not a very small prime, like 37.\n        return true;\n    }\n\n    Vector<UnsignedBigInteger, 256> tests;\n    // Make some good initial guesses that are guaranteed to find all primes < 2^64.\n    tests.append(UnsignedBigInteger(2));\n    tests.append(UnsignedBigInteger(3));\n    tests.append(UnsignedBigInteger(5));\n    tests.append(UnsignedBigInteger(7));\n    tests.append(UnsignedBigInteger(11));\n    tests.append(UnsignedBigInteger(13));\n    UnsignedBigInteger seventeen { 17 };\n    for (size_t i = tests.size(); i < 256; ++i) {\n        tests.append(random_number(seventeen, p.minus(2)));\n    }\n    // Miller-Rabin's \"error\" is 8^-k. In adversarial cases, it's 4^-k.\n    // With 200 random numbers, this would mean an error of about 2^-400.\n    // So we don't need to worry too much about the quality of the random numbers.\n\n    return MR_primality_test(p, tests);\n}\n\nUnsignedBigInteger random_big_prime(size_t bits)\n{\n    ASSERT(bits >= 33);\n    UnsignedBigInteger min = UnsignedBigInteger::from_base10(\"6074001000\").shift_left(bits - 33);\n    UnsignedBigInteger max = UnsignedBigInteger { 1 }.shift_left(bits).minus(1);\n    for (;;) {\n        auto p = random_number(min, max);\n        if ((p.words()[0] & 1) == 0) {\n            // An even number is definitely not a large prime.\n            continue;\n        }\n        if (is_probably_prime(p))\n            return p;\n    }\n}\n\n}\n}\n"], "fixing_code": ["/*\n * Copyright (c) 2020, Ali Mohammad Pur <ali.mpfard@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice, this\n *    list of conditions and the following disclaimer.\n *\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <AK/Debug.h>\n#include <LibCrypto/NumberTheory/ModularFunctions.h>\n\nnamespace Crypto {\nnamespace NumberTheory {\n\nUnsignedBigInteger ModularInverse(const UnsignedBigInteger& a_, const UnsignedBigInteger& b)\n{\n    if (b == 1)\n        return { 1 };\n\n    UnsignedBigInteger one { 1 };\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_plus;\n    UnsignedBigInteger temp_minus;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n    UnsignedBigInteger d;\n\n    auto a = a_;\n    auto u = a;\n    if (a.words()[0] % 2 == 0) {\n        // u += b\n        UnsignedBigInteger::add_without_allocation(u, b, temp_plus);\n        u.set_to(temp_plus);\n    }\n\n    auto v = b;\n    UnsignedBigInteger x { 0 };\n\n    // d = b - 1\n    UnsignedBigInteger::subtract_without_allocation(b, one, d);\n\n    while (!(v == 1)) {\n        while (v < u) {\n            // u -= v\n            UnsignedBigInteger::subtract_without_allocation(u, v, temp_minus);\n            u.set_to(temp_minus);\n\n            // d += x\n            UnsignedBigInteger::add_without_allocation(d, x, temp_plus);\n            d.set_to(temp_plus);\n\n            while (u.words()[0] % 2 == 0) {\n                if (d.words()[0] % 2 == 1) {\n                    // d += b\n                    UnsignedBigInteger::add_without_allocation(d, b, temp_plus);\n                    d.set_to(temp_plus);\n                }\n\n                // u /= 2\n                UnsignedBigInteger::divide_u16_without_allocation(u, 2, temp_quotient, temp_remainder);\n                u.set_to(temp_quotient);\n\n                // d /= 2\n                UnsignedBigInteger::divide_u16_without_allocation(d, 2, temp_quotient, temp_remainder);\n                d.set_to(temp_quotient);\n            }\n        }\n\n        // v -= u\n        UnsignedBigInteger::subtract_without_allocation(v, u, temp_minus);\n        v.set_to(temp_minus);\n\n        // x += d\n        UnsignedBigInteger::add_without_allocation(x, d, temp_plus);\n        x.set_to(temp_plus);\n\n        while (v.words()[0] % 2 == 0) {\n            if (x.words()[0] % 2 == 1) {\n                // x += b\n                UnsignedBigInteger::add_without_allocation(x, b, temp_plus);\n                x.set_to(temp_plus);\n            }\n\n            // v /= 2\n            UnsignedBigInteger::divide_u16_without_allocation(v, 2, temp_quotient, temp_remainder);\n            v.set_to(temp_quotient);\n\n            // x /= 2\n            UnsignedBigInteger::divide_u16_without_allocation(x, 2, temp_quotient, temp_remainder);\n            x.set_to(temp_quotient);\n        }\n    }\n\n    // x % b\n    UnsignedBigInteger::divide_without_allocation(x, b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n    return temp_remainder;\n}\n\nUnsignedBigInteger ModularPower(const UnsignedBigInteger& b, const UnsignedBigInteger& e, const UnsignedBigInteger& m)\n{\n    if (m == 1)\n        return 0;\n\n    UnsignedBigInteger ep { e };\n    UnsignedBigInteger base { b };\n    UnsignedBigInteger exp { 1 };\n\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_multiply;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n\n    while (!(ep < 1)) {\n        if (ep.words()[0] % 2 == 1) {\n            // exp = (exp * base) % m;\n            UnsignedBigInteger::multiply_without_allocation(exp, base, temp_1, temp_2, temp_3, temp_4, temp_multiply);\n            UnsignedBigInteger::divide_without_allocation(temp_multiply, m, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n            exp.set_to(temp_remainder);\n        }\n\n        // ep = ep / 2;\n        UnsignedBigInteger::divide_u16_without_allocation(ep, 2, temp_quotient, temp_remainder);\n        ep.set_to(temp_quotient);\n\n        // base = (base * base) % m;\n        UnsignedBigInteger::multiply_without_allocation(base, base, temp_1, temp_2, temp_3, temp_4, temp_multiply);\n        UnsignedBigInteger::divide_without_allocation(temp_multiply, m, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n        base.set_to(temp_remainder);\n    }\n    return exp;\n}\n\nstatic void GCD_without_allocation(\n    const UnsignedBigInteger& a,\n    const UnsignedBigInteger& b,\n    UnsignedBigInteger& temp_a,\n    UnsignedBigInteger& temp_b,\n    UnsignedBigInteger& temp_1,\n    UnsignedBigInteger& temp_2,\n    UnsignedBigInteger& temp_3,\n    UnsignedBigInteger& temp_4,\n    UnsignedBigInteger& temp_quotient,\n    UnsignedBigInteger& temp_remainder,\n    UnsignedBigInteger& output)\n{\n    temp_a.set_to(a);\n    temp_b.set_to(b);\n    for (;;) {\n        if (temp_a == 0) {\n            output.set_to(temp_b);\n            return;\n        }\n\n        // temp_b %= temp_a\n        UnsignedBigInteger::divide_without_allocation(temp_b, temp_a, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n        temp_b.set_to(temp_remainder);\n        if (temp_b == 0) {\n            output.set_to(temp_a);\n            return;\n        }\n\n        // temp_a %= temp_b\n        UnsignedBigInteger::divide_without_allocation(temp_a, temp_b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n        temp_a.set_to(temp_remainder);\n    }\n}\n\nUnsignedBigInteger GCD(const UnsignedBigInteger& a, const UnsignedBigInteger& b)\n{\n    UnsignedBigInteger temp_a;\n    UnsignedBigInteger temp_b;\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n    UnsignedBigInteger output;\n\n    GCD_without_allocation(a, b, temp_a, temp_b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder, output);\n\n    return output;\n}\n\nUnsignedBigInteger LCM(const UnsignedBigInteger& a, const UnsignedBigInteger& b)\n{\n    UnsignedBigInteger temp_a;\n    UnsignedBigInteger temp_b;\n    UnsignedBigInteger temp_1;\n    UnsignedBigInteger temp_2;\n    UnsignedBigInteger temp_3;\n    UnsignedBigInteger temp_4;\n    UnsignedBigInteger temp_quotient;\n    UnsignedBigInteger temp_remainder;\n    UnsignedBigInteger gcd_output;\n    UnsignedBigInteger output { 0 };\n\n    GCD_without_allocation(a, b, temp_a, temp_b, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder, gcd_output);\n    if (gcd_output == 0) {\n#if NT_DEBUG\n        dbgln(\"GCD is zero\");\n#endif\n        return output;\n    }\n\n    // output = (a / gcd_output) * b\n    UnsignedBigInteger::divide_without_allocation(a, gcd_output, temp_1, temp_2, temp_3, temp_4, temp_quotient, temp_remainder);\n    UnsignedBigInteger::multiply_without_allocation(temp_quotient, b, temp_1, temp_2, temp_3, temp_4, output);\n\n    dbgln_if(NT_DEBUG, \"quot: {} rem: {} out: {}\", temp_quotient, temp_remainder, output);\n\n    return output;\n}\n\nstatic bool MR_primality_test(UnsignedBigInteger n, const Vector<UnsignedBigInteger, 256>& tests)\n{\n    // Written using Wikipedia:\n    // https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test#Miller%E2%80%93Rabin_test\n    ASSERT(!(n < 4));\n    auto predecessor = n.minus({ 1 });\n    auto d = predecessor;\n    size_t r = 0;\n\n    {\n        auto div_result = d.divided_by(2);\n        while (div_result.remainder == 0) {\n            d = div_result.quotient;\n            div_result = d.divided_by(2);\n            ++r;\n        }\n    }\n    if (r == 0) {\n        // n - 1 is odd, so n was even. But there is only one even prime:\n        return n == 2;\n    }\n\n    for (auto& a : tests) {\n        // Technically: ASSERT(2 <= a && a <= n - 2)\n        ASSERT(a < n);\n        auto x = ModularPower(a, d, n);\n        if (x == 1 || x == predecessor)\n            continue;\n        bool skip_this_witness = false;\n        // r \u2212 1 iterations.\n        for (size_t i = 0; i < r - 1; ++i) {\n            x = ModularPower(x, 2, n);\n            if (x == predecessor) {\n                skip_this_witness = true;\n                break;\n            }\n        }\n        if (skip_this_witness)\n            continue;\n        return false; // \"composite\"\n    }\n\n    return true; // \"probably prime\"\n}\n\nUnsignedBigInteger random_number(const UnsignedBigInteger& min, const UnsignedBigInteger& max_excluded)\n{\n    ASSERT(min < max_excluded);\n    auto range = max_excluded.minus(min);\n    UnsignedBigInteger base;\n    auto size = range.trimmed_length() * sizeof(u32) + 2;\n    // \"+2\" is intentional (see below).\n    // Also, if we're about to crash anyway, at least produce a nice error:\n    ASSERT(size < 8 * MiB);\n    u8 buf[size];\n    AK::fill_with_random(buf, size);\n    UnsignedBigInteger random { buf, size };\n    // At this point, `random` is a large number, in the range [0, 256^size).\n    // To get down to the actual range, we could just compute random % range.\n    // This introduces \"modulo bias\". However, since we added 2 to `size`,\n    // we know that the generated range is at least 65536 times as large as the\n    // required range! This means that the modulo bias is only 0.0015%, if all\n    // inputs are chosen adversarially. Let's hope this is good enough.\n    auto divmod = random.divided_by(range);\n    // The proper way to fix this is to restart if `divmod.quotient` is maximal.\n    return divmod.remainder.plus(min);\n}\n\nbool is_probably_prime(const UnsignedBigInteger& p)\n{\n    // Is it a small number?\n    if (p < 49) {\n        u32 p_value = p.words()[0];\n        // Is it a very small prime?\n        if (p_value == 2 || p_value == 3 || p_value == 5 || p_value == 7)\n            return true;\n        // Is it the multiple of a very small prime?\n        if (p_value % 2 == 0 || p_value % 3 == 0 || p_value % 5 == 0 || p_value % 7 == 0)\n            return false;\n        // Then it must be a prime, but not a very small prime, like 37.\n        return true;\n    }\n\n    Vector<UnsignedBigInteger, 256> tests;\n    // Make some good initial guesses that are guaranteed to find all primes < 2^64.\n    tests.append(UnsignedBigInteger(2));\n    tests.append(UnsignedBigInteger(3));\n    tests.append(UnsignedBigInteger(5));\n    tests.append(UnsignedBigInteger(7));\n    tests.append(UnsignedBigInteger(11));\n    tests.append(UnsignedBigInteger(13));\n    UnsignedBigInteger seventeen { 17 };\n    for (size_t i = tests.size(); i < 256; ++i) {\n        tests.append(random_number(seventeen, p.minus(2)));\n    }\n    // Miller-Rabin's \"error\" is 8^-k. In adversarial cases, it's 4^-k.\n    // With 200 random numbers, this would mean an error of about 2^-400.\n    // So we don't need to worry too much about the quality of the random numbers.\n\n    return MR_primality_test(p, tests);\n}\n\nUnsignedBigInteger random_big_prime(size_t bits)\n{\n    ASSERT(bits >= 33);\n    UnsignedBigInteger min = UnsignedBigInteger::from_base10(\"6074001000\").shift_left(bits - 33);\n    UnsignedBigInteger max = UnsignedBigInteger { 1 }.shift_left(bits).minus(1);\n    for (;;) {\n        auto p = random_number(min, max);\n        if ((p.words()[0] & 1) == 0) {\n            // An even number is definitely not a large prime.\n            continue;\n        }\n        if (is_probably_prime(p))\n            return p;\n    }\n}\n\n}\n}\n"], "filenames": ["Userland/Libraries/LibCrypto/NumberTheory/ModularFunctions.cpp"], "buggy_code_start_loc": [261], "buggy_code_end_loc": [262], "fixing_code_start_loc": [261], "fixing_code_end_loc": [262], "type": "CWE-120", "message": "SerenityOS Unspecified is affected by: Buffer Overflow. The impact is: obtain sensitive information (context-dependent). The component is: /Userland/Libraries/LibCrypto/ASN1/DER.h Crypto::der_decode_sequence() function. The attack vector is: Parsing RSA Key ASN.1.", "other": {"cve": {"id": "CVE-2021-27343", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-06T13:15:14.200", "lastModified": "2022-12-08T18:55:41.790", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "SerenityOS Unspecified is affected by: Buffer Overflow. The impact is: obtain sensitive information (context-dependent). The component is: /Userland/Libraries/LibCrypto/ASN1/DER.h Crypto::der_decode_sequence() function. The attack vector is: Parsing RSA Key ASN.1."}, {"lang": "es", "value": "SerenityOS Unspecified est\u00e1 afectado por: un Desbordamiento del B\u00fafer.&#xa0;El impacto es: obtener informaci\u00f3n confidencial (dependiente del contexto).&#xa0;El componente es: la funci\u00f3n Crypto::der_decode_sequence() del archivo /Userland/Libraries/LibCrypto/ASN1/DER.h.&#xa0;El vector de ataque es: Parsing RSA Key ASN.1"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:serenityos:serenityos:-:*:*:*:*:*:*:*", "matchCriteriaId": "F0A631C0-3E3F-4FC9-8E7D-8843F0133B9C"}]}]}], "references": [{"url": "https://github.com/SerenityOS/serenity/commit/48fbf6a88d4822a1e5470cf08f29464511bd72c1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/SerenityOS/serenity/issues/5317", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/SerenityOS/serenity/pull/5344", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/SerenityOS/serenity/commit/48fbf6a88d4822a1e5470cf08f29464511bd72c1"}}