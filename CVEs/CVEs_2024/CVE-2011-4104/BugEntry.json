{"buggy_code": ["import datetime\nfrom StringIO import StringIO\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.serializers import json\nfrom django.utils import simplejson\nfrom django.utils.encoding import force_unicode\nfrom tastypie.bundle import Bundle\nfrom tastypie.exceptions import UnsupportedFormat\nfrom tastypie.utils import format_datetime, format_date, format_time\ntry:\n    import lxml\n    from lxml.etree import parse as parse_xml\n    from lxml.etree import Element, tostring\nexcept ImportError:\n    lxml = None\ntry:\n    import yaml\n    from django.core.serializers import pyyaml\nexcept ImportError:\n    yaml = None\ntry:\n    import biplist\nexcept ImportError:\n    biplist = None\n\n\nclass Serializer(object):\n    \"\"\"\n    A swappable class for serialization.\n    \n    This handles most types of data as well as the following output formats::\n    \n        * json\n        * jsonp\n        * xml\n        * yaml\n        * html\n        * plist (see http://explorapp.com/biplist/)\n    \n    It was designed to make changing behavior easy, either by overridding the\n    various format methods (i.e. ``to_json``), by changing the\n    ``formats/content_types`` options or by altering the other hook methods.\n    \"\"\"\n    formats = ['json', 'jsonp', 'xml', 'yaml', 'html', 'plist']\n    content_types = {\n        'json': 'application/json',\n        'jsonp': 'text/javascript',\n        'xml': 'application/xml',\n        'yaml': 'text/yaml',\n        'html': 'text/html',\n        'plist': 'application/x-plist',\n    }\n    \n    def __init__(self, formats=None, content_types=None, datetime_formatting=None):\n        self.supported_formats = []\n        self.datetime_formatting = getattr(settings, 'TASTYPIE_DATETIME_FORMATTING', 'iso-8601')\n        \n        if formats is not None:\n            self.formats = formats\n        \n        if content_types is not None:\n            self.content_types = content_types\n        \n        if datetime_formatting is not None:\n            self.datetime_formatting = datetime_formatting\n        \n        for format in self.formats:\n            try:\n                self.supported_formats.append(self.content_types[format])\n            except KeyError:\n                raise ImproperlyConfigured(\"Content type for specified type '%s' not found. Please provide it at either the class level or via the arguments.\" % format)\n    \n    def get_mime_for_format(self, format):\n        \"\"\"\n        Given a format, attempts to determine the correct MIME type.\n        \n        If not available on the current ``Serializer``, returns\n        ``application/json`` by default.\n        \"\"\"\n        try:\n            return self.content_types[format]\n        except KeyError:\n            return 'application/json'\n    \n    def format_datetime(self, data):\n        \"\"\"\n        A hook to control how datetimes are formatted.\n        \n        Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n        \n        Default is ``iso-8601``, which looks like \"2010-12-16T03:02:14\".\n        \"\"\"\n        if self.datetime_formatting == 'rfc-2822':\n            return format_datetime(data)\n        \n        return data.isoformat()\n    \n    def format_date(self, data):\n        \"\"\"\n        A hook to control how dates are formatted.\n        \n        Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n        \n        Default is ``iso-8601``, which looks like \"2010-12-16\".\n        \"\"\"\n        if self.datetime_formatting == 'rfc-2822':\n            return format_date(data)\n        \n        return data.isoformat()\n    \n    def format_time(self, data):\n        \"\"\"\n        A hook to control how times are formatted.\n        \n        Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n        \n        Default is ``iso-8601``, which looks like \"03:02:14\".\n        \"\"\"\n        if self.datetime_formatting == 'rfc-2822':\n            return format_time(data)\n        \n        return data.isoformat()\n    \n    def serialize(self, bundle, format='application/json', options={}):\n        \"\"\"\n        Given some data and a format, calls the correct method to serialize\n        the data and returns the result.\n        \"\"\"\n        desired_format = None\n        \n        for short_format, long_format in self.content_types.items():\n            if format == long_format:\n                if hasattr(self, \"to_%s\" % short_format):\n                    desired_format = short_format\n                    break\n        \n        if desired_format is None:\n            raise UnsupportedFormat(\"The format indicated '%s' had no available serialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)\n        \n        serialized = getattr(self, \"to_%s\" % desired_format)(bundle, options)\n        return serialized\n    \n    def deserialize(self, content, format='application/json'):\n        \"\"\"\n        Given some data and a format, calls the correct method to deserialize\n        the data and returns the result.\n        \"\"\"\n        desired_format = None\n\n        format = format.split(';')[0]\n\n        for short_format, long_format in self.content_types.items():\n            if format == long_format:\n                if hasattr(self, \"from_%s\" % short_format):\n                    desired_format = short_format\n                    break\n        \n        if desired_format is None:\n            raise UnsupportedFormat(\"The format indicated '%s' had no available deserialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)\n        \n        deserialized = getattr(self, \"from_%s\" % desired_format)(content)\n        return deserialized\n\n    def to_simple(self, data, options):\n        \"\"\"\n        For a piece of data, attempts to recognize it and provide a simplified\n        form of something complex.\n        \n        This brings complex Python data structures down to native types of the\n        serialization format(s).\n        \"\"\"\n        if isinstance(data, (list, tuple)):\n            return [self.to_simple(item, options) for item in data]\n        if isinstance(data, dict):\n            return dict((key, self.to_simple(val, options)) for (key, val) in data.iteritems())\n        elif isinstance(data, Bundle):\n            return dict((key, self.to_simple(val, options)) for (key, val) in data.data.iteritems())\n        elif hasattr(data, 'dehydrated_type'):\n            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:\n                if data.full:\n                    return self.to_simple(data.fk_resource, options)\n                else:\n                    return self.to_simple(data.value, options)\n            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:\n                if data.full:\n                    return [self.to_simple(bundle, options) for bundle in data.m2m_bundles]\n                else:\n                    return [self.to_simple(val, options) for val in data.value]\n            else:\n                return self.to_simple(data.value, options)\n        elif isinstance(data, datetime.datetime):\n            return self.format_datetime(data)\n        elif isinstance(data, datetime.date):\n            return self.format_date(data)\n        elif isinstance(data, datetime.time):\n            return self.format_time(data)\n        elif isinstance(data, bool):\n            return data\n        elif type(data) in (long, int, float):\n            return data\n        elif data is None:\n            return None\n        else:\n            return force_unicode(data)\n\n    def to_etree(self, data, options=None, name=None, depth=0):\n        \"\"\"\n        Given some data, converts that data to an ``etree.Element`` suitable\n        for use in the XML output.\n        \"\"\"\n        if isinstance(data, (list, tuple)):\n            element = Element(name or 'objects')\n            if name:\n                element = Element(name)\n                element.set('type', 'list')\n            else:\n                element = Element('objects')\n            for item in data:\n                element.append(self.to_etree(item, options, depth=depth+1))\n        elif isinstance(data, dict):\n            if depth == 0:\n                element = Element(name or 'response')\n            else:\n                element = Element(name or 'object')\n                element.set('type', 'hash')\n            for (key, value) in data.iteritems():\n                element.append(self.to_etree(value, options, name=key, depth=depth+1))\n        elif isinstance(data, Bundle):\n            element = Element(name or 'object')\n            for field_name, field_object in data.data.items():\n                element.append(self.to_etree(field_object, options, name=field_name, depth=depth+1))\n        elif hasattr(data, 'dehydrated_type'):\n            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:\n                if data.full:\n                    return self.to_etree(data.fk_resource, options, name, depth+1)\n                else:\n                    return self.to_etree(data.value, options, name, depth+1)\n            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:\n                if data.full:\n                    element = Element(name or 'objects')\n                    for bundle in data.m2m_bundles:\n                        element.append(self.to_etree(bundle, options, bundle.resource_name, depth+1))\n                else:\n                    element = Element(name or 'objects')\n                    for value in data.value:\n                        element.append(self.to_etree(value, options, name, depth=depth+1))\n            else:\n                return self.to_etree(data.value, options, name)\n        else:\n            element = Element(name or 'value')\n            simple_data = self.to_simple(data, options)\n            data_type = get_type_string(simple_data)\n            if data_type != 'string':\n                element.set('type', get_type_string(simple_data))\n            if data_type != 'null':\n                element.text = force_unicode(simple_data)\n        return element\n\n    def from_etree(self, data):\n        \"\"\"\n        Not the smartest deserializer on the planet. At the request level,\n        it first tries to output the deserialized subelement called \"object\"\n        or \"objects\" and falls back to deserializing based on hinted types in\n        the XML element attribute \"type\".\n        \"\"\"\n        if data.tag == 'request':\n            # if \"object\" or \"objects\" exists, return deserialized forms.\n            elements = data.getchildren()\n            for element in elements:\n                if element.tag in ('object', 'objects'):\n                    return self.from_etree(element)\n            return dict((element.tag, self.from_etree(element)) for element in elements)\n        elif data.tag == 'object' or data.get('type') == 'hash':\n            return dict((element.tag, self.from_etree(element)) for element in data.getchildren())\n        elif data.tag == 'objects' or data.get('type') == 'list':\n            return [self.from_etree(element) for element in data.getchildren()]\n        else:\n            type_string = data.get('type')\n            if type_string in ('string', None):\n                return data.text\n            elif type_string == 'integer':\n                return int(data.text)\n            elif type_string == 'float':\n                return float(data.text)\n            elif type_string == 'boolean':\n                if data.text == 'True':\n                    return True\n                else:\n                    return False\n            else:\n                return None\n            \n    def to_json(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces JSON output.\n        \"\"\"\n        options = options or {}\n        data = self.to_simple(data, options)\n        return simplejson.dumps(data, cls=json.DjangoJSONEncoder, sort_keys=True)\n\n    def from_json(self, content):\n        \"\"\"\n        Given some JSON data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        return simplejson.loads(content)\n\n    def to_jsonp(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces JSON output wrapped in the provided\n        callback.\n        \"\"\"\n        options = options or {}\n        return '%s(%s)' % (options['callback'], self.to_json(data, options))\n\n    def to_xml(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces XML output.\n        \"\"\"\n        options = options or {}\n        \n        if lxml is None:\n            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")\n        \n        return tostring(self.to_etree(data, options), xml_declaration=True, encoding='utf-8')\n    \n    def from_xml(self, content):\n        \"\"\"\n        Given some XML data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        if lxml is None:\n            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")\n        \n        return self.from_etree(parse_xml(StringIO(content)).getroot())\n    \n    def to_yaml(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces YAML output.\n        \"\"\"\n        options = options or {}\n        \n        if yaml is None:\n            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")\n        \n        return yaml.dump(self.to_simple(data, options))\n    \n    def from_yaml(self, content):\n        \"\"\"\n        Given some YAML data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        if yaml is None:\n            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")\n        \n        return yaml.load(content)\n    \n    def to_plist(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces binary plist output.\n        \"\"\"\n        options = options or {}\n        \n        if biplist is None:\n            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")\n        \n        return biplist.writePlistToString(self.to_simple(data, options))\n    \n    def from_plist(self, content):\n        \"\"\"\n        Given some binary plist data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        if biplist is None:\n            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")\n        \n        return biplist.readPlistFromString(content)\n    \n    def to_html(self, data, options=None):\n        \"\"\"\n        Reserved for future usage.\n        \n        The desire is to provide HTML output of a resource, making an API\n        available to a browser. This is on the TODO list but not currently\n        implemented.\n        \"\"\"\n        options = options or {}\n        return 'Sorry, not implemented yet. Please append \"?format=json\" to your URL.'\n    \n    def from_html(self, content):\n        \"\"\"\n        Reserved for future usage.\n        \n        The desire is to handle form-based (maybe Javascript?) input, making an\n        API available to a browser. This is on the TODO list but not currently\n        implemented.\n        \"\"\"\n        pass\n\ndef get_type_string(data):\n    \"\"\"\n    Translates a Python data type into a string format.\n    \"\"\"\n    data_type = type(data)\n    \n    if data_type in (int, long):\n        return 'integer'\n    elif data_type == float:\n        return 'float'\n    elif data_type == bool:\n        return 'boolean'\n    elif data_type in (list, tuple):\n        return 'list'\n    elif data_type == dict:\n        return 'hash'\n    elif data is None:\n        return 'null'\n    elif isinstance(data, basestring):\n        return 'string'\n"], "fixing_code": ["import datetime\nfrom StringIO import StringIO\nfrom django.conf import settings\nfrom django.core.exceptions import ImproperlyConfigured\nfrom django.core.serializers import json\nfrom django.utils import simplejson\nfrom django.utils.encoding import force_unicode\nfrom tastypie.bundle import Bundle\nfrom tastypie.exceptions import UnsupportedFormat\nfrom tastypie.utils import format_datetime, format_date, format_time\ntry:\n    import lxml\n    from lxml.etree import parse as parse_xml\n    from lxml.etree import Element, tostring\nexcept ImportError:\n    lxml = None\ntry:\n    import yaml\n    from django.core.serializers import pyyaml\nexcept ImportError:\n    yaml = None\ntry:\n    import biplist\nexcept ImportError:\n    biplist = None\n\n\nclass Serializer(object):\n    \"\"\"\n    A swappable class for serialization.\n\n    This handles most types of data as well as the following output formats::\n\n        * json\n        * jsonp\n        * xml\n        * yaml\n        * html\n        * plist (see http://explorapp.com/biplist/)\n\n    It was designed to make changing behavior easy, either by overridding the\n    various format methods (i.e. ``to_json``), by changing the\n    ``formats/content_types`` options or by altering the other hook methods.\n    \"\"\"\n    formats = ['json', 'jsonp', 'xml', 'yaml', 'html', 'plist']\n    content_types = {\n        'json': 'application/json',\n        'jsonp': 'text/javascript',\n        'xml': 'application/xml',\n        'yaml': 'text/yaml',\n        'html': 'text/html',\n        'plist': 'application/x-plist',\n    }\n\n    def __init__(self, formats=None, content_types=None, datetime_formatting=None):\n        self.supported_formats = []\n        self.datetime_formatting = getattr(settings, 'TASTYPIE_DATETIME_FORMATTING', 'iso-8601')\n\n        if formats is not None:\n            self.formats = formats\n\n        if content_types is not None:\n            self.content_types = content_types\n\n        if datetime_formatting is not None:\n            self.datetime_formatting = datetime_formatting\n\n        for format in self.formats:\n            try:\n                self.supported_formats.append(self.content_types[format])\n            except KeyError:\n                raise ImproperlyConfigured(\"Content type for specified type '%s' not found. Please provide it at either the class level or via the arguments.\" % format)\n\n    def get_mime_for_format(self, format):\n        \"\"\"\n        Given a format, attempts to determine the correct MIME type.\n\n        If not available on the current ``Serializer``, returns\n        ``application/json`` by default.\n        \"\"\"\n        try:\n            return self.content_types[format]\n        except KeyError:\n            return 'application/json'\n\n    def format_datetime(self, data):\n        \"\"\"\n        A hook to control how datetimes are formatted.\n\n        Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n\n        Default is ``iso-8601``, which looks like \"2010-12-16T03:02:14\".\n        \"\"\"\n        if self.datetime_formatting == 'rfc-2822':\n            return format_datetime(data)\n\n        return data.isoformat()\n\n    def format_date(self, data):\n        \"\"\"\n        A hook to control how dates are formatted.\n\n        Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n\n        Default is ``iso-8601``, which looks like \"2010-12-16\".\n        \"\"\"\n        if self.datetime_formatting == 'rfc-2822':\n            return format_date(data)\n\n        return data.isoformat()\n\n    def format_time(self, data):\n        \"\"\"\n        A hook to control how times are formatted.\n\n        Can be overridden at the ``Serializer`` level (``datetime_formatting``)\n        or globally (via ``settings.TASTYPIE_DATETIME_FORMATTING``).\n\n        Default is ``iso-8601``, which looks like \"03:02:14\".\n        \"\"\"\n        if self.datetime_formatting == 'rfc-2822':\n            return format_time(data)\n\n        return data.isoformat()\n\n    def serialize(self, bundle, format='application/json', options={}):\n        \"\"\"\n        Given some data and a format, calls the correct method to serialize\n        the data and returns the result.\n        \"\"\"\n        desired_format = None\n\n        for short_format, long_format in self.content_types.items():\n            if format == long_format:\n                if hasattr(self, \"to_%s\" % short_format):\n                    desired_format = short_format\n                    break\n\n        if desired_format is None:\n            raise UnsupportedFormat(\"The format indicated '%s' had no available serialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)\n\n        serialized = getattr(self, \"to_%s\" % desired_format)(bundle, options)\n        return serialized\n\n    def deserialize(self, content, format='application/json'):\n        \"\"\"\n        Given some data and a format, calls the correct method to deserialize\n        the data and returns the result.\n        \"\"\"\n        desired_format = None\n\n        format = format.split(';')[0]\n\n        for short_format, long_format in self.content_types.items():\n            if format == long_format:\n                if hasattr(self, \"from_%s\" % short_format):\n                    desired_format = short_format\n                    break\n\n        if desired_format is None:\n            raise UnsupportedFormat(\"The format indicated '%s' had no available deserialization method. Please check your ``formats`` and ``content_types`` on your Serializer.\" % format)\n\n        deserialized = getattr(self, \"from_%s\" % desired_format)(content)\n        return deserialized\n\n    def to_simple(self, data, options):\n        \"\"\"\n        For a piece of data, attempts to recognize it and provide a simplified\n        form of something complex.\n\n        This brings complex Python data structures down to native types of the\n        serialization format(s).\n        \"\"\"\n        if isinstance(data, (list, tuple)):\n            return [self.to_simple(item, options) for item in data]\n        if isinstance(data, dict):\n            return dict((key, self.to_simple(val, options)) for (key, val) in data.iteritems())\n        elif isinstance(data, Bundle):\n            return dict((key, self.to_simple(val, options)) for (key, val) in data.data.iteritems())\n        elif hasattr(data, 'dehydrated_type'):\n            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:\n                if data.full:\n                    return self.to_simple(data.fk_resource, options)\n                else:\n                    return self.to_simple(data.value, options)\n            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:\n                if data.full:\n                    return [self.to_simple(bundle, options) for bundle in data.m2m_bundles]\n                else:\n                    return [self.to_simple(val, options) for val in data.value]\n            else:\n                return self.to_simple(data.value, options)\n        elif isinstance(data, datetime.datetime):\n            return self.format_datetime(data)\n        elif isinstance(data, datetime.date):\n            return self.format_date(data)\n        elif isinstance(data, datetime.time):\n            return self.format_time(data)\n        elif isinstance(data, bool):\n            return data\n        elif type(data) in (long, int, float):\n            return data\n        elif data is None:\n            return None\n        else:\n            return force_unicode(data)\n\n    def to_etree(self, data, options=None, name=None, depth=0):\n        \"\"\"\n        Given some data, converts that data to an ``etree.Element`` suitable\n        for use in the XML output.\n        \"\"\"\n        if isinstance(data, (list, tuple)):\n            element = Element(name or 'objects')\n            if name:\n                element = Element(name)\n                element.set('type', 'list')\n            else:\n                element = Element('objects')\n            for item in data:\n                element.append(self.to_etree(item, options, depth=depth+1))\n        elif isinstance(data, dict):\n            if depth == 0:\n                element = Element(name or 'response')\n            else:\n                element = Element(name or 'object')\n                element.set('type', 'hash')\n            for (key, value) in data.iteritems():\n                element.append(self.to_etree(value, options, name=key, depth=depth+1))\n        elif isinstance(data, Bundle):\n            element = Element(name or 'object')\n            for field_name, field_object in data.data.items():\n                element.append(self.to_etree(field_object, options, name=field_name, depth=depth+1))\n        elif hasattr(data, 'dehydrated_type'):\n            if getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == False:\n                if data.full:\n                    return self.to_etree(data.fk_resource, options, name, depth+1)\n                else:\n                    return self.to_etree(data.value, options, name, depth+1)\n            elif getattr(data, 'dehydrated_type', None) == 'related' and data.is_m2m == True:\n                if data.full:\n                    element = Element(name or 'objects')\n                    for bundle in data.m2m_bundles:\n                        element.append(self.to_etree(bundle, options, bundle.resource_name, depth+1))\n                else:\n                    element = Element(name or 'objects')\n                    for value in data.value:\n                        element.append(self.to_etree(value, options, name, depth=depth+1))\n            else:\n                return self.to_etree(data.value, options, name)\n        else:\n            element = Element(name or 'value')\n            simple_data = self.to_simple(data, options)\n            data_type = get_type_string(simple_data)\n            if data_type != 'string':\n                element.set('type', get_type_string(simple_data))\n            if data_type != 'null':\n                element.text = force_unicode(simple_data)\n        return element\n\n    def from_etree(self, data):\n        \"\"\"\n        Not the smartest deserializer on the planet. At the request level,\n        it first tries to output the deserialized subelement called \"object\"\n        or \"objects\" and falls back to deserializing based on hinted types in\n        the XML element attribute \"type\".\n        \"\"\"\n        if data.tag == 'request':\n            # if \"object\" or \"objects\" exists, return deserialized forms.\n            elements = data.getchildren()\n            for element in elements:\n                if element.tag in ('object', 'objects'):\n                    return self.from_etree(element)\n            return dict((element.tag, self.from_etree(element)) for element in elements)\n        elif data.tag == 'object' or data.get('type') == 'hash':\n            return dict((element.tag, self.from_etree(element)) for element in data.getchildren())\n        elif data.tag == 'objects' or data.get('type') == 'list':\n            return [self.from_etree(element) for element in data.getchildren()]\n        else:\n            type_string = data.get('type')\n            if type_string in ('string', None):\n                return data.text\n            elif type_string == 'integer':\n                return int(data.text)\n            elif type_string == 'float':\n                return float(data.text)\n            elif type_string == 'boolean':\n                if data.text == 'True':\n                    return True\n                else:\n                    return False\n            else:\n                return None\n\n    def to_json(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces JSON output.\n        \"\"\"\n        options = options or {}\n        data = self.to_simple(data, options)\n        return simplejson.dumps(data, cls=json.DjangoJSONEncoder, sort_keys=True)\n\n    def from_json(self, content):\n        \"\"\"\n        Given some JSON data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        return simplejson.loads(content)\n\n    def to_jsonp(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces JSON output wrapped in the provided\n        callback.\n        \"\"\"\n        options = options or {}\n        return '%s(%s)' % (options['callback'], self.to_json(data, options))\n\n    def to_xml(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces XML output.\n        \"\"\"\n        options = options or {}\n\n        if lxml is None:\n            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")\n\n        return tostring(self.to_etree(data, options), xml_declaration=True, encoding='utf-8')\n\n    def from_xml(self, content):\n        \"\"\"\n        Given some XML data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        if lxml is None:\n            raise ImproperlyConfigured(\"Usage of the XML aspects requires lxml.\")\n\n        return self.from_etree(parse_xml(StringIO(content)).getroot())\n\n    def to_yaml(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces YAML output.\n        \"\"\"\n        options = options or {}\n\n        if yaml is None:\n            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")\n\n        return yaml.dump(self.to_simple(data, options))\n\n    def from_yaml(self, content):\n        \"\"\"\n        Given some YAML data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        if yaml is None:\n            raise ImproperlyConfigured(\"Usage of the YAML aspects requires yaml.\")\n\n        return yaml.safe_load(content)\n\n    def to_plist(self, data, options=None):\n        \"\"\"\n        Given some Python data, produces binary plist output.\n        \"\"\"\n        options = options or {}\n\n        if biplist is None:\n            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")\n\n        return biplist.writePlistToString(self.to_simple(data, options))\n\n    def from_plist(self, content):\n        \"\"\"\n        Given some binary plist data, returns a Python dictionary of the decoded data.\n        \"\"\"\n        if biplist is None:\n            raise ImproperlyConfigured(\"Usage of the plist aspects requires biplist.\")\n\n        return biplist.readPlistFromString(content)\n\n    def to_html(self, data, options=None):\n        \"\"\"\n        Reserved for future usage.\n\n        The desire is to provide HTML output of a resource, making an API\n        available to a browser. This is on the TODO list but not currently\n        implemented.\n        \"\"\"\n        options = options or {}\n        return 'Sorry, not implemented yet. Please append \"?format=json\" to your URL.'\n\n    def from_html(self, content):\n        \"\"\"\n        Reserved for future usage.\n\n        The desire is to handle form-based (maybe Javascript?) input, making an\n        API available to a browser. This is on the TODO list but not currently\n        implemented.\n        \"\"\"\n        pass\n\ndef get_type_string(data):\n    \"\"\"\n    Translates a Python data type into a string format.\n    \"\"\"\n    data_type = type(data)\n\n    if data_type in (int, long):\n        return 'integer'\n    elif data_type == float:\n        return 'float'\n    elif data_type == bool:\n        return 'boolean'\n    elif data_type in (list, tuple):\n        return 'list'\n    elif data_type == dict:\n        return 'hash'\n    elif data is None:\n        return 'null'\n    elif isinstance(data, basestring):\n        return 'string'\n"], "filenames": ["tastypie/serializers.py"], "buggy_code_start_loc": [31], "buggy_code_end_loc": [406], "fixing_code_start_loc": [31], "fixing_code_end_loc": [406], "type": "CWE-20", "message": "The from_yaml method in serializers.py in Django Tastypie before 0.9.10 does not properly deserialize YAML data, which allows remote attackers to execute arbitrary Python code via vectors related to the yaml.load method.", "other": {"cve": {"id": "CVE-2011-4104", "sourceIdentifier": "secalert@redhat.com", "published": "2014-10-27T01:55:23.407", "lastModified": "2018-08-13T21:47:39.900", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The from_yaml method in serializers.py in Django Tastypie before 0.9.10 does not properly deserialize YAML data, which allows remote attackers to execute arbitrary Python code via vectors related to the yaml.load method."}, {"lang": "es", "value": "El m\u00e9todo from_yaml en serializers.py en Django Tastypie anterior a 0.9.10 no deserializa debidamente los datos YAML, lo que permite a atacantes remotos ejecutar c\u00f3digo Python arbitrario a trav\u00e9s de vectores relacionados con el m\u00e9todo yaml.load."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:djangoproject:tastypie:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.9", "matchCriteriaId": "B6D983F7-056E-4271-B345-22B37205031B"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2011/11/02/1", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/11/02/7", "source": "secalert@redhat.com"}, {"url": "https://github.com/toastdriven/django-tastypie/commit/e8af315211b07c8f48f32a063233cc3f76dd5bc2", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://groups.google.com/forum/#!topic/django-tastypie/i2aNGDHTUBI", "source": "secalert@redhat.com"}, {"url": "https://www.djangoproject.com/weblog/2011/nov/01/piston-and-tastypie-security-releases/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/toastdriven/django-tastypie/commit/e8af315211b07c8f48f32a063233cc3f76dd5bc2"}}