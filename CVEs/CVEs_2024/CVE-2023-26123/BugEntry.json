{"buggy_code": ["/**********************************************************************************************\n*\n*   rcore - Basic functions to manage windows, OpenGL context and input on multiple platforms\n*\n*   PLATFORMS SUPPORTED:\n*       - PLATFORM_DESKTOP: Windows (Win32, Win64)\n*       - PLATFORM_DESKTOP: Linux (X11 desktop mode)\n*       - PLATFORM_DESKTOP: FreeBSD, OpenBSD, NetBSD, DragonFly (X11 desktop)\n*       - PLATFORM_DESKTOP: OSX/macOS\n*       - PLATFORM_ANDROID: Android (ARM, ARM64)\n*       - PLATFORM_RPI:     Raspberry Pi 0,1,2,3 (Raspbian, native mode)\n*       - PLATFORM_DRM:     Linux native mode, including Raspberry Pi 4 with V3D fkms driver\n*       - PLATFORM_WEB:     HTML5 with WebAssembly\n*\n*   CONFIGURATION:\n*\n*   #define PLATFORM_DESKTOP\n*       Windowing and input system configured for desktop platforms: Windows, Linux, OSX, FreeBSD, OpenBSD, NetBSD, DragonFly\n*       NOTE: Oculus Rift CV1 requires PLATFORM_DESKTOP for mirror rendering - View [rlgl] module to enable it\n*\n*   #define PLATFORM_ANDROID\n*       Windowing and input system configured for Android device, app activity managed internally in this module.\n*       NOTE: OpenGL ES 2.0 is required and graphic device is managed by EGL\n*\n*   #define PLATFORM_RPI (deprecated - RPI OS Buster only)\n*       Windowing and input system configured for Raspberry Pi in native mode (no XWindow required),\n*       graphic device is managed by EGL and inputs are processed is raw mode, reading from /dev/input/\n*       WARNING: This platform is deprecated, since RPI OS Bullseye, the old Dispmanx libraries are not\n*       supported and you must be using PLATFORM_DRM\n*\n*   #define PLATFORM_DRM\n*       Windowing and input system configured for DRM native mode (RPI4 and other devices)\n*       graphic device is managed by EGL and inputs are processed is raw mode, reading from /dev/input/\n*\n*   #define PLATFORM_WEB\n*       Windowing and input system configured for HTML5 (run on browser), code converted from C to asm.js\n*       using emscripten compiler. OpenGL ES 2.0 required for direct translation to WebGL equivalent code.\n*\n*   #define SUPPORT_DEFAULT_FONT (default)\n*       Default font is loaded on window initialization to be available for the user to render simple text.\n*       NOTE: If enabled, uses external module functions to load default raylib font (module: text)\n*\n*   #define SUPPORT_CAMERA_SYSTEM\n*       Camera module is included (rcamera.h) and multiple predefined cameras are available: free, 1st/3rd person, orbital\n*\n*   #define SUPPORT_GESTURES_SYSTEM\n*       Gestures module is included (rgestures.h) to support gestures detection: tap, hold, swipe, drag\n*\n*   #define SUPPORT_MOUSE_GESTURES\n*       Mouse gestures are directly mapped like touches and processed by gestures system.\n*\n*   #define SUPPORT_TOUCH_AS_MOUSE\n*       Touch input and mouse input are shared. Mouse functions also return touch information.\n*\n*   #define SUPPORT_SSH_KEYBOARD_RPI (Raspberry Pi only)\n*       Reconfigure standard input to receive key inputs, works with SSH connection.\n*       WARNING: Reconfiguring standard input could lead to undesired effects, like breaking other running processes or\n*       blocking the device if not restored properly. Use with care.\n*\n*   #define SUPPORT_BUSY_WAIT_LOOP\n*       Use busy wait loop for timing sync, if not defined, a high-resolution timer is setup and used\n*\n*   #define SUPPORT_PARTIALBUSY_WAIT_LOOP\n*       Use a partial-busy wait loop, in this case frame sleeps for most of the time and runs a busy-wait-loop at the end\n*\n*   #define SUPPORT_EVENTS_WAITING\n*       Wait for events passively (sleeping while no events) instead of polling them actively every frame\n*\n*   #define SUPPORT_SCREEN_CAPTURE\n*       Allow automatic screen capture of current screen pressing F12, defined in KeyCallback()\n*\n*   #define SUPPORT_GIF_RECORDING\n*       Allow automatic gif recording of current screen pressing CTRL+F12, defined in KeyCallback()\n*\n*   #define SUPPORT_COMPRESSION_API\n*       Support CompressData() and DecompressData() functions, those functions use zlib implementation\n*       provided by stb_image and stb_image_write libraries, so, those libraries must be enabled on textures module\n*       for linkage\n*\n*   #define SUPPORT_EVENTS_AUTOMATION\n*       Support automatic generated events, loading and recording of those events when required\n*\n*   DEPENDENCIES:\n*       rglfw    - Manage graphic device, OpenGL context and inputs on PLATFORM_DESKTOP (Windows, Linux, OSX. FreeBSD, OpenBSD, NetBSD, DragonFly)\n*       raymath  - 3D math functionality (Vector2, Vector3, Matrix, Quaternion)\n*       camera   - Multiple 3D camera modes (free, orbital, 1st person, 3rd person)\n*       gestures - Gestures system for touch-ready devices (or simulated from mouse inputs)\n*\n*\n*   LICENSE: zlib/libpng\n*\n*   Copyright (c) 2013-2023 Ramon Santamaria (@raysan5)\n*\n*   This software is provided \"as-is\", without any express or implied warranty. In no event\n*   will the authors be held liable for any damages arising from the use of this software.\n*\n*   Permission is granted to anyone to use this software for any purpose, including commercial\n*   applications, and to alter it and redistribute it freely, subject to the following restrictions:\n*\n*     1. The origin of this software must not be misrepresented; you must not claim that you\n*     wrote the original software. If you use this software in a product, an acknowledgment\n*     in the product documentation would be appreciated but is not required.\n*\n*     2. Altered source versions must be plainly marked as such, and must not be misrepresented\n*     as being the original software.\n*\n*     3. This notice may not be removed or altered from any source distribution.\n*\n**********************************************************************************************/\n\n#include \"raylib.h\"                 // Declares module functions\n\n// Check if config flags have been externally provided on compilation line\n#if !defined(EXTERNAL_CONFIG_FLAGS)\n    #include \"config.h\"             // Defines module configuration flags\n#endif\n\n#include \"utils.h\"                  // Required for: TRACELOG() macros\n\n#define RLGL_IMPLEMENTATION\n#include \"rlgl.h\"                   // OpenGL abstraction layer to OpenGL 1.1, 3.3+ or ES2\n\n#define RAYMATH_IMPLEMENTATION      // Define external out-of-line implementation\n#include \"raymath.h\"                // Vector3, Quaternion and Matrix functionality\n\n#if defined(SUPPORT_GESTURES_SYSTEM)\n    #define GESTURES_IMPLEMENTATION\n    #include \"rgestures.h\"           // Gestures detection functionality\n#endif\n\n#if defined(SUPPORT_CAMERA_SYSTEM)\n    #define CAMERA_IMPLEMENTATION\n    #include \"rcamera.h\"             // Camera system functionality\n#endif\n\n#if defined(SUPPORT_GIF_RECORDING)\n    #define MSF_GIF_MALLOC(contextPointer, newSize) RL_MALLOC(newSize)\n    #define MSF_GIF_REALLOC(contextPointer, oldMemory, oldSize, newSize) RL_REALLOC(oldMemory, newSize)\n    #define MSF_GIF_FREE(contextPointer, oldMemory, oldSize) RL_FREE(oldMemory)\n\n    #define MSF_GIF_IMPL\n    #include \"external/msf_gif.h\"   // GIF recording functionality\n#endif\n\n#if defined(SUPPORT_COMPRESSION_API)\n    #define SINFL_IMPLEMENTATION\n    #define SINFL_NO_SIMD\n    #include \"external/sinfl.h\"     // Deflate (RFC 1951) decompressor\n\n    #define SDEFL_IMPLEMENTATION\n    #include \"external/sdefl.h\"     // Deflate (RFC 1951) compressor\n#endif\n\n#if (defined(__linux__) || defined(PLATFORM_WEB)) && (_POSIX_C_SOURCE < 199309L)\n    #undef _POSIX_C_SOURCE\n    #define _POSIX_C_SOURCE 199309L // Required for: CLOCK_MONOTONIC if compiled with c99 without gnu ext.\n#endif\n#if defined(__linux__) && !defined(_GNU_SOURCE)\n    #define _GNU_SOURCE\n#endif\n\n// Platform specific defines to handle GetApplicationDirectory()\n#if defined (PLATFORM_DESKTOP)\n    #if defined(_WIN32)\n        #ifndef MAX_PATH\n            #define MAX_PATH 1025\n        #endif\n    __declspec(dllimport) unsigned long __stdcall GetModuleFileNameA(void *hModule, void *lpFilename, unsigned long nSize);\n    __declspec(dllimport) unsigned long __stdcall GetModuleFileNameW(void *hModule, void *lpFilename, unsigned long nSize);\n    __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, void *widestr, int cchwide, void *str, int cbmb, void *defchar, int *used_default);\n    #elif defined(__linux__)\n        #include <unistd.h>\n    #elif defined(__APPLE__)\n        #include <sys/syslimits.h>\n        #include <mach-o/dyld.h>\n    #endif // OSs\n#endif // PLATFORM_DESKTOP\n\n#include <stdlib.h>                 // Required for: srand(), rand(), atexit()\n#include <stdio.h>                  // Required for: sprintf() [Used in OpenURL()]\n#include <string.h>                 // Required for: strrchr(), strcmp(), strlen(), memset()\n#include <time.h>                   // Required for: time() [Used in InitTimer()]\n#include <math.h>                   // Required for: tan() [Used in BeginMode3D()], atan2f() [Used in LoadVrStereoConfig()]\n\n#define _CRT_INTERNAL_NONSTDC_NAMES  1\n#include <sys/stat.h>               // Required for: stat(), S_ISREG [Used in GetFileModTime(), IsFilePath()]\n\n#if !defined(S_ISREG) && defined(S_IFMT) && defined(S_IFREG)\n    #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n#endif\n\n#if defined(PLATFORM_DESKTOP) && defined(_WIN32) && (defined(_MSC_VER) || defined(__TINYC__))\n    #define DIRENT_MALLOC RL_MALLOC\n    #define DIRENT_FREE RL_FREE\n\n    #include \"external/dirent.h\"    // Required for: DIR, opendir(), closedir() [Used in LoadDirectoryFiles()]\n#else\n    #include <dirent.h>             // Required for: DIR, opendir(), closedir() [Used in LoadDirectoryFiles()]\n#endif\n\n#if defined(_WIN32)\n    #include <direct.h>             // Required for: _getch(), _chdir()\n    #define GETCWD _getcwd          // NOTE: MSDN recommends not to use getcwd(), chdir()\n    #define CHDIR _chdir\n    #include <io.h>                 // Required for: _access() [Used in FileExists()]\n#else\n    #include <unistd.h>             // Required for: getch(), chdir() (POSIX), access()\n    #define GETCWD getcwd\n    #define CHDIR chdir\n#endif\n\n#if defined(PLATFORM_DESKTOP)\n    #define GLFW_INCLUDE_NONE       // Disable the standard OpenGL header inclusion on GLFW3\n                                    // NOTE: Already provided by rlgl implementation (on glad.h)\n    #include \"GLFW/glfw3.h\"         // GLFW3 library: Windows, OpenGL context and Input management\n                                    // NOTE: GLFW3 already includes gl.h (OpenGL) headers\n\n    // Support retrieving native window handlers\n    #if defined(_WIN32)\n        typedef void *PVOID;\n        typedef PVOID HANDLE;\n        typedef HANDLE HWND;\n        #define GLFW_EXPOSE_NATIVE_WIN32\n        #define GLFW_NATIVE_INCLUDE_NONE // To avoid some symbols re-definition in windows.h\n        #include \"GLFW/glfw3native.h\"\n\n        #if defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)\n            // NOTE: Those functions require linking with winmm library\n            unsigned int __stdcall timeBeginPeriod(unsigned int uPeriod);\n            unsigned int __stdcall timeEndPeriod(unsigned int uPeriod);\n        #endif\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        #include <sys/time.h>               // Required for: timespec, nanosleep(), select() - POSIX\n\n        //#define GLFW_EXPOSE_NATIVE_X11      // WARNING: Exposing Xlib.h > X.h results in dup symbols for Font type\n        //#define GLFW_EXPOSE_NATIVE_WAYLAND\n        //#define GLFW_EXPOSE_NATIVE_MIR\n        #include \"GLFW/glfw3native.h\"       // Required for: glfwGetX11Window()\n    #endif\n    #if defined(__APPLE__)\n        #include <unistd.h>                 // Required for: usleep()\n\n        //#define GLFW_EXPOSE_NATIVE_COCOA    // WARNING: Fails due to type redefinition\n        void *glfwGetCocoaWindow(GLFWwindow* handle);\n        #include \"GLFW/glfw3native.h\"       // Required for: glfwGetCocoaWindow()\n    #endif\n\n    // TODO: HACK: Added flag if not provided by GLFW when using external library\n    // Latest GLFW release (GLFW 3.3.8) does not implement this flag, it was added for 3.4.0-dev\n    #if !defined(GLFW_MOUSE_PASSTHROUGH)\n        #define GLFW_MOUSE_PASSTHROUGH      0x0002000D\n    #endif\n#endif\n\n#if defined(PLATFORM_ANDROID)\n    //#include <android/sensor.h>           // Required for: Android sensors functions (accelerometer, gyroscope, light...)\n    #include <android/window.h>             // Required for: AWINDOW_FLAG_FULLSCREEN definition and others\n    #include <android_native_app_glue.h>    // Required for: android_app struct and activity management\n    #include <jni.h>                        // Required for: JNIEnv and JavaVM [Used in OpenURL()]\n\n    #include <EGL/egl.h>                    // Native platform windowing system interface\n    //#include <GLES2/gl2.h>                // OpenGL ES 2.0 library (not required in this module, only in rlgl)\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    #include <fcntl.h>                  // POSIX file control definitions - open(), creat(), fcntl()\n    #include <unistd.h>                 // POSIX standard function definitions - read(), close(), STDIN_FILENO\n    #include <termios.h>                // POSIX terminal control definitions - tcgetattr(), tcsetattr()\n    #include <pthread.h>                // POSIX threads management (inputs reading)\n    #include <dirent.h>                 // POSIX directory browsing\n\n    #include <sys/ioctl.h>              // Required for: ioctl() - UNIX System call for device-specific input/output operations\n    #include <linux/kd.h>               // Linux: KDSKBMODE, K_MEDIUMRAM constants definition\n    #include <linux/input.h>            // Linux: Keycodes constants definition (KEY_A, ...)\n    #include <linux/joystick.h>         // Linux: Joystick support library\n\n#if defined(PLATFORM_RPI)\n    #include \"bcm_host.h\"               // Raspberry Pi VideoCore IV access functions\n#endif\n#if defined(PLATFORM_DRM)\n    #include <gbm.h>                    // Generic Buffer Management (native platform for EGL on DRM)\n    #include <xf86drm.h>                // Direct Rendering Manager user-level library interface\n    #include <xf86drmMode.h>            // Direct Rendering Manager mode setting (KMS) interface\n#endif\n\n    #include \"EGL/egl.h\"                // Native platform windowing system interface\n    #include \"EGL/eglext.h\"             // EGL extensions\n    //#include \"GLES2/gl2.h\"            // OpenGL ES 2.0 library (not required in this module, only in rlgl)\n#endif\n\n#if defined(PLATFORM_WEB)\n    #define GLFW_INCLUDE_ES2            // GLFW3: Enable OpenGL ES 2.0 (translated to WebGL)\n    #include \"GLFW/glfw3.h\"             // GLFW3: Windows, OpenGL context and Input management\n    #include <sys/time.h>               // Required for: timespec, nanosleep(), select() - POSIX\n\n    #include <emscripten/emscripten.h>  // Emscripten functionality for C\n    #include <emscripten/html5.h>       // Emscripten HTML5 library\n#endif\n\n//----------------------------------------------------------------------------------\n// Defines and Macros\n//----------------------------------------------------------------------------------\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    #define USE_LAST_TOUCH_DEVICE       // When multiple touchscreens are connected, only use the one with the highest event<N> number\n\n    #define DEFAULT_GAMEPAD_DEV    \"/dev/input/js\"  // Gamepad input (base dev for all gamepads: js0, js1, ...)\n    #define DEFAULT_EVDEV_PATH       \"/dev/input/\"  // Path to the linux input events\n#endif\n\n#ifndef MAX_FILEPATH_CAPACITY\n    #define MAX_FILEPATH_CAPACITY       8192        // Maximum capacity for filepath\n#endif\n#ifndef MAX_FILEPATH_LENGTH\n    #define MAX_FILEPATH_LENGTH         4096        // Maximum length for filepaths (Linux PATH_MAX default value)\n#endif\n\n#ifndef MAX_KEYBOARD_KEYS\n    #define MAX_KEYBOARD_KEYS            512        // Maximum number of keyboard keys supported\n#endif\n#ifndef MAX_MOUSE_BUTTONS\n    #define MAX_MOUSE_BUTTONS              8        // Maximum number of mouse buttons supported\n#endif\n#ifndef MAX_GAMEPADS\n    #define MAX_GAMEPADS                   4        // Maximum number of gamepads supported\n#endif\n#ifndef MAX_GAMEPAD_AXIS\n    #define MAX_GAMEPAD_AXIS               8        // Maximum number of axis supported (per gamepad)\n#endif\n#ifndef MAX_GAMEPAD_BUTTONS\n    #define MAX_GAMEPAD_BUTTONS           32        // Maximum number of buttons supported (per gamepad)\n#endif\n#ifndef MAX_TOUCH_POINTS\n    #define MAX_TOUCH_POINTS               8        // Maximum number of touch points supported\n#endif\n#ifndef MAX_KEY_PRESSED_QUEUE\n    #define MAX_KEY_PRESSED_QUEUE         16        // Maximum number of keys in the key input queue\n#endif\n#ifndef MAX_CHAR_PRESSED_QUEUE\n    #define MAX_CHAR_PRESSED_QUEUE        16        // Maximum number of characters in the char input queue\n#endif\n\n#ifndef MAX_DECOMPRESSION_SIZE\n    #define MAX_DECOMPRESSION_SIZE        64        // Maximum size allocated for decompression in MB\n#endif\n\n// Flags operation macros\n#define FLAG_SET(n, f) ((n) |= (f))\n#define FLAG_CLEAR(n, f) ((n) &= ~(f))\n#define FLAG_TOGGLE(n, f) ((n) ^= (f))\n#define FLAG_CHECK(n, f) ((n) & (f))\n\n//----------------------------------------------------------------------------------\n// Types and Structures Definition\n//----------------------------------------------------------------------------------\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\ntypedef struct {\n    pthread_t threadId;             // Event reading thread id\n    int fd;                         // File descriptor to the device it is assigned to\n    int eventNum;                   // Number of 'event<N>' device\n    Rectangle absRange;             // Range of values for absolute pointing devices (touchscreens)\n    int touchSlot;                  // Hold the touch slot number of the currently being sent multitouch block\n    bool isMouse;                   // True if device supports relative X Y movements\n    bool isTouch;                   // True if device supports absolute X Y movements and has BTN_TOUCH\n    bool isMultitouch;              // True if device supports multiple absolute movevents and has BTN_TOUCH\n    bool isKeyboard;                // True if device has letter keycodes\n    bool isGamepad;                 // True if device has gamepad buttons\n} InputEventWorker;\n#endif\n\ntypedef struct { int x; int y; } Point;\ntypedef struct { unsigned int width; unsigned int height; } Size;\n\n// Core global state context data\ntypedef struct CoreData {\n    struct {\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n        GLFWwindow *handle;                 // GLFW window handle (graphic device)\n#endif\n#if defined(PLATFORM_RPI)\n        EGL_DISPMANX_WINDOW_T handle;       // Native window handle (graphic device)\n#endif\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n#if defined(PLATFORM_DRM)\n        int fd;                             // File descriptor for /dev/dri/...\n        drmModeConnector *connector;        // Direct Rendering Manager (DRM) mode connector\n        drmModeCrtc *crtc;                  // CRT Controller\n        int modeIndex;                      // Index of the used mode of connector->modes\n        struct gbm_device *gbmDevice;       // GBM device\n        struct gbm_surface *gbmSurface;     // GBM surface\n        struct gbm_bo *prevBO;              // Previous GBM buffer object (during frame swapping)\n        uint32_t prevFB;                    // Previous GBM framebufer (during frame swapping)\n#endif  // PLATFORM_DRM\n        EGLDisplay device;                  // Native display device (physical screen connection)\n        EGLSurface surface;                 // Surface to draw on, framebuffers (connected to context)\n        EGLContext context;                 // Graphic context, mode in which drawing can be done\n        EGLConfig config;                   // Graphic config\n#endif\n        const char *title;                  // Window text title const pointer\n        unsigned int flags;                 // Configuration flags (bit based), keeps window state\n        bool ready;                         // Check if window has been initialized successfully\n        bool fullscreen;                    // Check if fullscreen mode is enabled\n        bool shouldClose;                   // Check if window set for closing\n        bool resizedLastFrame;              // Check if window has been resized last frame\n        bool eventWaiting;                  // Wait for events before ending frame\n\n        Point position;                     // Window position on screen (required on fullscreen toggle)\n        Size display;                       // Display width and height (monitor, device-screen, LCD, ...)\n        Size screen;                        // Screen width and height (used render area)\n        Size currentFbo;                    // Current render width and height (depends on active fbo)\n        Size render;                        // Framebuffer width and height (render area, including black bars if required)\n        Point renderOffset;                 // Offset from render area (must be divided by 2)\n        Matrix screenScale;                 // Matrix to scale screen (framebuffer rendering)\n\n        char **dropFilepaths;         // Store dropped files paths pointers (provided by GLFW)\n        unsigned int dropFileCount;         // Count dropped files strings\n\n    } Window;\n#if defined(PLATFORM_ANDROID)\n    struct {\n        bool appEnabled;                    // Flag to detect if app is active ** = true\n        struct android_app *app;            // Android activity\n        struct android_poll_source *source; // Android events polling source\n        bool contextRebindRequired;         // Used to know context rebind required\n    } Android;\n#endif\n    struct {\n        const char *basePath;               // Base path for data storage\n    } Storage;\n    struct {\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n        InputEventWorker eventWorker[10];   // List of worker threads for every monitored \"/dev/input/event<N>\"\n#endif\n        struct {\n            int exitKey;                    // Default exit key\n            char currentKeyState[MAX_KEYBOARD_KEYS];        // Registers current frame key state\n            char previousKeyState[MAX_KEYBOARD_KEYS];       // Registers previous frame key state\n\n            int keyPressedQueue[MAX_KEY_PRESSED_QUEUE];     // Input keys queue\n            int keyPressedQueueCount;       // Input keys queue count\n\n            int charPressedQueue[MAX_CHAR_PRESSED_QUEUE];   // Input characters queue (unicode)\n            int charPressedQueueCount;      // Input characters queue count\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n            int defaultMode;                // Default keyboard mode\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\n            bool evtMode;                   // Keyboard in event mode\n#endif\n            int defaultFileFlags;           // Default IO file flags\n            struct termios defaultSettings; // Default keyboard settings\n            int fd;                         // File descriptor for the evdev keyboard\n#endif\n        } Keyboard;\n        struct {\n            Vector2 offset;                 // Mouse offset\n            Vector2 scale;                  // Mouse scaling\n            Vector2 currentPosition;        // Mouse position on screen\n            Vector2 previousPosition;       // Previous mouse position\n\n            int cursor;                     // Tracks current mouse cursor\n            bool cursorHidden;              // Track if cursor is hidden\n            bool cursorOnScreen;            // Tracks if cursor is inside client area\n\n            char currentButtonState[MAX_MOUSE_BUTTONS];     // Registers current mouse button state\n            char previousButtonState[MAX_MOUSE_BUTTONS];    // Registers previous mouse button state\n            Vector2 currentWheelMove;       // Registers current mouse wheel variation\n            Vector2 previousWheelMove;      // Registers previous mouse wheel variation\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n            // NOTE: currentButtonState[] can't be written directly due to multithreading, app could miss the update\n            char currentButtonStateEvdev[MAX_MOUSE_BUTTONS]; // Holds the new mouse state for the next polling event to grab\n#endif\n        } Mouse;\n        struct {\n            int pointCount;                             // Number of touch points active\n            int pointId[MAX_TOUCH_POINTS];              // Point identifiers\n            Vector2 position[MAX_TOUCH_POINTS];         // Touch position on screen\n            char currentTouchState[MAX_TOUCH_POINTS];   // Registers current touch state\n            char previousTouchState[MAX_TOUCH_POINTS];  // Registers previous touch state\n        } Touch;\n        struct {\n            int lastButtonPressed;          // Register last gamepad button pressed\n            int axisCount;                  // Register number of available gamepad axis\n            bool ready[MAX_GAMEPADS];       // Flag to know if gamepad is ready\n            char name[MAX_GAMEPADS][64];    // Gamepad name holder\n            char currentButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];     // Current gamepad buttons state\n            char previousButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];    // Previous gamepad buttons state\n            float axisState[MAX_GAMEPADS][MAX_GAMEPAD_AXIS];                // Gamepad axis state\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n            pthread_t threadId;             // Gamepad reading thread id\n            int streamId[MAX_GAMEPADS];     // Gamepad device file descriptor\n#endif\n        } Gamepad;\n    } Input;\n    struct {\n        double current;                     // Current time measure\n        double previous;                    // Previous time measure\n        double update;                      // Time measure for frame update\n        double draw;                        // Time measure for frame draw\n        double frame;                       // Time measure for one frame\n        double target;                      // Desired time for one frame, if 0 not applied\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n        unsigned long long base;            // Base time measure for hi-res timer\n#endif\n        unsigned int frameCounter;          // Frame counter\n    } Time;\n} CoreData;\n\n//----------------------------------------------------------------------------------\n// Global Variables Definition\n//----------------------------------------------------------------------------------\nRLAPI const char *raylib_version = RAYLIB_VERSION;  // raylib version exported symbol, required for some bindings\n\nstatic CoreData CORE = { 0 };               // Global CORE state context\n\n#if defined(SUPPORT_SCREEN_CAPTURE)\nstatic int screenshotCounter = 0;           // Screenshots counter\n#endif\n\n#if defined(SUPPORT_GIF_RECORDING)\nstatic int gifFrameCounter = 0;             // GIF frames counter\nstatic bool gifRecording = false;           // GIF recording state\nstatic MsfGifState gifState = { 0 };        // MSGIF context state\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n#define MAX_CODE_AUTOMATION_EVENTS      16384\n\ntypedef enum AutomationEventType {\n    EVENT_NONE = 0,\n    // Input events\n    INPUT_KEY_UP,                   // param[0]: key\n    INPUT_KEY_DOWN,                 // param[0]: key\n    INPUT_KEY_PRESSED,              // param[0]: key\n    INPUT_KEY_RELEASED,             // param[0]: key\n    INPUT_MOUSE_BUTTON_UP,          // param[0]: button\n    INPUT_MOUSE_BUTTON_DOWN,        // param[0]: button\n    INPUT_MOUSE_POSITION,           // param[0]: x, param[1]: y\n    INPUT_MOUSE_WHEEL_MOTION,       // param[0]: x delta, param[1]: y delta\n    INPUT_GAMEPAD_CONNECT,          // param[0]: gamepad\n    INPUT_GAMEPAD_DISCONNECT,       // param[0]: gamepad\n    INPUT_GAMEPAD_BUTTON_UP,        // param[0]: button\n    INPUT_GAMEPAD_BUTTON_DOWN,      // param[0]: button\n    INPUT_GAMEPAD_AXIS_MOTION,      // param[0]: axis, param[1]: delta\n    INPUT_TOUCH_UP,                 // param[0]: id\n    INPUT_TOUCH_DOWN,               // param[0]: id\n    INPUT_TOUCH_POSITION,           // param[0]: x, param[1]: y\n    INPUT_GESTURE,                  // param[0]: gesture\n    // Window events\n    WINDOW_CLOSE,                   // no params\n    WINDOW_MAXIMIZE,                // no params\n    WINDOW_MINIMIZE,                // no params\n    WINDOW_RESIZE,                  // param[0]: width, param[1]: height\n    // Custom events\n    ACTION_TAKE_SCREENSHOT,\n    ACTION_SETTARGETFPS\n} AutomationEventType;\n\n// Event type\n// Used to enable events flags\ntypedef enum {\n    EVENT_INPUT_KEYBOARD    = 0,\n    EVENT_INPUT_MOUSE       = 1,\n    EVENT_INPUT_GAMEPAD     = 2,\n    EVENT_INPUT_TOUCH       = 4,\n    EVENT_INPUT_GESTURE     = 8,\n    EVENT_WINDOW            = 16,\n    EVENT_CUSTOM            = 32\n} EventType;\n\nstatic const char *autoEventTypeName[] = {\n    \"EVENT_NONE\",\n    \"INPUT_KEY_UP\",\n    \"INPUT_KEY_DOWN\",\n    \"INPUT_KEY_PRESSED\",\n    \"INPUT_KEY_RELEASED\",\n    \"INPUT_MOUSE_BUTTON_UP\",\n    \"INPUT_MOUSE_BUTTON_DOWN\",\n    \"INPUT_MOUSE_POSITION\",\n    \"INPUT_MOUSE_WHEEL_MOTION\",\n    \"INPUT_GAMEPAD_CONNECT\",\n    \"INPUT_GAMEPAD_DISCONNECT\",\n    \"INPUT_GAMEPAD_BUTTON_UP\",\n    \"INPUT_GAMEPAD_BUTTON_DOWN\",\n    \"INPUT_GAMEPAD_AXIS_MOTION\",\n    \"INPUT_TOUCH_UP\",\n    \"INPUT_TOUCH_DOWN\",\n    \"INPUT_TOUCH_POSITION\",\n    \"INPUT_GESTURE\",\n    \"WINDOW_CLOSE\",\n    \"WINDOW_MAXIMIZE\",\n    \"WINDOW_MINIMIZE\",\n    \"WINDOW_RESIZE\",\n    \"ACTION_TAKE_SCREENSHOT\",\n    \"ACTION_SETTARGETFPS\"\n};\n\n// Automation Event (20 bytes)\ntypedef struct AutomationEvent {\n    unsigned int frame;                 // Event frame\n    unsigned int type;                  // Event type (AutoEventType)\n    int params[3];                      // Event parameters (if required)\n} AutomationEvent;\n\nstatic AutomationEvent *events = NULL;        // Events array\nstatic unsigned int eventCount = 0;     // Events count\nstatic bool eventsPlaying = false;      // Play events\nstatic bool eventsRecording = false;    // Record events\n\n//static short eventsEnabled = 0b0000001111111111;    // Events enabled for checking\n#endif\n//-----------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------\n// Other Modules Functions Declaration (required by core)\n//----------------------------------------------------------------------------------\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\nextern void LoadFontDefault(void);          // [Module: text] Loads default font on InitWindow()\nextern void UnloadFontDefault(void);        // [Module: text] Unloads default font from GPU memory\n#endif\n\n//----------------------------------------------------------------------------------\n// Module specific Functions Declaration\n//----------------------------------------------------------------------------------\nstatic void InitTimer(void);                            // Initialize timer (hi-resolution if available)\nstatic bool InitGraphicsDevice(int width, int height);  // Initialize graphics device\nstatic void SetupFramebuffer(int width, int height);    // Setup main framebuffer\nstatic void SetupViewport(int width, int height);       // Set viewport for a provided width and height\n\nstatic void ScanDirectoryFiles(const char *basePath, FilePathList *list, const char *filter);   // Scan all files and directories in a base path\nstatic void ScanDirectoryFilesRecursively(const char *basePath, FilePathList *list, const char *filter);  // Scan all files and directories recursively from a base path\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\nstatic void ErrorCallback(int error, const char *description);                             // GLFW3 Error Callback, runs on GLFW3 error\n// Window callbacks events\nstatic void WindowSizeCallback(GLFWwindow *window, int width, int height);                 // GLFW3 WindowSize Callback, runs when window is resized\n#if !defined(PLATFORM_WEB)\nstatic void WindowMaximizeCallback(GLFWwindow* window, int maximized);                     // GLFW3 Window Maximize Callback, runs when window is maximized\n#endif\nstatic void WindowIconifyCallback(GLFWwindow *window, int iconified);                      // GLFW3 WindowIconify Callback, runs when window is minimized/restored\nstatic void WindowFocusCallback(GLFWwindow *window, int focused);                          // GLFW3 WindowFocus Callback, runs when window get/lose focus\nstatic void WindowDropCallback(GLFWwindow *window, int count, const char **paths);         // GLFW3 Window Drop Callback, runs when drop files into window\n// Input callbacks events\nstatic void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);  // GLFW3 Keyboard Callback, runs on key pressed\nstatic void CharCallback(GLFWwindow *window, unsigned int key);                            // GLFW3 Char Key Callback, runs on key pressed (get char value)\nstatic void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods);     // GLFW3 Mouse Button Callback, runs on mouse button pressed\nstatic void MouseCursorPosCallback(GLFWwindow *window, double x, double y);                // GLFW3 Cursor Position Callback, runs on mouse move\nstatic void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset);       // GLFW3 Srolling Callback, runs on mouse wheel\nstatic void CursorEnterCallback(GLFWwindow *window, int enter);                            // GLFW3 Cursor Enter Callback, cursor enters client area\n#endif\n\n#if defined(PLATFORM_ANDROID)\nstatic void AndroidCommandCallback(struct android_app *app, int32_t cmd);                  // Process Android activity lifecycle commands\nstatic int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event);          // Process Android inputs\n#endif\n\n#if defined(PLATFORM_WEB)\nstatic EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData);\nstatic EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData);\nstatic EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData);\n\nstatic EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData);\nstatic EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData);\nstatic EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData);\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\nstatic void InitKeyboard(void);                         // Initialize raw keyboard system\nstatic void RestoreKeyboard(void);                      // Restore keyboard system\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\nstatic void ProcessKeyboard(void);                      // Process keyboard events\n#endif\n\nstatic void InitEvdevInput(void);                       // Initialize evdev inputs\nstatic void ConfigureEvdevDevice(char *device);         // Identifies a input device and configures it for use if appropriate\nstatic void PollKeyboardEvents(void);                   // Process evdev keyboard events.\nstatic void *EventThread(void *arg);                    // Input device events reading thread\n\nstatic void InitGamepad(void);                          // Initialize raw gamepad input\nstatic void *GamepadThread(void *arg);                  // Mouse reading thread\n\n#if defined(PLATFORM_DRM)\nstatic int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode);                               // Search matching DRM mode in connector's mode list\nstatic int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);      // Search exactly matching DRM connector mode in connector's list\nstatic int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);    // Search the nearest matching DRM connector mode in connector's list\n#endif\n\n#endif  // PLATFORM_RPI || PLATFORM_DRM\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\nstatic void LoadAutomationEvents(const char *fileName);     // Load automation events from file\nstatic void ExportAutomationEvents(const char *fileName);   // Export recorded automation events into a file\nstatic void RecordAutomationEvent(unsigned int frame);      // Record frame events (to internal events array)\nstatic void PlayAutomationEvent(unsigned int frame);        // Play frame events (from internal events array)\n#endif\n\n#if defined(_WIN32)\n// NOTE: We declare Sleep() function symbol to avoid including windows.h (kernel32.lib linkage required)\nvoid __stdcall Sleep(unsigned long msTimeout);              // Required for: WaitTime()\n#endif\n\n#if !defined(SUPPORT_MODULE_RTEXT)\nconst char *TextFormat(const char *text, ...);       // Formatting of text with variables to 'embed'\n#endif // !SUPPORT_MODULE_RTEXT\n\n//----------------------------------------------------------------------------------\n// Module Functions Definition - Window and OpenGL Context Functions\n//----------------------------------------------------------------------------------\n#if defined(PLATFORM_ANDROID)\n// To allow easier porting to android, we allow the user to define a\n// main function which we call from android_main, defined by ourselves\nextern int main(int argc, char *argv[]);\n\nvoid android_main(struct android_app *app)\n{\n    char arg0[] = \"raylib\";     // NOTE: argv[] are mutable\n    CORE.Android.app = app;\n\n    // NOTE: Return codes != 0 are skipped\n    (void)main(1, (char *[]) { arg0, NULL });\n}\n\n// NOTE: Add this to header (if apps really need it)\nstruct android_app *GetAndroidApp(void)\n{\n    return CORE.Android.app;\n}\n#endif\n\n// Initialize window and OpenGL context\n// NOTE: data parameter could be used to pass any kind of required data to the initialization\nvoid InitWindow(int width, int height, const char *title)\n{\n    TRACELOG(LOG_INFO, \"Initializing raylib %s\", RAYLIB_VERSION);\n\n    TRACELOG(LOG_INFO, \"Supported raylib modules:\");\n    TRACELOG(LOG_INFO, \"    > rcore:..... loaded (mandatory)\");\n    TRACELOG(LOG_INFO, \"    > rlgl:...... loaded (mandatory)\");\n#if defined(SUPPORT_MODULE_RSHAPES)\n    TRACELOG(LOG_INFO, \"    > rshapes:... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rshapes:... not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    TRACELOG(LOG_INFO, \"    > rtextures:. loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rtextures:. not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RTEXT)\n    TRACELOG(LOG_INFO, \"    > rtext:..... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rtext:..... not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RMODELS)\n    TRACELOG(LOG_INFO, \"    > rmodels:... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rmodels:... not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RAUDIO)\n    TRACELOG(LOG_INFO, \"    > raudio:.... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > raudio:.... not loaded (optional)\");\n#endif\n\n    if ((title != NULL) && (title[0] != 0)) CORE.Window.title = title;\n\n    // Initialize global input state\n    memset(&CORE.Input, 0, sizeof(CORE.Input));\n    CORE.Input.Keyboard.exitKey = KEY_ESCAPE;\n    CORE.Input.Mouse.scale = (Vector2){ 1.0f, 1.0f };\n    CORE.Input.Mouse.cursor = MOUSE_CURSOR_ARROW;\n    CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN\n#if defined(SUPPORT_EVENTS_WAITING)\n    CORE.Window.eventWaiting = true;\n#endif\n\n#if defined(PLATFORM_ANDROID)\n    CORE.Window.screen.width = width;\n    CORE.Window.screen.height = height;\n    CORE.Window.currentFbo.width = width;\n    CORE.Window.currentFbo.height = height;\n\n    // Set desired windows flags before initializing anything\n    ANativeActivity_setWindowFlags(CORE.Android.app->activity, AWINDOW_FLAG_FULLSCREEN, 0);  //AWINDOW_FLAG_SCALED, AWINDOW_FLAG_DITHER\n\n    int orientation = AConfiguration_getOrientation(CORE.Android.app->config);\n\n    if (orientation == ACONFIGURATION_ORIENTATION_PORT) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as portrait\");\n    else if (orientation == ACONFIGURATION_ORIENTATION_LAND) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as landscape\");\n\n    // TODO: Automatic orientation doesn't seem to work\n    if (width <= height)\n    {\n        AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_PORT);\n        TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to portrait\");\n    }\n    else\n    {\n        AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_LAND);\n        TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to landscape\");\n    }\n\n    //AConfiguration_getDensity(CORE.Android.app->config);\n    //AConfiguration_getKeyboard(CORE.Android.app->config);\n    //AConfiguration_getScreenSize(CORE.Android.app->config);\n    //AConfiguration_getScreenLong(CORE.Android.app->config);\n\n    // Initialize App command system\n    // NOTE: On APP_CMD_INIT_WINDOW -> InitGraphicsDevice(), InitTimer(), LoadFontDefault()...\n    CORE.Android.app->onAppCmd = AndroidCommandCallback;\n\n    // Initialize input events system\n    CORE.Android.app->onInputEvent = AndroidInputCallback;\n\n    // Initialize assets manager\n    InitAssetManager(CORE.Android.app->activity->assetManager, CORE.Android.app->activity->internalDataPath);\n\n    // Initialize base path for storage\n    CORE.Storage.basePath = CORE.Android.app->activity->internalDataPath;\n\n    TRACELOG(LOG_INFO, \"ANDROID: App initialized successfully\");\n\n    // Android ALooper_pollAll() variables\n    int pollResult = 0;\n    int pollEvents = 0;\n\n    // Wait for window to be initialized (display and context)\n    while (!CORE.Window.ready)\n    {\n        // Process events loop\n        while ((pollResult = ALooper_pollAll(0, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)\n        {\n            // Process this event\n            if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);\n\n            // NOTE: Never close window, native activity is controlled by the system!\n            //if (CORE.Android.app->destroyRequested != 0) CORE.Window.shouldClose = true;\n        }\n    }\n#endif\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Initialize graphics device (display device and OpenGL context)\n    // NOTE: returns true if window and graphic device has been initialized successfully\n    CORE.Window.ready = InitGraphicsDevice(width, height);\n\n    // If graphic device is no properly initialized, we end program\n    if (!CORE.Window.ready)\n    {\n        TRACELOG(LOG_FATAL, \"Failed to initialize Graphic Device\");\n        return;\n    }\n    else SetWindowPosition(GetMonitorWidth(GetCurrentMonitor())/2 - CORE.Window.screen.width/2, GetMonitorHeight(GetCurrentMonitor())/2 - CORE.Window.screen.height/2);\n\n    // Initialize hi-res timer\n    InitTimer();\n\n    // Initialize random seed\n    srand((unsigned int)time(NULL));\n\n    // Initialize base path for storage\n    CORE.Storage.basePath = GetWorkingDirectory();\n\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n    // Load default font\n    // WARNING: External function: Module required: rtext\n    LoadFontDefault();\n    #if defined(SUPPORT_MODULE_RSHAPES)\n    Rectangle rec = GetFontDefault().recs[95];\n    // NOTE: We set up a 1px padding on char rectangle to avoid pixel bleeding on MSAA filtering\n    SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 }); // WARNING: Module required: rshapes\n    #endif\n#else\n    #if defined(SUPPORT_MODULE_RSHAPES)\n    // Set default texture and rectangle to be used for shapes drawing\n    // NOTE: rlgl default texture is a 1x1 pixel UNCOMPRESSED_R8G8B8A8\n    Texture2D texture = { rlGetTextureIdDefault(), 1, 1, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n    SetShapesTexture(texture, (Rectangle){ 0.0f, 0.0f, 1.0f, 1.0f });    // WARNING: Module required: rshapes\n    #endif\n#endif\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        // Set default font texture filter for HighDPI (blurry)\n        // RL_TEXTURE_FILTER_LINEAR - tex filter: BILINEAR, no mipmaps\n        rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);\n        rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);\n    }\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Initialize raw input system\n    InitEvdevInput();   // Evdev inputs initialization\n    InitGamepad();      // Gamepad init\n    InitKeyboard();     // Keyboard init (stdin)\n#endif\n\n#if defined(PLATFORM_WEB)\n    // Setup callback funtions for the DOM events\n    emscripten_set_fullscreenchange_callback(\"#canvas\", NULL, 1, EmscriptenFullscreenChangeCallback);\n\n    // WARNING: Below resize code was breaking fullscreen mode for sample games and examples, it needs review\n    // Check fullscreen change events(note this is done on the window since most browsers don't support this on #canvas)\n    //emscripten_set_fullscreenchange_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, 1, EmscriptenResizeCallback);\n    // Check Resize event (note this is done on the window since most browsers don't support this on #canvas)\n    //emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, 1, EmscriptenResizeCallback);\n    // Trigger this once to get initial window sizing\n    //EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);\n\n    // Support keyboard events -> Not used, GLFW.JS takes care of that\n    //emscripten_set_keypress_callback(\"#canvas\", NULL, 1, EmscriptenKeyboardCallback);\n    //emscripten_set_keydown_callback(\"#canvas\", NULL, 1, EmscriptenKeyboardCallback);\n\n    // Support mouse events\n    emscripten_set_click_callback(\"#canvas\", NULL, 1, EmscriptenMouseCallback);\n\n    // Support touch events\n    emscripten_set_touchstart_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n    emscripten_set_touchend_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n    emscripten_set_touchmove_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n    emscripten_set_touchcancel_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n\n    // Support gamepad events (not provided by GLFW3 on emscripten)\n    emscripten_set_gamepadconnected_callback(NULL, 1, EmscriptenGamepadCallback);\n    emscripten_set_gamepaddisconnected_callback(NULL, 1, EmscriptenGamepadCallback);\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    events = (AutomationEvent *)malloc(MAX_CODE_AUTOMATION_EVENTS*sizeof(AutomationEvent));\n    CORE.Time.frameCounter = 0;\n#endif\n\n#endif        // PLATFORM_DESKTOP || PLATFORM_WEB || PLATFORM_RPI || PLATFORM_DRM\n}\n\n// Close window and unload OpenGL context\nvoid CloseWindow(void)\n{\n#if defined(SUPPORT_GIF_RECORDING)\n    if (gifRecording)\n    {\n        MsfGifResult result = msf_gif_end(&gifState);\n        msf_gif_free(result);\n        gifRecording = false;\n    }\n#endif\n\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n    UnloadFontDefault();        // WARNING: Module required: rtext\n#endif\n\n    rlglClose();                // De-init rlgl\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwDestroyWindow(CORE.Window.handle);\n    glfwTerminate();\n#endif\n\n#if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)\n    timeEndPeriod(1);           // Restore time period\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI)\n    // Close surface, context and display\n    if (CORE.Window.device != EGL_NO_DISPLAY)\n    {\n        eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n\n        if (CORE.Window.surface != EGL_NO_SURFACE)\n        {\n            eglDestroySurface(CORE.Window.device, CORE.Window.surface);\n            CORE.Window.surface = EGL_NO_SURFACE;\n        }\n\n        if (CORE.Window.context != EGL_NO_CONTEXT)\n        {\n            eglDestroyContext(CORE.Window.device, CORE.Window.context);\n            CORE.Window.context = EGL_NO_CONTEXT;\n        }\n\n        eglTerminate(CORE.Window.device);\n        CORE.Window.device = EGL_NO_DISPLAY;\n    }\n#endif\n\n#if defined(PLATFORM_DRM)\n    if (CORE.Window.prevFB)\n    {\n        drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);\n        CORE.Window.prevFB = 0;\n    }\n\n    if (CORE.Window.prevBO)\n    {\n        gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);\n        CORE.Window.prevBO = NULL;\n    }\n\n    if (CORE.Window.gbmSurface)\n    {\n        gbm_surface_destroy(CORE.Window.gbmSurface);\n        CORE.Window.gbmSurface = NULL;\n    }\n\n    if (CORE.Window.gbmDevice)\n    {\n        gbm_device_destroy(CORE.Window.gbmDevice);\n        CORE.Window.gbmDevice = NULL;\n    }\n\n    if (CORE.Window.crtc)\n    {\n        if (CORE.Window.connector)\n        {\n            drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, CORE.Window.crtc->buffer_id,\n                CORE.Window.crtc->x, CORE.Window.crtc->y, &CORE.Window.connector->connector_id, 1, &CORE.Window.crtc->mode);\n            drmModeFreeConnector(CORE.Window.connector);\n            CORE.Window.connector = NULL;\n        }\n\n        drmModeFreeCrtc(CORE.Window.crtc);\n        CORE.Window.crtc = NULL;\n    }\n\n    if (CORE.Window.fd != -1)\n    {\n        close(CORE.Window.fd);\n        CORE.Window.fd = -1;\n    }\n\n    // Close surface, context and display\n    if (CORE.Window.device != EGL_NO_DISPLAY)\n    {\n        if (CORE.Window.surface != EGL_NO_SURFACE)\n        {\n            eglDestroySurface(CORE.Window.device, CORE.Window.surface);\n            CORE.Window.surface = EGL_NO_SURFACE;\n        }\n\n        if (CORE.Window.context != EGL_NO_CONTEXT)\n        {\n            eglDestroyContext(CORE.Window.device, CORE.Window.context);\n            CORE.Window.context = EGL_NO_CONTEXT;\n        }\n\n        eglTerminate(CORE.Window.device);\n        CORE.Window.device = EGL_NO_DISPLAY;\n    }\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Wait for mouse and gamepad threads to finish before closing\n    // NOTE: Those threads should already have finished at this point\n    // because they are controlled by CORE.Window.shouldClose variable\n\n    CORE.Window.shouldClose = true;   // Added to force threads to exit when the close window is called\n\n    // Close the evdev keyboard\n    if (CORE.Input.Keyboard.fd != -1)\n    {\n        close(CORE.Input.Keyboard.fd);\n        CORE.Input.Keyboard.fd = -1;\n    }\n\n    for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n    {\n        if (CORE.Input.eventWorker[i].threadId)\n        {\n            pthread_join(CORE.Input.eventWorker[i].threadId, NULL);\n        }\n    }\n\n    if (CORE.Input.Gamepad.threadId) pthread_join(CORE.Input.Gamepad.threadId, NULL);\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    free(events);\n#endif\n\n    CORE.Window.ready = false;\n    TRACELOG(LOG_INFO, \"Window closed successfully\");\n}\n\n// Check if KEY_ESCAPE pressed or Close icon pressed\nbool WindowShouldClose(void)\n{\n#if defined(PLATFORM_WEB)\n    // Emterpreter-Async required to run sync code\n    // https://github.com/emscripten-core/emscripten/wiki/Emterpreter#emterpreter-async-run-synchronous-code\n    // By default, this function is never called on a web-ready raylib example because we encapsulate\n    // frame code in a UpdateDrawFrame() function, to allow browser manage execution asynchronously\n    // but now emscripten allows sync code to be executed in an interpreted way, using emterpreter!\n    emscripten_sleep(16);\n    return false;\n#endif\n\n#if defined(PLATFORM_DESKTOP)\n    if (CORE.Window.ready)\n    {\n        // While window minimized, stop loop execution\n        while (IsWindowState(FLAG_WINDOW_MINIMIZED) && !IsWindowState(FLAG_WINDOW_ALWAYS_RUN)) glfwWaitEvents();\n\n        CORE.Window.shouldClose = glfwWindowShouldClose(CORE.Window.handle);\n\n        // Reset close status for next frame\n        glfwSetWindowShouldClose(CORE.Window.handle, GLFW_FALSE);\n\n        return CORE.Window.shouldClose;\n    }\n    else return true;\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    if (CORE.Window.ready) return CORE.Window.shouldClose;\n    else return true;\n#endif\n}\n\n// Check if window has been initialized successfully\nbool IsWindowReady(void)\n{\n    return CORE.Window.ready;\n}\n\n// Check if window is currently fullscreen\nbool IsWindowFullscreen(void)\n{\n    return CORE.Window.fullscreen;\n}\n\n// Check if window is currently hidden\nbool IsWindowHidden(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0);\n#endif\n    return false;\n}\n\n// Check if window has been minimized\nbool IsWindowMinimized(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    return ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0);\n#endif\n    return false;\n}\n\n// Check if window has been maximized (only PLATFORM_DESKTOP)\nbool IsWindowMaximized(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0);\n#endif\n    return false;\n}\n\n// Check if window has the focus\nbool IsWindowFocused(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    return ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) == 0);\n#endif\n#if defined(PLATFORM_ANDROID)\n    return CORE.Android.appEnabled;\n#endif\n    return true;\n}\n\n// Check if window has been resizedLastFrame\nbool IsWindowResized(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    return CORE.Window.resizedLastFrame;\n#else\n    return false;\n#endif\n}\n\n// Check if one specific window flag is enabled\nbool IsWindowState(unsigned int flag)\n{\n    return ((CORE.Window.flags & flag) > 0);\n}\n\n// Toggle fullscreen mode (only PLATFORM_DESKTOP)\nvoid ToggleFullscreen(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (!CORE.Window.fullscreen)\n    {\n        // Store previous window position (in case we exit fullscreen)\n        glfwGetWindowPos(CORE.Window.handle, &CORE.Window.position.x, &CORE.Window.position.y);\n\n        int monitorCount = 0;\n        int monitorIndex = GetCurrentMonitor();\n        GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n        // Use current monitor, so we correctly get the display the window is on\n        GLFWmonitor *monitor = (monitorIndex < monitorCount)? monitors[monitorIndex] : NULL;\n\n        if (monitor == NULL)\n        {\n            TRACELOG(LOG_WARNING, \"GLFW: Failed to get monitor\");\n\n            CORE.Window.fullscreen = false;\n            CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;\n\n            glfwSetWindowMonitor(CORE.Window.handle, NULL, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n        }\n        else\n        {\n            CORE.Window.fullscreen = true;\n            CORE.Window.flags |= FLAG_FULLSCREEN_MODE;\n\n            glfwSetWindowMonitor(CORE.Window.handle, monitor, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n        }\n    }\n    else\n    {\n        CORE.Window.fullscreen = false;\n        CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;\n\n        glfwSetWindowMonitor(CORE.Window.handle, NULL, CORE.Window.position.x, CORE.Window.position.y, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n    }\n\n    // Try to enable GPU V-Sync, so frames are limited to screen refresh rate (60Hz -> 60 FPS)\n    // NOTE: V-Sync can be enabled by graphic driver configuration\n    if (CORE.Window.flags & FLAG_VSYNC_HINT) glfwSwapInterval(1);\n#endif\n#if defined(PLATFORM_WEB)\n/*\n    EM_ASM\n    (\n        // This strategy works well while using raylib minimal web shell for emscripten,\n        // it re-scales the canvas to fullscreen using monitor resolution, for tools this\n        // is a good strategy but maybe games prefer to keep current canvas resolution and\n        // display it in fullscreen, adjusting monitor resolution if possible\n        if (document.fullscreenElement) document.exitFullscreen();\n        else Module.requestFullscreen(true, true); //false, true);\n    );\n*/\n    //EM_ASM(Module.requestFullscreen(false, false););\n/*\n    if (!CORE.Window.fullscreen)\n    {\n        // Option 1: Request fullscreen for the canvas element\n        // This option does not seem to work at all:\n        // emscripten_request_pointerlock() and emscripten_request_fullscreen() are affected by web security,\n        // the user must click once on the canvas to hide the pointer or transition to full screen\n        //emscripten_request_fullscreen(\"#canvas\", false);\n\n        // Option 2: Request fullscreen for the canvas element with strategy\n        // This option does not seem to work at all\n        // Ref: https://github.com/emscripten-core/emscripten/issues/5124\n        // EmscriptenFullscreenStrategy strategy = {\n            // .scaleMode = EMSCRIPTEN_FULLSCREEN_SCALE_STRETCH, //EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT,\n            // .canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF,\n            // .filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT,\n            // .canvasResizedCallback = EmscriptenWindowResizedCallback,\n            // .canvasResizedCallbackUserData = NULL\n        // };\n        //emscripten_request_fullscreen_strategy(\"#canvas\", EM_FALSE, &strategy);\n\n        // Option 3: Request fullscreen for the canvas element with strategy\n        // It works as expected but only inside the browser (client area)\n        EmscriptenFullscreenStrategy strategy = {\n            .scaleMode = EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT,\n            .canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF,\n            .filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT,\n            .canvasResizedCallback = EmscriptenWindowResizedCallback,\n            .canvasResizedCallbackUserData = NULL\n        };\n        emscripten_enter_soft_fullscreen(\"#canvas\", &strategy);\n\n        int width, height;\n        emscripten_get_canvas_element_size(\"#canvas\", &width, &height);\n        TRACELOG(LOG_WARNING, \"Emscripten: Enter fullscreen: Canvas size: %i x %i\", width, height);\n\n        CORE.Window.fullscreen = true;          // Toggle fullscreen flag\n        CORE.Window.flags |= FLAG_FULLSCREEN_MODE;\n    }\n    else\n    {\n        //emscripten_exit_fullscreen();\n        //emscripten_exit_soft_fullscreen();\n\n        int width, height;\n        emscripten_get_canvas_element_size(\"#canvas\", &width, &height);\n        TRACELOG(LOG_WARNING, \"Emscripten: Exit fullscreen: Canvas size: %i x %i\", width, height);\n\n        CORE.Window.fullscreen = false;          // Toggle fullscreen flag\n        CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;\n    }\n*/\n\n    CORE.Window.fullscreen = !CORE.Window.fullscreen;          // Toggle fullscreen flag\n#endif\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    TRACELOG(LOG_WARNING, \"SYSTEM: Failed to toggle to windowed mode\");\n#endif\n}\n\n// Set window state: maximized, if resizable (only PLATFORM_DESKTOP)\nvoid MaximizeWindow(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)\n    {\n        glfwMaximizeWindow(CORE.Window.handle);\n        CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;\n    }\n#endif\n}\n\n// Set window state: minimized (only PLATFORM_DESKTOP)\nvoid MinimizeWindow(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    // NOTE: Following function launches callback that sets appropriate flag!\n    glfwIconifyWindow(CORE.Window.handle);\n#endif\n}\n\n// Set window state: not minimized/maximized (only PLATFORM_DESKTOP)\nvoid RestoreWindow(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)\n    {\n        // Restores the specified window if it was previously iconified (minimized) or maximized\n        glfwRestoreWindow(CORE.Window.handle);\n        CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;\n        CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;\n    }\n#endif\n}\n\n// Set window configuration state using flags\nvoid SetWindowState(unsigned int flags)\n{\n#if defined(PLATFORM_DESKTOP)\n    // Check previous state and requested state to apply required changes\n    // NOTE: In most cases the functions already change the flags internally\n\n    // State change: FLAG_VSYNC_HINT\n    if (((CORE.Window.flags & FLAG_VSYNC_HINT) != (flags & FLAG_VSYNC_HINT)) && ((flags & FLAG_VSYNC_HINT) > 0))\n    {\n        glfwSwapInterval(1);\n        CORE.Window.flags |= FLAG_VSYNC_HINT;\n    }\n\n    // State change: FLAG_FULLSCREEN_MODE\n    if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) != (flags & FLAG_FULLSCREEN_MODE))\n    {\n        ToggleFullscreen();     // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_RESIZABLE\n    if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != (flags & FLAG_WINDOW_RESIZABLE)) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_TRUE);\n        CORE.Window.flags |= FLAG_WINDOW_RESIZABLE;\n    }\n\n    // State change: FLAG_WINDOW_UNDECORATED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) != (flags & FLAG_WINDOW_UNDECORATED)) && (flags & FLAG_WINDOW_UNDECORATED))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_FALSE);\n        CORE.Window.flags |= FLAG_WINDOW_UNDECORATED;\n    }\n\n    // State change: FLAG_WINDOW_HIDDEN\n    if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) != (flags & FLAG_WINDOW_HIDDEN)) && ((flags & FLAG_WINDOW_HIDDEN) > 0))\n    {\n        glfwHideWindow(CORE.Window.handle);\n        CORE.Window.flags |= FLAG_WINDOW_HIDDEN;\n    }\n\n    // State change: FLAG_WINDOW_MINIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) != (flags & FLAG_WINDOW_MINIMIZED)) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))\n    {\n        //GLFW_ICONIFIED\n        MinimizeWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_MAXIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) != (flags & FLAG_WINDOW_MAXIMIZED)) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))\n    {\n        //GLFW_MAXIMIZED\n        MaximizeWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_UNFOCUSED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) != (flags & FLAG_WINDOW_UNFOCUSED)) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_FALSE);\n        CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;\n    }\n\n    // State change: FLAG_WINDOW_TOPMOST\n    if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) != (flags & FLAG_WINDOW_TOPMOST)) && ((flags & FLAG_WINDOW_TOPMOST) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_TRUE);\n        CORE.Window.flags |= FLAG_WINDOW_TOPMOST;\n    }\n\n    // State change: FLAG_WINDOW_ALWAYS_RUN\n    if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) != (flags & FLAG_WINDOW_ALWAYS_RUN)) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))\n    {\n        CORE.Window.flags |= FLAG_WINDOW_ALWAYS_RUN;\n    }\n\n    // The following states can not be changed after window creation\n\n    // State change: FLAG_WINDOW_TRANSPARENT\n    if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) != (flags & FLAG_WINDOW_TRANSPARENT)) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_HIGHDPI\n    if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) != (flags & FLAG_WINDOW_HIGHDPI)) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_MOUSE_PASSTHROUGH\n    if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) != (flags & FLAG_WINDOW_MOUSE_PASSTHROUGH)) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);\n        CORE.Window.flags |= FLAG_WINDOW_MOUSE_PASSTHROUGH;\n    }\n\n    // State change: FLAG_MSAA_4X_HINT\n    if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) != (flags & FLAG_MSAA_4X_HINT)) && ((flags & FLAG_MSAA_4X_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_INTERLACED_HINT\n    if (((CORE.Window.flags & FLAG_INTERLACED_HINT) != (flags & FLAG_INTERLACED_HINT)) && ((flags & FLAG_INTERLACED_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");\n    }\n#endif\n}\n\n// Clear window configuration state flags\nvoid ClearWindowState(unsigned int flags)\n{\n#if defined(PLATFORM_DESKTOP)\n    // Check previous state and requested state to apply required changes\n    // NOTE: In most cases the functions already change the flags internally\n\n    // State change: FLAG_VSYNC_HINT\n    if (((CORE.Window.flags & FLAG_VSYNC_HINT) > 0) && ((flags & FLAG_VSYNC_HINT) > 0))\n    {\n        glfwSwapInterval(0);\n        CORE.Window.flags &= ~FLAG_VSYNC_HINT;\n    }\n\n    // State change: FLAG_FULLSCREEN_MODE\n    if (((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) && ((flags & FLAG_FULLSCREEN_MODE) > 0))\n    {\n        ToggleFullscreen();     // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_RESIZABLE\n    if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_FALSE);\n        CORE.Window.flags &= ~FLAG_WINDOW_RESIZABLE;\n    }\n\n    // State change: FLAG_WINDOW_UNDECORATED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) && ((flags & FLAG_WINDOW_UNDECORATED) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_TRUE);\n        CORE.Window.flags &= ~FLAG_WINDOW_UNDECORATED;\n    }\n\n    // State change: FLAG_WINDOW_HIDDEN\n    if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) && ((flags & FLAG_WINDOW_HIDDEN) > 0))\n    {\n        glfwShowWindow(CORE.Window.handle);\n        CORE.Window.flags &= ~FLAG_WINDOW_HIDDEN;\n    }\n\n    // State change: FLAG_WINDOW_MINIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))\n    {\n        RestoreWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_MAXIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))\n    {\n        RestoreWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_UNFOCUSED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_TRUE);\n        CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;\n    }\n\n    // State change: FLAG_WINDOW_TOPMOST\n    if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) && ((flags & FLAG_WINDOW_TOPMOST) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_FALSE);\n        CORE.Window.flags &= ~FLAG_WINDOW_TOPMOST;\n    }\n\n    // State change: FLAG_WINDOW_ALWAYS_RUN\n    if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) > 0) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))\n    {\n        CORE.Window.flags &= ~FLAG_WINDOW_ALWAYS_RUN;\n    }\n\n    // The following states can not be changed after window creation\n\n    // State change: FLAG_WINDOW_TRANSPARENT\n    if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_HIGHDPI\n    if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_MOUSE_PASSTHROUGH\n    if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);\n        CORE.Window.flags &= ~FLAG_WINDOW_MOUSE_PASSTHROUGH;\n    }\n\n    // State change: FLAG_MSAA_4X_HINT\n    if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) > 0) && ((flags & FLAG_MSAA_4X_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_INTERLACED_HINT\n    if (((CORE.Window.flags & FLAG_INTERLACED_HINT) > 0) && ((flags & FLAG_INTERLACED_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");\n    }\n#endif\n}\n\n// Set icon for window (only PLATFORM_DESKTOP)\n// NOTE 1: Image must be in RGBA format, 8bit per channel\n// NOTE 2: Image is scaled by the OS for all required sizes\nvoid SetWindowIcon(Image image)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (image.data == NULL)\n    {\n        // Revert to the default window icon, pass in an empty image array\n        glfwSetWindowIcon(CORE.Window.handle, 0, NULL);\n    }\n    else\n    {\n        if (image.format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)\n        {\n            GLFWimage icon[1] = { 0 };\n\n            icon[0].width = image.width;\n            icon[0].height = image.height;\n            icon[0].pixels = (unsigned char *)image.data;\n\n            // NOTE 1: We only support one image icon\n            // NOTE 2: The specified image data is copied before this function returns\n            glfwSetWindowIcon(CORE.Window.handle, 1, icon);\n        }\n        else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");\n    }\n#endif\n}\n\n// Set icon for window (multiple images, only PLATFORM_DESKTOP)\n// NOTE 1: Images must be in RGBA format, 8bit per channel\n// NOTE 2: The multiple images are used depending on provided sizes\n// Standard Windows icon sizes: 256, 128, 96, 64, 48, 32, 24, 16\nvoid SetWindowIcons(Image *images, int count)\n{\n#if defined(PLATFORM_DESKTOP)\n    if ((images == NULL) || (count <= 0))\n    {\n        // Revert to the default window icon, pass in an empty image array\n        glfwSetWindowIcon(CORE.Window.handle, 0, NULL);\n    }\n    else\n    {\n        int valid = 0;\n        GLFWimage *icons = RL_CALLOC(count, sizeof(GLFWimage));\n\n        for (int i = 0; i < count; i++)\n        {\n            if (images[i].format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)\n            {\n                icons[valid].width = images[i].width;\n                icons[valid].height = images[i].height;\n                icons[valid].pixels = (unsigned char *)images[i].data;\n\n                valid++;\n            }\n            else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");\n        }\n        // NOTE: Images data is copied internally before this function returns\n        glfwSetWindowIcon(CORE.Window.handle, valid, icons);\n\n        RL_FREE(icons);\n    }\n#endif\n}\n\n// Set title for window (only PLATFORM_DESKTOP)\nvoid SetWindowTitle(const char *title)\n{\n    CORE.Window.title = title;\n#if defined(PLATFORM_DESKTOP)\n    glfwSetWindowTitle(CORE.Window.handle, title);\n#endif\n}\n\n// Set window position on screen (windowed mode)\nvoid SetWindowPosition(int x, int y)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetWindowPos(CORE.Window.handle, x, y);\n#endif\n}\n\n// Set monitor for the current window (fullscreen mode)\nvoid SetWindowMonitor(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount = 0;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        TRACELOG(LOG_INFO, \"GLFW: Selected fullscreen monitor: [%i] %s\", monitor, glfwGetMonitorName(monitors[monitor]));\n\n        const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);\n        glfwSetWindowMonitor(CORE.Window.handle, monitors[monitor], 0, 0, mode->width, mode->height, mode->refreshRate);\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n}\n\n// Set window minimum dimensions (FLAG_WINDOW_RESIZABLE)\nvoid SetWindowMinSize(int width, int height)\n{\n#if defined(PLATFORM_DESKTOP)\n    const GLFWvidmode *mode = glfwGetVideoMode(glfwGetPrimaryMonitor());\n    glfwSetWindowSizeLimits(CORE.Window.handle, width, height, mode->width, mode->height);\n#endif\n}\n\n// Set window dimensions\nvoid SetWindowSize(int width, int height)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwSetWindowSize(CORE.Window.handle, width, height);\n#endif\n}\n\n// Set window opacity, value opacity is between 0.0 and 1.0\nvoid SetWindowOpacity(float opacity)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (opacity >= 1.0f) opacity = 1.0f;\n    else if (opacity <= 0.0f) opacity = 0.0f;\n    glfwSetWindowOpacity(CORE.Window.handle, opacity);\n#endif\n}\n\n// Get current screen width\nint GetScreenWidth(void)\n{\n    return CORE.Window.screen.width;\n}\n\n// Get current screen height\nint GetScreenHeight(void)\n{\n    return CORE.Window.screen.height;\n}\n\n// Get current render width which is equal to screen width * dpi scale\nint GetRenderWidth(void)\n{\n    return CORE.Window.render.width;\n}\n\n// Get current screen height which is equal to screen height * dpi scale\nint GetRenderHeight(void)\n{\n    return CORE.Window.render.height;\n}\n\n// Get native window handle\nvoid *GetWindowHandle(void)\n{\n#if defined(PLATFORM_DESKTOP) && defined(_WIN32)\n    // NOTE: Returned handle is: void *HWND (windows.h)\n    return glfwGetWin32Window(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_DESKTOP) && defined(__linux__)\n    // NOTE: Returned handle is: unsigned long Window (X.h)\n    // typedef unsigned long XID;\n    // typedef XID Window;\n    //unsigned long id = (unsigned long)glfwGetX11Window(CORE.Window.handle);\n    //return NULL;    // TODO: Find a way to return value... cast to void *?\n    return (void *)CORE.Window.handle;\n#endif\n#if defined(__APPLE__)\n    // NOTE: Returned handle is: (objc_object *)\n    return (void *)glfwGetCocoaWindow(CORE.Window.handle);\n#endif\n\n    return NULL;\n}\n\n// Get number of monitors\nint GetMonitorCount(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    glfwGetMonitors(&monitorCount);\n    return monitorCount;\n#else\n    return 1;\n#endif\n}\n\n// Get number of monitors\nint GetCurrentMonitor(void)\n{\n    int index = 0;\n\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n    GLFWmonitor *monitor = NULL;\n\n    if (monitorCount > 1)\n    {\n        if (IsWindowFullscreen())\n        {\n            // Get the handle of the monitor that the specified window is in full screen on\n            monitor = glfwGetWindowMonitor(CORE.Window.handle);\n\n            for (int i = 0; i < monitorCount; i++)\n            {\n                if (monitors[i] == monitor)\n                {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        else\n        {\n            int x = 0;\n            int y = 0;\n\n            glfwGetWindowPos(CORE.Window.handle, &x, &y);\n\n            for (int i = 0; i < monitorCount; i++)\n            {\n                int mx = 0;\n                int my = 0;\n\n                int width = 0;\n                int height = 0;\n\n                monitor = monitors[i];\n                glfwGetMonitorWorkarea(monitor, &mx, &my, &width, &height);\n\n                if (x >= mx && x <= (mx + width) && y >= my && y <= (my + height))\n                {\n                    index = i;\n                    break;\n                }\n            }\n        }\n    }\n#endif\n\n    return index;\n}\n\n// Get selected monitor position\nVector2 GetMonitorPosition(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        int x, y;\n        glfwGetMonitorPos(monitors[monitor], &x, &y);\n\n        return (Vector2){ (float)x, (float)y };\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return (Vector2){ 0, 0 };\n}\n\n// Get selected monitor width (currently used by monitor)\nint GetMonitorWidth(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);\n\n        if (mode) return mode->width;\n        else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n#if defined(PLATFORM_ANDROID)\n    if (CORE.Android.app->window != NULL)\n    {\n        return ANativeWindow_getWidth(CORE.Android.app->window);\n    }\n#endif\n    return 0;\n}\n\n// Get selected monitor height (currently used by monitor)\nint GetMonitorHeight(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);\n\n        if (mode) return mode->height;\n        else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n#if defined(PLATFORM_ANDROID)\n    if (CORE.Android.app->window != NULL)\n    {\n        return ANativeWindow_getHeight(CORE.Android.app->window);\n    }\n#endif\n    return 0;\n}\n\n// Get selected monitor physical width in millimetres\nint GetMonitorPhysicalWidth(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        int physicalWidth;\n        glfwGetMonitorPhysicalSize(monitors[monitor], &physicalWidth, NULL);\n        return physicalWidth;\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return 0;\n}\n\n// Get selected monitor physical height in millimetres\nint GetMonitorPhysicalHeight(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        int physicalHeight;\n        glfwGetMonitorPhysicalSize(monitors[monitor], NULL, &physicalHeight);\n        return physicalHeight;\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return 0;\n}\n\n// Get selected monitor refresh rate\nint GetMonitorRefreshRate(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        const GLFWvidmode *vidmode = glfwGetVideoMode(monitors[monitor]);\n        return vidmode->refreshRate;\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n#if defined(PLATFORM_DRM)\n    if ((CORE.Window.connector) && (CORE.Window.modeIndex >= 0))\n    {\n        return CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh;\n    }\n#endif\n    return 0;\n}\n\n// Get window position XY on monitor\nVector2 GetWindowPosition(void)\n{\n    int x = 0;\n    int y = 0;\n#if defined(PLATFORM_DESKTOP)\n    glfwGetWindowPos(CORE.Window.handle, &x, &y);\n#endif\n    return (Vector2){ (float)x, (float)y };\n}\n\n// Get window scale DPI factor for current monitor\nVector2 GetWindowScaleDPI(void)\n{\n    Vector2 scale = { 1.0f, 1.0f };\n\n#if defined(PLATFORM_DESKTOP)\n    float xdpi = 1.0;\n    float ydpi = 1.0;\n    Vector2 windowPos = GetWindowPosition();\n\n    int monitorCount = 0;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    // Check window monitor\n    for (int i = 0; i < monitorCount; i++)\n    {\n        glfwGetMonitorContentScale(monitors[i], &xdpi, &ydpi);\n\n        int xpos, ypos, width, height;\n        glfwGetMonitorWorkarea(monitors[i], &xpos, &ypos, &width, &height);\n\n        if ((windowPos.x >= xpos) && (windowPos.x < xpos + width) &&\n            (windowPos.y >= ypos) && (windowPos.y < ypos + height))\n        {\n            scale.x = xdpi;\n            scale.y = ydpi;\n            break;\n        }\n    }\n#endif\n\n    return scale;\n}\n\n// Get the human-readable, UTF-8 encoded name of the selected monitor\nconst char *GetMonitorName(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        return glfwGetMonitorName(monitors[monitor]);\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return \"\";\n}\n\n// Set clipboard text content\nvoid SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}\n\n// Get clipboard text content\n// NOTE: returned string is allocated and freed by GLFW\nconst char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n    // Accessing clipboard data from browser is tricky due to security reasons\n    // The method to use is navigator.clipboard.readText() but this is an asynchronous method\n    // that will return at some moment after the function is called with the required data\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n\n    // The main issue is getting that data, one approach could be using ASYNCIFY and wait\n    // for the data but it requires adding Asyncify emscripten library on compilation\n\n    // Another approach could be just copy the data in a HTML text field and try to retrieve it\n    // later on if available... and clean it for future accesses\n\n    return NULL;\n#endif\n    return NULL;\n}\n\n// Enable waiting for events on EndDrawing(), no automatic event polling\nvoid EnableEventWaiting(void)\n{\n    CORE.Window.eventWaiting = true;\n}\n\n// Disable waiting for events on EndDrawing(), automatic events polling\nvoid DisableEventWaiting(void)\n{\n    CORE.Window.eventWaiting = false;\n}\n\n// Show mouse cursor\nvoid ShowCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n#endif\n\n    CORE.Input.Mouse.cursorHidden = false;\n}\n\n// Hides mouse cursor\nvoid HideCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);\n#endif\n\n    CORE.Input.Mouse.cursorHidden = true;\n}\n\n// Check if cursor is not visible\nbool IsCursorHidden(void)\n{\n    return CORE.Input.Mouse.cursorHidden;\n}\n\n// Enables cursor (unlock cursor)\nvoid EnableCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_exit_pointerlock();\n#endif\n    // Set cursor position in the middle\n    SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);\n\n    CORE.Input.Mouse.cursorHidden = false;\n}\n\n// Disables cursor (lock cursor)\nvoid DisableCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_request_pointerlock(\"#canvas\", 1);\n#endif\n    // Set cursor position in the middle\n    SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);\n\n    CORE.Input.Mouse.cursorHidden = true;\n}\n\n// Check if cursor is on the current screen.\nbool IsCursorOnScreen(void)\n{\n    return CORE.Input.Mouse.cursorOnScreen;\n}\n\n// Set background color (framebuffer clear color)\nvoid ClearBackground(Color color)\n{\n    rlClearColor(color.r, color.g, color.b, color.a);   // Set clear color\n    rlClearScreenBuffers();                             // Clear current framebuffers\n}\n\n// Setup canvas (framebuffer) to start drawing\nvoid BeginDrawing(void)\n{\n    // WARNING: Previously to BeginDrawing() other render textures drawing could happen,\n    // consequently the measure for update vs draw is not accurate (only the total frame time is accurate)\n\n    CORE.Time.current = GetTime();      // Number of elapsed seconds since InitTimer()\n    CORE.Time.update = CORE.Time.current - CORE.Time.previous;\n    CORE.Time.previous = CORE.Time.current;\n\n    rlLoadIdentity();                   // Reset current matrix (modelview)\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling\n\n    //rlTranslatef(0.375, 0.375, 0);    // HACK to have 2D pixel-perfect drawing on OpenGL 1.1\n                                        // NOTE: Not required with OpenGL 3.3+\n}\n\n// End canvas drawing and swap buffers (double buffering)\nvoid EndDrawing(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n#if defined(SUPPORT_GIF_RECORDING)\n    // Draw record indicator\n    if (gifRecording)\n    {\n        #define GIF_RECORD_FRAMERATE    10\n        gifFrameCounter++;\n\n        // NOTE: We record one gif frame every 10 game frames\n        if ((gifFrameCounter%GIF_RECORD_FRAMERATE) == 0)\n        {\n            // Get image data for the current frame (from backbuffer)\n            // NOTE: This process is quite slow... :(\n            Vector2 scale = GetWindowScaleDPI();\n            unsigned char *screenData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n            msf_gif_frame(&gifState, screenData, 10, 16, (int)((float)CORE.Window.render.width*scale.x)*4);\n\n            RL_FREE(screenData);    // Free image data\n        }\n\n    #if defined(SUPPORT_MODULE_RSHAPES) && defined(SUPPORT_MODULE_RTEXT)\n        if (((gifFrameCounter/15)%2) == 1)\n        {\n            DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);                 // WARNING: Module required: rshapes\n            DrawText(\"GIF RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);     // WARNING: Module required: rtext\n        }\n    #endif\n\n        rlDrawRenderBatchActive();  // Update and draw internal render batch\n    }\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    // Draw record/play indicator\n    if (eventsRecording)\n    {\n        gifFrameCounter++;\n\n        if (((gifFrameCounter/15)%2) == 1)\n        {\n            DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);\n            DrawText(\"EVENTS RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);\n        }\n\n        rlDrawRenderBatchActive();  // Update and draw internal render batch\n    }\n    else if (eventsPlaying)\n    {\n        gifFrameCounter++;\n\n        if (((gifFrameCounter/15)%2) == 1)\n        {\n            DrawCircle(30, CORE.Window.screen.height - 20, 10, LIME);\n            DrawText(\"EVENTS PLAYING\", 50, CORE.Window.screen.height - 25, 10, GREEN);\n        }\n\n        rlDrawRenderBatchActive();  // Update and draw internal render batch\n    }\n#endif\n\n#if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)\n    SwapScreenBuffer();                  // Copy back buffer to front buffer (screen)\n\n    // Frame time control system\n    CORE.Time.current = GetTime();\n    CORE.Time.draw = CORE.Time.current - CORE.Time.previous;\n    CORE.Time.previous = CORE.Time.current;\n\n    CORE.Time.frame = CORE.Time.update + CORE.Time.draw;\n\n    // Wait for some milliseconds...\n    if (CORE.Time.frame < CORE.Time.target)\n    {\n        WaitTime(CORE.Time.target - CORE.Time.frame);\n\n        CORE.Time.current = GetTime();\n        double waitTime = CORE.Time.current - CORE.Time.previous;\n        CORE.Time.previous = CORE.Time.current;\n\n        CORE.Time.frame += waitTime;    // Total frame time: update + draw + wait\n    }\n\n    PollInputEvents();      // Poll user events (before next frame update)\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    // Events recording and playing logic\n    if (eventsRecording) RecordAutomationEvent(CORE.Time.frameCounter);\n    else if (eventsPlaying)\n    {\n        // TODO: When should we play? After/before/replace PollInputEvents()?\n        if (CORE.Time.frameCounter >= eventCount) eventsPlaying = false;\n        PlayAutomationEvent(CORE.Time.frameCounter);\n    }\n#endif\n\n    CORE.Time.frameCounter++;\n}\n\n// Initialize 2D mode with custom camera (2D)\nvoid BeginMode2D(Camera2D camera)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    // Apply 2d camera transformation to modelview\n    rlMultMatrixf(MatrixToFloat(GetCameraMatrix2D(camera)));\n\n    // Apply screen scaling if required\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale));\n}\n\n// Ends 2D mode with custom camera\nvoid EndMode2D(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlLoadIdentity();               // Reset current matrix (modelview)\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required\n}\n\n// Initializes 3D mode with custom camera (3D)\nvoid BeginMode3D(Camera camera)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix\n    rlPushMatrix();                 // Save previous matrix, which contains the settings for the 2d ortho projection\n    rlLoadIdentity();               // Reset current matrix (projection)\n\n    float aspect = (float)CORE.Window.currentFbo.width/(float)CORE.Window.currentFbo.height;\n\n    // NOTE: zNear and zFar values are important when computing depth buffer values\n    if (camera.projection == CAMERA_PERSPECTIVE)\n    {\n        // Setup perspective projection\n        double top = RL_CULL_DISTANCE_NEAR*tan(camera.fovy*0.5*DEG2RAD);\n        double right = top*aspect;\n\n        rlFrustum(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC)\n    {\n        // Setup orthographic projection\n        double top = camera.fovy/2.0;\n        double right = top*aspect;\n\n        rlOrtho(-right, right, -top,top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n\n    rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    // Setup Camera view\n    Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);\n    rlMultMatrixf(MatrixToFloat(matView));      // Multiply modelview matrix by view matrix (camera)\n\n    rlEnableDepthTest();            // Enable DEPTH_TEST for 3D\n}\n\n// Ends 3D mode and returns to default 2D orthographic mode\nvoid EndMode3D(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix\n    rlPopMatrix();                  // Restore previous matrix (projection) from matrix stack\n\n    rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required\n\n    rlDisableDepthTest();           // Disable DEPTH_TEST for 2D\n}\n\n// Initializes render texture for drawing\nvoid BeginTextureMode(RenderTexture2D target)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlEnableFramebuffer(target.id); // Enable render target\n\n    // Set viewport and RLGL internal framebuffer size\n    rlViewport(0, 0, target.texture.width, target.texture.height);\n    rlSetFramebufferWidth(target.texture.width);\n    rlSetFramebufferHeight(target.texture.height);\n\n    rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix\n    rlLoadIdentity();               // Reset current matrix (projection)\n\n    // Set orthographic projection to current framebuffer size\n    // NOTE: Configured top-left corner as (0, 0)\n    rlOrtho(0, target.texture.width, target.texture.height, 0, 0.0f, 1.0f);\n\n    rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    //rlScalef(0.0f, -1.0f, 0.0f);  // Flip Y-drawing (?)\n\n    // Setup current width/height for proper aspect ratio\n    // calculation when using BeginMode3D()\n    CORE.Window.currentFbo.width = target.texture.width;\n    CORE.Window.currentFbo.height = target.texture.height;\n}\n\n// Ends drawing to render texture\nvoid EndTextureMode(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlDisableFramebuffer();         // Disable render target (fbo)\n\n    // Set viewport to default framebuffer size\n    SetupViewport(CORE.Window.render.width, CORE.Window.render.height);\n\n    // Reset current fbo to screen size\n    CORE.Window.currentFbo.width = CORE.Window.render.width;\n    CORE.Window.currentFbo.height = CORE.Window.render.height;\n}\n\n// Begin custom shader mode\nvoid BeginShaderMode(Shader shader)\n{\n    rlSetShader(shader.id, shader.locs);\n}\n\n// End custom shader mode (returns to default shader)\nvoid EndShaderMode(void)\n{\n    rlSetShader(rlGetShaderIdDefault(), rlGetShaderLocsDefault());\n}\n\n// Begin blending mode (alpha, additive, multiplied, subtract, custom)\n// NOTE: Blend modes supported are enumerated in BlendMode enum\nvoid BeginBlendMode(int mode)\n{\n    rlSetBlendMode(mode);\n}\n\n// End blending mode (reset to default: alpha blending)\nvoid EndBlendMode(void)\n{\n    rlSetBlendMode(BLEND_ALPHA);\n}\n\n// Begin scissor mode (define screen area for following drawing)\n// NOTE: Scissor rec refers to bottom-left corner, we change it to upper-left\nvoid BeginScissorMode(int x, int y, int width, int height)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlEnableScissorTest();\n\n#if defined(__APPLE__)\n    Vector2 scale = GetWindowScaleDPI();\n    rlScissor((int)(x*scale.x), (int)(GetScreenHeight()*scale.y - (((y + height)*scale.y))), (int)(width*scale.x), (int)(height*scale.y));\n#else\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        Vector2 scale = GetWindowScaleDPI();\n        rlScissor((int)(x*scale.x), (int)(CORE.Window.currentFbo.height - (y + height)*scale.y), (int)(width*scale.x), (int)(height*scale.y));\n    }\n    else\n    {\n        rlScissor(x, CORE.Window.currentFbo.height - (y + height), width, height);\n    }\n#endif\n}\n\n// End scissor mode\nvoid EndScissorMode(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n    rlDisableScissorTest();\n}\n\n// Begin VR drawing configuration\nvoid BeginVrStereoMode(VrStereoConfig config)\n{\n    rlEnableStereoRender();\n\n    // Set stereo render matrices\n    rlSetMatrixProjectionStereo(config.projection[0], config.projection[1]);\n    rlSetMatrixViewOffsetStereo(config.viewOffset[0], config.viewOffset[1]);\n}\n\n// End VR drawing process (and desktop mirror)\nvoid EndVrStereoMode(void)\n{\n    rlDisableStereoRender();\n}\n\n// Load VR stereo config for VR simulator device parameters\nVrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)\n{\n    VrStereoConfig config = { 0 };\n\n    if ((rlGetVersion() == RL_OPENGL_33) || (rlGetVersion() == RL_OPENGL_ES_20))\n    {\n        // Compute aspect ratio\n        float aspect = ((float)device.hResolution*0.5f)/(float)device.vResolution;\n\n        // Compute lens parameters\n        float lensShift = (device.hScreenSize*0.25f - device.lensSeparationDistance*0.5f)/device.hScreenSize;\n        config.leftLensCenter[0] = 0.25f + lensShift;\n        config.leftLensCenter[1] = 0.5f;\n        config.rightLensCenter[0] = 0.75f - lensShift;\n        config.rightLensCenter[1] = 0.5f;\n        config.leftScreenCenter[0] = 0.25f;\n        config.leftScreenCenter[1] = 0.5f;\n        config.rightScreenCenter[0] = 0.75f;\n        config.rightScreenCenter[1] = 0.5f;\n\n        // Compute distortion scale parameters\n        // NOTE: To get lens max radius, lensShift must be normalized to [-1..1]\n        float lensRadius = fabsf(-1.0f - 4.0f*lensShift);\n        float lensRadiusSq = lensRadius*lensRadius;\n        float distortionScale = device.lensDistortionValues[0] +\n                                device.lensDistortionValues[1]*lensRadiusSq +\n                                device.lensDistortionValues[2]*lensRadiusSq*lensRadiusSq +\n                                device.lensDistortionValues[3]*lensRadiusSq*lensRadiusSq*lensRadiusSq;\n\n        float normScreenWidth = 0.5f;\n        float normScreenHeight = 1.0f;\n        config.scaleIn[0] = 2.0f/normScreenWidth;\n        config.scaleIn[1] = 2.0f/normScreenHeight/aspect;\n        config.scale[0] = normScreenWidth*0.5f/distortionScale;\n        config.scale[1] = normScreenHeight*0.5f*aspect/distortionScale;\n\n        // Fovy is normally computed with: 2*atan2f(device.vScreenSize, 2*device.eyeToScreenDistance)\n        // ...but with lens distortion it is increased (see Oculus SDK Documentation)\n        float fovy = 2.0f*atan2f(device.vScreenSize*0.5f*distortionScale, device.eyeToScreenDistance);     // Really need distortionScale?\n       // float fovy = 2.0f*(float)atan2f(device.vScreenSize*0.5f, device.eyeToScreenDistance);\n\n        // Compute camera projection matrices\n        float projOffset = 4.0f*lensShift;      // Scaled to projection space coordinates [-1..1]\n        Matrix proj = MatrixPerspective(fovy, aspect, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n\n        config.projection[0] = MatrixMultiply(proj, MatrixTranslate(projOffset, 0.0f, 0.0f));\n        config.projection[1] = MatrixMultiply(proj, MatrixTranslate(-projOffset, 0.0f, 0.0f));\n\n        // Compute camera transformation matrices\n        // NOTE: Camera movement might seem more natural if we model the head.\n        // Our axis of rotation is the base of our head, so we might want to add\n        // some y (base of head to eye level) and -z (center of head to eye protrusion) to the camera positions.\n        config.viewOffset[0] = MatrixTranslate(-device.interpupillaryDistance*0.5f, 0.075f, 0.045f);\n        config.viewOffset[1] = MatrixTranslate(device.interpupillaryDistance*0.5f, 0.075f, 0.045f);\n\n        // Compute eyes Viewports\n        /*\n        config.eyeViewportRight[0] = 0;\n        config.eyeViewportRight[1] = 0;\n        config.eyeViewportRight[2] = device.hResolution/2;\n        config.eyeViewportRight[3] = device.vResolution;\n\n        config.eyeViewportLeft[0] = device.hResolution/2;\n        config.eyeViewportLeft[1] = 0;\n        config.eyeViewportLeft[2] = device.hResolution/2;\n        config.eyeViewportLeft[3] = device.vResolution;\n        */\n    }\n    else TRACELOG(LOG_WARNING, \"RLGL: VR Simulator not supported on OpenGL 1.1\");\n\n    return config;\n}\n\n// Unload VR stereo config properties\nvoid UnloadVrStereoConfig(VrStereoConfig config)\n{\n    //...\n}\n\n// Load shader from files and bind default locations\n// NOTE: If shader string is NULL, using default vertex/fragment shaders\nShader LoadShader(const char *vsFileName, const char *fsFileName)\n{\n    Shader shader = { 0 };\n\n    char *vShaderStr = NULL;\n    char *fShaderStr = NULL;\n\n    if (vsFileName != NULL) vShaderStr = LoadFileText(vsFileName);\n    if (fsFileName != NULL) fShaderStr = LoadFileText(fsFileName);\n\n    shader = LoadShaderFromMemory(vShaderStr, fShaderStr);\n\n    UnloadFileText(vShaderStr);\n    UnloadFileText(fShaderStr);\n\n    return shader;\n}\n\n// Load shader from code strings and bind default locations\nShader LoadShaderFromMemory(const char *vsCode, const char *fsCode)\n{\n    Shader shader = { 0 };\n\n    shader.id = rlLoadShaderCode(vsCode, fsCode);\n\n    // After shader loading, we TRY to set default location names\n    if (shader.id > 0)\n    {\n        // Default shader attribute locations have been binded before linking:\n        //          vertex position location    = 0\n        //          vertex texcoord location    = 1\n        //          vertex normal location      = 2\n        //          vertex color location       = 3\n        //          vertex tangent location     = 4\n        //          vertex texcoord2 location   = 5\n\n        // NOTE: If any location is not found, loc point becomes -1\n\n        shader.locs = (int *)RL_CALLOC(RL_MAX_SHADER_LOCATIONS, sizeof(int));\n\n        // All locations reset to -1 (no location)\n        for (int i = 0; i < RL_MAX_SHADER_LOCATIONS; i++) shader.locs[i] = -1;\n\n        // Get handles to GLSL input attribute locations\n        shader.locs[SHADER_LOC_VERTEX_POSITION] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION);\n        shader.locs[SHADER_LOC_VERTEX_TEXCOORD01] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD);\n        shader.locs[SHADER_LOC_VERTEX_TEXCOORD02] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2);\n        shader.locs[SHADER_LOC_VERTEX_NORMAL] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL);\n        shader.locs[SHADER_LOC_VERTEX_TANGENT] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT);\n        shader.locs[SHADER_LOC_VERTEX_COLOR] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR);\n\n        // Get handles to GLSL uniform locations (vertex shader)\n        shader.locs[SHADER_LOC_MATRIX_MVP] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MVP);\n        shader.locs[SHADER_LOC_MATRIX_VIEW] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW);\n        shader.locs[SHADER_LOC_MATRIX_PROJECTION] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION);\n        shader.locs[SHADER_LOC_MATRIX_MODEL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL);\n        shader.locs[SHADER_LOC_MATRIX_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL);\n\n        // Get handles to GLSL uniform locations (fragment shader)\n        shader.locs[SHADER_LOC_COLOR_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR);\n        shader.locs[SHADER_LOC_MAP_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0);  // SHADER_LOC_MAP_ALBEDO\n        shader.locs[SHADER_LOC_MAP_SPECULAR] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1); // SHADER_LOC_MAP_METALNESS\n        shader.locs[SHADER_LOC_MAP_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2);\n    }\n\n    return shader;\n}\n\n// Check if a shader is ready\nbool IsShaderReady(Shader shader)\n{\n    return ((shader.id > 0) &&          // Validate shader id (loaded successfully)\n            (shader.locs != NULL));     // Validate memory has been allocated for default shader locations\n\n    // The following locations are tried to be set automatically (locs[i] >= 0),\n    // any of them can be checked for validation but the only mandatory one is, afaik, SHADER_LOC_VERTEX_POSITION\n    // NOTE: Users can also setup manually their own attributes/uniforms and do not used the default raylib ones\n\n    // Vertex shader attribute locations (default)\n    // shader.locs[SHADER_LOC_VERTEX_POSITION]      // Set by default internal shader\n    // shader.locs[SHADER_LOC_VERTEX_TEXCOORD01]    // Set by default internal shader\n    // shader.locs[SHADER_LOC_VERTEX_TEXCOORD02]\n    // shader.locs[SHADER_LOC_VERTEX_NORMAL]\n    // shader.locs[SHADER_LOC_VERTEX_TANGENT]\n    // shader.locs[SHADER_LOC_VERTEX_COLOR]         // Set by default internal shader\n\n    // Vertex shader uniform locations (default)\n    // shader.locs[SHADER_LOC_MATRIX_MVP]           // Set by default internal shader\n    // shader.locs[SHADER_LOC_MATRIX_VIEW]\n    // shader.locs[SHADER_LOC_MATRIX_PROJECTION]\n    // shader.locs[SHADER_LOC_MATRIX_MODEL]\n    // shader.locs[SHADER_LOC_MATRIX_NORMAL]\n\n    // Fragment shader uniform locations (default)\n    // shader.locs[SHADER_LOC_COLOR_DIFFUSE]        // Set by default internal shader\n    // shader.locs[SHADER_LOC_MAP_DIFFUSE]          // Set by default internal shader\n    // shader.locs[SHADER_LOC_MAP_SPECULAR]\n    // shader.locs[SHADER_LOC_MAP_NORMAL]\n}\n\n// Unload shader from GPU memory (VRAM)\nvoid UnloadShader(Shader shader)\n{\n    if (shader.id != rlGetShaderIdDefault())\n    {\n        rlUnloadShaderProgram(shader.id);\n\n        // NOTE: If shader loading failed, it should be 0\n        RL_FREE(shader.locs);\n    }\n}\n\n// Get shader uniform location\nint GetShaderLocation(Shader shader, const char *uniformName)\n{\n    return rlGetLocationUniform(shader.id, uniformName);\n}\n\n// Get shader attribute location\nint GetShaderLocationAttrib(Shader shader, const char *attribName)\n{\n    return rlGetLocationAttrib(shader.id, attribName);\n}\n\n// Set shader uniform value\nvoid SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)\n{\n    SetShaderValueV(shader, locIndex, value, uniformType, 1);\n}\n\n// Set shader uniform value vector\nvoid SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)\n{\n    if (locIndex > -1)\n    {\n        rlEnableShader(shader.id);\n        rlSetUniform(locIndex, value, uniformType, count);\n        //rlDisableShader();      // Avoid resetting current shader program, in case other uniforms are set\n    }\n}\n\n// Set shader uniform value (matrix 4x4)\nvoid SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)\n{\n    if (locIndex > -1)\n    {\n        rlEnableShader(shader.id);\n        rlSetUniformMatrix(locIndex, mat);\n        //rlDisableShader();\n    }\n}\n\n// Set shader uniform value for texture\nvoid SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)\n{\n    if (locIndex > -1)\n    {\n        rlEnableShader(shader.id);\n        rlSetUniformSampler(locIndex, texture.id);\n        //rlDisableShader();\n    }\n}\n\n// Get a ray trace from mouse position\nRay GetMouseRay(Vector2 mouse, Camera camera)\n{\n    Ray ray = { 0 };\n\n    // Calculate normalized device coordinates\n    // NOTE: y value is negative\n    float x = (2.0f*mouse.x)/(float)GetScreenWidth() - 1.0f;\n    float y = 1.0f - (2.0f*mouse.y)/(float)GetScreenHeight();\n    float z = 1.0f;\n\n    // Store values in a vector\n    Vector3 deviceCoords = { x, y, z };\n\n    // Calculate view matrix from camera look at\n    Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);\n\n    Matrix matProj = MatrixIdentity();\n\n    if (camera.projection == CAMERA_PERSPECTIVE)\n    {\n        // Calculate projection matrix from perspective\n        matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)GetScreenWidth()/(double)GetScreenHeight()), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC)\n    {\n        float aspect = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;\n        double top = camera.fovy/2.0;\n        double right = top*aspect;\n\n        // Calculate projection matrix from orthographic\n        matProj = MatrixOrtho(-right, right, -top, top, 0.01, 1000.0);\n    }\n\n    // Unproject far/near points\n    Vector3 nearPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 0.0f }, matProj, matView);\n    Vector3 farPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 1.0f }, matProj, matView);\n\n    // Unproject the mouse cursor in the near plane.\n    // We need this as the source position because orthographic projects, compared to perspective doesn't have a\n    // convergence point, meaning that the \"eye\" of the camera is more like a plane than a point.\n    Vector3 cameraPlanePointerPos = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, -1.0f }, matProj, matView);\n\n    // Calculate normalized direction vector\n    Vector3 direction = Vector3Normalize(Vector3Subtract(farPoint, nearPoint));\n\n    if (camera.projection == CAMERA_PERSPECTIVE) ray.position = camera.position;\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC) ray.position = cameraPlanePointerPos;\n\n    // Apply calculated vectors to ray\n    ray.direction = direction;\n\n    return ray;\n}\n\n// Get transform matrix for camera\nMatrix GetCameraMatrix(Camera camera)\n{\n    return MatrixLookAt(camera.position, camera.target, camera.up);\n}\n\n// Get camera 2d transform matrix\nMatrix GetCameraMatrix2D(Camera2D camera)\n{\n    Matrix matTransform = { 0 };\n    // The camera in world-space is set by\n    //   1. Move it to target\n    //   2. Rotate by -rotation and scale by (1/zoom)\n    //      When setting higher scale, it's more intuitive for the world to become bigger (= camera become smaller),\n    //      not for the camera getting bigger, hence the invert. Same deal with rotation.\n    //   3. Move it by (-offset);\n    //      Offset defines target transform relative to screen, but since we're effectively \"moving\" screen (camera)\n    //      we need to do it into opposite direction (inverse transform)\n\n    // Having camera transform in world-space, inverse of it gives the modelview transform.\n    // Since (A*B*C)' = C'*B'*A', the modelview is\n    //   1. Move to offset\n    //   2. Rotate and Scale\n    //   3. Move by -target\n    Matrix matOrigin = MatrixTranslate(-camera.target.x, -camera.target.y, 0.0f);\n    Matrix matRotation = MatrixRotate((Vector3){ 0.0f, 0.0f, 1.0f }, camera.rotation*DEG2RAD);\n    Matrix matScale = MatrixScale(camera.zoom, camera.zoom, 1.0f);\n    Matrix matTranslation = MatrixTranslate(camera.offset.x, camera.offset.y, 0.0f);\n\n    matTransform = MatrixMultiply(MatrixMultiply(matOrigin, MatrixMultiply(matScale, matRotation)), matTranslation);\n\n    return matTransform;\n}\n\n// Get the screen space position from a 3d world space position\nVector2 GetWorldToScreen(Vector3 position, Camera camera)\n{\n    Vector2 screenPosition = GetWorldToScreenEx(position, camera, GetScreenWidth(), GetScreenHeight());\n\n    return screenPosition;\n}\n\n// Get size position for a 3d world space position (useful for texture drawing)\nVector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)\n{\n    // Calculate projection matrix (from perspective instead of frustum\n    Matrix matProj = MatrixIdentity();\n\n    if (camera.projection == CAMERA_PERSPECTIVE)\n    {\n        // Calculate projection matrix from perspective\n        matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)width/(double)height), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC)\n    {\n        float aspect = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;\n        double top = camera.fovy/2.0;\n        double right = top*aspect;\n\n        // Calculate projection matrix from orthographic\n        matProj = MatrixOrtho(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n\n    // Calculate view matrix from camera look at (and transpose it)\n    Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);\n\n    // TODO: Why not use Vector3Transform(Vector3 v, Matrix mat)?\n\n    // Convert world position vector to quaternion\n    Quaternion worldPos = { position.x, position.y, position.z, 1.0f };\n\n    // Transform world position to view\n    worldPos = QuaternionTransform(worldPos, matView);\n\n    // Transform result to projection (clip space position)\n    worldPos = QuaternionTransform(worldPos, matProj);\n\n    // Calculate normalized device coordinates (inverted y)\n    Vector3 ndcPos = { worldPos.x/worldPos.w, -worldPos.y/worldPos.w, worldPos.z/worldPos.w };\n\n    // Calculate 2d screen position vector\n    Vector2 screenPosition = { (ndcPos.x + 1.0f)/2.0f*(float)width, (ndcPos.y + 1.0f)/2.0f*(float)height };\n\n    return screenPosition;\n}\n\n// Get the screen space position for a 2d camera world space position\nVector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)\n{\n    Matrix matCamera = GetCameraMatrix2D(camera);\n    Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, matCamera);\n\n    return (Vector2){ transform.x, transform.y };\n}\n\n// Get the world space position for a 2d camera screen space position\nVector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)\n{\n    Matrix invMatCamera = MatrixInvert(GetCameraMatrix2D(camera));\n    Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, invMatCamera);\n\n    return (Vector2){ transform.x, transform.y };\n}\n\n// Set target FPS (maximum)\nvoid SetTargetFPS(int fps)\n{\n    if (fps < 1) CORE.Time.target = 0.0;\n    else CORE.Time.target = 1.0/(double)fps;\n\n    TRACELOG(LOG_INFO, \"TIMER: Target time per frame: %02.03f milliseconds\", (float)CORE.Time.target*1000.0f);\n}\n\n// Get current FPS\n// NOTE: We calculate an average framerate\nint GetFPS(void)\n{\n    int fps = 0;\n\n#if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)\n    #define FPS_CAPTURE_FRAMES_COUNT    30      // 30 captures\n    #define FPS_AVERAGE_TIME_SECONDS   0.5f     // 500 millisecondes\n    #define FPS_STEP (FPS_AVERAGE_TIME_SECONDS/FPS_CAPTURE_FRAMES_COUNT)\n\n    static int index = 0;\n    static float history[FPS_CAPTURE_FRAMES_COUNT] = { 0 };\n    static float average = 0, last = 0;\n    float fpsFrame = GetFrameTime();\n\n    if (fpsFrame == 0) return 0;\n\n    if ((GetTime() - last) > FPS_STEP)\n    {\n        last = (float)GetTime();\n        index = (index + 1)%FPS_CAPTURE_FRAMES_COUNT;\n        average -= history[index];\n        history[index] = fpsFrame/FPS_CAPTURE_FRAMES_COUNT;\n        average += history[index];\n    }\n\n    fps = (int)roundf(1.0f/average);\n#endif\n\n    return fps;\n}\n\n// Get time in seconds for last frame drawn (delta time)\nfloat GetFrameTime(void)\n{\n    return (float)CORE.Time.frame;\n}\n\n// Get elapsed time measure in seconds since InitTimer()\n// NOTE: On PLATFORM_DESKTOP InitTimer() is called on InitWindow()\n// NOTE: On PLATFORM_DESKTOP, timer is initialized on glfwInit()\ndouble GetTime(void)\n{\n    double time = 0.0;\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    time = glfwGetTime();   // Elapsed time since glfwInit()\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    struct timespec ts = { 0 };\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;\n\n    time = (double)(nanoSeconds - CORE.Time.base)*1e-9;  // Elapsed time since InitTimer()\n#endif\n    return time;\n}\n\n// Setup window configuration flags (view FLAGS)\n// NOTE: This function is expected to be called before window creation,\n// because it sets up some flags for the window creation process.\n// To configure window states after creation, just use SetWindowState()\nvoid SetConfigFlags(unsigned int flags)\n{\n    // Selected flags are set but not evaluated at this point,\n    // flag evaluation happens at InitWindow() or SetWindowState()\n    CORE.Window.flags |= flags;\n}\n\n// NOTE TRACELOG() function is located in [utils.h]\n\n// Takes a screenshot of current screen (saved a .png)\nvoid TakeScreenshot(const char *fileName)\n{\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    Vector2 scale = GetWindowScaleDPI();\n    unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n    Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n\n    char path[2048] = { 0 };\n    strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));\n\n    ExportImage(image, path);           // WARNING: Module required: rtextures\n    RL_FREE(imgData);\n\n#if defined(PLATFORM_WEB)\n    // Download file from MEMFS (emscripten memory filesystem)\n    // saveFileFromMEMFSToDisk() function is defined in raylib/src/shell.html\n    emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));\n#endif\n\n    TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);\n#else\n    TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");\n#endif\n}\n\n// Get a random value between min and max (both included)\n// WARNING: Ranges higher than RAND_MAX will return invalid results\n// More specifically, if (max - min) > INT_MAX there will be an overflow,\n// and otherwise if (max - min) > RAND_MAX the random value will incorrectly never exceed a certain threshold\nint GetRandomValue(int min, int max)\n{\n    if (min > max)\n    {\n        int tmp = max;\n        max = min;\n        min = tmp;\n    }\n\n    if ((unsigned int)(max - min) > (unsigned int)RAND_MAX)\n    {\n        TRACELOG(LOG_WARNING, \"Invalid GetRandomValue() arguments, range should not be higher than %i\", RAND_MAX);\n    }\n\n    return (rand()%(abs(max - min) + 1) + min);\n}\n\n// Set the seed for the random number generator\nvoid SetRandomSeed(unsigned int seed)\n{\n    srand(seed);\n}\n\n// Check if the file exists\nbool FileExists(const char *fileName)\n{\n    bool result = false;\n\n#if defined(_WIN32)\n    if (_access(fileName, 0) != -1) result = true;\n#else\n    if (access(fileName, F_OK) != -1) result = true;\n#endif\n\n    // NOTE: Alternatively, stat() can be used instead of access()\n    //#include <sys/stat.h>\n    //struct stat statbuf;\n    //if (stat(filename, &statbuf) == 0) result = true;\n\n    return result;\n}\n\n// Check file extension\n// NOTE: Extensions checking is not case-sensitive\nbool IsFileExtension(const char *fileName, const char *ext)\n{\n    #define MAX_FILE_EXTENSION_SIZE  16\n\n    bool result = false;\n    const char *fileExt = GetFileExtension(fileName);\n\n    if (fileExt != NULL)\n    {\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_TEXT_MANIPULATION)\n        int extCount = 0;\n        const char **checkExts = TextSplit(ext, ';', &extCount);  // WARNING: Module required: rtext\n\n        char fileExtLower[MAX_FILE_EXTENSION_SIZE + 1] = { 0 };\n        strncpy(fileExtLower, TextToLower(fileExt),MAX_FILE_EXTENSION_SIZE);  // WARNING: Module required: rtext\n\n        for (int i = 0; i < extCount; i++)\n        {\n            if (strcmp(fileExtLower, TextToLower(checkExts[i])) == 0)\n            {\n                result = true;\n                break;\n            }\n        }\n#else\n        if (strcmp(fileExt, ext) == 0) result = true;\n#endif\n    }\n\n    return result;\n}\n\n// Check if a directory path exists\nbool DirectoryExists(const char *dirPath)\n{\n    bool result = false;\n    DIR *dir = opendir(dirPath);\n\n    if (dir != NULL)\n    {\n        result = true;\n        closedir(dir);\n    }\n\n    return result;\n}\n\n// Get file length in bytes\n// NOTE: GetFileSize() conflicts with windows.h\nint GetFileLength(const char *fileName)\n{\n    int size = 0;\n\n    FILE *file = fopen(fileName, \"rb\");\n\n    if (file != NULL)\n    {\n        fseek(file, 0L, SEEK_END);\n        size = (int)ftell(file);\n        fclose(file);\n    }\n\n    return size;\n}\n\n// Get pointer to extension for a filename string (includes the dot: .png)\nconst char *GetFileExtension(const char *fileName)\n{\n    const char *dot = strrchr(fileName, '.');\n\n    if (!dot || dot == fileName) return NULL;\n\n    return dot;\n}\n\n// String pointer reverse break: returns right-most occurrence of charset in s\nstatic const char *strprbrk(const char *s, const char *charset)\n{\n    const char *latestMatch = NULL;\n    for (; s = strpbrk(s, charset), s != NULL; latestMatch = s++) { }\n    return latestMatch;\n}\n\n// Get pointer to filename for a path string\nconst char *GetFileName(const char *filePath)\n{\n    const char *fileName = NULL;\n    if (filePath != NULL) fileName = strprbrk(filePath, \"\\\\/\");\n\n    if (!fileName) return filePath;\n\n    return fileName + 1;\n}\n\n// Get filename string without extension (uses static string)\nconst char *GetFileNameWithoutExt(const char *filePath)\n{\n    #define MAX_FILENAMEWITHOUTEXT_LENGTH   256\n\n    static char fileName[MAX_FILENAMEWITHOUTEXT_LENGTH] = { 0 };\n    memset(fileName, 0, MAX_FILENAMEWITHOUTEXT_LENGTH);\n\n    if (filePath != NULL) strcpy(fileName, GetFileName(filePath));   // Get filename with extension\n\n    int size = (int)strlen(fileName);   // Get size in bytes\n\n    for (int i = 0; (i < size) && (i < MAX_FILENAMEWITHOUTEXT_LENGTH); i++)\n    {\n        if (fileName[i] == '.')\n        {\n            // NOTE: We break on first '.' found\n            fileName[i] = '\\0';\n            break;\n        }\n    }\n\n    return fileName;\n}\n\n// Get directory for a given filePath\nconst char *GetDirectoryPath(const char *filePath)\n{\n/*\n    // NOTE: Directory separator is different in Windows and other platforms,\n    // fortunately, Windows also support the '/' separator, that's the one should be used\n    #if defined(_WIN32)\n        char separator = '\\\\';\n    #else\n        char separator = '/';\n    #endif\n*/\n    const char *lastSlash = NULL;\n    static char dirPath[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(dirPath, 0, MAX_FILEPATH_LENGTH);\n\n    // In case provided path does not contain a root drive letter (C:\\, D:\\) nor leading path separator (\\, /),\n    // we add the current directory path to dirPath\n    if (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/')\n    {\n        // For security, we set starting path to current directory,\n        // obtained path will be concatenated to this\n        dirPath[0] = '.';\n        dirPath[1] = '/';\n    }\n\n    lastSlash = strprbrk(filePath, \"\\\\/\");\n    if (lastSlash)\n    {\n        if (lastSlash == filePath)\n        {\n            // The last and only slash is the leading one: path is in a root directory\n            dirPath[0] = filePath[0];\n            dirPath[1] = '\\0';\n        }\n        else\n        {\n            // NOTE: Be careful, strncpy() is not safe, it does not care about '\\0'\n            memcpy(dirPath + (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/' ? 2 : 0), filePath, strlen(filePath) - (strlen(lastSlash) - 1));\n            dirPath[strlen(filePath) - strlen(lastSlash) + (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/' ? 2 : 0)] = '\\0';  // Add '\\0' manually\n        }\n    }\n\n    return dirPath;\n}\n\n// Get previous directory path for a given path\nconst char *GetPrevDirectoryPath(const char *dirPath)\n{\n    static char prevDirPath[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(prevDirPath, 0, MAX_FILEPATH_LENGTH);\n    int pathLen = (int)strlen(dirPath);\n\n    if (pathLen <= 3) strcpy(prevDirPath, dirPath);\n\n    for (int i = (pathLen - 1); (i >= 0) && (pathLen > 3); i--)\n    {\n        if ((dirPath[i] == '\\\\') || (dirPath[i] == '/'))\n        {\n            // Check for root: \"C:\\\" or \"/\"\n            if (((i == 2) && (dirPath[1] ==':')) || (i == 0)) i++;\n\n            strncpy(prevDirPath, dirPath, i);\n            break;\n        }\n    }\n\n    return prevDirPath;\n}\n\n// Get current working directory\nconst char *GetWorkingDirectory(void)\n{\n    static char currentDir[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(currentDir, 0, MAX_FILEPATH_LENGTH);\n\n    char *path = GETCWD(currentDir, MAX_FILEPATH_LENGTH - 1);\n\n    return path;\n}\n\nconst char *GetApplicationDirectory(void)\n{\n    static char appDir[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(appDir, 0, MAX_FILEPATH_LENGTH);\n\n#if defined(_WIN32)\n    int len = 0;\n#if defined (UNICODE)\n    unsigned short widePath[MAX_PATH];\n    len = GetModuleFileNameW(NULL, widePath, MAX_PATH);\n    len = WideCharToMultiByte(0, 0, widePath, len, appDir, MAX_PATH, NULL, NULL);\n#else\n    len = GetModuleFileNameA(NULL, appDir, MAX_PATH);\n#endif\n    if (len > 0)\n    {\n        for (int i = len; i >= 0; --i)\n        {\n            if (appDir[i] == '\\\\')\n            {\n                appDir[i + 1] = '\\0';\n                break;\n            }\n        }\n    }\n    else\n    {\n        appDir[0] = '.';\n        appDir[1] = '\\\\';\n    }\n\n#elif defined(__linux__)\n    unsigned int size = sizeof(appDir);\n    ssize_t len = readlink(\"/proc/self/exe\", appDir, size);\n\n    if (len > 0)\n    {\n        for (int i = len; i >= 0; --i)\n        {\n            if (appDir[i] == '/')\n            {\n                appDir[i + 1] = '\\0';\n                break;\n            }\n        }\n    }\n    else\n    {\n        appDir[0] = '.';\n        appDir[1] = '/';\n    }\n#elif defined(__APPLE__)\n    uint32_t size = sizeof(appDir);\n\n    if (_NSGetExecutablePath(appDir, &size) == 0)\n    {\n        int len = strlen(appDir);\n        for (int i = len; i >= 0; --i)\n        {\n            if (appDir[i] == '/')\n            {\n                appDir[i + 1] = '\\0';\n                break;\n            }\n        }\n    }\n    else\n    {\n        appDir[0] = '.';\n        appDir[1] = '/';\n    }\n#endif\n\n    return appDir;\n}\n\n// Load directory filepaths\n// NOTE: Base path is prepended to the scanned filepaths\n// WARNING: Directory is scanned twice, first time to get files count\n// No recursive scanning is done!\nFilePathList LoadDirectoryFiles(const char *dirPath)\n{\n    FilePathList files = { 0 };\n    unsigned int fileCounter = 0;\n\n    struct dirent *entity;\n    DIR *dir = opendir(dirPath);\n\n    if (dir != NULL) // It's a directory\n    {\n        // SCAN 1: Count files\n        while ((entity = readdir(dir)) != NULL)\n        {\n            // NOTE: We skip '.' (current dir) and '..' (parent dir) filepaths\n            if ((strcmp(entity->d_name, \".\") != 0) && (strcmp(entity->d_name, \"..\") != 0)) fileCounter++;\n        }\n\n        // Memory allocation for dirFileCount\n        files.capacity = fileCounter;\n        files.paths = (char **)RL_MALLOC(files.capacity*sizeof(char *));\n        for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_MALLOC(MAX_FILEPATH_LENGTH*sizeof(char));\n\n        closedir(dir);\n\n        // SCAN 2: Read filepaths\n        // NOTE: Directory paths are also registered\n        ScanDirectoryFiles(dirPath, &files, NULL);\n\n        // Security check: read files.count should match fileCounter\n        if (files.count != files.capacity) TRACELOG(LOG_WARNING, \"FILEIO: Read files count do not match capacity allocated\");\n    }\n    else TRACELOG(LOG_WARNING, \"FILEIO: Failed to open requested directory\");  // Maybe it's a file...\n\n    return files;\n}\n\n// Load directory filepaths with extension filtering and recursive directory scan\n// NOTE: On recursive loading we do not pre-scan for file count, we use MAX_FILEPATH_CAPACITY\nFilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)\n{\n    FilePathList files = { 0 };\n\n    files.capacity = MAX_FILEPATH_CAPACITY;\n    files.paths = (char **)RL_CALLOC(files.capacity, sizeof(char *));\n    for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));\n\n    // WARNING: basePath is always prepended to scanned paths\n    if (scanSubdirs) ScanDirectoryFilesRecursively(basePath, &files, filter);\n    else ScanDirectoryFiles(basePath, &files, filter);\n\n    return files;\n}\n\n// Unload directory filepaths\n// WARNING: files.count is not reseted to 0 after unloading\nvoid UnloadDirectoryFiles(FilePathList files)\n{\n    for (unsigned int i = 0; i < files.capacity; i++) RL_FREE(files.paths[i]);\n\n    RL_FREE(files.paths);\n}\n\n// Change working directory, returns true on success\nbool ChangeDirectory(const char *dir)\n{\n    bool result = CHDIR(dir);\n\n    if (result != 0) TRACELOG(LOG_WARNING, \"SYSTEM: Failed to change to directory: %s\", dir);\n\n    return (result == 0);\n}\n\n// Check if a given path point to a file\nbool IsPathFile(const char *path)\n{\n    struct stat pathStat = { 0 };\n    stat(path, &pathStat);\n\n    return S_ISREG(pathStat.st_mode);\n}\n\n// Check if a file has been dropped into window\nbool IsFileDropped(void)\n{\n    if (CORE.Window.dropFileCount > 0) return true;\n    else return false;\n}\n\n// Load dropped filepaths\nFilePathList LoadDroppedFiles(void)\n{\n    FilePathList files = { 0 };\n\n    files.count = CORE.Window.dropFileCount;\n    files.paths = CORE.Window.dropFilepaths;\n\n    return files;\n}\n\n// Unload dropped filepaths\nvoid UnloadDroppedFiles(FilePathList files)\n{\n    // WARNING: files pointers are the same as internal ones\n\n    if (files.count > 0)\n    {\n        for (unsigned int i = 0; i < files.count; i++) RL_FREE(files.paths[i]);\n\n        RL_FREE(files.paths);\n\n        CORE.Window.dropFileCount = 0;\n        CORE.Window.dropFilepaths = NULL;\n    }\n}\n\n// Get file modification time (last write time)\nlong GetFileModTime(const char *fileName)\n{\n    struct stat result = { 0 };\n\n    if (stat(fileName, &result) == 0)\n    {\n        time_t mod = result.st_mtime;\n\n        return (long)mod;\n    }\n\n    return 0;\n}\n\n// Compress data (DEFLATE algorithm)\nunsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)\n{\n    #define COMPRESSION_QUALITY_DEFLATE  8\n\n    unsigned char *compData = NULL;\n\n#if defined(SUPPORT_COMPRESSION_API)\n    // Compress data and generate a valid DEFLATE stream\n    struct sdefl sdefl = { 0 };\n    int bounds = sdefl_bound(dataSize);\n    compData = (unsigned char *)RL_CALLOC(bounds, 1);\n    *compDataSize = sdeflate(&sdefl, compData, data, dataSize, COMPRESSION_QUALITY_DEFLATE);   // Compression level 8, same as stbwi\n\n    TRACELOG(LOG_INFO, \"SYSTEM: Compress data: Original size: %i -> Comp. size: %i\", dataSize, *compDataSize);\n#endif\n\n    return compData;\n}\n\n// Decompress data (DEFLATE algorithm)\nunsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)\n{\n    unsigned char *data = NULL;\n\n#if defined(SUPPORT_COMPRESSION_API)\n    // Decompress data from a valid DEFLATE stream\n    data = (unsigned char *)RL_CALLOC(MAX_DECOMPRESSION_SIZE*1024*1024, 1);\n    int length = sinflate(data, MAX_DECOMPRESSION_SIZE*1024*1024, compData, compDataSize);\n\n    // WARNING: RL_REALLOC can make (and leave) data copies in memory, be careful with sensitive compressed data!\n    // TODO: Use a different approach, create another buffer, copy data manually to it and wipe original buffer memory\n    unsigned char *temp = (unsigned char *)RL_REALLOC(data, length);\n\n    if (temp != NULL) data = temp;\n    else TRACELOG(LOG_WARNING, \"SYSTEM: Failed to re-allocate required decompression memory\");\n\n    *dataSize = length;\n\n    TRACELOG(LOG_INFO, \"SYSTEM: Decompress data: Comp. size: %i -> Original size: %i\", compDataSize, *dataSize);\n#endif\n\n    return data;\n}\n\n// Encode data to Base64 string\nchar *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)\n{\n    static const unsigned char base64encodeTable[] = {\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n        'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    static const int modTable[] = { 0, 2, 1 };\n\n    *outputSize = 4*((dataSize + 2)/3);\n\n    char *encodedData = (char *)RL_MALLOC(*outputSize);\n\n    if (encodedData == NULL) return NULL;\n\n    for (int i = 0, j = 0; i < dataSize;)\n    {\n        unsigned int octetA = (i < dataSize)? (unsigned char)data[i++] : 0;\n        unsigned int octetB = (i < dataSize)? (unsigned char)data[i++] : 0;\n        unsigned int octetC = (i < dataSize)? (unsigned char)data[i++] : 0;\n\n        unsigned int triple = (octetA << 0x10) + (octetB << 0x08) + octetC;\n\n        encodedData[j++] = base64encodeTable[(triple >> 3*6) & 0x3F];\n        encodedData[j++] = base64encodeTable[(triple >> 2*6) & 0x3F];\n        encodedData[j++] = base64encodeTable[(triple >> 1*6) & 0x3F];\n        encodedData[j++] = base64encodeTable[(triple >> 0*6) & 0x3F];\n    }\n\n    for (int i = 0; i < modTable[dataSize%3]; i++) encodedData[*outputSize - 1 - i] = '=';  // Padding character\n\n    return encodedData;\n}\n\n// Decode Base64 string data\nunsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)\n{\n    static const unsigned char base64decodeTable[] = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n        11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,\n        37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    // Get output size of Base64 input data\n    int outSize = 0;\n    for (int i = 0; data[4*i] != 0; i++)\n    {\n        if (data[4*i + 3] == '=')\n        {\n            if (data[4*i + 2] == '=') outSize += 1;\n            else outSize += 2;\n        }\n        else outSize += 3;\n    }\n\n    // Allocate memory to store decoded Base64 data\n    unsigned char *decodedData = (unsigned char *)RL_MALLOC(outSize);\n\n    for (int i = 0; i < outSize/3; i++)\n    {\n        unsigned char a = base64decodeTable[(int)data[4*i]];\n        unsigned char b = base64decodeTable[(int)data[4*i + 1]];\n        unsigned char c = base64decodeTable[(int)data[4*i + 2]];\n        unsigned char d = base64decodeTable[(int)data[4*i + 3]];\n\n        decodedData[3*i] = (a << 2) | (b >> 4);\n        decodedData[3*i + 1] = (b << 4) | (c >> 2);\n        decodedData[3*i + 2] = (c << 6) | d;\n    }\n\n    if (outSize%3 == 1)\n    {\n        int n = outSize/3;\n        unsigned char a = base64decodeTable[(int)data[4*n]];\n        unsigned char b = base64decodeTable[(int)data[4*n + 1]];\n        decodedData[outSize - 1] = (a << 2) | (b >> 4);\n    }\n    else if (outSize%3 == 2)\n    {\n        int n = outSize/3;\n        unsigned char a = base64decodeTable[(int)data[4*n]];\n        unsigned char b = base64decodeTable[(int)data[4*n + 1]];\n        unsigned char c = base64decodeTable[(int)data[4*n + 2]];\n        decodedData[outSize - 2] = (a << 2) | (b >> 4);\n        decodedData[outSize - 1] = (b << 4) | (c >> 2);\n    }\n\n    *outputSize = outSize;\n    return decodedData;\n}\n\n// Open URL with default system browser (if available)\n// NOTE: This function is only safe to use if you control the URL given.\n// A user could craft a malicious string performing another action.\n// Only call this function yourself not with user input or make sure to check the string yourself.\n// Ref: https://github.com/raysan5/raylib/issues/686\nvoid OpenURL(const char *url)\n{\n    // Small security check trying to avoid (partially) malicious code...\n    // sorry for the inconvenience when you hit this point...\n    if (strchr(url, '\\'') != NULL)\n    {\n        TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL is not valid\");\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); // Alternatives: firefox, x-www-browser\n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}\n\n//----------------------------------------------------------------------------------\n// Module Functions Definition - Input (Keyboard, Mouse, Gamepad) Functions\n//----------------------------------------------------------------------------------\n// Check if a key has been pressed once\nbool IsKeyPressed(int key)\n{\n    bool pressed = false;\n\n    if ((CORE.Input.Keyboard.previousKeyState[key] == 0) && (CORE.Input.Keyboard.currentKeyState[key] == 1)) pressed = true;\n\n    return pressed;\n}\n\n// Check if a key is being pressed (key held down)\nbool IsKeyDown(int key)\n{\n    if (CORE.Input.Keyboard.currentKeyState[key] == 1) return true;\n    else return false;\n}\n\n// Check if a key has been released once\nbool IsKeyReleased(int key)\n{\n    bool released = false;\n\n    if ((CORE.Input.Keyboard.previousKeyState[key] == 1) && (CORE.Input.Keyboard.currentKeyState[key] == 0)) released = true;\n\n    return released;\n}\n\n// Check if a key is NOT being pressed (key not held down)\nbool IsKeyUp(int key)\n{\n    if (CORE.Input.Keyboard.currentKeyState[key] == 0) return true;\n    else return false;\n}\n\n// Get the last key pressed\nint GetKeyPressed(void)\n{\n    int value = 0;\n\n    if (CORE.Input.Keyboard.keyPressedQueueCount > 0)\n    {\n        // Get character from the queue head\n        value = CORE.Input.Keyboard.keyPressedQueue[0];\n\n        // Shift elements 1 step toward the head.\n        for (int i = 0; i < (CORE.Input.Keyboard.keyPressedQueueCount - 1); i++)\n            CORE.Input.Keyboard.keyPressedQueue[i] = CORE.Input.Keyboard.keyPressedQueue[i + 1];\n\n        // Reset last character in the queue\n        CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount - 1] = 0;\n        CORE.Input.Keyboard.keyPressedQueueCount--;\n    }\n\n    return value;\n}\n\n// Get the last char pressed\nint GetCharPressed(void)\n{\n    int value = 0;\n\n    if (CORE.Input.Keyboard.charPressedQueueCount > 0)\n    {\n        // Get character from the queue head\n        value = CORE.Input.Keyboard.charPressedQueue[0];\n\n        // Shift elements 1 step toward the head.\n        for (int i = 0; i < (CORE.Input.Keyboard.charPressedQueueCount - 1); i++)\n            CORE.Input.Keyboard.charPressedQueue[i] = CORE.Input.Keyboard.charPressedQueue[i + 1];\n\n        // Reset last character in the queue\n        CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount - 1] = 0;\n        CORE.Input.Keyboard.charPressedQueueCount--;\n    }\n\n    return value;\n}\n\n// Set a custom key to exit program\n// NOTE: default exitKey is ESCAPE\nvoid SetExitKey(int key)\n{\n#if !defined(PLATFORM_ANDROID)\n    CORE.Input.Keyboard.exitKey = key;\n#endif\n}\n\n// NOTE: Gamepad support not implemented in emscripten GLFW3 (PLATFORM_WEB)\n\n// Check if a gamepad is available\nbool IsGamepadAvailable(int gamepad)\n{\n    bool result = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad]) result = true;\n\n    return result;\n}\n\n// Get gamepad internal name id\nconst char *GetGamepadName(int gamepad)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (CORE.Input.Gamepad.ready[gamepad]) return glfwGetJoystickName(gamepad);\n    else return NULL;\n#endif\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    if (CORE.Input.Gamepad.ready[gamepad]) ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGNAME(64), &CORE.Input.Gamepad.name[gamepad]);\n    return CORE.Input.Gamepad.name[gamepad];\n#endif\n#if defined(PLATFORM_WEB)\n    return CORE.Input.Gamepad.name[gamepad];\n#endif\n    return NULL;\n}\n\n// Get gamepad axis count\nint GetGamepadAxisCount(int gamepad)\n{\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    int axisCount = 0;\n    if (CORE.Input.Gamepad.ready[gamepad]) ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGAXES, &axisCount);\n    CORE.Input.Gamepad.axisCount = axisCount;\n#endif\n\n    return CORE.Input.Gamepad.axisCount;\n}\n\n// Get axis movement vector for a gamepad\nfloat GetGamepadAxisMovement(int gamepad, int axis)\n{\n    float value = 0;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (axis < MAX_GAMEPAD_AXIS) &&\n        (fabsf(CORE.Input.Gamepad.axisState[gamepad][axis]) > 0.1f)) value = CORE.Input.Gamepad.axisState[gamepad][axis];      // 0.1f = GAMEPAD_AXIS_MINIMUM_DRIFT/DELTA\n\n    return value;\n}\n\n// Check if a gamepad button has been pressed once\nbool IsGamepadButtonPressed(int gamepad, int button)\n{\n    bool pressed = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 0) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) pressed = true;\n\n    return pressed;\n}\n\n// Check if a gamepad button is being pressed\nbool IsGamepadButtonDown(int gamepad, int button)\n{\n    bool result = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) result = true;\n\n    return result;\n}\n\n// Check if a gamepad button has NOT been pressed once\nbool IsGamepadButtonReleased(int gamepad, int button)\n{\n    bool released = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 1) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) released = true;\n\n    return released;\n}\n\n// Check if a gamepad button is NOT being pressed\nbool IsGamepadButtonUp(int gamepad, int button)\n{\n    bool result = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) result = true;\n\n    return result;\n}\n\n// Get the last gamepad button pressed\nint GetGamepadButtonPressed(void)\n{\n    return CORE.Input.Gamepad.lastButtonPressed;\n}\n\n// Set internal gamepad mappings\nint SetGamepadMappings(const char *mappings)\n{\n    int result = 0;\n\n#if defined(PLATFORM_DESKTOP)\n    result = glfwUpdateGamepadMappings(mappings);\n#endif\n\n    return result;\n}\n\n// Check if a mouse button has been pressed once\nbool IsMouseButtonPressed(int button)\n{\n    bool pressed = false;\n\n    if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) pressed = true;\n\n    // Map touches to mouse buttons checking\n    if ((CORE.Input.Touch.currentTouchState[button] == 1) && (CORE.Input.Touch.previousTouchState[button] == 0)) pressed = true;\n\n    return pressed;\n}\n\n// Check if a mouse button is being pressed\nbool IsMouseButtonDown(int button)\n{\n    bool down = false;\n\n    if (CORE.Input.Mouse.currentButtonState[button] == 1) down = true;\n\n    // Map touches to mouse buttons checking\n    if (CORE.Input.Touch.currentTouchState[button] == 1) down = true;\n\n    return down;\n}\n\n// Check if a mouse button has been released once\nbool IsMouseButtonReleased(int button)\n{\n    bool released = false;\n\n    if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) released = true;\n\n    // Map touches to mouse buttons checking\n    if ((CORE.Input.Touch.currentTouchState[button] == 0) && (CORE.Input.Touch.previousTouchState[button] == 1)) released = true;\n\n    return released;\n}\n\n// Check if a mouse button is NOT being pressed\nbool IsMouseButtonUp(int button)\n{\n    return !IsMouseButtonDown(button);\n}\n\n// Get mouse position X\nint GetMouseX(void)\n{\n#if defined(PLATFORM_ANDROID)\n    return (int)CORE.Input.Touch.position[0].x;\n#else\n    return (int)((CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x);\n#endif\n}\n\n// Get mouse position Y\nint GetMouseY(void)\n{\n#if defined(PLATFORM_ANDROID)\n    return (int)CORE.Input.Touch.position[0].y;\n#else\n    return (int)((CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y);\n#endif\n}\n\n// Get mouse position XY\nVector2 GetMousePosition(void)\n{\n    Vector2 position = { 0 };\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)\n    position = GetTouchPosition(0);\n#else\n    position.x = (CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x;\n    position.y = (CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y;\n#endif\n\n    return position;\n}\n\n// Get mouse delta between frames\nVector2 GetMouseDelta(void)\n{\n    Vector2 delta = { 0 };\n\n    delta.x = CORE.Input.Mouse.currentPosition.x - CORE.Input.Mouse.previousPosition.x;\n    delta.y = CORE.Input.Mouse.currentPosition.y - CORE.Input.Mouse.previousPosition.y;\n\n    return delta;\n}\n\n// Set mouse position XY\nvoid SetMousePosition(int x, int y)\n{\n    CORE.Input.Mouse.currentPosition = (Vector2){ (float)x, (float)y };\n    CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    // NOTE: emscripten not implemented\n    glfwSetCursorPos(CORE.Window.handle, CORE.Input.Mouse.currentPosition.x, CORE.Input.Mouse.currentPosition.y);\n#endif\n}\n\n// Set mouse offset\n// NOTE: Useful when rendering to different size targets\nvoid SetMouseOffset(int offsetX, int offsetY)\n{\n    CORE.Input.Mouse.offset = (Vector2){ (float)offsetX, (float)offsetY };\n}\n\n// Set mouse scaling\n// NOTE: Useful when rendering to different size targets\nvoid SetMouseScale(float scaleX, float scaleY)\n{\n    CORE.Input.Mouse.scale = (Vector2){ scaleX, scaleY };\n}\n\n// Get mouse wheel movement Y\nfloat GetMouseWheelMove(void)\n{\n    float result = 0.0f;\n\n#if !defined(PLATFORM_ANDROID)\n    if (fabsf(CORE.Input.Mouse.currentWheelMove.x) > fabsf(CORE.Input.Mouse.currentWheelMove.y)) result = (float)CORE.Input.Mouse.currentWheelMove.x;\n    else result = (float)CORE.Input.Mouse.currentWheelMove.y;\n#endif\n\n    return result;\n}\n\n// Get mouse wheel movement X/Y as a vector\nVector2 GetMouseWheelMoveV(void)\n{\n    Vector2 result = { 0 };\n\n    result = CORE.Input.Mouse.currentWheelMove;\n\n    return result;\n}\n\n// Set mouse cursor\n// NOTE: This is a no-op on platforms other than PLATFORM_DESKTOP\nvoid SetMouseCursor(int cursor)\n{\n#if defined(PLATFORM_DESKTOP)\n    CORE.Input.Mouse.cursor = cursor;\n    if (cursor == MOUSE_CURSOR_DEFAULT) glfwSetCursor(CORE.Window.handle, NULL);\n    else\n    {\n        // NOTE: We are relating internal GLFW enum values to our MouseCursor enum values\n        glfwSetCursor(CORE.Window.handle, glfwCreateStandardCursor(0x00036000 + cursor));\n    }\n#endif\n}\n\n// Get touch position X for touch point 0 (relative to screen size)\nint GetTouchX(void)\n{\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)\n    return (int)CORE.Input.Touch.position[0].x;\n#else   // PLATFORM_DESKTOP, PLATFORM_RPI, PLATFORM_DRM\n    return GetMouseX();\n#endif\n}\n\n// Get touch position Y for touch point 0 (relative to screen size)\nint GetTouchY(void)\n{\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)\n    return (int)CORE.Input.Touch.position[0].y;\n#else   // PLATFORM_DESKTOP, PLATFORM_RPI, PLATFORM_DRM\n    return GetMouseY();\n#endif\n}\n\n// Get touch position XY for a touch point index (relative to screen size)\n// TODO: Touch position should be scaled depending on display size and render size\nVector2 GetTouchPosition(int index)\n{\n    Vector2 position = { -1.0f, -1.0f };\n\n#if defined(PLATFORM_DESKTOP)\n    // TODO: GLFW does not support multi-touch input just yet\n    // https://www.codeproject.com/Articles/668404/Programming-for-Multi-Touch\n    // https://docs.microsoft.com/en-us/windows/win32/wintouch/getting-started-with-multi-touch-messages\n    if (index == 0) position = GetMousePosition();\n#endif\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    if (index < MAX_TOUCH_POINTS) position = CORE.Input.Touch.position[index];\n    else TRACELOG(LOG_WARNING, \"INPUT: Required touch point out of range (Max touch points: %i)\", MAX_TOUCH_POINTS);\n#endif\n\n    return position;\n}\n\n// Get touch point identifier for given index\nint GetTouchPointId(int index)\n{\n    int id = -1;\n\n    if (index < MAX_TOUCH_POINTS) id = CORE.Input.Touch.pointId[index];\n\n    return id;\n}\n\n// Get number of touch points\nint GetTouchPointCount(void)\n{\n    return CORE.Input.Touch.pointCount;\n}\n\n//----------------------------------------------------------------------------------\n// Module specific Functions Definition\n//----------------------------------------------------------------------------------\n\n// Initialize display device and framebuffer\n// NOTE: width and height represent the screen (framebuffer) desired size, not actual display size\n// If width or height are 0, default display size will be used for framebuffer size\n// NOTE: returns false in case graphic device could not be created\nstatic bool InitGraphicsDevice(int width, int height)\n{\n    CORE.Window.screen.width = width;            // User desired width\n    CORE.Window.screen.height = height;          // User desired height\n    CORE.Window.screenScale = MatrixIdentity();  // No draw scaling required by default\n\n    // NOTE: Framebuffer (render area - CORE.Window.render.width, CORE.Window.render.height) could include black bars...\n    // ...in top-down or left-right to match display aspect ratio (no weird scaling)\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwSetErrorCallback(ErrorCallback);\n/*\n    // TODO: Setup GLFW custom allocators to match raylib ones\n    const GLFWallocator allocator = {\n        .allocate = MemAlloc,\n        .deallocate = MemFree,\n        .reallocate = MemRealloc,\n        .user = NULL\n    };\n\n    glfwInitAllocator(&allocator);\n*/\n#if defined(__APPLE__)\n    glfwInitHint(GLFW_COCOA_CHDIR_RESOURCES, GLFW_FALSE);\n#endif\n\n    if (!glfwInit())\n    {\n        TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize GLFW\");\n        return false;\n    }\n\n    glfwDefaultWindowHints();                       // Set default windows hints\n    //glfwWindowHint(GLFW_RED_BITS, 8);             // Framebuffer red color component bits\n    //glfwWindowHint(GLFW_GREEN_BITS, 8);           // Framebuffer green color component bits\n    //glfwWindowHint(GLFW_BLUE_BITS, 8);            // Framebuffer blue color component bits\n    //glfwWindowHint(GLFW_ALPHA_BITS, 8);           // Framebuffer alpha color component bits\n    //glfwWindowHint(GLFW_DEPTH_BITS, 24);          // Depthbuffer bits\n    //glfwWindowHint(GLFW_REFRESH_RATE, 0);         // Refresh rate for fullscreen window\n    //glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API); // OpenGL API to use. Alternative: GLFW_OPENGL_ES_API\n    //glfwWindowHint(GLFW_AUX_BUFFERS, 0);          // Number of auxiliar buffers\n\n    // Check window creation flags\n    if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) CORE.Window.fullscreen = true;\n\n    if ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // Visible window\n    else glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);     // Window initially hidden\n\n    if ((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) glfwWindowHint(GLFW_DECORATED, GLFW_FALSE); // Border and buttons on Window\n    else glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);   // Decorated window\n\n    if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // Resizable window\n    else glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);  // Avoid window being resizable\n\n    // Disable FLAG_WINDOW_MINIMIZED, not supported on initialization\n    if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;\n\n    // Disable FLAG_WINDOW_MAXIMIZED, not supported on initialization\n    if ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;\n\n    if ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) glfwWindowHint(GLFW_FOCUSED, GLFW_FALSE);\n    else glfwWindowHint(GLFW_FOCUSED, GLFW_TRUE);\n\n    if ((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);\n    else glfwWindowHint(GLFW_FLOATING, GLFW_FALSE);\n\n    // NOTE: Some GLFW flags are not supported on HTML5\n#if defined(PLATFORM_DESKTOP)\n    if ((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);     // Transparent framebuffer\n    else glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_FALSE);  // Opaque framebuffer\n\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        // Resize window content area based on the monitor content scale.\n        // NOTE: This hint only has an effect on platforms where screen coordinates and pixels always map 1:1 such as Windows and X11.\n        // On platforms like macOS the resolution of the framebuffer is changed independently of the window size.\n        glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);   // Scale content area based on the monitor content scale where window is placed on\n    #if defined(__APPLE__)\n        glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n    #endif\n    }\n    else glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_FALSE);\n\n    // Mouse passthrough\n    if ((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);\n    else glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);\n#endif\n\n    if (CORE.Window.flags & FLAG_MSAA_4X_HINT)\n    {\n        // NOTE: MSAA is only enabled for main framebuffer, not user-created FBOs\n        TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");\n        glfwWindowHint(GLFW_SAMPLES, 4);   // Tries to enable multisampling x4 (MSAA), default is 0\n    }\n\n    // NOTE: When asking for an OpenGL context version, most drivers provide the highest supported version\n    // with backward compatibility to older OpenGL versions.\n    // For example, if using OpenGL 1.1, driver can provide a 4.3 backwards compatible context.\n\n    // Check selection OpenGL version\n    if (rlGetVersion() == RL_OPENGL_21)\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);          // Choose OpenGL major version (just hint)\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);          // Choose OpenGL minor version (just hint)\n    }\n    else if (rlGetVersion() == RL_OPENGL_33)\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);          // Choose OpenGL major version (just hint)\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Profiles Hint: Only 3.3 and above!\n                                                                       // Values: GLFW_OPENGL_CORE_PROFILE, GLFW_OPENGL_ANY_PROFILE, GLFW_OPENGL_COMPAT_PROFILE\n#if defined(__APPLE__)\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);  // OSX Requires fordward compatibility\n#else\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE); // Fordward Compatibility Hint: Only 3.3 and above!\n#endif\n        //glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE); // Request OpenGL DEBUG context\n    }\n    else if (rlGetVersion() == RL_OPENGL_43)\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);          // Choose OpenGL major version (just hint)\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE);\n#if defined(RLGL_ENABLE_OPENGL_DEBUG_CONTEXT)\n        glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);   // Enable OpenGL Debug Context\n#endif\n    }\n    else if (rlGetVersion() == RL_OPENGL_ES_20)                 // Request OpenGL ES 2.0 context\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);\n#if defined(PLATFORM_DESKTOP)\n        glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_EGL_CONTEXT_API);\n#else\n        glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_NATIVE_CONTEXT_API);\n#endif\n    }\n\n#if defined(PLATFORM_DESKTOP)\n    // NOTE: GLFW 3.4+ defers initialization of the Joystick subsystem on the first call to any Joystick related functions.\n    // Forcing this initialization here avoids doing it on PollInputEvents() called by EndDrawing() after first frame has been just drawn.\n    // The initialization will still happen and possible delays still occur, but before the window is shown, which is a nicer experience.\n    // REF: https://github.com/raysan5/raylib/issues/1554\n    if (MAX_GAMEPADS > 0) glfwSetJoystickCallback(NULL);\n#endif\n\n#if defined(PLATFORM_DESKTOP)\n    // Find monitor resolution\n    GLFWmonitor *monitor = glfwGetPrimaryMonitor();\n    if (!monitor)\n    {\n        TRACELOG(LOG_WARNING, \"GLFW: Failed to get primary monitor\");\n        return false;\n    }\n\n    const GLFWvidmode *mode = glfwGetVideoMode(monitor);\n\n    CORE.Window.display.width = mode->width;\n    CORE.Window.display.height = mode->height;\n\n    // Set screen width/height to the display width/height if they are 0\n    if (CORE.Window.screen.width == 0) CORE.Window.screen.width = CORE.Window.display.width;\n    if (CORE.Window.screen.height == 0) CORE.Window.screen.height = CORE.Window.display.height;\n#endif  // PLATFORM_DESKTOP\n\n#if defined(PLATFORM_WEB)\n    // NOTE: Getting video modes is not implemented in emscripten GLFW3 version\n    CORE.Window.display.width = CORE.Window.screen.width;\n    CORE.Window.display.height = CORE.Window.screen.height;\n#endif  // PLATFORM_WEB\n\n    if (CORE.Window.fullscreen)\n    {\n        // remember center for switchinging from fullscreen to window\n        if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))\n        {\n            // If screen width/height equal to the display, we can't calculate the window pos for toggling full-screened/windowed.\n            // Toggling full-screened/windowed with pos(0, 0) can cause problems in some platforms, such as X11.\n            CORE.Window.position.x = CORE.Window.display.width/4;\n            CORE.Window.position.y = CORE.Window.display.height/4;\n        }\n        else\n        {\n            CORE.Window.position.x = CORE.Window.display.width/2 - CORE.Window.screen.width/2;\n            CORE.Window.position.y = CORE.Window.display.height/2 - CORE.Window.screen.height/2;\n        }\n\n        if (CORE.Window.position.x < 0) CORE.Window.position.x = 0;\n        if (CORE.Window.position.y < 0) CORE.Window.position.y = 0;\n\n        // Obtain recommended CORE.Window.display.width/CORE.Window.display.height from a valid videomode for the monitor\n        int count = 0;\n        const GLFWvidmode *modes = glfwGetVideoModes(glfwGetPrimaryMonitor(), &count);\n\n        // Get closest video mode to desired CORE.Window.screen.width/CORE.Window.screen.height\n        for (int i = 0; i < count; i++)\n        {\n            if ((unsigned int)modes[i].width >= CORE.Window.screen.width)\n            {\n                if ((unsigned int)modes[i].height >= CORE.Window.screen.height)\n                {\n                    CORE.Window.display.width = modes[i].width;\n                    CORE.Window.display.height = modes[i].height;\n                    break;\n                }\n            }\n        }\n        TRACELOG(LOG_WARNING, \"SYSTEM: Closest fullscreen videomode: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);\n\n        // NOTE: ISSUE: Closest videomode could not match monitor aspect-ratio, for example,\n        // for a desired screen size of 800x450 (16:9), closest supported videomode is 800x600 (4:3),\n        // framebuffer is rendered correctly but once displayed on a 16:9 monitor, it gets stretched\n        // by the sides to fit all monitor space...\n\n        // Try to setup the most appropriate fullscreen framebuffer for the requested screenWidth/screenHeight\n        // It considers device display resolution mode and setups a framebuffer with black bars if required (render size/offset)\n        // Modified global variables: CORE.Window.screen.width/CORE.Window.screen.height - CORE.Window.render.width/CORE.Window.render.height - CORE.Window.renderOffset.x/CORE.Window.renderOffset.y - CORE.Window.screenScale\n        // TODO: It is a quite cumbersome solution to display size vs requested size, it should be reviewed or removed...\n        // HighDPI monitors are properly considered in a following similar function: SetupViewport()\n        SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n\n        CORE.Window.handle = glfwCreateWindow(CORE.Window.display.width, CORE.Window.display.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", glfwGetPrimaryMonitor(), NULL);\n\n        // NOTE: Full-screen change, not working properly...\n        //glfwSetWindowMonitor(CORE.Window.handle, glfwGetPrimaryMonitor(), 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        // If we are windowed fullscreen, ensures that window does not minimize when focus is lost\n        if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))\n        {\n            glfwWindowHint(GLFW_AUTO_ICONIFY, 0);\n        }\n#endif\n        // No-fullscreen window creation\n        CORE.Window.handle = glfwCreateWindow(CORE.Window.screen.width, CORE.Window.screen.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", NULL, NULL);\n\n        if (CORE.Window.handle)\n        {\n            CORE.Window.render.width = CORE.Window.screen.width;\n            CORE.Window.render.height = CORE.Window.screen.height;\n        }\n    }\n\n    if (!CORE.Window.handle)\n    {\n        glfwTerminate();\n        TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize Window\");\n        return false;\n    }\n\n    // Set window callback events\n    glfwSetWindowSizeCallback(CORE.Window.handle, WindowSizeCallback);      // NOTE: Resizing not allowed by default!\n#if !defined(PLATFORM_WEB)\n    glfwSetWindowMaximizeCallback(CORE.Window.handle, WindowMaximizeCallback);\n#endif\n    glfwSetWindowIconifyCallback(CORE.Window.handle, WindowIconifyCallback);\n    glfwSetWindowFocusCallback(CORE.Window.handle, WindowFocusCallback);\n    glfwSetDropCallback(CORE.Window.handle, WindowDropCallback);\n\n    // Set input callback events\n    glfwSetKeyCallback(CORE.Window.handle, KeyCallback);\n    glfwSetCharCallback(CORE.Window.handle, CharCallback);\n    glfwSetMouseButtonCallback(CORE.Window.handle, MouseButtonCallback);\n    glfwSetCursorPosCallback(CORE.Window.handle, MouseCursorPosCallback);   // Track mouse position changes\n    glfwSetScrollCallback(CORE.Window.handle, MouseScrollCallback);\n    glfwSetCursorEnterCallback(CORE.Window.handle, CursorEnterCallback);\n\n    glfwMakeContextCurrent(CORE.Window.handle);\n\n#if !defined(PLATFORM_WEB)\n    glfwSetInputMode(CORE.Window.handle, GLFW_LOCK_KEY_MODS, GLFW_TRUE);    // Enable lock keys modifiers (CAPS, NUM)\n\n    glfwSwapInterval(0);        // No V-Sync by default\n#endif\n\n    // Try to enable GPU V-Sync, so frames are limited to screen refresh rate (60Hz -> 60 FPS)\n    // NOTE: V-Sync can be enabled by graphic driver configuration\n    if (CORE.Window.flags & FLAG_VSYNC_HINT)\n    {\n        // WARNING: It seems to hit a critical render path in Intel HD Graphics\n        glfwSwapInterval(1);\n        TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable VSYNC\");\n    }\n\n    int fbWidth = CORE.Window.screen.width;\n    int fbHeight = CORE.Window.screen.height;\n\n#if defined(PLATFORM_DESKTOP)\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        // NOTE: On APPLE platforms system should manage window/input scaling and also framebuffer scaling.\n        // Framebuffer scaling should be activated with: glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n    #if !defined(__APPLE__)\n        glfwGetFramebufferSize(CORE.Window.handle, &fbWidth, &fbHeight);\n\n        // Screen scaling matrix is required in case desired screen area is different from display area\n        CORE.Window.screenScale = MatrixScale((float)fbWidth/CORE.Window.screen.width, (float)fbHeight/CORE.Window.screen.height, 1.0f);\n\n        // Mouse input scaling for the new screen size\n        SetMouseScale((float)CORE.Window.screen.width/fbWidth, (float)CORE.Window.screen.height/fbHeight);\n    #endif\n    }\n#endif\n\n    CORE.Window.render.width = fbWidth;\n    CORE.Window.render.height = fbHeight;\n    CORE.Window.currentFbo.width = fbWidth;\n    CORE.Window.currentFbo.height = fbHeight;\n\n    TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");\n    TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);\n    TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);\n    TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);\n    TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);\n\n#endif  // PLATFORM_DESKTOP || PLATFORM_WEB\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    CORE.Window.fullscreen = true;\n    CORE.Window.flags |= FLAG_FULLSCREEN_MODE;\n\n#if defined(PLATFORM_RPI)\n    bcm_host_init();\n\n    DISPMANX_ELEMENT_HANDLE_T dispmanElement = { 0 };\n    DISPMANX_DISPLAY_HANDLE_T dispmanDisplay = { 0 };\n    DISPMANX_UPDATE_HANDLE_T dispmanUpdate = { 0 };\n\n    VC_RECT_T dstRect = { 0 };\n    VC_RECT_T srcRect = { 0 };\n#endif\n\n#if defined(PLATFORM_DRM)\n    CORE.Window.fd = -1;\n    CORE.Window.connector = NULL;\n    CORE.Window.modeIndex = -1;\n    CORE.Window.crtc = NULL;\n    CORE.Window.gbmDevice = NULL;\n    CORE.Window.gbmSurface = NULL;\n    CORE.Window.prevBO = NULL;\n    CORE.Window.prevFB = 0;\n\n#if defined(DEFAULT_GRAPHIC_DEVICE_DRM)\n    CORE.Window.fd = open(DEFAULT_GRAPHIC_DEVICE_DRM, O_RDWR);\n#else\n    TRACELOG(LOG_INFO, \"DISPLAY: No graphic card set, trying platform-gpu-card\");\n    CORE.Window.fd = open(\"/dev/dri/by-path/platform-gpu-card\",  O_RDWR); // VideoCore VI (Raspberry Pi 4)\n\n    if ((-1 == CORE.Window.fd) || (drmModeGetResources(CORE.Window.fd) == NULL))\n    {\n        TRACELOG(LOG_INFO, \"DISPLAY: Failed to open platform-gpu-card, trying card1\");\n        CORE.Window.fd = open(\"/dev/dri/card1\", O_RDWR); // Other Embedded\n    }\n\n    if ((-1 == CORE.Window.fd) || (drmModeGetResources(CORE.Window.fd) == NULL))\n    {\n        TRACELOG(LOG_INFO, \"DISPLAY: Failed to open graphic card1, trying card0\");\n        CORE.Window.fd = open(\"/dev/dri/card0\", O_RDWR); // VideoCore IV (Raspberry Pi 1-3)\n    }\n#endif\n    if (-1 == CORE.Window.fd)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to open graphic card\");\n        return false;\n    }\n\n    drmModeRes *res = drmModeGetResources(CORE.Window.fd);\n    if (!res)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed get DRM resources\");\n        return false;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: Connectors found: %i\", res->count_connectors);\n    for (size_t i = 0; i < res->count_connectors; i++)\n    {\n        TRACELOG(LOG_TRACE, \"DISPLAY: Connector index %i\", i);\n        drmModeConnector *con = drmModeGetConnector(CORE.Window.fd, res->connectors[i]);\n        TRACELOG(LOG_TRACE, \"DISPLAY: Connector modes detected: %i\", con->count_modes);\n        if ((con->connection == DRM_MODE_CONNECTED) && (con->encoder_id))\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode connected\");\n            CORE.Window.connector = con;\n            break;\n        }\n        else\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode NOT connected (deleting)\");\n            drmModeFreeConnector(con);\n        }\n    }\n\n    if (!CORE.Window.connector)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: No suitable DRM connector found\");\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    drmModeEncoder *enc = drmModeGetEncoder(CORE.Window.fd, CORE.Window.connector->encoder_id);\n    if (!enc)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode encoder\");\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    CORE.Window.crtc = drmModeGetCrtc(CORE.Window.fd, enc->crtc_id);\n    if (!CORE.Window.crtc)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode crtc\");\n        drmModeFreeEncoder(enc);\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    // If InitWindow should use the current mode find it in the connector's mode list\n    if ((CORE.Window.screen.width <= 0) || (CORE.Window.screen.height <= 0))\n    {\n        TRACELOG(LOG_TRACE, \"DISPLAY: Selecting DRM connector mode for current used mode...\");\n\n        CORE.Window.modeIndex = FindMatchingConnectorMode(CORE.Window.connector, &CORE.Window.crtc->mode);\n\n        if (CORE.Window.modeIndex < 0)\n        {\n            TRACELOG(LOG_WARNING, \"DISPLAY: No matching DRM connector mode found\");\n            drmModeFreeEncoder(enc);\n            drmModeFreeResources(res);\n            return false;\n        }\n\n        CORE.Window.screen.width = CORE.Window.display.width;\n        CORE.Window.screen.height = CORE.Window.display.height;\n    }\n\n    const bool allowInterlaced = CORE.Window.flags & FLAG_INTERLACED_HINT;\n    const int fps = (CORE.Time.target > 0) ? (1.0/CORE.Time.target) : 60;\n\n    // Try to find an exact matching mode\n    CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);\n\n    // If nothing found, try to find a nearly matching mode\n    if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);\n\n    // If nothing found, try to find an exactly matching mode including interlaced\n    if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);\n\n    // If nothing found, try to find a nearly matching mode including interlaced\n    if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);\n\n    // If nothing found, there is no suitable mode\n    if (CORE.Window.modeIndex < 0)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable DRM connector mode\");\n        drmModeFreeEncoder(enc);\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    CORE.Window.display.width = CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay;\n    CORE.Window.display.height = CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay;\n\n    TRACELOG(LOG_INFO, \"DISPLAY: Selected DRM connector mode %s (%ux%u%c@%u)\", CORE.Window.connector->modes[CORE.Window.modeIndex].name,\n        CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay,\n        (CORE.Window.connector->modes[CORE.Window.modeIndex].flags & DRM_MODE_FLAG_INTERLACE) ? 'i' : 'p',\n        CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh);\n\n    // Use the width and height of the surface for render\n    CORE.Window.render.width = CORE.Window.screen.width;\n    CORE.Window.render.height = CORE.Window.screen.height;\n\n    drmModeFreeEncoder(enc);\n    enc = NULL;\n\n    drmModeFreeResources(res);\n    res = NULL;\n\n    CORE.Window.gbmDevice = gbm_create_device(CORE.Window.fd);\n    if (!CORE.Window.gbmDevice)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM device\");\n        return false;\n    }\n\n    CORE.Window.gbmSurface = gbm_surface_create(CORE.Window.gbmDevice, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay,\n        CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, GBM_FORMAT_ARGB8888, GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);\n    if (!CORE.Window.gbmSurface)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM surface\");\n        return false;\n    }\n#endif\n\n    EGLint samples = 0;\n    EGLint sampleBuffer = 0;\n    if (CORE.Window.flags & FLAG_MSAA_4X_HINT)\n    {\n        samples = 4;\n        sampleBuffer = 1;\n        TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");\n    }\n\n    const EGLint framebufferAttribs[] =\n    {\n        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,     // Type of context support -> Required on RPI?\n#if defined(PLATFORM_DRM)\n        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,          // Don't use it on Android!\n#endif\n        EGL_RED_SIZE, 8,            // RED color bit depth (alternative: 5)\n        EGL_GREEN_SIZE, 8,          // GREEN color bit depth (alternative: 6)\n        EGL_BLUE_SIZE, 8,           // BLUE color bit depth (alternative: 5)\n#if defined(PLATFORM_DRM)\n        EGL_ALPHA_SIZE, 8,        // ALPHA bit depth (required for transparent framebuffer)\n#endif\n        //EGL_TRANSPARENT_TYPE, EGL_NONE, // Request transparent framebuffer (EGL_TRANSPARENT_RGB does not work on RPI)\n        EGL_DEPTH_SIZE, 16,         // Depth buffer size (Required to use Depth testing!)\n        //EGL_STENCIL_SIZE, 8,      // Stencil buffer size\n        EGL_SAMPLE_BUFFERS, sampleBuffer,    // Activate MSAA\n        EGL_SAMPLES, samples,       // 4x Antialiasing if activated (Free on MALI GPUs)\n        EGL_NONE\n    };\n\n    const EGLint contextAttribs[] =\n    {\n        EGL_CONTEXT_CLIENT_VERSION, 2,\n        EGL_NONE\n    };\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    EGLint numConfigs = 0;\n\n    // Get an EGL device connection\n#if defined(PLATFORM_DRM)\n    CORE.Window.device = eglGetDisplay((EGLNativeDisplayType)CORE.Window.gbmDevice);\n#else\n    CORE.Window.device = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n#endif\n    if (CORE.Window.device == EGL_NO_DISPLAY)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");\n        return false;\n    }\n\n    // Initialize the EGL device connection\n    if (eglInitialize(CORE.Window.device, NULL, NULL) == EGL_FALSE)\n    {\n        // If all of the calls to eglInitialize returned EGL_FALSE then an error has occurred.\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");\n        return false;\n    }\n\n#if defined(PLATFORM_DRM)\n    if (!eglChooseConfig(CORE.Window.device, NULL, NULL, 0, &numConfigs))\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config count: 0x%x\", eglGetError());\n        return false;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: EGL configs available: %d\", numConfigs);\n\n    EGLConfig *configs = RL_CALLOC(numConfigs, sizeof(*configs));\n    if (!configs)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get memory for EGL configs\");\n        return false;\n    }\n\n    EGLint matchingNumConfigs = 0;\n    if (!eglChooseConfig(CORE.Window.device, framebufferAttribs, configs, numConfigs, &matchingNumConfigs))\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to choose EGL config: 0x%x\", eglGetError());\n        free(configs);\n        return false;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: EGL matching configs available: %d\", matchingNumConfigs);\n\n    // find the EGL config that matches the previously setup GBM format\n    int found = 0;\n    for (EGLint i = 0; i < matchingNumConfigs; ++i)\n    {\n        EGLint id = 0;\n        if (!eglGetConfigAttrib(CORE.Window.device, configs[i], EGL_NATIVE_VISUAL_ID, &id))\n        {\n            TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config attribute: 0x%x\", eglGetError());\n            continue;\n        }\n\n        if (GBM_FORMAT_ARGB8888 == id)\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: Using EGL config: %d\", i);\n            CORE.Window.config = configs[i];\n            found = 1;\n            break;\n        }\n    }\n\n    RL_FREE(configs);\n\n    if (!found)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable EGL config\");\n        return false;\n    }\n#else\n    // Get an appropriate EGL framebuffer configuration\n    eglChooseConfig(CORE.Window.device, framebufferAttribs, &CORE.Window.config, 1, &numConfigs);\n#endif\n\n    // Set rendering API\n    eglBindAPI(EGL_OPENGL_ES_API);\n\n    // Create an EGL rendering context\n    CORE.Window.context = eglCreateContext(CORE.Window.device, CORE.Window.config, EGL_NO_CONTEXT, contextAttribs);\n    if (CORE.Window.context == EGL_NO_CONTEXT)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL context\");\n        return false;\n    }\n#endif\n\n    // Create an EGL window surface\n    //---------------------------------------------------------------------------------\n#if defined(PLATFORM_ANDROID)\n    EGLint displayFormat = 0;\n\n    // EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is guaranteed to be accepted by ANativeWindow_setBuffersGeometry()\n    // As soon as we picked a EGLConfig, we can safely reconfigure the ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID\n    eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);\n\n    // At this point we need to manage render size vs screen size\n    // NOTE: This function use and modify global module variables:\n    //  -> CORE.Window.screen.width/CORE.Window.screen.height\n    //  -> CORE.Window.render.width/CORE.Window.render.height\n    //  -> CORE.Window.screenScale\n    SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n\n    ANativeWindow_setBuffersGeometry(CORE.Android.app->window, CORE.Window.render.width, CORE.Window.render.height, displayFormat);\n    //ANativeWindow_setBuffersGeometry(CORE.Android.app->window, 0, 0, displayFormat);       // Force use of native display size\n\n    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, CORE.Android.app->window, NULL);\n#endif  // PLATFORM_ANDROID\n\n#if defined(PLATFORM_RPI)\n    graphics_get_display_size(0, &CORE.Window.display.width, &CORE.Window.display.height);\n\n    // Screen size security check\n    if (CORE.Window.screen.width <= 0) CORE.Window.screen.width = CORE.Window.display.width;\n    if (CORE.Window.screen.height <= 0) CORE.Window.screen.height = CORE.Window.display.height;\n\n    // At this point we need to manage render size vs screen size\n    // NOTE: This function use and modify global module variables:\n    //  -> CORE.Window.screen.width/CORE.Window.screen.height\n    //  -> CORE.Window.render.width/CORE.Window.render.height\n    //  -> CORE.Window.screenScale\n    SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n\n    dstRect.x = 0;\n    dstRect.y = 0;\n    dstRect.width = CORE.Window.display.width;\n    dstRect.height = CORE.Window.display.height;\n\n    srcRect.x = 0;\n    srcRect.y = 0;\n    srcRect.width = CORE.Window.render.width << 16;\n    srcRect.height = CORE.Window.render.height << 16;\n\n    // NOTE: RPI dispmanx windowing system takes care of source rectangle scaling to destination rectangle by hardware (no cost)\n    // Take care that renderWidth/renderHeight fit on displayWidth/displayHeight aspect ratio\n\n    VC_DISPMANX_ALPHA_T alpha = { 0 };\n    alpha.flags = DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS;\n    //alpha.flags = DISPMANX_FLAGS_ALPHA_FROM_SOURCE;       // TODO: Allow transparent framebuffer! -> FLAG_WINDOW_TRANSPARENT\n    alpha.opacity = 255;    // Set transparency level for framebuffer, requires EGLAttrib: EGL_TRANSPARENT_TYPE\n    alpha.mask = 0;\n\n    dispmanDisplay = vc_dispmanx_display_open(0);   // LCD\n    dispmanUpdate = vc_dispmanx_update_start(0);\n\n    dispmanElement = vc_dispmanx_element_add(dispmanUpdate, dispmanDisplay, 0/*layer*/, &dstRect, 0/*src*/,\n                                            &srcRect, DISPMANX_PROTECTION_NONE, &alpha, 0/*clamp*/, DISPMANX_NO_ROTATE);\n\n    CORE.Window.handle.element = dispmanElement;\n    CORE.Window.handle.width = CORE.Window.render.width;\n    CORE.Window.handle.height = CORE.Window.render.height;\n    vc_dispmanx_update_submit_sync(dispmanUpdate);\n\n    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, &CORE.Window.handle, NULL);\n\n    const unsigned char *const renderer = glGetString(GL_RENDERER);\n    if (renderer) TRACELOG(LOG_INFO, \"DISPLAY: Renderer name is: %s\", renderer);\n    else TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get renderer name\");\n    //---------------------------------------------------------------------------------\n#endif  // PLATFORM_RPI\n\n#if defined(PLATFORM_DRM)\n    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, (EGLNativeWindowType)CORE.Window.gbmSurface, NULL);\n    if (EGL_NO_SURFACE == CORE.Window.surface)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL window surface: 0x%04x\", eglGetError());\n        return false;\n    }\n\n    // At this point we need to manage render size vs screen size\n    // NOTE: This function use and modify global module variables:\n    //  -> CORE.Window.screen.width/CORE.Window.screen.height\n    //  -> CORE.Window.render.width/CORE.Window.render.height\n    //  -> CORE.Window.screenScale\n    SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n#endif  // PLATFORM_DRM\n\n    // There must be at least one frame displayed before the buffers are swapped\n    //eglSwapInterval(CORE.Window.device, 1);\n\n    if (eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context) == EGL_FALSE)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to attach EGL rendering context to EGL surface\");\n        return false;\n    }\n    else\n    {\n        CORE.Window.render.width = CORE.Window.screen.width;\n        CORE.Window.render.height = CORE.Window.screen.height;\n        CORE.Window.currentFbo.width = CORE.Window.render.width;\n        CORE.Window.currentFbo.height = CORE.Window.render.height;\n\n        TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");\n        TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);\n        TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);\n        TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);\n        TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);\n    }\n#endif  // PLATFORM_ANDROID || PLATFORM_RPI || PLATFORM_DRM\n\n    // Load OpenGL extensions\n    // NOTE: GL procedures address loader is required to load extensions\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    rlLoadExtensions(glfwGetProcAddress);\n#else\n    rlLoadExtensions(eglGetProcAddress);\n#endif\n\n    // Initialize OpenGL context (states and resources)\n    // NOTE: CORE.Window.currentFbo.width and CORE.Window.currentFbo.height not used, just stored as globals in rlgl\n    rlglInit(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);\n\n    // Setup default viewport\n    // NOTE: It updated CORE.Window.render.width and CORE.Window.render.height\n    SetupViewport(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);\n\n#if defined(PLATFORM_ANDROID)\n    CORE.Window.ready = true;\n#endif\n\n    if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) MinimizeWindow();\n\n    return true;\n}\n\n// Set viewport for a provided width and height\nstatic void SetupViewport(int width, int height)\n{\n    CORE.Window.render.width = width;\n    CORE.Window.render.height = height;\n\n    // Set viewport width and height\n    // NOTE: We consider render size (scaled) and offset in case black bars are required and\n    // render area does not match full display area (this situation is only applicable on fullscreen mode)\n#if defined(__APPLE__)\n    float xScale = 1.0f, yScale = 1.0f;\n    glfwGetWindowContentScale(CORE.Window.handle, &xScale, &yScale);\n    rlViewport(CORE.Window.renderOffset.x/2*xScale, CORE.Window.renderOffset.y/2*yScale, (CORE.Window.render.width)*xScale, (CORE.Window.render.height)*yScale);\n#else\n    rlViewport(CORE.Window.renderOffset.x/2, CORE.Window.renderOffset.y/2, CORE.Window.render.width, CORE.Window.render.height);\n#endif\n\n    rlMatrixMode(RL_PROJECTION);        // Switch to projection matrix\n    rlLoadIdentity();                   // Reset current matrix (projection)\n\n    // Set orthographic projection to current framebuffer size\n    // NOTE: Configured top-left corner as (0, 0)\n    rlOrtho(0, CORE.Window.render.width, CORE.Window.render.height, 0, 0.0f, 1.0f);\n\n    rlMatrixMode(RL_MODELVIEW);         // Switch back to modelview matrix\n    rlLoadIdentity();                   // Reset current matrix (modelview)\n}\n\n// Compute framebuffer size relative to screen size and display size\n// NOTE: Global variables CORE.Window.render.width/CORE.Window.render.height and CORE.Window.renderOffset.x/CORE.Window.renderOffset.y can be modified\nstatic void SetupFramebuffer(int width, int height)\n{\n    // Calculate CORE.Window.render.width and CORE.Window.render.height, we have the display size (input params) and the desired screen size (global var)\n    if ((CORE.Window.screen.width > CORE.Window.display.width) || (CORE.Window.screen.height > CORE.Window.display.height))\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Downscaling required: Screen size (%ix%i) is bigger than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);\n\n        // Downscaling to fit display with border-bars\n        float widthRatio = (float)CORE.Window.display.width/(float)CORE.Window.screen.width;\n        float heightRatio = (float)CORE.Window.display.height/(float)CORE.Window.screen.height;\n\n        if (widthRatio <= heightRatio)\n        {\n            CORE.Window.render.width = CORE.Window.display.width;\n            CORE.Window.render.height = (int)round((float)CORE.Window.screen.height*widthRatio);\n            CORE.Window.renderOffset.x = 0;\n            CORE.Window.renderOffset.y = (CORE.Window.display.height - CORE.Window.render.height);\n        }\n        else\n        {\n            CORE.Window.render.width = (int)round((float)CORE.Window.screen.width*heightRatio);\n            CORE.Window.render.height = CORE.Window.display.height;\n            CORE.Window.renderOffset.x = (CORE.Window.display.width - CORE.Window.render.width);\n            CORE.Window.renderOffset.y = 0;\n        }\n\n        // Screen scaling required\n        float scaleRatio = (float)CORE.Window.render.width/(float)CORE.Window.screen.width;\n        CORE.Window.screenScale = MatrixScale(scaleRatio, scaleRatio, 1.0f);\n\n        // NOTE: We render to full display resolution!\n        // We just need to calculate above parameters for downscale matrix and offsets\n        CORE.Window.render.width = CORE.Window.display.width;\n        CORE.Window.render.height = CORE.Window.display.height;\n\n        TRACELOG(LOG_WARNING, \"DISPLAY: Downscale matrix generated, content will be rendered at (%ix%i)\", CORE.Window.render.width, CORE.Window.render.height);\n    }\n    else if ((CORE.Window.screen.width < CORE.Window.display.width) || (CORE.Window.screen.height < CORE.Window.display.height))\n    {\n        // Required screen size is smaller than display size\n        TRACELOG(LOG_INFO, \"DISPLAY: Upscaling required: Screen size (%ix%i) smaller than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);\n\n        if ((CORE.Window.screen.width == 0) || (CORE.Window.screen.height == 0))\n        {\n            CORE.Window.screen.width = CORE.Window.display.width;\n            CORE.Window.screen.height = CORE.Window.display.height;\n        }\n\n        // Upscaling to fit display with border-bars\n        float displayRatio = (float)CORE.Window.display.width/(float)CORE.Window.display.height;\n        float screenRatio = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;\n\n        if (displayRatio <= screenRatio)\n        {\n            CORE.Window.render.width = CORE.Window.screen.width;\n            CORE.Window.render.height = (int)round((float)CORE.Window.screen.width/displayRatio);\n            CORE.Window.renderOffset.x = 0;\n            CORE.Window.renderOffset.y = (CORE.Window.render.height - CORE.Window.screen.height);\n        }\n        else\n        {\n            CORE.Window.render.width = (int)round((float)CORE.Window.screen.height*displayRatio);\n            CORE.Window.render.height = CORE.Window.screen.height;\n            CORE.Window.renderOffset.x = (CORE.Window.render.width - CORE.Window.screen.width);\n            CORE.Window.renderOffset.y = 0;\n        }\n    }\n    else\n    {\n        CORE.Window.render.width = CORE.Window.screen.width;\n        CORE.Window.render.height = CORE.Window.screen.height;\n        CORE.Window.renderOffset.x = 0;\n        CORE.Window.renderOffset.y = 0;\n    }\n}\n\n// Initialize hi-resolution timer\nstatic void InitTimer(void)\n{\n// Setting a higher resolution can improve the accuracy of time-out intervals in wait functions.\n// However, it can also reduce overall system performance, because the thread scheduler switches tasks more often.\n// High resolutions can also prevent the CPU power management system from entering power-saving modes.\n// Setting a higher resolution does not improve the accuracy of the high-resolution performance counter.\n#if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)\n    timeBeginPeriod(1);                 // Setup high-resolution timer to 1ms (granularity of 1-2 ms)\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    struct timespec now = { 0 };\n\n    if (clock_gettime(CLOCK_MONOTONIC, &now) == 0)  // Success\n    {\n        CORE.Time.base = (unsigned long long int)now.tv_sec*1000000000LLU + (unsigned long long int)now.tv_nsec;\n    }\n    else TRACELOG(LOG_WARNING, \"TIMER: Hi-resolution timer not available\");\n#endif\n\n    CORE.Time.previous = GetTime();     // Get time as double\n}\n\n// Wait for some time (stop program execution)\n// NOTE: Sleep() granularity could be around 10 ms, it means, Sleep() could\n// take longer than expected... for that reason we use the busy wait loop\n// Ref: http://stackoverflow.com/questions/43057578/c-programming-win32-games-sleep-taking-longer-than-expected\n// Ref: http://www.geisswerks.com/ryan/FAQS/timing.html --> All about timing on Win32!\nvoid WaitTime(double seconds)\n{\n#if defined(SUPPORT_BUSY_WAIT_LOOP) || defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)\n    double destinationTime = GetTime() + seconds;\n#endif\n\n#if defined(SUPPORT_BUSY_WAIT_LOOP)\n    while (GetTime() < destinationTime) { }\n#else\n    #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)\n        double sleepSeconds = seconds - seconds*0.05;  // NOTE: We reserve a percentage of the time for busy waiting\n    #else\n        double sleepSeconds = seconds;\n    #endif\n\n    // System halt functions\n    #if defined(_WIN32)\n        Sleep((unsigned long)(sleepSeconds*1000.0));\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__EMSCRIPTEN__)\n        struct timespec req = { 0 };\n        time_t sec = sleepSeconds;\n        long nsec = (sleepSeconds - sec)*1000000000L;\n        req.tv_sec = sec;\n        req.tv_nsec = nsec;\n\n        // NOTE: Use nanosleep() on Unix platforms... usleep() it's deprecated.\n        while (nanosleep(&req, &req) == -1) continue;\n    #endif\n    #if defined(__APPLE__)\n        usleep(sleepSeconds*1000000.0);\n    #endif\n\n    #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)\n        while (GetTime() < destinationTime) { }\n    #endif\n#endif\n}\n\n// Swap back buffer with front buffer (screen drawing)\nvoid SwapScreenBuffer(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwSwapBuffers(CORE.Window.handle);\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    eglSwapBuffers(CORE.Window.device, CORE.Window.surface);\n\n#if defined(PLATFORM_DRM)\n\n    if (!CORE.Window.gbmSurface || (-1 == CORE.Window.fd) || !CORE.Window.connector || !CORE.Window.crtc) TRACELOG(LOG_ERROR, \"DISPLAY: DRM initialization failed to swap\");\n\n    struct gbm_bo *bo = gbm_surface_lock_front_buffer(CORE.Window.gbmSurface);\n    if (!bo) TRACELOG(LOG_ERROR, \"DISPLAY: Failed GBM to lock front buffer\");\n\n    uint32_t fb = 0;\n    int result = drmModeAddFB(CORE.Window.fd, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, 24, 32, gbm_bo_get_stride(bo), gbm_bo_get_handle(bo).u32, &fb);\n    if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeAddFB() failed with result: %d\", result);\n\n    result = drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, fb, 0, 0, &CORE.Window.connector->connector_id, 1, &CORE.Window.connector->modes[CORE.Window.modeIndex]);\n    if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeSetCrtc() failed with result: %d\", result);\n\n    if (CORE.Window.prevFB)\n    {\n        result = drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);\n        if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeRmFB() failed with result: %d\", result);\n    }\n\n    CORE.Window.prevFB = fb;\n\n    if (CORE.Window.prevBO) gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);\n\n    CORE.Window.prevBO = bo;\n\n#endif  // PLATFORM_DRM\n#endif  // PLATFORM_ANDROID || PLATFORM_RPI || PLATFORM_DRM\n}\n\n// Register all input events\nvoid PollInputEvents(void)\n{\n#if defined(SUPPORT_GESTURES_SYSTEM)\n    // NOTE: Gestures update must be called every frame to reset gestures correctly\n    // because ProcessGestureEvent() is just called on an event, not every frame\n    UpdateGestures();\n#endif\n\n    // Reset keys/chars pressed registered\n    CORE.Input.Keyboard.keyPressedQueueCount = 0;\n    CORE.Input.Keyboard.charPressedQueueCount = 0;\n\n#if !(defined(PLATFORM_RPI) || defined(PLATFORM_DRM))\n    // Reset last gamepad button/axis registered state\n    CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN\n    CORE.Input.Gamepad.axisCount = 0;\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Register previous keys states\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];\n\n    PollKeyboardEvents();\n\n    // Register previous mouse states\n    CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;\n    CORE.Input.Mouse.currentWheelMove = (Vector2){ 0.0f, 0.0f };\n    for (int i = 0; i < MAX_MOUSE_BUTTONS; i++)\n    {\n        CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];\n        CORE.Input.Mouse.currentButtonState[i] = CORE.Input.Mouse.currentButtonStateEvdev[i];\n    }\n\n    // Register gamepads buttons events\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        if (CORE.Input.Gamepad.ready[i])\n        {\n            // Register previous gamepad states\n            for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];\n        }\n    }\n#endif\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    // Keyboard/Mouse input polling (automatically managed by GLFW3 through callback)\n\n    // Register previous keys states\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];\n\n    // Register previous mouse states\n    for (int i = 0; i < MAX_MOUSE_BUTTONS; i++) CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];\n\n    // Register previous mouse wheel state\n    CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;\n    CORE.Input.Mouse.currentWheelMove = (Vector2){ 0.0f, 0.0f };\n\n    // Register previous mouse position\n    CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;\n#endif\n\n    // Register previous touch states\n    for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.previousTouchState[i] = CORE.Input.Touch.currentTouchState[i];\n\n    // Reset touch positions\n    // TODO: It resets on PLATFORM_WEB the mouse position and not filled again until a move-event,\n    // so, if mouse is not moved it returns a (0, 0) position... this behaviour should be reviewed!\n    //for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.position[i] = (Vector2){ 0, 0 };\n\n#if defined(PLATFORM_DESKTOP)\n    // Check if gamepads are ready\n    // NOTE: We do it here in case of disconnection\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        if (glfwJoystickPresent(i)) CORE.Input.Gamepad.ready[i] = true;\n        else CORE.Input.Gamepad.ready[i] = false;\n    }\n\n    // Register gamepads buttons events\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        if (CORE.Input.Gamepad.ready[i])     // Check if gamepad is available\n        {\n            // Register previous gamepad states\n            for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];\n\n            // Get current gamepad state\n            // NOTE: There is no callback available, so we get it manually\n            // Get remapped buttons\n            GLFWgamepadstate state = { 0 };\n            glfwGetGamepadState(i, &state); // This remapps all gamepads so they have their buttons mapped like an xbox controller\n\n            const unsigned char *buttons = state.buttons;\n\n            for (int k = 0; (buttons != NULL) && (k < GLFW_GAMEPAD_BUTTON_DPAD_LEFT + 1) && (k < MAX_GAMEPAD_BUTTONS); k++)\n            {\n                GamepadButton button = -1;\n\n                switch (k)\n                {\n                    case GLFW_GAMEPAD_BUTTON_Y: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;\n                    case GLFW_GAMEPAD_BUTTON_B: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;\n                    case GLFW_GAMEPAD_BUTTON_A: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;\n                    case GLFW_GAMEPAD_BUTTON_X: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;\n\n                    case GLFW_GAMEPAD_BUTTON_LEFT_BUMPER: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;\n                    case GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;\n\n                    case GLFW_GAMEPAD_BUTTON_BACK: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;\n                    case GLFW_GAMEPAD_BUTTON_GUIDE: button = GAMEPAD_BUTTON_MIDDLE; break;\n                    case GLFW_GAMEPAD_BUTTON_START: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;\n\n                    case GLFW_GAMEPAD_BUTTON_DPAD_UP: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;\n                    case GLFW_GAMEPAD_BUTTON_DPAD_RIGHT: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;\n                    case GLFW_GAMEPAD_BUTTON_DPAD_DOWN: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;\n                    case GLFW_GAMEPAD_BUTTON_DPAD_LEFT: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;\n\n                    case GLFW_GAMEPAD_BUTTON_LEFT_THUMB: button = GAMEPAD_BUTTON_LEFT_THUMB; break;\n                    case GLFW_GAMEPAD_BUTTON_RIGHT_THUMB: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;\n                    default: break;\n                }\n\n                if (button != -1)   // Check for valid button\n                {\n                    if (buttons[k] == GLFW_PRESS)\n                    {\n                        CORE.Input.Gamepad.currentButtonState[i][button] = 1;\n                        CORE.Input.Gamepad.lastButtonPressed = button;\n                    }\n                    else CORE.Input.Gamepad.currentButtonState[i][button] = 0;\n                }\n            }\n\n            // Get current axis state\n            const float *axes = state.axes;\n\n            for (int k = 0; (axes != NULL) && (k < GLFW_GAMEPAD_AXIS_LAST + 1) && (k < MAX_GAMEPAD_AXIS); k++)\n            {\n                CORE.Input.Gamepad.axisState[i][k] = axes[k];\n            }\n\n            // Register buttons for 2nd triggers (because GLFW doesn't count these as buttons but rather axis)\n            CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_LEFT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_LEFT_TRIGGER] > 0.1f);\n            CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_RIGHT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_RIGHT_TRIGGER] > 0.1f);\n\n            CORE.Input.Gamepad.axisCount = GLFW_GAMEPAD_AXIS_LAST + 1;\n        }\n    }\n\n    CORE.Window.resizedLastFrame = false;\n\n    if (CORE.Window.eventWaiting) glfwWaitEvents();     // Wait for in input events before continue (drawing is paused)\n    else glfwPollEvents();      // Poll input events: keyboard/mouse/window events (callbacks)\n#endif  // PLATFORM_DESKTOP\n\n#if defined(PLATFORM_WEB)\n    CORE.Window.resizedLastFrame = false;\n#endif  // PLATFORM_WEB\n\n// Gamepad support using emscripten API\n// NOTE: GLFW3 joystick functionality not available in web\n#if defined(PLATFORM_WEB)\n    // Get number of gamepads connected\n    int numGamepads = 0;\n    if (emscripten_sample_gamepad_data() == EMSCRIPTEN_RESULT_SUCCESS) numGamepads = emscripten_get_num_gamepads();\n\n    for (int i = 0; (i < numGamepads) && (i < MAX_GAMEPADS); i++)\n    {\n        // Register previous gamepad button states\n        for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];\n\n        EmscriptenGamepadEvent gamepadState;\n\n        int result = emscripten_get_gamepad_status(i, &gamepadState);\n\n        if (result == EMSCRIPTEN_RESULT_SUCCESS)\n        {\n            // Register buttons data for every connected gamepad\n            for (int j = 0; (j < gamepadState.numButtons) && (j < MAX_GAMEPAD_BUTTONS); j++)\n            {\n                GamepadButton button = -1;\n\n                // Gamepad Buttons reference: https://www.w3.org/TR/gamepad/#gamepad-interface\n                switch (j)\n                {\n                    case 0: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;\n                    case 1: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;\n                    case 2: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;\n                    case 3: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;\n                    case 4: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;\n                    case 5: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;\n                    case 6: button = GAMEPAD_BUTTON_LEFT_TRIGGER_2; break;\n                    case 7: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_2; break;\n                    case 8: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;\n                    case 9: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;\n                    case 10: button = GAMEPAD_BUTTON_LEFT_THUMB; break;\n                    case 11: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;\n                    case 12: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;\n                    case 13: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;\n                    case 14: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;\n                    case 15: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;\n                    default: break;\n                }\n\n                if (button != -1)   // Check for valid button\n                {\n                    if (gamepadState.digitalButton[j] == 1)\n                    {\n                        CORE.Input.Gamepad.currentButtonState[i][button] = 1;\n                        CORE.Input.Gamepad.lastButtonPressed = button;\n                    }\n                    else CORE.Input.Gamepad.currentButtonState[i][button] = 0;\n                }\n\n                //TRACELOGD(\"INPUT: Gamepad %d, button %d: Digital: %d, Analog: %g\", gamepadState.index, j, gamepadState.digitalButton[j], gamepadState.analogButton[j]);\n            }\n\n            // Register axis data for every connected gamepad\n            for (int j = 0; (j < gamepadState.numAxes) && (j < MAX_GAMEPAD_AXIS); j++)\n            {\n                CORE.Input.Gamepad.axisState[i][j] = gamepadState.axis[j];\n            }\n\n            CORE.Input.Gamepad.axisCount = gamepadState.numAxes;\n        }\n    }\n#endif\n\n#if defined(PLATFORM_ANDROID)\n    // Register previous keys states\n    // NOTE: Android supports up to 260 keys\n    for (int i = 0; i < 260; i++) CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];\n\n    // Android ALooper_pollAll() variables\n    int pollResult = 0;\n    int pollEvents = 0;\n\n    // Poll Events (registered events)\n    // NOTE: Activity is paused if not enabled (CORE.Android.appEnabled)\n    while ((pollResult = ALooper_pollAll(CORE.Android.appEnabled? 0 : -1, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)\n    {\n        // Process this event\n        if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);\n\n        // NOTE: Never close window, native activity is controlled by the system!\n        if (CORE.Android.app->destroyRequested != 0)\n        {\n            //CORE.Window.shouldClose = true;\n            //ANativeActivity_finish(CORE.Android.app->activity);\n        }\n    }\n#endif\n\n#if (defined(PLATFORM_RPI) || defined(PLATFORM_DRM)) && defined(SUPPORT_SSH_KEYBOARD_RPI)\n    // NOTE: Keyboard reading could be done using input_event(s) or just read from stdin, both methods are used here.\n    // stdin reading is still used for legacy purposes, it allows keyboard input trough SSH console\n\n    if (!CORE.Input.Keyboard.evtMode) ProcessKeyboard();\n\n    // NOTE: Mouse input events polling is done asynchronously in another pthread - EventThread()\n    // NOTE: Gamepad (Joystick) input events polling is done asynchonously in another pthread - GamepadThread()\n#endif\n}\n\n// Scan all files and directories in a base path\n// WARNING: files.paths[] must be previously allocated and\n// contain enough space to store all required paths\nstatic void ScanDirectoryFiles(const char *basePath, FilePathList *files, const char *filter)\n{\n    static char path[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(path, 0, MAX_FILEPATH_LENGTH);\n\n    struct dirent *dp = NULL;\n    DIR *dir = opendir(basePath);\n\n    if (dir != NULL)\n    {\n        while ((dp = readdir(dir)) != NULL)\n        {\n            if ((strcmp(dp->d_name, \".\") != 0) &&\n                (strcmp(dp->d_name, \"..\") != 0))\n            {\n                sprintf(path, \"%s/%s\", basePath, dp->d_name);\n\n                if (filter != NULL)\n                {\n                    if (IsFileExtension(path, filter))\n                    {\n                        strcpy(files->paths[files->count], path);\n                        files->count++;\n                    }\n                }\n                else\n                {\n                    strcpy(files->paths[files->count], path);\n                    files->count++;\n                }\n            }\n        }\n\n        closedir(dir);\n    }\n    else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);\n}\n\n// Scan all files and directories recursively from a base path\nstatic void ScanDirectoryFilesRecursively(const char *basePath, FilePathList *files, const char *filter)\n{\n    char path[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(path, 0, MAX_FILEPATH_LENGTH);\n\n    struct dirent *dp = NULL;\n    DIR *dir = opendir(basePath);\n\n    if (dir != NULL)\n    {\n        while (((dp = readdir(dir)) != NULL) && (files->count < files->capacity))\n        {\n            if ((strcmp(dp->d_name, \".\") != 0) && (strcmp(dp->d_name, \"..\") != 0))\n            {\n                // Construct new path from our base path\n                sprintf(path, \"%s/%s\", basePath, dp->d_name);\n\n                if (IsPathFile(path))\n                {\n                    if (filter != NULL)\n                    {\n                        if (IsFileExtension(path, filter))\n                        {\n                            strcpy(files->paths[files->count], path);\n                            files->count++;\n                        }\n                    }\n                    else\n                    {\n                        strcpy(files->paths[files->count], path);\n                        files->count++;\n                    }\n\n                    if (files->count >= files->capacity)\n                    {\n                        TRACELOG(LOG_WARNING, \"FILEIO: Maximum filepath scan capacity reached (%i files)\", files->capacity);\n                        break;\n                    }\n                }\n                else ScanDirectoryFilesRecursively(path, files, filter);\n            }\n        }\n\n        closedir(dir);\n    }\n    else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);\n}\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n// GLFW3 Error Callback, runs on GLFW3 error\nstatic void ErrorCallback(int error, const char *description)\n{\n    TRACELOG(LOG_WARNING, \"GLFW: Error: %i Description: %s\", error, description);\n}\n\n// GLFW3 WindowSize Callback, runs when window is resizedLastFrame\n// NOTE: Window resizing not allowed by default\nstatic void WindowSizeCallback(GLFWwindow *window, int width, int height)\n{\n    // Reset viewport and projection matrix for new size\n    SetupViewport(width, height);\n\n    CORE.Window.currentFbo.width = width;\n    CORE.Window.currentFbo.height = height;\n    CORE.Window.resizedLastFrame = true;\n\n    if (IsWindowFullscreen()) return;\n\n    // Set current screen size\n#if defined(__APPLE__)\n    CORE.Window.screen.width = width;\n    CORE.Window.screen.height = height;\n#else\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        Vector2 windowScaleDPI = GetWindowScaleDPI();\n\n        CORE.Window.screen.width = (unsigned int)(width/windowScaleDPI.x);\n        CORE.Window.screen.height = (unsigned int)(height/windowScaleDPI.y);\n    }\n    else\n    {\n        CORE.Window.screen.width = width;\n        CORE.Window.screen.height = height;\n    }\n#endif\n\n    // NOTE: Postprocessing texture is not scaled to new size\n}\n\n// GLFW3 WindowIconify Callback, runs when window is minimized/restored\nstatic void WindowIconifyCallback(GLFWwindow *window, int iconified)\n{\n    if (iconified) CORE.Window.flags |= FLAG_WINDOW_MINIMIZED;  // The window was iconified\n    else CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;           // The window was restored\n}\n\n#if !defined(PLATFORM_WEB)\n// GLFW3 WindowMaximize Callback, runs when window is maximized/restored\nstatic void WindowMaximizeCallback(GLFWwindow *window, int maximized)\n{\n    if (maximized) CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;  // The window was maximized\n    else CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;           // The window was restored\n}\n#endif\n\n// GLFW3 WindowFocus Callback, runs when window get/lose focus\nstatic void WindowFocusCallback(GLFWwindow *window, int focused)\n{\n    if (focused) CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;   // The window was focused\n    else CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;            // The window lost focus\n}\n\n// GLFW3 Keyboard Callback, runs on key pressed\nstatic void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods)\n{\n    if (key < 0) return;    // Security check, macOS fn key generates -1\n\n    // WARNING: GLFW could return GLFW_REPEAT, we need to consider it as 1\n    // to work properly with our implementation (IsKeyDown/IsKeyUp checks)\n    if (action == GLFW_RELEASE) CORE.Input.Keyboard.currentKeyState[key] = 0;\n    else CORE.Input.Keyboard.currentKeyState[key] = 1;\n\n#if !defined(PLATFORM_WEB)\n    // WARNING: Check if CAPS/NUM key modifiers are enabled and force down state for those keys\n    if (((key == KEY_CAPS_LOCK) && ((mods & GLFW_MOD_CAPS_LOCK) > 0)) ||\n        ((key == KEY_NUM_LOCK) && ((mods & GLFW_MOD_NUM_LOCK) > 0))) CORE.Input.Keyboard.currentKeyState[key] = 1;\n#endif\n\n    // Check if there is space available in the key queue\n    if ((CORE.Input.Keyboard.keyPressedQueueCount < MAX_KEY_PRESSED_QUEUE) && (action == GLFW_PRESS))\n    {\n        // Add character to the queue\n        CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = key;\n        CORE.Input.Keyboard.keyPressedQueueCount++;\n    }\n\n    // Check the exit key to set close window\n    if ((key == CORE.Input.Keyboard.exitKey) && (action == GLFW_PRESS)) glfwSetWindowShouldClose(CORE.Window.handle, GLFW_TRUE);\n\n#if defined(SUPPORT_SCREEN_CAPTURE)\n    if ((key == GLFW_KEY_F12) && (action == GLFW_PRESS))\n    {\n#if defined(SUPPORT_GIF_RECORDING)\n        if (mods == GLFW_MOD_CONTROL)\n        {\n            if (gifRecording)\n            {\n                gifRecording = false;\n\n                MsfGifResult result = msf_gif_end(&gifState);\n\n                SaveFileData(TextFormat(\"%s/screenrec%03i.gif\", CORE.Storage.basePath, screenshotCounter), result.data, (unsigned int)result.dataSize);\n                msf_gif_free(result);\n\n            #if defined(PLATFORM_WEB)\n                // Download file from MEMFS (emscripten memory filesystem)\n                // saveFileFromMEMFSToDisk() function is defined in raylib/templates/web_shel/shell.html\n                emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1), TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1)));\n            #endif\n\n                TRACELOG(LOG_INFO, \"SYSTEM: Finish animated GIF recording\");\n            }\n            else\n            {\n                gifRecording = true;\n                gifFrameCounter = 0;\n\n                Vector2 scale = GetWindowScaleDPI();\n                msf_gif_begin(&gifState, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n                screenshotCounter++;\n\n                TRACELOG(LOG_INFO, \"SYSTEM: Start animated GIF recording: %s\", TextFormat(\"screenrec%03i.gif\", screenshotCounter));\n            }\n        }\n        else\n#endif  // SUPPORT_GIF_RECORDING\n        {\n            TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n            screenshotCounter++;\n        }\n    }\n#endif  // SUPPORT_SCREEN_CAPTURE\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    if ((key == GLFW_KEY_F11) && (action == GLFW_PRESS))\n    {\n        eventsRecording = !eventsRecording;\n\n        // On finish recording, we export events into a file\n        if (!eventsRecording) ExportAutomationEvents(\"eventsrec.rep\");\n    }\n    else if ((key == GLFW_KEY_F9) && (action == GLFW_PRESS))\n    {\n        LoadAutomationEvents(\"eventsrec.rep\");\n        eventsPlaying = true;\n\n        TRACELOG(LOG_WARNING, \"eventsPlaying enabled!\");\n    }\n#endif\n}\n\n// GLFW3 Char Key Callback, runs on key down (gets equivalent unicode char value)\nstatic void CharCallback(GLFWwindow *window, unsigned int key)\n{\n    //TRACELOG(LOG_DEBUG, \"Char Callback: KEY:%i(%c)\", key, key);\n\n    // NOTE: Registers any key down considering OS keyboard layout but\n    // does not detect action events, those should be managed by user...\n    // Ref: https://github.com/glfw/glfw/issues/668#issuecomment-166794907\n    // Ref: https://www.glfw.org/docs/latest/input_guide.html#input_char\n\n    // Check if there is space available in the queue\n    if (CORE.Input.Keyboard.charPressedQueueCount < MAX_CHAR_PRESSED_QUEUE)\n    {\n        // Add character to the queue\n        CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount] = key;\n        CORE.Input.Keyboard.charPressedQueueCount++;\n    }\n}\n\n// GLFW3 Mouse Button Callback, runs on mouse button pressed\nstatic void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)\n{\n    // WARNING: GLFW could only return GLFW_PRESS (1) or GLFW_RELEASE (0) for now,\n    // but future releases may add more actions (i.e. GLFW_REPEAT)\n    CORE.Input.Mouse.currentButtonState[button] = action;\n\n#if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)         // PLATFORM_DESKTOP\n    // Process mouse events as touches to be able to use mouse-gestures\n    GestureEvent gestureEvent = { 0 };\n\n    // Register touch actions\n    if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) gestureEvent.touchAction = TOUCH_ACTION_DOWN;\n    else if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) gestureEvent.touchAction = TOUCH_ACTION_UP;\n\n    // NOTE: TOUCH_ACTION_MOVE event is registered in MouseCursorPosCallback()\n\n    // Assign a pointer ID\n    gestureEvent.pointId[0] = 0;\n\n    // Register touch points count\n    gestureEvent.pointCount = 1;\n\n    // Register touch points position, only one point registered\n    gestureEvent.position[0] = GetMousePosition();\n\n    // Normalize gestureEvent.position[0] for CORE.Window.screen.width and CORE.Window.screen.height\n    gestureEvent.position[0].x /= (float)GetScreenWidth();\n    gestureEvent.position[0].y /= (float)GetScreenHeight();\n\n    // Gesture data is sent to gestures-system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n}\n\n// GLFW3 Cursor Position Callback, runs on mouse move\nstatic void MouseCursorPosCallback(GLFWwindow *window, double x, double y)\n{\n    CORE.Input.Mouse.currentPosition.x = (float)x;\n    CORE.Input.Mouse.currentPosition.y = (float)y;\n    CORE.Input.Touch.position[0] = CORE.Input.Mouse.currentPosition;\n\n#if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)         // PLATFORM_DESKTOP\n    // Process mouse events as touches to be able to use mouse-gestures\n    GestureEvent gestureEvent = { 0 };\n\n    gestureEvent.touchAction = TOUCH_ACTION_MOVE;\n\n    // Assign a pointer ID\n    gestureEvent.pointId[0] = 0;\n\n    // Register touch points count\n    gestureEvent.pointCount = 1;\n\n    // Register touch points position, only one point registered\n    gestureEvent.position[0] = CORE.Input.Touch.position[0];\n\n    // Normalize gestureEvent.position[0] for CORE.Window.screen.width and CORE.Window.screen.height\n    gestureEvent.position[0].x /= (float)GetScreenWidth();\n    gestureEvent.position[0].y /= (float)GetScreenHeight();\n\n    // Gesture data is sent to gestures-system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n}\n\n// GLFW3 Scrolling Callback, runs on mouse wheel\nstatic void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset)\n{\n    CORE.Input.Mouse.currentWheelMove = (Vector2){ (float)xoffset, (float)yoffset };\n}\n\n// GLFW3 CursorEnter Callback, when cursor enters the window\nstatic void CursorEnterCallback(GLFWwindow *window, int enter)\n{\n    if (enter == true) CORE.Input.Mouse.cursorOnScreen = true;\n    else CORE.Input.Mouse.cursorOnScreen = false;\n}\n\n// GLFW3 Window Drop Callback, runs when drop files into window\nstatic void WindowDropCallback(GLFWwindow *window, int count, const char **paths)\n{\n    if (count > 0)\n    {\n        // In case previous dropped filepaths have not been freed, we free them\n        if (CORE.Window.dropFileCount > 0)\n        {\n            for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++) RL_FREE(CORE.Window.dropFilepaths[i]);\n\n            RL_FREE(CORE.Window.dropFilepaths);\n\n            CORE.Window.dropFileCount = 0;\n            CORE.Window.dropFilepaths = NULL;\n        }\n\n        // WARNING: Paths are freed by GLFW when the callback returns, we must keep an internal copy\n        CORE.Window.dropFileCount = count;\n        CORE.Window.dropFilepaths = (char **)RL_CALLOC(CORE.Window.dropFileCount, sizeof(char *));\n\n        for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++)\n        {\n            CORE.Window.dropFilepaths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));\n            strcpy(CORE.Window.dropFilepaths[i], paths[i]);\n        }\n    }\n}\n#endif\n\n#if defined(PLATFORM_ANDROID)\n// ANDROID: Process activity lifecycle commands\nstatic void AndroidCommandCallback(struct android_app *app, int32_t cmd)\n{\n    switch (cmd)\n    {\n        case APP_CMD_START:\n        {\n            //rendering = true;\n        } break;\n        case APP_CMD_RESUME: break;\n        case APP_CMD_INIT_WINDOW:\n        {\n            if (app->window != NULL)\n            {\n                if (CORE.Android.contextRebindRequired)\n                {\n                    // Reset screen scaling to full display size\n                    EGLint displayFormat = 0;\n                    eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);\n\n                    // Adding renderOffset here feels rather hackish, but the viewport scaling is wrong after the\n                    // context rebinding if the screen is scaled unless offsets are added. There's probably a more\n                    // appropriate way to fix this\n                    ANativeWindow_setBuffersGeometry(app->window,\n                        CORE.Window.render.width + CORE.Window.renderOffset.x,\n                        CORE.Window.render.height + CORE.Window.renderOffset.y,\n                        displayFormat);\n\n                    // Recreate display surface and re-attach OpenGL context\n                    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, app->window, NULL);\n                    eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context);\n\n                    CORE.Android.contextRebindRequired = false;\n                }\n                else\n                {\n                    CORE.Window.display.width = ANativeWindow_getWidth(CORE.Android.app->window);\n                    CORE.Window.display.height = ANativeWindow_getHeight(CORE.Android.app->window);\n\n                    // Initialize graphics device (display device and OpenGL context)\n                    InitGraphicsDevice(CORE.Window.screen.width, CORE.Window.screen.height);\n\n                    // Initialize hi-res timer\n                    InitTimer();\n\n                    // Initialize random seed\n                    srand((unsigned int)time(NULL));\n\n                #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n                    // Load default font\n                    // WARNING: External function: Module required: rtext\n                    LoadFontDefault();\n                    Rectangle rec = GetFontDefault().recs[95];\n                    // NOTE: We setup a 1px padding on char rectangle to avoid pixel bleeding on MSAA filtering\n                    #if defined(SUPPORT_MODULE_RSHAPES)\n                    SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 });  // WARNING: Module required: rshapes\n                    #endif\n                #endif\n\n                    // TODO: GPU assets reload in case of lost focus (lost context)\n                    // NOTE: This problem has been solved just unbinding and rebinding context from display\n                    /*\n                    if (assetsReloadRequired)\n                    {\n                        for (int i = 0; i < assetCount; i++)\n                        {\n                            // TODO: Unload old asset if required\n\n                            // Load texture again to pointed texture\n                            (*textureAsset + i) = LoadTexture(assetPath[i]);\n                        }\n                    }\n                    */\n                }\n            }\n        } break;\n        case APP_CMD_GAINED_FOCUS:\n        {\n            CORE.Android.appEnabled = true;\n            //ResumeMusicStream();\n        } break;\n        case APP_CMD_PAUSE: break;\n        case APP_CMD_LOST_FOCUS:\n        {\n            CORE.Android.appEnabled = false;\n            //PauseMusicStream();\n        } break;\n        case APP_CMD_TERM_WINDOW:\n        {\n            // Dettach OpenGL context and destroy display surface\n            // NOTE 1: Detaching context before destroying display surface avoids losing our resources (textures, shaders, VBOs...)\n            // NOTE 2: In some cases (too many context loaded), OS could unload context automatically... :(\n            eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n            eglDestroySurface(CORE.Window.device, CORE.Window.surface);\n\n            CORE.Android.contextRebindRequired = true;\n        } break;\n        case APP_CMD_SAVE_STATE: break;\n        case APP_CMD_STOP: break;\n        case APP_CMD_DESTROY:\n        {\n            // TODO: Finish activity?\n            //ANativeActivity_finish(CORE.Android.app->activity);\n        } break;\n        case APP_CMD_CONFIG_CHANGED:\n        {\n            //AConfiguration_fromAssetManager(CORE.Android.app->config, CORE.Android.app->activity->assetManager);\n            //print_cur_config(CORE.Android.app);\n\n            // Check screen orientation here!\n        } break;\n        default: break;\n    }\n}\n\nstatic GamepadButton AndroidTranslateGamepadButton(int button)\n{\n    switch (button)\n    {\n        case AKEYCODE_BUTTON_A: return GAMEPAD_BUTTON_RIGHT_FACE_DOWN;\n        case AKEYCODE_BUTTON_B: return GAMEPAD_BUTTON_RIGHT_FACE_RIGHT;\n        case AKEYCODE_BUTTON_X: return GAMEPAD_BUTTON_RIGHT_FACE_LEFT;\n        case AKEYCODE_BUTTON_Y: return GAMEPAD_BUTTON_RIGHT_FACE_UP;\n        case AKEYCODE_BUTTON_L1: return GAMEPAD_BUTTON_LEFT_TRIGGER_1;\n        case AKEYCODE_BUTTON_R1: return GAMEPAD_BUTTON_RIGHT_TRIGGER_1;\n        case AKEYCODE_BUTTON_L2: return GAMEPAD_BUTTON_LEFT_TRIGGER_2;\n        case AKEYCODE_BUTTON_R2: return GAMEPAD_BUTTON_RIGHT_TRIGGER_2;\n        case AKEYCODE_BUTTON_THUMBL: return GAMEPAD_BUTTON_LEFT_THUMB;\n        case AKEYCODE_BUTTON_THUMBR: return GAMEPAD_BUTTON_RIGHT_THUMB;\n        case AKEYCODE_BUTTON_START: return GAMEPAD_BUTTON_MIDDLE_RIGHT;\n        case AKEYCODE_BUTTON_SELECT: return GAMEPAD_BUTTON_MIDDLE_LEFT;\n        case AKEYCODE_BUTTON_MODE: return GAMEPAD_BUTTON_MIDDLE;\n        // On some (most?) gamepads dpad events are reported as axis motion instead\n        case AKEYCODE_DPAD_DOWN: return GAMEPAD_BUTTON_LEFT_FACE_DOWN;\n        case AKEYCODE_DPAD_RIGHT: return GAMEPAD_BUTTON_LEFT_FACE_RIGHT;\n        case AKEYCODE_DPAD_LEFT: return GAMEPAD_BUTTON_LEFT_FACE_LEFT;\n        case AKEYCODE_DPAD_UP: return GAMEPAD_BUTTON_LEFT_FACE_UP;\n        default: return GAMEPAD_BUTTON_UNKNOWN;\n    }\n}\n\n// ANDROID: Get input events\nstatic int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event)\n{\n    // If additional inputs are required check:\n    // https://developer.android.com/ndk/reference/group/input\n    // https://developer.android.com/training/game-controllers/controller-input\n\n    int type = AInputEvent_getType(event);\n    int source = AInputEvent_getSource(event);\n\n    if (type == AINPUT_EVENT_TYPE_MOTION)\n    {\n        if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||\n            ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))\n        {\n            // For now we'll assume a single gamepad which we \"detect\" on its input event\n            CORE.Input.Gamepad.ready[0] = true;\n\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_X] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_X, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_Y] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_Y, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_X] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_Z, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_Y] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_RZ, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_TRIGGER] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_BRAKE, 0) * 2.0f - 1.0f;\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_TRIGGER] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_GAS, 0) * 2.0f - 1.0f;\n\n            // dpad is reported as an axis on android\n            float dpadX = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_X, 0);\n            float dpadY = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_Y, 0);\n\n            if (dpadX == 1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 1;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;\n            }\n            else if (dpadX == -1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 1;\n            }\n            else\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;\n            }\n\n            if (dpadY == 1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 1;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;\n            }\n            else if (dpadY == -1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 1;\n            }\n            else\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;\n            }\n\n            return 1; // Handled gamepad axis motion\n        }\n    }\n    else if (type == AINPUT_EVENT_TYPE_KEY)\n    {\n        int32_t keycode = AKeyEvent_getKeyCode(event);\n        //int32_t AKeyEvent_getMetaState(event);\n\n        // Handle gamepad button presses and releases\n        if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||\n            ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))\n        {\n            // For now we'll assume a single gamepad which we \"detect\" on its input event\n            CORE.Input.Gamepad.ready[0] = true;\n\n            GamepadButton button = AndroidTranslateGamepadButton(keycode);\n\n            if (button == GAMEPAD_BUTTON_UNKNOWN) return 1;\n\n            if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][button] = 1;\n            }\n            else CORE.Input.Gamepad.currentButtonState[0][button] = 0;  // Key up\n\n            return 1; // Handled gamepad button\n        }\n\n        // Save current button and its state\n        // NOTE: Android key action is 0 for down and 1 for up\n        if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)\n        {\n            CORE.Input.Keyboard.currentKeyState[keycode] = 1;   // Key down\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n        else CORE.Input.Keyboard.currentKeyState[keycode] = 0;  // Key up\n\n        if (keycode == AKEYCODE_POWER)\n        {\n            // Let the OS handle input to avoid app stuck. Behaviour: CMD_PAUSE -> CMD_SAVE_STATE -> CMD_STOP -> CMD_CONFIG_CHANGED -> CMD_LOST_FOCUS\n            // Resuming Behaviour: CMD_START -> CMD_RESUME -> CMD_CONFIG_CHANGED -> CMD_CONFIG_CHANGED -> CMD_GAINED_FOCUS\n            // It seems like locking mobile, screen size (CMD_CONFIG_CHANGED) is affected.\n            // NOTE: AndroidManifest.xml must have <activity android:configChanges=\"orientation|keyboardHidden|screenSize\" >\n            // Before that change, activity was calling CMD_TERM_WINDOW and CMD_DESTROY when locking mobile, so that was not a normal behaviour\n            return 0;\n        }\n        else if ((keycode == AKEYCODE_BACK) || (keycode == AKEYCODE_MENU))\n        {\n            // Eat BACK_BUTTON and AKEYCODE_MENU, just do nothing... and don't let to be handled by OS!\n            return 1;\n        }\n        else if ((keycode == AKEYCODE_VOLUME_UP) || (keycode == AKEYCODE_VOLUME_DOWN))\n        {\n            // Set default OS behaviour\n            return 0;\n        }\n\n        return 0;\n    }\n\n    // Register touch points count\n    CORE.Input.Touch.pointCount = AMotionEvent_getPointerCount(event);\n\n    for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        // Register touch points id\n        CORE.Input.Touch.pointId[i] = AMotionEvent_getPointerId(event, i);\n\n        // Register touch points position\n        CORE.Input.Touch.position[i] = (Vector2){ AMotionEvent_getX(event, i), AMotionEvent_getY(event, i) };\n\n        // Normalize CORE.Input.Touch.position[i] for CORE.Window.screen.width and CORE.Window.screen.height\n        float widthRatio = (float)(CORE.Window.screen.width + CORE.Window.renderOffset.x) / (float)CORE.Window.display.width;\n        float heightRatio = (float)(CORE.Window.screen.height + CORE.Window.renderOffset.y) / (float)CORE.Window.display.height;\n        CORE.Input.Touch.position[i].x = CORE.Input.Touch.position[i].x * widthRatio - (float)CORE.Window.renderOffset.x / 2;\n        CORE.Input.Touch.position[i].y = CORE.Input.Touch.position[i].y * heightRatio - (float)CORE.Window.renderOffset.y / 2;\n    }\n\n    int32_t action = AMotionEvent_getAction(event);\n    unsigned int flags = action & AMOTION_EVENT_ACTION_MASK;\n\n#if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_ANDROID\n    GestureEvent gestureEvent = { 0 };\n\n    gestureEvent.pointCount = CORE.Input.Touch.pointCount;\n\n    // Register touch actions\n    if (flags == AMOTION_EVENT_ACTION_DOWN) gestureEvent.touchAction = TOUCH_ACTION_DOWN;\n    else if (flags == AMOTION_EVENT_ACTION_UP) gestureEvent.touchAction = TOUCH_ACTION_UP;\n    else if (flags == AMOTION_EVENT_ACTION_MOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;\n    else if (flags == AMOTION_EVENT_ACTION_CANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;\n\n    for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];\n        gestureEvent.position[i] = CORE.Input.Touch.position[i];\n    }\n\n    // Gesture data is sent to gestures system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n\n    int32_t pointerIndex = (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;\n\n    if (flags == AMOTION_EVENT_ACTION_POINTER_UP || flags == AMOTION_EVENT_ACTION_UP)\n    {\n        // One of the touchpoints is released, remove it from touch point arrays\n        for (int i = pointerIndex; (i < CORE.Input.Touch.pointCount-1) && (i < MAX_TOUCH_POINTS); i++)\n        {\n            CORE.Input.Touch.pointId[i] = CORE.Input.Touch.pointId[i+1];\n            CORE.Input.Touch.position[i] = CORE.Input.Touch.position[i+1];\n        }\n        CORE.Input.Touch.pointCount--;\n    }\n\n    // When all touchpoints are tapped and released really quickly, this event is generated\n    if (flags == AMOTION_EVENT_ACTION_CANCEL) CORE.Input.Touch.pointCount = 0;\n\n    if (CORE.Input.Touch.pointCount > 0) CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 1;\n    else CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 0;\n\n    return 0;\n}\n#endif\n\n#if defined(PLATFORM_WEB)\n// Register fullscreen change events\nstatic EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData)\n{\n    // TODO: Implement EmscriptenFullscreenChangeCallback()?\n\n    return 1;   // The event was consumed by the callback handler\n}\n\n// Register window resize event\nstatic EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData)\n{\n    // TODO: Implement EmscriptenWindowResizedCallback()?\n\n    return 1;   // The event was consumed by the callback handler\n}\n\nEM_JS(int, GetCanvasWidth, (), { return canvas.clientWidth; });\nEM_JS(int, GetCanvasHeight, (), { return canvas.clientHeight; });\n\n// Register DOM element resize event\nstatic EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData)\n{\n    // Don't resize non-resizeable windows\n    if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) == 0) return 1;\n\n    // This event is called whenever the window changes sizes,\n    // so the size of the canvas object is explicitly retrieved below\n    int width = GetCanvasWidth();\n    int height = GetCanvasHeight();\n    emscripten_set_canvas_element_size(\"#canvas\",width,height);\n\n    SetupViewport(width, height);    // Reset viewport and projection matrix for new size\n\n    CORE.Window.currentFbo.width = width;\n    CORE.Window.currentFbo.height = height;\n    CORE.Window.resizedLastFrame = true;\n\n    if (IsWindowFullscreen()) return 1;\n\n    // Set current screen size\n    CORE.Window.screen.width = width;\n    CORE.Window.screen.height = height;\n\n    // NOTE: Postprocessing texture is not scaled to new size\n\n    return 0;\n}\n\n// Register mouse input events\nstatic EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData)\n{\n    // This is only for registering mouse click events with emscripten and doesn't need to do anything\n\n    return 1;   // The event was consumed by the callback handler\n}\n\n// Register connected/disconnected gamepads events\nstatic EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData)\n{\n    /*\n    TRACELOGD(\"%s: timeStamp: %g, connected: %d, index: %ld, numAxes: %d, numButtons: %d, id: \\\"%s\\\", mapping: \\\"%s\\\"\",\n           eventType != 0? emscripten_event_type_to_string(eventType) : \"Gamepad state\",\n           gamepadEvent->timestamp, gamepadEvent->connected, gamepadEvent->index, gamepadEvent->numAxes, gamepadEvent->numButtons, gamepadEvent->id, gamepadEvent->mapping);\n\n    for (int i = 0; i < gamepadEvent->numAxes; ++i) TRACELOGD(\"Axis %d: %g\", i, gamepadEvent->axis[i]);\n    for (int i = 0; i < gamepadEvent->numButtons; ++i) TRACELOGD(\"Button %d: Digital: %d, Analog: %g\", i, gamepadEvent->digitalButton[i], gamepadEvent->analogButton[i]);\n    */\n\n    if ((gamepadEvent->connected) && (gamepadEvent->index < MAX_GAMEPADS))\n    {\n        CORE.Input.Gamepad.ready[gamepadEvent->index] = true;\n        sprintf(CORE.Input.Gamepad.name[gamepadEvent->index],\"%s\",gamepadEvent->id);\n    }\n    else CORE.Input.Gamepad.ready[gamepadEvent->index] = false;\n\n    return 1;   // The event was consumed by the callback handler\n}\n\n// Register touch input events\nstatic EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData)\n{\n    // Register touch points count\n    CORE.Input.Touch.pointCount = touchEvent->numTouches;\n\n    double canvasWidth = 0.0;\n    double canvasHeight = 0.0;\n    // NOTE: emscripten_get_canvas_element_size() returns canvas.width and canvas.height but\n    // we are looking for actual CSS size: canvas.style.width and canvas.style.height\n    //EMSCRIPTEN_RESULT res = emscripten_get_canvas_element_size(\"#canvas\", &canvasWidth, &canvasHeight);\n    emscripten_get_element_css_size(\"#canvas\", &canvasWidth, &canvasHeight);\n\n    for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        // Register touch points id\n        CORE.Input.Touch.pointId[i] = touchEvent->touches[i].identifier;\n\n        // Register touch points position\n        CORE.Input.Touch.position[i] = (Vector2){ touchEvent->touches[i].targetX, touchEvent->touches[i].targetY };\n\n        // Normalize gestureEvent.position[x] for CORE.Window.screen.width and CORE.Window.screen.height\n        CORE.Input.Touch.position[i].x *= ((float)GetScreenWidth()/(float)canvasWidth);\n        CORE.Input.Touch.position[i].y *= ((float)GetScreenHeight()/(float)canvasHeight);\n\n        if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) CORE.Input.Touch.currentTouchState[i] = 1;\n        else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) CORE.Input.Touch.currentTouchState[i] = 0;\n    }\n\n#if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_WEB\n    GestureEvent gestureEvent = { 0 };\n\n    gestureEvent.pointCount = CORE.Input.Touch.pointCount;\n\n    // Register touch actions\n    if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) gestureEvent.touchAction = TOUCH_ACTION_DOWN;\n    else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) gestureEvent.touchAction = TOUCH_ACTION_UP;\n    else if (eventType == EMSCRIPTEN_EVENT_TOUCHMOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;\n    else if (eventType == EMSCRIPTEN_EVENT_TOUCHCANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;\n\n    for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];\n        gestureEvent.position[i] = CORE.Input.Touch.position[i];\n    }\n\n    // Gesture data is sent to gestures system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n\n    return 1;   // The event was consumed by the callback handler\n}\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n// Initialize Keyboard system (using standard input)\nstatic void InitKeyboard(void)\n{\n    // NOTE: We read directly from Standard Input (stdin) - STDIN_FILENO file descriptor,\n    // Reading directly from stdin will give chars already key-mapped by kernel to ASCII or UNICODE\n\n    // Save terminal keyboard settings\n    tcgetattr(STDIN_FILENO, &CORE.Input.Keyboard.defaultSettings);\n\n    // Reconfigure terminal with new settings\n    struct termios keyboardNewSettings = { 0 };\n    keyboardNewSettings = CORE.Input.Keyboard.defaultSettings;\n\n    // New terminal settings for keyboard: turn off buffering (non-canonical mode), echo and key processing\n    // NOTE: ISIG controls if ^C and ^Z generate break signals or not\n    keyboardNewSettings.c_lflag &= ~(ICANON | ECHO | ISIG);\n    //keyboardNewSettings.c_iflag &= ~(ISTRIP | INLCR | ICRNL | IGNCR | IXON | IXOFF);\n    keyboardNewSettings.c_cc[VMIN] = 1;\n    keyboardNewSettings.c_cc[VTIME] = 0;\n\n    // Set new keyboard settings (change occurs immediately)\n    tcsetattr(STDIN_FILENO, TCSANOW, &keyboardNewSettings);\n\n    // Save old keyboard mode to restore it at the end\n    CORE.Input.Keyboard.defaultFileFlags = fcntl(STDIN_FILENO, F_GETFL, 0);          // F_GETFL: Get the file access mode and the file status flags\n    fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags | O_NONBLOCK); // F_SETFL: Set the file status flags to the value specified\n\n    // NOTE: If ioctl() returns -1, it means the call failed for some reason (error code set in errno)\n    int result = ioctl(STDIN_FILENO, KDGKBMODE, &CORE.Input.Keyboard.defaultMode);\n\n    // In case of failure, it could mean a remote keyboard is used (SSH)\n    if (result < 0) TRACELOG(LOG_WARNING, \"RPI: Failed to change keyboard mode, an SSH keyboard is probably used\");\n    else\n    {\n        // Reconfigure keyboard mode to get:\n        //    - scancodes (K_RAW)\n        //    - keycodes (K_MEDIUMRAW)\n        //    - ASCII chars (K_XLATE)\n        //    - UNICODE chars (K_UNICODE)\n        ioctl(STDIN_FILENO, KDSKBMODE, K_XLATE);  // ASCII chars\n    }\n\n    // Register keyboard restore when program finishes\n    atexit(RestoreKeyboard);\n}\n\n// Restore default keyboard input\nstatic void RestoreKeyboard(void)\n{\n    // Reset to default keyboard settings\n    tcsetattr(STDIN_FILENO, TCSANOW, &CORE.Input.Keyboard.defaultSettings);\n\n    // Reconfigure keyboard to default mode\n    fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags);\n    ioctl(STDIN_FILENO, KDSKBMODE, CORE.Input.Keyboard.defaultMode);\n}\n\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\n// Process keyboard inputs\nstatic void ProcessKeyboard(void)\n{\n    #define MAX_KEYBUFFER_SIZE      32      // Max size in bytes to read\n\n    // Keyboard input polling (fill keys[256] array with status)\n    int bufferByteCount = 0;                        // Bytes available on the buffer\n    char keysBuffer[MAX_KEYBUFFER_SIZE] = { 0 };    // Max keys to be read at a time\n\n    // Read availables keycodes from stdin\n    bufferByteCount = read(STDIN_FILENO, keysBuffer, MAX_KEYBUFFER_SIZE);     // POSIX system call\n\n    // Reset pressed keys array (it will be filled below)\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.currentKeyState[i] = 0;\n\n    // Fill all read bytes (looking for keys)\n    for (int i = 0; i < bufferByteCount; i++)\n    {\n        // NOTE: If (key == 0x1b), depending on next key, it could be a special keymap code!\n        // Up -> 1b 5b 41 / Left -> 1b 5b 44 / Right -> 1b 5b 43 / Down -> 1b 5b 42\n        if (keysBuffer[i] == 0x1b)\n        {\n            // Check if ESCAPE key has been pressed to stop program\n            if (bufferByteCount == 1) CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] = 1;\n            else\n            {\n                if (keysBuffer[i + 1] == 0x5b)    // Special function key\n                {\n                    if ((keysBuffer[i + 2] == 0x5b) || (keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32))\n                    {\n                        // Process special function keys (F1 - F12)\n                        switch (keysBuffer[i + 3])\n                        {\n                            case 0x41: CORE.Input.Keyboard.currentKeyState[290] = 1; break;    // raylib KEY_F1\n                            case 0x42: CORE.Input.Keyboard.currentKeyState[291] = 1; break;    // raylib KEY_F2\n                            case 0x43: CORE.Input.Keyboard.currentKeyState[292] = 1; break;    // raylib KEY_F3\n                            case 0x44: CORE.Input.Keyboard.currentKeyState[293] = 1; break;    // raylib KEY_F4\n                            case 0x45: CORE.Input.Keyboard.currentKeyState[294] = 1; break;    // raylib KEY_F5\n                            case 0x37: CORE.Input.Keyboard.currentKeyState[295] = 1; break;    // raylib KEY_F6\n                            case 0x38: CORE.Input.Keyboard.currentKeyState[296] = 1; break;    // raylib KEY_F7\n                            case 0x39: CORE.Input.Keyboard.currentKeyState[297] = 1; break;    // raylib KEY_F8\n                            case 0x30: CORE.Input.Keyboard.currentKeyState[298] = 1; break;    // raylib KEY_F9\n                            case 0x31: CORE.Input.Keyboard.currentKeyState[299] = 1; break;    // raylib KEY_F10\n                            case 0x33: CORE.Input.Keyboard.currentKeyState[300] = 1; break;    // raylib KEY_F11\n                            case 0x34: CORE.Input.Keyboard.currentKeyState[301] = 1; break;    // raylib KEY_F12\n                            default: break;\n                        }\n\n                        if (keysBuffer[i + 2] == 0x5b) i += 4;\n                        else if ((keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32)) i += 5;\n                    }\n                    else\n                    {\n                        switch (keysBuffer[i + 2])\n                        {\n                            case 0x41: CORE.Input.Keyboard.currentKeyState[265] = 1; break;    // raylib KEY_UP\n                            case 0x42: CORE.Input.Keyboard.currentKeyState[264] = 1; break;    // raylib KEY_DOWN\n                            case 0x43: CORE.Input.Keyboard.currentKeyState[262] = 1; break;    // raylib KEY_RIGHT\n                            case 0x44: CORE.Input.Keyboard.currentKeyState[263] = 1; break;    // raylib KEY_LEFT\n                            default: break;\n                        }\n\n                        i += 3;  // Jump to next key\n                    }\n\n                    // NOTE: Some keys are not directly keymapped (CTRL, ALT, SHIFT)\n                }\n            }\n        }\n        else if (keysBuffer[i] == 0x0a)     // raylib KEY_ENTER (don't mix with <linux/input.h> KEY_*)\n        {\n            CORE.Input.Keyboard.currentKeyState[257] = 1;\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n        else if (keysBuffer[i] == 0x7f)     // raylib KEY_BACKSPACE\n        {\n            CORE.Input.Keyboard.currentKeyState[259] = 1;\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n        else\n        {\n            // Translate lowercase a-z letters to A-Z\n            if ((keysBuffer[i] >= 97) && (keysBuffer[i] <= 122))\n            {\n                CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i] - 32] = 1;\n            }\n            else CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i]] = 1;\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keysBuffer[i];     // Add keys pressed into queue\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n    }\n\n    // Check exit key (same functionality as GLFW3 KeyCallback())\n    if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;\n\n#if defined(SUPPORT_SCREEN_CAPTURE)\n    // Check screen capture key (raylib key: KEY_F12)\n    if (CORE.Input.Keyboard.currentKeyState[301] == 1)\n    {\n        TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n        screenshotCounter++;\n    }\n#endif\n}\n#endif  // SUPPORT_SSH_KEYBOARD_RPI\n\n// Initialise user input from evdev(/dev/input/event<N>) this means mouse, keyboard or gamepad devices\nstatic void InitEvdevInput(void)\n{\n    char path[MAX_FILEPATH_LENGTH] = { 0 };\n    DIR *directory = NULL;\n    struct dirent *entity = NULL;\n\n    // Initialise keyboard file descriptor\n    CORE.Input.Keyboard.fd = -1;\n\n    // Reset variables\n    for (int i = 0; i < MAX_TOUCH_POINTS; ++i)\n    {\n        CORE.Input.Touch.position[i].x = -1;\n        CORE.Input.Touch.position[i].y = -1;\n    }\n\n    // Reset keyboard key state\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.currentKeyState[i] = 0;\n\n    // Open the linux directory of \"/dev/input\"\n    directory = opendir(DEFAULT_EVDEV_PATH);\n\n    if (directory)\n    {\n        while ((entity = readdir(directory)) != NULL)\n        {\n            if ((strncmp(\"event\", entity->d_name, strlen(\"event\")) == 0) ||     // Search for devices named \"event*\"\n                (strncmp(\"mouse\", entity->d_name, strlen(\"mouse\")) == 0))       // Search for devices named \"mouse*\"\n            {\n                sprintf(path, \"%s%s\", DEFAULT_EVDEV_PATH, entity->d_name);\n                ConfigureEvdevDevice(path);                                     // Configure the device if appropriate\n            }\n        }\n\n        closedir(directory);\n    }\n    else TRACELOG(LOG_WARNING, \"RPI: Failed to open linux event directory: %s\", DEFAULT_EVDEV_PATH);\n}\n\n// Identifies a input device and configures it for use if appropriate\nstatic void ConfigureEvdevDevice(char *device)\n{\n    #define BITS_PER_LONG   (8*sizeof(long))\n    #define NBITS(x)        ((((x) - 1)/BITS_PER_LONG) + 1)\n    #define OFF(x)          ((x)%BITS_PER_LONG)\n    #define BIT(x)          (1UL<<OFF(x))\n    #define LONG(x)         ((x)/BITS_PER_LONG)\n    #define TEST_BIT(array, bit) ((array[LONG(bit)] >> OFF(bit)) & 1)\n\n    struct input_absinfo absinfo = { 0 };\n    unsigned long evBits[NBITS(EV_MAX)] = { 0 };\n    unsigned long absBits[NBITS(ABS_MAX)] = { 0 };\n    unsigned long relBits[NBITS(REL_MAX)] = { 0 };\n    unsigned long keyBits[NBITS(KEY_MAX)] = { 0 };\n    bool hasAbs = false;\n    bool hasRel = false;\n    bool hasAbsMulti = false;\n    int freeWorkerId = -1;\n    int fd = -1;\n\n    InputEventWorker *worker = NULL;\n\n    // Open the device and allocate worker\n    //-------------------------------------------------------------------------------------------------------\n    // Find a free spot in the workers array\n    for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n    {\n        if (CORE.Input.eventWorker[i].threadId == 0)\n        {\n            freeWorkerId = i;\n            break;\n        }\n    }\n\n    // Select the free worker from array\n    if (freeWorkerId >= 0)\n    {\n        worker = &(CORE.Input.eventWorker[freeWorkerId]);       // Grab a pointer to the worker\n        memset(worker, 0, sizeof(InputEventWorker));  // Clear the worker\n    }\n    else\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread for %s, out of worker slots\", device);\n        return;\n    }\n\n    // Open the device\n    fd = open(device, O_RDONLY | O_NONBLOCK);\n    if (fd < 0)\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Failed to open input device: %s\", device);\n        return;\n    }\n    worker->fd = fd;\n\n    // Grab number on the end of the devices name \"event<N>\"\n    int devNum = 0;\n    char *ptrDevName = strrchr(device, 't');\n    worker->eventNum = -1;\n\n    if (ptrDevName != NULL)\n    {\n        if (sscanf(ptrDevName, \"t%d\", &devNum) == 1) worker->eventNum = devNum;\n    }\n    else worker->eventNum = 0;      // TODO: HACK: Grab number for mouse0 device!\n\n    // At this point we have a connection to the device, but we don't yet know what the device is.\n    // It could be many things, even as simple as a power button...\n    //-------------------------------------------------------------------------------------------------------\n\n    // Identify the device\n    //-------------------------------------------------------------------------------------------------------\n    ioctl(fd, EVIOCGBIT(0, sizeof(evBits)), evBits);    // Read a bitfield of the available device properties\n\n    // Check for absolute input devices\n    if (TEST_BIT(evBits, EV_ABS))\n    {\n        ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absBits)), absBits);\n\n        // Check for absolute movement support (usualy touchscreens, but also joysticks)\n        if (TEST_BIT(absBits, ABS_X) && TEST_BIT(absBits, ABS_Y))\n        {\n            hasAbs = true;\n\n            // Get the scaling values\n            ioctl(fd, EVIOCGABS(ABS_X), &absinfo);\n            worker->absRange.x = absinfo.minimum;\n            worker->absRange.width = absinfo.maximum - absinfo.minimum;\n            ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);\n            worker->absRange.y = absinfo.minimum;\n            worker->absRange.height = absinfo.maximum - absinfo.minimum;\n        }\n\n        // Check for multiple absolute movement support (usualy multitouch touchscreens)\n        if (TEST_BIT(absBits, ABS_MT_POSITION_X) && TEST_BIT(absBits, ABS_MT_POSITION_Y))\n        {\n            hasAbsMulti = true;\n\n            // Get the scaling values\n            ioctl(fd, EVIOCGABS(ABS_X), &absinfo);\n            worker->absRange.x = absinfo.minimum;\n            worker->absRange.width = absinfo.maximum - absinfo.minimum;\n            ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);\n            worker->absRange.y = absinfo.minimum;\n            worker->absRange.height = absinfo.maximum - absinfo.minimum;\n        }\n    }\n\n    // Check for relative movement support (usualy mouse)\n    if (TEST_BIT(evBits, EV_REL))\n    {\n        ioctl(fd, EVIOCGBIT(EV_REL, sizeof(relBits)), relBits);\n\n        if (TEST_BIT(relBits, REL_X) && TEST_BIT(relBits, REL_Y)) hasRel = true;\n    }\n\n    // Check for button support to determine the device type(usualy on all input devices)\n    if (TEST_BIT(evBits, EV_KEY))\n    {\n        ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keyBits)), keyBits);\n\n        if (hasAbs || hasAbsMulti)\n        {\n            if (TEST_BIT(keyBits, BTN_TOUCH)) worker->isTouch = true;          // This is a touchscreen\n            if (TEST_BIT(keyBits, BTN_TOOL_FINGER)) worker->isTouch = true;    // This is a drawing tablet\n            if (TEST_BIT(keyBits, BTN_TOOL_PEN)) worker->isTouch = true;       // This is a drawing tablet\n            if (TEST_BIT(keyBits, BTN_STYLUS)) worker->isTouch = true;         // This is a drawing tablet\n            if (worker->isTouch || hasAbsMulti) worker->isMultitouch = true;   // This is a multitouch capable device\n        }\n\n        if (hasRel)\n        {\n            if (TEST_BIT(keyBits, BTN_LEFT)) worker->isMouse = true;           // This is a mouse\n            if (TEST_BIT(keyBits, BTN_RIGHT)) worker->isMouse = true;          // This is a mouse\n        }\n\n        if (TEST_BIT(keyBits, BTN_A)) worker->isGamepad = true;                // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_TRIGGER)) worker->isGamepad = true;          // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_START)) worker->isGamepad = true;            // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad\n\n        if (TEST_BIT(keyBits, KEY_SPACE)) worker->isKeyboard = true;           // This is a keyboard\n    }\n    //-------------------------------------------------------------------------------------------------------\n\n    // Decide what to do with the device\n    //-------------------------------------------------------------------------------------------------------\n    if (worker->isKeyboard && (CORE.Input.Keyboard.fd == -1))\n    {\n        // Use the first keyboard encountered. This assumes that a device that says it's a keyboard is just a\n        // keyboard. The keyboard is polled synchronously, whereas other input devices are polled in separate\n        // threads so that they don't drop events when the frame rate is slow.\n        TRACELOG(LOG_INFO, \"RPI: Opening keyboard device: %s\", device);\n        CORE.Input.Keyboard.fd = worker->fd;\n    }\n    else if (worker->isTouch || worker->isMouse)\n    {\n        // Looks like an interesting device\n        TRACELOG(LOG_INFO, \"RPI: Opening input device: %s (%s%s%s%s)\", device,\n            worker->isMouse? \"mouse \" : \"\",\n            worker->isMultitouch? \"multitouch \" : \"\",\n            worker->isTouch? \"touchscreen \" : \"\",\n            worker->isGamepad? \"gamepad \" : \"\");\n\n        // Create a thread for this device\n        int error = pthread_create(&worker->threadId, NULL, &EventThread, (void *)worker);\n        if (error != 0)\n        {\n            TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread: %s (error: %d)\", device, error);\n            worker->threadId = 0;\n            close(fd);\n        }\n\n#if defined(USE_LAST_TOUCH_DEVICE)\n        // Find touchscreen with the highest index\n        int maxTouchNumber = -1;\n\n        for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n        {\n            if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum > maxTouchNumber)) maxTouchNumber = CORE.Input.eventWorker[i].eventNum;\n        }\n\n        // Find touchscreens with lower indexes\n        for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n        {\n            if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum < maxTouchNumber))\n            {\n                if (CORE.Input.eventWorker[i].threadId != 0)\n                {\n                    TRACELOG(LOG_WARNING, \"RPI: Found duplicate touchscreen, killing touchscreen on event: %d\", i);\n                    pthread_cancel(CORE.Input.eventWorker[i].threadId);\n                    close(CORE.Input.eventWorker[i].fd);\n                }\n            }\n        }\n#endif\n    }\n    else close(fd);  // We are not interested in this device\n    //-------------------------------------------------------------------------------------------------------\n}\n\nstatic void PollKeyboardEvents(void)\n{\n    // Scancode to keycode mapping for US keyboards\n    // TODO: Replace this with a keymap from the X11 to get the correct regional map for the keyboard:\n    // Currently non US keyboards will have the wrong mapping for some keys\n    static const int keymapUS[] = {\n        0, 256, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61, 259, 258, 81, 87, 69, 82, 84,\n        89, 85, 73, 79, 80, 91, 93, 257, 341, 65, 83, 68, 70, 71, 72, 74, 75, 76, 59, 39, 96,\n        340, 92, 90, 88, 67, 86, 66, 78, 77, 44, 46, 47, 344, 332, 342, 32, 280, 290, 291,\n        292, 293, 294, 295, 296, 297, 298, 299, 282, 281, 327, 328, 329, 333, 324, 325,\n        326, 334, 321, 322, 323, 320, 330, 0, 85, 86, 300, 301, 89, 90, 91, 92, 93, 94, 95,\n        335, 345, 331, 283, 346, 101, 268, 265, 266, 263, 262, 269, 264, 267, 260, 261,\n        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 347, 127,\n        128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\n        144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n        160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\n        176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\n        192, 193, 194, 0, 0, 0, 0, 0, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,\n        211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,\n        227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,\n        243, 244, 245, 246, 247, 248, 0, 0, 0, 0, 0, 0, 0\n    };\n\n    int fd = CORE.Input.Keyboard.fd;\n    if (fd == -1) return;\n\n    struct input_event event = { 0 };\n    int keycode = -1;\n\n    // Try to read data from the keyboard and only continue if successful\n    while (read(fd, &event, sizeof(event)) == (int)sizeof(event))\n    {\n        // Button parsing\n        if (event.type == EV_KEY)\n        {\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\n            // Change keyboard mode to events\n            CORE.Input.Keyboard.evtMode = true;\n#endif\n            // Keyboard button parsing\n            if ((event.code >= 1) && (event.code <= 255))     //Keyboard keys appear for codes 1 to 255\n            {\n                keycode = keymapUS[event.code & 0xFF];     // The code we get is a scancode so we look up the apropriate keycode\n\n                // Make sure we got a valid keycode\n                if ((keycode > 0) && (keycode < sizeof(CORE.Input.Keyboard.currentKeyState)))\n                {\n                    // WARNING: https://www.kernel.org/doc/Documentation/input/input.txt\n                    // Event interface: 'value' is the value the event carries. Either a relative change for EV_REL,\n                    // absolute new value for EV_ABS (joysticks ...), or 0 for EV_KEY for release, 1 for keypress and 2 for autorepeat\n                    CORE.Input.Keyboard.currentKeyState[keycode] = (event.value >= 1)? 1 : 0;\n                    if (event.value >= 1)\n                    {\n                        CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;     // Register last key pressed\n                        CORE.Input.Keyboard.keyPressedQueueCount++;\n                    }\n\n                #if defined(SUPPORT_SCREEN_CAPTURE)\n                    // Check screen capture key (raylib key: KEY_F12)\n                    if (CORE.Input.Keyboard.currentKeyState[301] == 1)\n                    {\n                        TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n                        screenshotCounter++;\n                    }\n                #endif\n\n                    if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;\n\n                    TRACELOGD(\"RPI: KEY_%s ScanCode: %4i KeyCode: %4i\", event.value == 0 ? \"UP\":\"DOWN\", event.code, keycode);\n                }\n            }\n        }\n    }\n}\n\n// Input device events reading thread\nstatic void *EventThread(void *arg)\n{\n    struct input_event event = { 0 };\n    InputEventWorker *worker = (InputEventWorker *)arg;\n\n    int touchAction = -1;           // 0-TOUCH_ACTION_UP, 1-TOUCH_ACTION_DOWN, 2-TOUCH_ACTION_MOVE\n    bool gestureUpdate = false;     // Flag to note gestures require to update\n\n    while (!CORE.Window.shouldClose)\n    {\n        // Try to read data from the device and only continue if successful\n        while (read(worker->fd, &event, sizeof(event)) == (int)sizeof(event))\n        {\n            // Relative movement parsing\n            if (event.type == EV_REL)\n            {\n                if (event.code == REL_X)\n                {\n                    CORE.Input.Mouse.currentPosition.x += event.value;\n                    CORE.Input.Touch.position[0].x = CORE.Input.Mouse.currentPosition.x;\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                if (event.code == REL_Y)\n                {\n                    CORE.Input.Mouse.currentPosition.y += event.value;\n                    CORE.Input.Touch.position[0].y = CORE.Input.Mouse.currentPosition.y;\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                if (event.code == REL_WHEEL) CORE.Input.Mouse.currentWheelMove.y += event.value;\n            }\n\n            // Absolute movement parsing\n            if (event.type == EV_ABS)\n            {\n                // Basic movement\n                if (event.code == ABS_X)\n                {\n                    CORE.Input.Mouse.currentPosition.x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale acording to absRange\n                    CORE.Input.Touch.position[0].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;        // Scale acording to absRange\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                if (event.code == ABS_Y)\n                {\n                    CORE.Input.Mouse.currentPosition.y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale acording to absRange\n                    CORE.Input.Touch.position[0].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;      // Scale acording to absRange\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                // Multitouch movement\n                if (event.code == ABS_MT_SLOT) worker->touchSlot = event.value;   // Remember the slot number for the folowing events\n\n                if (event.code == ABS_MT_POSITION_X)\n                {\n                    if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale acording to absRange\n                }\n\n                if (event.code == ABS_MT_POSITION_Y)\n                {\n                    if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale acording to absRange\n                }\n\n                if (event.code == ABS_MT_TRACKING_ID)\n                {\n                    if ((event.value < 0) && (worker->touchSlot < MAX_TOUCH_POINTS))\n                    {\n                        // Touch has ended for this point\n                        CORE.Input.Touch.position[worker->touchSlot].x = -1;\n                        CORE.Input.Touch.position[worker->touchSlot].y = -1;\n                    }\n                }\n\n                // Touchscreen tap\n                if (event.code == ABS_PRESSURE)\n                {\n                    int previousMouseLeftButtonState = CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT];\n\n                    if (!event.value && previousMouseLeftButtonState)\n                    {\n                        CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 0;\n\n                        touchAction = 0;    // TOUCH_ACTION_UP\n                        gestureUpdate = true;\n                    }\n\n                    if (event.value && !previousMouseLeftButtonState)\n                    {\n                        CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 1;\n\n                        touchAction = 1;    // TOUCH_ACTION_DOWN\n                        gestureUpdate = true;\n                    }\n                }\n\n            }\n\n            // Button parsing\n            if (event.type == EV_KEY)\n            {\n                // Mouse button parsing\n                if ((event.code == BTN_TOUCH) || (event.code == BTN_LEFT))\n                {\n                    CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = event.value;\n\n                    if (event.value > 0) touchAction = 1;   // TOUCH_ACTION_DOWN\n                    else touchAction = 0;       // TOUCH_ACTION_UP\n                    gestureUpdate = true;\n                }\n\n                if (event.code == BTN_RIGHT) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_RIGHT] = event.value;\n                if (event.code == BTN_MIDDLE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_MIDDLE] = event.value;\n                if (event.code == BTN_SIDE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_SIDE] = event.value;\n                if (event.code == BTN_EXTRA) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_EXTRA] = event.value;\n                if (event.code == BTN_FORWARD) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_FORWARD] = event.value;\n                if (event.code == BTN_BACK) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_BACK] = event.value;\n            }\n\n            // Screen confinement\n            if (!CORE.Input.Mouse.cursorHidden)\n            {\n                if (CORE.Input.Mouse.currentPosition.x < 0) CORE.Input.Mouse.currentPosition.x = 0;\n                if (CORE.Input.Mouse.currentPosition.x > CORE.Window.screen.width/CORE.Input.Mouse.scale.x) CORE.Input.Mouse.currentPosition.x = CORE.Window.screen.width/CORE.Input.Mouse.scale.x;\n\n                if (CORE.Input.Mouse.currentPosition.y < 0) CORE.Input.Mouse.currentPosition.y = 0;\n                if (CORE.Input.Mouse.currentPosition.y > CORE.Window.screen.height/CORE.Input.Mouse.scale.y) CORE.Input.Mouse.currentPosition.y = CORE.Window.screen.height/CORE.Input.Mouse.scale.y;\n            }\n\n#if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_RPI, PLATFORM_DRM\n            if (gestureUpdate)\n            {\n                GestureEvent gestureEvent = { 0 };\n\n                gestureEvent.pointCount = 0;\n                gestureEvent.touchAction = touchAction;\n\n                if (CORE.Input.Touch.position[0].x >= 0) gestureEvent.pointCount++;\n                if (CORE.Input.Touch.position[1].x >= 0) gestureEvent.pointCount++;\n                if (CORE.Input.Touch.position[2].x >= 0) gestureEvent.pointCount++;\n                if (CORE.Input.Touch.position[3].x >= 0) gestureEvent.pointCount++;\n\n                gestureEvent.pointId[0] = 0;\n                gestureEvent.pointId[1] = 1;\n                gestureEvent.pointId[2] = 2;\n                gestureEvent.pointId[3] = 3;\n\n                gestureEvent.position[0] = CORE.Input.Touch.position[0];\n                gestureEvent.position[1] = CORE.Input.Touch.position[1];\n                gestureEvent.position[2] = CORE.Input.Touch.position[2];\n                gestureEvent.position[3] = CORE.Input.Touch.position[3];\n\n                ProcessGestureEvent(gestureEvent);\n            }\n#endif\n        }\n\n        WaitTime(0.005);    // Sleep for 5ms to avoid hogging CPU time\n    }\n\n    close(worker->fd);\n\n    return NULL;\n}\n\n// Initialize gamepad system\nstatic void InitGamepad(void)\n{\n    char gamepadDev[128] = { 0 };\n\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        sprintf(gamepadDev, \"%s%i\", DEFAULT_GAMEPAD_DEV, i);\n\n        if ((CORE.Input.Gamepad.streamId[i] = open(gamepadDev, O_RDONLY | O_NONBLOCK)) < 0)\n        {\n            // NOTE: Only show message for first gamepad\n            if (i == 0) TRACELOG(LOG_WARNING, \"RPI: Failed to open Gamepad device, no gamepad available\");\n        }\n        else\n        {\n            CORE.Input.Gamepad.ready[i] = true;\n\n            // NOTE: Only create one thread\n            if (i == 0)\n            {\n                int error = pthread_create(&CORE.Input.Gamepad.threadId, NULL, &GamepadThread, NULL);\n\n                if (error != 0) TRACELOG(LOG_WARNING, \"RPI: Failed to create gamepad input event thread\");\n                else  TRACELOG(LOG_INFO, \"RPI: Gamepad device initialized successfully\");\n            }\n        }\n    }\n}\n\n// Process Gamepad (/dev/input/js0)\nstatic void *GamepadThread(void *arg)\n{\n    #define JS_EVENT_BUTTON         0x01    // Button pressed/released\n    #define JS_EVENT_AXIS           0x02    // Joystick axis moved\n    #define JS_EVENT_INIT           0x80    // Initial state of device\n\n    struct js_event {\n        unsigned int time;      // event timestamp in milliseconds\n        short value;            // event value\n        unsigned char type;     // event type\n        unsigned char number;   // event axis/button number\n    };\n\n    // Read gamepad event\n    struct js_event gamepadEvent = { 0 };\n\n    while (!CORE.Window.shouldClose)\n    {\n        for (int i = 0; i < MAX_GAMEPADS; i++)\n        {\n            if (read(CORE.Input.Gamepad.streamId[i], &gamepadEvent, sizeof(struct js_event)) == (int)sizeof(struct js_event))\n            {\n                gamepadEvent.type &= ~JS_EVENT_INIT;     // Ignore synthetic events\n\n                // Process gamepad events by type\n                if (gamepadEvent.type == JS_EVENT_BUTTON)\n                {\n                    //TRACELOG(LOG_WARNING, \"RPI: Gamepad button: %i, value: %i\", gamepadEvent.number, gamepadEvent.value);\n\n                    if (gamepadEvent.number < MAX_GAMEPAD_BUTTONS)\n                    {\n                        // 1 - button pressed, 0 - button released\n                        CORE.Input.Gamepad.currentButtonState[i][gamepadEvent.number] = (int)gamepadEvent.value;\n\n                        if ((int)gamepadEvent.value == 1) CORE.Input.Gamepad.lastButtonPressed = gamepadEvent.number;\n                        else CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN\n                    }\n                }\n                else if (gamepadEvent.type == JS_EVENT_AXIS)\n                {\n                    //TRACELOG(LOG_WARNING, \"RPI: Gamepad axis: %i, value: %i\", gamepadEvent.number, gamepadEvent.value);\n\n                    if (gamepadEvent.number < MAX_GAMEPAD_AXIS)\n                    {\n                        // NOTE: Scaling of gamepadEvent.value to get values between -1..1\n                        CORE.Input.Gamepad.axisState[i][gamepadEvent.number] = (float)gamepadEvent.value/32768;\n                    }\n                }\n            }\n            else WaitTime(0.001);    // Sleep for 1 ms to avoid hogging CPU time\n        }\n    }\n\n    return NULL;\n}\n#endif  // PLATFORM_RPI || PLATFORM_DRM\n\n#if defined(PLATFORM_DRM)\n// Search matching DRM mode in connector's mode list\nstatic int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode)\n{\n    if (NULL == connector) return -1;\n    if (NULL == mode) return -1;\n\n    // safe bitwise comparison of two modes\n    #define BINCMP(a, b) memcmp((a), (b), (sizeof(a) < sizeof(b)) ? sizeof(a) : sizeof(b))\n\n    for (size_t i = 0; i < connector->count_modes; i++)\n    {\n        TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, connector->modes[i].hdisplay, connector->modes[i].vdisplay,\n            connector->modes[i].vrefresh, (connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");\n\n        if (0 == BINCMP(&CORE.Window.crtc->mode, &CORE.Window.connector->modes[i])) return i;\n    }\n\n    return -1;\n\n    #undef BINCMP\n}\n\n// Search exactly matching DRM connector mode in connector's list\nstatic int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)\n{\n    TRACELOG(LOG_TRACE, \"DISPLAY: Searching exact connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced ? \"yes\" : \"no\");\n\n    if (NULL == connector) return -1;\n\n    for (int i = 0; i < CORE.Window.connector->count_modes; i++)\n    {\n        const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];\n\n        TRACELOG(LOG_TRACE, \"DISPLAY: DRM Mode %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh, (mode->flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");\n\n        if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced)) continue;\n\n        if ((mode->hdisplay == width) && (mode->vdisplay == height) && (mode->vrefresh == fps)) return i;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: No DRM exact matching mode found\");\n    return -1;\n}\n\n// Search the nearest matching DRM connector mode in connector's list\nstatic int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)\n{\n    TRACELOG(LOG_TRACE, \"DISPLAY: Searching nearest connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced ? \"yes\" : \"no\");\n\n    if (NULL == connector) return -1;\n\n    int nearestIndex = -1;\n    for (int i = 0; i < CORE.Window.connector->count_modes; i++)\n    {\n        const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];\n\n        TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh,\n            (mode->flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");\n\n        if ((mode->hdisplay < width) || (mode->vdisplay < height))\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode is too small\");\n            continue;\n        }\n\n        if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced))\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM shouldn't choose an interlaced mode\");\n            continue;\n        }\n\n        if (nearestIndex < 0)\n        {\n            nearestIndex = i;\n            continue;\n        }\n\n        const int widthDiff = abs(mode->hdisplay - width);\n        const int heightDiff = abs(mode->vdisplay - height);\n        const int fpsDiff = abs(mode->vrefresh - fps);\n\n        const int nearestWidthDiff = abs(CORE.Window.connector->modes[nearestIndex].hdisplay - width);\n        const int nearestHeightDiff = abs(CORE.Window.connector->modes[nearestIndex].vdisplay - height);\n        const int nearestFpsDiff = abs(CORE.Window.connector->modes[nearestIndex].vrefresh - fps);\n\n        if ((widthDiff < nearestWidthDiff) || (heightDiff < nearestHeightDiff) || (fpsDiff < nearestFpsDiff)) {\n            nearestIndex = i;\n        }\n    }\n\n    return nearestIndex;\n}\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n// NOTE: Loading happens over AutomationEvent *events\n// TODO: This system should probably be redesigned\nstatic void LoadAutomationEvents(const char *fileName)\n{\n    //unsigned char fileId[4] = { 0 };\n\n    // Load binary\n    /*\n    FILE *repFile = fopen(fileName, \"rb\");\n    fread(fileId, 1, 4, repFile);\n\n    if ((fileId[0] == 'r') && (fileId[1] == 'E') && (fileId[2] == 'P') && (fileId[1] == ' '))\n    {\n        fread(&eventCount, sizeof(int), 1, repFile);\n        TRACELOG(LOG_WARNING, \"Events loaded: %i\\n\", eventCount);\n        fread(events, sizeof(AutomationEvent), eventCount, repFile);\n    }\n\n    fclose(repFile);\n    */\n\n    // Load events (text file)\n    FILE *repFile = fopen(fileName, \"rt\");\n\n    if (repFile != NULL)\n    {\n        unsigned int count = 0;\n        char buffer[256] = { 0 };\n\n        fgets(buffer, 256, repFile);\n\n        while (!feof(repFile))\n        {\n            if (buffer[0] == 'c') sscanf(buffer, \"c %i\", &eventCount);\n            else if (buffer[0] == 'e')\n            {\n                sscanf(buffer, \"e %d %d %d %d %d\", &events[count].frame, &events[count].type,\n                       &events[count].params[0], &events[count].params[1], &events[count].params[2]);\n\n                count++;\n            }\n\n            fgets(buffer, 256, repFile);\n        }\n\n        if (count != eventCount) TRACELOG(LOG_WARNING, \"Events count provided is different than count\");\n\n        fclose(repFile);\n    }\n\n    TRACELOG(LOG_WARNING, \"Events loaded: %i\", eventCount);\n}\n\n// Export recorded events into a file\nstatic void ExportAutomationEvents(const char *fileName)\n{\n    unsigned char fileId[4] = \"rEP \";\n\n    // Save as binary\n    /*\n    FILE *repFile = fopen(fileName, \"wb\");\n    fwrite(fileId, sizeof(unsigned char), 4, repFile);\n    fwrite(&eventCount, sizeof(int), 1, repFile);\n    fwrite(events, sizeof(AutomationEvent), eventCount, repFile);\n    fclose(repFile);\n    */\n\n    // Export events as text\n    FILE *repFile = fopen(fileName, \"wt\");\n\n    if (repFile != NULL)\n    {\n        fprintf(repFile, \"# Automation events list\\n\");\n        fprintf(repFile, \"#    c <events_count>\\n\");\n        fprintf(repFile, \"#    e <frame> <event_type> <param0> <param1> <param2> // <event_type_name>\\n\");\n\n        fprintf(repFile, \"c %i\\n\", eventCount);\n        for (int i = 0; i < eventCount; i++)\n        {\n            fprintf(repFile, \"e %i %i %i %i %i // %s\\n\", events[i].frame, events[i].type,\n                    events[i].params[0], events[i].params[1], events[i].params[2], autoEventTypeName[events[i].type]);\n        }\n\n        fclose(repFile);\n    }\n}\n\n// EndDrawing() -> After PollInputEvents()\n// Check event in current frame and save into the events[i] array\nstatic void RecordAutomationEvent(unsigned int frame)\n{\n    for (int key = 0; key < MAX_KEYBOARD_KEYS; key++)\n    {\n        // INPUT_KEY_UP (only saved once)\n        if (CORE.Input.Keyboard.previousKeyState[key] && !CORE.Input.Keyboard.currentKeyState[key])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_KEY_UP;\n            events[eventCount].params[0] = key;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_KEY_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_KEY_DOWN\n        if (CORE.Input.Keyboard.currentKeyState[key])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_KEY_DOWN;\n            events[eventCount].params[0] = key;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_KEY_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n    }\n\n    for (int button = 0; button < MAX_MOUSE_BUTTONS; button++)\n    {\n        // INPUT_MOUSE_BUTTON_UP\n        if (CORE.Input.Mouse.previousButtonState[button] && !CORE.Input.Mouse.currentButtonState[button])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_MOUSE_BUTTON_UP;\n            events[eventCount].params[0] = button;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_BUTTON_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_MOUSE_BUTTON_DOWN\n        if (CORE.Input.Mouse.currentButtonState[button])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_MOUSE_BUTTON_DOWN;\n            events[eventCount].params[0] = button;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_BUTTON_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n    }\n\n    // INPUT_MOUSE_POSITION (only saved if changed)\n    if (((int)CORE.Input.Mouse.currentPosition.x != (int)CORE.Input.Mouse.previousPosition.x) ||\n        ((int)CORE.Input.Mouse.currentPosition.y != (int)CORE.Input.Mouse.previousPosition.y))\n    {\n        events[eventCount].frame = frame;\n        events[eventCount].type = INPUT_MOUSE_POSITION;\n        events[eventCount].params[0] = (int)CORE.Input.Mouse.currentPosition.x;\n        events[eventCount].params[1] = (int)CORE.Input.Mouse.currentPosition.y;\n        events[eventCount].params[2] = 0;\n\n        TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_POSITION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n        eventCount++;\n    }\n\n    // INPUT_MOUSE_WHEEL_MOTION\n    if (((int)CORE.Input.Mouse.currentWheelMove.x != (int)CORE.Input.Mouse.previousWheelMove.x) ||\n        ((int)CORE.Input.Mouse.currentWheelMove.y != (int)CORE.Input.Mouse.previousWheelMove.y))\n    {\n        events[eventCount].frame = frame;\n        events[eventCount].type = INPUT_MOUSE_WHEEL_MOTION;\n        events[eventCount].params[0] = (int)CORE.Input.Mouse.currentWheelMove.x;\n        events[eventCount].params[1] = (int)CORE.Input.Mouse.currentWheelMove.y;;\n        events[eventCount].params[2] = 0;\n\n        TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_WHEEL_MOTION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n        eventCount++;\n    }\n\n    for (int id = 0; id < MAX_TOUCH_POINTS; id++)\n    {\n        // INPUT_TOUCH_UP\n        if (CORE.Input.Touch.previousTouchState[id] && !CORE.Input.Touch.currentTouchState[id])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_TOUCH_UP;\n            events[eventCount].params[0] = id;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_TOUCH_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_TOUCH_DOWN\n        if (CORE.Input.Touch.currentTouchState[id])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_TOUCH_DOWN;\n            events[eventCount].params[0] = id;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_TOUCH_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_TOUCH_POSITION\n        // TODO: It requires the id!\n        /*\n        if (((int)CORE.Input.Touch.currentPosition[id].x != (int)CORE.Input.Touch.previousPosition[id].x) ||\n            ((int)CORE.Input.Touch.currentPosition[id].y != (int)CORE.Input.Touch.previousPosition[id].y))\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_TOUCH_POSITION;\n            events[eventCount].params[0] = id;\n            events[eventCount].params[1] = (int)CORE.Input.Touch.currentPosition[id].x;\n            events[eventCount].params[2] = (int)CORE.Input.Touch.currentPosition[id].y;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_TOUCH_POSITION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n        */\n    }\n\n    for (int gamepad = 0; gamepad < MAX_GAMEPADS; gamepad++)\n    {\n        // INPUT_GAMEPAD_CONNECT\n        /*\n        if ((CORE.Input.Gamepad.currentState[gamepad] != CORE.Input.Gamepad.previousState[gamepad]) &&\n            (CORE.Input.Gamepad.currentState[gamepad] == true)) // Check if changed to ready\n        {\n            // TODO: Save gamepad connect event\n        }\n        */\n\n        // INPUT_GAMEPAD_DISCONNECT\n        /*\n        if ((CORE.Input.Gamepad.currentState[gamepad] != CORE.Input.Gamepad.previousState[gamepad]) &&\n            (CORE.Input.Gamepad.currentState[gamepad] == false)) // Check if changed to not-ready\n        {\n            // TODO: Save gamepad disconnect event\n        }\n        */\n\n        for (int button = 0; button < MAX_GAMEPAD_BUTTONS; button++)\n        {\n            // INPUT_GAMEPAD_BUTTON_UP\n            if (CORE.Input.Gamepad.previousButtonState[gamepad][button] && !CORE.Input.Gamepad.currentButtonState[gamepad][button])\n            {\n                events[eventCount].frame = frame;\n                events[eventCount].type = INPUT_GAMEPAD_BUTTON_UP;\n                events[eventCount].params[0] = gamepad;\n                events[eventCount].params[1] = button;\n                events[eventCount].params[2] = 0;\n\n                TRACELOG(LOG_INFO, \"[%i] INPUT_GAMEPAD_BUTTON_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n                eventCount++;\n            }\n\n            // INPUT_GAMEPAD_BUTTON_DOWN\n            if (CORE.Input.Gamepad.currentButtonState[gamepad][button])\n            {\n                events[eventCount].frame = frame;\n                events[eventCount].type = INPUT_GAMEPAD_BUTTON_DOWN;\n                events[eventCount].params[0] = gamepad;\n                events[eventCount].params[1] = button;\n                events[eventCount].params[2] = 0;\n\n                TRACELOG(LOG_INFO, \"[%i] INPUT_GAMEPAD_BUTTON_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n                eventCount++;\n            }\n        }\n\n        for (int axis = 0; axis < MAX_GAMEPAD_AXIS; axis++)\n        {\n            // INPUT_GAMEPAD_AXIS_MOTION\n            if (CORE.Input.Gamepad.axisState[gamepad][axis] > 0.1f)\n            {\n                events[eventCount].frame = frame;\n                events[eventCount].type = INPUT_GAMEPAD_AXIS_MOTION;\n                events[eventCount].params[0] = gamepad;\n                events[eventCount].params[1] = axis;\n                events[eventCount].params[2] = (int)(CORE.Input.Gamepad.axisState[gamepad][axis]*32768.0f);\n\n                TRACELOG(LOG_INFO, \"[%i] INPUT_GAMEPAD_AXIS_MOTION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n                eventCount++;\n            }\n        }\n    }\n\n    // INPUT_GESTURE\n    if (GESTURES.current != GESTURE_NONE)\n    {\n        events[eventCount].frame = frame;\n        events[eventCount].type = INPUT_GESTURE;\n        events[eventCount].params[0] = GESTURES.current;\n        events[eventCount].params[1] = 0;\n        events[eventCount].params[2] = 0;\n\n        TRACELOG(LOG_INFO, \"[%i] INPUT_GESTURE: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n        eventCount++;\n    }\n}\n\n// Play automation event\nstatic void PlayAutomationEvent(unsigned int frame)\n{\n    for (unsigned int i = 0; i < eventCount; i++)\n    {\n        if (events[i].frame == frame)\n        {\n            switch (events[i].type)\n            {\n                // Input events\n                case INPUT_KEY_UP: CORE.Input.Keyboard.currentKeyState[events[i].params[0]] = false; break;             // param[0]: key\n                case INPUT_KEY_DOWN: CORE.Input.Keyboard.currentKeyState[events[i].params[0]] = true; break;            // param[0]: key\n                case INPUT_MOUSE_BUTTON_UP: CORE.Input.Mouse.currentButtonState[events[i].params[0]] = false; break;    // param[0]: key\n                case INPUT_MOUSE_BUTTON_DOWN: CORE.Input.Mouse.currentButtonState[events[i].params[0]] = true; break;   // param[0]: key\n                case INPUT_MOUSE_POSITION:      // param[0]: x, param[1]: y\n                {\n                    CORE.Input.Mouse.currentPosition.x = (float)events[i].params[0];\n                    CORE.Input.Mouse.currentPosition.y = (float)events[i].params[1];\n                } break;\n                case INPUT_MOUSE_WHEEL_MOTION:  // param[0]: x delta, param[1]: y delta\n                {\n                    CORE.Input.Mouse.currentWheelMove.x = (float)events[i].params[0]; break;\n                    CORE.Input.Mouse.currentWheelMove.y = (float)events[i].params[1]; break;\n                } break;\n                case INPUT_TOUCH_UP: CORE.Input.Touch.currentTouchState[events[i].params[0]] = false; break;            // param[0]: id\n                case INPUT_TOUCH_DOWN: CORE.Input.Touch.currentTouchState[events[i].params[0]] = true; break;           // param[0]: id\n                case INPUT_TOUCH_POSITION:      // param[0]: id, param[1]: x, param[2]: y\n                {\n                    CORE.Input.Touch.position[events[i].params[0]].x = (float)events[i].params[1];\n                    CORE.Input.Touch.position[events[i].params[0]].y = (float)events[i].params[2];\n                } break;\n                case INPUT_GAMEPAD_CONNECT: CORE.Input.Gamepad.ready[events[i].params[0]] = true; break;                // param[0]: gamepad\n                case INPUT_GAMEPAD_DISCONNECT: CORE.Input.Gamepad.ready[events[i].params[0]] = false; break;            // param[0]: gamepad\n                case INPUT_GAMEPAD_BUTTON_UP: CORE.Input.Gamepad.currentButtonState[events[i].params[0]][events[i].params[1]] = false; break;    // param[0]: gamepad, param[1]: button\n                case INPUT_GAMEPAD_BUTTON_DOWN: CORE.Input.Gamepad.currentButtonState[events[i].params[0]][events[i].params[1]] = true; break;   // param[0]: gamepad, param[1]: button\n                case INPUT_GAMEPAD_AXIS_MOTION: // param[0]: gamepad, param[1]: axis, param[2]: delta\n                {\n                    CORE.Input.Gamepad.axisState[events[i].params[0]][events[i].params[1]] = ((float)events[i].params[2]/32768.0f);\n                } break;\n                case INPUT_GESTURE: GESTURES.current = events[i].params[0]; break;     // param[0]: gesture (enum Gesture) -> rgestures.h: GESTURES.current\n\n                // Window events\n                case WINDOW_CLOSE: CORE.Window.shouldClose = true; break;\n                case WINDOW_MAXIMIZE: MaximizeWindow(); break;\n                case WINDOW_MINIMIZE: MinimizeWindow(); break;\n                case WINDOW_RESIZE: SetWindowSize(events[i].params[0], events[i].params[1]); break;\n\n                // Custom events\n                case ACTION_TAKE_SCREENSHOT:\n                {\n                    TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n                    screenshotCounter++;\n                } break;\n                case ACTION_SETTARGETFPS: SetTargetFPS(events[i].params[0]); break;\n                default: break;\n            }\n        }\n    }\n}\n#endif\n\n#if !defined(SUPPORT_MODULE_RTEXT)\n// Formatting of text with variables to 'embed'\n// WARNING: String returned will expire after this function is called MAX_TEXTFORMAT_BUFFERS times\nconst char *TextFormat(const char *text, ...)\n{\n#ifndef MAX_TEXTFORMAT_BUFFERS\n    #define MAX_TEXTFORMAT_BUFFERS      4        // Maximum number of static buffers for text formatting\n#endif\n#ifndef MAX_TEXT_BUFFER_LENGTH\n    #define MAX_TEXT_BUFFER_LENGTH   1024        // Maximum size of static text buffer\n#endif\n\n    // We create an array of buffers so strings don't expire until MAX_TEXTFORMAT_BUFFERS invocations\n    static char buffers[MAX_TEXTFORMAT_BUFFERS][MAX_TEXT_BUFFER_LENGTH] = { 0 };\n    static int index = 0;\n\n    char *currentBuffer = buffers[index];\n    memset(currentBuffer, 0, MAX_TEXT_BUFFER_LENGTH);   // Clear buffer before using\n\n    va_list args;\n    va_start(args, text);\n    vsnprintf(currentBuffer, MAX_TEXT_BUFFER_LENGTH, text, args);\n    va_end(args);\n\n    index += 1;     // Move to next buffer for next function call\n    if (index >= MAX_TEXTFORMAT_BUFFERS) index = 0;\n\n    return currentBuffer;\n}\n#endif // !SUPPORT_MODULE_RTEXT\n"], "fixing_code": ["/**********************************************************************************************\n*\n*   rcore - Basic functions to manage windows, OpenGL context and input on multiple platforms\n*\n*   PLATFORMS SUPPORTED:\n*       - PLATFORM_DESKTOP: Windows (Win32, Win64)\n*       - PLATFORM_DESKTOP: Linux (X11 desktop mode)\n*       - PLATFORM_DESKTOP: FreeBSD, OpenBSD, NetBSD, DragonFly (X11 desktop)\n*       - PLATFORM_DESKTOP: OSX/macOS\n*       - PLATFORM_ANDROID: Android (ARM, ARM64)\n*       - PLATFORM_RPI:     Raspberry Pi 0,1,2,3 (Raspbian, native mode)\n*       - PLATFORM_DRM:     Linux native mode, including Raspberry Pi 4 with V3D fkms driver\n*       - PLATFORM_WEB:     HTML5 with WebAssembly\n*\n*   CONFIGURATION:\n*\n*   #define PLATFORM_DESKTOP\n*       Windowing and input system configured for desktop platforms: Windows, Linux, OSX, FreeBSD, OpenBSD, NetBSD, DragonFly\n*       NOTE: Oculus Rift CV1 requires PLATFORM_DESKTOP for mirror rendering - View [rlgl] module to enable it\n*\n*   #define PLATFORM_ANDROID\n*       Windowing and input system configured for Android device, app activity managed internally in this module.\n*       NOTE: OpenGL ES 2.0 is required and graphic device is managed by EGL\n*\n*   #define PLATFORM_RPI (deprecated - RPI OS Buster only)\n*       Windowing and input system configured for Raspberry Pi in native mode (no XWindow required),\n*       graphic device is managed by EGL and inputs are processed is raw mode, reading from /dev/input/\n*       WARNING: This platform is deprecated, since RPI OS Bullseye, the old Dispmanx libraries are not\n*       supported and you must be using PLATFORM_DRM\n*\n*   #define PLATFORM_DRM\n*       Windowing and input system configured for DRM native mode (RPI4 and other devices)\n*       graphic device is managed by EGL and inputs are processed is raw mode, reading from /dev/input/\n*\n*   #define PLATFORM_WEB\n*       Windowing and input system configured for HTML5 (run on browser), code converted from C to asm.js\n*       using emscripten compiler. OpenGL ES 2.0 required for direct translation to WebGL equivalent code.\n*\n*   #define SUPPORT_DEFAULT_FONT (default)\n*       Default font is loaded on window initialization to be available for the user to render simple text.\n*       NOTE: If enabled, uses external module functions to load default raylib font (module: text)\n*\n*   #define SUPPORT_CAMERA_SYSTEM\n*       Camera module is included (rcamera.h) and multiple predefined cameras are available: free, 1st/3rd person, orbital\n*\n*   #define SUPPORT_GESTURES_SYSTEM\n*       Gestures module is included (rgestures.h) to support gestures detection: tap, hold, swipe, drag\n*\n*   #define SUPPORT_MOUSE_GESTURES\n*       Mouse gestures are directly mapped like touches and processed by gestures system.\n*\n*   #define SUPPORT_TOUCH_AS_MOUSE\n*       Touch input and mouse input are shared. Mouse functions also return touch information.\n*\n*   #define SUPPORT_SSH_KEYBOARD_RPI (Raspberry Pi only)\n*       Reconfigure standard input to receive key inputs, works with SSH connection.\n*       WARNING: Reconfiguring standard input could lead to undesired effects, like breaking other running processes or\n*       blocking the device if not restored properly. Use with care.\n*\n*   #define SUPPORT_BUSY_WAIT_LOOP\n*       Use busy wait loop for timing sync, if not defined, a high-resolution timer is setup and used\n*\n*   #define SUPPORT_PARTIALBUSY_WAIT_LOOP\n*       Use a partial-busy wait loop, in this case frame sleeps for most of the time and runs a busy-wait-loop at the end\n*\n*   #define SUPPORT_EVENTS_WAITING\n*       Wait for events passively (sleeping while no events) instead of polling them actively every frame\n*\n*   #define SUPPORT_SCREEN_CAPTURE\n*       Allow automatic screen capture of current screen pressing F12, defined in KeyCallback()\n*\n*   #define SUPPORT_GIF_RECORDING\n*       Allow automatic gif recording of current screen pressing CTRL+F12, defined in KeyCallback()\n*\n*   #define SUPPORT_COMPRESSION_API\n*       Support CompressData() and DecompressData() functions, those functions use zlib implementation\n*       provided by stb_image and stb_image_write libraries, so, those libraries must be enabled on textures module\n*       for linkage\n*\n*   #define SUPPORT_EVENTS_AUTOMATION\n*       Support automatic generated events, loading and recording of those events when required\n*\n*   DEPENDENCIES:\n*       rglfw    - Manage graphic device, OpenGL context and inputs on PLATFORM_DESKTOP (Windows, Linux, OSX. FreeBSD, OpenBSD, NetBSD, DragonFly)\n*       raymath  - 3D math functionality (Vector2, Vector3, Matrix, Quaternion)\n*       camera   - Multiple 3D camera modes (free, orbital, 1st person, 3rd person)\n*       gestures - Gestures system for touch-ready devices (or simulated from mouse inputs)\n*\n*\n*   LICENSE: zlib/libpng\n*\n*   Copyright (c) 2013-2023 Ramon Santamaria (@raysan5)\n*\n*   This software is provided \"as-is\", without any express or implied warranty. In no event\n*   will the authors be held liable for any damages arising from the use of this software.\n*\n*   Permission is granted to anyone to use this software for any purpose, including commercial\n*   applications, and to alter it and redistribute it freely, subject to the following restrictions:\n*\n*     1. The origin of this software must not be misrepresented; you must not claim that you\n*     wrote the original software. If you use this software in a product, an acknowledgment\n*     in the product documentation would be appreciated but is not required.\n*\n*     2. Altered source versions must be plainly marked as such, and must not be misrepresented\n*     as being the original software.\n*\n*     3. This notice may not be removed or altered from any source distribution.\n*\n**********************************************************************************************/\n\n#include \"raylib.h\"                 // Declares module functions\n\n// Check if config flags have been externally provided on compilation line\n#if !defined(EXTERNAL_CONFIG_FLAGS)\n    #include \"config.h\"             // Defines module configuration flags\n#endif\n\n#include \"utils.h\"                  // Required for: TRACELOG() macros\n\n#define RLGL_IMPLEMENTATION\n#include \"rlgl.h\"                   // OpenGL abstraction layer to OpenGL 1.1, 3.3+ or ES2\n\n#define RAYMATH_IMPLEMENTATION      // Define external out-of-line implementation\n#include \"raymath.h\"                // Vector3, Quaternion and Matrix functionality\n\n#if defined(SUPPORT_GESTURES_SYSTEM)\n    #define GESTURES_IMPLEMENTATION\n    #include \"rgestures.h\"           // Gestures detection functionality\n#endif\n\n#if defined(SUPPORT_CAMERA_SYSTEM)\n    #define CAMERA_IMPLEMENTATION\n    #include \"rcamera.h\"             // Camera system functionality\n#endif\n\n#if defined(SUPPORT_GIF_RECORDING)\n    #define MSF_GIF_MALLOC(contextPointer, newSize) RL_MALLOC(newSize)\n    #define MSF_GIF_REALLOC(contextPointer, oldMemory, oldSize, newSize) RL_REALLOC(oldMemory, newSize)\n    #define MSF_GIF_FREE(contextPointer, oldMemory, oldSize) RL_FREE(oldMemory)\n\n    #define MSF_GIF_IMPL\n    #include \"external/msf_gif.h\"   // GIF recording functionality\n#endif\n\n#if defined(SUPPORT_COMPRESSION_API)\n    #define SINFL_IMPLEMENTATION\n    #define SINFL_NO_SIMD\n    #include \"external/sinfl.h\"     // Deflate (RFC 1951) decompressor\n\n    #define SDEFL_IMPLEMENTATION\n    #include \"external/sdefl.h\"     // Deflate (RFC 1951) compressor\n#endif\n\n#if (defined(__linux__) || defined(PLATFORM_WEB)) && (_POSIX_C_SOURCE < 199309L)\n    #undef _POSIX_C_SOURCE\n    #define _POSIX_C_SOURCE 199309L // Required for: CLOCK_MONOTONIC if compiled with c99 without gnu ext.\n#endif\n#if defined(__linux__) && !defined(_GNU_SOURCE)\n    #define _GNU_SOURCE\n#endif\n\n// Platform specific defines to handle GetApplicationDirectory()\n#if defined (PLATFORM_DESKTOP)\n    #if defined(_WIN32)\n        #ifndef MAX_PATH\n            #define MAX_PATH 1025\n        #endif\n    __declspec(dllimport) unsigned long __stdcall GetModuleFileNameA(void *hModule, void *lpFilename, unsigned long nSize);\n    __declspec(dllimport) unsigned long __stdcall GetModuleFileNameW(void *hModule, void *lpFilename, unsigned long nSize);\n    __declspec(dllimport) int __stdcall WideCharToMultiByte(unsigned int cp, unsigned long flags, void *widestr, int cchwide, void *str, int cbmb, void *defchar, int *used_default);\n    #elif defined(__linux__)\n        #include <unistd.h>\n    #elif defined(__APPLE__)\n        #include <sys/syslimits.h>\n        #include <mach-o/dyld.h>\n    #endif // OSs\n#endif // PLATFORM_DESKTOP\n\n#include <stdlib.h>                 // Required for: srand(), rand(), atexit()\n#include <stdio.h>                  // Required for: sprintf() [Used in OpenURL()]\n#include <string.h>                 // Required for: strrchr(), strcmp(), strlen(), memset()\n#include <time.h>                   // Required for: time() [Used in InitTimer()]\n#include <math.h>                   // Required for: tan() [Used in BeginMode3D()], atan2f() [Used in LoadVrStereoConfig()]\n\n#define _CRT_INTERNAL_NONSTDC_NAMES  1\n#include <sys/stat.h>               // Required for: stat(), S_ISREG [Used in GetFileModTime(), IsFilePath()]\n\n#if !defined(S_ISREG) && defined(S_IFMT) && defined(S_IFREG)\n    #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)\n#endif\n\n#if defined(PLATFORM_DESKTOP) && defined(_WIN32) && (defined(_MSC_VER) || defined(__TINYC__))\n    #define DIRENT_MALLOC RL_MALLOC\n    #define DIRENT_FREE RL_FREE\n\n    #include \"external/dirent.h\"    // Required for: DIR, opendir(), closedir() [Used in LoadDirectoryFiles()]\n#else\n    #include <dirent.h>             // Required for: DIR, opendir(), closedir() [Used in LoadDirectoryFiles()]\n#endif\n\n#if defined(_WIN32)\n    #include <direct.h>             // Required for: _getch(), _chdir()\n    #define GETCWD _getcwd          // NOTE: MSDN recommends not to use getcwd(), chdir()\n    #define CHDIR _chdir\n    #include <io.h>                 // Required for: _access() [Used in FileExists()]\n#else\n    #include <unistd.h>             // Required for: getch(), chdir() (POSIX), access()\n    #define GETCWD getcwd\n    #define CHDIR chdir\n#endif\n\n#if defined(PLATFORM_DESKTOP)\n    #define GLFW_INCLUDE_NONE       // Disable the standard OpenGL header inclusion on GLFW3\n                                    // NOTE: Already provided by rlgl implementation (on glad.h)\n    #include \"GLFW/glfw3.h\"         // GLFW3 library: Windows, OpenGL context and Input management\n                                    // NOTE: GLFW3 already includes gl.h (OpenGL) headers\n\n    // Support retrieving native window handlers\n    #if defined(_WIN32)\n        typedef void *PVOID;\n        typedef PVOID HANDLE;\n        typedef HANDLE HWND;\n        #define GLFW_EXPOSE_NATIVE_WIN32\n        #define GLFW_NATIVE_INCLUDE_NONE // To avoid some symbols re-definition in windows.h\n        #include \"GLFW/glfw3native.h\"\n\n        #if defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)\n            // NOTE: Those functions require linking with winmm library\n            unsigned int __stdcall timeBeginPeriod(unsigned int uPeriod);\n            unsigned int __stdcall timeEndPeriod(unsigned int uPeriod);\n        #endif\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        #include <sys/time.h>               // Required for: timespec, nanosleep(), select() - POSIX\n\n        //#define GLFW_EXPOSE_NATIVE_X11      // WARNING: Exposing Xlib.h > X.h results in dup symbols for Font type\n        //#define GLFW_EXPOSE_NATIVE_WAYLAND\n        //#define GLFW_EXPOSE_NATIVE_MIR\n        #include \"GLFW/glfw3native.h\"       // Required for: glfwGetX11Window()\n    #endif\n    #if defined(__APPLE__)\n        #include <unistd.h>                 // Required for: usleep()\n\n        //#define GLFW_EXPOSE_NATIVE_COCOA    // WARNING: Fails due to type redefinition\n        void *glfwGetCocoaWindow(GLFWwindow* handle);\n        #include \"GLFW/glfw3native.h\"       // Required for: glfwGetCocoaWindow()\n    #endif\n\n    // TODO: HACK: Added flag if not provided by GLFW when using external library\n    // Latest GLFW release (GLFW 3.3.8) does not implement this flag, it was added for 3.4.0-dev\n    #if !defined(GLFW_MOUSE_PASSTHROUGH)\n        #define GLFW_MOUSE_PASSTHROUGH      0x0002000D\n    #endif\n#endif\n\n#if defined(PLATFORM_ANDROID)\n    //#include <android/sensor.h>           // Required for: Android sensors functions (accelerometer, gyroscope, light...)\n    #include <android/window.h>             // Required for: AWINDOW_FLAG_FULLSCREEN definition and others\n    #include <android_native_app_glue.h>    // Required for: android_app struct and activity management\n    #include <jni.h>                        // Required for: JNIEnv and JavaVM [Used in OpenURL()]\n\n    #include <EGL/egl.h>                    // Native platform windowing system interface\n    //#include <GLES2/gl2.h>                // OpenGL ES 2.0 library (not required in this module, only in rlgl)\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    #include <fcntl.h>                  // POSIX file control definitions - open(), creat(), fcntl()\n    #include <unistd.h>                 // POSIX standard function definitions - read(), close(), STDIN_FILENO\n    #include <termios.h>                // POSIX terminal control definitions - tcgetattr(), tcsetattr()\n    #include <pthread.h>                // POSIX threads management (inputs reading)\n    #include <dirent.h>                 // POSIX directory browsing\n\n    #include <sys/ioctl.h>              // Required for: ioctl() - UNIX System call for device-specific input/output operations\n    #include <linux/kd.h>               // Linux: KDSKBMODE, K_MEDIUMRAM constants definition\n    #include <linux/input.h>            // Linux: Keycodes constants definition (KEY_A, ...)\n    #include <linux/joystick.h>         // Linux: Joystick support library\n\n#if defined(PLATFORM_RPI)\n    #include \"bcm_host.h\"               // Raspberry Pi VideoCore IV access functions\n#endif\n#if defined(PLATFORM_DRM)\n    #include <gbm.h>                    // Generic Buffer Management (native platform for EGL on DRM)\n    #include <xf86drm.h>                // Direct Rendering Manager user-level library interface\n    #include <xf86drmMode.h>            // Direct Rendering Manager mode setting (KMS) interface\n#endif\n\n    #include \"EGL/egl.h\"                // Native platform windowing system interface\n    #include \"EGL/eglext.h\"             // EGL extensions\n    //#include \"GLES2/gl2.h\"            // OpenGL ES 2.0 library (not required in this module, only in rlgl)\n#endif\n\n#if defined(PLATFORM_WEB)\n    #define GLFW_INCLUDE_ES2            // GLFW3: Enable OpenGL ES 2.0 (translated to WebGL)\n    #include \"GLFW/glfw3.h\"             // GLFW3: Windows, OpenGL context and Input management\n    #include <sys/time.h>               // Required for: timespec, nanosleep(), select() - POSIX\n\n    #include <emscripten/emscripten.h>  // Emscripten functionality for C\n    #include <emscripten/html5.h>       // Emscripten HTML5 library\n#endif\n\n//----------------------------------------------------------------------------------\n// Defines and Macros\n//----------------------------------------------------------------------------------\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    #define USE_LAST_TOUCH_DEVICE       // When multiple touchscreens are connected, only use the one with the highest event<N> number\n\n    #define DEFAULT_GAMEPAD_DEV    \"/dev/input/js\"  // Gamepad input (base dev for all gamepads: js0, js1, ...)\n    #define DEFAULT_EVDEV_PATH       \"/dev/input/\"  // Path to the linux input events\n#endif\n\n#ifndef MAX_FILEPATH_CAPACITY\n    #define MAX_FILEPATH_CAPACITY       8192        // Maximum capacity for filepath\n#endif\n#ifndef MAX_FILEPATH_LENGTH\n    #define MAX_FILEPATH_LENGTH         4096        // Maximum length for filepaths (Linux PATH_MAX default value)\n#endif\n\n#ifndef MAX_KEYBOARD_KEYS\n    #define MAX_KEYBOARD_KEYS            512        // Maximum number of keyboard keys supported\n#endif\n#ifndef MAX_MOUSE_BUTTONS\n    #define MAX_MOUSE_BUTTONS              8        // Maximum number of mouse buttons supported\n#endif\n#ifndef MAX_GAMEPADS\n    #define MAX_GAMEPADS                   4        // Maximum number of gamepads supported\n#endif\n#ifndef MAX_GAMEPAD_AXIS\n    #define MAX_GAMEPAD_AXIS               8        // Maximum number of axis supported (per gamepad)\n#endif\n#ifndef MAX_GAMEPAD_BUTTONS\n    #define MAX_GAMEPAD_BUTTONS           32        // Maximum number of buttons supported (per gamepad)\n#endif\n#ifndef MAX_TOUCH_POINTS\n    #define MAX_TOUCH_POINTS               8        // Maximum number of touch points supported\n#endif\n#ifndef MAX_KEY_PRESSED_QUEUE\n    #define MAX_KEY_PRESSED_QUEUE         16        // Maximum number of keys in the key input queue\n#endif\n#ifndef MAX_CHAR_PRESSED_QUEUE\n    #define MAX_CHAR_PRESSED_QUEUE        16        // Maximum number of characters in the char input queue\n#endif\n\n#ifndef MAX_DECOMPRESSION_SIZE\n    #define MAX_DECOMPRESSION_SIZE        64        // Maximum size allocated for decompression in MB\n#endif\n\n// Flags operation macros\n#define FLAG_SET(n, f) ((n) |= (f))\n#define FLAG_CLEAR(n, f) ((n) &= ~(f))\n#define FLAG_TOGGLE(n, f) ((n) ^= (f))\n#define FLAG_CHECK(n, f) ((n) & (f))\n\n//----------------------------------------------------------------------------------\n// Types and Structures Definition\n//----------------------------------------------------------------------------------\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\ntypedef struct {\n    pthread_t threadId;             // Event reading thread id\n    int fd;                         // File descriptor to the device it is assigned to\n    int eventNum;                   // Number of 'event<N>' device\n    Rectangle absRange;             // Range of values for absolute pointing devices (touchscreens)\n    int touchSlot;                  // Hold the touch slot number of the currently being sent multitouch block\n    bool isMouse;                   // True if device supports relative X Y movements\n    bool isTouch;                   // True if device supports absolute X Y movements and has BTN_TOUCH\n    bool isMultitouch;              // True if device supports multiple absolute movevents and has BTN_TOUCH\n    bool isKeyboard;                // True if device has letter keycodes\n    bool isGamepad;                 // True if device has gamepad buttons\n} InputEventWorker;\n#endif\n\ntypedef struct { int x; int y; } Point;\ntypedef struct { unsigned int width; unsigned int height; } Size;\n\n// Core global state context data\ntypedef struct CoreData {\n    struct {\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n        GLFWwindow *handle;                 // GLFW window handle (graphic device)\n#endif\n#if defined(PLATFORM_RPI)\n        EGL_DISPMANX_WINDOW_T handle;       // Native window handle (graphic device)\n#endif\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n#if defined(PLATFORM_DRM)\n        int fd;                             // File descriptor for /dev/dri/...\n        drmModeConnector *connector;        // Direct Rendering Manager (DRM) mode connector\n        drmModeCrtc *crtc;                  // CRT Controller\n        int modeIndex;                      // Index of the used mode of connector->modes\n        struct gbm_device *gbmDevice;       // GBM device\n        struct gbm_surface *gbmSurface;     // GBM surface\n        struct gbm_bo *prevBO;              // Previous GBM buffer object (during frame swapping)\n        uint32_t prevFB;                    // Previous GBM framebufer (during frame swapping)\n#endif  // PLATFORM_DRM\n        EGLDisplay device;                  // Native display device (physical screen connection)\n        EGLSurface surface;                 // Surface to draw on, framebuffers (connected to context)\n        EGLContext context;                 // Graphic context, mode in which drawing can be done\n        EGLConfig config;                   // Graphic config\n#endif\n        const char *title;                  // Window text title const pointer\n        unsigned int flags;                 // Configuration flags (bit based), keeps window state\n        bool ready;                         // Check if window has been initialized successfully\n        bool fullscreen;                    // Check if fullscreen mode is enabled\n        bool shouldClose;                   // Check if window set for closing\n        bool resizedLastFrame;              // Check if window has been resized last frame\n        bool eventWaiting;                  // Wait for events before ending frame\n\n        Point position;                     // Window position on screen (required on fullscreen toggle)\n        Size display;                       // Display width and height (monitor, device-screen, LCD, ...)\n        Size screen;                        // Screen width and height (used render area)\n        Size currentFbo;                    // Current render width and height (depends on active fbo)\n        Size render;                        // Framebuffer width and height (render area, including black bars if required)\n        Point renderOffset;                 // Offset from render area (must be divided by 2)\n        Matrix screenScale;                 // Matrix to scale screen (framebuffer rendering)\n\n        char **dropFilepaths;         // Store dropped files paths pointers (provided by GLFW)\n        unsigned int dropFileCount;         // Count dropped files strings\n\n    } Window;\n#if defined(PLATFORM_ANDROID)\n    struct {\n        bool appEnabled;                    // Flag to detect if app is active ** = true\n        struct android_app *app;            // Android activity\n        struct android_poll_source *source; // Android events polling source\n        bool contextRebindRequired;         // Used to know context rebind required\n    } Android;\n#endif\n    struct {\n        const char *basePath;               // Base path for data storage\n    } Storage;\n    struct {\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n        InputEventWorker eventWorker[10];   // List of worker threads for every monitored \"/dev/input/event<N>\"\n#endif\n        struct {\n            int exitKey;                    // Default exit key\n            char currentKeyState[MAX_KEYBOARD_KEYS];        // Registers current frame key state\n            char previousKeyState[MAX_KEYBOARD_KEYS];       // Registers previous frame key state\n\n            int keyPressedQueue[MAX_KEY_PRESSED_QUEUE];     // Input keys queue\n            int keyPressedQueueCount;       // Input keys queue count\n\n            int charPressedQueue[MAX_CHAR_PRESSED_QUEUE];   // Input characters queue (unicode)\n            int charPressedQueueCount;      // Input characters queue count\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n            int defaultMode;                // Default keyboard mode\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\n            bool evtMode;                   // Keyboard in event mode\n#endif\n            int defaultFileFlags;           // Default IO file flags\n            struct termios defaultSettings; // Default keyboard settings\n            int fd;                         // File descriptor for the evdev keyboard\n#endif\n        } Keyboard;\n        struct {\n            Vector2 offset;                 // Mouse offset\n            Vector2 scale;                  // Mouse scaling\n            Vector2 currentPosition;        // Mouse position on screen\n            Vector2 previousPosition;       // Previous mouse position\n\n            int cursor;                     // Tracks current mouse cursor\n            bool cursorHidden;              // Track if cursor is hidden\n            bool cursorOnScreen;            // Tracks if cursor is inside client area\n\n            char currentButtonState[MAX_MOUSE_BUTTONS];     // Registers current mouse button state\n            char previousButtonState[MAX_MOUSE_BUTTONS];    // Registers previous mouse button state\n            Vector2 currentWheelMove;       // Registers current mouse wheel variation\n            Vector2 previousWheelMove;      // Registers previous mouse wheel variation\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n            // NOTE: currentButtonState[] can't be written directly due to multithreading, app could miss the update\n            char currentButtonStateEvdev[MAX_MOUSE_BUTTONS]; // Holds the new mouse state for the next polling event to grab\n#endif\n        } Mouse;\n        struct {\n            int pointCount;                             // Number of touch points active\n            int pointId[MAX_TOUCH_POINTS];              // Point identifiers\n            Vector2 position[MAX_TOUCH_POINTS];         // Touch position on screen\n            char currentTouchState[MAX_TOUCH_POINTS];   // Registers current touch state\n            char previousTouchState[MAX_TOUCH_POINTS];  // Registers previous touch state\n        } Touch;\n        struct {\n            int lastButtonPressed;          // Register last gamepad button pressed\n            int axisCount;                  // Register number of available gamepad axis\n            bool ready[MAX_GAMEPADS];       // Flag to know if gamepad is ready\n            char name[MAX_GAMEPADS][64];    // Gamepad name holder\n            char currentButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];     // Current gamepad buttons state\n            char previousButtonState[MAX_GAMEPADS][MAX_GAMEPAD_BUTTONS];    // Previous gamepad buttons state\n            float axisState[MAX_GAMEPADS][MAX_GAMEPAD_AXIS];                // Gamepad axis state\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n            pthread_t threadId;             // Gamepad reading thread id\n            int streamId[MAX_GAMEPADS];     // Gamepad device file descriptor\n#endif\n        } Gamepad;\n    } Input;\n    struct {\n        double current;                     // Current time measure\n        double previous;                    // Previous time measure\n        double update;                      // Time measure for frame update\n        double draw;                        // Time measure for frame draw\n        double frame;                       // Time measure for one frame\n        double target;                      // Desired time for one frame, if 0 not applied\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n        unsigned long long base;            // Base time measure for hi-res timer\n#endif\n        unsigned int frameCounter;          // Frame counter\n    } Time;\n} CoreData;\n\n//----------------------------------------------------------------------------------\n// Global Variables Definition\n//----------------------------------------------------------------------------------\nRLAPI const char *raylib_version = RAYLIB_VERSION;  // raylib version exported symbol, required for some bindings\n\nstatic CoreData CORE = { 0 };               // Global CORE state context\n\n#if defined(SUPPORT_SCREEN_CAPTURE)\nstatic int screenshotCounter = 0;           // Screenshots counter\n#endif\n\n#if defined(SUPPORT_GIF_RECORDING)\nstatic int gifFrameCounter = 0;             // GIF frames counter\nstatic bool gifRecording = false;           // GIF recording state\nstatic MsfGifState gifState = { 0 };        // MSGIF context state\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n#define MAX_CODE_AUTOMATION_EVENTS      16384\n\ntypedef enum AutomationEventType {\n    EVENT_NONE = 0,\n    // Input events\n    INPUT_KEY_UP,                   // param[0]: key\n    INPUT_KEY_DOWN,                 // param[0]: key\n    INPUT_KEY_PRESSED,              // param[0]: key\n    INPUT_KEY_RELEASED,             // param[0]: key\n    INPUT_MOUSE_BUTTON_UP,          // param[0]: button\n    INPUT_MOUSE_BUTTON_DOWN,        // param[0]: button\n    INPUT_MOUSE_POSITION,           // param[0]: x, param[1]: y\n    INPUT_MOUSE_WHEEL_MOTION,       // param[0]: x delta, param[1]: y delta\n    INPUT_GAMEPAD_CONNECT,          // param[0]: gamepad\n    INPUT_GAMEPAD_DISCONNECT,       // param[0]: gamepad\n    INPUT_GAMEPAD_BUTTON_UP,        // param[0]: button\n    INPUT_GAMEPAD_BUTTON_DOWN,      // param[0]: button\n    INPUT_GAMEPAD_AXIS_MOTION,      // param[0]: axis, param[1]: delta\n    INPUT_TOUCH_UP,                 // param[0]: id\n    INPUT_TOUCH_DOWN,               // param[0]: id\n    INPUT_TOUCH_POSITION,           // param[0]: x, param[1]: y\n    INPUT_GESTURE,                  // param[0]: gesture\n    // Window events\n    WINDOW_CLOSE,                   // no params\n    WINDOW_MAXIMIZE,                // no params\n    WINDOW_MINIMIZE,                // no params\n    WINDOW_RESIZE,                  // param[0]: width, param[1]: height\n    // Custom events\n    ACTION_TAKE_SCREENSHOT,\n    ACTION_SETTARGETFPS\n} AutomationEventType;\n\n// Event type\n// Used to enable events flags\ntypedef enum {\n    EVENT_INPUT_KEYBOARD    = 0,\n    EVENT_INPUT_MOUSE       = 1,\n    EVENT_INPUT_GAMEPAD     = 2,\n    EVENT_INPUT_TOUCH       = 4,\n    EVENT_INPUT_GESTURE     = 8,\n    EVENT_WINDOW            = 16,\n    EVENT_CUSTOM            = 32\n} EventType;\n\nstatic const char *autoEventTypeName[] = {\n    \"EVENT_NONE\",\n    \"INPUT_KEY_UP\",\n    \"INPUT_KEY_DOWN\",\n    \"INPUT_KEY_PRESSED\",\n    \"INPUT_KEY_RELEASED\",\n    \"INPUT_MOUSE_BUTTON_UP\",\n    \"INPUT_MOUSE_BUTTON_DOWN\",\n    \"INPUT_MOUSE_POSITION\",\n    \"INPUT_MOUSE_WHEEL_MOTION\",\n    \"INPUT_GAMEPAD_CONNECT\",\n    \"INPUT_GAMEPAD_DISCONNECT\",\n    \"INPUT_GAMEPAD_BUTTON_UP\",\n    \"INPUT_GAMEPAD_BUTTON_DOWN\",\n    \"INPUT_GAMEPAD_AXIS_MOTION\",\n    \"INPUT_TOUCH_UP\",\n    \"INPUT_TOUCH_DOWN\",\n    \"INPUT_TOUCH_POSITION\",\n    \"INPUT_GESTURE\",\n    \"WINDOW_CLOSE\",\n    \"WINDOW_MAXIMIZE\",\n    \"WINDOW_MINIMIZE\",\n    \"WINDOW_RESIZE\",\n    \"ACTION_TAKE_SCREENSHOT\",\n    \"ACTION_SETTARGETFPS\"\n};\n\n// Automation Event (20 bytes)\ntypedef struct AutomationEvent {\n    unsigned int frame;                 // Event frame\n    unsigned int type;                  // Event type (AutoEventType)\n    int params[3];                      // Event parameters (if required)\n} AutomationEvent;\n\nstatic AutomationEvent *events = NULL;        // Events array\nstatic unsigned int eventCount = 0;     // Events count\nstatic bool eventsPlaying = false;      // Play events\nstatic bool eventsRecording = false;    // Record events\n\n//static short eventsEnabled = 0b0000001111111111;    // Events enabled for checking\n#endif\n//-----------------------------------------------------------------------------------\n\n//----------------------------------------------------------------------------------\n// Other Modules Functions Declaration (required by core)\n//----------------------------------------------------------------------------------\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\nextern void LoadFontDefault(void);          // [Module: text] Loads default font on InitWindow()\nextern void UnloadFontDefault(void);        // [Module: text] Unloads default font from GPU memory\n#endif\n\n//----------------------------------------------------------------------------------\n// Module specific Functions Declaration\n//----------------------------------------------------------------------------------\nstatic void InitTimer(void);                            // Initialize timer (hi-resolution if available)\nstatic bool InitGraphicsDevice(int width, int height);  // Initialize graphics device\nstatic void SetupFramebuffer(int width, int height);    // Setup main framebuffer\nstatic void SetupViewport(int width, int height);       // Set viewport for a provided width and height\n\nstatic void ScanDirectoryFiles(const char *basePath, FilePathList *list, const char *filter);   // Scan all files and directories in a base path\nstatic void ScanDirectoryFilesRecursively(const char *basePath, FilePathList *list, const char *filter);  // Scan all files and directories recursively from a base path\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\nstatic void ErrorCallback(int error, const char *description);                             // GLFW3 Error Callback, runs on GLFW3 error\n// Window callbacks events\nstatic void WindowSizeCallback(GLFWwindow *window, int width, int height);                 // GLFW3 WindowSize Callback, runs when window is resized\n#if !defined(PLATFORM_WEB)\nstatic void WindowMaximizeCallback(GLFWwindow* window, int maximized);                     // GLFW3 Window Maximize Callback, runs when window is maximized\n#endif\nstatic void WindowIconifyCallback(GLFWwindow *window, int iconified);                      // GLFW3 WindowIconify Callback, runs when window is minimized/restored\nstatic void WindowFocusCallback(GLFWwindow *window, int focused);                          // GLFW3 WindowFocus Callback, runs when window get/lose focus\nstatic void WindowDropCallback(GLFWwindow *window, int count, const char **paths);         // GLFW3 Window Drop Callback, runs when drop files into window\n// Input callbacks events\nstatic void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods);  // GLFW3 Keyboard Callback, runs on key pressed\nstatic void CharCallback(GLFWwindow *window, unsigned int key);                            // GLFW3 Char Key Callback, runs on key pressed (get char value)\nstatic void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods);     // GLFW3 Mouse Button Callback, runs on mouse button pressed\nstatic void MouseCursorPosCallback(GLFWwindow *window, double x, double y);                // GLFW3 Cursor Position Callback, runs on mouse move\nstatic void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset);       // GLFW3 Srolling Callback, runs on mouse wheel\nstatic void CursorEnterCallback(GLFWwindow *window, int enter);                            // GLFW3 Cursor Enter Callback, cursor enters client area\n#endif\n\n#if defined(PLATFORM_ANDROID)\nstatic void AndroidCommandCallback(struct android_app *app, int32_t cmd);                  // Process Android activity lifecycle commands\nstatic int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event);          // Process Android inputs\n#endif\n\n#if defined(PLATFORM_WEB)\nstatic EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData);\nstatic EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData);\nstatic EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData);\n\nstatic EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData);\nstatic EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData);\nstatic EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData);\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\nstatic void InitKeyboard(void);                         // Initialize raw keyboard system\nstatic void RestoreKeyboard(void);                      // Restore keyboard system\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\nstatic void ProcessKeyboard(void);                      // Process keyboard events\n#endif\n\nstatic void InitEvdevInput(void);                       // Initialize evdev inputs\nstatic void ConfigureEvdevDevice(char *device);         // Identifies a input device and configures it for use if appropriate\nstatic void PollKeyboardEvents(void);                   // Process evdev keyboard events.\nstatic void *EventThread(void *arg);                    // Input device events reading thread\n\nstatic void InitGamepad(void);                          // Initialize raw gamepad input\nstatic void *GamepadThread(void *arg);                  // Mouse reading thread\n\n#if defined(PLATFORM_DRM)\nstatic int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode);                               // Search matching DRM mode in connector's mode list\nstatic int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);      // Search exactly matching DRM connector mode in connector's list\nstatic int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced);    // Search the nearest matching DRM connector mode in connector's list\n#endif\n\n#endif  // PLATFORM_RPI || PLATFORM_DRM\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\nstatic void LoadAutomationEvents(const char *fileName);     // Load automation events from file\nstatic void ExportAutomationEvents(const char *fileName);   // Export recorded automation events into a file\nstatic void RecordAutomationEvent(unsigned int frame);      // Record frame events (to internal events array)\nstatic void PlayAutomationEvent(unsigned int frame);        // Play frame events (from internal events array)\n#endif\n\n#if defined(_WIN32)\n// NOTE: We declare Sleep() function symbol to avoid including windows.h (kernel32.lib linkage required)\nvoid __stdcall Sleep(unsigned long msTimeout);              // Required for: WaitTime()\n#endif\n\n#if !defined(SUPPORT_MODULE_RTEXT)\nconst char *TextFormat(const char *text, ...);       // Formatting of text with variables to 'embed'\n#endif // !SUPPORT_MODULE_RTEXT\n\n//----------------------------------------------------------------------------------\n// Module Functions Definition - Window and OpenGL Context Functions\n//----------------------------------------------------------------------------------\n#if defined(PLATFORM_ANDROID)\n// To allow easier porting to android, we allow the user to define a\n// main function which we call from android_main, defined by ourselves\nextern int main(int argc, char *argv[]);\n\nvoid android_main(struct android_app *app)\n{\n    char arg0[] = \"raylib\";     // NOTE: argv[] are mutable\n    CORE.Android.app = app;\n\n    // NOTE: Return codes != 0 are skipped\n    (void)main(1, (char *[]) { arg0, NULL });\n}\n\n// NOTE: Add this to header (if apps really need it)\nstruct android_app *GetAndroidApp(void)\n{\n    return CORE.Android.app;\n}\n#endif\n\n// Initialize window and OpenGL context\n// NOTE: data parameter could be used to pass any kind of required data to the initialization\nvoid InitWindow(int width, int height, const char *title)\n{\n    TRACELOG(LOG_INFO, \"Initializing raylib %s\", RAYLIB_VERSION);\n\n    TRACELOG(LOG_INFO, \"Supported raylib modules:\");\n    TRACELOG(LOG_INFO, \"    > rcore:..... loaded (mandatory)\");\n    TRACELOG(LOG_INFO, \"    > rlgl:...... loaded (mandatory)\");\n#if defined(SUPPORT_MODULE_RSHAPES)\n    TRACELOG(LOG_INFO, \"    > rshapes:... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rshapes:... not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    TRACELOG(LOG_INFO, \"    > rtextures:. loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rtextures:. not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RTEXT)\n    TRACELOG(LOG_INFO, \"    > rtext:..... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rtext:..... not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RMODELS)\n    TRACELOG(LOG_INFO, \"    > rmodels:... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > rmodels:... not loaded (optional)\");\n#endif\n#if defined(SUPPORT_MODULE_RAUDIO)\n    TRACELOG(LOG_INFO, \"    > raudio:.... loaded (optional)\");\n#else\n    TRACELOG(LOG_INFO, \"    > raudio:.... not loaded (optional)\");\n#endif\n\n    if ((title != NULL) && (title[0] != 0)) CORE.Window.title = title;\n\n    // Initialize global input state\n    memset(&CORE.Input, 0, sizeof(CORE.Input));\n    CORE.Input.Keyboard.exitKey = KEY_ESCAPE;\n    CORE.Input.Mouse.scale = (Vector2){ 1.0f, 1.0f };\n    CORE.Input.Mouse.cursor = MOUSE_CURSOR_ARROW;\n    CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN\n#if defined(SUPPORT_EVENTS_WAITING)\n    CORE.Window.eventWaiting = true;\n#endif\n\n#if defined(PLATFORM_ANDROID)\n    CORE.Window.screen.width = width;\n    CORE.Window.screen.height = height;\n    CORE.Window.currentFbo.width = width;\n    CORE.Window.currentFbo.height = height;\n\n    // Set desired windows flags before initializing anything\n    ANativeActivity_setWindowFlags(CORE.Android.app->activity, AWINDOW_FLAG_FULLSCREEN, 0);  //AWINDOW_FLAG_SCALED, AWINDOW_FLAG_DITHER\n\n    int orientation = AConfiguration_getOrientation(CORE.Android.app->config);\n\n    if (orientation == ACONFIGURATION_ORIENTATION_PORT) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as portrait\");\n    else if (orientation == ACONFIGURATION_ORIENTATION_LAND) TRACELOG(LOG_INFO, \"ANDROID: Window orientation set as landscape\");\n\n    // TODO: Automatic orientation doesn't seem to work\n    if (width <= height)\n    {\n        AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_PORT);\n        TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to portrait\");\n    }\n    else\n    {\n        AConfiguration_setOrientation(CORE.Android.app->config, ACONFIGURATION_ORIENTATION_LAND);\n        TRACELOG(LOG_WARNING, \"ANDROID: Window orientation changed to landscape\");\n    }\n\n    //AConfiguration_getDensity(CORE.Android.app->config);\n    //AConfiguration_getKeyboard(CORE.Android.app->config);\n    //AConfiguration_getScreenSize(CORE.Android.app->config);\n    //AConfiguration_getScreenLong(CORE.Android.app->config);\n\n    // Initialize App command system\n    // NOTE: On APP_CMD_INIT_WINDOW -> InitGraphicsDevice(), InitTimer(), LoadFontDefault()...\n    CORE.Android.app->onAppCmd = AndroidCommandCallback;\n\n    // Initialize input events system\n    CORE.Android.app->onInputEvent = AndroidInputCallback;\n\n    // Initialize assets manager\n    InitAssetManager(CORE.Android.app->activity->assetManager, CORE.Android.app->activity->internalDataPath);\n\n    // Initialize base path for storage\n    CORE.Storage.basePath = CORE.Android.app->activity->internalDataPath;\n\n    TRACELOG(LOG_INFO, \"ANDROID: App initialized successfully\");\n\n    // Android ALooper_pollAll() variables\n    int pollResult = 0;\n    int pollEvents = 0;\n\n    // Wait for window to be initialized (display and context)\n    while (!CORE.Window.ready)\n    {\n        // Process events loop\n        while ((pollResult = ALooper_pollAll(0, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)\n        {\n            // Process this event\n            if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);\n\n            // NOTE: Never close window, native activity is controlled by the system!\n            //if (CORE.Android.app->destroyRequested != 0) CORE.Window.shouldClose = true;\n        }\n    }\n#endif\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Initialize graphics device (display device and OpenGL context)\n    // NOTE: returns true if window and graphic device has been initialized successfully\n    CORE.Window.ready = InitGraphicsDevice(width, height);\n\n    // If graphic device is no properly initialized, we end program\n    if (!CORE.Window.ready)\n    {\n        TRACELOG(LOG_FATAL, \"Failed to initialize Graphic Device\");\n        return;\n    }\n    else SetWindowPosition(GetMonitorWidth(GetCurrentMonitor())/2 - CORE.Window.screen.width/2, GetMonitorHeight(GetCurrentMonitor())/2 - CORE.Window.screen.height/2);\n\n    // Initialize hi-res timer\n    InitTimer();\n\n    // Initialize random seed\n    srand((unsigned int)time(NULL));\n\n    // Initialize base path for storage\n    CORE.Storage.basePath = GetWorkingDirectory();\n\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n    // Load default font\n    // WARNING: External function: Module required: rtext\n    LoadFontDefault();\n    #if defined(SUPPORT_MODULE_RSHAPES)\n    Rectangle rec = GetFontDefault().recs[95];\n    // NOTE: We set up a 1px padding on char rectangle to avoid pixel bleeding on MSAA filtering\n    SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 }); // WARNING: Module required: rshapes\n    #endif\n#else\n    #if defined(SUPPORT_MODULE_RSHAPES)\n    // Set default texture and rectangle to be used for shapes drawing\n    // NOTE: rlgl default texture is a 1x1 pixel UNCOMPRESSED_R8G8B8A8\n    Texture2D texture = { rlGetTextureIdDefault(), 1, 1, 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n    SetShapesTexture(texture, (Rectangle){ 0.0f, 0.0f, 1.0f, 1.0f });    // WARNING: Module required: rshapes\n    #endif\n#endif\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        // Set default font texture filter for HighDPI (blurry)\n        // RL_TEXTURE_FILTER_LINEAR - tex filter: BILINEAR, no mipmaps\n        rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MIN_FILTER, RL_TEXTURE_FILTER_LINEAR);\n        rlTextureParameters(GetFontDefault().texture.id, RL_TEXTURE_MAG_FILTER, RL_TEXTURE_FILTER_LINEAR);\n    }\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Initialize raw input system\n    InitEvdevInput();   // Evdev inputs initialization\n    InitGamepad();      // Gamepad init\n    InitKeyboard();     // Keyboard init (stdin)\n#endif\n\n#if defined(PLATFORM_WEB)\n    // Setup callback funtions for the DOM events\n    emscripten_set_fullscreenchange_callback(\"#canvas\", NULL, 1, EmscriptenFullscreenChangeCallback);\n\n    // WARNING: Below resize code was breaking fullscreen mode for sample games and examples, it needs review\n    // Check fullscreen change events(note this is done on the window since most browsers don't support this on #canvas)\n    //emscripten_set_fullscreenchange_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, 1, EmscriptenResizeCallback);\n    // Check Resize event (note this is done on the window since most browsers don't support this on #canvas)\n    //emscripten_set_resize_callback(EMSCRIPTEN_EVENT_TARGET_WINDOW, NULL, 1, EmscriptenResizeCallback);\n    // Trigger this once to get initial window sizing\n    //EmscriptenResizeCallback(EMSCRIPTEN_EVENT_RESIZE, NULL, NULL);\n\n    // Support keyboard events -> Not used, GLFW.JS takes care of that\n    //emscripten_set_keypress_callback(\"#canvas\", NULL, 1, EmscriptenKeyboardCallback);\n    //emscripten_set_keydown_callback(\"#canvas\", NULL, 1, EmscriptenKeyboardCallback);\n\n    // Support mouse events\n    emscripten_set_click_callback(\"#canvas\", NULL, 1, EmscriptenMouseCallback);\n\n    // Support touch events\n    emscripten_set_touchstart_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n    emscripten_set_touchend_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n    emscripten_set_touchmove_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n    emscripten_set_touchcancel_callback(\"#canvas\", NULL, 1, EmscriptenTouchCallback);\n\n    // Support gamepad events (not provided by GLFW3 on emscripten)\n    emscripten_set_gamepadconnected_callback(NULL, 1, EmscriptenGamepadCallback);\n    emscripten_set_gamepaddisconnected_callback(NULL, 1, EmscriptenGamepadCallback);\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    events = (AutomationEvent *)malloc(MAX_CODE_AUTOMATION_EVENTS*sizeof(AutomationEvent));\n    CORE.Time.frameCounter = 0;\n#endif\n\n#endif        // PLATFORM_DESKTOP || PLATFORM_WEB || PLATFORM_RPI || PLATFORM_DRM\n}\n\n// Close window and unload OpenGL context\nvoid CloseWindow(void)\n{\n#if defined(SUPPORT_GIF_RECORDING)\n    if (gifRecording)\n    {\n        MsfGifResult result = msf_gif_end(&gifState);\n        msf_gif_free(result);\n        gifRecording = false;\n    }\n#endif\n\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n    UnloadFontDefault();        // WARNING: Module required: rtext\n#endif\n\n    rlglClose();                // De-init rlgl\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwDestroyWindow(CORE.Window.handle);\n    glfwTerminate();\n#endif\n\n#if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)\n    timeEndPeriod(1);           // Restore time period\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI)\n    // Close surface, context and display\n    if (CORE.Window.device != EGL_NO_DISPLAY)\n    {\n        eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n\n        if (CORE.Window.surface != EGL_NO_SURFACE)\n        {\n            eglDestroySurface(CORE.Window.device, CORE.Window.surface);\n            CORE.Window.surface = EGL_NO_SURFACE;\n        }\n\n        if (CORE.Window.context != EGL_NO_CONTEXT)\n        {\n            eglDestroyContext(CORE.Window.device, CORE.Window.context);\n            CORE.Window.context = EGL_NO_CONTEXT;\n        }\n\n        eglTerminate(CORE.Window.device);\n        CORE.Window.device = EGL_NO_DISPLAY;\n    }\n#endif\n\n#if defined(PLATFORM_DRM)\n    if (CORE.Window.prevFB)\n    {\n        drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);\n        CORE.Window.prevFB = 0;\n    }\n\n    if (CORE.Window.prevBO)\n    {\n        gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);\n        CORE.Window.prevBO = NULL;\n    }\n\n    if (CORE.Window.gbmSurface)\n    {\n        gbm_surface_destroy(CORE.Window.gbmSurface);\n        CORE.Window.gbmSurface = NULL;\n    }\n\n    if (CORE.Window.gbmDevice)\n    {\n        gbm_device_destroy(CORE.Window.gbmDevice);\n        CORE.Window.gbmDevice = NULL;\n    }\n\n    if (CORE.Window.crtc)\n    {\n        if (CORE.Window.connector)\n        {\n            drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, CORE.Window.crtc->buffer_id,\n                CORE.Window.crtc->x, CORE.Window.crtc->y, &CORE.Window.connector->connector_id, 1, &CORE.Window.crtc->mode);\n            drmModeFreeConnector(CORE.Window.connector);\n            CORE.Window.connector = NULL;\n        }\n\n        drmModeFreeCrtc(CORE.Window.crtc);\n        CORE.Window.crtc = NULL;\n    }\n\n    if (CORE.Window.fd != -1)\n    {\n        close(CORE.Window.fd);\n        CORE.Window.fd = -1;\n    }\n\n    // Close surface, context and display\n    if (CORE.Window.device != EGL_NO_DISPLAY)\n    {\n        if (CORE.Window.surface != EGL_NO_SURFACE)\n        {\n            eglDestroySurface(CORE.Window.device, CORE.Window.surface);\n            CORE.Window.surface = EGL_NO_SURFACE;\n        }\n\n        if (CORE.Window.context != EGL_NO_CONTEXT)\n        {\n            eglDestroyContext(CORE.Window.device, CORE.Window.context);\n            CORE.Window.context = EGL_NO_CONTEXT;\n        }\n\n        eglTerminate(CORE.Window.device);\n        CORE.Window.device = EGL_NO_DISPLAY;\n    }\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Wait for mouse and gamepad threads to finish before closing\n    // NOTE: Those threads should already have finished at this point\n    // because they are controlled by CORE.Window.shouldClose variable\n\n    CORE.Window.shouldClose = true;   // Added to force threads to exit when the close window is called\n\n    // Close the evdev keyboard\n    if (CORE.Input.Keyboard.fd != -1)\n    {\n        close(CORE.Input.Keyboard.fd);\n        CORE.Input.Keyboard.fd = -1;\n    }\n\n    for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n    {\n        if (CORE.Input.eventWorker[i].threadId)\n        {\n            pthread_join(CORE.Input.eventWorker[i].threadId, NULL);\n        }\n    }\n\n    if (CORE.Input.Gamepad.threadId) pthread_join(CORE.Input.Gamepad.threadId, NULL);\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    free(events);\n#endif\n\n    CORE.Window.ready = false;\n    TRACELOG(LOG_INFO, \"Window closed successfully\");\n}\n\n// Check if KEY_ESCAPE pressed or Close icon pressed\nbool WindowShouldClose(void)\n{\n#if defined(PLATFORM_WEB)\n    // Emterpreter-Async required to run sync code\n    // https://github.com/emscripten-core/emscripten/wiki/Emterpreter#emterpreter-async-run-synchronous-code\n    // By default, this function is never called on a web-ready raylib example because we encapsulate\n    // frame code in a UpdateDrawFrame() function, to allow browser manage execution asynchronously\n    // but now emscripten allows sync code to be executed in an interpreted way, using emterpreter!\n    emscripten_sleep(16);\n    return false;\n#endif\n\n#if defined(PLATFORM_DESKTOP)\n    if (CORE.Window.ready)\n    {\n        // While window minimized, stop loop execution\n        while (IsWindowState(FLAG_WINDOW_MINIMIZED) && !IsWindowState(FLAG_WINDOW_ALWAYS_RUN)) glfwWaitEvents();\n\n        CORE.Window.shouldClose = glfwWindowShouldClose(CORE.Window.handle);\n\n        // Reset close status for next frame\n        glfwSetWindowShouldClose(CORE.Window.handle, GLFW_FALSE);\n\n        return CORE.Window.shouldClose;\n    }\n    else return true;\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    if (CORE.Window.ready) return CORE.Window.shouldClose;\n    else return true;\n#endif\n}\n\n// Check if window has been initialized successfully\nbool IsWindowReady(void)\n{\n    return CORE.Window.ready;\n}\n\n// Check if window is currently fullscreen\nbool IsWindowFullscreen(void)\n{\n    return CORE.Window.fullscreen;\n}\n\n// Check if window is currently hidden\nbool IsWindowHidden(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0);\n#endif\n    return false;\n}\n\n// Check if window has been minimized\nbool IsWindowMinimized(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    return ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0);\n#endif\n    return false;\n}\n\n// Check if window has been maximized (only PLATFORM_DESKTOP)\nbool IsWindowMaximized(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0);\n#endif\n    return false;\n}\n\n// Check if window has the focus\nbool IsWindowFocused(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    return ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) == 0);\n#endif\n#if defined(PLATFORM_ANDROID)\n    return CORE.Android.appEnabled;\n#endif\n    return true;\n}\n\n// Check if window has been resizedLastFrame\nbool IsWindowResized(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    return CORE.Window.resizedLastFrame;\n#else\n    return false;\n#endif\n}\n\n// Check if one specific window flag is enabled\nbool IsWindowState(unsigned int flag)\n{\n    return ((CORE.Window.flags & flag) > 0);\n}\n\n// Toggle fullscreen mode (only PLATFORM_DESKTOP)\nvoid ToggleFullscreen(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (!CORE.Window.fullscreen)\n    {\n        // Store previous window position (in case we exit fullscreen)\n        glfwGetWindowPos(CORE.Window.handle, &CORE.Window.position.x, &CORE.Window.position.y);\n\n        int monitorCount = 0;\n        int monitorIndex = GetCurrentMonitor();\n        GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n        // Use current monitor, so we correctly get the display the window is on\n        GLFWmonitor *monitor = (monitorIndex < monitorCount)? monitors[monitorIndex] : NULL;\n\n        if (monitor == NULL)\n        {\n            TRACELOG(LOG_WARNING, \"GLFW: Failed to get monitor\");\n\n            CORE.Window.fullscreen = false;\n            CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;\n\n            glfwSetWindowMonitor(CORE.Window.handle, NULL, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n        }\n        else\n        {\n            CORE.Window.fullscreen = true;\n            CORE.Window.flags |= FLAG_FULLSCREEN_MODE;\n\n            glfwSetWindowMonitor(CORE.Window.handle, monitor, 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n        }\n    }\n    else\n    {\n        CORE.Window.fullscreen = false;\n        CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;\n\n        glfwSetWindowMonitor(CORE.Window.handle, NULL, CORE.Window.position.x, CORE.Window.position.y, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n    }\n\n    // Try to enable GPU V-Sync, so frames are limited to screen refresh rate (60Hz -> 60 FPS)\n    // NOTE: V-Sync can be enabled by graphic driver configuration\n    if (CORE.Window.flags & FLAG_VSYNC_HINT) glfwSwapInterval(1);\n#endif\n#if defined(PLATFORM_WEB)\n/*\n    EM_ASM\n    (\n        // This strategy works well while using raylib minimal web shell for emscripten,\n        // it re-scales the canvas to fullscreen using monitor resolution, for tools this\n        // is a good strategy but maybe games prefer to keep current canvas resolution and\n        // display it in fullscreen, adjusting monitor resolution if possible\n        if (document.fullscreenElement) document.exitFullscreen();\n        else Module.requestFullscreen(true, true); //false, true);\n    );\n*/\n    //EM_ASM(Module.requestFullscreen(false, false););\n/*\n    if (!CORE.Window.fullscreen)\n    {\n        // Option 1: Request fullscreen for the canvas element\n        // This option does not seem to work at all:\n        // emscripten_request_pointerlock() and emscripten_request_fullscreen() are affected by web security,\n        // the user must click once on the canvas to hide the pointer or transition to full screen\n        //emscripten_request_fullscreen(\"#canvas\", false);\n\n        // Option 2: Request fullscreen for the canvas element with strategy\n        // This option does not seem to work at all\n        // Ref: https://github.com/emscripten-core/emscripten/issues/5124\n        // EmscriptenFullscreenStrategy strategy = {\n            // .scaleMode = EMSCRIPTEN_FULLSCREEN_SCALE_STRETCH, //EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT,\n            // .canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF,\n            // .filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT,\n            // .canvasResizedCallback = EmscriptenWindowResizedCallback,\n            // .canvasResizedCallbackUserData = NULL\n        // };\n        //emscripten_request_fullscreen_strategy(\"#canvas\", EM_FALSE, &strategy);\n\n        // Option 3: Request fullscreen for the canvas element with strategy\n        // It works as expected but only inside the browser (client area)\n        EmscriptenFullscreenStrategy strategy = {\n            .scaleMode = EMSCRIPTEN_FULLSCREEN_SCALE_ASPECT,\n            .canvasResolutionScaleMode = EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_STDDEF,\n            .filteringMode = EMSCRIPTEN_FULLSCREEN_FILTERING_DEFAULT,\n            .canvasResizedCallback = EmscriptenWindowResizedCallback,\n            .canvasResizedCallbackUserData = NULL\n        };\n        emscripten_enter_soft_fullscreen(\"#canvas\", &strategy);\n\n        int width, height;\n        emscripten_get_canvas_element_size(\"#canvas\", &width, &height);\n        TRACELOG(LOG_WARNING, \"Emscripten: Enter fullscreen: Canvas size: %i x %i\", width, height);\n\n        CORE.Window.fullscreen = true;          // Toggle fullscreen flag\n        CORE.Window.flags |= FLAG_FULLSCREEN_MODE;\n    }\n    else\n    {\n        //emscripten_exit_fullscreen();\n        //emscripten_exit_soft_fullscreen();\n\n        int width, height;\n        emscripten_get_canvas_element_size(\"#canvas\", &width, &height);\n        TRACELOG(LOG_WARNING, \"Emscripten: Exit fullscreen: Canvas size: %i x %i\", width, height);\n\n        CORE.Window.fullscreen = false;          // Toggle fullscreen flag\n        CORE.Window.flags &= ~FLAG_FULLSCREEN_MODE;\n    }\n*/\n\n    CORE.Window.fullscreen = !CORE.Window.fullscreen;          // Toggle fullscreen flag\n#endif\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    TRACELOG(LOG_WARNING, \"SYSTEM: Failed to toggle to windowed mode\");\n#endif\n}\n\n// Set window state: maximized, if resizable (only PLATFORM_DESKTOP)\nvoid MaximizeWindow(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)\n    {\n        glfwMaximizeWindow(CORE.Window.handle);\n        CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;\n    }\n#endif\n}\n\n// Set window state: minimized (only PLATFORM_DESKTOP)\nvoid MinimizeWindow(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    // NOTE: Following function launches callback that sets appropriate flag!\n    glfwIconifyWindow(CORE.Window.handle);\n#endif\n}\n\n// Set window state: not minimized/maximized (only PLATFORM_DESKTOP)\nvoid RestoreWindow(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (glfwGetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE) == GLFW_TRUE)\n    {\n        // Restores the specified window if it was previously iconified (minimized) or maximized\n        glfwRestoreWindow(CORE.Window.handle);\n        CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;\n        CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;\n    }\n#endif\n}\n\n// Set window configuration state using flags\nvoid SetWindowState(unsigned int flags)\n{\n#if defined(PLATFORM_DESKTOP)\n    // Check previous state and requested state to apply required changes\n    // NOTE: In most cases the functions already change the flags internally\n\n    // State change: FLAG_VSYNC_HINT\n    if (((CORE.Window.flags & FLAG_VSYNC_HINT) != (flags & FLAG_VSYNC_HINT)) && ((flags & FLAG_VSYNC_HINT) > 0))\n    {\n        glfwSwapInterval(1);\n        CORE.Window.flags |= FLAG_VSYNC_HINT;\n    }\n\n    // State change: FLAG_FULLSCREEN_MODE\n    if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) != (flags & FLAG_FULLSCREEN_MODE))\n    {\n        ToggleFullscreen();     // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_RESIZABLE\n    if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) != (flags & FLAG_WINDOW_RESIZABLE)) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_TRUE);\n        CORE.Window.flags |= FLAG_WINDOW_RESIZABLE;\n    }\n\n    // State change: FLAG_WINDOW_UNDECORATED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) != (flags & FLAG_WINDOW_UNDECORATED)) && (flags & FLAG_WINDOW_UNDECORATED))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_FALSE);\n        CORE.Window.flags |= FLAG_WINDOW_UNDECORATED;\n    }\n\n    // State change: FLAG_WINDOW_HIDDEN\n    if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) != (flags & FLAG_WINDOW_HIDDEN)) && ((flags & FLAG_WINDOW_HIDDEN) > 0))\n    {\n        glfwHideWindow(CORE.Window.handle);\n        CORE.Window.flags |= FLAG_WINDOW_HIDDEN;\n    }\n\n    // State change: FLAG_WINDOW_MINIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) != (flags & FLAG_WINDOW_MINIMIZED)) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))\n    {\n        //GLFW_ICONIFIED\n        MinimizeWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_MAXIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) != (flags & FLAG_WINDOW_MAXIMIZED)) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))\n    {\n        //GLFW_MAXIMIZED\n        MaximizeWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_UNFOCUSED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) != (flags & FLAG_WINDOW_UNFOCUSED)) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_FALSE);\n        CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;\n    }\n\n    // State change: FLAG_WINDOW_TOPMOST\n    if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) != (flags & FLAG_WINDOW_TOPMOST)) && ((flags & FLAG_WINDOW_TOPMOST) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_TRUE);\n        CORE.Window.flags |= FLAG_WINDOW_TOPMOST;\n    }\n\n    // State change: FLAG_WINDOW_ALWAYS_RUN\n    if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) != (flags & FLAG_WINDOW_ALWAYS_RUN)) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))\n    {\n        CORE.Window.flags |= FLAG_WINDOW_ALWAYS_RUN;\n    }\n\n    // The following states can not be changed after window creation\n\n    // State change: FLAG_WINDOW_TRANSPARENT\n    if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) != (flags & FLAG_WINDOW_TRANSPARENT)) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_HIGHDPI\n    if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) != (flags & FLAG_WINDOW_HIGHDPI)) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_MOUSE_PASSTHROUGH\n    if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) != (flags & FLAG_WINDOW_MOUSE_PASSTHROUGH)) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);\n        CORE.Window.flags |= FLAG_WINDOW_MOUSE_PASSTHROUGH;\n    }\n\n    // State change: FLAG_MSAA_4X_HINT\n    if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) != (flags & FLAG_MSAA_4X_HINT)) && ((flags & FLAG_MSAA_4X_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_INTERLACED_HINT\n    if (((CORE.Window.flags & FLAG_INTERLACED_HINT) != (flags & FLAG_INTERLACED_HINT)) && ((flags & FLAG_INTERLACED_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");\n    }\n#endif\n}\n\n// Clear window configuration state flags\nvoid ClearWindowState(unsigned int flags)\n{\n#if defined(PLATFORM_DESKTOP)\n    // Check previous state and requested state to apply required changes\n    // NOTE: In most cases the functions already change the flags internally\n\n    // State change: FLAG_VSYNC_HINT\n    if (((CORE.Window.flags & FLAG_VSYNC_HINT) > 0) && ((flags & FLAG_VSYNC_HINT) > 0))\n    {\n        glfwSwapInterval(0);\n        CORE.Window.flags &= ~FLAG_VSYNC_HINT;\n    }\n\n    // State change: FLAG_FULLSCREEN_MODE\n    if (((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) && ((flags & FLAG_FULLSCREEN_MODE) > 0))\n    {\n        ToggleFullscreen();     // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_RESIZABLE\n    if (((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) && ((flags & FLAG_WINDOW_RESIZABLE) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_RESIZABLE, GLFW_FALSE);\n        CORE.Window.flags &= ~FLAG_WINDOW_RESIZABLE;\n    }\n\n    // State change: FLAG_WINDOW_UNDECORATED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) && ((flags & FLAG_WINDOW_UNDECORATED) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_DECORATED, GLFW_TRUE);\n        CORE.Window.flags &= ~FLAG_WINDOW_UNDECORATED;\n    }\n\n    // State change: FLAG_WINDOW_HIDDEN\n    if (((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) && ((flags & FLAG_WINDOW_HIDDEN) > 0))\n    {\n        glfwShowWindow(CORE.Window.handle);\n        CORE.Window.flags &= ~FLAG_WINDOW_HIDDEN;\n    }\n\n    // State change: FLAG_WINDOW_MINIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) && ((flags & FLAG_WINDOW_MINIMIZED) > 0))\n    {\n        RestoreWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_MAXIMIZED\n    if (((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) && ((flags & FLAG_WINDOW_MAXIMIZED) > 0))\n    {\n        RestoreWindow();       // NOTE: Window state flag updated inside function\n    }\n\n    // State change: FLAG_WINDOW_UNFOCUSED\n    if (((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) && ((flags & FLAG_WINDOW_UNFOCUSED) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FOCUS_ON_SHOW, GLFW_TRUE);\n        CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;\n    }\n\n    // State change: FLAG_WINDOW_TOPMOST\n    if (((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) && ((flags & FLAG_WINDOW_TOPMOST) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_FLOATING, GLFW_FALSE);\n        CORE.Window.flags &= ~FLAG_WINDOW_TOPMOST;\n    }\n\n    // State change: FLAG_WINDOW_ALWAYS_RUN\n    if (((CORE.Window.flags & FLAG_WINDOW_ALWAYS_RUN) > 0) && ((flags & FLAG_WINDOW_ALWAYS_RUN) > 0))\n    {\n        CORE.Window.flags &= ~FLAG_WINDOW_ALWAYS_RUN;\n    }\n\n    // The following states can not be changed after window creation\n\n    // State change: FLAG_WINDOW_TRANSPARENT\n    if (((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) && ((flags & FLAG_WINDOW_TRANSPARENT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: Framebuffer transparency can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_HIGHDPI\n    if (((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0) && ((flags & FLAG_WINDOW_HIGHDPI) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: High DPI can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_WINDOW_MOUSE_PASSTHROUGH\n    if (((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) && ((flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0))\n    {\n        glfwSetWindowAttrib(CORE.Window.handle, GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);\n        CORE.Window.flags &= ~FLAG_WINDOW_MOUSE_PASSTHROUGH;\n    }\n\n    // State change: FLAG_MSAA_4X_HINT\n    if (((CORE.Window.flags & FLAG_MSAA_4X_HINT) > 0) && ((flags & FLAG_MSAA_4X_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"WINDOW: MSAA can only be configured before window initialization\");\n    }\n\n    // State change: FLAG_INTERLACED_HINT\n    if (((CORE.Window.flags & FLAG_INTERLACED_HINT) > 0) && ((flags & FLAG_INTERLACED_HINT) > 0))\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Interlaced mode can only be configured before window initialization\");\n    }\n#endif\n}\n\n// Set icon for window (only PLATFORM_DESKTOP)\n// NOTE 1: Image must be in RGBA format, 8bit per channel\n// NOTE 2: Image is scaled by the OS for all required sizes\nvoid SetWindowIcon(Image image)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (image.data == NULL)\n    {\n        // Revert to the default window icon, pass in an empty image array\n        glfwSetWindowIcon(CORE.Window.handle, 0, NULL);\n    }\n    else\n    {\n        if (image.format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)\n        {\n            GLFWimage icon[1] = { 0 };\n\n            icon[0].width = image.width;\n            icon[0].height = image.height;\n            icon[0].pixels = (unsigned char *)image.data;\n\n            // NOTE 1: We only support one image icon\n            // NOTE 2: The specified image data is copied before this function returns\n            glfwSetWindowIcon(CORE.Window.handle, 1, icon);\n        }\n        else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");\n    }\n#endif\n}\n\n// Set icon for window (multiple images, only PLATFORM_DESKTOP)\n// NOTE 1: Images must be in RGBA format, 8bit per channel\n// NOTE 2: The multiple images are used depending on provided sizes\n// Standard Windows icon sizes: 256, 128, 96, 64, 48, 32, 24, 16\nvoid SetWindowIcons(Image *images, int count)\n{\n#if defined(PLATFORM_DESKTOP)\n    if ((images == NULL) || (count <= 0))\n    {\n        // Revert to the default window icon, pass in an empty image array\n        glfwSetWindowIcon(CORE.Window.handle, 0, NULL);\n    }\n    else\n    {\n        int valid = 0;\n        GLFWimage *icons = RL_CALLOC(count, sizeof(GLFWimage));\n\n        for (int i = 0; i < count; i++)\n        {\n            if (images[i].format == PIXELFORMAT_UNCOMPRESSED_R8G8B8A8)\n            {\n                icons[valid].width = images[i].width;\n                icons[valid].height = images[i].height;\n                icons[valid].pixels = (unsigned char *)images[i].data;\n\n                valid++;\n            }\n            else TRACELOG(LOG_WARNING, \"GLFW: Window icon image must be in R8G8B8A8 pixel format\");\n        }\n        // NOTE: Images data is copied internally before this function returns\n        glfwSetWindowIcon(CORE.Window.handle, valid, icons);\n\n        RL_FREE(icons);\n    }\n#endif\n}\n\n// Set title for window (only PLATFORM_DESKTOP)\nvoid SetWindowTitle(const char *title)\n{\n    CORE.Window.title = title;\n#if defined(PLATFORM_DESKTOP)\n    glfwSetWindowTitle(CORE.Window.handle, title);\n#endif\n}\n\n// Set window position on screen (windowed mode)\nvoid SetWindowPosition(int x, int y)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetWindowPos(CORE.Window.handle, x, y);\n#endif\n}\n\n// Set monitor for the current window (fullscreen mode)\nvoid SetWindowMonitor(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount = 0;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        TRACELOG(LOG_INFO, \"GLFW: Selected fullscreen monitor: [%i] %s\", monitor, glfwGetMonitorName(monitors[monitor]));\n\n        const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);\n        glfwSetWindowMonitor(CORE.Window.handle, monitors[monitor], 0, 0, mode->width, mode->height, mode->refreshRate);\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n}\n\n// Set window minimum dimensions (FLAG_WINDOW_RESIZABLE)\nvoid SetWindowMinSize(int width, int height)\n{\n#if defined(PLATFORM_DESKTOP)\n    const GLFWvidmode *mode = glfwGetVideoMode(glfwGetPrimaryMonitor());\n    glfwSetWindowSizeLimits(CORE.Window.handle, width, height, mode->width, mode->height);\n#endif\n}\n\n// Set window dimensions\nvoid SetWindowSize(int width, int height)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwSetWindowSize(CORE.Window.handle, width, height);\n#endif\n}\n\n// Set window opacity, value opacity is between 0.0 and 1.0\nvoid SetWindowOpacity(float opacity)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (opacity >= 1.0f) opacity = 1.0f;\n    else if (opacity <= 0.0f) opacity = 0.0f;\n    glfwSetWindowOpacity(CORE.Window.handle, opacity);\n#endif\n}\n\n// Get current screen width\nint GetScreenWidth(void)\n{\n    return CORE.Window.screen.width;\n}\n\n// Get current screen height\nint GetScreenHeight(void)\n{\n    return CORE.Window.screen.height;\n}\n\n// Get current render width which is equal to screen width * dpi scale\nint GetRenderWidth(void)\n{\n    return CORE.Window.render.width;\n}\n\n// Get current screen height which is equal to screen height * dpi scale\nint GetRenderHeight(void)\n{\n    return CORE.Window.render.height;\n}\n\n// Get native window handle\nvoid *GetWindowHandle(void)\n{\n#if defined(PLATFORM_DESKTOP) && defined(_WIN32)\n    // NOTE: Returned handle is: void *HWND (windows.h)\n    return glfwGetWin32Window(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_DESKTOP) && defined(__linux__)\n    // NOTE: Returned handle is: unsigned long Window (X.h)\n    // typedef unsigned long XID;\n    // typedef XID Window;\n    //unsigned long id = (unsigned long)glfwGetX11Window(CORE.Window.handle);\n    //return NULL;    // TODO: Find a way to return value... cast to void *?\n    return (void *)CORE.Window.handle;\n#endif\n#if defined(__APPLE__)\n    // NOTE: Returned handle is: (objc_object *)\n    return (void *)glfwGetCocoaWindow(CORE.Window.handle);\n#endif\n\n    return NULL;\n}\n\n// Get number of monitors\nint GetMonitorCount(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    glfwGetMonitors(&monitorCount);\n    return monitorCount;\n#else\n    return 1;\n#endif\n}\n\n// Get number of monitors\nint GetCurrentMonitor(void)\n{\n    int index = 0;\n\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n    GLFWmonitor *monitor = NULL;\n\n    if (monitorCount > 1)\n    {\n        if (IsWindowFullscreen())\n        {\n            // Get the handle of the monitor that the specified window is in full screen on\n            monitor = glfwGetWindowMonitor(CORE.Window.handle);\n\n            for (int i = 0; i < monitorCount; i++)\n            {\n                if (monitors[i] == monitor)\n                {\n                    index = i;\n                    break;\n                }\n            }\n        }\n        else\n        {\n            int x = 0;\n            int y = 0;\n\n            glfwGetWindowPos(CORE.Window.handle, &x, &y);\n\n            for (int i = 0; i < monitorCount; i++)\n            {\n                int mx = 0;\n                int my = 0;\n\n                int width = 0;\n                int height = 0;\n\n                monitor = monitors[i];\n                glfwGetMonitorWorkarea(monitor, &mx, &my, &width, &height);\n\n                if (x >= mx && x <= (mx + width) && y >= my && y <= (my + height))\n                {\n                    index = i;\n                    break;\n                }\n            }\n        }\n    }\n#endif\n\n    return index;\n}\n\n// Get selected monitor position\nVector2 GetMonitorPosition(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        int x, y;\n        glfwGetMonitorPos(monitors[monitor], &x, &y);\n\n        return (Vector2){ (float)x, (float)y };\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return (Vector2){ 0, 0 };\n}\n\n// Get selected monitor width (currently used by monitor)\nint GetMonitorWidth(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);\n\n        if (mode) return mode->width;\n        else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n#if defined(PLATFORM_ANDROID)\n    if (CORE.Android.app->window != NULL)\n    {\n        return ANativeWindow_getWidth(CORE.Android.app->window);\n    }\n#endif\n    return 0;\n}\n\n// Get selected monitor height (currently used by monitor)\nint GetMonitorHeight(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        const GLFWvidmode *mode = glfwGetVideoMode(monitors[monitor]);\n\n        if (mode) return mode->height;\n        else TRACELOG(LOG_WARNING, \"GLFW: Failed to find video mode for selected monitor\");\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n#if defined(PLATFORM_ANDROID)\n    if (CORE.Android.app->window != NULL)\n    {\n        return ANativeWindow_getHeight(CORE.Android.app->window);\n    }\n#endif\n    return 0;\n}\n\n// Get selected monitor physical width in millimetres\nint GetMonitorPhysicalWidth(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        int physicalWidth;\n        glfwGetMonitorPhysicalSize(monitors[monitor], &physicalWidth, NULL);\n        return physicalWidth;\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return 0;\n}\n\n// Get selected monitor physical height in millimetres\nint GetMonitorPhysicalHeight(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        int physicalHeight;\n        glfwGetMonitorPhysicalSize(monitors[monitor], NULL, &physicalHeight);\n        return physicalHeight;\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return 0;\n}\n\n// Get selected monitor refresh rate\nint GetMonitorRefreshRate(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        const GLFWvidmode *vidmode = glfwGetVideoMode(monitors[monitor]);\n        return vidmode->refreshRate;\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n#if defined(PLATFORM_DRM)\n    if ((CORE.Window.connector) && (CORE.Window.modeIndex >= 0))\n    {\n        return CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh;\n    }\n#endif\n    return 0;\n}\n\n// Get window position XY on monitor\nVector2 GetWindowPosition(void)\n{\n    int x = 0;\n    int y = 0;\n#if defined(PLATFORM_DESKTOP)\n    glfwGetWindowPos(CORE.Window.handle, &x, &y);\n#endif\n    return (Vector2){ (float)x, (float)y };\n}\n\n// Get window scale DPI factor for current monitor\nVector2 GetWindowScaleDPI(void)\n{\n    Vector2 scale = { 1.0f, 1.0f };\n\n#if defined(PLATFORM_DESKTOP)\n    float xdpi = 1.0;\n    float ydpi = 1.0;\n    Vector2 windowPos = GetWindowPosition();\n\n    int monitorCount = 0;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    // Check window monitor\n    for (int i = 0; i < monitorCount; i++)\n    {\n        glfwGetMonitorContentScale(monitors[i], &xdpi, &ydpi);\n\n        int xpos, ypos, width, height;\n        glfwGetMonitorWorkarea(monitors[i], &xpos, &ypos, &width, &height);\n\n        if ((windowPos.x >= xpos) && (windowPos.x < xpos + width) &&\n            (windowPos.y >= ypos) && (windowPos.y < ypos + height))\n        {\n            scale.x = xdpi;\n            scale.y = ydpi;\n            break;\n        }\n    }\n#endif\n\n    return scale;\n}\n\n// Get the human-readable, UTF-8 encoded name of the selected monitor\nconst char *GetMonitorName(int monitor)\n{\n#if defined(PLATFORM_DESKTOP)\n    int monitorCount;\n    GLFWmonitor **monitors = glfwGetMonitors(&monitorCount);\n\n    if ((monitor >= 0) && (monitor < monitorCount))\n    {\n        return glfwGetMonitorName(monitors[monitor]);\n    }\n    else TRACELOG(LOG_WARNING, \"GLFW: Failed to find selected monitor\");\n#endif\n    return \"\";\n}\n\n// Set clipboard text content\nvoid SetClipboardText(const char *text)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetClipboardString(CORE.Window.handle, text);\n#endif\n#if defined(PLATFORM_WEB)\n    // Security check to (partially) avoid malicious code\n    if (strchr(text, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided Clipboard could be potentially malicious, avoid [\\'] character\");\n    else emscripten_run_script(TextFormat(\"navigator.clipboard.writeText('%s')\", text));\n#endif\n}\n\n// Get clipboard text content\n// NOTE: returned string is allocated and freed by GLFW\nconst char *GetClipboardText(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    return glfwGetClipboardString(CORE.Window.handle);\n#endif\n#if defined(PLATFORM_WEB)\n/*\n    // Accessing clipboard data from browser is tricky due to security reasons\n    // The method to use is navigator.clipboard.readText() but this is an asynchronous method\n    // that will return at some moment after the function is called with the required data\n    emscripten_run_script_string(\"navigator.clipboard.readText() \\\n        .then(text => { document.getElementById('clipboard').innerText = text; console.log('Pasted content: ', text); }) \\\n        .catch(err => { console.error('Failed to read clipboard contents: ', err); });\"\n    );\n\n    // The main issue is getting that data, one approach could be using ASYNCIFY and wait\n    // for the data but it requires adding Asyncify emscripten library on compilation\n\n    // Another approach could be just copy the data in a HTML text field and try to retrieve it\n    // later on if available... and clean it for future accesses\n*/\n    return NULL;\n#endif\n    return NULL;\n}\n\n// Enable waiting for events on EndDrawing(), no automatic event polling\nvoid EnableEventWaiting(void)\n{\n    CORE.Window.eventWaiting = true;\n}\n\n// Disable waiting for events on EndDrawing(), automatic events polling\nvoid DisableEventWaiting(void)\n{\n    CORE.Window.eventWaiting = false;\n}\n\n// Show mouse cursor\nvoid ShowCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n#endif\n\n    CORE.Input.Mouse.cursorHidden = false;\n}\n\n// Hides mouse cursor\nvoid HideCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_HIDDEN);\n#endif\n\n    CORE.Input.Mouse.cursorHidden = true;\n}\n\n// Check if cursor is not visible\nbool IsCursorHidden(void)\n{\n    return CORE.Input.Mouse.cursorHidden;\n}\n\n// Enables cursor (unlock cursor)\nvoid EnableCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_NORMAL);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_exit_pointerlock();\n#endif\n    // Set cursor position in the middle\n    SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);\n\n    CORE.Input.Mouse.cursorHidden = false;\n}\n\n// Disables cursor (lock cursor)\nvoid DisableCursor(void)\n{\n#if defined(PLATFORM_DESKTOP)\n    glfwSetInputMode(CORE.Window.handle, GLFW_CURSOR, GLFW_CURSOR_DISABLED);\n#endif\n#if defined(PLATFORM_WEB)\n    emscripten_request_pointerlock(\"#canvas\", 1);\n#endif\n    // Set cursor position in the middle\n    SetMousePosition(CORE.Window.screen.width/2, CORE.Window.screen.height/2);\n\n    CORE.Input.Mouse.cursorHidden = true;\n}\n\n// Check if cursor is on the current screen.\nbool IsCursorOnScreen(void)\n{\n    return CORE.Input.Mouse.cursorOnScreen;\n}\n\n// Set background color (framebuffer clear color)\nvoid ClearBackground(Color color)\n{\n    rlClearColor(color.r, color.g, color.b, color.a);   // Set clear color\n    rlClearScreenBuffers();                             // Clear current framebuffers\n}\n\n// Setup canvas (framebuffer) to start drawing\nvoid BeginDrawing(void)\n{\n    // WARNING: Previously to BeginDrawing() other render textures drawing could happen,\n    // consequently the measure for update vs draw is not accurate (only the total frame time is accurate)\n\n    CORE.Time.current = GetTime();      // Number of elapsed seconds since InitTimer()\n    CORE.Time.update = CORE.Time.current - CORE.Time.previous;\n    CORE.Time.previous = CORE.Time.current;\n\n    rlLoadIdentity();                   // Reset current matrix (modelview)\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling\n\n    //rlTranslatef(0.375, 0.375, 0);    // HACK to have 2D pixel-perfect drawing on OpenGL 1.1\n                                        // NOTE: Not required with OpenGL 3.3+\n}\n\n// End canvas drawing and swap buffers (double buffering)\nvoid EndDrawing(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n#if defined(SUPPORT_GIF_RECORDING)\n    // Draw record indicator\n    if (gifRecording)\n    {\n        #define GIF_RECORD_FRAMERATE    10\n        gifFrameCounter++;\n\n        // NOTE: We record one gif frame every 10 game frames\n        if ((gifFrameCounter%GIF_RECORD_FRAMERATE) == 0)\n        {\n            // Get image data for the current frame (from backbuffer)\n            // NOTE: This process is quite slow... :(\n            Vector2 scale = GetWindowScaleDPI();\n            unsigned char *screenData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n            msf_gif_frame(&gifState, screenData, 10, 16, (int)((float)CORE.Window.render.width*scale.x)*4);\n\n            RL_FREE(screenData);    // Free image data\n        }\n\n    #if defined(SUPPORT_MODULE_RSHAPES) && defined(SUPPORT_MODULE_RTEXT)\n        if (((gifFrameCounter/15)%2) == 1)\n        {\n            DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);                 // WARNING: Module required: rshapes\n            DrawText(\"GIF RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);     // WARNING: Module required: rtext\n        }\n    #endif\n\n        rlDrawRenderBatchActive();  // Update and draw internal render batch\n    }\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    // Draw record/play indicator\n    if (eventsRecording)\n    {\n        gifFrameCounter++;\n\n        if (((gifFrameCounter/15)%2) == 1)\n        {\n            DrawCircle(30, CORE.Window.screen.height - 20, 10, MAROON);\n            DrawText(\"EVENTS RECORDING\", 50, CORE.Window.screen.height - 25, 10, RED);\n        }\n\n        rlDrawRenderBatchActive();  // Update and draw internal render batch\n    }\n    else if (eventsPlaying)\n    {\n        gifFrameCounter++;\n\n        if (((gifFrameCounter/15)%2) == 1)\n        {\n            DrawCircle(30, CORE.Window.screen.height - 20, 10, LIME);\n            DrawText(\"EVENTS PLAYING\", 50, CORE.Window.screen.height - 25, 10, GREEN);\n        }\n\n        rlDrawRenderBatchActive();  // Update and draw internal render batch\n    }\n#endif\n\n#if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)\n    SwapScreenBuffer();                  // Copy back buffer to front buffer (screen)\n\n    // Frame time control system\n    CORE.Time.current = GetTime();\n    CORE.Time.draw = CORE.Time.current - CORE.Time.previous;\n    CORE.Time.previous = CORE.Time.current;\n\n    CORE.Time.frame = CORE.Time.update + CORE.Time.draw;\n\n    // Wait for some milliseconds...\n    if (CORE.Time.frame < CORE.Time.target)\n    {\n        WaitTime(CORE.Time.target - CORE.Time.frame);\n\n        CORE.Time.current = GetTime();\n        double waitTime = CORE.Time.current - CORE.Time.previous;\n        CORE.Time.previous = CORE.Time.current;\n\n        CORE.Time.frame += waitTime;    // Total frame time: update + draw + wait\n    }\n\n    PollInputEvents();      // Poll user events (before next frame update)\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    // Events recording and playing logic\n    if (eventsRecording) RecordAutomationEvent(CORE.Time.frameCounter);\n    else if (eventsPlaying)\n    {\n        // TODO: When should we play? After/before/replace PollInputEvents()?\n        if (CORE.Time.frameCounter >= eventCount) eventsPlaying = false;\n        PlayAutomationEvent(CORE.Time.frameCounter);\n    }\n#endif\n\n    CORE.Time.frameCounter++;\n}\n\n// Initialize 2D mode with custom camera (2D)\nvoid BeginMode2D(Camera2D camera)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    // Apply 2d camera transformation to modelview\n    rlMultMatrixf(MatrixToFloat(GetCameraMatrix2D(camera)));\n\n    // Apply screen scaling if required\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale));\n}\n\n// Ends 2D mode with custom camera\nvoid EndMode2D(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlLoadIdentity();               // Reset current matrix (modelview)\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required\n}\n\n// Initializes 3D mode with custom camera (3D)\nvoid BeginMode3D(Camera camera)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix\n    rlPushMatrix();                 // Save previous matrix, which contains the settings for the 2d ortho projection\n    rlLoadIdentity();               // Reset current matrix (projection)\n\n    float aspect = (float)CORE.Window.currentFbo.width/(float)CORE.Window.currentFbo.height;\n\n    // NOTE: zNear and zFar values are important when computing depth buffer values\n    if (camera.projection == CAMERA_PERSPECTIVE)\n    {\n        // Setup perspective projection\n        double top = RL_CULL_DISTANCE_NEAR*tan(camera.fovy*0.5*DEG2RAD);\n        double right = top*aspect;\n\n        rlFrustum(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC)\n    {\n        // Setup orthographic projection\n        double top = camera.fovy/2.0;\n        double right = top*aspect;\n\n        rlOrtho(-right, right, -top,top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n\n    rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    // Setup Camera view\n    Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);\n    rlMultMatrixf(MatrixToFloat(matView));      // Multiply modelview matrix by view matrix (camera)\n\n    rlEnableDepthTest();            // Enable DEPTH_TEST for 3D\n}\n\n// Ends 3D mode and returns to default 2D orthographic mode\nvoid EndMode3D(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix\n    rlPopMatrix();                  // Restore previous matrix (projection) from matrix stack\n\n    rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    rlMultMatrixf(MatrixToFloat(CORE.Window.screenScale)); // Apply screen scaling if required\n\n    rlDisableDepthTest();           // Disable DEPTH_TEST for 2D\n}\n\n// Initializes render texture for drawing\nvoid BeginTextureMode(RenderTexture2D target)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlEnableFramebuffer(target.id); // Enable render target\n\n    // Set viewport and RLGL internal framebuffer size\n    rlViewport(0, 0, target.texture.width, target.texture.height);\n    rlSetFramebufferWidth(target.texture.width);\n    rlSetFramebufferHeight(target.texture.height);\n\n    rlMatrixMode(RL_PROJECTION);    // Switch to projection matrix\n    rlLoadIdentity();               // Reset current matrix (projection)\n\n    // Set orthographic projection to current framebuffer size\n    // NOTE: Configured top-left corner as (0, 0)\n    rlOrtho(0, target.texture.width, target.texture.height, 0, 0.0f, 1.0f);\n\n    rlMatrixMode(RL_MODELVIEW);     // Switch back to modelview matrix\n    rlLoadIdentity();               // Reset current matrix (modelview)\n\n    //rlScalef(0.0f, -1.0f, 0.0f);  // Flip Y-drawing (?)\n\n    // Setup current width/height for proper aspect ratio\n    // calculation when using BeginMode3D()\n    CORE.Window.currentFbo.width = target.texture.width;\n    CORE.Window.currentFbo.height = target.texture.height;\n}\n\n// Ends drawing to render texture\nvoid EndTextureMode(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlDisableFramebuffer();         // Disable render target (fbo)\n\n    // Set viewport to default framebuffer size\n    SetupViewport(CORE.Window.render.width, CORE.Window.render.height);\n\n    // Reset current fbo to screen size\n    CORE.Window.currentFbo.width = CORE.Window.render.width;\n    CORE.Window.currentFbo.height = CORE.Window.render.height;\n}\n\n// Begin custom shader mode\nvoid BeginShaderMode(Shader shader)\n{\n    rlSetShader(shader.id, shader.locs);\n}\n\n// End custom shader mode (returns to default shader)\nvoid EndShaderMode(void)\n{\n    rlSetShader(rlGetShaderIdDefault(), rlGetShaderLocsDefault());\n}\n\n// Begin blending mode (alpha, additive, multiplied, subtract, custom)\n// NOTE: Blend modes supported are enumerated in BlendMode enum\nvoid BeginBlendMode(int mode)\n{\n    rlSetBlendMode(mode);\n}\n\n// End blending mode (reset to default: alpha blending)\nvoid EndBlendMode(void)\n{\n    rlSetBlendMode(BLEND_ALPHA);\n}\n\n// Begin scissor mode (define screen area for following drawing)\n// NOTE: Scissor rec refers to bottom-left corner, we change it to upper-left\nvoid BeginScissorMode(int x, int y, int width, int height)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n\n    rlEnableScissorTest();\n\n#if defined(__APPLE__)\n    Vector2 scale = GetWindowScaleDPI();\n    rlScissor((int)(x*scale.x), (int)(GetScreenHeight()*scale.y - (((y + height)*scale.y))), (int)(width*scale.x), (int)(height*scale.y));\n#else\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        Vector2 scale = GetWindowScaleDPI();\n        rlScissor((int)(x*scale.x), (int)(CORE.Window.currentFbo.height - (y + height)*scale.y), (int)(width*scale.x), (int)(height*scale.y));\n    }\n    else\n    {\n        rlScissor(x, CORE.Window.currentFbo.height - (y + height), width, height);\n    }\n#endif\n}\n\n// End scissor mode\nvoid EndScissorMode(void)\n{\n    rlDrawRenderBatchActive();      // Update and draw internal render batch\n    rlDisableScissorTest();\n}\n\n// Begin VR drawing configuration\nvoid BeginVrStereoMode(VrStereoConfig config)\n{\n    rlEnableStereoRender();\n\n    // Set stereo render matrices\n    rlSetMatrixProjectionStereo(config.projection[0], config.projection[1]);\n    rlSetMatrixViewOffsetStereo(config.viewOffset[0], config.viewOffset[1]);\n}\n\n// End VR drawing process (and desktop mirror)\nvoid EndVrStereoMode(void)\n{\n    rlDisableStereoRender();\n}\n\n// Load VR stereo config for VR simulator device parameters\nVrStereoConfig LoadVrStereoConfig(VrDeviceInfo device)\n{\n    VrStereoConfig config = { 0 };\n\n    if ((rlGetVersion() == RL_OPENGL_33) || (rlGetVersion() == RL_OPENGL_ES_20))\n    {\n        // Compute aspect ratio\n        float aspect = ((float)device.hResolution*0.5f)/(float)device.vResolution;\n\n        // Compute lens parameters\n        float lensShift = (device.hScreenSize*0.25f - device.lensSeparationDistance*0.5f)/device.hScreenSize;\n        config.leftLensCenter[0] = 0.25f + lensShift;\n        config.leftLensCenter[1] = 0.5f;\n        config.rightLensCenter[0] = 0.75f - lensShift;\n        config.rightLensCenter[1] = 0.5f;\n        config.leftScreenCenter[0] = 0.25f;\n        config.leftScreenCenter[1] = 0.5f;\n        config.rightScreenCenter[0] = 0.75f;\n        config.rightScreenCenter[1] = 0.5f;\n\n        // Compute distortion scale parameters\n        // NOTE: To get lens max radius, lensShift must be normalized to [-1..1]\n        float lensRadius = fabsf(-1.0f - 4.0f*lensShift);\n        float lensRadiusSq = lensRadius*lensRadius;\n        float distortionScale = device.lensDistortionValues[0] +\n                                device.lensDistortionValues[1]*lensRadiusSq +\n                                device.lensDistortionValues[2]*lensRadiusSq*lensRadiusSq +\n                                device.lensDistortionValues[3]*lensRadiusSq*lensRadiusSq*lensRadiusSq;\n\n        float normScreenWidth = 0.5f;\n        float normScreenHeight = 1.0f;\n        config.scaleIn[0] = 2.0f/normScreenWidth;\n        config.scaleIn[1] = 2.0f/normScreenHeight/aspect;\n        config.scale[0] = normScreenWidth*0.5f/distortionScale;\n        config.scale[1] = normScreenHeight*0.5f*aspect/distortionScale;\n\n        // Fovy is normally computed with: 2*atan2f(device.vScreenSize, 2*device.eyeToScreenDistance)\n        // ...but with lens distortion it is increased (see Oculus SDK Documentation)\n        float fovy = 2.0f*atan2f(device.vScreenSize*0.5f*distortionScale, device.eyeToScreenDistance);     // Really need distortionScale?\n       // float fovy = 2.0f*(float)atan2f(device.vScreenSize*0.5f, device.eyeToScreenDistance);\n\n        // Compute camera projection matrices\n        float projOffset = 4.0f*lensShift;      // Scaled to projection space coordinates [-1..1]\n        Matrix proj = MatrixPerspective(fovy, aspect, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n\n        config.projection[0] = MatrixMultiply(proj, MatrixTranslate(projOffset, 0.0f, 0.0f));\n        config.projection[1] = MatrixMultiply(proj, MatrixTranslate(-projOffset, 0.0f, 0.0f));\n\n        // Compute camera transformation matrices\n        // NOTE: Camera movement might seem more natural if we model the head.\n        // Our axis of rotation is the base of our head, so we might want to add\n        // some y (base of head to eye level) and -z (center of head to eye protrusion) to the camera positions.\n        config.viewOffset[0] = MatrixTranslate(-device.interpupillaryDistance*0.5f, 0.075f, 0.045f);\n        config.viewOffset[1] = MatrixTranslate(device.interpupillaryDistance*0.5f, 0.075f, 0.045f);\n\n        // Compute eyes Viewports\n        /*\n        config.eyeViewportRight[0] = 0;\n        config.eyeViewportRight[1] = 0;\n        config.eyeViewportRight[2] = device.hResolution/2;\n        config.eyeViewportRight[3] = device.vResolution;\n\n        config.eyeViewportLeft[0] = device.hResolution/2;\n        config.eyeViewportLeft[1] = 0;\n        config.eyeViewportLeft[2] = device.hResolution/2;\n        config.eyeViewportLeft[3] = device.vResolution;\n        */\n    }\n    else TRACELOG(LOG_WARNING, \"RLGL: VR Simulator not supported on OpenGL 1.1\");\n\n    return config;\n}\n\n// Unload VR stereo config properties\nvoid UnloadVrStereoConfig(VrStereoConfig config)\n{\n    //...\n}\n\n// Load shader from files and bind default locations\n// NOTE: If shader string is NULL, using default vertex/fragment shaders\nShader LoadShader(const char *vsFileName, const char *fsFileName)\n{\n    Shader shader = { 0 };\n\n    char *vShaderStr = NULL;\n    char *fShaderStr = NULL;\n\n    if (vsFileName != NULL) vShaderStr = LoadFileText(vsFileName);\n    if (fsFileName != NULL) fShaderStr = LoadFileText(fsFileName);\n\n    shader = LoadShaderFromMemory(vShaderStr, fShaderStr);\n\n    UnloadFileText(vShaderStr);\n    UnloadFileText(fShaderStr);\n\n    return shader;\n}\n\n// Load shader from code strings and bind default locations\nShader LoadShaderFromMemory(const char *vsCode, const char *fsCode)\n{\n    Shader shader = { 0 };\n\n    shader.id = rlLoadShaderCode(vsCode, fsCode);\n\n    // After shader loading, we TRY to set default location names\n    if (shader.id > 0)\n    {\n        // Default shader attribute locations have been binded before linking:\n        //          vertex position location    = 0\n        //          vertex texcoord location    = 1\n        //          vertex normal location      = 2\n        //          vertex color location       = 3\n        //          vertex tangent location     = 4\n        //          vertex texcoord2 location   = 5\n\n        // NOTE: If any location is not found, loc point becomes -1\n\n        shader.locs = (int *)RL_CALLOC(RL_MAX_SHADER_LOCATIONS, sizeof(int));\n\n        // All locations reset to -1 (no location)\n        for (int i = 0; i < RL_MAX_SHADER_LOCATIONS; i++) shader.locs[i] = -1;\n\n        // Get handles to GLSL input attribute locations\n        shader.locs[SHADER_LOC_VERTEX_POSITION] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION);\n        shader.locs[SHADER_LOC_VERTEX_TEXCOORD01] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD);\n        shader.locs[SHADER_LOC_VERTEX_TEXCOORD02] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2);\n        shader.locs[SHADER_LOC_VERTEX_NORMAL] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL);\n        shader.locs[SHADER_LOC_VERTEX_TANGENT] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT);\n        shader.locs[SHADER_LOC_VERTEX_COLOR] = rlGetLocationAttrib(shader.id, RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR);\n\n        // Get handles to GLSL uniform locations (vertex shader)\n        shader.locs[SHADER_LOC_MATRIX_MVP] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MVP);\n        shader.locs[SHADER_LOC_MATRIX_VIEW] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW);\n        shader.locs[SHADER_LOC_MATRIX_PROJECTION] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION);\n        shader.locs[SHADER_LOC_MATRIX_MODEL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL);\n        shader.locs[SHADER_LOC_MATRIX_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL);\n\n        // Get handles to GLSL uniform locations (fragment shader)\n        shader.locs[SHADER_LOC_COLOR_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR);\n        shader.locs[SHADER_LOC_MAP_DIFFUSE] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0);  // SHADER_LOC_MAP_ALBEDO\n        shader.locs[SHADER_LOC_MAP_SPECULAR] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1); // SHADER_LOC_MAP_METALNESS\n        shader.locs[SHADER_LOC_MAP_NORMAL] = rlGetLocationUniform(shader.id, RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2);\n    }\n\n    return shader;\n}\n\n// Check if a shader is ready\nbool IsShaderReady(Shader shader)\n{\n    return ((shader.id > 0) &&          // Validate shader id (loaded successfully)\n            (shader.locs != NULL));     // Validate memory has been allocated for default shader locations\n\n    // The following locations are tried to be set automatically (locs[i] >= 0),\n    // any of them can be checked for validation but the only mandatory one is, afaik, SHADER_LOC_VERTEX_POSITION\n    // NOTE: Users can also setup manually their own attributes/uniforms and do not used the default raylib ones\n\n    // Vertex shader attribute locations (default)\n    // shader.locs[SHADER_LOC_VERTEX_POSITION]      // Set by default internal shader\n    // shader.locs[SHADER_LOC_VERTEX_TEXCOORD01]    // Set by default internal shader\n    // shader.locs[SHADER_LOC_VERTEX_TEXCOORD02]\n    // shader.locs[SHADER_LOC_VERTEX_NORMAL]\n    // shader.locs[SHADER_LOC_VERTEX_TANGENT]\n    // shader.locs[SHADER_LOC_VERTEX_COLOR]         // Set by default internal shader\n\n    // Vertex shader uniform locations (default)\n    // shader.locs[SHADER_LOC_MATRIX_MVP]           // Set by default internal shader\n    // shader.locs[SHADER_LOC_MATRIX_VIEW]\n    // shader.locs[SHADER_LOC_MATRIX_PROJECTION]\n    // shader.locs[SHADER_LOC_MATRIX_MODEL]\n    // shader.locs[SHADER_LOC_MATRIX_NORMAL]\n\n    // Fragment shader uniform locations (default)\n    // shader.locs[SHADER_LOC_COLOR_DIFFUSE]        // Set by default internal shader\n    // shader.locs[SHADER_LOC_MAP_DIFFUSE]          // Set by default internal shader\n    // shader.locs[SHADER_LOC_MAP_SPECULAR]\n    // shader.locs[SHADER_LOC_MAP_NORMAL]\n}\n\n// Unload shader from GPU memory (VRAM)\nvoid UnloadShader(Shader shader)\n{\n    if (shader.id != rlGetShaderIdDefault())\n    {\n        rlUnloadShaderProgram(shader.id);\n\n        // NOTE: If shader loading failed, it should be 0\n        RL_FREE(shader.locs);\n    }\n}\n\n// Get shader uniform location\nint GetShaderLocation(Shader shader, const char *uniformName)\n{\n    return rlGetLocationUniform(shader.id, uniformName);\n}\n\n// Get shader attribute location\nint GetShaderLocationAttrib(Shader shader, const char *attribName)\n{\n    return rlGetLocationAttrib(shader.id, attribName);\n}\n\n// Set shader uniform value\nvoid SetShaderValue(Shader shader, int locIndex, const void *value, int uniformType)\n{\n    SetShaderValueV(shader, locIndex, value, uniformType, 1);\n}\n\n// Set shader uniform value vector\nvoid SetShaderValueV(Shader shader, int locIndex, const void *value, int uniformType, int count)\n{\n    if (locIndex > -1)\n    {\n        rlEnableShader(shader.id);\n        rlSetUniform(locIndex, value, uniformType, count);\n        //rlDisableShader();      // Avoid resetting current shader program, in case other uniforms are set\n    }\n}\n\n// Set shader uniform value (matrix 4x4)\nvoid SetShaderValueMatrix(Shader shader, int locIndex, Matrix mat)\n{\n    if (locIndex > -1)\n    {\n        rlEnableShader(shader.id);\n        rlSetUniformMatrix(locIndex, mat);\n        //rlDisableShader();\n    }\n}\n\n// Set shader uniform value for texture\nvoid SetShaderValueTexture(Shader shader, int locIndex, Texture2D texture)\n{\n    if (locIndex > -1)\n    {\n        rlEnableShader(shader.id);\n        rlSetUniformSampler(locIndex, texture.id);\n        //rlDisableShader();\n    }\n}\n\n// Get a ray trace from mouse position\nRay GetMouseRay(Vector2 mouse, Camera camera)\n{\n    Ray ray = { 0 };\n\n    // Calculate normalized device coordinates\n    // NOTE: y value is negative\n    float x = (2.0f*mouse.x)/(float)GetScreenWidth() - 1.0f;\n    float y = 1.0f - (2.0f*mouse.y)/(float)GetScreenHeight();\n    float z = 1.0f;\n\n    // Store values in a vector\n    Vector3 deviceCoords = { x, y, z };\n\n    // Calculate view matrix from camera look at\n    Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);\n\n    Matrix matProj = MatrixIdentity();\n\n    if (camera.projection == CAMERA_PERSPECTIVE)\n    {\n        // Calculate projection matrix from perspective\n        matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)GetScreenWidth()/(double)GetScreenHeight()), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC)\n    {\n        float aspect = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;\n        double top = camera.fovy/2.0;\n        double right = top*aspect;\n\n        // Calculate projection matrix from orthographic\n        matProj = MatrixOrtho(-right, right, -top, top, 0.01, 1000.0);\n    }\n\n    // Unproject far/near points\n    Vector3 nearPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 0.0f }, matProj, matView);\n    Vector3 farPoint = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, 1.0f }, matProj, matView);\n\n    // Unproject the mouse cursor in the near plane.\n    // We need this as the source position because orthographic projects, compared to perspective doesn't have a\n    // convergence point, meaning that the \"eye\" of the camera is more like a plane than a point.\n    Vector3 cameraPlanePointerPos = Vector3Unproject((Vector3){ deviceCoords.x, deviceCoords.y, -1.0f }, matProj, matView);\n\n    // Calculate normalized direction vector\n    Vector3 direction = Vector3Normalize(Vector3Subtract(farPoint, nearPoint));\n\n    if (camera.projection == CAMERA_PERSPECTIVE) ray.position = camera.position;\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC) ray.position = cameraPlanePointerPos;\n\n    // Apply calculated vectors to ray\n    ray.direction = direction;\n\n    return ray;\n}\n\n// Get transform matrix for camera\nMatrix GetCameraMatrix(Camera camera)\n{\n    return MatrixLookAt(camera.position, camera.target, camera.up);\n}\n\n// Get camera 2d transform matrix\nMatrix GetCameraMatrix2D(Camera2D camera)\n{\n    Matrix matTransform = { 0 };\n    // The camera in world-space is set by\n    //   1. Move it to target\n    //   2. Rotate by -rotation and scale by (1/zoom)\n    //      When setting higher scale, it's more intuitive for the world to become bigger (= camera become smaller),\n    //      not for the camera getting bigger, hence the invert. Same deal with rotation.\n    //   3. Move it by (-offset);\n    //      Offset defines target transform relative to screen, but since we're effectively \"moving\" screen (camera)\n    //      we need to do it into opposite direction (inverse transform)\n\n    // Having camera transform in world-space, inverse of it gives the modelview transform.\n    // Since (A*B*C)' = C'*B'*A', the modelview is\n    //   1. Move to offset\n    //   2. Rotate and Scale\n    //   3. Move by -target\n    Matrix matOrigin = MatrixTranslate(-camera.target.x, -camera.target.y, 0.0f);\n    Matrix matRotation = MatrixRotate((Vector3){ 0.0f, 0.0f, 1.0f }, camera.rotation*DEG2RAD);\n    Matrix matScale = MatrixScale(camera.zoom, camera.zoom, 1.0f);\n    Matrix matTranslation = MatrixTranslate(camera.offset.x, camera.offset.y, 0.0f);\n\n    matTransform = MatrixMultiply(MatrixMultiply(matOrigin, MatrixMultiply(matScale, matRotation)), matTranslation);\n\n    return matTransform;\n}\n\n// Get the screen space position from a 3d world space position\nVector2 GetWorldToScreen(Vector3 position, Camera camera)\n{\n    Vector2 screenPosition = GetWorldToScreenEx(position, camera, GetScreenWidth(), GetScreenHeight());\n\n    return screenPosition;\n}\n\n// Get size position for a 3d world space position (useful for texture drawing)\nVector2 GetWorldToScreenEx(Vector3 position, Camera camera, int width, int height)\n{\n    // Calculate projection matrix (from perspective instead of frustum\n    Matrix matProj = MatrixIdentity();\n\n    if (camera.projection == CAMERA_PERSPECTIVE)\n    {\n        // Calculate projection matrix from perspective\n        matProj = MatrixPerspective(camera.fovy*DEG2RAD, ((double)width/(double)height), RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n    else if (camera.projection == CAMERA_ORTHOGRAPHIC)\n    {\n        float aspect = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;\n        double top = camera.fovy/2.0;\n        double right = top*aspect;\n\n        // Calculate projection matrix from orthographic\n        matProj = MatrixOrtho(-right, right, -top, top, RL_CULL_DISTANCE_NEAR, RL_CULL_DISTANCE_FAR);\n    }\n\n    // Calculate view matrix from camera look at (and transpose it)\n    Matrix matView = MatrixLookAt(camera.position, camera.target, camera.up);\n\n    // TODO: Why not use Vector3Transform(Vector3 v, Matrix mat)?\n\n    // Convert world position vector to quaternion\n    Quaternion worldPos = { position.x, position.y, position.z, 1.0f };\n\n    // Transform world position to view\n    worldPos = QuaternionTransform(worldPos, matView);\n\n    // Transform result to projection (clip space position)\n    worldPos = QuaternionTransform(worldPos, matProj);\n\n    // Calculate normalized device coordinates (inverted y)\n    Vector3 ndcPos = { worldPos.x/worldPos.w, -worldPos.y/worldPos.w, worldPos.z/worldPos.w };\n\n    // Calculate 2d screen position vector\n    Vector2 screenPosition = { (ndcPos.x + 1.0f)/2.0f*(float)width, (ndcPos.y + 1.0f)/2.0f*(float)height };\n\n    return screenPosition;\n}\n\n// Get the screen space position for a 2d camera world space position\nVector2 GetWorldToScreen2D(Vector2 position, Camera2D camera)\n{\n    Matrix matCamera = GetCameraMatrix2D(camera);\n    Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, matCamera);\n\n    return (Vector2){ transform.x, transform.y };\n}\n\n// Get the world space position for a 2d camera screen space position\nVector2 GetScreenToWorld2D(Vector2 position, Camera2D camera)\n{\n    Matrix invMatCamera = MatrixInvert(GetCameraMatrix2D(camera));\n    Vector3 transform = Vector3Transform((Vector3){ position.x, position.y, 0 }, invMatCamera);\n\n    return (Vector2){ transform.x, transform.y };\n}\n\n// Set target FPS (maximum)\nvoid SetTargetFPS(int fps)\n{\n    if (fps < 1) CORE.Time.target = 0.0;\n    else CORE.Time.target = 1.0/(double)fps;\n\n    TRACELOG(LOG_INFO, \"TIMER: Target time per frame: %02.03f milliseconds\", (float)CORE.Time.target*1000.0f);\n}\n\n// Get current FPS\n// NOTE: We calculate an average framerate\nint GetFPS(void)\n{\n    int fps = 0;\n\n#if !defined(SUPPORT_CUSTOM_FRAME_CONTROL)\n    #define FPS_CAPTURE_FRAMES_COUNT    30      // 30 captures\n    #define FPS_AVERAGE_TIME_SECONDS   0.5f     // 500 millisecondes\n    #define FPS_STEP (FPS_AVERAGE_TIME_SECONDS/FPS_CAPTURE_FRAMES_COUNT)\n\n    static int index = 0;\n    static float history[FPS_CAPTURE_FRAMES_COUNT] = { 0 };\n    static float average = 0, last = 0;\n    float fpsFrame = GetFrameTime();\n\n    if (fpsFrame == 0) return 0;\n\n    if ((GetTime() - last) > FPS_STEP)\n    {\n        last = (float)GetTime();\n        index = (index + 1)%FPS_CAPTURE_FRAMES_COUNT;\n        average -= history[index];\n        history[index] = fpsFrame/FPS_CAPTURE_FRAMES_COUNT;\n        average += history[index];\n    }\n\n    fps = (int)roundf(1.0f/average);\n#endif\n\n    return fps;\n}\n\n// Get time in seconds for last frame drawn (delta time)\nfloat GetFrameTime(void)\n{\n    return (float)CORE.Time.frame;\n}\n\n// Get elapsed time measure in seconds since InitTimer()\n// NOTE: On PLATFORM_DESKTOP InitTimer() is called on InitWindow()\n// NOTE: On PLATFORM_DESKTOP, timer is initialized on glfwInit()\ndouble GetTime(void)\n{\n    double time = 0.0;\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    time = glfwGetTime();   // Elapsed time since glfwInit()\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    struct timespec ts = { 0 };\n    clock_gettime(CLOCK_MONOTONIC, &ts);\n    unsigned long long int nanoSeconds = (unsigned long long int)ts.tv_sec*1000000000LLU + (unsigned long long int)ts.tv_nsec;\n\n    time = (double)(nanoSeconds - CORE.Time.base)*1e-9;  // Elapsed time since InitTimer()\n#endif\n    return time;\n}\n\n// Setup window configuration flags (view FLAGS)\n// NOTE: This function is expected to be called before window creation,\n// because it sets up some flags for the window creation process.\n// To configure window states after creation, just use SetWindowState()\nvoid SetConfigFlags(unsigned int flags)\n{\n    // Selected flags are set but not evaluated at this point,\n    // flag evaluation happens at InitWindow() or SetWindowState()\n    CORE.Window.flags |= flags;\n}\n\n// NOTE TRACELOG() function is located in [utils.h]\n\n// Takes a screenshot of current screen (saved a .png)\nvoid TakeScreenshot(const char *fileName)\n{\n#if defined(SUPPORT_MODULE_RTEXTURES)\n    // Security check to (partially) avoid malicious code on PLATFORM_WEB\n    if (strchr(fileName, '\\'') != NULL) { TRACELOG(LOG_WARNING, \"SYSTEM: Provided fileName could be potentially malicious, avoid [\\'] character\");  return; }\n\n    Vector2 scale = GetWindowScaleDPI();\n    unsigned char *imgData = rlReadScreenPixels((int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n    Image image = { imgData, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y), 1, PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 };\n\n    char path[2048] = { 0 };\n    strcpy(path, TextFormat(\"%s/%s\", CORE.Storage.basePath, fileName));\n\n    ExportImage(image, path);           // WARNING: Module required: rtextures\n    RL_FREE(imgData);\n\n#if defined(PLATFORM_WEB)\n    // Download file from MEMFS (emscripten memory filesystem)\n    // saveFileFromMEMFSToDisk() function is defined in raylib/src/shell.html\n    emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", GetFileName(path), GetFileName(path)));\n#endif\n\n    TRACELOG(LOG_INFO, \"SYSTEM: [%s] Screenshot taken successfully\", path);\n#else\n    TRACELOG(LOG_WARNING,\"IMAGE: ExportImage() requires module: rtextures\");\n#endif\n}\n\n// Get a random value between min and max (both included)\n// WARNING: Ranges higher than RAND_MAX will return invalid results\n// More specifically, if (max - min) > INT_MAX there will be an overflow,\n// and otherwise if (max - min) > RAND_MAX the random value will incorrectly never exceed a certain threshold\nint GetRandomValue(int min, int max)\n{\n    if (min > max)\n    {\n        int tmp = max;\n        max = min;\n        min = tmp;\n    }\n\n    if ((unsigned int)(max - min) > (unsigned int)RAND_MAX)\n    {\n        TRACELOG(LOG_WARNING, \"Invalid GetRandomValue() arguments, range should not be higher than %i\", RAND_MAX);\n    }\n\n    return (rand()%(abs(max - min) + 1) + min);\n}\n\n// Set the seed for the random number generator\nvoid SetRandomSeed(unsigned int seed)\n{\n    srand(seed);\n}\n\n// Check if the file exists\nbool FileExists(const char *fileName)\n{\n    bool result = false;\n\n#if defined(_WIN32)\n    if (_access(fileName, 0) != -1) result = true;\n#else\n    if (access(fileName, F_OK) != -1) result = true;\n#endif\n\n    // NOTE: Alternatively, stat() can be used instead of access()\n    //#include <sys/stat.h>\n    //struct stat statbuf;\n    //if (stat(filename, &statbuf) == 0) result = true;\n\n    return result;\n}\n\n// Check file extension\n// NOTE: Extensions checking is not case-sensitive\nbool IsFileExtension(const char *fileName, const char *ext)\n{\n    #define MAX_FILE_EXTENSION_SIZE  16\n\n    bool result = false;\n    const char *fileExt = GetFileExtension(fileName);\n\n    if (fileExt != NULL)\n    {\n#if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_TEXT_MANIPULATION)\n        int extCount = 0;\n        const char **checkExts = TextSplit(ext, ';', &extCount);  // WARNING: Module required: rtext\n\n        char fileExtLower[MAX_FILE_EXTENSION_SIZE + 1] = { 0 };\n        strncpy(fileExtLower, TextToLower(fileExt),MAX_FILE_EXTENSION_SIZE);  // WARNING: Module required: rtext\n\n        for (int i = 0; i < extCount; i++)\n        {\n            if (strcmp(fileExtLower, TextToLower(checkExts[i])) == 0)\n            {\n                result = true;\n                break;\n            }\n        }\n#else\n        if (strcmp(fileExt, ext) == 0) result = true;\n#endif\n    }\n\n    return result;\n}\n\n// Check if a directory path exists\nbool DirectoryExists(const char *dirPath)\n{\n    bool result = false;\n    DIR *dir = opendir(dirPath);\n\n    if (dir != NULL)\n    {\n        result = true;\n        closedir(dir);\n    }\n\n    return result;\n}\n\n// Get file length in bytes\n// NOTE: GetFileSize() conflicts with windows.h\nint GetFileLength(const char *fileName)\n{\n    int size = 0;\n\n    FILE *file = fopen(fileName, \"rb\");\n\n    if (file != NULL)\n    {\n        fseek(file, 0L, SEEK_END);\n        size = (int)ftell(file);\n        fclose(file);\n    }\n\n    return size;\n}\n\n// Get pointer to extension for a filename string (includes the dot: .png)\nconst char *GetFileExtension(const char *fileName)\n{\n    const char *dot = strrchr(fileName, '.');\n\n    if (!dot || dot == fileName) return NULL;\n\n    return dot;\n}\n\n// String pointer reverse break: returns right-most occurrence of charset in s\nstatic const char *strprbrk(const char *s, const char *charset)\n{\n    const char *latestMatch = NULL;\n    for (; s = strpbrk(s, charset), s != NULL; latestMatch = s++) { }\n    return latestMatch;\n}\n\n// Get pointer to filename for a path string\nconst char *GetFileName(const char *filePath)\n{\n    const char *fileName = NULL;\n    if (filePath != NULL) fileName = strprbrk(filePath, \"\\\\/\");\n\n    if (!fileName) return filePath;\n\n    return fileName + 1;\n}\n\n// Get filename string without extension (uses static string)\nconst char *GetFileNameWithoutExt(const char *filePath)\n{\n    #define MAX_FILENAMEWITHOUTEXT_LENGTH   256\n\n    static char fileName[MAX_FILENAMEWITHOUTEXT_LENGTH] = { 0 };\n    memset(fileName, 0, MAX_FILENAMEWITHOUTEXT_LENGTH);\n\n    if (filePath != NULL) strcpy(fileName, GetFileName(filePath));   // Get filename with extension\n\n    int size = (int)strlen(fileName);   // Get size in bytes\n\n    for (int i = 0; (i < size) && (i < MAX_FILENAMEWITHOUTEXT_LENGTH); i++)\n    {\n        if (fileName[i] == '.')\n        {\n            // NOTE: We break on first '.' found\n            fileName[i] = '\\0';\n            break;\n        }\n    }\n\n    return fileName;\n}\n\n// Get directory for a given filePath\nconst char *GetDirectoryPath(const char *filePath)\n{\n/*\n    // NOTE: Directory separator is different in Windows and other platforms,\n    // fortunately, Windows also support the '/' separator, that's the one should be used\n    #if defined(_WIN32)\n        char separator = '\\\\';\n    #else\n        char separator = '/';\n    #endif\n*/\n    const char *lastSlash = NULL;\n    static char dirPath[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(dirPath, 0, MAX_FILEPATH_LENGTH);\n\n    // In case provided path does not contain a root drive letter (C:\\, D:\\) nor leading path separator (\\, /),\n    // we add the current directory path to dirPath\n    if (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/')\n    {\n        // For security, we set starting path to current directory,\n        // obtained path will be concatenated to this\n        dirPath[0] = '.';\n        dirPath[1] = '/';\n    }\n\n    lastSlash = strprbrk(filePath, \"\\\\/\");\n    if (lastSlash)\n    {\n        if (lastSlash == filePath)\n        {\n            // The last and only slash is the leading one: path is in a root directory\n            dirPath[0] = filePath[0];\n            dirPath[1] = '\\0';\n        }\n        else\n        {\n            // NOTE: Be careful, strncpy() is not safe, it does not care about '\\0'\n            memcpy(dirPath + (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/' ? 2 : 0), filePath, strlen(filePath) - (strlen(lastSlash) - 1));\n            dirPath[strlen(filePath) - strlen(lastSlash) + (filePath[1] != ':' && filePath[0] != '\\\\' && filePath[0] != '/' ? 2 : 0)] = '\\0';  // Add '\\0' manually\n        }\n    }\n\n    return dirPath;\n}\n\n// Get previous directory path for a given path\nconst char *GetPrevDirectoryPath(const char *dirPath)\n{\n    static char prevDirPath[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(prevDirPath, 0, MAX_FILEPATH_LENGTH);\n    int pathLen = (int)strlen(dirPath);\n\n    if (pathLen <= 3) strcpy(prevDirPath, dirPath);\n\n    for (int i = (pathLen - 1); (i >= 0) && (pathLen > 3); i--)\n    {\n        if ((dirPath[i] == '\\\\') || (dirPath[i] == '/'))\n        {\n            // Check for root: \"C:\\\" or \"/\"\n            if (((i == 2) && (dirPath[1] ==':')) || (i == 0)) i++;\n\n            strncpy(prevDirPath, dirPath, i);\n            break;\n        }\n    }\n\n    return prevDirPath;\n}\n\n// Get current working directory\nconst char *GetWorkingDirectory(void)\n{\n    static char currentDir[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(currentDir, 0, MAX_FILEPATH_LENGTH);\n\n    char *path = GETCWD(currentDir, MAX_FILEPATH_LENGTH - 1);\n\n    return path;\n}\n\nconst char *GetApplicationDirectory(void)\n{\n    static char appDir[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(appDir, 0, MAX_FILEPATH_LENGTH);\n\n#if defined(_WIN32)\n    int len = 0;\n#if defined (UNICODE)\n    unsigned short widePath[MAX_PATH];\n    len = GetModuleFileNameW(NULL, widePath, MAX_PATH);\n    len = WideCharToMultiByte(0, 0, widePath, len, appDir, MAX_PATH, NULL, NULL);\n#else\n    len = GetModuleFileNameA(NULL, appDir, MAX_PATH);\n#endif\n    if (len > 0)\n    {\n        for (int i = len; i >= 0; --i)\n        {\n            if (appDir[i] == '\\\\')\n            {\n                appDir[i + 1] = '\\0';\n                break;\n            }\n        }\n    }\n    else\n    {\n        appDir[0] = '.';\n        appDir[1] = '\\\\';\n    }\n\n#elif defined(__linux__)\n    unsigned int size = sizeof(appDir);\n    ssize_t len = readlink(\"/proc/self/exe\", appDir, size);\n\n    if (len > 0)\n    {\n        for (int i = len; i >= 0; --i)\n        {\n            if (appDir[i] == '/')\n            {\n                appDir[i + 1] = '\\0';\n                break;\n            }\n        }\n    }\n    else\n    {\n        appDir[0] = '.';\n        appDir[1] = '/';\n    }\n#elif defined(__APPLE__)\n    uint32_t size = sizeof(appDir);\n\n    if (_NSGetExecutablePath(appDir, &size) == 0)\n    {\n        int len = strlen(appDir);\n        for (int i = len; i >= 0; --i)\n        {\n            if (appDir[i] == '/')\n            {\n                appDir[i + 1] = '\\0';\n                break;\n            }\n        }\n    }\n    else\n    {\n        appDir[0] = '.';\n        appDir[1] = '/';\n    }\n#endif\n\n    return appDir;\n}\n\n// Load directory filepaths\n// NOTE: Base path is prepended to the scanned filepaths\n// WARNING: Directory is scanned twice, first time to get files count\n// No recursive scanning is done!\nFilePathList LoadDirectoryFiles(const char *dirPath)\n{\n    FilePathList files = { 0 };\n    unsigned int fileCounter = 0;\n\n    struct dirent *entity;\n    DIR *dir = opendir(dirPath);\n\n    if (dir != NULL) // It's a directory\n    {\n        // SCAN 1: Count files\n        while ((entity = readdir(dir)) != NULL)\n        {\n            // NOTE: We skip '.' (current dir) and '..' (parent dir) filepaths\n            if ((strcmp(entity->d_name, \".\") != 0) && (strcmp(entity->d_name, \"..\") != 0)) fileCounter++;\n        }\n\n        // Memory allocation for dirFileCount\n        files.capacity = fileCounter;\n        files.paths = (char **)RL_MALLOC(files.capacity*sizeof(char *));\n        for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_MALLOC(MAX_FILEPATH_LENGTH*sizeof(char));\n\n        closedir(dir);\n\n        // SCAN 2: Read filepaths\n        // NOTE: Directory paths are also registered\n        ScanDirectoryFiles(dirPath, &files, NULL);\n\n        // Security check: read files.count should match fileCounter\n        if (files.count != files.capacity) TRACELOG(LOG_WARNING, \"FILEIO: Read files count do not match capacity allocated\");\n    }\n    else TRACELOG(LOG_WARNING, \"FILEIO: Failed to open requested directory\");  // Maybe it's a file...\n\n    return files;\n}\n\n// Load directory filepaths with extension filtering and recursive directory scan\n// NOTE: On recursive loading we do not pre-scan for file count, we use MAX_FILEPATH_CAPACITY\nFilePathList LoadDirectoryFilesEx(const char *basePath, const char *filter, bool scanSubdirs)\n{\n    FilePathList files = { 0 };\n\n    files.capacity = MAX_FILEPATH_CAPACITY;\n    files.paths = (char **)RL_CALLOC(files.capacity, sizeof(char *));\n    for (unsigned int i = 0; i < files.capacity; i++) files.paths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));\n\n    // WARNING: basePath is always prepended to scanned paths\n    if (scanSubdirs) ScanDirectoryFilesRecursively(basePath, &files, filter);\n    else ScanDirectoryFiles(basePath, &files, filter);\n\n    return files;\n}\n\n// Unload directory filepaths\n// WARNING: files.count is not reseted to 0 after unloading\nvoid UnloadDirectoryFiles(FilePathList files)\n{\n    for (unsigned int i = 0; i < files.capacity; i++) RL_FREE(files.paths[i]);\n\n    RL_FREE(files.paths);\n}\n\n// Change working directory, returns true on success\nbool ChangeDirectory(const char *dir)\n{\n    bool result = CHDIR(dir);\n\n    if (result != 0) TRACELOG(LOG_WARNING, \"SYSTEM: Failed to change to directory: %s\", dir);\n\n    return (result == 0);\n}\n\n// Check if a given path point to a file\nbool IsPathFile(const char *path)\n{\n    struct stat pathStat = { 0 };\n    stat(path, &pathStat);\n\n    return S_ISREG(pathStat.st_mode);\n}\n\n// Check if a file has been dropped into window\nbool IsFileDropped(void)\n{\n    if (CORE.Window.dropFileCount > 0) return true;\n    else return false;\n}\n\n// Load dropped filepaths\nFilePathList LoadDroppedFiles(void)\n{\n    FilePathList files = { 0 };\n\n    files.count = CORE.Window.dropFileCount;\n    files.paths = CORE.Window.dropFilepaths;\n\n    return files;\n}\n\n// Unload dropped filepaths\nvoid UnloadDroppedFiles(FilePathList files)\n{\n    // WARNING: files pointers are the same as internal ones\n\n    if (files.count > 0)\n    {\n        for (unsigned int i = 0; i < files.count; i++) RL_FREE(files.paths[i]);\n\n        RL_FREE(files.paths);\n\n        CORE.Window.dropFileCount = 0;\n        CORE.Window.dropFilepaths = NULL;\n    }\n}\n\n// Get file modification time (last write time)\nlong GetFileModTime(const char *fileName)\n{\n    struct stat result = { 0 };\n\n    if (stat(fileName, &result) == 0)\n    {\n        time_t mod = result.st_mtime;\n\n        return (long)mod;\n    }\n\n    return 0;\n}\n\n// Compress data (DEFLATE algorithm)\nunsigned char *CompressData(const unsigned char *data, int dataSize, int *compDataSize)\n{\n    #define COMPRESSION_QUALITY_DEFLATE  8\n\n    unsigned char *compData = NULL;\n\n#if defined(SUPPORT_COMPRESSION_API)\n    // Compress data and generate a valid DEFLATE stream\n    struct sdefl sdefl = { 0 };\n    int bounds = sdefl_bound(dataSize);\n    compData = (unsigned char *)RL_CALLOC(bounds, 1);\n    *compDataSize = sdeflate(&sdefl, compData, data, dataSize, COMPRESSION_QUALITY_DEFLATE);   // Compression level 8, same as stbwi\n\n    TRACELOG(LOG_INFO, \"SYSTEM: Compress data: Original size: %i -> Comp. size: %i\", dataSize, *compDataSize);\n#endif\n\n    return compData;\n}\n\n// Decompress data (DEFLATE algorithm)\nunsigned char *DecompressData(const unsigned char *compData, int compDataSize, int *dataSize)\n{\n    unsigned char *data = NULL;\n\n#if defined(SUPPORT_COMPRESSION_API)\n    // Decompress data from a valid DEFLATE stream\n    data = (unsigned char *)RL_CALLOC(MAX_DECOMPRESSION_SIZE*1024*1024, 1);\n    int length = sinflate(data, MAX_DECOMPRESSION_SIZE*1024*1024, compData, compDataSize);\n\n    // WARNING: RL_REALLOC can make (and leave) data copies in memory, be careful with sensitive compressed data!\n    // TODO: Use a different approach, create another buffer, copy data manually to it and wipe original buffer memory\n    unsigned char *temp = (unsigned char *)RL_REALLOC(data, length);\n\n    if (temp != NULL) data = temp;\n    else TRACELOG(LOG_WARNING, \"SYSTEM: Failed to re-allocate required decompression memory\");\n\n    *dataSize = length;\n\n    TRACELOG(LOG_INFO, \"SYSTEM: Decompress data: Comp. size: %i -> Original size: %i\", compDataSize, *dataSize);\n#endif\n\n    return data;\n}\n\n// Encode data to Base64 string\nchar *EncodeDataBase64(const unsigned char *data, int dataSize, int *outputSize)\n{\n    static const unsigned char base64encodeTable[] = {\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n        'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'\n    };\n\n    static const int modTable[] = { 0, 2, 1 };\n\n    *outputSize = 4*((dataSize + 2)/3);\n\n    char *encodedData = (char *)RL_MALLOC(*outputSize);\n\n    if (encodedData == NULL) return NULL;\n\n    for (int i = 0, j = 0; i < dataSize;)\n    {\n        unsigned int octetA = (i < dataSize)? (unsigned char)data[i++] : 0;\n        unsigned int octetB = (i < dataSize)? (unsigned char)data[i++] : 0;\n        unsigned int octetC = (i < dataSize)? (unsigned char)data[i++] : 0;\n\n        unsigned int triple = (octetA << 0x10) + (octetB << 0x08) + octetC;\n\n        encodedData[j++] = base64encodeTable[(triple >> 3*6) & 0x3F];\n        encodedData[j++] = base64encodeTable[(triple >> 2*6) & 0x3F];\n        encodedData[j++] = base64encodeTable[(triple >> 1*6) & 0x3F];\n        encodedData[j++] = base64encodeTable[(triple >> 0*6) & 0x3F];\n    }\n\n    for (int i = 0; i < modTable[dataSize%3]; i++) encodedData[*outputSize - 1 - i] = '=';  // Padding character\n\n    return encodedData;\n}\n\n// Decode Base64 string data\nunsigned char *DecodeDataBase64(const unsigned char *data, int *outputSize)\n{\n    static const unsigned char base64decodeTable[] = {\n        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 62, 0, 0, 0, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n        11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0, 0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36,\n        37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n    };\n\n    // Get output size of Base64 input data\n    int outSize = 0;\n    for (int i = 0; data[4*i] != 0; i++)\n    {\n        if (data[4*i + 3] == '=')\n        {\n            if (data[4*i + 2] == '=') outSize += 1;\n            else outSize += 2;\n        }\n        else outSize += 3;\n    }\n\n    // Allocate memory to store decoded Base64 data\n    unsigned char *decodedData = (unsigned char *)RL_MALLOC(outSize);\n\n    for (int i = 0; i < outSize/3; i++)\n    {\n        unsigned char a = base64decodeTable[(int)data[4*i]];\n        unsigned char b = base64decodeTable[(int)data[4*i + 1]];\n        unsigned char c = base64decodeTable[(int)data[4*i + 2]];\n        unsigned char d = base64decodeTable[(int)data[4*i + 3]];\n\n        decodedData[3*i] = (a << 2) | (b >> 4);\n        decodedData[3*i + 1] = (b << 4) | (c >> 2);\n        decodedData[3*i + 2] = (c << 6) | d;\n    }\n\n    if (outSize%3 == 1)\n    {\n        int n = outSize/3;\n        unsigned char a = base64decodeTable[(int)data[4*n]];\n        unsigned char b = base64decodeTable[(int)data[4*n + 1]];\n        decodedData[outSize - 1] = (a << 2) | (b >> 4);\n    }\n    else if (outSize%3 == 2)\n    {\n        int n = outSize/3;\n        unsigned char a = base64decodeTable[(int)data[4*n]];\n        unsigned char b = base64decodeTable[(int)data[4*n + 1]];\n        unsigned char c = base64decodeTable[(int)data[4*n + 2]];\n        decodedData[outSize - 2] = (a << 2) | (b >> 4);\n        decodedData[outSize - 1] = (b << 4) | (c >> 2);\n    }\n\n    *outputSize = outSize;\n    return decodedData;\n}\n\n// Open URL with default system browser (if available)\n// NOTE: This function is only safe to use if you control the URL given.\n// A user could craft a malicious string performing another action.\n// Only call this function yourself not with user input or make sure to check the string yourself.\n// Ref: https://github.com/raysan5/raylib/issues/686\nvoid OpenURL(const char *url)\n{\n    // Security check to (aprtially) avoid malicious code on PLATFORM_WEB\n    if (strchr(url, '\\'') != NULL) TRACELOG(LOG_WARNING, \"SYSTEM: Provided URL could be potentially malicious, avoid [\\'] character\");\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        char *cmd = (char *)RL_CALLOC(strlen(url) + 32, sizeof(char));\n    #if defined(_WIN32)\n        sprintf(cmd, \"explorer \\\"%s\\\"\", url);\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__)\n        sprintf(cmd, \"xdg-open '%s'\", url); // Alternatives: firefox, x-www-browser\n    #endif\n    #if defined(__APPLE__)\n        sprintf(cmd, \"open '%s'\", url);\n    #endif\n        int result = system(cmd);\n        if (result == -1) TRACELOG(LOG_WARNING, \"OpenURL() child process could not be created\");\n        RL_FREE(cmd);\n#endif\n#if defined(PLATFORM_WEB)\n        emscripten_run_script(TextFormat(\"window.open('%s', '_blank')\", url));\n#endif\n#if defined(PLATFORM_ANDROID)\n        JNIEnv *env = NULL;\n        JavaVM *vm = CORE.Android.app->activity->vm;\n        (*vm)->AttachCurrentThread(vm, &env, NULL);\n\n        jstring urlString = (*env)->NewStringUTF(env, url);\n        jclass uriClass = (*env)->FindClass(env, \"android/net/Uri\");\n        jmethodID uriParse = (*env)->GetStaticMethodID(env, uriClass, \"parse\", \"(Ljava/lang/String;)Landroid/net/Uri;\");\n        jobject uri = (*env)->CallStaticObjectMethod(env, uriClass, uriParse, urlString);\n\n        jclass intentClass = (*env)->FindClass(env, \"android/content/Intent\");\n        jfieldID actionViewId = (*env)->GetStaticFieldID(env, intentClass, \"ACTION_VIEW\", \"Ljava/lang/String;\");\n        jobject actionView = (*env)->GetStaticObjectField(env, intentClass, actionViewId);\n        jmethodID newIntent = (*env)->GetMethodID(env, intentClass, \"<init>\", \"(Ljava/lang/String;Landroid/net/Uri;)V\");\n        jobject intent = (*env)->AllocObject(env, intentClass);\n\n        (*env)->CallVoidMethod(env, intent, newIntent, actionView, uri);\n        jclass activityClass = (*env)->FindClass(env, \"android/app/Activity\");\n        jmethodID startActivity = (*env)->GetMethodID(env, activityClass, \"startActivity\", \"(Landroid/content/Intent;)V\");\n        (*env)->CallVoidMethod(env, CORE.Android.app->activity->clazz, startActivity, intent);\n\n        (*vm)->DetachCurrentThread(vm);\n#endif\n    }\n}\n\n//----------------------------------------------------------------------------------\n// Module Functions Definition - Input (Keyboard, Mouse, Gamepad) Functions\n//----------------------------------------------------------------------------------\n// Check if a key has been pressed once\nbool IsKeyPressed(int key)\n{\n    bool pressed = false;\n\n    if ((CORE.Input.Keyboard.previousKeyState[key] == 0) && (CORE.Input.Keyboard.currentKeyState[key] == 1)) pressed = true;\n\n    return pressed;\n}\n\n// Check if a key is being pressed (key held down)\nbool IsKeyDown(int key)\n{\n    if (CORE.Input.Keyboard.currentKeyState[key] == 1) return true;\n    else return false;\n}\n\n// Check if a key has been released once\nbool IsKeyReleased(int key)\n{\n    bool released = false;\n\n    if ((CORE.Input.Keyboard.previousKeyState[key] == 1) && (CORE.Input.Keyboard.currentKeyState[key] == 0)) released = true;\n\n    return released;\n}\n\n// Check if a key is NOT being pressed (key not held down)\nbool IsKeyUp(int key)\n{\n    if (CORE.Input.Keyboard.currentKeyState[key] == 0) return true;\n    else return false;\n}\n\n// Get the last key pressed\nint GetKeyPressed(void)\n{\n    int value = 0;\n\n    if (CORE.Input.Keyboard.keyPressedQueueCount > 0)\n    {\n        // Get character from the queue head\n        value = CORE.Input.Keyboard.keyPressedQueue[0];\n\n        // Shift elements 1 step toward the head.\n        for (int i = 0; i < (CORE.Input.Keyboard.keyPressedQueueCount - 1); i++)\n            CORE.Input.Keyboard.keyPressedQueue[i] = CORE.Input.Keyboard.keyPressedQueue[i + 1];\n\n        // Reset last character in the queue\n        CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount - 1] = 0;\n        CORE.Input.Keyboard.keyPressedQueueCount--;\n    }\n\n    return value;\n}\n\n// Get the last char pressed\nint GetCharPressed(void)\n{\n    int value = 0;\n\n    if (CORE.Input.Keyboard.charPressedQueueCount > 0)\n    {\n        // Get character from the queue head\n        value = CORE.Input.Keyboard.charPressedQueue[0];\n\n        // Shift elements 1 step toward the head.\n        for (int i = 0; i < (CORE.Input.Keyboard.charPressedQueueCount - 1); i++)\n            CORE.Input.Keyboard.charPressedQueue[i] = CORE.Input.Keyboard.charPressedQueue[i + 1];\n\n        // Reset last character in the queue\n        CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount - 1] = 0;\n        CORE.Input.Keyboard.charPressedQueueCount--;\n    }\n\n    return value;\n}\n\n// Set a custom key to exit program\n// NOTE: default exitKey is ESCAPE\nvoid SetExitKey(int key)\n{\n#if !defined(PLATFORM_ANDROID)\n    CORE.Input.Keyboard.exitKey = key;\n#endif\n}\n\n// NOTE: Gamepad support not implemented in emscripten GLFW3 (PLATFORM_WEB)\n\n// Check if a gamepad is available\nbool IsGamepadAvailable(int gamepad)\n{\n    bool result = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad]) result = true;\n\n    return result;\n}\n\n// Get gamepad internal name id\nconst char *GetGamepadName(int gamepad)\n{\n#if defined(PLATFORM_DESKTOP)\n    if (CORE.Input.Gamepad.ready[gamepad]) return glfwGetJoystickName(gamepad);\n    else return NULL;\n#endif\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    if (CORE.Input.Gamepad.ready[gamepad]) ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGNAME(64), &CORE.Input.Gamepad.name[gamepad]);\n    return CORE.Input.Gamepad.name[gamepad];\n#endif\n#if defined(PLATFORM_WEB)\n    return CORE.Input.Gamepad.name[gamepad];\n#endif\n    return NULL;\n}\n\n// Get gamepad axis count\nint GetGamepadAxisCount(int gamepad)\n{\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    int axisCount = 0;\n    if (CORE.Input.Gamepad.ready[gamepad]) ioctl(CORE.Input.Gamepad.streamId[gamepad], JSIOCGAXES, &axisCount);\n    CORE.Input.Gamepad.axisCount = axisCount;\n#endif\n\n    return CORE.Input.Gamepad.axisCount;\n}\n\n// Get axis movement vector for a gamepad\nfloat GetGamepadAxisMovement(int gamepad, int axis)\n{\n    float value = 0;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (axis < MAX_GAMEPAD_AXIS) &&\n        (fabsf(CORE.Input.Gamepad.axisState[gamepad][axis]) > 0.1f)) value = CORE.Input.Gamepad.axisState[gamepad][axis];      // 0.1f = GAMEPAD_AXIS_MINIMUM_DRIFT/DELTA\n\n    return value;\n}\n\n// Check if a gamepad button has been pressed once\nbool IsGamepadButtonPressed(int gamepad, int button)\n{\n    bool pressed = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 0) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) pressed = true;\n\n    return pressed;\n}\n\n// Check if a gamepad button is being pressed\nbool IsGamepadButtonDown(int gamepad, int button)\n{\n    bool result = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 1)) result = true;\n\n    return result;\n}\n\n// Check if a gamepad button has NOT been pressed once\nbool IsGamepadButtonReleased(int gamepad, int button)\n{\n    bool released = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.previousButtonState[gamepad][button] == 1) && (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) released = true;\n\n    return released;\n}\n\n// Check if a gamepad button is NOT being pressed\nbool IsGamepadButtonUp(int gamepad, int button)\n{\n    bool result = false;\n\n    if ((gamepad < MAX_GAMEPADS) && CORE.Input.Gamepad.ready[gamepad] && (button < MAX_GAMEPAD_BUTTONS) &&\n        (CORE.Input.Gamepad.currentButtonState[gamepad][button] == 0)) result = true;\n\n    return result;\n}\n\n// Get the last gamepad button pressed\nint GetGamepadButtonPressed(void)\n{\n    return CORE.Input.Gamepad.lastButtonPressed;\n}\n\n// Set internal gamepad mappings\nint SetGamepadMappings(const char *mappings)\n{\n    int result = 0;\n\n#if defined(PLATFORM_DESKTOP)\n    result = glfwUpdateGamepadMappings(mappings);\n#endif\n\n    return result;\n}\n\n// Check if a mouse button has been pressed once\nbool IsMouseButtonPressed(int button)\n{\n    bool pressed = false;\n\n    if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) pressed = true;\n\n    // Map touches to mouse buttons checking\n    if ((CORE.Input.Touch.currentTouchState[button] == 1) && (CORE.Input.Touch.previousTouchState[button] == 0)) pressed = true;\n\n    return pressed;\n}\n\n// Check if a mouse button is being pressed\nbool IsMouseButtonDown(int button)\n{\n    bool down = false;\n\n    if (CORE.Input.Mouse.currentButtonState[button] == 1) down = true;\n\n    // Map touches to mouse buttons checking\n    if (CORE.Input.Touch.currentTouchState[button] == 1) down = true;\n\n    return down;\n}\n\n// Check if a mouse button has been released once\nbool IsMouseButtonReleased(int button)\n{\n    bool released = false;\n\n    if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) released = true;\n\n    // Map touches to mouse buttons checking\n    if ((CORE.Input.Touch.currentTouchState[button] == 0) && (CORE.Input.Touch.previousTouchState[button] == 1)) released = true;\n\n    return released;\n}\n\n// Check if a mouse button is NOT being pressed\nbool IsMouseButtonUp(int button)\n{\n    return !IsMouseButtonDown(button);\n}\n\n// Get mouse position X\nint GetMouseX(void)\n{\n#if defined(PLATFORM_ANDROID)\n    return (int)CORE.Input.Touch.position[0].x;\n#else\n    return (int)((CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x);\n#endif\n}\n\n// Get mouse position Y\nint GetMouseY(void)\n{\n#if defined(PLATFORM_ANDROID)\n    return (int)CORE.Input.Touch.position[0].y;\n#else\n    return (int)((CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y);\n#endif\n}\n\n// Get mouse position XY\nVector2 GetMousePosition(void)\n{\n    Vector2 position = { 0 };\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)\n    position = GetTouchPosition(0);\n#else\n    position.x = (CORE.Input.Mouse.currentPosition.x + CORE.Input.Mouse.offset.x)*CORE.Input.Mouse.scale.x;\n    position.y = (CORE.Input.Mouse.currentPosition.y + CORE.Input.Mouse.offset.y)*CORE.Input.Mouse.scale.y;\n#endif\n\n    return position;\n}\n\n// Get mouse delta between frames\nVector2 GetMouseDelta(void)\n{\n    Vector2 delta = { 0 };\n\n    delta.x = CORE.Input.Mouse.currentPosition.x - CORE.Input.Mouse.previousPosition.x;\n    delta.y = CORE.Input.Mouse.currentPosition.y - CORE.Input.Mouse.previousPosition.y;\n\n    return delta;\n}\n\n// Set mouse position XY\nvoid SetMousePosition(int x, int y)\n{\n    CORE.Input.Mouse.currentPosition = (Vector2){ (float)x, (float)y };\n    CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    // NOTE: emscripten not implemented\n    glfwSetCursorPos(CORE.Window.handle, CORE.Input.Mouse.currentPosition.x, CORE.Input.Mouse.currentPosition.y);\n#endif\n}\n\n// Set mouse offset\n// NOTE: Useful when rendering to different size targets\nvoid SetMouseOffset(int offsetX, int offsetY)\n{\n    CORE.Input.Mouse.offset = (Vector2){ (float)offsetX, (float)offsetY };\n}\n\n// Set mouse scaling\n// NOTE: Useful when rendering to different size targets\nvoid SetMouseScale(float scaleX, float scaleY)\n{\n    CORE.Input.Mouse.scale = (Vector2){ scaleX, scaleY };\n}\n\n// Get mouse wheel movement Y\nfloat GetMouseWheelMove(void)\n{\n    float result = 0.0f;\n\n#if !defined(PLATFORM_ANDROID)\n    if (fabsf(CORE.Input.Mouse.currentWheelMove.x) > fabsf(CORE.Input.Mouse.currentWheelMove.y)) result = (float)CORE.Input.Mouse.currentWheelMove.x;\n    else result = (float)CORE.Input.Mouse.currentWheelMove.y;\n#endif\n\n    return result;\n}\n\n// Get mouse wheel movement X/Y as a vector\nVector2 GetMouseWheelMoveV(void)\n{\n    Vector2 result = { 0 };\n\n    result = CORE.Input.Mouse.currentWheelMove;\n\n    return result;\n}\n\n// Set mouse cursor\n// NOTE: This is a no-op on platforms other than PLATFORM_DESKTOP\nvoid SetMouseCursor(int cursor)\n{\n#if defined(PLATFORM_DESKTOP)\n    CORE.Input.Mouse.cursor = cursor;\n    if (cursor == MOUSE_CURSOR_DEFAULT) glfwSetCursor(CORE.Window.handle, NULL);\n    else\n    {\n        // NOTE: We are relating internal GLFW enum values to our MouseCursor enum values\n        glfwSetCursor(CORE.Window.handle, glfwCreateStandardCursor(0x00036000 + cursor));\n    }\n#endif\n}\n\n// Get touch position X for touch point 0 (relative to screen size)\nint GetTouchX(void)\n{\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)\n    return (int)CORE.Input.Touch.position[0].x;\n#else   // PLATFORM_DESKTOP, PLATFORM_RPI, PLATFORM_DRM\n    return GetMouseX();\n#endif\n}\n\n// Get touch position Y for touch point 0 (relative to screen size)\nint GetTouchY(void)\n{\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB)\n    return (int)CORE.Input.Touch.position[0].y;\n#else   // PLATFORM_DESKTOP, PLATFORM_RPI, PLATFORM_DRM\n    return GetMouseY();\n#endif\n}\n\n// Get touch position XY for a touch point index (relative to screen size)\n// TODO: Touch position should be scaled depending on display size and render size\nVector2 GetTouchPosition(int index)\n{\n    Vector2 position = { -1.0f, -1.0f };\n\n#if defined(PLATFORM_DESKTOP)\n    // TODO: GLFW does not support multi-touch input just yet\n    // https://www.codeproject.com/Articles/668404/Programming-for-Multi-Touch\n    // https://docs.microsoft.com/en-us/windows/win32/wintouch/getting-started-with-multi-touch-messages\n    if (index == 0) position = GetMousePosition();\n#endif\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_WEB) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    if (index < MAX_TOUCH_POINTS) position = CORE.Input.Touch.position[index];\n    else TRACELOG(LOG_WARNING, \"INPUT: Required touch point out of range (Max touch points: %i)\", MAX_TOUCH_POINTS);\n#endif\n\n    return position;\n}\n\n// Get touch point identifier for given index\nint GetTouchPointId(int index)\n{\n    int id = -1;\n\n    if (index < MAX_TOUCH_POINTS) id = CORE.Input.Touch.pointId[index];\n\n    return id;\n}\n\n// Get number of touch points\nint GetTouchPointCount(void)\n{\n    return CORE.Input.Touch.pointCount;\n}\n\n//----------------------------------------------------------------------------------\n// Module specific Functions Definition\n//----------------------------------------------------------------------------------\n\n// Initialize display device and framebuffer\n// NOTE: width and height represent the screen (framebuffer) desired size, not actual display size\n// If width or height are 0, default display size will be used for framebuffer size\n// NOTE: returns false in case graphic device could not be created\nstatic bool InitGraphicsDevice(int width, int height)\n{\n    CORE.Window.screen.width = width;            // User desired width\n    CORE.Window.screen.height = height;          // User desired height\n    CORE.Window.screenScale = MatrixIdentity();  // No draw scaling required by default\n\n    // NOTE: Framebuffer (render area - CORE.Window.render.width, CORE.Window.render.height) could include black bars...\n    // ...in top-down or left-right to match display aspect ratio (no weird scaling)\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwSetErrorCallback(ErrorCallback);\n/*\n    // TODO: Setup GLFW custom allocators to match raylib ones\n    const GLFWallocator allocator = {\n        .allocate = MemAlloc,\n        .deallocate = MemFree,\n        .reallocate = MemRealloc,\n        .user = NULL\n    };\n\n    glfwInitAllocator(&allocator);\n*/\n#if defined(__APPLE__)\n    glfwInitHint(GLFW_COCOA_CHDIR_RESOURCES, GLFW_FALSE);\n#endif\n\n    if (!glfwInit())\n    {\n        TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize GLFW\");\n        return false;\n    }\n\n    glfwDefaultWindowHints();                       // Set default windows hints\n    //glfwWindowHint(GLFW_RED_BITS, 8);             // Framebuffer red color component bits\n    //glfwWindowHint(GLFW_GREEN_BITS, 8);           // Framebuffer green color component bits\n    //glfwWindowHint(GLFW_BLUE_BITS, 8);            // Framebuffer blue color component bits\n    //glfwWindowHint(GLFW_ALPHA_BITS, 8);           // Framebuffer alpha color component bits\n    //glfwWindowHint(GLFW_DEPTH_BITS, 24);          // Depthbuffer bits\n    //glfwWindowHint(GLFW_REFRESH_RATE, 0);         // Refresh rate for fullscreen window\n    //glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_API); // OpenGL API to use. Alternative: GLFW_OPENGL_ES_API\n    //glfwWindowHint(GLFW_AUX_BUFFERS, 0);          // Number of auxiliar buffers\n\n    // Check window creation flags\n    if ((CORE.Window.flags & FLAG_FULLSCREEN_MODE) > 0) CORE.Window.fullscreen = true;\n\n    if ((CORE.Window.flags & FLAG_WINDOW_HIDDEN) > 0) glfwWindowHint(GLFW_VISIBLE, GLFW_FALSE); // Visible window\n    else glfwWindowHint(GLFW_VISIBLE, GLFW_TRUE);     // Window initially hidden\n\n    if ((CORE.Window.flags & FLAG_WINDOW_UNDECORATED) > 0) glfwWindowHint(GLFW_DECORATED, GLFW_FALSE); // Border and buttons on Window\n    else glfwWindowHint(GLFW_DECORATED, GLFW_TRUE);   // Decorated window\n\n    if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) > 0) glfwWindowHint(GLFW_RESIZABLE, GLFW_TRUE); // Resizable window\n    else glfwWindowHint(GLFW_RESIZABLE, GLFW_FALSE);  // Avoid window being resizable\n\n    // Disable FLAG_WINDOW_MINIMIZED, not supported on initialization\n    if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;\n\n    // Disable FLAG_WINDOW_MAXIMIZED, not supported on initialization\n    if ((CORE.Window.flags & FLAG_WINDOW_MAXIMIZED) > 0) CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;\n\n    if ((CORE.Window.flags & FLAG_WINDOW_UNFOCUSED) > 0) glfwWindowHint(GLFW_FOCUSED, GLFW_FALSE);\n    else glfwWindowHint(GLFW_FOCUSED, GLFW_TRUE);\n\n    if ((CORE.Window.flags & FLAG_WINDOW_TOPMOST) > 0) glfwWindowHint(GLFW_FLOATING, GLFW_TRUE);\n    else glfwWindowHint(GLFW_FLOATING, GLFW_FALSE);\n\n    // NOTE: Some GLFW flags are not supported on HTML5\n#if defined(PLATFORM_DESKTOP)\n    if ((CORE.Window.flags & FLAG_WINDOW_TRANSPARENT) > 0) glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_TRUE);     // Transparent framebuffer\n    else glfwWindowHint(GLFW_TRANSPARENT_FRAMEBUFFER, GLFW_FALSE);  // Opaque framebuffer\n\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        // Resize window content area based on the monitor content scale.\n        // NOTE: This hint only has an effect on platforms where screen coordinates and pixels always map 1:1 such as Windows and X11.\n        // On platforms like macOS the resolution of the framebuffer is changed independently of the window size.\n        glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_TRUE);   // Scale content area based on the monitor content scale where window is placed on\n    #if defined(__APPLE__)\n        glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n    #endif\n    }\n    else glfwWindowHint(GLFW_SCALE_TO_MONITOR, GLFW_FALSE);\n\n    // Mouse passthrough\n    if ((CORE.Window.flags & FLAG_WINDOW_MOUSE_PASSTHROUGH) > 0) glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_TRUE);\n    else glfwWindowHint(GLFW_MOUSE_PASSTHROUGH, GLFW_FALSE);\n#endif\n\n    if (CORE.Window.flags & FLAG_MSAA_4X_HINT)\n    {\n        // NOTE: MSAA is only enabled for main framebuffer, not user-created FBOs\n        TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");\n        glfwWindowHint(GLFW_SAMPLES, 4);   // Tries to enable multisampling x4 (MSAA), default is 0\n    }\n\n    // NOTE: When asking for an OpenGL context version, most drivers provide the highest supported version\n    // with backward compatibility to older OpenGL versions.\n    // For example, if using OpenGL 1.1, driver can provide a 4.3 backwards compatible context.\n\n    // Check selection OpenGL version\n    if (rlGetVersion() == RL_OPENGL_21)\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);          // Choose OpenGL major version (just hint)\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 1);          // Choose OpenGL minor version (just hint)\n    }\n    else if (rlGetVersion() == RL_OPENGL_33)\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);          // Choose OpenGL major version (just hint)\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // Profiles Hint: Only 3.3 and above!\n                                                                       // Values: GLFW_OPENGL_CORE_PROFILE, GLFW_OPENGL_ANY_PROFILE, GLFW_OPENGL_COMPAT_PROFILE\n#if defined(__APPLE__)\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);  // OSX Requires fordward compatibility\n#else\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE); // Fordward Compatibility Hint: Only 3.3 and above!\n#endif\n        //glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE); // Request OpenGL DEBUG context\n    }\n    else if (rlGetVersion() == RL_OPENGL_43)\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);          // Choose OpenGL major version (just hint)\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);          // Choose OpenGL minor version (just hint)\n        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_FALSE);\n#if defined(RLGL_ENABLE_OPENGL_DEBUG_CONTEXT)\n        glfwWindowHint(GLFW_OPENGL_DEBUG_CONTEXT, GLFW_TRUE);   // Enable OpenGL Debug Context\n#endif\n    }\n    else if (rlGetVersion() == RL_OPENGL_ES_20)                 // Request OpenGL ES 2.0 context\n    {\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 2);\n        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 0);\n        glfwWindowHint(GLFW_CLIENT_API, GLFW_OPENGL_ES_API);\n#if defined(PLATFORM_DESKTOP)\n        glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_EGL_CONTEXT_API);\n#else\n        glfwWindowHint(GLFW_CONTEXT_CREATION_API, GLFW_NATIVE_CONTEXT_API);\n#endif\n    }\n\n#if defined(PLATFORM_DESKTOP)\n    // NOTE: GLFW 3.4+ defers initialization of the Joystick subsystem on the first call to any Joystick related functions.\n    // Forcing this initialization here avoids doing it on PollInputEvents() called by EndDrawing() after first frame has been just drawn.\n    // The initialization will still happen and possible delays still occur, but before the window is shown, which is a nicer experience.\n    // REF: https://github.com/raysan5/raylib/issues/1554\n    if (MAX_GAMEPADS > 0) glfwSetJoystickCallback(NULL);\n#endif\n\n#if defined(PLATFORM_DESKTOP)\n    // Find monitor resolution\n    GLFWmonitor *monitor = glfwGetPrimaryMonitor();\n    if (!monitor)\n    {\n        TRACELOG(LOG_WARNING, \"GLFW: Failed to get primary monitor\");\n        return false;\n    }\n\n    const GLFWvidmode *mode = glfwGetVideoMode(monitor);\n\n    CORE.Window.display.width = mode->width;\n    CORE.Window.display.height = mode->height;\n\n    // Set screen width/height to the display width/height if they are 0\n    if (CORE.Window.screen.width == 0) CORE.Window.screen.width = CORE.Window.display.width;\n    if (CORE.Window.screen.height == 0) CORE.Window.screen.height = CORE.Window.display.height;\n#endif  // PLATFORM_DESKTOP\n\n#if defined(PLATFORM_WEB)\n    // NOTE: Getting video modes is not implemented in emscripten GLFW3 version\n    CORE.Window.display.width = CORE.Window.screen.width;\n    CORE.Window.display.height = CORE.Window.screen.height;\n#endif  // PLATFORM_WEB\n\n    if (CORE.Window.fullscreen)\n    {\n        // remember center for switchinging from fullscreen to window\n        if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))\n        {\n            // If screen width/height equal to the display, we can't calculate the window pos for toggling full-screened/windowed.\n            // Toggling full-screened/windowed with pos(0, 0) can cause problems in some platforms, such as X11.\n            CORE.Window.position.x = CORE.Window.display.width/4;\n            CORE.Window.position.y = CORE.Window.display.height/4;\n        }\n        else\n        {\n            CORE.Window.position.x = CORE.Window.display.width/2 - CORE.Window.screen.width/2;\n            CORE.Window.position.y = CORE.Window.display.height/2 - CORE.Window.screen.height/2;\n        }\n\n        if (CORE.Window.position.x < 0) CORE.Window.position.x = 0;\n        if (CORE.Window.position.y < 0) CORE.Window.position.y = 0;\n\n        // Obtain recommended CORE.Window.display.width/CORE.Window.display.height from a valid videomode for the monitor\n        int count = 0;\n        const GLFWvidmode *modes = glfwGetVideoModes(glfwGetPrimaryMonitor(), &count);\n\n        // Get closest video mode to desired CORE.Window.screen.width/CORE.Window.screen.height\n        for (int i = 0; i < count; i++)\n        {\n            if ((unsigned int)modes[i].width >= CORE.Window.screen.width)\n            {\n                if ((unsigned int)modes[i].height >= CORE.Window.screen.height)\n                {\n                    CORE.Window.display.width = modes[i].width;\n                    CORE.Window.display.height = modes[i].height;\n                    break;\n                }\n            }\n        }\n        TRACELOG(LOG_WARNING, \"SYSTEM: Closest fullscreen videomode: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);\n\n        // NOTE: ISSUE: Closest videomode could not match monitor aspect-ratio, for example,\n        // for a desired screen size of 800x450 (16:9), closest supported videomode is 800x600 (4:3),\n        // framebuffer is rendered correctly but once displayed on a 16:9 monitor, it gets stretched\n        // by the sides to fit all monitor space...\n\n        // Try to setup the most appropriate fullscreen framebuffer for the requested screenWidth/screenHeight\n        // It considers device display resolution mode and setups a framebuffer with black bars if required (render size/offset)\n        // Modified global variables: CORE.Window.screen.width/CORE.Window.screen.height - CORE.Window.render.width/CORE.Window.render.height - CORE.Window.renderOffset.x/CORE.Window.renderOffset.y - CORE.Window.screenScale\n        // TODO: It is a quite cumbersome solution to display size vs requested size, it should be reviewed or removed...\n        // HighDPI monitors are properly considered in a following similar function: SetupViewport()\n        SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n\n        CORE.Window.handle = glfwCreateWindow(CORE.Window.display.width, CORE.Window.display.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", glfwGetPrimaryMonitor(), NULL);\n\n        // NOTE: Full-screen change, not working properly...\n        //glfwSetWindowMonitor(CORE.Window.handle, glfwGetPrimaryMonitor(), 0, 0, CORE.Window.screen.width, CORE.Window.screen.height, GLFW_DONT_CARE);\n    }\n    else\n    {\n#if defined(PLATFORM_DESKTOP)\n        // If we are windowed fullscreen, ensures that window does not minimize when focus is lost\n        if ((CORE.Window.screen.height == CORE.Window.display.height) && (CORE.Window.screen.width == CORE.Window.display.width))\n        {\n            glfwWindowHint(GLFW_AUTO_ICONIFY, 0);\n        }\n#endif\n        // No-fullscreen window creation\n        CORE.Window.handle = glfwCreateWindow(CORE.Window.screen.width, CORE.Window.screen.height, (CORE.Window.title != 0)? CORE.Window.title : \" \", NULL, NULL);\n\n        if (CORE.Window.handle)\n        {\n            CORE.Window.render.width = CORE.Window.screen.width;\n            CORE.Window.render.height = CORE.Window.screen.height;\n        }\n    }\n\n    if (!CORE.Window.handle)\n    {\n        glfwTerminate();\n        TRACELOG(LOG_WARNING, \"GLFW: Failed to initialize Window\");\n        return false;\n    }\n\n    // Set window callback events\n    glfwSetWindowSizeCallback(CORE.Window.handle, WindowSizeCallback);      // NOTE: Resizing not allowed by default!\n#if !defined(PLATFORM_WEB)\n    glfwSetWindowMaximizeCallback(CORE.Window.handle, WindowMaximizeCallback);\n#endif\n    glfwSetWindowIconifyCallback(CORE.Window.handle, WindowIconifyCallback);\n    glfwSetWindowFocusCallback(CORE.Window.handle, WindowFocusCallback);\n    glfwSetDropCallback(CORE.Window.handle, WindowDropCallback);\n\n    // Set input callback events\n    glfwSetKeyCallback(CORE.Window.handle, KeyCallback);\n    glfwSetCharCallback(CORE.Window.handle, CharCallback);\n    glfwSetMouseButtonCallback(CORE.Window.handle, MouseButtonCallback);\n    glfwSetCursorPosCallback(CORE.Window.handle, MouseCursorPosCallback);   // Track mouse position changes\n    glfwSetScrollCallback(CORE.Window.handle, MouseScrollCallback);\n    glfwSetCursorEnterCallback(CORE.Window.handle, CursorEnterCallback);\n\n    glfwMakeContextCurrent(CORE.Window.handle);\n\n#if !defined(PLATFORM_WEB)\n    glfwSetInputMode(CORE.Window.handle, GLFW_LOCK_KEY_MODS, GLFW_TRUE);    // Enable lock keys modifiers (CAPS, NUM)\n\n    glfwSwapInterval(0);        // No V-Sync by default\n#endif\n\n    // Try to enable GPU V-Sync, so frames are limited to screen refresh rate (60Hz -> 60 FPS)\n    // NOTE: V-Sync can be enabled by graphic driver configuration\n    if (CORE.Window.flags & FLAG_VSYNC_HINT)\n    {\n        // WARNING: It seems to hit a critical render path in Intel HD Graphics\n        glfwSwapInterval(1);\n        TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable VSYNC\");\n    }\n\n    int fbWidth = CORE.Window.screen.width;\n    int fbHeight = CORE.Window.screen.height;\n\n#if defined(PLATFORM_DESKTOP)\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        // NOTE: On APPLE platforms system should manage window/input scaling and also framebuffer scaling.\n        // Framebuffer scaling should be activated with: glfwWindowHint(GLFW_COCOA_RETINA_FRAMEBUFFER, GLFW_TRUE);\n    #if !defined(__APPLE__)\n        glfwGetFramebufferSize(CORE.Window.handle, &fbWidth, &fbHeight);\n\n        // Screen scaling matrix is required in case desired screen area is different from display area\n        CORE.Window.screenScale = MatrixScale((float)fbWidth/CORE.Window.screen.width, (float)fbHeight/CORE.Window.screen.height, 1.0f);\n\n        // Mouse input scaling for the new screen size\n        SetMouseScale((float)CORE.Window.screen.width/fbWidth, (float)CORE.Window.screen.height/fbHeight);\n    #endif\n    }\n#endif\n\n    CORE.Window.render.width = fbWidth;\n    CORE.Window.render.height = fbHeight;\n    CORE.Window.currentFbo.width = fbWidth;\n    CORE.Window.currentFbo.height = fbHeight;\n\n    TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");\n    TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);\n    TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);\n    TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);\n    TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);\n\n#endif  // PLATFORM_DESKTOP || PLATFORM_WEB\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    CORE.Window.fullscreen = true;\n    CORE.Window.flags |= FLAG_FULLSCREEN_MODE;\n\n#if defined(PLATFORM_RPI)\n    bcm_host_init();\n\n    DISPMANX_ELEMENT_HANDLE_T dispmanElement = { 0 };\n    DISPMANX_DISPLAY_HANDLE_T dispmanDisplay = { 0 };\n    DISPMANX_UPDATE_HANDLE_T dispmanUpdate = { 0 };\n\n    VC_RECT_T dstRect = { 0 };\n    VC_RECT_T srcRect = { 0 };\n#endif\n\n#if defined(PLATFORM_DRM)\n    CORE.Window.fd = -1;\n    CORE.Window.connector = NULL;\n    CORE.Window.modeIndex = -1;\n    CORE.Window.crtc = NULL;\n    CORE.Window.gbmDevice = NULL;\n    CORE.Window.gbmSurface = NULL;\n    CORE.Window.prevBO = NULL;\n    CORE.Window.prevFB = 0;\n\n#if defined(DEFAULT_GRAPHIC_DEVICE_DRM)\n    CORE.Window.fd = open(DEFAULT_GRAPHIC_DEVICE_DRM, O_RDWR);\n#else\n    TRACELOG(LOG_INFO, \"DISPLAY: No graphic card set, trying platform-gpu-card\");\n    CORE.Window.fd = open(\"/dev/dri/by-path/platform-gpu-card\",  O_RDWR); // VideoCore VI (Raspberry Pi 4)\n\n    if ((-1 == CORE.Window.fd) || (drmModeGetResources(CORE.Window.fd) == NULL))\n    {\n        TRACELOG(LOG_INFO, \"DISPLAY: Failed to open platform-gpu-card, trying card1\");\n        CORE.Window.fd = open(\"/dev/dri/card1\", O_RDWR); // Other Embedded\n    }\n\n    if ((-1 == CORE.Window.fd) || (drmModeGetResources(CORE.Window.fd) == NULL))\n    {\n        TRACELOG(LOG_INFO, \"DISPLAY: Failed to open graphic card1, trying card0\");\n        CORE.Window.fd = open(\"/dev/dri/card0\", O_RDWR); // VideoCore IV (Raspberry Pi 1-3)\n    }\n#endif\n    if (-1 == CORE.Window.fd)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to open graphic card\");\n        return false;\n    }\n\n    drmModeRes *res = drmModeGetResources(CORE.Window.fd);\n    if (!res)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed get DRM resources\");\n        return false;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: Connectors found: %i\", res->count_connectors);\n    for (size_t i = 0; i < res->count_connectors; i++)\n    {\n        TRACELOG(LOG_TRACE, \"DISPLAY: Connector index %i\", i);\n        drmModeConnector *con = drmModeGetConnector(CORE.Window.fd, res->connectors[i]);\n        TRACELOG(LOG_TRACE, \"DISPLAY: Connector modes detected: %i\", con->count_modes);\n        if ((con->connection == DRM_MODE_CONNECTED) && (con->encoder_id))\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode connected\");\n            CORE.Window.connector = con;\n            break;\n        }\n        else\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode NOT connected (deleting)\");\n            drmModeFreeConnector(con);\n        }\n    }\n\n    if (!CORE.Window.connector)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: No suitable DRM connector found\");\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    drmModeEncoder *enc = drmModeGetEncoder(CORE.Window.fd, CORE.Window.connector->encoder_id);\n    if (!enc)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode encoder\");\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    CORE.Window.crtc = drmModeGetCrtc(CORE.Window.fd, enc->crtc_id);\n    if (!CORE.Window.crtc)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get DRM mode crtc\");\n        drmModeFreeEncoder(enc);\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    // If InitWindow should use the current mode find it in the connector's mode list\n    if ((CORE.Window.screen.width <= 0) || (CORE.Window.screen.height <= 0))\n    {\n        TRACELOG(LOG_TRACE, \"DISPLAY: Selecting DRM connector mode for current used mode...\");\n\n        CORE.Window.modeIndex = FindMatchingConnectorMode(CORE.Window.connector, &CORE.Window.crtc->mode);\n\n        if (CORE.Window.modeIndex < 0)\n        {\n            TRACELOG(LOG_WARNING, \"DISPLAY: No matching DRM connector mode found\");\n            drmModeFreeEncoder(enc);\n            drmModeFreeResources(res);\n            return false;\n        }\n\n        CORE.Window.screen.width = CORE.Window.display.width;\n        CORE.Window.screen.height = CORE.Window.display.height;\n    }\n\n    const bool allowInterlaced = CORE.Window.flags & FLAG_INTERLACED_HINT;\n    const int fps = (CORE.Time.target > 0) ? (1.0/CORE.Time.target) : 60;\n\n    // Try to find an exact matching mode\n    CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);\n\n    // If nothing found, try to find a nearly matching mode\n    if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, allowInterlaced);\n\n    // If nothing found, try to find an exactly matching mode including interlaced\n    if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindExactConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);\n\n    // If nothing found, try to find a nearly matching mode including interlaced\n    if (CORE.Window.modeIndex < 0) CORE.Window.modeIndex = FindNearestConnectorMode(CORE.Window.connector, CORE.Window.screen.width, CORE.Window.screen.height, fps, true);\n\n    // If nothing found, there is no suitable mode\n    if (CORE.Window.modeIndex < 0)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable DRM connector mode\");\n        drmModeFreeEncoder(enc);\n        drmModeFreeResources(res);\n        return false;\n    }\n\n    CORE.Window.display.width = CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay;\n    CORE.Window.display.height = CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay;\n\n    TRACELOG(LOG_INFO, \"DISPLAY: Selected DRM connector mode %s (%ux%u%c@%u)\", CORE.Window.connector->modes[CORE.Window.modeIndex].name,\n        CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay,\n        (CORE.Window.connector->modes[CORE.Window.modeIndex].flags & DRM_MODE_FLAG_INTERLACE) ? 'i' : 'p',\n        CORE.Window.connector->modes[CORE.Window.modeIndex].vrefresh);\n\n    // Use the width and height of the surface for render\n    CORE.Window.render.width = CORE.Window.screen.width;\n    CORE.Window.render.height = CORE.Window.screen.height;\n\n    drmModeFreeEncoder(enc);\n    enc = NULL;\n\n    drmModeFreeResources(res);\n    res = NULL;\n\n    CORE.Window.gbmDevice = gbm_create_device(CORE.Window.fd);\n    if (!CORE.Window.gbmDevice)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM device\");\n        return false;\n    }\n\n    CORE.Window.gbmSurface = gbm_surface_create(CORE.Window.gbmDevice, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay,\n        CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, GBM_FORMAT_ARGB8888, GBM_BO_USE_SCANOUT | GBM_BO_USE_RENDERING);\n    if (!CORE.Window.gbmSurface)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create GBM surface\");\n        return false;\n    }\n#endif\n\n    EGLint samples = 0;\n    EGLint sampleBuffer = 0;\n    if (CORE.Window.flags & FLAG_MSAA_4X_HINT)\n    {\n        samples = 4;\n        sampleBuffer = 1;\n        TRACELOG(LOG_INFO, \"DISPLAY: Trying to enable MSAA x4\");\n    }\n\n    const EGLint framebufferAttribs[] =\n    {\n        EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,     // Type of context support -> Required on RPI?\n#if defined(PLATFORM_DRM)\n        EGL_SURFACE_TYPE, EGL_WINDOW_BIT,          // Don't use it on Android!\n#endif\n        EGL_RED_SIZE, 8,            // RED color bit depth (alternative: 5)\n        EGL_GREEN_SIZE, 8,          // GREEN color bit depth (alternative: 6)\n        EGL_BLUE_SIZE, 8,           // BLUE color bit depth (alternative: 5)\n#if defined(PLATFORM_DRM)\n        EGL_ALPHA_SIZE, 8,        // ALPHA bit depth (required for transparent framebuffer)\n#endif\n        //EGL_TRANSPARENT_TYPE, EGL_NONE, // Request transparent framebuffer (EGL_TRANSPARENT_RGB does not work on RPI)\n        EGL_DEPTH_SIZE, 16,         // Depth buffer size (Required to use Depth testing!)\n        //EGL_STENCIL_SIZE, 8,      // Stencil buffer size\n        EGL_SAMPLE_BUFFERS, sampleBuffer,    // Activate MSAA\n        EGL_SAMPLES, samples,       // 4x Antialiasing if activated (Free on MALI GPUs)\n        EGL_NONE\n    };\n\n    const EGLint contextAttribs[] =\n    {\n        EGL_CONTEXT_CLIENT_VERSION, 2,\n        EGL_NONE\n    };\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    EGLint numConfigs = 0;\n\n    // Get an EGL device connection\n#if defined(PLATFORM_DRM)\n    CORE.Window.device = eglGetDisplay((EGLNativeDisplayType)CORE.Window.gbmDevice);\n#else\n    CORE.Window.device = eglGetDisplay(EGL_DEFAULT_DISPLAY);\n#endif\n    if (CORE.Window.device == EGL_NO_DISPLAY)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");\n        return false;\n    }\n\n    // Initialize the EGL device connection\n    if (eglInitialize(CORE.Window.device, NULL, NULL) == EGL_FALSE)\n    {\n        // If all of the calls to eglInitialize returned EGL_FALSE then an error has occurred.\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to initialize EGL device\");\n        return false;\n    }\n\n#if defined(PLATFORM_DRM)\n    if (!eglChooseConfig(CORE.Window.device, NULL, NULL, 0, &numConfigs))\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config count: 0x%x\", eglGetError());\n        return false;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: EGL configs available: %d\", numConfigs);\n\n    EGLConfig *configs = RL_CALLOC(numConfigs, sizeof(*configs));\n    if (!configs)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get memory for EGL configs\");\n        return false;\n    }\n\n    EGLint matchingNumConfigs = 0;\n    if (!eglChooseConfig(CORE.Window.device, framebufferAttribs, configs, numConfigs, &matchingNumConfigs))\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to choose EGL config: 0x%x\", eglGetError());\n        free(configs);\n        return false;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: EGL matching configs available: %d\", matchingNumConfigs);\n\n    // find the EGL config that matches the previously setup GBM format\n    int found = 0;\n    for (EGLint i = 0; i < matchingNumConfigs; ++i)\n    {\n        EGLint id = 0;\n        if (!eglGetConfigAttrib(CORE.Window.device, configs[i], EGL_NATIVE_VISUAL_ID, &id))\n        {\n            TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get EGL config attribute: 0x%x\", eglGetError());\n            continue;\n        }\n\n        if (GBM_FORMAT_ARGB8888 == id)\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: Using EGL config: %d\", i);\n            CORE.Window.config = configs[i];\n            found = 1;\n            break;\n        }\n    }\n\n    RL_FREE(configs);\n\n    if (!found)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to find a suitable EGL config\");\n        return false;\n    }\n#else\n    // Get an appropriate EGL framebuffer configuration\n    eglChooseConfig(CORE.Window.device, framebufferAttribs, &CORE.Window.config, 1, &numConfigs);\n#endif\n\n    // Set rendering API\n    eglBindAPI(EGL_OPENGL_ES_API);\n\n    // Create an EGL rendering context\n    CORE.Window.context = eglCreateContext(CORE.Window.device, CORE.Window.config, EGL_NO_CONTEXT, contextAttribs);\n    if (CORE.Window.context == EGL_NO_CONTEXT)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL context\");\n        return false;\n    }\n#endif\n\n    // Create an EGL window surface\n    //---------------------------------------------------------------------------------\n#if defined(PLATFORM_ANDROID)\n    EGLint displayFormat = 0;\n\n    // EGL_NATIVE_VISUAL_ID is an attribute of the EGLConfig that is guaranteed to be accepted by ANativeWindow_setBuffersGeometry()\n    // As soon as we picked a EGLConfig, we can safely reconfigure the ANativeWindow buffers to match, using EGL_NATIVE_VISUAL_ID\n    eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);\n\n    // At this point we need to manage render size vs screen size\n    // NOTE: This function use and modify global module variables:\n    //  -> CORE.Window.screen.width/CORE.Window.screen.height\n    //  -> CORE.Window.render.width/CORE.Window.render.height\n    //  -> CORE.Window.screenScale\n    SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n\n    ANativeWindow_setBuffersGeometry(CORE.Android.app->window, CORE.Window.render.width, CORE.Window.render.height, displayFormat);\n    //ANativeWindow_setBuffersGeometry(CORE.Android.app->window, 0, 0, displayFormat);       // Force use of native display size\n\n    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, CORE.Android.app->window, NULL);\n#endif  // PLATFORM_ANDROID\n\n#if defined(PLATFORM_RPI)\n    graphics_get_display_size(0, &CORE.Window.display.width, &CORE.Window.display.height);\n\n    // Screen size security check\n    if (CORE.Window.screen.width <= 0) CORE.Window.screen.width = CORE.Window.display.width;\n    if (CORE.Window.screen.height <= 0) CORE.Window.screen.height = CORE.Window.display.height;\n\n    // At this point we need to manage render size vs screen size\n    // NOTE: This function use and modify global module variables:\n    //  -> CORE.Window.screen.width/CORE.Window.screen.height\n    //  -> CORE.Window.render.width/CORE.Window.render.height\n    //  -> CORE.Window.screenScale\n    SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n\n    dstRect.x = 0;\n    dstRect.y = 0;\n    dstRect.width = CORE.Window.display.width;\n    dstRect.height = CORE.Window.display.height;\n\n    srcRect.x = 0;\n    srcRect.y = 0;\n    srcRect.width = CORE.Window.render.width << 16;\n    srcRect.height = CORE.Window.render.height << 16;\n\n    // NOTE: RPI dispmanx windowing system takes care of source rectangle scaling to destination rectangle by hardware (no cost)\n    // Take care that renderWidth/renderHeight fit on displayWidth/displayHeight aspect ratio\n\n    VC_DISPMANX_ALPHA_T alpha = { 0 };\n    alpha.flags = DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS;\n    //alpha.flags = DISPMANX_FLAGS_ALPHA_FROM_SOURCE;       // TODO: Allow transparent framebuffer! -> FLAG_WINDOW_TRANSPARENT\n    alpha.opacity = 255;    // Set transparency level for framebuffer, requires EGLAttrib: EGL_TRANSPARENT_TYPE\n    alpha.mask = 0;\n\n    dispmanDisplay = vc_dispmanx_display_open(0);   // LCD\n    dispmanUpdate = vc_dispmanx_update_start(0);\n\n    dispmanElement = vc_dispmanx_element_add(dispmanUpdate, dispmanDisplay, 0/*layer*/, &dstRect, 0/*src*/,\n                                            &srcRect, DISPMANX_PROTECTION_NONE, &alpha, 0/*clamp*/, DISPMANX_NO_ROTATE);\n\n    CORE.Window.handle.element = dispmanElement;\n    CORE.Window.handle.width = CORE.Window.render.width;\n    CORE.Window.handle.height = CORE.Window.render.height;\n    vc_dispmanx_update_submit_sync(dispmanUpdate);\n\n    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, &CORE.Window.handle, NULL);\n\n    const unsigned char *const renderer = glGetString(GL_RENDERER);\n    if (renderer) TRACELOG(LOG_INFO, \"DISPLAY: Renderer name is: %s\", renderer);\n    else TRACELOG(LOG_WARNING, \"DISPLAY: Failed to get renderer name\");\n    //---------------------------------------------------------------------------------\n#endif  // PLATFORM_RPI\n\n#if defined(PLATFORM_DRM)\n    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, (EGLNativeWindowType)CORE.Window.gbmSurface, NULL);\n    if (EGL_NO_SURFACE == CORE.Window.surface)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to create EGL window surface: 0x%04x\", eglGetError());\n        return false;\n    }\n\n    // At this point we need to manage render size vs screen size\n    // NOTE: This function use and modify global module variables:\n    //  -> CORE.Window.screen.width/CORE.Window.screen.height\n    //  -> CORE.Window.render.width/CORE.Window.render.height\n    //  -> CORE.Window.screenScale\n    SetupFramebuffer(CORE.Window.display.width, CORE.Window.display.height);\n#endif  // PLATFORM_DRM\n\n    // There must be at least one frame displayed before the buffers are swapped\n    //eglSwapInterval(CORE.Window.device, 1);\n\n    if (eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context) == EGL_FALSE)\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Failed to attach EGL rendering context to EGL surface\");\n        return false;\n    }\n    else\n    {\n        CORE.Window.render.width = CORE.Window.screen.width;\n        CORE.Window.render.height = CORE.Window.screen.height;\n        CORE.Window.currentFbo.width = CORE.Window.render.width;\n        CORE.Window.currentFbo.height = CORE.Window.render.height;\n\n        TRACELOG(LOG_INFO, \"DISPLAY: Device initialized successfully\");\n        TRACELOG(LOG_INFO, \"    > Display size: %i x %i\", CORE.Window.display.width, CORE.Window.display.height);\n        TRACELOG(LOG_INFO, \"    > Screen size:  %i x %i\", CORE.Window.screen.width, CORE.Window.screen.height);\n        TRACELOG(LOG_INFO, \"    > Render size:  %i x %i\", CORE.Window.render.width, CORE.Window.render.height);\n        TRACELOG(LOG_INFO, \"    > Viewport offsets: %i, %i\", CORE.Window.renderOffset.x, CORE.Window.renderOffset.y);\n    }\n#endif  // PLATFORM_ANDROID || PLATFORM_RPI || PLATFORM_DRM\n\n    // Load OpenGL extensions\n    // NOTE: GL procedures address loader is required to load extensions\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    rlLoadExtensions(glfwGetProcAddress);\n#else\n    rlLoadExtensions(eglGetProcAddress);\n#endif\n\n    // Initialize OpenGL context (states and resources)\n    // NOTE: CORE.Window.currentFbo.width and CORE.Window.currentFbo.height not used, just stored as globals in rlgl\n    rlglInit(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);\n\n    // Setup default viewport\n    // NOTE: It updated CORE.Window.render.width and CORE.Window.render.height\n    SetupViewport(CORE.Window.currentFbo.width, CORE.Window.currentFbo.height);\n\n#if defined(PLATFORM_ANDROID)\n    CORE.Window.ready = true;\n#endif\n\n    if ((CORE.Window.flags & FLAG_WINDOW_MINIMIZED) > 0) MinimizeWindow();\n\n    return true;\n}\n\n// Set viewport for a provided width and height\nstatic void SetupViewport(int width, int height)\n{\n    CORE.Window.render.width = width;\n    CORE.Window.render.height = height;\n\n    // Set viewport width and height\n    // NOTE: We consider render size (scaled) and offset in case black bars are required and\n    // render area does not match full display area (this situation is only applicable on fullscreen mode)\n#if defined(__APPLE__)\n    float xScale = 1.0f, yScale = 1.0f;\n    glfwGetWindowContentScale(CORE.Window.handle, &xScale, &yScale);\n    rlViewport(CORE.Window.renderOffset.x/2*xScale, CORE.Window.renderOffset.y/2*yScale, (CORE.Window.render.width)*xScale, (CORE.Window.render.height)*yScale);\n#else\n    rlViewport(CORE.Window.renderOffset.x/2, CORE.Window.renderOffset.y/2, CORE.Window.render.width, CORE.Window.render.height);\n#endif\n\n    rlMatrixMode(RL_PROJECTION);        // Switch to projection matrix\n    rlLoadIdentity();                   // Reset current matrix (projection)\n\n    // Set orthographic projection to current framebuffer size\n    // NOTE: Configured top-left corner as (0, 0)\n    rlOrtho(0, CORE.Window.render.width, CORE.Window.render.height, 0, 0.0f, 1.0f);\n\n    rlMatrixMode(RL_MODELVIEW);         // Switch back to modelview matrix\n    rlLoadIdentity();                   // Reset current matrix (modelview)\n}\n\n// Compute framebuffer size relative to screen size and display size\n// NOTE: Global variables CORE.Window.render.width/CORE.Window.render.height and CORE.Window.renderOffset.x/CORE.Window.renderOffset.y can be modified\nstatic void SetupFramebuffer(int width, int height)\n{\n    // Calculate CORE.Window.render.width and CORE.Window.render.height, we have the display size (input params) and the desired screen size (global var)\n    if ((CORE.Window.screen.width > CORE.Window.display.width) || (CORE.Window.screen.height > CORE.Window.display.height))\n    {\n        TRACELOG(LOG_WARNING, \"DISPLAY: Downscaling required: Screen size (%ix%i) is bigger than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);\n\n        // Downscaling to fit display with border-bars\n        float widthRatio = (float)CORE.Window.display.width/(float)CORE.Window.screen.width;\n        float heightRatio = (float)CORE.Window.display.height/(float)CORE.Window.screen.height;\n\n        if (widthRatio <= heightRatio)\n        {\n            CORE.Window.render.width = CORE.Window.display.width;\n            CORE.Window.render.height = (int)round((float)CORE.Window.screen.height*widthRatio);\n            CORE.Window.renderOffset.x = 0;\n            CORE.Window.renderOffset.y = (CORE.Window.display.height - CORE.Window.render.height);\n        }\n        else\n        {\n            CORE.Window.render.width = (int)round((float)CORE.Window.screen.width*heightRatio);\n            CORE.Window.render.height = CORE.Window.display.height;\n            CORE.Window.renderOffset.x = (CORE.Window.display.width - CORE.Window.render.width);\n            CORE.Window.renderOffset.y = 0;\n        }\n\n        // Screen scaling required\n        float scaleRatio = (float)CORE.Window.render.width/(float)CORE.Window.screen.width;\n        CORE.Window.screenScale = MatrixScale(scaleRatio, scaleRatio, 1.0f);\n\n        // NOTE: We render to full display resolution!\n        // We just need to calculate above parameters for downscale matrix and offsets\n        CORE.Window.render.width = CORE.Window.display.width;\n        CORE.Window.render.height = CORE.Window.display.height;\n\n        TRACELOG(LOG_WARNING, \"DISPLAY: Downscale matrix generated, content will be rendered at (%ix%i)\", CORE.Window.render.width, CORE.Window.render.height);\n    }\n    else if ((CORE.Window.screen.width < CORE.Window.display.width) || (CORE.Window.screen.height < CORE.Window.display.height))\n    {\n        // Required screen size is smaller than display size\n        TRACELOG(LOG_INFO, \"DISPLAY: Upscaling required: Screen size (%ix%i) smaller than display size (%ix%i)\", CORE.Window.screen.width, CORE.Window.screen.height, CORE.Window.display.width, CORE.Window.display.height);\n\n        if ((CORE.Window.screen.width == 0) || (CORE.Window.screen.height == 0))\n        {\n            CORE.Window.screen.width = CORE.Window.display.width;\n            CORE.Window.screen.height = CORE.Window.display.height;\n        }\n\n        // Upscaling to fit display with border-bars\n        float displayRatio = (float)CORE.Window.display.width/(float)CORE.Window.display.height;\n        float screenRatio = (float)CORE.Window.screen.width/(float)CORE.Window.screen.height;\n\n        if (displayRatio <= screenRatio)\n        {\n            CORE.Window.render.width = CORE.Window.screen.width;\n            CORE.Window.render.height = (int)round((float)CORE.Window.screen.width/displayRatio);\n            CORE.Window.renderOffset.x = 0;\n            CORE.Window.renderOffset.y = (CORE.Window.render.height - CORE.Window.screen.height);\n        }\n        else\n        {\n            CORE.Window.render.width = (int)round((float)CORE.Window.screen.height*displayRatio);\n            CORE.Window.render.height = CORE.Window.screen.height;\n            CORE.Window.renderOffset.x = (CORE.Window.render.width - CORE.Window.screen.width);\n            CORE.Window.renderOffset.y = 0;\n        }\n    }\n    else\n    {\n        CORE.Window.render.width = CORE.Window.screen.width;\n        CORE.Window.render.height = CORE.Window.screen.height;\n        CORE.Window.renderOffset.x = 0;\n        CORE.Window.renderOffset.y = 0;\n    }\n}\n\n// Initialize hi-resolution timer\nstatic void InitTimer(void)\n{\n// Setting a higher resolution can improve the accuracy of time-out intervals in wait functions.\n// However, it can also reduce overall system performance, because the thread scheduler switches tasks more often.\n// High resolutions can also prevent the CPU power management system from entering power-saving modes.\n// Setting a higher resolution does not improve the accuracy of the high-resolution performance counter.\n#if defined(_WIN32) && defined(SUPPORT_WINMM_HIGHRES_TIMER) && !defined(SUPPORT_BUSY_WAIT_LOOP)\n    timeBeginPeriod(1);                 // Setup high-resolution timer to 1ms (granularity of 1-2 ms)\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    struct timespec now = { 0 };\n\n    if (clock_gettime(CLOCK_MONOTONIC, &now) == 0)  // Success\n    {\n        CORE.Time.base = (unsigned long long int)now.tv_sec*1000000000LLU + (unsigned long long int)now.tv_nsec;\n    }\n    else TRACELOG(LOG_WARNING, \"TIMER: Hi-resolution timer not available\");\n#endif\n\n    CORE.Time.previous = GetTime();     // Get time as double\n}\n\n// Wait for some time (stop program execution)\n// NOTE: Sleep() granularity could be around 10 ms, it means, Sleep() could\n// take longer than expected... for that reason we use the busy wait loop\n// Ref: http://stackoverflow.com/questions/43057578/c-programming-win32-games-sleep-taking-longer-than-expected\n// Ref: http://www.geisswerks.com/ryan/FAQS/timing.html --> All about timing on Win32!\nvoid WaitTime(double seconds)\n{\n#if defined(SUPPORT_BUSY_WAIT_LOOP) || defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)\n    double destinationTime = GetTime() + seconds;\n#endif\n\n#if defined(SUPPORT_BUSY_WAIT_LOOP)\n    while (GetTime() < destinationTime) { }\n#else\n    #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)\n        double sleepSeconds = seconds - seconds*0.05;  // NOTE: We reserve a percentage of the time for busy waiting\n    #else\n        double sleepSeconds = seconds;\n    #endif\n\n    // System halt functions\n    #if defined(_WIN32)\n        Sleep((unsigned long)(sleepSeconds*1000.0));\n    #endif\n    #if defined(__linux__) || defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__EMSCRIPTEN__)\n        struct timespec req = { 0 };\n        time_t sec = sleepSeconds;\n        long nsec = (sleepSeconds - sec)*1000000000L;\n        req.tv_sec = sec;\n        req.tv_nsec = nsec;\n\n        // NOTE: Use nanosleep() on Unix platforms... usleep() it's deprecated.\n        while (nanosleep(&req, &req) == -1) continue;\n    #endif\n    #if defined(__APPLE__)\n        usleep(sleepSeconds*1000000.0);\n    #endif\n\n    #if defined(SUPPORT_PARTIALBUSY_WAIT_LOOP)\n        while (GetTime() < destinationTime) { }\n    #endif\n#endif\n}\n\n// Swap back buffer with front buffer (screen drawing)\nvoid SwapScreenBuffer(void)\n{\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    glfwSwapBuffers(CORE.Window.handle);\n#endif\n\n#if defined(PLATFORM_ANDROID) || defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    eglSwapBuffers(CORE.Window.device, CORE.Window.surface);\n\n#if defined(PLATFORM_DRM)\n\n    if (!CORE.Window.gbmSurface || (-1 == CORE.Window.fd) || !CORE.Window.connector || !CORE.Window.crtc) TRACELOG(LOG_ERROR, \"DISPLAY: DRM initialization failed to swap\");\n\n    struct gbm_bo *bo = gbm_surface_lock_front_buffer(CORE.Window.gbmSurface);\n    if (!bo) TRACELOG(LOG_ERROR, \"DISPLAY: Failed GBM to lock front buffer\");\n\n    uint32_t fb = 0;\n    int result = drmModeAddFB(CORE.Window.fd, CORE.Window.connector->modes[CORE.Window.modeIndex].hdisplay, CORE.Window.connector->modes[CORE.Window.modeIndex].vdisplay, 24, 32, gbm_bo_get_stride(bo), gbm_bo_get_handle(bo).u32, &fb);\n    if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeAddFB() failed with result: %d\", result);\n\n    result = drmModeSetCrtc(CORE.Window.fd, CORE.Window.crtc->crtc_id, fb, 0, 0, &CORE.Window.connector->connector_id, 1, &CORE.Window.connector->modes[CORE.Window.modeIndex]);\n    if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeSetCrtc() failed with result: %d\", result);\n\n    if (CORE.Window.prevFB)\n    {\n        result = drmModeRmFB(CORE.Window.fd, CORE.Window.prevFB);\n        if (result != 0) TRACELOG(LOG_ERROR, \"DISPLAY: drmModeRmFB() failed with result: %d\", result);\n    }\n\n    CORE.Window.prevFB = fb;\n\n    if (CORE.Window.prevBO) gbm_surface_release_buffer(CORE.Window.gbmSurface, CORE.Window.prevBO);\n\n    CORE.Window.prevBO = bo;\n\n#endif  // PLATFORM_DRM\n#endif  // PLATFORM_ANDROID || PLATFORM_RPI || PLATFORM_DRM\n}\n\n// Register all input events\nvoid PollInputEvents(void)\n{\n#if defined(SUPPORT_GESTURES_SYSTEM)\n    // NOTE: Gestures update must be called every frame to reset gestures correctly\n    // because ProcessGestureEvent() is just called on an event, not every frame\n    UpdateGestures();\n#endif\n\n    // Reset keys/chars pressed registered\n    CORE.Input.Keyboard.keyPressedQueueCount = 0;\n    CORE.Input.Keyboard.charPressedQueueCount = 0;\n\n#if !(defined(PLATFORM_RPI) || defined(PLATFORM_DRM))\n    // Reset last gamepad button/axis registered state\n    CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN\n    CORE.Input.Gamepad.axisCount = 0;\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n    // Register previous keys states\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];\n\n    PollKeyboardEvents();\n\n    // Register previous mouse states\n    CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;\n    CORE.Input.Mouse.currentWheelMove = (Vector2){ 0.0f, 0.0f };\n    for (int i = 0; i < MAX_MOUSE_BUTTONS; i++)\n    {\n        CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];\n        CORE.Input.Mouse.currentButtonState[i] = CORE.Input.Mouse.currentButtonStateEvdev[i];\n    }\n\n    // Register gamepads buttons events\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        if (CORE.Input.Gamepad.ready[i])\n        {\n            // Register previous gamepad states\n            for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];\n        }\n    }\n#endif\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n    // Keyboard/Mouse input polling (automatically managed by GLFW3 through callback)\n\n    // Register previous keys states\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];\n\n    // Register previous mouse states\n    for (int i = 0; i < MAX_MOUSE_BUTTONS; i++) CORE.Input.Mouse.previousButtonState[i] = CORE.Input.Mouse.currentButtonState[i];\n\n    // Register previous mouse wheel state\n    CORE.Input.Mouse.previousWheelMove = CORE.Input.Mouse.currentWheelMove;\n    CORE.Input.Mouse.currentWheelMove = (Vector2){ 0.0f, 0.0f };\n\n    // Register previous mouse position\n    CORE.Input.Mouse.previousPosition = CORE.Input.Mouse.currentPosition;\n#endif\n\n    // Register previous touch states\n    for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.previousTouchState[i] = CORE.Input.Touch.currentTouchState[i];\n\n    // Reset touch positions\n    // TODO: It resets on PLATFORM_WEB the mouse position and not filled again until a move-event,\n    // so, if mouse is not moved it returns a (0, 0) position... this behaviour should be reviewed!\n    //for (int i = 0; i < MAX_TOUCH_POINTS; i++) CORE.Input.Touch.position[i] = (Vector2){ 0, 0 };\n\n#if defined(PLATFORM_DESKTOP)\n    // Check if gamepads are ready\n    // NOTE: We do it here in case of disconnection\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        if (glfwJoystickPresent(i)) CORE.Input.Gamepad.ready[i] = true;\n        else CORE.Input.Gamepad.ready[i] = false;\n    }\n\n    // Register gamepads buttons events\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        if (CORE.Input.Gamepad.ready[i])     // Check if gamepad is available\n        {\n            // Register previous gamepad states\n            for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];\n\n            // Get current gamepad state\n            // NOTE: There is no callback available, so we get it manually\n            // Get remapped buttons\n            GLFWgamepadstate state = { 0 };\n            glfwGetGamepadState(i, &state); // This remapps all gamepads so they have their buttons mapped like an xbox controller\n\n            const unsigned char *buttons = state.buttons;\n\n            for (int k = 0; (buttons != NULL) && (k < GLFW_GAMEPAD_BUTTON_DPAD_LEFT + 1) && (k < MAX_GAMEPAD_BUTTONS); k++)\n            {\n                GamepadButton button = -1;\n\n                switch (k)\n                {\n                    case GLFW_GAMEPAD_BUTTON_Y: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;\n                    case GLFW_GAMEPAD_BUTTON_B: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;\n                    case GLFW_GAMEPAD_BUTTON_A: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;\n                    case GLFW_GAMEPAD_BUTTON_X: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;\n\n                    case GLFW_GAMEPAD_BUTTON_LEFT_BUMPER: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;\n                    case GLFW_GAMEPAD_BUTTON_RIGHT_BUMPER: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;\n\n                    case GLFW_GAMEPAD_BUTTON_BACK: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;\n                    case GLFW_GAMEPAD_BUTTON_GUIDE: button = GAMEPAD_BUTTON_MIDDLE; break;\n                    case GLFW_GAMEPAD_BUTTON_START: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;\n\n                    case GLFW_GAMEPAD_BUTTON_DPAD_UP: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;\n                    case GLFW_GAMEPAD_BUTTON_DPAD_RIGHT: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;\n                    case GLFW_GAMEPAD_BUTTON_DPAD_DOWN: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;\n                    case GLFW_GAMEPAD_BUTTON_DPAD_LEFT: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;\n\n                    case GLFW_GAMEPAD_BUTTON_LEFT_THUMB: button = GAMEPAD_BUTTON_LEFT_THUMB; break;\n                    case GLFW_GAMEPAD_BUTTON_RIGHT_THUMB: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;\n                    default: break;\n                }\n\n                if (button != -1)   // Check for valid button\n                {\n                    if (buttons[k] == GLFW_PRESS)\n                    {\n                        CORE.Input.Gamepad.currentButtonState[i][button] = 1;\n                        CORE.Input.Gamepad.lastButtonPressed = button;\n                    }\n                    else CORE.Input.Gamepad.currentButtonState[i][button] = 0;\n                }\n            }\n\n            // Get current axis state\n            const float *axes = state.axes;\n\n            for (int k = 0; (axes != NULL) && (k < GLFW_GAMEPAD_AXIS_LAST + 1) && (k < MAX_GAMEPAD_AXIS); k++)\n            {\n                CORE.Input.Gamepad.axisState[i][k] = axes[k];\n            }\n\n            // Register buttons for 2nd triggers (because GLFW doesn't count these as buttons but rather axis)\n            CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_LEFT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_LEFT_TRIGGER] > 0.1f);\n            CORE.Input.Gamepad.currentButtonState[i][GAMEPAD_BUTTON_RIGHT_TRIGGER_2] = (char)(CORE.Input.Gamepad.axisState[i][GAMEPAD_AXIS_RIGHT_TRIGGER] > 0.1f);\n\n            CORE.Input.Gamepad.axisCount = GLFW_GAMEPAD_AXIS_LAST + 1;\n        }\n    }\n\n    CORE.Window.resizedLastFrame = false;\n\n    if (CORE.Window.eventWaiting) glfwWaitEvents();     // Wait for in input events before continue (drawing is paused)\n    else glfwPollEvents();      // Poll input events: keyboard/mouse/window events (callbacks)\n#endif  // PLATFORM_DESKTOP\n\n#if defined(PLATFORM_WEB)\n    CORE.Window.resizedLastFrame = false;\n#endif  // PLATFORM_WEB\n\n// Gamepad support using emscripten API\n// NOTE: GLFW3 joystick functionality not available in web\n#if defined(PLATFORM_WEB)\n    // Get number of gamepads connected\n    int numGamepads = 0;\n    if (emscripten_sample_gamepad_data() == EMSCRIPTEN_RESULT_SUCCESS) numGamepads = emscripten_get_num_gamepads();\n\n    for (int i = 0; (i < numGamepads) && (i < MAX_GAMEPADS); i++)\n    {\n        // Register previous gamepad button states\n        for (int k = 0; k < MAX_GAMEPAD_BUTTONS; k++) CORE.Input.Gamepad.previousButtonState[i][k] = CORE.Input.Gamepad.currentButtonState[i][k];\n\n        EmscriptenGamepadEvent gamepadState;\n\n        int result = emscripten_get_gamepad_status(i, &gamepadState);\n\n        if (result == EMSCRIPTEN_RESULT_SUCCESS)\n        {\n            // Register buttons data for every connected gamepad\n            for (int j = 0; (j < gamepadState.numButtons) && (j < MAX_GAMEPAD_BUTTONS); j++)\n            {\n                GamepadButton button = -1;\n\n                // Gamepad Buttons reference: https://www.w3.org/TR/gamepad/#gamepad-interface\n                switch (j)\n                {\n                    case 0: button = GAMEPAD_BUTTON_RIGHT_FACE_DOWN; break;\n                    case 1: button = GAMEPAD_BUTTON_RIGHT_FACE_RIGHT; break;\n                    case 2: button = GAMEPAD_BUTTON_RIGHT_FACE_LEFT; break;\n                    case 3: button = GAMEPAD_BUTTON_RIGHT_FACE_UP; break;\n                    case 4: button = GAMEPAD_BUTTON_LEFT_TRIGGER_1; break;\n                    case 5: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_1; break;\n                    case 6: button = GAMEPAD_BUTTON_LEFT_TRIGGER_2; break;\n                    case 7: button = GAMEPAD_BUTTON_RIGHT_TRIGGER_2; break;\n                    case 8: button = GAMEPAD_BUTTON_MIDDLE_LEFT; break;\n                    case 9: button = GAMEPAD_BUTTON_MIDDLE_RIGHT; break;\n                    case 10: button = GAMEPAD_BUTTON_LEFT_THUMB; break;\n                    case 11: button = GAMEPAD_BUTTON_RIGHT_THUMB; break;\n                    case 12: button = GAMEPAD_BUTTON_LEFT_FACE_UP; break;\n                    case 13: button = GAMEPAD_BUTTON_LEFT_FACE_DOWN; break;\n                    case 14: button = GAMEPAD_BUTTON_LEFT_FACE_LEFT; break;\n                    case 15: button = GAMEPAD_BUTTON_LEFT_FACE_RIGHT; break;\n                    default: break;\n                }\n\n                if (button != -1)   // Check for valid button\n                {\n                    if (gamepadState.digitalButton[j] == 1)\n                    {\n                        CORE.Input.Gamepad.currentButtonState[i][button] = 1;\n                        CORE.Input.Gamepad.lastButtonPressed = button;\n                    }\n                    else CORE.Input.Gamepad.currentButtonState[i][button] = 0;\n                }\n\n                //TRACELOGD(\"INPUT: Gamepad %d, button %d: Digital: %d, Analog: %g\", gamepadState.index, j, gamepadState.digitalButton[j], gamepadState.analogButton[j]);\n            }\n\n            // Register axis data for every connected gamepad\n            for (int j = 0; (j < gamepadState.numAxes) && (j < MAX_GAMEPAD_AXIS); j++)\n            {\n                CORE.Input.Gamepad.axisState[i][j] = gamepadState.axis[j];\n            }\n\n            CORE.Input.Gamepad.axisCount = gamepadState.numAxes;\n        }\n    }\n#endif\n\n#if defined(PLATFORM_ANDROID)\n    // Register previous keys states\n    // NOTE: Android supports up to 260 keys\n    for (int i = 0; i < 260; i++) CORE.Input.Keyboard.previousKeyState[i] = CORE.Input.Keyboard.currentKeyState[i];\n\n    // Android ALooper_pollAll() variables\n    int pollResult = 0;\n    int pollEvents = 0;\n\n    // Poll Events (registered events)\n    // NOTE: Activity is paused if not enabled (CORE.Android.appEnabled)\n    while ((pollResult = ALooper_pollAll(CORE.Android.appEnabled? 0 : -1, NULL, &pollEvents, (void**)&CORE.Android.source)) >= 0)\n    {\n        // Process this event\n        if (CORE.Android.source != NULL) CORE.Android.source->process(CORE.Android.app, CORE.Android.source);\n\n        // NOTE: Never close window, native activity is controlled by the system!\n        if (CORE.Android.app->destroyRequested != 0)\n        {\n            //CORE.Window.shouldClose = true;\n            //ANativeActivity_finish(CORE.Android.app->activity);\n        }\n    }\n#endif\n\n#if (defined(PLATFORM_RPI) || defined(PLATFORM_DRM)) && defined(SUPPORT_SSH_KEYBOARD_RPI)\n    // NOTE: Keyboard reading could be done using input_event(s) or just read from stdin, both methods are used here.\n    // stdin reading is still used for legacy purposes, it allows keyboard input trough SSH console\n\n    if (!CORE.Input.Keyboard.evtMode) ProcessKeyboard();\n\n    // NOTE: Mouse input events polling is done asynchronously in another pthread - EventThread()\n    // NOTE: Gamepad (Joystick) input events polling is done asynchonously in another pthread - GamepadThread()\n#endif\n}\n\n// Scan all files and directories in a base path\n// WARNING: files.paths[] must be previously allocated and\n// contain enough space to store all required paths\nstatic void ScanDirectoryFiles(const char *basePath, FilePathList *files, const char *filter)\n{\n    static char path[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(path, 0, MAX_FILEPATH_LENGTH);\n\n    struct dirent *dp = NULL;\n    DIR *dir = opendir(basePath);\n\n    if (dir != NULL)\n    {\n        while ((dp = readdir(dir)) != NULL)\n        {\n            if ((strcmp(dp->d_name, \".\") != 0) &&\n                (strcmp(dp->d_name, \"..\") != 0))\n            {\n                sprintf(path, \"%s/%s\", basePath, dp->d_name);\n\n                if (filter != NULL)\n                {\n                    if (IsFileExtension(path, filter))\n                    {\n                        strcpy(files->paths[files->count], path);\n                        files->count++;\n                    }\n                }\n                else\n                {\n                    strcpy(files->paths[files->count], path);\n                    files->count++;\n                }\n            }\n        }\n\n        closedir(dir);\n    }\n    else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);\n}\n\n// Scan all files and directories recursively from a base path\nstatic void ScanDirectoryFilesRecursively(const char *basePath, FilePathList *files, const char *filter)\n{\n    char path[MAX_FILEPATH_LENGTH] = { 0 };\n    memset(path, 0, MAX_FILEPATH_LENGTH);\n\n    struct dirent *dp = NULL;\n    DIR *dir = opendir(basePath);\n\n    if (dir != NULL)\n    {\n        while (((dp = readdir(dir)) != NULL) && (files->count < files->capacity))\n        {\n            if ((strcmp(dp->d_name, \".\") != 0) && (strcmp(dp->d_name, \"..\") != 0))\n            {\n                // Construct new path from our base path\n                sprintf(path, \"%s/%s\", basePath, dp->d_name);\n\n                if (IsPathFile(path))\n                {\n                    if (filter != NULL)\n                    {\n                        if (IsFileExtension(path, filter))\n                        {\n                            strcpy(files->paths[files->count], path);\n                            files->count++;\n                        }\n                    }\n                    else\n                    {\n                        strcpy(files->paths[files->count], path);\n                        files->count++;\n                    }\n\n                    if (files->count >= files->capacity)\n                    {\n                        TRACELOG(LOG_WARNING, \"FILEIO: Maximum filepath scan capacity reached (%i files)\", files->capacity);\n                        break;\n                    }\n                }\n                else ScanDirectoryFilesRecursively(path, files, filter);\n            }\n        }\n\n        closedir(dir);\n    }\n    else TRACELOG(LOG_WARNING, \"FILEIO: Directory cannot be opened (%s)\", basePath);\n}\n\n#if defined(PLATFORM_DESKTOP) || defined(PLATFORM_WEB)\n// GLFW3 Error Callback, runs on GLFW3 error\nstatic void ErrorCallback(int error, const char *description)\n{\n    TRACELOG(LOG_WARNING, \"GLFW: Error: %i Description: %s\", error, description);\n}\n\n// GLFW3 WindowSize Callback, runs when window is resizedLastFrame\n// NOTE: Window resizing not allowed by default\nstatic void WindowSizeCallback(GLFWwindow *window, int width, int height)\n{\n    // Reset viewport and projection matrix for new size\n    SetupViewport(width, height);\n\n    CORE.Window.currentFbo.width = width;\n    CORE.Window.currentFbo.height = height;\n    CORE.Window.resizedLastFrame = true;\n\n    if (IsWindowFullscreen()) return;\n\n    // Set current screen size\n#if defined(__APPLE__)\n    CORE.Window.screen.width = width;\n    CORE.Window.screen.height = height;\n#else\n    if ((CORE.Window.flags & FLAG_WINDOW_HIGHDPI) > 0)\n    {\n        Vector2 windowScaleDPI = GetWindowScaleDPI();\n\n        CORE.Window.screen.width = (unsigned int)(width/windowScaleDPI.x);\n        CORE.Window.screen.height = (unsigned int)(height/windowScaleDPI.y);\n    }\n    else\n    {\n        CORE.Window.screen.width = width;\n        CORE.Window.screen.height = height;\n    }\n#endif\n\n    // NOTE: Postprocessing texture is not scaled to new size\n}\n\n// GLFW3 WindowIconify Callback, runs when window is minimized/restored\nstatic void WindowIconifyCallback(GLFWwindow *window, int iconified)\n{\n    if (iconified) CORE.Window.flags |= FLAG_WINDOW_MINIMIZED;  // The window was iconified\n    else CORE.Window.flags &= ~FLAG_WINDOW_MINIMIZED;           // The window was restored\n}\n\n#if !defined(PLATFORM_WEB)\n// GLFW3 WindowMaximize Callback, runs when window is maximized/restored\nstatic void WindowMaximizeCallback(GLFWwindow *window, int maximized)\n{\n    if (maximized) CORE.Window.flags |= FLAG_WINDOW_MAXIMIZED;  // The window was maximized\n    else CORE.Window.flags &= ~FLAG_WINDOW_MAXIMIZED;           // The window was restored\n}\n#endif\n\n// GLFW3 WindowFocus Callback, runs when window get/lose focus\nstatic void WindowFocusCallback(GLFWwindow *window, int focused)\n{\n    if (focused) CORE.Window.flags &= ~FLAG_WINDOW_UNFOCUSED;   // The window was focused\n    else CORE.Window.flags |= FLAG_WINDOW_UNFOCUSED;            // The window lost focus\n}\n\n// GLFW3 Keyboard Callback, runs on key pressed\nstatic void KeyCallback(GLFWwindow *window, int key, int scancode, int action, int mods)\n{\n    if (key < 0) return;    // Security check, macOS fn key generates -1\n\n    // WARNING: GLFW could return GLFW_REPEAT, we need to consider it as 1\n    // to work properly with our implementation (IsKeyDown/IsKeyUp checks)\n    if (action == GLFW_RELEASE) CORE.Input.Keyboard.currentKeyState[key] = 0;\n    else CORE.Input.Keyboard.currentKeyState[key] = 1;\n\n#if !defined(PLATFORM_WEB)\n    // WARNING: Check if CAPS/NUM key modifiers are enabled and force down state for those keys\n    if (((key == KEY_CAPS_LOCK) && ((mods & GLFW_MOD_CAPS_LOCK) > 0)) ||\n        ((key == KEY_NUM_LOCK) && ((mods & GLFW_MOD_NUM_LOCK) > 0))) CORE.Input.Keyboard.currentKeyState[key] = 1;\n#endif\n\n    // Check if there is space available in the key queue\n    if ((CORE.Input.Keyboard.keyPressedQueueCount < MAX_KEY_PRESSED_QUEUE) && (action == GLFW_PRESS))\n    {\n        // Add character to the queue\n        CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = key;\n        CORE.Input.Keyboard.keyPressedQueueCount++;\n    }\n\n    // Check the exit key to set close window\n    if ((key == CORE.Input.Keyboard.exitKey) && (action == GLFW_PRESS)) glfwSetWindowShouldClose(CORE.Window.handle, GLFW_TRUE);\n\n#if defined(SUPPORT_SCREEN_CAPTURE)\n    if ((key == GLFW_KEY_F12) && (action == GLFW_PRESS))\n    {\n#if defined(SUPPORT_GIF_RECORDING)\n        if (mods == GLFW_MOD_CONTROL)\n        {\n            if (gifRecording)\n            {\n                gifRecording = false;\n\n                MsfGifResult result = msf_gif_end(&gifState);\n\n                SaveFileData(TextFormat(\"%s/screenrec%03i.gif\", CORE.Storage.basePath, screenshotCounter), result.data, (unsigned int)result.dataSize);\n                msf_gif_free(result);\n\n            #if defined(PLATFORM_WEB)\n                // Download file from MEMFS (emscripten memory filesystem)\n                // saveFileFromMEMFSToDisk() function is defined in raylib/templates/web_shel/shell.html\n                emscripten_run_script(TextFormat(\"saveFileFromMEMFSToDisk('%s','%s')\", TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1), TextFormat(\"screenrec%03i.gif\", screenshotCounter - 1)));\n            #endif\n\n                TRACELOG(LOG_INFO, \"SYSTEM: Finish animated GIF recording\");\n            }\n            else\n            {\n                gifRecording = true;\n                gifFrameCounter = 0;\n\n                Vector2 scale = GetWindowScaleDPI();\n                msf_gif_begin(&gifState, (int)((float)CORE.Window.render.width*scale.x), (int)((float)CORE.Window.render.height*scale.y));\n                screenshotCounter++;\n\n                TRACELOG(LOG_INFO, \"SYSTEM: Start animated GIF recording: %s\", TextFormat(\"screenrec%03i.gif\", screenshotCounter));\n            }\n        }\n        else\n#endif  // SUPPORT_GIF_RECORDING\n        {\n            TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n            screenshotCounter++;\n        }\n    }\n#endif  // SUPPORT_SCREEN_CAPTURE\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n    if ((key == GLFW_KEY_F11) && (action == GLFW_PRESS))\n    {\n        eventsRecording = !eventsRecording;\n\n        // On finish recording, we export events into a file\n        if (!eventsRecording) ExportAutomationEvents(\"eventsrec.rep\");\n    }\n    else if ((key == GLFW_KEY_F9) && (action == GLFW_PRESS))\n    {\n        LoadAutomationEvents(\"eventsrec.rep\");\n        eventsPlaying = true;\n\n        TRACELOG(LOG_WARNING, \"eventsPlaying enabled!\");\n    }\n#endif\n}\n\n// GLFW3 Char Key Callback, runs on key down (gets equivalent unicode char value)\nstatic void CharCallback(GLFWwindow *window, unsigned int key)\n{\n    //TRACELOG(LOG_DEBUG, \"Char Callback: KEY:%i(%c)\", key, key);\n\n    // NOTE: Registers any key down considering OS keyboard layout but\n    // does not detect action events, those should be managed by user...\n    // Ref: https://github.com/glfw/glfw/issues/668#issuecomment-166794907\n    // Ref: https://www.glfw.org/docs/latest/input_guide.html#input_char\n\n    // Check if there is space available in the queue\n    if (CORE.Input.Keyboard.charPressedQueueCount < MAX_CHAR_PRESSED_QUEUE)\n    {\n        // Add character to the queue\n        CORE.Input.Keyboard.charPressedQueue[CORE.Input.Keyboard.charPressedQueueCount] = key;\n        CORE.Input.Keyboard.charPressedQueueCount++;\n    }\n}\n\n// GLFW3 Mouse Button Callback, runs on mouse button pressed\nstatic void MouseButtonCallback(GLFWwindow *window, int button, int action, int mods)\n{\n    // WARNING: GLFW could only return GLFW_PRESS (1) or GLFW_RELEASE (0) for now,\n    // but future releases may add more actions (i.e. GLFW_REPEAT)\n    CORE.Input.Mouse.currentButtonState[button] = action;\n\n#if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)         // PLATFORM_DESKTOP\n    // Process mouse events as touches to be able to use mouse-gestures\n    GestureEvent gestureEvent = { 0 };\n\n    // Register touch actions\n    if ((CORE.Input.Mouse.currentButtonState[button] == 1) && (CORE.Input.Mouse.previousButtonState[button] == 0)) gestureEvent.touchAction = TOUCH_ACTION_DOWN;\n    else if ((CORE.Input.Mouse.currentButtonState[button] == 0) && (CORE.Input.Mouse.previousButtonState[button] == 1)) gestureEvent.touchAction = TOUCH_ACTION_UP;\n\n    // NOTE: TOUCH_ACTION_MOVE event is registered in MouseCursorPosCallback()\n\n    // Assign a pointer ID\n    gestureEvent.pointId[0] = 0;\n\n    // Register touch points count\n    gestureEvent.pointCount = 1;\n\n    // Register touch points position, only one point registered\n    gestureEvent.position[0] = GetMousePosition();\n\n    // Normalize gestureEvent.position[0] for CORE.Window.screen.width and CORE.Window.screen.height\n    gestureEvent.position[0].x /= (float)GetScreenWidth();\n    gestureEvent.position[0].y /= (float)GetScreenHeight();\n\n    // Gesture data is sent to gestures-system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n}\n\n// GLFW3 Cursor Position Callback, runs on mouse move\nstatic void MouseCursorPosCallback(GLFWwindow *window, double x, double y)\n{\n    CORE.Input.Mouse.currentPosition.x = (float)x;\n    CORE.Input.Mouse.currentPosition.y = (float)y;\n    CORE.Input.Touch.position[0] = CORE.Input.Mouse.currentPosition;\n\n#if defined(SUPPORT_GESTURES_SYSTEM) && defined(SUPPORT_MOUSE_GESTURES)         // PLATFORM_DESKTOP\n    // Process mouse events as touches to be able to use mouse-gestures\n    GestureEvent gestureEvent = { 0 };\n\n    gestureEvent.touchAction = TOUCH_ACTION_MOVE;\n\n    // Assign a pointer ID\n    gestureEvent.pointId[0] = 0;\n\n    // Register touch points count\n    gestureEvent.pointCount = 1;\n\n    // Register touch points position, only one point registered\n    gestureEvent.position[0] = CORE.Input.Touch.position[0];\n\n    // Normalize gestureEvent.position[0] for CORE.Window.screen.width and CORE.Window.screen.height\n    gestureEvent.position[0].x /= (float)GetScreenWidth();\n    gestureEvent.position[0].y /= (float)GetScreenHeight();\n\n    // Gesture data is sent to gestures-system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n}\n\n// GLFW3 Scrolling Callback, runs on mouse wheel\nstatic void MouseScrollCallback(GLFWwindow *window, double xoffset, double yoffset)\n{\n    CORE.Input.Mouse.currentWheelMove = (Vector2){ (float)xoffset, (float)yoffset };\n}\n\n// GLFW3 CursorEnter Callback, when cursor enters the window\nstatic void CursorEnterCallback(GLFWwindow *window, int enter)\n{\n    if (enter == true) CORE.Input.Mouse.cursorOnScreen = true;\n    else CORE.Input.Mouse.cursorOnScreen = false;\n}\n\n// GLFW3 Window Drop Callback, runs when drop files into window\nstatic void WindowDropCallback(GLFWwindow *window, int count, const char **paths)\n{\n    if (count > 0)\n    {\n        // In case previous dropped filepaths have not been freed, we free them\n        if (CORE.Window.dropFileCount > 0)\n        {\n            for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++) RL_FREE(CORE.Window.dropFilepaths[i]);\n\n            RL_FREE(CORE.Window.dropFilepaths);\n\n            CORE.Window.dropFileCount = 0;\n            CORE.Window.dropFilepaths = NULL;\n        }\n\n        // WARNING: Paths are freed by GLFW when the callback returns, we must keep an internal copy\n        CORE.Window.dropFileCount = count;\n        CORE.Window.dropFilepaths = (char **)RL_CALLOC(CORE.Window.dropFileCount, sizeof(char *));\n\n        for (unsigned int i = 0; i < CORE.Window.dropFileCount; i++)\n        {\n            CORE.Window.dropFilepaths[i] = (char *)RL_CALLOC(MAX_FILEPATH_LENGTH, sizeof(char));\n            strcpy(CORE.Window.dropFilepaths[i], paths[i]);\n        }\n    }\n}\n#endif\n\n#if defined(PLATFORM_ANDROID)\n// ANDROID: Process activity lifecycle commands\nstatic void AndroidCommandCallback(struct android_app *app, int32_t cmd)\n{\n    switch (cmd)\n    {\n        case APP_CMD_START:\n        {\n            //rendering = true;\n        } break;\n        case APP_CMD_RESUME: break;\n        case APP_CMD_INIT_WINDOW:\n        {\n            if (app->window != NULL)\n            {\n                if (CORE.Android.contextRebindRequired)\n                {\n                    // Reset screen scaling to full display size\n                    EGLint displayFormat = 0;\n                    eglGetConfigAttrib(CORE.Window.device, CORE.Window.config, EGL_NATIVE_VISUAL_ID, &displayFormat);\n\n                    // Adding renderOffset here feels rather hackish, but the viewport scaling is wrong after the\n                    // context rebinding if the screen is scaled unless offsets are added. There's probably a more\n                    // appropriate way to fix this\n                    ANativeWindow_setBuffersGeometry(app->window,\n                        CORE.Window.render.width + CORE.Window.renderOffset.x,\n                        CORE.Window.render.height + CORE.Window.renderOffset.y,\n                        displayFormat);\n\n                    // Recreate display surface and re-attach OpenGL context\n                    CORE.Window.surface = eglCreateWindowSurface(CORE.Window.device, CORE.Window.config, app->window, NULL);\n                    eglMakeCurrent(CORE.Window.device, CORE.Window.surface, CORE.Window.surface, CORE.Window.context);\n\n                    CORE.Android.contextRebindRequired = false;\n                }\n                else\n                {\n                    CORE.Window.display.width = ANativeWindow_getWidth(CORE.Android.app->window);\n                    CORE.Window.display.height = ANativeWindow_getHeight(CORE.Android.app->window);\n\n                    // Initialize graphics device (display device and OpenGL context)\n                    InitGraphicsDevice(CORE.Window.screen.width, CORE.Window.screen.height);\n\n                    // Initialize hi-res timer\n                    InitTimer();\n\n                    // Initialize random seed\n                    srand((unsigned int)time(NULL));\n\n                #if defined(SUPPORT_MODULE_RTEXT) && defined(SUPPORT_DEFAULT_FONT)\n                    // Load default font\n                    // WARNING: External function: Module required: rtext\n                    LoadFontDefault();\n                    Rectangle rec = GetFontDefault().recs[95];\n                    // NOTE: We setup a 1px padding on char rectangle to avoid pixel bleeding on MSAA filtering\n                    #if defined(SUPPORT_MODULE_RSHAPES)\n                    SetShapesTexture(GetFontDefault().texture, (Rectangle){ rec.x + 1, rec.y + 1, rec.width - 2, rec.height - 2 });  // WARNING: Module required: rshapes\n                    #endif\n                #endif\n\n                    // TODO: GPU assets reload in case of lost focus (lost context)\n                    // NOTE: This problem has been solved just unbinding and rebinding context from display\n                    /*\n                    if (assetsReloadRequired)\n                    {\n                        for (int i = 0; i < assetCount; i++)\n                        {\n                            // TODO: Unload old asset if required\n\n                            // Load texture again to pointed texture\n                            (*textureAsset + i) = LoadTexture(assetPath[i]);\n                        }\n                    }\n                    */\n                }\n            }\n        } break;\n        case APP_CMD_GAINED_FOCUS:\n        {\n            CORE.Android.appEnabled = true;\n            //ResumeMusicStream();\n        } break;\n        case APP_CMD_PAUSE: break;\n        case APP_CMD_LOST_FOCUS:\n        {\n            CORE.Android.appEnabled = false;\n            //PauseMusicStream();\n        } break;\n        case APP_CMD_TERM_WINDOW:\n        {\n            // Dettach OpenGL context and destroy display surface\n            // NOTE 1: Detaching context before destroying display surface avoids losing our resources (textures, shaders, VBOs...)\n            // NOTE 2: In some cases (too many context loaded), OS could unload context automatically... :(\n            eglMakeCurrent(CORE.Window.device, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);\n            eglDestroySurface(CORE.Window.device, CORE.Window.surface);\n\n            CORE.Android.contextRebindRequired = true;\n        } break;\n        case APP_CMD_SAVE_STATE: break;\n        case APP_CMD_STOP: break;\n        case APP_CMD_DESTROY:\n        {\n            // TODO: Finish activity?\n            //ANativeActivity_finish(CORE.Android.app->activity);\n        } break;\n        case APP_CMD_CONFIG_CHANGED:\n        {\n            //AConfiguration_fromAssetManager(CORE.Android.app->config, CORE.Android.app->activity->assetManager);\n            //print_cur_config(CORE.Android.app);\n\n            // Check screen orientation here!\n        } break;\n        default: break;\n    }\n}\n\nstatic GamepadButton AndroidTranslateGamepadButton(int button)\n{\n    switch (button)\n    {\n        case AKEYCODE_BUTTON_A: return GAMEPAD_BUTTON_RIGHT_FACE_DOWN;\n        case AKEYCODE_BUTTON_B: return GAMEPAD_BUTTON_RIGHT_FACE_RIGHT;\n        case AKEYCODE_BUTTON_X: return GAMEPAD_BUTTON_RIGHT_FACE_LEFT;\n        case AKEYCODE_BUTTON_Y: return GAMEPAD_BUTTON_RIGHT_FACE_UP;\n        case AKEYCODE_BUTTON_L1: return GAMEPAD_BUTTON_LEFT_TRIGGER_1;\n        case AKEYCODE_BUTTON_R1: return GAMEPAD_BUTTON_RIGHT_TRIGGER_1;\n        case AKEYCODE_BUTTON_L2: return GAMEPAD_BUTTON_LEFT_TRIGGER_2;\n        case AKEYCODE_BUTTON_R2: return GAMEPAD_BUTTON_RIGHT_TRIGGER_2;\n        case AKEYCODE_BUTTON_THUMBL: return GAMEPAD_BUTTON_LEFT_THUMB;\n        case AKEYCODE_BUTTON_THUMBR: return GAMEPAD_BUTTON_RIGHT_THUMB;\n        case AKEYCODE_BUTTON_START: return GAMEPAD_BUTTON_MIDDLE_RIGHT;\n        case AKEYCODE_BUTTON_SELECT: return GAMEPAD_BUTTON_MIDDLE_LEFT;\n        case AKEYCODE_BUTTON_MODE: return GAMEPAD_BUTTON_MIDDLE;\n        // On some (most?) gamepads dpad events are reported as axis motion instead\n        case AKEYCODE_DPAD_DOWN: return GAMEPAD_BUTTON_LEFT_FACE_DOWN;\n        case AKEYCODE_DPAD_RIGHT: return GAMEPAD_BUTTON_LEFT_FACE_RIGHT;\n        case AKEYCODE_DPAD_LEFT: return GAMEPAD_BUTTON_LEFT_FACE_LEFT;\n        case AKEYCODE_DPAD_UP: return GAMEPAD_BUTTON_LEFT_FACE_UP;\n        default: return GAMEPAD_BUTTON_UNKNOWN;\n    }\n}\n\n// ANDROID: Get input events\nstatic int32_t AndroidInputCallback(struct android_app *app, AInputEvent *event)\n{\n    // If additional inputs are required check:\n    // https://developer.android.com/ndk/reference/group/input\n    // https://developer.android.com/training/game-controllers/controller-input\n\n    int type = AInputEvent_getType(event);\n    int source = AInputEvent_getSource(event);\n\n    if (type == AINPUT_EVENT_TYPE_MOTION)\n    {\n        if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||\n            ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))\n        {\n            // For now we'll assume a single gamepad which we \"detect\" on its input event\n            CORE.Input.Gamepad.ready[0] = true;\n\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_X] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_X, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_Y] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_Y, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_X] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_Z, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_Y] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_RZ, 0);\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_LEFT_TRIGGER] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_BRAKE, 0) * 2.0f - 1.0f;\n            CORE.Input.Gamepad.axisState[0][GAMEPAD_AXIS_RIGHT_TRIGGER] = AMotionEvent_getAxisValue(\n                    event, AMOTION_EVENT_AXIS_GAS, 0) * 2.0f - 1.0f;\n\n            // dpad is reported as an axis on android\n            float dpadX = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_X, 0);\n            float dpadY = AMotionEvent_getAxisValue(event, AMOTION_EVENT_AXIS_HAT_Y, 0);\n\n            if (dpadX == 1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 1;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;\n            }\n            else if (dpadX == -1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 1;\n            }\n            else\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_RIGHT] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_LEFT] = 0;\n            }\n\n            if (dpadY == 1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 1;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;\n            }\n            else if (dpadY == -1.0f)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 1;\n            }\n            else\n            {\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_DOWN] = 0;\n                CORE.Input.Gamepad.currentButtonState[0][GAMEPAD_BUTTON_LEFT_FACE_UP] = 0;\n            }\n\n            return 1; // Handled gamepad axis motion\n        }\n    }\n    else if (type == AINPUT_EVENT_TYPE_KEY)\n    {\n        int32_t keycode = AKeyEvent_getKeyCode(event);\n        //int32_t AKeyEvent_getMetaState(event);\n\n        // Handle gamepad button presses and releases\n        if (((source & AINPUT_SOURCE_JOYSTICK) == AINPUT_SOURCE_JOYSTICK) ||\n            ((source & AINPUT_SOURCE_GAMEPAD) == AINPUT_SOURCE_GAMEPAD))\n        {\n            // For now we'll assume a single gamepad which we \"detect\" on its input event\n            CORE.Input.Gamepad.ready[0] = true;\n\n            GamepadButton button = AndroidTranslateGamepadButton(keycode);\n\n            if (button == GAMEPAD_BUTTON_UNKNOWN) return 1;\n\n            if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)\n            {\n                CORE.Input.Gamepad.currentButtonState[0][button] = 1;\n            }\n            else CORE.Input.Gamepad.currentButtonState[0][button] = 0;  // Key up\n\n            return 1; // Handled gamepad button\n        }\n\n        // Save current button and its state\n        // NOTE: Android key action is 0 for down and 1 for up\n        if (AKeyEvent_getAction(event) == AKEY_EVENT_ACTION_DOWN)\n        {\n            CORE.Input.Keyboard.currentKeyState[keycode] = 1;   // Key down\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n        else CORE.Input.Keyboard.currentKeyState[keycode] = 0;  // Key up\n\n        if (keycode == AKEYCODE_POWER)\n        {\n            // Let the OS handle input to avoid app stuck. Behaviour: CMD_PAUSE -> CMD_SAVE_STATE -> CMD_STOP -> CMD_CONFIG_CHANGED -> CMD_LOST_FOCUS\n            // Resuming Behaviour: CMD_START -> CMD_RESUME -> CMD_CONFIG_CHANGED -> CMD_CONFIG_CHANGED -> CMD_GAINED_FOCUS\n            // It seems like locking mobile, screen size (CMD_CONFIG_CHANGED) is affected.\n            // NOTE: AndroidManifest.xml must have <activity android:configChanges=\"orientation|keyboardHidden|screenSize\" >\n            // Before that change, activity was calling CMD_TERM_WINDOW and CMD_DESTROY when locking mobile, so that was not a normal behaviour\n            return 0;\n        }\n        else if ((keycode == AKEYCODE_BACK) || (keycode == AKEYCODE_MENU))\n        {\n            // Eat BACK_BUTTON and AKEYCODE_MENU, just do nothing... and don't let to be handled by OS!\n            return 1;\n        }\n        else if ((keycode == AKEYCODE_VOLUME_UP) || (keycode == AKEYCODE_VOLUME_DOWN))\n        {\n            // Set default OS behaviour\n            return 0;\n        }\n\n        return 0;\n    }\n\n    // Register touch points count\n    CORE.Input.Touch.pointCount = AMotionEvent_getPointerCount(event);\n\n    for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        // Register touch points id\n        CORE.Input.Touch.pointId[i] = AMotionEvent_getPointerId(event, i);\n\n        // Register touch points position\n        CORE.Input.Touch.position[i] = (Vector2){ AMotionEvent_getX(event, i), AMotionEvent_getY(event, i) };\n\n        // Normalize CORE.Input.Touch.position[i] for CORE.Window.screen.width and CORE.Window.screen.height\n        float widthRatio = (float)(CORE.Window.screen.width + CORE.Window.renderOffset.x) / (float)CORE.Window.display.width;\n        float heightRatio = (float)(CORE.Window.screen.height + CORE.Window.renderOffset.y) / (float)CORE.Window.display.height;\n        CORE.Input.Touch.position[i].x = CORE.Input.Touch.position[i].x * widthRatio - (float)CORE.Window.renderOffset.x / 2;\n        CORE.Input.Touch.position[i].y = CORE.Input.Touch.position[i].y * heightRatio - (float)CORE.Window.renderOffset.y / 2;\n    }\n\n    int32_t action = AMotionEvent_getAction(event);\n    unsigned int flags = action & AMOTION_EVENT_ACTION_MASK;\n\n#if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_ANDROID\n    GestureEvent gestureEvent = { 0 };\n\n    gestureEvent.pointCount = CORE.Input.Touch.pointCount;\n\n    // Register touch actions\n    if (flags == AMOTION_EVENT_ACTION_DOWN) gestureEvent.touchAction = TOUCH_ACTION_DOWN;\n    else if (flags == AMOTION_EVENT_ACTION_UP) gestureEvent.touchAction = TOUCH_ACTION_UP;\n    else if (flags == AMOTION_EVENT_ACTION_MOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;\n    else if (flags == AMOTION_EVENT_ACTION_CANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;\n\n    for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];\n        gestureEvent.position[i] = CORE.Input.Touch.position[i];\n    }\n\n    // Gesture data is sent to gestures system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n\n    int32_t pointerIndex = (action & AMOTION_EVENT_ACTION_POINTER_INDEX_MASK) >> AMOTION_EVENT_ACTION_POINTER_INDEX_SHIFT;\n\n    if (flags == AMOTION_EVENT_ACTION_POINTER_UP || flags == AMOTION_EVENT_ACTION_UP)\n    {\n        // One of the touchpoints is released, remove it from touch point arrays\n        for (int i = pointerIndex; (i < CORE.Input.Touch.pointCount-1) && (i < MAX_TOUCH_POINTS); i++)\n        {\n            CORE.Input.Touch.pointId[i] = CORE.Input.Touch.pointId[i+1];\n            CORE.Input.Touch.position[i] = CORE.Input.Touch.position[i+1];\n        }\n        CORE.Input.Touch.pointCount--;\n    }\n\n    // When all touchpoints are tapped and released really quickly, this event is generated\n    if (flags == AMOTION_EVENT_ACTION_CANCEL) CORE.Input.Touch.pointCount = 0;\n\n    if (CORE.Input.Touch.pointCount > 0) CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 1;\n    else CORE.Input.Touch.currentTouchState[MOUSE_BUTTON_LEFT] = 0;\n\n    return 0;\n}\n#endif\n\n#if defined(PLATFORM_WEB)\n// Register fullscreen change events\nstatic EM_BOOL EmscriptenFullscreenChangeCallback(int eventType, const EmscriptenFullscreenChangeEvent *event, void *userData)\n{\n    // TODO: Implement EmscriptenFullscreenChangeCallback()?\n\n    return 1;   // The event was consumed by the callback handler\n}\n\n// Register window resize event\nstatic EM_BOOL EmscriptenWindowResizedCallback(int eventType, const EmscriptenUiEvent *event, void *userData)\n{\n    // TODO: Implement EmscriptenWindowResizedCallback()?\n\n    return 1;   // The event was consumed by the callback handler\n}\n\nEM_JS(int, GetCanvasWidth, (), { return canvas.clientWidth; });\nEM_JS(int, GetCanvasHeight, (), { return canvas.clientHeight; });\n\n// Register DOM element resize event\nstatic EM_BOOL EmscriptenResizeCallback(int eventType, const EmscriptenUiEvent *event, void *userData)\n{\n    // Don't resize non-resizeable windows\n    if ((CORE.Window.flags & FLAG_WINDOW_RESIZABLE) == 0) return 1;\n\n    // This event is called whenever the window changes sizes,\n    // so the size of the canvas object is explicitly retrieved below\n    int width = GetCanvasWidth();\n    int height = GetCanvasHeight();\n    emscripten_set_canvas_element_size(\"#canvas\",width,height);\n\n    SetupViewport(width, height);    // Reset viewport and projection matrix for new size\n\n    CORE.Window.currentFbo.width = width;\n    CORE.Window.currentFbo.height = height;\n    CORE.Window.resizedLastFrame = true;\n\n    if (IsWindowFullscreen()) return 1;\n\n    // Set current screen size\n    CORE.Window.screen.width = width;\n    CORE.Window.screen.height = height;\n\n    // NOTE: Postprocessing texture is not scaled to new size\n\n    return 0;\n}\n\n// Register mouse input events\nstatic EM_BOOL EmscriptenMouseCallback(int eventType, const EmscriptenMouseEvent *mouseEvent, void *userData)\n{\n    // This is only for registering mouse click events with emscripten and doesn't need to do anything\n\n    return 1;   // The event was consumed by the callback handler\n}\n\n// Register connected/disconnected gamepads events\nstatic EM_BOOL EmscriptenGamepadCallback(int eventType, const EmscriptenGamepadEvent *gamepadEvent, void *userData)\n{\n    /*\n    TRACELOGD(\"%s: timeStamp: %g, connected: %d, index: %ld, numAxes: %d, numButtons: %d, id: \\\"%s\\\", mapping: \\\"%s\\\"\",\n           eventType != 0? emscripten_event_type_to_string(eventType) : \"Gamepad state\",\n           gamepadEvent->timestamp, gamepadEvent->connected, gamepadEvent->index, gamepadEvent->numAxes, gamepadEvent->numButtons, gamepadEvent->id, gamepadEvent->mapping);\n\n    for (int i = 0; i < gamepadEvent->numAxes; ++i) TRACELOGD(\"Axis %d: %g\", i, gamepadEvent->axis[i]);\n    for (int i = 0; i < gamepadEvent->numButtons; ++i) TRACELOGD(\"Button %d: Digital: %d, Analog: %g\", i, gamepadEvent->digitalButton[i], gamepadEvent->analogButton[i]);\n    */\n\n    if ((gamepadEvent->connected) && (gamepadEvent->index < MAX_GAMEPADS))\n    {\n        CORE.Input.Gamepad.ready[gamepadEvent->index] = true;\n        sprintf(CORE.Input.Gamepad.name[gamepadEvent->index],\"%s\",gamepadEvent->id);\n    }\n    else CORE.Input.Gamepad.ready[gamepadEvent->index] = false;\n\n    return 1;   // The event was consumed by the callback handler\n}\n\n// Register touch input events\nstatic EM_BOOL EmscriptenTouchCallback(int eventType, const EmscriptenTouchEvent *touchEvent, void *userData)\n{\n    // Register touch points count\n    CORE.Input.Touch.pointCount = touchEvent->numTouches;\n\n    double canvasWidth = 0.0;\n    double canvasHeight = 0.0;\n    // NOTE: emscripten_get_canvas_element_size() returns canvas.width and canvas.height but\n    // we are looking for actual CSS size: canvas.style.width and canvas.style.height\n    //EMSCRIPTEN_RESULT res = emscripten_get_canvas_element_size(\"#canvas\", &canvasWidth, &canvasHeight);\n    emscripten_get_element_css_size(\"#canvas\", &canvasWidth, &canvasHeight);\n\n    for (int i = 0; (i < CORE.Input.Touch.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        // Register touch points id\n        CORE.Input.Touch.pointId[i] = touchEvent->touches[i].identifier;\n\n        // Register touch points position\n        CORE.Input.Touch.position[i] = (Vector2){ touchEvent->touches[i].targetX, touchEvent->touches[i].targetY };\n\n        // Normalize gestureEvent.position[x] for CORE.Window.screen.width and CORE.Window.screen.height\n        CORE.Input.Touch.position[i].x *= ((float)GetScreenWidth()/(float)canvasWidth);\n        CORE.Input.Touch.position[i].y *= ((float)GetScreenHeight()/(float)canvasHeight);\n\n        if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) CORE.Input.Touch.currentTouchState[i] = 1;\n        else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) CORE.Input.Touch.currentTouchState[i] = 0;\n    }\n\n#if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_WEB\n    GestureEvent gestureEvent = { 0 };\n\n    gestureEvent.pointCount = CORE.Input.Touch.pointCount;\n\n    // Register touch actions\n    if (eventType == EMSCRIPTEN_EVENT_TOUCHSTART) gestureEvent.touchAction = TOUCH_ACTION_DOWN;\n    else if (eventType == EMSCRIPTEN_EVENT_TOUCHEND) gestureEvent.touchAction = TOUCH_ACTION_UP;\n    else if (eventType == EMSCRIPTEN_EVENT_TOUCHMOVE) gestureEvent.touchAction = TOUCH_ACTION_MOVE;\n    else if (eventType == EMSCRIPTEN_EVENT_TOUCHCANCEL) gestureEvent.touchAction = TOUCH_ACTION_CANCEL;\n\n    for (int i = 0; (i < gestureEvent.pointCount) && (i < MAX_TOUCH_POINTS); i++)\n    {\n        gestureEvent.pointId[i] = CORE.Input.Touch.pointId[i];\n        gestureEvent.position[i] = CORE.Input.Touch.position[i];\n    }\n\n    // Gesture data is sent to gestures system for processing\n    ProcessGestureEvent(gestureEvent);\n#endif\n\n    return 1;   // The event was consumed by the callback handler\n}\n#endif\n\n#if defined(PLATFORM_RPI) || defined(PLATFORM_DRM)\n// Initialize Keyboard system (using standard input)\nstatic void InitKeyboard(void)\n{\n    // NOTE: We read directly from Standard Input (stdin) - STDIN_FILENO file descriptor,\n    // Reading directly from stdin will give chars already key-mapped by kernel to ASCII or UNICODE\n\n    // Save terminal keyboard settings\n    tcgetattr(STDIN_FILENO, &CORE.Input.Keyboard.defaultSettings);\n\n    // Reconfigure terminal with new settings\n    struct termios keyboardNewSettings = { 0 };\n    keyboardNewSettings = CORE.Input.Keyboard.defaultSettings;\n\n    // New terminal settings for keyboard: turn off buffering (non-canonical mode), echo and key processing\n    // NOTE: ISIG controls if ^C and ^Z generate break signals or not\n    keyboardNewSettings.c_lflag &= ~(ICANON | ECHO | ISIG);\n    //keyboardNewSettings.c_iflag &= ~(ISTRIP | INLCR | ICRNL | IGNCR | IXON | IXOFF);\n    keyboardNewSettings.c_cc[VMIN] = 1;\n    keyboardNewSettings.c_cc[VTIME] = 0;\n\n    // Set new keyboard settings (change occurs immediately)\n    tcsetattr(STDIN_FILENO, TCSANOW, &keyboardNewSettings);\n\n    // Save old keyboard mode to restore it at the end\n    CORE.Input.Keyboard.defaultFileFlags = fcntl(STDIN_FILENO, F_GETFL, 0);          // F_GETFL: Get the file access mode and the file status flags\n    fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags | O_NONBLOCK); // F_SETFL: Set the file status flags to the value specified\n\n    // NOTE: If ioctl() returns -1, it means the call failed for some reason (error code set in errno)\n    int result = ioctl(STDIN_FILENO, KDGKBMODE, &CORE.Input.Keyboard.defaultMode);\n\n    // In case of failure, it could mean a remote keyboard is used (SSH)\n    if (result < 0) TRACELOG(LOG_WARNING, \"RPI: Failed to change keyboard mode, an SSH keyboard is probably used\");\n    else\n    {\n        // Reconfigure keyboard mode to get:\n        //    - scancodes (K_RAW)\n        //    - keycodes (K_MEDIUMRAW)\n        //    - ASCII chars (K_XLATE)\n        //    - UNICODE chars (K_UNICODE)\n        ioctl(STDIN_FILENO, KDSKBMODE, K_XLATE);  // ASCII chars\n    }\n\n    // Register keyboard restore when program finishes\n    atexit(RestoreKeyboard);\n}\n\n// Restore default keyboard input\nstatic void RestoreKeyboard(void)\n{\n    // Reset to default keyboard settings\n    tcsetattr(STDIN_FILENO, TCSANOW, &CORE.Input.Keyboard.defaultSettings);\n\n    // Reconfigure keyboard to default mode\n    fcntl(STDIN_FILENO, F_SETFL, CORE.Input.Keyboard.defaultFileFlags);\n    ioctl(STDIN_FILENO, KDSKBMODE, CORE.Input.Keyboard.defaultMode);\n}\n\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\n// Process keyboard inputs\nstatic void ProcessKeyboard(void)\n{\n    #define MAX_KEYBUFFER_SIZE      32      // Max size in bytes to read\n\n    // Keyboard input polling (fill keys[256] array with status)\n    int bufferByteCount = 0;                        // Bytes available on the buffer\n    char keysBuffer[MAX_KEYBUFFER_SIZE] = { 0 };    // Max keys to be read at a time\n\n    // Read availables keycodes from stdin\n    bufferByteCount = read(STDIN_FILENO, keysBuffer, MAX_KEYBUFFER_SIZE);     // POSIX system call\n\n    // Reset pressed keys array (it will be filled below)\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.currentKeyState[i] = 0;\n\n    // Fill all read bytes (looking for keys)\n    for (int i = 0; i < bufferByteCount; i++)\n    {\n        // NOTE: If (key == 0x1b), depending on next key, it could be a special keymap code!\n        // Up -> 1b 5b 41 / Left -> 1b 5b 44 / Right -> 1b 5b 43 / Down -> 1b 5b 42\n        if (keysBuffer[i] == 0x1b)\n        {\n            // Check if ESCAPE key has been pressed to stop program\n            if (bufferByteCount == 1) CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] = 1;\n            else\n            {\n                if (keysBuffer[i + 1] == 0x5b)    // Special function key\n                {\n                    if ((keysBuffer[i + 2] == 0x5b) || (keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32))\n                    {\n                        // Process special function keys (F1 - F12)\n                        switch (keysBuffer[i + 3])\n                        {\n                            case 0x41: CORE.Input.Keyboard.currentKeyState[290] = 1; break;    // raylib KEY_F1\n                            case 0x42: CORE.Input.Keyboard.currentKeyState[291] = 1; break;    // raylib KEY_F2\n                            case 0x43: CORE.Input.Keyboard.currentKeyState[292] = 1; break;    // raylib KEY_F3\n                            case 0x44: CORE.Input.Keyboard.currentKeyState[293] = 1; break;    // raylib KEY_F4\n                            case 0x45: CORE.Input.Keyboard.currentKeyState[294] = 1; break;    // raylib KEY_F5\n                            case 0x37: CORE.Input.Keyboard.currentKeyState[295] = 1; break;    // raylib KEY_F6\n                            case 0x38: CORE.Input.Keyboard.currentKeyState[296] = 1; break;    // raylib KEY_F7\n                            case 0x39: CORE.Input.Keyboard.currentKeyState[297] = 1; break;    // raylib KEY_F8\n                            case 0x30: CORE.Input.Keyboard.currentKeyState[298] = 1; break;    // raylib KEY_F9\n                            case 0x31: CORE.Input.Keyboard.currentKeyState[299] = 1; break;    // raylib KEY_F10\n                            case 0x33: CORE.Input.Keyboard.currentKeyState[300] = 1; break;    // raylib KEY_F11\n                            case 0x34: CORE.Input.Keyboard.currentKeyState[301] = 1; break;    // raylib KEY_F12\n                            default: break;\n                        }\n\n                        if (keysBuffer[i + 2] == 0x5b) i += 4;\n                        else if ((keysBuffer[i + 2] == 0x31) || (keysBuffer[i + 2] == 0x32)) i += 5;\n                    }\n                    else\n                    {\n                        switch (keysBuffer[i + 2])\n                        {\n                            case 0x41: CORE.Input.Keyboard.currentKeyState[265] = 1; break;    // raylib KEY_UP\n                            case 0x42: CORE.Input.Keyboard.currentKeyState[264] = 1; break;    // raylib KEY_DOWN\n                            case 0x43: CORE.Input.Keyboard.currentKeyState[262] = 1; break;    // raylib KEY_RIGHT\n                            case 0x44: CORE.Input.Keyboard.currentKeyState[263] = 1; break;    // raylib KEY_LEFT\n                            default: break;\n                        }\n\n                        i += 3;  // Jump to next key\n                    }\n\n                    // NOTE: Some keys are not directly keymapped (CTRL, ALT, SHIFT)\n                }\n            }\n        }\n        else if (keysBuffer[i] == 0x0a)     // raylib KEY_ENTER (don't mix with <linux/input.h> KEY_*)\n        {\n            CORE.Input.Keyboard.currentKeyState[257] = 1;\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n        else if (keysBuffer[i] == 0x7f)     // raylib KEY_BACKSPACE\n        {\n            CORE.Input.Keyboard.currentKeyState[259] = 1;\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = 257;     // Add keys pressed into queue\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n        else\n        {\n            // Translate lowercase a-z letters to A-Z\n            if ((keysBuffer[i] >= 97) && (keysBuffer[i] <= 122))\n            {\n                CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i] - 32] = 1;\n            }\n            else CORE.Input.Keyboard.currentKeyState[(int)keysBuffer[i]] = 1;\n\n            CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keysBuffer[i];     // Add keys pressed into queue\n            CORE.Input.Keyboard.keyPressedQueueCount++;\n        }\n    }\n\n    // Check exit key (same functionality as GLFW3 KeyCallback())\n    if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;\n\n#if defined(SUPPORT_SCREEN_CAPTURE)\n    // Check screen capture key (raylib key: KEY_F12)\n    if (CORE.Input.Keyboard.currentKeyState[301] == 1)\n    {\n        TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n        screenshotCounter++;\n    }\n#endif\n}\n#endif  // SUPPORT_SSH_KEYBOARD_RPI\n\n// Initialise user input from evdev(/dev/input/event<N>) this means mouse, keyboard or gamepad devices\nstatic void InitEvdevInput(void)\n{\n    char path[MAX_FILEPATH_LENGTH] = { 0 };\n    DIR *directory = NULL;\n    struct dirent *entity = NULL;\n\n    // Initialise keyboard file descriptor\n    CORE.Input.Keyboard.fd = -1;\n\n    // Reset variables\n    for (int i = 0; i < MAX_TOUCH_POINTS; ++i)\n    {\n        CORE.Input.Touch.position[i].x = -1;\n        CORE.Input.Touch.position[i].y = -1;\n    }\n\n    // Reset keyboard key state\n    for (int i = 0; i < MAX_KEYBOARD_KEYS; i++) CORE.Input.Keyboard.currentKeyState[i] = 0;\n\n    // Open the linux directory of \"/dev/input\"\n    directory = opendir(DEFAULT_EVDEV_PATH);\n\n    if (directory)\n    {\n        while ((entity = readdir(directory)) != NULL)\n        {\n            if ((strncmp(\"event\", entity->d_name, strlen(\"event\")) == 0) ||     // Search for devices named \"event*\"\n                (strncmp(\"mouse\", entity->d_name, strlen(\"mouse\")) == 0))       // Search for devices named \"mouse*\"\n            {\n                sprintf(path, \"%s%s\", DEFAULT_EVDEV_PATH, entity->d_name);\n                ConfigureEvdevDevice(path);                                     // Configure the device if appropriate\n            }\n        }\n\n        closedir(directory);\n    }\n    else TRACELOG(LOG_WARNING, \"RPI: Failed to open linux event directory: %s\", DEFAULT_EVDEV_PATH);\n}\n\n// Identifies a input device and configures it for use if appropriate\nstatic void ConfigureEvdevDevice(char *device)\n{\n    #define BITS_PER_LONG   (8*sizeof(long))\n    #define NBITS(x)        ((((x) - 1)/BITS_PER_LONG) + 1)\n    #define OFF(x)          ((x)%BITS_PER_LONG)\n    #define BIT(x)          (1UL<<OFF(x))\n    #define LONG(x)         ((x)/BITS_PER_LONG)\n    #define TEST_BIT(array, bit) ((array[LONG(bit)] >> OFF(bit)) & 1)\n\n    struct input_absinfo absinfo = { 0 };\n    unsigned long evBits[NBITS(EV_MAX)] = { 0 };\n    unsigned long absBits[NBITS(ABS_MAX)] = { 0 };\n    unsigned long relBits[NBITS(REL_MAX)] = { 0 };\n    unsigned long keyBits[NBITS(KEY_MAX)] = { 0 };\n    bool hasAbs = false;\n    bool hasRel = false;\n    bool hasAbsMulti = false;\n    int freeWorkerId = -1;\n    int fd = -1;\n\n    InputEventWorker *worker = NULL;\n\n    // Open the device and allocate worker\n    //-------------------------------------------------------------------------------------------------------\n    // Find a free spot in the workers array\n    for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n    {\n        if (CORE.Input.eventWorker[i].threadId == 0)\n        {\n            freeWorkerId = i;\n            break;\n        }\n    }\n\n    // Select the free worker from array\n    if (freeWorkerId >= 0)\n    {\n        worker = &(CORE.Input.eventWorker[freeWorkerId]);       // Grab a pointer to the worker\n        memset(worker, 0, sizeof(InputEventWorker));  // Clear the worker\n    }\n    else\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread for %s, out of worker slots\", device);\n        return;\n    }\n\n    // Open the device\n    fd = open(device, O_RDONLY | O_NONBLOCK);\n    if (fd < 0)\n    {\n        TRACELOG(LOG_WARNING, \"RPI: Failed to open input device: %s\", device);\n        return;\n    }\n    worker->fd = fd;\n\n    // Grab number on the end of the devices name \"event<N>\"\n    int devNum = 0;\n    char *ptrDevName = strrchr(device, 't');\n    worker->eventNum = -1;\n\n    if (ptrDevName != NULL)\n    {\n        if (sscanf(ptrDevName, \"t%d\", &devNum) == 1) worker->eventNum = devNum;\n    }\n    else worker->eventNum = 0;      // TODO: HACK: Grab number for mouse0 device!\n\n    // At this point we have a connection to the device, but we don't yet know what the device is.\n    // It could be many things, even as simple as a power button...\n    //-------------------------------------------------------------------------------------------------------\n\n    // Identify the device\n    //-------------------------------------------------------------------------------------------------------\n    ioctl(fd, EVIOCGBIT(0, sizeof(evBits)), evBits);    // Read a bitfield of the available device properties\n\n    // Check for absolute input devices\n    if (TEST_BIT(evBits, EV_ABS))\n    {\n        ioctl(fd, EVIOCGBIT(EV_ABS, sizeof(absBits)), absBits);\n\n        // Check for absolute movement support (usualy touchscreens, but also joysticks)\n        if (TEST_BIT(absBits, ABS_X) && TEST_BIT(absBits, ABS_Y))\n        {\n            hasAbs = true;\n\n            // Get the scaling values\n            ioctl(fd, EVIOCGABS(ABS_X), &absinfo);\n            worker->absRange.x = absinfo.minimum;\n            worker->absRange.width = absinfo.maximum - absinfo.minimum;\n            ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);\n            worker->absRange.y = absinfo.minimum;\n            worker->absRange.height = absinfo.maximum - absinfo.minimum;\n        }\n\n        // Check for multiple absolute movement support (usualy multitouch touchscreens)\n        if (TEST_BIT(absBits, ABS_MT_POSITION_X) && TEST_BIT(absBits, ABS_MT_POSITION_Y))\n        {\n            hasAbsMulti = true;\n\n            // Get the scaling values\n            ioctl(fd, EVIOCGABS(ABS_X), &absinfo);\n            worker->absRange.x = absinfo.minimum;\n            worker->absRange.width = absinfo.maximum - absinfo.minimum;\n            ioctl(fd, EVIOCGABS(ABS_Y), &absinfo);\n            worker->absRange.y = absinfo.minimum;\n            worker->absRange.height = absinfo.maximum - absinfo.minimum;\n        }\n    }\n\n    // Check for relative movement support (usualy mouse)\n    if (TEST_BIT(evBits, EV_REL))\n    {\n        ioctl(fd, EVIOCGBIT(EV_REL, sizeof(relBits)), relBits);\n\n        if (TEST_BIT(relBits, REL_X) && TEST_BIT(relBits, REL_Y)) hasRel = true;\n    }\n\n    // Check for button support to determine the device type(usualy on all input devices)\n    if (TEST_BIT(evBits, EV_KEY))\n    {\n        ioctl(fd, EVIOCGBIT(EV_KEY, sizeof(keyBits)), keyBits);\n\n        if (hasAbs || hasAbsMulti)\n        {\n            if (TEST_BIT(keyBits, BTN_TOUCH)) worker->isTouch = true;          // This is a touchscreen\n            if (TEST_BIT(keyBits, BTN_TOOL_FINGER)) worker->isTouch = true;    // This is a drawing tablet\n            if (TEST_BIT(keyBits, BTN_TOOL_PEN)) worker->isTouch = true;       // This is a drawing tablet\n            if (TEST_BIT(keyBits, BTN_STYLUS)) worker->isTouch = true;         // This is a drawing tablet\n            if (worker->isTouch || hasAbsMulti) worker->isMultitouch = true;   // This is a multitouch capable device\n        }\n\n        if (hasRel)\n        {\n            if (TEST_BIT(keyBits, BTN_LEFT)) worker->isMouse = true;           // This is a mouse\n            if (TEST_BIT(keyBits, BTN_RIGHT)) worker->isMouse = true;          // This is a mouse\n        }\n\n        if (TEST_BIT(keyBits, BTN_A)) worker->isGamepad = true;                // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_TRIGGER)) worker->isGamepad = true;          // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_START)) worker->isGamepad = true;            // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad\n        if (TEST_BIT(keyBits, BTN_TL)) worker->isGamepad = true;               // This is a gamepad\n\n        if (TEST_BIT(keyBits, KEY_SPACE)) worker->isKeyboard = true;           // This is a keyboard\n    }\n    //-------------------------------------------------------------------------------------------------------\n\n    // Decide what to do with the device\n    //-------------------------------------------------------------------------------------------------------\n    if (worker->isKeyboard && (CORE.Input.Keyboard.fd == -1))\n    {\n        // Use the first keyboard encountered. This assumes that a device that says it's a keyboard is just a\n        // keyboard. The keyboard is polled synchronously, whereas other input devices are polled in separate\n        // threads so that they don't drop events when the frame rate is slow.\n        TRACELOG(LOG_INFO, \"RPI: Opening keyboard device: %s\", device);\n        CORE.Input.Keyboard.fd = worker->fd;\n    }\n    else if (worker->isTouch || worker->isMouse)\n    {\n        // Looks like an interesting device\n        TRACELOG(LOG_INFO, \"RPI: Opening input device: %s (%s%s%s%s)\", device,\n            worker->isMouse? \"mouse \" : \"\",\n            worker->isMultitouch? \"multitouch \" : \"\",\n            worker->isTouch? \"touchscreen \" : \"\",\n            worker->isGamepad? \"gamepad \" : \"\");\n\n        // Create a thread for this device\n        int error = pthread_create(&worker->threadId, NULL, &EventThread, (void *)worker);\n        if (error != 0)\n        {\n            TRACELOG(LOG_WARNING, \"RPI: Failed to create input device thread: %s (error: %d)\", device, error);\n            worker->threadId = 0;\n            close(fd);\n        }\n\n#if defined(USE_LAST_TOUCH_DEVICE)\n        // Find touchscreen with the highest index\n        int maxTouchNumber = -1;\n\n        for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n        {\n            if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum > maxTouchNumber)) maxTouchNumber = CORE.Input.eventWorker[i].eventNum;\n        }\n\n        // Find touchscreens with lower indexes\n        for (int i = 0; i < sizeof(CORE.Input.eventWorker)/sizeof(InputEventWorker); ++i)\n        {\n            if (CORE.Input.eventWorker[i].isTouch && (CORE.Input.eventWorker[i].eventNum < maxTouchNumber))\n            {\n                if (CORE.Input.eventWorker[i].threadId != 0)\n                {\n                    TRACELOG(LOG_WARNING, \"RPI: Found duplicate touchscreen, killing touchscreen on event: %d\", i);\n                    pthread_cancel(CORE.Input.eventWorker[i].threadId);\n                    close(CORE.Input.eventWorker[i].fd);\n                }\n            }\n        }\n#endif\n    }\n    else close(fd);  // We are not interested in this device\n    //-------------------------------------------------------------------------------------------------------\n}\n\nstatic void PollKeyboardEvents(void)\n{\n    // Scancode to keycode mapping for US keyboards\n    // TODO: Replace this with a keymap from the X11 to get the correct regional map for the keyboard:\n    // Currently non US keyboards will have the wrong mapping for some keys\n    static const int keymapUS[] = {\n        0, 256, 49, 50, 51, 52, 53, 54, 55, 56, 57, 48, 45, 61, 259, 258, 81, 87, 69, 82, 84,\n        89, 85, 73, 79, 80, 91, 93, 257, 341, 65, 83, 68, 70, 71, 72, 74, 75, 76, 59, 39, 96,\n        340, 92, 90, 88, 67, 86, 66, 78, 77, 44, 46, 47, 344, 332, 342, 32, 280, 290, 291,\n        292, 293, 294, 295, 296, 297, 298, 299, 282, 281, 327, 328, 329, 333, 324, 325,\n        326, 334, 321, 322, 323, 320, 330, 0, 85, 86, 300, 301, 89, 90, 91, 92, 93, 94, 95,\n        335, 345, 331, 283, 346, 101, 268, 265, 266, 263, 262, 269, 264, 267, 260, 261,\n        112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 347, 127,\n        128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,\n        144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n        160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,\n        176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,\n        192, 193, 194, 0, 0, 0, 0, 0, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210,\n        211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226,\n        227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242,\n        243, 244, 245, 246, 247, 248, 0, 0, 0, 0, 0, 0, 0\n    };\n\n    int fd = CORE.Input.Keyboard.fd;\n    if (fd == -1) return;\n\n    struct input_event event = { 0 };\n    int keycode = -1;\n\n    // Try to read data from the keyboard and only continue if successful\n    while (read(fd, &event, sizeof(event)) == (int)sizeof(event))\n    {\n        // Button parsing\n        if (event.type == EV_KEY)\n        {\n#if defined(SUPPORT_SSH_KEYBOARD_RPI)\n            // Change keyboard mode to events\n            CORE.Input.Keyboard.evtMode = true;\n#endif\n            // Keyboard button parsing\n            if ((event.code >= 1) && (event.code <= 255))     //Keyboard keys appear for codes 1 to 255\n            {\n                keycode = keymapUS[event.code & 0xFF];     // The code we get is a scancode so we look up the apropriate keycode\n\n                // Make sure we got a valid keycode\n                if ((keycode > 0) && (keycode < sizeof(CORE.Input.Keyboard.currentKeyState)))\n                {\n                    // WARNING: https://www.kernel.org/doc/Documentation/input/input.txt\n                    // Event interface: 'value' is the value the event carries. Either a relative change for EV_REL,\n                    // absolute new value for EV_ABS (joysticks ...), or 0 for EV_KEY for release, 1 for keypress and 2 for autorepeat\n                    CORE.Input.Keyboard.currentKeyState[keycode] = (event.value >= 1)? 1 : 0;\n                    if (event.value >= 1)\n                    {\n                        CORE.Input.Keyboard.keyPressedQueue[CORE.Input.Keyboard.keyPressedQueueCount] = keycode;     // Register last key pressed\n                        CORE.Input.Keyboard.keyPressedQueueCount++;\n                    }\n\n                #if defined(SUPPORT_SCREEN_CAPTURE)\n                    // Check screen capture key (raylib key: KEY_F12)\n                    if (CORE.Input.Keyboard.currentKeyState[301] == 1)\n                    {\n                        TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n                        screenshotCounter++;\n                    }\n                #endif\n\n                    if (CORE.Input.Keyboard.currentKeyState[CORE.Input.Keyboard.exitKey] == 1) CORE.Window.shouldClose = true;\n\n                    TRACELOGD(\"RPI: KEY_%s ScanCode: %4i KeyCode: %4i\", event.value == 0 ? \"UP\":\"DOWN\", event.code, keycode);\n                }\n            }\n        }\n    }\n}\n\n// Input device events reading thread\nstatic void *EventThread(void *arg)\n{\n    struct input_event event = { 0 };\n    InputEventWorker *worker = (InputEventWorker *)arg;\n\n    int touchAction = -1;           // 0-TOUCH_ACTION_UP, 1-TOUCH_ACTION_DOWN, 2-TOUCH_ACTION_MOVE\n    bool gestureUpdate = false;     // Flag to note gestures require to update\n\n    while (!CORE.Window.shouldClose)\n    {\n        // Try to read data from the device and only continue if successful\n        while (read(worker->fd, &event, sizeof(event)) == (int)sizeof(event))\n        {\n            // Relative movement parsing\n            if (event.type == EV_REL)\n            {\n                if (event.code == REL_X)\n                {\n                    CORE.Input.Mouse.currentPosition.x += event.value;\n                    CORE.Input.Touch.position[0].x = CORE.Input.Mouse.currentPosition.x;\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                if (event.code == REL_Y)\n                {\n                    CORE.Input.Mouse.currentPosition.y += event.value;\n                    CORE.Input.Touch.position[0].y = CORE.Input.Mouse.currentPosition.y;\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                if (event.code == REL_WHEEL) CORE.Input.Mouse.currentWheelMove.y += event.value;\n            }\n\n            // Absolute movement parsing\n            if (event.type == EV_ABS)\n            {\n                // Basic movement\n                if (event.code == ABS_X)\n                {\n                    CORE.Input.Mouse.currentPosition.x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale acording to absRange\n                    CORE.Input.Touch.position[0].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;        // Scale acording to absRange\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                if (event.code == ABS_Y)\n                {\n                    CORE.Input.Mouse.currentPosition.y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale acording to absRange\n                    CORE.Input.Touch.position[0].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;      // Scale acording to absRange\n\n                    touchAction = 2;    // TOUCH_ACTION_MOVE\n                    gestureUpdate = true;\n                }\n\n                // Multitouch movement\n                if (event.code == ABS_MT_SLOT) worker->touchSlot = event.value;   // Remember the slot number for the folowing events\n\n                if (event.code == ABS_MT_POSITION_X)\n                {\n                    if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].x = (event.value - worker->absRange.x)*CORE.Window.screen.width/worker->absRange.width;    // Scale acording to absRange\n                }\n\n                if (event.code == ABS_MT_POSITION_Y)\n                {\n                    if (worker->touchSlot < MAX_TOUCH_POINTS) CORE.Input.Touch.position[worker->touchSlot].y = (event.value - worker->absRange.y)*CORE.Window.screen.height/worker->absRange.height;  // Scale acording to absRange\n                }\n\n                if (event.code == ABS_MT_TRACKING_ID)\n                {\n                    if ((event.value < 0) && (worker->touchSlot < MAX_TOUCH_POINTS))\n                    {\n                        // Touch has ended for this point\n                        CORE.Input.Touch.position[worker->touchSlot].x = -1;\n                        CORE.Input.Touch.position[worker->touchSlot].y = -1;\n                    }\n                }\n\n                // Touchscreen tap\n                if (event.code == ABS_PRESSURE)\n                {\n                    int previousMouseLeftButtonState = CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT];\n\n                    if (!event.value && previousMouseLeftButtonState)\n                    {\n                        CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 0;\n\n                        touchAction = 0;    // TOUCH_ACTION_UP\n                        gestureUpdate = true;\n                    }\n\n                    if (event.value && !previousMouseLeftButtonState)\n                    {\n                        CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = 1;\n\n                        touchAction = 1;    // TOUCH_ACTION_DOWN\n                        gestureUpdate = true;\n                    }\n                }\n\n            }\n\n            // Button parsing\n            if (event.type == EV_KEY)\n            {\n                // Mouse button parsing\n                if ((event.code == BTN_TOUCH) || (event.code == BTN_LEFT))\n                {\n                    CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_LEFT] = event.value;\n\n                    if (event.value > 0) touchAction = 1;   // TOUCH_ACTION_DOWN\n                    else touchAction = 0;       // TOUCH_ACTION_UP\n                    gestureUpdate = true;\n                }\n\n                if (event.code == BTN_RIGHT) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_RIGHT] = event.value;\n                if (event.code == BTN_MIDDLE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_MIDDLE] = event.value;\n                if (event.code == BTN_SIDE) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_SIDE] = event.value;\n                if (event.code == BTN_EXTRA) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_EXTRA] = event.value;\n                if (event.code == BTN_FORWARD) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_FORWARD] = event.value;\n                if (event.code == BTN_BACK) CORE.Input.Mouse.currentButtonStateEvdev[MOUSE_BUTTON_BACK] = event.value;\n            }\n\n            // Screen confinement\n            if (!CORE.Input.Mouse.cursorHidden)\n            {\n                if (CORE.Input.Mouse.currentPosition.x < 0) CORE.Input.Mouse.currentPosition.x = 0;\n                if (CORE.Input.Mouse.currentPosition.x > CORE.Window.screen.width/CORE.Input.Mouse.scale.x) CORE.Input.Mouse.currentPosition.x = CORE.Window.screen.width/CORE.Input.Mouse.scale.x;\n\n                if (CORE.Input.Mouse.currentPosition.y < 0) CORE.Input.Mouse.currentPosition.y = 0;\n                if (CORE.Input.Mouse.currentPosition.y > CORE.Window.screen.height/CORE.Input.Mouse.scale.y) CORE.Input.Mouse.currentPosition.y = CORE.Window.screen.height/CORE.Input.Mouse.scale.y;\n            }\n\n#if defined(SUPPORT_GESTURES_SYSTEM)        // PLATFORM_RPI, PLATFORM_DRM\n            if (gestureUpdate)\n            {\n                GestureEvent gestureEvent = { 0 };\n\n                gestureEvent.pointCount = 0;\n                gestureEvent.touchAction = touchAction;\n\n                if (CORE.Input.Touch.position[0].x >= 0) gestureEvent.pointCount++;\n                if (CORE.Input.Touch.position[1].x >= 0) gestureEvent.pointCount++;\n                if (CORE.Input.Touch.position[2].x >= 0) gestureEvent.pointCount++;\n                if (CORE.Input.Touch.position[3].x >= 0) gestureEvent.pointCount++;\n\n                gestureEvent.pointId[0] = 0;\n                gestureEvent.pointId[1] = 1;\n                gestureEvent.pointId[2] = 2;\n                gestureEvent.pointId[3] = 3;\n\n                gestureEvent.position[0] = CORE.Input.Touch.position[0];\n                gestureEvent.position[1] = CORE.Input.Touch.position[1];\n                gestureEvent.position[2] = CORE.Input.Touch.position[2];\n                gestureEvent.position[3] = CORE.Input.Touch.position[3];\n\n                ProcessGestureEvent(gestureEvent);\n            }\n#endif\n        }\n\n        WaitTime(0.005);    // Sleep for 5ms to avoid hogging CPU time\n    }\n\n    close(worker->fd);\n\n    return NULL;\n}\n\n// Initialize gamepad system\nstatic void InitGamepad(void)\n{\n    char gamepadDev[128] = { 0 };\n\n    for (int i = 0; i < MAX_GAMEPADS; i++)\n    {\n        sprintf(gamepadDev, \"%s%i\", DEFAULT_GAMEPAD_DEV, i);\n\n        if ((CORE.Input.Gamepad.streamId[i] = open(gamepadDev, O_RDONLY | O_NONBLOCK)) < 0)\n        {\n            // NOTE: Only show message for first gamepad\n            if (i == 0) TRACELOG(LOG_WARNING, \"RPI: Failed to open Gamepad device, no gamepad available\");\n        }\n        else\n        {\n            CORE.Input.Gamepad.ready[i] = true;\n\n            // NOTE: Only create one thread\n            if (i == 0)\n            {\n                int error = pthread_create(&CORE.Input.Gamepad.threadId, NULL, &GamepadThread, NULL);\n\n                if (error != 0) TRACELOG(LOG_WARNING, \"RPI: Failed to create gamepad input event thread\");\n                else  TRACELOG(LOG_INFO, \"RPI: Gamepad device initialized successfully\");\n            }\n        }\n    }\n}\n\n// Process Gamepad (/dev/input/js0)\nstatic void *GamepadThread(void *arg)\n{\n    #define JS_EVENT_BUTTON         0x01    // Button pressed/released\n    #define JS_EVENT_AXIS           0x02    // Joystick axis moved\n    #define JS_EVENT_INIT           0x80    // Initial state of device\n\n    struct js_event {\n        unsigned int time;      // event timestamp in milliseconds\n        short value;            // event value\n        unsigned char type;     // event type\n        unsigned char number;   // event axis/button number\n    };\n\n    // Read gamepad event\n    struct js_event gamepadEvent = { 0 };\n\n    while (!CORE.Window.shouldClose)\n    {\n        for (int i = 0; i < MAX_GAMEPADS; i++)\n        {\n            if (read(CORE.Input.Gamepad.streamId[i], &gamepadEvent, sizeof(struct js_event)) == (int)sizeof(struct js_event))\n            {\n                gamepadEvent.type &= ~JS_EVENT_INIT;     // Ignore synthetic events\n\n                // Process gamepad events by type\n                if (gamepadEvent.type == JS_EVENT_BUTTON)\n                {\n                    //TRACELOG(LOG_WARNING, \"RPI: Gamepad button: %i, value: %i\", gamepadEvent.number, gamepadEvent.value);\n\n                    if (gamepadEvent.number < MAX_GAMEPAD_BUTTONS)\n                    {\n                        // 1 - button pressed, 0 - button released\n                        CORE.Input.Gamepad.currentButtonState[i][gamepadEvent.number] = (int)gamepadEvent.value;\n\n                        if ((int)gamepadEvent.value == 1) CORE.Input.Gamepad.lastButtonPressed = gamepadEvent.number;\n                        else CORE.Input.Gamepad.lastButtonPressed = 0;       // GAMEPAD_BUTTON_UNKNOWN\n                    }\n                }\n                else if (gamepadEvent.type == JS_EVENT_AXIS)\n                {\n                    //TRACELOG(LOG_WARNING, \"RPI: Gamepad axis: %i, value: %i\", gamepadEvent.number, gamepadEvent.value);\n\n                    if (gamepadEvent.number < MAX_GAMEPAD_AXIS)\n                    {\n                        // NOTE: Scaling of gamepadEvent.value to get values between -1..1\n                        CORE.Input.Gamepad.axisState[i][gamepadEvent.number] = (float)gamepadEvent.value/32768;\n                    }\n                }\n            }\n            else WaitTime(0.001);    // Sleep for 1 ms to avoid hogging CPU time\n        }\n    }\n\n    return NULL;\n}\n#endif  // PLATFORM_RPI || PLATFORM_DRM\n\n#if defined(PLATFORM_DRM)\n// Search matching DRM mode in connector's mode list\nstatic int FindMatchingConnectorMode(const drmModeConnector *connector, const drmModeModeInfo *mode)\n{\n    if (NULL == connector) return -1;\n    if (NULL == mode) return -1;\n\n    // safe bitwise comparison of two modes\n    #define BINCMP(a, b) memcmp((a), (b), (sizeof(a) < sizeof(b)) ? sizeof(a) : sizeof(b))\n\n    for (size_t i = 0; i < connector->count_modes; i++)\n    {\n        TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, connector->modes[i].hdisplay, connector->modes[i].vdisplay,\n            connector->modes[i].vrefresh, (connector->modes[i].flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");\n\n        if (0 == BINCMP(&CORE.Window.crtc->mode, &CORE.Window.connector->modes[i])) return i;\n    }\n\n    return -1;\n\n    #undef BINCMP\n}\n\n// Search exactly matching DRM connector mode in connector's list\nstatic int FindExactConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)\n{\n    TRACELOG(LOG_TRACE, \"DISPLAY: Searching exact connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced ? \"yes\" : \"no\");\n\n    if (NULL == connector) return -1;\n\n    for (int i = 0; i < CORE.Window.connector->count_modes; i++)\n    {\n        const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];\n\n        TRACELOG(LOG_TRACE, \"DISPLAY: DRM Mode %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh, (mode->flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");\n\n        if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced)) continue;\n\n        if ((mode->hdisplay == width) && (mode->vdisplay == height) && (mode->vrefresh == fps)) return i;\n    }\n\n    TRACELOG(LOG_TRACE, \"DISPLAY: No DRM exact matching mode found\");\n    return -1;\n}\n\n// Search the nearest matching DRM connector mode in connector's list\nstatic int FindNearestConnectorMode(const drmModeConnector *connector, uint width, uint height, uint fps, bool allowInterlaced)\n{\n    TRACELOG(LOG_TRACE, \"DISPLAY: Searching nearest connector mode for %ux%u@%u, selecting an interlaced mode is allowed: %s\", width, height, fps, allowInterlaced ? \"yes\" : \"no\");\n\n    if (NULL == connector) return -1;\n\n    int nearestIndex = -1;\n    for (int i = 0; i < CORE.Window.connector->count_modes; i++)\n    {\n        const drmModeModeInfo *const mode = &CORE.Window.connector->modes[i];\n\n        TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode: %d %ux%u@%u %s\", i, mode->hdisplay, mode->vdisplay, mode->vrefresh,\n            (mode->flags & DRM_MODE_FLAG_INTERLACE) ? \"interlaced\" : \"progressive\");\n\n        if ((mode->hdisplay < width) || (mode->vdisplay < height))\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM mode is too small\");\n            continue;\n        }\n\n        if ((mode->flags & DRM_MODE_FLAG_INTERLACE) && (!allowInterlaced))\n        {\n            TRACELOG(LOG_TRACE, \"DISPLAY: DRM shouldn't choose an interlaced mode\");\n            continue;\n        }\n\n        if (nearestIndex < 0)\n        {\n            nearestIndex = i;\n            continue;\n        }\n\n        const int widthDiff = abs(mode->hdisplay - width);\n        const int heightDiff = abs(mode->vdisplay - height);\n        const int fpsDiff = abs(mode->vrefresh - fps);\n\n        const int nearestWidthDiff = abs(CORE.Window.connector->modes[nearestIndex].hdisplay - width);\n        const int nearestHeightDiff = abs(CORE.Window.connector->modes[nearestIndex].vdisplay - height);\n        const int nearestFpsDiff = abs(CORE.Window.connector->modes[nearestIndex].vrefresh - fps);\n\n        if ((widthDiff < nearestWidthDiff) || (heightDiff < nearestHeightDiff) || (fpsDiff < nearestFpsDiff)) {\n            nearestIndex = i;\n        }\n    }\n\n    return nearestIndex;\n}\n#endif\n\n#if defined(SUPPORT_EVENTS_AUTOMATION)\n// NOTE: Loading happens over AutomationEvent *events\n// TODO: This system should probably be redesigned\nstatic void LoadAutomationEvents(const char *fileName)\n{\n    //unsigned char fileId[4] = { 0 };\n\n    // Load binary\n    /*\n    FILE *repFile = fopen(fileName, \"rb\");\n    fread(fileId, 1, 4, repFile);\n\n    if ((fileId[0] == 'r') && (fileId[1] == 'E') && (fileId[2] == 'P') && (fileId[1] == ' '))\n    {\n        fread(&eventCount, sizeof(int), 1, repFile);\n        TRACELOG(LOG_WARNING, \"Events loaded: %i\\n\", eventCount);\n        fread(events, sizeof(AutomationEvent), eventCount, repFile);\n    }\n\n    fclose(repFile);\n    */\n\n    // Load events (text file)\n    FILE *repFile = fopen(fileName, \"rt\");\n\n    if (repFile != NULL)\n    {\n        unsigned int count = 0;\n        char buffer[256] = { 0 };\n\n        fgets(buffer, 256, repFile);\n\n        while (!feof(repFile))\n        {\n            if (buffer[0] == 'c') sscanf(buffer, \"c %i\", &eventCount);\n            else if (buffer[0] == 'e')\n            {\n                sscanf(buffer, \"e %d %d %d %d %d\", &events[count].frame, &events[count].type,\n                       &events[count].params[0], &events[count].params[1], &events[count].params[2]);\n\n                count++;\n            }\n\n            fgets(buffer, 256, repFile);\n        }\n\n        if (count != eventCount) TRACELOG(LOG_WARNING, \"Events count provided is different than count\");\n\n        fclose(repFile);\n    }\n\n    TRACELOG(LOG_WARNING, \"Events loaded: %i\", eventCount);\n}\n\n// Export recorded events into a file\nstatic void ExportAutomationEvents(const char *fileName)\n{\n    unsigned char fileId[4] = \"rEP \";\n\n    // Save as binary\n    /*\n    FILE *repFile = fopen(fileName, \"wb\");\n    fwrite(fileId, sizeof(unsigned char), 4, repFile);\n    fwrite(&eventCount, sizeof(int), 1, repFile);\n    fwrite(events, sizeof(AutomationEvent), eventCount, repFile);\n    fclose(repFile);\n    */\n\n    // Export events as text\n    FILE *repFile = fopen(fileName, \"wt\");\n\n    if (repFile != NULL)\n    {\n        fprintf(repFile, \"# Automation events list\\n\");\n        fprintf(repFile, \"#    c <events_count>\\n\");\n        fprintf(repFile, \"#    e <frame> <event_type> <param0> <param1> <param2> // <event_type_name>\\n\");\n\n        fprintf(repFile, \"c %i\\n\", eventCount);\n        for (int i = 0; i < eventCount; i++)\n        {\n            fprintf(repFile, \"e %i %i %i %i %i // %s\\n\", events[i].frame, events[i].type,\n                    events[i].params[0], events[i].params[1], events[i].params[2], autoEventTypeName[events[i].type]);\n        }\n\n        fclose(repFile);\n    }\n}\n\n// EndDrawing() -> After PollInputEvents()\n// Check event in current frame and save into the events[i] array\nstatic void RecordAutomationEvent(unsigned int frame)\n{\n    for (int key = 0; key < MAX_KEYBOARD_KEYS; key++)\n    {\n        // INPUT_KEY_UP (only saved once)\n        if (CORE.Input.Keyboard.previousKeyState[key] && !CORE.Input.Keyboard.currentKeyState[key])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_KEY_UP;\n            events[eventCount].params[0] = key;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_KEY_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_KEY_DOWN\n        if (CORE.Input.Keyboard.currentKeyState[key])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_KEY_DOWN;\n            events[eventCount].params[0] = key;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_KEY_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n    }\n\n    for (int button = 0; button < MAX_MOUSE_BUTTONS; button++)\n    {\n        // INPUT_MOUSE_BUTTON_UP\n        if (CORE.Input.Mouse.previousButtonState[button] && !CORE.Input.Mouse.currentButtonState[button])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_MOUSE_BUTTON_UP;\n            events[eventCount].params[0] = button;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_BUTTON_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_MOUSE_BUTTON_DOWN\n        if (CORE.Input.Mouse.currentButtonState[button])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_MOUSE_BUTTON_DOWN;\n            events[eventCount].params[0] = button;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_BUTTON_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n    }\n\n    // INPUT_MOUSE_POSITION (only saved if changed)\n    if (((int)CORE.Input.Mouse.currentPosition.x != (int)CORE.Input.Mouse.previousPosition.x) ||\n        ((int)CORE.Input.Mouse.currentPosition.y != (int)CORE.Input.Mouse.previousPosition.y))\n    {\n        events[eventCount].frame = frame;\n        events[eventCount].type = INPUT_MOUSE_POSITION;\n        events[eventCount].params[0] = (int)CORE.Input.Mouse.currentPosition.x;\n        events[eventCount].params[1] = (int)CORE.Input.Mouse.currentPosition.y;\n        events[eventCount].params[2] = 0;\n\n        TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_POSITION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n        eventCount++;\n    }\n\n    // INPUT_MOUSE_WHEEL_MOTION\n    if (((int)CORE.Input.Mouse.currentWheelMove.x != (int)CORE.Input.Mouse.previousWheelMove.x) ||\n        ((int)CORE.Input.Mouse.currentWheelMove.y != (int)CORE.Input.Mouse.previousWheelMove.y))\n    {\n        events[eventCount].frame = frame;\n        events[eventCount].type = INPUT_MOUSE_WHEEL_MOTION;\n        events[eventCount].params[0] = (int)CORE.Input.Mouse.currentWheelMove.x;\n        events[eventCount].params[1] = (int)CORE.Input.Mouse.currentWheelMove.y;;\n        events[eventCount].params[2] = 0;\n\n        TRACELOG(LOG_INFO, \"[%i] INPUT_MOUSE_WHEEL_MOTION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n        eventCount++;\n    }\n\n    for (int id = 0; id < MAX_TOUCH_POINTS; id++)\n    {\n        // INPUT_TOUCH_UP\n        if (CORE.Input.Touch.previousTouchState[id] && !CORE.Input.Touch.currentTouchState[id])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_TOUCH_UP;\n            events[eventCount].params[0] = id;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_TOUCH_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_TOUCH_DOWN\n        if (CORE.Input.Touch.currentTouchState[id])\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_TOUCH_DOWN;\n            events[eventCount].params[0] = id;\n            events[eventCount].params[1] = 0;\n            events[eventCount].params[2] = 0;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_TOUCH_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n\n        // INPUT_TOUCH_POSITION\n        // TODO: It requires the id!\n        /*\n        if (((int)CORE.Input.Touch.currentPosition[id].x != (int)CORE.Input.Touch.previousPosition[id].x) ||\n            ((int)CORE.Input.Touch.currentPosition[id].y != (int)CORE.Input.Touch.previousPosition[id].y))\n        {\n            events[eventCount].frame = frame;\n            events[eventCount].type = INPUT_TOUCH_POSITION;\n            events[eventCount].params[0] = id;\n            events[eventCount].params[1] = (int)CORE.Input.Touch.currentPosition[id].x;\n            events[eventCount].params[2] = (int)CORE.Input.Touch.currentPosition[id].y;\n\n            TRACELOG(LOG_INFO, \"[%i] INPUT_TOUCH_POSITION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n            eventCount++;\n        }\n        */\n    }\n\n    for (int gamepad = 0; gamepad < MAX_GAMEPADS; gamepad++)\n    {\n        // INPUT_GAMEPAD_CONNECT\n        /*\n        if ((CORE.Input.Gamepad.currentState[gamepad] != CORE.Input.Gamepad.previousState[gamepad]) &&\n            (CORE.Input.Gamepad.currentState[gamepad] == true)) // Check if changed to ready\n        {\n            // TODO: Save gamepad connect event\n        }\n        */\n\n        // INPUT_GAMEPAD_DISCONNECT\n        /*\n        if ((CORE.Input.Gamepad.currentState[gamepad] != CORE.Input.Gamepad.previousState[gamepad]) &&\n            (CORE.Input.Gamepad.currentState[gamepad] == false)) // Check if changed to not-ready\n        {\n            // TODO: Save gamepad disconnect event\n        }\n        */\n\n        for (int button = 0; button < MAX_GAMEPAD_BUTTONS; button++)\n        {\n            // INPUT_GAMEPAD_BUTTON_UP\n            if (CORE.Input.Gamepad.previousButtonState[gamepad][button] && !CORE.Input.Gamepad.currentButtonState[gamepad][button])\n            {\n                events[eventCount].frame = frame;\n                events[eventCount].type = INPUT_GAMEPAD_BUTTON_UP;\n                events[eventCount].params[0] = gamepad;\n                events[eventCount].params[1] = button;\n                events[eventCount].params[2] = 0;\n\n                TRACELOG(LOG_INFO, \"[%i] INPUT_GAMEPAD_BUTTON_UP: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n                eventCount++;\n            }\n\n            // INPUT_GAMEPAD_BUTTON_DOWN\n            if (CORE.Input.Gamepad.currentButtonState[gamepad][button])\n            {\n                events[eventCount].frame = frame;\n                events[eventCount].type = INPUT_GAMEPAD_BUTTON_DOWN;\n                events[eventCount].params[0] = gamepad;\n                events[eventCount].params[1] = button;\n                events[eventCount].params[2] = 0;\n\n                TRACELOG(LOG_INFO, \"[%i] INPUT_GAMEPAD_BUTTON_DOWN: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n                eventCount++;\n            }\n        }\n\n        for (int axis = 0; axis < MAX_GAMEPAD_AXIS; axis++)\n        {\n            // INPUT_GAMEPAD_AXIS_MOTION\n            if (CORE.Input.Gamepad.axisState[gamepad][axis] > 0.1f)\n            {\n                events[eventCount].frame = frame;\n                events[eventCount].type = INPUT_GAMEPAD_AXIS_MOTION;\n                events[eventCount].params[0] = gamepad;\n                events[eventCount].params[1] = axis;\n                events[eventCount].params[2] = (int)(CORE.Input.Gamepad.axisState[gamepad][axis]*32768.0f);\n\n                TRACELOG(LOG_INFO, \"[%i] INPUT_GAMEPAD_AXIS_MOTION: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n                eventCount++;\n            }\n        }\n    }\n\n    // INPUT_GESTURE\n    if (GESTURES.current != GESTURE_NONE)\n    {\n        events[eventCount].frame = frame;\n        events[eventCount].type = INPUT_GESTURE;\n        events[eventCount].params[0] = GESTURES.current;\n        events[eventCount].params[1] = 0;\n        events[eventCount].params[2] = 0;\n\n        TRACELOG(LOG_INFO, \"[%i] INPUT_GESTURE: %i, %i, %i\", events[eventCount].frame, events[eventCount].params[0], events[eventCount].params[1], events[eventCount].params[2]);\n        eventCount++;\n    }\n}\n\n// Play automation event\nstatic void PlayAutomationEvent(unsigned int frame)\n{\n    for (unsigned int i = 0; i < eventCount; i++)\n    {\n        if (events[i].frame == frame)\n        {\n            switch (events[i].type)\n            {\n                // Input events\n                case INPUT_KEY_UP: CORE.Input.Keyboard.currentKeyState[events[i].params[0]] = false; break;             // param[0]: key\n                case INPUT_KEY_DOWN: CORE.Input.Keyboard.currentKeyState[events[i].params[0]] = true; break;            // param[0]: key\n                case INPUT_MOUSE_BUTTON_UP: CORE.Input.Mouse.currentButtonState[events[i].params[0]] = false; break;    // param[0]: key\n                case INPUT_MOUSE_BUTTON_DOWN: CORE.Input.Mouse.currentButtonState[events[i].params[0]] = true; break;   // param[0]: key\n                case INPUT_MOUSE_POSITION:      // param[0]: x, param[1]: y\n                {\n                    CORE.Input.Mouse.currentPosition.x = (float)events[i].params[0];\n                    CORE.Input.Mouse.currentPosition.y = (float)events[i].params[1];\n                } break;\n                case INPUT_MOUSE_WHEEL_MOTION:  // param[0]: x delta, param[1]: y delta\n                {\n                    CORE.Input.Mouse.currentWheelMove.x = (float)events[i].params[0]; break;\n                    CORE.Input.Mouse.currentWheelMove.y = (float)events[i].params[1]; break;\n                } break;\n                case INPUT_TOUCH_UP: CORE.Input.Touch.currentTouchState[events[i].params[0]] = false; break;            // param[0]: id\n                case INPUT_TOUCH_DOWN: CORE.Input.Touch.currentTouchState[events[i].params[0]] = true; break;           // param[0]: id\n                case INPUT_TOUCH_POSITION:      // param[0]: id, param[1]: x, param[2]: y\n                {\n                    CORE.Input.Touch.position[events[i].params[0]].x = (float)events[i].params[1];\n                    CORE.Input.Touch.position[events[i].params[0]].y = (float)events[i].params[2];\n                } break;\n                case INPUT_GAMEPAD_CONNECT: CORE.Input.Gamepad.ready[events[i].params[0]] = true; break;                // param[0]: gamepad\n                case INPUT_GAMEPAD_DISCONNECT: CORE.Input.Gamepad.ready[events[i].params[0]] = false; break;            // param[0]: gamepad\n                case INPUT_GAMEPAD_BUTTON_UP: CORE.Input.Gamepad.currentButtonState[events[i].params[0]][events[i].params[1]] = false; break;    // param[0]: gamepad, param[1]: button\n                case INPUT_GAMEPAD_BUTTON_DOWN: CORE.Input.Gamepad.currentButtonState[events[i].params[0]][events[i].params[1]] = true; break;   // param[0]: gamepad, param[1]: button\n                case INPUT_GAMEPAD_AXIS_MOTION: // param[0]: gamepad, param[1]: axis, param[2]: delta\n                {\n                    CORE.Input.Gamepad.axisState[events[i].params[0]][events[i].params[1]] = ((float)events[i].params[2]/32768.0f);\n                } break;\n                case INPUT_GESTURE: GESTURES.current = events[i].params[0]; break;     // param[0]: gesture (enum Gesture) -> rgestures.h: GESTURES.current\n\n                // Window events\n                case WINDOW_CLOSE: CORE.Window.shouldClose = true; break;\n                case WINDOW_MAXIMIZE: MaximizeWindow(); break;\n                case WINDOW_MINIMIZE: MinimizeWindow(); break;\n                case WINDOW_RESIZE: SetWindowSize(events[i].params[0], events[i].params[1]); break;\n\n                // Custom events\n                case ACTION_TAKE_SCREENSHOT:\n                {\n                    TakeScreenshot(TextFormat(\"screenshot%03i.png\", screenshotCounter));\n                    screenshotCounter++;\n                } break;\n                case ACTION_SETTARGETFPS: SetTargetFPS(events[i].params[0]); break;\n                default: break;\n            }\n        }\n    }\n}\n#endif\n\n#if !defined(SUPPORT_MODULE_RTEXT)\n// Formatting of text with variables to 'embed'\n// WARNING: String returned will expire after this function is called MAX_TEXTFORMAT_BUFFERS times\nconst char *TextFormat(const char *text, ...)\n{\n#ifndef MAX_TEXTFORMAT_BUFFERS\n    #define MAX_TEXTFORMAT_BUFFERS      4        // Maximum number of static buffers for text formatting\n#endif\n#ifndef MAX_TEXT_BUFFER_LENGTH\n    #define MAX_TEXT_BUFFER_LENGTH   1024        // Maximum size of static text buffer\n#endif\n\n    // We create an array of buffers so strings don't expire until MAX_TEXTFORMAT_BUFFERS invocations\n    static char buffers[MAX_TEXTFORMAT_BUFFERS][MAX_TEXT_BUFFER_LENGTH] = { 0 };\n    static int index = 0;\n\n    char *currentBuffer = buffers[index];\n    memset(currentBuffer, 0, MAX_TEXT_BUFFER_LENGTH);   // Clear buffer before using\n\n    va_list args;\n    va_start(args, text);\n    vsnprintf(currentBuffer, MAX_TEXT_BUFFER_LENGTH, text, args);\n    va_end(args);\n\n    index += 1;     // Move to next buffer for next function call\n    if (index >= MAX_TEXTFORMAT_BUFFERS) index = 0;\n\n    return currentBuffer;\n}\n#endif // !SUPPORT_MODULE_RTEXT\n"], "filenames": ["src/rcore.c"], "buggy_code_start_loc": [1997], "buggy_code_end_loc": [3545], "fixing_code_start_loc": [1997], "fixing_code_end_loc": [3547], "type": "CWE-79", "message": "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site Scripting (XSS) such that the SetClipboardText API does not properly escape the ' character, allowing attacker-controlled input to break out of the string and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB. All the other Desktop/Mobile/Embedded platforms are not affected.", "other": {"cve": {"id": "CVE-2023-26123", "sourceIdentifier": "report@snyk.io", "published": "2023-04-14T05:15:13.867", "lastModified": "2023-04-21T03:45:53.513", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Versions of the package raysan5/raylib before 4.5.0 are vulnerable to Cross-site Scripting (XSS) such that the SetClipboardText API does not properly escape the ' character, allowing attacker-controlled input to break out of the string and execute arbitrary JavaScript via emscripten_run_script function.\r\r**Note:** This vulnerability is present only when compiling raylib for PLATFORM_WEB. All the other Desktop/Mobile/Embedded platforms are not affected."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}, {"source": "report@snyk.io", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:raylib:raylib:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.5.0", "matchCriteriaId": "CEDAAF81-EA14-4AEF-9C38-FB3063261835"}]}]}], "references": [{"url": "https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d", "source": "report@snyk.io", "tags": ["Patch"]}, {"url": "https://github.com/raysan5/raylib/issues/2954", "source": "report@snyk.io", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/raysan5/raylib/releases/tag/4.5.0", "source": "report@snyk.io", "tags": ["Release Notes"]}, {"url": "https://security.snyk.io/vuln/SNYK-UNMANAGED-RAYSAN5RAYLIB-5421188", "source": "report@snyk.io", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/raysan5/raylib/commit/b436c8d7e5346a241b00511a11585936895d959d"}}