{"buggy_code": ["#!/usr/bin/env bash\n# IMPORTANT NOTE: this script does not use the normal LEMMY_DATABASE_URL format\n#   it is expected that this script is called by run-federation-test.sh script.\nset -e\n\nexport RUST_BACKTRACE=1\nexport RUST_LOG=\"warn,lemmy_server=debug,lemmy_federate=debug,lemmy_api=debug,lemmy_api_common=debug,lemmy_api_crud=debug,lemmy_apub=debug,lemmy_db_schema=debug,lemmy_db_views=debug,lemmy_db_views_actor=debug,lemmy_db_views_moderator=debug,lemmy_routes=debug,lemmy_utils=debug,lemmy_websocket=debug\"\n\nexport LEMMY_TEST_FAST_FEDERATION=1 # by default, the persistent federation queue has delays in the scale of 30s-5min\n\n# pictrs setup\nif ! [ -f \"pict-rs\" ]; then\n  curl \"https://git.asonix.dog/asonix/pict-rs/releases/download/v0.5.0-beta.2/pict-rs-linux-amd64\" -o api_tests/pict-rs\n  chmod +x api_tests/pict-rs\nfi\n./api_tests/pict-rs \\\n  run -a 0.0.0.0:8080 \\\n  --danger-dummy-mode \\\n  --api-key \"my-pictrs-key\" \\\n  filesystem -p /tmp/pictrs/files \\\n  sled -p /tmp/pictrs/sled-repo 2>&1 &\n\nfor INSTANCE in lemmy_alpha lemmy_beta lemmy_gamma lemmy_delta lemmy_epsilon; do\n  echo \"DB URL: ${LEMMY_DATABASE_URL} INSTANCE: $INSTANCE\"\n  psql \"${LEMMY_DATABASE_URL}/lemmy\" -c \"DROP DATABASE IF EXISTS $INSTANCE\"\n  echo \"create database\"\n  psql \"${LEMMY_DATABASE_URL}/lemmy\" -c \"CREATE DATABASE $INSTANCE\"\ndone\n\nif [ -z \"$DO_WRITE_HOSTS_FILE\" ]; then\n  if ! grep -q lemmy-alpha /etc/hosts; then\n    echo \"Please add the following to your /etc/hosts file, then press enter:\n\n      127.0.0.1       lemmy-alpha\n      127.0.0.1       lemmy-beta\n      127.0.0.1       lemmy-gamma\n      127.0.0.1       lemmy-delta\n      127.0.0.1       lemmy-epsilon\"\n    read -p \"\"\n  fi\nelse\n  for INSTANCE in lemmy-alpha lemmy-beta lemmy-gamma lemmy-delta lemmy-epsilon; do\n    echo \"127.0.0.1 $INSTANCE\" >>/etc/hosts\n  done\nfi\n\necho \"$PWD\"\n\necho \"start alpha\"\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_alpha.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_alpha\" \\\n  target/lemmy_server >/tmp/lemmy_alpha.out 2>&1 &\n\necho \"start beta\"\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_beta.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_beta\" \\\n  target/lemmy_server >/tmp/lemmy_beta.out 2>&1 &\n\necho \"start gamma\"\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_gamma.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_gamma\" \\\n  target/lemmy_server >/tmp/lemmy_gamma.out 2>&1 &\n\necho \"start delta\"\n# An instance with only an allowlist for beta\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_delta.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_delta\" \\\n  target/lemmy_server >/tmp/lemmy_delta.out 2>&1 &\n\necho \"start epsilon\"\n# An instance who has a blocklist, with lemmy-alpha blocked\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_epsilon.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_epsilon\" \\\n  target/lemmy_server >/tmp/lemmy_epsilon.out 2>&1 &\n\necho \"wait for all instances to start\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-alpha:8541/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"alpha started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-beta:8551/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"beta started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-gamma:8561/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"gamma started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-delta:8571/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"delta started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-epsilon:8581/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"epsilon started. All started\"\n", "jest.setTimeout(120000);\nimport {\n  alpha,\n  beta,\n  setupLogins,\n  followBeta,\n  createPrivateMessage,\n  editPrivateMessage,\n  listPrivateMessages,\n  deletePrivateMessage,\n  unfollowRemotes,\n  waitUntil,\n} from \"./shared\";\n\nlet recipient_id: number;\n\nbeforeAll(async () => {\n  await setupLogins();\n  await followBeta(alpha);\n  recipient_id = 3;\n});\n\nafterAll(() => {\n  unfollowRemotes(alpha);\n});\n\ntest(\"Create a private message\", async () => {\n  let pmRes = await createPrivateMessage(alpha, recipient_id);\n  expect(pmRes.private_message_view.private_message.content).toBeDefined();\n  expect(pmRes.private_message_view.private_message.local).toBe(true);\n  expect(pmRes.private_message_view.creator.local).toBe(true);\n  expect(pmRes.private_message_view.recipient.local).toBe(false);\n\n  let betaPms = await waitUntil(\n    () => listPrivateMessages(beta),\n    e => !!e.private_messages[0],\n  );\n  expect(betaPms.private_messages[0].private_message.content).toBeDefined();\n  expect(betaPms.private_messages[0].private_message.local).toBe(false);\n  expect(betaPms.private_messages[0].creator.local).toBe(false);\n  expect(betaPms.private_messages[0].recipient.local).toBe(true);\n});\n\ntest(\"Update a private message\", async () => {\n  let updatedContent = \"A jest test federated private message edited\";\n\n  let pmRes = await createPrivateMessage(alpha, recipient_id);\n  let pmUpdated = await editPrivateMessage(\n    alpha,\n    pmRes.private_message_view.private_message.id,\n  );\n  expect(pmUpdated.private_message_view.private_message.content).toBe(\n    updatedContent,\n  );\n\n  let betaPms = await waitUntil(\n    () => listPrivateMessages(beta),\n    p => p.private_messages[0].private_message.content === updatedContent,\n  );\n  expect(betaPms.private_messages[0].private_message.content).toBe(\n    updatedContent,\n  );\n});\n\ntest(\"Delete a private message\", async () => {\n  let pmRes = await createPrivateMessage(alpha, recipient_id);\n  let betaPms1 = await waitUntil(\n    () => listPrivateMessages(beta),\n    m =>\n      !!m.private_messages.find(\n        e =>\n          e.private_message.ap_id ===\n          pmRes.private_message_view.private_message.ap_id,\n      ),\n  );\n  let deletedPmRes = await deletePrivateMessage(\n    alpha,\n    true,\n    pmRes.private_message_view.private_message.id,\n  );\n  expect(deletedPmRes.private_message_view.private_message.deleted).toBe(true);\n\n  // The GetPrivateMessages filters out deleted,\n  // even though they are in the actual database.\n  // no reason to show them\n  let betaPms2 = await waitUntil(\n    () => listPrivateMessages(beta),\n    p => p.private_messages.length === betaPms1.private_messages.length - 1,\n  );\n  expect(betaPms2.private_messages.length).toBe(\n    betaPms1.private_messages.length - 1,\n  );\n\n  // Undelete\n  let undeletedPmRes = await deletePrivateMessage(\n    alpha,\n    false,\n    pmRes.private_message_view.private_message.id,\n  );\n  expect(undeletedPmRes.private_message_view.private_message.deleted).toBe(\n    false,\n  );\n\n  let betaPms3 = await waitUntil(\n    () => listPrivateMessages(beta),\n    p => p.private_messages.length === betaPms1.private_messages.length,\n  );\n  expect(betaPms3.private_messages.length).toBe(\n    betaPms1.private_messages.length,\n  );\n});\n", "import {\n  BlockCommunity,\n  BlockCommunityResponse,\n  BlockInstance,\n  BlockInstanceResponse,\n  CommunityId,\n  GetReplies,\n  GetRepliesResponse,\n  GetUnreadCountResponse,\n  InstanceId,\n  LemmyHttp,\n  PostView,\n  SuccessResponse,\n} from \"lemmy-js-client\";\nimport { CreatePost } from \"lemmy-js-client/dist/types/CreatePost\";\nimport { DeletePost } from \"lemmy-js-client/dist/types/DeletePost\";\nimport { EditPost } from \"lemmy-js-client/dist/types/EditPost\";\nimport { EditSite } from \"lemmy-js-client/dist/types/EditSite\";\nimport { FeaturePost } from \"lemmy-js-client/dist/types/FeaturePost\";\nimport { GetComments } from \"lemmy-js-client/dist/types/GetComments\";\nimport { GetCommentsResponse } from \"lemmy-js-client/dist/types/GetCommentsResponse\";\nimport { GetPost } from \"lemmy-js-client/dist/types/GetPost\";\nimport { GetPostResponse } from \"lemmy-js-client/dist/types/GetPostResponse\";\nimport { LockPost } from \"lemmy-js-client/dist/types/LockPost\";\nimport { Login } from \"lemmy-js-client/dist/types/Login\";\nimport { Post } from \"lemmy-js-client/dist/types/Post\";\nimport { PostResponse } from \"lemmy-js-client/dist/types/PostResponse\";\nimport { RemovePost } from \"lemmy-js-client/dist/types/RemovePost\";\nimport { ResolveObject } from \"lemmy-js-client/dist/types/ResolveObject\";\nimport { ResolveObjectResponse } from \"lemmy-js-client/dist/types/ResolveObjectResponse\";\nimport { Search } from \"lemmy-js-client/dist/types/Search\";\nimport { SearchResponse } from \"lemmy-js-client/dist/types/SearchResponse\";\nimport { Comment } from \"lemmy-js-client/dist/types/Comment\";\nimport { BanPersonResponse } from \"lemmy-js-client/dist/types/BanPersonResponse\";\nimport { BanPerson } from \"lemmy-js-client/dist/types/BanPerson\";\nimport { BanFromCommunityResponse } from \"lemmy-js-client/dist/types/BanFromCommunityResponse\";\nimport { BanFromCommunity } from \"lemmy-js-client/dist/types/BanFromCommunity\";\nimport { CommunityResponse } from \"lemmy-js-client/dist/types/CommunityResponse\";\nimport { FollowCommunity } from \"lemmy-js-client/dist/types/FollowCommunity\";\nimport { CreatePostLike } from \"lemmy-js-client/dist/types/CreatePostLike\";\nimport { CommentResponse } from \"lemmy-js-client/dist/types/CommentResponse\";\nimport { CreateComment } from \"lemmy-js-client/dist/types/CreateComment\";\nimport { EditComment } from \"lemmy-js-client/dist/types/EditComment\";\nimport { DeleteComment } from \"lemmy-js-client/dist/types/DeleteComment\";\nimport { RemoveComment } from \"lemmy-js-client/dist/types/RemoveComment\";\nimport { GetPersonMentionsResponse } from \"lemmy-js-client/dist/types/GetPersonMentionsResponse\";\nimport { GetPersonMentions } from \"lemmy-js-client/dist/types/GetPersonMentions\";\nimport { CreateCommentLike } from \"lemmy-js-client/dist/types/CreateCommentLike\";\nimport { CreateCommunity } from \"lemmy-js-client/dist/types/CreateCommunity\";\nimport { GetCommunity } from \"lemmy-js-client/dist/types/GetCommunity\";\nimport { DeleteCommunity } from \"lemmy-js-client/dist/types/DeleteCommunity\";\nimport { RemoveCommunity } from \"lemmy-js-client/dist/types/RemoveCommunity\";\nimport { PrivateMessageResponse } from \"lemmy-js-client/dist/types/PrivateMessageResponse\";\nimport { CreatePrivateMessage } from \"lemmy-js-client/dist/types/CreatePrivateMessage\";\nimport { EditPrivateMessage } from \"lemmy-js-client/dist/types/EditPrivateMessage\";\nimport { DeletePrivateMessage } from \"lemmy-js-client/dist/types/DeletePrivateMessage\";\nimport { LoginResponse } from \"lemmy-js-client/dist/types/LoginResponse\";\nimport { Register } from \"lemmy-js-client/dist/types/Register\";\nimport { SaveUserSettings } from \"lemmy-js-client/dist/types/SaveUserSettings\";\nimport { DeleteAccount } from \"lemmy-js-client/dist/types/DeleteAccount\";\nimport { GetSiteResponse } from \"lemmy-js-client/dist/types/GetSiteResponse\";\nimport { PrivateMessagesResponse } from \"lemmy-js-client/dist/types/PrivateMessagesResponse\";\nimport { GetPrivateMessages } from \"lemmy-js-client/dist/types/GetPrivateMessages\";\nimport { PostReportResponse } from \"lemmy-js-client/dist/types/PostReportResponse\";\nimport { CreatePostReport } from \"lemmy-js-client/dist/types/CreatePostReport\";\nimport { ListPostReportsResponse } from \"lemmy-js-client/dist/types/ListPostReportsResponse\";\nimport { ListPostReports } from \"lemmy-js-client/dist/types/ListPostReports\";\nimport { CommentReportResponse } from \"lemmy-js-client/dist/types/CommentReportResponse\";\nimport { CreateCommentReport } from \"lemmy-js-client/dist/types/CreateCommentReport\";\nimport { ListCommentReportsResponse } from \"lemmy-js-client/dist/types/ListCommentReportsResponse\";\nimport { ListCommentReports } from \"lemmy-js-client/dist/types/ListCommentReports\";\nimport { GetPostsResponse } from \"lemmy-js-client/dist/types/GetPostsResponse\";\nimport { GetPosts } from \"lemmy-js-client/dist/types/GetPosts\";\nimport { GetPersonDetailsResponse } from \"lemmy-js-client/dist/types/GetPersonDetailsResponse\";\nimport { GetPersonDetails } from \"lemmy-js-client/dist/types/GetPersonDetails\";\nimport { ListingType } from \"lemmy-js-client/dist/types/ListingType\";\n\nexport const fetchFunction = fetch;\n\nexport let alphaUrl = \"http://127.0.0.1:8541\";\nexport let betaUrl = \"http://127.0.0.1:8551\";\nexport let gammaUrl = \"http://127.0.0.1:8561\";\nexport let deltaUrl = \"http://127.0.0.1:8571\";\nexport let epsilonUrl = \"http://127.0.0.1:8581\";\n\nexport let alpha = new LemmyHttp(alphaUrl, { fetchFunction });\nexport let alphaImage = new LemmyHttp(alphaUrl);\nexport let beta = new LemmyHttp(betaUrl, { fetchFunction });\nexport let gamma = new LemmyHttp(gammaUrl, { fetchFunction });\nexport let delta = new LemmyHttp(deltaUrl, { fetchFunction });\nexport let epsilon = new LemmyHttp(epsilonUrl, { fetchFunction });\n\nexport let betaAllowedInstances = [\n  \"lemmy-alpha\",\n  \"lemmy-gamma\",\n  \"lemmy-delta\",\n  \"lemmy-epsilon\",\n];\n\nconst password = \"lemmylemmy\";\n\nexport async function setupLogins() {\n  let formAlpha: Login = {\n    username_or_email: \"lemmy_alpha\",\n    password,\n  };\n  let resAlpha = alpha.login(formAlpha);\n\n  let formBeta: Login = {\n    username_or_email: \"lemmy_beta\",\n    password,\n  };\n  let resBeta = beta.login(formBeta);\n\n  let formGamma: Login = {\n    username_or_email: \"lemmy_gamma\",\n    password,\n  };\n  let resGamma = gamma.login(formGamma);\n\n  let formDelta: Login = {\n    username_or_email: \"lemmy_delta\",\n    password,\n  };\n  let resDelta = delta.login(formDelta);\n\n  let formEpsilon: Login = {\n    username_or_email: \"lemmy_epsilon\",\n    password,\n  };\n  let resEpsilon = epsilon.login(formEpsilon);\n\n  let res = await Promise.all([\n    resAlpha,\n    resBeta,\n    resGamma,\n    resDelta,\n    resEpsilon,\n  ]);\n  alpha.setHeaders({ Authorization: `Bearer ${res[0].jwt ?? \"\"}` });\n  alphaImage.setHeaders({ Authorization: `Bearer ${res[0].jwt ?? \"\"}` });\n  beta.setHeaders({ Authorization: `Bearer ${res[1].jwt ?? \"\"}` });\n  gamma.setHeaders({ Authorization: `Bearer ${res[2].jwt ?? \"\"}` });\n  delta.setHeaders({ Authorization: `Bearer ${res[3].jwt ?? \"\"}` });\n  epsilon.setHeaders({ Authorization: `Bearer ${res[4].jwt ?? \"\"}` });\n\n  // Registration applications are now enabled by default, need to disable them\n  let editSiteForm: EditSite = {\n    registration_mode: \"Open\",\n    rate_limit_message: 999,\n    rate_limit_post: 999,\n    rate_limit_register: 999,\n    rate_limit_image: 999,\n    rate_limit_comment: 999,\n    rate_limit_search: 999,\n  };\n\n  // Set the blocks and auths for each\n  editSiteForm.allowed_instances = [\n    \"lemmy-beta\",\n    \"lemmy-gamma\",\n    \"lemmy-delta\",\n    \"lemmy-epsilon\",\n  ];\n  await alpha.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = betaAllowedInstances;\n  await beta.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = [\n    \"lemmy-alpha\",\n    \"lemmy-beta\",\n    \"lemmy-delta\",\n    \"lemmy-epsilon\",\n  ];\n  await gamma.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = [\"lemmy-beta\"];\n  await delta.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = [];\n  editSiteForm.blocked_instances = [\"lemmy-alpha\"];\n  await epsilon.editSite(editSiteForm);\n\n  // Create the main alpha/beta communities\n  // Ignore thrown errors of duplicates\n  try {\n    await createCommunity(alpha, \"main\");\n    await createCommunity(beta, \"main\");\n    // wait for > INSTANCES_RECHECK_DELAY to ensure federation is initialized\n    // otherwise the first few federated events may be missed\n    // (because last_successful_id is set to current id when federation to an instance is first started)\n    // only needed the first time so do in this try\n    await delay(10_000);\n  } catch (_) {\n    console.log(\"Communities already exist\");\n  }\n}\n\nexport async function createPost(\n  api: LemmyHttp,\n  community_id: number,\n  // use example.com for consistent title and embed description\n  url: string = \"https://example.com/\",\n): Promise<PostResponse> {\n  let name = randomString(5);\n  let body = randomString(10);\n  let form: CreatePost = {\n    name,\n    url,\n    body,\n    community_id,\n  };\n  return api.createPost(form);\n}\n\nexport async function editPost(\n  api: LemmyHttp,\n  post: Post,\n): Promise<PostResponse> {\n  let name = \"A jest test federated post, updated\";\n  let form: EditPost = {\n    name,\n    post_id: post.id,\n  };\n  return api.editPost(form);\n}\n\nexport async function deletePost(\n  api: LemmyHttp,\n  deleted: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: DeletePost = {\n    post_id: post.id,\n    deleted: deleted,\n  };\n  return api.deletePost(form);\n}\n\nexport async function removePost(\n  api: LemmyHttp,\n  removed: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: RemovePost = {\n    post_id: post.id,\n    removed,\n  };\n  return api.removePost(form);\n}\n\nexport async function featurePost(\n  api: LemmyHttp,\n  featured: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: FeaturePost = {\n    post_id: post.id,\n    featured,\n    feature_type: \"Community\",\n  };\n  return api.featurePost(form);\n}\n\nexport async function lockPost(\n  api: LemmyHttp,\n  locked: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: LockPost = {\n    post_id: post.id,\n    locked,\n  };\n  return api.lockPost(form);\n}\n\nexport async function resolvePost(\n  api: LemmyHttp,\n  post: Post,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q: post.ap_id,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function searchPostLocal(\n  api: LemmyHttp,\n  post: Post,\n): Promise<SearchResponse> {\n  let form: Search = {\n    q: post.name,\n    type_: \"Posts\",\n    sort: \"TopAll\",\n    listing_type: \"All\",\n  };\n  return api.search(form);\n}\n\n/// wait for a post to appear locally without pulling it\nexport async function waitForPost(\n  api: LemmyHttp,\n  post: Post,\n  checker: (t: PostView | undefined) => boolean = p => !!p,\n) {\n  return waitUntil<PostView>(\n    () => searchPostLocal(api, post).then(p => p.posts[0]),\n    checker,\n  );\n}\n\nexport async function getPost(\n  api: LemmyHttp,\n  post_id: number,\n): Promise<GetPostResponse> {\n  let form: GetPost = {\n    id: post_id,\n  };\n  return api.getPost(form);\n}\n\nexport async function getComments(\n  api: LemmyHttp,\n  post_id?: number,\n  listingType: ListingType = \"All\",\n): Promise<GetCommentsResponse> {\n  let form: GetComments = {\n    post_id: post_id,\n    type_: listingType,\n    sort: \"New\",\n    limit: 50,\n  };\n  return api.getComments(form);\n}\n\nexport async function getUnreadCount(\n  api: LemmyHttp,\n): Promise<GetUnreadCountResponse> {\n  return api.getUnreadCount();\n}\n\nexport async function getReplies(api: LemmyHttp): Promise<GetRepliesResponse> {\n  let form: GetReplies = {\n    sort: \"New\",\n    unread_only: false,\n  };\n  return api.getReplies(form);\n}\n\nexport async function resolveComment(\n  api: LemmyHttp,\n  comment: Comment,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q: comment.ap_id,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function resolveBetaCommunity(\n  api: LemmyHttp,\n): Promise<ResolveObjectResponse> {\n  // Use short-hand search url\n  let form: ResolveObject = {\n    q: \"!main@lemmy-beta:8551\",\n  };\n  return api.resolveObject(form);\n}\n\nexport async function resolveCommunity(\n  api: LemmyHttp,\n  q: string,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function resolvePerson(\n  api: LemmyHttp,\n  apShortname: string,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q: apShortname,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function banPersonFromSite(\n  api: LemmyHttp,\n  person_id: number,\n  ban: boolean,\n  remove_data: boolean,\n): Promise<BanPersonResponse> {\n  // Make sure lemmy-beta/c/main is cached on lemmy_alpha\n  let form: BanPerson = {\n    person_id,\n    ban,\n    remove_data: remove_data,\n  };\n  return api.banPerson(form);\n}\n\nexport async function banPersonFromCommunity(\n  api: LemmyHttp,\n  person_id: number,\n  community_id: number,\n  remove_data: boolean,\n  ban: boolean,\n): Promise<BanFromCommunityResponse> {\n  let form: BanFromCommunity = {\n    person_id,\n    community_id,\n    remove_data: remove_data,\n    ban,\n  };\n  return api.banFromCommunity(form);\n}\n\nexport async function followCommunity(\n  api: LemmyHttp,\n  follow: boolean,\n  community_id: number,\n): Promise<CommunityResponse> {\n  let form: FollowCommunity = {\n    community_id,\n    follow,\n  };\n  const res = await api.followCommunity(form);\n  await waitUntil(\n    () => getCommunity(api, res.community_view.community.id),\n    g =>\n      g.community_view.subscribed === (follow ? \"Subscribed\" : \"NotSubscribed\"),\n  );\n  // wait FOLLOW_ADDITIONS_RECHECK_DELAY (there's no API to wait for this currently)\n  await delay(2000);\n  return res;\n}\n\nexport async function likePost(\n  api: LemmyHttp,\n  score: number,\n  post: Post,\n): Promise<PostResponse> {\n  let form: CreatePostLike = {\n    post_id: post.id,\n    score: score,\n  };\n\n  return api.likePost(form);\n}\n\nexport async function createComment(\n  api: LemmyHttp,\n  post_id: number,\n  parent_id?: number,\n  content = \"a jest test comment\",\n): Promise<CommentResponse> {\n  let form: CreateComment = {\n    content,\n    post_id,\n    parent_id,\n  };\n  return api.createComment(form);\n}\n\nexport async function editComment(\n  api: LemmyHttp,\n  comment_id: number,\n  content = \"A jest test federated comment update\",\n): Promise<CommentResponse> {\n  let form: EditComment = {\n    content,\n    comment_id,\n  };\n  return api.editComment(form);\n}\n\nexport async function deleteComment(\n  api: LemmyHttp,\n  deleted: boolean,\n  comment_id: number,\n): Promise<CommentResponse> {\n  let form: DeleteComment = {\n    comment_id,\n    deleted,\n  };\n  return api.deleteComment(form);\n}\n\nexport async function removeComment(\n  api: LemmyHttp,\n  removed: boolean,\n  comment_id: number,\n): Promise<CommentResponse> {\n  let form: RemoveComment = {\n    comment_id,\n    removed,\n  };\n  return api.removeComment(form);\n}\n\nexport async function getMentions(\n  api: LemmyHttp,\n): Promise<GetPersonMentionsResponse> {\n  let form: GetPersonMentions = {\n    sort: \"New\",\n    unread_only: false,\n  };\n  return api.getPersonMentions(form);\n}\n\nexport async function likeComment(\n  api: LemmyHttp,\n  score: number,\n  comment: Comment,\n): Promise<CommentResponse> {\n  let form: CreateCommentLike = {\n    comment_id: comment.id,\n    score,\n  };\n  return api.likeComment(form);\n}\n\nexport async function createCommunity(\n  api: LemmyHttp,\n  name_: string = randomString(5),\n): Promise<CommunityResponse> {\n  let description = \"a sample description\";\n  let form: CreateCommunity = {\n    name: name_,\n    title: name_,\n    description,\n  };\n  return api.createCommunity(form);\n}\n\nexport async function getCommunity(\n  api: LemmyHttp,\n  id: number,\n): Promise<CommunityResponse> {\n  let form: GetCommunity = {\n    id,\n  };\n  return api.getCommunity(form);\n}\n\nexport async function getCommunityByName(\n  api: LemmyHttp,\n  name: string,\n): Promise<CommunityResponse> {\n  let form: GetCommunity = {\n    name,\n  };\n  return api.getCommunity(form);\n}\n\nexport async function deleteCommunity(\n  api: LemmyHttp,\n  deleted: boolean,\n  community_id: number,\n): Promise<CommunityResponse> {\n  let form: DeleteCommunity = {\n    community_id,\n    deleted,\n  };\n  return api.deleteCommunity(form);\n}\n\nexport async function removeCommunity(\n  api: LemmyHttp,\n  removed: boolean,\n  community_id: number,\n): Promise<CommunityResponse> {\n  let form: RemoveCommunity = {\n    community_id,\n    removed,\n  };\n  return api.removeCommunity(form);\n}\n\nexport async function createPrivateMessage(\n  api: LemmyHttp,\n  recipient_id: number,\n): Promise<PrivateMessageResponse> {\n  let content = \"A jest test federated private message\";\n  let form: CreatePrivateMessage = {\n    content,\n    recipient_id,\n  };\n  return api.createPrivateMessage(form);\n}\n\nexport async function editPrivateMessage(\n  api: LemmyHttp,\n  private_message_id: number,\n): Promise<PrivateMessageResponse> {\n  let updatedContent = \"A jest test federated private message edited\";\n  let form: EditPrivateMessage = {\n    content: updatedContent,\n    private_message_id,\n  };\n  return api.editPrivateMessage(form);\n}\n\nexport async function deletePrivateMessage(\n  api: LemmyHttp,\n  deleted: boolean,\n  private_message_id: number,\n): Promise<PrivateMessageResponse> {\n  let form: DeletePrivateMessage = {\n    deleted,\n    private_message_id,\n  };\n  return api.deletePrivateMessage(form);\n}\n\nexport async function registerUser(\n  api: LemmyHttp,\n  url: string,\n  username: string = randomString(5),\n): Promise<LemmyHttp> {\n  let form: Register = {\n    username,\n    password,\n    password_verify: password,\n    show_nsfw: true,\n  };\n  let login_response = await api.register(form);\n\n  expect(login_response.jwt).toBeDefined();\n  let lemmy_http = new LemmyHttp(url, {\n    headers: { Authorization: `Bearer ${login_response.jwt ?? \"\"}` },\n  });\n  return lemmy_http;\n}\n\nexport async function loginUser(\n  api: LemmyHttp,\n  username: string,\n): Promise<LoginResponse> {\n  let form: Login = {\n    username_or_email: username,\n    password: password,\n  };\n  return api.login(form);\n}\n\nexport async function saveUserSettingsBio(\n  api: LemmyHttp,\n): Promise<SuccessResponse> {\n  let form: SaveUserSettings = {\n    show_nsfw: true,\n    blur_nsfw: false,\n    auto_expand: true,\n    theme: \"darkly\",\n    default_sort_type: \"Active\",\n    default_listing_type: \"All\",\n    interface_language: \"en\",\n    show_avatars: true,\n    send_notifications_to_email: false,\n    bio: \"a changed bio\",\n  };\n  return saveUserSettings(api, form);\n}\n\nexport async function saveUserSettingsFederated(\n  api: LemmyHttp,\n): Promise<SuccessResponse> {\n  let avatar = \"https://image.flaticon.com/icons/png/512/35/35896.png\";\n  let banner = \"https://image.flaticon.com/icons/png/512/36/35896.png\";\n  let bio = \"a changed bio\";\n  let form: SaveUserSettings = {\n    show_nsfw: false,\n    blur_nsfw: true,\n    auto_expand: false,\n    default_sort_type: \"Hot\",\n    default_listing_type: \"All\",\n    interface_language: \"\",\n    avatar,\n    banner,\n    display_name: \"user321\",\n    show_avatars: false,\n    send_notifications_to_email: false,\n    bio,\n  };\n  return await saveUserSettings(api, form);\n}\n\nexport async function saveUserSettings(\n  api: LemmyHttp,\n  form: SaveUserSettings,\n): Promise<SuccessResponse> {\n  return api.saveUserSettings(form);\n}\nexport async function getPersonDetails(\n  api: LemmyHttp,\n  person_id: number,\n): Promise<GetPersonDetailsResponse> {\n  let form: GetPersonDetails = {\n    person_id: person_id,\n  };\n  return api.getPersonDetails(form);\n}\n\nexport async function deleteUser(api: LemmyHttp): Promise<SuccessResponse> {\n  let form: DeleteAccount = {\n    delete_content: true,\n    password,\n  };\n  return api.deleteAccount(form);\n}\n\nexport async function getSite(api: LemmyHttp): Promise<GetSiteResponse> {\n  return api.getSite();\n}\n\nexport async function listPrivateMessages(\n  api: LemmyHttp,\n): Promise<PrivateMessagesResponse> {\n  let form: GetPrivateMessages = {\n    unread_only: false,\n  };\n  return api.getPrivateMessages(form);\n}\n\nexport async function unfollowRemotes(\n  api: LemmyHttp,\n): Promise<GetSiteResponse> {\n  // Unfollow all remote communities\n  let site = await getSite(api);\n  let remoteFollowed =\n    site.my_user?.follows.filter(c => c.community.local == false) ?? [];\n  await Promise.all(\n    remoteFollowed.map(cu => followCommunity(api, false, cu.community.id)),\n  );\n  let siteRes = await getSite(api);\n  return siteRes;\n}\n\nexport async function followBeta(api: LemmyHttp): Promise<CommunityResponse> {\n  let betaCommunity = (await resolveBetaCommunity(api)).community;\n  if (betaCommunity) {\n    let follow = await followCommunity(api, true, betaCommunity.community.id);\n    return follow;\n  } else {\n    return Promise.reject(\"no community worked\");\n  }\n}\n\nexport async function reportPost(\n  api: LemmyHttp,\n  post_id: number,\n  reason: string,\n): Promise<PostReportResponse> {\n  let form: CreatePostReport = {\n    post_id,\n    reason,\n  };\n  return api.createPostReport(form);\n}\n\nexport async function listPostReports(\n  api: LemmyHttp,\n): Promise<ListPostReportsResponse> {\n  let form: ListPostReports = {};\n  return api.listPostReports(form);\n}\n\nexport async function reportComment(\n  api: LemmyHttp,\n  comment_id: number,\n  reason: string,\n): Promise<CommentReportResponse> {\n  let form: CreateCommentReport = {\n    comment_id,\n    reason,\n  };\n  return api.createCommentReport(form);\n}\n\nexport async function listCommentReports(\n  api: LemmyHttp,\n): Promise<ListCommentReportsResponse> {\n  let form: ListCommentReports = {};\n  return api.listCommentReports(form);\n}\n\nexport function getPosts(\n  api: LemmyHttp,\n  listingType?: ListingType,\n): Promise<GetPostsResponse> {\n  let form: GetPosts = {\n    type_: listingType,\n    limit: 50,\n  };\n  return api.getPosts(form);\n}\n\nexport function blockInstance(\n  api: LemmyHttp,\n  instance_id: InstanceId,\n  block: boolean,\n): Promise<BlockInstanceResponse> {\n  let form: BlockInstance = {\n    instance_id,\n    block,\n  };\n  return api.blockInstance(form);\n}\n\nexport function blockCommunity(\n  api: LemmyHttp,\n  community_id: CommunityId,\n  block: boolean,\n): Promise<BlockCommunityResponse> {\n  let form: BlockCommunity = {\n    community_id,\n    block,\n  };\n  return api.blockCommunity(form);\n}\n\nexport function delay(millis = 500) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\n\nexport function longDelay() {\n  return delay(10000);\n}\n\nexport function wrapper(form: any): string {\n  return JSON.stringify(form);\n}\n\nexport function randomString(length: number): string {\n  var result = \"\";\n  var characters =\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport async function unfollows() {\n  await Promise.all([\n    unfollowRemotes(alpha),\n    unfollowRemotes(gamma),\n    unfollowRemotes(delta),\n    unfollowRemotes(epsilon),\n  ]);\n}\n\nexport function getCommentParentId(comment: Comment): number | undefined {\n  let split = comment.path.split(\".\");\n  // remove the 0\n  split.shift();\n\n  if (split.length > 1) {\n    return Number(split[split.length - 2]);\n  } else {\n    console.log(`Failed to extract comment parent id from ${comment.path}`);\n    return undefined;\n  }\n}\n\nexport async function waitUntil<T>(\n  fetcher: () => Promise<T>,\n  checker: (t: T) => boolean,\n  retries = 10,\n  delaySeconds = [0.2, 0.5, 1, 2, 3],\n) {\n  let retry = 0;\n  let result;\n  while (retry++ < retries) {\n    result = await fetcher();\n    if (checker(result)) return result;\n    await delay(\n      delaySeconds[Math.min(retry - 1, delaySeconds.length - 1)] * 1000,\n    );\n  }\n  console.error(\"result\", result);\n  throw Error(\n    `Failed \"${fetcher}\": \"${checker}\" did not return true after ${retries} retries (delayed ${delaySeconds}s each)`,\n  );\n}\n", "use crate::check_report_reason;\nuse actix_web::web::{Data, Json};\nuse lemmy_api_common::{\n  context::LemmyContext,\n  private_message::{CreatePrivateMessageReport, PrivateMessageReportResponse},\n  utils::send_new_report_email_to_admins,\n};\nuse lemmy_db_schema::{\n  source::{\n    local_site::LocalSite,\n    private_message::PrivateMessage,\n    private_message_report::{PrivateMessageReport, PrivateMessageReportForm},\n  },\n  traits::{Crud, Reportable},\n};\nuse lemmy_db_views::structs::{LocalUserView, PrivateMessageReportView};\nuse lemmy_utils::error::{LemmyError, LemmyErrorExt, LemmyErrorType};\n\n#[tracing::instrument(skip(context))]\npub async fn create_pm_report(\n  data: Json<CreatePrivateMessageReport>,\n  context: Data<LemmyContext>,\n  local_user_view: LocalUserView,\n) -> Result<Json<PrivateMessageReportResponse>, LemmyError> {\n  let local_site = LocalSite::read(&mut context.pool()).await?;\n\n  let reason = data.reason.trim().to_string();\n  check_report_reason(&reason, &local_site)?;\n\n  let person_id = local_user_view.person.id;\n  let private_message_id = data.private_message_id;\n  let private_message = PrivateMessage::read(&mut context.pool(), private_message_id).await?;\n\n  let report_form = PrivateMessageReportForm {\n    creator_id: person_id,\n    private_message_id,\n    original_pm_text: private_message.content,\n    reason,\n  };\n\n  let report = PrivateMessageReport::report(&mut context.pool(), &report_form)\n    .await\n    .with_lemmy_type(LemmyErrorType::CouldntCreateReport)?;\n\n  let private_message_report_view =\n    PrivateMessageReportView::read(&mut context.pool(), report.id).await?;\n\n  // Email the admins\n  if local_site.reports_email_admins {\n    send_new_report_email_to_admins(\n      &private_message_report_view.creator.name,\n      &private_message_report_view.private_message_creator.name,\n      &mut context.pool(),\n      context.settings(),\n    )\n    .await?;\n  }\n\n  // TODO: consider federating this\n\n  Ok(Json(PrivateMessageReportResponse {\n    private_message_report_view,\n  }))\n}\n"], "fixing_code": ["#!/usr/bin/env bash\n# IMPORTANT NOTE: this script does not use the normal LEMMY_DATABASE_URL format\n#   it is expected that this script is called by run-federation-test.sh script.\nset -e\n\nexport RUST_BACKTRACE=1\nexport RUST_LOG=\"warn,lemmy_server=debug,lemmy_federate=debug,lemmy_api=debug,lemmy_api_common=debug,lemmy_api_crud=debug,lemmy_apub=debug,lemmy_db_schema=debug,lemmy_db_views=debug,lemmy_db_views_actor=debug,lemmy_db_views_moderator=debug,lemmy_routes=debug,lemmy_utils=debug,lemmy_websocket=debug\"\n\nexport LEMMY_TEST_FAST_FEDERATION=1 # by default, the persistent federation queue has delays in the scale of 30s-5min\n\n# pictrs setup\nif [ ! -f \"pict-rs\" ]; then\n  curl \"https://git.asonix.dog/asonix/pict-rs/releases/download/v0.5.0-beta.2/pict-rs-linux-amd64\" -o api_tests/pict-rs\n  chmod +x api_tests/pict-rs\nfi\n./api_tests/pict-rs \\\n  run -a 0.0.0.0:8080 \\\n  --danger-dummy-mode \\\n  --api-key \"my-pictrs-key\" \\\n  filesystem -p /tmp/pictrs/files \\\n  sled -p /tmp/pictrs/sled-repo 2>&1 &\n\nfor INSTANCE in lemmy_alpha lemmy_beta lemmy_gamma lemmy_delta lemmy_epsilon; do\n  echo \"DB URL: ${LEMMY_DATABASE_URL} INSTANCE: $INSTANCE\"\n  psql \"${LEMMY_DATABASE_URL}/lemmy\" -c \"DROP DATABASE IF EXISTS $INSTANCE\"\n  echo \"create database\"\n  psql \"${LEMMY_DATABASE_URL}/lemmy\" -c \"CREATE DATABASE $INSTANCE\"\ndone\n\nif [ -z \"$DO_WRITE_HOSTS_FILE\" ]; then\n  if ! grep -q lemmy-alpha /etc/hosts; then\n    echo \"Please add the following to your /etc/hosts file, then press enter:\n\n      127.0.0.1       lemmy-alpha\n      127.0.0.1       lemmy-beta\n      127.0.0.1       lemmy-gamma\n      127.0.0.1       lemmy-delta\n      127.0.0.1       lemmy-epsilon\"\n    read -p \"\"\n  fi\nelse\n  for INSTANCE in lemmy-alpha lemmy-beta lemmy-gamma lemmy-delta lemmy-epsilon; do\n    echo \"127.0.0.1 $INSTANCE\" >>/etc/hosts\n  done\nfi\n\necho \"$PWD\"\n\necho \"start alpha\"\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_alpha.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_alpha\" \\\n  target/lemmy_server >/tmp/lemmy_alpha.out 2>&1 &\n\necho \"start beta\"\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_beta.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_beta\" \\\n  target/lemmy_server >/tmp/lemmy_beta.out 2>&1 &\n\necho \"start gamma\"\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_gamma.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_gamma\" \\\n  target/lemmy_server >/tmp/lemmy_gamma.out 2>&1 &\n\necho \"start delta\"\n# An instance with only an allowlist for beta\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_delta.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_delta\" \\\n  target/lemmy_server >/tmp/lemmy_delta.out 2>&1 &\n\necho \"start epsilon\"\n# An instance who has a blocklist, with lemmy-alpha blocked\nLEMMY_CONFIG_LOCATION=./docker/federation/lemmy_epsilon.hjson \\\n  LEMMY_DATABASE_URL=\"${LEMMY_DATABASE_URL}/lemmy_epsilon\" \\\n  target/lemmy_server >/tmp/lemmy_epsilon.out 2>&1 &\n\necho \"wait for all instances to start\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-alpha:8541/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"alpha started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-beta:8551/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"beta started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-gamma:8561/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"gamma started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-delta:8571/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"delta started\"\nwhile [[ \"$(curl -s -o /dev/null -w '%{http_code}' 'lemmy-epsilon:8581/api/v3/site')\" != \"200\" ]]; do sleep 1; done\necho \"epsilon started. All started\"\n", "jest.setTimeout(120000);\nimport {\n  alpha,\n  beta,\n  setupLogins,\n  followBeta,\n  createPrivateMessage,\n  editPrivateMessage,\n  listPrivateMessages,\n  deletePrivateMessage,\n  unfollowRemotes,\n  waitUntil,\n  reportPrivateMessage,\n} from \"./shared\";\n\nlet recipient_id: number;\n\nbeforeAll(async () => {\n  await setupLogins();\n  await followBeta(alpha);\n  recipient_id = 3;\n});\n\nafterAll(() => {\n  unfollowRemotes(alpha);\n});\n\ntest(\"Create a private message\", async () => {\n  let pmRes = await createPrivateMessage(alpha, recipient_id);\n  expect(pmRes.private_message_view.private_message.content).toBeDefined();\n  expect(pmRes.private_message_view.private_message.local).toBe(true);\n  expect(pmRes.private_message_view.creator.local).toBe(true);\n  expect(pmRes.private_message_view.recipient.local).toBe(false);\n\n  let betaPms = await waitUntil(\n    () => listPrivateMessages(beta),\n    e => !!e.private_messages[0],\n  );\n  expect(betaPms.private_messages[0].private_message.content).toBeDefined();\n  expect(betaPms.private_messages[0].private_message.local).toBe(false);\n  expect(betaPms.private_messages[0].creator.local).toBe(false);\n  expect(betaPms.private_messages[0].recipient.local).toBe(true);\n});\n\ntest(\"Update a private message\", async () => {\n  let updatedContent = \"A jest test federated private message edited\";\n\n  let pmRes = await createPrivateMessage(alpha, recipient_id);\n  let pmUpdated = await editPrivateMessage(\n    alpha,\n    pmRes.private_message_view.private_message.id,\n  );\n  expect(pmUpdated.private_message_view.private_message.content).toBe(\n    updatedContent,\n  );\n\n  let betaPms = await waitUntil(\n    () => listPrivateMessages(beta),\n    p => p.private_messages[0].private_message.content === updatedContent,\n  );\n  expect(betaPms.private_messages[0].private_message.content).toBe(\n    updatedContent,\n  );\n});\n\ntest(\"Delete a private message\", async () => {\n  let pmRes = await createPrivateMessage(alpha, recipient_id);\n  let betaPms1 = await waitUntil(\n    () => listPrivateMessages(beta),\n    m =>\n      !!m.private_messages.find(\n        e =>\n          e.private_message.ap_id ===\n          pmRes.private_message_view.private_message.ap_id,\n      ),\n  );\n  let deletedPmRes = await deletePrivateMessage(\n    alpha,\n    true,\n    pmRes.private_message_view.private_message.id,\n  );\n  expect(deletedPmRes.private_message_view.private_message.deleted).toBe(true);\n\n  // The GetPrivateMessages filters out deleted,\n  // even though they are in the actual database.\n  // no reason to show them\n  let betaPms2 = await waitUntil(\n    () => listPrivateMessages(beta),\n    p => p.private_messages.length === betaPms1.private_messages.length - 1,\n  );\n  expect(betaPms2.private_messages.length).toBe(\n    betaPms1.private_messages.length - 1,\n  );\n\n  // Undelete\n  let undeletedPmRes = await deletePrivateMessage(\n    alpha,\n    false,\n    pmRes.private_message_view.private_message.id,\n  );\n  expect(undeletedPmRes.private_message_view.private_message.deleted).toBe(\n    false,\n  );\n\n  let betaPms3 = await waitUntil(\n    () => listPrivateMessages(beta),\n    p => p.private_messages.length === betaPms1.private_messages.length,\n  );\n  expect(betaPms3.private_messages.length).toBe(\n    betaPms1.private_messages.length,\n  );\n});\n\ntest(\"Create a private message report\", async () => {\n  let pmRes = await createPrivateMessage(alpha, recipient_id);\n  let betaPms1 = await waitUntil(\n    () => listPrivateMessages(beta),\n    m =>\n      !!m.private_messages.find(\n        e =>\n          e.private_message.ap_id ===\n          pmRes.private_message_view.private_message.ap_id,\n      ),\n  );\n  let betaPm = betaPms1.private_messages[0];\n  expect(betaPm).toBeDefined();\n\n  // Make sure that only the recipient can report it, so this should fail\n  await expect(\n    reportPrivateMessage(\n      alpha,\n      pmRes.private_message_view.private_message.id,\n      \"a reason\",\n    ),\n  ).rejects.toStrictEqual(Error(\"couldnt_create_report\"));\n\n  // This one should pass\n  let reason = \"another reason\";\n  let report = await reportPrivateMessage(\n    beta,\n    betaPm.private_message.id,\n    reason,\n  );\n\n  expect(report.private_message_report_view.private_message.id).toBe(\n    betaPm.private_message.id,\n  );\n  expect(report.private_message_report_view.private_message_report.reason).toBe(\n    reason,\n  );\n});\n", "import {\n  BlockCommunity,\n  BlockCommunityResponse,\n  BlockInstance,\n  BlockInstanceResponse,\n  CommunityId,\n  CreatePrivateMessageReport,\n  GetReplies,\n  GetRepliesResponse,\n  GetUnreadCountResponse,\n  InstanceId,\n  LemmyHttp,\n  PostView,\n  PrivateMessageReportResponse,\n  SuccessResponse,\n} from \"lemmy-js-client\";\nimport { CreatePost } from \"lemmy-js-client/dist/types/CreatePost\";\nimport { DeletePost } from \"lemmy-js-client/dist/types/DeletePost\";\nimport { EditPost } from \"lemmy-js-client/dist/types/EditPost\";\nimport { EditSite } from \"lemmy-js-client/dist/types/EditSite\";\nimport { FeaturePost } from \"lemmy-js-client/dist/types/FeaturePost\";\nimport { GetComments } from \"lemmy-js-client/dist/types/GetComments\";\nimport { GetCommentsResponse } from \"lemmy-js-client/dist/types/GetCommentsResponse\";\nimport { GetPost } from \"lemmy-js-client/dist/types/GetPost\";\nimport { GetPostResponse } from \"lemmy-js-client/dist/types/GetPostResponse\";\nimport { LockPost } from \"lemmy-js-client/dist/types/LockPost\";\nimport { Login } from \"lemmy-js-client/dist/types/Login\";\nimport { Post } from \"lemmy-js-client/dist/types/Post\";\nimport { PostResponse } from \"lemmy-js-client/dist/types/PostResponse\";\nimport { RemovePost } from \"lemmy-js-client/dist/types/RemovePost\";\nimport { ResolveObject } from \"lemmy-js-client/dist/types/ResolveObject\";\nimport { ResolveObjectResponse } from \"lemmy-js-client/dist/types/ResolveObjectResponse\";\nimport { Search } from \"lemmy-js-client/dist/types/Search\";\nimport { SearchResponse } from \"lemmy-js-client/dist/types/SearchResponse\";\nimport { Comment } from \"lemmy-js-client/dist/types/Comment\";\nimport { BanPersonResponse } from \"lemmy-js-client/dist/types/BanPersonResponse\";\nimport { BanPerson } from \"lemmy-js-client/dist/types/BanPerson\";\nimport { BanFromCommunityResponse } from \"lemmy-js-client/dist/types/BanFromCommunityResponse\";\nimport { BanFromCommunity } from \"lemmy-js-client/dist/types/BanFromCommunity\";\nimport { CommunityResponse } from \"lemmy-js-client/dist/types/CommunityResponse\";\nimport { FollowCommunity } from \"lemmy-js-client/dist/types/FollowCommunity\";\nimport { CreatePostLike } from \"lemmy-js-client/dist/types/CreatePostLike\";\nimport { CommentResponse } from \"lemmy-js-client/dist/types/CommentResponse\";\nimport { CreateComment } from \"lemmy-js-client/dist/types/CreateComment\";\nimport { EditComment } from \"lemmy-js-client/dist/types/EditComment\";\nimport { DeleteComment } from \"lemmy-js-client/dist/types/DeleteComment\";\nimport { RemoveComment } from \"lemmy-js-client/dist/types/RemoveComment\";\nimport { GetPersonMentionsResponse } from \"lemmy-js-client/dist/types/GetPersonMentionsResponse\";\nimport { GetPersonMentions } from \"lemmy-js-client/dist/types/GetPersonMentions\";\nimport { CreateCommentLike } from \"lemmy-js-client/dist/types/CreateCommentLike\";\nimport { CreateCommunity } from \"lemmy-js-client/dist/types/CreateCommunity\";\nimport { GetCommunity } from \"lemmy-js-client/dist/types/GetCommunity\";\nimport { DeleteCommunity } from \"lemmy-js-client/dist/types/DeleteCommunity\";\nimport { RemoveCommunity } from \"lemmy-js-client/dist/types/RemoveCommunity\";\nimport { PrivateMessageResponse } from \"lemmy-js-client/dist/types/PrivateMessageResponse\";\nimport { CreatePrivateMessage } from \"lemmy-js-client/dist/types/CreatePrivateMessage\";\nimport { EditPrivateMessage } from \"lemmy-js-client/dist/types/EditPrivateMessage\";\nimport { DeletePrivateMessage } from \"lemmy-js-client/dist/types/DeletePrivateMessage\";\nimport { LoginResponse } from \"lemmy-js-client/dist/types/LoginResponse\";\nimport { Register } from \"lemmy-js-client/dist/types/Register\";\nimport { SaveUserSettings } from \"lemmy-js-client/dist/types/SaveUserSettings\";\nimport { DeleteAccount } from \"lemmy-js-client/dist/types/DeleteAccount\";\nimport { GetSiteResponse } from \"lemmy-js-client/dist/types/GetSiteResponse\";\nimport { PrivateMessagesResponse } from \"lemmy-js-client/dist/types/PrivateMessagesResponse\";\nimport { GetPrivateMessages } from \"lemmy-js-client/dist/types/GetPrivateMessages\";\nimport { PostReportResponse } from \"lemmy-js-client/dist/types/PostReportResponse\";\nimport { CreatePostReport } from \"lemmy-js-client/dist/types/CreatePostReport\";\nimport { ListPostReportsResponse } from \"lemmy-js-client/dist/types/ListPostReportsResponse\";\nimport { ListPostReports } from \"lemmy-js-client/dist/types/ListPostReports\";\nimport { CommentReportResponse } from \"lemmy-js-client/dist/types/CommentReportResponse\";\nimport { CreateCommentReport } from \"lemmy-js-client/dist/types/CreateCommentReport\";\nimport { ListCommentReportsResponse } from \"lemmy-js-client/dist/types/ListCommentReportsResponse\";\nimport { ListCommentReports } from \"lemmy-js-client/dist/types/ListCommentReports\";\nimport { GetPostsResponse } from \"lemmy-js-client/dist/types/GetPostsResponse\";\nimport { GetPosts } from \"lemmy-js-client/dist/types/GetPosts\";\nimport { GetPersonDetailsResponse } from \"lemmy-js-client/dist/types/GetPersonDetailsResponse\";\nimport { GetPersonDetails } from \"lemmy-js-client/dist/types/GetPersonDetails\";\nimport { ListingType } from \"lemmy-js-client/dist/types/ListingType\";\n\nexport const fetchFunction = fetch;\n\nexport let alphaUrl = \"http://127.0.0.1:8541\";\nexport let betaUrl = \"http://127.0.0.1:8551\";\nexport let gammaUrl = \"http://127.0.0.1:8561\";\nexport let deltaUrl = \"http://127.0.0.1:8571\";\nexport let epsilonUrl = \"http://127.0.0.1:8581\";\n\nexport let alpha = new LemmyHttp(alphaUrl, { fetchFunction });\nexport let alphaImage = new LemmyHttp(alphaUrl);\nexport let beta = new LemmyHttp(betaUrl, { fetchFunction });\nexport let gamma = new LemmyHttp(gammaUrl, { fetchFunction });\nexport let delta = new LemmyHttp(deltaUrl, { fetchFunction });\nexport let epsilon = new LemmyHttp(epsilonUrl, { fetchFunction });\n\nexport let betaAllowedInstances = [\n  \"lemmy-alpha\",\n  \"lemmy-gamma\",\n  \"lemmy-delta\",\n  \"lemmy-epsilon\",\n];\n\nconst password = \"lemmylemmy\";\n\nexport async function setupLogins() {\n  let formAlpha: Login = {\n    username_or_email: \"lemmy_alpha\",\n    password,\n  };\n  let resAlpha = alpha.login(formAlpha);\n\n  let formBeta: Login = {\n    username_or_email: \"lemmy_beta\",\n    password,\n  };\n  let resBeta = beta.login(formBeta);\n\n  let formGamma: Login = {\n    username_or_email: \"lemmy_gamma\",\n    password,\n  };\n  let resGamma = gamma.login(formGamma);\n\n  let formDelta: Login = {\n    username_or_email: \"lemmy_delta\",\n    password,\n  };\n  let resDelta = delta.login(formDelta);\n\n  let formEpsilon: Login = {\n    username_or_email: \"lemmy_epsilon\",\n    password,\n  };\n  let resEpsilon = epsilon.login(formEpsilon);\n\n  let res = await Promise.all([\n    resAlpha,\n    resBeta,\n    resGamma,\n    resDelta,\n    resEpsilon,\n  ]);\n  alpha.setHeaders({ Authorization: `Bearer ${res[0].jwt ?? \"\"}` });\n  alphaImage.setHeaders({ Authorization: `Bearer ${res[0].jwt ?? \"\"}` });\n  beta.setHeaders({ Authorization: `Bearer ${res[1].jwt ?? \"\"}` });\n  gamma.setHeaders({ Authorization: `Bearer ${res[2].jwt ?? \"\"}` });\n  delta.setHeaders({ Authorization: `Bearer ${res[3].jwt ?? \"\"}` });\n  epsilon.setHeaders({ Authorization: `Bearer ${res[4].jwt ?? \"\"}` });\n\n  // Registration applications are now enabled by default, need to disable them\n  let editSiteForm: EditSite = {\n    registration_mode: \"Open\",\n    rate_limit_message: 999,\n    rate_limit_post: 999,\n    rate_limit_register: 999,\n    rate_limit_image: 999,\n    rate_limit_comment: 999,\n    rate_limit_search: 999,\n  };\n\n  // Set the blocks and auths for each\n  editSiteForm.allowed_instances = [\n    \"lemmy-beta\",\n    \"lemmy-gamma\",\n    \"lemmy-delta\",\n    \"lemmy-epsilon\",\n  ];\n  await alpha.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = betaAllowedInstances;\n  await beta.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = [\n    \"lemmy-alpha\",\n    \"lemmy-beta\",\n    \"lemmy-delta\",\n    \"lemmy-epsilon\",\n  ];\n  await gamma.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = [\"lemmy-beta\"];\n  await delta.editSite(editSiteForm);\n\n  editSiteForm.allowed_instances = [];\n  editSiteForm.blocked_instances = [\"lemmy-alpha\"];\n  await epsilon.editSite(editSiteForm);\n\n  // Create the main alpha/beta communities\n  // Ignore thrown errors of duplicates\n  try {\n    await createCommunity(alpha, \"main\");\n    await createCommunity(beta, \"main\");\n    // wait for > INSTANCES_RECHECK_DELAY to ensure federation is initialized\n    // otherwise the first few federated events may be missed\n    // (because last_successful_id is set to current id when federation to an instance is first started)\n    // only needed the first time so do in this try\n    await delay(10_000);\n  } catch (_) {\n    console.log(\"Communities already exist\");\n  }\n}\n\nexport async function createPost(\n  api: LemmyHttp,\n  community_id: number,\n  // use example.com for consistent title and embed description\n  url: string = \"https://example.com/\",\n): Promise<PostResponse> {\n  let name = randomString(5);\n  let body = randomString(10);\n  let form: CreatePost = {\n    name,\n    url,\n    body,\n    community_id,\n  };\n  return api.createPost(form);\n}\n\nexport async function editPost(\n  api: LemmyHttp,\n  post: Post,\n): Promise<PostResponse> {\n  let name = \"A jest test federated post, updated\";\n  let form: EditPost = {\n    name,\n    post_id: post.id,\n  };\n  return api.editPost(form);\n}\n\nexport async function deletePost(\n  api: LemmyHttp,\n  deleted: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: DeletePost = {\n    post_id: post.id,\n    deleted: deleted,\n  };\n  return api.deletePost(form);\n}\n\nexport async function removePost(\n  api: LemmyHttp,\n  removed: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: RemovePost = {\n    post_id: post.id,\n    removed,\n  };\n  return api.removePost(form);\n}\n\nexport async function featurePost(\n  api: LemmyHttp,\n  featured: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: FeaturePost = {\n    post_id: post.id,\n    featured,\n    feature_type: \"Community\",\n  };\n  return api.featurePost(form);\n}\n\nexport async function lockPost(\n  api: LemmyHttp,\n  locked: boolean,\n  post: Post,\n): Promise<PostResponse> {\n  let form: LockPost = {\n    post_id: post.id,\n    locked,\n  };\n  return api.lockPost(form);\n}\n\nexport async function resolvePost(\n  api: LemmyHttp,\n  post: Post,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q: post.ap_id,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function searchPostLocal(\n  api: LemmyHttp,\n  post: Post,\n): Promise<SearchResponse> {\n  let form: Search = {\n    q: post.name,\n    type_: \"Posts\",\n    sort: \"TopAll\",\n    listing_type: \"All\",\n  };\n  return api.search(form);\n}\n\n/// wait for a post to appear locally without pulling it\nexport async function waitForPost(\n  api: LemmyHttp,\n  post: Post,\n  checker: (t: PostView | undefined) => boolean = p => !!p,\n) {\n  return waitUntil<PostView>(\n    () => searchPostLocal(api, post).then(p => p.posts[0]),\n    checker,\n  );\n}\n\nexport async function getPost(\n  api: LemmyHttp,\n  post_id: number,\n): Promise<GetPostResponse> {\n  let form: GetPost = {\n    id: post_id,\n  };\n  return api.getPost(form);\n}\n\nexport async function getComments(\n  api: LemmyHttp,\n  post_id?: number,\n  listingType: ListingType = \"All\",\n): Promise<GetCommentsResponse> {\n  let form: GetComments = {\n    post_id: post_id,\n    type_: listingType,\n    sort: \"New\",\n    limit: 50,\n  };\n  return api.getComments(form);\n}\n\nexport async function getUnreadCount(\n  api: LemmyHttp,\n): Promise<GetUnreadCountResponse> {\n  return api.getUnreadCount();\n}\n\nexport async function getReplies(api: LemmyHttp): Promise<GetRepliesResponse> {\n  let form: GetReplies = {\n    sort: \"New\",\n    unread_only: false,\n  };\n  return api.getReplies(form);\n}\n\nexport async function resolveComment(\n  api: LemmyHttp,\n  comment: Comment,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q: comment.ap_id,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function resolveBetaCommunity(\n  api: LemmyHttp,\n): Promise<ResolveObjectResponse> {\n  // Use short-hand search url\n  let form: ResolveObject = {\n    q: \"!main@lemmy-beta:8551\",\n  };\n  return api.resolveObject(form);\n}\n\nexport async function resolveCommunity(\n  api: LemmyHttp,\n  q: string,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function resolvePerson(\n  api: LemmyHttp,\n  apShortname: string,\n): Promise<ResolveObjectResponse> {\n  let form: ResolveObject = {\n    q: apShortname,\n  };\n  return api.resolveObject(form);\n}\n\nexport async function banPersonFromSite(\n  api: LemmyHttp,\n  person_id: number,\n  ban: boolean,\n  remove_data: boolean,\n): Promise<BanPersonResponse> {\n  // Make sure lemmy-beta/c/main is cached on lemmy_alpha\n  let form: BanPerson = {\n    person_id,\n    ban,\n    remove_data: remove_data,\n  };\n  return api.banPerson(form);\n}\n\nexport async function banPersonFromCommunity(\n  api: LemmyHttp,\n  person_id: number,\n  community_id: number,\n  remove_data: boolean,\n  ban: boolean,\n): Promise<BanFromCommunityResponse> {\n  let form: BanFromCommunity = {\n    person_id,\n    community_id,\n    remove_data: remove_data,\n    ban,\n  };\n  return api.banFromCommunity(form);\n}\n\nexport async function followCommunity(\n  api: LemmyHttp,\n  follow: boolean,\n  community_id: number,\n): Promise<CommunityResponse> {\n  let form: FollowCommunity = {\n    community_id,\n    follow,\n  };\n  const res = await api.followCommunity(form);\n  await waitUntil(\n    () => getCommunity(api, res.community_view.community.id),\n    g =>\n      g.community_view.subscribed === (follow ? \"Subscribed\" : \"NotSubscribed\"),\n  );\n  // wait FOLLOW_ADDITIONS_RECHECK_DELAY (there's no API to wait for this currently)\n  await delay(2000);\n  return res;\n}\n\nexport async function likePost(\n  api: LemmyHttp,\n  score: number,\n  post: Post,\n): Promise<PostResponse> {\n  let form: CreatePostLike = {\n    post_id: post.id,\n    score: score,\n  };\n\n  return api.likePost(form);\n}\n\nexport async function createComment(\n  api: LemmyHttp,\n  post_id: number,\n  parent_id?: number,\n  content = \"a jest test comment\",\n): Promise<CommentResponse> {\n  let form: CreateComment = {\n    content,\n    post_id,\n    parent_id,\n  };\n  return api.createComment(form);\n}\n\nexport async function editComment(\n  api: LemmyHttp,\n  comment_id: number,\n  content = \"A jest test federated comment update\",\n): Promise<CommentResponse> {\n  let form: EditComment = {\n    content,\n    comment_id,\n  };\n  return api.editComment(form);\n}\n\nexport async function deleteComment(\n  api: LemmyHttp,\n  deleted: boolean,\n  comment_id: number,\n): Promise<CommentResponse> {\n  let form: DeleteComment = {\n    comment_id,\n    deleted,\n  };\n  return api.deleteComment(form);\n}\n\nexport async function removeComment(\n  api: LemmyHttp,\n  removed: boolean,\n  comment_id: number,\n): Promise<CommentResponse> {\n  let form: RemoveComment = {\n    comment_id,\n    removed,\n  };\n  return api.removeComment(form);\n}\n\nexport async function getMentions(\n  api: LemmyHttp,\n): Promise<GetPersonMentionsResponse> {\n  let form: GetPersonMentions = {\n    sort: \"New\",\n    unread_only: false,\n  };\n  return api.getPersonMentions(form);\n}\n\nexport async function likeComment(\n  api: LemmyHttp,\n  score: number,\n  comment: Comment,\n): Promise<CommentResponse> {\n  let form: CreateCommentLike = {\n    comment_id: comment.id,\n    score,\n  };\n  return api.likeComment(form);\n}\n\nexport async function createCommunity(\n  api: LemmyHttp,\n  name_: string = randomString(5),\n): Promise<CommunityResponse> {\n  let description = \"a sample description\";\n  let form: CreateCommunity = {\n    name: name_,\n    title: name_,\n    description,\n  };\n  return api.createCommunity(form);\n}\n\nexport async function getCommunity(\n  api: LemmyHttp,\n  id: number,\n): Promise<CommunityResponse> {\n  let form: GetCommunity = {\n    id,\n  };\n  return api.getCommunity(form);\n}\n\nexport async function getCommunityByName(\n  api: LemmyHttp,\n  name: string,\n): Promise<CommunityResponse> {\n  let form: GetCommunity = {\n    name,\n  };\n  return api.getCommunity(form);\n}\n\nexport async function deleteCommunity(\n  api: LemmyHttp,\n  deleted: boolean,\n  community_id: number,\n): Promise<CommunityResponse> {\n  let form: DeleteCommunity = {\n    community_id,\n    deleted,\n  };\n  return api.deleteCommunity(form);\n}\n\nexport async function removeCommunity(\n  api: LemmyHttp,\n  removed: boolean,\n  community_id: number,\n): Promise<CommunityResponse> {\n  let form: RemoveCommunity = {\n    community_id,\n    removed,\n  };\n  return api.removeCommunity(form);\n}\n\nexport async function createPrivateMessage(\n  api: LemmyHttp,\n  recipient_id: number,\n): Promise<PrivateMessageResponse> {\n  let content = \"A jest test federated private message\";\n  let form: CreatePrivateMessage = {\n    content,\n    recipient_id,\n  };\n  return api.createPrivateMessage(form);\n}\n\nexport async function editPrivateMessage(\n  api: LemmyHttp,\n  private_message_id: number,\n): Promise<PrivateMessageResponse> {\n  let updatedContent = \"A jest test federated private message edited\";\n  let form: EditPrivateMessage = {\n    content: updatedContent,\n    private_message_id,\n  };\n  return api.editPrivateMessage(form);\n}\n\nexport async function deletePrivateMessage(\n  api: LemmyHttp,\n  deleted: boolean,\n  private_message_id: number,\n): Promise<PrivateMessageResponse> {\n  let form: DeletePrivateMessage = {\n    deleted,\n    private_message_id,\n  };\n  return api.deletePrivateMessage(form);\n}\n\nexport async function registerUser(\n  api: LemmyHttp,\n  url: string,\n  username: string = randomString(5),\n): Promise<LemmyHttp> {\n  let form: Register = {\n    username,\n    password,\n    password_verify: password,\n    show_nsfw: true,\n  };\n  let login_response = await api.register(form);\n\n  expect(login_response.jwt).toBeDefined();\n  let lemmy_http = new LemmyHttp(url, {\n    headers: { Authorization: `Bearer ${login_response.jwt ?? \"\"}` },\n  });\n  return lemmy_http;\n}\n\nexport async function loginUser(\n  api: LemmyHttp,\n  username: string,\n): Promise<LoginResponse> {\n  let form: Login = {\n    username_or_email: username,\n    password: password,\n  };\n  return api.login(form);\n}\n\nexport async function saveUserSettingsBio(\n  api: LemmyHttp,\n): Promise<SuccessResponse> {\n  let form: SaveUserSettings = {\n    show_nsfw: true,\n    blur_nsfw: false,\n    auto_expand: true,\n    theme: \"darkly\",\n    default_sort_type: \"Active\",\n    default_listing_type: \"All\",\n    interface_language: \"en\",\n    show_avatars: true,\n    send_notifications_to_email: false,\n    bio: \"a changed bio\",\n  };\n  return saveUserSettings(api, form);\n}\n\nexport async function saveUserSettingsFederated(\n  api: LemmyHttp,\n): Promise<SuccessResponse> {\n  let avatar = \"https://image.flaticon.com/icons/png/512/35/35896.png\";\n  let banner = \"https://image.flaticon.com/icons/png/512/36/35896.png\";\n  let bio = \"a changed bio\";\n  let form: SaveUserSettings = {\n    show_nsfw: false,\n    blur_nsfw: true,\n    auto_expand: false,\n    default_sort_type: \"Hot\",\n    default_listing_type: \"All\",\n    interface_language: \"\",\n    avatar,\n    banner,\n    display_name: \"user321\",\n    show_avatars: false,\n    send_notifications_to_email: false,\n    bio,\n  };\n  return await saveUserSettings(api, form);\n}\n\nexport async function saveUserSettings(\n  api: LemmyHttp,\n  form: SaveUserSettings,\n): Promise<SuccessResponse> {\n  return api.saveUserSettings(form);\n}\nexport async function getPersonDetails(\n  api: LemmyHttp,\n  person_id: number,\n): Promise<GetPersonDetailsResponse> {\n  let form: GetPersonDetails = {\n    person_id: person_id,\n  };\n  return api.getPersonDetails(form);\n}\n\nexport async function deleteUser(api: LemmyHttp): Promise<SuccessResponse> {\n  let form: DeleteAccount = {\n    delete_content: true,\n    password,\n  };\n  return api.deleteAccount(form);\n}\n\nexport async function getSite(api: LemmyHttp): Promise<GetSiteResponse> {\n  return api.getSite();\n}\n\nexport async function listPrivateMessages(\n  api: LemmyHttp,\n): Promise<PrivateMessagesResponse> {\n  let form: GetPrivateMessages = {\n    unread_only: false,\n  };\n  return api.getPrivateMessages(form);\n}\n\nexport async function unfollowRemotes(\n  api: LemmyHttp,\n): Promise<GetSiteResponse> {\n  // Unfollow all remote communities\n  let site = await getSite(api);\n  let remoteFollowed =\n    site.my_user?.follows.filter(c => c.community.local == false) ?? [];\n  await Promise.all(\n    remoteFollowed.map(cu => followCommunity(api, false, cu.community.id)),\n  );\n  let siteRes = await getSite(api);\n  return siteRes;\n}\n\nexport async function followBeta(api: LemmyHttp): Promise<CommunityResponse> {\n  let betaCommunity = (await resolveBetaCommunity(api)).community;\n  if (betaCommunity) {\n    let follow = await followCommunity(api, true, betaCommunity.community.id);\n    return follow;\n  } else {\n    return Promise.reject(\"no community worked\");\n  }\n}\n\nexport async function reportPost(\n  api: LemmyHttp,\n  post_id: number,\n  reason: string,\n): Promise<PostReportResponse> {\n  let form: CreatePostReport = {\n    post_id,\n    reason,\n  };\n  return api.createPostReport(form);\n}\n\nexport async function listPostReports(\n  api: LemmyHttp,\n): Promise<ListPostReportsResponse> {\n  let form: ListPostReports = {};\n  return api.listPostReports(form);\n}\n\nexport async function reportComment(\n  api: LemmyHttp,\n  comment_id: number,\n  reason: string,\n): Promise<CommentReportResponse> {\n  let form: CreateCommentReport = {\n    comment_id,\n    reason,\n  };\n  return api.createCommentReport(form);\n}\n\nexport async function reportPrivateMessage(\n  api: LemmyHttp,\n  private_message_id: number,\n  reason: string,\n): Promise<PrivateMessageReportResponse> {\n  let form: CreatePrivateMessageReport = {\n    private_message_id,\n    reason,\n  };\n  return api.createPrivateMessageReport(form);\n}\n\nexport async function listCommentReports(\n  api: LemmyHttp,\n): Promise<ListCommentReportsResponse> {\n  let form: ListCommentReports = {};\n  return api.listCommentReports(form);\n}\n\nexport function getPosts(\n  api: LemmyHttp,\n  listingType?: ListingType,\n): Promise<GetPostsResponse> {\n  let form: GetPosts = {\n    type_: listingType,\n    limit: 50,\n  };\n  return api.getPosts(form);\n}\n\nexport function blockInstance(\n  api: LemmyHttp,\n  instance_id: InstanceId,\n  block: boolean,\n): Promise<BlockInstanceResponse> {\n  let form: BlockInstance = {\n    instance_id,\n    block,\n  };\n  return api.blockInstance(form);\n}\n\nexport function blockCommunity(\n  api: LemmyHttp,\n  community_id: CommunityId,\n  block: boolean,\n): Promise<BlockCommunityResponse> {\n  let form: BlockCommunity = {\n    community_id,\n    block,\n  };\n  return api.blockCommunity(form);\n}\n\nexport function delay(millis = 500) {\n  return new Promise(resolve => setTimeout(resolve, millis));\n}\n\nexport function longDelay() {\n  return delay(10000);\n}\n\nexport function wrapper(form: any): string {\n  return JSON.stringify(form);\n}\n\nexport function randomString(length: number): string {\n  var result = \"\";\n  var characters =\n    \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_\";\n  var charactersLength = characters.length;\n  for (var i = 0; i < length; i++) {\n    result += characters.charAt(Math.floor(Math.random() * charactersLength));\n  }\n  return result;\n}\n\nexport async function unfollows() {\n  await Promise.all([\n    unfollowRemotes(alpha),\n    unfollowRemotes(gamma),\n    unfollowRemotes(delta),\n    unfollowRemotes(epsilon),\n  ]);\n}\n\nexport function getCommentParentId(comment: Comment): number | undefined {\n  let split = comment.path.split(\".\");\n  // remove the 0\n  split.shift();\n\n  if (split.length > 1) {\n    return Number(split[split.length - 2]);\n  } else {\n    console.log(`Failed to extract comment parent id from ${comment.path}`);\n    return undefined;\n  }\n}\n\nexport async function waitUntil<T>(\n  fetcher: () => Promise<T>,\n  checker: (t: T) => boolean,\n  retries = 10,\n  delaySeconds = [0.2, 0.5, 1, 2, 3],\n) {\n  let retry = 0;\n  let result;\n  while (retry++ < retries) {\n    result = await fetcher();\n    if (checker(result)) return result;\n    await delay(\n      delaySeconds[Math.min(retry - 1, delaySeconds.length - 1)] * 1000,\n    );\n  }\n  console.error(\"result\", result);\n  throw Error(\n    `Failed \"${fetcher}\": \"${checker}\" did not return true after ${retries} retries (delayed ${delaySeconds}s each)`,\n  );\n}\n", "use crate::check_report_reason;\nuse actix_web::web::{Data, Json};\nuse lemmy_api_common::{\n  context::LemmyContext,\n  private_message::{CreatePrivateMessageReport, PrivateMessageReportResponse},\n  utils::send_new_report_email_to_admins,\n};\nuse lemmy_db_schema::{\n  source::{\n    local_site::LocalSite,\n    private_message::PrivateMessage,\n    private_message_report::{PrivateMessageReport, PrivateMessageReportForm},\n  },\n  traits::{Crud, Reportable},\n};\nuse lemmy_db_views::structs::{LocalUserView, PrivateMessageReportView};\nuse lemmy_utils::error::{LemmyError, LemmyErrorExt, LemmyErrorType};\n\n#[tracing::instrument(skip(context))]\npub async fn create_pm_report(\n  data: Json<CreatePrivateMessageReport>,\n  context: Data<LemmyContext>,\n  local_user_view: LocalUserView,\n) -> Result<Json<PrivateMessageReportResponse>, LemmyError> {\n  let local_site = LocalSite::read(&mut context.pool()).await?;\n\n  let reason = data.reason.trim().to_string();\n  check_report_reason(&reason, &local_site)?;\n\n  let person_id = local_user_view.person.id;\n  let private_message_id = data.private_message_id;\n  let private_message = PrivateMessage::read(&mut context.pool(), private_message_id).await?;\n\n  // Make sure that only the recipient of the private message can create a report\n  if person_id != private_message.recipient_id {\n    Err(LemmyErrorType::CouldntCreateReport)?\n  }\n\n  let report_form = PrivateMessageReportForm {\n    creator_id: person_id,\n    private_message_id,\n    original_pm_text: private_message.content,\n    reason,\n  };\n\n  let report = PrivateMessageReport::report(&mut context.pool(), &report_form)\n    .await\n    .with_lemmy_type(LemmyErrorType::CouldntCreateReport)?;\n\n  let private_message_report_view =\n    PrivateMessageReportView::read(&mut context.pool(), report.id).await?;\n\n  // Email the admins\n  if local_site.reports_email_admins {\n    send_new_report_email_to_admins(\n      &private_message_report_view.creator.name,\n      &private_message_report_view.private_message_creator.name,\n      &mut context.pool(),\n      context.settings(),\n    )\n    .await?;\n  }\n\n  // TODO: consider federating this\n\n  Ok(Json(PrivateMessageReportResponse {\n    private_message_report_view,\n  }))\n}\n"], "filenames": ["api_tests/prepare-drone-federation-test.sh", "api_tests/src/private_message.spec.ts", "api_tests/src/shared.ts", "crates/api/src/private_message_report/create.rs"], "buggy_code_start_loc": [12, 12, 6, 33], "buggy_code_end_loc": [13, 111, 783, 33], "fixing_code_start_loc": [12, 13, 7, 34], "fixing_code_end_loc": [13, 152, 798, 39], "type": "NVD-CWE-noinfo", "message": "Lemmy is a link aggregator and forum for the fediverse. Starting in version 0.17.0 and prior to version 0.19.1, users can report private messages, even when they're neither sender nor recipient of the message. The API response to creating a private message report contains the private message itself, which means any user can just iterate over message ids to (loudly) obtain all private messages of an instance. A user with instance admin privileges can also abuse this if the private message is removed from the response, as they're able to see the resulting reports.\n\nCreating a private message report by POSTing to `/api/v3/private_message/report` does not validate whether the reporter is the recipient of the message. lemmy-ui does not allow the sender to report the message; the API method should likely be restricted to accessible to recipients only. The API response when creating a report contains the `private_message_report_view` with all the details of the report, including the private message that has been reported:\n\nAny authenticated user can obtain arbitrary (untargeted) private message contents. Privileges required depend on the instance configuration; when registrations are enabled without application system, the privileges required are practically none. When registration applications are required, privileges required could be considered low, but this assessment heavily varies by instance.\n\nVersion 0.19.1 contains a patch for this issue. A workaround is available. If an update to a fixed Lemmy version is not immediately possible, the API route can be blocked in the reverse proxy. This will prevent anyone from reporting private messages, but it will also prevent exploitation before the update has been applied.", "other": {"cve": {"id": "CVE-2024-23649", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-24T18:15:09.103", "lastModified": "2024-02-02T15:46:30.623", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Lemmy is a link aggregator and forum for the fediverse. Starting in version 0.17.0 and prior to version 0.19.1, users can report private messages, even when they're neither sender nor recipient of the message. The API response to creating a private message report contains the private message itself, which means any user can just iterate over message ids to (loudly) obtain all private messages of an instance. A user with instance admin privileges can also abuse this if the private message is removed from the response, as they're able to see the resulting reports.\n\nCreating a private message report by POSTing to `/api/v3/private_message/report` does not validate whether the reporter is the recipient of the message. lemmy-ui does not allow the sender to report the message; the API method should likely be restricted to accessible to recipients only. The API response when creating a report contains the `private_message_report_view` with all the details of the report, including the private message that has been reported:\n\nAny authenticated user can obtain arbitrary (untargeted) private message contents. Privileges required depend on the instance configuration; when registrations are enabled without application system, the privileges required are practically none. When registration applications are required, privileges required could be considered low, but this assessment heavily varies by instance.\n\nVersion 0.19.1 contains a patch for this issue. A workaround is available. If an update to a fixed Lemmy version is not immediately possible, the API route can be blocked in the reverse proxy. This will prevent anyone from reporting private messages, but it will also prevent exploitation before the update has been applied."}, {"lang": "es", "value": "Lemmy es un agregador de enlaces y un foro para la diversidad. A partir de la versi\u00f3n 0.17.0 y anteriores a la versi\u00f3n 0.19.1, los usuarios pueden reportar mensajes privados, incluso cuando no son ni el remitente ni el destinatario del mensaje. La respuesta de la API para crear un informe de mensajes privados contiene el mensaje privado en s\u00ed, lo que significa que cualquier usuario puede simplemente iterar sobre los ID de los mensajes para obtener (en voz alta) todos los mensajes privados de una instancia. Un usuario con privilegios de administrador de instancias tambi\u00e9n puede abusar de esto si el mensaje privado se elimina de la respuesta, ya que puede ver los informes resultantes. La creaci\u00f3n de un informe de mensaje privado mediante PUBLICACI\u00d3N en `/api/v3/private_message/report` no valida si el informante es el destinatario del mensaje. lemmy-ui no permite que el remitente informe el mensaje; Es probable que el m\u00e9todo API deba estar restringido al acceso \u00fanicamente a los destinatarios. La respuesta de la API al crear un informe contiene `private_message_report_view` con todos los detalles del informe, incluido el mensaje privado que se ha informado: cualquier usuario autenticado puede obtener contenidos de mensajes privados arbitrarios (no dirigidos). Los privilegios necesarios dependen de la configuraci\u00f3n de la instancia; cuando los registros se habilitan sin sistema de aplicaci\u00f3n, los privilegios requeridos son pr\u00e1cticamente nulos. Cuando se requieren solicitudes de registro, los privilegios requeridos podr\u00edan considerarse bajos, pero esta evaluaci\u00f3n var\u00eda mucho seg\u00fan el caso. La versi\u00f3n 0.19.1 contiene un parche para este problema. Hay una soluci\u00f3n disponible. Si no es posible actualizar inmediatamente a una versi\u00f3n fija de Lemmy, la ruta API se puede bloquear en el proxy inverso. Esto evitar\u00e1 que alguien denuncie mensajes privados, pero tambi\u00e9n evitar\u00e1 la explotaci\u00f3n antes de que se haya aplicado la actualizaci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}, {"lang": "en", "value": "CWE-285"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:join-lemmy:lemmy:*:*:*:*:*:rust:*:*", "versionStartIncluding": "0.17.0", "versionEndExcluding": "0.19.1", "matchCriteriaId": "934C8D15-0F2A-42C0-B574-D350377870B4"}]}]}], "references": [{"url": "https://github.com/LemmyNet/lemmy/commit/bc32b408b523b9b64aa57b8e47748f96cce0dae5", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/LemmyNet/lemmy/security/advisories/GHSA-r64r-5h43-26qv", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/LemmyNet/lemmy/commit/bc32b408b523b9b64aa57b8e47748f96cce0dae5"}}