{"buggy_code": ["package middleware\n\nimport (\n\t\"errors\"\n\tjwt \"github.com/appleboy/gin-jwt/v2\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/px-org/PanIndex/module\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\tLoginTimeOut = 24 * 365\n\tidentityKey  = \"id\"\n)\n\nfunc JWTMiddlewar() (*jwt.GinJWTMiddleware, error) {\n\tauthMiddleware, err := jwt.New(&jwt.GinJWTMiddleware{\n\t\tRealm:       \"PanIndex Zone\",\n\t\tKey:         []byte(\"PanIndex\"),\n\t\tTimeout:     (time.Duration(LoginTimeOut)) * time.Hour,\n\t\tMaxRefresh:  (time.Duration(LoginTimeOut)) * time.Hour,\n\t\tIdentityKey: identityKey,\n\t\tPayloadFunc: func(data interface{}) jwt.MapClaims {\n\t\t\tif v, ok := data.(*User); ok {\n\t\t\t\treturn jwt.MapClaims{\n\t\t\t\t\tidentityKey: v.UserName,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn jwt.MapClaims{}\n\t\t},\n\t\tIdentityHandler: func(c *gin.Context) interface{} {\n\t\t\tclaims := jwt.ExtractClaims(c)\n\t\t\treturn &User{\n\t\t\t\tUserName: claims[identityKey].(string),\n\t\t\t}\n\t\t},\n\t\tAuthenticator: func(c *gin.Context) (interface{}, error) {\n\t\t\tvar loginVals Login\n\t\t\tif err := c.ShouldBind(&loginVals); err != nil {\n\t\t\t\treturn \"\", jwt.ErrMissingLoginValues\n\t\t\t}\n\t\t\tpassword := loginVals.Password\n\t\t\tuser := loginVals.User\n\t\t\tif user == module.GloablConfig.AdminUser &&\n\t\t\t\tpassword == module.GloablConfig.AdminPassword {\n\t\t\t\treturn &User{\n\t\t\t\t\tUserName: module.GloablConfig.AdminUser,\n\t\t\t\t}, nil\n\t\t\t}\n\n\t\t\treturn nil, errors.New(\"\u5bc6\u7801\u9519\u8bef\uff01\u8bf7\u91cd\u8bd5\")\n\t\t},\n\t\tAuthorizator: func(data interface{}, c *gin.Context) bool {\n\t\t\tif v, ok := data.(*User); ok && v.UserName == module.GloablConfig.AdminUser {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t},\n\t\tLoginResponse: func(c *gin.Context, code int, token string, expire time.Time) {\n\t\t\t//c.Redirect(http.StatusFound, module.GloablConfig.AdminPath+\"/common\")\n\t\t\treferer := c.Request.Header.Get(\"Referer\")\n\t\t\tu, _ := url.Parse(referer)\n\t\t\tif strings.HasPrefix(u.Path, module.GloablConfig.AdminPath) {\n\t\t\t\tc.Redirect(http.StatusFound, module.GloablConfig.AdminPath+\"/common\")\n\t\t\t} else {\n\t\t\t\tc.Redirect(http.StatusFound, c.Request.Header.Get(\"Referer\"))\n\t\t\t}\n\t\t},\n\t\tLogoutResponse: func(c *gin.Context, code int) {\n\t\t\tThemeCheck(c)\n\t\t\ttheme := c.GetString(\"theme\")\n\t\t\tc.HTML(http.StatusOK, \"templates/pan/admin/login.html\", gin.H{\n\t\t\t\t\"error\":        true,\n\t\t\t\t\"msg\":          \"\u9000\u51fa\u6210\u529f\",\n\t\t\t\t\"redirect_url\": \"login\",\n\t\t\t\t\"config\":       module.GloablConfig,\n\t\t\t\t\"theme\":        theme,\n\t\t\t})\n\t\t},\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tpath := c.Request.RequestURI\n\t\t\tif strings.HasPrefix(path, \"/api\") {\n\t\t\t\t//api return json\n\t\t\t\tc.JSON(code, gin.H{\n\t\t\t\t\t\"status\": code,\n\t\t\t\t\t\"msg\":    message,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t//return to login\n\t\t\t\tdata := gin.H{\n\t\t\t\t\t\"error\":        true,\n\t\t\t\t\t\"msg\":          message,\n\t\t\t\t\t\"redirect_url\": \"login\",\n\t\t\t\t\t\"config\":       module.GloablConfig,\n\t\t\t\t\t\"theme\":        module.GloablConfig.Theme,\n\t\t\t\t}\n\t\t\t\tif message == \"cookie token is empty\" {\n\t\t\t\t\tdata[\"error\"] = false\n\t\t\t\t\tdata[\"msg\"] = \"\"\n\t\t\t\t}\n\t\t\t\tc.HTML(http.StatusOK, \"templates/pan/admin/login.html\", data)\n\t\t\t}\n\t\t},\n\t\tSendCookie:     true,\n\t\tSecureCookie:   false,   //non HTTPS dev environments\n\t\tCookieHTTPOnly: true,    // JS can't modify\n\t\tCookieName:     \"token\", // default jwt\n\t\tTokenLookup:    \"header: Authorization, cookie: token\",\n\t\tCookieSameSite: http.SameSiteDefaultMode, //SameSiteDefaultMode, SameSiteLaxMode, SameSiteStrictMode, SameSiteNoneMode\n\t\tTokenHeadName:  \"Bearer\",\n\t\t// TimeFunc provides the current time. You can override it to use another time value. This is useful for testing or if your server uses a different time zone than your tokens.\n\t\tTimeFunc: time.Now,\n\t})\n\terrInit := authMiddleware.MiddlewareInit()\n\tif errInit != nil {\n\t\tlog.Fatal(\"authMiddleware.MiddlewareInit() Error:\" + errInit.Error())\n\t}\n\n\tif err != nil {\n\t\tlog.Fatal(\"JWT Error:\" + err.Error())\n\t}\n\treturn authMiddleware, err\n}\n\ntype Login struct {\n\tUser     string `form:\"user\" json:\"user\" binding:\"required\"`\n\tPassword string `form:\"password\" json:\"password\" binding:\"required\"`\n}\ntype User struct {\n\tUserName string\n}\n", "package dao\n\nimport (\n\t\"errors\"\n\t\"github.com/bluele/gcache\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/px-org/PanIndex/module\"\n\t_115 \"github.com/px-org/PanIndex/pan/115\"\n\t\"github.com/px-org/PanIndex/pan/123\"\n\t\"github.com/px-org/PanIndex/pan/ali\"\n\t\"github.com/px-org/PanIndex/pan/base\"\n\t\"github.com/px-org/PanIndex/pan/cloud189\"\n\t\"github.com/px-org/PanIndex/pan/googledrive\"\n\t\"github.com/px-org/PanIndex/pan/onedrive\"\n\t\"github.com/px-org/PanIndex/pan/pikpak\"\n\t\"github.com/px-org/PanIndex/pan/s3\"\n\t\"github.com/px-org/PanIndex/pan/teambition\"\n\t\"github.com/px-org/PanIndex/util\"\n\tuuid \"github.com/satori/go.uuid\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/smallnest/weighted\"\n\t\"gorm.io/gorm\"\n\t\"math/rand\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar DB *gorm.DB\nvar NewPassword = \"\"\nvar NewUser = \"admin\"\nvar DB_TYPE = \"sqlite\"\nvar InitConfigItems = []module.ConfigItem{\n\t{\"site_name\", \"PanIndex\", \"common\"},\n\t{\"account_choose\", \"default\", \"common\"},\n\t{\"path_prefix\", \"\", \"common\"},\n\t{\"admin_user\", \"admin\", \"common\"},\n\t{\"admin_password\", \"PanIndex\", \"common\"},\n\t{\"s_column\", \"default\", \"common\"},\n\t{\"s_order\", \"asc\", \"common\"},\n\t{\"readme\", \"1\", \"common\"},\n\t{\"head\", \"1\", \"common\"},\n\t{\"favicon_url\", \"\", \"appearance\"},\n\t{\"footer\", \"\", \"appearance\"},\n\t{\"css\", \"\", \"appearance\"},\n\t{\"js\", \"\", \"appearance\"},\n\t{\"theme\", \"mdui\", \"appearance\"},\n\t{\"enable_preview\", \"1\", \"view\"},\n\t{\"image\", \"png,gif,jpg,bmp,jpeg,ico,webp\", \"view\"},\n\t{\"video\", \"mp4,mkv,m3u8,flv,avi\", \"view\"},\n\t{\"audio\", \"mp3,wav,flac,ape\", \"view\"},\n\t{\"code\", \"txt,go,html,js,java,json,css,lua,sh,sql,py,cpp,xml,jsp,properties,yaml,ini\", \"view\"},\n\t{\"doc\", \"doc,docx,dotx,ppt,pptx,xls,xlsx\", \"view\"},\n\t{\"other\", \"*\", \"view\"},\n\t{\"enable_lrc\", \"0\", \"view\"},\n\t{\"lrc_path\", \"\", \"view\"},\n\t{\"subtitle\", \"\", \"view\"},\n\t{\"subtitle_path\", \"\", \"view\"},\n\t{\"danmuku\", \"0\", \"view\"},\n\t{\"danmuku_path\", \"\", \"view\"},\n\t{\"access\", \"0\", \"safety\"},\n\t{\"short_action\", \"0\", \"safety\"},\n\t{\"enable_safety_link\", \"0\", \"safety\"},\n\t{\"only_referrer\", \"\", \"safety\"},\n\t{\"is_null_referrer\", \"0\", \"safety\"},\n\t{\"admin_path\", \"/admin\", \"common\"},\n\t{\"cdn\", \"1\", \"common\"},\n\t{\"dav_path\", \"/dav\", \"dav\"},\n\t{\"enable_dav\", \"0\", \"dav\"},\n\t{\"dav_mode\", \"0\", \"dav\"},\n\t{\"dav_down_mode\", \"1\", \"dav\"},\n\t{\"dav_user\", \"webdav\", \"dav\"},\n\t{\"dav_password\", \"1234\", \"dav\"},\n\t{\"proxy\", \"\", \"common\"},\n}\n\ntype Db interface {\n\tCreateDb(dsn string) //get dao connection\n}\n\nvar DbMap = map[string]Db{}\n\nfunc RegisterDb(driver string, db Db) {\n\tDbMap[driver] = db\n}\n\nfunc GetDb(driver string) (db Db, ok bool) {\n\tdb, ok = DbMap[driver]\n\treturn\n}\n\nfunc InitDb() {\n\tDB.AutoMigrate(&module.FileNode{})\n\tDB.AutoMigrate(&module.ShareInfo{})\n\tDB.AutoMigrate(&module.ConfigItem{})\n\tDB.AutoMigrate(&module.Account{})\n\tDB.AutoMigrate(&module.PwdFiles{})\n\tDB.AutoMigrate(&module.HideFiles{})\n\tDB.AutoMigrate(&module.Bypass{})\n\tDB.AutoMigrate(&module.BypassAccounts{})\n\t//init data\n\tvar count int64\n\terr := DB.Model(module.ConfigItem{}).Count(&count).Error\n\tSaveConfigItems(InitConfigItems)\n\tif err != nil {\n\t\tpanic(err)\n\t} else if count == 0 {\n\t\t//DB.Create(&InitConfigItems)\n\t\trand.Seed(time.Now().UnixNano())\n\t\tApiToken := strconv.Itoa(rand.Intn(10000000))\n\t\tconfigItem := module.ConfigItem{K: \"api_token\", V: ApiToken, G: \"common\"}\n\t\tDB.Create(configItem)\n\t}\n\tif NewPassword != \"\" {\n\t\tconfigItem := module.ConfigItem{}\n\t\tDB.Where(\"k=?\", \"admin_password\").First(&configItem)\n\t\tOldPassword := configItem.V\n\t\tconfigItem.V = NewPassword\n\t\tDB.Where(\"k=?\", \"admin_password\").Updates(configItem)\n\t\tlog.Infof(\"reset password success, old [%s], new [%s] \", OldPassword, NewPassword)\n\t}\n\tif NewUser != \"\" {\n\t\tconfigItem := module.ConfigItem{}\n\t\tDB.Where(\"k=?\", \"admin_user\").First(&configItem)\n\t\tOldUser := configItem.V\n\t\tconfigItem.V = NewUser\n\t\tDB.Where(\"k=?\", \"admin_user\").Updates(configItem)\n\t\tlog.Infof(\"reset user success, old [%s], new [%s] \", OldUser, configItem.V)\n\t}\n\t//\u517c\u5bb9\u65e7\u7248\u672c\u5bc6\u7801\u89c4\u5219\n\tUpdateOldPassword()\n}\n\nfunc UpdateOldPassword() {\n\tvar pwdFiles []module.PwdFiles\n\tc := DB.Where(\"1=1\").Find(&pwdFiles).RowsAffected\n\tif c != 0 {\n\t\tfor _, file := range pwdFiles {\n\t\t\tif file.Id == \"\" {\n\t\t\t\tfile.Id = uuid.NewV4().String()\n\t\t\t\tDB.Table(\"pwd_files\").Where(\"file_path=?\", file.FilePath).Updates(map[string]interface{}{\n\t\t\t\t\t\"expire_at\": 0, \"id\": file.Id,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc SaveConfigItems(items []module.ConfigItem) {\n\tfor _, item := range items {\n\t\tvar c module.ConfigItem\n\t\terr := DB.Where(\"k=?\", item.K).First(&c).Error\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tDB.Create(item)\n\t\t}\n\t}\n}\n\n// init global config\nfunc InitGlobalConfig() {\n\tc := module.Config{}\n\tcis := []module.ConfigItem{}\n\taccounts := []module.Account{}\n\tDB.Raw(\"select * from config_item where 1=1\").Find(&cis)\n\tconfigMap := make(map[string]interface{})\n\tfor _, ci := range cis {\n\t\tconfigMap[ci.K] = ci.V\n\t}\n\tconfigJson, _ := jsoniter.MarshalToString(configMap)\n\tjsoniter.Unmarshal([]byte(configJson), &c)\n\tDB.Raw(\"select * from account order by seq asc\").Find(&accounts)\n\tc.Accounts = accounts\n\tc.HideFiles = GetHideFilesMap()\n\tc.PwdFiles = FindPwdList()\n\tc.BypassList = GetBypassList()\n\tmodule.GloablConfig = c\n\tc.CdnFiles = util.GetCdnFilesMap(c.Cdn, module.VERSION)\n\tc.ShareInfoList = GetShareInfoList()\n\tmodule.GloablConfig = c\n\tRoundRobin()\n}\n\n// share info all list\nfunc GetShareInfoList() []module.ShareInfo {\n\tshareInfoList := []module.ShareInfo{}\n\tDB.Where(\"1 = 1\").Find(&shareInfoList)\n\treturn shareInfoList\n}\n\n// pwd files to map\nfunc GetHideFilesMap() map[string]string {\n\tm := make(map[string]string)\n\thidefiles := []module.HideFiles{}\n\tDB.Where(\"1 = 1\").Find(&hidefiles)\n\tif len(hidefiles) > 0 {\n\t\tfor _, hidefile := range hidefiles {\n\t\t\tm[hidefile.FilePath] = \"1\"\n\t\t}\n\t}\n\treturn m\n}\n\n// hide files to map\nfunc GetPwdFilesMap() map[string]string {\n\tm := make(map[string]string)\n\tpwdfiles := []module.PwdFiles{}\n\tDB.Where(\"1 = 1\").Find(&pwdfiles)\n\tif len(pwdfiles) > 0 {\n\t\tfor _, pwdfile := range pwdfiles {\n\t\t\tm[pwdfile.FilePath] = pwdfile.Password\n\t\t}\n\t}\n\treturn m\n}\n\n// get pwd from full path\nfunc GetPwdFromPath(path string) ([]string, string, bool) {\n\tpwdfiles := []string{}\n\tpwdfile := module.PwdFiles{}\n\tfilePath := \"\"\n\tnow := time.Now().Unix()\n\tlikeSql := \"\"\n\tif DB_TYPE == \"sqlite\" {\n\t\tlikeSql = \"SELECT * FROM pwd_files WHERE ? LIKE file_path || '%' AND (expire_at =0 or expire_at >= ?) ORDER BY LENGTH(file_path) DESC\"\n\t} else if DB_TYPE == \"postgres\" {\n\t\tlikeSql = \"SELECT * FROM pwd_files WHERE ? LIKE concat_ws('', file_path, '%') AND (expire_at =0 or expire_at >= ?) ORDER BY LENGTH(file_path) DESC\"\n\t} else {\n\t\tlikeSql = \"SELECT * FROM pwd_files WHERE ? LIKE concat(file_path, '%') AND (expire_at =0 or expire_at >= ?) ORDER BY LENGTH(file_path) DESC\"\n\t}\n\tresult := DB.Table(\"pwd_files\").Select(\"password\").Where(\"file_path = ? AND (expire_at =0 or expire_at >= ?)\", path, now).Find(&pwdfiles)\n\tif result.RowsAffected == 0 {\n\t\tresult = DB.Raw(likeSql, path, now).First(&pwdfile)\n\t\tif result.RowsAffected == 0 {\n\t\t\treturn pwdfiles, filePath, false\n\t\t} else {\n\t\t\tfilePath = pwdfile.FilePath\n\t\t\tresult = DB.Table(\"pwd_files\").Select(\"password\").Where(\"file_path = ? AND (expire_at =0 or expire_at >= ?)\", pwdfile.FilePath, now).Find(&pwdfiles)\n\t\t}\n\t} else {\n\t\tfilePath = path\n\t}\n\treturn pwdfiles, filePath, true\n}\n\n// find account by name\nfunc FindAccountByName(name string) module.Account {\n\taccount := module.Account{}\n\tDB.Where(\"name = ?\", name).First(&account)\n\treturn account\n}\n\n// find first account by seq\nfunc FindAccountBySeq(seq int) module.Account {\n\taccount := module.Account{}\n\tDB.Where(\"seq = ?\", seq).First(&account)\n\treturn account\n}\n\n// find first file by path\nfunc FindFileByPath(ac module.Account, path string) (module.FileNode, bool) {\n\tfn := module.FileNode{}\n\tok := false\n\tsql := `select fn.* from file_node fn where fn.account_id = ? and fn.path = ?`\n\tDB.Raw(sql, ac.Id, path).First(&fn)\n\tif !fn.IsFolder {\n\t\tok = true\n\t}\n\tif fn.FileId == \"\" {\n\t\t//check root file\n\t\tsql := `select fn.* from file_node fn where fn.account_id = ? and fn.parent_path = ?`\n\t\tDB.Raw(sql, ac.Id, path).First(&fn)\n\t\tif fn.FileId != \"\" {\n\t\t\t_, fileName := util.ParsePath(path)\n\t\t\treturn module.FileNode{\n\t\t\t\tFileId:     ac.RootId,\n\t\t\t\tFileName:   fileName,\n\t\t\t\tFileSize:   0,\n\t\t\t\tIsFolder:   true,\n\t\t\t\tPath:       path,\n\t\t\t\tLastOpTime: time.Now().Format(\"2006-01-02 15:04:05\"),\n\t\t\t}, true\n\t\t}\n\n\t}\n\treturn fn, ok\n}\n\n// find first file  list by path\nfunc FindFileListByPath(ac module.Account, path, sortColumn, sortOrder string) []module.FileNode {\n\tfns := []module.FileNode{}\n\ttx := DB.Where(\"is_delete=0 and hide =0 and account_id=? and parent_path=?\", ac.Id, path)\n\ttx.Order(\"is_folder desc\")\n\t/*if sortColumn != \"default\" && sortOrder != \"\" {\n\t\ttx = tx.Order(fmt.Sprintf(\"%s %s\", sortColumn, sortOrder))\n\t} else {\n\t\ttx = tx.Order(fmt.Sprintf(\"last_op_time asc\"))\n\t}*/\n\ttx.Find(&fns)\n\treturn fns\n}\n\n// update config\nfunc UpdateConfig(config map[string]string) {\n\tfor key, value := range config {\n\t\tDB.Table(\"config_item\").Where(\"k=?\", key).Update(\"v\", value)\n\t}\n\tInitGlobalConfig()\n}\n\n// get config\nfunc GetConfig() module.Config {\n\tc := module.Config{}\n\tcis := []module.ConfigItem{}\n\taccounts := []module.Account{}\n\tDB.Raw(\"select * from config_item where 1=1\").Find(&cis)\n\tconfigMap := make(map[string]interface{})\n\tfor _, ci := range cis {\n\t\tconfigMap[ci.K] = ci.V\n\t}\n\tconfigJson, _ := jsoniter.MarshalToString(configMap)\n\tjsoniter.Unmarshal([]byte(configJson), &c)\n\tDB.Raw(\"select * from account order by `seq` asc\").Find(&accounts)\n\tc.Accounts = accounts\n\tmodule.GloablConfig = c\n\treturn c\n}\n\n// get account\nfunc GetAccountById(id string) module.Account {\n\taccount := module.Account{}\n\tDB.Where(\"id = ?\", id).First(&account)\n\treturn account\n}\n\n// delete accounts\nfunc DeleteAccounts(ids []string) {\n\tfor _, id := range ids {\n\t\t//delete account db file\n\t\tDB.Where(\"account_id = ?\", id).Delete(module.FileNode{})\n\t\t//delete account\n\t\tvar a module.Account\n\t\tvar si module.ShareInfo\n\t\ta.Id = id\n\t\tDB.Model(module.Account{}).Where(\"1=1\").Delete(a)\n\t\t//delete share info\n\t\tDB.Model(module.ShareInfo{}).Where(\"1=1\").Delete(si)\n\t\t//delete login account\n\t\t//base.RemoveLoginAccount(id)\n\t\t// refresh global config\n\t\tInitGlobalConfig()\n\t\t//remove login account\n\t\tdelete(ali.Alis, id)\n\t\tdelete(onedrive.OneDrives, id)\n\t\tdelete(teambition.TeambitionSessions, id)\n\t\tdelete(cloud189.CLoud189s, id)\n\t\tdelete(googledrive.GoogleDrives, id)\n\t\tdelete(s3.S3s, id)\n\t\tdelete(pikpak.Pikpaks, id)\n\t\tdelete(_123.Sessions, id)\n\t\tdelete(_115.Sessions, id)\n\t}\n}\n\nvar RetryTasksCache = gcache.New(100000).LRU().Build()\n\ntype RetryTask struct {\n\taccount      module.Account\n\tfileId, path string\n\thide, hasPwd int\n}\n\n// Loop add files\nfunc LoopCreateFiles(account module.Account, fileId, path string, hide, hasPwd int) {\n\tpan, _ := base.GetPan(account.Mode)\n\tfileNodes, err := pan.Files(account, fileId, path, \"default\", \"null\")\n\tif err != nil {\n\t\tif err.Error() == \"flow limit\" {\n\t\t\tlog.Debugf(\"%s need retry\uff0c err\uff1a%v\", path, err)\n\t\t\t//\u52a0\u5165\u91cd\u8bd5\n\t\t\tRetryTasksCache.Set(account.Id+fileId, RetryTask{account, fileId, path, hide, hasPwd})\n\t\t} else {\n\t\t\tlog.Warningf(\"%s get files error\", account.Mode)\n\t\t\tlog.Errorln(err)\n\t\t}\n\t}\n\tfor _, fn := range fileNodes {\n\t\tFileNodeAuth(&fn, hide, hasPwd)\n\t\tif fn.IsFolder && account.SyncChild == 0 {\n\t\t\tLoopCreateFiles(account, fn.FileId, fn.Path, fn.Hide, fn.HasPwd)\n\t\t}\n\t}\n\tif len(fileNodes) > 0 {\n\t\tDB.Create(&fileNodes)\n\t}\n\tif len(fileNodes) > 0 || (len(fileNodes) == 0 && err == nil) {\n\t\tRetryTasksCache.Remove(account.Id + fileId)\n\t}\n}\n\n// sync account status\nfunc SyncAccountStatus(account module.Account) {\n\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"cookie_status\", -1)\n\tpan, _ := base.GetPan(account.Mode)\n\tauth, err := pan.AuthLogin(&account)\n\tif err == nil && auth != \"\" {\n\t\tlog.Debugf(\"[%s] %s auth login success\", account.Mode, account.Name)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"cookie_status\", 2)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"refresh_token\", auth)\n\t} else {\n\t\tlog.Errorln(err)\n\t\tlog.Errorf(\"[%s] %s auth login fail, api return : %s\", account.Mode, account.Name, auth)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"cookie_status\", 4)\n\t}\n\tInitGlobalConfig()\n}\n\n// sync files cache\nvar SYNC_STATUS = 0\n\nfunc SyncFilesCache(account module.Account) {\n\tsyncDirs := strings.Split(account.SyncDir, \",\")\n\tfor _, syncDir := range syncDirs {\n\t\tt1 := time.Now()\n\t\tdbFile := module.FileNode{}\n\t\tresult := DB.Raw(\"select * from file_node where path=? and is_delete=0 and account_id=?\", syncDir, account.Id).Take(&dbFile)\n\t\tisRoot := true\n\t\tif !errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\taccount.RootId = dbFile.FileId\n\t\t\tisRoot = false\n\t\t}\n\t\t//cache new files\n\t\tLoopCreateFiles(account, account.RootId, syncDir, 0, 0)\n\t\t//retry\n\t\tLoopRetryTasks(account.Id)\n\t\t//handle old files && update account status\n\t\tvar fileNodeCount int64\n\t\tDB.Model(&module.FileNode{}).Where(\"account_id=? and is_delete=1\", account.Id).Count(&fileNodeCount)\n\t\tstatus := 3\n\t\tif int(fileNodeCount) > 0 {\n\t\t\tstatus = 2\n\t\t\tif isRoot {\n\t\t\t\t//\u5220\u9664\u65e7\u6570\u636e\n\t\t\t\tDB.Where(\"account_id=? and is_delete=0\", account.Id).Delete(module.FileNode{})\n\t\t\t\t//\u66b4\u9732\u65b0\u6570\u636e\n\t\t\t\tDB.Table(\"file_node\").Where(\"account_id=?\", account.Id).Update(\"is_delete\", 0)\n\t\t\t} else {\n\t\t\t\tRefreshFileNodes(account.Id, account.RootId)\n\t\t\t}\n\t\t\tlog.Infoln(\"[DB cache][\" + account.Name + \"]refresh >> success\")\n\t\t}\n\t\tt2 := time.Now()\n\t\td := t2.Sub(t1)\n\t\tnow := time.Now().UTC().Add(8 * time.Hour)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Updates(map[string]interface{}{\n\t\t\t\"status\": status, \"files_count\": int(fileNodeCount), \"last_op_time\": now.Format(\"2006-01-02 15:04:05\"),\n\t\t\t\"time_span\": util.ShortDur(d),\n\t\t})\n\t}\n\tInitGlobalConfig()\n\tSYNC_STATUS = 0\n}\n\nfunc LoopRetryTasks(accountId string) {\n\tks := []string{}\n\tfor _, key := range RetryTasksCache.Keys(false) {\n\t\tif strings.HasPrefix(key.(string), accountId) {\n\t\t\tks = append(ks, key.(string))\n\t\t}\n\t}\n\tfor _, k := range ks {\n\t\trt, _ := RetryTasksCache.Get(k)\n\t\tretryTask := rt.(RetryTask)\n\t\ttime.Sleep(time.Duration(1) * time.Second)\n\t\tLoopCreateFiles(retryTask.account, retryTask.fileId, retryTask.path, retryTask.hide, retryTask.hasPwd)\n\t\tlog.Debugf(\"retry path: %s\uff0c\u5269\u4f59\uff1a%d\", retryTask.path, len(ks))\n\t}\n\tif len(ks) > 0 {\n\t\tLoopRetryTasks(accountId)\n\t}\n}\n\nfunc RefreshFileNodes(accountId, fileId string) {\n\ttmpList := []module.FileNode{}\n\tlist := []module.FileNode{}\n\tDB.Raw(\"select * from file_node where parent_id=? and is_delete=0 and account_id=?\", fileId, accountId).Find(&tmpList)\n\tGetAllNodes(&tmpList, &list)\n\tfor _, fn := range list {\n\t\tDB.Where(\"id=?\", fn.Id).Delete(module.FileNode{})\n\t}\n\tDB.Table(\"file_node\").Where(\"account_id=?\", accountId).Update(\"is_delete\", 0)\n}\n\nfunc DeleteFileNodes(accountId, fileId string) {\n\ttmpList := []module.FileNode{}\n\tlist := []module.FileNode{}\n\tDB.Raw(\"select * from file_node where parent_id=? and is_delete=0 and account_id=?\", fileId, accountId).Find(&tmpList)\n\tGetAllNodes(&tmpList, &list)\n\tfor _, fn := range list {\n\t\tDB.Where(\"id=?\", fn.Id).Delete(module.FileNode{})\n\t}\n\tDB.Where(\"file_id=? and account_id=?\", fileId, accountId).Delete(module.FileNode{})\n}\n\nfunc GetAllNodes(tmpList, list *[]module.FileNode) {\n\tfor _, fn := range *tmpList {\n\t\ttmpList = &[]module.FileNode{}\n\t\tDB.Raw(\"select * from file_node where parent_id=? and is_delete=0\", fn.FileId).Find(&tmpList)\n\t\t*list = append(*list, fn)\n\t\tif len(*tmpList) != 0 {\n\t\t\tGetAllNodes(tmpList, list)\n\t\t}\n\t}\n}\n\n// sort accounts\nfunc SortAccounts(ids []string) {\n\tfor i, id := range ids {\n\t\ti++\n\t\tDB.Model(module.Account{}).Where(\"id=?\", id).Update(\"seq\", i)\n\t}\n\tInitGlobalConfig()\n}\n\n// get file id by path\nfunc GetFileIdByPath(accountId, path string) string {\n\tfn := module.FileNode{}\n\tif path == \"/\" {\n\t\tDB.Raw(\"select * from file_node where parent_path=? and is_delete=0 and account_id=? limit 1\", path, accountId).Take(&fn)\n\t\treturn fn.ParentId\n\t} else {\n\t\tDB.Raw(\"select * from file_node where path=? and is_delete=0 and account_id=?\", path, accountId).Take(&fn)\n\t\treturn fn.FileId\n\t}\n}\n\n// save hide file\nfunc SaveHideFile(filePath string) {\n\thideFile := module.HideFiles{FilePath: filePath}\n\terr := DB.Where(\"file_path=?\", filePath).First(&module.HideFiles{}).Error\n\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\tDB.Create(&hideFile)\n\t}\n\tInitGlobalConfig()\n}\n\n// delete hide file\nfunc DeleteHideFiles(filePaths []string) {\n\tfor _, filePath := range filePaths {\n\t\tc := DB.Where(\"file_path=?\", filePath).Delete(&module.HideFiles{}).RowsAffected\n\t\tlog.Debugf(\"delete hide file [%s], result [%d]\", filePath, c)\n\t}\n\tInitGlobalConfig()\n}\n\n// save pwd file\nfunc SavePwdFile(pwdFile module.PwdFiles) {\n\tif pwdFile.Password == \"\" {\n\t\tpwdFile.Password = util.RandomPassword(8)\n\t}\n\tdecodedPath, err := url.QueryUnescape(pwdFile.FilePath)\n\tif err != nil {\n\t\tlog.Error(err)\n\t} else {\n\t\tpwdFile.FilePath = decodedPath\n\t}\n\tif pwdFile.Id != \"\" {\n\t\tDB.Table(\"pwd_files\").Where(\"id=?\", pwdFile.Id).Updates(pwdFile)\n\t} else {\n\t\tpwdFile.Id = uuid.NewV4().String()\n\t\tDB.Create(&pwdFile)\n\t}\n}\n\n// delete hide file\nfunc DeletePwdFiles(delIds []string) {\n\tfor _, id := range delIds {\n\t\tc := DB.Where(\"id=?\", id).Delete(&module.PwdFiles{}).RowsAffected\n\t\tlog.Debugf(\"delete pwd file [%s], result [%d]\", id, c)\n\t}\n\tInitGlobalConfig()\n}\n\nfunc GetBypassList() []module.Bypass {\n\tlist := []module.Bypass{}\n\tDB.Find(&list)\n\tif len(list) > 0 {\n\t\tfor i := 0; i < len(list); i++ {\n\t\t\taccounts := []module.Account{}\n\t\t\tDB.Raw(`select\n\t\t\t\ta.*\n\t\t\t\t\tfrom\n\t\t\t\taccount a\n\t\t\t\tleft join bypass_accounts ba on\n\t\t\t\tba.account_id = a.id\n\t\t\t\twhere\n\t\t\t\tba.bypass_id =?`, list[i].Id).Find(&accounts)\n\t\t\tlist[i].Accounts = accounts\n\t\t}\n\t}\n\treturn list\n}\n\nfunc SaveBypass(bypass module.Bypass) string {\n\tif bypass.Id != \"\" {\n\t\terr := DB.Where(\"name=? and id!=?\", bypass.Name, bypass.Id).First(&module.Bypass{}).Error\n\t\tif err == nil {\n\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u5206\u6d41\u540d\u79f0\u5df2\u5b58\u5728\uff01\"\n\t\t}\n\t\t//check account bind\n\t\tfor _, account := range bypass.Accounts {\n\t\t\tacs := []module.BypassAccounts{}\n\t\t\tDB.Where(\"account_id = ? and bypass_id!=?\", account.Id, bypass.Id).Find(&acs)\n\t\t\tif len(acs) > 0 {\n\t\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u7f51\u76d8\u5df2\u88ab\u5176\u4ed6\u5206\u6d41\u7ed1\u5b9a\uff01\"\n\t\t\t}\n\t\t}\n\t\tDB.Where(\"id=?\", bypass.Id).Save(&bypass)\n\t} else {\n\t\terr := DB.Where(\"name=?\", bypass.Name).First(&module.Bypass{}).Error\n\t\tif err == nil {\n\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u5206\u6d41\u540d\u79f0\u5df2\u5b58\u5728\uff01\"\n\t\t}\n\t\t//check account bind\n\t\tfor _, account := range bypass.Accounts {\n\t\t\tacs := []module.BypassAccounts{}\n\t\t\tDB.Where(\"account_id = ?\", account.Id).Find(&acs)\n\t\t\tif len(acs) > 0 {\n\t\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u7f51\u76d8\u5df2\u88ab\u5176\u4ed6\u5206\u6d41\u7ed1\u5b9a\uff01\"\n\t\t\t}\n\t\t}\n\t\tbypass.Id = uuid.NewV4().String()\n\t\tDB.Create(&bypass)\n\t}\n\tDB.Where(\"bypass_id = ?\", bypass.Id).Delete(&module.BypassAccounts{})\n\tfor _, account := range bypass.Accounts {\n\t\tba := module.BypassAccounts{bypass.Id, account.Id}\n\t\tDB.Create(&ba)\n\t}\n\tInitGlobalConfig()\n\treturn \"\u4fdd\u5b58\u6210\u529f\uff01\"\n}\n\nfunc DeleteBypass(ids []string) {\n\tfor _, id := range ids {\n\t\tc := DB.Where(\"id=?\", id).Delete(&module.Bypass{}).RowsAffected\n\t\tDB.Where(\"bypass_id=?\", id).Delete(&module.BypassAccounts{})\n\t\tlog.Debugf(\"delete bypass [%s], result [%d]\", id, c)\n\t}\n\tInitGlobalConfig()\n}\n\nfunc RoundRobin() {\n\tif len(module.GloablConfig.BypassList) > 0 {\n\t\tfor i := 0; i < len(module.GloablConfig.BypassList); i++ {\n\t\t\trrw := weighted.NewRandW()\n\t\t\tfor _, account := range module.GloablConfig.BypassList[i].Accounts {\n\t\t\t\trrw.Add(account, 1)\n\t\t\t}\n\t\t\tmodule.GloablConfig.BypassList[i].Rw = rrw\n\t\t}\n\t}\n}\n\nfunc FindAccountsByPath(path string) ([]module.Account, string) {\n\taccounts := []module.Account{}\n\tfn := module.FileNode{}\n\tDB.Where(\"path=?\", path).First(&fn)\n\tif fn.Path != \"\" {\n\t\tif !fn.IsFolder {\n\t\t\tpath = fn.ParentPath\n\t\t}\n\t}\n\tDB.Raw(`select a.* from file_node fn left join account a on a.id = fn.account_id where fn.path = ? group by a.id`, path).\n\t\tFind(&accounts)\n\tif len(accounts) == 0 {\n\t\tDB.Raw(`select a.* from file_node fn left join account a on a.id = fn.account_id where fn.parent_path = ? group by a.id`, path).\n\t\t\tFind(&accounts)\n\t}\n\treturn accounts, path\n}\n\nfunc UpdateCacheConfig(account module.Account, t string) {\n\taccount.Status = -1\n\tac := GetAccountById(account.Id)\n\tif t == \"1\" {\n\t\tDB.Where(\"account_id = ?\", account.Id).Delete(module.FileNode{})\n\t}\n\tif account.CachePolicy == \"dc\" {\n\t\tif t == \"1\" {\n\t\t\tif SYNC_STATUS == 0 {\n\t\t\t\tbypass := SelectBypassByAccountId(account.Id)\n\t\t\t\tcachePath := \"/\" + ac.Name\n\t\t\t\tif bypass.Name != \"\" {\n\t\t\t\t\tcachePath = \"/\" + bypass.Name\n\t\t\t\t}\n\t\t\t\tac.SyncDir = cachePath\n\t\t\t\tgo SyncFilesCache(ac)\n\t\t\t}\n\t\t} else {\n\t\t\taccount.Status = 2\n\t\t}\n\n\t} else {\n\t\taccount.Status = 2\n\t}\n\tDB.Model(&[]module.Account{}).\n\t\tSelect(\"CachePolicy\", \"SyncDir\", \"SyncChild\", \"ExpireTimeSpan\", \"SyncCron\", \"Status\").\n\t\tWhere(\"id=?\", account.Id).\n\t\tUpdates(&account)\n\tgo SaveCacheCron(ac)\n\tInitGlobalConfig()\n}\n\nfunc SaveCacheCron(ac module.Account) {\n\tc, ok := util.CacheCronMap[ac.Id]\n\tif ok {\n\t\tif ac.CachePolicy != \"dc\" || ac.SyncCron == \"\" || ac.SyncDir == \"\" {\n\t\t\tutil.Cron.Remove(c)\n\t\t\tdelete(util.CacheCronMap, ac.Id)\n\t\t} else {\n\t\t\tutil.Cron.Remove(c)\n\t\t\tentryId, err := util.Cron.AddFunc(ac.SyncCron, func() {\n\t\t\t\tSyncFilesCache(ac)\n\t\t\t\t//log.Debugf(\"[%s] [%s] [%s] [%s] [%s]\", ac.Name, ac.Mode, ac.CachePolicy, ac.SyncCron, ac.SyncDir)\n\t\t\t})\n\t\t\tif err == nil {\n\t\t\t\tutil.CacheCronMap[ac.Id] = entryId\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ac.CachePolicy == \"dc\" && ac.SyncCron != \"\" && ac.SyncDir != \"\" {\n\t\t\tutil.Cron.Remove(c)\n\t\t\tentryId, err := util.Cron.AddFunc(ac.SyncCron, func() {\n\t\t\t\tSyncFilesCache(ac)\n\t\t\t\t//log.Debugf(\"[%s] [%s] [%s] [%s] [%s]\", ac.Name, ac.Mode, ac.CachePolicy, ac.SyncCron, ac.SyncDir)\n\t\t\t})\n\t\t\tif err == nil {\n\t\t\t\tutil.CacheCronMap[ac.Id] = entryId\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc SaveAccount(account module.Account) string {\n\t//check name exists\n\tif AccountNameExist(account.Id, account.Name) {\n\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u7f51\u76d8\uff08\u6216\u5206\u6d41\uff09\u540d\u79f0\u5df2\u5b58\u5728\uff01\"\n\t}\n\tif account.Id == \"\" {\n\t\taccount.Id = uuid.NewV4().String()\n\t\taccount.CachePolicy = \"nc\"\n\t\taccount.SyncDir = \"/\" + account.Name\n\t\taccount.SyncChild = 0\n\t\taccount.ExpireTimeSpan = 1\n\t\taccount.SyncCron = \"\"\n\t\taccount.LastOpTime = time.Now().Format(\"2006-01-02 15:04:05\")\n\t\tvar seq int\n\t\tDB.Table(\"account\").Raw(\"select seq from account where 1=1 order by seq desc limit 1\").Take(&seq)\n\t\taccount.Seq = seq + 1\n\t\tDB.Create(&account)\n\t} else {\n\t\taccount.LastOpTime = time.Now().Format(\"2006-01-02 15:04:05\")\n\t\tDB.Model(&[]module.Account{}).\n\t\t\tSelect(\"Id\", \"Name\", \"Mode\", \"User\", \"Password\", \"RefreshToken\", \"AccessToken\", \"SiteId\",\n\t\t\t\t\"RedirectUri\", \"ApiUrl\", \"RootId\", \"LastOpTime\", \"DownTransfer\", \"TransferUrl\", \"Host\", \"TransferDomain\", \"PathStyle\", \"Info\").\n\t\t\tWhere(\"id=?\", account.Id).\n\t\t\tUpdates(&account)\n\t}\n\tSyncAccountStatus(account)\n\tInitGlobalConfig()\n\treturn \"\u4fdd\u5b58\u6210\u529f\uff01\"\n}\n\nfunc AccountNameExist(id, name string) bool {\n\tif id != \"\" {\n\t\terr := DB.Where(\"name=? and id!=?\", name, id).First(&module.Account{}).Error\n\t\tif err == nil {\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\terr := DB.Where(\"name=?\", name).First(&module.Account{}).Error\n\t\tif err == nil {\n\t\t\treturn true\n\t\t}\n\t}\n\terr := DB.Where(\"name=?\", name).First(&module.Bypass{}).Error\n\tif err == nil {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc SelectBypassByAccountId(accountId string) module.Bypass {\n\tbypass := module.Bypass{}\n\tDB.Raw(`select\n\t\t\t\t\t\tb.*\n\t\t\t\t\tfrom\n\t\t\t\t\t\tbypass_accounts ba\n\t\t\t\t\tleft join bypass b on\n\t\t\t\t\t\tba.bypass_id = b.id\n\t\t\t\t\twhere\n\t\t\t\t\t\tba.account_id = ?`, accountId).Find(&bypass)\n\treturn bypass\n}\n\nfunc SaveShareInfo(info module.ShareInfo) {\n\terr := DB.Where(\"file_path=?\", info.FilePath).First(&module.ShareInfo{}).Error\n\tif err != nil && errors.Is(err, gorm.ErrRecordNotFound) {\n\t\tDB.Create(&info)\n\t} else {\n\t\tDB.Model(&[]module.ShareInfo{}).\n\t\t\tSelect(\"ShortCode\", \"IsFile\").\n\t\t\tWhere(\"file_path=?\", info.FilePath).\n\t\t\tUpdates(&info)\n\t}\n}\n\nfunc FindPwdList() []module.PwdFiles {\n\tpwdFiles := []module.PwdFiles{}\n\tDB.Raw(\"select * from pwd_files where 1=1\").Find(&pwdFiles)\n\treturn pwdFiles\n}\n\nfunc FileNodeAuth(fn *module.FileNode, hide, hasPwd int) {\n\tif hide == 1 {\n\t\tfn.Hide = hide\n\t} else {\n\t\t_, ok := module.GloablConfig.HideFiles[fn.FileId]\n\t\tif ok {\n\t\t\tfn.Hide = 1\n\t\t} else {\n\t\t\tfn.Hide = 0\n\t\t}\n\t}\n\tif hasPwd == 1 {\n\t\tfn.HasPwd = hasPwd\n\t} else {\n\t\t_, _, ok := GetPwdFromPath(fn.Path)\n\t\tif ok {\n\t\t\tfn.HasPwd = 1\n\t\t} else {\n\t\t\tfn.HasPwd = 0\n\t\t}\n\t}\n}\n\nfunc SelectAccountsById(ids []string) []module.Account {\n\tvar accounts []module.Account\n\tDB.Where(\"id IN ?\", ids).Find(&accounts)\n\treturn accounts\n}\n"], "fixing_code": ["package middleware\n\nimport (\n\t\"errors\"\n\tjwt \"github.com/appleboy/gin-jwt/v2\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/px-org/PanIndex/module\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"strings\"\n\t\"time\"\n)\n\nconst (\n\tLoginTimeOut = 24 * 365\n\tidentityKey  = \"id\"\n)\n\nfunc JWTMiddlewar() (*jwt.GinJWTMiddleware, error) {\n\tauthMiddleware, err := jwt.New(&jwt.GinJWTMiddleware{\n\t\tRealm:       \"PanIndex Zone\",\n\t\tKey:         []byte(module.GloablConfig.JwtSignKey),\n\t\tTimeout:     (time.Duration(LoginTimeOut)) * time.Hour,\n\t\tMaxRefresh:  (time.Duration(LoginTimeOut)) * time.Hour,\n\t\tIdentityKey: identityKey,\n\t\tPayloadFunc: func(data interface{}) jwt.MapClaims {\n\t\t\tif v, ok := data.(*User); ok {\n\t\t\t\treturn jwt.MapClaims{\n\t\t\t\t\tidentityKey: v.UserName,\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn jwt.MapClaims{}\n\t\t},\n\t\tIdentityHandler: func(c *gin.Context) interface{} {\n\t\t\tclaims := jwt.ExtractClaims(c)\n\t\t\treturn &User{\n\t\t\t\tUserName: claims[identityKey].(string),\n\t\t\t}\n\t\t},\n\t\tAuthenticator: func(c *gin.Context) (interface{}, error) {\n\t\t\tvar loginVals Login\n\t\t\tif err := c.ShouldBind(&loginVals); err != nil {\n\t\t\t\treturn \"\", jwt.ErrMissingLoginValues\n\t\t\t}\n\t\t\tpassword := loginVals.Password\n\t\t\tuser := loginVals.User\n\t\t\tif user == module.GloablConfig.AdminUser &&\n\t\t\t\tpassword == module.GloablConfig.AdminPassword {\n\t\t\t\treturn &User{\n\t\t\t\t\tUserName: module.GloablConfig.AdminUser,\n\t\t\t\t}, nil\n\t\t\t}\n\n\t\t\treturn nil, errors.New(\"\u5bc6\u7801\u9519\u8bef\uff01\u8bf7\u91cd\u8bd5\")\n\t\t},\n\t\tAuthorizator: func(data interface{}, c *gin.Context) bool {\n\t\t\tif v, ok := data.(*User); ok && v.UserName == module.GloablConfig.AdminUser {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\treturn false\n\t\t},\n\t\tLoginResponse: func(c *gin.Context, code int, token string, expire time.Time) {\n\t\t\t//c.Redirect(http.StatusFound, module.GloablConfig.AdminPath+\"/common\")\n\t\t\treferer := c.Request.Header.Get(\"Referer\")\n\t\t\tu, _ := url.Parse(referer)\n\t\t\tif strings.HasPrefix(u.Path, module.GloablConfig.AdminPath) {\n\t\t\t\tc.Redirect(http.StatusFound, module.GloablConfig.AdminPath+\"/common\")\n\t\t\t} else {\n\t\t\t\tc.Redirect(http.StatusFound, c.Request.Header.Get(\"Referer\"))\n\t\t\t}\n\t\t},\n\t\tLogoutResponse: func(c *gin.Context, code int) {\n\t\t\tThemeCheck(c)\n\t\t\ttheme := c.GetString(\"theme\")\n\t\t\tc.HTML(http.StatusOK, \"templates/pan/admin/login.html\", gin.H{\n\t\t\t\t\"error\":        true,\n\t\t\t\t\"msg\":          \"\u9000\u51fa\u6210\u529f\",\n\t\t\t\t\"redirect_url\": \"login\",\n\t\t\t\t\"config\":       module.GloablConfig,\n\t\t\t\t\"theme\":        theme,\n\t\t\t})\n\t\t},\n\t\tUnauthorized: func(c *gin.Context, code int, message string) {\n\t\t\tpath := c.Request.RequestURI\n\t\t\tif strings.HasPrefix(path, \"/api\") {\n\t\t\t\t//api return json\n\t\t\t\tc.JSON(code, gin.H{\n\t\t\t\t\t\"status\": code,\n\t\t\t\t\t\"msg\":    message,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t//return to login\n\t\t\t\tdata := gin.H{\n\t\t\t\t\t\"error\":        true,\n\t\t\t\t\t\"msg\":          message,\n\t\t\t\t\t\"redirect_url\": \"login\",\n\t\t\t\t\t\"config\":       module.GloablConfig,\n\t\t\t\t\t\"theme\":        module.GloablConfig.Theme,\n\t\t\t\t}\n\t\t\t\tif message == \"cookie token is empty\" {\n\t\t\t\t\tdata[\"error\"] = false\n\t\t\t\t\tdata[\"msg\"] = \"\"\n\t\t\t\t}\n\t\t\t\tc.HTML(http.StatusOK, \"templates/pan/admin/login.html\", data)\n\t\t\t}\n\t\t},\n\t\tSendCookie:     true,\n\t\tSecureCookie:   false,   //non HTTPS dev environments\n\t\tCookieHTTPOnly: true,    // JS can't modify\n\t\tCookieName:     \"token\", // default jwt\n\t\tTokenLookup:    \"header: Authorization, cookie: token\",\n\t\tCookieSameSite: http.SameSiteDefaultMode, //SameSiteDefaultMode, SameSiteLaxMode, SameSiteStrictMode, SameSiteNoneMode\n\t\tTokenHeadName:  \"Bearer\",\n\t\t// TimeFunc provides the current time. You can override it to use another time value. This is useful for testing or if your server uses a different time zone than your tokens.\n\t\tTimeFunc: time.Now,\n\t})\n\terrInit := authMiddleware.MiddlewareInit()\n\tif errInit != nil {\n\t\tlog.Fatal(\"authMiddleware.MiddlewareInit() Error:\" + errInit.Error())\n\t}\n\n\tif err != nil {\n\t\tlog.Fatal(\"JWT Error:\" + err.Error())\n\t}\n\treturn authMiddleware, err\n}\n\ntype Login struct {\n\tUser     string `form:\"user\" json:\"user\" binding:\"required\"`\n\tPassword string `form:\"password\" json:\"password\" binding:\"required\"`\n}\ntype User struct {\n\tUserName string\n}\n", "package dao\n\nimport (\n\t\"errors\"\n\t\"github.com/bluele/gcache\"\n\tjsoniter \"github.com/json-iterator/go\"\n\t\"github.com/px-org/PanIndex/module\"\n\t_115 \"github.com/px-org/PanIndex/pan/115\"\n\t\"github.com/px-org/PanIndex/pan/123\"\n\t\"github.com/px-org/PanIndex/pan/ali\"\n\t\"github.com/px-org/PanIndex/pan/base\"\n\t\"github.com/px-org/PanIndex/pan/cloud189\"\n\t\"github.com/px-org/PanIndex/pan/googledrive\"\n\t\"github.com/px-org/PanIndex/pan/onedrive\"\n\t\"github.com/px-org/PanIndex/pan/pikpak\"\n\t\"github.com/px-org/PanIndex/pan/s3\"\n\t\"github.com/px-org/PanIndex/pan/teambition\"\n\t\"github.com/px-org/PanIndex/util\"\n\tuuid \"github.com/satori/go.uuid\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/smallnest/weighted\"\n\t\"gorm.io/gorm\"\n\t\"math/rand\"\n\t\"net/url\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar DB *gorm.DB\nvar NewPassword = \"\"\nvar NewUser = \"admin\"\nvar DB_TYPE = \"sqlite\"\nvar InitConfigItems = []module.ConfigItem{\n\t{\"site_name\", \"PanIndex\", \"common\"},\n\t{\"account_choose\", \"default\", \"common\"},\n\t{\"path_prefix\", \"\", \"common\"},\n\t{\"admin_user\", \"admin\", \"common\"},\n\t{\"admin_password\", \"PanIndex\", \"common\"},\n\t{\"s_column\", \"default\", \"common\"},\n\t{\"s_order\", \"asc\", \"common\"},\n\t{\"readme\", \"1\", \"common\"},\n\t{\"head\", \"1\", \"common\"},\n\t{\"favicon_url\", \"\", \"appearance\"},\n\t{\"footer\", \"\", \"appearance\"},\n\t{\"css\", \"\", \"appearance\"},\n\t{\"js\", \"\", \"appearance\"},\n\t{\"theme\", \"mdui\", \"appearance\"},\n\t{\"enable_preview\", \"1\", \"view\"},\n\t{\"image\", \"png,gif,jpg,bmp,jpeg,ico,webp\", \"view\"},\n\t{\"video\", \"mp4,mkv,m3u8,flv,avi\", \"view\"},\n\t{\"audio\", \"mp3,wav,flac,ape\", \"view\"},\n\t{\"code\", \"txt,go,html,js,java,json,css,lua,sh,sql,py,cpp,xml,jsp,properties,yaml,ini\", \"view\"},\n\t{\"doc\", \"doc,docx,dotx,ppt,pptx,xls,xlsx\", \"view\"},\n\t{\"other\", \"*\", \"view\"},\n\t{\"enable_lrc\", \"0\", \"view\"},\n\t{\"lrc_path\", \"\", \"view\"},\n\t{\"subtitle\", \"\", \"view\"},\n\t{\"subtitle_path\", \"\", \"view\"},\n\t{\"danmuku\", \"0\", \"view\"},\n\t{\"danmuku_path\", \"\", \"view\"},\n\t{\"access\", \"0\", \"safety\"},\n\t{\"short_action\", \"0\", \"safety\"},\n\t{\"enable_safety_link\", \"0\", \"safety\"},\n\t{\"only_referrer\", \"\", \"safety\"},\n\t{\"is_null_referrer\", \"0\", \"safety\"},\n\t{\"admin_path\", \"/admin\", \"common\"},\n\t{\"cdn\", \"1\", \"common\"},\n\t{\"dav_path\", \"/dav\", \"dav\"},\n\t{\"enable_dav\", \"0\", \"dav\"},\n\t{\"dav_mode\", \"0\", \"dav\"},\n\t{\"dav_down_mode\", \"1\", \"dav\"},\n\t{\"dav_user\", \"webdav\", \"dav\"},\n\t{\"dav_password\", \"1234\", \"dav\"},\n\t{\"proxy\", \"\", \"common\"},\n\t{\"jwt_sign_key\", uuid.NewV4().String(), \"common\"},\n}\n\ntype Db interface {\n\tCreateDb(dsn string) //get dao connection\n}\n\nvar DbMap = map[string]Db{}\n\nfunc RegisterDb(driver string, db Db) {\n\tDbMap[driver] = db\n}\n\nfunc GetDb(driver string) (db Db, ok bool) {\n\tdb, ok = DbMap[driver]\n\treturn\n}\n\nfunc InitDb() {\n\tDB.AutoMigrate(&module.FileNode{})\n\tDB.AutoMigrate(&module.ShareInfo{})\n\tDB.AutoMigrate(&module.ConfigItem{})\n\tDB.AutoMigrate(&module.Account{})\n\tDB.AutoMigrate(&module.PwdFiles{})\n\tDB.AutoMigrate(&module.HideFiles{})\n\tDB.AutoMigrate(&module.Bypass{})\n\tDB.AutoMigrate(&module.BypassAccounts{})\n\t//init data\n\tvar count int64\n\terr := DB.Model(module.ConfigItem{}).Count(&count).Error\n\tSaveConfigItems(InitConfigItems)\n\tif err != nil {\n\t\tpanic(err)\n\t} else if count == 0 {\n\t\t//DB.Create(&InitConfigItems)\n\t\trand.Seed(time.Now().UnixNano())\n\t\tApiToken := strconv.Itoa(rand.Intn(10000000))\n\t\tconfigItem := module.ConfigItem{K: \"api_token\", V: ApiToken, G: \"common\"}\n\t\tDB.Create(configItem)\n\t}\n\tif NewPassword != \"\" {\n\t\tconfigItem := module.ConfigItem{}\n\t\tDB.Where(\"k=?\", \"admin_password\").First(&configItem)\n\t\tOldPassword := configItem.V\n\t\tconfigItem.V = NewPassword\n\t\tDB.Where(\"k=?\", \"admin_password\").Updates(configItem)\n\t\tlog.Infof(\"reset password success, old [%s], new [%s] \", OldPassword, NewPassword)\n\t}\n\tif NewUser != \"\" {\n\t\tconfigItem := module.ConfigItem{}\n\t\tDB.Where(\"k=?\", \"admin_user\").First(&configItem)\n\t\tOldUser := configItem.V\n\t\tconfigItem.V = NewUser\n\t\tDB.Where(\"k=?\", \"admin_user\").Updates(configItem)\n\t\tlog.Infof(\"reset user success, old [%s], new [%s] \", OldUser, configItem.V)\n\t}\n\t//\u517c\u5bb9\u65e7\u7248\u672c\u5bc6\u7801\u89c4\u5219\n\tUpdateOldPassword()\n}\n\nfunc UpdateOldPassword() {\n\tvar pwdFiles []module.PwdFiles\n\tc := DB.Where(\"1=1\").Find(&pwdFiles).RowsAffected\n\tif c != 0 {\n\t\tfor _, file := range pwdFiles {\n\t\t\tif file.Id == \"\" {\n\t\t\t\tfile.Id = uuid.NewV4().String()\n\t\t\t\tDB.Table(\"pwd_files\").Where(\"file_path=?\", file.FilePath).Updates(map[string]interface{}{\n\t\t\t\t\t\"expire_at\": 0, \"id\": file.Id,\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunc SaveConfigItems(items []module.ConfigItem) {\n\tfor _, item := range items {\n\t\tvar c module.ConfigItem\n\t\terr := DB.Where(\"k=?\", item.K).First(&c).Error\n\t\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\t\tDB.Create(item)\n\t\t}\n\t}\n}\n\n// init global config\nfunc InitGlobalConfig() {\n\tc := module.Config{}\n\tcis := []module.ConfigItem{}\n\taccounts := []module.Account{}\n\tDB.Raw(\"select * from config_item where 1=1\").Find(&cis)\n\tconfigMap := make(map[string]interface{})\n\tfor _, ci := range cis {\n\t\tconfigMap[ci.K] = ci.V\n\t}\n\tconfigJson, _ := jsoniter.MarshalToString(configMap)\n\tjsoniter.Unmarshal([]byte(configJson), &c)\n\tDB.Raw(\"select * from account order by seq asc\").Find(&accounts)\n\tc.Accounts = accounts\n\tc.HideFiles = GetHideFilesMap()\n\tc.PwdFiles = FindPwdList()\n\tc.BypassList = GetBypassList()\n\tmodule.GloablConfig = c\n\tc.CdnFiles = util.GetCdnFilesMap(c.Cdn, module.VERSION)\n\tc.ShareInfoList = GetShareInfoList()\n\tmodule.GloablConfig = c\n\tRoundRobin()\n}\n\n// share info all list\nfunc GetShareInfoList() []module.ShareInfo {\n\tshareInfoList := []module.ShareInfo{}\n\tDB.Where(\"1 = 1\").Find(&shareInfoList)\n\treturn shareInfoList\n}\n\n// pwd files to map\nfunc GetHideFilesMap() map[string]string {\n\tm := make(map[string]string)\n\thidefiles := []module.HideFiles{}\n\tDB.Where(\"1 = 1\").Find(&hidefiles)\n\tif len(hidefiles) > 0 {\n\t\tfor _, hidefile := range hidefiles {\n\t\t\tm[hidefile.FilePath] = \"1\"\n\t\t}\n\t}\n\treturn m\n}\n\n// hide files to map\nfunc GetPwdFilesMap() map[string]string {\n\tm := make(map[string]string)\n\tpwdfiles := []module.PwdFiles{}\n\tDB.Where(\"1 = 1\").Find(&pwdfiles)\n\tif len(pwdfiles) > 0 {\n\t\tfor _, pwdfile := range pwdfiles {\n\t\t\tm[pwdfile.FilePath] = pwdfile.Password\n\t\t}\n\t}\n\treturn m\n}\n\n// get pwd from full path\nfunc GetPwdFromPath(path string) ([]string, string, bool) {\n\tpwdfiles := []string{}\n\tpwdfile := module.PwdFiles{}\n\tfilePath := \"\"\n\tnow := time.Now().Unix()\n\tlikeSql := \"\"\n\tif DB_TYPE == \"sqlite\" {\n\t\tlikeSql = \"SELECT * FROM pwd_files WHERE ? LIKE file_path || '%' AND (expire_at =0 or expire_at >= ?) ORDER BY LENGTH(file_path) DESC\"\n\t} else if DB_TYPE == \"postgres\" {\n\t\tlikeSql = \"SELECT * FROM pwd_files WHERE ? LIKE concat_ws('', file_path, '%') AND (expire_at =0 or expire_at >= ?) ORDER BY LENGTH(file_path) DESC\"\n\t} else {\n\t\tlikeSql = \"SELECT * FROM pwd_files WHERE ? LIKE concat(file_path, '%') AND (expire_at =0 or expire_at >= ?) ORDER BY LENGTH(file_path) DESC\"\n\t}\n\tresult := DB.Table(\"pwd_files\").Select(\"password\").Where(\"file_path = ? AND (expire_at =0 or expire_at >= ?)\", path, now).Find(&pwdfiles)\n\tif result.RowsAffected == 0 {\n\t\tresult = DB.Raw(likeSql, path, now).First(&pwdfile)\n\t\tif result.RowsAffected == 0 {\n\t\t\treturn pwdfiles, filePath, false\n\t\t} else {\n\t\t\tfilePath = pwdfile.FilePath\n\t\t\tresult = DB.Table(\"pwd_files\").Select(\"password\").Where(\"file_path = ? AND (expire_at =0 or expire_at >= ?)\", pwdfile.FilePath, now).Find(&pwdfiles)\n\t\t}\n\t} else {\n\t\tfilePath = path\n\t}\n\treturn pwdfiles, filePath, true\n}\n\n// find account by name\nfunc FindAccountByName(name string) module.Account {\n\taccount := module.Account{}\n\tDB.Where(\"name = ?\", name).First(&account)\n\treturn account\n}\n\n// find first account by seq\nfunc FindAccountBySeq(seq int) module.Account {\n\taccount := module.Account{}\n\tDB.Where(\"seq = ?\", seq).First(&account)\n\treturn account\n}\n\n// find first file by path\nfunc FindFileByPath(ac module.Account, path string) (module.FileNode, bool) {\n\tfn := module.FileNode{}\n\tok := false\n\tsql := `select fn.* from file_node fn where fn.account_id = ? and fn.path = ?`\n\tDB.Raw(sql, ac.Id, path).First(&fn)\n\tif !fn.IsFolder {\n\t\tok = true\n\t}\n\tif fn.FileId == \"\" {\n\t\t//check root file\n\t\tsql := `select fn.* from file_node fn where fn.account_id = ? and fn.parent_path = ?`\n\t\tDB.Raw(sql, ac.Id, path).First(&fn)\n\t\tif fn.FileId != \"\" {\n\t\t\t_, fileName := util.ParsePath(path)\n\t\t\treturn module.FileNode{\n\t\t\t\tFileId:     ac.RootId,\n\t\t\t\tFileName:   fileName,\n\t\t\t\tFileSize:   0,\n\t\t\t\tIsFolder:   true,\n\t\t\t\tPath:       path,\n\t\t\t\tLastOpTime: time.Now().Format(\"2006-01-02 15:04:05\"),\n\t\t\t}, true\n\t\t}\n\n\t}\n\treturn fn, ok\n}\n\n// find first file  list by path\nfunc FindFileListByPath(ac module.Account, path, sortColumn, sortOrder string) []module.FileNode {\n\tfns := []module.FileNode{}\n\ttx := DB.Where(\"is_delete=0 and hide =0 and account_id=? and parent_path=?\", ac.Id, path)\n\ttx.Order(\"is_folder desc\")\n\t/*if sortColumn != \"default\" && sortOrder != \"\" {\n\t\ttx = tx.Order(fmt.Sprintf(\"%s %s\", sortColumn, sortOrder))\n\t} else {\n\t\ttx = tx.Order(fmt.Sprintf(\"last_op_time asc\"))\n\t}*/\n\ttx.Find(&fns)\n\treturn fns\n}\n\n// update config\nfunc UpdateConfig(config map[string]string) {\n\tfor key, value := range config {\n\t\tDB.Table(\"config_item\").Where(\"k=?\", key).Update(\"v\", value)\n\t}\n\tInitGlobalConfig()\n}\n\n// get config\nfunc GetConfig() module.Config {\n\tc := module.Config{}\n\tcis := []module.ConfigItem{}\n\taccounts := []module.Account{}\n\tDB.Raw(\"select * from config_item where 1=1\").Find(&cis)\n\tconfigMap := make(map[string]interface{})\n\tfor _, ci := range cis {\n\t\tconfigMap[ci.K] = ci.V\n\t}\n\tconfigJson, _ := jsoniter.MarshalToString(configMap)\n\tjsoniter.Unmarshal([]byte(configJson), &c)\n\tDB.Raw(\"select * from account order by `seq` asc\").Find(&accounts)\n\tc.Accounts = accounts\n\tmodule.GloablConfig = c\n\treturn c\n}\n\n// get account\nfunc GetAccountById(id string) module.Account {\n\taccount := module.Account{}\n\tDB.Where(\"id = ?\", id).First(&account)\n\treturn account\n}\n\n// delete accounts\nfunc DeleteAccounts(ids []string) {\n\tfor _, id := range ids {\n\t\t//delete account db file\n\t\tDB.Where(\"account_id = ?\", id).Delete(module.FileNode{})\n\t\t//delete account\n\t\tvar a module.Account\n\t\tvar si module.ShareInfo\n\t\ta.Id = id\n\t\tDB.Model(module.Account{}).Where(\"1=1\").Delete(a)\n\t\t//delete share info\n\t\tDB.Model(module.ShareInfo{}).Where(\"1=1\").Delete(si)\n\t\t//delete login account\n\t\t//base.RemoveLoginAccount(id)\n\t\t// refresh global config\n\t\tInitGlobalConfig()\n\t\t//remove login account\n\t\tdelete(ali.Alis, id)\n\t\tdelete(onedrive.OneDrives, id)\n\t\tdelete(teambition.TeambitionSessions, id)\n\t\tdelete(cloud189.CLoud189s, id)\n\t\tdelete(googledrive.GoogleDrives, id)\n\t\tdelete(s3.S3s, id)\n\t\tdelete(pikpak.Pikpaks, id)\n\t\tdelete(_123.Sessions, id)\n\t\tdelete(_115.Sessions, id)\n\t}\n}\n\nvar RetryTasksCache = gcache.New(100000).LRU().Build()\n\ntype RetryTask struct {\n\taccount      module.Account\n\tfileId, path string\n\thide, hasPwd int\n}\n\n// Loop add files\nfunc LoopCreateFiles(account module.Account, fileId, path string, hide, hasPwd int) {\n\tpan, _ := base.GetPan(account.Mode)\n\tfileNodes, err := pan.Files(account, fileId, path, \"default\", \"null\")\n\tif err != nil {\n\t\tif err.Error() == \"flow limit\" {\n\t\t\tlog.Debugf(\"%s need retry\uff0c err\uff1a%v\", path, err)\n\t\t\t//\u52a0\u5165\u91cd\u8bd5\n\t\t\tRetryTasksCache.Set(account.Id+fileId, RetryTask{account, fileId, path, hide, hasPwd})\n\t\t} else {\n\t\t\tlog.Warningf(\"%s get files error\", account.Mode)\n\t\t\tlog.Errorln(err)\n\t\t}\n\t}\n\tfor _, fn := range fileNodes {\n\t\tFileNodeAuth(&fn, hide, hasPwd)\n\t\tif fn.IsFolder && account.SyncChild == 0 {\n\t\t\tLoopCreateFiles(account, fn.FileId, fn.Path, fn.Hide, fn.HasPwd)\n\t\t}\n\t}\n\tif len(fileNodes) > 0 {\n\t\tDB.Create(&fileNodes)\n\t}\n\tif len(fileNodes) > 0 || (len(fileNodes) == 0 && err == nil) {\n\t\tRetryTasksCache.Remove(account.Id + fileId)\n\t}\n}\n\n// sync account status\nfunc SyncAccountStatus(account module.Account) {\n\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"cookie_status\", -1)\n\tpan, _ := base.GetPan(account.Mode)\n\tauth, err := pan.AuthLogin(&account)\n\tif err == nil && auth != \"\" {\n\t\tlog.Debugf(\"[%s] %s auth login success\", account.Mode, account.Name)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"cookie_status\", 2)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"refresh_token\", auth)\n\t} else {\n\t\tlog.Errorln(err)\n\t\tlog.Errorf(\"[%s] %s auth login fail, api return : %s\", account.Mode, account.Name, auth)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Update(\"cookie_status\", 4)\n\t}\n\tInitGlobalConfig()\n}\n\n// sync files cache\nvar SYNC_STATUS = 0\n\nfunc SyncFilesCache(account module.Account) {\n\tsyncDirs := strings.Split(account.SyncDir, \",\")\n\tfor _, syncDir := range syncDirs {\n\t\tt1 := time.Now()\n\t\tdbFile := module.FileNode{}\n\t\tresult := DB.Raw(\"select * from file_node where path=? and is_delete=0 and account_id=?\", syncDir, account.Id).Take(&dbFile)\n\t\tisRoot := true\n\t\tif !errors.Is(result.Error, gorm.ErrRecordNotFound) {\n\t\t\taccount.RootId = dbFile.FileId\n\t\t\tisRoot = false\n\t\t}\n\t\t//cache new files\n\t\tLoopCreateFiles(account, account.RootId, syncDir, 0, 0)\n\t\t//retry\n\t\tLoopRetryTasks(account.Id)\n\t\t//handle old files && update account status\n\t\tvar fileNodeCount int64\n\t\tDB.Model(&module.FileNode{}).Where(\"account_id=? and is_delete=1\", account.Id).Count(&fileNodeCount)\n\t\tstatus := 3\n\t\tif int(fileNodeCount) > 0 {\n\t\t\tstatus = 2\n\t\t\tif isRoot {\n\t\t\t\t//\u5220\u9664\u65e7\u6570\u636e\n\t\t\t\tDB.Where(\"account_id=? and is_delete=0\", account.Id).Delete(module.FileNode{})\n\t\t\t\t//\u66b4\u9732\u65b0\u6570\u636e\n\t\t\t\tDB.Table(\"file_node\").Where(\"account_id=?\", account.Id).Update(\"is_delete\", 0)\n\t\t\t} else {\n\t\t\t\tRefreshFileNodes(account.Id, account.RootId)\n\t\t\t}\n\t\t\tlog.Infoln(\"[DB cache][\" + account.Name + \"]refresh >> success\")\n\t\t}\n\t\tt2 := time.Now()\n\t\td := t2.Sub(t1)\n\t\tnow := time.Now().UTC().Add(8 * time.Hour)\n\t\tDB.Table(\"account\").Where(\"id=?\", account.Id).Updates(map[string]interface{}{\n\t\t\t\"status\": status, \"files_count\": int(fileNodeCount), \"last_op_time\": now.Format(\"2006-01-02 15:04:05\"),\n\t\t\t\"time_span\": util.ShortDur(d),\n\t\t})\n\t}\n\tInitGlobalConfig()\n\tSYNC_STATUS = 0\n}\n\nfunc LoopRetryTasks(accountId string) {\n\tks := []string{}\n\tfor _, key := range RetryTasksCache.Keys(false) {\n\t\tif strings.HasPrefix(key.(string), accountId) {\n\t\t\tks = append(ks, key.(string))\n\t\t}\n\t}\n\tfor _, k := range ks {\n\t\trt, _ := RetryTasksCache.Get(k)\n\t\tretryTask := rt.(RetryTask)\n\t\ttime.Sleep(time.Duration(1) * time.Second)\n\t\tLoopCreateFiles(retryTask.account, retryTask.fileId, retryTask.path, retryTask.hide, retryTask.hasPwd)\n\t\tlog.Debugf(\"retry path: %s\uff0c\u5269\u4f59\uff1a%d\", retryTask.path, len(ks))\n\t}\n\tif len(ks) > 0 {\n\t\tLoopRetryTasks(accountId)\n\t}\n}\n\nfunc RefreshFileNodes(accountId, fileId string) {\n\ttmpList := []module.FileNode{}\n\tlist := []module.FileNode{}\n\tDB.Raw(\"select * from file_node where parent_id=? and is_delete=0 and account_id=?\", fileId, accountId).Find(&tmpList)\n\tGetAllNodes(&tmpList, &list)\n\tfor _, fn := range list {\n\t\tDB.Where(\"id=?\", fn.Id).Delete(module.FileNode{})\n\t}\n\tDB.Table(\"file_node\").Where(\"account_id=?\", accountId).Update(\"is_delete\", 0)\n}\n\nfunc DeleteFileNodes(accountId, fileId string) {\n\ttmpList := []module.FileNode{}\n\tlist := []module.FileNode{}\n\tDB.Raw(\"select * from file_node where parent_id=? and is_delete=0 and account_id=?\", fileId, accountId).Find(&tmpList)\n\tGetAllNodes(&tmpList, &list)\n\tfor _, fn := range list {\n\t\tDB.Where(\"id=?\", fn.Id).Delete(module.FileNode{})\n\t}\n\tDB.Where(\"file_id=? and account_id=?\", fileId, accountId).Delete(module.FileNode{})\n}\n\nfunc GetAllNodes(tmpList, list *[]module.FileNode) {\n\tfor _, fn := range *tmpList {\n\t\ttmpList = &[]module.FileNode{}\n\t\tDB.Raw(\"select * from file_node where parent_id=? and is_delete=0\", fn.FileId).Find(&tmpList)\n\t\t*list = append(*list, fn)\n\t\tif len(*tmpList) != 0 {\n\t\t\tGetAllNodes(tmpList, list)\n\t\t}\n\t}\n}\n\n// sort accounts\nfunc SortAccounts(ids []string) {\n\tfor i, id := range ids {\n\t\ti++\n\t\tDB.Model(module.Account{}).Where(\"id=?\", id).Update(\"seq\", i)\n\t}\n\tInitGlobalConfig()\n}\n\n// get file id by path\nfunc GetFileIdByPath(accountId, path string) string {\n\tfn := module.FileNode{}\n\tif path == \"/\" {\n\t\tDB.Raw(\"select * from file_node where parent_path=? and is_delete=0 and account_id=? limit 1\", path, accountId).Take(&fn)\n\t\treturn fn.ParentId\n\t} else {\n\t\tDB.Raw(\"select * from file_node where path=? and is_delete=0 and account_id=?\", path, accountId).Take(&fn)\n\t\treturn fn.FileId\n\t}\n}\n\n// save hide file\nfunc SaveHideFile(filePath string) {\n\thideFile := module.HideFiles{FilePath: filePath}\n\terr := DB.Where(\"file_path=?\", filePath).First(&module.HideFiles{}).Error\n\tif errors.Is(err, gorm.ErrRecordNotFound) {\n\t\tDB.Create(&hideFile)\n\t}\n\tInitGlobalConfig()\n}\n\n// delete hide file\nfunc DeleteHideFiles(filePaths []string) {\n\tfor _, filePath := range filePaths {\n\t\tc := DB.Where(\"file_path=?\", filePath).Delete(&module.HideFiles{}).RowsAffected\n\t\tlog.Debugf(\"delete hide file [%s], result [%d]\", filePath, c)\n\t}\n\tInitGlobalConfig()\n}\n\n// save pwd file\nfunc SavePwdFile(pwdFile module.PwdFiles) {\n\tif pwdFile.Password == \"\" {\n\t\tpwdFile.Password = util.RandomPassword(8)\n\t}\n\tdecodedPath, err := url.QueryUnescape(pwdFile.FilePath)\n\tif err != nil {\n\t\tlog.Error(err)\n\t} else {\n\t\tpwdFile.FilePath = decodedPath\n\t}\n\tif pwdFile.Id != \"\" {\n\t\tDB.Table(\"pwd_files\").Where(\"id=?\", pwdFile.Id).Updates(pwdFile)\n\t} else {\n\t\tpwdFile.Id = uuid.NewV4().String()\n\t\tDB.Create(&pwdFile)\n\t}\n}\n\n// delete hide file\nfunc DeletePwdFiles(delIds []string) {\n\tfor _, id := range delIds {\n\t\tc := DB.Where(\"id=?\", id).Delete(&module.PwdFiles{}).RowsAffected\n\t\tlog.Debugf(\"delete pwd file [%s], result [%d]\", id, c)\n\t}\n\tInitGlobalConfig()\n}\n\nfunc GetBypassList() []module.Bypass {\n\tlist := []module.Bypass{}\n\tDB.Find(&list)\n\tif len(list) > 0 {\n\t\tfor i := 0; i < len(list); i++ {\n\t\t\taccounts := []module.Account{}\n\t\t\tDB.Raw(`select\n\t\t\t\ta.*\n\t\t\t\t\tfrom\n\t\t\t\taccount a\n\t\t\t\tleft join bypass_accounts ba on\n\t\t\t\tba.account_id = a.id\n\t\t\t\twhere\n\t\t\t\tba.bypass_id =?`, list[i].Id).Find(&accounts)\n\t\t\tlist[i].Accounts = accounts\n\t\t}\n\t}\n\treturn list\n}\n\nfunc SaveBypass(bypass module.Bypass) string {\n\tif bypass.Id != \"\" {\n\t\terr := DB.Where(\"name=? and id!=?\", bypass.Name, bypass.Id).First(&module.Bypass{}).Error\n\t\tif err == nil {\n\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u5206\u6d41\u540d\u79f0\u5df2\u5b58\u5728\uff01\"\n\t\t}\n\t\t//check account bind\n\t\tfor _, account := range bypass.Accounts {\n\t\t\tacs := []module.BypassAccounts{}\n\t\t\tDB.Where(\"account_id = ? and bypass_id!=?\", account.Id, bypass.Id).Find(&acs)\n\t\t\tif len(acs) > 0 {\n\t\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u7f51\u76d8\u5df2\u88ab\u5176\u4ed6\u5206\u6d41\u7ed1\u5b9a\uff01\"\n\t\t\t}\n\t\t}\n\t\tDB.Where(\"id=?\", bypass.Id).Save(&bypass)\n\t} else {\n\t\terr := DB.Where(\"name=?\", bypass.Name).First(&module.Bypass{}).Error\n\t\tif err == nil {\n\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u5206\u6d41\u540d\u79f0\u5df2\u5b58\u5728\uff01\"\n\t\t}\n\t\t//check account bind\n\t\tfor _, account := range bypass.Accounts {\n\t\t\tacs := []module.BypassAccounts{}\n\t\t\tDB.Where(\"account_id = ?\", account.Id).Find(&acs)\n\t\t\tif len(acs) > 0 {\n\t\t\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u7f51\u76d8\u5df2\u88ab\u5176\u4ed6\u5206\u6d41\u7ed1\u5b9a\uff01\"\n\t\t\t}\n\t\t}\n\t\tbypass.Id = uuid.NewV4().String()\n\t\tDB.Create(&bypass)\n\t}\n\tDB.Where(\"bypass_id = ?\", bypass.Id).Delete(&module.BypassAccounts{})\n\tfor _, account := range bypass.Accounts {\n\t\tba := module.BypassAccounts{bypass.Id, account.Id}\n\t\tDB.Create(&ba)\n\t}\n\tInitGlobalConfig()\n\treturn \"\u4fdd\u5b58\u6210\u529f\uff01\"\n}\n\nfunc DeleteBypass(ids []string) {\n\tfor _, id := range ids {\n\t\tc := DB.Where(\"id=?\", id).Delete(&module.Bypass{}).RowsAffected\n\t\tDB.Where(\"bypass_id=?\", id).Delete(&module.BypassAccounts{})\n\t\tlog.Debugf(\"delete bypass [%s], result [%d]\", id, c)\n\t}\n\tInitGlobalConfig()\n}\n\nfunc RoundRobin() {\n\tif len(module.GloablConfig.BypassList) > 0 {\n\t\tfor i := 0; i < len(module.GloablConfig.BypassList); i++ {\n\t\t\trrw := weighted.NewRandW()\n\t\t\tfor _, account := range module.GloablConfig.BypassList[i].Accounts {\n\t\t\t\trrw.Add(account, 1)\n\t\t\t}\n\t\t\tmodule.GloablConfig.BypassList[i].Rw = rrw\n\t\t}\n\t}\n}\n\nfunc FindAccountsByPath(path string) ([]module.Account, string) {\n\taccounts := []module.Account{}\n\tfn := module.FileNode{}\n\tDB.Where(\"path=?\", path).First(&fn)\n\tif fn.Path != \"\" {\n\t\tif !fn.IsFolder {\n\t\t\tpath = fn.ParentPath\n\t\t}\n\t}\n\tDB.Raw(`select a.* from file_node fn left join account a on a.id = fn.account_id where fn.path = ? group by a.id`, path).\n\t\tFind(&accounts)\n\tif len(accounts) == 0 {\n\t\tDB.Raw(`select a.* from file_node fn left join account a on a.id = fn.account_id where fn.parent_path = ? group by a.id`, path).\n\t\t\tFind(&accounts)\n\t}\n\treturn accounts, path\n}\n\nfunc UpdateCacheConfig(account module.Account, t string) {\n\taccount.Status = -1\n\tac := GetAccountById(account.Id)\n\tif t == \"1\" {\n\t\tDB.Where(\"account_id = ?\", account.Id).Delete(module.FileNode{})\n\t}\n\tif account.CachePolicy == \"dc\" {\n\t\tif t == \"1\" {\n\t\t\tif SYNC_STATUS == 0 {\n\t\t\t\tbypass := SelectBypassByAccountId(account.Id)\n\t\t\t\tcachePath := \"/\" + ac.Name\n\t\t\t\tif bypass.Name != \"\" {\n\t\t\t\t\tcachePath = \"/\" + bypass.Name\n\t\t\t\t}\n\t\t\t\tac.SyncDir = cachePath\n\t\t\t\tgo SyncFilesCache(ac)\n\t\t\t}\n\t\t} else {\n\t\t\taccount.Status = 2\n\t\t}\n\n\t} else {\n\t\taccount.Status = 2\n\t}\n\tDB.Model(&[]module.Account{}).\n\t\tSelect(\"CachePolicy\", \"SyncDir\", \"SyncChild\", \"ExpireTimeSpan\", \"SyncCron\", \"Status\").\n\t\tWhere(\"id=?\", account.Id).\n\t\tUpdates(&account)\n\tgo SaveCacheCron(ac)\n\tInitGlobalConfig()\n}\n\nfunc SaveCacheCron(ac module.Account) {\n\tc, ok := util.CacheCronMap[ac.Id]\n\tif ok {\n\t\tif ac.CachePolicy != \"dc\" || ac.SyncCron == \"\" || ac.SyncDir == \"\" {\n\t\t\tutil.Cron.Remove(c)\n\t\t\tdelete(util.CacheCronMap, ac.Id)\n\t\t} else {\n\t\t\tutil.Cron.Remove(c)\n\t\t\tentryId, err := util.Cron.AddFunc(ac.SyncCron, func() {\n\t\t\t\tSyncFilesCache(ac)\n\t\t\t\t//log.Debugf(\"[%s] [%s] [%s] [%s] [%s]\", ac.Name, ac.Mode, ac.CachePolicy, ac.SyncCron, ac.SyncDir)\n\t\t\t})\n\t\t\tif err == nil {\n\t\t\t\tutil.CacheCronMap[ac.Id] = entryId\n\t\t\t}\n\t\t}\n\t} else {\n\t\tif ac.CachePolicy == \"dc\" && ac.SyncCron != \"\" && ac.SyncDir != \"\" {\n\t\t\tutil.Cron.Remove(c)\n\t\t\tentryId, err := util.Cron.AddFunc(ac.SyncCron, func() {\n\t\t\t\tSyncFilesCache(ac)\n\t\t\t\t//log.Debugf(\"[%s] [%s] [%s] [%s] [%s]\", ac.Name, ac.Mode, ac.CachePolicy, ac.SyncCron, ac.SyncDir)\n\t\t\t})\n\t\t\tif err == nil {\n\t\t\t\tutil.CacheCronMap[ac.Id] = entryId\n\t\t\t}\n\t\t}\n\t}\n\n}\n\nfunc SaveAccount(account module.Account) string {\n\t//check name exists\n\tif AccountNameExist(account.Id, account.Name) {\n\t\treturn \"\u4fdd\u5b58\u5931\u8d25\uff0c\u7f51\u76d8\uff08\u6216\u5206\u6d41\uff09\u540d\u79f0\u5df2\u5b58\u5728\uff01\"\n\t}\n\tif account.Id == \"\" {\n\t\taccount.Id = uuid.NewV4().String()\n\t\taccount.CachePolicy = \"nc\"\n\t\taccount.SyncDir = \"/\" + account.Name\n\t\taccount.SyncChild = 0\n\t\taccount.ExpireTimeSpan = 1\n\t\taccount.SyncCron = \"\"\n\t\taccount.LastOpTime = time.Now().Format(\"2006-01-02 15:04:05\")\n\t\tvar seq int\n\t\tDB.Table(\"account\").Raw(\"select seq from account where 1=1 order by seq desc limit 1\").Take(&seq)\n\t\taccount.Seq = seq + 1\n\t\tDB.Create(&account)\n\t} else {\n\t\taccount.LastOpTime = time.Now().Format(\"2006-01-02 15:04:05\")\n\t\tDB.Model(&[]module.Account{}).\n\t\t\tSelect(\"Id\", \"Name\", \"Mode\", \"User\", \"Password\", \"RefreshToken\", \"AccessToken\", \"SiteId\",\n\t\t\t\t\"RedirectUri\", \"ApiUrl\", \"RootId\", \"LastOpTime\", \"DownTransfer\", \"TransferUrl\", \"Host\", \"TransferDomain\", \"PathStyle\", \"Info\").\n\t\t\tWhere(\"id=?\", account.Id).\n\t\t\tUpdates(&account)\n\t}\n\tSyncAccountStatus(account)\n\tInitGlobalConfig()\n\treturn \"\u4fdd\u5b58\u6210\u529f\uff01\"\n}\n\nfunc AccountNameExist(id, name string) bool {\n\tif id != \"\" {\n\t\terr := DB.Where(\"name=? and id!=?\", name, id).First(&module.Account{}).Error\n\t\tif err == nil {\n\t\t\treturn true\n\t\t}\n\t} else {\n\t\terr := DB.Where(\"name=?\", name).First(&module.Account{}).Error\n\t\tif err == nil {\n\t\t\treturn true\n\t\t}\n\t}\n\terr := DB.Where(\"name=?\", name).First(&module.Bypass{}).Error\n\tif err == nil {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc SelectBypassByAccountId(accountId string) module.Bypass {\n\tbypass := module.Bypass{}\n\tDB.Raw(`select\n\t\t\t\t\t\tb.*\n\t\t\t\t\tfrom\n\t\t\t\t\t\tbypass_accounts ba\n\t\t\t\t\tleft join bypass b on\n\t\t\t\t\t\tba.bypass_id = b.id\n\t\t\t\t\twhere\n\t\t\t\t\t\tba.account_id = ?`, accountId).Find(&bypass)\n\treturn bypass\n}\n\nfunc SaveShareInfo(info module.ShareInfo) {\n\terr := DB.Where(\"file_path=?\", info.FilePath).First(&module.ShareInfo{}).Error\n\tif err != nil && errors.Is(err, gorm.ErrRecordNotFound) {\n\t\tDB.Create(&info)\n\t} else {\n\t\tDB.Model(&[]module.ShareInfo{}).\n\t\t\tSelect(\"ShortCode\", \"IsFile\").\n\t\t\tWhere(\"file_path=?\", info.FilePath).\n\t\t\tUpdates(&info)\n\t}\n}\n\nfunc FindPwdList() []module.PwdFiles {\n\tpwdFiles := []module.PwdFiles{}\n\tDB.Raw(\"select * from pwd_files where 1=1\").Find(&pwdFiles)\n\treturn pwdFiles\n}\n\nfunc FileNodeAuth(fn *module.FileNode, hide, hasPwd int) {\n\tif hide == 1 {\n\t\tfn.Hide = hide\n\t} else {\n\t\t_, ok := module.GloablConfig.HideFiles[fn.FileId]\n\t\tif ok {\n\t\t\tfn.Hide = 1\n\t\t} else {\n\t\t\tfn.Hide = 0\n\t\t}\n\t}\n\tif hasPwd == 1 {\n\t\tfn.HasPwd = hasPwd\n\t} else {\n\t\t_, _, ok := GetPwdFromPath(fn.Path)\n\t\tif ok {\n\t\t\tfn.HasPwd = 1\n\t\t} else {\n\t\t\tfn.HasPwd = 0\n\t\t}\n\t}\n}\n\nfunc SelectAccountsById(ids []string) []module.Account {\n\tvar accounts []module.Account\n\tDB.Where(\"id IN ?\", ids).Find(&accounts)\n\treturn accounts\n}\n"], "filenames": ["control/middleware/jwt.go", "dao/db.go"], "buggy_code_start_loc": [23, 75], "buggy_code_end_loc": [24, 75], "fixing_code_start_loc": [23, 76], "fixing_code_end_loc": [24, 77], "type": "CWE-798", "message": "PanIndex is a network disk directory index. In Panindex prior to version 3.1.3, a hard-coded JWT key `PanIndex` is used. An attacker can use the hard-coded JWT key to sign JWT token and perform any actions as a user with admin privileges. Version 3.1.3 has a patch for the issue. As a workaround, one may change the JWT key in the source code before compiling the project.", "other": {"cve": {"id": "CVE-2023-27583", "sourceIdentifier": "security-advisories@github.com", "published": "2023-03-13T21:15:14.130", "lastModified": "2023-03-17T17:01:00.507", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PanIndex is a network disk directory index. In Panindex prior to version 3.1.3, a hard-coded JWT key `PanIndex` is used. An attacker can use the hard-coded JWT key to sign JWT token and perform any actions as a user with admin privileges. Version 3.1.3 has a patch for the issue. As a workaround, one may change the JWT key in the source code before compiling the project."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-798"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-321"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:panindex_project:panindex:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.3", "matchCriteriaId": "7D580FA1-B0E8-4B6E-A566-3A8D679897D9"}]}]}], "references": [{"url": "https://github.com/px-org/PanIndex/commit/f7ec0c5739af055ad3a825a20294a5c01ada3302", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/px-org/PanIndex/releases/tag/v3.1.3", "source": "security-advisories@github.com", "tags": ["Release Notes"]}, {"url": "https://github.com/px-org/PanIndex/security/advisories/GHSA-82wq-gmw8-g87v", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/px-org/PanIndex/commit/f7ec0c5739af055ad3a825a20294a5c01ada3302"}}