{"buggy_code": ["/*\n * USB Serial Console driver\n *\n * Copyright (C) 2001 - 2002 Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * Thanks to Randy Dunlap for the original version of this code.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstruct usbcons_info {\n\tint\t\t\tmagic;\n\tint\t\t\tbreak_flag;\n\tstruct usb_serial_port\t*port;\n};\n\nstatic struct usbcons_info usbcons_info;\nstatic struct console usbcons;\n\n/*\n * ------------------------------------------------------------\n * USB Serial console driver\n *\n * Much of the code here is copied from drivers/char/serial.c\n * and implements a phony serial console in the same way that\n * serial.c does so that in case some software queries it,\n * it will get the same results.\n *\n * Things that are different from the way the serial port code\n * does things, is that we call the lower level usb-serial\n * driver code to initialize the device, and we set the initial\n * console speeds based on the command line arguments.\n * ------------------------------------------------------------\n */\n\nstatic const struct tty_operations usb_console_fake_tty_ops = {\n};\n\n/*\n * The parsing of the command line works exactly like the\n * serial.c code, except that the specifier is \"ttyUSB\" instead\n * of \"ttyS\".\n */\nstatic int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n\nstatic void usb_console_write(struct console *co,\n\t\t\t\t\tconst char *buf, unsigned count)\n{\n\tstatic struct usbcons_info *info = &usbcons_info;\n\tstruct usb_serial_port *port = info->port;\n\tstruct usb_serial *serial;\n\tint retval = -ENODEV;\n\n\tif (!port || port->serial->dev->state == USB_STATE_NOTATTACHED)\n\t\treturn;\n\tserial = port->serial;\n\n\tif (count == 0)\n\t\treturn;\n\n\tdev_dbg(&port->dev, \"%s - %d byte(s)\\n\", __func__, count);\n\n\tif (!port->port.console) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\twhile (count) {\n\t\tunsigned int i;\n\t\tunsigned int lf;\n\t\t/* search for LF so we can insert CR if necessary */\n\t\tfor (i = 0, lf = 0 ; i < count ; i++) {\n\t\t\tif (*(buf + i) == 10) {\n\t\t\t\tlf = 1;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* pass on to the driver specific version of this function if\n\t\t   it is available */\n\t\tretval = serial->type->write(NULL, port, buf, i);\n\t\tdev_dbg(&port->dev, \"%s - write: %d\\n\", __func__, retval);\n\t\tif (lf) {\n\t\t\t/* append CR after LF */\n\t\t\tunsigned char cr = 13;\n\t\t\tretval = serial->type->write(NULL, port, &cr, 1);\n\t\t\tdev_dbg(&port->dev, \"%s - write cr: %d\\n\",\n\t\t\t\t\t\t\t__func__, retval);\n\t\t}\n\t\tbuf += i;\n\t\tcount -= i;\n\t}\n}\n\nstatic struct tty_driver *usb_console_device(struct console *co, int *index)\n{\n\tstruct tty_driver **p = (struct tty_driver **)co->data;\n\n\tif (!*p)\n\t\treturn NULL;\n\n\t*index = co->index;\n\treturn *p;\n}\n\nstatic struct console usbcons = {\n\t.name =\t\t\"ttyUSB\",\n\t.write =\tusb_console_write,\n\t.device =\tusb_console_device,\n\t.setup =\tusb_console_setup,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n\t.data = \t&usb_serial_tty_driver,\n};\n\nvoid usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}\n\nvoid usb_serial_console_init(int minor)\n{\n\tif (minor == 0) {\n\t\t/*\n\t\t * Call register_console() if this is the first device plugged\n\t\t * in.  If we call it earlier, then the callback to\n\t\t * console_setup() will fail, as there is not a device seen by\n\t\t * the USB subsystem yet.\n\t\t */\n\t\t/*\n\t\t * Register console.\n\t\t * NOTES:\n\t\t * console_setup() is called (back) immediately (from\n\t\t * register_console). console_write() is called immediately\n\t\t * from register_console iff CON_PRINTBUFFER is set in flags.\n\t\t */\n\t\tpr_debug(\"registering the USB serial console.\\n\");\n\t\tregister_console(&usbcons);\n\t}\n}\n\nvoid usb_serial_console_exit(void)\n{\n\tif (usbcons_info.port) {\n\t\tunregister_console(&usbcons);\n\t\tusbcons_info.port->port.console = 0;\n\t\tusbcons_info.port = NULL;\n\t}\n}\n\n"], "fixing_code": ["/*\n * USB Serial Console driver\n *\n * Copyright (C) 2001 - 2002 Greg Kroah-Hartman (greg@kroah.com)\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * Thanks to Randy Dunlap for the original version of this code.\n *\n */\n\n#define pr_fmt(fmt) KBUILD_MODNAME \": \" fmt\n\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/console.h>\n#include <linux/serial.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\nstruct usbcons_info {\n\tint\t\t\tmagic;\n\tint\t\t\tbreak_flag;\n\tstruct usb_serial_port\t*port;\n};\n\nstatic struct usbcons_info usbcons_info;\nstatic struct console usbcons;\n\n/*\n * ------------------------------------------------------------\n * USB Serial console driver\n *\n * Much of the code here is copied from drivers/char/serial.c\n * and implements a phony serial console in the same way that\n * serial.c does so that in case some software queries it,\n * it will get the same results.\n *\n * Things that are different from the way the serial port code\n * does things, is that we call the lower level usb-serial\n * driver code to initialize the device, and we set the initial\n * console speeds based on the command line arguments.\n * ------------------------------------------------------------\n */\n\nstatic const struct tty_operations usb_console_fake_tty_ops = {\n};\n\n/*\n * The parsing of the command line works exactly like the\n * serial.c code, except that the specifier is \"ttyUSB\" instead\n * of \"ttyS\".\n */\nstatic int usb_console_setup(struct console *co, char *options)\n{\n\tstruct usbcons_info *info = &usbcons_info;\n\tint baud = 9600;\n\tint bits = 8;\n\tint parity = 'n';\n\tint doflow = 0;\n\tint cflag = CREAD | HUPCL | CLOCAL;\n\tchar *s;\n\tstruct usb_serial *serial;\n\tstruct usb_serial_port *port;\n\tint retval;\n\tstruct tty_struct *tty = NULL;\n\tstruct ktermios dummy;\n\n\tif (options) {\n\t\tbaud = simple_strtoul(options, NULL, 10);\n\t\ts = options;\n\t\twhile (*s >= '0' && *s <= '9')\n\t\t\ts++;\n\t\tif (*s)\n\t\t\tparity = *s++;\n\t\tif (*s)\n\t\t\tbits   = *s++ - '0';\n\t\tif (*s)\n\t\t\tdoflow = (*s++ == 'r');\n\t}\n\t\n\t/* Sane default */\n\tif (baud == 0)\n\t\tbaud = 9600;\n\n\tswitch (bits) {\n\tcase 7:\n\t\tcflag |= CS7;\n\t\tbreak;\n\tdefault:\n\tcase 8:\n\t\tcflag |= CS8;\n\t\tbreak;\n\t}\n\tswitch (parity) {\n\tcase 'o': case 'O':\n\t\tcflag |= PARODD;\n\t\tbreak;\n\tcase 'e': case 'E':\n\t\tcflag |= PARENB;\n\t\tbreak;\n\t}\n\tco->cflag = cflag;\n\n\t/*\n\t * no need to check the index here: if the index is wrong, console\n\t * code won't call us\n\t */\n\tport = usb_serial_port_get_by_minor(co->index);\n\tif (port == NULL) {\n\t\t/* no device is connected yet, sorry :( */\n\t\tpr_err(\"No USB device connected to ttyUSB%i\\n\", co->index);\n\t\treturn -ENODEV;\n\t}\n\tserial = port->serial;\n\n\tretval = usb_autopm_get_interface(serial->interface);\n\tif (retval)\n\t\tgoto error_get_interface;\n\n\ttty_port_tty_set(&port->port, NULL);\n\n\tinfo->port = port;\n\n\t++port->port.count;\n\tif (!tty_port_initialized(&port->port)) {\n\t\tif (serial->type->set_termios) {\n\t\t\t/*\n\t\t\t * allocate a fake tty so the driver can initialize\n\t\t\t * the termios structure, then later call set_termios to\n\t\t\t * configure according to command line arguments\n\t\t\t */\n\t\t\ttty = kzalloc(sizeof(*tty), GFP_KERNEL);\n\t\t\tif (!tty) {\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto reset_open_count;\n\t\t\t}\n\t\t\tkref_init(&tty->kref);\n\t\t\ttty->driver = usb_serial_tty_driver;\n\t\t\ttty->index = co->index;\n\t\t\tinit_ldsem(&tty->ldisc_sem);\n\t\t\tspin_lock_init(&tty->files_lock);\n\t\t\tINIT_LIST_HEAD(&tty->tty_files);\n\t\t\tkref_get(&tty->driver->kref);\n\t\t\t__module_get(tty->driver->owner);\n\t\t\ttty->ops = &usb_console_fake_tty_ops;\n\t\t\ttty_init_termios(tty);\n\t\t\ttty_port_tty_set(&port->port, tty);\n\t\t}\n\n\t\t/* only call the device specific open if this\n\t\t * is the first time the port is opened */\n\t\tretval = serial->type->open(NULL, port);\n\t\tif (retval) {\n\t\t\tdev_err(&port->dev, \"could not open USB console port\\n\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (serial->type->set_termios) {\n\t\t\ttty->termios.c_cflag = cflag;\n\t\t\ttty_termios_encode_baud_rate(&tty->termios, baud, baud);\n\t\t\tmemset(&dummy, 0, sizeof(struct ktermios));\n\t\t\tserial->type->set_termios(tty, port, &dummy);\n\n\t\t\ttty_port_tty_set(&port->port, NULL);\n\t\t\ttty_kref_put(tty);\n\t\t}\n\t\ttty_port_set_initialized(&port->port, 1);\n\t}\n\t/* Now that any required fake tty operations are completed restore\n\t * the tty port count */\n\t--port->port.count;\n\t/* The console is special in terms of closing the device so\n\t * indicate this port is now acting as a system console. */\n\tport->port.console = 1;\n\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n\n fail:\n\ttty_port_tty_set(&port->port, NULL);\n\ttty_kref_put(tty);\n reset_open_count:\n\tport->port.count = 0;\n\tinfo->port = NULL;\n\tusb_autopm_put_interface(serial->interface);\n error_get_interface:\n\tusb_serial_put(serial);\n\tmutex_unlock(&serial->disc_mutex);\n\treturn retval;\n}\n\nstatic void usb_console_write(struct console *co,\n\t\t\t\t\tconst char *buf, unsigned count)\n{\n\tstatic struct usbcons_info *info = &usbcons_info;\n\tstruct usb_serial_port *port = info->port;\n\tstruct usb_serial *serial;\n\tint retval = -ENODEV;\n\n\tif (!port || port->serial->dev->state == USB_STATE_NOTATTACHED)\n\t\treturn;\n\tserial = port->serial;\n\n\tif (count == 0)\n\t\treturn;\n\n\tdev_dbg(&port->dev, \"%s - %d byte(s)\\n\", __func__, count);\n\n\tif (!port->port.console) {\n\t\tdev_dbg(&port->dev, \"%s - port not opened\\n\", __func__);\n\t\treturn;\n\t}\n\n\twhile (count) {\n\t\tunsigned int i;\n\t\tunsigned int lf;\n\t\t/* search for LF so we can insert CR if necessary */\n\t\tfor (i = 0, lf = 0 ; i < count ; i++) {\n\t\t\tif (*(buf + i) == 10) {\n\t\t\t\tlf = 1;\n\t\t\t\ti++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* pass on to the driver specific version of this function if\n\t\t   it is available */\n\t\tretval = serial->type->write(NULL, port, buf, i);\n\t\tdev_dbg(&port->dev, \"%s - write: %d\\n\", __func__, retval);\n\t\tif (lf) {\n\t\t\t/* append CR after LF */\n\t\t\tunsigned char cr = 13;\n\t\t\tretval = serial->type->write(NULL, port, &cr, 1);\n\t\t\tdev_dbg(&port->dev, \"%s - write cr: %d\\n\",\n\t\t\t\t\t\t\t__func__, retval);\n\t\t}\n\t\tbuf += i;\n\t\tcount -= i;\n\t}\n}\n\nstatic struct tty_driver *usb_console_device(struct console *co, int *index)\n{\n\tstruct tty_driver **p = (struct tty_driver **)co->data;\n\n\tif (!*p)\n\t\treturn NULL;\n\n\t*index = co->index;\n\treturn *p;\n}\n\nstatic struct console usbcons = {\n\t.name =\t\t\"ttyUSB\",\n\t.write =\tusb_console_write,\n\t.device =\tusb_console_device,\n\t.setup =\tusb_console_setup,\n\t.flags =\tCON_PRINTBUFFER,\n\t.index =\t-1,\n\t.data = \t&usb_serial_tty_driver,\n};\n\nvoid usb_serial_console_disconnect(struct usb_serial *serial)\n{\n\tif (serial->port[0] && serial->port[0] == usbcons_info.port) {\n\t\tusb_serial_console_exit();\n\t\tusb_serial_put(serial);\n\t}\n}\n\nvoid usb_serial_console_init(int minor)\n{\n\tif (minor == 0) {\n\t\t/*\n\t\t * Call register_console() if this is the first device plugged\n\t\t * in.  If we call it earlier, then the callback to\n\t\t * console_setup() will fail, as there is not a device seen by\n\t\t * the USB subsystem yet.\n\t\t */\n\t\t/*\n\t\t * Register console.\n\t\t * NOTES:\n\t\t * console_setup() is called (back) immediately (from\n\t\t * register_console). console_write() is called immediately\n\t\t * from register_console iff CON_PRINTBUFFER is set in flags.\n\t\t */\n\t\tpr_debug(\"registering the USB serial console.\\n\");\n\t\tregister_console(&usbcons);\n\t}\n}\n\nvoid usb_serial_console_exit(void)\n{\n\tif (usbcons_info.port) {\n\t\tunregister_console(&usbcons);\n\t\tusbcons_info.port->port.console = 0;\n\t\tusbcons_info.port = NULL;\n\t}\n}\n\n"], "filenames": ["drivers/usb/serial/console.c"], "buggy_code_start_loc": [188], "buggy_code_end_loc": [188], "fixing_code_start_loc": [189], "fixing_code_end_loc": [190], "type": "CWE-416", "message": "The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup.", "other": {"cve": {"id": "CVE-2017-16525", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-04T01:29:36.740", "lastModified": "2018-03-16T01:29:06.623", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup."}, {"lang": "es", "value": "La funci\u00f3n usb_serial_console_disconnect en drivers/usb/serial/console.c en el kernel de Linux, en versiones anteriores a la 4.13.8, permite que los usuarios locales provoquen una denegaci\u00f3n de servicio (uso de memoria previamente liberada y cierre inesperado del sistema) o, posiblemente, causen otros impactos no especificados mediante llamadas del sistema manipuladas. Esto est\u00e1 relacionado con desconexi\u00f3n y fallo de instalaci\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:P/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "PHYSICAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 7.2}, "baseSeverity": "HIGH", "exploitabilityScore": 3.9, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.7", "matchCriteriaId": "11C6B206-8716-4A16-81BD-F3B8C8ACBE19"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/102028", "source": "cve@mitre.org"}, {"url": "https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bd998c2e0df0469707503023d50d46cf0b10c787", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://groups.google.com/d/msg/syzkaller/cMACrmo1x0k/4KhRoUgABAAJ", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2017/12/msg00004.html", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3583-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/3583-2/", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047"}}