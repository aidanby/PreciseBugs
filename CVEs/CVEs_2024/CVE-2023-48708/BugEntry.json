{"buggy_code": ["# JWT Authentication\n\n!!! note\n\n    Shield now supports only JWS (Singed JWT). JWE (Encrypted JWT) is not supported.\n\n## What is JWT?\n\nJWT or JSON Web Token is a compact and self-contained way of securely transmitting\ninformation between parties as a JSON object. It is commonly used for authentication\nand authorization purposes in web applications.\n\nFor example, when a user logs in to a web application, the server generates a JWT\ntoken and sends it to the client. The client then includes this token in the header\nof subsequent requests to the server. The server verifies the authenticity of the\ntoken and grants access to protected resources accordingly.\n\nIf you are not familiar with JWT, we recommend that you check out\n[Introduction to JSON Web Tokens](https://jwt.io/introduction) before continuing.\n\n## Setup\n\nTo use JWT Authentication, you need additional setup and configuration.\n\n### Manual Setup\n\n1. Install \"firebase/php-jwt\" via Composer.\n\n    ```console\n    composer require firebase/php-jwt:^6.4\n    ```\n\n2. Copy the **AuthJWT.php** from **vendor/codeigniter4/shield/src/Config/** into your project's config folder and update the namespace to `Config`. You will also need to have these classes extend the original classes. See the example below.\n\n    ```php\n    <?php\n    \n    // app/Config/AuthJWT.php\n    \n    declare(strict_types=1);\n\n    namespace Config;\n\n    use CodeIgniter\\Shield\\Config\\AuthJWT as ShieldAuthJWT;\n\n    /**\n     * JWT Authenticator Configuration\n     */\n    class AuthJWT extends ShieldAuthJWT\n    {\n        // ...\n    }\n    ```\n\n3. If your **app/Config/Auth.php** is not up-to-date, you also need to update it. Check **vendor/codeigniter4/shield/src/Config/Auth.php** and apply the differences.\n\n    You need to add the following constants:\n    ```php\n    public const RECORD_LOGIN_ATTEMPT_NONE    = 0; // Do not record at all\n    public const RECORD_LOGIN_ATTEMPT_FAILURE = 1; // Record only failures\n    public const RECORD_LOGIN_ATTEMPT_ALL     = 2; // Record all login attempts\n    ```\n\n    You need to add JWT Authenticator:\n    ```php\n    use CodeIgniter\\Shield\\Authentication\\Authenticators\\JWT;\n\n    // ...\n\n    public array $authenticators = [\n        'tokens'  => AccessTokens::class,\n        'session' => Session::class,\n        'jwt'     => JWT::class,\n    ];\n    ```\n\n    If you want to use JWT Authenticator in Authentication Chain, add `jwt`:\n    ```php\n    public array $authenticationChain = [\n        'session',\n        'tokens',\n        'jwt'\n    ];\n    ```\n\n## Configuration\n\nConfigure **app/Config/AuthJWT.php** for your needs.\n\n### Set the Default Claims\n\n!!! note\n\n    A payload contains the actual data being transmitted, such as user ID, role,\n    or expiration time. Items in a payload is called *claims*.\n\nSet the default payload items to the property `$defaultClaims`.\n\nE.g.:\n```php\npublic array $defaultClaims = [\n    'iss' => 'https://codeigniter.com/',\n];\n```\n\nThe default claims will be included in all tokens issued by Shield.\n\n### Set Secret Key\n\nSet your secret key in the `$keys` property, or set it in your `.env` file.\n\nE.g.:\n```text\nauthjwt.keys.default.0.secret = 8XBFsF6HThIa7OV/bSynahEch+WbKrGcuiJVYPiwqPE=\n```\n\nIt needs at least 256 bits random string. The length of the secret depends on the\nalgorithm we use. The default one is `HS256`, so to ensure that the hash value is\nsecure and not easily guessable, the secret key should be at least as long as the\nhash function's output - 256 bits (32 bytes). You can get a secure random string\nwith the following command:\n\n```console\nphp -r 'echo base64_encode(random_bytes(32));'\n```\n\n!!! note\n\n    The secret key is used for signing and validating tokens.\n\n## Issuing JWTs\n\nTo use JWT Authentication, you need a controller that issues JWTs.\n\nHere is a sample controller. When a client posts valid credentials (email/password),\nit returns a new JWT.\n\n```php\n// app/Config/Routes.php\n$routes->post('auth/jwt', '\\App\\Controllers\\Auth\\LoginController::jwtLogin');\n```\n\n```php\n<?php\n\n// app/Controllers/Auth/LoginController.php\n\ndeclare(strict_types=1);\n\nnamespace App\\Controllers\\Auth;\n\nuse App\\Controllers\\BaseController;\nuse CodeIgniter\\API\\ResponseTrait;\nuse CodeIgniter\\HTTP\\ResponseInterface;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\Session;\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\nuse CodeIgniter\\Shield\\Validation\\ValidationRules;\n\nclass LoginController extends BaseController\n{\n    use ResponseTrait;\n\n    /**\n     * Authenticate Existing User and Issue JWT.\n     */\n    public function jwtLogin(): ResponseInterface\n    {\n        // Get the validation rules\n        $rules = $this->getValidationRules();\n\n        // Validate credentials\n        if (! $this->validateData($this->request->getJSON(true), $rules, [], config('Auth')->DBGroup)) {\n            return $this->fail(\n                ['errors' => $this->validator->getErrors()],\n                $this->codes['unauthorized']\n            );\n        }\n\n        // Get the credentials for login\n        $credentials             = $this->request->getJsonVar(setting('Auth.validFields'));\n        $credentials             = array_filter($credentials);\n        $credentials['password'] = $this->request->getJsonVar('password');\n\n        /** @var Session $authenticator */\n        $authenticator = auth('session')->getAuthenticator();\n\n        // Check the credentials\n        $result = $authenticator->check($credentials);\n\n        // Credentials mismatch.\n        if (! $result->isOK()) {\n            // @TODO Record a failed login attempt\n\n            return $this->failUnauthorized($result->reason());\n        }\n\n        // Credentials match.\n        // @TODO Record a successful login attempt\n\n        $user = $result->extraInfo();\n\n        /** @var JWTManager $manager */\n        $manager = service('jwtmanager');\n\n        // Generate JWT and return to client\n        $jwt = $manager->generateToken($user);\n\n        return $this->respond([\n            'access_token' => $jwt,\n        ]);\n    }\n\n    /**\n     * Returns the rules that should be used for validation.\n     *\n     * @return array<string, array<string, array<string>|string>>\n     * @phpstan-return array<string, array<string, string|list<string>>>\n     */\n    protected function getValidationRules(): array\n    {\n        $rules = new ValidationRules();\n\n        return $rules->getLoginRules();\n    }\n}\n```\n\nYou could send a request with the existing user's credentials by curl like this:\n\n```curl\ncurl --location 'http://localhost:8080/auth/jwt' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\"email\" : \"admin@example.jp\" , \"password\" : \"passw0rd!\"}'\n```\n\nWhen making all future requests to the API, the client should send the JWT in\nthe `Authorization` header as a `Bearer` token.\n\nYou could send a request with the `Authorization` header by curl like this:\n\n```curl\ncurl --location --request GET 'http://localhost:8080/api/users' \\\n--header 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJTaGllbGQgVGVzdCBBcHAiLCJzdWIiOiIxIiwiaWF0IjoxNjgxODA1OTMwLCJleHAiOjE2ODE4MDk1MzB9.DGpOmRPOBe45whVtEOSt53qJTw_CpH0V8oMoI_gm2XI'\n```\n\n## Protecting Routes\n\nThe first way to specify which routes are protected is to use the `jwt` controller\nfilter.\n\nFor example, to ensure it protects all routes under the `/api` route group, you\nwould use the `$filters` setting on **app/Config/Filters.php**.\n\n```php\npublic $filters = [\n    'jwt' => ['before' => ['api', 'api/*']],\n];\n```\n\nYou can also specify the filter should run on one or more routes within the routes\nfile itself:\n\n```php\n$routes->group('api', ['filter' => 'jwt'], static function ($routes) {\n    // ...\n});\n\n$routes->get('users', 'UserController::list', ['filter' => 'jwt']);\n```\n\nWhen the filter runs, it checks the `Authorization` header for a `Bearer` value\nthat has the JWT. It then validates the token. If the token is valid, it can\ndetermine the correct user, which will then be available through an `auth()->user()`\ncall.\n\n## Method References\n\n### Generating Signed JWTs\n\n#### JWT to a Specific User\n\nJWTs are created through the `JWTManager::generateToken()` method.\nThis takes a User object to give to the token as the first argument.\nIt can also take optional additional claims array, time to live in seconds,\na key group (an array key) in the `Config\\AuthJWT::$keys`, and additional header\narray:\n\n```php\npublic function generateToken(\n    User $user,\n    array $claims = [],\n    ?int $ttl = null,\n    $keyset = 'default',\n    ?array $headers = null\n): string\n```\n\nThe following code generates a JWT to the user.\n\n```php\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\n\n/** @var JWTManager $manager */\n$manager = service('jwtmanager');\n\n$user   = auth()->user();\n$claims = [\n    'email' => $user->email,\n];\n$jwt = $manager->generateToken($user, $claims);\n```\n\nIt sets the `Config\\AuthJWT::$defaultClaims` to the token, and adds\nthe `'email'` claim and the user ID in the `\"sub\"` (subject) claim.\nIt also sets `\"iat\"` (Issued At) and `\"exp\"` (Expiration Time) claims automatically\nif you don't specify.\n\n#### Arbitrary JWT\n\nYou can generate arbitrary JWT with the ``JWTManager::issue()`` method.\n\nIt takes a JWT claims array, and can take time to live in seconds, a key group\n(an array key) in the `Config\\AuthJWT::$keys`, and additional header array:\n\n```php\npublic function issue(\n    array $claims,\n    ?int $ttl = null,\n    $keyset = 'default',\n    ?array $headers = null\n): string\n```\n\nThe following code generates a JWT.\n\n```php\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\n\n/** @var JWTManager $manager */\n$manager = service('jwtmanager');\n\n$payload = [\n    'user_id' => '1',\n    'email'   => 'admin@example.jp',\n];\n$jwt = $manager->issue($payload, DAY);\n```\n\nIt uses the `secret` and `alg` in the `Config\\AuthJWT::$keys['default']`.\n\nIt sets the `Config\\AuthJWT::$defaultClaims` to the token, and sets\n`\"iat\"` (Issued At) and `\"exp\"` (Expiration Time) claims automatically even if\nyou don't pass them.\n", "# Configuration\n\n## Config files\n\nShield has a lot of Config items. Change the default values as needed.\n\nIf you have completed the setup according to this documentation, you will have\nthe following configuration files:\n\n- **app/Config/Auth.php**\n- **app/Config/AuthGroups.php** - For Authorization\n- **app/Config/AuthToken.php** - For AccessTokens and HmacSha256 Authentication\n- **app/Config/AuthJWT.php** - For JWT Authentication\n\nNote that you do not need to have configuration files for features you do not use.\n\nThis section describes the major Config items that are not described elsewhere.\n\n## AccessTokens Authenticator\n\n### Access Token Lifetime\n\nBy default, Access Tokens can be used for 1 year since the last use. This can be easily modified in the **app/Config/AuthToken.php** config file.\n\n```php\npublic int $unusedTokenLifetime = YEAR;\n```\n", "# HMAC SHA256 Token Authenticator\n\nThe HMAC-SHA256 authenticator supports the use of revocable API keys without using OAuth. This provides\nan alternative to a token that is passed in every request and instead uses a shared secret that is used to sign\nthe request in a secure manner. Like authorization tokens, these are commonly used to provide third-party developers\naccess to your API. These keys typically have a very long expiration time, often years.\n\nThese are also suitable for use with mobile applications. In this case, the user would register/sign-in\nwith their email/password. The application would create a new access token for them, with a recognizable\nname, like \"John's iPhone 12\", and return it to the mobile application, where it is stored and used\nin all future requests.\n\n!!! note\n\n    For the purpose of this documentation, and to maintain a level of consistency with the Authorization Tokens,\n    the term \"Token\" will be used to represent a set of API Keys (key and secretKey).\n\n## Usage\n\nIn order to use HMAC Keys/Token the `Authorization` header will be set to the following in the request:\n\n```\nAuthorization: HMAC-SHA256 <key>:<HMAC-HASH-of-request-body>\n```\n\nThe code to do this will look something like this:\n\n```php\nheader(\"Authorization: HMAC-SHA256 {$key}:\" . hash_hmac('sha256', $requestBody, $secretKey));\n```\n\nUsing the CodeIgniter CURLRequest class:\n\n```php\n<?php\n\n$client = \\Config\\Services::curlrequest();\n\n$key = 'a6c460151b4cabbe1c1d73e08915ce8e';\n$secretKey = '56c85232f0e5b55c05015476cd132c8d';\n$requestBody = '{\"name\":\"John\",\"email\":\"john@example.com\"}';\n\n// $hashValue = b22b0ec11ad61cd4488ab1a09c8a0317e896c22adcc5754ea4cfd0f903a0f8c2\n$hashValue = hash_hmac('sha256', $requestBody, $secretKey);\n\n$response = $client->setHeader('Authorization', \"HMAC-SHA256 {$key}:{$hashValue}\")\n    ->setBody($requestBody)\n    ->request('POST', 'https://example.com/api');\n```\n\n## HMAC Keys/API Authentication\n\nUsing HMAC keys requires that you either use/extend `CodeIgniter\\Shield\\Models\\UserModel` or\nuse the `CodeIgniter\\Shield\\Authentication\\Traits\\HasHmacTokens` on your own user model. This trait\nprovides all the custom methods needed to implement HMAC keys in your application. The necessary\ndatabase table, `auth_identities`, is created in Shield's only migration class, which must be run\nbefore first using any of the features of Shield.\n\n## Generating HMAC Access Keys\n\nAccess keys/tokens are created through the `generateHmacToken()` method on the user. This takes a name to\ngive to the token as the first argument. The name is used to display it to the user, so they can\ndifferentiate between multiple tokens.\n\n```php\n$token = $user->generateHmacToken('Work Laptop');\n```\n\nThis creates the keys/tokens using a cryptographically secure random string. The keys operate as shared keys.\nThe '**key**' is stored as plain text in the database, the '**secretKey**' is stored encrypted. The method returns an\ninstance of `CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken`. The field `secret` is the '**key**' the field\n`rawSecretKey` is the shared '**secretKey**'. Both are required to when using this authentication method.\n\n**The plain text version of these keys should be displayed to the user immediately, so they can copy it for\ntheir use.** It is recommended that after that only the '**key**' field is displayed to a user. If a user loses the\n'**secretKey**', they should be required to generate a new set of keys to use.\n\n```php\n$token = $user->generateHmacToken('Work Laptop');\n\necho 'Key: ' . $token->secret;\necho 'SecretKey: ' . $token->rawSecretKey;\n```\n\n## Revoking HMAC Keys\n\nHMAC keys can be revoked through the `revokeHmacToken()` method. This takes the key as the only\nargument. Revoking simply deletes the record from the database.\n\n```php\n$user->revokeHmacToken($key);\n```\n\nYou can revoke all HMAC Keys with the `revokeAllHmacTokens()` method.\n\n```php\n$user->revokeAllHmacTokens();\n```\n\n## Retrieving HMAC Keys\n\nThe following methods are available to help you retrieve a user's HMAC keys:\n\n```php\n// Retrieve a set of HMAC Token/Keys by key\n$token = $user->getHmacToken($key);\n\n// Retrieve an HMAC token/keys by its database ID\n$token = $user->getHmacTokenById($id);\n\n// Retrieve all HMAC tokens as an array of AccessToken instances.\n$tokens = $user->hmacTokens();\n```\n\n## HMAC Keys Lifetime\n\nHMAC Keys/Tokens will expire after a specified amount of time has passed since they have been used.\nThis uses the same configuration value as AccessTokens.\n\nBy default, this is set to 1 year. You can change this value by setting the `$unusedTokenLifetime`\nvalue in the **app/Config/AuthToken.php** config file. This is in seconds so that you can use the\n[time constants](https://codeigniter.com/user_guide/general/common_functions.html#time-constants)\nthat CodeIgniter provides.\n\n```php\npublic $unusedTokenLifetime = YEAR;\n```\n\n## HMAC Keys Scopes\n\nEach token (set of keys) can be given one or more scopes they can be used within. These can be thought of as\npermissions the token grants to the user. Scopes are provided when the token is generated and\ncannot be modified afterword.\n\n```php\n$token = $user->gererateHmacToken('Work Laptop', ['posts.manage', 'forums.manage']);\n```\n\nBy default, a user is granted a wildcard scope which provides access to all scopes. This is the\nsame as:\n\n```php\n$token = $user->gererateHmacToken('Work Laptop', ['*']);\n```\n\nDuring authentication, the HMAC Keys the user used is stored on the user. Once authenticated, you\ncan use the `hmacTokenCan()` and `hmacTokenCant()` methods on the user to determine if they have access\nto the specified scope.\n\n```php\nif ($user->hmacTokenCan('posts.manage')) {\n    // do something....\n}\n\nif ($user->hmacTokenCant('forums.manage')) {\n    // do something....\n}\n```\n\n## HMAC Secret Key Encryption\n\nThe HMAC Secret Key is stored encrypted. Before you start using HMAC, you will need to set/override the encryption key\nin `$hmacEncryptionKeys` in **app/Config/AuthToken.php**. This should be set using **.env** and/or system\nenvironment variables. Instructions on how to do that can be found in the\n[Setting Your Encryption Key](https://codeigniter.com/user_guide/libraries/encryption.html#setting-your-encryption-key)\nsection of the CodeIgniter 4 documentation.\n\nYou will also be able to adjust the default Driver `$hmacEncryptionDefaultDriver` and the default Digest\n`$hmacEncryptionDefaultDigest`, these default to `'OpenSSL'` and `'SHA512'` respectively. These can also be\noverridden for an individual key by including them in the keys array.\n\n```php\npublic $hmacEncryptionKeys = [\n    'k1' => [\n        'key' => 'hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7',\n    ],\n];\n\npublic string $hmacEncryptionCurrentKey    = 'k1';\npublic string $hmacEncryptionDefaultDriver = 'OpenSSL';\npublic string $hmacEncryptionDefaultDigest = 'SHA512';\n```\n\nWhen it is time to update your encryption keys you will need to add an additional key to the above\n`$hmacEncryptionKeys` array. Then adjust the `$hmacEncryptionCurrentKey` to point at the new key.  After the new\nencryption key is in place, run `php spark shield:hmac reencrypt` to re-encrypt all existing keys with the new\nencryption key.  You will need to leave the old key in the array as it will be used read the existing 'Secret Keys'\nduring re-encryption.\n\n```php\npublic $hmacEncryptionKeys = [\n    'k1' => [\n        'key' => 'hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7',\n    ],\n    'k2' => [\n        'key'    => 'hex2bin:451df599363b19be1434605fff8556a0bbfc50bede1bb33793dcde4d97fce4b0',\n        'digest' => 'SHA256',\n    ],\n];\n\npublic string $hmacEncryptionCurrentKey    = 'k2';\npublic string $hmacEncryptionDefaultDriver = 'OpenSSL';\npublic string $hmacEncryptionDefaultDigest = 'SHA512';\n\n```\n\n```console\nphp spark shield:hmac reencrypt\n```\n\nYou can (and should) set these values using environment variable and/or the **.env** file. To do this you will need to set\nthe values as JSON strings:\n\n```text\nauthtoken.hmacEncryptionKeys = '{\"k1\":{\"key\":\"hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7\"},\"k2\":{\"key\":\"hex2bin:451df599363b19be1434605fff8556a0bbfc50bede1bb33793dcde4d97fce4b0\"}}'\nauthtoken.hmacEncryptionCurrentKey = k2\n```\n\nDepending on the set length of the Secret Key and the type of encryption used, it is possible for the encrypted value to\nexceed the database column character limit of 255 characters. If this happens, creation of a new HMAC identity will\nthrow a `RuntimeException`.\n", "# Access Token Authenticator\n\nThe Access Token authenticator supports the use of revoke-able API tokens without using OAuth. These are commonly\nused to provide third-party developers access to your API. These tokens typically have a very long\nexpiration time, often years.\n\nThese are also suitable for use with mobile applications. In this case, the user would register/sign-in\nwith their email/password. The application would create a new access token for them, with a recognizable\nname, like John's iPhone 12, and return it to the mobile application, where it is stored and used\nin all future requests.\n\n## Access Token/API Authentication\n\nUsing access tokens requires that you either use/extend `CodeIgniter\\Shield\\Models\\UserModel` or\nuse the `CodeIgniter\\Shield\\Authentication\\Traits\\HasAccessTokens` on your own user model. This trait\nprovides all of the custom methods needed to implement access tokens in your application. The necessary\ndatabase table, `auth_identities`, is created in Shield's only migration class, which must be run\nbefore first using any of the features of Shield.\n\n## Generating Access Tokens\n\nAccess tokens are created through the `generateAccessToken()` method on the user. This takes a name to\ngive to the token as the first argument. The name is used to display it to the user so they can\ndifferentiate between multiple tokens.\n\n```php\n$token = $user->generateAccessToken('Work Laptop');\n```\n\nThis creates the token using a cryptographically secure random string. The token\nis hashed (sha256) before saving it to the database. The method returns an instance of\n`CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken`. The only time a plain text\nversion of the token is available is in the `AccessToken` returned immediately after creation.\n\n**The plain text version should be displayed to the user immediately so they can copy it for\ntheir use.** If a user loses it, they cannot see the raw version anymore, but they can generate\na new token to use.\n\n```php\n$token = $user->generateAccessToken('Work Laptop');\n\n// Only available immediately after creation.\necho $token->raw_token;\n```\n\n## Revoking Access Tokens\n\nAccess tokens can be revoked through the `revokeAccessToken()` method. This takes the plain-text\naccess token as the only argument. Revoking simply deletes the record from the database.\n\n```php\n$user->revokeAccessToken($token);\n```\n\nTypically, the plain text token is retrieved from the request's headers as part of the authentication\nprocess. If you need to revoke the token for another user as an admin, and don't have access to the\ntoken, you would need to get the user's access tokens and delete them manually.\n\nIf you don't have the raw token usable to remove the token there is the possibility to remove it using the tokens secret thats stored in the database. It's possible to get a list of all tokens with there secret using the `accessTokens()` function.\n\n```php\n$user->revokeAccessTokenBySecret($secret);\n```\n\nYou can revoke all access tokens with the `revokeAllAccessTokens()` method.\n\n```php\n$user->revokeAllAccessTokens();\n```\n\n## Retrieving Access Tokens\n\nThe following methods are available to help you retrieve a user's access tokens:\n\n```php\n// Retrieve a single token by plain text token\n$token = $user->getAccessToken($rawToken);\n\n// Retrieve a single token by it's database ID\n$token = $user->getAccessTokenById($id);\n\n// Retrieve all access tokens as an array of AccessToken instances.\n$tokens = $user->accessTokens();\n```\n\n## Access Token Lifetime\n\nTokens will expire after a specified amount of time has passed since they have been used.\nBy default, this is set to 1 year. You can change this value by setting the `$unusedTokenLifetime`\nvalue in the **app/Config/AuthToken.php** config file. This is in seconds so that you can use the\n[time constants](https://codeigniter.com/user_guide/general/common_functions.html#time-constants)\nthat CodeIgniter provides.\n\n```php\npublic $unusedTokenLifetime = YEAR;\n```\n\n## Access Token Scopes\n\nEach token can be given one or more scopes they can be used within. These can be thought of as\npermissions the token grants to the user. Scopes are provided when the token is generated and\ncannot be modified afterword.\n\n```php\n$token = $user->gererateAccessToken('Work Laptop', ['posts.manage', 'forums.manage']);\n```\n\nBy default a user is granted a wildcard scope which provides access to all scopes. This is the\nsame as:\n\n```php\n$token = $user->gererateAccessToken('Work Laptop', ['*']);\n```\n\nDuring authentication, the token the user used is stored on the user. Once authenticated, you\ncan use the `tokenCan()` and `tokenCant()` methods on the user to determine if they have access\nto the specified scope.\n\n```php\nif ($user->tokenCan('posts.manage')) {\n    // do something....\n}\n\nif ($user->tokenCant('forums.manage')) {\n    // do something....\n}\n```\n", "<?php declare(strict_types = 1);\n\n$ignoreErrors = [];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Actions/Email2FA.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Actions/Email2FA.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Actions/Email2FA.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Actions/EmailActivator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Actions/EmailActivator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authentication.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 4,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in &&, CodeIgniter\\\\\\\\I18n\\\\\\\\Time\\\\|null given on the left side\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\TokenLoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{token\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\JWT\\\\:\\\\:attempt\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:attempt\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/JWT.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{token\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\JWT\\\\:\\\\:check\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:check\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/JWT.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\TokenLoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/JWT.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in an elseif condition, string\\\\|null given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in an if condition, CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\UserIdentity\\\\|null given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in an if condition, int\\\\|string\\\\|null given\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{email\\\\?\\\\: string, username\\\\?\\\\: string, password\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\Session\\\\:\\\\:attempt\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:attempt\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{email\\\\?\\\\: string, username\\\\?\\\\: string, password\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\Session\\\\:\\\\:check\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:check\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\LoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\RememberModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method CodeIgniter\\\\\\\\Shield\\\\\\\\Result\\\\:\\\\:isOK\\\\(\\\\) with incorrect case\\\\: isOk$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/CompositionValidator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 5,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/NothingPersonalValidator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method CodeIgniter\\\\\\\\Shield\\\\\\\\Result\\\\:\\\\:isOK\\\\(\\\\) with incorrect case\\\\: isOk$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/ValidationRules.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/ValidationRules.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in &&, CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\|null given on the right side\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/ValidationRules.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/src/Authorization/Groups.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Return type \\\\(int\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Collectors\\\\\\\\Auth\\\\:\\\\:getBadgeValue\\\\(\\\\) should be covariant with return type \\\\(int\\\\|null\\\\) of method CodeIgniter\\\\\\\\Debug\\\\\\\\Toolbar\\\\\\\\Collectors\\\\\\\\BaseCollector\\\\:\\\\:getBadgeValue\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Collectors/Auth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^PHPDoc type array\\\\<string, string\\\\> of property CodeIgniter\\\\\\\\Shield\\\\\\\\Commands\\\\\\\\Generators\\\\\\\\UserModelGenerator\\\\:\\\\:\\\\$arguments is not the same as PHPDoc type array of overridden property CodeIgniter\\\\\\\\CLI\\\\\\\\BaseCommand\\\\:\\\\:\\\\$arguments\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Commands/Generators/UserModelGenerator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^PHPDoc type array\\\\<string, string\\\\> of property CodeIgniter\\\\\\\\Shield\\\\\\\\Commands\\\\\\\\Generators\\\\\\\\UserModelGenerator\\\\:\\\\:\\\\$options is not the same as PHPDoc type array of overridden property CodeIgniter\\\\\\\\CLI\\\\\\\\BaseCommand\\\\:\\\\:\\\\$options\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Commands/Generators/UserModelGenerator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/ActionController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Instanceof between CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Actions\\\\\\\\ActionInterface and CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Actions\\\\\\\\ActionInterface will always evaluate to true\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/ActionController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/MagicLinkController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Controllers/MagicLinkController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\LoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/MagicLinkController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function assert\\\\(\\\\) with false and \\'Config Auth\u2026\\' will always evaluate to false\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/RegisterController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Instanceof between null and CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel will always evaluate to false\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/RegisterController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$name of function model expects a valid class string, array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/RegisterController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to an undefined method CodeIgniter\\\\\\\\Database\\\\\\\\ConnectionInterface\\\\:\\\\:disableForeignKeyChecks\\\\(\\\\)\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Database/Migrations/2020-12-28-223112_create_auth_tables.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to an undefined method CodeIgniter\\\\\\\\Database\\\\\\\\ConnectionInterface\\\\:\\\\:enableForeignKeyChecks\\\\(\\\\)\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Database/Migrations/2020-12-28-223112_create_auth_tables.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(bool\\\\|int\\\\|string\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:set\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\BaseCast\\\\:\\\\:set\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(bool\\\\|int\\\\|string\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:set\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\CastInterface\\\\:\\\\:set\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(int\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:get\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\BaseCast\\\\:\\\\:get\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(int\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:get\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\CastInterface\\\\:\\\\:get\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^PHPDoc type array\\\\<string, class\\\\-string\\\\> of property CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Entity\\\\:\\\\:\\\\$castHandlers is not the same as PHPDoc type array\\\\<string, string\\\\> of overridden property CodeIgniter\\\\\\\\Entity\\\\\\\\Entity\\\\:\\\\:\\\\$castHandlers\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Entity.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Entities/Group.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 8,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in a ternary operator condition, int\\\\<0, max\\\\> given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 19,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\LoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 9,\n\t'path' => __DIR__ . '/src/Commands/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Filters/AbstractAuthFilter.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Method CodeIgniter\\\\\\\\Shield\\\\\\\\Filters\\\\\\\\AuthRates\\\\:\\\\:before\\\\(\\\\) should return CodeIgniter\\\\\\\\HTTP\\\\\\\\RedirectResponse\\\\|void but returns CodeIgniter\\\\\\\\HTTP\\\\\\\\ResponseInterface\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Filters/AuthRates.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method CodeIgniter\\\\\\\\HTTP\\\\\\\\ResponseInterface\\\\:\\\\:setJSON\\\\(\\\\) with incorrect case\\\\: setJson$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Filters/TokenAuth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Filters/TokenAuth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Method CodeIgniter\\\\\\\\Shield\\\\\\\\Filters\\\\\\\\TokenAuth\\\\:\\\\:before\\\\(\\\\) should return CodeIgniter\\\\\\\\HTTP\\\\\\\\RedirectResponse\\\\|void but returns CodeIgniter\\\\\\\\HTTP\\\\\\\\ResponseInterface\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Filters/TokenAuth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/TokenLoginModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserIdentityModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Cannot unset offset \\'email\\' on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Cannot unset offset \\'password_hash\\' on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Offset \\'email\\' does not exist on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Offset \\'password_hash\\' does not exist on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$data \\\\(array\\\\|CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:insert\\\\(\\\\) should be contravariant with parameter \\\\$data \\\\(array\\\\|object\\\\|null\\\\) of method CodeIgniter\\\\\\\\Model\\\\:\\\\:insert\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$data \\\\(array\\\\|CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:save\\\\(\\\\) should be contravariant with parameter \\\\$data \\\\(array\\\\|object\\\\) of method CodeIgniter\\\\\\\\BaseModel\\\\:\\\\:save\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#2 \\\\$data \\\\(array\\\\|CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:update\\\\(\\\\) should be contravariant with parameter \\\\$data \\\\(array\\\\|object\\\\|null\\\\) of method CodeIgniter\\\\\\\\Model\\\\:\\\\:update\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Return type \\\\(int\\\\|string\\\\|true\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:insert\\\\(\\\\) should be covariant with return type \\\\(int\\\\|object\\\\|string\\\\|false\\\\) of method CodeIgniter\\\\\\\\Model\\\\:\\\\:insert\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Result\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Result will always evaluate to true\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/tests/Authentication/Authenticators/AccessTokenAuthenticatorTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Result\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Result will always evaluate to true\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/tests/Authentication/Authenticators/JWTAuthenticatorTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Result\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Result will always evaluate to true\\\\.$#',\n\t'count' => 9,\n\t'path' => __DIR__ . '/tests/Authentication/Authenticators/SessionAuthenticatorTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/Filters/AbstractFilterTestCase.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Implicit array creation is not allowed \\\\- variable \\\\$users might not exist\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/ForcePasswordResetTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Variable \\\\$users might not be defined\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/ForcePasswordResetTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Entities\\\\\\\\\\\\\\\\AccessToken\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\AccessToken will always evaluate to true\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/HasAccessTokensTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in a ternary operator condition, string\\\\|null given\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/tests/Language/AbstractTranslationTestCase.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertIsString\\\\(\\\\) with string will always evaluate to true\\\\.$#',\n\t'count' => 6,\n\t'path' => __DIR__ . '/tests/Unit/Authentication/JWT/JWTManagerTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to an undefined method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:getLastQuery\\\\(\\\\)\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Unit/UserTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Entities\\\\\\\\\\\\\\\\UserIdentity\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\UserIdentity will always evaluate to true\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Unit/UserTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\TokenLoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/HmacSha256.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/HmacSha256.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\GroupModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authorization/Traits/Authorizable.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\PermissionModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authorization/Traits/Authorizable.php',\n];\nreturn ['parameters' => ['ignoreErrors' => $ignoreErrors]];\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Authentication\\Authenticators;\n\nuse CodeIgniter\\HTTP\\IncomingRequest;\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticatorInterface;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Exceptions\\InvalidArgumentException;\nuse CodeIgniter\\Shield\\Models\\TokenLoginModel;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\n\nclass AccessTokens implements AuthenticatorInterface\n{\n    public const ID_TYPE_ACCESS_TOKEN = 'access_token';\n\n    /**\n     * The persistence engine\n     */\n    protected UserModel $provider;\n\n    protected ?User $user = null;\n    protected TokenLoginModel $loginModel;\n\n    public function __construct(UserModel $provider)\n    {\n        $this->provider = $provider;\n\n        $this->loginModel = model(TokenLoginModel::class);\n    }\n\n    /**\n     * Attempts to authenticate a user with the given $credentials.\n     * Logs the user in with a successful check.\n     *\n     * @throws AuthenticationException\n     */\n    public function attempt(array $credentials): Result\n    {\n        $config = config('AuthToken');\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $ipAddress = $request->getIPAddress();\n        $userAgent = (string) $request->getUserAgent();\n\n        $result = $this->check($credentials);\n\n        if (! $result->isOK()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record all failed login attempts.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_ACCESS_TOKEN,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent\n                );\n            }\n\n            return $result;\n        }\n\n        $user = $result->extraInfo();\n\n        if ($user->isBanned()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a banned login attempt.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_ACCESS_TOKEN,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent,\n                    $user->id\n                );\n            }\n\n            $this->user = null;\n\n            return new Result([\n                'success' => false,\n                'reason'  => $user->getBanMessage() ?? lang('Auth.bannedUser'),\n            ]);\n        }\n\n        $user = $user->setAccessToken(\n            $user->getAccessToken($this->getBearerToken())\n        );\n\n        $this->login($user);\n\n        if ($config->recordLoginAttempt === Auth::RECORD_LOGIN_ATTEMPT_ALL) {\n            // Record a successful login attempt.\n            $this->loginModel->recordLoginAttempt(\n                self::ID_TYPE_ACCESS_TOKEN,\n                $credentials['token'] ?? '',\n                true,\n                $ipAddress,\n                $userAgent,\n                $this->user->id\n            );\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks a user's $credentials to see if they match an\n     * existing user.\n     *\n     * In this case, $credentials has only a single valid value: token,\n     * which is the plain text token to return.\n     */\n    public function check(array $credentials): Result\n    {\n        if (! array_key_exists('token', $credentials) || empty($credentials['token'])) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang(\n                    'Auth.noToken',\n                    [config('AuthToken')->authenticatorHeader['tokens']]\n                ),\n            ]);\n        }\n\n        if (strpos($credentials['token'], 'Bearer') === 0) {\n            $credentials['token'] = trim(substr($credentials['token'], 6));\n        }\n\n        /** @var UserIdentityModel $identityModel */\n        $identityModel = model(UserIdentityModel::class);\n\n        $token = $identityModel->getAccessTokenByRawToken($credentials['token']);\n\n        if ($token === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.badToken'),\n            ]);\n        }\n\n        assert($token->last_used_at instanceof Time || $token->last_used_at === null);\n\n        // Hasn't been used in a long time\n        if (\n            $token->last_used_at\n            && $token->last_used_at->isBefore(\n                Time::now()->subSeconds(config('AuthToken')->unusedTokenLifetime)\n            )\n        ) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.oldToken'),\n            ]);\n        }\n\n        $token->last_used_at = Time::now()->format('Y-m-d H:i:s');\n\n        if ($token->hasChanged()) {\n            $identityModel->save($token);\n        }\n\n        // Ensure the token is set as the current token\n        $user = $token->user();\n        $user->setAccessToken($token);\n\n        return new Result([\n            'success'   => true,\n            'extraInfo' => $user,\n        ]);\n    }\n\n    /**\n     * Checks if the user is currently logged in.\n     * Since AccessToken usage is inherently stateless,\n     * it runs $this->attempt on each usage.\n     */\n    public function loggedIn(): bool\n    {\n        if (! empty($this->user)) {\n            return true;\n        }\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        return $this->attempt([\n            'token' => $request->getHeaderLine(\n                config('AuthToken')->authenticatorHeader['tokens']\n            ),\n        ])->isOK();\n    }\n\n    /**\n     * Logs the given user in by saving them to the class.\n     */\n    public function login(User $user): void\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Logs a user in based on their ID.\n     *\n     * @param int|string $userId\n     *\n     * @throws AuthenticationException\n     */\n    public function loginById($userId): void\n    {\n        $user = $this->provider->findById($userId);\n\n        if (empty($user)) {\n            throw AuthenticationException::forInvalidUser();\n        }\n\n        $user->setAccessToken(\n            $user->getAccessToken($this->getBearerToken())\n        );\n\n        $this->login($user);\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout(): void\n    {\n        $this->user = null;\n    }\n\n    /**\n     * Returns the currently logged in user.\n     */\n    public function getUser(): ?User\n    {\n        return $this->user;\n    }\n\n    /**\n     * Returns the Bearer token from the Authorization header\n     */\n    public function getBearerToken(): ?string\n    {\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $header = $request->getHeaderLine(config('AuthToken')->authenticatorHeader['tokens']);\n\n        if (empty($header)) {\n            return null;\n        }\n\n        return trim(substr($header, 6));   // 'Bearer'\n    }\n\n    /**\n     * Updates the user's last active date.\n     */\n    public function recordActiveDate(): void\n    {\n        if (! $this->user instanceof User) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() requires logged in user before calling.'\n            );\n        }\n\n        $this->user->last_active = Time::now();\n\n        $this->provider->updateActiveDate($this->user);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Authentication\\Authenticators;\n\nuse CodeIgniter\\HTTP\\IncomingRequest;\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticatorInterface;\nuse CodeIgniter\\Shield\\Authentication\\HMAC\\HmacEncrypter;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Exceptions\\InvalidArgumentException;\nuse CodeIgniter\\Shield\\Models\\TokenLoginModel;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\n\nclass HmacSha256 implements AuthenticatorInterface\n{\n    public const ID_TYPE_HMAC_TOKEN = 'hmac_sha256';\n\n    /**\n     * The persistence engine\n     */\n    protected UserModel $provider;\n\n    protected ?User $user = null;\n    protected TokenLoginModel $loginModel;\n\n    public function __construct(UserModel $provider)\n    {\n        $this->provider = $provider;\n\n        $this->loginModel = model(TokenLoginModel::class);\n    }\n\n    /**\n     * Attempts to authenticate a user with the given $credentials.\n     * Logs the user in with a successful check.\n     *\n     * @throws AuthenticationException\n     */\n    public function attempt(array $credentials): Result\n    {\n        $config = config('AuthToken');\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $ipAddress = $request->getIPAddress();\n        $userAgent = (string) $request->getUserAgent();\n\n        $result = $this->check($credentials);\n\n        if (! $result->isOK()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record all failed login attempts.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_HMAC_TOKEN,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent\n                );\n            }\n\n            return $result;\n        }\n\n        $user = $result->extraInfo();\n\n        if ($user->isBanned()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a banned login attempt.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_HMAC_TOKEN,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent,\n                    $user->id\n                );\n            }\n\n            $this->user = null;\n\n            return new Result([\n                'success' => false,\n                'reason'  => $user->getBanMessage() ?? lang('Auth.bannedUser'),\n            ]);\n        }\n\n        $user = $user->setHmacToken(\n            $user->getHmacToken($this->getHmacKeyFromToken())\n        );\n\n        $this->login($user);\n\n        if ($config->recordLoginAttempt === Auth::RECORD_LOGIN_ATTEMPT_ALL) {\n            // Record a successful login attempt.\n            $this->loginModel->recordLoginAttempt(\n                self::ID_TYPE_HMAC_TOKEN,\n                $credentials['token'] ?? '',\n                true,\n                $ipAddress,\n                $userAgent,\n                $this->user->id\n            );\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks a user's $credentials to see if they match an\n     * existing user.\n     *\n     * In this case, $credentials has only a single valid value: token,\n     * which is the plain text token to return.\n     */\n    public function check(array $credentials): Result\n    {\n        if (! array_key_exists('token', $credentials) || $credentials['token'] === '') {\n            return new Result([\n                'success' => false,\n                'reason'  => lang(\n                    'Auth.noToken',\n                    [config('AuthToken')->authenticatorHeader['hmac']]\n                ),\n            ]);\n        }\n\n        if (strpos($credentials['token'], 'HMAC-SHA256') === 0) {\n            $credentials['token'] = trim(substr($credentials['token'], 11)); // HMAC-SHA256\n        }\n\n        // Extract UserToken and HMACSHA256 Signature from Authorization token\n        [$userToken, $signature] = $this->getHmacAuthTokens($credentials['token']);\n\n        /** @var UserIdentityModel $identityModel */\n        $identityModel = model(UserIdentityModel::class);\n\n        $token = $identityModel->getHmacTokenByKey($userToken);\n\n        if ($token === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.badToken'),\n            ]);\n        }\n\n        $encrypter = new HmacEncrypter();\n        $secretKey = $encrypter->decrypt($token->secret2);\n\n        // Check signature...\n        $hash = hash_hmac('sha256', $credentials['body'], $secretKey);\n        if ($hash !== $signature) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.badToken'),\n            ]);\n        }\n\n        assert($token->last_used_at instanceof Time || $token->last_used_at === null);\n\n        // Hasn't been used in a long time\n        if (\n            isset($token->last_used_at)\n            && $token->last_used_at->isBefore(\n                Time::now()->subSeconds(config('AuthToken')->unusedTokenLifetime)\n            )\n        ) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.oldToken'),\n            ]);\n        }\n\n        $token->last_used_at = Time::now()->format('Y-m-d H:i:s');\n\n        if ($token->hasChanged()) {\n            $identityModel->save($token);\n        }\n\n        // Ensure the token is set as the current token\n        $user = $token->user();\n        $user->setHmacToken($token);\n\n        return new Result([\n            'success'   => true,\n            'extraInfo' => $user,\n        ]);\n    }\n\n    /**\n     * Checks if the user is currently logged in.\n     * Since AccessToken usage is inherently stateless,\n     * it runs $this->attempt on each usage.\n     */\n    public function loggedIn(): bool\n    {\n        if (isset($this->user)) {\n            return true;\n        }\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        return $this->attempt([\n            'token' => $request->getHeaderLine(\n                config('AuthToken')->authenticatorHeader['hmac']\n            ),\n        ])->isOK();\n    }\n\n    /**\n     * Logs the given user in by saving them to the class.\n     */\n    public function login(User $user): void\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Logs a user in based on their ID.\n     *\n     * @param int|string $userId User ID\n     *\n     * @throws AuthenticationException\n     */\n    public function loginById($userId): void\n    {\n        $user = $this->provider->findById($userId);\n\n        if ($user === null) {\n            throw AuthenticationException::forInvalidUser();\n        }\n\n        $user->setHmacToken(\n            $user->getHmacToken($this->getHmacKeyFromToken())\n        );\n\n        $this->login($user);\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout(): void\n    {\n        $this->user = null;\n    }\n\n    /**\n     * Returns the currently logged-in user.\n     */\n    public function getUser(): ?User\n    {\n        return $this->user;\n    }\n\n    /**\n     * Returns the Full HMAC Authorization token from the Authorization header\n     *\n     * @return ?string Trimmed Authorization Token from Header\n     */\n    public function getFullHmacToken(): ?string\n    {\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $header = $request->getHeaderLine(config('AuthToken')->authenticatorHeader['hmac']);\n\n        if ($header === '') {\n            return null;\n        }\n\n        return trim(substr($header, 11));   // 'HMAC-SHA256'\n    }\n\n    /**\n     * Get Key and HMAC hash from Auth token\n     *\n     * @param ?string $fullToken Full Token\n     *\n     * @return ?array [key, hmacHash]\n     */\n    public function getHmacAuthTokens(?string $fullToken = null): ?array\n    {\n        if (! isset($fullToken)) {\n            $fullToken = $this->getFullHmacToken();\n        }\n\n        if (isset($fullToken)) {\n            return preg_split('/:/', $fullToken, -1, PREG_SPLIT_NO_EMPTY);\n        }\n\n        return null;\n    }\n\n    /**\n     * Retrieve the key from the Auth token\n     *\n     * @return ?string HMAC token key\n     */\n    public function getHmacKeyFromToken(): ?string\n    {\n        [$key, $secretKey] = $this->getHmacAuthTokens();\n\n        return $key;\n    }\n\n    /**\n     * Retrieve the HMAC Hash from the Auth token\n     *\n     * @return ?string HMAC Hash\n     */\n    public function getHmacHashFromToken(): ?string\n    {\n        [$key, $hash] = $this->getHmacAuthTokens();\n\n        return $hash;\n    }\n\n    /**\n     * Updates the user's last active date.\n     */\n    public function recordActiveDate(): void\n    {\n        if (! $this->user instanceof User) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() requires logged in user before calling.'\n            );\n        }\n\n        $this->user->last_active = Time::now();\n\n        $this->provider->updateActiveDate($this->user);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Authentication\\Authenticators;\n\nuse CodeIgniter\\HTTP\\IncomingRequest;\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticatorInterface;\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Config\\AuthJWT;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Exceptions\\RuntimeException;\nuse CodeIgniter\\Shield\\Models\\TokenLoginModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\nuse InvalidArgumentException;\nuse stdClass;\n\n/**\n * Stateless JWT Authenticator\n */\nclass JWT implements AuthenticatorInterface\n{\n    /**\n     * @var string Special ID Type.\n     *             This Authenticator is stateless, so no `auth_identities` record.\n     */\n    public const ID_TYPE_JWT = 'jwt';\n\n    /**\n     * The persistence engine\n     */\n    protected UserModel $provider;\n\n    protected ?User $user = null;\n    protected JWTManager $jwtManager;\n    protected TokenLoginModel $tokenLoginModel;\n    protected ?stdClass $payload = null;\n\n    /**\n     * @var string The key group. The array key of Config\\AuthJWT::$keys.\n     */\n    protected $keyset = 'default';\n\n    public function __construct(UserModel $provider)\n    {\n        $this->provider = $provider;\n\n        $this->jwtManager      = service('jwtmanager');\n        $this->tokenLoginModel = model(TokenLoginModel::class);\n    }\n\n    /**\n     * Attempts to authenticate a user with the given $credentials.\n     * Logs the user in with a successful check.\n     *\n     * @param array{token?: string} $credentials\n     */\n    public function attempt(array $credentials): Result\n    {\n        /** @var AuthJWT $config */\n        $config = config('AuthJWT');\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $ipAddress = $request->getIPAddress();\n        $userAgent = (string) $request->getUserAgent();\n\n        $result = $this->check($credentials);\n\n        if (! $result->isOK()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a failed login attempt.\n                $this->tokenLoginModel->recordLoginAttempt(\n                    self::ID_TYPE_JWT,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent\n                );\n            }\n\n            return $result;\n        }\n\n        $user = $result->extraInfo();\n\n        if ($user->isBanned()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a banned login attempt.\n                $this->tokenLoginModel->recordLoginAttempt(\n                    self::ID_TYPE_JWT,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent,\n                    $user->id\n                );\n            }\n\n            $this->user = null;\n\n            return new Result([\n                'success' => false,\n                'reason'  => $user->getBanMessage() ?? lang('Auth.bannedUser'),\n            ]);\n        }\n\n        $this->login($user);\n\n        if ($config->recordLoginAttempt === Auth::RECORD_LOGIN_ATTEMPT_ALL) {\n            // Record a successful login attempt.\n            $this->tokenLoginModel->recordLoginAttempt(\n                self::ID_TYPE_JWT,\n                $credentials['token'] ?? '',\n                true,\n                $ipAddress,\n                $userAgent,\n                $this->user->id\n            );\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks a user's $credentials to see if they match an\n     * existing user.\n     *\n     * In this case, $credentials has only a single valid value: token,\n     * which is the plain text token to return.\n     *\n     * @param array{token?: string} $credentials\n     */\n    public function check(array $credentials): Result\n    {\n        if (! array_key_exists('token', $credentials) || $credentials['token'] === '') {\n            return new Result([\n                'success' => false,\n                'reason'  => lang(\n                    'Auth.noToken',\n                    [config('AuthJWT')->authenticatorHeader]\n                ),\n            ]);\n        }\n\n        // Check JWT\n        try {\n            $this->payload = $this->jwtManager->parse($credentials['token'], $this->keyset);\n        } catch (RuntimeException $e) {\n            return new Result([\n                'success' => false,\n                'reason'  => $e->getMessage(),\n            ]);\n        }\n\n        $userId = $this->payload->sub ?? null;\n\n        if ($userId === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => 'Invalid JWT: no user_id',\n            ]);\n        }\n\n        // Find User\n        $user = $this->provider->findById($userId);\n\n        if ($user === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.invalidUser'),\n            ]);\n        }\n\n        return new Result([\n            'success'   => true,\n            'extraInfo' => $user,\n        ]);\n    }\n\n    /**\n     * Checks if the user is currently logged in.\n     * Since AccessToken usage is inherently stateless,\n     * it runs $this->attempt on each usage.\n     */\n    public function loggedIn(): bool\n    {\n        if ($this->user !== null) {\n            return true;\n        }\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        /** @var AuthJWT $config */\n        $config = config('AuthJWT');\n\n        return $this->attempt([\n            'token' => $request->getHeaderLine($config->authenticatorHeader),\n        ])->isOK();\n    }\n\n    /**\n     * Logs the given user in by saving them to the class.\n     */\n    public function login(User $user): void\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Logs a user in based on their ID.\n     *\n     * @param int|string $userId\n     *\n     * @throws AuthenticationException\n     */\n    public function loginById($userId): void\n    {\n        $user = $this->provider->findById($userId);\n\n        if ($user === null) {\n            throw AuthenticationException::forInvalidUser();\n        }\n\n        $this->login($user);\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout(): void\n    {\n        $this->user = null;\n    }\n\n    /**\n     * Returns the currently logged in user.\n     */\n    public function getUser(): ?User\n    {\n        return $this->user;\n    }\n\n    /**\n     * Updates the user's last active date.\n     */\n    public function recordActiveDate(): void\n    {\n        if (! $this->user instanceof User) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() requires logged in user before calling.'\n            );\n        }\n\n        $this->user->last_active = Time::now();\n\n        $this->provider->save($this->user);\n    }\n\n    /**\n     * @param string $keyset The key group. The array key of Config\\AuthJWT::$keys.\n     */\n    public function setKeyset($keyset): void\n    {\n        $this->keyset = $keyset;\n    }\n\n    /**\n     * Returns payload\n     */\n    public function getPayload(): ?stdClass\n    {\n        return $this->payload;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Config;\n\n/**\n * Configuration for Token Auth and HMAC Auth\n */\nclass AuthToken extends BaseAuthToken\n{\n    /**\n     * --------------------------------------------------------------------\n     * Record Login Attempts for Token Auth and HMAC Auth\n     * --------------------------------------------------------------------\n     * Specify which login attempts are recorded in the database.\n     *\n     * Valid values are:\n     * - Auth::RECORD_LOGIN_ATTEMPT_NONE\n     * - Auth::RECORD_LOGIN_ATTEMPT_FAILURE\n     * - Auth::RECORD_LOGIN_ATTEMPT_ALL\n     */\n    public int $recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_FAILURE;\n\n    /**\n     * --------------------------------------------------------------------\n     * Name of Authenticator Header\n     * --------------------------------------------------------------------\n     * The name of Header that the Authorization token should be found.\n     * According to the specs, this should be `Authorization`, but rare\n     * circumstances might need a different header.\n     */\n    public array $authenticatorHeader = [\n        'tokens' => 'Authorization',\n        'hmac'   => 'Authorization',\n    ];\n\n    /**\n     * --------------------------------------------------------------------\n     * Unused Token Lifetime\n     * --------------------------------------------------------------------\n     * Determines the amount of time, in seconds, that an unused token can\n     * be used.\n     */\n    public int $unusedTokenLifetime = YEAR;\n\n    /**\n     * --------------------------------------------------------------------\n     * Secret2 storage character limit\n     * --------------------------------------------------------------------\n     * Database size limit for the identities 'secret2' field.\n     */\n    public int $secret2StorageLimit = 255;\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC secret key byte size\n     * --------------------------------------------------------------------\n     * Specify in integer the desired byte size of the\n     * HMAC SHA256 byte size\n     */\n    public int $hmacSecretKeyByteSize = 32;\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC encryption Keys\n     * --------------------------------------------------------------------\n     * This sets the key to be used when encrypting a user's HMAC Secret Key.\n     *\n     * 'keys' is an array of keys which will facilitate key rotation. Valid\n     *  keyTitles must include only [a-zA-Z0-9_] and should be kept to a\n     *  max of 8 characters.\n     *\n     * Each keyTitle is an associative array containing the required 'key'\n     *  value, and the optional 'driver' and 'digest' values. If the\n     *  'driver' and 'digest' values are not specified, the default 'driver'\n     *  and 'digest' values will be used.\n     *\n     * Old keys will are used to decrypt existing Secret Keys. It is encouraged\n     *  to run 'php spark shield:hmac reencrypt' to update existing Secret\n     *  Key encryptions.\n     *\n     * @see https://codeigniter.com/user_guide/libraries/encryption.html\n     *\n     * @var array<string, array{key: string, driver?: string, digest?: string}>|string\n     *\n     * NOTE: The value becomes temporarily a string when setting value as JSON\n     *       from environment variable.\n     *\n     * [key_name => ['key' => key_value]]\n     * or [key_name => ['key' => key_value, 'driver' => driver, 'digest' => digest]]\n     */\n    public $hmacEncryptionKeys = [\n        'k1' => [\n            'key' => '',\n        ],\n    ];\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC Current Encryption Key Selector\n     * --------------------------------------------------------------------\n     * This specifies which of the encryption keys should be used.\n     */\n    public string $hmacEncryptionCurrentKey = 'k1';\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC Encryption Key Driver\n     * --------------------------------------------------------------------\n     * This specifies which of the encryption drivers should be used.\n     *\n     * Available drivers:\n     *     - OpenSSL\n     *     - Sodium\n     */\n    public string $hmacEncryptionDefaultDriver = 'OpenSSL';\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC Encryption Key Driver\n     * --------------------------------------------------------------------\n     * THis specifies the type of encryption to be used.\n     *     e.g. 'SHA512' or 'SHA256'.\n     */\n    public string $hmacEncryptionDefaultDigest = 'SHA512';\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace Tests\\Authentication\\Authenticators;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\Authentication;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\AccessTokens;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Entities\\AccessToken;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\nuse CodeIgniter\\Test\\Mock\\MockEvents;\nuse Config\\Services;\nuse Tests\\Support\\DatabaseTestCase;\n\n/**\n * @internal\n */\nfinal class AccessTokenAuthenticatorTest extends DatabaseTestCase\n{\n    private AccessTokens $auth;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $config = new Auth();\n        $auth   = new Authentication($config);\n        $auth->setProvider(model(UserModel::class));\n\n        /** @var AccessTokens $authenticator */\n        $authenticator = $auth->factory('tokens');\n        $this->auth    = $authenticator;\n\n        Services::injectMock('events', new MockEvents());\n    }\n\n    public function testLogin(): void\n    {\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n\n        // Stores the user\n        $this->assertInstanceOf(User::class, $this->auth->getUser());\n        $this->assertSame($user->id, $this->auth->getUser()->id);\n    }\n\n    public function testLogout(): void\n    {\n        // this one's a little odd since it's stateless, but roll with it...\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n        $this->assertNotNull($this->auth->getUser());\n\n        $this->auth->logout();\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginByIdNoToken(): void\n    {\n        $user = fake(UserModel::class);\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertNull($this->auth->getUser()->currentAccessToken());\n    }\n\n    public function testLoginByIdWithToken(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateAccessToken('foo');\n\n        $this->setRequestHeader($token->raw_token);\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentAccessToken());\n        $this->assertSame($token->id, $this->auth->getUser()->currentAccessToken()->id);\n    }\n\n    public function testLoginByIdWithMultipleTokens(): void\n    {\n        /** @var User $user */\n        $user   = fake(UserModel::class);\n        $token1 = $user->generateAccessToken('foo');\n        $user->generateAccessToken('bar');\n\n        $this->setRequestHeader($token1->raw_token);\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentAccessToken());\n        $this->assertSame($token1->id, $this->auth->getUser()->currentAccessToken()->id);\n    }\n\n    public function testCheckNoToken(): void\n    {\n        $result = $this->auth->check([]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\n            lang('Auth.noToken', [config('AuthToken')->authenticatorHeader['tokens']]),\n            $result->reason()\n        );\n    }\n\n    public function testCheckBadToken(): void\n    {\n        $result = $this->auth->check(['token' => 'abc123']);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n    }\n\n    public function testCheckOldToken(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n        /** @var UserIdentityModel $identities */\n        $identities = model(UserIdentityModel::class);\n        $token      = $user->generateAccessToken('foo');\n        // CI 4.2 uses the Chicago timezone that has Daylight Saving Time,\n        // so subtracts 1 hour to make sure this test passes.\n        $token->last_used_at = Time::now()->subYears(1)->subHours(1)->subMinutes(1);\n        $identities->save($token);\n\n        $result = $this->auth->check(['token' => $token->raw_token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.oldToken'), $result->reason());\n    }\n\n    public function testCheckSuccess(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateAccessToken('foo');\n\n        $this->seeInDatabase($this->tables['identities'], [\n            'user_id'      => $user->id,\n            'type'         => 'access_token',\n            'last_used_at' => null,\n        ]);\n\n        $result = $this->auth->check(['token' => $token->raw_token]);\n\n        $this->assertTrue($result->isOK());\n        $this->assertInstanceOf(User::class, $result->extraInfo());\n        $this->assertSame($user->id, $result->extraInfo()->id);\n\n        $updatedToken = $result->extraInfo()->currentAccessToken();\n        $this->assertNotEmpty($updatedToken->last_used_at);\n\n        // Checking token in the same second does not throw \"DataException : There is no data to update.\"\n        $this->auth->check(['token' => $token->raw_token]);\n    }\n\n    public function testAttemptCannotFindUser(): void\n    {\n        $result = $this->auth->attempt([\n            'token' => 'abc123',\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n\n        // A failed login attempt should have been recorded by default.\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => AccessTokens::ID_TYPE_ACCESS_TOKEN,\n            'identifier' => 'abc123',\n            'success'    => 0,\n        ]);\n    }\n\n    public function testAttemptSuccess(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateAccessToken('foo');\n        $this->setRequestHeader($token->raw_token);\n\n        $result = $this->auth->attempt([\n            'token' => $token->raw_token,\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertTrue($result->isOK());\n\n        $foundUser = $result->extraInfo();\n        $this->assertInstanceOf(User::class, $foundUser);\n        $this->assertSame($user->id, $foundUser->id);\n        $this->assertInstanceOf(AccessToken::class, $foundUser->currentAccessToken());\n        $this->assertSame($token->token, $foundUser->currentAccessToken()->token);\n\n        // A successful login attempt is not recorded by default.\n        $this->dontSeeInDatabase($this->tables['token_logins'], [\n            'id_type'    => AccessTokens::ID_TYPE_ACCESS_TOKEN,\n            'identifier' => $token->raw_token,\n            'success'    => 1,\n        ]);\n    }\n\n    protected function setRequestHeader(string $token): void\n    {\n        $request = service('request');\n        $request->setHeader('Authorization', 'Bearer ' . $token);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace Tests\\Authentication\\Authenticators;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\Authentication;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\HmacSha256;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Entities\\AccessToken;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Test\\Mock\\MockEvents;\nuse Config\\Services;\nuse Tests\\Support\\DatabaseTestCase;\n\n/**\n * @internal\n */\nfinal class HmacAuthenticatorTest extends DatabaseTestCase\n{\n    private HmacSha256 $auth;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $config = new Auth();\n        $auth   = new Authentication($config);\n        $auth->setProvider(model(UserModel::class));\n\n        config('AuthToken')->recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_ALL;\n\n        /** @var HmacSha256 $authenticator */\n        $authenticator = $auth->factory('hmac');\n        $this->auth    = $authenticator;\n\n        Services::injectMock('events', new MockEvents());\n    }\n\n    public function testLogin(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n\n        // Stores the user\n        $this->assertInstanceOf(User::class, $this->auth->getUser());\n        $this->assertSame($user->id, $this->auth->getUser()->id);\n    }\n\n    public function testLogout(): void\n    {\n        // this one's a little odd since it's stateless, but roll with it...\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n        $this->assertNotNull($this->auth->getUser());\n\n        $this->auth->logout();\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginByIdNoToken(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertNull($this->auth->getUser()->currentHmacToken());\n    }\n\n    public function testLoginByIdBadId(): void\n    {\n        fake(UserModel::class);\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        try {\n            $this->auth->loginById(0);\n        } catch (AuthenticationException $e) {\n            // Failed login\n        }\n\n        $this->assertFalse($this->auth->loggedIn());\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginByIdWithToken(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateHmacToken('foo');\n\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n        $this->setRequestHeader($rawToken);\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentHmacToken());\n        $this->assertSame($token->id, $this->auth->getUser()->currentHmacToken()->id);\n    }\n\n    public function testLoginByIdWithMultipleTokens(): void\n    {\n        /** @var User $user */\n        $user   = fake(UserModel::class);\n        $token1 = $user->generateHmacToken('foo');\n        $user->generateHmacToken('bar');\n\n        $this->setRequestHeader($this->generateRawHeaderToken($token1->secret, $token1->rawSecretKey, 'bar'));\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentHmacToken());\n        $this->assertSame($token1->id, $this->auth->getUser()->currentHmacToken()->id);\n    }\n\n    public function testCheckNoToken(): void\n    {\n        $result = $this->auth->check([]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\n            lang('Auth.noToken', [config('AuthToken')->authenticatorHeader['hmac']]),\n            $result->reason()\n        );\n    }\n\n    public function testCheckBadSignature(): void\n    {\n        $result = $this->auth->check([\n            'token' => 'abc123:lasdkjflksjdflksjdf',\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n    }\n\n    public function testCheckOldToken(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n        /** @var UserIdentityModel $identities */\n        $identities = model(UserIdentityModel::class);\n        $token      = $user->generateHmacToken('foo');\n        // CI 4.2 uses the Chicago timezone that has Daylight Saving Time,\n        // so subtracts 1 hour to make sure this test passes.\n        $token->last_used_at = Time::now()->subYears(1)->subHours(1)->subMinutes(1);\n        $identities->save($token);\n\n        $result = $this->auth->check([\n            'token' => $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar'),\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.oldToken'), $result->reason());\n    }\n\n    public function testCheckSuccess(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateHmacToken('foo');\n\n        $this->seeInDatabase($this->tables['identities'], [\n            'user_id'      => $user->id,\n            'type'         => 'hmac_sha256',\n            'last_used_at' => null,\n        ]);\n\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n\n        $result = $this->auth->check([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertTrue($result->isOK());\n        $this->assertInstanceOf(User::class, $result->extraInfo());\n        $this->assertSame($user->id, $result->extraInfo()->id);\n\n        $updatedToken = $result->extraInfo()->currentHmacToken();\n        $this->assertNotEmpty($updatedToken->last_used_at);\n\n        // Checking token in the same second does not throw \"DataException : There is no data to update.\"\n        $this->auth->check(['token' => $rawToken, 'body' => 'bar']);\n    }\n\n    public function testCheckBadToken(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateHmacToken('foo');\n\n        $this->seeInDatabase($this->tables['identities'], [\n            'user_id'      => $user->id,\n            'type'         => 'hmac_sha256',\n            'last_used_at' => null,\n        ]);\n\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'foobar');\n\n        $result = $this->auth->check([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n    }\n\n    public function testAttemptCannotFindUser(): void\n    {\n        $result = $this->auth->attempt([\n            'token' => 'abc123:lsakdjfljsdflkajsfd',\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n\n        // A login attempt should have always been recorded\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => HmacSha256::ID_TYPE_HMAC_TOKEN,\n            'identifier' => 'abc123:lsakdjfljsdflkajsfd',\n            'success'    => 0,\n        ]);\n    }\n\n    public function testAttemptSuccess(): void\n    {\n        /** @var User $user */\n        $user     = fake(UserModel::class);\n        $token    = $user->generateHmacToken('foo');\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n        $this->setRequestHeader($rawToken);\n\n        $result = $this->auth->attempt([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertTrue($result->isOK());\n\n        $foundUser = $result->extraInfo();\n        $this->assertInstanceOf(User::class, $foundUser);\n        $this->assertSame($user->id, $foundUser->id);\n        $this->assertInstanceOf(AccessToken::class, $foundUser->currentHmacToken());\n        $this->assertSame($token->token, $foundUser->currentHmacToken()->token);\n\n        // A login attempt should have been recorded\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => HmacSha256::ID_TYPE_HMAC_TOKEN,\n            'identifier' => $rawToken,\n            'success'    => 1,\n        ]);\n\n        // Check get key Method\n        $key = $this->auth->getHmacKeyFromToken();\n        $this->assertSame($token->secret, $key);\n\n        // Check get hash method\n        [, $hash]  = explode(':', $rawToken);\n        $secretKey = $this->auth->getHmacHashFromToken();\n        $this->assertSame($hash, $secretKey);\n    }\n\n    public function testAttemptBanned(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n        $user->ban('Test ban.');\n\n        $token    = $user->generateHmacToken('foo');\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n        $this->setRequestHeader($rawToken);\n\n        $result = $this->auth->attempt([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n\n        $foundUser = $result->extraInfo();\n        $this->assertNull($foundUser);\n\n        // A login attempt should have been recorded\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => HmacSha256::ID_TYPE_HMAC_TOKEN,\n            'identifier' => $rawToken,\n            'success'    => 0,\n        ]);\n    }\n\n    protected function setRequestHeader(string $token): void\n    {\n        $request = service('request');\n        $request->setHeader('Authorization', 'HMAC-SHA256 ' . $token);\n    }\n\n    protected function generateRawHeaderToken(string $secret, string $secretKey, string $body): string\n    {\n        return $secret . ':' . hash_hmac('sha256', $body, $secretKey);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace Tests\\Authentication\\Authenticators;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\Authentication;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\JWT;\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Config\\AuthJWT;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\nuse CodeIgniter\\Test\\Mock\\MockEvents;\nuse Config\\Services;\nuse Firebase\\JWT\\JWT as FirebaseJWT;\nuse InvalidArgumentException;\nuse Tests\\Support\\DatabaseTestCase;\n\n/**\n * @internal\n */\nfinal class JWTAuthenticatorTest extends DatabaseTestCase\n{\n    private const BAD_JWT = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJJc3N1ZXIgb2YgdGhlIEpXVCIsImF1ZCI6IkF1ZGllbmNlIG9mIHRoZSBKV1QiLCJzdWIiOiIxIiwiaWF0IjoxNjUzOTkxOTg5LCJleHAiOjE2NTM5OTU1ODl9.hgOYHEcT6RGHb3po1lspTcmjrylY1Cy1IvYmHOyx0CY';\n\n    private JWT $auth;\n    private User $user;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $config                        = new Auth();\n        $config->authenticators['jwt'] = JWT::class;\n\n        $auth = new Authentication($config);\n        $auth->setProvider(\\model(UserModel::class));\n\n        /** @var JWT $authenticator */\n        $authenticator = $auth->factory('jwt');\n        $this->auth    = $authenticator;\n\n        Services::injectMock('events', new MockEvents());\n    }\n\n    private function createUser(): User\n    {\n        return \\fake(UserModel::class);\n    }\n\n    public function testLogin(): void\n    {\n        $user = $this->createUser();\n\n        $this->auth->login($user);\n\n        // Stores the user\n        $this->assertInstanceOf(User::class, $this->auth->getUser());\n        $this->assertSame($user->id, $this->auth->getUser()->id);\n    }\n\n    public function testLogout(): void\n    {\n        // this one's a little odd since it's stateless, but roll with it...\n\n        $user = $this->createUser();\n\n        $this->auth->login($user);\n        $this->assertNotNull($this->auth->getUser());\n\n        $this->auth->logout();\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginById(): void\n    {\n        $user = $this->createUser();\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n    }\n\n    public function testLoginByIdNoUser(): void\n    {\n        $this->expectException(AuthenticationException::class);\n        $this->expectExceptionMessage('Unable to locate the specified user.');\n\n        $this->createUser();\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById(9999);\n    }\n\n    public function testCheckNoToken(): void\n    {\n        $result = $this->auth->check([]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\n            \\lang('Auth.noToken', [config('AuthJWT')->authenticatorHeader]),\n            $result->reason()\n        );\n    }\n\n    public function testCheckBadSignatureToken(): void\n    {\n        $result = $this->auth->check(['token' => self::BAD_JWT]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.invalidJWT'), $result->reason());\n    }\n\n    public function testCheckNoSubToken(): void\n    {\n        /** @var AuthJWT $config */\n        $config  = config('AuthJWT');\n        $payload = [\n            'iss' => $config->defaultClaims['iss'], // issuer\n        ];\n        $token = FirebaseJWT::encode($payload, $config->keys['default'][0]['secret'], $config->keys['default'][0]['alg']);\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame('Invalid JWT: no user_id', $result->reason());\n    }\n\n    public function testCheckOldToken(): void\n    {\n        Time::setTestNow('-1 hour');\n        $token = $this->generateJWT();\n        Time::setTestNow();\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.expiredJWT'), $result->reason());\n    }\n\n    public function testCheckNoUserInDatabase(): void\n    {\n        $token = $this->generateJWT();\n\n        $users = \\model(UserModel::class);\n        $users->delete(1);\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\\lang('Auth.invalidUser'), $result->reason());\n    }\n\n    public function testCheckSuccess(): void\n    {\n        $token = $this->generateJWT();\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertTrue($result->isOK());\n        $this->assertInstanceOf(User::class, $result->extraInfo());\n        $this->assertSame(1, $result->extraInfo()->id);\n    }\n\n    public function testGetPayload(): void\n    {\n        $token = $this->generateJWT();\n\n        $this->auth->check(['token' => $token]);\n        $payload = $this->auth->getPayload();\n\n        $this->assertSame((string) $this->user->id, $payload->sub);\n        /** @var AuthJWT $config */\n        $config = config('AuthJWT');\n        $this->assertSame($config->defaultClaims['iss'], $payload->iss);\n    }\n\n    public function testAttemptBadSignatureToken(): void\n    {\n        $result = $this->auth->attempt([\n            'token' => self::BAD_JWT,\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.invalidJWT'), $result->reason());\n\n        // A login attempt should have always been recorded\n        $this->seeInDatabase('auth_token_logins', [\n            'id_type'    => JWT::ID_TYPE_JWT,\n            'identifier' => self::BAD_JWT,\n            'success'    => 0,\n        ]);\n    }\n\n    public function testAttemptBannedUser(): void\n    {\n        $token = $this->generateJWT();\n\n        $this->user->ban();\n\n        $result = $this->auth->attempt([\n            'token' => $token,\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.bannedUser'), $result->reason());\n\n        // The login attempt should have been recorded\n        $this->seeInDatabase('auth_token_logins', [\n            'id_type'    => JWT::ID_TYPE_JWT,\n            'identifier' => $token,\n            'success'    => 0,\n            'user_id'    => $this->user->id,\n        ]);\n    }\n\n    public function testAttemptSuccess(): void\n    {\n        // Change $recordLoginAttempt in Config.\n        /** @var AuthJWT $config */\n        $config                     = config('AuthJWT');\n        $config->recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_ALL;\n\n        $token = $this->generateJWT();\n\n        $result = $this->auth->attempt([\n            'token' => $token,\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertTrue($result->isOK());\n\n        $foundUser = $result->extraInfo();\n\n        $this->assertInstanceOf(User::class, $foundUser);\n        $this->assertSame(1, $foundUser->id);\n\n        // A login attempt should have been recorded\n        $this->seeInDatabase('auth_token_logins', [\n            'id_type'    => JWT::ID_TYPE_JWT,\n            'identifier' => $token,\n            'success'    => 1,\n        ]);\n    }\n\n    public function testRecordActiveDateNoUser(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage(\n            'Authentication\\Authenticators\\JWT::recordActiveDate() requires logged in user before calling.'\n        );\n\n        $this->auth->recordActiveDate();\n    }\n\n    /**\n     * @param Time|null $clock The Time object\n     */\n    private function generateJWT(?Time $clock = null): string\n    {\n        $this->user = \\fake(UserModel::class, ['id' => 1, 'username' => 'John Smith']);\n\n        $generator = new JWTManager($clock);\n\n        return $generator->generateToken($this->user);\n    }\n}\n"], "fixing_code": ["# JWT Authentication\n\n!!! note\n\n    Shield now supports only JWS (Singed JWT). JWE (Encrypted JWT) is not supported.\n\n## What is JWT?\n\nJWT or JSON Web Token is a compact and self-contained way of securely transmitting\ninformation between parties as a JSON object. It is commonly used for authentication\nand authorization purposes in web applications.\n\nFor example, when a user logs in to a web application, the server generates a JWT\ntoken and sends it to the client. The client then includes this token in the header\nof subsequent requests to the server. The server verifies the authenticity of the\ntoken and grants access to protected resources accordingly.\n\nIf you are not familiar with JWT, we recommend that you check out\n[Introduction to JSON Web Tokens](https://jwt.io/introduction) before continuing.\n\n## Setup\n\nTo use JWT Authentication, you need additional setup and configuration.\n\n### Manual Setup\n\n1. Install \"firebase/php-jwt\" via Composer.\n\n    ```console\n    composer require firebase/php-jwt:^6.4\n    ```\n\n2. Copy the **AuthJWT.php** from **vendor/codeigniter4/shield/src/Config/** into your project's config folder and update the namespace to `Config`. You will also need to have these classes extend the original classes. See the example below.\n\n    ```php\n    <?php\n\n    // app/Config/AuthJWT.php\n\n    declare(strict_types=1);\n\n    namespace Config;\n\n    use CodeIgniter\\Shield\\Config\\AuthJWT as ShieldAuthJWT;\n\n    /**\n     * JWT Authenticator Configuration\n     */\n    class AuthJWT extends ShieldAuthJWT\n    {\n        // ...\n    }\n    ```\n\n3. If your **app/Config/Auth.php** is not up-to-date, you also need to update it. Check **vendor/codeigniter4/shield/src/Config/Auth.php** and apply the differences.\n\n    You need to add the following constants:\n    ```php\n    public const RECORD_LOGIN_ATTEMPT_NONE    = 0; // Do not record at all\n    public const RECORD_LOGIN_ATTEMPT_FAILURE = 1; // Record only failures\n    public const RECORD_LOGIN_ATTEMPT_ALL     = 2; // Record all login attempts\n    ```\n\n    You need to add JWT Authenticator:\n    ```php\n    use CodeIgniter\\Shield\\Authentication\\Authenticators\\JWT;\n\n    // ...\n\n    public array $authenticators = [\n        'tokens'  => AccessTokens::class,\n        'session' => Session::class,\n        'jwt'     => JWT::class,\n    ];\n    ```\n\n    If you want to use JWT Authenticator in Authentication Chain, add `jwt`:\n    ```php\n    public array $authenticationChain = [\n        'session',\n        'tokens',\n        'jwt'\n    ];\n    ```\n\n## Configuration\n\nConfigure **app/Config/AuthJWT.php** for your needs.\n\n### Set the Default Claims\n\n!!! note\n\n    A payload contains the actual data being transmitted, such as user ID, role,\n    or expiration time. Items in a payload is called *claims*.\n\nSet the default payload items to the property `$defaultClaims`.\n\nE.g.:\n```php\npublic array $defaultClaims = [\n    'iss' => 'https://codeigniter.com/',\n];\n```\n\nThe default claims will be included in all tokens issued by Shield.\n\n### Set Secret Key\n\nSet your secret key in the `$keys` property, or set it in your `.env` file.\n\nE.g.:\n```text\nauthjwt.keys.default.0.secret = 8XBFsF6HThIa7OV/bSynahEch+WbKrGcuiJVYPiwqPE=\n```\n\nIt needs at least 256 bits random string. The length of the secret depends on the\nalgorithm we use. The default one is `HS256`, so to ensure that the hash value is\nsecure and not easily guessable, the secret key should be at least as long as the\nhash function's output - 256 bits (32 bytes). You can get a secure random string\nwith the following command:\n\n```console\nphp -r 'echo base64_encode(random_bytes(32));'\n```\n\n!!! note\n\n    The secret key is used for signing and validating tokens.\n\n### Login Attempt Logging\n\nBy default, only failed login attempts are recorded in the `auth_token_logins` table.\n\n```php\npublic int $recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_FAILURE;\n```\n\nIf you don't want any logs, set it to `Auth::RECORD_LOGIN_ATTEMPT_NONE`.\n\nIf you want to log all login attempts, set it to `Auth::RECORD_LOGIN_ATTEMPT_ALL`.\nIt means you log all requests.\n\n## Issuing JWTs\n\nTo use JWT Authentication, you need a controller that issues JWTs.\n\nHere is a sample controller. When a client posts valid credentials (email/password),\nit returns a new JWT.\n\n```php\n// app/Config/Routes.php\n$routes->post('auth/jwt', '\\App\\Controllers\\Auth\\LoginController::jwtLogin');\n```\n\n```php\n<?php\n\n// app/Controllers/Auth/LoginController.php\n\ndeclare(strict_types=1);\n\nnamespace App\\Controllers\\Auth;\n\nuse App\\Controllers\\BaseController;\nuse CodeIgniter\\API\\ResponseTrait;\nuse CodeIgniter\\HTTP\\ResponseInterface;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\Session;\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\nuse CodeIgniter\\Shield\\Validation\\ValidationRules;\n\nclass LoginController extends BaseController\n{\n    use ResponseTrait;\n\n    /**\n     * Authenticate Existing User and Issue JWT.\n     */\n    public function jwtLogin(): ResponseInterface\n    {\n        // Get the validation rules\n        $rules = $this->getValidationRules();\n\n        // Validate credentials\n        if (! $this->validateData($this->request->getJSON(true), $rules, [], config('Auth')->DBGroup)) {\n            return $this->fail(\n                ['errors' => $this->validator->getErrors()],\n                $this->codes['unauthorized']\n            );\n        }\n\n        // Get the credentials for login\n        $credentials             = $this->request->getJsonVar(setting('Auth.validFields'));\n        $credentials             = array_filter($credentials);\n        $credentials['password'] = $this->request->getJsonVar('password');\n\n        /** @var Session $authenticator */\n        $authenticator = auth('session')->getAuthenticator();\n\n        // Check the credentials\n        $result = $authenticator->check($credentials);\n\n        // Credentials mismatch.\n        if (! $result->isOK()) {\n            // @TODO Record a failed login attempt\n\n            return $this->failUnauthorized($result->reason());\n        }\n\n        // Credentials match.\n        // @TODO Record a successful login attempt\n\n        $user = $result->extraInfo();\n\n        /** @var JWTManager $manager */\n        $manager = service('jwtmanager');\n\n        // Generate JWT and return to client\n        $jwt = $manager->generateToken($user);\n\n        return $this->respond([\n            'access_token' => $jwt,\n        ]);\n    }\n\n    /**\n     * Returns the rules that should be used for validation.\n     *\n     * @return array<string, array<string, array<string>|string>>\n     * @phpstan-return array<string, array<string, string|list<string>>>\n     */\n    protected function getValidationRules(): array\n    {\n        $rules = new ValidationRules();\n\n        return $rules->getLoginRules();\n    }\n}\n```\n\nYou could send a request with the existing user's credentials by curl like this:\n\n```curl\ncurl --location 'http://localhost:8080/auth/jwt' \\\n--header 'Content-Type: application/json' \\\n--data-raw '{\"email\" : \"admin@example.jp\" , \"password\" : \"passw0rd!\"}'\n```\n\nWhen making all future requests to the API, the client should send the JWT in\nthe `Authorization` header as a `Bearer` token.\n\nYou could send a request with the `Authorization` header by curl like this:\n\n```curl\ncurl --location --request GET 'http://localhost:8080/api/users' \\\n--header 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJTaGllbGQgVGVzdCBBcHAiLCJzdWIiOiIxIiwiaWF0IjoxNjgxODA1OTMwLCJleHAiOjE2ODE4MDk1MzB9.DGpOmRPOBe45whVtEOSt53qJTw_CpH0V8oMoI_gm2XI'\n```\n\n## Protecting Routes\n\nThe first way to specify which routes are protected is to use the `jwt` controller\nfilter.\n\nFor example, to ensure it protects all routes under the `/api` route group, you\nwould use the `$filters` setting on **app/Config/Filters.php**.\n\n```php\npublic $filters = [\n    'jwt' => ['before' => ['api', 'api/*']],\n];\n```\n\nYou can also specify the filter should run on one or more routes within the routes\nfile itself:\n\n```php\n$routes->group('api', ['filter' => 'jwt'], static function ($routes) {\n    // ...\n});\n\n$routes->get('users', 'UserController::list', ['filter' => 'jwt']);\n```\n\nWhen the filter runs, it checks the `Authorization` header for a `Bearer` value\nthat has the JWT. It then validates the token. If the token is valid, it can\ndetermine the correct user, which will then be available through an `auth()->user()`\ncall.\n\n## Method References\n\n### Generating Signed JWTs\n\n#### JWT to a Specific User\n\nJWTs are created through the `JWTManager::generateToken()` method.\nThis takes a User object to give to the token as the first argument.\nIt can also take optional additional claims array, time to live in seconds,\na key group (an array key) in the `Config\\AuthJWT::$keys`, and additional header\narray:\n\n```php\npublic function generateToken(\n    User $user,\n    array $claims = [],\n    ?int $ttl = null,\n    $keyset = 'default',\n    ?array $headers = null\n): string\n```\n\nThe following code generates a JWT to the user.\n\n```php\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\n\n/** @var JWTManager $manager */\n$manager = service('jwtmanager');\n\n$user   = auth()->user();\n$claims = [\n    'email' => $user->email,\n];\n$jwt = $manager->generateToken($user, $claims);\n```\n\nIt sets the `Config\\AuthJWT::$defaultClaims` to the token, and adds\nthe `'email'` claim and the user ID in the `\"sub\"` (subject) claim.\nIt also sets `\"iat\"` (Issued At) and `\"exp\"` (Expiration Time) claims automatically\nif you don't specify.\n\n#### Arbitrary JWT\n\nYou can generate arbitrary JWT with the ``JWTManager::issue()`` method.\n\nIt takes a JWT claims array, and can take time to live in seconds, a key group\n(an array key) in the `Config\\AuthJWT::$keys`, and additional header array:\n\n```php\npublic function issue(\n    array $claims,\n    ?int $ttl = null,\n    $keyset = 'default',\n    ?array $headers = null\n): string\n```\n\nThe following code generates a JWT.\n\n```php\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\n\n/** @var JWTManager $manager */\n$manager = service('jwtmanager');\n\n$payload = [\n    'user_id' => '1',\n    'email'   => 'admin@example.jp',\n];\n$jwt = $manager->issue($payload, DAY);\n```\n\nIt uses the `secret` and `alg` in the `Config\\AuthJWT::$keys['default']`.\n\nIt sets the `Config\\AuthJWT::$defaultClaims` to the token, and sets\n`\"iat\"` (Issued At) and `\"exp\"` (Expiration Time) claims automatically even if\nyou don't pass them.\n\n## Logging\n\nLogin attempts are recorded in the `auth_token_logins` table, according to the\nconfiguration above.\n\nWhen a failed login attempt is logged, the raw token value sent is saved in\nthe `identifier` column.\n\nWhen a successful login attempt is logged, the SHA256 hash value of the token\nsent is saved in the `identifier` column.\n", "# Configuration\n\n## Config files\n\nShield has a lot of Config items. Change the default values as needed.\n\nIf you have completed the setup according to this documentation, you will have\nthe following configuration files:\n\n- **app/Config/Auth.php**\n- **app/Config/AuthGroups.php** - For [Authorization](../references/authorization.md)\n- **app/Config/AuthToken.php** - For [AccessTokens](../references/authentication/tokens.md#configuration) and [HmacSha256](../references/authentication/hmac.md#configuration) Authentication\n- **app/Config/AuthJWT.php** - For [JWT Authentication](../addons/jwt.md#configuration)\n\nNote that you do not need to have configuration files for features you do not use.\n", "# HMAC SHA256 Token Authenticator\n\nThe HMAC-SHA256 authenticator supports the use of revocable API keys without using OAuth. This provides\nan alternative to a token that is passed in every request and instead uses a shared secret that is used to sign\nthe request in a secure manner. Like authorization tokens, these are commonly used to provide third-party developers\naccess to your API. These keys typically have a very long expiration time, often years.\n\nThese are also suitable for use with mobile applications. In this case, the user would register/sign-in\nwith their email/password. The application would create a new access token for them, with a recognizable\nname, like \"John's iPhone 12\", and return it to the mobile application, where it is stored and used\nin all future requests.\n\n!!! note\n\n    For the purpose of this documentation, and to maintain a level of consistency with the Authorization Tokens,\n    the term \"Token\" will be used to represent a set of API Keys (key and secretKey).\n\n## Usage\n\nIn order to use HMAC Keys/Token the `Authorization` header will be set to the following in the request:\n\n```\nAuthorization: HMAC-SHA256 <key>:<HMAC-HASH-of-request-body>\n```\n\nThe code to do this will look something like this:\n\n```php\nheader(\"Authorization: HMAC-SHA256 {$key}:\" . hash_hmac('sha256', $requestBody, $secretKey));\n```\n\nUsing the CodeIgniter CURLRequest class:\n\n```php\n<?php\n\n$client = \\Config\\Services::curlrequest();\n\n$key = 'a6c460151b4cabbe1c1d73e08915ce8e';\n$secretKey = '56c85232f0e5b55c05015476cd132c8d';\n$requestBody = '{\"name\":\"John\",\"email\":\"john@example.com\"}';\n\n// $hashValue = b22b0ec11ad61cd4488ab1a09c8a0317e896c22adcc5754ea4cfd0f903a0f8c2\n$hashValue = hash_hmac('sha256', $requestBody, $secretKey);\n\n$response = $client->setHeader('Authorization', \"HMAC-SHA256 {$key}:{$hashValue}\")\n    ->setBody($requestBody)\n    ->request('POST', 'https://example.com/api');\n```\n\n## HMAC Keys/API Authentication\n\nUsing HMAC keys requires that you either use/extend `CodeIgniter\\Shield\\Models\\UserModel` or\nuse the `CodeIgniter\\Shield\\Authentication\\Traits\\HasHmacTokens` on your own user model. This trait\nprovides all the custom methods needed to implement HMAC keys in your application. The necessary\ndatabase table, `auth_identities`, is created in Shield's only migration class, which must be run\nbefore first using any of the features of Shield.\n\n## Generating HMAC Access Keys\n\nAccess keys/tokens are created through the `generateHmacToken()` method on the user. This takes a name to\ngive to the token as the first argument. The name is used to display it to the user, so they can\ndifferentiate between multiple tokens.\n\n```php\n$token = $user->generateHmacToken('Work Laptop');\n```\n\nThis creates the keys/tokens using a cryptographically secure random string. The keys operate as shared keys.\nThe '**key**' is stored as plain text in the database, the '**secretKey**' is stored encrypted. The method returns an\ninstance of `CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken`. The field `secret` is the '**key**' the field\n`rawSecretKey` is the shared '**secretKey**'. Both are required to when using this authentication method.\n\n**The plain text version of these keys should be displayed to the user immediately, so they can copy it for\ntheir use.** It is recommended that after that only the '**key**' field is displayed to a user. If a user loses the\n'**secretKey**', they should be required to generate a new set of keys to use.\n\n```php\n$token = $user->generateHmacToken('Work Laptop');\n\necho 'Key: ' . $token->secret;\necho 'SecretKey: ' . $token->rawSecretKey;\n```\n\n## Revoking HMAC Keys\n\nHMAC keys can be revoked through the `revokeHmacToken()` method. This takes the key as the only\nargument. Revoking simply deletes the record from the database.\n\n```php\n$user->revokeHmacToken($key);\n```\n\nYou can revoke all HMAC Keys with the `revokeAllHmacTokens()` method.\n\n```php\n$user->revokeAllHmacTokens();\n```\n\n## Retrieving HMAC Keys\n\nThe following methods are available to help you retrieve a user's HMAC keys:\n\n```php\n// Retrieve a set of HMAC Token/Keys by key\n$token = $user->getHmacToken($key);\n\n// Retrieve an HMAC token/keys by its database ID\n$token = $user->getHmacTokenById($id);\n\n// Retrieve all HMAC tokens as an array of AccessToken instances.\n$tokens = $user->hmacTokens();\n```\n\n## HMAC Keys Scopes\n\nEach token (set of keys) can be given one or more scopes they can be used within. These can be thought of as\npermissions the token grants to the user. Scopes are provided when the token is generated and\ncannot be modified afterword.\n\n```php\n$token = $user->gererateHmacToken('Work Laptop', ['posts.manage', 'forums.manage']);\n```\n\nBy default, a user is granted a wildcard scope which provides access to all scopes. This is the\nsame as:\n\n```php\n$token = $user->gererateHmacToken('Work Laptop', ['*']);\n```\n\nDuring authentication, the HMAC Keys the user used is stored on the user. Once authenticated, you\ncan use the `hmacTokenCan()` and `hmacTokenCant()` methods on the user to determine if they have access\nto the specified scope.\n\n```php\nif ($user->hmacTokenCan('posts.manage')) {\n    // do something....\n}\n\nif ($user->hmacTokenCant('forums.manage')) {\n    // do something....\n}\n```\n\n## HMAC Secret Key Encryption\n\nThe HMAC Secret Key is stored encrypted. Before you start using HMAC, you will need to set/override the encryption key\nin `$hmacEncryptionKeys` in **app/Config/AuthToken.php**. This should be set using **.env** and/or system\nenvironment variables. Instructions on how to do that can be found in the\n[Setting Your Encryption Key](https://codeigniter.com/user_guide/libraries/encryption.html#setting-your-encryption-key)\nsection of the CodeIgniter 4 documentation.\n\nYou will also be able to adjust the default Driver `$hmacEncryptionDefaultDriver` and the default Digest\n`$hmacEncryptionDefaultDigest`, these default to `'OpenSSL'` and `'SHA512'` respectively. These can also be\noverridden for an individual key by including them in the keys array.\n\n```php\npublic $hmacEncryptionKeys = [\n    'k1' => [\n        'key' => 'hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7',\n    ],\n];\n\npublic string $hmacEncryptionCurrentKey    = 'k1';\npublic string $hmacEncryptionDefaultDriver = 'OpenSSL';\npublic string $hmacEncryptionDefaultDigest = 'SHA512';\n```\n\nWhen it is time to update your encryption keys you will need to add an additional key to the above\n`$hmacEncryptionKeys` array. Then adjust the `$hmacEncryptionCurrentKey` to point at the new key.  After the new\nencryption key is in place, run `php spark shield:hmac reencrypt` to re-encrypt all existing keys with the new\nencryption key.  You will need to leave the old key in the array as it will be used read the existing 'Secret Keys'\nduring re-encryption.\n\n```php\npublic $hmacEncryptionKeys = [\n    'k1' => [\n        'key' => 'hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7',\n    ],\n    'k2' => [\n        'key'    => 'hex2bin:451df599363b19be1434605fff8556a0bbfc50bede1bb33793dcde4d97fce4b0',\n        'digest' => 'SHA256',\n    ],\n];\n\npublic string $hmacEncryptionCurrentKey    = 'k2';\npublic string $hmacEncryptionDefaultDriver = 'OpenSSL';\npublic string $hmacEncryptionDefaultDigest = 'SHA512';\n\n```\n\n```console\nphp spark shield:hmac reencrypt\n```\n\nYou can (and should) set these values using environment variable and/or the **.env** file. To do this you will need to set\nthe values as JSON strings:\n\n```text\nauthtoken.hmacEncryptionKeys = '{\"k1\":{\"key\":\"hex2bin:923dfab5ddca0c7784c2c388a848a704f5e048736c1a852c862959da62ade8c7\"},\"k2\":{\"key\":\"hex2bin:451df599363b19be1434605fff8556a0bbfc50bede1bb33793dcde4d97fce4b0\"}}'\nauthtoken.hmacEncryptionCurrentKey = k2\n```\n\nDepending on the set length of the Secret Key and the type of encryption used, it is possible for the encrypted value to\nexceed the database column character limit of 255 characters. If this happens, creation of a new HMAC identity will\nthrow a `RuntimeException`.\n\n## Configuration\n\nConfigure **app/Config/AuthToken.php** for your needs.\n\n!!! note\n\n    Shield does not expect you use the Access Token Authenticator and HMAC Authenticator\n    at the same time. Therefore, some Config items are common.\n\n### HMAC Keys Lifetime\n\nHMAC Keys/Tokens will expire after a specified amount of time has passed since they have been used.\n\nBy default, this is set to 1 year. You can change this value by setting the `$unusedTokenLifetime`\nvalue. This is in seconds so that you can use the\n[time constants](https://codeigniter.com/user_guide/general/common_functions.html#time-constants)\nthat CodeIgniter provides.\n\n```php\npublic $unusedTokenLifetime = YEAR;\n```\n\n### Login Attempt Logging\n\nBy default, only failed login attempts are recorded in the `auth_token_logins` table.\nThis can be modified by changing the `$recordLoginAttempt` value.\n\n```php\npublic int $recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_FAILURE;\n```\n\nIf you don't want any logs, set it to `Auth::RECORD_LOGIN_ATTEMPT_NONE`.\n\nIf you want to log all login attempts, set it to `Auth::RECORD_LOGIN_ATTEMPT_ALL`.\nIt means you log all requests.\n\n## Logging\n\nLogin attempts are recorded in the `auth_token_logins` table, according to the\nconfiguration above.\n\nWhen a failed login attempt is logged, the raw token value sent is saved in\nthe `identifier` column.\n\nWhen a successful login attempt is logged, the token name is saved in the\n`identifier` column.\n", "# Access Token Authenticator\n\nThe Access Token authenticator supports the use of revoke-able API tokens without using OAuth. These are commonly\nused to provide third-party developers access to your API. These tokens typically have a very long\nexpiration time, often years.\n\nThese are also suitable for use with mobile applications. In this case, the user would register/sign-in\nwith their email/password. The application would create a new access token for them, with a recognizable\nname, like John's iPhone 12, and return it to the mobile application, where it is stored and used\nin all future requests.\n\n## Access Token/API Authentication\n\nUsing access tokens requires that you either use/extend `CodeIgniter\\Shield\\Models\\UserModel` or\nuse the `CodeIgniter\\Shield\\Authentication\\Traits\\HasAccessTokens` on your own user model. This trait\nprovides all of the custom methods needed to implement access tokens in your application. The necessary\ndatabase table, `auth_identities`, is created in Shield's only migration class, which must be run\nbefore first using any of the features of Shield.\n\n## Generating Access Tokens\n\nAccess tokens are created through the `generateAccessToken()` method on the user. This takes a name to\ngive to the token as the first argument. The name is used to display it to the user so they can\ndifferentiate between multiple tokens.\n\n```php\n$token = $user->generateAccessToken('Work Laptop');\n```\n\nThis creates the token using a cryptographically secure random string. The token\nis hashed (sha256) before saving it to the database. The method returns an instance of\n`CodeIgniters\\Shield\\Authentication\\Entities\\AccessToken`. The only time a plain text\nversion of the token is available is in the `AccessToken` returned immediately after creation.\n\n**The plain text version should be displayed to the user immediately so they can copy it for\ntheir use.** If a user loses it, they cannot see the raw version anymore, but they can generate\na new token to use.\n\n```php\n$token = $user->generateAccessToken('Work Laptop');\n\n// Only available immediately after creation.\necho $token->raw_token;\n```\n\n## Revoking Access Tokens\n\nAccess tokens can be revoked through the `revokeAccessToken()` method. This takes the plain-text\naccess token as the only argument. Revoking simply deletes the record from the database.\n\n```php\n$user->revokeAccessToken($token);\n```\n\nTypically, the plain text token is retrieved from the request's headers as part of the authentication\nprocess. If you need to revoke the token for another user as an admin, and don't have access to the\ntoken, you would need to get the user's access tokens and delete them manually.\n\nIf you don't have the raw token usable to remove the token there is the possibility to remove it using the tokens secret thats stored in the database. It's possible to get a list of all tokens with there secret using the `accessTokens()` function.\n\n```php\n$user->revokeAccessTokenBySecret($secret);\n```\n\nYou can revoke all access tokens with the `revokeAllAccessTokens()` method.\n\n```php\n$user->revokeAllAccessTokens();\n```\n\n## Retrieving Access Tokens\n\nThe following methods are available to help you retrieve a user's access tokens:\n\n```php\n// Retrieve a single token by plain text token\n$token = $user->getAccessToken($rawToken);\n\n// Retrieve a single token by it's database ID\n$token = $user->getAccessTokenById($id);\n\n// Retrieve all access tokens as an array of AccessToken instances.\n$tokens = $user->accessTokens();\n```\n\n## Access Token Scopes\n\nEach token can be given one or more scopes they can be used within. These can be thought of as\npermissions the token grants to the user. Scopes are provided when the token is generated and\ncannot be modified afterword.\n\n```php\n$token = $user->gererateAccessToken('Work Laptop', ['posts.manage', 'forums.manage']);\n```\n\nBy default a user is granted a wildcard scope which provides access to all scopes. This is the\nsame as:\n\n```php\n$token = $user->gererateAccessToken('Work Laptop', ['*']);\n```\n\nDuring authentication, the token the user used is stored on the user. Once authenticated, you\ncan use the `tokenCan()` and `tokenCant()` methods on the user to determine if they have access\nto the specified scope.\n\n```php\nif ($user->tokenCan('posts.manage')) {\n    // do something....\n}\n\nif ($user->tokenCant('forums.manage')) {\n    // do something....\n}\n```\n\n## Configuration\n\nConfigure **app/Config/AuthToken.php** for your needs.\n\n!!! note\n\n    Shield does not expect you use the Access Token Authenticator and HMAC Authenticator\n    at the same time. Therefore, some Config items are common.\n\n### Access Token Lifetime\n\nTokens will expire after a specified amount of time has passed since they have been used.\n\nBy default, this is set to 1 year.\nYou can change this value by setting the `$unusedTokenLifetime` value. This is\nin seconds so that you can use the\n[time constants](https://codeigniter.com/user_guide/general/common_functions.html#time-constants)\nthat CodeIgniter provides.\n\n```php\npublic $unusedTokenLifetime = YEAR;\n```\n\n### Login Attempt Logging\n\nBy default, only failed login attempts are recorded in the `auth_token_logins` table.\n\nThis can be modified by changing the `$recordLoginAttempt` value.\n\n```php\npublic int $recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_FAILURE;\n```\n\nIf you don't want any logs, set it to `Auth::RECORD_LOGIN_ATTEMPT_NONE`.\n\nIf you want to log all login attempts, set it to `Auth::RECORD_LOGIN_ATTEMPT_ALL`.\nIt means you log all requests.\n\n## Logging\n\nLogin attempts are recorded in the `auth_token_logins` table, according to the\nconfiguration above.\n\nWhen a failed login attempt is logged, the raw token value sent is saved in\nthe `identifier` column.\n\nWhen a successful login attempt is logged, the token name is saved in the\n`identifier` column.\n", "<?php declare(strict_types = 1);\n\n$ignoreErrors = [];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Actions/Email2FA.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Actions/Email2FA.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Actions/Email2FA.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Actions/EmailActivator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Actions/EmailActivator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authentication.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 4,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in &&, CodeIgniter\\\\\\\\I18n\\\\\\\\Time\\\\|null given on the left side\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\TokenLoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/AccessTokens.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{token\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\JWT\\\\:\\\\:attempt\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:attempt\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/JWT.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{token\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\JWT\\\\:\\\\:check\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:check\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/JWT.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\TokenLoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/JWT.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in an elseif condition, string\\\\|null given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in an if condition, CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\UserIdentity\\\\|null given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in an if condition, int\\\\|string\\\\|null given\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{email\\\\?\\\\: string, username\\\\?\\\\: string, password\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\Session\\\\:\\\\:attempt\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:attempt\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$credentials \\\\(array\\\\{email\\\\?\\\\: string, username\\\\?\\\\: string, password\\\\?\\\\: string\\\\}\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Authenticators\\\\\\\\Session\\\\:\\\\:check\\\\(\\\\) should be contravariant with parameter \\\\$credentials \\\\(array\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\AuthenticatorInterface\\\\:\\\\:check\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\LoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\RememberModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/Session.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method CodeIgniter\\\\\\\\Shield\\\\\\\\Result\\\\:\\\\:isOK\\\\(\\\\) with incorrect case\\\\: isOk$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/CompositionValidator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 5,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/NothingPersonalValidator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method CodeIgniter\\\\\\\\Shield\\\\\\\\Result\\\\:\\\\:isOK\\\\(\\\\) with incorrect case\\\\: isOk$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/ValidationRules.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/ValidationRules.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in &&, CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\|null given on the right side\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Passwords/ValidationRules.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/src/Authorization/Groups.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Return type \\\\(int\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Collectors\\\\\\\\Auth\\\\:\\\\:getBadgeValue\\\\(\\\\) should be covariant with return type \\\\(int\\\\|null\\\\) of method CodeIgniter\\\\\\\\Debug\\\\\\\\Toolbar\\\\\\\\Collectors\\\\\\\\BaseCollector\\\\:\\\\:getBadgeValue\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Collectors/Auth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^PHPDoc type array\\\\<string, string\\\\> of property CodeIgniter\\\\\\\\Shield\\\\\\\\Commands\\\\\\\\Generators\\\\\\\\UserModelGenerator\\\\:\\\\:\\\\$arguments is not the same as PHPDoc type array of overridden property CodeIgniter\\\\\\\\CLI\\\\\\\\BaseCommand\\\\:\\\\:\\\\$arguments\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Commands/Generators/UserModelGenerator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^PHPDoc type array\\\\<string, string\\\\> of property CodeIgniter\\\\\\\\Shield\\\\\\\\Commands\\\\\\\\Generators\\\\\\\\UserModelGenerator\\\\:\\\\:\\\\$options is not the same as PHPDoc type array of overridden property CodeIgniter\\\\\\\\CLI\\\\\\\\BaseCommand\\\\:\\\\:\\\\$options\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Commands/Generators/UserModelGenerator.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/ActionController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Instanceof between CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Actions\\\\\\\\ActionInterface and CodeIgniter\\\\\\\\Shield\\\\\\\\Authentication\\\\\\\\Actions\\\\\\\\ActionInterface will always evaluate to true\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/ActionController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/MagicLinkController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Controllers/MagicLinkController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\LoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/MagicLinkController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function assert\\\\(\\\\) with false and \\'Config Auth\u2026\\' will always evaluate to false\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/RegisterController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Instanceof between null and CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel will always evaluate to false\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/RegisterController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$name of function model expects a valid class string, array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Controllers/RegisterController.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to an undefined method CodeIgniter\\\\\\\\Database\\\\\\\\ConnectionInterface\\\\:\\\\:disableForeignKeyChecks\\\\(\\\\)\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Database/Migrations/2020-12-28-223112_create_auth_tables.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to an undefined method CodeIgniter\\\\\\\\Database\\\\\\\\ConnectionInterface\\\\:\\\\:enableForeignKeyChecks\\\\(\\\\)\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Database/Migrations/2020-12-28-223112_create_auth_tables.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(bool\\\\|int\\\\|string\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:set\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\BaseCast\\\\:\\\\:set\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(bool\\\\|int\\\\|string\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:set\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\CastInterface\\\\:\\\\:set\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(int\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:get\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\BaseCast\\\\:\\\\:get\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$value \\\\(int\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Cast\\\\\\\\IntBoolCast\\\\:\\\\:get\\\\(\\\\) should be contravariant with parameter \\\\$value \\\\(array\\\\|bool\\\\|float\\\\|int\\\\|object\\\\|string\\\\|null\\\\) of method CodeIgniter\\\\\\\\Entity\\\\\\\\Cast\\\\\\\\CastInterface\\\\:\\\\:get\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Cast/IntBoolCast.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^PHPDoc type array\\\\<string, class\\\\-string\\\\> of property CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\Entity\\\\:\\\\:\\\\$castHandlers is not the same as PHPDoc type array\\\\<string, string\\\\> of overridden property CodeIgniter\\\\\\\\Entity\\\\\\\\Entity\\\\:\\\\:\\\\$castHandlers\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/Entity.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Entities/Group.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 8,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in a ternary operator condition, int\\\\<0, max\\\\> given\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 19,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\LoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Entities/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 9,\n\t'path' => __DIR__ . '/src/Commands/User.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Filters/AbstractAuthFilter.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Method CodeIgniter\\\\\\\\Shield\\\\\\\\Filters\\\\\\\\AuthRates\\\\:\\\\:before\\\\(\\\\) should return CodeIgniter\\\\\\\\HTTP\\\\\\\\RedirectResponse\\\\|void but returns CodeIgniter\\\\\\\\HTTP\\\\\\\\ResponseInterface\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Filters/AuthRates.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method CodeIgniter\\\\\\\\HTTP\\\\\\\\ResponseInterface\\\\:\\\\:setJSON\\\\(\\\\) with incorrect case\\\\: setJson$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Filters/TokenAuth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Filters/TokenAuth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Method CodeIgniter\\\\\\\\Shield\\\\\\\\Filters\\\\\\\\TokenAuth\\\\:\\\\:before\\\\(\\\\) should return CodeIgniter\\\\\\\\HTTP\\\\\\\\RedirectResponse\\\\|void but returns CodeIgniter\\\\\\\\HTTP\\\\\\\\ResponseInterface\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Filters/TokenAuth.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/TokenLoginModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to deprecated function random_string\\\\(\\\\)\\\\:\nThe type \\'basic\\', \\'md5\\', and \\'sha1\\' are deprecated\\\\. They are not cryptographically secure\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserIdentityModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Cannot unset offset \\'email\\' on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Cannot unset offset \\'password_hash\\' on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Offset \\'email\\' does not exist on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Offset \\'password_hash\\' does not exist on array\\\\{username\\\\: string, status\\\\: string, status_message\\\\: string, active\\\\: bool, last_active\\\\: string, deleted_at\\\\: string\\\\}\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$data \\\\(array\\\\|CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:insert\\\\(\\\\) should be contravariant with parameter \\\\$data \\\\(array\\\\|object\\\\|null\\\\) of method CodeIgniter\\\\\\\\Model\\\\:\\\\:insert\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#1 \\\\$data \\\\(array\\\\|CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:save\\\\(\\\\) should be contravariant with parameter \\\\$data \\\\(array\\\\|object\\\\) of method CodeIgniter\\\\\\\\BaseModel\\\\:\\\\:save\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Parameter \\\\#2 \\\\$data \\\\(array\\\\|CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\User\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:update\\\\(\\\\) should be contravariant with parameter \\\\$data \\\\(array\\\\|object\\\\|null\\\\) of method CodeIgniter\\\\\\\\Model\\\\:\\\\:update\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Return type \\\\(int\\\\|string\\\\|true\\\\) of method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:insert\\\\(\\\\) should be covariant with return type \\\\(int\\\\|object\\\\|string\\\\|false\\\\) of method CodeIgniter\\\\\\\\Model\\\\:\\\\:insert\\\\(\\\\)$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Models/UserModel.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Result\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Result will always evaluate to true\\\\.$#',\n\t'count' => 3,\n\t'path' => __DIR__ . '/tests/Authentication/Authenticators/JWTAuthenticatorTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Result\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Result will always evaluate to true\\\\.$#',\n\t'count' => 9,\n\t'path' => __DIR__ . '/tests/Authentication/Authenticators/SessionAuthenticatorTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Construct empty\\\\(\\\\) is not allowed\\\\. Use more strict comparison\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/Filters/AbstractFilterTestCase.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Implicit array creation is not allowed \\\\- variable \\\\$users might not exist\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/ForcePasswordResetTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Variable \\\\$users might not be defined\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/ForcePasswordResetTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Entities\\\\\\\\\\\\\\\\AccessToken\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\AccessToken will always evaluate to true\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Authentication/HasAccessTokensTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Only booleans are allowed in a ternary operator condition, string\\\\|null given\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/tests/Language/AbstractTranslationTestCase.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertIsString\\\\(\\\\) with string will always evaluate to true\\\\.$#',\n\t'count' => 6,\n\t'path' => __DIR__ . '/tests/Unit/Authentication/JWT/JWTManagerTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to an undefined method CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserModel\\\\:\\\\:getLastQuery\\\\(\\\\)\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Unit/UserTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to method PHPUnit\\\\\\\\Framework\\\\\\\\Assert\\\\:\\\\:assertInstanceOf\\\\(\\\\) with \\'CodeIgniter\\\\\\\\\\\\\\\\Shield\\\\\\\\\\\\\\\\Entities\\\\\\\\\\\\\\\\UserIdentity\\' and CodeIgniter\\\\\\\\Shield\\\\\\\\Entities\\\\\\\\UserIdentity will always evaluate to true\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/tests/Unit/UserTest.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\TokenLoginModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/HmacSha256.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\UserIdentityModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 1,\n\t'path' => __DIR__ . '/src/Authentication/Authenticators/HmacSha256.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\GroupModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authorization/Traits/Authorizable.php',\n];\n$ignoreErrors[] = [\n\t'message' => '#^Call to function model with CodeIgniter\\\\\\\\Shield\\\\\\\\Models\\\\\\\\PermissionModel\\\\:\\\\:class is discouraged\\\\.$#',\n\t'count' => 2,\n\t'path' => __DIR__ . '/src/Authorization/Traits/Authorizable.php',\n];\nreturn ['parameters' => ['ignoreErrors' => $ignoreErrors]];\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Authentication\\Authenticators;\n\nuse CodeIgniter\\HTTP\\IncomingRequest;\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticatorInterface;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Exceptions\\InvalidArgumentException;\nuse CodeIgniter\\Shield\\Models\\TokenLoginModel;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\n\nclass AccessTokens implements AuthenticatorInterface\n{\n    public const ID_TYPE_ACCESS_TOKEN = 'access_token';\n\n    /**\n     * The persistence engine\n     */\n    protected UserModel $provider;\n\n    protected ?User $user = null;\n    protected TokenLoginModel $loginModel;\n\n    public function __construct(UserModel $provider)\n    {\n        $this->provider = $provider;\n\n        $this->loginModel = model(TokenLoginModel::class);\n    }\n\n    /**\n     * Attempts to authenticate a user with the given $credentials.\n     * Logs the user in with a successful check.\n     *\n     * @throws AuthenticationException\n     */\n    public function attempt(array $credentials): Result\n    {\n        $config = config('AuthToken');\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $ipAddress = $request->getIPAddress();\n        $userAgent = (string) $request->getUserAgent();\n\n        $result = $this->check($credentials);\n\n        if (! $result->isOK()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record all failed login attempts.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_ACCESS_TOKEN,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent\n                );\n            }\n\n            return $result;\n        }\n\n        $user  = $result->extraInfo();\n        $token = $user->getAccessToken($this->getBearerToken());\n\n        if ($user->isBanned()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a banned login attempt.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_ACCESS_TOKEN,\n                    $token->name ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent,\n                    $user->id\n                );\n            }\n\n            $this->user = null;\n\n            return new Result([\n                'success' => false,\n                'reason'  => $user->getBanMessage() ?? lang('Auth.bannedUser'),\n            ]);\n        }\n\n        $user = $user->setAccessToken($token);\n\n        $this->login($user);\n\n        if ($config->recordLoginAttempt === Auth::RECORD_LOGIN_ATTEMPT_ALL) {\n            // Record a successful login attempt.\n            $this->loginModel->recordLoginAttempt(\n                self::ID_TYPE_ACCESS_TOKEN,\n                $token->name ?? '',\n                true,\n                $ipAddress,\n                $userAgent,\n                $this->user->id\n            );\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks a user's $credentials to see if they match an\n     * existing user.\n     *\n     * In this case, $credentials has only a single valid value: token,\n     * which is the plain text token to return.\n     */\n    public function check(array $credentials): Result\n    {\n        if (! array_key_exists('token', $credentials) || empty($credentials['token'])) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang(\n                    'Auth.noToken',\n                    [config('AuthToken')->authenticatorHeader['tokens']]\n                ),\n            ]);\n        }\n\n        if (strpos($credentials['token'], 'Bearer') === 0) {\n            $credentials['token'] = trim(substr($credentials['token'], 6));\n        }\n\n        /** @var UserIdentityModel $identityModel */\n        $identityModel = model(UserIdentityModel::class);\n\n        $token = $identityModel->getAccessTokenByRawToken($credentials['token']);\n\n        if ($token === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.badToken'),\n            ]);\n        }\n\n        assert($token->last_used_at instanceof Time || $token->last_used_at === null);\n\n        // Hasn't been used in a long time\n        if (\n            $token->last_used_at\n            && $token->last_used_at->isBefore(\n                Time::now()->subSeconds(config('AuthToken')->unusedTokenLifetime)\n            )\n        ) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.oldToken'),\n            ]);\n        }\n\n        $token->last_used_at = Time::now()->format('Y-m-d H:i:s');\n\n        if ($token->hasChanged()) {\n            $identityModel->save($token);\n        }\n\n        // Ensure the token is set as the current token\n        $user = $token->user();\n        $user->setAccessToken($token);\n\n        return new Result([\n            'success'   => true,\n            'extraInfo' => $user,\n        ]);\n    }\n\n    /**\n     * Checks if the user is currently logged in.\n     * Since AccessToken usage is inherently stateless,\n     * it runs $this->attempt on each usage.\n     */\n    public function loggedIn(): bool\n    {\n        if (! empty($this->user)) {\n            return true;\n        }\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        return $this->attempt([\n            'token' => $request->getHeaderLine(\n                config('AuthToken')->authenticatorHeader['tokens']\n            ),\n        ])->isOK();\n    }\n\n    /**\n     * Logs the given user in by saving them to the class.\n     */\n    public function login(User $user): void\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Logs a user in based on their ID.\n     *\n     * @param int|string $userId\n     *\n     * @throws AuthenticationException\n     */\n    public function loginById($userId): void\n    {\n        $user = $this->provider->findById($userId);\n\n        if (empty($user)) {\n            throw AuthenticationException::forInvalidUser();\n        }\n\n        $user->setAccessToken(\n            $user->getAccessToken($this->getBearerToken())\n        );\n\n        $this->login($user);\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout(): void\n    {\n        $this->user = null;\n    }\n\n    /**\n     * Returns the currently logged in user.\n     */\n    public function getUser(): ?User\n    {\n        return $this->user;\n    }\n\n    /**\n     * Returns the Bearer token from the Authorization header\n     */\n    public function getBearerToken(): ?string\n    {\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $header = $request->getHeaderLine(config('AuthToken')->authenticatorHeader['tokens']);\n\n        if (empty($header)) {\n            return null;\n        }\n\n        return trim(substr($header, 6));   // 'Bearer'\n    }\n\n    /**\n     * Updates the user's last active date.\n     */\n    public function recordActiveDate(): void\n    {\n        if (! $this->user instanceof User) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() requires logged in user before calling.'\n            );\n        }\n\n        $this->user->last_active = Time::now();\n\n        $this->provider->updateActiveDate($this->user);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Authentication\\Authenticators;\n\nuse CodeIgniter\\HTTP\\IncomingRequest;\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticatorInterface;\nuse CodeIgniter\\Shield\\Authentication\\HMAC\\HmacEncrypter;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Exceptions\\InvalidArgumentException;\nuse CodeIgniter\\Shield\\Models\\TokenLoginModel;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\n\nclass HmacSha256 implements AuthenticatorInterface\n{\n    public const ID_TYPE_HMAC_TOKEN = 'hmac_sha256';\n\n    /**\n     * The persistence engine\n     */\n    protected UserModel $provider;\n\n    protected ?User $user = null;\n    protected TokenLoginModel $loginModel;\n\n    public function __construct(UserModel $provider)\n    {\n        $this->provider = $provider;\n\n        $this->loginModel = model(TokenLoginModel::class);\n    }\n\n    /**\n     * Attempts to authenticate a user with the given $credentials.\n     * Logs the user in with a successful check.\n     *\n     * @throws AuthenticationException\n     */\n    public function attempt(array $credentials): Result\n    {\n        $config = config('AuthToken');\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $ipAddress = $request->getIPAddress();\n        $userAgent = (string) $request->getUserAgent();\n\n        $result = $this->check($credentials);\n\n        if (! $result->isOK()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record all failed login attempts.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_HMAC_TOKEN,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent\n                );\n            }\n\n            return $result;\n        }\n\n        $user  = $result->extraInfo();\n        $token = $user->getHmacToken($this->getHmacKeyFromToken());\n\n        if ($user->isBanned()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a banned login attempt.\n                $this->loginModel->recordLoginAttempt(\n                    self::ID_TYPE_HMAC_TOKEN,\n                    $token->name ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent,\n                    $user->id\n                );\n            }\n\n            $this->user = null;\n\n            return new Result([\n                'success' => false,\n                'reason'  => $user->getBanMessage() ?? lang('Auth.bannedUser'),\n            ]);\n        }\n\n        $user = $user->setHmacToken($token);\n\n        $this->login($user);\n\n        if ($config->recordLoginAttempt === Auth::RECORD_LOGIN_ATTEMPT_ALL) {\n            // Record a successful login attempt.\n            $this->loginModel->recordLoginAttempt(\n                self::ID_TYPE_HMAC_TOKEN,\n                $token->name ?? '',\n                true,\n                $ipAddress,\n                $userAgent,\n                $this->user->id\n            );\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks a user's $credentials to see if they match an\n     * existing user.\n     *\n     * In this case, $credentials has only a single valid value: token,\n     * which is the plain text token to return.\n     */\n    public function check(array $credentials): Result\n    {\n        if (! array_key_exists('token', $credentials) || $credentials['token'] === '') {\n            return new Result([\n                'success' => false,\n                'reason'  => lang(\n                    'Auth.noToken',\n                    [config('AuthToken')->authenticatorHeader['hmac']]\n                ),\n            ]);\n        }\n\n        if (strpos($credentials['token'], 'HMAC-SHA256') === 0) {\n            $credentials['token'] = trim(substr($credentials['token'], 11)); // HMAC-SHA256\n        }\n\n        // Extract UserToken and HMACSHA256 Signature from Authorization token\n        [$userToken, $signature] = $this->getHmacAuthTokens($credentials['token']);\n\n        /** @var UserIdentityModel $identityModel */\n        $identityModel = model(UserIdentityModel::class);\n\n        $token = $identityModel->getHmacTokenByKey($userToken);\n\n        if ($token === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.badToken'),\n            ]);\n        }\n\n        $encrypter = new HmacEncrypter();\n        $secretKey = $encrypter->decrypt($token->secret2);\n\n        // Check signature...\n        $hash = hash_hmac('sha256', $credentials['body'], $secretKey);\n        if ($hash !== $signature) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.badToken'),\n            ]);\n        }\n\n        assert($token->last_used_at instanceof Time || $token->last_used_at === null);\n\n        // Hasn't been used in a long time\n        if (\n            isset($token->last_used_at)\n            && $token->last_used_at->isBefore(\n                Time::now()->subSeconds(config('AuthToken')->unusedTokenLifetime)\n            )\n        ) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.oldToken'),\n            ]);\n        }\n\n        $token->last_used_at = Time::now()->format('Y-m-d H:i:s');\n\n        if ($token->hasChanged()) {\n            $identityModel->save($token);\n        }\n\n        // Ensure the token is set as the current token\n        $user = $token->user();\n        $user->setHmacToken($token);\n\n        return new Result([\n            'success'   => true,\n            'extraInfo' => $user,\n        ]);\n    }\n\n    /**\n     * Checks if the user is currently logged in.\n     * Since AccessToken usage is inherently stateless,\n     * it runs $this->attempt on each usage.\n     */\n    public function loggedIn(): bool\n    {\n        if (isset($this->user)) {\n            return true;\n        }\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        return $this->attempt([\n            'token' => $request->getHeaderLine(\n                config('AuthToken')->authenticatorHeader['hmac']\n            ),\n        ])->isOK();\n    }\n\n    /**\n     * Logs the given user in by saving them to the class.\n     */\n    public function login(User $user): void\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Logs a user in based on their ID.\n     *\n     * @param int|string $userId User ID\n     *\n     * @throws AuthenticationException\n     */\n    public function loginById($userId): void\n    {\n        $user = $this->provider->findById($userId);\n\n        if ($user === null) {\n            throw AuthenticationException::forInvalidUser();\n        }\n\n        $user->setHmacToken(\n            $user->getHmacToken($this->getHmacKeyFromToken())\n        );\n\n        $this->login($user);\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout(): void\n    {\n        $this->user = null;\n    }\n\n    /**\n     * Returns the currently logged-in user.\n     */\n    public function getUser(): ?User\n    {\n        return $this->user;\n    }\n\n    /**\n     * Returns the Full HMAC Authorization token from the Authorization header\n     *\n     * @return ?string Trimmed Authorization Token from Header\n     */\n    public function getFullHmacToken(): ?string\n    {\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $header = $request->getHeaderLine(config('AuthToken')->authenticatorHeader['hmac']);\n\n        if ($header === '') {\n            return null;\n        }\n\n        return trim(substr($header, 11));   // 'HMAC-SHA256'\n    }\n\n    /**\n     * Get Key and HMAC hash from Auth token\n     *\n     * @param ?string $fullToken Full Token\n     *\n     * @return ?array [key, hmacHash]\n     */\n    public function getHmacAuthTokens(?string $fullToken = null): ?array\n    {\n        if (! isset($fullToken)) {\n            $fullToken = $this->getFullHmacToken();\n        }\n\n        if (isset($fullToken)) {\n            return preg_split('/:/', $fullToken, -1, PREG_SPLIT_NO_EMPTY);\n        }\n\n        return null;\n    }\n\n    /**\n     * Retrieve the key from the Auth token\n     *\n     * @return ?string HMAC token key\n     */\n    public function getHmacKeyFromToken(): ?string\n    {\n        [$key, $secretKey] = $this->getHmacAuthTokens();\n\n        return $key;\n    }\n\n    /**\n     * Retrieve the HMAC Hash from the Auth token\n     *\n     * @return ?string HMAC Hash\n     */\n    public function getHmacHashFromToken(): ?string\n    {\n        [$key, $hash] = $this->getHmacAuthTokens();\n\n        return $hash;\n    }\n\n    /**\n     * Updates the user's last active date.\n     */\n    public function recordActiveDate(): void\n    {\n        if (! $this->user instanceof User) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() requires logged in user before calling.'\n            );\n        }\n\n        $this->user->last_active = Time::now();\n\n        $this->provider->updateActiveDate($this->user);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Authentication\\Authenticators;\n\nuse CodeIgniter\\HTTP\\IncomingRequest;\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticatorInterface;\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Config\\AuthJWT;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Exceptions\\RuntimeException;\nuse CodeIgniter\\Shield\\Models\\TokenLoginModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\nuse InvalidArgumentException;\nuse stdClass;\n\n/**\n * Stateless JWT Authenticator\n */\nclass JWT implements AuthenticatorInterface\n{\n    /**\n     * @var string Special ID Type.\n     *             This Authenticator is stateless, so no `auth_identities` record.\n     */\n    public const ID_TYPE_JWT = 'jwt';\n\n    /**\n     * The persistence engine\n     */\n    protected UserModel $provider;\n\n    protected ?User $user = null;\n    protected JWTManager $jwtManager;\n    protected TokenLoginModel $tokenLoginModel;\n    protected ?stdClass $payload = null;\n\n    /**\n     * @var string The key group. The array key of Config\\AuthJWT::$keys.\n     */\n    protected $keyset = 'default';\n\n    public function __construct(UserModel $provider)\n    {\n        $this->provider = $provider;\n\n        $this->jwtManager      = service('jwtmanager');\n        $this->tokenLoginModel = model(TokenLoginModel::class);\n    }\n\n    /**\n     * Attempts to authenticate a user with the given $credentials.\n     * Logs the user in with a successful check.\n     *\n     * @param array{token?: string} $credentials\n     */\n    public function attempt(array $credentials): Result\n    {\n        /** @var AuthJWT $config */\n        $config = config('AuthJWT');\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        $ipAddress = $request->getIPAddress();\n        $userAgent = (string) $request->getUserAgent();\n\n        $result = $this->check($credentials);\n\n        if (! $result->isOK()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a failed login attempt.\n                $this->tokenLoginModel->recordLoginAttempt(\n                    self::ID_TYPE_JWT,\n                    $credentials['token'] ?? '',\n                    false,\n                    $ipAddress,\n                    $userAgent\n                );\n            }\n\n            return $result;\n        }\n\n        $user = $result->extraInfo();\n\n        if ($user->isBanned()) {\n            if ($config->recordLoginAttempt >= Auth::RECORD_LOGIN_ATTEMPT_FAILURE) {\n                // Record a banned login attempt.\n                $this->tokenLoginModel->recordLoginAttempt(\n                    self::ID_TYPE_JWT,\n                    'sha256:' . hash('sha256', $credentials['token'] ?? ''),\n                    false,\n                    $ipAddress,\n                    $userAgent,\n                    $user->id\n                );\n            }\n\n            $this->user = null;\n\n            return new Result([\n                'success' => false,\n                'reason'  => $user->getBanMessage() ?? lang('Auth.bannedUser'),\n            ]);\n        }\n\n        $this->login($user);\n\n        if ($config->recordLoginAttempt === Auth::RECORD_LOGIN_ATTEMPT_ALL) {\n            // Record a successful login attempt.\n            $this->tokenLoginModel->recordLoginAttempt(\n                self::ID_TYPE_JWT,\n                'sha256:' . hash('sha256', $credentials['token']),\n                true,\n                $ipAddress,\n                $userAgent,\n                $this->user->id\n            );\n        }\n\n        return $result;\n    }\n\n    /**\n     * Checks a user's $credentials to see if they match an\n     * existing user.\n     *\n     * In this case, $credentials has only a single valid value: token,\n     * which is the plain text token to return.\n     *\n     * @param array{token?: string} $credentials\n     */\n    public function check(array $credentials): Result\n    {\n        if (! array_key_exists('token', $credentials) || $credentials['token'] === '') {\n            return new Result([\n                'success' => false,\n                'reason'  => lang(\n                    'Auth.noToken',\n                    [config('AuthJWT')->authenticatorHeader]\n                ),\n            ]);\n        }\n\n        // Check JWT\n        try {\n            $this->payload = $this->jwtManager->parse($credentials['token'], $this->keyset);\n        } catch (RuntimeException $e) {\n            return new Result([\n                'success' => false,\n                'reason'  => $e->getMessage(),\n            ]);\n        }\n\n        $userId = $this->payload->sub ?? null;\n\n        if ($userId === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => 'Invalid JWT: no user_id',\n            ]);\n        }\n\n        // Find User\n        $user = $this->provider->findById($userId);\n\n        if ($user === null) {\n            return new Result([\n                'success' => false,\n                'reason'  => lang('Auth.invalidUser'),\n            ]);\n        }\n\n        return new Result([\n            'success'   => true,\n            'extraInfo' => $user,\n        ]);\n    }\n\n    /**\n     * Checks if the user is currently logged in.\n     * Since AccessToken usage is inherently stateless,\n     * it runs $this->attempt on each usage.\n     */\n    public function loggedIn(): bool\n    {\n        if ($this->user !== null) {\n            return true;\n        }\n\n        /** @var IncomingRequest $request */\n        $request = service('request');\n\n        /** @var AuthJWT $config */\n        $config = config('AuthJWT');\n\n        return $this->attempt([\n            'token' => $request->getHeaderLine($config->authenticatorHeader),\n        ])->isOK();\n    }\n\n    /**\n     * Logs the given user in by saving them to the class.\n     */\n    public function login(User $user): void\n    {\n        $this->user = $user;\n    }\n\n    /**\n     * Logs a user in based on their ID.\n     *\n     * @param int|string $userId\n     *\n     * @throws AuthenticationException\n     */\n    public function loginById($userId): void\n    {\n        $user = $this->provider->findById($userId);\n\n        if ($user === null) {\n            throw AuthenticationException::forInvalidUser();\n        }\n\n        $this->login($user);\n    }\n\n    /**\n     * Logs the current user out.\n     */\n    public function logout(): void\n    {\n        $this->user = null;\n    }\n\n    /**\n     * Returns the currently logged in user.\n     */\n    public function getUser(): ?User\n    {\n        return $this->user;\n    }\n\n    /**\n     * Updates the user's last active date.\n     */\n    public function recordActiveDate(): void\n    {\n        if (! $this->user instanceof User) {\n            throw new InvalidArgumentException(\n                __METHOD__ . '() requires logged in user before calling.'\n            );\n        }\n\n        $this->user->last_active = Time::now();\n\n        $this->provider->save($this->user);\n    }\n\n    /**\n     * @param string $keyset The key group. The array key of Config\\AuthJWT::$keys.\n     */\n    public function setKeyset($keyset): void\n    {\n        $this->keyset = $keyset;\n    }\n\n    /**\n     * Returns payload\n     */\n    public function getPayload(): ?stdClass\n    {\n        return $this->payload;\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace CodeIgniter\\Shield\\Config;\n\n/**\n * Configuration for Token Auth and HMAC Auth\n */\nclass AuthToken extends BaseAuthToken\n{\n    /**\n     * --------------------------------------------------------------------\n     * Record Login Attempts for Token Auth and HMAC Auth\n     * --------------------------------------------------------------------\n     * Specify which login attempts are recorded in the database.\n     *\n     * Valid values are:\n     * - Auth::RECORD_LOGIN_ATTEMPT_NONE\n     * - Auth::RECORD_LOGIN_ATTEMPT_FAILURE\n     * - Auth::RECORD_LOGIN_ATTEMPT_ALL\n     */\n    public int $recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_FAILURE;\n\n    /**\n     * --------------------------------------------------------------------\n     * Name of Authenticator Header\n     * --------------------------------------------------------------------\n     * The name of Header that the Authorization token should be found.\n     * According to the specs, this should be `Authorization`, but rare\n     * circumstances might need a different header.\n     */\n    public array $authenticatorHeader = [\n        'tokens' => 'Authorization',\n        'hmac'   => 'Authorization',\n    ];\n\n    /**\n     * --------------------------------------------------------------------\n     * Unused Token Lifetime for Token Auth and HMAC Auth\n     * --------------------------------------------------------------------\n     * Determines the amount of time, in seconds, that an unused token can\n     * be used.\n     */\n    public int $unusedTokenLifetime = YEAR;\n\n    /**\n     * --------------------------------------------------------------------\n     * Secret2 storage character limit\n     * --------------------------------------------------------------------\n     * Database size limit for the identities 'secret2' field.\n     */\n    public int $secret2StorageLimit = 255;\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC secret key byte size\n     * --------------------------------------------------------------------\n     * Specify in integer the desired byte size of the\n     * HMAC SHA256 byte size\n     */\n    public int $hmacSecretKeyByteSize = 32;\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC encryption Keys\n     * --------------------------------------------------------------------\n     * This sets the key to be used when encrypting a user's HMAC Secret Key.\n     *\n     * 'keys' is an array of keys which will facilitate key rotation. Valid\n     *  keyTitles must include only [a-zA-Z0-9_] and should be kept to a\n     *  max of 8 characters.\n     *\n     * Each keyTitle is an associative array containing the required 'key'\n     *  value, and the optional 'driver' and 'digest' values. If the\n     *  'driver' and 'digest' values are not specified, the default 'driver'\n     *  and 'digest' values will be used.\n     *\n     * Old keys will are used to decrypt existing Secret Keys. It is encouraged\n     *  to run 'php spark shield:hmac reencrypt' to update existing Secret\n     *  Key encryptions.\n     *\n     * @see https://codeigniter.com/user_guide/libraries/encryption.html\n     *\n     * @var array<string, array{key: string, driver?: string, digest?: string}>|string\n     *\n     * NOTE: The value becomes temporarily a string when setting value as JSON\n     *       from environment variable.\n     *\n     * [key_name => ['key' => key_value]]\n     * or [key_name => ['key' => key_value, 'driver' => driver, 'digest' => digest]]\n     */\n    public $hmacEncryptionKeys = [\n        'k1' => [\n            'key' => '',\n        ],\n    ];\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC Current Encryption Key Selector\n     * --------------------------------------------------------------------\n     * This specifies which of the encryption keys should be used.\n     */\n    public string $hmacEncryptionCurrentKey = 'k1';\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC Encryption Key Driver\n     * --------------------------------------------------------------------\n     * This specifies which of the encryption drivers should be used.\n     *\n     * Available drivers:\n     *     - OpenSSL\n     *     - Sodium\n     */\n    public string $hmacEncryptionDefaultDriver = 'OpenSSL';\n\n    /**\n     * --------------------------------------------------------------------\n     * HMAC Encryption Key Driver\n     * --------------------------------------------------------------------\n     * THis specifies the type of encryption to be used.\n     *     e.g. 'SHA512' or 'SHA256'.\n     */\n    public string $hmacEncryptionDefaultDigest = 'SHA512';\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace Tests\\Authentication\\Authenticators;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\Authentication;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\AccessTokens;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Config\\AuthToken;\nuse CodeIgniter\\Shield\\Entities\\AccessToken;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Test\\Mock\\MockEvents;\nuse Config\\Services;\nuse Tests\\Support\\DatabaseTestCase;\n\n/**\n * @internal\n */\nfinal class AccessTokenAuthenticatorTest extends DatabaseTestCase\n{\n    private AccessTokens $auth;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $config = new Auth();\n        $auth   = new Authentication($config);\n        $auth->setProvider(model(UserModel::class));\n\n        /** @var AccessTokens $authenticator */\n        $authenticator = $auth->factory('tokens');\n        $this->auth    = $authenticator;\n\n        Services::injectMock('events', new MockEvents());\n    }\n\n    public function testLogin(): void\n    {\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n\n        // Stores the user\n        $this->assertInstanceOf(User::class, $this->auth->getUser());\n        $this->assertSame($user->id, $this->auth->getUser()->id);\n    }\n\n    public function testLogout(): void\n    {\n        // this one's a little odd since it's stateless, but roll with it...\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n        $this->assertNotNull($this->auth->getUser());\n\n        $this->auth->logout();\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginByIdNoToken(): void\n    {\n        $user = fake(UserModel::class);\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertNull($this->auth->getUser()->currentAccessToken());\n    }\n\n    public function testLoginByIdWithToken(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateAccessToken('foo');\n\n        $this->setRequestHeader($token->raw_token);\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentAccessToken());\n        $this->assertSame($token->id, $this->auth->getUser()->currentAccessToken()->id);\n    }\n\n    public function testLoginByIdWithMultipleTokens(): void\n    {\n        /** @var User $user */\n        $user   = fake(UserModel::class);\n        $token1 = $user->generateAccessToken('foo');\n        $user->generateAccessToken('bar');\n\n        $this->setRequestHeader($token1->raw_token);\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentAccessToken());\n        $this->assertSame($token1->id, $this->auth->getUser()->currentAccessToken()->id);\n    }\n\n    public function testCheckNoToken(): void\n    {\n        $result = $this->auth->check([]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\n            lang('Auth.noToken', [config('AuthToken')->authenticatorHeader['tokens']]),\n            $result->reason()\n        );\n    }\n\n    public function testCheckBadToken(): void\n    {\n        $result = $this->auth->check(['token' => 'abc123']);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n    }\n\n    public function testCheckOldToken(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n        /** @var UserIdentityModel $identities */\n        $identities = model(UserIdentityModel::class);\n        $token      = $user->generateAccessToken('foo');\n        // CI 4.2 uses the Chicago timezone that has Daylight Saving Time,\n        // so subtracts 1 hour to make sure this test passes.\n        $token->last_used_at = Time::now()->subYears(1)->subHours(1)->subMinutes(1);\n        $identities->save($token);\n\n        $result = $this->auth->check(['token' => $token->raw_token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.oldToken'), $result->reason());\n    }\n\n    public function testCheckSuccess(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateAccessToken('foo');\n\n        $this->seeInDatabase($this->tables['identities'], [\n            'user_id'      => $user->id,\n            'type'         => 'access_token',\n            'last_used_at' => null,\n        ]);\n\n        $result = $this->auth->check(['token' => $token->raw_token]);\n\n        $this->assertTrue($result->isOK());\n        $this->assertInstanceOf(User::class, $result->extraInfo());\n        $this->assertSame($user->id, $result->extraInfo()->id);\n\n        $updatedToken = $result->extraInfo()->currentAccessToken();\n        $this->assertNotEmpty($updatedToken->last_used_at);\n\n        // Checking token in the same second does not throw \"DataException : There is no data to update.\"\n        $this->auth->check(['token' => $token->raw_token]);\n    }\n\n    public function testAttemptCannotFindUser(): void\n    {\n        $result = $this->auth->attempt([\n            'token' => 'abc123',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n\n        // A failed login attempt should have been recorded by default.\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => AccessTokens::ID_TYPE_ACCESS_TOKEN,\n            'identifier' => 'abc123',\n            'success'    => 0,\n        ]);\n    }\n\n    public function testAttemptSuccess(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateAccessToken('foo');\n        $this->setRequestHeader($token->raw_token);\n\n        $result = $this->auth->attempt([\n            'token' => $token->raw_token,\n        ]);\n\n        $this->assertTrue($result->isOK());\n\n        $foundUser = $result->extraInfo();\n        $this->assertInstanceOf(User::class, $foundUser);\n        $this->assertSame($user->id, $foundUser->id);\n        $this->assertInstanceOf(AccessToken::class, $foundUser->currentAccessToken());\n        $this->assertSame($token->token, $foundUser->currentAccessToken()->token);\n\n        // A successful login attempt is not recorded by default.\n        $this->dontSeeInDatabase($this->tables['token_logins'], [\n            'id_type'    => AccessTokens::ID_TYPE_ACCESS_TOKEN,\n            'identifier' => $token->raw_token,\n            'success'    => 1,\n        ]);\n    }\n\n    public function testAttemptSuccessLog(): void\n    {\n        // Change $recordLoginAttempt in Config.\n        /** @var AuthToken $config */\n        $config                     = config('AuthToken');\n        $config->recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_ALL;\n\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateAccessToken('foo');\n        $this->setRequestHeader($token->raw_token);\n\n        $result = $this->auth->attempt([\n            'token' => $token->raw_token,\n        ]);\n\n        $this->assertTrue($result->isOK());\n\n        $foundUser = $result->extraInfo();\n        $this->assertInstanceOf(User::class, $foundUser);\n        $this->assertSame($user->id, $foundUser->id);\n        $this->assertInstanceOf(AccessToken::class, $foundUser->currentAccessToken());\n        $this->assertSame($token->token, $foundUser->currentAccessToken()->token);\n\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => AccessTokens::ID_TYPE_ACCESS_TOKEN,\n            'identifier' => 'foo',\n            'success'    => 1,\n        ]);\n    }\n\n    protected function setRequestHeader(string $token): void\n    {\n        $request = service('request');\n        $request->setHeader('Authorization', 'Bearer ' . $token);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace Tests\\Authentication\\Authenticators;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\Authentication;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\HmacSha256;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Entities\\AccessToken;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Models\\UserIdentityModel;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Test\\Mock\\MockEvents;\nuse Config\\Services;\nuse Tests\\Support\\DatabaseTestCase;\n\n/**\n * @internal\n */\nfinal class HmacAuthenticatorTest extends DatabaseTestCase\n{\n    private HmacSha256 $auth;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $config = new Auth();\n        $auth   = new Authentication($config);\n        $auth->setProvider(model(UserModel::class));\n\n        config('AuthToken')->recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_ALL;\n\n        /** @var HmacSha256 $authenticator */\n        $authenticator = $auth->factory('hmac');\n        $this->auth    = $authenticator;\n\n        Services::injectMock('events', new MockEvents());\n    }\n\n    public function testLogin(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n\n        // Stores the user\n        $this->assertInstanceOf(User::class, $this->auth->getUser());\n        $this->assertSame($user->id, $this->auth->getUser()->id);\n    }\n\n    public function testLogout(): void\n    {\n        // this one's a little odd since it's stateless, but roll with it...\n        $user = fake(UserModel::class);\n\n        $this->auth->login($user);\n        $this->assertNotNull($this->auth->getUser());\n\n        $this->auth->logout();\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginByIdNoToken(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertNull($this->auth->getUser()->currentHmacToken());\n    }\n\n    public function testLoginByIdBadId(): void\n    {\n        fake(UserModel::class);\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        try {\n            $this->auth->loginById(0);\n        } catch (AuthenticationException $e) {\n            // Failed login\n        }\n\n        $this->assertFalse($this->auth->loggedIn());\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginByIdWithToken(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateHmacToken('foo');\n\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n        $this->setRequestHeader($rawToken);\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentHmacToken());\n        $this->assertSame($token->id, $this->auth->getUser()->currentHmacToken()->id);\n    }\n\n    public function testLoginByIdWithMultipleTokens(): void\n    {\n        /** @var User $user */\n        $user   = fake(UserModel::class);\n        $token1 = $user->generateHmacToken('foo');\n        $user->generateHmacToken('bar');\n\n        $this->setRequestHeader($this->generateRawHeaderToken($token1->secret, $token1->rawSecretKey, 'bar'));\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n        $this->assertInstanceOf(AccessToken::class, $this->auth->getUser()->currentHmacToken());\n        $this->assertSame($token1->id, $this->auth->getUser()->currentHmacToken()->id);\n    }\n\n    public function testCheckNoToken(): void\n    {\n        $result = $this->auth->check([]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\n            lang('Auth.noToken', [config('AuthToken')->authenticatorHeader['hmac']]),\n            $result->reason()\n        );\n    }\n\n    public function testCheckBadSignature(): void\n    {\n        $result = $this->auth->check([\n            'token' => 'abc123:lasdkjflksjdflksjdf',\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n    }\n\n    public function testCheckOldToken(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n        /** @var UserIdentityModel $identities */\n        $identities = model(UserIdentityModel::class);\n        $token      = $user->generateHmacToken('foo');\n        // CI 4.2 uses the Chicago timezone that has Daylight Saving Time,\n        // so subtracts 1 hour to make sure this test passes.\n        $token->last_used_at = Time::now()->subYears(1)->subHours(1)->subMinutes(1);\n        $identities->save($token);\n\n        $result = $this->auth->check([\n            'token' => $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar'),\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.oldToken'), $result->reason());\n    }\n\n    public function testCheckSuccess(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateHmacToken('foo');\n\n        $this->seeInDatabase($this->tables['identities'], [\n            'user_id'      => $user->id,\n            'type'         => 'hmac_sha256',\n            'last_used_at' => null,\n        ]);\n\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n\n        $result = $this->auth->check([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertTrue($result->isOK());\n        $this->assertInstanceOf(User::class, $result->extraInfo());\n        $this->assertSame($user->id, $result->extraInfo()->id);\n\n        $updatedToken = $result->extraInfo()->currentHmacToken();\n        $this->assertNotEmpty($updatedToken->last_used_at);\n\n        // Checking token in the same second does not throw \"DataException : There is no data to update.\"\n        $this->auth->check(['token' => $rawToken, 'body' => 'bar']);\n    }\n\n    public function testCheckBadToken(): void\n    {\n        /** @var User $user */\n        $user  = fake(UserModel::class);\n        $token = $user->generateHmacToken('foo');\n\n        $this->seeInDatabase($this->tables['identities'], [\n            'user_id'      => $user->id,\n            'type'         => 'hmac_sha256',\n            'last_used_at' => null,\n        ]);\n\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'foobar');\n\n        $result = $this->auth->check([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n    }\n\n    public function testAttemptCannotFindUser(): void\n    {\n        $result = $this->auth->attempt([\n            'token' => 'abc123:lsakdjfljsdflkajsfd',\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.badToken'), $result->reason());\n\n        // A login attempt should have always been recorded\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => HmacSha256::ID_TYPE_HMAC_TOKEN,\n            'identifier' => 'abc123:lsakdjfljsdflkajsfd',\n            'success'    => 0,\n        ]);\n    }\n\n    public function testAttemptSuccess(): void\n    {\n        /** @var User $user */\n        $user     = fake(UserModel::class);\n        $token    = $user->generateHmacToken('foo');\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n        $this->setRequestHeader($rawToken);\n\n        $result = $this->auth->attempt([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertTrue($result->isOK());\n\n        $foundUser = $result->extraInfo();\n        $this->assertInstanceOf(User::class, $foundUser);\n        $this->assertSame($user->id, $foundUser->id);\n        $this->assertInstanceOf(AccessToken::class, $foundUser->currentHmacToken());\n        $this->assertSame($token->token, $foundUser->currentHmacToken()->token);\n\n        // A login attempt should have been recorded\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => HmacSha256::ID_TYPE_HMAC_TOKEN,\n            'identifier' => 'foo',\n            'success'    => 1,\n        ]);\n\n        // Check get key Method\n        $key = $this->auth->getHmacKeyFromToken();\n        $this->assertSame($token->secret, $key);\n\n        // Check get hash method\n        [, $hash]  = explode(':', $rawToken);\n        $secretKey = $this->auth->getHmacHashFromToken();\n        $this->assertSame($hash, $secretKey);\n    }\n\n    public function testAttemptBanned(): void\n    {\n        /** @var User $user */\n        $user = fake(UserModel::class);\n        $user->ban('Test ban.');\n\n        $token    = $user->generateHmacToken('foo');\n        $rawToken = $this->generateRawHeaderToken($token->secret, $token->rawSecretKey, 'bar');\n        $this->setRequestHeader($rawToken);\n\n        $result = $this->auth->attempt([\n            'token' => $rawToken,\n            'body'  => 'bar',\n        ]);\n\n        $this->assertFalse($result->isOK());\n\n        $foundUser = $result->extraInfo();\n        $this->assertNull($foundUser);\n\n        // A login attempt should have been recorded\n        $this->seeInDatabase($this->tables['token_logins'], [\n            'id_type'    => HmacSha256::ID_TYPE_HMAC_TOKEN,\n            'identifier' => 'foo',\n            'success'    => 0,\n        ]);\n    }\n\n    protected function setRequestHeader(string $token): void\n    {\n        $request = service('request');\n        $request->setHeader('Authorization', 'HMAC-SHA256 ' . $token);\n    }\n\n    protected function generateRawHeaderToken(string $secret, string $secretKey, string $body): string\n    {\n        return $secret . ':' . hash_hmac('sha256', $body, $secretKey);\n    }\n}\n", "<?php\n\ndeclare(strict_types=1);\n\n/**\n * This file is part of CodeIgniter Shield.\n *\n * (c) CodeIgniter Foundation <admin@codeigniter.com>\n *\n * For the full copyright and license information, please view\n * the LICENSE file that was distributed with this source code.\n */\n\nnamespace Tests\\Authentication\\Authenticators;\n\nuse CodeIgniter\\I18n\\Time;\nuse CodeIgniter\\Shield\\Authentication\\Authentication;\nuse CodeIgniter\\Shield\\Authentication\\AuthenticationException;\nuse CodeIgniter\\Shield\\Authentication\\Authenticators\\JWT;\nuse CodeIgniter\\Shield\\Authentication\\JWTManager;\nuse CodeIgniter\\Shield\\Config\\Auth;\nuse CodeIgniter\\Shield\\Config\\AuthJWT;\nuse CodeIgniter\\Shield\\Entities\\User;\nuse CodeIgniter\\Shield\\Models\\UserModel;\nuse CodeIgniter\\Shield\\Result;\nuse CodeIgniter\\Test\\Mock\\MockEvents;\nuse Config\\Services;\nuse Firebase\\JWT\\JWT as FirebaseJWT;\nuse InvalidArgumentException;\nuse Tests\\Support\\DatabaseTestCase;\n\n/**\n * @internal\n */\nfinal class JWTAuthenticatorTest extends DatabaseTestCase\n{\n    private const BAD_JWT = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJJc3N1ZXIgb2YgdGhlIEpXVCIsImF1ZCI6IkF1ZGllbmNlIG9mIHRoZSBKV1QiLCJzdWIiOiIxIiwiaWF0IjoxNjUzOTkxOTg5LCJleHAiOjE2NTM5OTU1ODl9.hgOYHEcT6RGHb3po1lspTcmjrylY1Cy1IvYmHOyx0CY';\n\n    private JWT $auth;\n    private User $user;\n\n    protected function setUp(): void\n    {\n        parent::setUp();\n\n        $config                        = new Auth();\n        $config->authenticators['jwt'] = JWT::class;\n\n        $auth = new Authentication($config);\n        $auth->setProvider(\\model(UserModel::class));\n\n        /** @var JWT $authenticator */\n        $authenticator = $auth->factory('jwt');\n        $this->auth    = $authenticator;\n\n        Services::injectMock('events', new MockEvents());\n    }\n\n    private function createUser(): User\n    {\n        return \\fake(UserModel::class);\n    }\n\n    public function testLogin(): void\n    {\n        $user = $this->createUser();\n\n        $this->auth->login($user);\n\n        // Stores the user\n        $this->assertInstanceOf(User::class, $this->auth->getUser());\n        $this->assertSame($user->id, $this->auth->getUser()->id);\n    }\n\n    public function testLogout(): void\n    {\n        // this one's a little odd since it's stateless, but roll with it...\n\n        $user = $this->createUser();\n\n        $this->auth->login($user);\n        $this->assertNotNull($this->auth->getUser());\n\n        $this->auth->logout();\n        $this->assertNull($this->auth->getUser());\n    }\n\n    public function testLoginById(): void\n    {\n        $user = $this->createUser();\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById($user->id);\n\n        $this->assertTrue($this->auth->loggedIn());\n    }\n\n    public function testLoginByIdNoUser(): void\n    {\n        $this->expectException(AuthenticationException::class);\n        $this->expectExceptionMessage('Unable to locate the specified user.');\n\n        $this->createUser();\n\n        $this->assertFalse($this->auth->loggedIn());\n\n        $this->auth->loginById(9999);\n    }\n\n    public function testCheckNoToken(): void\n    {\n        $result = $this->auth->check([]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\n            \\lang('Auth.noToken', [config('AuthJWT')->authenticatorHeader]),\n            $result->reason()\n        );\n    }\n\n    public function testCheckBadSignatureToken(): void\n    {\n        $result = $this->auth->check(['token' => self::BAD_JWT]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.invalidJWT'), $result->reason());\n    }\n\n    public function testCheckNoSubToken(): void\n    {\n        /** @var AuthJWT $config */\n        $config  = config('AuthJWT');\n        $payload = [\n            'iss' => $config->defaultClaims['iss'], // issuer\n        ];\n        $token = FirebaseJWT::encode($payload, $config->keys['default'][0]['secret'], $config->keys['default'][0]['alg']);\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame('Invalid JWT: no user_id', $result->reason());\n    }\n\n    public function testCheckOldToken(): void\n    {\n        Time::setTestNow('-1 hour');\n        $token = $this->generateJWT();\n        Time::setTestNow();\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.expiredJWT'), $result->reason());\n    }\n\n    public function testCheckNoUserInDatabase(): void\n    {\n        $token = $this->generateJWT();\n\n        $users = \\model(UserModel::class);\n        $users->delete(1);\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertFalse($result->isOK());\n        $this->assertSame(\\lang('Auth.invalidUser'), $result->reason());\n    }\n\n    public function testCheckSuccess(): void\n    {\n        $token = $this->generateJWT();\n\n        $result = $this->auth->check(['token' => $token]);\n\n        $this->assertTrue($result->isOK());\n        $this->assertInstanceOf(User::class, $result->extraInfo());\n        $this->assertSame(1, $result->extraInfo()->id);\n    }\n\n    public function testGetPayload(): void\n    {\n        $token = $this->generateJWT();\n\n        $this->auth->check(['token' => $token]);\n        $payload = $this->auth->getPayload();\n\n        $this->assertSame((string) $this->user->id, $payload->sub);\n        /** @var AuthJWT $config */\n        $config = config('AuthJWT');\n        $this->assertSame($config->defaultClaims['iss'], $payload->iss);\n    }\n\n    public function testAttemptBadSignatureToken(): void\n    {\n        $result = $this->auth->attempt([\n            'token' => self::BAD_JWT,\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.invalidJWT'), $result->reason());\n\n        // A login attempt should have always been recorded\n        $this->seeInDatabase('auth_token_logins', [\n            'id_type'    => JWT::ID_TYPE_JWT,\n            'identifier' => self::BAD_JWT,\n            'success'    => 0,\n        ]);\n    }\n\n    public function testAttemptBannedUser(): void\n    {\n        $token = $this->generateJWT();\n\n        $this->user->ban();\n\n        $result = $this->auth->attempt([\n            'token' => $token,\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertFalse($result->isOK());\n        $this->assertSame(lang('Auth.bannedUser'), $result->reason());\n\n        // The login attempt should have been recorded\n        $this->seeInDatabase('auth_token_logins', [\n            'id_type'    => JWT::ID_TYPE_JWT,\n            'identifier' => 'sha256:' . hash('sha256', $token),\n            'success'    => 0,\n            'user_id'    => $this->user->id,\n        ]);\n    }\n\n    public function testAttemptSuccess(): void\n    {\n        // Change $recordLoginAttempt in Config.\n        /** @var AuthJWT $config */\n        $config                     = config('AuthJWT');\n        $config->recordLoginAttempt = Auth::RECORD_LOGIN_ATTEMPT_ALL;\n\n        $token = $this->generateJWT();\n\n        $result = $this->auth->attempt([\n            'token' => $token,\n        ]);\n\n        $this->assertInstanceOf(Result::class, $result);\n        $this->assertTrue($result->isOK());\n\n        $foundUser = $result->extraInfo();\n\n        $this->assertInstanceOf(User::class, $foundUser);\n        $this->assertSame(1, $foundUser->id);\n\n        // A login attempt should have been recorded\n        $this->seeInDatabase('auth_token_logins', [\n            'id_type'    => JWT::ID_TYPE_JWT,\n            'identifier' => 'sha256:' . hash('sha256', $token),\n            'success'    => 1,\n        ]);\n    }\n\n    public function testRecordActiveDateNoUser(): void\n    {\n        $this->expectException(InvalidArgumentException::class);\n        $this->expectExceptionMessage(\n            'Authentication\\Authenticators\\JWT::recordActiveDate() requires logged in user before calling.'\n        );\n\n        $this->auth->recordActiveDate();\n    }\n\n    /**\n     * @param Time|null $clock The Time object\n     */\n    private function generateJWT(?Time $clock = null): string\n    {\n        $this->user = \\fake(UserModel::class, ['id' => 1, 'username' => 'John Smith']);\n\n        $generator = new JWTManager($clock);\n\n        return $generator->generateToken($this->user);\n    }\n}\n"], "filenames": ["docs/addons/jwt.md", "docs/getting_started/configuration.md", "docs/references/authentication/hmac.md", "docs/references/authentication/tokens.md", "phpstan-baseline.php", "src/Authentication/Authenticators/AccessTokens.php", "src/Authentication/Authenticators/HmacSha256.php", "src/Authentication/Authenticators/JWT.php", "src/Config/AuthToken.php", "tests/Authentication/Authenticators/AccessTokenAuthenticatorTest.php", "tests/Authentication/Authenticators/HmacAuthenticatorTest.php", "tests/Authentication/Authenticators/JWTAuthenticatorTest.php"], "buggy_code_start_loc": [37, 11, 113, 86, 366, 80, 81, 106, 49, 19, 276, 229], "buggy_code_end_loc": [353, 28, 221, 127, 371, 114, 115, 129, 50, 224, 314, 260], "fixing_code_start_loc": [37, 11, 112, 85, 365, 80, 81, 106, 49, 20, 276, 229], "fixing_code_end_loc": [378, 15, 255, 165, 365, 113, 114, 129, 50, 254, 314, 260], "type": "CWE-532", "message": "CodeIgniter Shield is an authentication and authorization provider for CodeIgniter 4. In affected versions successful login attempts are recorded with the raw tokens stored in the log table. If a malicious person somehow views the data in the log table they can obtain a raw token which can then be used to send a request with that user's authority. This issue has been addressed in version 1.0.0-beta.8. Users are advised to upgrade. Users unable to upgrade should disable logging for successful login attempts by the configuration files.", "other": {"cve": {"id": "CVE-2023-48708", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-24T18:15:07.520", "lastModified": "2023-11-30T20:11:33.040", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CodeIgniter Shield is an authentication and authorization provider for CodeIgniter 4. In affected versions successful login attempts are recorded with the raw tokens stored in the log table. If a malicious person somehow views the data in the log table they can obtain a raw token which can then be used to send a request with that user's authority. This issue has been addressed in version 1.0.0-beta.8. Users are advised to upgrade. Users unable to upgrade should disable logging for successful login attempts by the configuration files."}, {"lang": "es", "value": "CodeIgniter Shield es un proveedor de autenticaci\u00f3n y autorizaci\u00f3n para CodeIgniter 4. En las versiones afectadas, los intentos de inicio de sesi\u00f3n exitosos se registran con los tokens sin procesar almacenados en la tabla de registro. Si una persona malintencionada de alguna manera ve los datos en la tabla de registro, puede obtener un token sin procesar que luego puede usarse para enviar una solicitud con la autoridad de ese usuario. Este problema se solucion\u00f3 en la versi\u00f3n 1.0.0-beta.8. Se recomienda a los usuarios que actualicen. Los usuarios que no puedan actualizar deben desactivar el registro para intentar iniciar sesi\u00f3n exitosamente mediante los archivos de configuraci\u00f3n."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:H/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.7, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-532"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:shield:1.0.0:beta:*:*:*:*:*:*", "matchCriteriaId": "B1E3F1E0-C2D7-4EC5-AD04-AEB414A3D71C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:shield:1.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8DDA8B62-EE63-40C0-9F2C-23F56B225F49"}, {"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:shield:1.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "4F37B4E1-D641-4D55-9D3F-FB3B18934FE9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:shield:1.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "3361F9CD-A084-4437-BF22-08A558C326B5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:shield:1.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "AEF20FB8-F114-4B54-8CEF-739433359E21"}, {"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:shield:1.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "340EBC7C-51FC-4792-A0A4-A323219D1551"}, {"vulnerable": true, "criteria": "cpe:2.3:a:codeigniter:shield:1.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "061CA3F7-EDAD-4D04-AFBC-9ABD22470AF1"}]}]}], "references": [{"url": "https://codeigniter4.github.io/shield/getting_started/authenticators/", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/codeigniter4/shield/commit/7e84c3fb3411294f70890819bfe51781bb9dc8e4", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/codeigniter4/shield/security/advisories/GHSA-j72f-h752-mx4w", "source": "security-advisories@github.com", "tags": ["Mitigation", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/codeigniter4/shield/commit/7e84c3fb3411294f70890819bfe51781bb9dc8e4"}}