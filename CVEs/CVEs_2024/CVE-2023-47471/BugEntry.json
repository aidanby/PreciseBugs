{"buggy_code": ["/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * Authors: struktur AG, Dirk Farin <farin@struktur.de>\n *          Min Chen <chenm003@163.com>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"slice.h\"\n#include \"motion.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"intrapred.h\"\n#include \"transform.h\"\n#include \"threads.h\"\n#include \"image.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\n\n#define LOCK de265_mutex_lock(&ctx->thread_pool.mutex)\n#define UNLOCK de265_mutex_unlock(&ctx->thread_pool.mutex)\n\nextern bool read_short_term_ref_pic_set(error_queue* errqueue,\n                                        const seq_parameter_set* sps,\n                                        bitreader* br,\n                                        ref_pic_set* out_set,\n                                        int idxRps,  // index of the set to be read\n                                        const std::vector<ref_pic_set>& sets,\n                                        bool sliceRefPicSet);\n\n\nvoid read_coding_tree_unit(thread_context* tctx);\nvoid read_coding_quadtree(thread_context* tctx,\n                          int xCtb, int yCtb,\n                          int Log2CtbSizeY,\n                          int ctDepth);\n/*\nvoid decode_inter_block(decoder_context* ctx,thread_context* tctx,\n                        int xC, int yC, int log2CbSize);\n*/\n\nvoid slice_segment_header::set_defaults()\n{\n  slice_index = 0;\n\n  first_slice_segment_in_pic_flag = 1;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n\n  slice_type = SLICE_TYPE_I;\n  pic_output_flag = 1;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 1;\n  // ref_pic_set slice_ref_pic_set;\n\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics = 0;\n\n  //uint8_t lt_idx_sps[MAX_NUM_REF_PICS];\n  //int     poc_lsb_lt[MAX_NUM_REF_PICS];\n  //char    used_by_curr_pic_lt_flag[MAX_NUM_REF_PICS];\n\n  //char delta_poc_msb_present_flag[MAX_NUM_REF_PICS];\n  //int delta_poc_msb_cycle_lt[MAX_NUM_REF_PICS];\n\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active=1; // [1;16]\n  num_ref_idx_l1_active=1; // [1;16]\n\n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  //uint8_t list_entry_l0[16];\n  //uint8_t list_entry_l1[16];\n\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n\n  // --- pred_weight_table ---\n\n  luma_log2_weight_denom=0; // [0;7]\n  ChromaLog2WeightDenom=0;  // [0;7]\n\n  // first index is L0/L1\n  /*\n  uint8_t luma_weight_flag[2][16];   // bool\n  uint8_t chroma_weight_flag[2][16]; // bool\n  int16_t LumaWeight[2][16];\n  int8_t  luma_offset[2][16];\n  int16_t ChromaWeight[2][16][2];\n  int8_t  ChromaOffset[2][16][2];\n  */\n\n\n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n\n  cu_chroma_qp_offset_enabled_flag = 0;\n\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset=0; // = pps->beta_offset if undefined\n  slice_tc_offset=0;   // = pps->tc_offset if undefined\n\n  slice_loop_filter_across_slices_enabled_flag = 0;\n\n  num_entry_point_offsets = 0;\n  //int  offset_len;\n  //std::vector<int> entry_point_offset;\n\n  slice_segment_header_extension_length = 0;\n\n  SliceAddrRS = slice_segment_address;\n}\n\n\nbool read_pred_weight_table(bitreader* br, slice_segment_header* shdr, decoder_context* ctx)\n{\n  int vlc;\n\n  pic_parameter_set* pps = ctx->get_pps((int)shdr->slice_pic_parameter_set_id);\n  assert(pps);\n  seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  assert(sps);\n\n  shdr->luma_log2_weight_denom = vlc = get_uvlc(br);\n  if (vlc<0 || vlc>7) return false;\n\n  if (sps->chroma_format_idc != 0) {\n    vlc = get_svlc(br);\n    vlc += shdr->luma_log2_weight_denom;\n    if (vlc<0 || vlc>7) return false;\n    shdr->ChromaLog2WeightDenom = vlc;\n  }\n\n  int sumWeightFlags = 0;\n\n  for (int l=0;l<=1;l++)\n    if (l==0 || (l==1 && shdr->slice_type == SLICE_TYPE_B))\n      {\n        int num_ref = (l==0 ? shdr->num_ref_idx_l0_active-1 : shdr->num_ref_idx_l1_active-1);\n\n        for (int i=0;i<=num_ref;i++) {\n          shdr->luma_weight_flag[l][i] = get_bits(br,1);\n          if (shdr->luma_weight_flag[l][i]) sumWeightFlags++;\n        }\n\n        if (sps->chroma_format_idc != 0) {\n          for (int i=0;i<=num_ref;i++) {\n            shdr->chroma_weight_flag[l][i] = get_bits(br,1);\n            if (shdr->chroma_weight_flag[l][i]) sumWeightFlags+=2;\n          }\n        }\n\n        for (int i=0;i<=num_ref;i++) {\n          if (shdr->luma_weight_flag[l][i]) {\n\n            // delta_luma_weight\n\n            vlc = get_svlc(br);\n            if (vlc < -128 || vlc > 127) return false;\n\n            shdr->LumaWeight[l][i] = (1<<shdr->luma_log2_weight_denom) + vlc;\n\n            // luma_offset\n\n            vlc = get_svlc(br);\n            if (vlc < -sps->WpOffsetHalfRangeY || vlc > sps->WpOffsetHalfRangeY-1) return false;\n            shdr->luma_offset[l][i] = vlc;\n          }\n          else {\n            shdr->LumaWeight[l][i] = 1<<shdr->luma_log2_weight_denom;\n            shdr->luma_offset[l][i] = 0;\n          }\n\n          if (shdr->chroma_weight_flag[l][i])\n            for (int j=0;j<2;j++) {\n              // delta_chroma_weight\n\n              vlc = get_svlc(br);\n              if (vlc < -128 || vlc >  127) return false;\n\n              shdr->ChromaWeight[l][i][j] = (1<<shdr->ChromaLog2WeightDenom) + vlc;\n\n              // delta_chroma_offset\n\n              vlc = get_svlc(br);\n              if (vlc < -4*sps->WpOffsetHalfRangeC ||\n                  vlc >  4*sps->WpOffsetHalfRangeC-1) return false;\n\n              vlc = Clip3(-sps->WpOffsetHalfRangeC,\n                          sps->WpOffsetHalfRangeC-1,\n                          (sps->WpOffsetHalfRangeC\n                           +vlc\n                           -((sps->WpOffsetHalfRangeC*shdr->ChromaWeight[l][i][j])\n                             >> shdr->ChromaLog2WeightDenom)));\n\n              shdr->ChromaOffset[l][i][j] = vlc;\n            }\n          else {\n            for (int j=0;j<2;j++) {\n              shdr->ChromaWeight[l][i][j] = 1<<shdr->ChromaLog2WeightDenom;\n              shdr->ChromaOffset[l][i][j] = 0;\n            }\n          }\n        }\n      }\n\n  // TODO: bitstream conformance requires that 'sumWeightFlags<=24'\n\n  return true;\n}\n\n\nvoid slice_segment_header::reset()\n{\n  pps = NULL;\n\n  slice_index = 0;\n\n  first_slice_segment_in_pic_flag = 0;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n\n  slice_type = 0;\n  pic_output_flag = 0;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 0;\n  slice_ref_pic_set.reset();\n\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics= 0;\n\n  for (int i=0;i<MAX_NUM_REF_PICS;i++) {\n    lt_idx_sps[i] = 0;\n    poc_lsb_lt[i] = 0;\n    used_by_curr_pic_lt_flag[i] = 0;\n    delta_poc_msb_present_flag[i] = 0;\n    delta_poc_msb_cycle_lt[i] = 0;\n  }\n\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active = 0;\n  num_ref_idx_l1_active = 0;\n\n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  for (int i=0;i<16;i++) {\n    list_entry_l0[i] = 0;\n    list_entry_l1[i] = 0;\n  }\n\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag  = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n\n  luma_log2_weight_denom = 0;\n  ChromaLog2WeightDenom  = 0;\n\n  for (int i=0;i<2;i++)\n    for (int j=0;j<16;j++) {\n      luma_weight_flag[i][j] = 0;\n      chroma_weight_flag[i][j] = 0;\n      LumaWeight[i][j] = 0;\n      luma_offset[i][j] = 0;\n      ChromaWeight[i][j][0] = ChromaWeight[i][j][1] = 0;\n      ChromaOffset[i][j][0] = ChromaOffset[i][j][1] = 0;\n    }\n\n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n\n  cu_chroma_qp_offset_enabled_flag = 0;\n\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset = 0;\n  slice_tc_offset = 0;\n\n  slice_loop_filter_across_slices_enabled_flag = 0;\n\n  num_entry_point_offsets = 0;\n  offset_len = 0;\n  entry_point_offset.clear();\n\n  slice_segment_header_extension_length = 0;\n\n  SliceAddrRS = 0;\n  SliceQPY = 0;\n\n  initType = 0;\n\n  MaxNumMergeCand = 0;\n  CurrRpsIdx = 0;\n  CurrRps.reset();\n  NumPocTotalCurr = 0;\n\n  for (int i=0;i<2;i++)\n    for (int j=0;j<MAX_NUM_REF_PICS;j++) {\n      RefPicList[i][j] = 0;\n      RefPicList_POC[i][j] = 0;\n      RefPicList_PicState[i][j] = 0;\n      LongTermRefPic[i][j] = 0;\n    }\n\n  //context_model ctx_model_storage[CONTEXT_MODEL_TABLE_LENGTH];\n\n  RemoveReferencesList.clear();\n\n  ctx_model_storage_defined = false;\n}\n\n\nde265_error slice_segment_header::read(bitreader* br, decoder_context* ctx,\n                                       bool* continueDecoding)\n{\n  *continueDecoding = false;\n  reset();\n\n  // set defaults\n\n  dependent_slice_segment_flag = 0;\n\n\n  // read bitstream\n\n  first_slice_segment_in_pic_flag = get_bits(br,1);\n\n  if (ctx->get_RapPicFlag()) { // TODO: is this still correct ? Should we drop RapPicFlag ?\n    no_output_of_prior_pics_flag = get_bits(br,1);\n  }\n\n  slice_pic_parameter_set_id = get_uvlc(br);\n  if (slice_pic_parameter_set_id >= DE265_MAX_PPS_SETS ||\n      slice_pic_parameter_set_id == UVLC_ERROR) {\n    ctx->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return DE265_OK;\n  }\n\n  if (!ctx->has_pps(slice_pic_parameter_set_id)) {\n    ctx->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return DE265_OK;\n  }\n\n  pps = ctx->get_shared_pps(slice_pic_parameter_set_id);\n\n  const seq_parameter_set* sps = pps->sps.get();\n  if (!sps->sps_read) {\n    ctx->add_warning(DE265_WARNING_NONEXISTING_SPS_REFERENCED, false);\n    *continueDecoding = false;\n    return DE265_OK;\n  }\n\n  if (!first_slice_segment_in_pic_flag) {\n    if (pps->dependent_slice_segments_enabled_flag) {\n      dependent_slice_segment_flag = get_bits(br,1);\n    } else {\n      dependent_slice_segment_flag = 0;\n    }\n\n    int slice_segment_address = get_bits(br, ceil_log2(sps->PicSizeInCtbsY));\n\n    if (dependent_slice_segment_flag) {\n      if (slice_segment_address == 0) {\n        *continueDecoding = false;\n        ctx->add_warning(DE265_WARNING_DEPENDENT_SLICE_WITH_ADDRESS_ZERO, false);\n        return DE265_OK;\n      }\n\n      if (ctx->previous_slice_header == NULL) {\n        return DE265_ERROR_NO_INITIAL_SLICE_HEADER;\n      }\n\n      *this = *ctx->previous_slice_header;\n\n      first_slice_segment_in_pic_flag = 0;\n      dependent_slice_segment_flag = 1;\n    }\n\n    this->slice_segment_address = slice_segment_address;\n  } else {\n    dependent_slice_segment_flag = 0;\n    slice_segment_address = 0;\n  }\n\n  if (slice_segment_address < 0 ||\n      slice_segment_address >= sps->PicSizeInCtbsY) {\n    ctx->add_warning(DE265_WARNING_SLICE_SEGMENT_ADDRESS_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  //printf(\"SLICE %d (%d)\\n\",slice_segment_address, sps->PicSizeInCtbsY);\n\n\n  if (!dependent_slice_segment_flag) {\n    for (int i=0; i<pps->num_extra_slice_header_bits; i++) {\n      //slice_reserved_undetermined_flag[i]\n      skip_bits(br,1);\n    }\n\n    slice_type = get_uvlc(br);\n    if (slice_type > 2 ||\n\tslice_type == UVLC_ERROR) {\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      *continueDecoding = false;\n      return DE265_OK;\n    }\n\n    if (pps->output_flag_present_flag) {\n      pic_output_flag = get_bits(br,1);\n    }\n    else {\n      pic_output_flag = 1;\n    }\n\n    if (sps->separate_colour_plane_flag == 1) {\n      colour_plane_id = get_bits(br,2);\n    }\n\n\n    slice_pic_order_cnt_lsb = 0;\n    short_term_ref_pic_set_sps_flag = 0;\n\n    int NumLtPics = 0;\n\n    if (ctx->get_nal_unit_type() != NAL_UNIT_IDR_W_RADL &&\n        ctx->get_nal_unit_type() != NAL_UNIT_IDR_N_LP) {\n      slice_pic_order_cnt_lsb = get_bits(br, sps->log2_max_pic_order_cnt_lsb);\n      short_term_ref_pic_set_sps_flag = get_bits(br,1);\n\n      if (!short_term_ref_pic_set_sps_flag) {\n        read_short_term_ref_pic_set(ctx, sps,\n                                    br, &slice_ref_pic_set,\n                                    sps->num_short_term_ref_pic_sets(),\n                                    sps->ref_pic_sets,\n                                    true);\n\n        CurrRpsIdx = sps->num_short_term_ref_pic_sets();\n        CurrRps    = slice_ref_pic_set;\n      }\n      else {\n        int nBits = ceil_log2(sps->num_short_term_ref_pic_sets());\n        if (nBits>0) short_term_ref_pic_set_idx = get_bits(br,nBits);\n        else         short_term_ref_pic_set_idx = 0;\n\n        if (short_term_ref_pic_set_idx >= sps->num_short_term_ref_pic_sets()) {\n          ctx->add_warning(DE265_WARNING_SHORT_TERM_REF_PIC_SET_OUT_OF_RANGE, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        CurrRpsIdx = short_term_ref_pic_set_idx;\n        CurrRps    = sps->ref_pic_sets[CurrRpsIdx];\n      }\n\n\n      // --- long-term MC ---\n\n      if (sps->long_term_ref_pics_present_flag) {\n        if (sps->num_long_term_ref_pics_sps > 0) {\n          num_long_term_sps = get_uvlc(br);\n          if (num_long_term_sps == UVLC_ERROR) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n        }\n        else {\n          num_long_term_sps = 0;\n        }\n\n        num_long_term_pics= get_uvlc(br);\n        if (num_long_term_pics == UVLC_ERROR) {\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        // check maximum number of reference frames\n\n        if (num_long_term_sps +\n            num_long_term_pics +\n            CurrRps.NumNegativePics +\n            CurrRps.NumPositivePics\n            > sps->sps_max_dec_pic_buffering[sps->sps_max_sub_layers-1])\n          {\n            ctx->add_warning(DE265_WARNING_MAX_NUM_REF_PICS_EXCEEDED, false);\n            *continueDecoding = false;\n            return DE265_OK;\n          }\n\n        for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {\n          if (i < num_long_term_sps) {\n            int nBits = ceil_log2(sps->num_long_term_ref_pics_sps);\n            lt_idx_sps[i] = get_bits(br, nBits);\n\n            // check that the referenced lt-reference really exists\n\n            if (lt_idx_sps[i] >= sps->num_long_term_ref_pics_sps) {\n              ctx->add_warning(DE265_NON_EXISTING_LT_REFERENCE_CANDIDATE_IN_SLICE_HEADER, false);\n              *continueDecoding = false;\n              return DE265_OK;\n            }\n\n            // delta_poc_msb_present_flag[i] = 0; // TODO ?\n\n            ctx->PocLsbLt[i] = sps->lt_ref_pic_poc_lsb_sps[ lt_idx_sps[i] ];\n            ctx->UsedByCurrPicLt[i] = sps->used_by_curr_pic_lt_sps_flag[ lt_idx_sps[i] ];\n          }\n          else {\n            int nBits = sps->log2_max_pic_order_cnt_lsb;\n            poc_lsb_lt[i] = get_bits(br, nBits);\n            used_by_curr_pic_lt_flag[i] = get_bits(br,1);\n\n            ctx->PocLsbLt[i] = poc_lsb_lt[i];\n            ctx->UsedByCurrPicLt[i] = used_by_curr_pic_lt_flag[i];\n          }\n\n          if (ctx->UsedByCurrPicLt[i]) {\n            NumLtPics++;\n          }\n\n          delta_poc_msb_present_flag[i] = get_bits(br,1);\n          if (delta_poc_msb_present_flag[i]) {\n            delta_poc_msb_cycle_lt[i] = get_uvlc(br);\n            if (delta_poc_msb_cycle_lt[i]==UVLC_ERROR) {\n              return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n            }\n          }\n          else {\n            delta_poc_msb_cycle_lt[i] = 0;\n          }\n\n          if (i==0 || i==num_long_term_sps) {\n            ctx->DeltaPocMsbCycleLt[i] = delta_poc_msb_cycle_lt[i];\n          }\n          else {\n            ctx->DeltaPocMsbCycleLt[i] = (delta_poc_msb_cycle_lt[i] +\n                                          ctx->DeltaPocMsbCycleLt[i-1]);\n          }\n        }\n      }\n      else {\n        num_long_term_sps = 0;\n        num_long_term_pics= 0;\n      }\n\n      if (sps->sps_temporal_mvp_enabled_flag) {\n        slice_temporal_mvp_enabled_flag = get_bits(br,1);\n      }\n      else {\n        slice_temporal_mvp_enabled_flag = 0;\n      }\n    }\n    else {\n      slice_pic_order_cnt_lsb = 0;\n      num_long_term_sps = 0;\n      num_long_term_pics= 0;\n    }\n\n\n    // --- SAO ---\n\n    if (sps->sample_adaptive_offset_enabled_flag) {\n      slice_sao_luma_flag   = get_bits(br,1);\n\n      if (sps->ChromaArrayType != CHROMA_MONO) {\n        slice_sao_chroma_flag = get_bits(br,1);\n      }\n      else {\n        slice_sao_chroma_flag = 0;\n      }\n    }\n    else {\n      slice_sao_luma_flag   = 0;\n      slice_sao_chroma_flag = 0;\n    }\n\n    num_ref_idx_l0_active = 0;\n    num_ref_idx_l1_active = 0;\n\n    if (slice_type == SLICE_TYPE_P  ||\n        slice_type == SLICE_TYPE_B) {\n      num_ref_idx_active_override_flag = get_bits(br,1);\n      if (num_ref_idx_active_override_flag) {\n        num_ref_idx_l0_active = get_uvlc(br);\n        if (num_ref_idx_l0_active == UVLC_ERROR) {\n\t  ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t}\n        num_ref_idx_l0_active++;;\n\n        if (slice_type == SLICE_TYPE_B) {\n          num_ref_idx_l1_active = get_uvlc(br);\n          if (num_ref_idx_l1_active == UVLC_ERROR) {\n\t    ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t  }\n          num_ref_idx_l1_active++;\n        }\n      }\n      else {\n        num_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n        num_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n      }\n\n      if (num_ref_idx_l0_active > 16) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n      if (num_ref_idx_l1_active > 16) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n\n      NumPocTotalCurr = CurrRps.NumPocTotalCurr_shortterm_only + NumLtPics;\n\n      if (pps->lists_modification_present_flag && NumPocTotalCurr > 1) {\n\n        int nBits = ceil_log2(NumPocTotalCurr);\n\n        ref_pic_list_modification_flag_l0 = get_bits(br,1);\n        if (ref_pic_list_modification_flag_l0) {\n          for (int i=0;i<num_ref_idx_l0_active;i++) {\n            list_entry_l0[i] = get_bits(br, nBits);\n          }\n        }\n\n        if (slice_type == SLICE_TYPE_B) {\n          ref_pic_list_modification_flag_l1 = get_bits(br,1);\n          if (ref_pic_list_modification_flag_l1) {\n            for (int i=0;i<num_ref_idx_l1_active;i++) {\n              list_entry_l1[i] = get_bits(br, nBits);\n            }\n          }\n        }\n        else {\n          ref_pic_list_modification_flag_l1 = 0;\n        }\n      }\n      else {\n        ref_pic_list_modification_flag_l0 = 0;\n        ref_pic_list_modification_flag_l1 = 0;\n      }\n\n      if (slice_type == SLICE_TYPE_B) {\n        mvd_l1_zero_flag = get_bits(br,1);\n      }\n\n      if (pps->cabac_init_present_flag) {\n        cabac_init_flag = get_bits(br,1);\n      }\n      else {\n        cabac_init_flag = 0;\n      }\n\n      if (slice_temporal_mvp_enabled_flag) {\n        if (slice_type == SLICE_TYPE_B)\n          collocated_from_l0_flag = get_bits(br,1);\n        else\n          collocated_from_l0_flag = 1;\n\n        if (( collocated_from_l0_flag && num_ref_idx_l0_active > 1) ||\n            (!collocated_from_l0_flag && num_ref_idx_l1_active > 1)) {\n          collocated_ref_idx = get_uvlc(br);\n          if (collocated_ref_idx == UVLC_ERROR) {\n\t    ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t  }\n        }\n        else {\n          collocated_ref_idx = 0;\n        }\n\n        // check whether collocated_ref_idx points to a valid index\n\n        if (( collocated_from_l0_flag && collocated_ref_idx >= num_ref_idx_l0_active) ||\n            (!collocated_from_l0_flag && collocated_ref_idx >= num_ref_idx_l1_active)) {\n          ctx->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n      }\n\n\n      if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||\n          (pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B)) {\n\n        if (!read_pred_weight_table(br,this,ctx))\n          {\n\t    ctx->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n      }\n\n      five_minus_max_num_merge_cand = get_uvlc(br);\n      if (five_minus_max_num_merge_cand == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n      MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n    }\n\n    slice_qp_delta = get_svlc(br);\n    if (slice_qp_delta == UVLC_ERROR) {\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n    //logtrace(LogSlice,\"slice_qp_delta: %d\\n\",shdr->slice_qp_delta);\n\n    if (pps->pps_slice_chroma_qp_offsets_present_flag) {\n      slice_cb_qp_offset = get_svlc(br);\n      if (slice_cb_qp_offset == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n\n      slice_cr_qp_offset = get_svlc(br);\n      if (slice_cr_qp_offset == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n    else {\n      slice_cb_qp_offset = 0;\n      slice_cr_qp_offset = 0;\n    }\n\n    if (pps->range_extension.chroma_qp_offset_list_enabled_flag) {\n      cu_chroma_qp_offset_enabled_flag = get_bits(br,1);\n    }\n\n    if (pps->deblocking_filter_override_enabled_flag) {\n      deblocking_filter_override_flag = get_bits(br,1);\n    }\n    else {\n      deblocking_filter_override_flag = 0;\n    }\n\n    slice_beta_offset = pps->beta_offset;\n    slice_tc_offset   = pps->tc_offset;\n\n    if (deblocking_filter_override_flag) {\n      slice_deblocking_filter_disabled_flag = get_bits(br,1);\n      if (!slice_deblocking_filter_disabled_flag) {\n        slice_beta_offset = get_svlc(br);\n        if (slice_beta_offset == UVLC_ERROR) {\n\t  ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t  return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t}\n        slice_beta_offset *= 2;\n\n        slice_tc_offset   = get_svlc(br);\n        if (slice_tc_offset == UVLC_ERROR) {\n\t  ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t  return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t}\n        slice_tc_offset   *= 2;\n      }\n    }\n    else {\n      slice_deblocking_filter_disabled_flag = pps->pic_disable_deblocking_filter_flag;\n    }\n\n    if (pps->pps_loop_filter_across_slices_enabled_flag  &&\n        (slice_sao_luma_flag || slice_sao_chroma_flag ||\n         !slice_deblocking_filter_disabled_flag )) {\n      slice_loop_filter_across_slices_enabled_flag = get_bits(br,1);\n    }\n    else {\n      slice_loop_filter_across_slices_enabled_flag =\n        pps->pps_loop_filter_across_slices_enabled_flag;\n    }\n  }\n\n  if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag ) {\n    num_entry_point_offsets = get_uvlc(br);\n    if (num_entry_point_offsets == UVLC_ERROR) {\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    if (pps->entropy_coding_sync_enabled_flag) {\n      // check num_entry_points for valid range\n\n      int firstCTBRow = slice_segment_address / sps->PicWidthInCtbsY;\n      int lastCTBRow  = firstCTBRow + num_entry_point_offsets;\n      if (lastCTBRow >= sps->PicHeightInCtbsY) {\n        ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n        return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n\n    if (pps->tiles_enabled_flag) {\n      if (num_entry_point_offsets > pps->num_tile_columns * pps->num_tile_rows) {\n        ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n        return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n\n    entry_point_offset.resize( num_entry_point_offsets );\n\n    if (num_entry_point_offsets > 0) {\n      offset_len = get_uvlc(br);\n      if (offset_len == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n      offset_len++;\n\n      if (offset_len > 32) {\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n\n      for (int i=0; i<num_entry_point_offsets; i++) {\n        {\n          entry_point_offset[i] = get_bits(br,offset_len)+1;\n        }\n\n        if (i>0) {\n          entry_point_offset[i] += entry_point_offset[i-1];\n        }\n      }\n    }\n  }\n  else {\n    num_entry_point_offsets = 0;\n  }\n\n  if (pps->slice_segment_header_extension_present_flag) {\n    slice_segment_header_extension_length = get_uvlc(br);\n    if (slice_segment_header_extension_length == UVLC_ERROR ||\n\tslice_segment_header_extension_length > 1000) {  // TODO: safety check against too large values\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i=0; i<slice_segment_header_extension_length; i++) {\n      //slice_segment_header_extension_data_byte[i]\n      get_bits(br,8);\n    }\n  }\n\n\n  compute_derived_values(pps.get());\n\n  *continueDecoding = true;\n  return DE265_OK;\n}\n\n\nde265_error slice_segment_header::write(error_queue* errqueue, CABAC_encoder& out,\n                                        const seq_parameter_set* sps,\n                                        const pic_parameter_set* pps,\n                                        uint8_t nal_unit_type)\n{\n  out.write_bit(first_slice_segment_in_pic_flag);\n\n  if (isRapPic(nal_unit_type)) { // TODO: is this still correct ? Should we drop RapPicFlag ?\n    out.write_bit(no_output_of_prior_pics_flag);\n  }\n\n  if (slice_pic_parameter_set_id > DE265_MAX_PPS_SETS) {\n    errqueue->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return DE265_OK;\n  }\n  out.write_uvlc(slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    if (pps->dependent_slice_segments_enabled_flag) {\n      out.write_bit(dependent_slice_segment_flag);\n    }\n\n    out.write_bits(slice_segment_address, ceil_log2(sps->PicSizeInCtbsY));\n\n    if (dependent_slice_segment_flag) {\n      if (slice_segment_address == 0) {\n        errqueue->add_warning(DE265_WARNING_DEPENDENT_SLICE_WITH_ADDRESS_ZERO, false);\n        return DE265_OK;\n      }\n    }\n  }\n\n  if (slice_segment_address < 0 ||\n      slice_segment_address > sps->PicSizeInCtbsY) {\n    errqueue->add_warning(DE265_WARNING_SLICE_SEGMENT_ADDRESS_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n\n  if (!dependent_slice_segment_flag) {\n    for (int i=0; i<pps->num_extra_slice_header_bits; i++) {\n      //slice_reserved_undetermined_flag[i]\n      out.skip_bits(1);\n    }\n\n    if (slice_type > 2) {\n      errqueue->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_OK;\n    }\n    out.write_uvlc(slice_type);\n\n    if (pps->output_flag_present_flag) {\n      out.write_bit(pic_output_flag);\n    }\n\n    if (sps->separate_colour_plane_flag == 1) {\n      out.write_bits(colour_plane_id,2);\n    }\n\n\n    int NumLtPics = 0;\n\n    if (nal_unit_type != NAL_UNIT_IDR_W_RADL &&\n        nal_unit_type != NAL_UNIT_IDR_N_LP) {\n      out.write_bits(slice_pic_order_cnt_lsb, sps->log2_max_pic_order_cnt_lsb);\n      out.write_bit(short_term_ref_pic_set_sps_flag);\n\n      if (!short_term_ref_pic_set_sps_flag) {\n        /* TODO\n        read_short_term_ref_pic_set(ctx, sps,\n                                    br, &slice_ref_pic_set,\n                                    sps->num_short_term_ref_pic_sets,\n                                    sps->ref_pic_sets,\n                                    true);\n        */\n        //CurrRpsIdx = sps->num_short_term_ref_pic_sets;\n        //CurrRps    = slice_ref_pic_set;\n      }\n      else {\n        int nBits = ceil_log2(sps->num_short_term_ref_pic_sets());\n        if (nBits>0) out.write_bits(short_term_ref_pic_set_idx,nBits);\n        else         { assert(short_term_ref_pic_set_idx==0); }\n\n        if (short_term_ref_pic_set_idx > sps->num_short_term_ref_pic_sets()) {\n          errqueue->add_warning(DE265_WARNING_SHORT_TERM_REF_PIC_SET_OUT_OF_RANGE, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        //CurrRpsIdx = short_term_ref_pic_set_idx;\n        //CurrRps    = sps->ref_pic_sets[CurrRpsIdx];\n      }\n\n\n      // --- long-term MC ---\n\n      if (sps->long_term_ref_pics_present_flag) {\n        if (sps->num_long_term_ref_pics_sps > 0) {\n          out.write_uvlc(num_long_term_sps);\n        }\n        else {\n          assert(num_long_term_sps == 0);\n        }\n\n        out.write_uvlc(num_long_term_pics);\n\n\n        // check maximum number of reference frames\n\n        if (num_long_term_sps +\n            num_long_term_pics +\n            CurrRps.NumNegativePics +\n            CurrRps.NumPositivePics\n            > sps->sps_max_dec_pic_buffering[sps->sps_max_sub_layers-1])\n          {\n            errqueue->add_warning(DE265_WARNING_MAX_NUM_REF_PICS_EXCEEDED, false);\n            return DE265_OK;\n          }\n\n        for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {\n          if (i < num_long_term_sps) {\n            int nBits = ceil_log2(sps->num_long_term_ref_pics_sps);\n            out.write_bits(lt_idx_sps[i], nBits);\n\n            // check that the referenced lt-reference really exists\n\n            if (lt_idx_sps[i] >= sps->num_long_term_ref_pics_sps) {\n              errqueue->add_warning(DE265_NON_EXISTING_LT_REFERENCE_CANDIDATE_IN_SLICE_HEADER, false);\n              return DE265_OK;\n            }\n\n            //ctx->PocLsbLt[i] = sps->lt_ref_pic_poc_lsb_sps[ lt_idx_sps[i] ];\n            //ctx->UsedByCurrPicLt[i] = sps->used_by_curr_pic_lt_sps_flag[ lt_idx_sps[i] ];\n          }\n          else {\n            int nBits = sps->log2_max_pic_order_cnt_lsb;\n            out.write_bits(poc_lsb_lt[i], nBits);\n            out.write_bit(used_by_curr_pic_lt_flag[i]);\n\n            //ctx->PocLsbLt[i] = poc_lsb_lt[i];\n            //ctx->UsedByCurrPicLt[i] = used_by_curr_pic_lt_flag[i];\n          }\n\n          //if (ctx->UsedByCurrPicLt[i]) {\n          //NumLtPics++;\n          //}\n\n          out.write_bit(delta_poc_msb_present_flag[i]);\n          if (delta_poc_msb_present_flag[i]) {\n            out.write_uvlc(delta_poc_msb_cycle_lt[i]);\n          }\n          else {\n            assert(delta_poc_msb_cycle_lt[i] == 0);\n          }\n\n          /*\n          if (i==0 || i==num_long_term_sps) {\n            ctx->DeltaPocMsbCycleLt[i] = delta_poc_msb_cycle_lt[i];\n          }\n          else {\n            ctx->DeltaPocMsbCycleLt[i] = (delta_poc_msb_cycle_lt[i] +\n                                          ctx->DeltaPocMsbCycleLt[i-1]);\n          }\n          */\n        }\n      }\n      else {\n        assert(num_long_term_sps == 0);\n        assert(num_long_term_pics== 0);\n      }\n\n      if (sps->sps_temporal_mvp_enabled_flag) {\n        out.write_bit(slice_temporal_mvp_enabled_flag);\n      }\n      else {\n        assert(slice_temporal_mvp_enabled_flag == 0);\n      }\n    }\n    else {\n      assert(slice_pic_order_cnt_lsb == 0);\n      assert(num_long_term_sps == 0);\n      assert(num_long_term_pics== 0);\n    }\n\n\n    // --- SAO ---\n\n    if (sps->sample_adaptive_offset_enabled_flag) {\n      out.write_bit(slice_sao_luma_flag);\n      out.write_bit(slice_sao_chroma_flag);\n    }\n    else {\n      assert(slice_sao_luma_flag  == 0);\n      assert(slice_sao_chroma_flag== 0);\n    }\n\n    if (slice_type == SLICE_TYPE_P  ||\n        slice_type == SLICE_TYPE_B) {\n      out.write_bit(num_ref_idx_active_override_flag);\n\n      if (num_ref_idx_active_override_flag) {\n        out.write_uvlc(num_ref_idx_l0_active);\n        num_ref_idx_l0_active++;;\n\n        if (slice_type == SLICE_TYPE_B) {\n          out.write_uvlc(num_ref_idx_l1_active);\n          num_ref_idx_l1_active++;\n        }\n      }\n      else {\n        assert(num_ref_idx_l0_active == pps->num_ref_idx_l0_default_active);\n        assert(num_ref_idx_l1_active == pps->num_ref_idx_l1_default_active);\n      }\n\n      NumPocTotalCurr = CurrRps.NumPocTotalCurr_shortterm_only + NumLtPics;\n\n      if (pps->lists_modification_present_flag && NumPocTotalCurr > 1) {\n\n        int nBits = ceil_log2(NumPocTotalCurr);\n\n        out.write_bit(ref_pic_list_modification_flag_l0);\n        if (ref_pic_list_modification_flag_l0) {\n          for (int i=0;i<num_ref_idx_l0_active;i++) {\n            out.write_bits(list_entry_l0[i], nBits);\n          }\n        }\n\n        if (slice_type == SLICE_TYPE_B) {\n          out.write_bit(ref_pic_list_modification_flag_l1);\n          if (ref_pic_list_modification_flag_l1) {\n            for (int i=0;i<num_ref_idx_l1_active;i++) {\n              out.write_bits(list_entry_l1[i], nBits);\n            }\n          }\n        }\n        else {\n          assert(ref_pic_list_modification_flag_l1 == 0);\n        }\n      }\n      else {\n        assert(ref_pic_list_modification_flag_l0 == 0);\n        assert(ref_pic_list_modification_flag_l1 == 0);\n      }\n\n      if (slice_type == SLICE_TYPE_B) {\n        out.write_bit(mvd_l1_zero_flag);\n      }\n\n      if (pps->cabac_init_present_flag) {\n        out.write_bit(cabac_init_flag);\n      }\n      else {\n        assert(cabac_init_flag == 0);\n      }\n\n      if (slice_temporal_mvp_enabled_flag) {\n        if (slice_type == SLICE_TYPE_B)\n          out.write_bit(collocated_from_l0_flag);\n        else\n          { assert(collocated_from_l0_flag == 1); }\n\n        if (( collocated_from_l0_flag && num_ref_idx_l0_active > 1) ||\n            (!collocated_from_l0_flag && num_ref_idx_l1_active > 1)) {\n          out.write_uvlc(collocated_ref_idx);\n        }\n        else {\n          assert(collocated_ref_idx == 0);\n        }\n      }\n\n      if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||\n          (pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B)) {\n\n        assert(0);\n        /* TODO\n        if (!read_pred_weight_table(br,this,ctx))\n          {\n\t    ctx->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n        */\n      }\n\n      out.write_uvlc(five_minus_max_num_merge_cand);\n      //MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n    }\n\n    out.write_svlc(slice_qp_delta);\n\n    if (pps->pps_slice_chroma_qp_offsets_present_flag) {\n      out.write_svlc(slice_cb_qp_offset);\n      out.write_svlc(slice_cr_qp_offset);\n    }\n    else {\n      assert(slice_cb_qp_offset == 0);\n      assert(slice_cr_qp_offset == 0);\n    }\n\n    if (pps->deblocking_filter_override_enabled_flag) {\n      out.write_bit(deblocking_filter_override_flag);\n    }\n    else {\n      assert(deblocking_filter_override_flag == 0);\n    }\n\n    //slice_beta_offset = pps->beta_offset;\n    //slice_tc_offset   = pps->tc_offset;\n\n    if (deblocking_filter_override_flag) {\n      out.write_bit(slice_deblocking_filter_disabled_flag);\n      if (!slice_deblocking_filter_disabled_flag) {\n        out.write_svlc(slice_beta_offset/2);\n        out.write_svlc(slice_tc_offset  /2);\n      }\n    }\n    else {\n      assert(slice_deblocking_filter_disabled_flag == pps->pic_disable_deblocking_filter_flag);\n    }\n\n    if (pps->pps_loop_filter_across_slices_enabled_flag  &&\n        (slice_sao_luma_flag || slice_sao_chroma_flag ||\n         !slice_deblocking_filter_disabled_flag )) {\n      out.write_bit(slice_loop_filter_across_slices_enabled_flag);\n    }\n    else {\n      assert(slice_loop_filter_across_slices_enabled_flag ==\n             pps->pps_loop_filter_across_slices_enabled_flag);\n    }\n  }\n\n  if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag ) {\n    out.write_uvlc(num_entry_point_offsets);\n\n    if (num_entry_point_offsets > 0) {\n      out.write_uvlc(offset_len-1);\n\n      for (int i=0; i<num_entry_point_offsets; i++) {\n        {\n          int prev=0;\n          if (i>0) prev = entry_point_offset[i-1];\n          out.write_bits(entry_point_offset[i]-prev-1, offset_len);\n        }\n      }\n    }\n  }\n  else {\n    assert(num_entry_point_offsets == 0);\n  }\n\n  if (pps->slice_segment_header_extension_present_flag) {\n    out.write_uvlc(slice_segment_header_extension_length);\n    if (slice_segment_header_extension_length > 1000) {  // TODO: safety check against too large values\n      errqueue->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i=0; i<slice_segment_header_extension_length; i++) {\n      //slice_segment_header_extension_data_byte[i]\n      out.skip_bits(8);\n    }\n  }\n\n  return DE265_OK;\n}\n\nvoid slice_segment_header::compute_derived_values(const pic_parameter_set* pps)\n{\n  // --- init variables ---\n\n  SliceQPY = pps->pic_init_qp + slice_qp_delta;\n\n  switch (slice_type)\n    {\n    case SLICE_TYPE_I: initType = 0; break;\n    case SLICE_TYPE_P: initType = cabac_init_flag + 1; break;\n    case SLICE_TYPE_B: initType = 2 - cabac_init_flag; break;\n    }\n\n  MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n}\n\n\n//-----------------------------------------------------------------------\n\n\nvoid slice_segment_header::dump_slice_segment_header(const decoder_context* ctx, int fd) const\n{\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  assert(pps->pps_read); // TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  assert(sps->sps_read); // TODO: error handling\n\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }\n\n  LOG1(\"slice_pic_parameter_set_id           : %d\\n\", slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    //if (pps->dependent_slice_segments_enabled_flag) {\n      LOG1(\"dependent_slice_segment_flag         : %d\\n\", dependent_slice_segment_flag);\n      //}\n    LOG1(\"slice_segment_address                : %d\\n\", slice_segment_address);\n  }\n\n  //if (!dependent_slice_segment_flag)\n    {\n    //for (int i=0; i<pps->num_extra_slice_header_bits; i++) {\n    //slice_reserved_flag[i]\n\n    LOG1(\"slice_type                           : %c\\n\",\n         slice_type == 0 ? 'B' :\n         slice_type == 1 ? 'P' : 'I');\n\n    if (pps->output_flag_present_flag) {\n      LOG1(\"pic_output_flag                      : %d\\n\", pic_output_flag);\n    }\n\n    if (sps->separate_colour_plane_flag == 1) {\n      LOG1(\"colour_plane_id                      : %d\\n\", colour_plane_id);\n    }\n\n    LOG1(\"slice_pic_order_cnt_lsb              : %d\\n\", slice_pic_order_cnt_lsb);\n\n    if (ctx->get_nal_unit_type() != NAL_UNIT_IDR_W_RADL &&\n        ctx->get_nal_unit_type() != NAL_UNIT_IDR_N_LP) {\n      LOG1(\"short_term_ref_pic_set_sps_flag      : %d\\n\", short_term_ref_pic_set_sps_flag);\n\n      if (!short_term_ref_pic_set_sps_flag) {\n        LOG1(\"ref_pic_set[ %2d ]: \",sps->num_short_term_ref_pic_sets());\n        dump_compact_short_term_ref_pic_set(&slice_ref_pic_set, 16, fh);\n      }\n      else if (sps->num_short_term_ref_pic_sets() > 1) {\n        LOG1(\"short_term_ref_pic_set_idx           : %d\\n\", short_term_ref_pic_set_idx);\n        dump_compact_short_term_ref_pic_set(&sps->ref_pic_sets[short_term_ref_pic_set_idx], 16, fh);\n      }\n\n      if (sps->long_term_ref_pics_present_flag) {\n        if (sps->num_long_term_ref_pics_sps > 0) {\n          LOG1(\"num_long_term_sps                        : %d\\n\", num_long_term_sps);\n        }\n\n        LOG1(\"num_long_term_pics                       : %d\\n\", num_long_term_pics);\n\n#if 0\n        for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {\n          LOG2(\"PocLsbLt[%d]            : %d\\n\", i, ctx->PocLsbLt[i]);\n          LOG2(\"UsedByCurrPicLt[%d]     : %d\\n\", i, ctx->UsedByCurrPicLt[i]);\n          LOG2(\"DeltaPocMsbCycleLt[%d]  : %d\\n\", i, ctx->DeltaPocMsbCycleLt[i]);\n        }\n#endif\n      }\n\n      if (sps->sps_temporal_mvp_enabled_flag) {\n        LOG1(\"slice_temporal_mvp_enabled_flag : %d\\n\", slice_temporal_mvp_enabled_flag);\n      }\n    }\n\n\n    if (sps->sample_adaptive_offset_enabled_flag) {\n      LOG1(\"slice_sao_luma_flag             : %d\\n\", slice_sao_luma_flag);\n      LOG1(\"slice_sao_chroma_flag           : %d\\n\", slice_sao_chroma_flag);\n    }\n\n\n    if (slice_type == SLICE_TYPE_P || slice_type == SLICE_TYPE_B) {\n      LOG1(\"num_ref_idx_active_override_flag : %d\\n\", num_ref_idx_active_override_flag);\n\n      LOG2(\"num_ref_idx_l0_active          : %d %s\\n\", num_ref_idx_l0_active,\n           num_ref_idx_active_override_flag ? \"\" : \"(from PPS)\");\n\n      if (slice_type == SLICE_TYPE_B) {\n        LOG2(\"num_ref_idx_l1_active          : %d %s\\n\", num_ref_idx_l1_active,\n             num_ref_idx_active_override_flag ? \"\" : \"(from PPS)\");\n      }\n\n      if (pps->lists_modification_present_flag && NumPocTotalCurr > 1)\n        {\n          LOG1(\"ref_pic_list_modification_flag_l0 : %d\\n\", ref_pic_list_modification_flag_l0);\n          if (ref_pic_list_modification_flag_l0) {\n            for (int i=0;i<num_ref_idx_l0_active;i++) {\n              LOG2(\"  %d: %d\\n\",i,list_entry_l0[i]);\n            }\n          }\n\n          LOG1(\"ref_pic_list_modification_flag_l1 : %d\\n\", ref_pic_list_modification_flag_l1);\n          if (ref_pic_list_modification_flag_l1) {\n            for (int i=0;i<num_ref_idx_l1_active;i++) {\n              LOG2(\"  %d: %d\\n\",i,list_entry_l1[i]);\n            }\n          }\n        }\n\n      if (slice_type == SLICE_TYPE_B) {\n        LOG1(\"mvd_l1_zero_flag               : %d\\n\", mvd_l1_zero_flag);\n      }\n\n      LOG1(\"cabac_init_flag                : %d\\n\", cabac_init_flag);\n\n      if (slice_temporal_mvp_enabled_flag) {\n        LOG1(\"collocated_from_l0_flag        : %d\\n\", collocated_from_l0_flag);\n        LOG1(\"collocated_ref_idx             : %d\\n\", collocated_ref_idx);\n      }\n\n      if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||\n          (pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B))\n        {\n          LOG1(\"luma_log2_weight_denom         : %d\\n\", luma_log2_weight_denom);\n          if (sps->chroma_format_idc != 0) {\n            LOG1(\"ChromaLog2WeightDenom          : %d\\n\", ChromaLog2WeightDenom);\n          }\n\n          for (int l=0;l<=1;l++)\n            if (l==0 || (l==1 && slice_type == SLICE_TYPE_B))\n              {\n                int num_ref = (l==0 ?\n                               num_ref_idx_l0_active-1 :\n                               num_ref_idx_l1_active-1);\n\n                if (false) { // do not show these flags\n                  for (int i=0;i<=num_ref;i++) {\n                    LOG3(\"luma_weight_flag_l%d[%d]        : %d\\n\",l,i,luma_weight_flag[l][i]);\n                  }\n\n                  if (sps->chroma_format_idc != 0) {\n                    for (int i=0;i<=num_ref;i++) {\n                      LOG3(\"chroma_weight_flag_l%d[%d]      : %d\\n\",l,i,chroma_weight_flag[l][i]);\n                    }\n                  }\n                }\n\n                for (int i=0;i<=num_ref;i++) {\n                  LOG3(\"LumaWeight_L%d[%d]             : %d\\n\",l,i,LumaWeight[l][i]);\n                  LOG3(\"luma_offset_l%d[%d]            : %d\\n\",l,i,luma_offset[l][i]);\n\n                  for (int j=0;j<2;j++) {\n                    LOG4(\"ChromaWeight_L%d[%d][%d]        : %d\\n\",l,i,j,ChromaWeight[l][i][j]);\n                    LOG4(\"ChromaOffset_L%d[%d][%d]        : %d\\n\",l,i,j,ChromaOffset[l][i][j]);\n                  }\n                }\n              }\n        }\n\n      LOG1(\"five_minus_max_num_merge_cand  : %d\\n\", five_minus_max_num_merge_cand);\n    }\n\n\n    LOG1(\"slice_qp_delta         : %d\\n\", slice_qp_delta);\n    if (pps->pps_slice_chroma_qp_offsets_present_flag) {\n      LOG1(\"slice_cb_qp_offset     : %d\\n\", slice_cb_qp_offset);\n      LOG1(\"slice_cr_qp_offset     : %d\\n\", slice_cr_qp_offset);\n    }\n\n    if (pps->deblocking_filter_override_enabled_flag) {\n      LOG1(\"deblocking_filter_override_flag : %d\\n\", deblocking_filter_override_flag);\n    }\n\n    LOG2(\"slice_deblocking_filter_disabled_flag : %d %s\\n\",\n         slice_deblocking_filter_disabled_flag,\n         (deblocking_filter_override_flag ? \"(override)\" : \"(from pps)\"));\n\n    if (deblocking_filter_override_flag) {\n\n      if (!slice_deblocking_filter_disabled_flag) {\n        LOG1(\"slice_beta_offset  : %d\\n\", slice_beta_offset);\n        LOG1(\"slice_tc_offset    : %d\\n\", slice_tc_offset);\n      }\n    }\n\n    if (pps->pps_loop_filter_across_slices_enabled_flag  &&\n        (slice_sao_luma_flag || slice_sao_chroma_flag ||\n         !slice_deblocking_filter_disabled_flag)) {\n      LOG1(\"slice_loop_filter_across_slices_enabled_flag : %d\\n\",\n           slice_loop_filter_across_slices_enabled_flag);\n    }\n  }\n\n  if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n    LOG1(\"num_entry_point_offsets    : %d\\n\", num_entry_point_offsets);\n\n    if (num_entry_point_offsets > 0) {\n      LOG1(\"offset_len                 : %d\\n\", offset_len);\n\n      for (int i=0; i<num_entry_point_offsets; i++) {\n        LOG2(\"entry point [%i] : %d\\n\", i, entry_point_offset[i]);\n      }\n    }\n  }\n\n  /*\n    if( slice_segment_header_extension_present_flag ) {\n    slice_segment_header_extension_length\n    for( i = 0; i < slice_segment_header_extension_length; i++)\n    slice_segment_header_extension_data_byte[i]\n    }\n    byte_alignment()\n    }\n  */\n\n#undef LOG0\n#undef LOG1\n#undef LOG2\n#undef LOG3\n#undef LOG4\n  //#endif\n}\n\n\n\nvoid initialize_CABAC_models(thread_context* tctx)\n{\n  const int QPY = tctx->shdr->SliceQPY;\n  const int initType = tctx->shdr->initType;\n  assert(initType >= 0 && initType <= 2);\n\n  tctx->ctx_model.init(initType, QPY);\n\n  for (int i=0;i<4;i++) {\n    tctx->StatCoeff[i] = 0;\n  }\n}\n\n\n\nstatic int decode_transform_skip_flag(thread_context* tctx, int cIdx)\n{\n  const int context = (cIdx==0) ? 0 : 1;\n\n  logtrace(LogSlice,\"# transform_skip_flag (context=%d)\\n\",context);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_TRANSFORM_SKIP_FLAG+context]);\n\n  logtrace(LogSymbols,\"$1 transform_skip_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_sao_merge_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_merge_left/up_flag\\n\");\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_SAO_MERGE_FLAG]);\n\n  logtrace(LogSymbols,\"$1 sao_merge_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\n\nstatic int decode_sao_type_idx(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_type_idx_luma/chroma\\n\");\n\n  int bit0 = decode_CABAC_bit(&tctx->cabac_decoder,\n                              &tctx->ctx_model[CONTEXT_MODEL_SAO_TYPE_IDX]);\n\n  if (bit0==0) {\n    logtrace(LogSymbols,\"$1 sao_type_idx=%d\\n\",0);\n    return 0;\n  }\n  else {\n    int bit1 = decode_CABAC_bypass(&tctx->cabac_decoder);\n    if (bit1==0) {\n      logtrace(LogSymbols,\"$1 sao_type_idx=%d\\n\",1);\n      return 1;\n    }\n    else {\n      logtrace(LogSymbols,\"$1 sao_type_idx=%d\\n\",2);\n      return 2;\n    }\n  }\n}\n\n\nstatic int decode_sao_offset_abs(thread_context* tctx, int bitDepth)\n{\n  logtrace(LogSlice,\"# sao_offset_abs\\n\");\n  int cMax = (1<<(libde265_min(bitDepth,10)-5))-1;\n  int value = decode_CABAC_TU_bypass(&tctx->cabac_decoder, cMax);\n  logtrace(LogSymbols,\"$1 sao_offset_abs=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_sao_class(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_class\\n\");\n  int value = decode_CABAC_FL_bypass(&tctx->cabac_decoder, 2);\n  logtrace(LogSymbols,\"$1 sao_class=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_sao_offset_sign(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_offset_sign\\n\");\n  int value = decode_CABAC_bypass(&tctx->cabac_decoder);\n  logtrace(LogSymbols,\"$1 sao_offset_sign=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_sao_band_position(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_band_position\\n\");\n  int value = decode_CABAC_FL_bypass(&tctx->cabac_decoder,5);\n  logtrace(LogSymbols,\"$1 sao_band_position=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_transquant_bypass_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# cu_transquant_bypass_enable_flag\\n\");\n  int value = decode_CABAC_bit(&tctx->cabac_decoder,\n                               &tctx->ctx_model[CONTEXT_MODEL_CU_TRANSQUANT_BYPASS_FLAG]);\n  logtrace(LogSymbols,\"$1 transquant_bypass_flag=%d\\n\",value);\n  return value;\n}\n\n\n#include <sys/types.h>\n#include <signal.h>\n\nstatic int decode_split_cu_flag(thread_context* tctx,\n\t\t\t\tint x0, int y0, int ctDepth)\n{\n  // check if neighbors are available\n\n  int availableL = check_CTB_available(tctx->img, x0,y0, x0-1,y0);\n  int availableA = check_CTB_available(tctx->img, x0,y0, x0,y0-1);\n\n  int condL = 0;\n  int condA = 0;\n\n  if (availableL && tctx->img->get_ctDepth(x0-1,y0) > ctDepth) condL=1;\n  if (availableA && tctx->img->get_ctDepth(x0,y0-1) > ctDepth) condA=1;\n\n  int contextOffset = condL + condA;\n  int context = contextOffset;\n\n  // decode bit\n\n  logtrace(LogSlice,\"# split_cu_flag context=%d R=%x\\n\", context, tctx->cabac_decoder.range);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_SPLIT_CU_FLAG + context]);\n\n  logtrace(LogSlice,\"> split_cu_flag R=%x, ctx=%d, bit=%d\\n\", tctx->cabac_decoder.range,context,bit);\n\n  logtrace(LogSymbols,\"$1 split_cu_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_cu_skip_flag(thread_context* tctx,\n\t\t\t       int x0, int y0, int ctDepth)\n{\n  decoder_context* ctx = tctx->decctx;\n\n  // check if neighbors are available\n\n  int availableL = check_CTB_available(tctx->img, x0,y0, x0-1,y0);\n  int availableA = check_CTB_available(tctx->img, x0,y0, x0,y0-1);\n\n  int condL = 0;\n  int condA = 0;\n\n  if (availableL && tctx->img->get_cu_skip_flag(x0-1,y0)) condL=1;\n  if (availableA && tctx->img->get_cu_skip_flag(x0,y0-1)) condA=1;\n\n  int contextOffset = condL + condA;\n  int context = contextOffset;\n\n  // decode bit\n\n  logtrace(LogSlice,\"# cu_skip_flag context=%d R=%x\\n\", context, tctx->cabac_decoder.range);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_CU_SKIP_FLAG + context]);\n\n  logtrace(LogSlice,\"> cu_skip_flag R=%x, ctx=%d, bit=%d\\n\", tctx->cabac_decoder.range,context,bit);\n\n  logtrace(LogSymbols,\"$1 cu_skip_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic enum PartMode decode_part_mode(thread_context* tctx,\n\t\t\t\t      enum PredMode pred_mode, int cLog2CbSize)\n{\n  de265_image* img = tctx->img;\n\n  if (pred_mode == MODE_INTRA) {\n    logtrace(LogSlice,\"# part_mode (INTRA)\\n\");\n\n    int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE]);\n\n    logtrace(LogSlice,\"> %s\\n\",bit ? \"2Nx2N\" : \"NxN\");\n\n    logtrace(LogSymbols,\"$1 part_mode=%d\\n\",bit ? PART_2Nx2N : PART_NxN);\n\n    return bit ? PART_2Nx2N : PART_NxN;\n  }\n  else {\n    const seq_parameter_set& sps = img->get_sps();\n\n    int bit0 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+0]);\n    if (bit0) { logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2Nx2N); return PART_2Nx2N; }\n\n    // CHECK_ME: I optimize code and fix bug here, need more VERIFY!\n    int bit1 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+1]);\n    if (cLog2CbSize > sps.Log2MinCbSizeY) {\n      if (!sps.amp_enabled_flag) {\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",bit1 ? PART_2NxN : PART_Nx2N);\n        return bit1 ? PART_2NxN : PART_Nx2N;\n      }\n      else {\n        int bit3 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+3]);\n        if (bit3) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",bit1 ? PART_2NxN : PART_Nx2N);\n          return bit1 ? PART_2NxN : PART_Nx2N;\n        }\n\n        int bit4 = decode_CABAC_bypass(&tctx->cabac_decoder);\n        if ( bit1 &&  bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2NxnD);\n          return PART_2NxnD;\n        }\n        if ( bit1 && !bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2NxnU);\n          return PART_2NxnU;\n        }\n        if (!bit1 && !bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_nLx2N);\n          return PART_nLx2N;\n        }\n        if (!bit1 &&  bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_nRx2N);\n          return PART_nRx2N;\n        }\n      }\n    }\n    else {\n      // TODO, we could save one if here when first decoding the next bin and then\n      // checkcLog2CbSize==3 when it is '0'\n\n      if (bit1) {\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2NxN);\n        return PART_2NxN;\n      }\n\n      if (cLog2CbSize==3) {\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_Nx2N);\n        return PART_Nx2N;\n      }\n      else {\n        int bit2 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+2]);\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_NxN-bit2);\n        return (enum PartMode)((int)PART_NxN - bit2)/*bit2 ? PART_Nx2N : PART_NxN*/;\n      }\n    }\n  }\n\n  assert(false); // should never be reached\n  return PART_2Nx2N;\n}\n\n\nstatic inline int decode_prev_intra_luma_pred_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# prev_intra_luma_pred_flag\\n\");\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PREV_INTRA_LUMA_PRED_FLAG]);\n  logtrace(LogSymbols,\"$1 prev_intra_luma_pred_flag=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic inline int decode_mpm_idx(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# mpm_idx (TU:2)\\n\");\n  int mpm = decode_CABAC_TU_bypass(&tctx->cabac_decoder, 2);\n  logtrace(LogSlice,\"> mpm_idx = %d\\n\",mpm);\n  logtrace(LogSymbols,\"$1 mpm_idx=%d\\n\",mpm);\n  return mpm;\n}\n\n\nstatic inline int decode_rem_intra_luma_pred_mode(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# rem_intra_luma_pred_mode (5 bits)\\n\");\n  int value = decode_CABAC_FL_bypass(&tctx->cabac_decoder, 5);\n  logtrace(LogSymbols,\"$1 rem_intra_luma_pred_mode=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_intra_chroma_pred_mode(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# intra_chroma_pred_mode\\n\");\n\n  int prefix = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_INTRA_CHROMA_PRED_MODE]);\n\n  int mode;\n  if (prefix==0) {\n    mode=4;\n  }\n  else {\n    mode = decode_CABAC_FL_bypass(&tctx->cabac_decoder, 2);\n  }\n\n  logtrace(LogSlice,\"> intra_chroma_pred_mode = %d\\n\",mode);\n  logtrace(LogSymbols,\"$1 intra_chroma_pred_mode=%d\\n\",mode);\n\n  return mode;\n}\n\n\nstatic int decode_split_transform_flag(thread_context* tctx,\n\t\t\t\t       int log2TrafoSize)\n{\n  logtrace(LogSlice,\"# split_transform_flag (log2TrafoSize=%d)\\n\",log2TrafoSize);\n\n  int context = 5-log2TrafoSize;\n  assert(context >= 0 && context <= 2);\n\n  logtrace(LogSlice,\"# context: %d\\n\",context);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_SPLIT_TRANSFORM_FLAG + context]);\n  logtrace(LogSymbols,\"$1 split_transform_flag=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic int decode_cbf_chroma(thread_context* tctx,\n\t\t\t     int trafoDepth)\n{\n  logtrace(LogSlice,\"# cbf_chroma\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_CBF_CHROMA + trafoDepth]);\n\n  logtrace(LogSymbols,\"$1 cbf_chroma=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic int decode_cbf_luma(thread_context* tctx,\n\t\t\t   int trafoDepth)\n{\n  logtrace(LogSlice,\"# cbf_luma\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_CBF_LUMA + (trafoDepth==0)]);\n\n  logtrace(LogSlice,\"> cbf_luma = %d\\n\",bit);\n\n  logtrace(LogSymbols,\"$1 cbf_luma=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic inline int decode_coded_sub_block_flag(thread_context* tctx,\n                                              int cIdx,\n                                              uint8_t coded_sub_block_neighbors)\n{\n  logtrace(LogSlice,\"# coded_sub_block_flag\\n\");\n\n  // tricky computation of csbfCtx\n  int csbfCtx = ((coded_sub_block_neighbors &  1) |  // right neighbor set  or\n                 (coded_sub_block_neighbors >> 1));  // bottom neighbor set   -> csbfCtx=1\n\n  int ctxIdxInc = csbfCtx;\n  if (cIdx!=0) {\n    ctxIdxInc += 2;\n  }\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_CODED_SUB_BLOCK_FLAG + ctxIdxInc]);\n\n  logtrace(LogSymbols,\"$1 coded_sub_block_flag=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic int decode_cu_qp_delta_abs(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# cu_qp_delta_abs\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_CU_QP_DELTA_ABS + 0]);\n  if (bit==0) {\n    logtrace(LogSymbols,\"$1 cu_qp_delta_abs=%d\\n\",0);\n    return 0;\n  }\n\n  int prefix=1;\n  for (int i=0;i<4;i++) {\n    bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                           &tctx->ctx_model[CONTEXT_MODEL_CU_QP_DELTA_ABS + 1]);\n    if (bit==0) { break; }\n    else { prefix++; }\n  }\n\n  if (prefix==5) {\n    int value = decode_CABAC_EGk_bypass(&tctx->cabac_decoder, 0);\n    logtrace(LogSymbols,\"$1 cu_qp_delta_abs=%d\\n\",value+5);\n    return value + 5;\n  }\n  else {\n    logtrace(LogSymbols,\"$1 cu_qp_delta_abs=%d\\n\",prefix);\n    return prefix;\n  }\n}\n\n\nstatic int decode_last_significant_coeff_prefix(thread_context* tctx,\n\t\t\t\t\t\tint log2TrafoSize,\n\t\t\t\t\t\tint cIdx,\n\t\t\t\t\t\tcontext_model* model)\n{\n  logtrace(LogSlice,\"# last_significant_coeff_prefix log2TrafoSize:%d cIdx:%d\\n\",log2TrafoSize,cIdx);\n\n  int cMax = (log2TrafoSize<<1)-1;\n\n  int ctxOffset, ctxShift;\n  if (cIdx==0) {\n    ctxOffset = 3*(log2TrafoSize-2) + ((log2TrafoSize-1)>>2);\n    ctxShift  = (log2TrafoSize+1)>>2;\n  }\n  else {\n    ctxOffset = 15;\n    ctxShift  = log2TrafoSize-2;\n  }\n\n  int binIdx;\n  int value = cMax;\n  for (binIdx=0;binIdx<cMax;binIdx++)\n    {\n      int ctxIdxInc = (binIdx >> ctxShift);\n\n      logtrace(LogSlice,\"context: %d+%d\\n\",ctxOffset,ctxIdxInc);\n\n      int bit = decode_CABAC_bit(&tctx->cabac_decoder, &model[ctxOffset + ctxIdxInc]);\n      if (bit==0) {\n        value=binIdx;\n        break;\n      }\n    }\n\n  logtrace(LogSlice,\"> last_significant_coeff_prefix: %d\\n\", value);\n\n  return value;\n}\n\n\nstatic const uint8_t ctxIdxMap[16] = {\n  0,1,4,5,\n  2,3,4,5,\n  6,6,8,8,\n  7,7,8,99\n};\n\nuint8_t* ctxIdxLookup[4 /* 4-log2-32 */][2 /* !!cIdx */][2 /* !!scanIdx */][4 /* prevCsbf */];\n\nbool alloc_and_init_significant_coeff_ctxIdx_lookupTable()\n{\n  int tableSize = 4*4*(2) + 8*8*(2*2*4) + 16*16*(2*4) + 32*32*(2*4);\n\n  uint8_t* p = (uint8_t*)malloc(tableSize);\n  if (p==NULL) {\n    return false;\n  }\n\n  memset(p,0xFF,tableSize);  // just for debugging\n\n\n  // --- Set pointers to memory areas. Note that some parameters share the same memory. ---\n\n  // 4x4\n\n  for (int cIdx=0;cIdx<2;cIdx++) {\n    for (int scanIdx=0;scanIdx<2;scanIdx++)\n      for (int prevCsbf=0;prevCsbf<4;prevCsbf++)\n        ctxIdxLookup[0][cIdx][scanIdx][prevCsbf] = p;\n\n    p += 4*4;\n  }\n\n  // 8x8\n\n  for (int cIdx=0;cIdx<2;cIdx++)\n    for (int scanIdx=0;scanIdx<2;scanIdx++)\n      for (int prevCsbf=0;prevCsbf<4;prevCsbf++) {\n        ctxIdxLookup[1][cIdx][scanIdx][prevCsbf] = p;\n        p += 8*8;\n      }\n\n  // 16x16\n\n  for (int cIdx=0;cIdx<2;cIdx++)\n    for (int prevCsbf=0;prevCsbf<4;prevCsbf++) {\n      for (int scanIdx=0;scanIdx<2;scanIdx++) {\n        ctxIdxLookup[2][cIdx][scanIdx][prevCsbf] = p;\n      }\n\n      p += 16*16;\n    }\n\n  // 32x32\n\n  for (int cIdx=0;cIdx<2;cIdx++)\n    for (int prevCsbf=0;prevCsbf<4;prevCsbf++) {\n      for (int scanIdx=0;scanIdx<2;scanIdx++) {\n        ctxIdxLookup[3][cIdx][scanIdx][prevCsbf] = p;\n      }\n\n      p += 32*32;\n    }\n\n\n  // --- precompute ctxIdx tables ---\n\n  for (int log2w=2; log2w<=5 ; log2w++)\n    for (int cIdx=0;cIdx<2;cIdx++)\n      for (int scanIdx=0;scanIdx<2;scanIdx++)\n        for (int prevCsbf=0;prevCsbf<4;prevCsbf++)\n          {\n            for (int yC=0;yC<(1<<log2w);yC++)\n              for (int xC=0;xC<(1<<log2w);xC++)\n                {\n                  int w = 1<<log2w;\n                  int sbWidth = w>>2;\n\n                  int sigCtx;\n\n                  // if log2TrafoSize==2\n                  if (sbWidth==1) {\n                    sigCtx = ctxIdxMap[(yC<<2) + xC];\n                  }\n                  else if (xC+yC==0) {\n                    sigCtx = 0;\n                  }\n                  else {\n                    int xS = xC>>2;\n                    int yS = yC>>2;\n                    /*\n                      int prevCsbf = 0;\n\n                      if (xS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+1  +yS*sbWidth];    }\n                      if (yS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+(1+yS)*sbWidth]<<1; }\n                    */\n                    int xP = xC & 3;\n                    int yP = yC & 3;\n\n                    //logtrace(LogSlice,\"posInSubset: %d,%d\\n\",xP,yP);\n                    //logtrace(LogSlice,\"prevCsbf: %d\\n\",prevCsbf);\n\n                    switch (prevCsbf) {\n                    case 0:\n                      sigCtx = (xP+yP>=3) ? 0 : (xP+yP>0) ? 1 : 2;\n                      break;\n                    case 1:\n                      sigCtx = (yP==0) ? 2 : (yP==1) ? 1 : 0;\n                      break;\n                    case 2:\n                      sigCtx = (xP==0) ? 2 : (xP==1) ? 1 : 0;\n                      break;\n                    default:\n                      sigCtx = 2;\n                      break;\n                    }\n\n                    //logtrace(LogSlice,\"a) sigCtx=%d\\n\",sigCtx);\n\n                    if (cIdx==0) {\n                      if (xS+yS > 0) sigCtx+=3;\n\n                      //logtrace(LogSlice,\"b) sigCtx=%d\\n\",sigCtx);\n\n                      // if log2TrafoSize==3\n                      if (sbWidth==2) { // 8x8 block\n                        sigCtx += (scanIdx==0) ? 9 : 15;\n                      } else {\n                        sigCtx += 21;\n                      }\n\n                      //logtrace(LogSlice,\"c) sigCtx=%d\\n\",sigCtx);\n                    }\n                    else {\n                      // if log2TrafoSize==3\n                      if (sbWidth==2) { // 8x8 block\n                        sigCtx+=9;\n                      }\n                      else {\n                        sigCtx+=12;\n                      }\n                    }\n\n                  }\n\n                  int ctxIdxInc;\n                  if (cIdx==0) { ctxIdxInc=sigCtx; }\n                  else         { ctxIdxInc=27+sigCtx; }\n\n                  if (ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] != 0xFF) {\n                    assert(ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] == ctxIdxInc);\n                  }\n\n                  ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] = ctxIdxInc;\n\n                  //NOTE: when using this option, we have to include all three scanIdx in the table\n                  //ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][s] = ctxIdxInc;\n                }\n          }\n\n  return true;\n}\n\n\nbool alloc_and_init_significant_coeff_ctxIdx_lookupTable_OLD()\n{\n  int tableSize = 2*2*4*(4*4 + 8*8 + 16*16 + 32*32);\n  uint8_t* p = (uint8_t*)malloc(tableSize);\n  if (p==NULL) {\n    return false;\n  }\n\n  for (int log2w=2; log2w<=5 ; log2w++)\n    for (int cIdx=0;cIdx<2;cIdx++)\n      for (int scanIdx=0;scanIdx<2;scanIdx++)\n        for (int prevCsbf=0;prevCsbf<4;prevCsbf++)\n          {\n            // assign pointer into reserved memory area\n\n            ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf] = p;\n            p += (1<<log2w)*(1<<log2w);\n\n            const position* ScanOrderSub = get_scan_order(log2w-2, scanIdx);\n            const position* ScanOrderPos = get_scan_order(2, scanIdx);\n\n            //for (int yC=0;yC<(1<<log2w);yC++)\n            // for (int xC=0;xC<(1<<log2w);xC++)\n            for (int s=0;s<(1<<log2w)*(1<<log2w);s++)\n              {\n                position S = ScanOrderSub[s>>4];\n                int x0 = S.x<<2;\n                int y0 = S.y<<2;\n\n                int subX = ScanOrderPos[s & 0xF].x;\n                int subY = ScanOrderPos[s & 0xF].y;\n                int xC = x0 + subX;\n                int yC = y0 + subY;\n\n\n                int w = 1<<log2w;\n                int sbWidth = w>>2;\n\n                int sigCtx;\n\n                // if log2TrafoSize==2\n                if (sbWidth==1) {\n                  sigCtx = ctxIdxMap[(yC<<2) + xC];\n                }\n                else if (xC+yC==0) {\n                  sigCtx = 0;\n                }\n                else {\n                  int xS = xC>>2;\n                  int yS = yC>>2;\n                  /*\n                    int prevCsbf = 0;\n\n                    if (xS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+1  +yS*sbWidth];    }\n                    if (yS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+(1+yS)*sbWidth]<<1; }\n                  */\n                  int xP = xC & 3;\n                  int yP = yC & 3;\n\n                  logtrace(LogSlice,\"posInSubset: %d,%d\\n\",xP,yP);\n                  logtrace(LogSlice,\"prevCsbf: %d\\n\",prevCsbf);\n\n                  //printf(\"%d | %d %d\\n\",prevCsbf,xP,yP);\n\n                  switch (prevCsbf) {\n                  case 0:\n                    //sigCtx = (xP+yP==0) ? 2 : (xP+yP<3) ? 1 : 0;\n                    sigCtx = (xP+yP>=3) ? 0 : (xP+yP>0) ? 1 : 2;\n                    break;\n                  case 1:\n                    sigCtx = (yP==0) ? 2 : (yP==1) ? 1 : 0;\n                    break;\n                  case 2:\n                    sigCtx = (xP==0) ? 2 : (xP==1) ? 1 : 0;\n                    break;\n                  default:\n                    sigCtx = 2;\n                    break;\n                  }\n\n                  logtrace(LogSlice,\"a) sigCtx=%d\\n\",sigCtx);\n\n                  if (cIdx==0) {\n                    if (xS+yS > 0) sigCtx+=3;\n\n                    logtrace(LogSlice,\"b) sigCtx=%d\\n\",sigCtx);\n\n                    // if log2TrafoSize==3\n                    if (sbWidth==2) { // 8x8 block\n                      sigCtx += (scanIdx==0) ? 9 : 15;\n                    } else {\n                      sigCtx += 21;\n                    }\n\n                    logtrace(LogSlice,\"c) sigCtx=%d\\n\",sigCtx);\n                  }\n                  else {\n                    // if log2TrafoSize==3\n                    if (sbWidth==2) { // 8x8 block\n                      sigCtx+=9;\n                    }\n                    else {\n                      sigCtx+=12;\n                    }\n                  }\n                }\n\n                int ctxIdxInc;\n                if (cIdx==0) { ctxIdxInc=sigCtx; }\n                else         { ctxIdxInc=27+sigCtx; }\n\n\n                ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] = ctxIdxInc;\n\n                //NOTE: when using this option, we have to include all three scanIdx in the table\n                //ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][s] = ctxIdxInc;\n              }\n          }\n\n  return true;\n}\n\nvoid free_significant_coeff_ctxIdx_lookupTable()\n{\n  free(ctxIdxLookup[0][0][0][0]);\n  ctxIdxLookup[0][0][0][0]=NULL;\n}\n\n\n\n\n#if 0\nstatic int decode_significant_coeff_flag(thread_context* tctx,\n\t\t\t\t\t int xC,int yC,\n\t\t\t\t\t const uint8_t* coded_sub_block_flag,\n\t\t\t\t\t int sbWidth,\n\t\t\t\t\t int cIdx,\n\t\t\t\t\t int scanIdx)\n{\n  logtrace(LogSlice,\"# significant_coeff_flag (xC:%d yC:%d sbWidth:%d cIdx:%d scanIdx:%d)\\n\",\n           xC,yC,sbWidth,cIdx,scanIdx);\n\n  int sigCtx;\n\n  // if log2TrafoSize==2\n  if (sbWidth==1) {\n    sigCtx = ctxIdxMap[(yC<<2) + xC];\n  }\n  else if (xC+yC==0) {\n    sigCtx = 0;\n  }\n  else {\n    int xS = xC>>2;\n    int yS = yC>>2;\n    int prevCsbf = 0;\n    if (xS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+1  +yS*sbWidth];    }\n    if (yS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+(1+yS)*sbWidth]<<1; }\n\n    int xP = xC & 3;\n    int yP = yC & 3;\n\n    logtrace(LogSlice,\"posInSubset: %d,%d\\n\",xP,yP);\n    logtrace(LogSlice,\"prevCsbf: %d\\n\",prevCsbf);\n\n    //printf(\"%d | %d %d\\n\",prevCsbf,xP,yP);\n\n    switch (prevCsbf) {\n    case 0:\n      //sigCtx = (xP+yP==0) ? 2 : (xP+yP<3) ? 1 : 0;\n      sigCtx = (xP+yP>=3) ? 0 : (xP+yP>0) ? 1 : 2;\n      break;\n    case 1:\n      sigCtx = (yP==0) ? 2 : (yP==1) ? 1 : 0;\n      break;\n    case 2:\n      sigCtx = (xP==0) ? 2 : (xP==1) ? 1 : 0;\n      break;\n    default:\n      sigCtx = 2;\n      break;\n    }\n\n    logtrace(LogSlice,\"a) sigCtx=%d\\n\",sigCtx);\n\n    if (cIdx==0) {\n      if (xS+yS > 0) sigCtx+=3;\n\n      logtrace(LogSlice,\"b) sigCtx=%d\\n\",sigCtx);\n\n      // if log2TrafoSize==3\n      if (sbWidth==2) {\n        sigCtx += (scanIdx==0) ? 9 : 15;\n      } else {\n        sigCtx += 21;\n      }\n\n      logtrace(LogSlice,\"c) sigCtx=%d\\n\",sigCtx);\n    }\n    else {\n      // if log2TrafoSize==3\n      if (sbWidth==2) {\n        sigCtx+=9;\n      }\n      else {\n        sigCtx+=12;\n      }\n    }\n  }\n\n  int ctxIdxInc;\n  if (cIdx==0) { ctxIdxInc=sigCtx; }\n  else         { ctxIdxInc=27+sigCtx; }\n\n  int context = tctx->shdr->initType*42 + ctxIdxInc;\n  logtrace(LogSlice,\"context: %d\\n\",context);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_SIGNIFICANT_COEFF_FLAG + context]);\n  return bit;\n}\n#endif\n\n\n\nstatic inline int decode_significant_coeff_flag_lookup(thread_context* tctx,\n                                                 uint8_t ctxIdxInc)\n{\n  logtrace(LogSlice,\"# significant_coeff_flag\\n\");\n  logtrace(LogSlice,\"context: %d\\n\",ctxIdxInc);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_SIGNIFICANT_COEFF_FLAG + ctxIdxInc]);\n\n  logtrace(LogSymbols,\"$1 significant_coeff_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\n\n\n\nstatic inline int decode_coeff_abs_level_greater1(thread_context* tctx,\n                                                  int cIdx, int i,\n                                                  bool firstCoeffInSubblock,\n                                                  bool firstSubblock,\n                                                  int  lastSubblock_greater1Ctx,\n                                                  int* lastInvocation_greater1Ctx,\n                                                  int* lastInvocation_coeff_abs_level_greater1_flag,\n                                                  int* lastInvocation_ctxSet, int c1)\n{\n  logtrace(LogSlice,\"# coeff_abs_level_greater1\\n\");\n\n  logtrace(LogSlice,\"  cIdx:%d i:%d firstCoeffInSB:%d firstSB:%d lastSB>1:%d last>1Ctx:%d lastLev>1:%d lastCtxSet:%d\\n\", cIdx,i,firstCoeffInSubblock,firstSubblock,lastSubblock_greater1Ctx,\n\t   *lastInvocation_greater1Ctx,\n\t   *lastInvocation_coeff_abs_level_greater1_flag,\n\t   *lastInvocation_ctxSet);\n\n  int lastGreater1Ctx;\n  int greater1Ctx;\n  int ctxSet;\n\n  logtrace(LogSlice,\"c1: %d\\n\",c1);\n\n  if (firstCoeffInSubblock) {\n    // block with real DC -> ctx 0\n    if (i==0 || cIdx>0) { ctxSet=0; }\n    else { ctxSet=2; }\n\n    if (firstSubblock) { lastGreater1Ctx=1; }\n    else { lastGreater1Ctx = lastSubblock_greater1Ctx; }\n\n    if (lastGreater1Ctx==0) { ctxSet++; }\n\n    logtrace(LogSlice,\"ctxSet: %d\\n\",ctxSet);\n\n    greater1Ctx=1;\n  }\n  else { // !firstCoeffInSubblock\n    ctxSet = *lastInvocation_ctxSet;\n    logtrace(LogSlice,\"ctxSet (old): %d\\n\",ctxSet);\n\n    greater1Ctx = *lastInvocation_greater1Ctx;\n    if (greater1Ctx>0) {\n      int lastGreater1Flag=*lastInvocation_coeff_abs_level_greater1_flag;\n      if (lastGreater1Flag==1) greater1Ctx=0;\n      else { /*if (greater1Ctx>0)*/ greater1Ctx++; }\n    }\n  }\n\n  ctxSet = c1; // use HM algo\n\n  int ctxIdxInc = (ctxSet*4) + (greater1Ctx>=3 ? 3 : greater1Ctx);\n\n  if (cIdx>0) { ctxIdxInc+=16; }\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_COEFF_ABS_LEVEL_GREATER1_FLAG + ctxIdxInc]);\n\n  *lastInvocation_greater1Ctx = greater1Ctx;\n  *lastInvocation_coeff_abs_level_greater1_flag = bit;\n  *lastInvocation_ctxSet = ctxSet;\n\n  //logtrace(LogSymbols,\"$1 coeff_abs_level_greater1=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_coeff_abs_level_greater2(thread_context* tctx,\n\t\t\t\t\t   int cIdx, // int i,int n,\n\t\t\t\t\t   int ctxSet)\n{\n  logtrace(LogSlice,\"# coeff_abs_level_greater2\\n\");\n\n  int ctxIdxInc = ctxSet;\n\n  if (cIdx>0) ctxIdxInc+=4;\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_COEFF_ABS_LEVEL_GREATER2_FLAG + ctxIdxInc]);\n\n  logtrace(LogSymbols,\"$1 coeff_abs_level_greater2=%d\\n\",bit);\n\n  return bit;\n}\n\n\n#define MAX_PREFIX 64\n\nstatic int decode_coeff_abs_level_remaining(thread_context* tctx,\n                                            int cRiceParam)\n{\n  logtrace(LogSlice,\"# decode_coeff_abs_level_remaining\\n\");\n\n  int prefix=-1;\n  int codeword=0;\n  do {\n    prefix++;\n    codeword = decode_CABAC_bypass(&tctx->cabac_decoder);\n\n    if (prefix>MAX_PREFIX) {\n      return 0; // TODO: error\n    }\n  }\n  while (codeword);\n\n  // prefix = nb. 1 bits\n\n  int value;\n\n  if (prefix <= 3) {\n    // when code only TR part (level < TRMax)\n\n    codeword = decode_CABAC_FL_bypass(&tctx->cabac_decoder, cRiceParam);\n    value = (prefix<<cRiceParam) + codeword;\n  }\n  else {\n    // Suffix coded with EGk. Note that the unary part of EGk is already\n    // included in the 'prefix' counter above.\n\n    codeword = decode_CABAC_FL_bypass(&tctx->cabac_decoder, prefix-3+cRiceParam);\n    value = (((1<<(prefix-3))+3-1)<<cRiceParam)+codeword;\n  }\n\n  logtrace(LogSymbols,\"$1 coeff_abs_level_remaining=%d\\n\",value);\n\n  return value;\n}\n\n\nstatic int decode_merge_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# merge_flag\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_MERGE_FLAG]);\n\n  logtrace(LogSymbols,\"$1 merge_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_merge_idx(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# merge_idx\\n\");\n\n  if (tctx->shdr->MaxNumMergeCand <= 1) {\n    logtrace(LogSymbols,\"$1 merge_idx=%d\\n\",0);\n    return 0;\n  }\n\n  // TU coding, first bin is CABAC, remaining are bypass.\n  // cMax = MaxNumMergeCand-1\n\n  int idx = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_MERGE_IDX]);\n\n  if (idx==0) {\n    // nothing\n  }\n  else {\n    idx=1;\n\n    while (idx<tctx->shdr->MaxNumMergeCand-1) {\n      if (decode_CABAC_bypass(&tctx->cabac_decoder)) {\n        idx++;\n      }\n      else {\n        break;\n      }\n    }\n  }\n\n  logtrace(LogSlice,\"> merge_idx = %d\\n\",idx);\n  logtrace(LogSymbols,\"$1 merge_idx=%d\\n\",idx);\n\n  return idx;\n}\n\n\nstatic int decode_pred_mode_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# pred_mode_flag\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_PRED_MODE_FLAG]);\n\n  logtrace(LogSymbols,\"$1 pred_mode=%d\\n\",bit);\n  return bit;\n}\n\nstatic int decode_mvp_lx_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# mvp_lx_flag\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_MVP_LX_FLAG]);\n\n  logtrace(LogSymbols,\"$1 mvp_lx_flag=%d\\n\",bit);\n  return bit;\n}\n\nstatic int decode_rqt_root_cbf(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# rqt_root_cbf\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_RQT_ROOT_CBF]);\n\n  logtrace(LogSymbols,\"$1 rqt_root_cbf=%d\\n\",bit);\n  return bit;\n}\n\nstatic int decode_ref_idx_lX(thread_context* tctx, int numRefIdxLXActive)\n{\n  logtrace(LogSlice,\"# ref_idx_lX\\n\");\n\n  int cMax = numRefIdxLXActive-1;\n\n  if (cMax==0) {\n    logtrace(LogSlice,\"> ref_idx = 0 (cMax==0)\\n\");\n    return 0;\n  } // do check for single reference frame here\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_REF_IDX_LX + 0]);\n\n  int idx=0;\n\n  while (bit) {\n    idx++;\n    if (idx==cMax) { break; }\n\n    if (idx==1) {\n      bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_REF_IDX_LX + 1]);\n    }\n    else {\n      bit = decode_CABAC_bypass(&tctx->cabac_decoder);\n    }\n  }\n\n  logtrace(LogSlice,\"> ref_idx = %d\\n\",idx);\n\n  logtrace(LogSymbols,\"$1 ref_idx_lX=%d\\n\",idx);\n  return idx;\n}\n\n\nstatic enum InterPredIdc  decode_inter_pred_idc(thread_context* tctx,\n                                               int x0, int y0,\n                                               int nPbW, int nPbH,\n                                               int ctDepth)\n{\n  logtrace(LogSlice,\"# inter_pred_idc\\n\");\n\n  int value;\n\n  context_model* model = &tctx->ctx_model[CONTEXT_MODEL_INTER_PRED_IDC];\n\n  if (nPbW+nPbH==12) {\n    value = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &model[4]);\n  }\n  else {\n    int bit0 = decode_CABAC_bit(&tctx->cabac_decoder,\n                                &model[ctDepth]);\n    if (bit0==0) {\n      value = decode_CABAC_bit(&tctx->cabac_decoder,\n                               &model[4]);\n    }\n    else {\n      value = 2;\n    }\n  }\n\n  logtrace(LogSlice,\"> inter_pred_idc = %d (%s)\\n\",value,\n           value==0 ? \"L0\" : (value==1 ? \"L1\" : \"BI\"));\n\n  logtrace(LogSymbols,\"$1 decode_inter_pred_idx=%d\\n\",value+1);\n\n  return (enum InterPredIdc) (value+1);\n}\n\n\nstatic int  decode_explicit_rdpcm_flag(thread_context* tctx,int cIdx)\n{\n  context_model* model = &tctx->ctx_model[CONTEXT_MODEL_RDPCM_FLAG];\n  int value = decode_CABAC_bit(&tctx->cabac_decoder, &model[cIdx ? 1 : 0]);\n  return value;\n}\n\n\nstatic int  decode_explicit_rdpcm_dir(thread_context* tctx,int cIdx)\n{\n  context_model* model = &tctx->ctx_model[CONTEXT_MODEL_RDPCM_DIR];\n  int value = decode_CABAC_bit(&tctx->cabac_decoder, &model[cIdx ? 1 : 0]);\n  return value;\n}\n\n\n\n/* Take CtbAddrInTS and compute\n   -> CtbAddrInRS, CtbX, CtbY\n */\nbool setCtbAddrFromTS(thread_context* tctx)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  if (tctx->CtbAddrInTS < sps.PicSizeInCtbsY) {\n    tctx->CtbAddrInRS = tctx->img->get_pps().CtbAddrTStoRS[tctx->CtbAddrInTS];\n\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return false;\n  }\n  else {\n    tctx->CtbAddrInRS = sps.PicSizeInCtbsY;\n\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return true;\n  }\n}\n\n// returns true when we reached the end of the image (ctbAddr==picSizeInCtbsY)\nbool advanceCtbAddr(thread_context* tctx)\n{\n    tctx->CtbAddrInTS++;\n\n    return setCtbAddrFromTS(tctx);\n}\n\n\nvoid read_sao(thread_context* tctx, int xCtb,int yCtb,\n              int CtbAddrInSliceSeg)\n{\n  slice_segment_header* shdr = tctx->shdr;\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n\n  logtrace(LogSlice,\"# read_sao(%d,%d)\\n\",xCtb,yCtb);\n\n  sao_info saoinfo;\n  memset(&saoinfo,0,sizeof(sao_info));\n  logtrace(LogSlice,\"sizeof saoinfo: %d\\n\",sizeof(sao_info));\n\n\n  char sao_merge_left_flag = 0;\n  char sao_merge_up_flag = 0;\n\n  if (xCtb>0) {\n    //char leftCtbInSliceSeg = (CtbAddrInSliceSeg>0);\n    char leftCtbInSliceSeg = (tctx->CtbAddrInRS > shdr->SliceAddrRS);\n    char leftCtbInTile = (pps.TileIdRS[xCtb   + yCtb * sps.PicWidthInCtbsY] ==\n                          pps.TileIdRS[xCtb-1 + yCtb * sps.PicWidthInCtbsY]);\n\n    if (leftCtbInSliceSeg && leftCtbInTile) {\n      sao_merge_left_flag = decode_sao_merge_flag(tctx);\n      logtrace(LogSlice,\"sao_merge_left_flag: %d\\n\",sao_merge_left_flag);\n    }\n  }\n\n  if (yCtb>0 && sao_merge_left_flag==0) {\n    logtrace(LogSlice,\"CtbAddrInRS:%d PicWidthInCtbsY:%d slice_segment_address:%d\\n\",\n             tctx->CtbAddrInRS,\n             sps.PicWidthInCtbsY,\n             shdr->slice_segment_address);\n    char upCtbInSliceSeg = (tctx->CtbAddrInRS - sps.PicWidthInCtbsY) >= shdr->SliceAddrRS;\n    char upCtbInTile = (pps.TileIdRS[xCtb +  yCtb    * sps.PicWidthInCtbsY] ==\n                        pps.TileIdRS[xCtb + (yCtb-1) * sps.PicWidthInCtbsY]);\n\n    if (upCtbInSliceSeg && upCtbInTile) {\n      sao_merge_up_flag = decode_sao_merge_flag(tctx);\n      logtrace(LogSlice,\"sao_merge_up_flag: %d\\n\",sao_merge_up_flag);\n    }\n  }\n\n  if (!sao_merge_up_flag && !sao_merge_left_flag) {\n    int nChroma = 3;\n    if (sps.ChromaArrayType == CHROMA_MONO) nChroma=1;\n\n    for (int cIdx=0; cIdx<nChroma; cIdx++) {\n      if ((shdr->slice_sao_luma_flag && cIdx==0) ||\n          (shdr->slice_sao_chroma_flag && cIdx>0)) {\n\n        uint8_t SaoTypeIdx = 0;\n\n        if (cIdx==0) {\n          char sao_type_idx_luma = decode_sao_type_idx(tctx);\n          logtrace(LogSlice,\"sao_type_idx_luma: %d\\n\", sao_type_idx_luma);\n          saoinfo.SaoTypeIdx = SaoTypeIdx = sao_type_idx_luma;\n        }\n        else if (cIdx==1) {\n          char sao_type_idx_chroma = decode_sao_type_idx(tctx);\n          logtrace(LogSlice,\"sao_type_idx_chroma: %d\\n\", sao_type_idx_chroma);\n          SaoTypeIdx = sao_type_idx_chroma;\n          saoinfo.SaoTypeIdx |= SaoTypeIdx<<(2*1);\n          saoinfo.SaoTypeIdx |= SaoTypeIdx<<(2*2);  // set for both chroma components\n        }\n        else {\n          // SaoTypeIdx = 0\n\n          SaoTypeIdx = (saoinfo.SaoTypeIdx >> (2*cIdx)) & 0x3;\n        }\n\n        if (SaoTypeIdx != 0) {\n          for (int i=0;i<4;i++) {\n            saoinfo.saoOffsetVal[cIdx][i] = decode_sao_offset_abs(tctx, img->get_bit_depth(cIdx));\n            logtrace(LogSlice,\"saoOffsetVal[%d][%d] = %d\\n\",cIdx,i, saoinfo.saoOffsetVal[cIdx][i]);\n          }\n\n          int sign[4];\n          if (SaoTypeIdx==1) {\n            for (int i=0;i<4;i++) {\n              if (saoinfo.saoOffsetVal[cIdx][i] != 0) {\n                sign[i] = decode_sao_offset_sign(tctx) ? -1 : 1;\n              }\n              else {\n                sign[i] = 0; // not really required, but compiler warns about uninitialized values\n              }\n            }\n\n            saoinfo.sao_band_position[cIdx] = decode_sao_band_position(tctx);\n          }\n          else {\n            uint8_t SaoEoClass = 0;\n\n            sign[0] = sign[1] =  1;\n            sign[2] = sign[3] = -1;\n\n            if (cIdx==0) {\n              saoinfo.SaoEoClass = SaoEoClass = decode_sao_class(tctx);\n            }\n            else if (cIdx==1) {\n              SaoEoClass = decode_sao_class(tctx);\n              saoinfo.SaoEoClass |= SaoEoClass << (2*1);\n              saoinfo.SaoEoClass |= SaoEoClass << (2*2);\n            }\n\n            logtrace(LogSlice,\"SaoEoClass[%d] = %d\\n\",cIdx,SaoEoClass);\n          }\n\n          int log2OffsetScale;\n\n          if (cIdx==0) {\n            log2OffsetScale = pps.range_extension.log2_sao_offset_scale_luma;\n          }\n          else {\n            log2OffsetScale = pps.range_extension.log2_sao_offset_scale_chroma;\n          }\n\n          for (int i=0;i<4;i++) {\n            saoinfo.saoOffsetVal[cIdx][i] = sign[i]*(saoinfo.saoOffsetVal[cIdx][i] << log2OffsetScale);\n          }\n        }\n      }\n    }\n\n    img->set_sao_info(xCtb,yCtb,  &saoinfo);\n  }\n\n\n  if (sao_merge_left_flag) {\n    img->set_sao_info(xCtb,yCtb,  img->get_sao_info(xCtb-1,yCtb));\n  }\n\n  if (sao_merge_up_flag) {\n    img->set_sao_info(xCtb,yCtb,  img->get_sao_info(xCtb,yCtb-1));\n  }\n}\n\n\nvoid read_coding_tree_unit(thread_context* tctx)\n{\n  slice_segment_header* shdr = tctx->shdr;\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n\n  int xCtb = (tctx->CtbAddrInRS % sps.PicWidthInCtbsY);\n  int yCtb = (tctx->CtbAddrInRS / sps.PicWidthInCtbsY);\n  int xCtbPixels = xCtb << sps.Log2CtbSizeY;\n  int yCtbPixels = yCtb << sps.Log2CtbSizeY;\n\n  logtrace(LogSlice,\"----- decode CTB %d;%d (%d;%d) POC=%d, SliceAddrRS=%d\\n\",\n           xCtbPixels,yCtbPixels, xCtb,yCtb,\n           tctx->img->PicOrderCntVal, tctx->shdr->SliceAddrRS);\n\n  img->set_SliceAddrRS(xCtb, yCtb, tctx->shdr->SliceAddrRS);\n\n  img->set_SliceHeaderIndex(xCtbPixels,yCtbPixels, shdr->slice_index);\n\n  int CtbAddrInSliceSeg = tctx->CtbAddrInRS - shdr->slice_segment_address;\n\n  if (shdr->slice_sao_luma_flag || shdr->slice_sao_chroma_flag)\n    {\n      read_sao(tctx, xCtb,yCtb, CtbAddrInSliceSeg);\n    }\n\n  read_coding_quadtree(tctx, xCtbPixels, yCtbPixels, sps.Log2CtbSizeY, 0);\n}\n\n\nLIBDE265_INLINE static int luma_pos_to_ctbAddrRS(const seq_parameter_set* sps, int x,int y)\n{\n  int ctbX = x >> sps->Log2CtbSizeY;\n  int ctbY = y >> sps->Log2CtbSizeY;\n\n  return ctbY * sps->PicWidthInCtbsY + ctbX;\n}\n\n\nint check_CTB_available(const de265_image* img,\n                        int xC,int yC, int xN,int yN)\n{\n  // check whether neighbor is outside of frame\n\n  if (xN < 0 || yN < 0) { return 0; }\n  if (xN >= img->get_sps().pic_width_in_luma_samples)  { return 0; }\n  if (yN >= img->get_sps().pic_height_in_luma_samples) { return 0; }\n\n\n  int current_ctbAddrRS  = luma_pos_to_ctbAddrRS(&img->get_sps(), xC,yC);\n  int neighbor_ctbAddrRS = luma_pos_to_ctbAddrRS(&img->get_sps(), xN,yN);\n\n  // TODO: check if this is correct (6.4.1)\n\n  if (img->get_SliceAddrRS_atCtbRS(current_ctbAddrRS) !=\n      img->get_SliceAddrRS_atCtbRS(neighbor_ctbAddrRS)) {\n    return 0;\n  }\n\n  // check if both CTBs are in the same tile.\n\n  if (img->get_pps().TileIdRS[current_ctbAddrRS] !=\n      img->get_pps().TileIdRS[neighbor_ctbAddrRS]) {\n    return 0;\n  }\n\n  return 1;\n}\n\n\nint residual_coding(thread_context* tctx,\n                    int x0, int y0,  // position of TU in frame\n                    int log2TrafoSize,\n                    int cIdx)\n{\n  logtrace(LogSlice,\"- residual_coding x0:%d y0:%d log2TrafoSize:%d cIdx:%d\\n\",x0,y0,log2TrafoSize,cIdx);\n\n  //slice_segment_header* shdr = tctx->shdr;\n\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n\n  enum PredMode PredMode = img->get_pred_mode(x0,y0);\n\n  if (cIdx==0) {\n    img->set_nonzero_coefficient(x0,y0,log2TrafoSize);\n  }\n\n\n  if (pps.transform_skip_enabled_flag &&\n      !tctx->cu_transquant_bypass_flag &&\n      (log2TrafoSize <= pps.Log2MaxTransformSkipSize))\n    {\n      tctx->transform_skip_flag[cIdx] = decode_transform_skip_flag(tctx,cIdx);\n    }\n  else\n    {\n      tctx->transform_skip_flag[cIdx] = 0;\n    }\n\n\n  tctx->explicit_rdpcm_flag = false;\n\n  if (PredMode == MODE_INTER && sps.range_extension.explicit_rdpcm_enabled_flag &&\n      ( tctx->transform_skip_flag[cIdx] || tctx->cu_transquant_bypass_flag))\n    {\n      tctx->explicit_rdpcm_flag = decode_explicit_rdpcm_flag(tctx,cIdx);\n      if (tctx->explicit_rdpcm_flag) {\n        tctx->explicit_rdpcm_dir = decode_explicit_rdpcm_dir(tctx,cIdx);\n      }\n\n      //printf(\"EXPLICIT RDPCM %d;%d\\n\",x0,y0);\n    }\n  else\n    {\n      tctx->explicit_rdpcm_flag = false;\n    }\n\n\n\n  // sbType for persistent_rice_adaptation_enabled_flag\n\n  int sbType = (cIdx==0) ? 2 : 0;\n  if (tctx->transform_skip_flag[cIdx] || tctx->cu_transquant_bypass_flag) {\n    sbType++;\n  }\n\n\n  // --- decode position of last coded coefficient ---\n\n  int last_significant_coeff_x_prefix =\n    decode_last_significant_coeff_prefix(tctx,log2TrafoSize,cIdx,\n                                         &tctx->ctx_model[CONTEXT_MODEL_LAST_SIGNIFICANT_COEFFICIENT_X_PREFIX]);\n\n  int last_significant_coeff_y_prefix =\n    decode_last_significant_coeff_prefix(tctx,log2TrafoSize,cIdx,\n                                         &tctx->ctx_model[CONTEXT_MODEL_LAST_SIGNIFICANT_COEFFICIENT_Y_PREFIX]);\n\n\n  // TODO: we can combine both FL-bypass calls into one, but the gain may be limited...\n\n  int LastSignificantCoeffX;\n  if (last_significant_coeff_x_prefix > 3) {\n    int nBits = (last_significant_coeff_x_prefix>>1)-1;\n    int last_significant_coeff_x_suffix = decode_CABAC_FL_bypass(&tctx->cabac_decoder,nBits);\n\n    LastSignificantCoeffX =\n      ((2+(last_significant_coeff_x_prefix & 1)) << nBits) + last_significant_coeff_x_suffix;\n  }\n  else {\n    LastSignificantCoeffX = last_significant_coeff_x_prefix;\n  }\n\n  int LastSignificantCoeffY;\n  if (last_significant_coeff_y_prefix > 3) {\n    int nBits = (last_significant_coeff_y_prefix>>1)-1;\n    int last_significant_coeff_y_suffix = decode_CABAC_FL_bypass(&tctx->cabac_decoder,nBits);\n\n    LastSignificantCoeffY =\n      ((2+(last_significant_coeff_y_prefix & 1)) << nBits) + last_significant_coeff_y_suffix;\n  }\n  else {\n    LastSignificantCoeffY = last_significant_coeff_y_prefix;\n  }\n\n\n\n  // --- determine scanIdx ---\n\n  int scanIdx;\n\n  if (PredMode == MODE_INTRA) {\n    if (cIdx==0) {\n      scanIdx = get_intra_scan_idx(log2TrafoSize, img->get_IntraPredMode(x0,y0),  cIdx, &sps);\n      //printf(\"luma scan idx=%d <- intra mode=%d\\n\",scanIdx, img->get_IntraPredMode(x0,y0));\n    }\n    else {\n      scanIdx = get_intra_scan_idx(log2TrafoSize, img->get_IntraPredModeC(x0,y0), cIdx, &sps);\n      //printf(\"chroma scan idx=%d <- intra mode=%d chroma:%d trsize:%d\\n\",scanIdx,\n      //       img->get_IntraPredModeC(x0,y0), sps->chroma_format_idc, 1<<log2TrafoSize);\n    }\n  }\n  else {\n    scanIdx=0;\n  }\n\n  if (scanIdx==2) {\n    std::swap(LastSignificantCoeffX, LastSignificantCoeffY);\n  }\n\n  logtrace(LogSlice,\"LastSignificantCoeff: x=%d;y=%d\\n\",LastSignificantCoeffX,LastSignificantCoeffY);\n\n  const position* ScanOrderSub = get_scan_order(log2TrafoSize-2, scanIdx);\n  const position* ScanOrderPos = get_scan_order(2, scanIdx);\n\n  logtrace(LogSlice,\"ScanOrderPos: \");\n  for (int n=0;n<4*4;n++)\n    logtrace(LogSlice,\"*%d,%d \", ScanOrderPos[n].x, ScanOrderPos[n].y);\n  logtrace(LogSlice,\"*\\n\");\n\n\n  // --- find last sub block and last scan pos ---\n\n  int xC,yC;\n\n  scan_position lastScanP = get_scan_position(LastSignificantCoeffX, LastSignificantCoeffY,\n                                              scanIdx, log2TrafoSize);\n\n  int lastScanPos  = lastScanP.scanPos;\n  int lastSubBlock = lastScanP.subBlock;\n\n\n  int sbWidth = 1<<(log2TrafoSize-2);\n\n  uint8_t coded_sub_block_neighbors[32/4*32/4];\n  memset(coded_sub_block_neighbors,0,sbWidth*sbWidth);\n\n  int  c1 = 1;\n  bool firstSubblock = true;           // for coeff_abs_level_greater1_flag context model\n  int  lastSubblock_greater1Ctx=false; /* for coeff_abs_level_greater1_flag context model\n                                          (initialization not strictly needed)\n                                       */\n\n#ifdef DE265_LOG_TRACE\n  int16_t TransCoeffLevel[32 * 32];\n  memset(TransCoeffLevel,0, sizeof(uint16_t)*32*32);\n#endif\n\n  int CoeffStride = 1<<log2TrafoSize;\n\n  int  lastInvocation_greater1Ctx=0;\n  int  lastInvocation_coeff_abs_level_greater1_flag=0;\n  int  lastInvocation_ctxSet=0;\n\n\n\n  // ----- decode coefficients -----\n\n  tctx->nCoeff[cIdx] = 0;\n\n\n  // i - subblock index\n  // n - coefficient index in subblock\n\n  for (int i=lastSubBlock;i>=0;i--) {\n    position S = ScanOrderSub[i];\n    int inferSbDcSigCoeffFlag=0;\n\n    logtrace(LogSlice,\"sub block scan idx: %d\\n\",i);\n\n\n    // --- check whether this sub-block is coded ---\n\n    int sub_block_is_coded = 0;\n\n    if ((i<lastSubBlock) && (i>0)) {\n      sub_block_is_coded = decode_coded_sub_block_flag(tctx, cIdx,\n                                                       coded_sub_block_neighbors[S.x+S.y*sbWidth]);\n      inferSbDcSigCoeffFlag=1;\n    }\n    else if (i==0 || i==lastSubBlock) {\n      // first (DC) and last sub-block are always coded\n      // - the first will most probably contain coefficients\n      // - the last obviously contains the last coded coefficient\n\n      sub_block_is_coded = 1;\n    }\n\n    if (sub_block_is_coded) {\n      if (S.x > 0) coded_sub_block_neighbors[S.x-1 + S.y  *sbWidth] |= 1;\n      if (S.y > 0) coded_sub_block_neighbors[S.x + (S.y-1)*sbWidth] |= 2;\n    }\n\n\n    // ----- find significant coefficients in this sub-block -----\n\n    int16_t  coeff_value[16];\n    int8_t   coeff_scan_pos[16];\n    int8_t   coeff_sign[16];\n    int8_t   coeff_has_max_base_level[16];\n    int nCoefficients=0;\n\n\n    if (sub_block_is_coded) {\n      int x0 = S.x<<2;\n      int y0 = S.y<<2;\n\n      int log2w = log2TrafoSize-2;\n      int prevCsbf = coded_sub_block_neighbors[S.x+S.y*sbWidth];\n      uint8_t* ctxIdxMap = ctxIdxLookup[log2w][!!cIdx][!!scanIdx][prevCsbf];\n\n      logdebug(LogSlice,\"log2w:%d cIdx:%d scanIdx:%d prevCsbf:%d\\n\",\n               log2w,cIdx,scanIdx,prevCsbf);\n\n\n      // set the last coded coefficient in the last subblock\n\n      int last_coeff =  (i==lastSubBlock) ? lastScanPos-1 : 15;\n\n      if (i==lastSubBlock) {\n        coeff_value[nCoefficients] = 1;\n        coeff_has_max_base_level[nCoefficients] = 1;\n        coeff_scan_pos[nCoefficients] = lastScanPos;\n        nCoefficients++;\n      }\n\n\n      // --- decode all coefficients' significant_coeff flags except for the DC coefficient ---\n\n      for (int n= last_coeff ; n>0 ; n--) {\n        int subX = ScanOrderPos[n].x;\n        int subY = ScanOrderPos[n].y;\n        xC = x0 + subX;\n        yC = y0 + subY;\n\n\n        // for all AC coefficients in sub-block, a significant_coeff flag is coded\n\n        int ctxInc;\n        if (sps.range_extension.transform_skip_context_enabled_flag &&\n            (tctx->cu_transquant_bypass_flag || tctx->transform_skip_flag[cIdx])) {\n          ctxInc = ( cIdx == 0 ) ? 42 : (16+27);\n        }\n        else {\n          ctxInc = ctxIdxMap[xC+(yC<<log2TrafoSize)];\n        }\n\n        logtrace(LogSlice,\"trafoSize: %d\\n\",1<<log2TrafoSize);\n\n        int significant_coeff = decode_significant_coeff_flag_lookup(tctx, ctxInc);\n\n        if (significant_coeff) {\n          coeff_value[nCoefficients] = 1;\n          coeff_has_max_base_level[nCoefficients] = 1;\n          coeff_scan_pos[nCoefficients] = n;\n          nCoefficients++;\n\n          // since we have a coefficient in the sub-block,\n          // we cannot infer the DC coefficient anymore\n          inferSbDcSigCoeffFlag = 0;\n        }\n      }\n\n\n      // --- decode DC coefficient significance ---\n\n      if (last_coeff>=0) // last coded coefficient (always set to 1) is not the DC coefficient\n        {\n          if (inferSbDcSigCoeffFlag==0) {\n            // if we cannot infert the DC coefficient, it is coded\n\n            int ctxInc;\n            if (sps.range_extension.transform_skip_context_enabled_flag &&\n                (tctx->cu_transquant_bypass_flag || tctx->transform_skip_flag[cIdx])) {\n              ctxInc = ( cIdx == 0 ) ? 42 : (16+27);\n            }\n            else {\n              ctxInc = ctxIdxMap[x0+(y0<<log2TrafoSize)];\n            }\n\n            int significant_coeff = decode_significant_coeff_flag_lookup(tctx, ctxInc);\n\n\n            if (significant_coeff) {\n              coeff_value[nCoefficients] = 1;\n              coeff_has_max_base_level[nCoefficients] = 1;\n              coeff_scan_pos[nCoefficients] = 0;\n              nCoefficients++;\n            }\n          }\n          else {\n            // we can infer that the DC coefficient must be present\n            coeff_value[nCoefficients] = 1;\n            coeff_has_max_base_level[nCoefficients] = 1;\n            coeff_scan_pos[nCoefficients] = 0;\n            nCoefficients++;\n          }\n        }\n\n    }\n\n\n    /*\n      logtrace(LogSlice,\"significant_coeff_flags:\\n\");\n      for (int y=0;y<4;y++) {\n      logtrace(LogSlice,\"  \");\n      for (int x=0;x<4;x++) {\n      logtrace(LogSlice,\"*%d \",significant_coeff_flag[y][x]);\n      }\n      logtrace(LogSlice,\"*\\n\");\n      }\n    */\n\n\n    if (nCoefficients) {\n      int ctxSet;\n      if (i==0 || cIdx>0) { ctxSet=0; }\n      else { ctxSet=2; }\n\n      if (c1==0) { ctxSet++; }\n      c1=1;\n\n\n      // --- decode greater-1 flags ---\n\n      int newLastGreater1ScanPos=-1;\n\n      int lastGreater1Coefficient = libde265_min(8,nCoefficients);\n      for (int c=0;c<lastGreater1Coefficient;c++) {\n        int greater1_flag =\n          decode_coeff_abs_level_greater1(tctx, cIdx,i,\n                                          c==0,\n                                          firstSubblock,\n                                          lastSubblock_greater1Ctx,\n                                          &lastInvocation_greater1Ctx,\n                                          &lastInvocation_coeff_abs_level_greater1_flag,\n                                          &lastInvocation_ctxSet, ctxSet);\n\n        if (greater1_flag) {\n          coeff_value[c]++;\n\n          c1=0;\n\n          if (newLastGreater1ScanPos == -1) {\n            newLastGreater1ScanPos=c;\n          }\n        }\n        else {\n          coeff_has_max_base_level[c] = 0;\n\n          if (c1<3 && c1>0) {\n            c1++;\n          }\n        }\n      }\n\n      firstSubblock = false;\n      lastSubblock_greater1Ctx = lastInvocation_greater1Ctx;\n\n\n      // --- decode greater-2 flag ---\n\n      if (newLastGreater1ScanPos != -1) {\n        int flag = decode_coeff_abs_level_greater2(tctx,cIdx, lastInvocation_ctxSet);\n        coeff_value[newLastGreater1ScanPos] += flag;\n        coeff_has_max_base_level[newLastGreater1ScanPos] = flag;\n      }\n\n\n      // --- decode coefficient signs ---\n\n      int signHidden;\n\n\n      IntraPredMode predModeIntra;\n      if (cIdx==0) predModeIntra = img->get_IntraPredMode(x0,y0);\n      else         predModeIntra = img->get_IntraPredModeC(x0,y0);\n\n\n      if (tctx->cu_transquant_bypass_flag ||\n          (PredMode == MODE_INTRA &&\n           sps.range_extension.implicit_rdpcm_enabled_flag &&\n           tctx->transform_skip_flag[cIdx] &&\n           ( predModeIntra == 10 || predModeIntra == 26 )) ||\n          tctx->explicit_rdpcm_flag)\n        {\n          signHidden = 0;\n        }\n      else\n        {\n          signHidden = (coeff_scan_pos[0]-coeff_scan_pos[nCoefficients-1] > 3);\n        }\n\n\n      for (int n=0;n<nCoefficients-1;n++) {\n        coeff_sign[n] = decode_CABAC_bypass(&tctx->cabac_decoder);\n        logtrace(LogSlice,\"sign[%d] = %d\\n\", n, coeff_sign[n]);\n      }\n\n      // n==nCoefficients-1\n      if (!pps.sign_data_hiding_flag || !signHidden) {\n        coeff_sign[nCoefficients-1] = decode_CABAC_bypass(&tctx->cabac_decoder);\n        logtrace(LogSlice,\"sign[%d] = %d\\n\", nCoefficients-1, coeff_sign[nCoefficients-1]);\n      }\n      else {\n        coeff_sign[nCoefficients-1] = 0;\n      }\n\n\n      // --- decode coefficient value ---\n\n      int sumAbsLevel=0;\n      int uiGoRiceParam;\n\n      if (sps.range_extension.persistent_rice_adaptation_enabled_flag==0) {\n        uiGoRiceParam = 0;\n      }\n      else {\n        uiGoRiceParam = tctx->StatCoeff[sbType]/4;\n      }\n\n      // printf(\"initial uiGoRiceParam=%d\\n\",uiGoRiceParam);\n      bool firstCoeffWithAbsLevelRemaining = true;\n\n      for (int n=0;n<nCoefficients;n++) {\n        int baseLevel = coeff_value[n];\n\n        int coeff_abs_level_remaining;\n\n        // printf(\"coeff %d/%d, uiRiceParam: %d\\n\",n,nCoefficients,uiGoRiceParam);\n\n        if (coeff_has_max_base_level[n]) {\n          coeff_abs_level_remaining =\n            decode_coeff_abs_level_remaining(tctx, uiGoRiceParam);\n\n          if (sps.range_extension.persistent_rice_adaptation_enabled_flag == 0) {\n            // (2014.10 / 9-20)\n            if (baseLevel + coeff_abs_level_remaining > 3*(1<<uiGoRiceParam)) {\n              uiGoRiceParam++;\n              if (uiGoRiceParam>4) uiGoRiceParam=4;\n            }\n          }\n          else {\n            if (baseLevel + coeff_abs_level_remaining > 3*(1<<uiGoRiceParam))\n              uiGoRiceParam++;\n          }\n\n          // persistent_rice_adaptation_enabled_flag\n          if (sps.range_extension.persistent_rice_adaptation_enabled_flag &&\n              firstCoeffWithAbsLevelRemaining) {\n            if (coeff_abs_level_remaining >= (3 << (tctx->StatCoeff[sbType]/4 ))) {\n              tctx->StatCoeff[sbType]++;\n            }\n            else if (2*coeff_abs_level_remaining < (1 << (tctx->StatCoeff[sbType]/4 )) &&\n                     tctx->StatCoeff[sbType] > 0) {\n              tctx->StatCoeff[sbType]--;\n            }\n          }\n\n          firstCoeffWithAbsLevelRemaining=false;\n        }\n        else {\n          coeff_abs_level_remaining = 0;\n        }\n\n        logtrace(LogSlice, \"coeff_abs_level_remaining=%d\\n\",coeff_abs_level_remaining);\n\n\n        int16_t currCoeff = baseLevel + coeff_abs_level_remaining;\n        if (coeff_sign[n]) {\n          currCoeff = -currCoeff;\n        }\n\n        if (pps.sign_data_hiding_flag && signHidden) {\n          sumAbsLevel += currCoeff;\n\n          if (n==nCoefficients-1 && (sumAbsLevel & 1)) {\n            currCoeff = -currCoeff;\n          }\n        }\n\n        logtrace(LogSlice, \"quantized coefficient=%d\\n\",currCoeff);\n\n#ifdef DE265_LOG_TRACE\n        //TransCoeffLevel[yC*CoeffStride + xC] = currCoeff;\n#endif\n\n        // put coefficient in list\n        int p = coeff_scan_pos[n];\n        xC = (S.x<<2) + ScanOrderPos[p].x;\n        yC = (S.y<<2) + ScanOrderPos[p].y;\n\n        tctx->coeffList[cIdx][ tctx->nCoeff[cIdx] ] = currCoeff;\n        tctx->coeffPos [cIdx][ tctx->nCoeff[cIdx] ] = xC + yC*CoeffStride;\n        tctx->nCoeff[cIdx]++;\n\n        //printf(\"%d \",currCoeff);\n      }  // iterate through coefficients in sub-block\n\n      //printf(\" (%d;%d)\\n\",x0,y0);\n\n    }  // if nonZero\n  }  // next sub-block\n\n  return DE265_OK;\n}\n\n\nstatic void decode_TU(thread_context* tctx,\n                      int x0,int y0,\n                      int xCUBase,int yCUBase,\n                      int nT, int cIdx, enum PredMode cuPredMode, bool cbf)\n{\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n\n  int residualDpcm = 0;\n\n  if (cuPredMode == MODE_INTRA) // if intra mode\n    {\n      enum IntraPredMode intraPredMode;\n\n      if (cIdx==0) {\n        intraPredMode = img->get_IntraPredMode(x0,y0);\n      }\n      else {\n        const int SubWidthC  = sps.SubWidthC;\n        const int SubHeightC = sps.SubHeightC;\n\n        intraPredMode = img->get_IntraPredModeC(x0*SubWidthC,y0*SubHeightC);\n      }\n\n      if (intraPredMode<0 || intraPredMode>=35) {\n        // TODO: ERROR\n        intraPredMode = INTRA_DC;\n      }\n\n      decode_intra_prediction(img, x0,y0, intraPredMode, nT, cIdx);\n\n\n      residualDpcm = sps.range_extension.implicit_rdpcm_enabled_flag &&\n        (tctx->cu_transquant_bypass_flag || tctx->transform_skip_flag[cIdx]) &&\n        (intraPredMode == 10 || intraPredMode == 26);\n\n      if (residualDpcm && intraPredMode == 26)\n        residualDpcm = 2;\n    }\n  else // INTER\n    {\n      if (tctx->explicit_rdpcm_flag) {\n        residualDpcm = (tctx->explicit_rdpcm_dir ? 2 : 1);\n      }\n    }\n\n  if (cbf) {\n    scale_coefficients(tctx, x0,y0, xCUBase,yCUBase, nT, cIdx,\n                       tctx->transform_skip_flag[cIdx], cuPredMode==MODE_INTRA, residualDpcm);\n  }\n  /*\n  else if (!cbf && cIdx==0) {\n    memset(tctx->residual_luma,0,32*32*sizeof(int32_t));\n  }\n  */\n  else if (!cbf && cIdx!=0 && tctx->ResScaleVal) {\n    // --- cross-component-prediction when CBF==0 ---\n\n    tctx->nCoeff[cIdx] = 0;\n    residualDpcm=0;\n\n    scale_coefficients(tctx, x0,y0, xCUBase,yCUBase, nT, cIdx,\n                       tctx->transform_skip_flag[cIdx], cuPredMode==MODE_INTRA, residualDpcm);\n  }\n}\n\n\nstatic int decode_log2_res_scale_abs_plus1(thread_context* tctx, int cIdxMinus1)\n{\n  //const int context = (cIdx==0) ? 0 : 1;\n\n  logtrace(LogSlice,\"# log2_res_scale_abs_plus1 (c=%d)\\n\",cIdxMinus1);\n\n  int value = 0;\n  int cMax  = 4;\n  for (int binIdx=0;binIdx<cMax;binIdx++)\n    {\n      int ctxIdxInc = 4*cIdxMinus1 + binIdx;\n\n      int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                                 &tctx->ctx_model[CONTEXT_MODEL_LOG2_RES_SCALE_ABS_PLUS1+ctxIdxInc]);\n      if (!bit) break;\n      value++;\n    }\n\n  logtrace(LogSymbols,\"$1 log2_res_scale_abs_plus1=%d\\n\",value);\n\n  return value;\n}\n\n\nstatic int decode_res_scale_sign_flag(thread_context* tctx, int cIdxMinus1)\n{\n  //const int context = (cIdx==0) ? 0 : 1;\n\n  logtrace(LogSlice,\"# res_scale_sign_flag (c=%d)\\n\",cIdxMinus1);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_RES_SCALE_SIGN_FLAG+cIdxMinus1]);\n\n  logtrace(LogSymbols,\"$1 res_scale_sign_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic void read_cross_comp_pred(thread_context* tctx, int cIdxMinus1)\n{\n  int log2_res_scale_abs_plus1 = decode_log2_res_scale_abs_plus1(tctx,cIdxMinus1);\n  int ResScaleVal;\n\n  if (log2_res_scale_abs_plus1 != 0) {\n    int res_scale_sign_flag = decode_res_scale_sign_flag(tctx,cIdxMinus1);\n\n    ResScaleVal = 1 << (log2_res_scale_abs_plus1 - 1);\n    ResScaleVal *= 1 - 2 * res_scale_sign_flag;\n  }\n  else {\n    ResScaleVal = 0;\n  }\n\n  tctx->ResScaleVal = ResScaleVal;\n}\n\n\nint read_transform_unit(thread_context* tctx,\n                        int x0, int y0,        // position of TU in frame\n                        int xBase, int yBase,  // position of parent TU in frame\n                        int xCUBase,int yCUBase,  // position of CU in frame\n                        int log2TrafoSize,\n                        int trafoDepth,\n                        int blkIdx,\n                        int cbf_luma, int cbf_cb, int cbf_cr)\n{\n  logtrace(LogSlice,\"- read_transform_unit x0:%d y0:%d xBase:%d yBase:%d nT:%d cbf:%d:%d:%d\\n\",\n           x0,y0,xBase,yBase, 1<<log2TrafoSize, cbf_luma, cbf_cb, cbf_cr);\n\n  assert(cbf_cb != -1);\n  assert(cbf_cr != -1);\n  assert(cbf_luma != -1);\n\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  const int ChromaArrayType = sps.ChromaArrayType;\n\n  int log2TrafoSizeC = (ChromaArrayType==CHROMA_444 ? log2TrafoSize : log2TrafoSize-1);\n  log2TrafoSizeC = libde265_max(2, log2TrafoSizeC);\n\n  const int cbfLuma   = cbf_luma;\n  const int cbfChroma = cbf_cb | cbf_cr;\n\n  tctx->transform_skip_flag[0]=0;\n  tctx->transform_skip_flag[1]=0;\n  tctx->transform_skip_flag[2]=0;\n\n  tctx->explicit_rdpcm_flag = false;\n\n\n  enum PredMode cuPredMode = tctx->img->get_pred_mode(x0,y0);\n\n  if (cbfLuma || cbfChroma)\n    {\n      bool doDecodeQuantParameters = false;\n\n      if (tctx->img->get_pps().cu_qp_delta_enabled_flag &&\n          !tctx->IsCuQpDeltaCoded) {\n\n        int cu_qp_delta_abs = decode_cu_qp_delta_abs(tctx);\n        int cu_qp_delta_sign=0;\n        if (cu_qp_delta_abs) {\n          cu_qp_delta_sign = decode_CABAC_bypass(&tctx->cabac_decoder);\n        }\n\n        tctx->IsCuQpDeltaCoded = 1;\n        tctx->CuQpDelta = cu_qp_delta_abs*(1-2*cu_qp_delta_sign);\n\n        //printf(\"read cu_qp_delta (%d;%d) = %d\\n\",x0,y0,tctx->CuQpDelta);\n\n        logtrace(LogSlice,\"cu_qp_delta_abs = %d\\n\",cu_qp_delta_abs);\n        logtrace(LogSlice,\"cu_qp_delta_sign = %d\\n\",cu_qp_delta_sign);\n        logtrace(LogSlice,\"CuQpDelta = %d\\n\",tctx->CuQpDelta);\n\n        doDecodeQuantParameters = true;\n        //decode_quantization_parameters(tctx, x0,y0, xCUBase, yCUBase);\n      }\n\n      if (tctx->shdr->cu_chroma_qp_offset_enabled_flag && cbfChroma &&\n          !tctx->cu_transquant_bypass_flag && !tctx->IsCuChromaQpOffsetCoded ) {\n        logtrace(LogSlice,\"# cu_chroma_qp_offset_flag\\n\");\n\n        int cu_chroma_qp_offset_flag = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                        &tctx->ctx_model[CONTEXT_MODEL_CU_CHROMA_QP_OFFSET_FLAG]);\n\n\n        const pic_parameter_set& pps = tctx->img->get_pps();\n\n        int cu_chroma_qp_offset_idx = 0;\n        if (cu_chroma_qp_offset_flag && pps.range_extension.chroma_qp_offset_list_len > 1) {\n          cu_chroma_qp_offset_idx = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                     &tctx->ctx_model[CONTEXT_MODEL_CU_CHROMA_QP_OFFSET_IDX]);\n        }\n\n        tctx->IsCuChromaQpOffsetCoded = 1;\n\n        if (cu_chroma_qp_offset_flag) {\n          tctx->CuQpOffsetCb = pps.range_extension.cb_qp_offset_list[ cu_chroma_qp_offset_idx ];\n          tctx->CuQpOffsetCr = pps.range_extension.cr_qp_offset_list[ cu_chroma_qp_offset_idx ];\n        }\n        else {\n          tctx->CuQpOffsetCb = 0;\n          tctx->CuQpOffsetCr = 0;\n        }\n\n        doDecodeQuantParameters = true;\n        //decode_quantization_parameters(tctx, x0,y0, xCUBase, yCUBase);\n      }\n\n\n      if (doDecodeQuantParameters) {\n        decode_quantization_parameters(tctx, x0,y0, xCUBase, yCUBase);\n      }\n    }\n\n  // position of TU in local CU\n  int xL = x0 - xCUBase;\n  int yL = y0 - yCUBase;\n  int nT = 1<<log2TrafoSize;\n  int nTC = 1<<log2TrafoSizeC;\n\n  const int SubWidthC  = sps.SubWidthC;\n  const int SubHeightC = sps.SubHeightC;\n\n  // --- luma ---\n\n  tctx->ResScaleVal = 0;\n\n  int err;\n  if (cbf_luma) {\n    if ((err=residual_coding(tctx,x0,y0, log2TrafoSize,0)) != DE265_OK) return err;\n  }\n\n  decode_TU(tctx, x0,y0, xCUBase,yCUBase, nT, 0, cuPredMode, cbf_luma);\n\n\n  // --- chroma ---\n\n  const int yOffset422 = 1<<log2TrafoSizeC;\n\n  if (log2TrafoSize>2 || ChromaArrayType == CHROMA_444) {\n    // TODO: cross-component prediction\n\n    const bool do_cross_component_prediction =\n      (tctx->img->get_pps().range_extension.cross_component_prediction_enabled_flag &&\n       cbf_luma &&\n       (cuPredMode == MODE_INTER || tctx->img->is_IntraPredModeC_Mode4(x0,y0)));\n\n    if (do_cross_component_prediction) {\n      read_cross_comp_pred(tctx, 0);\n    }\n    else {\n      tctx->ResScaleVal = 0;\n    }\n\n    {\n      if (cbf_cb & 1) {\n        if ((err=residual_coding(tctx,x0,y0,log2TrafoSizeC,1)) != DE265_OK) return err;\n      }\n\n      if (sps.ChromaArrayType != CHROMA_MONO) {\n        decode_TU(tctx,\n                  x0/SubWidthC,y0/SubHeightC,\n                  xCUBase/SubWidthC,yCUBase/SubHeightC, nTC, 1, cuPredMode, cbf_cb & 1);\n      }\n    }\n\n    // 4:2:2\n    if (ChromaArrayType == CHROMA_422) {\n      const int yOffset = 1<<log2TrafoSizeC;\n\n      if (cbf_cb & 2) {\n        if ((err=residual_coding(tctx,\n                                 x0,y0+yOffset*SubHeightC,\n                                 log2TrafoSizeC,1)) != DE265_OK) return err;\n      }\n\n      decode_TU(tctx,\n                x0/SubWidthC,y0/SubHeightC + yOffset,\n                xCUBase/SubWidthC,yCUBase/SubHeightC +yOffset,\n                nTC, 1, cuPredMode, cbf_cb & 2);\n    }\n\n\n    if (do_cross_component_prediction) {\n      read_cross_comp_pred(tctx, 1);\n    }\n    else {\n      tctx->ResScaleVal = 0;\n    }\n\n    {\n      if (cbf_cr & 1) {\n        if ((err=residual_coding(tctx,x0,y0,log2TrafoSizeC,2)) != DE265_OK) return err;\n      }\n\n      if (sps.ChromaArrayType != CHROMA_MONO) {\n        decode_TU(tctx,\n                  x0/SubWidthC,y0/SubHeightC,\n                  xCUBase/SubWidthC,yCUBase/SubHeightC,\n                  nTC, 2, cuPredMode, cbf_cr & 1);\n      }\n    }\n\n    // 4:2:2\n    if (ChromaArrayType == CHROMA_422) {\n      const int yOffset = 1<<log2TrafoSizeC;\n\n      if (cbf_cr & 2) {\n        if ((err=residual_coding(tctx,\n                                 x0,y0+yOffset*SubHeightC,\n                                 log2TrafoSizeC,2)) != DE265_OK) return err;\n      }\n\n      decode_TU(tctx,\n                x0/SubWidthC,y0/SubHeightC+yOffset,\n                xCUBase/SubWidthC,yCUBase/SubHeightC+yOffset,\n                nTC, 2, cuPredMode, cbf_cr & 2);\n    }\n  }\n  else if (blkIdx==3) {\n    if (cbf_cb & 1) {\n      if ((err=residual_coding(tctx,xBase,yBase,\n                               log2TrafoSize,1)) != DE265_OK) return err;\n    }\n\n    if (sps.ChromaArrayType != CHROMA_MONO) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC,\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 1, cuPredMode, cbf_cb & 1);\n    }\n\n    // 4:2:2\n    if (cbf_cb & 2) {\n      if ((err=residual_coding(tctx,\n                               xBase        ,yBase        +(1<<log2TrafoSize),\n                               log2TrafoSize,1)) != DE265_OK) return err;\n    }\n\n    if (ChromaArrayType == CHROMA_422) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC + (1<<log2TrafoSize),\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 1, cuPredMode, cbf_cb & 2);\n    }\n\n    if (cbf_cr & 1) {\n      if ((err=residual_coding(tctx,xBase,yBase,\n                               log2TrafoSize,2)) != DE265_OK) return err;\n    }\n\n    if (sps.ChromaArrayType != CHROMA_MONO) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC,\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 2, cuPredMode, cbf_cr & 1);\n    }\n\n    // 4:2:2\n    if (cbf_cr & 2) {\n      if ((err=residual_coding(tctx,\n                               xBase        ,yBase        +(1<<log2TrafoSizeC),\n                               log2TrafoSize,2)) != DE265_OK) return err;\n    }\n\n    if (ChromaArrayType == CHROMA_422) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC + (1<<log2TrafoSize),\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 2, cuPredMode, cbf_cr & 2);\n    }\n  }\n\n\n  return DE265_OK;\n}\n\n\nstatic void dump_cbsize(de265_image* img)\n{\n  int w = img->get_width(0);\n  int h = img->get_height(0);\n\n  for (int y=0;y<h;y+=8) {\n    for (int x=0;x<w;x+=8) {\n      printf(\"%d\",img->get_log2CbSize(x,y));\n    }\n    printf(\"\\n\");\n  }\n}\n\n\nvoid read_transform_tree(thread_context* tctx,\n                         int x0, int y0,        // position of TU in frame\n                         int xBase, int yBase,  // position of parent TU in frame\n                         int xCUBase, int yCUBase, // position of CU in frame\n                         int log2TrafoSize,\n                         int trafoDepth,\n                         int blkIdx,\n                         int MaxTrafoDepth,\n                         int IntraSplitFlag,\n                         enum PredMode cuPredMode,\n                         uint8_t parent_cbf_cb,uint8_t parent_cbf_cr)\n{\n  logtrace(LogSlice,\"- read_transform_tree (interleaved) x0:%d y0:%d xBase:%d yBase:%d \"\n           \"log2TrafoSize:%d trafoDepth:%d MaxTrafoDepth:%d parent-cbf-cb:%d parent-cbf-cr:%d\\n\",\n           x0,y0,xBase,yBase,log2TrafoSize,trafoDepth,MaxTrafoDepth,parent_cbf_cb,parent_cbf_cr);\n\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n\n  int split_transform_flag;\n\n  enum PredMode PredMode = img->get_pred_mode(x0,y0);\n  assert(PredMode == cuPredMode);\n\n  /*  If TrafoSize is larger than maximum size   -> split automatically\n      If TrafoSize is at minimum size            -> do not split\n      If maximum transformation depth is reached -> do not split\n      If intra-prediction is NxN mode            -> split automatically (only at level 0)\n      Otherwise  ->  read split flag\n  */\n  if (log2TrafoSize <= sps.Log2MaxTrafoSize &&\n      log2TrafoSize >  sps.Log2MinTrafoSize &&\n      trafoDepth < MaxTrafoDepth &&\n      !(IntraSplitFlag && trafoDepth==0))\n    {\n      split_transform_flag = decode_split_transform_flag(tctx, log2TrafoSize);\n    }\n  else\n    {\n      enum PartMode PartMode = img->get_PartMode(x0,y0);\n\n      int interSplitFlag= (sps.max_transform_hierarchy_depth_inter==0 &&\n                           trafoDepth == 0 &&\n                           PredMode == MODE_INTER &&\n                           PartMode != PART_2Nx2N);\n\n      split_transform_flag = (log2TrafoSize > sps.Log2MaxTrafoSize ||\n                              (IntraSplitFlag==1 && trafoDepth==0) ||\n                              interSplitFlag==1) ? 1:0;\n    }\n\n  if (split_transform_flag) {\n    logtrace(LogSlice,\"set_split_transform_flag(%d,%d, %d)\\n\",x0,y0,trafoDepth);\n    img->set_split_transform_flag(x0,y0,trafoDepth);\n  }\n\n  int cbf_cb=-1;\n  int cbf_cr=-1;\n\n  // CBF_CB/CR flags are encoded like this:\n  // 4:2:0 and 4:4:4 modes: binary flag in bit 0\n  // 4:2:2 mode: bit 0: top block, bit 1: bottom block\n\n  if ((log2TrafoSize>2 && sps.ChromaArrayType != CHROMA_MONO) ||\n      sps.ChromaArrayType == CHROMA_444) {\n    // we do not have to test for trafoDepth==0, because parent_cbf_cb is 1 at depth 0\n    if (/*trafoDepth==0 ||*/ parent_cbf_cb) {\n      cbf_cb = decode_cbf_chroma(tctx,trafoDepth);\n\n      if (sps.ChromaArrayType == CHROMA_422 && (!split_transform_flag || log2TrafoSize==3)) {\n        cbf_cb |= (decode_cbf_chroma(tctx,trafoDepth) << 1);\n      }\n    }\n\n    // we do not have to test for trafoDepth==0, because parent_cbf_cb is 1 at depth 0\n    if (/*trafoDepth==0 ||*/ parent_cbf_cr) {\n      cbf_cr = decode_cbf_chroma(tctx,trafoDepth);\n\n      if (sps.ChromaArrayType == CHROMA_422 && (!split_transform_flag || log2TrafoSize==3)) {\n        cbf_cr |= (decode_cbf_chroma(tctx,trafoDepth) << 1);\n      }\n    }\n  }\n\n  //printf(\"CBF: cb:%d cr:%d\\n\",cbf_cb,cbf_cr);\n\n  // cbf_cr/cbf_cb not present in bitstream -> induce values\n\n  if (cbf_cb<0) {\n    assert(!(trafoDepth==0 && log2TrafoSize==2));\n\n    /* The standard specifies to check trafoDepth>0 AND log2TrafoSize==2.\n       However, I think that trafoDepth>0 is redundant as a CB is always\n       at least 8x8 and hence trafoDepth>0.\n    */\n\n    if (trafoDepth>0 && log2TrafoSize==2) {\n      cbf_cb = parent_cbf_cb;\n    } else {\n      cbf_cb=0;\n    }\n  }\n\n  if (cbf_cr<0) {\n    if (trafoDepth>0 && log2TrafoSize==2) {\n      cbf_cr = parent_cbf_cr;\n    } else {\n      cbf_cr=0;\n    }\n  }\n\n  if (split_transform_flag) {\n    int x1 = x0 + (1<<(log2TrafoSize-1));\n    int y1 = y0 + (1<<(log2TrafoSize-1));\n\n    logtrace(LogSlice,\"transform split.\\n\");\n\n    read_transform_tree(tctx, x0,y0, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 0,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n    read_transform_tree(tctx, x1,y0, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 1,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n    read_transform_tree(tctx, x0,y1, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 2,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n    read_transform_tree(tctx, x1,y1, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 3,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n  }\n  else {\n    int cbf_luma;\n\n    if (PredMode==MODE_INTRA || trafoDepth!=0 || cbf_cb || cbf_cr) {\n      cbf_luma = decode_cbf_luma(tctx,trafoDepth);\n    }\n    else {\n      /* There cannot be INTER blocks with no residual data.\n         That case is already handled with rqt_root_cbf.\n      */\n\n      cbf_luma = 1;\n    }\n\n    logtrace(LogSlice,\"call read_transform_unit %d/%d\\n\",x0,y0);\n\n    read_transform_unit(tctx, x0,y0,xBase,yBase, xCUBase,yCUBase, log2TrafoSize,trafoDepth, blkIdx,\n                        cbf_luma, cbf_cb, cbf_cr);\n  }\n}\n\n\nconst char* part_mode_name(enum PartMode pm)\n{\n  switch (pm) {\n  case PART_2Nx2N: return \"2Nx2N\";\n  case PART_2NxN:  return \"2NxN\";\n  case PART_Nx2N:  return \"Nx2N\";\n  case PART_NxN:   return \"NxN\";\n  case PART_2NxnU: return \"2NxnU\";\n  case PART_2NxnD: return \"2NxnD\";\n  case PART_nLx2N: return \"nLx2N\";\n  case PART_nRx2N: return \"nRx2N\";\n  }\n\n  return \"undefined part mode\";\n}\n\n\nvoid read_mvd_coding(thread_context* tctx,\n                     int x0,int y0, int refList)\n{\n  int abs_mvd_greater0_flag[2];\n  abs_mvd_greater0_flag[0] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                              &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+0]);\n  abs_mvd_greater0_flag[1] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                              &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+0]);\n\n  int abs_mvd_greater1_flag[2];\n  if (abs_mvd_greater0_flag[0]) {\n    abs_mvd_greater1_flag[0] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+1]);\n  }\n  else {\n    abs_mvd_greater1_flag[0]=0;\n  }\n\n  if (abs_mvd_greater0_flag[1]) {\n    abs_mvd_greater1_flag[1] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+1]);\n  }\n  else {\n    abs_mvd_greater1_flag[1]=0;\n  }\n\n\n  int abs_mvd_minus2[2];\n  int mvd_sign_flag[2];\n  int value[2];\n\n  for (int c=0;c<2;c++) {\n    if (abs_mvd_greater0_flag[c]) {\n      if (abs_mvd_greater1_flag[c]) {\n        abs_mvd_minus2[c] = decode_CABAC_EGk_bypass(&tctx->cabac_decoder, 1);\n      }\n      else {\n        abs_mvd_minus2[c] = abs_mvd_greater1_flag[c] -1;\n      }\n\n      mvd_sign_flag[c] = decode_CABAC_bypass(&tctx->cabac_decoder);\n\n      value[c] = abs_mvd_minus2[c]+2;\n      if (mvd_sign_flag[c]) { value[c] = -value[c]; }\n    }\n    else {\n      value[c] = 0;\n    }\n  }\n\n  //set_mvd(tctx->decctx, x0,y0, refList, value[0],value[1]);\n  tctx->motion.mvd[refList][0] = value[0];\n  tctx->motion.mvd[refList][1] = value[1];\n\n  logtrace(LogSlice, \"MVD[%d;%d|%d] = %d;%d\\n\",x0,y0,refList, value[0],value[1]);\n}\n\n\nvoid read_prediction_unit_SKIP(thread_context* tctx,\n                               int x0, int y0,\n                               int nPbW, int nPbH)\n{\n  int merge_idx = decode_merge_idx(tctx);\n\n  tctx->motion.merge_idx = merge_idx;\n  tctx->motion.merge_flag = true;\n\n  logtrace(LogSlice,\"prediction skip 2Nx2N, merge_idx: %d\\n\",merge_idx);\n}\n\n\n/* xC/yC : CB position\n   xB/yB : position offset of the PB\n   nPbW/nPbH : size of PB\n   nCS   : CB size\n */\nvoid read_prediction_unit(thread_context* tctx,\n                          int xC,int yC, int xB,int yB,\n                          int nPbW, int nPbH,\n                          int ctDepth, int nCS,int partIdx)\n{\n  logtrace(LogSlice,\"read_prediction_unit %d;%d %dx%d\\n\",xC+xB,yC+xB,nPbW,nPbH);\n\n  int x0 = xC+xB;\n  int y0 = yC+yB;\n\n  slice_segment_header* shdr = tctx->shdr;\n\n  int merge_flag = decode_merge_flag(tctx);\n  tctx->motion.merge_flag = merge_flag;\n\n  if (merge_flag) {\n    int merge_idx = decode_merge_idx(tctx);\n\n    logtrace(LogSlice,\"prediction unit %d,%d, merge mode, index: %d\\n\",x0,y0,merge_idx);\n\n    tctx->motion.merge_idx = merge_idx;\n  }\n  else { // no merge flag\n    enum InterPredIdc inter_pred_idc;\n\n    if (shdr->slice_type == SLICE_TYPE_B) {\n      inter_pred_idc = decode_inter_pred_idc(tctx,x0,y0,nPbW,nPbH,ctDepth);\n    }\n    else {\n      inter_pred_idc = PRED_L0;\n    }\n\n    tctx->motion.inter_pred_idc = inter_pred_idc; // set_inter_pred_idc(ctx,x0,y0, inter_pred_idc);\n\n    if (inter_pred_idc != PRED_L1) {\n      int ref_idx_l0 = decode_ref_idx_lX(tctx, shdr->num_ref_idx_l0_active);\n\n      // NOTE: case for only one reference frame is handles in decode_ref_idx_lX()\n      tctx->motion.refIdx[0] = ref_idx_l0;\n\n      read_mvd_coding(tctx,x0,y0, 0);\n\n      int mvp_l0_flag = decode_mvp_lx_flag(tctx); // l0\n      tctx->motion.mvp_l0_flag = mvp_l0_flag;\n\n      logtrace(LogSlice,\"prediction unit %d,%d, L0, refIdx=%d mvp_l0_flag:%d\\n\",\n               x0,y0, tctx->motion.refIdx[0], mvp_l0_flag);\n    }\n\n    if (inter_pred_idc != PRED_L0) {\n      int ref_idx_l1 = decode_ref_idx_lX(tctx, shdr->num_ref_idx_l1_active);\n\n      // NOTE: case for only one reference frame is handles in decode_ref_idx_lX()\n      tctx->motion.refIdx[1] = ref_idx_l1;\n\n      if (shdr->mvd_l1_zero_flag &&\n          inter_pred_idc == PRED_BI) {\n        tctx->motion.mvd[1][0] = 0;\n        tctx->motion.mvd[1][1] = 0;\n      }\n      else {\n        read_mvd_coding(tctx,x0,y0, 1);\n      }\n\n      int mvp_l1_flag = decode_mvp_lx_flag(tctx); // l1\n      tctx->motion.mvp_l1_flag = mvp_l1_flag;\n\n      logtrace(LogSlice,\"prediction unit %d,%d, L1, refIdx=%d mvp_l1_flag:%d\\n\",\n               x0,y0, tctx->motion.refIdx[1], mvp_l1_flag);\n    }\n  }\n\n\n\n  decode_prediction_unit(tctx->decctx, tctx->shdr, tctx->img, tctx->motion,\n                         xC,yC,xB,yB, nCS, nPbW,nPbH, partIdx);\n}\n\n\n\n\ntemplate <class pixel_t>\nvoid read_pcm_samples_internal(thread_context* tctx, int x0, int y0, int log2CbSize,\n                               int cIdx, bitreader& br)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  int nPcmBits;\n  int bitDepth;\n\n  int w = 1<<log2CbSize;\n  int h = 1<<log2CbSize;\n\n  if (cIdx>0) {\n    w /= sps.SubWidthC;\n    h /= sps.SubHeightC;\n\n    x0 /= sps.SubWidthC;\n    y0 /= sps.SubHeightC;\n\n    nPcmBits = sps.pcm_sample_bit_depth_chroma;\n    bitDepth = sps.BitDepth_C;\n  }\n  else {\n    nPcmBits = sps.pcm_sample_bit_depth_luma;\n    bitDepth = sps.BitDepth_Y;\n  }\n\n  pixel_t* ptr;\n  int stride;\n  ptr    = tctx->img->get_image_plane_at_pos_NEW<pixel_t>(cIdx,x0,y0);\n  stride = tctx->img->get_image_stride(cIdx);\n\n  int shift = bitDepth - nPcmBits;\n\n  // a shift < 0 may result when the SPS sequence header is broken\n  if (shift < 0) {\n    shift=0;\n  }\n\n  for (int y=0;y<h;y++)\n    for (int x=0;x<w;x++)\n      {\n        int value = get_bits(&br, nPcmBits);\n        ptr[y*stride+x] = value << shift;\n      }\n}\n\nstatic void read_pcm_samples(thread_context* tctx, int x0, int y0, int log2CbSize)\n{\n  bitreader br;\n  br.data            = tctx->cabac_decoder.bitstream_curr;\n  br.bytes_remaining = tctx->cabac_decoder.bitstream_end - tctx->cabac_decoder.bitstream_curr;\n  br.nextbits = 0;\n  br.nextbits_cnt = 0;\n\n\n  if (tctx->img->high_bit_depth(0)) {\n    read_pcm_samples_internal<uint16_t>(tctx,x0,y0,log2CbSize,0,br);\n  } else {\n    read_pcm_samples_internal<uint8_t>(tctx,x0,y0,log2CbSize,0,br);\n  }\n\n  if (tctx->img->get_sps().ChromaArrayType != CHROMA_MONO) {\n    if (tctx->img->high_bit_depth(1)) {\n      read_pcm_samples_internal<uint16_t>(tctx,x0,y0,log2CbSize,1,br);\n      read_pcm_samples_internal<uint16_t>(tctx,x0,y0,log2CbSize,2,br);\n    } else {\n      read_pcm_samples_internal<uint8_t>(tctx,x0,y0,log2CbSize,1,br);\n      read_pcm_samples_internal<uint8_t>(tctx,x0,y0,log2CbSize,2,br);\n    }\n  }\n\n  prepare_for_CABAC(&br);\n  tctx->cabac_decoder.bitstream_curr = br.data;\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n}\n\n\nint map_chroma_pred_mode(int intra_chroma_pred_mode, int IntraPredMode)\n{\n  if (intra_chroma_pred_mode==4) {\n    return IntraPredMode;\n  }\n  else {\n    static const enum IntraPredMode IntraPredModeCCand[4] = {\n      INTRA_PLANAR,\n      INTRA_ANGULAR_26, // vertical\n      INTRA_ANGULAR_10, // horizontal\n      INTRA_DC\n    };\n\n    int IntraPredModeC = IntraPredModeCCand[intra_chroma_pred_mode];\n    if (IntraPredModeC == IntraPredMode) {\n      return INTRA_ANGULAR_34;\n    }\n    else {\n      return IntraPredModeC;\n    }\n  }\n}\n\n// h.265-V2 Table 8-3\nstatic const uint8_t map_chroma_422[35] = {\n  0,1,2, 2, 2, 2, 3, 5, 7, 8,10,12,13,15,17,18,19,20,\n  21,22,23,23,24,24,25,25,26,27,27,28,28,29,29,30,31\n};\n\nvoid read_coding_unit(thread_context* tctx,\n                      int x0, int y0,  // position of coding unit in frame\n                      int log2CbSize,\n                      int ctDepth)\n{\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n  slice_segment_header* shdr = tctx->shdr;\n\n  logtrace(LogSlice,\"- read_coding_unit %d;%d cbsize:%d\\n\",x0,y0,1<<log2CbSize);\n\n\n  //QQprintf(\"- read_coding_unit %d;%d cbsize:%d\\n\",x0,y0,1<<log2CbSize);\n\n  img->set_log2CbSize(x0,y0, log2CbSize, true);\n\n  /* This is only required on corrupted input streams.\n     It may happen that there are several slices in the image that overlap.\n     In this case, flags would accumulate from both slices.\n  */\n  img->clear_split_transform_flags(x0,y0, log2CbSize);\n\n  int nCbS = 1<<log2CbSize; // number of coding block samples\n\n  decode_quantization_parameters(tctx, x0,y0, x0, y0);\n\n\n  if (pps.transquant_bypass_enable_flag)\n    {\n      int transquant_bypass = decode_transquant_bypass_flag(tctx);\n\n      tctx->cu_transquant_bypass_flag = transquant_bypass;\n\n      if (transquant_bypass) {\n        img->set_cu_transquant_bypass(x0,y0,log2CbSize);\n      }\n    }\n  else {\n    tctx->cu_transquant_bypass_flag = 0;\n  }\n\n  uint8_t cu_skip_flag = 0;\n  if (shdr->slice_type != SLICE_TYPE_I) {\n    cu_skip_flag = decode_cu_skip_flag(tctx,x0,y0,ctDepth);\n  }\n\n  int IntraSplitFlag = 0;\n\n  enum PredMode cuPredMode;\n\n  if (cu_skip_flag) {\n    read_prediction_unit_SKIP(tctx,x0,y0,nCbS,nCbS);\n\n    img->set_PartMode(x0,y0, PART_2Nx2N); // need this for deblocking filter\n    img->set_pred_mode(x0,y0,log2CbSize, MODE_SKIP);\n    cuPredMode = MODE_SKIP;\n\n    logtrace(LogSlice,\"CU pred mode: SKIP\\n\");\n\n\n    // DECODE\n\n    int nCS_L = 1<<log2CbSize;\n    decode_prediction_unit(tctx->decctx,tctx->shdr,tctx->img,tctx->motion,\n                           x0,y0, 0,0, nCS_L, nCS_L,nCS_L, 0);\n  }\n  else /* not skipped */ {\n    if (shdr->slice_type != SLICE_TYPE_I) {\n      int pred_mode_flag = decode_pred_mode_flag(tctx);\n      cuPredMode = pred_mode_flag ? MODE_INTRA : MODE_INTER;\n    }\n    else {\n      cuPredMode = MODE_INTRA;\n    }\n\n    img->set_pred_mode(x0,y0,log2CbSize, cuPredMode);\n\n    logtrace(LogSlice,\"CU pred mode: %s\\n\", cuPredMode==MODE_INTRA ? \"INTRA\" : \"INTER\");\n\n\n    enum PartMode PartMode;\n\n    if (cuPredMode != MODE_INTRA ||\n        log2CbSize == sps.Log2MinCbSizeY) {\n      PartMode = decode_part_mode(tctx, cuPredMode, log2CbSize);\n\n      if (PartMode==PART_NxN && cuPredMode==MODE_INTRA) {\n        IntraSplitFlag=1;\n      }\n    } else {\n      PartMode = PART_2Nx2N;\n    }\n\n    img->set_PartMode(x0,y0, PartMode); // needed for deblocking ?\n\n    logtrace(LogSlice, \"PartMode: %s\\n\", part_mode_name(PartMode));\n\n\n    bool pcm_flag = false;\n\n    if (cuPredMode == MODE_INTRA) {\n      if (PartMode == PART_2Nx2N && sps.pcm_enabled_flag &&\n          log2CbSize >= sps.Log2MinIpcmCbSizeY &&\n          log2CbSize <= sps.Log2MaxIpcmCbSizeY) {\n        pcm_flag = decode_CABAC_term_bit(&tctx->cabac_decoder);\n      }\n\n      if (pcm_flag) {\n        img->set_pcm_flag(x0,y0,log2CbSize);\n\n        read_pcm_samples(tctx, x0,y0, log2CbSize);\n      }\n      else {\n        int pbOffset = (PartMode == PART_NxN) ? (nCbS/2) : nCbS;\n        int log2IntraPredSize = (PartMode == PART_NxN) ? (log2CbSize-1) : log2CbSize;\n\n        logtrace(LogSlice,\"nCbS:%d pbOffset:%d\\n\",nCbS,pbOffset);\n\n        int prev_intra_luma_pred_flag[4];\n\n        int idx=0;\n        for (int j=0;j<nCbS;j+=pbOffset)\n          for (int i=0;i<nCbS;i+=pbOffset)\n            {\n              prev_intra_luma_pred_flag[idx++] = decode_prev_intra_luma_pred_flag(tctx);\n            }\n\n        int mpm_idx[4], rem_intra_luma_pred_mode[4];\n        idx=0;\n\n        int availableA0 = check_CTB_available(img, x0,y0, x0-1,y0);\n        int availableB0 = check_CTB_available(img, x0,y0, x0,y0-1);\n\n        for (int j=0;j<nCbS;j+=pbOffset)\n          for (int i=0;i<nCbS;i+=pbOffset)\n            {\n              if (prev_intra_luma_pred_flag[idx]) {\n                mpm_idx[idx] = decode_mpm_idx(tctx);\n              }\n              else {\n                rem_intra_luma_pred_mode[idx] = decode_rem_intra_luma_pred_mode(tctx);\n              }\n\n\n              int x = x0+i;\n              int y = y0+j;\n\n              // --- find intra prediction mode ---\n\n              int IntraPredMode;\n\n              int availableA = availableA0 || (i>0); // left candidate always available for right blk\n              int availableB = availableB0 || (j>0); // top candidate always available for bottom blk\n\n\n\n              int PUidx = (x>>sps.Log2MinPUSize) + (y>>sps.Log2MinPUSize)*sps.PicWidthInMinPUs;\n\n              enum IntraPredMode candModeList[3];\n\n              fillIntraPredModeCandidates(candModeList,x,y,PUidx,\n                                          availableA, availableB, img);\n\n              for (int i=0;i<3;i++)\n                logtrace(LogSlice,\"candModeList[%d] = %d\\n\", i, candModeList[i]);\n\n              if (prev_intra_luma_pred_flag[idx]==1) {\n                IntraPredMode = candModeList[ mpm_idx[idx] ];\n              }\n              else {\n                // sort candModeList\n\n                if (candModeList[0] > candModeList[1]) {\n                  std::swap(candModeList[0],candModeList[1]);\n                }\n                if (candModeList[0] > candModeList[2]) {\n                  std::swap(candModeList[0],candModeList[2]);\n                }\n                if (candModeList[1] > candModeList[2]) {\n                  std::swap(candModeList[1],candModeList[2]);\n                }\n\n                // skip modes in the list\n                // (we have 35 modes. skipping the 3 in the list gives us 32, which can be selected by 5 bits)\n                IntraPredMode = rem_intra_luma_pred_mode[idx];\n                for (int n=0;n<=2;n++) {\n                  if (IntraPredMode >= candModeList[n]) { IntraPredMode++; }\n                }\n              }\n\n              logtrace(LogSlice,\"IntraPredMode[%d][%d] = %d (log2blk:%d)\\n\",x,y,IntraPredMode, log2IntraPredSize);\n\n              img->set_IntraPredMode(PUidx, log2IntraPredSize,\n                                     (enum IntraPredMode)IntraPredMode);\n\n              idx++;\n            }\n\n\n        // set chroma intra prediction mode\n\n        if (sps.ChromaArrayType == CHROMA_444) {\n          // chroma 4:4:4\n\n          idx = 0;\n          for (int j=0;j<nCbS;j+=pbOffset)\n            for (int i=0;i<nCbS;i+=pbOffset) {\n              int x = x0+i;\n              int y = y0+j;\n\n              int intra_chroma_pred_mode = decode_intra_chroma_pred_mode(tctx);\n              int IntraPredMode = img->get_IntraPredMode(x,y);\n\n              int IntraPredModeC = map_chroma_pred_mode(intra_chroma_pred_mode, IntraPredMode);\n\n              logtrace(LogSlice,\"IntraPredModeC[%d][%d]: %d (blksize:%d)\\n\",x,y,IntraPredModeC,\n                       1<<log2IntraPredSize);\n\n              img->set_IntraPredModeC(x,y, log2IntraPredSize,\n                                      (enum IntraPredMode)IntraPredModeC,\n                                      intra_chroma_pred_mode == 4);\n              idx++;\n            }\n        }\n        else if (sps.ChromaArrayType != CHROMA_MONO) {\n          // chroma 4:2:0 and 4:2:2\n\n          int intra_chroma_pred_mode = decode_intra_chroma_pred_mode(tctx);\n          int IntraPredMode = img->get_IntraPredMode(x0,y0);\n          logtrace(LogSlice,\"IntraPredMode: %d\\n\",IntraPredMode);\n          int IntraPredModeC = map_chroma_pred_mode(intra_chroma_pred_mode, IntraPredMode);\n\n          if (sps.ChromaArrayType == CHROMA_422) {\n            IntraPredModeC = map_chroma_422[ IntraPredModeC ];\n          }\n\n          img->set_IntraPredModeC(x0,y0, log2CbSize,\n                                  (enum IntraPredMode)IntraPredModeC,\n                                  intra_chroma_pred_mode == 4);\n        }\n      }\n    }\n    else { // INTER\n      int nCS = 1<<log2CbSize;\n\n      if (PartMode == PART_2Nx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0,nCbS,nCbS,ctDepth,nCS,0);\n      }\n      else if (PartMode == PART_2NxN) {\n        read_prediction_unit(tctx,x0,y0,0,0     ,nCbS,nCbS/2,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,0,nCbS/2,nCbS,nCbS/2,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_Nx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0  ,   nCbS/2,nCbS,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS/2,0,nCbS/2,nCbS,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_2NxnU) {\n        read_prediction_unit(tctx,x0,y0,0,0,     nCbS,nCbS/4,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,0,nCbS/4,nCbS,nCbS*3/4,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_2NxnD) {\n        read_prediction_unit(tctx,x0,y0,0,0,       nCbS,nCbS*3/4,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,0,nCbS*3/4,nCbS,nCbS/4,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_nLx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0,     nCbS/4,nCbS,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS/4,0,nCbS*3/4,nCbS,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_nRx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0,       nCbS*3/4,nCbS,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS*3/4,0,nCbS/4,nCbS,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_NxN) {\n        read_prediction_unit(tctx,x0,y0,0,0,          nCbS/2,nCbS/2,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS/2,0,     nCbS/2,nCbS/2,ctDepth,nCS,1);\n        read_prediction_unit(tctx,x0,y0,0,nCbS/2,     nCbS/2,nCbS/2,ctDepth,nCS,2);\n        read_prediction_unit(tctx,x0,y0,nCbS/2,nCbS/2,nCbS/2,nCbS/2,ctDepth,nCS,3);\n      }\n      else {\n        assert(0); // undefined PartMode\n      }\n    } // INTER\n\n\n    // decode residual\n\n    if (!pcm_flag) { // !pcm\n      bool rqt_root_cbf;\n\n      uint8_t merge_flag = tctx->motion.merge_flag; // !!get_merge_flag(ctx,x0,y0);\n\n      if (cuPredMode != MODE_INTRA &&\n          !(PartMode == PART_2Nx2N && merge_flag)) {\n\n        rqt_root_cbf = !!decode_rqt_root_cbf(tctx);\n      }\n      else {\n        /* rqt_root_cbf=1 is inferred for Inter blocks with 2Nx2N, merge mode.\n           These must be some residual data, because otherwise, the CB could\n           also be coded in SKIP mode.\n         */\n\n        rqt_root_cbf = true;\n      }\n\n      //set_rqt_root_cbf(ctx,x0,y0, log2CbSize, rqt_root_cbf);\n\n      if (rqt_root_cbf) {\n        int MaxTrafoDepth;\n\n        if (cuPredMode==MODE_INTRA) {\n          MaxTrafoDepth = sps.max_transform_hierarchy_depth_intra + IntraSplitFlag;\n        }\n        else {\n          MaxTrafoDepth = sps.max_transform_hierarchy_depth_inter;\n        }\n\n        logtrace(LogSlice,\"MaxTrafoDepth: %d\\n\",MaxTrafoDepth);\n\n        uint8_t initial_chroma_cbf = 1;\n        if (sps.ChromaArrayType == CHROMA_MONO) {\n          initial_chroma_cbf = 0;\n        }\n\n        read_transform_tree(tctx, x0,y0, x0,y0, x0,y0, log2CbSize, 0,0,\n                            MaxTrafoDepth, IntraSplitFlag, cuPredMode,\n                            initial_chroma_cbf, initial_chroma_cbf);\n      }\n    } // !pcm\n  }\n}\n\n\n// ------------------------------------------------------------------------------------------\n\n\nvoid read_coding_quadtree(thread_context* tctx,\n                          int x0, int y0,\n                          int log2CbSize,\n                          int ctDepth)\n{\n  logtrace(LogSlice,\"- read_coding_quadtree %d;%d cbsize:%d depth:%d POC:%d\\n\",x0,y0,1<<log2CbSize,ctDepth,tctx->img->PicOrderCntVal);\n\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n\n  int split_flag;\n\n  // We only send a split flag if CU is larger than minimum size and\n  // completely contained within the image area.\n  // If it is partly outside the image area and not at minimum size,\n  // it is split. If already at minimum size, it is not split further.\n  if (x0+(1<<log2CbSize) <= sps.pic_width_in_luma_samples &&\n      y0+(1<<log2CbSize) <= sps.pic_height_in_luma_samples &&\n      log2CbSize > sps.Log2MinCbSizeY) {\n    split_flag = decode_split_cu_flag(tctx, x0,y0, ctDepth);\n  } else {\n    if (log2CbSize > sps.Log2MinCbSizeY) { split_flag=1; }\n    else                                  { split_flag=0; }\n  }\n\n\n  if (pps.cu_qp_delta_enabled_flag &&\n      log2CbSize >= pps.Log2MinCuQpDeltaSize)\n    {\n      tctx->IsCuQpDeltaCoded = 0;\n      tctx->CuQpDelta = 0;\n    }\n  else\n    {\n      // shdr->CuQpDelta = 0; // TODO check: is this the right place to set to default value ?\n    }\n\n\n  if (tctx->shdr->cu_chroma_qp_offset_enabled_flag &&\n      log2CbSize >= pps.Log2MinCuChromaQpOffsetSize) {\n    tctx->IsCuChromaQpOffsetCoded = 0;\n  }\n\n  if (split_flag) {\n    int x1 = x0 + (1<<(log2CbSize-1));\n    int y1 = y0 + (1<<(log2CbSize-1));\n\n    read_coding_quadtree(tctx,x0,y0, log2CbSize-1, ctDepth+1);\n\n    if (x1<sps.pic_width_in_luma_samples)\n      read_coding_quadtree(tctx,x1,y0, log2CbSize-1, ctDepth+1);\n\n    if (y1<sps.pic_height_in_luma_samples)\n      read_coding_quadtree(tctx,x0,y1, log2CbSize-1, ctDepth+1);\n\n    if (x1<sps.pic_width_in_luma_samples &&\n        y1<sps.pic_height_in_luma_samples)\n      read_coding_quadtree(tctx,x1,y1, log2CbSize-1, ctDepth+1);\n  }\n  else {\n    // set ctDepth of this CU\n\n    img->set_ctDepth(x0,y0, log2CbSize, ctDepth);\n\n    read_coding_unit(tctx, x0,y0, log2CbSize, ctDepth);\n  }\n\n  logtrace(LogSlice,\"-\\n\");\n}\n\n\n// ---------------------------------------------------------------------------\n\nenum DecodeResult {\n  Decode_EndOfSliceSegment,\n  Decode_EndOfSubstream,\n  Decode_Error\n};\n\n/* Decode CTBs until the end of sub-stream, the end-of-slice, or some error occurs.\n */\nenum DecodeResult decode_substream(thread_context* tctx,\n                                   bool block_wpp, // block on WPP dependencies\n                                   bool first_independent_substream)\n{\n  const pic_parameter_set& pps = tctx->img->get_pps();\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  const int ctbW = sps.PicWidthInCtbsY;\n\n\n  const int startCtbY = tctx->CtbY;\n\n  //printf(\"start decoding substream at %d;%d\\n\",tctx->CtbX,tctx->CtbY);\n\n  // in WPP mode: initialize CABAC model with stored model from row above\n\n  if ((!first_independent_substream || tctx->CtbY != startCtbY) &&\n      pps.entropy_coding_sync_enabled_flag &&\n      tctx->CtbY>=1 && tctx->CtbX==0)\n    {\n      if (sps.PicWidthInCtbsY>1) {\n        if ((tctx->CtbY-1) >= tctx->imgunit->ctx_models.size()) {\n          return Decode_Error;\n        }\n\n        //printf(\"CTX wait on %d/%d\\n\",1,tctx->CtbY-1);\n\n        // we have to wait until the context model data is there\n        tctx->img->wait_for_progress(tctx->task, 1,tctx->CtbY-1,CTB_PROGRESS_PREFILTER);\n\n        // copy CABAC model from previous CTB row\n        tctx->ctx_model = tctx->imgunit->ctx_models[(tctx->CtbY-1)];\n        tctx->imgunit->ctx_models[(tctx->CtbY-1)].release(); // not used anymore\n      }\n      else {\n        tctx->img->wait_for_progress(tctx->task, 0,tctx->CtbY-1,CTB_PROGRESS_PREFILTER);\n        initialize_CABAC_models(tctx);\n      }\n    }\n\n\n  do {\n    const int ctbx = tctx->CtbX;\n    const int ctby = tctx->CtbY;\n\n    if (ctbx+ctby*ctbW >= pps.CtbAddrRStoTS.size()) {\n        return Decode_Error;\n    }\n\n    if (ctbx >= sps.PicWidthInCtbsY ||\n        ctby >= sps.PicHeightInCtbsY) {\n        return Decode_Error;\n    }\n\n    if (block_wpp && ctby>0 && ctbx < ctbW-1) {\n\n      // TODO: if we are in tiles mode and at the right border, do not wait for x+1,y-1\n\n      //printf(\"wait on %d/%d (%d)\\n\",ctbx+1,ctby-1, ctbx+1+(ctby-1)*sps->PicWidthInCtbsY);\n\n      tctx->img->wait_for_progress(tctx->task, ctbx+1,ctby-1, CTB_PROGRESS_PREFILTER);\n    }\n\n    //printf(\"%p: decode %d;%d\\n\", tctx, tctx->CtbX,tctx->CtbY);\n\n\n    // read and decode CTB\n\n    if (tctx->ctx_model.empty() == false) {\n      return Decode_Error;\n    }\n\n    read_coding_tree_unit(tctx);\n\n\n    // save CABAC-model for WPP (except in last CTB row)\n\n    if (pps.entropy_coding_sync_enabled_flag &&\n        ctbx == 1 &&\n        ctby < sps.PicHeightInCtbsY-1)\n      {\n        // no storage for context table has been allocated\n        if (tctx->imgunit->ctx_models.size() <= ctby) {\n          return Decode_Error;\n        }\n\n        tctx->imgunit->ctx_models[ctby] = tctx->ctx_model;\n        tctx->imgunit->ctx_models[ctby].decouple(); // store an independent copy\n      }\n\n\n    // end of slice segment ?\n\n    int end_of_slice_segment_flag = decode_CABAC_term_bit(&tctx->cabac_decoder);\n    //printf(\"end-of-slice flag: %d\\n\", end_of_slice_segment_flag);\n\n    if (end_of_slice_segment_flag) {\n      // at the end of the slice segment, we store the CABAC model if we need it\n      // because a dependent slice may follow\n\n      if (pps.dependent_slice_segments_enabled_flag) {\n        tctx->shdr->ctx_model_storage = tctx->ctx_model;\n        tctx->shdr->ctx_model_storage.decouple(); // store an independent copy\n\n        tctx->shdr->ctx_model_storage_defined = true;\n      }\n    }\n\n    tctx->img->ctb_progress[ctbx+ctby*ctbW].set_progress(CTB_PROGRESS_PREFILTER);\n\n    //printf(\"%p: decoded %d|%d\\n\",tctx, ctby,ctbx);\n\n\n    logtrace(LogSlice,\"read CTB %d -> end=%d\\n\", tctx->CtbAddrInRS, end_of_slice_segment_flag);\n    //printf(\"read CTB %d -> end=%d\\n\", tctx->CtbAddrInRS, end_of_slice_segment_flag);\n\n    const int lastCtbY = tctx->CtbY;\n\n    bool endOfPicture = advanceCtbAddr(tctx); // true if we read past the end of the image\n\n    if (endOfPicture &&\n        end_of_slice_segment_flag == false)\n      {\n        tctx->decctx->add_warning(DE265_WARNING_CTB_OUTSIDE_IMAGE_AREA, false);\n        tctx->img->integrity = INTEGRITY_DECODING_ERRORS;\n        return Decode_Error;\n      }\n\n\n    if (end_of_slice_segment_flag) {\n      /* corrupted inputs may send the end_of_slice_segment_flag even if not all\n         CTBs in a row have been coded. Hence, we mark all of them as finished.\n       */\n\n      /*\n      for (int x = ctbx+1 ; x<sps->PicWidthInCtbsY; x++) {\n        printf(\"mark skipped %d;%d\\n\",ctbx,ctby);\n        tctx->img->ctb_progress[ctbx+ctby*ctbW].set_progress(CTB_PROGRESS_PREFILTER);\n      }\n      */\n\n      return Decode_EndOfSliceSegment;\n    }\n\n\n    if (!end_of_slice_segment_flag) {\n      bool end_of_sub_stream = false;\n      end_of_sub_stream |= (pps.tiles_enabled_flag &&\n                            pps.TileId[tctx->CtbAddrInTS] != pps.TileId[tctx->CtbAddrInTS-1]);\n      end_of_sub_stream |= (pps.entropy_coding_sync_enabled_flag &&\n                            lastCtbY != tctx->CtbY);\n\n      if (end_of_sub_stream) {\n        int end_of_sub_stream_one_bit = decode_CABAC_term_bit(&tctx->cabac_decoder);\n        if (!end_of_sub_stream_one_bit) {\n          tctx->decctx->add_warning(DE265_WARNING_EOSS_BIT_NOT_SET, false);\n          tctx->img->integrity = INTEGRITY_DECODING_ERRORS;\n          return Decode_Error;\n        }\n\n        init_CABAC_decoder_2(&tctx->cabac_decoder); // byte alignment\n        return Decode_EndOfSubstream;\n      }\n    }\n\n  } while (true);\n}\n\n\n\nbool initialize_CABAC_at_slice_segment_start(thread_context* tctx)\n{\n  de265_image* img = tctx->img;\n  const pic_parameter_set& pps = img->get_pps();\n  const seq_parameter_set& sps = img->get_sps();\n  slice_segment_header* shdr = tctx->shdr;\n\n  if (shdr->dependent_slice_segment_flag) {\n    int prevCtb = pps.CtbAddrTStoRS[ pps.CtbAddrRStoTS[shdr->slice_segment_address] -1 ];\n\n    int sliceIdx = img->get_SliceHeaderIndex_atIndex(prevCtb);\n    if (sliceIdx >= img->slices.size()) {\n      return false;\n    }\n    slice_segment_header* prevCtbHdr = img->slices[ sliceIdx ];\n\n    if (pps.is_tile_start_CTB(shdr->slice_segment_address % sps.PicWidthInCtbsY,\n                              shdr->slice_segment_address / sps.PicWidthInCtbsY\n                              )) {\n      initialize_CABAC_models(tctx);\n    }\n    else {\n      // wait for previous slice to finish decoding\n\n      //printf(\"wait for previous slice to finish decoding\\n\");\n\n\n      slice_unit* prevSliceSegment = tctx->imgunit->get_prev_slice_segment(tctx->sliceunit);\n      //assert(prevSliceSegment);\n      if (prevSliceSegment==NULL) {\n        return false;\n      }\n\n      prevSliceSegment->finished_threads.wait_for_progress(prevSliceSegment->nThreads);\n\n\n      /*\n      printf(\"wait for %d,%d (init)\\n\",\n             prevCtb / sps->PicWidthInCtbsY,\n             prevCtb % sps->PicWidthInCtbsY);\n      tctx->img->wait_for_progress(tctx->task, prevCtb, CTB_PROGRESS_PREFILTER);\n      */\n\n      if (!prevCtbHdr->ctx_model_storage_defined) {\n        return false;\n      }\n\n      tctx->ctx_model = prevCtbHdr->ctx_model_storage;\n      prevCtbHdr->ctx_model_storage.release();\n    }\n  }\n  else {\n    initialize_CABAC_models(tctx);\n  }\n\n  return true;\n}\n\n\nstd::string thread_task_ctb_row::name() const {\n  char buf[100];\n  sprintf(buf,\"ctb-row-%d\",debug_startCtbRow);\n  return buf;\n}\n\n\nstd::string thread_task_slice_segment::name() const {\n  char buf[100];\n  sprintf(buf,\"slice-segment-%d;%d\",debug_startCtbX,debug_startCtbY);\n  return buf;\n}\n\n\nvoid thread_task_slice_segment::work()\n{\n  thread_task_slice_segment* data = this;\n  thread_context* tctx = data->tctx;\n  de265_image* img = tctx->img;\n\n  state = Running;\n  img->thread_run(this);\n\n  setCtbAddrFromTS(tctx);\n\n  //printf(\"%p: A start decoding at %d/%d\\n\", tctx, tctx->CtbX,tctx->CtbY);\n\n  if (data->firstSliceSubstream) {\n    bool success = initialize_CABAC_at_slice_segment_start(tctx);\n    if (!success) {\n      state = Finished;\n      tctx->sliceunit->finished_threads.increase_progress(1);\n      img->thread_finishes(this);\n      return;\n    }\n  }\n  else {\n    initialize_CABAC_models(tctx);\n  }\n\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n\n  /*enum DecodeResult result =*/ decode_substream(tctx, false, data->firstSliceSubstream);\n\n  state = Finished;\n  tctx->sliceunit->finished_threads.increase_progress(1);\n  img->thread_finishes(this);\n\n  return; // DE265_OK;\n}\n\n\nvoid thread_task_ctb_row::work()\n{\n  thread_task_ctb_row* data = this;\n  thread_context* tctx = data->tctx;\n  de265_image* img = tctx->img;\n\n  const seq_parameter_set& sps = img->get_sps();\n  int ctbW = sps.PicWidthInCtbsY;\n\n  state = Running;\n  img->thread_run(this);\n\n  setCtbAddrFromTS(tctx);\n\n  int ctby = tctx->CtbAddrInRS / ctbW;\n  int myCtbRow = ctby;\n\n  //printf(\"start CTB-row decoding at row %d\\n\", ctby);\n\n  if (data->firstSliceSubstream) {\n    bool success = initialize_CABAC_at_slice_segment_start(tctx);\n    if (!success) {\n      // could not decode this row, mark whole row as finished\n      for (int x=0;x<ctbW;x++) {\n        img->ctb_progress[myCtbRow*ctbW + x].set_progress(CTB_PROGRESS_PREFILTER);\n      }\n\n      state = Finished;\n      tctx->sliceunit->finished_threads.increase_progress(1);\n      img->thread_finishes(this);\n      return;\n    }\n    //initialize_CABAC(tctx);\n  }\n\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n\n  bool firstIndependentSubstream =\n    data->firstSliceSubstream && !tctx->shdr->dependent_slice_segment_flag;\n\n  /*enum DecodeResult result =*/\n  decode_substream(tctx, true, firstIndependentSubstream);\n\n  // mark progress on remaining CTBs in row (in case of decoder error and early termination)\n\n  // TODO: what about slices that end properly in the middle of a CTB row?\n\n  if (tctx->CtbY == myCtbRow) {\n    int lastCtbX = sps.PicWidthInCtbsY; // assume no tiles when WPP is on\n    for (int x = tctx->CtbX; x<lastCtbX ; x++) {\n\n      if (x        < sps.PicWidthInCtbsY &&\n          myCtbRow < sps.PicHeightInCtbsY) {\n        img->ctb_progress[myCtbRow*ctbW + x].set_progress(CTB_PROGRESS_PREFILTER);\n      }\n    }\n  }\n\n  state = Finished;\n  tctx->sliceunit->finished_threads.increase_progress(1);\n  img->thread_finishes(this);\n}\n\n\nde265_error read_slice_segment_data(thread_context* tctx)\n{\n  setCtbAddrFromTS(tctx);\n\n  de265_image* img = tctx->img;\n  const pic_parameter_set& pps = img->get_pps();\n  const seq_parameter_set& sps = img->get_sps();\n  slice_segment_header* shdr = tctx->shdr;\n\n  bool success = initialize_CABAC_at_slice_segment_start(tctx);\n  if (!success) {\n    return DE265_ERROR_UNSPECIFIED_DECODING_ERROR;\n  }\n\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n\n  //printf(\"-----\\n\");\n\n  bool first_slice_substream = !shdr->dependent_slice_segment_flag;\n\n  int substream=0;\n\n  enum DecodeResult result;\n  do {\n    int ctby = tctx->CtbY;\n\n\n    // check whether entry_points[] are correct in the bitstream\n\n    if (substream>0) {\n      if (substream-1 >= tctx->shdr->entry_point_offset.size() ||\n          tctx->cabac_decoder.bitstream_curr - tctx->cabac_decoder.bitstream_start -2 /* -2 because of CABAC init */\n          != tctx->shdr->entry_point_offset[substream-1]) {\n        tctx->decctx->add_warning(DE265_WARNING_INCORRECT_ENTRY_POINT_OFFSET, true);\n      }\n    }\n\n    substream++;\n\n\n    result = decode_substream(tctx, false, first_slice_substream);\n\n\n    if (result == Decode_EndOfSliceSegment ||\n        result == Decode_Error) {\n      break;\n    }\n\n    first_slice_substream = false;\n\n    if (pps.tiles_enabled_flag) {\n      initialize_CABAC_models(tctx);\n    }\n  } while (true);\n\n  return DE265_OK;\n}\n\n\n/* TODO:\n   When a task wants to block, but is the first in the list of pending tasks,\n   do some error concealment instead of blocking, since it will never be deblocked.\n   This will only happen in the case of input error.\n */\n"], "fixing_code": ["/*\n * H.265 video codec.\n * Copyright (c) 2013-2014 struktur AG, Dirk Farin <farin@struktur.de>\n *\n * Authors: struktur AG, Dirk Farin <farin@struktur.de>\n *          Min Chen <chenm003@163.com>\n *\n * This file is part of libde265.\n *\n * libde265 is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation, either version 3 of\n * the License, or (at your option) any later version.\n *\n * libde265 is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with libde265.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"slice.h\"\n#include \"motion.h\"\n#include \"util.h\"\n#include \"scan.h\"\n#include \"intrapred.h\"\n#include \"transform.h\"\n#include \"threads.h\"\n#include \"image.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\n\n#define LOCK de265_mutex_lock(&ctx->thread_pool.mutex)\n#define UNLOCK de265_mutex_unlock(&ctx->thread_pool.mutex)\n\nextern bool read_short_term_ref_pic_set(error_queue* errqueue,\n                                        const seq_parameter_set* sps,\n                                        bitreader* br,\n                                        ref_pic_set* out_set,\n                                        int idxRps,  // index of the set to be read\n                                        const std::vector<ref_pic_set>& sets,\n                                        bool sliceRefPicSet);\n\n\nvoid read_coding_tree_unit(thread_context* tctx);\nvoid read_coding_quadtree(thread_context* tctx,\n                          int xCtb, int yCtb,\n                          int Log2CtbSizeY,\n                          int ctDepth);\n/*\nvoid decode_inter_block(decoder_context* ctx,thread_context* tctx,\n                        int xC, int yC, int log2CbSize);\n*/\n\nvoid slice_segment_header::set_defaults()\n{\n  slice_index = 0;\n\n  first_slice_segment_in_pic_flag = 1;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n\n  slice_type = SLICE_TYPE_I;\n  pic_output_flag = 1;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 1;\n  // ref_pic_set slice_ref_pic_set;\n\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics = 0;\n\n  //uint8_t lt_idx_sps[MAX_NUM_REF_PICS];\n  //int     poc_lsb_lt[MAX_NUM_REF_PICS];\n  //char    used_by_curr_pic_lt_flag[MAX_NUM_REF_PICS];\n\n  //char delta_poc_msb_present_flag[MAX_NUM_REF_PICS];\n  //int delta_poc_msb_cycle_lt[MAX_NUM_REF_PICS];\n\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active=1; // [1;16]\n  num_ref_idx_l1_active=1; // [1;16]\n\n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  //uint8_t list_entry_l0[16];\n  //uint8_t list_entry_l1[16];\n\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n\n  // --- pred_weight_table ---\n\n  luma_log2_weight_denom=0; // [0;7]\n  ChromaLog2WeightDenom=0;  // [0;7]\n\n  // first index is L0/L1\n  /*\n  uint8_t luma_weight_flag[2][16];   // bool\n  uint8_t chroma_weight_flag[2][16]; // bool\n  int16_t LumaWeight[2][16];\n  int8_t  luma_offset[2][16];\n  int16_t ChromaWeight[2][16][2];\n  int8_t  ChromaOffset[2][16][2];\n  */\n\n\n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n\n  cu_chroma_qp_offset_enabled_flag = 0;\n\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset=0; // = pps->beta_offset if undefined\n  slice_tc_offset=0;   // = pps->tc_offset if undefined\n\n  slice_loop_filter_across_slices_enabled_flag = 0;\n\n  num_entry_point_offsets = 0;\n  //int  offset_len;\n  //std::vector<int> entry_point_offset;\n\n  slice_segment_header_extension_length = 0;\n\n  SliceAddrRS = slice_segment_address;\n}\n\n\nbool read_pred_weight_table(bitreader* br, slice_segment_header* shdr, decoder_context* ctx)\n{\n  int vlc;\n\n  pic_parameter_set* pps = ctx->get_pps((int)shdr->slice_pic_parameter_set_id);\n  assert(pps);\n  seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  assert(sps);\n\n  shdr->luma_log2_weight_denom = vlc = get_uvlc(br);\n  if (vlc<0 || vlc>7) return false;\n\n  if (sps->chroma_format_idc != 0) {\n    vlc = get_svlc(br);\n    vlc += shdr->luma_log2_weight_denom;\n    if (vlc<0 || vlc>7) return false;\n    shdr->ChromaLog2WeightDenom = vlc;\n  }\n\n  int sumWeightFlags = 0;\n\n  for (int l=0;l<=1;l++)\n    if (l==0 || (l==1 && shdr->slice_type == SLICE_TYPE_B))\n      {\n        int num_ref = (l==0 ? shdr->num_ref_idx_l0_active-1 : shdr->num_ref_idx_l1_active-1);\n\n        for (int i=0;i<=num_ref;i++) {\n          shdr->luma_weight_flag[l][i] = get_bits(br,1);\n          if (shdr->luma_weight_flag[l][i]) sumWeightFlags++;\n        }\n\n        if (sps->chroma_format_idc != 0) {\n          for (int i=0;i<=num_ref;i++) {\n            shdr->chroma_weight_flag[l][i] = get_bits(br,1);\n            if (shdr->chroma_weight_flag[l][i]) sumWeightFlags+=2;\n          }\n        }\n\n        for (int i=0;i<=num_ref;i++) {\n          if (shdr->luma_weight_flag[l][i]) {\n\n            // delta_luma_weight\n\n            vlc = get_svlc(br);\n            if (vlc < -128 || vlc > 127) return false;\n\n            shdr->LumaWeight[l][i] = (1<<shdr->luma_log2_weight_denom) + vlc;\n\n            // luma_offset\n\n            vlc = get_svlc(br);\n            if (vlc < -sps->WpOffsetHalfRangeY || vlc > sps->WpOffsetHalfRangeY-1) return false;\n            shdr->luma_offset[l][i] = vlc;\n          }\n          else {\n            shdr->LumaWeight[l][i] = 1<<shdr->luma_log2_weight_denom;\n            shdr->luma_offset[l][i] = 0;\n          }\n\n          if (shdr->chroma_weight_flag[l][i])\n            for (int j=0;j<2;j++) {\n              // delta_chroma_weight\n\n              vlc = get_svlc(br);\n              if (vlc < -128 || vlc >  127) return false;\n\n              shdr->ChromaWeight[l][i][j] = (1<<shdr->ChromaLog2WeightDenom) + vlc;\n\n              // delta_chroma_offset\n\n              vlc = get_svlc(br);\n              if (vlc < -4*sps->WpOffsetHalfRangeC ||\n                  vlc >  4*sps->WpOffsetHalfRangeC-1) return false;\n\n              vlc = Clip3(-sps->WpOffsetHalfRangeC,\n                          sps->WpOffsetHalfRangeC-1,\n                          (sps->WpOffsetHalfRangeC\n                           +vlc\n                           -((sps->WpOffsetHalfRangeC*shdr->ChromaWeight[l][i][j])\n                             >> shdr->ChromaLog2WeightDenom)));\n\n              shdr->ChromaOffset[l][i][j] = vlc;\n            }\n          else {\n            for (int j=0;j<2;j++) {\n              shdr->ChromaWeight[l][i][j] = 1<<shdr->ChromaLog2WeightDenom;\n              shdr->ChromaOffset[l][i][j] = 0;\n            }\n          }\n        }\n      }\n\n  // TODO: bitstream conformance requires that 'sumWeightFlags<=24'\n\n  return true;\n}\n\n\nvoid slice_segment_header::reset()\n{\n  pps = NULL;\n\n  slice_index = 0;\n\n  first_slice_segment_in_pic_flag = 0;\n  no_output_of_prior_pics_flag = 0;\n  slice_pic_parameter_set_id = 0;\n  dependent_slice_segment_flag = 0;\n  slice_segment_address = 0;\n\n  slice_type = 0;\n  pic_output_flag = 0;\n  colour_plane_id = 0;\n  slice_pic_order_cnt_lsb = 0;\n  short_term_ref_pic_set_sps_flag = 0;\n  slice_ref_pic_set.reset();\n\n  short_term_ref_pic_set_idx = 0;\n  num_long_term_sps = 0;\n  num_long_term_pics= 0;\n\n  for (int i=0;i<MAX_NUM_REF_PICS;i++) {\n    lt_idx_sps[i] = 0;\n    poc_lsb_lt[i] = 0;\n    used_by_curr_pic_lt_flag[i] = 0;\n    delta_poc_msb_present_flag[i] = 0;\n    delta_poc_msb_cycle_lt[i] = 0;\n  }\n\n  slice_temporal_mvp_enabled_flag = 0;\n  slice_sao_luma_flag = 0;\n  slice_sao_chroma_flag = 0;\n\n  num_ref_idx_active_override_flag = 0;\n  num_ref_idx_l0_active = 0;\n  num_ref_idx_l1_active = 0;\n\n  ref_pic_list_modification_flag_l0 = 0;\n  ref_pic_list_modification_flag_l1 = 0;\n  for (int i=0;i<16;i++) {\n    list_entry_l0[i] = 0;\n    list_entry_l1[i] = 0;\n  }\n\n  mvd_l1_zero_flag = 0;\n  cabac_init_flag  = 0;\n  collocated_from_l0_flag = 0;\n  collocated_ref_idx = 0;\n\n  luma_log2_weight_denom = 0;\n  ChromaLog2WeightDenom  = 0;\n\n  for (int i=0;i<2;i++)\n    for (int j=0;j<16;j++) {\n      luma_weight_flag[i][j] = 0;\n      chroma_weight_flag[i][j] = 0;\n      LumaWeight[i][j] = 0;\n      luma_offset[i][j] = 0;\n      ChromaWeight[i][j][0] = ChromaWeight[i][j][1] = 0;\n      ChromaOffset[i][j][0] = ChromaOffset[i][j][1] = 0;\n    }\n\n  five_minus_max_num_merge_cand = 0;\n  slice_qp_delta = 0;\n\n  slice_cb_qp_offset = 0;\n  slice_cr_qp_offset = 0;\n\n  cu_chroma_qp_offset_enabled_flag = 0;\n\n  deblocking_filter_override_flag = 0;\n  slice_deblocking_filter_disabled_flag = 0;\n  slice_beta_offset = 0;\n  slice_tc_offset = 0;\n\n  slice_loop_filter_across_slices_enabled_flag = 0;\n\n  num_entry_point_offsets = 0;\n  offset_len = 0;\n  entry_point_offset.clear();\n\n  slice_segment_header_extension_length = 0;\n\n  SliceAddrRS = 0;\n  SliceQPY = 0;\n\n  initType = 0;\n\n  MaxNumMergeCand = 0;\n  CurrRpsIdx = 0;\n  CurrRps.reset();\n  NumPocTotalCurr = 0;\n\n  for (int i=0;i<2;i++)\n    for (int j=0;j<MAX_NUM_REF_PICS;j++) {\n      RefPicList[i][j] = 0;\n      RefPicList_POC[i][j] = 0;\n      RefPicList_PicState[i][j] = 0;\n      LongTermRefPic[i][j] = 0;\n    }\n\n  //context_model ctx_model_storage[CONTEXT_MODEL_TABLE_LENGTH];\n\n  RemoveReferencesList.clear();\n\n  ctx_model_storage_defined = false;\n}\n\n\nde265_error slice_segment_header::read(bitreader* br, decoder_context* ctx,\n                                       bool* continueDecoding)\n{\n  *continueDecoding = false;\n  reset();\n\n  // set defaults\n\n  dependent_slice_segment_flag = 0;\n\n\n  // read bitstream\n\n  first_slice_segment_in_pic_flag = get_bits(br,1);\n\n  if (ctx->get_RapPicFlag()) { // TODO: is this still correct ? Should we drop RapPicFlag ?\n    no_output_of_prior_pics_flag = get_bits(br,1);\n  }\n\n  slice_pic_parameter_set_id = get_uvlc(br);\n  if (slice_pic_parameter_set_id >= DE265_MAX_PPS_SETS ||\n      slice_pic_parameter_set_id == UVLC_ERROR) {\n    ctx->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return DE265_OK;\n  }\n\n  if (!ctx->has_pps(slice_pic_parameter_set_id)) {\n    ctx->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return DE265_OK;\n  }\n\n  pps = ctx->get_shared_pps(slice_pic_parameter_set_id);\n\n  const seq_parameter_set* sps = pps->sps.get();\n  if (!sps->sps_read) {\n    ctx->add_warning(DE265_WARNING_NONEXISTING_SPS_REFERENCED, false);\n    *continueDecoding = false;\n    return DE265_OK;\n  }\n\n  if (!first_slice_segment_in_pic_flag) {\n    if (pps->dependent_slice_segments_enabled_flag) {\n      dependent_slice_segment_flag = get_bits(br,1);\n    } else {\n      dependent_slice_segment_flag = 0;\n    }\n\n    int slice_segment_address = get_bits(br, ceil_log2(sps->PicSizeInCtbsY));\n\n    if (dependent_slice_segment_flag) {\n      if (slice_segment_address == 0) {\n        *continueDecoding = false;\n        ctx->add_warning(DE265_WARNING_DEPENDENT_SLICE_WITH_ADDRESS_ZERO, false);\n        return DE265_OK;\n      }\n\n      if (ctx->previous_slice_header == NULL) {\n        return DE265_ERROR_NO_INITIAL_SLICE_HEADER;\n      }\n\n      *this = *ctx->previous_slice_header;\n\n      first_slice_segment_in_pic_flag = 0;\n      dependent_slice_segment_flag = 1;\n    }\n\n    this->slice_segment_address = slice_segment_address;\n  } else {\n    dependent_slice_segment_flag = 0;\n    slice_segment_address = 0;\n  }\n\n  if (slice_segment_address < 0 ||\n      slice_segment_address >= sps->PicSizeInCtbsY) {\n    ctx->add_warning(DE265_WARNING_SLICE_SEGMENT_ADDRESS_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n  //printf(\"SLICE %d (%d)\\n\",slice_segment_address, sps->PicSizeInCtbsY);\n\n\n  if (!dependent_slice_segment_flag) {\n    for (int i=0; i<pps->num_extra_slice_header_bits; i++) {\n      //slice_reserved_undetermined_flag[i]\n      skip_bits(br,1);\n    }\n\n    slice_type = get_uvlc(br);\n    if (slice_type > 2 ||\n\tslice_type == UVLC_ERROR) {\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      *continueDecoding = false;\n      return DE265_OK;\n    }\n\n    if (pps->output_flag_present_flag) {\n      pic_output_flag = get_bits(br,1);\n    }\n    else {\n      pic_output_flag = 1;\n    }\n\n    if (sps->separate_colour_plane_flag == 1) {\n      colour_plane_id = get_bits(br,2);\n    }\n\n\n    slice_pic_order_cnt_lsb = 0;\n    short_term_ref_pic_set_sps_flag = 0;\n\n    int NumLtPics = 0;\n\n    if (ctx->get_nal_unit_type() != NAL_UNIT_IDR_W_RADL &&\n        ctx->get_nal_unit_type() != NAL_UNIT_IDR_N_LP) {\n      slice_pic_order_cnt_lsb = get_bits(br, sps->log2_max_pic_order_cnt_lsb);\n      short_term_ref_pic_set_sps_flag = get_bits(br,1);\n\n      if (!short_term_ref_pic_set_sps_flag) {\n        read_short_term_ref_pic_set(ctx, sps,\n                                    br, &slice_ref_pic_set,\n                                    sps->num_short_term_ref_pic_sets(),\n                                    sps->ref_pic_sets,\n                                    true);\n\n        CurrRpsIdx = sps->num_short_term_ref_pic_sets();\n        CurrRps    = slice_ref_pic_set;\n      }\n      else {\n        int nBits = ceil_log2(sps->num_short_term_ref_pic_sets());\n        if (nBits>0) short_term_ref_pic_set_idx = get_bits(br,nBits);\n        else         short_term_ref_pic_set_idx = 0;\n\n        if (short_term_ref_pic_set_idx >= sps->num_short_term_ref_pic_sets()) {\n          ctx->add_warning(DE265_WARNING_SHORT_TERM_REF_PIC_SET_OUT_OF_RANGE, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        CurrRpsIdx = short_term_ref_pic_set_idx;\n        CurrRps    = sps->ref_pic_sets[CurrRpsIdx];\n      }\n\n\n      // --- long-term MC ---\n\n      if (sps->long_term_ref_pics_present_flag) {\n        if (sps->num_long_term_ref_pics_sps > 0) {\n          num_long_term_sps = get_uvlc(br);\n          if (num_long_term_sps == UVLC_ERROR) {\n            return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n        }\n        else {\n          num_long_term_sps = 0;\n        }\n\n        num_long_term_pics= get_uvlc(br);\n        if (num_long_term_pics == UVLC_ERROR) {\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        // check maximum number of reference frames\n\n        if (num_long_term_sps +\n            num_long_term_pics +\n            CurrRps.NumNegativePics +\n            CurrRps.NumPositivePics\n            > sps->sps_max_dec_pic_buffering[sps->sps_max_sub_layers-1])\n          {\n            ctx->add_warning(DE265_WARNING_MAX_NUM_REF_PICS_EXCEEDED, false);\n            *continueDecoding = false;\n            return DE265_OK;\n          }\n\n        for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {\n          if (i < num_long_term_sps) {\n            int nBits = ceil_log2(sps->num_long_term_ref_pics_sps);\n            lt_idx_sps[i] = get_bits(br, nBits);\n\n            // check that the referenced lt-reference really exists\n\n            if (lt_idx_sps[i] >= sps->num_long_term_ref_pics_sps) {\n              ctx->add_warning(DE265_NON_EXISTING_LT_REFERENCE_CANDIDATE_IN_SLICE_HEADER, false);\n              *continueDecoding = false;\n              return DE265_OK;\n            }\n\n            // delta_poc_msb_present_flag[i] = 0; // TODO ?\n\n            ctx->PocLsbLt[i] = sps->lt_ref_pic_poc_lsb_sps[ lt_idx_sps[i] ];\n            ctx->UsedByCurrPicLt[i] = sps->used_by_curr_pic_lt_sps_flag[ lt_idx_sps[i] ];\n          }\n          else {\n            int nBits = sps->log2_max_pic_order_cnt_lsb;\n            poc_lsb_lt[i] = get_bits(br, nBits);\n            used_by_curr_pic_lt_flag[i] = get_bits(br,1);\n\n            ctx->PocLsbLt[i] = poc_lsb_lt[i];\n            ctx->UsedByCurrPicLt[i] = used_by_curr_pic_lt_flag[i];\n          }\n\n          if (ctx->UsedByCurrPicLt[i]) {\n            NumLtPics++;\n          }\n\n          delta_poc_msb_present_flag[i] = get_bits(br,1);\n          if (delta_poc_msb_present_flag[i]) {\n            delta_poc_msb_cycle_lt[i] = get_uvlc(br);\n            if (delta_poc_msb_cycle_lt[i]==UVLC_ERROR) {\n              return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n            }\n          }\n          else {\n            delta_poc_msb_cycle_lt[i] = 0;\n          }\n\n          if (i==0 || i==num_long_term_sps) {\n            ctx->DeltaPocMsbCycleLt[i] = delta_poc_msb_cycle_lt[i];\n          }\n          else {\n            ctx->DeltaPocMsbCycleLt[i] = (delta_poc_msb_cycle_lt[i] +\n                                          ctx->DeltaPocMsbCycleLt[i-1]);\n          }\n        }\n      }\n      else {\n        num_long_term_sps = 0;\n        num_long_term_pics= 0;\n      }\n\n      if (sps->sps_temporal_mvp_enabled_flag) {\n        slice_temporal_mvp_enabled_flag = get_bits(br,1);\n      }\n      else {\n        slice_temporal_mvp_enabled_flag = 0;\n      }\n    }\n    else {\n      slice_pic_order_cnt_lsb = 0;\n      num_long_term_sps = 0;\n      num_long_term_pics= 0;\n    }\n\n\n    // --- SAO ---\n\n    if (sps->sample_adaptive_offset_enabled_flag) {\n      slice_sao_luma_flag   = get_bits(br,1);\n\n      if (sps->ChromaArrayType != CHROMA_MONO) {\n        slice_sao_chroma_flag = get_bits(br,1);\n      }\n      else {\n        slice_sao_chroma_flag = 0;\n      }\n    }\n    else {\n      slice_sao_luma_flag   = 0;\n      slice_sao_chroma_flag = 0;\n    }\n\n    num_ref_idx_l0_active = 0;\n    num_ref_idx_l1_active = 0;\n\n    if (slice_type == SLICE_TYPE_P  ||\n        slice_type == SLICE_TYPE_B) {\n      num_ref_idx_active_override_flag = get_bits(br,1);\n      if (num_ref_idx_active_override_flag) {\n        num_ref_idx_l0_active = get_uvlc(br);\n        if (num_ref_idx_l0_active == UVLC_ERROR) {\n\t  ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t}\n        num_ref_idx_l0_active++;;\n\n        if (slice_type == SLICE_TYPE_B) {\n          num_ref_idx_l1_active = get_uvlc(br);\n          if (num_ref_idx_l1_active == UVLC_ERROR) {\n\t    ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t  }\n          num_ref_idx_l1_active++;\n        }\n      }\n      else {\n        num_ref_idx_l0_active = pps->num_ref_idx_l0_default_active;\n        num_ref_idx_l1_active = pps->num_ref_idx_l1_default_active;\n      }\n\n      if (num_ref_idx_l0_active > 16) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n      if (num_ref_idx_l1_active > 16) { return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE; }\n\n      NumPocTotalCurr = CurrRps.NumPocTotalCurr_shortterm_only + NumLtPics;\n\n      if (pps->lists_modification_present_flag && NumPocTotalCurr > 1) {\n\n        int nBits = ceil_log2(NumPocTotalCurr);\n\n        ref_pic_list_modification_flag_l0 = get_bits(br,1);\n        if (ref_pic_list_modification_flag_l0) {\n          for (int i=0;i<num_ref_idx_l0_active;i++) {\n            list_entry_l0[i] = get_bits(br, nBits);\n          }\n        }\n\n        if (slice_type == SLICE_TYPE_B) {\n          ref_pic_list_modification_flag_l1 = get_bits(br,1);\n          if (ref_pic_list_modification_flag_l1) {\n            for (int i=0;i<num_ref_idx_l1_active;i++) {\n              list_entry_l1[i] = get_bits(br, nBits);\n            }\n          }\n        }\n        else {\n          ref_pic_list_modification_flag_l1 = 0;\n        }\n      }\n      else {\n        ref_pic_list_modification_flag_l0 = 0;\n        ref_pic_list_modification_flag_l1 = 0;\n      }\n\n      if (slice_type == SLICE_TYPE_B) {\n        mvd_l1_zero_flag = get_bits(br,1);\n      }\n\n      if (pps->cabac_init_present_flag) {\n        cabac_init_flag = get_bits(br,1);\n      }\n      else {\n        cabac_init_flag = 0;\n      }\n\n      if (slice_temporal_mvp_enabled_flag) {\n        if (slice_type == SLICE_TYPE_B)\n          collocated_from_l0_flag = get_bits(br,1);\n        else\n          collocated_from_l0_flag = 1;\n\n        if (( collocated_from_l0_flag && num_ref_idx_l0_active > 1) ||\n            (!collocated_from_l0_flag && num_ref_idx_l1_active > 1)) {\n          collocated_ref_idx = get_uvlc(br);\n          if (collocated_ref_idx == UVLC_ERROR) {\n\t    ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t  }\n        }\n        else {\n          collocated_ref_idx = 0;\n        }\n\n        // check whether collocated_ref_idx points to a valid index\n\n        if (( collocated_from_l0_flag && collocated_ref_idx >= num_ref_idx_l0_active) ||\n            (!collocated_from_l0_flag && collocated_ref_idx >= num_ref_idx_l1_active)) {\n          ctx->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n      }\n\n\n      if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||\n          (pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B)) {\n\n        if (!read_pred_weight_table(br,this,ctx))\n          {\n\t    ctx->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n      }\n\n      five_minus_max_num_merge_cand = get_uvlc(br);\n      if (five_minus_max_num_merge_cand == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n      MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n    }\n\n    slice_qp_delta = get_svlc(br);\n    if (slice_qp_delta == UVLC_ERROR) {\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n    //logtrace(LogSlice,\"slice_qp_delta: %d\\n\",shdr->slice_qp_delta);\n\n    if (pps->pps_slice_chroma_qp_offsets_present_flag) {\n      slice_cb_qp_offset = get_svlc(br);\n      if (slice_cb_qp_offset == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n\n      slice_cr_qp_offset = get_svlc(br);\n      if (slice_cr_qp_offset == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n    else {\n      slice_cb_qp_offset = 0;\n      slice_cr_qp_offset = 0;\n    }\n\n    if (pps->range_extension.chroma_qp_offset_list_enabled_flag) {\n      cu_chroma_qp_offset_enabled_flag = get_bits(br,1);\n    }\n\n    if (pps->deblocking_filter_override_enabled_flag) {\n      deblocking_filter_override_flag = get_bits(br,1);\n    }\n    else {\n      deblocking_filter_override_flag = 0;\n    }\n\n    slice_beta_offset = pps->beta_offset;\n    slice_tc_offset   = pps->tc_offset;\n\n    if (deblocking_filter_override_flag) {\n      slice_deblocking_filter_disabled_flag = get_bits(br,1);\n      if (!slice_deblocking_filter_disabled_flag) {\n        slice_beta_offset = get_svlc(br);\n        if (slice_beta_offset == UVLC_ERROR) {\n\t  ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t  return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t}\n        slice_beta_offset *= 2;\n\n        slice_tc_offset   = get_svlc(br);\n        if (slice_tc_offset == UVLC_ERROR) {\n\t  ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\t  return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n\t}\n        slice_tc_offset   *= 2;\n      }\n    }\n    else {\n      slice_deblocking_filter_disabled_flag = pps->pic_disable_deblocking_filter_flag;\n    }\n\n    if (pps->pps_loop_filter_across_slices_enabled_flag  &&\n        (slice_sao_luma_flag || slice_sao_chroma_flag ||\n         !slice_deblocking_filter_disabled_flag )) {\n      slice_loop_filter_across_slices_enabled_flag = get_bits(br,1);\n    }\n    else {\n      slice_loop_filter_across_slices_enabled_flag =\n        pps->pps_loop_filter_across_slices_enabled_flag;\n    }\n  }\n\n  if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag ) {\n    num_entry_point_offsets = get_uvlc(br);\n    if (num_entry_point_offsets == UVLC_ERROR) {\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    if (pps->entropy_coding_sync_enabled_flag) {\n      // check num_entry_points for valid range\n\n      int firstCTBRow = slice_segment_address / sps->PicWidthInCtbsY;\n      int lastCTBRow  = firstCTBRow + num_entry_point_offsets;\n      if (lastCTBRow >= sps->PicHeightInCtbsY) {\n        ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n        return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n\n    if (pps->tiles_enabled_flag) {\n      if (num_entry_point_offsets > pps->num_tile_columns * pps->num_tile_rows) {\n        ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n        return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n    }\n\n    entry_point_offset.resize( num_entry_point_offsets );\n\n    if (num_entry_point_offsets > 0) {\n      offset_len = get_uvlc(br);\n      if (offset_len == UVLC_ERROR) {\n\tctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n      offset_len++;\n\n      if (offset_len > 32) {\n\treturn DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n      }\n\n      for (int i=0; i<num_entry_point_offsets; i++) {\n        {\n          entry_point_offset[i] = get_bits(br,offset_len)+1;\n        }\n\n        if (i>0) {\n          entry_point_offset[i] += entry_point_offset[i-1];\n        }\n      }\n    }\n  }\n  else {\n    num_entry_point_offsets = 0;\n  }\n\n  if (pps->slice_segment_header_extension_present_flag) {\n    slice_segment_header_extension_length = get_uvlc(br);\n    if (slice_segment_header_extension_length == UVLC_ERROR ||\n\tslice_segment_header_extension_length > 1000) {  // TODO: safety check against too large values\n      ctx->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i=0; i<slice_segment_header_extension_length; i++) {\n      //slice_segment_header_extension_data_byte[i]\n      get_bits(br,8);\n    }\n  }\n\n\n  compute_derived_values(pps.get());\n\n  *continueDecoding = true;\n  return DE265_OK;\n}\n\n\nde265_error slice_segment_header::write(error_queue* errqueue, CABAC_encoder& out,\n                                        const seq_parameter_set* sps,\n                                        const pic_parameter_set* pps,\n                                        uint8_t nal_unit_type)\n{\n  out.write_bit(first_slice_segment_in_pic_flag);\n\n  if (isRapPic(nal_unit_type)) { // TODO: is this still correct ? Should we drop RapPicFlag ?\n    out.write_bit(no_output_of_prior_pics_flag);\n  }\n\n  if (slice_pic_parameter_set_id > DE265_MAX_PPS_SETS) {\n    errqueue->add_warning(DE265_WARNING_NONEXISTING_PPS_REFERENCED, false);\n    return DE265_OK;\n  }\n  out.write_uvlc(slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    if (pps->dependent_slice_segments_enabled_flag) {\n      out.write_bit(dependent_slice_segment_flag);\n    }\n\n    out.write_bits(slice_segment_address, ceil_log2(sps->PicSizeInCtbsY));\n\n    if (dependent_slice_segment_flag) {\n      if (slice_segment_address == 0) {\n        errqueue->add_warning(DE265_WARNING_DEPENDENT_SLICE_WITH_ADDRESS_ZERO, false);\n        return DE265_OK;\n      }\n    }\n  }\n\n  if (slice_segment_address < 0 ||\n      slice_segment_address > sps->PicSizeInCtbsY) {\n    errqueue->add_warning(DE265_WARNING_SLICE_SEGMENT_ADDRESS_INVALID, false);\n    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n  }\n\n\n\n  if (!dependent_slice_segment_flag) {\n    for (int i=0; i<pps->num_extra_slice_header_bits; i++) {\n      //slice_reserved_undetermined_flag[i]\n      out.skip_bits(1);\n    }\n\n    if (slice_type > 2) {\n      errqueue->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_OK;\n    }\n    out.write_uvlc(slice_type);\n\n    if (pps->output_flag_present_flag) {\n      out.write_bit(pic_output_flag);\n    }\n\n    if (sps->separate_colour_plane_flag == 1) {\n      out.write_bits(colour_plane_id,2);\n    }\n\n\n    int NumLtPics = 0;\n\n    if (nal_unit_type != NAL_UNIT_IDR_W_RADL &&\n        nal_unit_type != NAL_UNIT_IDR_N_LP) {\n      out.write_bits(slice_pic_order_cnt_lsb, sps->log2_max_pic_order_cnt_lsb);\n      out.write_bit(short_term_ref_pic_set_sps_flag);\n\n      if (!short_term_ref_pic_set_sps_flag) {\n        /* TODO\n        read_short_term_ref_pic_set(ctx, sps,\n                                    br, &slice_ref_pic_set,\n                                    sps->num_short_term_ref_pic_sets,\n                                    sps->ref_pic_sets,\n                                    true);\n        */\n        //CurrRpsIdx = sps->num_short_term_ref_pic_sets;\n        //CurrRps    = slice_ref_pic_set;\n      }\n      else {\n        int nBits = ceil_log2(sps->num_short_term_ref_pic_sets());\n        if (nBits>0) out.write_bits(short_term_ref_pic_set_idx,nBits);\n        else         { assert(short_term_ref_pic_set_idx==0); }\n\n        if (short_term_ref_pic_set_idx > sps->num_short_term_ref_pic_sets()) {\n          errqueue->add_warning(DE265_WARNING_SHORT_TERM_REF_PIC_SET_OUT_OF_RANGE, false);\n          return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n        }\n\n        //CurrRpsIdx = short_term_ref_pic_set_idx;\n        //CurrRps    = sps->ref_pic_sets[CurrRpsIdx];\n      }\n\n\n      // --- long-term MC ---\n\n      if (sps->long_term_ref_pics_present_flag) {\n        if (sps->num_long_term_ref_pics_sps > 0) {\n          out.write_uvlc(num_long_term_sps);\n        }\n        else {\n          assert(num_long_term_sps == 0);\n        }\n\n        out.write_uvlc(num_long_term_pics);\n\n\n        // check maximum number of reference frames\n\n        if (num_long_term_sps +\n            num_long_term_pics +\n            CurrRps.NumNegativePics +\n            CurrRps.NumPositivePics\n            > sps->sps_max_dec_pic_buffering[sps->sps_max_sub_layers-1])\n          {\n            errqueue->add_warning(DE265_WARNING_MAX_NUM_REF_PICS_EXCEEDED, false);\n            return DE265_OK;\n          }\n\n        for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {\n          if (i < num_long_term_sps) {\n            int nBits = ceil_log2(sps->num_long_term_ref_pics_sps);\n            out.write_bits(lt_idx_sps[i], nBits);\n\n            // check that the referenced lt-reference really exists\n\n            if (lt_idx_sps[i] >= sps->num_long_term_ref_pics_sps) {\n              errqueue->add_warning(DE265_NON_EXISTING_LT_REFERENCE_CANDIDATE_IN_SLICE_HEADER, false);\n              return DE265_OK;\n            }\n\n            //ctx->PocLsbLt[i] = sps->lt_ref_pic_poc_lsb_sps[ lt_idx_sps[i] ];\n            //ctx->UsedByCurrPicLt[i] = sps->used_by_curr_pic_lt_sps_flag[ lt_idx_sps[i] ];\n          }\n          else {\n            int nBits = sps->log2_max_pic_order_cnt_lsb;\n            out.write_bits(poc_lsb_lt[i], nBits);\n            out.write_bit(used_by_curr_pic_lt_flag[i]);\n\n            //ctx->PocLsbLt[i] = poc_lsb_lt[i];\n            //ctx->UsedByCurrPicLt[i] = used_by_curr_pic_lt_flag[i];\n          }\n\n          //if (ctx->UsedByCurrPicLt[i]) {\n          //NumLtPics++;\n          //}\n\n          out.write_bit(delta_poc_msb_present_flag[i]);\n          if (delta_poc_msb_present_flag[i]) {\n            out.write_uvlc(delta_poc_msb_cycle_lt[i]);\n          }\n          else {\n            assert(delta_poc_msb_cycle_lt[i] == 0);\n          }\n\n          /*\n          if (i==0 || i==num_long_term_sps) {\n            ctx->DeltaPocMsbCycleLt[i] = delta_poc_msb_cycle_lt[i];\n          }\n          else {\n            ctx->DeltaPocMsbCycleLt[i] = (delta_poc_msb_cycle_lt[i] +\n                                          ctx->DeltaPocMsbCycleLt[i-1]);\n          }\n          */\n        }\n      }\n      else {\n        assert(num_long_term_sps == 0);\n        assert(num_long_term_pics== 0);\n      }\n\n      if (sps->sps_temporal_mvp_enabled_flag) {\n        out.write_bit(slice_temporal_mvp_enabled_flag);\n      }\n      else {\n        assert(slice_temporal_mvp_enabled_flag == 0);\n      }\n    }\n    else {\n      assert(slice_pic_order_cnt_lsb == 0);\n      assert(num_long_term_sps == 0);\n      assert(num_long_term_pics== 0);\n    }\n\n\n    // --- SAO ---\n\n    if (sps->sample_adaptive_offset_enabled_flag) {\n      out.write_bit(slice_sao_luma_flag);\n      out.write_bit(slice_sao_chroma_flag);\n    }\n    else {\n      assert(slice_sao_luma_flag  == 0);\n      assert(slice_sao_chroma_flag== 0);\n    }\n\n    if (slice_type == SLICE_TYPE_P  ||\n        slice_type == SLICE_TYPE_B) {\n      out.write_bit(num_ref_idx_active_override_flag);\n\n      if (num_ref_idx_active_override_flag) {\n        out.write_uvlc(num_ref_idx_l0_active);\n        num_ref_idx_l0_active++;;\n\n        if (slice_type == SLICE_TYPE_B) {\n          out.write_uvlc(num_ref_idx_l1_active);\n          num_ref_idx_l1_active++;\n        }\n      }\n      else {\n        assert(num_ref_idx_l0_active == pps->num_ref_idx_l0_default_active);\n        assert(num_ref_idx_l1_active == pps->num_ref_idx_l1_default_active);\n      }\n\n      NumPocTotalCurr = CurrRps.NumPocTotalCurr_shortterm_only + NumLtPics;\n\n      if (pps->lists_modification_present_flag && NumPocTotalCurr > 1) {\n\n        int nBits = ceil_log2(NumPocTotalCurr);\n\n        out.write_bit(ref_pic_list_modification_flag_l0);\n        if (ref_pic_list_modification_flag_l0) {\n          for (int i=0;i<num_ref_idx_l0_active;i++) {\n            out.write_bits(list_entry_l0[i], nBits);\n          }\n        }\n\n        if (slice_type == SLICE_TYPE_B) {\n          out.write_bit(ref_pic_list_modification_flag_l1);\n          if (ref_pic_list_modification_flag_l1) {\n            for (int i=0;i<num_ref_idx_l1_active;i++) {\n              out.write_bits(list_entry_l1[i], nBits);\n            }\n          }\n        }\n        else {\n          assert(ref_pic_list_modification_flag_l1 == 0);\n        }\n      }\n      else {\n        assert(ref_pic_list_modification_flag_l0 == 0);\n        assert(ref_pic_list_modification_flag_l1 == 0);\n      }\n\n      if (slice_type == SLICE_TYPE_B) {\n        out.write_bit(mvd_l1_zero_flag);\n      }\n\n      if (pps->cabac_init_present_flag) {\n        out.write_bit(cabac_init_flag);\n      }\n      else {\n        assert(cabac_init_flag == 0);\n      }\n\n      if (slice_temporal_mvp_enabled_flag) {\n        if (slice_type == SLICE_TYPE_B)\n          out.write_bit(collocated_from_l0_flag);\n        else\n          { assert(collocated_from_l0_flag == 1); }\n\n        if (( collocated_from_l0_flag && num_ref_idx_l0_active > 1) ||\n            (!collocated_from_l0_flag && num_ref_idx_l1_active > 1)) {\n          out.write_uvlc(collocated_ref_idx);\n        }\n        else {\n          assert(collocated_ref_idx == 0);\n        }\n      }\n\n      if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||\n          (pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B)) {\n\n        assert(0);\n        /* TODO\n        if (!read_pred_weight_table(br,this,ctx))\n          {\n\t    ctx->add_warning(DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE, false);\n\t    return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n          }\n        */\n      }\n\n      out.write_uvlc(five_minus_max_num_merge_cand);\n      //MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n    }\n\n    out.write_svlc(slice_qp_delta);\n\n    if (pps->pps_slice_chroma_qp_offsets_present_flag) {\n      out.write_svlc(slice_cb_qp_offset);\n      out.write_svlc(slice_cr_qp_offset);\n    }\n    else {\n      assert(slice_cb_qp_offset == 0);\n      assert(slice_cr_qp_offset == 0);\n    }\n\n    if (pps->deblocking_filter_override_enabled_flag) {\n      out.write_bit(deblocking_filter_override_flag);\n    }\n    else {\n      assert(deblocking_filter_override_flag == 0);\n    }\n\n    //slice_beta_offset = pps->beta_offset;\n    //slice_tc_offset   = pps->tc_offset;\n\n    if (deblocking_filter_override_flag) {\n      out.write_bit(slice_deblocking_filter_disabled_flag);\n      if (!slice_deblocking_filter_disabled_flag) {\n        out.write_svlc(slice_beta_offset/2);\n        out.write_svlc(slice_tc_offset  /2);\n      }\n    }\n    else {\n      assert(slice_deblocking_filter_disabled_flag == pps->pic_disable_deblocking_filter_flag);\n    }\n\n    if (pps->pps_loop_filter_across_slices_enabled_flag  &&\n        (slice_sao_luma_flag || slice_sao_chroma_flag ||\n         !slice_deblocking_filter_disabled_flag )) {\n      out.write_bit(slice_loop_filter_across_slices_enabled_flag);\n    }\n    else {\n      assert(slice_loop_filter_across_slices_enabled_flag ==\n             pps->pps_loop_filter_across_slices_enabled_flag);\n    }\n  }\n\n  if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag ) {\n    out.write_uvlc(num_entry_point_offsets);\n\n    if (num_entry_point_offsets > 0) {\n      out.write_uvlc(offset_len-1);\n\n      for (int i=0; i<num_entry_point_offsets; i++) {\n        {\n          int prev=0;\n          if (i>0) prev = entry_point_offset[i-1];\n          out.write_bits(entry_point_offset[i]-prev-1, offset_len);\n        }\n      }\n    }\n  }\n  else {\n    assert(num_entry_point_offsets == 0);\n  }\n\n  if (pps->slice_segment_header_extension_present_flag) {\n    out.write_uvlc(slice_segment_header_extension_length);\n    if (slice_segment_header_extension_length > 1000) {  // TODO: safety check against too large values\n      errqueue->add_warning(DE265_WARNING_SLICEHEADER_INVALID, false);\n      return DE265_ERROR_CODED_PARAMETER_OUT_OF_RANGE;\n    }\n\n    for (int i=0; i<slice_segment_header_extension_length; i++) {\n      //slice_segment_header_extension_data_byte[i]\n      out.skip_bits(8);\n    }\n  }\n\n  return DE265_OK;\n}\n\nvoid slice_segment_header::compute_derived_values(const pic_parameter_set* pps)\n{\n  // --- init variables ---\n\n  SliceQPY = pps->pic_init_qp + slice_qp_delta;\n\n  switch (slice_type)\n    {\n    case SLICE_TYPE_I: initType = 0; break;\n    case SLICE_TYPE_P: initType = cabac_init_flag + 1; break;\n    case SLICE_TYPE_B: initType = 2 - cabac_init_flag; break;\n    }\n\n  MaxNumMergeCand = 5-five_minus_max_num_merge_cand;\n}\n\n\n//-----------------------------------------------------------------------\n\n\nvoid slice_segment_header::dump_slice_segment_header(const decoder_context* ctx, int fd) const\n{\n  FILE* fh;\n  if (fd==1) fh=stdout;\n  else if (fd==2) fh=stderr;\n  else { return; }\n\n#define LOG0(t) log2fh(fh, t)\n#define LOG1(t,d) log2fh(fh, t,d)\n#define LOG2(t,d1,d2) log2fh(fh, t,d1,d2)\n#define LOG3(t,d1,d2,d3) log2fh(fh, t,d1,d2,d3)\n#define LOG4(t,d1,d2,d3,d4) log2fh(fh, t,d1,d2,d3,d4)\n\n  LOG0(\"----------------- SLICE -----------------\\n\");\n\n  const pic_parameter_set* pps = ctx->get_pps(slice_pic_parameter_set_id);\n  if (!pps) {\n    LOG0(\"invalid PPS referenced\\n\");\n    return;\n  }\n  assert(pps->pps_read); // TODO: error handling\n\n  const seq_parameter_set* sps = ctx->get_sps((int)pps->seq_parameter_set_id);\n  if (!sps) {\n    LOG0(\"invalid SPS referenced\\n\");\n    return;\n  }\n  assert(sps->sps_read); // TODO: error handling\n\n\n  LOG1(\"first_slice_segment_in_pic_flag      : %d\\n\", first_slice_segment_in_pic_flag);\n  if (ctx->get_nal_unit_type() >= NAL_UNIT_BLA_W_LP &&\n      ctx->get_nal_unit_type() <= NAL_UNIT_RESERVED_IRAP_VCL23) {\n    LOG1(\"no_output_of_prior_pics_flag         : %d\\n\", no_output_of_prior_pics_flag);\n  }\n\n  LOG1(\"slice_pic_parameter_set_id           : %d\\n\", slice_pic_parameter_set_id);\n\n  if (!first_slice_segment_in_pic_flag) {\n    //if (pps->dependent_slice_segments_enabled_flag) {\n      LOG1(\"dependent_slice_segment_flag         : %d\\n\", dependent_slice_segment_flag);\n      //}\n    LOG1(\"slice_segment_address                : %d\\n\", slice_segment_address);\n  }\n\n  //if (!dependent_slice_segment_flag)\n    {\n    //for (int i=0; i<pps->num_extra_slice_header_bits; i++) {\n    //slice_reserved_flag[i]\n\n    LOG1(\"slice_type                           : %c\\n\",\n         slice_type == 0 ? 'B' :\n         slice_type == 1 ? 'P' : 'I');\n\n    if (pps->output_flag_present_flag) {\n      LOG1(\"pic_output_flag                      : %d\\n\", pic_output_flag);\n    }\n\n    if (sps->separate_colour_plane_flag == 1) {\n      LOG1(\"colour_plane_id                      : %d\\n\", colour_plane_id);\n    }\n\n    LOG1(\"slice_pic_order_cnt_lsb              : %d\\n\", slice_pic_order_cnt_lsb);\n\n    if (ctx->get_nal_unit_type() != NAL_UNIT_IDR_W_RADL &&\n        ctx->get_nal_unit_type() != NAL_UNIT_IDR_N_LP) {\n      LOG1(\"short_term_ref_pic_set_sps_flag      : %d\\n\", short_term_ref_pic_set_sps_flag);\n\n      if (!short_term_ref_pic_set_sps_flag) {\n        LOG1(\"ref_pic_set[ %2d ]: \",sps->num_short_term_ref_pic_sets());\n        dump_compact_short_term_ref_pic_set(&slice_ref_pic_set, 16, fh);\n      }\n      else if (sps->num_short_term_ref_pic_sets() > 1) {\n        LOG1(\"short_term_ref_pic_set_idx           : %d\\n\", short_term_ref_pic_set_idx);\n        dump_compact_short_term_ref_pic_set(&sps->ref_pic_sets[short_term_ref_pic_set_idx], 16, fh);\n      }\n\n      if (sps->long_term_ref_pics_present_flag) {\n        if (sps->num_long_term_ref_pics_sps > 0) {\n          LOG1(\"num_long_term_sps                        : %d\\n\", num_long_term_sps);\n        }\n\n        LOG1(\"num_long_term_pics                       : %d\\n\", num_long_term_pics);\n\n#if 0\n        for (int i=0; i<num_long_term_sps + num_long_term_pics; i++) {\n          LOG2(\"PocLsbLt[%d]            : %d\\n\", i, ctx->PocLsbLt[i]);\n          LOG2(\"UsedByCurrPicLt[%d]     : %d\\n\", i, ctx->UsedByCurrPicLt[i]);\n          LOG2(\"DeltaPocMsbCycleLt[%d]  : %d\\n\", i, ctx->DeltaPocMsbCycleLt[i]);\n        }\n#endif\n      }\n\n      if (sps->sps_temporal_mvp_enabled_flag) {\n        LOG1(\"slice_temporal_mvp_enabled_flag : %d\\n\", slice_temporal_mvp_enabled_flag);\n      }\n    }\n\n\n    if (sps->sample_adaptive_offset_enabled_flag) {\n      LOG1(\"slice_sao_luma_flag             : %d\\n\", slice_sao_luma_flag);\n      LOG1(\"slice_sao_chroma_flag           : %d\\n\", slice_sao_chroma_flag);\n    }\n\n\n    if (slice_type == SLICE_TYPE_P || slice_type == SLICE_TYPE_B) {\n      LOG1(\"num_ref_idx_active_override_flag : %d\\n\", num_ref_idx_active_override_flag);\n\n      LOG2(\"num_ref_idx_l0_active          : %d %s\\n\", num_ref_idx_l0_active,\n           num_ref_idx_active_override_flag ? \"\" : \"(from PPS)\");\n\n      if (slice_type == SLICE_TYPE_B) {\n        LOG2(\"num_ref_idx_l1_active          : %d %s\\n\", num_ref_idx_l1_active,\n             num_ref_idx_active_override_flag ? \"\" : \"(from PPS)\");\n      }\n\n      if (pps->lists_modification_present_flag && NumPocTotalCurr > 1)\n        {\n          LOG1(\"ref_pic_list_modification_flag_l0 : %d\\n\", ref_pic_list_modification_flag_l0);\n          if (ref_pic_list_modification_flag_l0) {\n            for (int i=0;i<num_ref_idx_l0_active;i++) {\n              LOG2(\"  %d: %d\\n\",i,list_entry_l0[i]);\n            }\n          }\n\n          LOG1(\"ref_pic_list_modification_flag_l1 : %d\\n\", ref_pic_list_modification_flag_l1);\n          if (ref_pic_list_modification_flag_l1) {\n            for (int i=0;i<num_ref_idx_l1_active;i++) {\n              LOG2(\"  %d: %d\\n\",i,list_entry_l1[i]);\n            }\n          }\n        }\n\n      if (slice_type == SLICE_TYPE_B) {\n        LOG1(\"mvd_l1_zero_flag               : %d\\n\", mvd_l1_zero_flag);\n      }\n\n      LOG1(\"cabac_init_flag                : %d\\n\", cabac_init_flag);\n\n      if (slice_temporal_mvp_enabled_flag) {\n        LOG1(\"collocated_from_l0_flag        : %d\\n\", collocated_from_l0_flag);\n        LOG1(\"collocated_ref_idx             : %d\\n\", collocated_ref_idx);\n      }\n\n      if ((pps->weighted_pred_flag   && slice_type == SLICE_TYPE_P) ||\n          (pps->weighted_bipred_flag && slice_type == SLICE_TYPE_B))\n        {\n          LOG1(\"luma_log2_weight_denom         : %d\\n\", luma_log2_weight_denom);\n          if (sps->chroma_format_idc != 0) {\n            LOG1(\"ChromaLog2WeightDenom          : %d\\n\", ChromaLog2WeightDenom);\n          }\n\n          for (int l=0;l<=1;l++)\n            if (l==0 || (l==1 && slice_type == SLICE_TYPE_B))\n              {\n                int num_ref = (l==0 ?\n                               num_ref_idx_l0_active-1 :\n                               num_ref_idx_l1_active-1);\n\n                if (false) { // do not show these flags\n                  for (int i=0;i<=num_ref;i++) {\n                    LOG3(\"luma_weight_flag_l%d[%d]        : %d\\n\",l,i,luma_weight_flag[l][i]);\n                  }\n\n                  if (sps->chroma_format_idc != 0) {\n                    for (int i=0;i<=num_ref;i++) {\n                      LOG3(\"chroma_weight_flag_l%d[%d]      : %d\\n\",l,i,chroma_weight_flag[l][i]);\n                    }\n                  }\n                }\n\n                for (int i=0;i<=num_ref;i++) {\n                  LOG3(\"LumaWeight_L%d[%d]             : %d\\n\",l,i,LumaWeight[l][i]);\n                  LOG3(\"luma_offset_l%d[%d]            : %d\\n\",l,i,luma_offset[l][i]);\n\n                  for (int j=0;j<2;j++) {\n                    LOG4(\"ChromaWeight_L%d[%d][%d]        : %d\\n\",l,i,j,ChromaWeight[l][i][j]);\n                    LOG4(\"ChromaOffset_L%d[%d][%d]        : %d\\n\",l,i,j,ChromaOffset[l][i][j]);\n                  }\n                }\n              }\n        }\n\n      LOG1(\"five_minus_max_num_merge_cand  : %d\\n\", five_minus_max_num_merge_cand);\n    }\n\n\n    LOG1(\"slice_qp_delta         : %d\\n\", slice_qp_delta);\n    if (pps->pps_slice_chroma_qp_offsets_present_flag) {\n      LOG1(\"slice_cb_qp_offset     : %d\\n\", slice_cb_qp_offset);\n      LOG1(\"slice_cr_qp_offset     : %d\\n\", slice_cr_qp_offset);\n    }\n\n    if (pps->deblocking_filter_override_enabled_flag) {\n      LOG1(\"deblocking_filter_override_flag : %d\\n\", deblocking_filter_override_flag);\n    }\n\n    LOG2(\"slice_deblocking_filter_disabled_flag : %d %s\\n\",\n         slice_deblocking_filter_disabled_flag,\n         (deblocking_filter_override_flag ? \"(override)\" : \"(from pps)\"));\n\n    if (deblocking_filter_override_flag) {\n\n      if (!slice_deblocking_filter_disabled_flag) {\n        LOG1(\"slice_beta_offset  : %d\\n\", slice_beta_offset);\n        LOG1(\"slice_tc_offset    : %d\\n\", slice_tc_offset);\n      }\n    }\n\n    if (pps->pps_loop_filter_across_slices_enabled_flag  &&\n        (slice_sao_luma_flag || slice_sao_chroma_flag ||\n         !slice_deblocking_filter_disabled_flag)) {\n      LOG1(\"slice_loop_filter_across_slices_enabled_flag : %d\\n\",\n           slice_loop_filter_across_slices_enabled_flag);\n    }\n  }\n\n  if (pps->tiles_enabled_flag || pps->entropy_coding_sync_enabled_flag) {\n    LOG1(\"num_entry_point_offsets    : %d\\n\", num_entry_point_offsets);\n\n    if (num_entry_point_offsets > 0) {\n      LOG1(\"offset_len                 : %d\\n\", offset_len);\n\n      for (int i=0; i<num_entry_point_offsets; i++) {\n        LOG2(\"entry point [%i] : %d\\n\", i, entry_point_offset[i]);\n      }\n    }\n  }\n\n  /*\n    if( slice_segment_header_extension_present_flag ) {\n    slice_segment_header_extension_length\n    for( i = 0; i < slice_segment_header_extension_length; i++)\n    slice_segment_header_extension_data_byte[i]\n    }\n    byte_alignment()\n    }\n  */\n\n#undef LOG0\n#undef LOG1\n#undef LOG2\n#undef LOG3\n#undef LOG4\n  //#endif\n}\n\n\n\nvoid initialize_CABAC_models(thread_context* tctx)\n{\n  const int QPY = tctx->shdr->SliceQPY;\n  const int initType = tctx->shdr->initType;\n  assert(initType >= 0 && initType <= 2);\n\n  tctx->ctx_model.init(initType, QPY);\n\n  for (int i=0;i<4;i++) {\n    tctx->StatCoeff[i] = 0;\n  }\n}\n\n\n\nstatic int decode_transform_skip_flag(thread_context* tctx, int cIdx)\n{\n  const int context = (cIdx==0) ? 0 : 1;\n\n  logtrace(LogSlice,\"# transform_skip_flag (context=%d)\\n\",context);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_TRANSFORM_SKIP_FLAG+context]);\n\n  logtrace(LogSymbols,\"$1 transform_skip_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_sao_merge_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_merge_left/up_flag\\n\");\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_SAO_MERGE_FLAG]);\n\n  logtrace(LogSymbols,\"$1 sao_merge_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\n\nstatic int decode_sao_type_idx(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_type_idx_luma/chroma\\n\");\n\n  int bit0 = decode_CABAC_bit(&tctx->cabac_decoder,\n                              &tctx->ctx_model[CONTEXT_MODEL_SAO_TYPE_IDX]);\n\n  if (bit0==0) {\n    logtrace(LogSymbols,\"$1 sao_type_idx=%d\\n\",0);\n    return 0;\n  }\n  else {\n    int bit1 = decode_CABAC_bypass(&tctx->cabac_decoder);\n    if (bit1==0) {\n      logtrace(LogSymbols,\"$1 sao_type_idx=%d\\n\",1);\n      return 1;\n    }\n    else {\n      logtrace(LogSymbols,\"$1 sao_type_idx=%d\\n\",2);\n      return 2;\n    }\n  }\n}\n\n\nstatic int decode_sao_offset_abs(thread_context* tctx, int bitDepth)\n{\n  logtrace(LogSlice,\"# sao_offset_abs\\n\");\n  int cMax = (1<<(libde265_min(bitDepth,10)-5))-1;\n  int value = decode_CABAC_TU_bypass(&tctx->cabac_decoder, cMax);\n  logtrace(LogSymbols,\"$1 sao_offset_abs=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_sao_class(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_class\\n\");\n  int value = decode_CABAC_FL_bypass(&tctx->cabac_decoder, 2);\n  logtrace(LogSymbols,\"$1 sao_class=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_sao_offset_sign(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_offset_sign\\n\");\n  int value = decode_CABAC_bypass(&tctx->cabac_decoder);\n  logtrace(LogSymbols,\"$1 sao_offset_sign=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_sao_band_position(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# sao_band_position\\n\");\n  int value = decode_CABAC_FL_bypass(&tctx->cabac_decoder,5);\n  logtrace(LogSymbols,\"$1 sao_band_position=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_transquant_bypass_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# cu_transquant_bypass_enable_flag\\n\");\n  int value = decode_CABAC_bit(&tctx->cabac_decoder,\n                               &tctx->ctx_model[CONTEXT_MODEL_CU_TRANSQUANT_BYPASS_FLAG]);\n  logtrace(LogSymbols,\"$1 transquant_bypass_flag=%d\\n\",value);\n  return value;\n}\n\n\n#include <sys/types.h>\n#include <signal.h>\n\nstatic int decode_split_cu_flag(thread_context* tctx,\n\t\t\t\tint x0, int y0, int ctDepth)\n{\n  // check if neighbors are available\n\n  int availableL = check_CTB_available(tctx->img, x0,y0, x0-1,y0);\n  int availableA = check_CTB_available(tctx->img, x0,y0, x0,y0-1);\n\n  int condL = 0;\n  int condA = 0;\n\n  if (availableL && tctx->img->get_ctDepth(x0-1,y0) > ctDepth) condL=1;\n  if (availableA && tctx->img->get_ctDepth(x0,y0-1) > ctDepth) condA=1;\n\n  int contextOffset = condL + condA;\n  int context = contextOffset;\n\n  // decode bit\n\n  logtrace(LogSlice,\"# split_cu_flag context=%d R=%x\\n\", context, tctx->cabac_decoder.range);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_SPLIT_CU_FLAG + context]);\n\n  logtrace(LogSlice,\"> split_cu_flag R=%x, ctx=%d, bit=%d\\n\", tctx->cabac_decoder.range,context,bit);\n\n  logtrace(LogSymbols,\"$1 split_cu_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_cu_skip_flag(thread_context* tctx,\n\t\t\t       int x0, int y0, int ctDepth)\n{\n  decoder_context* ctx = tctx->decctx;\n\n  // check if neighbors are available\n\n  int availableL = check_CTB_available(tctx->img, x0,y0, x0-1,y0);\n  int availableA = check_CTB_available(tctx->img, x0,y0, x0,y0-1);\n\n  int condL = 0;\n  int condA = 0;\n\n  if (availableL && tctx->img->get_cu_skip_flag(x0-1,y0)) condL=1;\n  if (availableA && tctx->img->get_cu_skip_flag(x0,y0-1)) condA=1;\n\n  int contextOffset = condL + condA;\n  int context = contextOffset;\n\n  // decode bit\n\n  logtrace(LogSlice,\"# cu_skip_flag context=%d R=%x\\n\", context, tctx->cabac_decoder.range);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_CU_SKIP_FLAG + context]);\n\n  logtrace(LogSlice,\"> cu_skip_flag R=%x, ctx=%d, bit=%d\\n\", tctx->cabac_decoder.range,context,bit);\n\n  logtrace(LogSymbols,\"$1 cu_skip_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic enum PartMode decode_part_mode(thread_context* tctx,\n\t\t\t\t      enum PredMode pred_mode, int cLog2CbSize)\n{\n  de265_image* img = tctx->img;\n\n  if (pred_mode == MODE_INTRA) {\n    logtrace(LogSlice,\"# part_mode (INTRA)\\n\");\n\n    int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE]);\n\n    logtrace(LogSlice,\"> %s\\n\",bit ? \"2Nx2N\" : \"NxN\");\n\n    logtrace(LogSymbols,\"$1 part_mode=%d\\n\",bit ? PART_2Nx2N : PART_NxN);\n\n    return bit ? PART_2Nx2N : PART_NxN;\n  }\n  else {\n    const seq_parameter_set& sps = img->get_sps();\n\n    int bit0 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+0]);\n    if (bit0) { logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2Nx2N); return PART_2Nx2N; }\n\n    // CHECK_ME: I optimize code and fix bug here, need more VERIFY!\n    int bit1 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+1]);\n    if (cLog2CbSize > sps.Log2MinCbSizeY) {\n      if (!sps.amp_enabled_flag) {\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",bit1 ? PART_2NxN : PART_Nx2N);\n        return bit1 ? PART_2NxN : PART_Nx2N;\n      }\n      else {\n        int bit3 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+3]);\n        if (bit3) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",bit1 ? PART_2NxN : PART_Nx2N);\n          return bit1 ? PART_2NxN : PART_Nx2N;\n        }\n\n        int bit4 = decode_CABAC_bypass(&tctx->cabac_decoder);\n        if ( bit1 &&  bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2NxnD);\n          return PART_2NxnD;\n        }\n        if ( bit1 && !bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2NxnU);\n          return PART_2NxnU;\n        }\n        if (!bit1 && !bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_nLx2N);\n          return PART_nLx2N;\n        }\n        if (!bit1 &&  bit4) {\n          logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_nRx2N);\n          return PART_nRx2N;\n        }\n      }\n    }\n    else {\n      // TODO, we could save one if here when first decoding the next bin and then\n      // checkcLog2CbSize==3 when it is '0'\n\n      if (bit1) {\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_2NxN);\n        return PART_2NxN;\n      }\n\n      if (cLog2CbSize==3) {\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_Nx2N);\n        return PART_Nx2N;\n      }\n      else {\n        int bit2 = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PART_MODE+2]);\n        logtrace(LogSymbols,\"$1 part_mode=%d\\n\",PART_NxN-bit2);\n        return (enum PartMode)((int)PART_NxN - bit2)/*bit2 ? PART_Nx2N : PART_NxN*/;\n      }\n    }\n  }\n\n  assert(false); // should never be reached\n  return PART_2Nx2N;\n}\n\n\nstatic inline int decode_prev_intra_luma_pred_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# prev_intra_luma_pred_flag\\n\");\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_PREV_INTRA_LUMA_PRED_FLAG]);\n  logtrace(LogSymbols,\"$1 prev_intra_luma_pred_flag=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic inline int decode_mpm_idx(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# mpm_idx (TU:2)\\n\");\n  int mpm = decode_CABAC_TU_bypass(&tctx->cabac_decoder, 2);\n  logtrace(LogSlice,\"> mpm_idx = %d\\n\",mpm);\n  logtrace(LogSymbols,\"$1 mpm_idx=%d\\n\",mpm);\n  return mpm;\n}\n\n\nstatic inline int decode_rem_intra_luma_pred_mode(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# rem_intra_luma_pred_mode (5 bits)\\n\");\n  int value = decode_CABAC_FL_bypass(&tctx->cabac_decoder, 5);\n  logtrace(LogSymbols,\"$1 rem_intra_luma_pred_mode=%d\\n\",value);\n  return value;\n}\n\n\nstatic int decode_intra_chroma_pred_mode(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# intra_chroma_pred_mode\\n\");\n\n  int prefix = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_INTRA_CHROMA_PRED_MODE]);\n\n  int mode;\n  if (prefix==0) {\n    mode=4;\n  }\n  else {\n    mode = decode_CABAC_FL_bypass(&tctx->cabac_decoder, 2);\n  }\n\n  logtrace(LogSlice,\"> intra_chroma_pred_mode = %d\\n\",mode);\n  logtrace(LogSymbols,\"$1 intra_chroma_pred_mode=%d\\n\",mode);\n\n  return mode;\n}\n\n\nstatic int decode_split_transform_flag(thread_context* tctx,\n\t\t\t\t       int log2TrafoSize)\n{\n  logtrace(LogSlice,\"# split_transform_flag (log2TrafoSize=%d)\\n\",log2TrafoSize);\n\n  int context = 5-log2TrafoSize;\n  assert(context >= 0 && context <= 2);\n\n  logtrace(LogSlice,\"# context: %d\\n\",context);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_SPLIT_TRANSFORM_FLAG + context]);\n  logtrace(LogSymbols,\"$1 split_transform_flag=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic int decode_cbf_chroma(thread_context* tctx,\n\t\t\t     int trafoDepth)\n{\n  logtrace(LogSlice,\"# cbf_chroma\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_CBF_CHROMA + trafoDepth]);\n\n  logtrace(LogSymbols,\"$1 cbf_chroma=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic int decode_cbf_luma(thread_context* tctx,\n\t\t\t   int trafoDepth)\n{\n  logtrace(LogSlice,\"# cbf_luma\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder, &tctx->ctx_model[CONTEXT_MODEL_CBF_LUMA + (trafoDepth==0)]);\n\n  logtrace(LogSlice,\"> cbf_luma = %d\\n\",bit);\n\n  logtrace(LogSymbols,\"$1 cbf_luma=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic inline int decode_coded_sub_block_flag(thread_context* tctx,\n                                              int cIdx,\n                                              uint8_t coded_sub_block_neighbors)\n{\n  logtrace(LogSlice,\"# coded_sub_block_flag\\n\");\n\n  // tricky computation of csbfCtx\n  int csbfCtx = ((coded_sub_block_neighbors &  1) |  // right neighbor set  or\n                 (coded_sub_block_neighbors >> 1));  // bottom neighbor set   -> csbfCtx=1\n\n  int ctxIdxInc = csbfCtx;\n  if (cIdx!=0) {\n    ctxIdxInc += 2;\n  }\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_CODED_SUB_BLOCK_FLAG + ctxIdxInc]);\n\n  logtrace(LogSymbols,\"$1 coded_sub_block_flag=%d\\n\",bit);\n  return bit;\n}\n\n\nstatic int decode_cu_qp_delta_abs(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# cu_qp_delta_abs\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_CU_QP_DELTA_ABS + 0]);\n  if (bit==0) {\n    logtrace(LogSymbols,\"$1 cu_qp_delta_abs=%d\\n\",0);\n    return 0;\n  }\n\n  int prefix=1;\n  for (int i=0;i<4;i++) {\n    bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                           &tctx->ctx_model[CONTEXT_MODEL_CU_QP_DELTA_ABS + 1]);\n    if (bit==0) { break; }\n    else { prefix++; }\n  }\n\n  if (prefix==5) {\n    int value = decode_CABAC_EGk_bypass(&tctx->cabac_decoder, 0);\n    logtrace(LogSymbols,\"$1 cu_qp_delta_abs=%d\\n\",value+5);\n    return value + 5;\n  }\n  else {\n    logtrace(LogSymbols,\"$1 cu_qp_delta_abs=%d\\n\",prefix);\n    return prefix;\n  }\n}\n\n\nstatic int decode_last_significant_coeff_prefix(thread_context* tctx,\n\t\t\t\t\t\tint log2TrafoSize,\n\t\t\t\t\t\tint cIdx,\n\t\t\t\t\t\tcontext_model* model)\n{\n  logtrace(LogSlice,\"# last_significant_coeff_prefix log2TrafoSize:%d cIdx:%d\\n\",log2TrafoSize,cIdx);\n\n  int cMax = (log2TrafoSize<<1)-1;\n\n  int ctxOffset, ctxShift;\n  if (cIdx==0) {\n    ctxOffset = 3*(log2TrafoSize-2) + ((log2TrafoSize-1)>>2);\n    ctxShift  = (log2TrafoSize+1)>>2;\n  }\n  else {\n    ctxOffset = 15;\n    ctxShift  = log2TrafoSize-2;\n  }\n\n  int binIdx;\n  int value = cMax;\n  for (binIdx=0;binIdx<cMax;binIdx++)\n    {\n      int ctxIdxInc = (binIdx >> ctxShift);\n\n      logtrace(LogSlice,\"context: %d+%d\\n\",ctxOffset,ctxIdxInc);\n\n      int bit = decode_CABAC_bit(&tctx->cabac_decoder, &model[ctxOffset + ctxIdxInc]);\n      if (bit==0) {\n        value=binIdx;\n        break;\n      }\n    }\n\n  logtrace(LogSlice,\"> last_significant_coeff_prefix: %d\\n\", value);\n\n  return value;\n}\n\n\nstatic const uint8_t ctxIdxMap[16] = {\n  0,1,4,5,\n  2,3,4,5,\n  6,6,8,8,\n  7,7,8,99\n};\n\nuint8_t* ctxIdxLookup[4 /* 4-log2-32 */][2 /* !!cIdx */][2 /* !!scanIdx */][4 /* prevCsbf */];\n\nbool alloc_and_init_significant_coeff_ctxIdx_lookupTable()\n{\n  int tableSize = 4*4*(2) + 8*8*(2*2*4) + 16*16*(2*4) + 32*32*(2*4);\n\n  uint8_t* p = (uint8_t*)malloc(tableSize);\n  if (p==NULL) {\n    return false;\n  }\n\n  memset(p,0xFF,tableSize);  // just for debugging\n\n\n  // --- Set pointers to memory areas. Note that some parameters share the same memory. ---\n\n  // 4x4\n\n  for (int cIdx=0;cIdx<2;cIdx++) {\n    for (int scanIdx=0;scanIdx<2;scanIdx++)\n      for (int prevCsbf=0;prevCsbf<4;prevCsbf++)\n        ctxIdxLookup[0][cIdx][scanIdx][prevCsbf] = p;\n\n    p += 4*4;\n  }\n\n  // 8x8\n\n  for (int cIdx=0;cIdx<2;cIdx++)\n    for (int scanIdx=0;scanIdx<2;scanIdx++)\n      for (int prevCsbf=0;prevCsbf<4;prevCsbf++) {\n        ctxIdxLookup[1][cIdx][scanIdx][prevCsbf] = p;\n        p += 8*8;\n      }\n\n  // 16x16\n\n  for (int cIdx=0;cIdx<2;cIdx++)\n    for (int prevCsbf=0;prevCsbf<4;prevCsbf++) {\n      for (int scanIdx=0;scanIdx<2;scanIdx++) {\n        ctxIdxLookup[2][cIdx][scanIdx][prevCsbf] = p;\n      }\n\n      p += 16*16;\n    }\n\n  // 32x32\n\n  for (int cIdx=0;cIdx<2;cIdx++)\n    for (int prevCsbf=0;prevCsbf<4;prevCsbf++) {\n      for (int scanIdx=0;scanIdx<2;scanIdx++) {\n        ctxIdxLookup[3][cIdx][scanIdx][prevCsbf] = p;\n      }\n\n      p += 32*32;\n    }\n\n\n  // --- precompute ctxIdx tables ---\n\n  for (int log2w=2; log2w<=5 ; log2w++)\n    for (int cIdx=0;cIdx<2;cIdx++)\n      for (int scanIdx=0;scanIdx<2;scanIdx++)\n        for (int prevCsbf=0;prevCsbf<4;prevCsbf++)\n          {\n            for (int yC=0;yC<(1<<log2w);yC++)\n              for (int xC=0;xC<(1<<log2w);xC++)\n                {\n                  int w = 1<<log2w;\n                  int sbWidth = w>>2;\n\n                  int sigCtx;\n\n                  // if log2TrafoSize==2\n                  if (sbWidth==1) {\n                    sigCtx = ctxIdxMap[(yC<<2) + xC];\n                  }\n                  else if (xC+yC==0) {\n                    sigCtx = 0;\n                  }\n                  else {\n                    int xS = xC>>2;\n                    int yS = yC>>2;\n                    /*\n                      int prevCsbf = 0;\n\n                      if (xS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+1  +yS*sbWidth];    }\n                      if (yS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+(1+yS)*sbWidth]<<1; }\n                    */\n                    int xP = xC & 3;\n                    int yP = yC & 3;\n\n                    //logtrace(LogSlice,\"posInSubset: %d,%d\\n\",xP,yP);\n                    //logtrace(LogSlice,\"prevCsbf: %d\\n\",prevCsbf);\n\n                    switch (prevCsbf) {\n                    case 0:\n                      sigCtx = (xP+yP>=3) ? 0 : (xP+yP>0) ? 1 : 2;\n                      break;\n                    case 1:\n                      sigCtx = (yP==0) ? 2 : (yP==1) ? 1 : 0;\n                      break;\n                    case 2:\n                      sigCtx = (xP==0) ? 2 : (xP==1) ? 1 : 0;\n                      break;\n                    default:\n                      sigCtx = 2;\n                      break;\n                    }\n\n                    //logtrace(LogSlice,\"a) sigCtx=%d\\n\",sigCtx);\n\n                    if (cIdx==0) {\n                      if (xS+yS > 0) sigCtx+=3;\n\n                      //logtrace(LogSlice,\"b) sigCtx=%d\\n\",sigCtx);\n\n                      // if log2TrafoSize==3\n                      if (sbWidth==2) { // 8x8 block\n                        sigCtx += (scanIdx==0) ? 9 : 15;\n                      } else {\n                        sigCtx += 21;\n                      }\n\n                      //logtrace(LogSlice,\"c) sigCtx=%d\\n\",sigCtx);\n                    }\n                    else {\n                      // if log2TrafoSize==3\n                      if (sbWidth==2) { // 8x8 block\n                        sigCtx+=9;\n                      }\n                      else {\n                        sigCtx+=12;\n                      }\n                    }\n\n                  }\n\n                  int ctxIdxInc;\n                  if (cIdx==0) { ctxIdxInc=sigCtx; }\n                  else         { ctxIdxInc=27+sigCtx; }\n\n                  if (ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] != 0xFF) {\n                    assert(ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] == ctxIdxInc);\n                  }\n\n                  ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] = ctxIdxInc;\n\n                  //NOTE: when using this option, we have to include all three scanIdx in the table\n                  //ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][s] = ctxIdxInc;\n                }\n          }\n\n  return true;\n}\n\n\nbool alloc_and_init_significant_coeff_ctxIdx_lookupTable_OLD()\n{\n  int tableSize = 2*2*4*(4*4 + 8*8 + 16*16 + 32*32);\n  uint8_t* p = (uint8_t*)malloc(tableSize);\n  if (p==NULL) {\n    return false;\n  }\n\n  for (int log2w=2; log2w<=5 ; log2w++)\n    for (int cIdx=0;cIdx<2;cIdx++)\n      for (int scanIdx=0;scanIdx<2;scanIdx++)\n        for (int prevCsbf=0;prevCsbf<4;prevCsbf++)\n          {\n            // assign pointer into reserved memory area\n\n            ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf] = p;\n            p += (1<<log2w)*(1<<log2w);\n\n            const position* ScanOrderSub = get_scan_order(log2w-2, scanIdx);\n            const position* ScanOrderPos = get_scan_order(2, scanIdx);\n\n            //for (int yC=0;yC<(1<<log2w);yC++)\n            // for (int xC=0;xC<(1<<log2w);xC++)\n            for (int s=0;s<(1<<log2w)*(1<<log2w);s++)\n              {\n                position S = ScanOrderSub[s>>4];\n                int x0 = S.x<<2;\n                int y0 = S.y<<2;\n\n                int subX = ScanOrderPos[s & 0xF].x;\n                int subY = ScanOrderPos[s & 0xF].y;\n                int xC = x0 + subX;\n                int yC = y0 + subY;\n\n\n                int w = 1<<log2w;\n                int sbWidth = w>>2;\n\n                int sigCtx;\n\n                // if log2TrafoSize==2\n                if (sbWidth==1) {\n                  sigCtx = ctxIdxMap[(yC<<2) + xC];\n                }\n                else if (xC+yC==0) {\n                  sigCtx = 0;\n                }\n                else {\n                  int xS = xC>>2;\n                  int yS = yC>>2;\n                  /*\n                    int prevCsbf = 0;\n\n                    if (xS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+1  +yS*sbWidth];    }\n                    if (yS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+(1+yS)*sbWidth]<<1; }\n                  */\n                  int xP = xC & 3;\n                  int yP = yC & 3;\n\n                  logtrace(LogSlice,\"posInSubset: %d,%d\\n\",xP,yP);\n                  logtrace(LogSlice,\"prevCsbf: %d\\n\",prevCsbf);\n\n                  //printf(\"%d | %d %d\\n\",prevCsbf,xP,yP);\n\n                  switch (prevCsbf) {\n                  case 0:\n                    //sigCtx = (xP+yP==0) ? 2 : (xP+yP<3) ? 1 : 0;\n                    sigCtx = (xP+yP>=3) ? 0 : (xP+yP>0) ? 1 : 2;\n                    break;\n                  case 1:\n                    sigCtx = (yP==0) ? 2 : (yP==1) ? 1 : 0;\n                    break;\n                  case 2:\n                    sigCtx = (xP==0) ? 2 : (xP==1) ? 1 : 0;\n                    break;\n                  default:\n                    sigCtx = 2;\n                    break;\n                  }\n\n                  logtrace(LogSlice,\"a) sigCtx=%d\\n\",sigCtx);\n\n                  if (cIdx==0) {\n                    if (xS+yS > 0) sigCtx+=3;\n\n                    logtrace(LogSlice,\"b) sigCtx=%d\\n\",sigCtx);\n\n                    // if log2TrafoSize==3\n                    if (sbWidth==2) { // 8x8 block\n                      sigCtx += (scanIdx==0) ? 9 : 15;\n                    } else {\n                      sigCtx += 21;\n                    }\n\n                    logtrace(LogSlice,\"c) sigCtx=%d\\n\",sigCtx);\n                  }\n                  else {\n                    // if log2TrafoSize==3\n                    if (sbWidth==2) { // 8x8 block\n                      sigCtx+=9;\n                    }\n                    else {\n                      sigCtx+=12;\n                    }\n                  }\n                }\n\n                int ctxIdxInc;\n                if (cIdx==0) { ctxIdxInc=sigCtx; }\n                else         { ctxIdxInc=27+sigCtx; }\n\n\n                ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][xC+(yC<<log2w)] = ctxIdxInc;\n\n                //NOTE: when using this option, we have to include all three scanIdx in the table\n                //ctxIdxLookup[log2w-2][cIdx][scanIdx][prevCsbf][s] = ctxIdxInc;\n              }\n          }\n\n  return true;\n}\n\nvoid free_significant_coeff_ctxIdx_lookupTable()\n{\n  free(ctxIdxLookup[0][0][0][0]);\n  ctxIdxLookup[0][0][0][0]=NULL;\n}\n\n\n\n\n#if 0\nstatic int decode_significant_coeff_flag(thread_context* tctx,\n\t\t\t\t\t int xC,int yC,\n\t\t\t\t\t const uint8_t* coded_sub_block_flag,\n\t\t\t\t\t int sbWidth,\n\t\t\t\t\t int cIdx,\n\t\t\t\t\t int scanIdx)\n{\n  logtrace(LogSlice,\"# significant_coeff_flag (xC:%d yC:%d sbWidth:%d cIdx:%d scanIdx:%d)\\n\",\n           xC,yC,sbWidth,cIdx,scanIdx);\n\n  int sigCtx;\n\n  // if log2TrafoSize==2\n  if (sbWidth==1) {\n    sigCtx = ctxIdxMap[(yC<<2) + xC];\n  }\n  else if (xC+yC==0) {\n    sigCtx = 0;\n  }\n  else {\n    int xS = xC>>2;\n    int yS = yC>>2;\n    int prevCsbf = 0;\n    if (xS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+1  +yS*sbWidth];    }\n    if (yS < sbWidth-1) { prevCsbf += coded_sub_block_flag[xS+(1+yS)*sbWidth]<<1; }\n\n    int xP = xC & 3;\n    int yP = yC & 3;\n\n    logtrace(LogSlice,\"posInSubset: %d,%d\\n\",xP,yP);\n    logtrace(LogSlice,\"prevCsbf: %d\\n\",prevCsbf);\n\n    //printf(\"%d | %d %d\\n\",prevCsbf,xP,yP);\n\n    switch (prevCsbf) {\n    case 0:\n      //sigCtx = (xP+yP==0) ? 2 : (xP+yP<3) ? 1 : 0;\n      sigCtx = (xP+yP>=3) ? 0 : (xP+yP>0) ? 1 : 2;\n      break;\n    case 1:\n      sigCtx = (yP==0) ? 2 : (yP==1) ? 1 : 0;\n      break;\n    case 2:\n      sigCtx = (xP==0) ? 2 : (xP==1) ? 1 : 0;\n      break;\n    default:\n      sigCtx = 2;\n      break;\n    }\n\n    logtrace(LogSlice,\"a) sigCtx=%d\\n\",sigCtx);\n\n    if (cIdx==0) {\n      if (xS+yS > 0) sigCtx+=3;\n\n      logtrace(LogSlice,\"b) sigCtx=%d\\n\",sigCtx);\n\n      // if log2TrafoSize==3\n      if (sbWidth==2) {\n        sigCtx += (scanIdx==0) ? 9 : 15;\n      } else {\n        sigCtx += 21;\n      }\n\n      logtrace(LogSlice,\"c) sigCtx=%d\\n\",sigCtx);\n    }\n    else {\n      // if log2TrafoSize==3\n      if (sbWidth==2) {\n        sigCtx+=9;\n      }\n      else {\n        sigCtx+=12;\n      }\n    }\n  }\n\n  int ctxIdxInc;\n  if (cIdx==0) { ctxIdxInc=sigCtx; }\n  else         { ctxIdxInc=27+sigCtx; }\n\n  int context = tctx->shdr->initType*42 + ctxIdxInc;\n  logtrace(LogSlice,\"context: %d\\n\",context);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_SIGNIFICANT_COEFF_FLAG + context]);\n  return bit;\n}\n#endif\n\n\n\nstatic inline int decode_significant_coeff_flag_lookup(thread_context* tctx,\n                                                 uint8_t ctxIdxInc)\n{\n  logtrace(LogSlice,\"# significant_coeff_flag\\n\");\n  logtrace(LogSlice,\"context: %d\\n\",ctxIdxInc);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_SIGNIFICANT_COEFF_FLAG + ctxIdxInc]);\n\n  logtrace(LogSymbols,\"$1 significant_coeff_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\n\n\n\nstatic inline int decode_coeff_abs_level_greater1(thread_context* tctx,\n                                                  int cIdx, int i,\n                                                  bool firstCoeffInSubblock,\n                                                  bool firstSubblock,\n                                                  int  lastSubblock_greater1Ctx,\n                                                  int* lastInvocation_greater1Ctx,\n                                                  int* lastInvocation_coeff_abs_level_greater1_flag,\n                                                  int* lastInvocation_ctxSet, int c1)\n{\n  logtrace(LogSlice,\"# coeff_abs_level_greater1\\n\");\n\n  logtrace(LogSlice,\"  cIdx:%d i:%d firstCoeffInSB:%d firstSB:%d lastSB>1:%d last>1Ctx:%d lastLev>1:%d lastCtxSet:%d\\n\", cIdx,i,firstCoeffInSubblock,firstSubblock,lastSubblock_greater1Ctx,\n\t   *lastInvocation_greater1Ctx,\n\t   *lastInvocation_coeff_abs_level_greater1_flag,\n\t   *lastInvocation_ctxSet);\n\n  int lastGreater1Ctx;\n  int greater1Ctx;\n  int ctxSet;\n\n  logtrace(LogSlice,\"c1: %d\\n\",c1);\n\n  if (firstCoeffInSubblock) {\n    // block with real DC -> ctx 0\n    if (i==0 || cIdx>0) { ctxSet=0; }\n    else { ctxSet=2; }\n\n    if (firstSubblock) { lastGreater1Ctx=1; }\n    else { lastGreater1Ctx = lastSubblock_greater1Ctx; }\n\n    if (lastGreater1Ctx==0) { ctxSet++; }\n\n    logtrace(LogSlice,\"ctxSet: %d\\n\",ctxSet);\n\n    greater1Ctx=1;\n  }\n  else { // !firstCoeffInSubblock\n    ctxSet = *lastInvocation_ctxSet;\n    logtrace(LogSlice,\"ctxSet (old): %d\\n\",ctxSet);\n\n    greater1Ctx = *lastInvocation_greater1Ctx;\n    if (greater1Ctx>0) {\n      int lastGreater1Flag=*lastInvocation_coeff_abs_level_greater1_flag;\n      if (lastGreater1Flag==1) greater1Ctx=0;\n      else { /*if (greater1Ctx>0)*/ greater1Ctx++; }\n    }\n  }\n\n  ctxSet = c1; // use HM algo\n\n  int ctxIdxInc = (ctxSet*4) + (greater1Ctx>=3 ? 3 : greater1Ctx);\n\n  if (cIdx>0) { ctxIdxInc+=16; }\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_COEFF_ABS_LEVEL_GREATER1_FLAG + ctxIdxInc]);\n\n  *lastInvocation_greater1Ctx = greater1Ctx;\n  *lastInvocation_coeff_abs_level_greater1_flag = bit;\n  *lastInvocation_ctxSet = ctxSet;\n\n  //logtrace(LogSymbols,\"$1 coeff_abs_level_greater1=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_coeff_abs_level_greater2(thread_context* tctx,\n\t\t\t\t\t   int cIdx, // int i,int n,\n\t\t\t\t\t   int ctxSet)\n{\n  logtrace(LogSlice,\"# coeff_abs_level_greater2\\n\");\n\n  int ctxIdxInc = ctxSet;\n\n  if (cIdx>0) ctxIdxInc+=4;\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_COEFF_ABS_LEVEL_GREATER2_FLAG + ctxIdxInc]);\n\n  logtrace(LogSymbols,\"$1 coeff_abs_level_greater2=%d\\n\",bit);\n\n  return bit;\n}\n\n\n#define MAX_PREFIX 64\n\nstatic int decode_coeff_abs_level_remaining(thread_context* tctx,\n                                            int cRiceParam)\n{\n  logtrace(LogSlice,\"# decode_coeff_abs_level_remaining\\n\");\n\n  int prefix=-1;\n  int codeword=0;\n  do {\n    prefix++;\n    codeword = decode_CABAC_bypass(&tctx->cabac_decoder);\n\n    if (prefix>MAX_PREFIX) {\n      return 0; // TODO: error\n    }\n  }\n  while (codeword);\n\n  // prefix = nb. 1 bits\n\n  int value;\n\n  if (prefix <= 3) {\n    // when code only TR part (level < TRMax)\n\n    codeword = decode_CABAC_FL_bypass(&tctx->cabac_decoder, cRiceParam);\n    value = (prefix<<cRiceParam) + codeword;\n  }\n  else {\n    // Suffix coded with EGk. Note that the unary part of EGk is already\n    // included in the 'prefix' counter above.\n\n    codeword = decode_CABAC_FL_bypass(&tctx->cabac_decoder, prefix-3+cRiceParam);\n    value = (((1<<(prefix-3))+3-1)<<cRiceParam)+codeword;\n  }\n\n  logtrace(LogSymbols,\"$1 coeff_abs_level_remaining=%d\\n\",value);\n\n  return value;\n}\n\n\nstatic int decode_merge_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# merge_flag\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_MERGE_FLAG]);\n\n  logtrace(LogSymbols,\"$1 merge_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic int decode_merge_idx(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# merge_idx\\n\");\n\n  if (tctx->shdr->MaxNumMergeCand <= 1) {\n    logtrace(LogSymbols,\"$1 merge_idx=%d\\n\",0);\n    return 0;\n  }\n\n  // TU coding, first bin is CABAC, remaining are bypass.\n  // cMax = MaxNumMergeCand-1\n\n  int idx = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_MERGE_IDX]);\n\n  if (idx==0) {\n    // nothing\n  }\n  else {\n    idx=1;\n\n    while (idx<tctx->shdr->MaxNumMergeCand-1) {\n      if (decode_CABAC_bypass(&tctx->cabac_decoder)) {\n        idx++;\n      }\n      else {\n        break;\n      }\n    }\n  }\n\n  logtrace(LogSlice,\"> merge_idx = %d\\n\",idx);\n  logtrace(LogSymbols,\"$1 merge_idx=%d\\n\",idx);\n\n  return idx;\n}\n\n\nstatic int decode_pred_mode_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# pred_mode_flag\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_PRED_MODE_FLAG]);\n\n  logtrace(LogSymbols,\"$1 pred_mode=%d\\n\",bit);\n  return bit;\n}\n\nstatic int decode_mvp_lx_flag(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# mvp_lx_flag\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_MVP_LX_FLAG]);\n\n  logtrace(LogSymbols,\"$1 mvp_lx_flag=%d\\n\",bit);\n  return bit;\n}\n\nstatic int decode_rqt_root_cbf(thread_context* tctx)\n{\n  logtrace(LogSlice,\"# rqt_root_cbf\\n\");\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_RQT_ROOT_CBF]);\n\n  logtrace(LogSymbols,\"$1 rqt_root_cbf=%d\\n\",bit);\n  return bit;\n}\n\nstatic int decode_ref_idx_lX(thread_context* tctx, int numRefIdxLXActive)\n{\n  logtrace(LogSlice,\"# ref_idx_lX\\n\");\n\n  int cMax = numRefIdxLXActive-1;\n\n  if (cMax==0) {\n    logtrace(LogSlice,\"> ref_idx = 0 (cMax==0)\\n\");\n    return 0;\n  } // do check for single reference frame here\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_REF_IDX_LX + 0]);\n\n  int idx=0;\n\n  while (bit) {\n    idx++;\n    if (idx==cMax) { break; }\n\n    if (idx==1) {\n      bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_REF_IDX_LX + 1]);\n    }\n    else {\n      bit = decode_CABAC_bypass(&tctx->cabac_decoder);\n    }\n  }\n\n  logtrace(LogSlice,\"> ref_idx = %d\\n\",idx);\n\n  logtrace(LogSymbols,\"$1 ref_idx_lX=%d\\n\",idx);\n  return idx;\n}\n\n\nstatic enum InterPredIdc  decode_inter_pred_idc(thread_context* tctx,\n                                               int x0, int y0,\n                                               int nPbW, int nPbH,\n                                               int ctDepth)\n{\n  logtrace(LogSlice,\"# inter_pred_idc\\n\");\n\n  int value;\n\n  context_model* model = &tctx->ctx_model[CONTEXT_MODEL_INTER_PRED_IDC];\n\n  if (nPbW+nPbH==12) {\n    value = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &model[4]);\n  }\n  else {\n    int bit0 = decode_CABAC_bit(&tctx->cabac_decoder,\n                                &model[ctDepth]);\n    if (bit0==0) {\n      value = decode_CABAC_bit(&tctx->cabac_decoder,\n                               &model[4]);\n    }\n    else {\n      value = 2;\n    }\n  }\n\n  logtrace(LogSlice,\"> inter_pred_idc = %d (%s)\\n\",value,\n           value==0 ? \"L0\" : (value==1 ? \"L1\" : \"BI\"));\n\n  logtrace(LogSymbols,\"$1 decode_inter_pred_idx=%d\\n\",value+1);\n\n  return (enum InterPredIdc) (value+1);\n}\n\n\nstatic int  decode_explicit_rdpcm_flag(thread_context* tctx,int cIdx)\n{\n  context_model* model = &tctx->ctx_model[CONTEXT_MODEL_RDPCM_FLAG];\n  int value = decode_CABAC_bit(&tctx->cabac_decoder, &model[cIdx ? 1 : 0]);\n  return value;\n}\n\n\nstatic int  decode_explicit_rdpcm_dir(thread_context* tctx,int cIdx)\n{\n  context_model* model = &tctx->ctx_model[CONTEXT_MODEL_RDPCM_DIR];\n  int value = decode_CABAC_bit(&tctx->cabac_decoder, &model[cIdx ? 1 : 0]);\n  return value;\n}\n\n\n\n/* Take CtbAddrInTS and compute\n   -> CtbAddrInRS, CtbX, CtbY\n */\nbool setCtbAddrFromTS(thread_context* tctx)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  if (tctx->CtbAddrInTS < sps.PicSizeInCtbsY) {\n    tctx->CtbAddrInRS = tctx->img->get_pps().CtbAddrTStoRS[tctx->CtbAddrInTS];\n\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return false;\n  }\n  else {\n    tctx->CtbAddrInRS = sps.PicSizeInCtbsY;\n\n    tctx->CtbX = tctx->CtbAddrInRS % sps.PicWidthInCtbsY;\n    tctx->CtbY = tctx->CtbAddrInRS / sps.PicWidthInCtbsY;\n    return true;\n  }\n}\n\n// returns true when we reached the end of the image (ctbAddr==picSizeInCtbsY)\nbool advanceCtbAddr(thread_context* tctx)\n{\n    tctx->CtbAddrInTS++;\n\n    return setCtbAddrFromTS(tctx);\n}\n\n\nvoid read_sao(thread_context* tctx, int xCtb,int yCtb,\n              int CtbAddrInSliceSeg)\n{\n  slice_segment_header* shdr = tctx->shdr;\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n\n  logtrace(LogSlice,\"# read_sao(%d,%d)\\n\",xCtb,yCtb);\n\n  sao_info saoinfo;\n  memset(&saoinfo,0,sizeof(sao_info));\n  logtrace(LogSlice,\"sizeof saoinfo: %d\\n\",sizeof(sao_info));\n\n\n  char sao_merge_left_flag = 0;\n  char sao_merge_up_flag = 0;\n\n  if (xCtb>0) {\n    //char leftCtbInSliceSeg = (CtbAddrInSliceSeg>0);\n    char leftCtbInSliceSeg = (tctx->CtbAddrInRS > shdr->SliceAddrRS);\n    char leftCtbInTile = (pps.TileIdRS[xCtb   + yCtb * sps.PicWidthInCtbsY] ==\n                          pps.TileIdRS[xCtb-1 + yCtb * sps.PicWidthInCtbsY]);\n\n    if (leftCtbInSliceSeg && leftCtbInTile) {\n      sao_merge_left_flag = decode_sao_merge_flag(tctx);\n      logtrace(LogSlice,\"sao_merge_left_flag: %d\\n\",sao_merge_left_flag);\n    }\n  }\n\n  if (yCtb>0 && sao_merge_left_flag==0) {\n    logtrace(LogSlice,\"CtbAddrInRS:%d PicWidthInCtbsY:%d slice_segment_address:%d\\n\",\n             tctx->CtbAddrInRS,\n             sps.PicWidthInCtbsY,\n             shdr->slice_segment_address);\n    char upCtbInSliceSeg = (tctx->CtbAddrInRS - sps.PicWidthInCtbsY) >= shdr->SliceAddrRS;\n    char upCtbInTile = (pps.TileIdRS[xCtb +  yCtb    * sps.PicWidthInCtbsY] ==\n                        pps.TileIdRS[xCtb + (yCtb-1) * sps.PicWidthInCtbsY]);\n\n    if (upCtbInSliceSeg && upCtbInTile) {\n      sao_merge_up_flag = decode_sao_merge_flag(tctx);\n      logtrace(LogSlice,\"sao_merge_up_flag: %d\\n\",sao_merge_up_flag);\n    }\n  }\n\n  if (!sao_merge_up_flag && !sao_merge_left_flag) {\n    int nChroma = 3;\n    if (sps.ChromaArrayType == CHROMA_MONO) nChroma=1;\n\n    for (int cIdx=0; cIdx<nChroma; cIdx++) {\n      if ((shdr->slice_sao_luma_flag && cIdx==0) ||\n          (shdr->slice_sao_chroma_flag && cIdx>0)) {\n\n        uint8_t SaoTypeIdx = 0;\n\n        if (cIdx==0) {\n          char sao_type_idx_luma = decode_sao_type_idx(tctx);\n          logtrace(LogSlice,\"sao_type_idx_luma: %d\\n\", sao_type_idx_luma);\n          saoinfo.SaoTypeIdx = SaoTypeIdx = sao_type_idx_luma;\n        }\n        else if (cIdx==1) {\n          char sao_type_idx_chroma = decode_sao_type_idx(tctx);\n          logtrace(LogSlice,\"sao_type_idx_chroma: %d\\n\", sao_type_idx_chroma);\n          SaoTypeIdx = sao_type_idx_chroma;\n          saoinfo.SaoTypeIdx |= SaoTypeIdx<<(2*1);\n          saoinfo.SaoTypeIdx |= SaoTypeIdx<<(2*2);  // set for both chroma components\n        }\n        else {\n          // SaoTypeIdx = 0\n\n          SaoTypeIdx = (saoinfo.SaoTypeIdx >> (2*cIdx)) & 0x3;\n        }\n\n        if (SaoTypeIdx != 0) {\n          for (int i=0;i<4;i++) {\n            saoinfo.saoOffsetVal[cIdx][i] = decode_sao_offset_abs(tctx, img->get_bit_depth(cIdx));\n            logtrace(LogSlice,\"saoOffsetVal[%d][%d] = %d\\n\",cIdx,i, saoinfo.saoOffsetVal[cIdx][i]);\n          }\n\n          int sign[4];\n          if (SaoTypeIdx==1) {\n            for (int i=0;i<4;i++) {\n              if (saoinfo.saoOffsetVal[cIdx][i] != 0) {\n                sign[i] = decode_sao_offset_sign(tctx) ? -1 : 1;\n              }\n              else {\n                sign[i] = 0; // not really required, but compiler warns about uninitialized values\n              }\n            }\n\n            saoinfo.sao_band_position[cIdx] = decode_sao_band_position(tctx);\n          }\n          else {\n            uint8_t SaoEoClass = 0;\n\n            sign[0] = sign[1] =  1;\n            sign[2] = sign[3] = -1;\n\n            if (cIdx==0) {\n              saoinfo.SaoEoClass = SaoEoClass = decode_sao_class(tctx);\n            }\n            else if (cIdx==1) {\n              SaoEoClass = decode_sao_class(tctx);\n              saoinfo.SaoEoClass |= SaoEoClass << (2*1);\n              saoinfo.SaoEoClass |= SaoEoClass << (2*2);\n            }\n\n            logtrace(LogSlice,\"SaoEoClass[%d] = %d\\n\",cIdx,SaoEoClass);\n          }\n\n          int log2OffsetScale;\n\n          if (cIdx==0) {\n            log2OffsetScale = pps.range_extension.log2_sao_offset_scale_luma;\n          }\n          else {\n            log2OffsetScale = pps.range_extension.log2_sao_offset_scale_chroma;\n          }\n\n          for (int i=0;i<4;i++) {\n            saoinfo.saoOffsetVal[cIdx][i] = sign[i]*(saoinfo.saoOffsetVal[cIdx][i] << log2OffsetScale);\n          }\n        }\n      }\n    }\n\n    img->set_sao_info(xCtb,yCtb,  &saoinfo);\n  }\n\n\n  if (sao_merge_left_flag) {\n    img->set_sao_info(xCtb,yCtb,  img->get_sao_info(xCtb-1,yCtb));\n  }\n\n  if (sao_merge_up_flag) {\n    img->set_sao_info(xCtb,yCtb,  img->get_sao_info(xCtb,yCtb-1));\n  }\n}\n\n\nvoid read_coding_tree_unit(thread_context* tctx)\n{\n  slice_segment_header* shdr = tctx->shdr;\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n\n  int xCtb = (tctx->CtbAddrInRS % sps.PicWidthInCtbsY);\n  int yCtb = (tctx->CtbAddrInRS / sps.PicWidthInCtbsY);\n  int xCtbPixels = xCtb << sps.Log2CtbSizeY;\n  int yCtbPixels = yCtb << sps.Log2CtbSizeY;\n\n  logtrace(LogSlice,\"----- decode CTB %d;%d (%d;%d) POC=%d, SliceAddrRS=%d\\n\",\n           xCtbPixels,yCtbPixels, xCtb,yCtb,\n           tctx->img->PicOrderCntVal, tctx->shdr->SliceAddrRS);\n\n  img->set_SliceAddrRS(xCtb, yCtb, tctx->shdr->SliceAddrRS);\n\n  img->set_SliceHeaderIndex(xCtbPixels,yCtbPixels, shdr->slice_index);\n\n  int CtbAddrInSliceSeg = tctx->CtbAddrInRS - shdr->slice_segment_address;\n\n  if (shdr->slice_sao_luma_flag || shdr->slice_sao_chroma_flag)\n    {\n      read_sao(tctx, xCtb,yCtb, CtbAddrInSliceSeg);\n    }\n\n  read_coding_quadtree(tctx, xCtbPixels, yCtbPixels, sps.Log2CtbSizeY, 0);\n}\n\n\nLIBDE265_INLINE static int luma_pos_to_ctbAddrRS(const seq_parameter_set* sps, int x,int y)\n{\n  int ctbX = x >> sps->Log2CtbSizeY;\n  int ctbY = y >> sps->Log2CtbSizeY;\n\n  return ctbY * sps->PicWidthInCtbsY + ctbX;\n}\n\n\nint check_CTB_available(const de265_image* img,\n                        int xC,int yC, int xN,int yN)\n{\n  // check whether neighbor is outside of frame\n\n  if (xN < 0 || yN < 0) { return 0; }\n  if (xN >= img->get_sps().pic_width_in_luma_samples)  { return 0; }\n  if (yN >= img->get_sps().pic_height_in_luma_samples) { return 0; }\n\n\n  int current_ctbAddrRS  = luma_pos_to_ctbAddrRS(&img->get_sps(), xC,yC);\n  int neighbor_ctbAddrRS = luma_pos_to_ctbAddrRS(&img->get_sps(), xN,yN);\n\n  // TODO: check if this is correct (6.4.1)\n\n  if (img->get_SliceAddrRS_atCtbRS(current_ctbAddrRS) !=\n      img->get_SliceAddrRS_atCtbRS(neighbor_ctbAddrRS)) {\n    return 0;\n  }\n\n  // check if both CTBs are in the same tile.\n\n  if (img->get_pps().TileIdRS[current_ctbAddrRS] !=\n      img->get_pps().TileIdRS[neighbor_ctbAddrRS]) {\n    return 0;\n  }\n\n  return 1;\n}\n\n\nint residual_coding(thread_context* tctx,\n                    int x0, int y0,  // position of TU in frame\n                    int log2TrafoSize,\n                    int cIdx)\n{\n  logtrace(LogSlice,\"- residual_coding x0:%d y0:%d log2TrafoSize:%d cIdx:%d\\n\",x0,y0,log2TrafoSize,cIdx);\n\n  //slice_segment_header* shdr = tctx->shdr;\n\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n\n  enum PredMode PredMode = img->get_pred_mode(x0,y0);\n\n  if (cIdx==0) {\n    img->set_nonzero_coefficient(x0,y0,log2TrafoSize);\n  }\n\n\n  if (pps.transform_skip_enabled_flag &&\n      !tctx->cu_transquant_bypass_flag &&\n      (log2TrafoSize <= pps.Log2MaxTransformSkipSize))\n    {\n      tctx->transform_skip_flag[cIdx] = decode_transform_skip_flag(tctx,cIdx);\n    }\n  else\n    {\n      tctx->transform_skip_flag[cIdx] = 0;\n    }\n\n\n  tctx->explicit_rdpcm_flag = false;\n\n  if (PredMode == MODE_INTER && sps.range_extension.explicit_rdpcm_enabled_flag &&\n      ( tctx->transform_skip_flag[cIdx] || tctx->cu_transquant_bypass_flag))\n    {\n      tctx->explicit_rdpcm_flag = decode_explicit_rdpcm_flag(tctx,cIdx);\n      if (tctx->explicit_rdpcm_flag) {\n        tctx->explicit_rdpcm_dir = decode_explicit_rdpcm_dir(tctx,cIdx);\n      }\n\n      //printf(\"EXPLICIT RDPCM %d;%d\\n\",x0,y0);\n    }\n  else\n    {\n      tctx->explicit_rdpcm_flag = false;\n    }\n\n\n\n  // sbType for persistent_rice_adaptation_enabled_flag\n\n  int sbType = (cIdx==0) ? 2 : 0;\n  if (tctx->transform_skip_flag[cIdx] || tctx->cu_transquant_bypass_flag) {\n    sbType++;\n  }\n\n\n  // --- decode position of last coded coefficient ---\n\n  int last_significant_coeff_x_prefix =\n    decode_last_significant_coeff_prefix(tctx,log2TrafoSize,cIdx,\n                                         &tctx->ctx_model[CONTEXT_MODEL_LAST_SIGNIFICANT_COEFFICIENT_X_PREFIX]);\n\n  int last_significant_coeff_y_prefix =\n    decode_last_significant_coeff_prefix(tctx,log2TrafoSize,cIdx,\n                                         &tctx->ctx_model[CONTEXT_MODEL_LAST_SIGNIFICANT_COEFFICIENT_Y_PREFIX]);\n\n\n  // TODO: we can combine both FL-bypass calls into one, but the gain may be limited...\n\n  int LastSignificantCoeffX;\n  if (last_significant_coeff_x_prefix > 3) {\n    int nBits = (last_significant_coeff_x_prefix>>1)-1;\n    int last_significant_coeff_x_suffix = decode_CABAC_FL_bypass(&tctx->cabac_decoder,nBits);\n\n    LastSignificantCoeffX =\n      ((2+(last_significant_coeff_x_prefix & 1)) << nBits) + last_significant_coeff_x_suffix;\n  }\n  else {\n    LastSignificantCoeffX = last_significant_coeff_x_prefix;\n  }\n\n  int LastSignificantCoeffY;\n  if (last_significant_coeff_y_prefix > 3) {\n    int nBits = (last_significant_coeff_y_prefix>>1)-1;\n    int last_significant_coeff_y_suffix = decode_CABAC_FL_bypass(&tctx->cabac_decoder,nBits);\n\n    LastSignificantCoeffY =\n      ((2+(last_significant_coeff_y_prefix & 1)) << nBits) + last_significant_coeff_y_suffix;\n  }\n  else {\n    LastSignificantCoeffY = last_significant_coeff_y_prefix;\n  }\n\n\n\n  // --- determine scanIdx ---\n\n  int scanIdx;\n\n  if (PredMode == MODE_INTRA) {\n    if (cIdx==0) {\n      scanIdx = get_intra_scan_idx(log2TrafoSize, img->get_IntraPredMode(x0,y0),  cIdx, &sps);\n      //printf(\"luma scan idx=%d <- intra mode=%d\\n\",scanIdx, img->get_IntraPredMode(x0,y0));\n    }\n    else {\n      scanIdx = get_intra_scan_idx(log2TrafoSize, img->get_IntraPredModeC(x0,y0), cIdx, &sps);\n      //printf(\"chroma scan idx=%d <- intra mode=%d chroma:%d trsize:%d\\n\",scanIdx,\n      //       img->get_IntraPredModeC(x0,y0), sps->chroma_format_idc, 1<<log2TrafoSize);\n    }\n  }\n  else {\n    scanIdx=0;\n  }\n\n  if (scanIdx==2) {\n    std::swap(LastSignificantCoeffX, LastSignificantCoeffY);\n  }\n\n  logtrace(LogSlice,\"LastSignificantCoeff: x=%d;y=%d\\n\",LastSignificantCoeffX,LastSignificantCoeffY);\n\n  const position* ScanOrderSub = get_scan_order(log2TrafoSize-2, scanIdx);\n  const position* ScanOrderPos = get_scan_order(2, scanIdx);\n\n  logtrace(LogSlice,\"ScanOrderPos: \");\n  for (int n=0;n<4*4;n++)\n    logtrace(LogSlice,\"*%d,%d \", ScanOrderPos[n].x, ScanOrderPos[n].y);\n  logtrace(LogSlice,\"*\\n\");\n\n\n  // --- find last sub block and last scan pos ---\n\n  int xC,yC;\n\n  scan_position lastScanP = get_scan_position(LastSignificantCoeffX, LastSignificantCoeffY,\n                                              scanIdx, log2TrafoSize);\n\n  int lastScanPos  = lastScanP.scanPos;\n  int lastSubBlock = lastScanP.subBlock;\n\n\n  int sbWidth = 1<<(log2TrafoSize-2);\n\n  uint8_t coded_sub_block_neighbors[32/4*32/4];\n  memset(coded_sub_block_neighbors,0,sbWidth*sbWidth);\n\n  int  c1 = 1;\n  bool firstSubblock = true;           // for coeff_abs_level_greater1_flag context model\n  int  lastSubblock_greater1Ctx=false; /* for coeff_abs_level_greater1_flag context model\n                                          (initialization not strictly needed)\n                                       */\n\n#ifdef DE265_LOG_TRACE\n  int16_t TransCoeffLevel[32 * 32];\n  memset(TransCoeffLevel,0, sizeof(uint16_t)*32*32);\n#endif\n\n  int CoeffStride = 1<<log2TrafoSize;\n\n  int  lastInvocation_greater1Ctx=0;\n  int  lastInvocation_coeff_abs_level_greater1_flag=0;\n  int  lastInvocation_ctxSet=0;\n\n\n\n  // ----- decode coefficients -----\n\n  tctx->nCoeff[cIdx] = 0;\n\n\n  // i - subblock index\n  // n - coefficient index in subblock\n\n  for (int i=lastSubBlock;i>=0;i--) {\n    position S = ScanOrderSub[i];\n    int inferSbDcSigCoeffFlag=0;\n\n    logtrace(LogSlice,\"sub block scan idx: %d\\n\",i);\n\n\n    // --- check whether this sub-block is coded ---\n\n    int sub_block_is_coded = 0;\n\n    if ((i<lastSubBlock) && (i>0)) {\n      sub_block_is_coded = decode_coded_sub_block_flag(tctx, cIdx,\n                                                       coded_sub_block_neighbors[S.x+S.y*sbWidth]);\n      inferSbDcSigCoeffFlag=1;\n    }\n    else if (i==0 || i==lastSubBlock) {\n      // first (DC) and last sub-block are always coded\n      // - the first will most probably contain coefficients\n      // - the last obviously contains the last coded coefficient\n\n      sub_block_is_coded = 1;\n    }\n\n    if (sub_block_is_coded) {\n      if (S.x > 0) coded_sub_block_neighbors[S.x-1 + S.y  *sbWidth] |= 1;\n      if (S.y > 0) coded_sub_block_neighbors[S.x + (S.y-1)*sbWidth] |= 2;\n    }\n\n\n    // ----- find significant coefficients in this sub-block -----\n\n    int16_t  coeff_value[16];\n    int8_t   coeff_scan_pos[16];\n    int8_t   coeff_sign[16];\n    int8_t   coeff_has_max_base_level[16];\n    int nCoefficients=0;\n\n\n    if (sub_block_is_coded) {\n      int x0 = S.x<<2;\n      int y0 = S.y<<2;\n\n      int log2w = log2TrafoSize-2;\n      int prevCsbf = coded_sub_block_neighbors[S.x+S.y*sbWidth];\n      uint8_t* ctxIdxMap = ctxIdxLookup[log2w][!!cIdx][!!scanIdx][prevCsbf];\n\n      logdebug(LogSlice,\"log2w:%d cIdx:%d scanIdx:%d prevCsbf:%d\\n\",\n               log2w,cIdx,scanIdx,prevCsbf);\n\n\n      // set the last coded coefficient in the last subblock\n\n      int last_coeff =  (i==lastSubBlock) ? lastScanPos-1 : 15;\n\n      if (i==lastSubBlock) {\n        coeff_value[nCoefficients] = 1;\n        coeff_has_max_base_level[nCoefficients] = 1;\n        coeff_scan_pos[nCoefficients] = lastScanPos;\n        nCoefficients++;\n      }\n\n\n      // --- decode all coefficients' significant_coeff flags except for the DC coefficient ---\n\n      for (int n= last_coeff ; n>0 ; n--) {\n        int subX = ScanOrderPos[n].x;\n        int subY = ScanOrderPos[n].y;\n        xC = x0 + subX;\n        yC = y0 + subY;\n\n\n        // for all AC coefficients in sub-block, a significant_coeff flag is coded\n\n        int ctxInc;\n        if (sps.range_extension.transform_skip_context_enabled_flag &&\n            (tctx->cu_transquant_bypass_flag || tctx->transform_skip_flag[cIdx])) {\n          ctxInc = ( cIdx == 0 ) ? 42 : (16+27);\n        }\n        else {\n          ctxInc = ctxIdxMap[xC+(yC<<log2TrafoSize)];\n        }\n\n        logtrace(LogSlice,\"trafoSize: %d\\n\",1<<log2TrafoSize);\n\n        int significant_coeff = decode_significant_coeff_flag_lookup(tctx, ctxInc);\n\n        if (significant_coeff) {\n          coeff_value[nCoefficients] = 1;\n          coeff_has_max_base_level[nCoefficients] = 1;\n          coeff_scan_pos[nCoefficients] = n;\n          nCoefficients++;\n\n          // since we have a coefficient in the sub-block,\n          // we cannot infer the DC coefficient anymore\n          inferSbDcSigCoeffFlag = 0;\n        }\n      }\n\n\n      // --- decode DC coefficient significance ---\n\n      if (last_coeff>=0) // last coded coefficient (always set to 1) is not the DC coefficient\n        {\n          if (inferSbDcSigCoeffFlag==0) {\n            // if we cannot infert the DC coefficient, it is coded\n\n            int ctxInc;\n            if (sps.range_extension.transform_skip_context_enabled_flag &&\n                (tctx->cu_transquant_bypass_flag || tctx->transform_skip_flag[cIdx])) {\n              ctxInc = ( cIdx == 0 ) ? 42 : (16+27);\n            }\n            else {\n              ctxInc = ctxIdxMap[x0+(y0<<log2TrafoSize)];\n            }\n\n            int significant_coeff = decode_significant_coeff_flag_lookup(tctx, ctxInc);\n\n\n            if (significant_coeff) {\n              coeff_value[nCoefficients] = 1;\n              coeff_has_max_base_level[nCoefficients] = 1;\n              coeff_scan_pos[nCoefficients] = 0;\n              nCoefficients++;\n            }\n          }\n          else {\n            // we can infer that the DC coefficient must be present\n            coeff_value[nCoefficients] = 1;\n            coeff_has_max_base_level[nCoefficients] = 1;\n            coeff_scan_pos[nCoefficients] = 0;\n            nCoefficients++;\n          }\n        }\n\n    }\n\n\n    /*\n      logtrace(LogSlice,\"significant_coeff_flags:\\n\");\n      for (int y=0;y<4;y++) {\n      logtrace(LogSlice,\"  \");\n      for (int x=0;x<4;x++) {\n      logtrace(LogSlice,\"*%d \",significant_coeff_flag[y][x]);\n      }\n      logtrace(LogSlice,\"*\\n\");\n      }\n    */\n\n\n    if (nCoefficients) {\n      int ctxSet;\n      if (i==0 || cIdx>0) { ctxSet=0; }\n      else { ctxSet=2; }\n\n      if (c1==0) { ctxSet++; }\n      c1=1;\n\n\n      // --- decode greater-1 flags ---\n\n      int newLastGreater1ScanPos=-1;\n\n      int lastGreater1Coefficient = libde265_min(8,nCoefficients);\n      for (int c=0;c<lastGreater1Coefficient;c++) {\n        int greater1_flag =\n          decode_coeff_abs_level_greater1(tctx, cIdx,i,\n                                          c==0,\n                                          firstSubblock,\n                                          lastSubblock_greater1Ctx,\n                                          &lastInvocation_greater1Ctx,\n                                          &lastInvocation_coeff_abs_level_greater1_flag,\n                                          &lastInvocation_ctxSet, ctxSet);\n\n        if (greater1_flag) {\n          coeff_value[c]++;\n\n          c1=0;\n\n          if (newLastGreater1ScanPos == -1) {\n            newLastGreater1ScanPos=c;\n          }\n        }\n        else {\n          coeff_has_max_base_level[c] = 0;\n\n          if (c1<3 && c1>0) {\n            c1++;\n          }\n        }\n      }\n\n      firstSubblock = false;\n      lastSubblock_greater1Ctx = lastInvocation_greater1Ctx;\n\n\n      // --- decode greater-2 flag ---\n\n      if (newLastGreater1ScanPos != -1) {\n        int flag = decode_coeff_abs_level_greater2(tctx,cIdx, lastInvocation_ctxSet);\n        coeff_value[newLastGreater1ScanPos] += flag;\n        coeff_has_max_base_level[newLastGreater1ScanPos] = flag;\n      }\n\n\n      // --- decode coefficient signs ---\n\n      int signHidden;\n\n\n      IntraPredMode predModeIntra;\n      if (cIdx==0) predModeIntra = img->get_IntraPredMode(x0,y0);\n      else         predModeIntra = img->get_IntraPredModeC(x0,y0);\n\n\n      if (tctx->cu_transquant_bypass_flag ||\n          (PredMode == MODE_INTRA &&\n           sps.range_extension.implicit_rdpcm_enabled_flag &&\n           tctx->transform_skip_flag[cIdx] &&\n           ( predModeIntra == 10 || predModeIntra == 26 )) ||\n          tctx->explicit_rdpcm_flag)\n        {\n          signHidden = 0;\n        }\n      else\n        {\n          signHidden = (coeff_scan_pos[0]-coeff_scan_pos[nCoefficients-1] > 3);\n        }\n\n\n      for (int n=0;n<nCoefficients-1;n++) {\n        coeff_sign[n] = decode_CABAC_bypass(&tctx->cabac_decoder);\n        logtrace(LogSlice,\"sign[%d] = %d\\n\", n, coeff_sign[n]);\n      }\n\n      // n==nCoefficients-1\n      if (!pps.sign_data_hiding_flag || !signHidden) {\n        coeff_sign[nCoefficients-1] = decode_CABAC_bypass(&tctx->cabac_decoder);\n        logtrace(LogSlice,\"sign[%d] = %d\\n\", nCoefficients-1, coeff_sign[nCoefficients-1]);\n      }\n      else {\n        coeff_sign[nCoefficients-1] = 0;\n      }\n\n\n      // --- decode coefficient value ---\n\n      int sumAbsLevel=0;\n      int uiGoRiceParam;\n\n      if (sps.range_extension.persistent_rice_adaptation_enabled_flag==0) {\n        uiGoRiceParam = 0;\n      }\n      else {\n        uiGoRiceParam = tctx->StatCoeff[sbType]/4;\n      }\n\n      // printf(\"initial uiGoRiceParam=%d\\n\",uiGoRiceParam);\n      bool firstCoeffWithAbsLevelRemaining = true;\n\n      for (int n=0;n<nCoefficients;n++) {\n        int baseLevel = coeff_value[n];\n\n        int coeff_abs_level_remaining;\n\n        // printf(\"coeff %d/%d, uiRiceParam: %d\\n\",n,nCoefficients,uiGoRiceParam);\n\n        if (coeff_has_max_base_level[n]) {\n          coeff_abs_level_remaining =\n            decode_coeff_abs_level_remaining(tctx, uiGoRiceParam);\n\n          if (sps.range_extension.persistent_rice_adaptation_enabled_flag == 0) {\n            // (2014.10 / 9-20)\n            if (baseLevel + coeff_abs_level_remaining > 3*(1<<uiGoRiceParam)) {\n              uiGoRiceParam++;\n              if (uiGoRiceParam>4) uiGoRiceParam=4;\n            }\n          }\n          else {\n            if (baseLevel + coeff_abs_level_remaining > 3*(1<<uiGoRiceParam))\n              uiGoRiceParam++;\n          }\n\n          // persistent_rice_adaptation_enabled_flag\n          if (sps.range_extension.persistent_rice_adaptation_enabled_flag &&\n              firstCoeffWithAbsLevelRemaining) {\n            if (coeff_abs_level_remaining >= (3 << (tctx->StatCoeff[sbType]/4 ))) {\n              tctx->StatCoeff[sbType]++;\n            }\n            else if (2*coeff_abs_level_remaining < (1 << (tctx->StatCoeff[sbType]/4 )) &&\n                     tctx->StatCoeff[sbType] > 0) {\n              tctx->StatCoeff[sbType]--;\n            }\n          }\n\n          firstCoeffWithAbsLevelRemaining=false;\n        }\n        else {\n          coeff_abs_level_remaining = 0;\n        }\n\n        logtrace(LogSlice, \"coeff_abs_level_remaining=%d\\n\",coeff_abs_level_remaining);\n\n\n        int16_t currCoeff = baseLevel + coeff_abs_level_remaining;\n        if (coeff_sign[n]) {\n          currCoeff = -currCoeff;\n        }\n\n        if (pps.sign_data_hiding_flag && signHidden) {\n          sumAbsLevel += currCoeff;\n\n          if (n==nCoefficients-1 && (sumAbsLevel & 1)) {\n            currCoeff = -currCoeff;\n          }\n        }\n\n        logtrace(LogSlice, \"quantized coefficient=%d\\n\",currCoeff);\n\n#ifdef DE265_LOG_TRACE\n        //TransCoeffLevel[yC*CoeffStride + xC] = currCoeff;\n#endif\n\n        // put coefficient in list\n        int p = coeff_scan_pos[n];\n        xC = (S.x<<2) + ScanOrderPos[p].x;\n        yC = (S.y<<2) + ScanOrderPos[p].y;\n\n        tctx->coeffList[cIdx][ tctx->nCoeff[cIdx] ] = currCoeff;\n        tctx->coeffPos [cIdx][ tctx->nCoeff[cIdx] ] = xC + yC*CoeffStride;\n        tctx->nCoeff[cIdx]++;\n\n        //printf(\"%d \",currCoeff);\n      }  // iterate through coefficients in sub-block\n\n      //printf(\" (%d;%d)\\n\",x0,y0);\n\n    }  // if nonZero\n  }  // next sub-block\n\n  return DE265_OK;\n}\n\n\nstatic void decode_TU(thread_context* tctx,\n                      int x0,int y0,\n                      int xCUBase,int yCUBase,\n                      int nT, int cIdx, enum PredMode cuPredMode, bool cbf)\n{\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n\n  int residualDpcm = 0;\n\n  if (cuPredMode == MODE_INTRA) // if intra mode\n    {\n      enum IntraPredMode intraPredMode;\n\n      if (cIdx==0) {\n        intraPredMode = img->get_IntraPredMode(x0,y0);\n      }\n      else {\n        const int SubWidthC  = sps.SubWidthC;\n        const int SubHeightC = sps.SubHeightC;\n\n        intraPredMode = img->get_IntraPredModeC(x0*SubWidthC,y0*SubHeightC);\n      }\n\n      if (intraPredMode<0 || intraPredMode>=35) {\n        // TODO: ERROR\n        intraPredMode = INTRA_DC;\n      }\n\n      decode_intra_prediction(img, x0,y0, intraPredMode, nT, cIdx);\n\n\n      residualDpcm = sps.range_extension.implicit_rdpcm_enabled_flag &&\n        (tctx->cu_transquant_bypass_flag || tctx->transform_skip_flag[cIdx]) &&\n        (intraPredMode == 10 || intraPredMode == 26);\n\n      if (residualDpcm && intraPredMode == 26)\n        residualDpcm = 2;\n    }\n  else // INTER\n    {\n      if (tctx->explicit_rdpcm_flag) {\n        residualDpcm = (tctx->explicit_rdpcm_dir ? 2 : 1);\n      }\n    }\n\n  if (cbf) {\n    scale_coefficients(tctx, x0,y0, xCUBase,yCUBase, nT, cIdx,\n                       tctx->transform_skip_flag[cIdx], cuPredMode==MODE_INTRA, residualDpcm);\n  }\n  /*\n  else if (!cbf && cIdx==0) {\n    memset(tctx->residual_luma,0,32*32*sizeof(int32_t));\n  }\n  */\n  else if (!cbf && cIdx!=0 && tctx->ResScaleVal) {\n    // --- cross-component-prediction when CBF==0 ---\n\n    tctx->nCoeff[cIdx] = 0;\n    residualDpcm=0;\n\n    scale_coefficients(tctx, x0,y0, xCUBase,yCUBase, nT, cIdx,\n                       tctx->transform_skip_flag[cIdx], cuPredMode==MODE_INTRA, residualDpcm);\n  }\n}\n\n\nstatic int decode_log2_res_scale_abs_plus1(thread_context* tctx, int cIdxMinus1)\n{\n  //const int context = (cIdx==0) ? 0 : 1;\n\n  logtrace(LogSlice,\"# log2_res_scale_abs_plus1 (c=%d)\\n\",cIdxMinus1);\n\n  int value = 0;\n  int cMax  = 4;\n  for (int binIdx=0;binIdx<cMax;binIdx++)\n    {\n      int ctxIdxInc = 4*cIdxMinus1 + binIdx;\n\n      int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                                 &tctx->ctx_model[CONTEXT_MODEL_LOG2_RES_SCALE_ABS_PLUS1+ctxIdxInc]);\n      if (!bit) break;\n      value++;\n    }\n\n  logtrace(LogSymbols,\"$1 log2_res_scale_abs_plus1=%d\\n\",value);\n\n  return value;\n}\n\n\nstatic int decode_res_scale_sign_flag(thread_context* tctx, int cIdxMinus1)\n{\n  //const int context = (cIdx==0) ? 0 : 1;\n\n  logtrace(LogSlice,\"# res_scale_sign_flag (c=%d)\\n\",cIdxMinus1);\n\n  int bit = decode_CABAC_bit(&tctx->cabac_decoder,\n                             &tctx->ctx_model[CONTEXT_MODEL_RES_SCALE_SIGN_FLAG+cIdxMinus1]);\n\n  logtrace(LogSymbols,\"$1 res_scale_sign_flag=%d\\n\",bit);\n\n  return bit;\n}\n\n\nstatic void read_cross_comp_pred(thread_context* tctx, int cIdxMinus1)\n{\n  int log2_res_scale_abs_plus1 = decode_log2_res_scale_abs_plus1(tctx,cIdxMinus1);\n  int ResScaleVal;\n\n  if (log2_res_scale_abs_plus1 != 0) {\n    int res_scale_sign_flag = decode_res_scale_sign_flag(tctx,cIdxMinus1);\n\n    ResScaleVal = 1 << (log2_res_scale_abs_plus1 - 1);\n    ResScaleVal *= 1 - 2 * res_scale_sign_flag;\n  }\n  else {\n    ResScaleVal = 0;\n  }\n\n  tctx->ResScaleVal = ResScaleVal;\n}\n\n\nint read_transform_unit(thread_context* tctx,\n                        int x0, int y0,        // position of TU in frame\n                        int xBase, int yBase,  // position of parent TU in frame\n                        int xCUBase,int yCUBase,  // position of CU in frame\n                        int log2TrafoSize,\n                        int trafoDepth,\n                        int blkIdx,\n                        int cbf_luma, int cbf_cb, int cbf_cr)\n{\n  logtrace(LogSlice,\"- read_transform_unit x0:%d y0:%d xBase:%d yBase:%d nT:%d cbf:%d:%d:%d\\n\",\n           x0,y0,xBase,yBase, 1<<log2TrafoSize, cbf_luma, cbf_cb, cbf_cr);\n\n  assert(cbf_cb != -1);\n  assert(cbf_cr != -1);\n  assert(cbf_luma != -1);\n\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  const int ChromaArrayType = sps.ChromaArrayType;\n\n  int log2TrafoSizeC = (ChromaArrayType==CHROMA_444 ? log2TrafoSize : log2TrafoSize-1);\n  log2TrafoSizeC = libde265_max(2, log2TrafoSizeC);\n\n  const int cbfLuma   = cbf_luma;\n  const int cbfChroma = cbf_cb | cbf_cr;\n\n  tctx->transform_skip_flag[0]=0;\n  tctx->transform_skip_flag[1]=0;\n  tctx->transform_skip_flag[2]=0;\n\n  tctx->explicit_rdpcm_flag = false;\n\n\n  enum PredMode cuPredMode = tctx->img->get_pred_mode(x0,y0);\n\n  if (cbfLuma || cbfChroma)\n    {\n      bool doDecodeQuantParameters = false;\n\n      if (tctx->img->get_pps().cu_qp_delta_enabled_flag &&\n          !tctx->IsCuQpDeltaCoded) {\n\n        int cu_qp_delta_abs = decode_cu_qp_delta_abs(tctx);\n        int cu_qp_delta_sign=0;\n        if (cu_qp_delta_abs) {\n          cu_qp_delta_sign = decode_CABAC_bypass(&tctx->cabac_decoder);\n        }\n\n        tctx->IsCuQpDeltaCoded = 1;\n        tctx->CuQpDelta = cu_qp_delta_abs*(1-2*cu_qp_delta_sign);\n\n        //printf(\"read cu_qp_delta (%d;%d) = %d\\n\",x0,y0,tctx->CuQpDelta);\n\n        logtrace(LogSlice,\"cu_qp_delta_abs = %d\\n\",cu_qp_delta_abs);\n        logtrace(LogSlice,\"cu_qp_delta_sign = %d\\n\",cu_qp_delta_sign);\n        logtrace(LogSlice,\"CuQpDelta = %d\\n\",tctx->CuQpDelta);\n\n        doDecodeQuantParameters = true;\n        //decode_quantization_parameters(tctx, x0,y0, xCUBase, yCUBase);\n      }\n\n      if (tctx->shdr->cu_chroma_qp_offset_enabled_flag && cbfChroma &&\n          !tctx->cu_transquant_bypass_flag && !tctx->IsCuChromaQpOffsetCoded ) {\n        logtrace(LogSlice,\"# cu_chroma_qp_offset_flag\\n\");\n\n        int cu_chroma_qp_offset_flag = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                        &tctx->ctx_model[CONTEXT_MODEL_CU_CHROMA_QP_OFFSET_FLAG]);\n\n\n        const pic_parameter_set& pps = tctx->img->get_pps();\n\n        int cu_chroma_qp_offset_idx = 0;\n        if (cu_chroma_qp_offset_flag && pps.range_extension.chroma_qp_offset_list_len > 1) {\n          cu_chroma_qp_offset_idx = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                     &tctx->ctx_model[CONTEXT_MODEL_CU_CHROMA_QP_OFFSET_IDX]);\n        }\n\n        tctx->IsCuChromaQpOffsetCoded = 1;\n\n        if (cu_chroma_qp_offset_flag) {\n          tctx->CuQpOffsetCb = pps.range_extension.cb_qp_offset_list[ cu_chroma_qp_offset_idx ];\n          tctx->CuQpOffsetCr = pps.range_extension.cr_qp_offset_list[ cu_chroma_qp_offset_idx ];\n        }\n        else {\n          tctx->CuQpOffsetCb = 0;\n          tctx->CuQpOffsetCr = 0;\n        }\n\n        doDecodeQuantParameters = true;\n        //decode_quantization_parameters(tctx, x0,y0, xCUBase, yCUBase);\n      }\n\n\n      if (doDecodeQuantParameters) {\n        decode_quantization_parameters(tctx, x0,y0, xCUBase, yCUBase);\n      }\n    }\n\n  // position of TU in local CU\n  int xL = x0 - xCUBase;\n  int yL = y0 - yCUBase;\n  int nT = 1<<log2TrafoSize;\n  int nTC = 1<<log2TrafoSizeC;\n\n  const int SubWidthC  = sps.SubWidthC;\n  const int SubHeightC = sps.SubHeightC;\n\n  // --- luma ---\n\n  tctx->ResScaleVal = 0;\n\n  int err;\n  if (cbf_luma) {\n    if ((err=residual_coding(tctx,x0,y0, log2TrafoSize,0)) != DE265_OK) return err;\n  }\n\n  decode_TU(tctx, x0,y0, xCUBase,yCUBase, nT, 0, cuPredMode, cbf_luma);\n\n\n  // --- chroma ---\n\n  const int yOffset422 = 1<<log2TrafoSizeC;\n\n  if (log2TrafoSize>2 || ChromaArrayType == CHROMA_444) {\n    // TODO: cross-component prediction\n\n    const bool do_cross_component_prediction =\n      (tctx->img->get_pps().range_extension.cross_component_prediction_enabled_flag &&\n       cbf_luma &&\n       (cuPredMode == MODE_INTER || tctx->img->is_IntraPredModeC_Mode4(x0,y0)));\n\n    if (do_cross_component_prediction) {\n      read_cross_comp_pred(tctx, 0);\n    }\n    else {\n      tctx->ResScaleVal = 0;\n    }\n\n    {\n      if (cbf_cb & 1) {\n        if ((err=residual_coding(tctx,x0,y0,log2TrafoSizeC,1)) != DE265_OK) return err;\n      }\n\n      if (sps.ChromaArrayType != CHROMA_MONO) {\n        decode_TU(tctx,\n                  x0/SubWidthC,y0/SubHeightC,\n                  xCUBase/SubWidthC,yCUBase/SubHeightC, nTC, 1, cuPredMode, cbf_cb & 1);\n      }\n    }\n\n    // 4:2:2\n    if (ChromaArrayType == CHROMA_422) {\n      const int yOffset = 1<<log2TrafoSizeC;\n\n      if (cbf_cb & 2) {\n        if ((err=residual_coding(tctx,\n                                 x0,y0+yOffset*SubHeightC,\n                                 log2TrafoSizeC,1)) != DE265_OK) return err;\n      }\n\n      decode_TU(tctx,\n                x0/SubWidthC,y0/SubHeightC + yOffset,\n                xCUBase/SubWidthC,yCUBase/SubHeightC +yOffset,\n                nTC, 1, cuPredMode, cbf_cb & 2);\n    }\n\n\n    if (do_cross_component_prediction) {\n      read_cross_comp_pred(tctx, 1);\n    }\n    else {\n      tctx->ResScaleVal = 0;\n    }\n\n    {\n      if (cbf_cr & 1) {\n        if ((err=residual_coding(tctx,x0,y0,log2TrafoSizeC,2)) != DE265_OK) return err;\n      }\n\n      if (sps.ChromaArrayType != CHROMA_MONO) {\n        decode_TU(tctx,\n                  x0/SubWidthC,y0/SubHeightC,\n                  xCUBase/SubWidthC,yCUBase/SubHeightC,\n                  nTC, 2, cuPredMode, cbf_cr & 1);\n      }\n    }\n\n    // 4:2:2\n    if (ChromaArrayType == CHROMA_422) {\n      const int yOffset = 1<<log2TrafoSizeC;\n\n      if (cbf_cr & 2) {\n        if ((err=residual_coding(tctx,\n                                 x0,y0+yOffset*SubHeightC,\n                                 log2TrafoSizeC,2)) != DE265_OK) return err;\n      }\n\n      decode_TU(tctx,\n                x0/SubWidthC,y0/SubHeightC+yOffset,\n                xCUBase/SubWidthC,yCUBase/SubHeightC+yOffset,\n                nTC, 2, cuPredMode, cbf_cr & 2);\n    }\n  }\n  else if (blkIdx==3) {\n    if (cbf_cb & 1) {\n      if ((err=residual_coding(tctx,xBase,yBase,\n                               log2TrafoSize,1)) != DE265_OK) return err;\n    }\n\n    if (sps.ChromaArrayType != CHROMA_MONO) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC,\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 1, cuPredMode, cbf_cb & 1);\n    }\n\n    // 4:2:2\n    if (cbf_cb & 2) {\n      if ((err=residual_coding(tctx,\n                               xBase        ,yBase        +(1<<log2TrafoSize),\n                               log2TrafoSize,1)) != DE265_OK) return err;\n    }\n\n    if (ChromaArrayType == CHROMA_422) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC + (1<<log2TrafoSize),\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 1, cuPredMode, cbf_cb & 2);\n    }\n\n    if (cbf_cr & 1) {\n      if ((err=residual_coding(tctx,xBase,yBase,\n                               log2TrafoSize,2)) != DE265_OK) return err;\n    }\n\n    if (sps.ChromaArrayType != CHROMA_MONO) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC,\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 2, cuPredMode, cbf_cr & 1);\n    }\n\n    // 4:2:2\n    if (cbf_cr & 2) {\n      if ((err=residual_coding(tctx,\n                               xBase        ,yBase        +(1<<log2TrafoSizeC),\n                               log2TrafoSize,2)) != DE265_OK) return err;\n    }\n\n    if (ChromaArrayType == CHROMA_422) {\n      decode_TU(tctx,\n                xBase/SubWidthC,  yBase/SubHeightC + (1<<log2TrafoSize),\n                xCUBase/SubWidthC,yCUBase/SubHeightC, nT, 2, cuPredMode, cbf_cr & 2);\n    }\n  }\n\n\n  return DE265_OK;\n}\n\n\nstatic void dump_cbsize(de265_image* img)\n{\n  int w = img->get_width(0);\n  int h = img->get_height(0);\n\n  for (int y=0;y<h;y+=8) {\n    for (int x=0;x<w;x+=8) {\n      printf(\"%d\",img->get_log2CbSize(x,y));\n    }\n    printf(\"\\n\");\n  }\n}\n\n\nvoid read_transform_tree(thread_context* tctx,\n                         int x0, int y0,        // position of TU in frame\n                         int xBase, int yBase,  // position of parent TU in frame\n                         int xCUBase, int yCUBase, // position of CU in frame\n                         int log2TrafoSize,\n                         int trafoDepth,\n                         int blkIdx,\n                         int MaxTrafoDepth,\n                         int IntraSplitFlag,\n                         enum PredMode cuPredMode,\n                         uint8_t parent_cbf_cb,uint8_t parent_cbf_cr)\n{\n  logtrace(LogSlice,\"- read_transform_tree (interleaved) x0:%d y0:%d xBase:%d yBase:%d \"\n           \"log2TrafoSize:%d trafoDepth:%d MaxTrafoDepth:%d parent-cbf-cb:%d parent-cbf-cr:%d\\n\",\n           x0,y0,xBase,yBase,log2TrafoSize,trafoDepth,MaxTrafoDepth,parent_cbf_cb,parent_cbf_cr);\n\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n\n  int split_transform_flag;\n\n  enum PredMode PredMode = img->get_pred_mode(x0,y0);\n  assert(PredMode == cuPredMode);\n\n  /*  If TrafoSize is larger than maximum size   -> split automatically\n      If TrafoSize is at minimum size            -> do not split\n      If maximum transformation depth is reached -> do not split\n      If intra-prediction is NxN mode            -> split automatically (only at level 0)\n      Otherwise  ->  read split flag\n  */\n  if (log2TrafoSize <= sps.Log2MaxTrafoSize &&\n      log2TrafoSize >  sps.Log2MinTrafoSize &&\n      trafoDepth < MaxTrafoDepth &&\n      !(IntraSplitFlag && trafoDepth==0))\n    {\n      split_transform_flag = decode_split_transform_flag(tctx, log2TrafoSize);\n    }\n  else\n    {\n      enum PartMode PartMode = img->get_PartMode(x0,y0);\n\n      int interSplitFlag= (sps.max_transform_hierarchy_depth_inter==0 &&\n                           trafoDepth == 0 &&\n                           PredMode == MODE_INTER &&\n                           PartMode != PART_2Nx2N);\n\n      split_transform_flag = (log2TrafoSize > sps.Log2MaxTrafoSize ||\n                              (IntraSplitFlag==1 && trafoDepth==0) ||\n                              interSplitFlag==1) ? 1:0;\n    }\n\n  if (split_transform_flag) {\n    logtrace(LogSlice,\"set_split_transform_flag(%d,%d, %d)\\n\",x0,y0,trafoDepth);\n    img->set_split_transform_flag(x0,y0,trafoDepth);\n  }\n\n  int cbf_cb=-1;\n  int cbf_cr=-1;\n\n  // CBF_CB/CR flags are encoded like this:\n  // 4:2:0 and 4:4:4 modes: binary flag in bit 0\n  // 4:2:2 mode: bit 0: top block, bit 1: bottom block\n\n  if ((log2TrafoSize>2 && sps.ChromaArrayType != CHROMA_MONO) ||\n      sps.ChromaArrayType == CHROMA_444) {\n    // we do not have to test for trafoDepth==0, because parent_cbf_cb is 1 at depth 0\n    if (/*trafoDepth==0 ||*/ parent_cbf_cb) {\n      cbf_cb = decode_cbf_chroma(tctx,trafoDepth);\n\n      if (sps.ChromaArrayType == CHROMA_422 && (!split_transform_flag || log2TrafoSize==3)) {\n        cbf_cb |= (decode_cbf_chroma(tctx,trafoDepth) << 1);\n      }\n    }\n\n    // we do not have to test for trafoDepth==0, because parent_cbf_cb is 1 at depth 0\n    if (/*trafoDepth==0 ||*/ parent_cbf_cr) {\n      cbf_cr = decode_cbf_chroma(tctx,trafoDepth);\n\n      if (sps.ChromaArrayType == CHROMA_422 && (!split_transform_flag || log2TrafoSize==3)) {\n        cbf_cr |= (decode_cbf_chroma(tctx,trafoDepth) << 1);\n      }\n    }\n  }\n\n  //printf(\"CBF: cb:%d cr:%d\\n\",cbf_cb,cbf_cr);\n\n  // cbf_cr/cbf_cb not present in bitstream -> induce values\n\n  if (cbf_cb<0) {\n    assert(!(trafoDepth==0 && log2TrafoSize==2));\n\n    /* The standard specifies to check trafoDepth>0 AND log2TrafoSize==2.\n       However, I think that trafoDepth>0 is redundant as a CB is always\n       at least 8x8 and hence trafoDepth>0.\n    */\n\n    if (trafoDepth>0 && log2TrafoSize==2) {\n      cbf_cb = parent_cbf_cb;\n    } else {\n      cbf_cb=0;\n    }\n  }\n\n  if (cbf_cr<0) {\n    if (trafoDepth>0 && log2TrafoSize==2) {\n      cbf_cr = parent_cbf_cr;\n    } else {\n      cbf_cr=0;\n    }\n  }\n\n  if (split_transform_flag) {\n    int x1 = x0 + (1<<(log2TrafoSize-1));\n    int y1 = y0 + (1<<(log2TrafoSize-1));\n\n    logtrace(LogSlice,\"transform split.\\n\");\n\n    read_transform_tree(tctx, x0,y0, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 0,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n    read_transform_tree(tctx, x1,y0, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 1,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n    read_transform_tree(tctx, x0,y1, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 2,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n    read_transform_tree(tctx, x1,y1, x0,y0, xCUBase,yCUBase, log2TrafoSize-1, trafoDepth+1, 3,\n                        MaxTrafoDepth,IntraSplitFlag, cuPredMode, cbf_cb,cbf_cr);\n  }\n  else {\n    int cbf_luma;\n\n    if (PredMode==MODE_INTRA || trafoDepth!=0 || cbf_cb || cbf_cr) {\n      cbf_luma = decode_cbf_luma(tctx,trafoDepth);\n    }\n    else {\n      /* There cannot be INTER blocks with no residual data.\n         That case is already handled with rqt_root_cbf.\n      */\n\n      cbf_luma = 1;\n    }\n\n    logtrace(LogSlice,\"call read_transform_unit %d/%d\\n\",x0,y0);\n\n    read_transform_unit(tctx, x0,y0,xBase,yBase, xCUBase,yCUBase, log2TrafoSize,trafoDepth, blkIdx,\n                        cbf_luma, cbf_cb, cbf_cr);\n  }\n}\n\n\nconst char* part_mode_name(enum PartMode pm)\n{\n  switch (pm) {\n  case PART_2Nx2N: return \"2Nx2N\";\n  case PART_2NxN:  return \"2NxN\";\n  case PART_Nx2N:  return \"Nx2N\";\n  case PART_NxN:   return \"NxN\";\n  case PART_2NxnU: return \"2NxnU\";\n  case PART_2NxnD: return \"2NxnD\";\n  case PART_nLx2N: return \"nLx2N\";\n  case PART_nRx2N: return \"nRx2N\";\n  }\n\n  return \"undefined part mode\";\n}\n\n\nvoid read_mvd_coding(thread_context* tctx,\n                     int x0,int y0, int refList)\n{\n  int abs_mvd_greater0_flag[2];\n  abs_mvd_greater0_flag[0] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                              &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+0]);\n  abs_mvd_greater0_flag[1] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                              &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+0]);\n\n  int abs_mvd_greater1_flag[2];\n  if (abs_mvd_greater0_flag[0]) {\n    abs_mvd_greater1_flag[0] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+1]);\n  }\n  else {\n    abs_mvd_greater1_flag[0]=0;\n  }\n\n  if (abs_mvd_greater0_flag[1]) {\n    abs_mvd_greater1_flag[1] = decode_CABAC_bit(&tctx->cabac_decoder,\n                                                &tctx->ctx_model[CONTEXT_MODEL_ABS_MVD_GREATER01_FLAG+1]);\n  }\n  else {\n    abs_mvd_greater1_flag[1]=0;\n  }\n\n\n  int abs_mvd_minus2[2];\n  int mvd_sign_flag[2];\n  int value[2];\n\n  for (int c=0;c<2;c++) {\n    if (abs_mvd_greater0_flag[c]) {\n      if (abs_mvd_greater1_flag[c]) {\n        abs_mvd_minus2[c] = decode_CABAC_EGk_bypass(&tctx->cabac_decoder, 1);\n      }\n      else {\n        abs_mvd_minus2[c] = abs_mvd_greater1_flag[c] -1;\n      }\n\n      mvd_sign_flag[c] = decode_CABAC_bypass(&tctx->cabac_decoder);\n\n      value[c] = abs_mvd_minus2[c]+2;\n      if (mvd_sign_flag[c]) { value[c] = -value[c]; }\n    }\n    else {\n      value[c] = 0;\n    }\n  }\n\n  //set_mvd(tctx->decctx, x0,y0, refList, value[0],value[1]);\n  tctx->motion.mvd[refList][0] = value[0];\n  tctx->motion.mvd[refList][1] = value[1];\n\n  logtrace(LogSlice, \"MVD[%d;%d|%d] = %d;%d\\n\",x0,y0,refList, value[0],value[1]);\n}\n\n\nvoid read_prediction_unit_SKIP(thread_context* tctx,\n                               int x0, int y0,\n                               int nPbW, int nPbH)\n{\n  int merge_idx = decode_merge_idx(tctx);\n\n  tctx->motion.merge_idx = merge_idx;\n  tctx->motion.merge_flag = true;\n\n  logtrace(LogSlice,\"prediction skip 2Nx2N, merge_idx: %d\\n\",merge_idx);\n}\n\n\n/* xC/yC : CB position\n   xB/yB : position offset of the PB\n   nPbW/nPbH : size of PB\n   nCS   : CB size\n */\nvoid read_prediction_unit(thread_context* tctx,\n                          int xC,int yC, int xB,int yB,\n                          int nPbW, int nPbH,\n                          int ctDepth, int nCS,int partIdx)\n{\n  logtrace(LogSlice,\"read_prediction_unit %d;%d %dx%d\\n\",xC+xB,yC+xB,nPbW,nPbH);\n\n  int x0 = xC+xB;\n  int y0 = yC+yB;\n\n  slice_segment_header* shdr = tctx->shdr;\n\n  int merge_flag = decode_merge_flag(tctx);\n  tctx->motion.merge_flag = merge_flag;\n\n  if (merge_flag) {\n    int merge_idx = decode_merge_idx(tctx);\n\n    logtrace(LogSlice,\"prediction unit %d,%d, merge mode, index: %d\\n\",x0,y0,merge_idx);\n\n    tctx->motion.merge_idx = merge_idx;\n  }\n  else { // no merge flag\n    enum InterPredIdc inter_pred_idc;\n\n    if (shdr->slice_type == SLICE_TYPE_B) {\n      inter_pred_idc = decode_inter_pred_idc(tctx,x0,y0,nPbW,nPbH,ctDepth);\n    }\n    else {\n      inter_pred_idc = PRED_L0;\n    }\n\n    tctx->motion.inter_pred_idc = inter_pred_idc; // set_inter_pred_idc(ctx,x0,y0, inter_pred_idc);\n\n    if (inter_pred_idc != PRED_L1) {\n      int ref_idx_l0 = decode_ref_idx_lX(tctx, shdr->num_ref_idx_l0_active);\n\n      // NOTE: case for only one reference frame is handles in decode_ref_idx_lX()\n      tctx->motion.refIdx[0] = ref_idx_l0;\n\n      read_mvd_coding(tctx,x0,y0, 0);\n\n      int mvp_l0_flag = decode_mvp_lx_flag(tctx); // l0\n      tctx->motion.mvp_l0_flag = mvp_l0_flag;\n\n      logtrace(LogSlice,\"prediction unit %d,%d, L0, refIdx=%d mvp_l0_flag:%d\\n\",\n               x0,y0, tctx->motion.refIdx[0], mvp_l0_flag);\n    }\n\n    if (inter_pred_idc != PRED_L0) {\n      int ref_idx_l1 = decode_ref_idx_lX(tctx, shdr->num_ref_idx_l1_active);\n\n      // NOTE: case for only one reference frame is handles in decode_ref_idx_lX()\n      tctx->motion.refIdx[1] = ref_idx_l1;\n\n      if (shdr->mvd_l1_zero_flag &&\n          inter_pred_idc == PRED_BI) {\n        tctx->motion.mvd[1][0] = 0;\n        tctx->motion.mvd[1][1] = 0;\n      }\n      else {\n        read_mvd_coding(tctx,x0,y0, 1);\n      }\n\n      int mvp_l1_flag = decode_mvp_lx_flag(tctx); // l1\n      tctx->motion.mvp_l1_flag = mvp_l1_flag;\n\n      logtrace(LogSlice,\"prediction unit %d,%d, L1, refIdx=%d mvp_l1_flag:%d\\n\",\n               x0,y0, tctx->motion.refIdx[1], mvp_l1_flag);\n    }\n  }\n\n\n\n  decode_prediction_unit(tctx->decctx, tctx->shdr, tctx->img, tctx->motion,\n                         xC,yC,xB,yB, nCS, nPbW,nPbH, partIdx);\n}\n\n\n\n\ntemplate <class pixel_t>\nvoid read_pcm_samples_internal(thread_context* tctx, int x0, int y0, int log2CbSize,\n                               int cIdx, bitreader& br)\n{\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  int nPcmBits;\n  int bitDepth;\n\n  int w = 1<<log2CbSize;\n  int h = 1<<log2CbSize;\n\n  if (cIdx>0) {\n    w /= sps.SubWidthC;\n    h /= sps.SubHeightC;\n\n    x0 /= sps.SubWidthC;\n    y0 /= sps.SubHeightC;\n\n    nPcmBits = sps.pcm_sample_bit_depth_chroma;\n    bitDepth = sps.BitDepth_C;\n  }\n  else {\n    nPcmBits = sps.pcm_sample_bit_depth_luma;\n    bitDepth = sps.BitDepth_Y;\n  }\n\n  pixel_t* ptr;\n  int stride;\n  ptr    = tctx->img->get_image_plane_at_pos_NEW<pixel_t>(cIdx,x0,y0);\n  stride = tctx->img->get_image_stride(cIdx);\n\n  int shift = bitDepth - nPcmBits;\n\n  // a shift < 0 may result when the SPS sequence header is broken\n  if (shift < 0) {\n    shift=0;\n  }\n\n  for (int y=0;y<h;y++)\n    for (int x=0;x<w;x++)\n      {\n        int value = get_bits(&br, nPcmBits);\n        ptr[y*stride+x] = value << shift;\n      }\n}\n\nstatic void read_pcm_samples(thread_context* tctx, int x0, int y0, int log2CbSize)\n{\n  bitreader br;\n  br.data            = tctx->cabac_decoder.bitstream_curr;\n  br.bytes_remaining = tctx->cabac_decoder.bitstream_end - tctx->cabac_decoder.bitstream_curr;\n  br.nextbits = 0;\n  br.nextbits_cnt = 0;\n\n\n  if (tctx->img->high_bit_depth(0)) {\n    read_pcm_samples_internal<uint16_t>(tctx,x0,y0,log2CbSize,0,br);\n  } else {\n    read_pcm_samples_internal<uint8_t>(tctx,x0,y0,log2CbSize,0,br);\n  }\n\n  if (tctx->img->get_sps().ChromaArrayType != CHROMA_MONO) {\n    if (tctx->img->high_bit_depth(1)) {\n      read_pcm_samples_internal<uint16_t>(tctx,x0,y0,log2CbSize,1,br);\n      read_pcm_samples_internal<uint16_t>(tctx,x0,y0,log2CbSize,2,br);\n    } else {\n      read_pcm_samples_internal<uint8_t>(tctx,x0,y0,log2CbSize,1,br);\n      read_pcm_samples_internal<uint8_t>(tctx,x0,y0,log2CbSize,2,br);\n    }\n  }\n\n  prepare_for_CABAC(&br);\n  tctx->cabac_decoder.bitstream_curr = br.data;\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n}\n\n\nint map_chroma_pred_mode(int intra_chroma_pred_mode, int IntraPredMode)\n{\n  if (intra_chroma_pred_mode==4) {\n    return IntraPredMode;\n  }\n  else {\n    static const enum IntraPredMode IntraPredModeCCand[4] = {\n      INTRA_PLANAR,\n      INTRA_ANGULAR_26, // vertical\n      INTRA_ANGULAR_10, // horizontal\n      INTRA_DC\n    };\n\n    int IntraPredModeC = IntraPredModeCCand[intra_chroma_pred_mode];\n    if (IntraPredModeC == IntraPredMode) {\n      return INTRA_ANGULAR_34;\n    }\n    else {\n      return IntraPredModeC;\n    }\n  }\n}\n\n// h.265-V2 Table 8-3\nstatic const uint8_t map_chroma_422[35] = {\n  0,1,2, 2, 2, 2, 3, 5, 7, 8,10,12,13,15,17,18,19,20,\n  21,22,23,23,24,24,25,25,26,27,27,28,28,29,29,30,31\n};\n\nvoid read_coding_unit(thread_context* tctx,\n                      int x0, int y0,  // position of coding unit in frame\n                      int log2CbSize,\n                      int ctDepth)\n{\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n  slice_segment_header* shdr = tctx->shdr;\n\n  logtrace(LogSlice,\"- read_coding_unit %d;%d cbsize:%d\\n\",x0,y0,1<<log2CbSize);\n\n\n  //QQprintf(\"- read_coding_unit %d;%d cbsize:%d\\n\",x0,y0,1<<log2CbSize);\n\n  img->set_log2CbSize(x0,y0, log2CbSize, true);\n\n  /* This is only required on corrupted input streams.\n     It may happen that there are several slices in the image that overlap.\n     In this case, flags would accumulate from both slices.\n  */\n  img->clear_split_transform_flags(x0,y0, log2CbSize);\n\n  int nCbS = 1<<log2CbSize; // number of coding block samples\n\n  decode_quantization_parameters(tctx, x0,y0, x0, y0);\n\n\n  if (pps.transquant_bypass_enable_flag)\n    {\n      int transquant_bypass = decode_transquant_bypass_flag(tctx);\n\n      tctx->cu_transquant_bypass_flag = transquant_bypass;\n\n      if (transquant_bypass) {\n        img->set_cu_transquant_bypass(x0,y0,log2CbSize);\n      }\n    }\n  else {\n    tctx->cu_transquant_bypass_flag = 0;\n  }\n\n  uint8_t cu_skip_flag = 0;\n  if (shdr->slice_type != SLICE_TYPE_I) {\n    cu_skip_flag = decode_cu_skip_flag(tctx,x0,y0,ctDepth);\n  }\n\n  int IntraSplitFlag = 0;\n\n  enum PredMode cuPredMode;\n\n  if (cu_skip_flag) {\n    read_prediction_unit_SKIP(tctx,x0,y0,nCbS,nCbS);\n\n    img->set_PartMode(x0,y0, PART_2Nx2N); // need this for deblocking filter\n    img->set_pred_mode(x0,y0,log2CbSize, MODE_SKIP);\n    cuPredMode = MODE_SKIP;\n\n    logtrace(LogSlice,\"CU pred mode: SKIP\\n\");\n\n\n    // DECODE\n\n    int nCS_L = 1<<log2CbSize;\n    decode_prediction_unit(tctx->decctx,tctx->shdr,tctx->img,tctx->motion,\n                           x0,y0, 0,0, nCS_L, nCS_L,nCS_L, 0);\n  }\n  else /* not skipped */ {\n    if (shdr->slice_type != SLICE_TYPE_I) {\n      int pred_mode_flag = decode_pred_mode_flag(tctx);\n      cuPredMode = pred_mode_flag ? MODE_INTRA : MODE_INTER;\n    }\n    else {\n      cuPredMode = MODE_INTRA;\n    }\n\n    img->set_pred_mode(x0,y0,log2CbSize, cuPredMode);\n\n    logtrace(LogSlice,\"CU pred mode: %s\\n\", cuPredMode==MODE_INTRA ? \"INTRA\" : \"INTER\");\n\n\n    enum PartMode PartMode;\n\n    if (cuPredMode != MODE_INTRA ||\n        log2CbSize == sps.Log2MinCbSizeY) {\n      PartMode = decode_part_mode(tctx, cuPredMode, log2CbSize);\n\n      if (PartMode==PART_NxN && cuPredMode==MODE_INTRA) {\n        IntraSplitFlag=1;\n      }\n    } else {\n      PartMode = PART_2Nx2N;\n    }\n\n    img->set_PartMode(x0,y0, PartMode); // needed for deblocking ?\n\n    logtrace(LogSlice, \"PartMode: %s\\n\", part_mode_name(PartMode));\n\n\n    bool pcm_flag = false;\n\n    if (cuPredMode == MODE_INTRA) {\n      if (PartMode == PART_2Nx2N && sps.pcm_enabled_flag &&\n          log2CbSize >= sps.Log2MinIpcmCbSizeY &&\n          log2CbSize <= sps.Log2MaxIpcmCbSizeY) {\n        pcm_flag = decode_CABAC_term_bit(&tctx->cabac_decoder);\n      }\n\n      if (pcm_flag) {\n        img->set_pcm_flag(x0,y0,log2CbSize);\n\n        read_pcm_samples(tctx, x0,y0, log2CbSize);\n      }\n      else {\n        int pbOffset = (PartMode == PART_NxN) ? (nCbS/2) : nCbS;\n        int log2IntraPredSize = (PartMode == PART_NxN) ? (log2CbSize-1) : log2CbSize;\n\n        logtrace(LogSlice,\"nCbS:%d pbOffset:%d\\n\",nCbS,pbOffset);\n\n        int prev_intra_luma_pred_flag[4];\n\n        int idx=0;\n        for (int j=0;j<nCbS;j+=pbOffset)\n          for (int i=0;i<nCbS;i+=pbOffset)\n            {\n              prev_intra_luma_pred_flag[idx++] = decode_prev_intra_luma_pred_flag(tctx);\n            }\n\n        int mpm_idx[4], rem_intra_luma_pred_mode[4];\n        idx=0;\n\n        int availableA0 = check_CTB_available(img, x0,y0, x0-1,y0);\n        int availableB0 = check_CTB_available(img, x0,y0, x0,y0-1);\n\n        for (int j=0;j<nCbS;j+=pbOffset)\n          for (int i=0;i<nCbS;i+=pbOffset)\n            {\n              if (prev_intra_luma_pred_flag[idx]) {\n                mpm_idx[idx] = decode_mpm_idx(tctx);\n              }\n              else {\n                rem_intra_luma_pred_mode[idx] = decode_rem_intra_luma_pred_mode(tctx);\n              }\n\n\n              int x = x0+i;\n              int y = y0+j;\n\n              // --- find intra prediction mode ---\n\n              int IntraPredMode;\n\n              int availableA = availableA0 || (i>0); // left candidate always available for right blk\n              int availableB = availableB0 || (j>0); // top candidate always available for bottom blk\n\n\n\n              int PUidx = (x>>sps.Log2MinPUSize) + (y>>sps.Log2MinPUSize)*sps.PicWidthInMinPUs;\n\n              enum IntraPredMode candModeList[3];\n\n              fillIntraPredModeCandidates(candModeList,x,y,PUidx,\n                                          availableA, availableB, img);\n\n              for (int i=0;i<3;i++)\n                logtrace(LogSlice,\"candModeList[%d] = %d\\n\", i, candModeList[i]);\n\n              if (prev_intra_luma_pred_flag[idx]==1) {\n                IntraPredMode = candModeList[ mpm_idx[idx] ];\n              }\n              else {\n                // sort candModeList\n\n                if (candModeList[0] > candModeList[1]) {\n                  std::swap(candModeList[0],candModeList[1]);\n                }\n                if (candModeList[0] > candModeList[2]) {\n                  std::swap(candModeList[0],candModeList[2]);\n                }\n                if (candModeList[1] > candModeList[2]) {\n                  std::swap(candModeList[1],candModeList[2]);\n                }\n\n                // skip modes in the list\n                // (we have 35 modes. skipping the 3 in the list gives us 32, which can be selected by 5 bits)\n                IntraPredMode = rem_intra_luma_pred_mode[idx];\n                for (int n=0;n<=2;n++) {\n                  if (IntraPredMode >= candModeList[n]) { IntraPredMode++; }\n                }\n              }\n\n              logtrace(LogSlice,\"IntraPredMode[%d][%d] = %d (log2blk:%d)\\n\",x,y,IntraPredMode, log2IntraPredSize);\n\n              img->set_IntraPredMode(PUidx, log2IntraPredSize,\n                                     (enum IntraPredMode)IntraPredMode);\n\n              idx++;\n            }\n\n\n        // set chroma intra prediction mode\n\n        if (sps.ChromaArrayType == CHROMA_444) {\n          // chroma 4:4:4\n\n          idx = 0;\n          for (int j=0;j<nCbS;j+=pbOffset)\n            for (int i=0;i<nCbS;i+=pbOffset) {\n              int x = x0+i;\n              int y = y0+j;\n\n              int intra_chroma_pred_mode = decode_intra_chroma_pred_mode(tctx);\n              int IntraPredMode = img->get_IntraPredMode(x,y);\n\n              int IntraPredModeC = map_chroma_pred_mode(intra_chroma_pred_mode, IntraPredMode);\n\n              logtrace(LogSlice,\"IntraPredModeC[%d][%d]: %d (blksize:%d)\\n\",x,y,IntraPredModeC,\n                       1<<log2IntraPredSize);\n\n              img->set_IntraPredModeC(x,y, log2IntraPredSize,\n                                      (enum IntraPredMode)IntraPredModeC,\n                                      intra_chroma_pred_mode == 4);\n              idx++;\n            }\n        }\n        else if (sps.ChromaArrayType != CHROMA_MONO) {\n          // chroma 4:2:0 and 4:2:2\n\n          int intra_chroma_pred_mode = decode_intra_chroma_pred_mode(tctx);\n          int IntraPredMode = img->get_IntraPredMode(x0,y0);\n          logtrace(LogSlice,\"IntraPredMode: %d\\n\",IntraPredMode);\n          int IntraPredModeC = map_chroma_pred_mode(intra_chroma_pred_mode, IntraPredMode);\n\n          if (sps.ChromaArrayType == CHROMA_422) {\n            IntraPredModeC = map_chroma_422[ IntraPredModeC ];\n          }\n\n          img->set_IntraPredModeC(x0,y0, log2CbSize,\n                                  (enum IntraPredMode)IntraPredModeC,\n                                  intra_chroma_pred_mode == 4);\n        }\n      }\n    }\n    else { // INTER\n      int nCS = 1<<log2CbSize;\n\n      if (PartMode == PART_2Nx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0,nCbS,nCbS,ctDepth,nCS,0);\n      }\n      else if (PartMode == PART_2NxN) {\n        read_prediction_unit(tctx,x0,y0,0,0     ,nCbS,nCbS/2,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,0,nCbS/2,nCbS,nCbS/2,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_Nx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0  ,   nCbS/2,nCbS,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS/2,0,nCbS/2,nCbS,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_2NxnU) {\n        read_prediction_unit(tctx,x0,y0,0,0,     nCbS,nCbS/4,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,0,nCbS/4,nCbS,nCbS*3/4,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_2NxnD) {\n        read_prediction_unit(tctx,x0,y0,0,0,       nCbS,nCbS*3/4,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,0,nCbS*3/4,nCbS,nCbS/4,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_nLx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0,     nCbS/4,nCbS,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS/4,0,nCbS*3/4,nCbS,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_nRx2N) {\n        read_prediction_unit(tctx,x0,y0,0,0,       nCbS*3/4,nCbS,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS*3/4,0,nCbS/4,nCbS,ctDepth,nCS,1);\n      }\n      else if (PartMode == PART_NxN) {\n        read_prediction_unit(tctx,x0,y0,0,0,          nCbS/2,nCbS/2,ctDepth,nCS,0);\n        read_prediction_unit(tctx,x0,y0,nCbS/2,0,     nCbS/2,nCbS/2,ctDepth,nCS,1);\n        read_prediction_unit(tctx,x0,y0,0,nCbS/2,     nCbS/2,nCbS/2,ctDepth,nCS,2);\n        read_prediction_unit(tctx,x0,y0,nCbS/2,nCbS/2,nCbS/2,nCbS/2,ctDepth,nCS,3);\n      }\n      else {\n        assert(0); // undefined PartMode\n      }\n    } // INTER\n\n\n    // decode residual\n\n    if (!pcm_flag) { // !pcm\n      bool rqt_root_cbf;\n\n      uint8_t merge_flag = tctx->motion.merge_flag; // !!get_merge_flag(ctx,x0,y0);\n\n      if (cuPredMode != MODE_INTRA &&\n          !(PartMode == PART_2Nx2N && merge_flag)) {\n\n        rqt_root_cbf = !!decode_rqt_root_cbf(tctx);\n      }\n      else {\n        /* rqt_root_cbf=1 is inferred for Inter blocks with 2Nx2N, merge mode.\n           These must be some residual data, because otherwise, the CB could\n           also be coded in SKIP mode.\n         */\n\n        rqt_root_cbf = true;\n      }\n\n      //set_rqt_root_cbf(ctx,x0,y0, log2CbSize, rqt_root_cbf);\n\n      if (rqt_root_cbf) {\n        int MaxTrafoDepth;\n\n        if (cuPredMode==MODE_INTRA) {\n          MaxTrafoDepth = sps.max_transform_hierarchy_depth_intra + IntraSplitFlag;\n        }\n        else {\n          MaxTrafoDepth = sps.max_transform_hierarchy_depth_inter;\n        }\n\n        logtrace(LogSlice,\"MaxTrafoDepth: %d\\n\",MaxTrafoDepth);\n\n        uint8_t initial_chroma_cbf = 1;\n        if (sps.ChromaArrayType == CHROMA_MONO) {\n          initial_chroma_cbf = 0;\n        }\n\n        read_transform_tree(tctx, x0,y0, x0,y0, x0,y0, log2CbSize, 0,0,\n                            MaxTrafoDepth, IntraSplitFlag, cuPredMode,\n                            initial_chroma_cbf, initial_chroma_cbf);\n      }\n    } // !pcm\n  }\n}\n\n\n// ------------------------------------------------------------------------------------------\n\n\nvoid read_coding_quadtree(thread_context* tctx,\n                          int x0, int y0,\n                          int log2CbSize,\n                          int ctDepth)\n{\n  logtrace(LogSlice,\"- read_coding_quadtree %d;%d cbsize:%d depth:%d POC:%d\\n\",x0,y0,1<<log2CbSize,ctDepth,tctx->img->PicOrderCntVal);\n\n  de265_image* img = tctx->img;\n  const seq_parameter_set& sps = img->get_sps();\n  const pic_parameter_set& pps = img->get_pps();\n\n  int split_flag;\n\n  // We only send a split flag if CU is larger than minimum size and\n  // completely contained within the image area.\n  // If it is partly outside the image area and not at minimum size,\n  // it is split. If already at minimum size, it is not split further.\n  if (x0+(1<<log2CbSize) <= sps.pic_width_in_luma_samples &&\n      y0+(1<<log2CbSize) <= sps.pic_height_in_luma_samples &&\n      log2CbSize > sps.Log2MinCbSizeY) {\n    split_flag = decode_split_cu_flag(tctx, x0,y0, ctDepth);\n  } else {\n    if (log2CbSize > sps.Log2MinCbSizeY) { split_flag=1; }\n    else                                  { split_flag=0; }\n  }\n\n\n  if (pps.cu_qp_delta_enabled_flag &&\n      log2CbSize >= pps.Log2MinCuQpDeltaSize)\n    {\n      tctx->IsCuQpDeltaCoded = 0;\n      tctx->CuQpDelta = 0;\n    }\n  else\n    {\n      // shdr->CuQpDelta = 0; // TODO check: is this the right place to set to default value ?\n    }\n\n\n  if (tctx->shdr->cu_chroma_qp_offset_enabled_flag &&\n      log2CbSize >= pps.Log2MinCuChromaQpOffsetSize) {\n    tctx->IsCuChromaQpOffsetCoded = 0;\n  }\n\n  if (split_flag) {\n    int x1 = x0 + (1<<(log2CbSize-1));\n    int y1 = y0 + (1<<(log2CbSize-1));\n\n    read_coding_quadtree(tctx,x0,y0, log2CbSize-1, ctDepth+1);\n\n    if (x1<sps.pic_width_in_luma_samples)\n      read_coding_quadtree(tctx,x1,y0, log2CbSize-1, ctDepth+1);\n\n    if (y1<sps.pic_height_in_luma_samples)\n      read_coding_quadtree(tctx,x0,y1, log2CbSize-1, ctDepth+1);\n\n    if (x1<sps.pic_width_in_luma_samples &&\n        y1<sps.pic_height_in_luma_samples)\n      read_coding_quadtree(tctx,x1,y1, log2CbSize-1, ctDepth+1);\n  }\n  else {\n    // set ctDepth of this CU\n\n    img->set_ctDepth(x0,y0, log2CbSize, ctDepth);\n\n    read_coding_unit(tctx, x0,y0, log2CbSize, ctDepth);\n  }\n\n  logtrace(LogSlice,\"-\\n\");\n}\n\n\n// ---------------------------------------------------------------------------\n\nenum DecodeResult {\n  Decode_EndOfSliceSegment,\n  Decode_EndOfSubstream,\n  Decode_Error\n};\n\n/* Decode CTBs until the end of sub-stream, the end-of-slice, or some error occurs.\n */\nenum DecodeResult decode_substream(thread_context* tctx,\n                                   bool block_wpp, // block on WPP dependencies\n                                   bool first_independent_substream)\n{\n  const pic_parameter_set& pps = tctx->img->get_pps();\n  const seq_parameter_set& sps = tctx->img->get_sps();\n\n  const int ctbW = sps.PicWidthInCtbsY;\n\n\n  const int startCtbY = tctx->CtbY;\n\n  //printf(\"start decoding substream at %d;%d\\n\",tctx->CtbX,tctx->CtbY);\n\n  // in WPP mode: initialize CABAC model with stored model from row above\n\n  if ((!first_independent_substream || tctx->CtbY != startCtbY) &&\n      pps.entropy_coding_sync_enabled_flag &&\n      tctx->CtbY>=1 && tctx->CtbX==0)\n    {\n      if (sps.PicWidthInCtbsY>1) {\n        if ((tctx->CtbY-1) >= tctx->imgunit->ctx_models.size()) {\n          return Decode_Error;\n        }\n\n        //printf(\"CTX wait on %d/%d\\n\",1,tctx->CtbY-1);\n\n        // we have to wait until the context model data is there\n        tctx->img->wait_for_progress(tctx->task, 1,tctx->CtbY-1,CTB_PROGRESS_PREFILTER);\n\n        // copy CABAC model from previous CTB row\n        tctx->ctx_model = tctx->imgunit->ctx_models[(tctx->CtbY-1)];\n        tctx->imgunit->ctx_models[(tctx->CtbY-1)].release(); // not used anymore\n      }\n      else {\n        tctx->img->wait_for_progress(tctx->task, 0,tctx->CtbY-1,CTB_PROGRESS_PREFILTER);\n        initialize_CABAC_models(tctx);\n      }\n    }\n\n\n  do {\n    const int ctbx = tctx->CtbX;\n    const int ctby = tctx->CtbY;\n\n    if (ctbx+ctby*ctbW >= pps.CtbAddrRStoTS.size()) {\n        return Decode_Error;\n    }\n\n    if (ctbx >= sps.PicWidthInCtbsY ||\n        ctby >= sps.PicHeightInCtbsY) {\n        return Decode_Error;\n    }\n\n    if (block_wpp && ctby>0 && ctbx < ctbW-1) {\n\n      // TODO: if we are in tiles mode and at the right border, do not wait for x+1,y-1\n\n      //printf(\"wait on %d/%d (%d)\\n\",ctbx+1,ctby-1, ctbx+1+(ctby-1)*sps->PicWidthInCtbsY);\n\n      tctx->img->wait_for_progress(tctx->task, ctbx+1,ctby-1, CTB_PROGRESS_PREFILTER);\n    }\n\n    //printf(\"%p: decode %d;%d\\n\", tctx, tctx->CtbX,tctx->CtbY);\n\n\n    // read and decode CTB\n\n    if (tctx->ctx_model.empty() == false) {\n      return Decode_Error;\n    }\n\n    read_coding_tree_unit(tctx);\n\n\n    // save CABAC-model for WPP (except in last CTB row)\n\n    if (pps.entropy_coding_sync_enabled_flag &&\n        ctbx == 1 &&\n        ctby < sps.PicHeightInCtbsY-1)\n      {\n        // no storage for context table has been allocated\n        if (tctx->imgunit->ctx_models.size() <= ctby) {\n          return Decode_Error;\n        }\n\n        tctx->imgunit->ctx_models[ctby] = tctx->ctx_model;\n        tctx->imgunit->ctx_models[ctby].decouple(); // store an independent copy\n      }\n\n\n    // end of slice segment ?\n\n    int end_of_slice_segment_flag = decode_CABAC_term_bit(&tctx->cabac_decoder);\n    //printf(\"end-of-slice flag: %d\\n\", end_of_slice_segment_flag);\n\n    if (end_of_slice_segment_flag) {\n      // at the end of the slice segment, we store the CABAC model if we need it\n      // because a dependent slice may follow\n\n      if (pps.dependent_slice_segments_enabled_flag) {\n        tctx->shdr->ctx_model_storage = tctx->ctx_model;\n        tctx->shdr->ctx_model_storage.decouple(); // store an independent copy\n\n        tctx->shdr->ctx_model_storage_defined = true;\n      }\n    }\n\n    tctx->img->ctb_progress[ctbx+ctby*ctbW].set_progress(CTB_PROGRESS_PREFILTER);\n\n    //printf(\"%p: decoded %d|%d\\n\",tctx, ctby,ctbx);\n\n\n    logtrace(LogSlice,\"read CTB %d -> end=%d\\n\", tctx->CtbAddrInRS, end_of_slice_segment_flag);\n    //printf(\"read CTB %d -> end=%d\\n\", tctx->CtbAddrInRS, end_of_slice_segment_flag);\n\n    const int lastCtbY = tctx->CtbY;\n\n    bool endOfPicture = advanceCtbAddr(tctx); // true if we read past the end of the image\n\n    if (endOfPicture &&\n        end_of_slice_segment_flag == false)\n      {\n        tctx->decctx->add_warning(DE265_WARNING_CTB_OUTSIDE_IMAGE_AREA, false);\n        tctx->img->integrity = INTEGRITY_DECODING_ERRORS;\n        return Decode_Error;\n      }\n\n\n    if (end_of_slice_segment_flag) {\n      /* corrupted inputs may send the end_of_slice_segment_flag even if not all\n         CTBs in a row have been coded. Hence, we mark all of them as finished.\n       */\n\n      /*\n      for (int x = ctbx+1 ; x<sps->PicWidthInCtbsY; x++) {\n        printf(\"mark skipped %d;%d\\n\",ctbx,ctby);\n        tctx->img->ctb_progress[ctbx+ctby*ctbW].set_progress(CTB_PROGRESS_PREFILTER);\n      }\n      */\n\n      return Decode_EndOfSliceSegment;\n    }\n\n\n    if (!end_of_slice_segment_flag) {\n      bool end_of_sub_stream = false;\n      end_of_sub_stream |= (pps.tiles_enabled_flag &&\n                            pps.TileId[tctx->CtbAddrInTS] != pps.TileId[tctx->CtbAddrInTS-1]);\n      end_of_sub_stream |= (pps.entropy_coding_sync_enabled_flag &&\n                            lastCtbY != tctx->CtbY);\n\n      if (end_of_sub_stream) {\n        int end_of_sub_stream_one_bit = decode_CABAC_term_bit(&tctx->cabac_decoder);\n        if (!end_of_sub_stream_one_bit) {\n          tctx->decctx->add_warning(DE265_WARNING_EOSS_BIT_NOT_SET, false);\n          tctx->img->integrity = INTEGRITY_DECODING_ERRORS;\n          return Decode_Error;\n        }\n\n        init_CABAC_decoder_2(&tctx->cabac_decoder); // byte alignment\n        return Decode_EndOfSubstream;\n      }\n    }\n\n  } while (true);\n}\n\n\n\nbool initialize_CABAC_at_slice_segment_start(thread_context* tctx)\n{\n  de265_image* img = tctx->img;\n  const pic_parameter_set& pps = img->get_pps();\n  const seq_parameter_set& sps = img->get_sps();\n  slice_segment_header* shdr = tctx->shdr;\n\n  if (shdr->dependent_slice_segment_flag) {\n    int prevCtb = pps.CtbAddrTStoRS[ pps.CtbAddrRStoTS[shdr->slice_segment_address] -1 ];\n\n    int sliceIdx = img->get_SliceHeaderIndex_atIndex(prevCtb);\n    if (sliceIdx >= img->slices.size()) {\n      return false;\n    }\n    slice_segment_header* prevCtbHdr = img->slices[ sliceIdx ];\n\n    if (pps.is_tile_start_CTB(shdr->slice_segment_address % sps.PicWidthInCtbsY,\n                              shdr->slice_segment_address / sps.PicWidthInCtbsY\n                              )) {\n      initialize_CABAC_models(tctx);\n    }\n    else {\n      // wait for previous slice to finish decoding\n\n      //printf(\"wait for previous slice to finish decoding\\n\");\n\n\n      slice_unit* prevSliceSegment = tctx->imgunit->get_prev_slice_segment(tctx->sliceunit);\n      //assert(prevSliceSegment);\n      if (prevSliceSegment==NULL) {\n        return false;\n      }\n\n      prevSliceSegment->finished_threads.wait_for_progress(prevSliceSegment->nThreads);\n\n\n      /*\n      printf(\"wait for %d,%d (init)\\n\",\n             prevCtb / sps->PicWidthInCtbsY,\n             prevCtb % sps->PicWidthInCtbsY);\n      tctx->img->wait_for_progress(tctx->task, prevCtb, CTB_PROGRESS_PREFILTER);\n      */\n\n      if (!prevCtbHdr->ctx_model_storage_defined) {\n        return false;\n      }\n\n      tctx->ctx_model = prevCtbHdr->ctx_model_storage;\n      prevCtbHdr->ctx_model_storage.release();\n    }\n  }\n  else {\n    initialize_CABAC_models(tctx);\n  }\n\n  return true;\n}\n\n\nstd::string thread_task_ctb_row::name() const {\n  char buf[100];\n  sprintf(buf,\"ctb-row-%d\",debug_startCtbRow);\n  return buf;\n}\n\n\nstd::string thread_task_slice_segment::name() const {\n  char buf[100];\n  sprintf(buf,\"slice-segment-%d;%d\",debug_startCtbX,debug_startCtbY);\n  return buf;\n}\n\n\nvoid thread_task_slice_segment::work()\n{\n  thread_task_slice_segment* data = this;\n  thread_context* tctx = data->tctx;\n  de265_image* img = tctx->img;\n\n  state = Running;\n  img->thread_run(this);\n\n  setCtbAddrFromTS(tctx);\n\n  //printf(\"%p: A start decoding at %d/%d\\n\", tctx, tctx->CtbX,tctx->CtbY);\n\n  if (data->firstSliceSubstream) {\n    bool success = initialize_CABAC_at_slice_segment_start(tctx);\n    if (!success) {\n      state = Finished;\n      tctx->sliceunit->finished_threads.increase_progress(1);\n      img->thread_finishes(this);\n      return;\n    }\n  }\n  else {\n    initialize_CABAC_models(tctx);\n  }\n\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n\n  /*enum DecodeResult result =*/ decode_substream(tctx, false, data->firstSliceSubstream);\n\n  state = Finished;\n  tctx->sliceunit->finished_threads.increase_progress(1);\n  img->thread_finishes(this);\n\n  return; // DE265_OK;\n}\n\n\nvoid thread_task_ctb_row::work()\n{\n  thread_task_ctb_row* data = this;\n  thread_context* tctx = data->tctx;\n  de265_image* img = tctx->img;\n\n  const seq_parameter_set& sps = img->get_sps();\n  int ctbW = sps.PicWidthInCtbsY;\n\n  state = Running;\n  img->thread_run(this);\n\n  setCtbAddrFromTS(tctx);\n\n  int ctby = tctx->CtbAddrInRS / ctbW;\n  int myCtbRow = ctby;\n\n  //printf(\"start CTB-row decoding at row %d\\n\", ctby);\n\n  if (data->firstSliceSubstream) {\n    bool success = initialize_CABAC_at_slice_segment_start(tctx);\n    if (!success) {\n      // could not decode this row, mark whole row as finished\n      for (int x=0;x<ctbW;x++) {\n        img->ctb_progress[myCtbRow*ctbW + x].set_progress(CTB_PROGRESS_PREFILTER);\n      }\n\n      state = Finished;\n      tctx->sliceunit->finished_threads.increase_progress(1);\n      img->thread_finishes(this);\n      return;\n    }\n    //initialize_CABAC(tctx);\n  }\n\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n\n  bool firstIndependentSubstream =\n    data->firstSliceSubstream && !tctx->shdr->dependent_slice_segment_flag;\n\n  /*enum DecodeResult result =*/\n  decode_substream(tctx, true, firstIndependentSubstream);\n\n  // mark progress on remaining CTBs in row (in case of decoder error and early termination)\n\n  // TODO: what about slices that end properly in the middle of a CTB row?\n\n  if (tctx->CtbY == myCtbRow) {\n    int lastCtbX = sps.PicWidthInCtbsY; // assume no tiles when WPP is on\n    for (int x = tctx->CtbX; x<lastCtbX ; x++) {\n\n      if (x        < sps.PicWidthInCtbsY &&\n          myCtbRow < sps.PicHeightInCtbsY) {\n        img->ctb_progress[myCtbRow*ctbW + x].set_progress(CTB_PROGRESS_PREFILTER);\n      }\n    }\n  }\n\n  state = Finished;\n  tctx->sliceunit->finished_threads.increase_progress(1);\n  img->thread_finishes(this);\n}\n\n\nde265_error read_slice_segment_data(thread_context* tctx)\n{\n  setCtbAddrFromTS(tctx);\n\n  de265_image* img = tctx->img;\n  const pic_parameter_set& pps = img->get_pps();\n  const seq_parameter_set& sps = img->get_sps();\n  slice_segment_header* shdr = tctx->shdr;\n\n  bool success = initialize_CABAC_at_slice_segment_start(tctx);\n  if (!success) {\n    return DE265_ERROR_UNSPECIFIED_DECODING_ERROR;\n  }\n\n  init_CABAC_decoder_2(&tctx->cabac_decoder);\n\n  //printf(\"-----\\n\");\n\n  bool first_slice_substream = !shdr->dependent_slice_segment_flag;\n\n  int substream=0;\n\n  enum DecodeResult result;\n  do {\n    int ctby = tctx->CtbY;\n\n\n    // check whether entry_points[] are correct in the bitstream\n\n    if (substream>0) {\n      if (substream-1 >= tctx->shdr->entry_point_offset.size() ||\n          tctx->cabac_decoder.bitstream_curr - tctx->cabac_decoder.bitstream_start -2 /* -2 because of CABAC init */\n          != tctx->shdr->entry_point_offset[substream-1]) {\n        tctx->decctx->add_warning(DE265_WARNING_INCORRECT_ENTRY_POINT_OFFSET, true);\n      }\n    }\n\n    substream++;\n\n\n    result = decode_substream(tctx, false, first_slice_substream);\n\n\n    if (result == Decode_EndOfSliceSegment ||\n        result == Decode_Error) {\n      break;\n    }\n\n    first_slice_substream = false;\n\n    if (pps.tiles_enabled_flag) {\n      initialize_CABAC_models(tctx);\n    }\n  } while (true);\n\n  return DE265_OK;\n}\n\n\n/* TODO:\n   When a task wants to block, but is the first in the list of pending tasks,\n   do some error concealment instead of blocking, since it will never be deblocked.\n   This will only happen in the case of input error.\n */\n"], "filenames": ["libde265/slice.cc"], "buggy_code_start_loc": [1279], "buggy_code_end_loc": [1288], "fixing_code_start_loc": [1280], "fixing_code_end_loc": [1296], "type": "CWE-120", "message": "Buffer Overflow vulnerability in strukturag libde265 v1.10.12 allows a local attacker to cause a denial of service via the slice_segment_header function in the slice.cc component.", "other": {"cve": {"id": "CVE-2023-47471", "sourceIdentifier": "cve@mitre.org", "published": "2023-11-16T04:15:06.857", "lastModified": "2023-11-30T19:15:13.313", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer Overflow vulnerability in strukturag libde265 v1.10.12 allows a local attacker to cause a denial of service via the slice_segment_header function in the slice.cc component."}, {"lang": "es", "value": "Vulnerabilidad de desbordamiento del b\u00fafer en strukturag libde265 v1.10.12 permite que un atacante local provoque una denegaci\u00f3n de servicio a trav\u00e9s de la funci\u00f3n slice_segment_header en el componente slice.cc."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-120"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:struktur:libde265:1.0.12:*:*:*:*:*:*:*", "matchCriteriaId": "A736D1CB-9F33-4561-B10C-4074DF6C02F9"}]}]}], "references": [{"url": "https://github.com/strukturag/libde265/commit/e36b4a1b0bafa53df47514c419d5be3e8916ebc7", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/strukturag/libde265/issues/426", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/11/msg00032.html", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/strukturag/libde265/commit/e36b4a1b0bafa53df47514c419d5be3e8916ebc7"}}