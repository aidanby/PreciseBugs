{"buggy_code": ["<?php\nheader('Content-Type: application/json');\n\n$files_utils = new \\MicroweberPackages\\Utils\\System\\Files();\n$dangerous = $files_utils->get_dangerous_files_extentions();\n\n\nif (!mw()->user_manager->session_id() or (mw()->user_manager->session_all() == false)) {\n    // //session_start();\n}\n\n\n\n$validate_token = false;\nif (!isset($_SERVER['HTTP_REFERER'])) {\n    header(\"HTTP/1.1 401 Unauthorized\");\n\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":97, \"message\": \"You are not allowed to upload\"}}');\n} elseif (!stristr($_SERVER['HTTP_REFERER'], site_url())) {\n    //    if (!is_logged()){\n//        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":98, \"message\": \"You cannot upload from remote domains\"}}');\n//    }\n}\n\nif (!is_admin()) {\n    $validate_token = mw()->user_manager->csrf_validate($_GET);\n    if ($validate_token == false) {\n        header(\"HTTP/1.1 401 Unauthorized\");\n        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":98, \"message\": \"You are not allowed to upload\"}}');\n    }\n\n    $is_ajax = mw()->url_manager->is_ajax();\n    if (!$is_ajax) {\n        header(\"HTTP/1.1 401 Unauthorized\");\n        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":99, \"message\": \"You are not allowed to upload\"}}');\n    }\n}\n\n$host = (parse_url(site_url()));\n\n//$host_dir = false;\n$host_dir = 'default';\n\n\nif(defined('MW_IS_MULTISITE') and MW_IS_MULTISITE){\n    if (isset($host['host'])) {\n        $host_dir = $host['host'];\n        $host_dir = str_ireplace('www.', '', $host_dir);\n        $host_dir = str_ireplace('.', '-', $host_dir);\n    }\n}\n\n\n$fileName_ext = isset($_REQUEST['name']) ? $_REQUEST['name'] : '';\n\n$is_ext = get_file_extension($fileName_ext);\n$is_ext = strtolower($is_ext);\n\n$is_dangerous_file = $files_utils->is_dangerous_file($fileName_ext);\n\nif ($is_dangerous_file) {\n    header(\"HTTP/1.1 401 Unauthorized\");\n\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":100, \"message\": \"You cannot upload scripts or executable files\"}}');\n}\n\n$allowed_to_upload = false;\n\nif (is_admin() != false) {\n    $allowed_to_upload = true;\n} else {\n    $uid = user_id();\n    if ($uid != 0) {\n        $user = mw()->user_manager->get_by_id($uid);\n        if (!empty($user) and isset($user['is_active']) and $user['is_active'] == 1) {\n            $are_allowed = 'img';\n            $_REQUEST['path'] = 'media/' . $host_dir . DS . 'user_uploads/user/' . $user['id'] . DS;\n            if (isset($_REQUEST['autopath']) and $_REQUEST['autopath'] == 'user_hash') {\n                $up_path = md5($user['id'] . $user['created_at']);\n                $_REQUEST['path'] = 'media/' . $host_dir . DS . 'user_uploads/user_hash/' . DS . $up_path . DS;\n            }\n            $allowed_to_upload = true;\n        }\n    } else {\n        $_REQUEST['path'] = 'media/' . $host_dir . DS . 'user_uploads/anonymous/';\n        $allowed_to_upload = true;\n    }\n\n\n}\n\n\nif ($allowed_to_upload == false) {\n    if (isset($_REQUEST['rel_type']) and isset($_REQUEST['custom_field_id']) and trim($_REQUEST['rel_type']) != '' and trim($_REQUEST['rel_type']) != 'false') {\n        $cfid = mw()->fields_manager->getById(intval($_REQUEST['custom_field_id']));\n        if ($cfid == false) {\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 90, \"message\": \"Custom field is not found\"}}');\n        } else {\n            $rel_error = false;\n            if (!isset($_REQUEST['rel_id'])) {\n                $rel_error = true;\n            }\n            if (!isset($cfid['rel_id'])) {\n                $rel_error = true;\n            }\n\n            if (($_REQUEST['rel_id']) != $cfid['rel_id']) {\n                $rel_error = true;\n            }\n\n\n\n\n\n            if ($rel_error) {\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 91, \"message\": \"You are not allowed to upload\"}}');\n            }\n        }\n\n        if ($cfid != false and isset($cfid['custom_field_type'])) {\n            if ($cfid['custom_field_type'] != 'upload') {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Custom field is not file upload type\"}}');\n            }\n            if ($cfid != false and (!isset($cfid['options']) or !isset($cfid['options']['file_types']))) {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"File types is not set.\"}}');\n            }\n            if ($cfid != false and isset($cfid['file_types']) and empty($cfid['file_types'])) {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 103, \"message\": \"File types cannot by empty.\"}}');\n            }\n\n            if ($cfid != false and isset($cfid['options']) and isset($cfid['options']['file_types'])) {\n                $alloled_ft = array_values(($cfid['options']['file_types']));\n                if (empty($alloled_ft)) {\n                    header(\"HTTP/1.1 401 Unauthorized\");\n\n                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 104, \"message\": \"File types cannot by empty.\"}}');\n                } else {\n                    $are_allowed = '';\n                    $fileName_ext = isset($_REQUEST['name']) ? $_REQUEST['name'] : '';\n                    foreach ($alloled_ft as $allowed_file_type_item) {\n                        if (trim($allowed_file_type_item) != '' and $fileName_ext != '') {\n                            $is_ext = get_file_extension($fileName_ext);\n                            $is_ext = strtolower($is_ext);\n\n                            switch ($is_ext) {\n                                case 'php':\n                                case 'php12':\n                                case 'php11':\n                                case 'php10':\n                                case 'php9':\n                                case 'php8':\n                                case 'php7':\n                                case 'php5':\n                                case 'php4':\n                                case 'php3':\n                                case 'ptml':\n                                case 'html':\n                                case 'xhtml':\n                                case 'phtml':\n                                case 'shtml':\n                                case 'htm':\n                                case 'pl':\n                                case 'cgi':\n                                case 'rb':\n                                case 'py':\n                                case 'asp':\n                                case 'htaccess':\n                                case 'exe':\n                                case 'msi':\n                                case 'sh':\n                                case 'bat':\n                                case 'vbs':\n                                    $are_allowed = false;\n                                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":105, \"message\": \"You cannot upload scripts or executables\"}}');\n\n                                    break;\n\n\n                            }\n\n                            $are_allowed = $files_utils->get_allowed_files_extensions_for_upload($allowed_file_type_item);\n\n                            $pass_type_check = false;\n                            if ($are_allowed != false) {\n                                $are_allowed_a = explode(',', $are_allowed);\n                                if (!empty($are_allowed_a)) {\n                                    foreach ($are_allowed_a as $are_allowed_a_item) {\n                                        $are_allowed_a_item = strtolower(trim($are_allowed_a_item));\n                                        $is_ext = strtolower(trim($is_ext));\n\n                                        if ($are_allowed_a_item == '*') {\n                                            $pass_type_check = 1;\n                                        }\n\n                                        if ($are_allowed_a_item != '' and $are_allowed_a_item == $is_ext) {\n                                            $pass_type_check = 1;\n                                        }\n                                    }\n                                }\n                            }\n                            if ($pass_type_check == false) {\n                                header(\"HTTP/1.1 401 Unauthorized\");\n\n                                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":106, \"message\": \"You can only upload ' . $are_allowed . ' files.\"}}');\n                            } else {\n                                if (!isset($_REQUEST['captcha'])) {\n                                    if (!$validate_token) {\n                                        header(\"HTTP/1.1 401 Unauthorized\");\n\n                                        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":107, \"message\": \"Please enter the captcha answer!\"}}');\n                                    }\n                                } else {\n                                    $cap = mw()->user_manager->session_get('captcha');\n                                    if ($cap == false) {\n                                        header(\"HTTP/1.1 401 Unauthorized\");\n\n                                        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":108, \"message\": \"You must load a captcha first!\"}}');\n                                    }\n                                    $validate_captcha = $this->app->captcha_manager->validate($_REQUEST['captcha']);\n                                    if (!$validate_captcha) {\n                                        header(\"HTTP/1.1 401 Unauthorized\");\n\n                                        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":109, \"message\": \"Invalid captcha answer! \"}}');\n                                    } else {\n                                        if (!isset($_REQUEST['path'])) {\n                                            $_REQUEST['path'] = 'media/' . $host_dir . '/user_uploads' . DS . $_REQUEST['rel_type'] . DS;\n                                        }\n                                    }\n                                }\n\n                                //die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":98, \"message\": PECATA - Not finished yet.\"}}');\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        header(\"HTTP/1.1 401 Unauthorized\");\n\n        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 110, \"message\": \"Only admin can upload.\"}, \"id\" : \"id\"}');\n    }\n}\n\n\nif(!is_admin()){\n\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 111, \"message\": \"Only admin can upload.\"}, \"id\" : \"id\"}');\n\n    return response(array(\n        'error' => _e('Please enter captcha answer!', true),\n        'captcha_error' => true,\n        'form_data_required' => 'captcha',\n        'form_data_required_params' => array('captcha_parent_for_id' => $_REQUEST['rel_id']),\n        'form_data_module' => 'captcha'\n    ));\n}\n\n\n// Settings\n//$target_path = media_base_path() . DS;\n//$target_path = media_base_path() . DS . $host_dir . DS . 'uploaded' . DS;\n$target_path = media_uploads_path();\n$target_path = normalize_path($target_path, 0);\n\n$path_restirct = userfiles_path(); // the path the script should access\nif (isset($_REQUEST['path']) and trim($_REQUEST['path']) != '' and trim($_REQUEST['path']) != 'false') {\n    $path = urldecode($_REQUEST['path']);\n\n    $path = html_entity_decode($path);\n    $path = htmlspecialchars_decode($path, ENT_NOQUOTES);\n\n    //$path = urldecode($path);\n    $path = str_replace('%2F', '/', $path);\n    //$path = str_replace('%25252F','/',$path);\n\n    $path = normalize_path($path, 0);\n\n    $path = str_replace('..', '', $path);\n    $path = str_replace($path_restirct, '', $path);\n\n    // $target_path = userfiles_path() . DS . $path;\n    $target_path = media_uploads_path() . DS . $path;\n    $target_path = normalize_path($target_path, 1);\n}\n\n$targetDir = $target_path;\nif (!is_dir($targetDir)) {\n    mkdir_recursive($targetDir);\n}\n//$targetDir = 'uploads';\n\n$cleanupTargetDir = true;\n// Remove old files\n$maxFileAge = 5 * 3600;\n// Temp file age in seconds\n// 5 minutes execution time\n@set_time_limit(5 * 60);\n\n// Uncomment this one to fake upload time\n// usleep(5000);\n// Get parameters\n$chunk = isset($_REQUEST['chunk']) ? intval($_REQUEST['chunk']) : 0;\n$chunks = isset($_REQUEST['chunks']) ? intval($_REQUEST['chunks']) : 0;\n$fileName = isset($_REQUEST['name']) ? $_REQUEST['name'] : '';\n\n// Clean the fileName for security reasons\n$fileNameExtension = get_file_extension($fileName);\n$fileName = \\MicroweberPackages\\Helper\\URLify::filter($fileName);\n//$fileName = url_title($fileName);\n//$fileName = preg_replace('/[\\p{P}\\p{Zs}\\w\\._]+/u', \"\", $fileName);\n// $fileName = preg_replace('/[^\\w\\._]+/', '_', $fileName);\n$fileName = preg_replace('/\\s+\\d+%|\\)/', '', $fileName);\n$fileName = preg_replace(\"/[\\/\\&%#\\$]/\", \"_\", $fileName);\n$fileName = preg_replace(\"/[\\\"\\']/\", \" \", $fileName);\n$fileName = str_replace(array('(', ')', \"'\", \"!\", \"`\", \"*\", \"#\"), '_', $fileName);\n$fileName = str_replace(' ', '_', $fileName);\n$fileName = str_replace('..', '.', $fileName);\n$fileName = strtolower($fileName);\n$fileName = mw()->url_manager->clean_url_wrappers($fileName);\n$fileName = substr($fileName, 0, -(strlen($fileNameExtension)));\n$fileName = $fileName . '.' . $fileNameExtension;\n\n\n$fileName_uniq = date('ymdhis') . uniqid() . $fileName;\n// Make sure the fileName is unique but only if chunking is disabled\nif ($chunks < 2 && file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {\n    $ext = strrpos($fileName, '.');\n    $fileName_a = substr($fileName, 0, $ext);\n    $fileName_b = substr($fileName, $ext);\n\n    $count = 1;\n    while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b)) {\n        ++$count;\n    }\n\n    $fileName = $fileName_a . '_' . $count . $fileName_b;\n}\n\n$filePath = $targetDir . DIRECTORY_SEPARATOR . $fileName;\n$filePath_uniq = $targetDir . DIRECTORY_SEPARATOR . $fileName_uniq;\n\n// Create target dir\nif (!is_dir($targetDir)) {\n    @mkdir_recursive($targetDir);\n}\n\n$has_index = $targetDir . DIRECTORY_SEPARATOR . 'index.html';\n\nif (!is_file($has_index)) {\n    @touch($has_index);\n}\n\n// Remove old temp files\nif ($cleanupTargetDir && is_dir($targetDir) && ($dir = opendir($targetDir))) {\n    while (($file = readdir($dir)) !== false) {\n        $tmpfilePath = $targetDir . DIRECTORY_SEPARATOR . $file;\n\n        // Remove temp file if it is older than the max age and is not the current file\n        if (preg_match('/\\.part$/', $file) && (filemtime($tmpfilePath) < time() - $maxFileAge) && ($tmpfilePath != \"{$filePath}.part\")) {\n            @unlink($tmpfilePath);\n        }\n    }\n\n    closedir($dir);\n} else {\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 100, \"message\": \"Failed to open temp directory.\"}, \"id\" : \"id\"}');\n}\n\n\nif (isset($_SERVER['CONTENT_LENGTH']) and isset($_FILES['file'])) {\n    $filename_log = mw()->url_manager->slug($fileName);\n    $check = mw()->log_manager->get('one=true&no_cache=true&is_system=y&created_at=[mt]30 min ago&field=upload_size&rel=uploader&rel_id=' . $filename_log . '&user_ip=' . user_ip());\n    $upl_size_log = $_SERVER['CONTENT_LENGTH'];\n    if (is_array($check) and isset($check['id'])) {\n        $upl_size_log = intval($upl_size_log) + intval($check['value']);\n        mw()->log_manager->save('no_cache=true&is_system=y&field=upload_size&rel=uploader&rel_id=' . $filename_log . '&value=' . $upl_size_log . '&user_ip=' . user_ip() . '&id=' . $check['id']);\n    } else {\n        mw()->log_manager->save('no_cache=true&is_system=y&field=upload_size&rel=uploader&rel_id=' . $filename_log . '&value=' . $upl_size_log . '&user_ip=' . user_ip());\n    }\n}\n\n// Look for the content type header\nif (isset($_SERVER['HTTP_CONTENT_TYPE'])) {\n    $contentType = $_SERVER['HTTP_CONTENT_TYPE'];\n}\n\nif (isset($_SERVER['CONTENT_TYPE'])) {\n    $contentType = $_SERVER['CONTENT_TYPE'];\n}\n\n// Handle non multipart uploads older WebKit versions didn't support multipart in HTML5\n$is_image = false;\n\n$engine = 'plupload';\n\n\nif ($engine == 'plupload') {\n\n\n    if (isset($contentType)) {\n        if (strpos($contentType, 'multipart') !== false) {\n            if ($_FILES['file']['error'] === UPLOAD_ERR_OK) {\n                //uploading successfully done\n            } else {\n                throw new UploadException($_FILES['file']['error']);\n            }\n        }\n\n        if (isset($_FILES['file']['tmp_name']) && is_uploaded_file($_FILES['file']['tmp_name'])) {\n\n            // Open temp file\n            $out = fopen(\"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab');\n            if ($out) {\n                // Read binary input stream and append it to temp file\n                $in = fopen($_FILES['file']['tmp_name'], 'rb');\n\n                if ($in) {\n                    while ($buff = fread($in, 4096)) {\n                        fwrite($out, $buff);\n                    }\n                } else {\n                    header(\"HTTP/1.1 401 Unauthorized\");\n\n                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\n                }\n                fclose($in);\n                fclose($out);\n\n                @unlink($_FILES['file']['tmp_name']);\n            } else {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\n            }\n        } else {\n            header(\"HTTP/1.1 401 Unauthorized\");\n\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 103, \"message\": \"Failed to move uploaded file.\"}, \"id\" : \"id\"}');\n        }\n    } else {\n        // Open temp file\n        $out = fopen(\"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab');\n        if ($out) {\n            // Read binary input stream and append it to temp file\n            $in = fopen('php://input', 'rb');\n\n            if ($in) {\n                while ($buff = fread($in, 4096)) {\n                    fwrite($out, $buff);\n                }\n            } else {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\n            }\n\n            fclose($in);\n            fclose($out);\n        } else {\n            header(\"HTTP/1.1 401 Unauthorized\");\n\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\n        }\n    }\n\n} else {\n\n\n}\n\n\n$rerturn = array();\n\n\n// Check if file has been uploaded\nif (!$chunks || $chunk == $chunks - 1) {\n    // Strip the temp .part suffix off\n    $newfile = $filePath;\n    if (is_file($newfile)) {\n        $newfile = $filePath_uniq;\n    }\n\n\n    rename(\"{$filePath}.part\", $newfile);\n    $filePath = $newfile;\n\n    $automatic_image_resize_on_upload = get_option('automatic_image_resize_on_upload', 'website') == 'y';\n    $automatic_image_resize_on_upload_disabled = get_option('automatic_image_resize_on_upload', 'website') == 'd';\n\n    if (is_file($filePath) and !$chunks || $chunk == $chunks - 1) {\n        $ext = get_file_extension($filePath);\n\n        if (function_exists('finfo_open') and function_exists('finfo_file')) {\n            $finfo = finfo_open(FILEINFO_MIME_TYPE); // return mime type ala mimetype extension\n            $mime = @finfo_file($finfo, $filePath);\n            if ($mime) {\n                $upl_mime_ext = explode('/', $mime);\n                $upl_mime_ext = end($upl_mime_ext);\n                $upl_mime_ext = explode('-', $upl_mime_ext);\n                $upl_mime_ext = end($upl_mime_ext);\n                $upl_mime_ext = strtolower($upl_mime_ext);\n\n                if (in_array($upl_mime_ext, $dangerous)) {\n                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Cannot upload mime type ' . $upl_mime_ext . '\"}, \"id\" : \"id\"}');\n                }\n            }\n            finfo_close($finfo);\n        }\n\n        if ($ext == 'gif' || $ext == 'jpg' || $ext == 'jpeg' || $ext === 'jpe' || $ext == 'png'|| $ext == 'svg') {\n\n            $valid = false;\n            if ($ext === 'jpg' || $ext === 'jpeg' || $ext === 'jpe') {\n\n                // This will clear exif data - security issue\n                $imgCreatedFromJpeg = @imagecreatefromjpeg($filePath);\n                if ($imgCreatedFromJpeg) {\n                    imagejpeg($imgCreatedFromJpeg, $filePath);  // this will create fresh new image without exif sensitive data\n                    $valid = true;\n                }\n            } else if ($ext === 'png') {\n\n                $imgCreatedFromPng = @imagecreatefrompng($filePath);\n                if ($imgCreatedFromPng) {\n                    imagepng($imgCreatedFromPng, $filePath);  // this will create fresh new image without exif sensitive data\n                    $valid = true;\n                }\n\n            } else if ($ext === 'gif') {\n\n                $imgCreatedFromGif = @imagecreatefromgif($filePath);\n                if ($imgCreatedFromGif) {\n                    imagegif($imgCreatedFromGif, $filePath); // this will create fresh new image without exif sensitive data\n                    $valid = true;\n                }\n\n            } else if ($ext === 'svg') {\n\n                if (is_file($filePath)) {\n                    $sanitizer = new \\enshrined\\svgSanitize\\Sanitizer();\n                    // Load the dirty svg\n                    $dirtySVG = file_get_contents($filePath);\n                     // Pass it to the sanitizer and get it back clean\n                    $cleanSVG = $sanitizer->sanitize($dirtySVG);\n                    file_put_contents($filePath, $cleanSVG);\n\n                }\n               $valid = true;\n\n            } else {\n                $valid = false;\n            }\n\n            if (!$valid) {\n                @unlink($filePath);\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 107, \"message\": \"File is not an image\"}, \"id\" : \"id\"}');\n            }\n        }\n\n    }\n\n\n    if ($is_ext == 'gif' || $is_ext == 'jpg' || $is_ext == 'jpeg' || $is_ext == 'png') {\n        try {\n\n            $size = getimagesize($filePath);\n            $is_image = true;\n            $filesize = filesize($filePath);\n            $rerturn['file_size'] = $filesize;\n            $rerturn['file_size_human'] = mw()->format->human_filesize($filesize);\n            $rerturn['image_size'] = $size;\n            // $auto_resize_treshold = 10000000; // 10MiB\n            $auto_resize_treshold = 2000000; // 2MiB\n\n            if ($is_ext == 'jpg' || $is_ext == 'jpeg' || $is_ext == 'png') {\n                $rerturn['automatic_image_resize_is_enabled'] = $automatic_image_resize_on_upload;\n                if (!$automatic_image_resize_on_upload and $filesize > $auto_resize_treshold) {\n                    // if image is big, ask to enable resizing\n                    $rerturn['ask_user_to_enable_auto_resizing'] = 1;\n                    $rerturn['ask_user_to_enable_auto_resizing_filesize'] = $filesize;\n\n                }\n                if (!$automatic_image_resize_on_upload_disabled and $automatic_image_resize_on_upload and $filesize > $auto_resize_treshold) {\n                    $maxDim = 1980;\n                    //@ini_set('memory_limit', '256M');\n\n                    list($width, $height, $type, $attr) = $size;\n                    if ($width > $maxDim || $height > $maxDim) {\n//                        $d1 = dirname($filePath);\n                        $d2 = basename($filePath);\n//                        $target_filename = $d1 . DS . 'auto_resized_' . $d2;\n                        $target_filename = $filePath;\n                        $fn = $filePath;\n                        $ratio = $size[0] / $size[1]; // width/height\n                        if ($ratio > 1) {\n                            $width = $maxDim;\n                            $height = $maxDim / $ratio;\n                        } else {\n                            $width = $maxDim * $ratio;\n                            $height = $maxDim;\n                        }\n                        $src = imagecreatefromstring(file_get_contents($fn));\n                        $dst = imagecreatetruecolor($width, $height);\n\n                        if ($is_ext == 'png') {\n                            // save transparency in alpha channel\n                            imagealphablending($dst, false);\n                            imagesavealpha($dst, true);\n\n                        }\n                        imagecopyresampled($dst, $src, 0, 0, 0, 0, $width, $height, $size[0], $size[1]);\n                        imagedestroy($src);\n\n                        if ($is_ext == 'png') {\n                            imagepng($dst, $target_filename); // adjust format as needed\n\n                        } else if ($is_ext == 'jpg' || $is_ext == 'jpeg') {\n                            imagejpeg($dst, $target_filename); // adjust format as needed\n                        }\n\n                        $rerturn['image_was_auto_resized'] = 1;\n                        $rerturn['image_was_auto_resized_msg'] = \"Image was automatically resized because it was \" . $rerturn['file_size_human'];\n\n                        imagedestroy($dst);\n                    }\n                }\n            }\n\n\n        } catch (Exception $e) {\n            @unlink($filePath);\n\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 107, \"message\": \"File is not an image\"}, \"id\" : \"id\"}');\n\n        }\n    }\n\n\n    mw()->log_manager->delete('is_system=y&rel=uploader&created_at=[lt]30 min ago');\n    mw()->log_manager->delete('is_system=y&rel=uploader&session_id=' . mw()->user_manager->session_id());\n}\n$f_name = explode(DS, $filePath);\n$f_name = end($f_name);\n\n$filePath = mw()->url_manager->link_to_file($filePath);\n\n$rerturn['src'] = $filePath;\n$rerturn['name'] = $f_name;\n\n\nif (isset($upl_size_log) and $upl_size_log > 0) {\n    $rerturn['bytes_uploaded'] = $upl_size_log;\n}\n//$rerturn['ORIG_REQUEST'] = $_GET;\n\n\n/*\n * upload.php\n *\n * Copyright 2009, Moxiecode Systems AB\n * Released under GPL License.\n *\n * License: http://www.plupload.com/license\n * Contributing: http://www.plupload.com/contributing\n */\n// HTTP headers for no cache etc\nheader('Expires: Mon, 26 Jul 1997 05:00:00 GMT');\nheader('Last-Modified: ' . gmdate('D, d M Y H:i:s') . ' GMT');\nheader('Cache-Control: no-store, no-cache, must-revalidate');\nheader('Cache-Control: post-check=0, pre-check=0', false);\nheader('Pragma: no-cache');\n\n\necho json_encode($rerturn);\nif (mw()->user_manager->session_id() and !(mw()->user_manager->session_all() == false)) {\n    // @//session_write_close();\n}\n\nclass UploadException extends Exception\n{\n    public function __construct($code)\n    {\n        $message = $this->codeToMessage($code);\n        parent::__construct($message, $code);\n    }\n\n    private function codeToMessage($code)\n    {\n        switch ($code) {\n            case UPLOAD_ERR_INI_SIZE:\n                $message = 'The uploaded file exceeds the upload_max_filesize directive in php.ini';\n                break;\n            case UPLOAD_ERR_FORM_SIZE:\n                $message = 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form';\n                break;\n            case UPLOAD_ERR_PARTIAL:\n                $message = 'The uploaded file was only partially uploaded';\n                break;\n            case UPLOAD_ERR_NO_FILE:\n                $message = 'No file was uploaded';\n                break;\n            case UPLOAD_ERR_NO_TMP_DIR:\n                $message = 'Missing a temporary folder';\n                break;\n            case UPLOAD_ERR_CANT_WRITE:\n                $message = 'Failed to write file to disk';\n                break;\n            case UPLOAD_ERR_EXTENSION:\n                $message = 'File upload stopped by extension';\n                break;\n\n            default:\n                $message = 'Unknown upload error';\n                break;\n        }\n\n        return $message;\n    }\n}\n\nexit;\n\n// Return JSON-RPC response\n//die('{\"jsonrpc\" : \"2.0\", \"result\" : null, \"id\" : \"id\"}');\n", "<?php\n\nnamespace MicroweberPackages\\Utils\\System;\n\nuse RecursiveIteratorIterator;\nuse RecursiveDirectoryIterator;\nuse FilesystemIterator;\n\n$mw_static_option_groups = array();\n\nclass Files\n{\n    /**\n     * Copies directory recursively.\n     *\n     * @param $source\n     * @param $destination\n     */\n    public function copy_directory($source, $destination)\n    {\n        static $copies;\n        if (is_dir($source)) {\n            @mkdir($destination);\n            $directory = dir($source);\n            while (false !== ($readdirectory = $directory->read())) {\n                if ($readdirectory == '.' || $readdirectory == '..') {\n                    continue;\n                }\n\n                $PathDir = $source . DIRECTORY_SEPARATOR . $readdirectory;\n                if (is_dir($PathDir)) {\n                    $this->copy_directory($PathDir, $destination . DIRECTORY_SEPARATOR . $readdirectory);\n                    continue;\n                }\n                $copies[] = $destination . DIRECTORY_SEPARATOR . $readdirectory;\n                copy($PathDir, $destination . DIRECTORY_SEPARATOR . $readdirectory);\n            }\n\n            $directory->close();\n        } else {\n            $copies[] = $destination;\n            copy($source, $destination);\n        }\n\n        return $copies;\n    }\n\n    /**\n     * Returns a human readable filesize.\n     *\n     * @category Files\n     *\n     * @author      wesman20 (php.net)\n     * @author      Jonas John\n     *\n     * @version     0.3\n     *\n     * @link        http://www.jonasjohn.de/snippets/php/readable-filesize.htm\n     */\n    public function file_size_nice($size)\n    {\n        // Adapted from: http://www.php.net/manual/en/function.filesize.php\n\n        $mod = 1024;\n\n        $units = explode(' ', 'B KB MB GB TB PB');\n        for ($i = 0; $size > $mod; ++$i) {\n            $size /= $mod;\n        }\n\n        return round($size, 2) . ' ' . $units[$i];\n    }\n\n\n    public function rmdir($dirPath)\n    {\n        foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dirPath, FilesystemIterator::SKIP_DOTS), RecursiveIteratorIterator::CHILD_FIRST) as $path) {\n            $path->isDir() && !$path->isLink() ? rmdir($path->getPathname()) : unlink($path->getPathname());\n        }\n        @rmdir($dirPath);\n    }\n\n//    public function dir_tree($path = '.', $params = false)\n//    {\n//        $params = parse_params($params);\n//        $dir = $path;\n//\n//        return $this->directory_tree_build($dir, $params);\n//    }\n\n    public function md5_dir($path)\n    {\n        if (!file_exists($path)) {\n            throw new \\Exception('Directory doesn\\'t exist.');\n        }\n\n        $directoryIterator = new \\DirectoryIterator($path);\n        $items = array();\n        foreach ($directoryIterator as $fileInfo) {\n            $filePath = $fileInfo->getPathname();\n            if (!$fileInfo->isDot()) {\n                if ($fileInfo->isFile()) {\n                    $md = md5_file($filePath);\n                    $filePath = normalize_path($filePath, false);\n                    $items [$md] = $filePath;\n                } else if ($fileInfo->isDir()) {\n                    $more = $this->md5_dir($filePath);\n                    foreach ($more as $k => $v) {\n                        $items [$k] = $v;\n                    }\n                }\n            }\n        }\n        return $items;\n    }\n\n\n    /**\n     * get_files.\n     *\n     *  Get an array that represents directory and files\n     *\n     * @category    files module api\n     *\n     * @version 1.0\n     *\n     * @since 0.320\n     *\n     * @return mixed Array with files\n     *\n     * @param array $params = array()     the params\n     * @param string $params ['directory']       The directory\n     * @param string $params ['keyword']       If set it will seach the dir and subdirs\n     */\n    public function get($params)\n    {\n        if (is_admin() == false) {\n            mw_error('Must be admin');\n        }\n\n        $params = parse_params($params);\n        if (!isset($params['directory'])) {\n            mw_error('You must define directory');\n        } else {\n            $directory = $params['directory'];\n        }\n\n\n        $filter_extensions = false;\n\n        if (isset($params['extensions']) and is_string($params['extensions'])) {\n            $filter_extensions = explode(',', $params['extensions']);\n        }\n\n        $hide_files = false;\n\n        if (isset($params['hide_files']) and is_string($params['hide_files'])) {\n            $hide_files = explode(',', $params['hide_files']);\n        } else if (isset($params['hide_files']) and is_array($params['hide_files'])) {\n            $hide_files = $params['hide_files'];\n        }\n        $restrict_path = false;\n\n        if (isset($params['restrict_path']) and is_string($params['restrict_path'])) {\n            $restrict_path = $params['restrict_path'];\n        }\n\n        if ($restrict_path) {\n            if (!strstr($directory, $restrict_path)) {\n                $directory = $restrict_path . $directory;\n            }\n        }\n\n        $from_search = 0;\n        $arrayItems = array();\n        if (isset($params['search']) and strval($params['search']) != '') {\n            $from_search = 1;\n            $arrayItems_search = $this->rglob($pattern = DS . '*' . $params['search'] . '*', $flags = 0, $directory);\n        } else {\n            if (!is_dir($directory . DS)) {\n                return false;\n            }\n\n            $arrayItems_search = array();\n            $myDirectory = opendir($directory . DS);\n\n\n\n            while ($entryName = readdir($myDirectory)) {\n\n                if(!empty($hide_files) && in_array($entryName,$hide_files)){\n                    continue;\n                }\n\n                if ($entryName != '..' and $entryName != '.') {\n                    $arrayItems_search[] = $entryName;\n                }\n            }\n\n            closedir($myDirectory);\n        }\n\n        if (!empty($arrayItems_search)) {\n//\n            //usort($myarray, create_function('$a,$b', 'return filemtime($a) - filemtime($b);'));\n\n            $arrayItems_f = array();\n            $arrayItems_d = array();\n            foreach ($arrayItems_search as $file) {\n                if ($from_search == 0) {\n                    $file = $directory . DS . $file;\n                }\n                if (is_file($file)) {\n\n                    $skip = false;\n                    $df = normalize_path($file, false);\n                    $file_ext = get_file_extension($df);\n\n\n                    if ($filter_extensions and !empty($filter_extensions)) {\n                        $skip = true;\n                        foreach ($filter_extensions as $filter_extension) {\n                            if ($filter_extension == $file_ext) {\n                                $skip = false;\n                            }\n                        }\n//                        if(array_search($file_ext,$filter_extensions)){\n//                           // $skip = false;\n//                        }\n                    }\n\n                    if ($skip == false) {\n                        if (!in_array($df, $arrayItems_f)) {\n                            $arrayItems_f[] = $df;\n                        }\n                    }\n                } else {\n                    $df = normalize_path($file, 1);\n                    if (!in_array($df, $arrayItems_d)) {\n                        $arrayItems_d[] = $df;\n                    }\n                }\n            }\n\n            /*\n            // Sort  by filetime\n            $sortedFiles = array();\n            foreach($arrayItems_f as $dir) {\n            \t$sortedFiles[filemtime($dir)] = $dir;\n            }\n            ksort($sortedFiles);\n            $sortedFiles = array_reverse($sortedFiles);\n            */\n\n\n            if (isset($params['sort_by']) and strval($params['sort_by']) != '') {\n                if (!isset($params['sort_order'])) {\n                    $sort_params = explode(' ', $params['sort_by']);\n                    if (isset($sort_params[1])) {\n                        $params['sort_by'] = $sort_params[0];\n                        $params['sort_order'] = $sort_params[1];\n                    }\n                }\n\n\n                if (isset($params['sort_order']) and strval($params['sort_order']) != '') {\n                    $ord = SORT_DESC;\n                    if (strtolower($params['sort_order']) == 'asc') {\n                        $ord = SORT_ASC;\n                    }\n                    $allowed_sort = array('basename', 'filemtime', 'filesize');\n                    if (in_array($params['sort_by'], $allowed_sort)) {\n                        array_multisort(array_map($params['sort_by'], $arrayItems_f), SORT_NUMERIC, $ord, $arrayItems_f);\n                    }\n                }\n            }\n\n            $arrayItems['files'] = $arrayItems_f;\n            $arrayItems['dirs'] = $arrayItems_d;\n        }\n\n\n        return $arrayItems;\n    }\n\n    /**\n     * Recursive glob().\n     *\n     * @category Files\n     *\n     * @uses is_array()\n     *\n     * @param int|string $pattern\n     *                            the pattern passed to glob()\n     * @param int $flags\n     *                            the flags passed to glob()\n     * @param string $path\n     *                            the path to scan\n     *\n     * @return mixed\n     *               an array of files in the given path matching the pattern.\n     */\n    public function rglob($pattern = '*', $flags = 0, $path = '')\n    {\n        if (!$path && ($dir = dirname($pattern)) != '.') {\n            if ($dir == '\\\\' || $dir == '/') {\n                $dir = '';\n            }\n\n            return $this->rglob(basename($pattern), $flags, $dir . DS);\n        }\n\n        if (stristr($path, '_notes') or stristr($path, '.git') or stristr($path, '.svn')) {\n            return false;\n        }\n\n        $paths = glob($path . '*', GLOB_ONLYDIR | GLOB_NOSORT);\n        $files = glob($path . $pattern, $flags);\n\n        if (is_array($paths)) {\n            foreach ($paths as $p) {\n                $temp = array();\n                if (is_dir($p) and is_readable($p)) {\n                    $temp = $this->rglob($pattern, false, $p . DS);\n                }\n\n                if (is_array($temp) and is_array($files)) {\n                    $files = array_merge($files, $temp);\n                } elseif (is_array($temp)) {\n                    $files = $temp;\n                }\n            }\n        }\n\n        return $files;\n    }\n\n    public function dir_tree_build($dir, $params = false)\n    {\n        $params = parse_params($params);\n        $class = 'directory_tree';\n        if (isset($params['class'])) {\n            $class = $params['class'];\n        }\n\n        $title_class = 'is_folder';\n        if (isset($params['title_class'])) {\n            $title_class = $params['title_class'];\n        }\n\n        $basedir = '';\n        if (isset($params['dir_name'])) {\n            $basedir = $params['dir_name'];\n        }\n\n        $max_depth = 100;\n        if (isset($params['max_depth'])) {\n            $max_depth = $params['max_depth'];\n        }\n\n        $url_param = 'file';\n        if (isset($params['url_param'])) {\n            $url_param = $params['url_param'];\n        }\n\n        if (isset($params['url'])) {\n            $url = $params['url'];\n        } else {\n            $url = mw()->url->current(true, true);\n        }\n\n        static $level = 0;\n\n        if ($max_depth > $level) {\n            ++$level;\n            $ffs = scandir($dir);\n            echo '<ul class=\"' . $class . ' depth_' . $level . '\">';\n            foreach ($ffs as $ff) {\n                $is_hidden = substr($ff, 0, 1);\n                if ($is_hidden == '_') {\n                } else {\n                    $file1 = $ff;\n\n                    if (strlen($file1) > 3) {\n                        $pos = strpos($file1, '_', 1);\n\n                        if ($pos != false) {\n                            $substr = substr($file1, 0, $pos);\n                            if (intval($substr) > 0) {\n                                $file1 = substr($file1, $pos, strlen($file1));\n                                $file1 = ltrim($file1, '_');\n                            }\n                        }\n                    }\n\n                    $file1 = str_replace('_', ' ', $file1);\n\n                    if ($ff != '.' && $ff != '..') {\n                        echo '<li class=\"' . $class . ' depth_' . $level . '\">';\n                        if (is_dir($dir . '/' . $ff)) {\n                            $is_index = $dir . DS . $ff . DS . 'index.php';\n                            $link_href = '';\n\n                            if (is_file($is_index)) {\n                                $link = $dir . '/' . $ff . '/index.php';\n                                if (trim($basedir) != '') {\n                                    $link = normalize_path($link, false);\n                                    $basedir = normalize_path($basedir, false);\n                                    $link = str_replace($basedir . DS, '', $link);\n                                    $link = str_replace('\\\\', '/', $link);\n                                    $link = urlencode($link);\n                                }\n                                $active_class = '';\n\n                                if (isset($_REQUEST[$url_param]) and urldecode($_REQUEST[$url_param]) == $link) {\n                                    $active_class = ' active ';\n                                }\n\n                                $file1 = \"<a class='{$active_class}' href='{$url}?{$url_param}={$link}'>{$file1}</a>\";\n                            }\n\n                            $h_start = ($level == 1) ? '<h2 class=\"' . $title_class . '\">' : '<h3 class=\"' . $title_class . '\">';\n                            $h_close = ($level == 1) ? '</h2>' : '</h3>';\n                            echo $h_start . $file1 . $h_close;\n                            $this->dir_tree_build($dir . '/' . $ff, $params);\n                        } else {\n                            $file1 = no_ext($file1);\n\n                            $link = $dir . '/' . $ff;\n\n                            if (trim($basedir) != '') {\n                                $link = normalize_path($link, false);\n                                $basedir = normalize_path($basedir, false);\n                                $link = str_replace($basedir . DS, '', $link);\n                            }\n\n                            $link = str_replace('\\\\', '/', $link);\n                            $class_path = str_replace('/', '--', $link);\n                            $class_path = str_replace(' ', '_', $class_path);\n                            $class_path = str_replace('.', '_', $class_path);\n                            $active_class = '';\n                            if (isset($_REQUEST[$url_param]) and urldecode($_REQUEST[$url_param]) == $link) {\n                                $active_class = ' active ';\n                            }\n\n                            $link_href = $file1;\n                            if ($link != false) {\n                                $link = urlencode($link);\n                                $link_href = \"<a class='{$active_class} page_{$class_path} ' href='{$url}?{$url_param}={$link}'>{$file1}</a>\";\n                            }\n\n                            echo $link_href;\n                        }\n                        echo '</li>';\n                    }\n                }\n            }\n            echo '</ul>';\n        }\n        --$level;\n    }\n\n    public function download_to_browser($filename)\n    {\n        if (file_exists($filename)) {\n            $name = basename($filename);\n            $ext = get_file_extension($filename);\n\n            header('Cache-Control: public');\n            if ($ext == 'zip') {\n                header('Content-Type: application/zip');\n                header('Content-Transfer-Encoding: Binary');\n            } elseif ($ext == 'sql') {\n                header('Content-type: text/plain; charset=utf-8');\n            }\n            header('Content-Description: File Transfer');\n            header('Content-Disposition: attachment; filename=' . $name);\n            header('Content-Length: ' . filesize($filename));\n            readfile($filename);\n            exit;\n//            if (function_exists('mime_content_type')) {\n//                $this->_readfile_laravel_chunked($filename);\n//            } else {\n//\n//            }\n            //$this->_readfile_chunked($filename);\n        }\n    }\n\n    private function _readfile_chunked($filename, $retbytes = true)\n    {\n        $filename = str_replace('..', '', $filename);\n        $chunk_size = 1024 * 1024;\n        $buffer = '';\n        $cnt = 0;\n        $handle = fopen($filename, 'rb');\n        if ($handle === false) {\n            return false;\n        }\n        while (!feof($handle)) {\n            $buffer = fread($handle, $chunk_size);\n            echo $buffer;\n            ob_flush();\n            flush();\n            if ($retbytes) {\n                $cnt += strlen($buffer);\n            }\n        }\n        $status = fclose($handle);\n        if ($retbytes && $status) {\n            return $cnt; // return num. bytes delivered like readfile() does.\n        }\n\n        return $status;\n    }\n\n    private function _readfile_laravel_chunked($path, $name = null, array $headers = array())\n    {\n        if (is_null($name)) {\n            $name = basename($path);\n        }\n\n        // Prepare the headers\n        $headers = array_merge(array(\n            'Content-Description' => 'File Transfer',\n            'Content-Type' => \\File::mime(\\File::extension($path)),\n            'Content-Transfer-Encoding' => 'binary',\n            'Expires' => 0,\n            'Cache-Control' => 'must-revalidate, post-check=0, pre-check=0',\n            'Pragma' => 'public',\n            'Content-Length' => \\File::size($path),\n        ), $headers);\n\n        $response = new \\Response('', 200, $headers);\n        $response->header('Content-Disposition', $response->disposition($name));\n\n        // If there's a session we should save it now\n        if (\\Config::get('session.driver') !== '') {\n            \\Session::save();\n        }\n\n        // Send the headers and the file\n        ob_end_clean();\n        $response->send_headers();\n\n        if ($fp = fread($path, 'rb')) {\n            while (!feof($fp) and (connection_status() == 0)) {\n                echo fread($fp, 8192);\n                flush();\n            }\n        }\n\n        // Finish off, like Laravel would\n        \\Event::fire('laravel.done', array($response));\n        $response->foundation->finish();\n\n        exit;\n    }\n\n\n    function get_dangerous_files_extentions()\n    {\n\n\n        $dangerous = array(\n            'php',\n            'php5',\n            'php7',\n            'php72',\n            'php73',\n            'php74',\n            'php8',\n            'php81',\n            'php82',\n            'php56',\n            'php4',\n            'php3',\n            'phps',\n            'phpt',\n            'ptml',\n            'hphp',\n            'html',\n            'xhtml',\n            'phtml',\n            'shtml',\n            'htm',\n            'pl',\n            'js',\n            'cgi',\n            'rb',\n            'py',\n            'alfa',\n            'asp',\n            'aspx',\n            'htaccess',\n            'exe',\n            'msi',\n            'sh',\n            'bat',\n            'vbs',\n            'vb',\n            'lnk',\n            'jsp',\n            'jspx',\n\n            // from http://www.file-extensions.org/filetype/extension/name/program-executable-files\n            'action ',  //  Automator Action  Mac OS\n            'apk',      //     Application  Android\n            'app',      //     Executable  Mac OS\n            'bat',      //     Batch File  Windows\n            'bin',      //     Binary Executable  Windows, Mac OS, Linux\n            'cmd',      //     Command Script  Windows\n            'com',      //     Command File  Windows\n            'command',  //   Terminal Command  Mac OS\n            'cpl',      //     Control Panel Extension  Windows\n            'csh',      //     C Shell Script  Mac OS, Linux\n            'exe',      //     Executable  Windows\n            'gadget',   //  Windows Gadget  Windows\n            'inf1',     //      Setup Information File  Windows\n            'ins',      //     Internet Communication Settings  Windows\n            'inx',      //     InstallShield Compiled Script  Windows\n            'ipa',      //     Application  iOS\n            'isu',      //     InstallShield Uninstaller Script  Windows\n            'job',      //     Windows Task Scheduler Job File  Windows\n            'jse',      //     JScript Encoded File  Windows\n            'ksh',      //     Unix Korn Shell Script  Linux\n            'lnk',      //     File Shortcut  Windows\n            'msc',      //     Microsoft Common Console Document  Windows\n            'msi',      //     Windows Installer Package  Windows\n            'msp',      //     Windows Installer Patch  Windows\n            'mst',      //     Windows Installer Setup Transform File  Windows\n            'osx',      //     Executable  Mac OS\n            'out',      //     Executable  Linux\n            'paf',      //     Portable Application Installer File  Windows\n            'pif',      //     Program Information File  Windows\n            'prg',      //     Executable  GEM\n            'ps1',      //     Windows PowerShell Cmdlet  Windows\n            'reg',      //     Registry Data File  Windows\n            'rgs',      //     Registry Script  Windows\n            'run',      //     Executable  Linux\n            'sct',      //     Windows Scriptlet  Windows\n            'shb',      //     Windows Document Shortcut  Windows\n            'shs',      //     Shell Scrap Object  Windows\n            'u3p',      //     U3 Smart Application  Windows\n            'vb',       //    VBScript File  Windows\n            'vbe',      //     VBScript Encoded Script  Windows\n            'vbs',      //     VBScript File  Windows\n            'vbscript', //    Visual Basic Script  Windows\n            'workflow', //    Automator Workflow  Mac OS\n            'ws',       //    Windows Script  Windows\n            'wsf',      //  Windows Script  Windows\n\n            // from http://fileinfo.com/filetypes/executable\n            '0xe',        //    F-Secure Renamed Virus File',\n            '73k',        //    TI-73 Application',\n            '89k',        //    TI-89 Application',\n            '8ck',        //    TI-83 and TI-84 Plus Application\n            'a6p',        //    Authorware 6 Program',\n            'a7r',        //    Authorware 7 Runtime File',\n            'ac',        //    Autoconf Script',\n            'acc',        //    GEM Accessory File',\n            'acr',        //    ACRobot Script',\n            'action',        //    Automator Action',\n            'actm',        //    AutoCAD Action Macro File',\n            'ahk',        //    AutoHotkey Script',\n            'air',        //    Adobe AIR Installation Package',\n            'apk',        //    Android Package File',\n            'app',        //    Mac OS X Application',\n            'app',        //    FoxPro Generated Application',\n            'app',        //    Symbian OS Application',\n            'applescripT',        //    AppleScript File',\n            'arscript',        //    ArtRage Script',\n            'asb',        //    Alphacam Stone VB Macro File',\n            'azw2',        //    Kindle Active Content App File',\n            'ba_',        //    Renamed BAT File',\n            'bat',        //    DOS Batch File',\n            'beam',        //    Compiled Erlang File',\n            'bin',        //    Generic Binary Executable File',\n            'bin',        //    Unix Executable File',\n            'btm',        //    4DOS Batch File',\n            'caction',        //    Automator Converter Action',\n            'cel',        //    Celestia Script File',\n            'celx',        //    Celestia Script',\n            'cgi',        //    Common Gateway Interface Script',\n            'cmd',        //    Windows Command File',\n            'cof',        //    MPLAB COFF File',\n            'com',        //    DOS Command File',\n            'command',        //    Terminal Command File',\n            'csh',        //    C Shell Script',\n            'cyw',        //    Rbot.CYW Worm File',\n            'dek',        //    Eavesdropper Batch File',\n            'dld',        //    EdLog Compiled Program',\n            'dmc',        //    Medical Manager Script',\n            'dosexec',\n            'ds',        //    TWAIN Data Source',\n            'dxl',        //    Rational DOORS Script',\n            'e_e',        //    Renamed EXE File',\n            'ear',        //    Java Enterprise Archive File',\n            'ebm',        //    EXTRA! Basic Macro',\n            'ebs',        //    E-Run 1.x Script',\n            'ebs2',        //    E-Run 2.0 Script File',\n            'ecf',        //    SageCRM Component File',\n            'eham',        //    ExtraHAM Executable File',\n            'elf',        //    Nintendo Wii Game File',\n            'es',        //    SageCRM Script File',\n            'esh',        //    Extended Shell Batch File',\n            'ex4',        //    MetaTrader Program File',\n            'ex_',        //    Compressed Executable File',\n            'ex_',        //    Renamed Windows Executable File',\n            'exe',        //    Windows Executable File',\n            'exe',        //    PortableApps.com Application',\n            'exe1',        //    Renamed EXE File',\n            'exopc',        //    ExoPC Application',\n            'ezs',        //    EZ-R Stats Batch Script',\n            'ezt',        //    EZT Malicious Worm File',\n            'fas',        //    Compiled Fast-Load AutoLISP File'\n            'fas',        //    QuickSilver Fast Save Lisp File',\n            'fky',        //    FoxPro Macro',\n            'fpi',        //    FPS Creator Intelligence Script',\n            'frs',        //    Flash Renamer Script',\n            'fxp',        //    FoxPro Compiled Program',\n            'gadget',        //    Windows Gadget',\n            'gpe',        //    GP2X Video Game',\n            'gpu',        //    GP2X Utility Program',\n            'gs',        //    Geosoft Script',\n            'ham',        //    HAM Executable File',\n            'hms',        //    HostMonitor Script File',\n            'hpf',        //    HP9100A Program File',\n            'hta',        //    HTML Application',\n            'icd',        //    SafeDisc Encrypted Program',\n            'iim',        //    iMacro Macro File',\n            'ipa',        //    iOS Application',\n            'ipf',        //    SMS Installer Script',\n            'isu',        //    InstallShield Uninstaller Script'\n            'ita',        //    VTech InnoTab Application File',\n            'jar',        //    Java Archive File',\n            'js',        //    JScript Executable Script',\n            'jse',        //    JScript Encoded File',\n            'jsx',        //    ExtendScript Script File',\n            'kix',        //    KiXtart Script File',\n            'ksh',        //    Unix Korn Shell Script',\n            'lo',        //    Interleaf Compiled Lisp File',\n            'ls',        //    LightWave LScript File',\n            'm3g',        //    Mobile 3D Graphics Program',\n            'mam',        //    Microsoft Access Macro',\n            'mcr',        //    3ds Max Macroscript File',\n            'mcr',        //    Tecplot Macro',\n            'mel',        //    Maya Embedded Language File',\n            'mem',        //    Macro Editor Macro',\n            'mio',        //    MioEngine Application File',\n            'mm',        //    NeXtMidas Macro File',\n            'mpx',        //    FoxPro Compiled Menu Program',\n            'mrc',        //    mIRC Script File',\n            'mrp',        //    Mobile Application File',\n            'ms',        //    3ds Max Script File',\n            'ms',        //    Maxwell Script',\n            'msl',        //    Magick Scripting Language File',\n            'mxe',        //    Macro Express Playable Macro',\n            'n',        //    Neko Bytecode File',\n            'nexe',        //    Chrome Native Client Executable',\n            'ore',        //    Ore Executable File',\n            'osx',        //    PowerPC Executable File',\n            'otm',        //    Outlook Macro File',\n            'out',        //    Compiled Executable File',\n            'paf',        //    Portable Application Installer Fi\n            'paf.exe',        //    PortableApps.com Program File\n            'pex',        //    ProBoard Executable File',\n            'phar',        //    PHP Archive',\n            'pif',        //    Program Information File',\n            'plsc',        //    Messenger Plus! Live Script File'\n            'plx',        //    Perl Executable File',\n            'prc',        //    Palm Resource Code File',\n            'prg',        //    Program File',\n            'prg',        //    GEM Application',\n            'ps1',        //    Windows PowerShell Cmdlet File',\n            'pvd',        //    Instalit Script',\n            'pwc',        //    PictureTaker File',\n            'pyc',        //    Python Compiled File',\n            'pyo',        //    Python Optimized Code',\n            'qit',        //    QIT Trojan Horse File',\n            'qpx',        //    FoxPro Compiled Query Program',\n            'rbx',        //    Rembo-C Compiled Script',\n            'rfu',        //    Remote Firmware Update',\n            'rgs',        //    Registry Script',\n            'rox',        //    Actuate Report Object Executable\n            'rpj',        //    Real Pac Batch Job File',\n            'run',        //    Linux Executable File',\n            'rxe',        //    Lego Mindstorms NXT Executable Pr\n            's2a',        //    SEAL2 Application',\n            'sbs',        //    SPSS Script',\n            'sca',        //    Scala Script File',\n            'scar',        //    SCAR Script',\n            'scb',        //    Scala Published Script',\n            'scpt',        //    AppleScript Script File',\n            'scptd',        //    AppleScript Script Bundle',\n            'scr',        //    Script File',\n            'script',        //    Generic Script File',\n            'sct',        //    Windows Scriptlet',\n            'seed',        //    Linux Preseed File',\n            'shb',        //    Windows Document Shortcut',\n            'smm',        //    Ami Pro Macro',\n            'spr',        //    FoxPro Generated Screen File',\n            'tcp',        //    Tally Compiled Program File',\n            'thm',        //    Thermwood Macro File',\n            'tms',        //    Telemate Script',\n            'u3p',        //    U3 Smart Application',\n            'udf',        //    Excel User Defined Function',\n            'upx',        //    Ultimate Packer for eXecutables F\n            'vb',        //    VBScript File',    \t//\n            'vbe',        //    VBScript Encoded Script File',\n            'vbs',        //    VBScript File',\n            'vbscript',        //    Visual Basic Script',\n            'vdo',        //    Heathen Virus File',\n            'vexe',        //    Virus Executable File',\n            'vlx',        //    Compiled AutoLISP File',\n            'vpm',        //    Vox Proxy Macro File',\n            'vxp',        //    Mobile Application File',\n            'wcm',        //    WordPerfect Macro',\n            'widget',        //    Microsoft Windows Mobile Widget',\n            'widget',        //    Yahoo! Widget',\n            'wiz',        //    Microsoft Wizard File',\n            'workflow',        //    Automator Workflow',\n            'wpk',        //    WordPerfect Macro',\n            'wpm',        //    WordPerfect Macro File',\n            'ws',        //    Windows Script',\n            'wsf',        //    Windows Script File',\n            'wsh',        //    Windows Script Host Settings',\n            'x86',        //    Linux Executable File',\n            'xap',        //    Silverlight Application Package',\n            'xbap',        //    XAML Browser Application File',\n            'xlm',        //    Excel Macro',\n            'xqt',        //    SuperCalc Macro File',\n            'xys',        //    XYplorer Script File',\n            'zl9',        //    ZoneAlarm Quarantined EXE File\n\n\n            'swf',        //    Flash File\n\n        );\n\n\n        return $dangerous;\n    }\n\n\n    public function is_dangerous_file($file_name)\n    {\n        $dangerous = $this->get_dangerous_files_extentions();\n        $is_ext = get_file_extension($file_name);\n        $is_ext = strtolower($is_ext);\n\n        if (in_array($is_ext, $dangerous)) {\n            return true;\n        }\n\n    }\n\n\n    function get_allowed_files_extensions_for_upload($fileTypes = 'images')\n    {\n\n        $are_allowed = '';\n        switch ($fileTypes) {\n\n            case 'img':\n            case 'image':\n            case 'images':\n                $are_allowed .= ',png,gif,jpg,jpeg,tiff,bmp,svg';\n                break;\n            case 'video':\n            case 'videos':\n                $are_allowed .= ',avi,asf,mpg,mpeg,mp4,flv,mkv,webm,ogg,wma,mov,wmv';\n                break;\n            case 'file':\n            case 'files':\n                $are_allowed .= ',doc,docx,pdf,html,js,css,htm,rtf,txt,zip,gzip,rar,cad,xml,psd,xlsx,csv,7z';\n                break;\n            case 'documents':\n            case 'doc':\n                $are_allowed .= ',doc,docx,pdf,log,msg,odt,pages,rtf,tex,txt,wpd,wps,pps,ppt,pptx,xml,htm,html,xlr,xls,xlsx';\n                break;\n            case 'archives':\n            case 'arc':\n            case 'arch':\n                $are_allowed .= ',zip,zipx,gzip,rar,gz,7z,cbr,tar.gz';\n                break;\n            case 'all':\n                $are_allowed .= ',*';\n                break;\n            case '*':\n                $are_allowed .= ',*';\n                break;\n            default:\n                $are_allowed .= ',' . $fileTypes;\n        }\n\n        if($are_allowed){\n            $are_allowed = explode(',',$are_allowed);\n            array_unique($are_allowed);\n            $are_allowed = array_filter($are_allowed);\n            $are_allowed = implode(',', $are_allowed);\n        }\n\n        return $are_allowed;\n    }\n}\n", "<?php\n\nnamespace MicroweberPackages\\Utils\\Zip;\n\n/**\n * UnZip Class.\n *\n * This class is based on a library I found at PHPClasses:\n * http://phpclasses.org/package/2495-PHP-Pack-and-unpack-files-packed-in-ZIP-archives.html\n *\n * The original library is a little rough around the edges so I\n * refactored it and added several additional methods -- Phil Sturgeon\n *\n * This class requires extension ZLib Enabled.\n *\n * @author        Alexandre Tedeschi\n * @author        Phil Sturgeon\n *\n * @link        http://bitbucket.org/philsturgeon/codeigniter-unzip\n *\n * @license        http://www.gnu.org/licenses/lgpl.html\n *\n * @version     1.0.0\n */\nclass Unzip\n{\n    private $compressed_list = array();\n    // List of files in the ZIP\n    private $central_dir_list = array();\n    // Central dir list... It's a kind of 'extra attributes' for a set of files\n    private $end_of_central = array();\n    // End of central dir, contains ZIP Comments\n    private $info = array();\n    private $error = array();\n    private $_zip_file = '';\n    private $_target_dir = false;\n    private $apply_chmod = 0755;\n    private $fh;\n    private $zip_signature = \"\\x50\\x4b\\x03\\x04\";\n    // local file header signature\n    private $dir_signature = \"\\x50\\x4b\\x01\\x02\";\n    // central dir header signature\n    private $central_signature_end = \"\\x50\\x4b\\x05\\x06\";\n    // ignore these directories (useless meta data)\n    private $_skip_dirs = array('__MACOSX');\n    // Rename target files with underscore case\n    private $underscore_case = true;\n    private $_allow_extensions = null;\n\n    // What is allowed out of the zip\n    // --------------------------------------------------------------------\n\n    /**\n     * Constructor.\n     *\n     * @param     string\n     *\n     * @return none\n     */\n    public function __construct()\n    {\n    }\n\n    /**\n     * Unzip all files in archive.\n     *\n     * @param     none\n     *\n     * @return    none\n     */\n    public function extract($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $this->_zip_file = $zip_file;\n        $this->_target_dir = $target_dir ? $target_dir : dirname($this->_zip_file);\n\n        if (function_exists('zip_open')) {\n\n            $is_any = $this->native_unzip($zip_file, $target_dir, $preserve_filepath);\n\n            if (!empty($is_any)) {\n                return $is_any;\n            }\n\n        } else if (function_exists('gzinflate')) {\n\n            if (!$files = $this->_list_files()) {\n                $this->set_error('ZIP folder was empty.');\n                return false;\n            }\n\n            $file_locations = array();\n            foreach ($files as $file => $trash) {\n\n                if (strpos($file,'..') !== false) {\n                    continue;\n                }\n\n                $dirname = pathinfo($file, PATHINFO_DIRNAME);\n                $extension = (pathinfo($file, PATHINFO_EXTENSION));\n\n                $folders = explode('/', $dirname);\n                $out_dn = $this->_target_dir . '/' . $dirname;\n                $out_dn = str_replace('\\/', DS, $out_dn);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n\n                                return false;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n                                $resp = array('error' => 'Error with the unzip! Desitnation path is not writable.');\n\n                                return $resp;\n\n                                return false;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n            }\n\n            return $file_locations;\n        }\n\n        $resp = array('error' => 'There was an error with the unzip');\n\n        return $resp;\n    }\n\n\n    public function native_unzip($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $file_locations = array();\n        if (function_exists('zip_open')) {\n            $filename = $zip_file;\n\n            try {\n                if (!is_dir($target_dir)) {\n                    @mkdir_recursive($target_dir);\n                }\n            } catch (\\ErrorException $e) {\n\n            }\n\n\n            // get all dirs and make them because of error: is_dir(): open_basedir restriction in effect.\n            $dirs_tree = array();\n            $archive = zip_open($filename);\n            while ($entry = zip_read($archive)) {\n                $name = zip_entry_name($entry);\n                $name = dirname($name);\n                $is_dir_there = $target_dir . $name;\n\n                if (strpos($is_dir_there,'..') !== false) {\n                   continue;\n                }\n\n                if ($name != '.') {\n                    $dirs_tree[] = $is_dir_there;\n\n                }\n\n            }\n\n            $dirs_tree = array_unique($dirs_tree);\n\n            foreach ($dirs_tree as $item) {\n                try {\n                    if (!is_dir($item)) {\n                        @mkdir_recursive($item);\n                    }\n                } catch (\\ErrorException $e) {\n                // error: is_dir(): open_basedir restriction in effect.\n                }\n            }\n\n            zip_close($archive);\n\n\n            // open for extract\n            $archive = zip_open($filename);\n\n            if (is_resource($archive)) {\n//                if (php_can_use_func('set_time_limit')) {\n//                    set_time_limit(0);\n//                }\n\n                while ($entry = zip_read($archive)) {\n                    $size = zip_entry_filesize($entry);\n                    $name = zip_entry_name($entry);\n                    $target_file_to_save = normalize_path($target_dir . $name, false);\n\n                    if (strpos($target_file_to_save,'..') !== false) {\n                        continue;\n                    }\n\n                    $target_file_to_save_dir = dirname($target_file_to_save);\n                    if(!is_dir($target_file_to_save_dir)){\n                        mkdir_recursive($target_file_to_save_dir);\n                    }\n//\n                   //  var_dump($entry);\n//                    var_dump($name);\n//                    var_dump($target_file_to_save);\n//                    echo '________________' . PHP_EOL;\n//                    continue;\n\n                    $unzipped = @fopen($target_file_to_save, 'wb');\n                    while ($size > 0) {\n                        $chunkSize = ($size > 10240) ? 10240 : $size;\n                        $size -= $chunkSize;\n                        $chunk = zip_entry_read($entry, $chunkSize);\n                        if ($chunk !== false) {\n                            @fwrite($unzipped, $chunk);\n                            $file_locations[] = $target_file_to_save;\n                        }\n                    }\n                    @fclose($unzipped);\n                }\n                zip_close($archive);\n            }\n            if (!empty($file_locations)) {\n                $file_locations = array_unique($file_locations);\n            }\n        }\n\n        return $file_locations;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * List all files in archive.\n     *\n     * @param     bool\n     *\n     * @return mixed\n     */\n    private function _list_files($stop_on_file = false)\n    {\n        if (sizeof($this->compressed_list)) {\n            $this->set_debug('Returning already loaded file list.');\n\n            return $this->compressed_list;\n        }\n\n        // Open file, and set file handler\n        $fh = fopen($this->_zip_file, 'r');\n        $this->fh = &$fh;\n\n        if (!$fh) {\n            $this->set_error('Failed to load file: ' . $this->_zip_file);\n\n            return false;\n        }\n\n        $this->set_debug('Loading list from \"End of Central Dir\" index list...');\n\n        if (!$this->_load_file_list_by_eof($fh, $stop_on_file)) {\n            $this->set_debug('Failed! Trying to load list looking for signatures...');\n\n            if (!$this->_load_files_by_signatures($fh, $stop_on_file)) {\n                $this->set_debug('Failed! Could not find any valid header.');\n                $this->set_error('ZIP File is corrupted or empty');\n\n                return false;\n            }\n        }\n\n        return $this->compressed_list;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save debug data.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_debug($string)\n    {\n        $this->info[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save errors.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_error($string)\n    {\n        $this->error[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_file_list_by_eof(&$fh, $stop_on_file = false)\n    {\n        // Check if there's a valid Central Dir signature.\n        // Let's consider a file comment smaller than 1024 characters...\n        // Actually, it length can be 65536.. But we're not going to support it.\n\n        for ($x = 0; $x < 1024; ++$x) {\n            fseek($fh, -22 - $x, SEEK_END);\n\n            $signature = fread($fh, 4);\n\n            if ($signature == $this->central_signature_end) {\n                // If found EOF Central Dir\n                $eodir['disk_number_this'] = unpack('v', fread($fh, 2));\n                // number of this disk\n                $eodir['disk_number'] = unpack('v', fread($fh, 2));\n                // number of the disk with the start of the central directory\n                $eodir['total_entries_this'] = unpack('v', fread($fh, 2));\n                // total number of entries in the central dir on this disk\n                $eodir['total_entries'] = unpack('v', fread($fh, 2));\n                // total number of entries in\n                $eodir['size_of_cd'] = unpack('V', fread($fh, 4));\n                // size of the central directory\n                $eodir['offset_start_cd'] = unpack('V', fread($fh, 4));\n                // offset of start of central directory with respect to the starting disk number\n                $zip_comment_lenght = unpack('v', fread($fh, 2));\n                // zipfile comment length\n                $eodir['zipfile_comment'] = $zip_comment_lenght[1] ? fread($fh, $zip_comment_lenght[1]) : '';\n                // zipfile comment\n\n                $this->end_of_central = array('disk_number_this' => $eodir['disk_number_this'][1], 'disk_number' => $eodir['disk_number'][1], 'total_entries_this' => $eodir['total_entries_this'][1], 'total_entries' => $eodir['total_entries'][1], 'size_of_cd' => $eodir['size_of_cd'][1], 'offset_start_cd' => $eodir['offset_start_cd'][1], 'zipfile_comment' => $eodir['zipfile_comment']);\n\n                // Then, load file list\n                fseek($fh, $this->end_of_central['offset_start_cd']);\n                $signature = fread($fh, 4);\n\n                while ($signature == $this->dir_signature) {\n                    $dir['version_madeby'] = unpack('v', fread($fh, 2));\n                    // version made by\n                    $dir['version_needed'] = unpack('v', fread($fh, 2));\n                    // version needed to extract\n                    $dir['general_bit_flag'] = unpack('v', fread($fh, 2));\n                    // general purpose bit flag\n                    $dir['compression_method'] = unpack('v', fread($fh, 2));\n                    // compression method\n                    $dir['lastmod_time'] = unpack('v', fread($fh, 2));\n                    // last mod file time\n                    $dir['lastmod_date'] = unpack('v', fread($fh, 2));\n                    // last mod file date\n                    $dir['crc-32'] = fread($fh, 4);\n                    // crc-32\n                    $dir['compressed_size'] = unpack('V', fread($fh, 4));\n                    // compressed size\n                    $dir['uncompressed_size'] = unpack('V', fread($fh, 4));\n                    // uncompressed size\n                    $zip_file_length = unpack('v', fread($fh, 2));\n                    // filename length\n                    $extra_field_length = unpack('v', fread($fh, 2));\n                    // extra field length\n                    $fileCommentLength = unpack('v', fread($fh, 2));\n                    // file comment length\n                    $dir['disk_number_start'] = unpack('v', fread($fh, 2));\n                    // disk number start\n                    $dir['internal_attributes'] = unpack('v', fread($fh, 2));\n                    // internal file attributes-byte1\n                    $dir['external_attributes1'] = unpack('v', fread($fh, 2));\n                    // external file attributes-byte2\n                    $dir['external_attributes2'] = unpack('v', fread($fh, 2));\n                    // external file attributes\n                    $dir['relative_offset'] = unpack('V', fread($fh, 4));\n                    // relative offset of local header\n                    $dir['file_name'] = fread($fh, $zip_file_length[1]);\n                    // filename\n                    $dir['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n                    // extra field\n                    $dir['file_comment'] = $fileCommentLength[1] ? fread($fh, $fileCommentLength[1]) : '';\n                    // file comment\n                    // Convert the date and time, from MS-DOS format to UNIX Timestamp\n                    $binary_mod_date = str_pad(decbin($dir['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n                    $binary_mod_time = str_pad(decbin($dir['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n                    $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n                    $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n                    $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n                    $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n                    $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n                    $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n                    $this->central_dir_list[$dir['file_name']] = array('version_madeby' => $dir['version_madeby'][1], 'version_needed' => $dir['version_needed'][1], 'general_bit_flag' => str_pad(decbin($dir['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'compression_method' => $dir['compression_method'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($dir['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $dir['compressed_size'][1], 'uncompressed_size' => $dir['uncompressed_size'][1], 'disk_number_start' => $dir['disk_number_start'][1], 'internal_attributes' => $dir['internal_attributes'][1], 'external_attributes1' => $dir['external_attributes1'][1], 'external_attributes2' => $dir['external_attributes2'][1], 'relative_offset' => $dir['relative_offset'][1], 'file_name' => $dir['file_name'], 'extra_field' => $dir['extra_field'], 'file_comment' => $dir['file_comment']);\n\n                    $signature = fread($fh, 4);\n                }\n\n                // If loaded centralDirs, then try to identify the offsetPosition of the compressed data.\n                if ($this->central_dir_list) {\n                    foreach ($this->central_dir_list as $filename => $details) {\n                        $i = $this->_get_file_header($fh, $details['relative_offset']);\n                        $this->compressed_list[$filename]['file_name'] = $filename;\n                        $this->compressed_list[$filename]['compression_method'] = $details['compression_method'];\n                        $this->compressed_list[$filename]['version_needed'] = $details['version_needed'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['crc-32'] = $details['crc-32'];\n                        $this->compressed_list[$filename]['compressed_size'] = $details['compressed_size'];\n                        $this->compressed_list[$filename]['uncompressed_size'] = $details['uncompressed_size'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['extra_field'] = $i['extra_field'];\n                        $this->compressed_list[$filename]['contents_start_offset'] = $i['contents_start_offset'];\n\n                        if (strtolower($stop_on_file) == strtolower($filename)) {\n                            break;\n                        }\n                    }\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _get_file_header(&$fh, $start_offset = false)\n    {\n        if ($start_offset !== false) {\n            fseek($fh, $start_offset);\n        }\n\n        $signature = fread($fh, 4);\n\n        if ($signature == $this->zip_signature) {\n            // Get information about the zipped file\n            $file['version_needed'] = unpack('v', fread($fh, 2));\n            // version needed to extract\n            $file['general_bit_flag'] = unpack('v', fread($fh, 2));\n            // general purpose bit flag\n            $file['compression_method'] = unpack('v', fread($fh, 2));\n            // compression method\n            $file['lastmod_time'] = unpack('v', fread($fh, 2));\n            // last mod file time\n            $file['lastmod_date'] = unpack('v', fread($fh, 2));\n            // last mod file date\n            $file['crc-32'] = fread($fh, 4);\n            // crc-32\n            $file['compressed_size'] = unpack('V', fread($fh, 4));\n            // compressed size\n            $file['uncompressed_size'] = unpack('V', fread($fh, 4));\n            // uncompressed size\n            $zip_file_length = unpack('v', fread($fh, 2));\n            // filename length\n            $extra_field_length = unpack('v', fread($fh, 2));\n            // extra field length\n            $file['file_name'] = fread($fh, $zip_file_length[1]);\n            // filename\n            $file['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n            // extra field\n            $file['contents_start_offset'] = ftell($fh);\n\n            // Bypass the whole compressed contents, and look for the next file\n            fseek($fh, $file['compressed_size'][1], SEEK_CUR);\n\n            // Convert the date and time, from MS-DOS format to UNIX Timestamp\n            $binary_mod_date = str_pad(decbin($file['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n            $binary_mod_time = str_pad(decbin($file['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n\n            $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n            $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n            $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n            $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n            $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n            $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n            // Mount file table\n            $i = array('file_name' => $file['file_name'], 'compression_method' => $file['compression_method'][1], 'version_needed' => $file['version_needed'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($file['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $file['compressed_size'][1], 'uncompressed_size' => $file['uncompressed_size'][1], 'extra_field' => $file['extra_field'], 'general_bit_flag' => str_pad(decbin($file['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'contents_start_offset' => $file['contents_start_offset']);\n\n            return $i;\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_files_by_signatures(&$fh, $stop_on_file = false)\n    {\n        fseek($fh, 0);\n\n        $return = false;\n        for (; ;) {\n            $details = $this->_get_file_header($fh);\n\n            if (!$details) {\n                $this->set_debug('Invalid signature. Trying to verify if is old style Data Descriptor...');\n                fseek($fh, 12 - 4, SEEK_CUR);\n                // 12: Data descriptor - 4: Signature (that will be read again)\n                $details = $this->_get_file_header($fh);\n            }\n\n            if (!$details) {\n                $this->set_debug('Still invalid signature. Probably reached the end of the file.');\n                break;\n            }\n\n            $filename = $details['file_name'];\n            $this->compressed_list[$filename] = $details;\n            $return = true;\n\n            if (strtolower($stop_on_file) == strtolower($filename)) {\n                break;\n            }\n        }\n\n        return $return;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Unzip file in archive.\n     *\n     * @param     string , boolean, boolean\n     *\n     * @return Unziped file.\n     */\n    private function _extract_file($compressed_file_name, $target_file_name = false, $underscore_case = false)\n    {\n        if (strpos($target_file_name,'..') !== false) {\n            return false;\n        }\n\n        if (strpos($compressed_file_name,'..') !== false) {\n            return false;\n        }\n\n        if (!sizeof($this->compressed_list)) {\n            $this->set_debug('Trying to unzip before loading file list... Loading it!');\n            $this->_list_files(false, $compressed_file_name);\n        }\n\n        $fdetails = &$this->compressed_list[$compressed_file_name];\n\n        if (!isset($this->compressed_list[$compressed_file_name])) {\n            $this->set_error('File \"<strong>$compressed_file_name</strong>\" is not compressed in the zip.');\n\n            return false;\n        }\n\n        if (substr($compressed_file_name, -1) == '/') {\n            $this->set_error('Trying to unzip a folder name \"<strong>$compressed_file_name</strong>\".');\n\n            return false;\n        }\n\n        if (!$fdetails['uncompressed_size']) {\n            $this->set_debug('File \"<strong>$compressed_file_name</strong>\" is empty.');\n\n            return $target_file_name ? file_put_contents($target_file_name, '') : '';\n        }\n\n        if ($underscore_case) {\n            $pathinfo = pathinfo($target_file_name);\n            //  $pathinfo['filename_new'] = preg_replace('/([^.a-z0-9]+)/i', '_', strtolower($pathinfo['filename']));\n            $pathinfo['filename_new'] = ($pathinfo['filename']);\n            $target_file_name = $pathinfo['dirname'] . '/' . $pathinfo['filename_new'] . '.' . ($pathinfo['extension']);\n        }\n\n        fseek($this->fh, $fdetails['contents_start_offset']);\n        $ret = $this->_uncompress(fread($this->fh, $fdetails['compressed_size']), $fdetails['compression_method'], $fdetails['uncompressed_size'], $target_file_name);\n\n        if ($this->apply_chmod && $target_file_name) {\n            chmod($target_file_name, 0755);\n        }\n\n        return $ret;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Uncompress file. And save it to the targetFile.\n     *\n     * @param     Filecontent , int, int, boolean\n     *\n     * @return none\n     */\n    private function _uncompress($content, $mode, $uncompressed_size, $target_file_name = false)\n    {\n        switch ($mode) {\n            case 0 :\n                return $target_file_name ? file_put_contents($target_file_name, $content) : $content;\n            case 1 :\n                $this->set_error('Shrunk mode is not supported... yet?');\n\n                return false;\n            case 2 :\n            case 3 :\n            case 4 :\n            case 5 :\n                $this->set_error('Compression factor ' . ($mode - 1) . ' is not supported... yet?');\n\n                return false;\n            case 6 :\n                $this->set_error('Implode is not supported... yet?');\n\n                return false;\n            case 7 :\n                $this->set_error('Tokenizing compression algorithm is not supported... yet?');\n\n                return false;\n            case 8 :\n                // Deflate\n                return $target_file_name ? file_put_contents($target_file_name, gzinflate($content, $uncompressed_size)) : gzinflate($content, $uncompressed_size);\n            case 9 :\n                $this->set_error('Enhanced Deflating is not supported... yet?');\n\n                return false;\n            case 10 :\n                $this->set_error('PKWARE Date Compression Library Impoloding is not supported... yet?');\n\n                return false;\n            case 12 :\n                // Bzip2\n                return $target_file_name ? file_put_contents($target_file_name, bzdecompress($content)) : bzdecompress($content);\n            case 18 :\n                $this->set_error('IBM TERSE is not supported... yet?');\n\n                return false;\n            default :\n                $this->set_error('Unknown uncompress method: $mode');\n\n                return false;\n        }\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * What extensions do we want out of this ZIP.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function allow($ext = null)\n    {\n        $this->_allow_extensions = $ext;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Show error messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function error_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->error) . $close;\n    }\n\n    /**\n     * Show debug messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function debug_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->info) . $close;\n    }\n\n    /**\n     * Free the file resource Automatic destroy.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function __destroy()\n    {\n        $this->close();\n    }\n\n    /**\n     * Free the file resource.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function close()\n    {\n        // Free the file resource\n        if ($this->fh) {\n            fclose($this->fh);\n        }\n    }\n}\n"], "fixing_code": ["<?php\nheader('Content-Type: application/json');\n\n$files_utils = new \\MicroweberPackages\\Utils\\System\\Files();\n$dangerous = $files_utils->get_dangerous_files_extentions();\n\n\nif (!mw()->user_manager->session_id() or (mw()->user_manager->session_all() == false)) {\n    // //session_start();\n}\n\n\n\n$validate_token = false;\nif (!isset($_SERVER['HTTP_REFERER'])) {\n    header(\"HTTP/1.1 401 Unauthorized\");\n\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":97, \"message\": \"You are not allowed to upload\"}}');\n} elseif (!stristr($_SERVER['HTTP_REFERER'], site_url())) {\n    //    if (!is_logged()){\n//        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":98, \"message\": \"You cannot upload from remote domains\"}}');\n//    }\n}\n\nif (!is_admin()) {\n    $validate_token = mw()->user_manager->csrf_validate($_GET);\n    if ($validate_token == false) {\n        header(\"HTTP/1.1 401 Unauthorized\");\n        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":98, \"message\": \"You are not allowed to upload\"}}');\n    }\n\n    $is_ajax = mw()->url_manager->is_ajax();\n    if (!$is_ajax) {\n        header(\"HTTP/1.1 401 Unauthorized\");\n        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":99, \"message\": \"You are not allowed to upload\"}}');\n    }\n}\n\n$host = (parse_url(site_url()));\n\n//$host_dir = false;\n$host_dir = 'default';\n\n\nif(defined('MW_IS_MULTISITE') and MW_IS_MULTISITE){\n    if (isset($host['host'])) {\n        $host_dir = $host['host'];\n        $host_dir = str_ireplace('www.', '', $host_dir);\n        $host_dir = str_ireplace('.', '-', $host_dir);\n    }\n}\n\n\n$fileName_ext = isset($_REQUEST['name']) ? $_REQUEST['name'] : '';\n\n$is_ext = get_file_extension($fileName_ext);\n$is_ext = strtolower($is_ext);\n\n$is_dangerous_file = $files_utils->is_dangerous_file($fileName_ext);\n\nif ($is_dangerous_file) {\n    header(\"HTTP/1.1 401 Unauthorized\");\n\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":100, \"message\": \"You cannot upload scripts or executable files\"}}');\n}\n\n$allowed_to_upload = false;\n\nif (is_admin() != false) {\n    $allowed_to_upload = true;\n} else {\n    $uid = user_id();\n    if ($uid != 0) {\n        $user = mw()->user_manager->get_by_id($uid);\n        if (!empty($user) and isset($user['is_active']) and $user['is_active'] == 1) {\n            $are_allowed = 'img';\n            $_REQUEST['path'] = 'media/' . $host_dir . DS . 'user_uploads/user/' . $user['id'] . DS;\n            if (isset($_REQUEST['autopath']) and $_REQUEST['autopath'] == 'user_hash') {\n                $up_path = md5($user['id'] . $user['created_at']);\n                $_REQUEST['path'] = 'media/' . $host_dir . DS . 'user_uploads/user_hash/' . DS . $up_path . DS;\n            }\n            $allowed_to_upload = true;\n        }\n    } else {\n        $_REQUEST['path'] = 'media/' . $host_dir . DS . 'user_uploads/anonymous/';\n        $allowed_to_upload = true;\n    }\n\n\n}\n\n\nif ($allowed_to_upload == false) {\n    if (isset($_REQUEST['rel_type']) and isset($_REQUEST['custom_field_id']) and trim($_REQUEST['rel_type']) != '' and trim($_REQUEST['rel_type']) != 'false') {\n        $cfid = mw()->fields_manager->getById(intval($_REQUEST['custom_field_id']));\n        if ($cfid == false) {\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 90, \"message\": \"Custom field is not found\"}}');\n        } else {\n            $rel_error = false;\n            if (!isset($_REQUEST['rel_id'])) {\n                $rel_error = true;\n            }\n            if (!isset($cfid['rel_id'])) {\n                $rel_error = true;\n            }\n\n            if (($_REQUEST['rel_id']) != $cfid['rel_id']) {\n                $rel_error = true;\n            }\n\n\n\n\n\n            if ($rel_error) {\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 91, \"message\": \"You are not allowed to upload\"}}');\n            }\n        }\n\n        if ($cfid != false and isset($cfid['custom_field_type'])) {\n            if ($cfid['custom_field_type'] != 'upload') {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Custom field is not file upload type\"}}');\n            }\n            if ($cfid != false and (!isset($cfid['options']) or !isset($cfid['options']['file_types']))) {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"File types is not set.\"}}');\n            }\n            if ($cfid != false and isset($cfid['file_types']) and empty($cfid['file_types'])) {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 103, \"message\": \"File types cannot by empty.\"}}');\n            }\n\n            if ($cfid != false and isset($cfid['options']) and isset($cfid['options']['file_types'])) {\n                $alloled_ft = array_values(($cfid['options']['file_types']));\n                if (empty($alloled_ft)) {\n                    header(\"HTTP/1.1 401 Unauthorized\");\n\n                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 104, \"message\": \"File types cannot by empty.\"}}');\n                } else {\n                    $are_allowed = '';\n                    $fileName_ext = isset($_REQUEST['name']) ? $_REQUEST['name'] : '';\n                    foreach ($alloled_ft as $allowed_file_type_item) {\n                        if (trim($allowed_file_type_item) != '' and $fileName_ext != '') {\n                            $is_ext = get_file_extension($fileName_ext);\n                            $is_ext = strtolower($is_ext);\n\n                            switch ($is_ext) {\n                                case 'phtml':\n                                case 'php':\n                                case 'php12':\n                                case 'php11':\n                                case 'php10':\n                                case 'php9':\n                                case 'php8':\n                                case 'php7':\n                                case 'php6':\n                                case 'php5':\n                                case 'php4':\n                                case 'php3':\n                                case 'ptml':\n                                case 'html':\n                                case 'xhtml':\n                                case 'phtml':\n                                case 'shtml':\n                                case 'htm':\n                                case 'pl':\n                                case 'cgi':\n                                case 'rb':\n                                case 'py':\n                                case 'asp':\n                                case 'htaccess':\n                                case 'exe':\n                                case 'msi':\n                                case 'sh':\n                                case 'bat':\n                                case 'vbs':\n                                    $are_allowed = false;\n                                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":105, \"message\": \"You cannot upload scripts or executables\"}}');\n\n                                    break;\n\n\n                            }\n\n                            $are_allowed = $files_utils->get_allowed_files_extensions_for_upload($allowed_file_type_item);\n\n                            $pass_type_check = false;\n                            if ($are_allowed != false) {\n                                $are_allowed_a = explode(',', $are_allowed);\n                                if (!empty($are_allowed_a)) {\n                                    foreach ($are_allowed_a as $are_allowed_a_item) {\n                                        $are_allowed_a_item = strtolower(trim($are_allowed_a_item));\n                                        $is_ext = strtolower(trim($is_ext));\n\n                                        if ($are_allowed_a_item == '*') {\n                                            $pass_type_check = 1;\n                                        }\n\n                                        if ($are_allowed_a_item != '' and $are_allowed_a_item == $is_ext) {\n                                            $pass_type_check = 1;\n                                        }\n                                    }\n                                }\n                            }\n                            if ($pass_type_check == false) {\n                                header(\"HTTP/1.1 401 Unauthorized\");\n\n                                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":106, \"message\": \"You can only upload ' . $are_allowed . ' files.\"}}');\n                            } else {\n                                if (!isset($_REQUEST['captcha'])) {\n                                    if (!$validate_token) {\n                                        header(\"HTTP/1.1 401 Unauthorized\");\n\n                                        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":107, \"message\": \"Please enter the captcha answer!\"}}');\n                                    }\n                                } else {\n                                    $cap = mw()->user_manager->session_get('captcha');\n                                    if ($cap == false) {\n                                        header(\"HTTP/1.1 401 Unauthorized\");\n\n                                        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":108, \"message\": \"You must load a captcha first!\"}}');\n                                    }\n                                    $validate_captcha = $this->app->captcha_manager->validate($_REQUEST['captcha']);\n                                    if (!$validate_captcha) {\n                                        header(\"HTTP/1.1 401 Unauthorized\");\n\n                                        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":109, \"message\": \"Invalid captcha answer! \"}}');\n                                    } else {\n                                        if (!isset($_REQUEST['path'])) {\n                                            $_REQUEST['path'] = 'media/' . $host_dir . '/user_uploads' . DS . $_REQUEST['rel_type'] . DS;\n                                        }\n                                    }\n                                }\n\n                                //die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\":98, \"message\": PECATA - Not finished yet.\"}}');\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        header(\"HTTP/1.1 401 Unauthorized\");\n\n        die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 110, \"message\": \"Only admin can upload.\"}, \"id\" : \"id\"}');\n    }\n}\n\n\nif(!is_admin()){\n\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 111, \"message\": \"Only admin can upload.\"}, \"id\" : \"id\"}');\n\n    return response(array(\n        'error' => _e('Please enter captcha answer!', true),\n        'captcha_error' => true,\n        'form_data_required' => 'captcha',\n        'form_data_required_params' => array('captcha_parent_for_id' => $_REQUEST['rel_id']),\n        'form_data_module' => 'captcha'\n    ));\n}\n\n\n// Settings\n//$target_path = media_base_path() . DS;\n//$target_path = media_base_path() . DS . $host_dir . DS . 'uploaded' . DS;\n$target_path = media_uploads_path();\n$target_path = normalize_path($target_path, 0);\n\n$path_restirct = userfiles_path(); // the path the script should access\nif (isset($_REQUEST['path']) and trim($_REQUEST['path']) != '' and trim($_REQUEST['path']) != 'false') {\n    $path = urldecode($_REQUEST['path']);\n\n    $path = html_entity_decode($path);\n    $path = htmlspecialchars_decode($path, ENT_NOQUOTES);\n\n    //$path = urldecode($path);\n    $path = str_replace('%2F', '/', $path);\n    //$path = str_replace('%25252F','/',$path);\n\n    $path = normalize_path($path, 0);\n\n    $path = str_replace('..', '', $path);\n    $path = str_replace($path_restirct, '', $path);\n\n    // $target_path = userfiles_path() . DS . $path;\n    $target_path = media_uploads_path() . DS . $path;\n    $target_path = normalize_path($target_path, 1);\n}\n\n$targetDir = $target_path;\nif (!is_dir($targetDir)) {\n    mkdir_recursive($targetDir);\n}\n//$targetDir = 'uploads';\n\n$cleanupTargetDir = true;\n// Remove old files\n$maxFileAge = 5 * 3600;\n// Temp file age in seconds\n// 5 minutes execution time\n@set_time_limit(5 * 60);\n\n// Uncomment this one to fake upload time\n// usleep(5000);\n// Get parameters\n$chunk = isset($_REQUEST['chunk']) ? intval($_REQUEST['chunk']) : 0;\n$chunks = isset($_REQUEST['chunks']) ? intval($_REQUEST['chunks']) : 0;\n$fileName = isset($_REQUEST['name']) ? $_REQUEST['name'] : '';\n\n// Clean the fileName for security reasons\n$fileNameExtension = get_file_extension($fileName);\n$fileName = \\MicroweberPackages\\Helper\\URLify::filter($fileName);\n//$fileName = url_title($fileName);\n//$fileName = preg_replace('/[\\p{P}\\p{Zs}\\w\\._]+/u', \"\", $fileName);\n// $fileName = preg_replace('/[^\\w\\._]+/', '_', $fileName);\n$fileName = preg_replace('/\\s+\\d+%|\\)/', '', $fileName);\n$fileName = preg_replace(\"/[\\/\\&%#\\$]/\", \"_\", $fileName);\n$fileName = preg_replace(\"/[\\\"\\']/\", \" \", $fileName);\n$fileName = str_replace(array('(', ')', \"'\", \"!\", \"`\", \"*\", \"#\"), '_', $fileName);\n$fileName = str_replace(' ', '_', $fileName);\n$fileName = str_replace('..', '.', $fileName);\n$fileName = strtolower($fileName);\n$fileName = mw()->url_manager->clean_url_wrappers($fileName);\n$fileName = substr($fileName, 0, -(strlen($fileNameExtension)));\n$fileName = $fileName . '.' . $fileNameExtension;\n\n\n$fileName_uniq = date('ymdhis') . uniqid() . $fileName;\n// Make sure the fileName is unique but only if chunking is disabled\nif ($chunks < 2 && file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName)) {\n    $ext = strrpos($fileName, '.');\n    $fileName_a = substr($fileName, 0, $ext);\n    $fileName_b = substr($fileName, $ext);\n\n    $count = 1;\n    while (file_exists($targetDir . DIRECTORY_SEPARATOR . $fileName_a . '_' . $count . $fileName_b)) {\n        ++$count;\n    }\n\n    $fileName = $fileName_a . '_' . $count . $fileName_b;\n}\n\n$filePath = $targetDir . DIRECTORY_SEPARATOR . $fileName;\n$filePath_uniq = $targetDir . DIRECTORY_SEPARATOR . $fileName_uniq;\n\n// Create target dir\nif (!is_dir($targetDir)) {\n    @mkdir_recursive($targetDir);\n}\n\n$has_index = $targetDir . DIRECTORY_SEPARATOR . 'index.html';\n\nif (!is_file($has_index)) {\n    @touch($has_index);\n}\n\n// Remove old temp files\nif ($cleanupTargetDir && is_dir($targetDir) && ($dir = opendir($targetDir))) {\n    while (($file = readdir($dir)) !== false) {\n        $tmpfilePath = $targetDir . DIRECTORY_SEPARATOR . $file;\n\n        // Remove temp file if it is older than the max age and is not the current file\n        if (preg_match('/\\.part$/', $file) && (filemtime($tmpfilePath) < time() - $maxFileAge) && ($tmpfilePath != \"{$filePath}.part\")) {\n            @unlink($tmpfilePath);\n        }\n    }\n\n    closedir($dir);\n} else {\n    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 100, \"message\": \"Failed to open temp directory.\"}, \"id\" : \"id\"}');\n}\n\n\nif (isset($_SERVER['CONTENT_LENGTH']) and isset($_FILES['file'])) {\n    $filename_log = mw()->url_manager->slug($fileName);\n    $check = mw()->log_manager->get('one=true&no_cache=true&is_system=y&created_at=[mt]30 min ago&field=upload_size&rel=uploader&rel_id=' . $filename_log . '&user_ip=' . user_ip());\n    $upl_size_log = $_SERVER['CONTENT_LENGTH'];\n    if (is_array($check) and isset($check['id'])) {\n        $upl_size_log = intval($upl_size_log) + intval($check['value']);\n        mw()->log_manager->save('no_cache=true&is_system=y&field=upload_size&rel=uploader&rel_id=' . $filename_log . '&value=' . $upl_size_log . '&user_ip=' . user_ip() . '&id=' . $check['id']);\n    } else {\n        mw()->log_manager->save('no_cache=true&is_system=y&field=upload_size&rel=uploader&rel_id=' . $filename_log . '&value=' . $upl_size_log . '&user_ip=' . user_ip());\n    }\n}\n\n// Look for the content type header\nif (isset($_SERVER['HTTP_CONTENT_TYPE'])) {\n    $contentType = $_SERVER['HTTP_CONTENT_TYPE'];\n}\n\nif (isset($_SERVER['CONTENT_TYPE'])) {\n    $contentType = $_SERVER['CONTENT_TYPE'];\n}\n\n// Handle non multipart uploads older WebKit versions didn't support multipart in HTML5\n$is_image = false;\n\n$engine = 'plupload';\n\n\nif ($engine == 'plupload') {\n\n\n    if (isset($contentType)) {\n        if (strpos($contentType, 'multipart') !== false) {\n            if ($_FILES['file']['error'] === UPLOAD_ERR_OK) {\n                //uploading successfully done\n            } else {\n                throw new UploadException($_FILES['file']['error']);\n            }\n        }\n\n        if (isset($_FILES['file']['tmp_name']) && is_uploaded_file($_FILES['file']['tmp_name'])) {\n\n            // Open temp file\n            $out = fopen(\"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab');\n            if ($out) {\n                // Read binary input stream and append it to temp file\n                $in = fopen($_FILES['file']['tmp_name'], 'rb');\n\n                if ($in) {\n                    while ($buff = fread($in, 4096)) {\n                        fwrite($out, $buff);\n                    }\n                } else {\n                    header(\"HTTP/1.1 401 Unauthorized\");\n\n                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\n                }\n                fclose($in);\n                fclose($out);\n\n                @unlink($_FILES['file']['tmp_name']);\n            } else {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\n            }\n        } else {\n            header(\"HTTP/1.1 401 Unauthorized\");\n\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 103, \"message\": \"Failed to move uploaded file.\"}, \"id\" : \"id\"}');\n        }\n    } else {\n        // Open temp file\n        $out = fopen(\"{$filePath}.part\", $chunk == 0 ? 'wb' : 'ab');\n        if ($out) {\n            // Read binary input stream and append it to temp file\n            $in = fopen('php://input', 'rb');\n\n            if ($in) {\n                while ($buff = fread($in, 4096)) {\n                    fwrite($out, $buff);\n                }\n            } else {\n                header(\"HTTP/1.1 401 Unauthorized\");\n\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Failed to open input stream.\"}, \"id\" : \"id\"}');\n            }\n\n            fclose($in);\n            fclose($out);\n        } else {\n            header(\"HTTP/1.1 401 Unauthorized\");\n\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 102, \"message\": \"Failed to open output stream.\"}, \"id\" : \"id\"}');\n        }\n    }\n\n} else {\n\n\n}\n\n\n$rerturn = array();\n\n\n// Check if file has been uploaded\nif (!$chunks || $chunk == $chunks - 1) {\n    // Strip the temp .part suffix off\n    $newfile = $filePath;\n    if (is_file($newfile)) {\n        $newfile = $filePath_uniq;\n    }\n\n\n    rename(\"{$filePath}.part\", $newfile);\n    $filePath = $newfile;\n\n    $automatic_image_resize_on_upload = get_option('automatic_image_resize_on_upload', 'website') == 'y';\n    $automatic_image_resize_on_upload_disabled = get_option('automatic_image_resize_on_upload', 'website') == 'd';\n\n    if (is_file($filePath) and !$chunks || $chunk == $chunks - 1) {\n        $ext = get_file_extension($filePath);\n\n        if (function_exists('finfo_open') and function_exists('finfo_file')) {\n            $finfo = finfo_open(FILEINFO_MIME_TYPE); // return mime type ala mimetype extension\n            $mime = @finfo_file($finfo, $filePath);\n            if ($mime) {\n                $upl_mime_ext = explode('/', $mime);\n                $upl_mime_ext = end($upl_mime_ext);\n                $upl_mime_ext = explode('-', $upl_mime_ext);\n                $upl_mime_ext = end($upl_mime_ext);\n                $upl_mime_ext = strtolower($upl_mime_ext);\n\n                if (in_array($upl_mime_ext, $dangerous)) {\n                    die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 101, \"message\": \"Cannot upload mime type ' . $upl_mime_ext . '\"}, \"id\" : \"id\"}');\n                }\n            }\n            finfo_close($finfo);\n        }\n\n        if ($ext == 'gif' || $ext == 'jpg' || $ext == 'jpeg' || $ext === 'jpe' || $ext == 'png'|| $ext == 'svg') {\n\n            $valid = false;\n            if ($ext === 'jpg' || $ext === 'jpeg' || $ext === 'jpe') {\n\n                // This will clear exif data - security issue\n                $imgCreatedFromJpeg = @imagecreatefromjpeg($filePath);\n                if ($imgCreatedFromJpeg) {\n                    imagejpeg($imgCreatedFromJpeg, $filePath);  // this will create fresh new image without exif sensitive data\n                    $valid = true;\n                }\n            } else if ($ext === 'png') {\n\n                $imgCreatedFromPng = @imagecreatefrompng($filePath);\n                if ($imgCreatedFromPng) {\n                    imagepng($imgCreatedFromPng, $filePath);  // this will create fresh new image without exif sensitive data\n                    $valid = true;\n                }\n\n            } else if ($ext === 'gif') {\n\n                $imgCreatedFromGif = @imagecreatefromgif($filePath);\n                if ($imgCreatedFromGif) {\n                    imagegif($imgCreatedFromGif, $filePath); // this will create fresh new image without exif sensitive data\n                    $valid = true;\n                }\n\n            } else if ($ext === 'svg') {\n\n                if (is_file($filePath)) {\n                    $sanitizer = new \\enshrined\\svgSanitize\\Sanitizer();\n                    // Load the dirty svg\n                    $dirtySVG = file_get_contents($filePath);\n                     // Pass it to the sanitizer and get it back clean\n                    $cleanSVG = $sanitizer->sanitize($dirtySVG);\n                    file_put_contents($filePath, $cleanSVG);\n\n                }\n               $valid = true;\n\n            } else {\n                $valid = false;\n            }\n\n            if (!$valid) {\n                @unlink($filePath);\n                die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 107, \"message\": \"File is not an image\"}, \"id\" : \"id\"}');\n            }\n        }\n\n    }\n\n\n    if ($is_ext == 'gif' || $is_ext == 'jpg' || $is_ext == 'jpeg' || $is_ext == 'png') {\n        try {\n\n            $size = getimagesize($filePath);\n            $is_image = true;\n            $filesize = filesize($filePath);\n            $rerturn['file_size'] = $filesize;\n            $rerturn['file_size_human'] = mw()->format->human_filesize($filesize);\n            $rerturn['image_size'] = $size;\n            // $auto_resize_treshold = 10000000; // 10MiB\n            $auto_resize_treshold = 2000000; // 2MiB\n\n            if ($is_ext == 'jpg' || $is_ext == 'jpeg' || $is_ext == 'png') {\n                $rerturn['automatic_image_resize_is_enabled'] = $automatic_image_resize_on_upload;\n                if (!$automatic_image_resize_on_upload and $filesize > $auto_resize_treshold) {\n                    // if image is big, ask to enable resizing\n                    $rerturn['ask_user_to_enable_auto_resizing'] = 1;\n                    $rerturn['ask_user_to_enable_auto_resizing_filesize'] = $filesize;\n\n                }\n                if (!$automatic_image_resize_on_upload_disabled and $automatic_image_resize_on_upload and $filesize > $auto_resize_treshold) {\n                    $maxDim = 1980;\n                    //@ini_set('memory_limit', '256M');\n\n                    list($width, $height, $type, $attr) = $size;\n                    if ($width > $maxDim || $height > $maxDim) {\n//                        $d1 = dirname($filePath);\n                        $d2 = basename($filePath);\n//                        $target_filename = $d1 . DS . 'auto_resized_' . $d2;\n                        $target_filename = $filePath;\n                        $fn = $filePath;\n                        $ratio = $size[0] / $size[1]; // width/height\n                        if ($ratio > 1) {\n                            $width = $maxDim;\n                            $height = $maxDim / $ratio;\n                        } else {\n                            $width = $maxDim * $ratio;\n                            $height = $maxDim;\n                        }\n                        $src = imagecreatefromstring(file_get_contents($fn));\n                        $dst = imagecreatetruecolor($width, $height);\n\n                        if ($is_ext == 'png') {\n                            // save transparency in alpha channel\n                            imagealphablending($dst, false);\n                            imagesavealpha($dst, true);\n\n                        }\n                        imagecopyresampled($dst, $src, 0, 0, 0, 0, $width, $height, $size[0], $size[1]);\n                        imagedestroy($src);\n\n                        if ($is_ext == 'png') {\n                            imagepng($dst, $target_filename); // adjust format as needed\n\n                        } else if ($is_ext == 'jpg' || $is_ext == 'jpeg') {\n                            imagejpeg($dst, $target_filename); // adjust format as needed\n                        }\n\n                        $rerturn['image_was_auto_resized'] = 1;\n                        $rerturn['image_was_auto_resized_msg'] = \"Image was automatically resized because it was \" . $rerturn['file_size_human'];\n\n                        imagedestroy($dst);\n                    }\n                }\n            }\n\n\n        } catch (Exception $e) {\n            @unlink($filePath);\n\n            die('{\"jsonrpc\" : \"2.0\", \"error\" : {\"code\": 107, \"message\": \"File is not an image\"}, \"id\" : \"id\"}');\n\n        }\n    }\n\n\n    mw()->log_manager->delete('is_system=y&rel=uploader&created_at=[lt]30 min ago');\n    mw()->log_manager->delete('is_system=y&rel=uploader&session_id=' . mw()->user_manager->session_id());\n}\n$f_name = explode(DS, $filePath);\n$f_name = end($f_name);\n\n$filePath = mw()->url_manager->link_to_file($filePath);\n\n$rerturn['src'] = $filePath;\n$rerturn['name'] = $f_name;\n\n\nif (isset($upl_size_log) and $upl_size_log > 0) {\n    $rerturn['bytes_uploaded'] = $upl_size_log;\n}\n//$rerturn['ORIG_REQUEST'] = $_GET;\n\n\n/*\n * upload.php\n *\n * Copyright 2009, Moxiecode Systems AB\n * Released under GPL License.\n *\n * License: http://www.plupload.com/license\n * Contributing: http://www.plupload.com/contributing\n */\n// HTTP headers for no cache etc\nheader('Expires: Mon, 26 Jul 1997 05:00:00 GMT');\nheader('Last-Modified: ' . gmdate('D, d M Y H:i:s') . ' GMT');\nheader('Cache-Control: no-store, no-cache, must-revalidate');\nheader('Cache-Control: post-check=0, pre-check=0', false);\nheader('Pragma: no-cache');\n\n\necho json_encode($rerturn);\nif (mw()->user_manager->session_id() and !(mw()->user_manager->session_all() == false)) {\n    // @//session_write_close();\n}\n\nclass UploadException extends Exception\n{\n    public function __construct($code)\n    {\n        $message = $this->codeToMessage($code);\n        parent::__construct($message, $code);\n    }\n\n    private function codeToMessage($code)\n    {\n        switch ($code) {\n            case UPLOAD_ERR_INI_SIZE:\n                $message = 'The uploaded file exceeds the upload_max_filesize directive in php.ini';\n                break;\n            case UPLOAD_ERR_FORM_SIZE:\n                $message = 'The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form';\n                break;\n            case UPLOAD_ERR_PARTIAL:\n                $message = 'The uploaded file was only partially uploaded';\n                break;\n            case UPLOAD_ERR_NO_FILE:\n                $message = 'No file was uploaded';\n                break;\n            case UPLOAD_ERR_NO_TMP_DIR:\n                $message = 'Missing a temporary folder';\n                break;\n            case UPLOAD_ERR_CANT_WRITE:\n                $message = 'Failed to write file to disk';\n                break;\n            case UPLOAD_ERR_EXTENSION:\n                $message = 'File upload stopped by extension';\n                break;\n\n            default:\n                $message = 'Unknown upload error';\n                break;\n        }\n\n        return $message;\n    }\n}\n\nexit;\n\n// Return JSON-RPC response\n//die('{\"jsonrpc\" : \"2.0\", \"result\" : null, \"id\" : \"id\"}');\n", "<?php\n\nnamespace MicroweberPackages\\Utils\\System;\n\nuse RecursiveIteratorIterator;\nuse RecursiveDirectoryIterator;\nuse FilesystemIterator;\n\n$mw_static_option_groups = array();\n\nclass Files\n{\n    /**\n     * Copies directory recursively.\n     *\n     * @param $source\n     * @param $destination\n     */\n    public function copy_directory($source, $destination)\n    {\n        static $copies;\n        if (is_dir($source)) {\n            @mkdir($destination);\n            $directory = dir($source);\n            while (false !== ($readdirectory = $directory->read())) {\n                if ($readdirectory == '.' || $readdirectory == '..') {\n                    continue;\n                }\n\n                $PathDir = $source . DIRECTORY_SEPARATOR . $readdirectory;\n                if (is_dir($PathDir)) {\n                    $this->copy_directory($PathDir, $destination . DIRECTORY_SEPARATOR . $readdirectory);\n                    continue;\n                }\n                $copies[] = $destination . DIRECTORY_SEPARATOR . $readdirectory;\n                copy($PathDir, $destination . DIRECTORY_SEPARATOR . $readdirectory);\n            }\n\n            $directory->close();\n        } else {\n            $copies[] = $destination;\n            copy($source, $destination);\n        }\n\n        return $copies;\n    }\n\n    /**\n     * Returns a human readable filesize.\n     *\n     * @category Files\n     *\n     * @author      wesman20 (php.net)\n     * @author      Jonas John\n     *\n     * @version     0.3\n     *\n     * @link        http://www.jonasjohn.de/snippets/php/readable-filesize.htm\n     */\n    public function file_size_nice($size)\n    {\n        // Adapted from: http://www.php.net/manual/en/function.filesize.php\n\n        $mod = 1024;\n\n        $units = explode(' ', 'B KB MB GB TB PB');\n        for ($i = 0; $size > $mod; ++$i) {\n            $size /= $mod;\n        }\n\n        return round($size, 2) . ' ' . $units[$i];\n    }\n\n\n    public function rmdir($dirPath)\n    {\n        foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($dirPath, FilesystemIterator::SKIP_DOTS), RecursiveIteratorIterator::CHILD_FIRST) as $path) {\n            $path->isDir() && !$path->isLink() ? rmdir($path->getPathname()) : unlink($path->getPathname());\n        }\n        @rmdir($dirPath);\n    }\n\n//    public function dir_tree($path = '.', $params = false)\n//    {\n//        $params = parse_params($params);\n//        $dir = $path;\n//\n//        return $this->directory_tree_build($dir, $params);\n//    }\n\n    public function md5_dir($path)\n    {\n        if (!file_exists($path)) {\n            throw new \\Exception('Directory doesn\\'t exist.');\n        }\n\n        $directoryIterator = new \\DirectoryIterator($path);\n        $items = array();\n        foreach ($directoryIterator as $fileInfo) {\n            $filePath = $fileInfo->getPathname();\n            if (!$fileInfo->isDot()) {\n                if ($fileInfo->isFile()) {\n                    $md = md5_file($filePath);\n                    $filePath = normalize_path($filePath, false);\n                    $items [$md] = $filePath;\n                } else if ($fileInfo->isDir()) {\n                    $more = $this->md5_dir($filePath);\n                    foreach ($more as $k => $v) {\n                        $items [$k] = $v;\n                    }\n                }\n            }\n        }\n        return $items;\n    }\n\n\n    /**\n     * get_files.\n     *\n     *  Get an array that represents directory and files\n     *\n     * @category    files module api\n     *\n     * @version 1.0\n     *\n     * @since 0.320\n     *\n     * @return mixed Array with files\n     *\n     * @param array $params = array()     the params\n     * @param string $params ['directory']       The directory\n     * @param string $params ['keyword']       If set it will seach the dir and subdirs\n     */\n    public function get($params)\n    {\n        if (is_admin() == false) {\n            mw_error('Must be admin');\n        }\n\n        $params = parse_params($params);\n        if (!isset($params['directory'])) {\n            mw_error('You must define directory');\n        } else {\n            $directory = $params['directory'];\n        }\n\n\n        $filter_extensions = false;\n\n        if (isset($params['extensions']) and is_string($params['extensions'])) {\n            $filter_extensions = explode(',', $params['extensions']);\n        }\n\n        $hide_files = false;\n\n        if (isset($params['hide_files']) and is_string($params['hide_files'])) {\n            $hide_files = explode(',', $params['hide_files']);\n        } else if (isset($params['hide_files']) and is_array($params['hide_files'])) {\n            $hide_files = $params['hide_files'];\n        }\n        $restrict_path = false;\n\n        if (isset($params['restrict_path']) and is_string($params['restrict_path'])) {\n            $restrict_path = $params['restrict_path'];\n        }\n\n        if ($restrict_path) {\n            if (!strstr($directory, $restrict_path)) {\n                $directory = $restrict_path . $directory;\n            }\n        }\n\n        $from_search = 0;\n        $arrayItems = array();\n        if (isset($params['search']) and strval($params['search']) != '') {\n            $from_search = 1;\n            $arrayItems_search = $this->rglob($pattern = DS . '*' . $params['search'] . '*', $flags = 0, $directory);\n        } else {\n            if (!is_dir($directory . DS)) {\n                return false;\n            }\n\n            $arrayItems_search = array();\n            $myDirectory = opendir($directory . DS);\n\n\n\n            while ($entryName = readdir($myDirectory)) {\n\n                if(!empty($hide_files) && in_array($entryName,$hide_files)){\n                    continue;\n                }\n\n                if ($entryName != '..' and $entryName != '.') {\n                    $arrayItems_search[] = $entryName;\n                }\n            }\n\n            closedir($myDirectory);\n        }\n\n        if (!empty($arrayItems_search)) {\n//\n            //usort($myarray, create_function('$a,$b', 'return filemtime($a) - filemtime($b);'));\n\n            $arrayItems_f = array();\n            $arrayItems_d = array();\n            foreach ($arrayItems_search as $file) {\n                if ($from_search == 0) {\n                    $file = $directory . DS . $file;\n                }\n                if (is_file($file)) {\n\n                    $skip = false;\n                    $df = normalize_path($file, false);\n                    $file_ext = get_file_extension($df);\n\n\n                    if ($filter_extensions and !empty($filter_extensions)) {\n                        $skip = true;\n                        foreach ($filter_extensions as $filter_extension) {\n                            if ($filter_extension == $file_ext) {\n                                $skip = false;\n                            }\n                        }\n//                        if(array_search($file_ext,$filter_extensions)){\n//                           // $skip = false;\n//                        }\n                    }\n\n                    if ($skip == false) {\n                        if (!in_array($df, $arrayItems_f)) {\n                            $arrayItems_f[] = $df;\n                        }\n                    }\n                } else {\n                    $df = normalize_path($file, 1);\n                    if (!in_array($df, $arrayItems_d)) {\n                        $arrayItems_d[] = $df;\n                    }\n                }\n            }\n\n            /*\n            // Sort  by filetime\n            $sortedFiles = array();\n            foreach($arrayItems_f as $dir) {\n            \t$sortedFiles[filemtime($dir)] = $dir;\n            }\n            ksort($sortedFiles);\n            $sortedFiles = array_reverse($sortedFiles);\n            */\n\n\n            if (isset($params['sort_by']) and strval($params['sort_by']) != '') {\n                if (!isset($params['sort_order'])) {\n                    $sort_params = explode(' ', $params['sort_by']);\n                    if (isset($sort_params[1])) {\n                        $params['sort_by'] = $sort_params[0];\n                        $params['sort_order'] = $sort_params[1];\n                    }\n                }\n\n\n                if (isset($params['sort_order']) and strval($params['sort_order']) != '') {\n                    $ord = SORT_DESC;\n                    if (strtolower($params['sort_order']) == 'asc') {\n                        $ord = SORT_ASC;\n                    }\n                    $allowed_sort = array('basename', 'filemtime', 'filesize');\n                    if (in_array($params['sort_by'], $allowed_sort)) {\n                        array_multisort(array_map($params['sort_by'], $arrayItems_f), SORT_NUMERIC, $ord, $arrayItems_f);\n                    }\n                }\n            }\n\n            $arrayItems['files'] = $arrayItems_f;\n            $arrayItems['dirs'] = $arrayItems_d;\n        }\n\n\n        return $arrayItems;\n    }\n\n    /**\n     * Recursive glob().\n     *\n     * @category Files\n     *\n     * @uses is_array()\n     *\n     * @param int|string $pattern\n     *                            the pattern passed to glob()\n     * @param int $flags\n     *                            the flags passed to glob()\n     * @param string $path\n     *                            the path to scan\n     *\n     * @return mixed\n     *               an array of files in the given path matching the pattern.\n     */\n    public function rglob($pattern = '*', $flags = 0, $path = '')\n    {\n        if (!$path && ($dir = dirname($pattern)) != '.') {\n            if ($dir == '\\\\' || $dir == '/') {\n                $dir = '';\n            }\n\n            return $this->rglob(basename($pattern), $flags, $dir . DS);\n        }\n\n        if (stristr($path, '_notes') or stristr($path, '.git') or stristr($path, '.svn')) {\n            return false;\n        }\n\n        $paths = glob($path . '*', GLOB_ONLYDIR | GLOB_NOSORT);\n        $files = glob($path . $pattern, $flags);\n\n        if (is_array($paths)) {\n            foreach ($paths as $p) {\n                $temp = array();\n                if (is_dir($p) and is_readable($p)) {\n                    $temp = $this->rglob($pattern, false, $p . DS);\n                }\n\n                if (is_array($temp) and is_array($files)) {\n                    $files = array_merge($files, $temp);\n                } elseif (is_array($temp)) {\n                    $files = $temp;\n                }\n            }\n        }\n\n        return $files;\n    }\n\n    public function dir_tree_build($dir, $params = false)\n    {\n        $params = parse_params($params);\n        $class = 'directory_tree';\n        if (isset($params['class'])) {\n            $class = $params['class'];\n        }\n\n        $title_class = 'is_folder';\n        if (isset($params['title_class'])) {\n            $title_class = $params['title_class'];\n        }\n\n        $basedir = '';\n        if (isset($params['dir_name'])) {\n            $basedir = $params['dir_name'];\n        }\n\n        $max_depth = 100;\n        if (isset($params['max_depth'])) {\n            $max_depth = $params['max_depth'];\n        }\n\n        $url_param = 'file';\n        if (isset($params['url_param'])) {\n            $url_param = $params['url_param'];\n        }\n\n        if (isset($params['url'])) {\n            $url = $params['url'];\n        } else {\n            $url = mw()->url->current(true, true);\n        }\n\n        static $level = 0;\n\n        if ($max_depth > $level) {\n            ++$level;\n            $ffs = scandir($dir);\n            echo '<ul class=\"' . $class . ' depth_' . $level . '\">';\n            foreach ($ffs as $ff) {\n                $is_hidden = substr($ff, 0, 1);\n                if ($is_hidden == '_') {\n                } else {\n                    $file1 = $ff;\n\n                    if (strlen($file1) > 3) {\n                        $pos = strpos($file1, '_', 1);\n\n                        if ($pos != false) {\n                            $substr = substr($file1, 0, $pos);\n                            if (intval($substr) > 0) {\n                                $file1 = substr($file1, $pos, strlen($file1));\n                                $file1 = ltrim($file1, '_');\n                            }\n                        }\n                    }\n\n                    $file1 = str_replace('_', ' ', $file1);\n\n                    if ($ff != '.' && $ff != '..') {\n                        echo '<li class=\"' . $class . ' depth_' . $level . '\">';\n                        if (is_dir($dir . '/' . $ff)) {\n                            $is_index = $dir . DS . $ff . DS . 'index.php';\n                            $link_href = '';\n\n                            if (is_file($is_index)) {\n                                $link = $dir . '/' . $ff . '/index.php';\n                                if (trim($basedir) != '') {\n                                    $link = normalize_path($link, false);\n                                    $basedir = normalize_path($basedir, false);\n                                    $link = str_replace($basedir . DS, '', $link);\n                                    $link = str_replace('\\\\', '/', $link);\n                                    $link = urlencode($link);\n                                }\n                                $active_class = '';\n\n                                if (isset($_REQUEST[$url_param]) and urldecode($_REQUEST[$url_param]) == $link) {\n                                    $active_class = ' active ';\n                                }\n\n                                $file1 = \"<a class='{$active_class}' href='{$url}?{$url_param}={$link}'>{$file1}</a>\";\n                            }\n\n                            $h_start = ($level == 1) ? '<h2 class=\"' . $title_class . '\">' : '<h3 class=\"' . $title_class . '\">';\n                            $h_close = ($level == 1) ? '</h2>' : '</h3>';\n                            echo $h_start . $file1 . $h_close;\n                            $this->dir_tree_build($dir . '/' . $ff, $params);\n                        } else {\n                            $file1 = no_ext($file1);\n\n                            $link = $dir . '/' . $ff;\n\n                            if (trim($basedir) != '') {\n                                $link = normalize_path($link, false);\n                                $basedir = normalize_path($basedir, false);\n                                $link = str_replace($basedir . DS, '', $link);\n                            }\n\n                            $link = str_replace('\\\\', '/', $link);\n                            $class_path = str_replace('/', '--', $link);\n                            $class_path = str_replace(' ', '_', $class_path);\n                            $class_path = str_replace('.', '_', $class_path);\n                            $active_class = '';\n                            if (isset($_REQUEST[$url_param]) and urldecode($_REQUEST[$url_param]) == $link) {\n                                $active_class = ' active ';\n                            }\n\n                            $link_href = $file1;\n                            if ($link != false) {\n                                $link = urlencode($link);\n                                $link_href = \"<a class='{$active_class} page_{$class_path} ' href='{$url}?{$url_param}={$link}'>{$file1}</a>\";\n                            }\n\n                            echo $link_href;\n                        }\n                        echo '</li>';\n                    }\n                }\n            }\n            echo '</ul>';\n        }\n        --$level;\n    }\n\n    public function download_to_browser($filename)\n    {\n        if (file_exists($filename)) {\n            $name = basename($filename);\n            $ext = get_file_extension($filename);\n\n            header('Cache-Control: public');\n            if ($ext == 'zip') {\n                header('Content-Type: application/zip');\n                header('Content-Transfer-Encoding: Binary');\n            } elseif ($ext == 'sql') {\n                header('Content-type: text/plain; charset=utf-8');\n            }\n            header('Content-Description: File Transfer');\n            header('Content-Disposition: attachment; filename=' . $name);\n            header('Content-Length: ' . filesize($filename));\n            readfile($filename);\n            exit;\n//            if (function_exists('mime_content_type')) {\n//                $this->_readfile_laravel_chunked($filename);\n//            } else {\n//\n//            }\n            //$this->_readfile_chunked($filename);\n        }\n    }\n\n    private function _readfile_chunked($filename, $retbytes = true)\n    {\n        $filename = str_replace('..', '', $filename);\n        $chunk_size = 1024 * 1024;\n        $buffer = '';\n        $cnt = 0;\n        $handle = fopen($filename, 'rb');\n        if ($handle === false) {\n            return false;\n        }\n        while (!feof($handle)) {\n            $buffer = fread($handle, $chunk_size);\n            echo $buffer;\n            ob_flush();\n            flush();\n            if ($retbytes) {\n                $cnt += strlen($buffer);\n            }\n        }\n        $status = fclose($handle);\n        if ($retbytes && $status) {\n            return $cnt; // return num. bytes delivered like readfile() does.\n        }\n\n        return $status;\n    }\n\n    private function _readfile_laravel_chunked($path, $name = null, array $headers = array())\n    {\n        if (is_null($name)) {\n            $name = basename($path);\n        }\n\n        // Prepare the headers\n        $headers = array_merge(array(\n            'Content-Description' => 'File Transfer',\n            'Content-Type' => \\File::mime(\\File::extension($path)),\n            'Content-Transfer-Encoding' => 'binary',\n            'Expires' => 0,\n            'Cache-Control' => 'must-revalidate, post-check=0, pre-check=0',\n            'Pragma' => 'public',\n            'Content-Length' => \\File::size($path),\n        ), $headers);\n\n        $response = new \\Response('', 200, $headers);\n        $response->header('Content-Disposition', $response->disposition($name));\n\n        // If there's a session we should save it now\n        if (\\Config::get('session.driver') !== '') {\n            \\Session::save();\n        }\n\n        // Send the headers and the file\n        ob_end_clean();\n        $response->send_headers();\n\n        if ($fp = fread($path, 'rb')) {\n            while (!feof($fp) and (connection_status() == 0)) {\n                echo fread($fp, 8192);\n                flush();\n            }\n        }\n\n        // Finish off, like Laravel would\n        \\Event::fire('laravel.done', array($response));\n        $response->foundation->finish();\n\n        exit;\n    }\n\n\n    function get_dangerous_files_extentions()\n    {\n\n\n        $dangerous = array(\n            'phtml',\n            'php',\n            'php5',\n            'php6',\n            'php7',\n            'php72',\n            'php73',\n            'php74',\n            'php8',\n            'php81',\n            'php82',\n            'php56',\n            'php4',\n            'php3',\n            'phps',\n            'phpt',\n            'ptml',\n            'hphp',\n            'html',\n            'xhtml',\n            'phtml',\n            'shtml',\n            'htm',\n            'pl',\n            'js',\n            'cgi',\n            'rb',\n            'py',\n            'alfa',\n            'asp',\n            'aspx',\n            'htaccess',\n            'exe',\n            'msi',\n            'sh',\n            'bat',\n            'vbs',\n            'vb',\n            'lnk',\n            'jsp',\n            'jspx',\n\n            // from http://www.file-extensions.org/filetype/extension/name/program-executable-files\n            'action ',  //  Automator Action  Mac OS\n            'apk',      //     Application  Android\n            'app',      //     Executable  Mac OS\n            'bat',      //     Batch File  Windows\n            'bin',      //     Binary Executable  Windows, Mac OS, Linux\n            'cmd',      //     Command Script  Windows\n            'com',      //     Command File  Windows\n            'command',  //   Terminal Command  Mac OS\n            'cpl',      //     Control Panel Extension  Windows\n            'csh',      //     C Shell Script  Mac OS, Linux\n            'exe',      //     Executable  Windows\n            'gadget',   //  Windows Gadget  Windows\n            'inf1',     //      Setup Information File  Windows\n            'ins',      //     Internet Communication Settings  Windows\n            'inx',      //     InstallShield Compiled Script  Windows\n            'ipa',      //     Application  iOS\n            'isu',      //     InstallShield Uninstaller Script  Windows\n            'job',      //     Windows Task Scheduler Job File  Windows\n            'jse',      //     JScript Encoded File  Windows\n            'ksh',      //     Unix Korn Shell Script  Linux\n            'lnk',      //     File Shortcut  Windows\n            'msc',      //     Microsoft Common Console Document  Windows\n            'msi',      //     Windows Installer Package  Windows\n            'msp',      //     Windows Installer Patch  Windows\n            'mst',      //     Windows Installer Setup Transform File  Windows\n            'osx',      //     Executable  Mac OS\n            'out',      //     Executable  Linux\n            'paf',      //     Portable Application Installer File  Windows\n            'pif',      //     Program Information File  Windows\n            'prg',      //     Executable  GEM\n            'ps1',      //     Windows PowerShell Cmdlet  Windows\n            'reg',      //     Registry Data File  Windows\n            'rgs',      //     Registry Script  Windows\n            'run',      //     Executable  Linux\n            'sct',      //     Windows Scriptlet  Windows\n            'shb',      //     Windows Document Shortcut  Windows\n            'shs',      //     Shell Scrap Object  Windows\n            'u3p',      //     U3 Smart Application  Windows\n            'vb',       //    VBScript File  Windows\n            'vbe',      //     VBScript Encoded Script  Windows\n            'vbs',      //     VBScript File  Windows\n            'vbscript', //    Visual Basic Script  Windows\n            'workflow', //    Automator Workflow  Mac OS\n            'ws',       //    Windows Script  Windows\n            'wsf',      //  Windows Script  Windows\n\n            // from http://fileinfo.com/filetypes/executable\n            '0xe',        //    F-Secure Renamed Virus File',\n            '73k',        //    TI-73 Application',\n            '89k',        //    TI-89 Application',\n            '8ck',        //    TI-83 and TI-84 Plus Application\n            'a6p',        //    Authorware 6 Program',\n            'a7r',        //    Authorware 7 Runtime File',\n            'ac',        //    Autoconf Script',\n            'acc',        //    GEM Accessory File',\n            'acr',        //    ACRobot Script',\n            'action',        //    Automator Action',\n            'actm',        //    AutoCAD Action Macro File',\n            'ahk',        //    AutoHotkey Script',\n            'air',        //    Adobe AIR Installation Package',\n            'apk',        //    Android Package File',\n            'app',        //    Mac OS X Application',\n            'app',        //    FoxPro Generated Application',\n            'app',        //    Symbian OS Application',\n            'applescripT',        //    AppleScript File',\n            'arscript',        //    ArtRage Script',\n            'asb',        //    Alphacam Stone VB Macro File',\n            'azw2',        //    Kindle Active Content App File',\n            'ba_',        //    Renamed BAT File',\n            'bat',        //    DOS Batch File',\n            'beam',        //    Compiled Erlang File',\n            'bin',        //    Generic Binary Executable File',\n            'bin',        //    Unix Executable File',\n            'btm',        //    4DOS Batch File',\n            'caction',        //    Automator Converter Action',\n            'cel',        //    Celestia Script File',\n            'celx',        //    Celestia Script',\n            'cgi',        //    Common Gateway Interface Script',\n            'cmd',        //    Windows Command File',\n            'cof',        //    MPLAB COFF File',\n            'com',        //    DOS Command File',\n            'command',        //    Terminal Command File',\n            'csh',        //    C Shell Script',\n            'cyw',        //    Rbot.CYW Worm File',\n            'dek',        //    Eavesdropper Batch File',\n            'dld',        //    EdLog Compiled Program',\n            'dmc',        //    Medical Manager Script',\n            'dosexec',\n            'ds',        //    TWAIN Data Source',\n            'dxl',        //    Rational DOORS Script',\n            'e_e',        //    Renamed EXE File',\n            'ear',        //    Java Enterprise Archive File',\n            'ebm',        //    EXTRA! Basic Macro',\n            'ebs',        //    E-Run 1.x Script',\n            'ebs2',        //    E-Run 2.0 Script File',\n            'ecf',        //    SageCRM Component File',\n            'eham',        //    ExtraHAM Executable File',\n            'elf',        //    Nintendo Wii Game File',\n            'es',        //    SageCRM Script File',\n            'esh',        //    Extended Shell Batch File',\n            'ex4',        //    MetaTrader Program File',\n            'ex_',        //    Compressed Executable File',\n            'ex_',        //    Renamed Windows Executable File',\n            'exe',        //    Windows Executable File',\n            'exe',        //    PortableApps.com Application',\n            'exe1',        //    Renamed EXE File',\n            'exopc',        //    ExoPC Application',\n            'ezs',        //    EZ-R Stats Batch Script',\n            'ezt',        //    EZT Malicious Worm File',\n            'fas',        //    Compiled Fast-Load AutoLISP File'\n            'fas',        //    QuickSilver Fast Save Lisp File',\n            'fky',        //    FoxPro Macro',\n            'fpi',        //    FPS Creator Intelligence Script',\n            'frs',        //    Flash Renamer Script',\n            'fxp',        //    FoxPro Compiled Program',\n            'gadget',        //    Windows Gadget',\n            'gpe',        //    GP2X Video Game',\n            'gpu',        //    GP2X Utility Program',\n            'gs',        //    Geosoft Script',\n            'ham',        //    HAM Executable File',\n            'hms',        //    HostMonitor Script File',\n            'hpf',        //    HP9100A Program File',\n            'hta',        //    HTML Application',\n            'icd',        //    SafeDisc Encrypted Program',\n            'iim',        //    iMacro Macro File',\n            'ipa',        //    iOS Application',\n            'ipf',        //    SMS Installer Script',\n            'isu',        //    InstallShield Uninstaller Script'\n            'ita',        //    VTech InnoTab Application File',\n            'jar',        //    Java Archive File',\n            'js',        //    JScript Executable Script',\n            'jse',        //    JScript Encoded File',\n            'jsx',        //    ExtendScript Script File',\n            'kix',        //    KiXtart Script File',\n            'ksh',        //    Unix Korn Shell Script',\n            'lo',        //    Interleaf Compiled Lisp File',\n            'ls',        //    LightWave LScript File',\n            'm3g',        //    Mobile 3D Graphics Program',\n            'mam',        //    Microsoft Access Macro',\n            'mcr',        //    3ds Max Macroscript File',\n            'mcr',        //    Tecplot Macro',\n            'mel',        //    Maya Embedded Language File',\n            'mem',        //    Macro Editor Macro',\n            'mio',        //    MioEngine Application File',\n            'mm',        //    NeXtMidas Macro File',\n            'mpx',        //    FoxPro Compiled Menu Program',\n            'mrc',        //    mIRC Script File',\n            'mrp',        //    Mobile Application File',\n            'ms',        //    3ds Max Script File',\n            'ms',        //    Maxwell Script',\n            'msl',        //    Magick Scripting Language File',\n            'mxe',        //    Macro Express Playable Macro',\n            'n',        //    Neko Bytecode File',\n            'nexe',        //    Chrome Native Client Executable',\n            'ore',        //    Ore Executable File',\n            'osx',        //    PowerPC Executable File',\n            'otm',        //    Outlook Macro File',\n            'out',        //    Compiled Executable File',\n            'paf',        //    Portable Application Installer Fi\n            'paf.exe',        //    PortableApps.com Program File\n            'pex',        //    ProBoard Executable File',\n            'phar',        //    PHP Archive',\n            'pif',        //    Program Information File',\n            'plsc',        //    Messenger Plus! Live Script File'\n            'plx',        //    Perl Executable File',\n            'prc',        //    Palm Resource Code File',\n            'prg',        //    Program File',\n            'prg',        //    GEM Application',\n            'ps1',        //    Windows PowerShell Cmdlet File',\n            'pvd',        //    Instalit Script',\n            'pwc',        //    PictureTaker File',\n            'pyc',        //    Python Compiled File',\n            'pyo',        //    Python Optimized Code',\n            'qit',        //    QIT Trojan Horse File',\n            'qpx',        //    FoxPro Compiled Query Program',\n            'rbx',        //    Rembo-C Compiled Script',\n            'rfu',        //    Remote Firmware Update',\n            'rgs',        //    Registry Script',\n            'rox',        //    Actuate Report Object Executable\n            'rpj',        //    Real Pac Batch Job File',\n            'run',        //    Linux Executable File',\n            'rxe',        //    Lego Mindstorms NXT Executable Pr\n            's2a',        //    SEAL2 Application',\n            'sbs',        //    SPSS Script',\n            'sca',        //    Scala Script File',\n            'scar',        //    SCAR Script',\n            'scb',        //    Scala Published Script',\n            'scpt',        //    AppleScript Script File',\n            'scptd',        //    AppleScript Script Bundle',\n            'scr',        //    Script File',\n            'script',        //    Generic Script File',\n            'sct',        //    Windows Scriptlet',\n            'seed',        //    Linux Preseed File',\n            'shb',        //    Windows Document Shortcut',\n            'smm',        //    Ami Pro Macro',\n            'spr',        //    FoxPro Generated Screen File',\n            'tcp',        //    Tally Compiled Program File',\n            'thm',        //    Thermwood Macro File',\n            'tms',        //    Telemate Script',\n            'u3p',        //    U3 Smart Application',\n            'udf',        //    Excel User Defined Function',\n            'upx',        //    Ultimate Packer for eXecutables F\n            'vb',        //    VBScript File',    \t//\n            'vbe',        //    VBScript Encoded Script File',\n            'vbs',        //    VBScript File',\n            'vbscript',        //    Visual Basic Script',\n            'vdo',        //    Heathen Virus File',\n            'vexe',        //    Virus Executable File',\n            'vlx',        //    Compiled AutoLISP File',\n            'vpm',        //    Vox Proxy Macro File',\n            'vxp',        //    Mobile Application File',\n            'wcm',        //    WordPerfect Macro',\n            'widget',        //    Microsoft Windows Mobile Widget',\n            'widget',        //    Yahoo! Widget',\n            'wiz',        //    Microsoft Wizard File',\n            'workflow',        //    Automator Workflow',\n            'wpk',        //    WordPerfect Macro',\n            'wpm',        //    WordPerfect Macro File',\n            'ws',        //    Windows Script',\n            'wsf',        //    Windows Script File',\n            'wsh',        //    Windows Script Host Settings',\n            'x86',        //    Linux Executable File',\n            'xap',        //    Silverlight Application Package',\n            'xbap',        //    XAML Browser Application File',\n            'xlm',        //    Excel Macro',\n            'xqt',        //    SuperCalc Macro File',\n            'xys',        //    XYplorer Script File',\n            'zl9',        //    ZoneAlarm Quarantined EXE File\n\n\n            'swf',        //    Flash File\n\n        );\n\n\n        return $dangerous;\n    }\n\n\n    public function is_dangerous_file($file_name)\n    {\n        $dangerous = $this->get_dangerous_files_extentions();\n        $is_ext = get_file_extension($file_name);\n        $is_ext = strtolower($is_ext);\n\n        if (in_array($is_ext, $dangerous)) {\n            return true;\n        }\n\n    }\n\n\n    function get_allowed_files_extensions_for_upload($fileTypes = 'images')\n    {\n\n        $are_allowed = '';\n        switch ($fileTypes) {\n\n            case 'img':\n            case 'image':\n            case 'images':\n                $are_allowed .= ',png,gif,jpg,jpeg,tiff,bmp,svg';\n                break;\n            case 'video':\n            case 'videos':\n                $are_allowed .= ',avi,asf,mpg,mpeg,mp4,flv,mkv,webm,ogg,wma,mov,wmv';\n                break;\n            case 'file':\n            case 'files':\n                $are_allowed .= ',doc,docx,pdf,html,js,css,htm,rtf,txt,zip,gzip,rar,cad,xml,psd,xlsx,csv,7z';\n                break;\n            case 'documents':\n            case 'doc':\n                $are_allowed .= ',doc,docx,pdf,log,msg,odt,pages,rtf,tex,txt,wpd,wps,pps,ppt,pptx,xml,htm,html,xlr,xls,xlsx';\n                break;\n            case 'archives':\n            case 'arc':\n            case 'arch':\n                $are_allowed .= ',zip,zipx,gzip,rar,gz,7z,cbr,tar.gz';\n                break;\n            case 'all':\n                $are_allowed .= ',*';\n                break;\n            case '*':\n                $are_allowed .= ',*';\n                break;\n            default:\n                $are_allowed .= ',' . $fileTypes;\n        }\n\n        if($are_allowed){\n            $are_allowed = explode(',',$are_allowed);\n            array_unique($are_allowed);\n            $are_allowed = array_filter($are_allowed);\n            $are_allowed = implode(',', $are_allowed);\n        }\n\n        return $are_allowed;\n    }\n}\n", "<?php\n\nnamespace MicroweberPackages\\Utils\\Zip;\n\n/**\n * UnZip Class.\n *\n * This class is based on a library I found at PHPClasses:\n * http://phpclasses.org/package/2495-PHP-Pack-and-unpack-files-packed-in-ZIP-archives.html\n *\n * The original library is a little rough around the edges so I\n * refactored it and added several additional methods -- Phil Sturgeon\n *\n * This class requires extension ZLib Enabled.\n *\n * @author        Alexandre Tedeschi\n * @author        Phil Sturgeon\n *\n * @link        http://bitbucket.org/philsturgeon/codeigniter-unzip\n *\n * @license        http://www.gnu.org/licenses/lgpl.html\n *\n * @version     1.0.0\n */\nclass Unzip\n{\n    private $compressed_list = array();\n    // List of files in the ZIP\n    private $central_dir_list = array();\n    // Central dir list... It's a kind of 'extra attributes' for a set of files\n    private $end_of_central = array();\n    // End of central dir, contains ZIP Comments\n    private $info = array();\n    private $error = array();\n    private $_zip_file = '';\n    private $_target_dir = false;\n    private $apply_chmod = 0755;\n    private $fh;\n    private $zip_signature = \"\\x50\\x4b\\x03\\x04\";\n    // local file header signature\n    private $dir_signature = \"\\x50\\x4b\\x01\\x02\";\n    // central dir header signature\n    private $central_signature_end = \"\\x50\\x4b\\x05\\x06\";\n    // ignore these directories (useless meta data)\n    private $_skip_dirs = array('__MACOSX');\n    // Rename target files with underscore case\n    private $underscore_case = true;\n    private $_allow_extensions = null;\n\n    // What is allowed out of the zip\n    // --------------------------------------------------------------------\n\n    /**\n     * Constructor.\n     *\n     * @param     string\n     *\n     * @return none\n     */\n    public function __construct()\n    {\n    }\n\n    /**\n     * Unzip all files in archive.\n     *\n     * @param     none\n     *\n     * @return    none\n     */\n    public function extract($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $this->_zip_file = $zip_file;\n        $this->_target_dir = $target_dir ? $target_dir : dirname($this->_zip_file);\n\n        if (function_exists('zip_open')) {\n\n            $is_any = $this->native_unzip($zip_file, $target_dir, $preserve_filepath);\n\n            if (!empty($is_any)) {\n                return $is_any;\n            }\n\n        } else if (function_exists('gzinflate')) {\n\n            if (!$files = $this->_list_files()) {\n                $this->set_error('ZIP folder was empty.');\n                return false;\n            }\n\n            $file_locations = array();\n            foreach ($files as $file => $trash) {\n\n                if (strpos($file,'..') !== false) {\n                    continue;\n                }\n\n                $dirname = pathinfo($file, PATHINFO_DIRNAME);\n                $extension = (pathinfo($file, PATHINFO_EXTENSION));\n\n                $folders = explode('/', $dirname);\n                $out_dn = $this->_target_dir . '/' . $dirname;\n                $out_dn = str_replace('\\/', DS, $out_dn);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n\n                                return false;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n                // Skip stuff in stupid folders\n                if (in_array(current($folders), $this->_skip_dirs)) {\n                    continue;\n                }\n\n                // Skip any files that are not allowed\n                if (is_array($this->_allow_extensions) && $extension && !in_array($extension, $this->_allow_extensions)) {\n                    continue;\n                }\n\n                if (!is_dir($out_dn) && $preserve_filepath) {\n                    $str = '';\n                    foreach ($folders as $folder) {\n                        $str = $str ? $str . '/' . $folder : $folder;\n                        if (!is_dir($this->_target_dir . '/' . $str)) {\n                            $this->set_debug('Creating folder: ' . $this->_target_dir . '/' . $str);\n\n                            if (!@mkdir_recursive($this->_target_dir . '/' . $str)) {\n                                $this->set_error('Desitnation path is not writable.');\n                                $resp = array('error' => 'Error with the unzip! Desitnation path is not writable.');\n\n                                return $resp;\n                            }\n\n                            // Apply chmod if configured to do so\n                            $this->apply_chmod && chmod($this->_target_dir . '/' . $str, $this->apply_chmod);\n                        }\n                    }\n                }\n\n                if (substr($file, -1, 1) == '/') {\n                    continue;\n                }\n\n                $file_locations[] = $file_location = $this->_target_dir . '/' . ($preserve_filepath ? $file : basename($file));\n\n                $this->_extract_file($file, $file_location, $this->underscore_case);\n            }\n\n            return $file_locations;\n        }\n\n        $resp = array('error' => 'There was an error with the unzip');\n\n        return $resp;\n    }\n\n\n    public function native_unzip($zip_file, $target_dir = null, $preserve_filepath = true)\n    {\n        $file_locations = array();\n        if (function_exists('zip_open')) {\n            $filename = $zip_file;\n\n            try {\n                if (!is_dir($target_dir)) {\n                    @mkdir_recursive($target_dir);\n                }\n            } catch (\\ErrorException $e) {\n\n            }\n\n\n            // get all dirs and make them because of error: is_dir(): open_basedir restriction in effect.\n            $dirs_tree = array();\n            $archive = zip_open($filename);\n            while ($entry = zip_read($archive)) {\n                $name = zip_entry_name($entry);\n                $name = dirname($name);\n                $is_dir_there = $target_dir . $name;\n\n                if (strpos($is_dir_there,'..') !== false) {\n                   continue;\n                }\n\n                if ($name != '.') {\n                    $dirs_tree[] = $is_dir_there;\n\n                }\n\n            }\n\n            $dirs_tree = array_unique($dirs_tree);\n\n            foreach ($dirs_tree as $item) {\n                try {\n                    if (!is_dir($item)) {\n                        @mkdir_recursive($item);\n                    }\n                } catch (\\ErrorException $e) {\n                // error: is_dir(): open_basedir restriction in effect.\n                }\n            }\n\n            zip_close($archive);\n\n\n            // open for extract\n            $archive = zip_open($filename);\n\n            if (is_resource($archive)) {\n//                if (php_can_use_func('set_time_limit')) {\n//                    set_time_limit(0);\n//                }\n\n                while ($entry = zip_read($archive)) {\n                    $size = zip_entry_filesize($entry);\n                    $name = zip_entry_name($entry);\n                    $target_file_to_save = normalize_path($target_dir . $name, false);\n\n                    if (strpos($target_file_to_save,'..') !== false) {\n                        continue;\n                    }\n\n                    $target_file_to_save_dir = dirname($target_file_to_save);\n                    if(!is_dir($target_file_to_save_dir)){\n                        mkdir_recursive($target_file_to_save_dir);\n                    }\n//\n                   //  var_dump($entry);\n//                    var_dump($name);\n//                    var_dump($target_file_to_save);\n//                    echo '________________' . PHP_EOL;\n//                    continue;\n\n                    $unzipped = @fopen($target_file_to_save, 'wb');\n                    while ($size > 0) {\n                        $chunkSize = ($size > 10240) ? 10240 : $size;\n                        $size -= $chunkSize;\n                        $chunk = zip_entry_read($entry, $chunkSize);\n                        if ($chunk !== false) {\n                            @fwrite($unzipped, $chunk);\n                            $file_locations[] = $target_file_to_save;\n                        }\n                    }\n                    @fclose($unzipped);\n                }\n                zip_close($archive);\n            }\n            if (!empty($file_locations)) {\n                $file_locations = array_unique($file_locations);\n            }\n        }\n\n        return $file_locations;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * List all files in archive.\n     *\n     * @param     bool\n     *\n     * @return mixed\n     */\n    private function _list_files($stop_on_file = false)\n    {\n        if (sizeof($this->compressed_list)) {\n            $this->set_debug('Returning already loaded file list.');\n\n            return $this->compressed_list;\n        }\n\n        // Open file, and set file handler\n        $fh = fopen($this->_zip_file, 'r');\n        $this->fh = &$fh;\n\n        if (!$fh) {\n            $this->set_error('Failed to load file: ' . $this->_zip_file);\n\n            return false;\n        }\n\n        $this->set_debug('Loading list from \"End of Central Dir\" index list...');\n\n        if (!$this->_load_file_list_by_eof($fh, $stop_on_file)) {\n            $this->set_debug('Failed! Trying to load list looking for signatures...');\n\n            if (!$this->_load_files_by_signatures($fh, $stop_on_file)) {\n                $this->set_debug('Failed! Could not find any valid header.');\n                $this->set_error('ZIP File is corrupted or empty');\n\n                return false;\n            }\n        }\n\n        return $this->compressed_list;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save debug data.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_debug($string)\n    {\n        $this->info[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Save errors.\n     *\n     * @param    string\n     *\n     * @return none\n     */\n    public function set_error($string)\n    {\n        $this->error[] = $string;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_file_list_by_eof(&$fh, $stop_on_file = false)\n    {\n        // Check if there's a valid Central Dir signature.\n        // Let's consider a file comment smaller than 1024 characters...\n        // Actually, it length can be 65536.. But we're not going to support it.\n\n        for ($x = 0; $x < 1024; ++$x) {\n            fseek($fh, -22 - $x, SEEK_END);\n\n            $signature = fread($fh, 4);\n\n            if ($signature == $this->central_signature_end) {\n                // If found EOF Central Dir\n                $eodir['disk_number_this'] = unpack('v', fread($fh, 2));\n                // number of this disk\n                $eodir['disk_number'] = unpack('v', fread($fh, 2));\n                // number of the disk with the start of the central directory\n                $eodir['total_entries_this'] = unpack('v', fread($fh, 2));\n                // total number of entries in the central dir on this disk\n                $eodir['total_entries'] = unpack('v', fread($fh, 2));\n                // total number of entries in\n                $eodir['size_of_cd'] = unpack('V', fread($fh, 4));\n                // size of the central directory\n                $eodir['offset_start_cd'] = unpack('V', fread($fh, 4));\n                // offset of start of central directory with respect to the starting disk number\n                $zip_comment_lenght = unpack('v', fread($fh, 2));\n                // zipfile comment length\n                $eodir['zipfile_comment'] = $zip_comment_lenght[1] ? fread($fh, $zip_comment_lenght[1]) : '';\n                // zipfile comment\n\n                $this->end_of_central = array('disk_number_this' => $eodir['disk_number_this'][1], 'disk_number' => $eodir['disk_number'][1], 'total_entries_this' => $eodir['total_entries_this'][1], 'total_entries' => $eodir['total_entries'][1], 'size_of_cd' => $eodir['size_of_cd'][1], 'offset_start_cd' => $eodir['offset_start_cd'][1], 'zipfile_comment' => $eodir['zipfile_comment']);\n\n                // Then, load file list\n                fseek($fh, $this->end_of_central['offset_start_cd']);\n                $signature = fread($fh, 4);\n\n                while ($signature == $this->dir_signature) {\n                    $dir['version_madeby'] = unpack('v', fread($fh, 2));\n                    // version made by\n                    $dir['version_needed'] = unpack('v', fread($fh, 2));\n                    // version needed to extract\n                    $dir['general_bit_flag'] = unpack('v', fread($fh, 2));\n                    // general purpose bit flag\n                    $dir['compression_method'] = unpack('v', fread($fh, 2));\n                    // compression method\n                    $dir['lastmod_time'] = unpack('v', fread($fh, 2));\n                    // last mod file time\n                    $dir['lastmod_date'] = unpack('v', fread($fh, 2));\n                    // last mod file date\n                    $dir['crc-32'] = fread($fh, 4);\n                    // crc-32\n                    $dir['compressed_size'] = unpack('V', fread($fh, 4));\n                    // compressed size\n                    $dir['uncompressed_size'] = unpack('V', fread($fh, 4));\n                    // uncompressed size\n                    $zip_file_length = unpack('v', fread($fh, 2));\n                    // filename length\n                    $extra_field_length = unpack('v', fread($fh, 2));\n                    // extra field length\n                    $fileCommentLength = unpack('v', fread($fh, 2));\n                    // file comment length\n                    $dir['disk_number_start'] = unpack('v', fread($fh, 2));\n                    // disk number start\n                    $dir['internal_attributes'] = unpack('v', fread($fh, 2));\n                    // internal file attributes-byte1\n                    $dir['external_attributes1'] = unpack('v', fread($fh, 2));\n                    // external file attributes-byte2\n                    $dir['external_attributes2'] = unpack('v', fread($fh, 2));\n                    // external file attributes\n                    $dir['relative_offset'] = unpack('V', fread($fh, 4));\n                    // relative offset of local header\n                    $dir['file_name'] = fread($fh, $zip_file_length[1]);\n                    // filename\n                    $dir['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n                    // extra field\n                    $dir['file_comment'] = $fileCommentLength[1] ? fread($fh, $fileCommentLength[1]) : '';\n                    // file comment\n                    // Convert the date and time, from MS-DOS format to UNIX Timestamp\n                    $binary_mod_date = str_pad(decbin($dir['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n                    $binary_mod_time = str_pad(decbin($dir['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n                    $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n                    $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n                    $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n                    $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n                    $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n                    $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n                    $this->central_dir_list[$dir['file_name']] = array('version_madeby' => $dir['version_madeby'][1], 'version_needed' => $dir['version_needed'][1], 'general_bit_flag' => str_pad(decbin($dir['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'compression_method' => $dir['compression_method'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($dir['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($dir['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $dir['compressed_size'][1], 'uncompressed_size' => $dir['uncompressed_size'][1], 'disk_number_start' => $dir['disk_number_start'][1], 'internal_attributes' => $dir['internal_attributes'][1], 'external_attributes1' => $dir['external_attributes1'][1], 'external_attributes2' => $dir['external_attributes2'][1], 'relative_offset' => $dir['relative_offset'][1], 'file_name' => $dir['file_name'], 'extra_field' => $dir['extra_field'], 'file_comment' => $dir['file_comment']);\n\n                    $signature = fread($fh, 4);\n                }\n\n                // If loaded centralDirs, then try to identify the offsetPosition of the compressed data.\n                if ($this->central_dir_list) {\n                    foreach ($this->central_dir_list as $filename => $details) {\n                        $i = $this->_get_file_header($fh, $details['relative_offset']);\n                        $this->compressed_list[$filename]['file_name'] = $filename;\n                        $this->compressed_list[$filename]['compression_method'] = $details['compression_method'];\n                        $this->compressed_list[$filename]['version_needed'] = $details['version_needed'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['crc-32'] = $details['crc-32'];\n                        $this->compressed_list[$filename]['compressed_size'] = $details['compressed_size'];\n                        $this->compressed_list[$filename]['uncompressed_size'] = $details['uncompressed_size'];\n                        $this->compressed_list[$filename]['lastmod_datetime'] = $details['lastmod_datetime'];\n                        $this->compressed_list[$filename]['extra_field'] = $i['extra_field'];\n                        $this->compressed_list[$filename]['contents_start_offset'] = $i['contents_start_offset'];\n\n                        if (strtolower($stop_on_file) == strtolower($filename)) {\n                            break;\n                        }\n                    }\n                }\n\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _get_file_header(&$fh, $start_offset = false)\n    {\n        if ($start_offset !== false) {\n            fseek($fh, $start_offset);\n        }\n\n        $signature = fread($fh, 4);\n\n        if ($signature == $this->zip_signature) {\n            // Get information about the zipped file\n            $file['version_needed'] = unpack('v', fread($fh, 2));\n            // version needed to extract\n            $file['general_bit_flag'] = unpack('v', fread($fh, 2));\n            // general purpose bit flag\n            $file['compression_method'] = unpack('v', fread($fh, 2));\n            // compression method\n            $file['lastmod_time'] = unpack('v', fread($fh, 2));\n            // last mod file time\n            $file['lastmod_date'] = unpack('v', fread($fh, 2));\n            // last mod file date\n            $file['crc-32'] = fread($fh, 4);\n            // crc-32\n            $file['compressed_size'] = unpack('V', fread($fh, 4));\n            // compressed size\n            $file['uncompressed_size'] = unpack('V', fread($fh, 4));\n            // uncompressed size\n            $zip_file_length = unpack('v', fread($fh, 2));\n            // filename length\n            $extra_field_length = unpack('v', fread($fh, 2));\n            // extra field length\n            $file['file_name'] = fread($fh, $zip_file_length[1]);\n            // filename\n            $file['extra_field'] = $extra_field_length[1] ? fread($fh, $extra_field_length[1]) : '';\n            // extra field\n            $file['contents_start_offset'] = ftell($fh);\n\n            // Bypass the whole compressed contents, and look for the next file\n            fseek($fh, $file['compressed_size'][1], SEEK_CUR);\n\n            // Convert the date and time, from MS-DOS format to UNIX Timestamp\n            $binary_mod_date = str_pad(decbin($file['lastmod_date'][1]), 16, '0', STR_PAD_LEFT);\n            $binary_mod_time = str_pad(decbin($file['lastmod_time'][1]), 16, '0', STR_PAD_LEFT);\n\n            $last_mod_year = bindec(substr($binary_mod_date, 0, 7)) + 1980;\n            $last_mod_month = bindec(substr($binary_mod_date, 7, 4));\n            $last_mod_day = bindec(substr($binary_mod_date, 11, 5));\n            $last_mod_hour = bindec(substr($binary_mod_time, 0, 5));\n            $last_mod_minute = bindec(substr($binary_mod_time, 5, 6));\n            $last_mod_second = bindec(substr($binary_mod_time, 11, 5));\n\n            // Mount file table\n            $i = array('file_name' => $file['file_name'], 'compression_method' => $file['compression_method'][1], 'version_needed' => $file['version_needed'][1], 'lastmod_datetime' => mktime($last_mod_hour, $last_mod_minute, $last_mod_second, $last_mod_month, $last_mod_day, $last_mod_year), 'crc-32' => str_pad(dechex(ord($file['crc-32'][3])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][2])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][1])), 2, '0', STR_PAD_LEFT) . str_pad(dechex(ord($file['crc-32'][0])), 2, '0', STR_PAD_LEFT), 'compressed_size' => $file['compressed_size'][1], 'uncompressed_size' => $file['uncompressed_size'][1], 'extra_field' => $file['extra_field'], 'general_bit_flag' => str_pad(decbin($file['general_bit_flag'][1]), 8, '0', STR_PAD_LEFT), 'contents_start_offset' => $file['contents_start_offset']);\n\n            return $i;\n        }\n\n        return false;\n    }\n\n    // --------------------------------------------------------------------\n\n    private function _load_files_by_signatures(&$fh, $stop_on_file = false)\n    {\n        fseek($fh, 0);\n\n        $return = false;\n        for (; ;) {\n            $details = $this->_get_file_header($fh);\n\n            if (!$details) {\n                $this->set_debug('Invalid signature. Trying to verify if is old style Data Descriptor...');\n                fseek($fh, 12 - 4, SEEK_CUR);\n                // 12: Data descriptor - 4: Signature (that will be read again)\n                $details = $this->_get_file_header($fh);\n            }\n\n            if (!$details) {\n                $this->set_debug('Still invalid signature. Probably reached the end of the file.');\n                break;\n            }\n\n            $filename = $details['file_name'];\n            $this->compressed_list[$filename] = $details;\n            $return = true;\n\n            if (strtolower($stop_on_file) == strtolower($filename)) {\n                break;\n            }\n        }\n\n        return $return;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Unzip file in archive.\n     *\n     * @param     string , boolean, boolean\n     *\n     * @return Unziped file.\n     */\n    private function _extract_file($compressed_file_name, $target_file_name = false, $underscore_case = false)\n    {\n        if (strpos($target_file_name,'..') !== false) {\n            return false;\n        }\n\n        if (strpos($compressed_file_name,'..') !== false) {\n            return false;\n        }\n\n        if (!sizeof($this->compressed_list)) {\n            $this->set_debug('Trying to unzip before loading file list... Loading it!');\n            $this->_list_files(false, $compressed_file_name);\n        }\n\n        $fdetails = &$this->compressed_list[$compressed_file_name];\n\n        if (!isset($this->compressed_list[$compressed_file_name])) {\n            $this->set_error('File \"<strong>$compressed_file_name</strong>\" is not compressed in the zip.');\n\n            return false;\n        }\n\n        if (substr($compressed_file_name, -1) == '/') {\n            $this->set_error('Trying to unzip a folder name \"<strong>$compressed_file_name</strong>\".');\n\n            return false;\n        }\n\n        if (!$fdetails['uncompressed_size']) {\n            $this->set_debug('File \"<strong>$compressed_file_name</strong>\" is empty.');\n\n            return $target_file_name ? file_put_contents($target_file_name, '') : '';\n        }\n\n        if ($underscore_case) {\n            $pathinfo = pathinfo($target_file_name);\n            //  $pathinfo['filename_new'] = preg_replace('/([^.a-z0-9]+)/i', '_', strtolower($pathinfo['filename']));\n            $pathinfo['filename_new'] = ($pathinfo['filename']);\n            $target_file_name = $pathinfo['dirname'] . '/' . $pathinfo['filename_new'] . '.' . ($pathinfo['extension']);\n        }\n\n        fseek($this->fh, $fdetails['contents_start_offset']);\n        $ret = $this->_uncompress(fread($this->fh, $fdetails['compressed_size']), $fdetails['compression_method'], $fdetails['uncompressed_size'], $target_file_name);\n\n        if ($this->apply_chmod && $target_file_name) {\n            chmod($target_file_name, 0755);\n        }\n\n        return $ret;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Uncompress file. And save it to the targetFile.\n     *\n     * @param     Filecontent , int, int, boolean\n     *\n     * @return none\n     */\n    private function _uncompress($content, $mode, $uncompressed_size, $target_file_name = false)\n    {\n        switch ($mode) {\n            case 0 :\n                return $target_file_name ? file_put_contents($target_file_name, $content) : $content;\n            case 1 :\n                $this->set_error('Shrunk mode is not supported... yet?');\n\n                return false;\n            case 2 :\n            case 3 :\n            case 4 :\n            case 5 :\n                $this->set_error('Compression factor ' . ($mode - 1) . ' is not supported... yet?');\n\n                return false;\n            case 6 :\n                $this->set_error('Implode is not supported... yet?');\n\n                return false;\n            case 7 :\n                $this->set_error('Tokenizing compression algorithm is not supported... yet?');\n\n                return false;\n            case 8 :\n                // Deflate\n                return $target_file_name ? file_put_contents($target_file_name, gzinflate($content, $uncompressed_size)) : gzinflate($content, $uncompressed_size);\n            case 9 :\n                $this->set_error('Enhanced Deflating is not supported... yet?');\n\n                return false;\n            case 10 :\n                $this->set_error('PKWARE Date Compression Library Impoloding is not supported... yet?');\n\n                return false;\n            case 12 :\n                // Bzip2\n                return $target_file_name ? file_put_contents($target_file_name, bzdecompress($content)) : bzdecompress($content);\n            case 18 :\n                $this->set_error('IBM TERSE is not supported... yet?');\n\n                return false;\n            default :\n                $this->set_error('Unknown uncompress method: $mode');\n\n                return false;\n        }\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * What extensions do we want out of this ZIP.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function allow($ext = null)\n    {\n        $this->_allow_extensions = $ext;\n    }\n\n    // --------------------------------------------------------------------\n\n    /**\n     * Show error messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function error_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->error) . $close;\n    }\n\n    /**\n     * Show debug messages.\n     *\n     * @param    string\n     *\n     * @return string\n     */\n    public function debug_string($open = '<p>', $close = '</p>')\n    {\n        return $open . implode($close . $open, $this->info) . $close;\n    }\n\n    /**\n     * Free the file resource Automatic destroy.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function __destroy()\n    {\n        $this->close();\n    }\n\n    /**\n     * Free the file resource.\n     *\n     * @param     none\n     *\n     * @return none\n     */\n    public function close()\n    {\n        // Free the file resource\n        if ($this->fh) {\n            fclose($this->fh);\n        }\n    }\n}\n"], "filenames": ["src/MicroweberPackages/App/functions/plupload.php", "src/MicroweberPackages/Utils/System/Files.php", "src/MicroweberPackages/Utils/Zip/Unzip.php"], "buggy_code_start_loc": [151, 565, 162], "buggy_code_end_loc": [158, 567, 164], "fixing_code_start_loc": [152, 566, 161], "fixing_code_end_loc": [161, 570, 161], "type": "CWE-434", "message": "Unrestricted Upload of File with Dangerous Type in GitHub repository microweber/microweber prior to 1.2.11.", "other": {"cve": {"id": "CVE-2022-0912", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-11T10:15:07.823", "lastModified": "2022-03-18T19:42:51.187", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Unrestricted Upload of File with Dangerous Type in GitHub repository microweber/microweber prior to 1.2.11."}, {"lang": "es", "value": "Una Carga no Restringida de un Archivo de Tipo Peligroso en el repositorio de GitHub microweber/microweber versiones anteriores a 1.2.11"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.8, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.7, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microweber:microweber:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.2.11", "matchCriteriaId": "52D59B39-B1A3-45D1-B4C4-65BEF86F2D85"}]}]}], "references": [{"url": "https://github.com/microweber/microweber/commit/24245297231f5dc88bb3a2b20d0e4e25b0ebc789", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ae5bb359-7e53-498b-848e-540c05b44c54", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/microweber/microweber/commit/24245297231f5dc88bb3a2b20d0e4e25b0ebc789"}}