{"buggy_code": ["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n( function() {\n\tvar removeReservedKeywords;\n\n\t/**\n\t * Represents an HTML data processor, which is responsible for translating and\n\t * transforming the editor data on input and output.\n\t *\n\t * @class\n\t * @extends CKEDITOR.dataProcessor\n\t * @constructor Creates an htmlDataProcessor class instance.\n\t * @param {CKEDITOR.editor} editor\n\t */\n\tCKEDITOR.htmlDataProcessor = function( editor ) {\n\t\tvar dataFilter, htmlFilter,\n\t\t\tthat = this;\n\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * Data filter used when processing input by {@link #toHtml}.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.filter}\n\t\t */\n\t\tthis.dataFilter = dataFilter = new CKEDITOR.htmlParser.filter();\n\n\t\t/**\n\t\t * HTML filter used when processing output by {@link #toDataFormat}.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.filter}\n\t\t */\n\t\tthis.htmlFilter = htmlFilter = new CKEDITOR.htmlParser.filter();\n\n\t\t/**\n\t\t * The HTML writer used by this data processor to format the output.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.basicWriter}\n\t\t */\n\t\tthis.writer = new CKEDITOR.htmlParser.basicWriter();\n\n\t\tdataFilter.addRules( defaultDataFilterRulesEditableOnly );\n\t\tdataFilter.addRules( defaultDataFilterRulesForAll, { applyToAll: true } );\n\t\tdataFilter.addRules( createBogusAndFillerRules( editor, 'data' ), { applyToAll: true } );\n\t\thtmlFilter.addRules( defaultHtmlFilterRulesEditableOnly );\n\t\thtmlFilter.addRules( defaultHtmlFilterRulesForAll, { applyToAll: true } );\n\t\thtmlFilter.addRules( createBogusAndFillerRules( editor, 'html' ), { applyToAll: true } );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tvar evtData = evt.data,\n\t\t\t\tdata = evtData.dataValue,\n\t\t\t\tfixBodyTag;\n\n\t\t\t// Before we start protecting markup, make sure there are no externally injected\n\t\t\t// protection keywords.\n\t\t\tdata = removeReservedKeywords( data );\n\n\t\t\t// The source data is already HTML, but we need to clean\n\t\t\t// it up and apply the filter.\n\t\t\tdata = protectSource( data, editor );\n\n\t\t\t// Protect content of textareas. (https://dev.ckeditor.com/ticket/9995)\n\t\t\t// Do this before protecting attributes to avoid breaking:\n\t\t\t// <textarea><img src=\"...\" /></textarea>\n\t\t\tdata = protectElements( data, protectTextareaRegex );\n\n\t\t\t// Before anything, we must protect the URL attributes as the\n\t\t\t// browser may changing them when setting the innerHTML later in\n\t\t\t// the code.\n\t\t\tdata = protectAttributes( data );\n\n\t\t\t// Protect elements than can't be set inside a DIV. E.g. IE removes\n\t\t\t// style tags from innerHTML. (https://dev.ckeditor.com/ticket/3710)\n\t\t\tdata = protectElements( data, protectElementsRegex );\n\n\t\t\t// Certain elements has problem to go through DOM operation, protect\n\t\t\t// them by prefixing 'cke' namespace. (https://dev.ckeditor.com/ticket/3591)\n\t\t\tdata = protectElementsNames( data );\n\n\t\t\t// All none-IE browsers ignore self-closed custom elements,\n\t\t\t// protecting them into open-close. (https://dev.ckeditor.com/ticket/3591)\n\t\t\tdata = protectSelfClosingElements( data );\n\n\t\t\t// Compensate one leading line break after <pre> open as browsers\n\t\t\t// eat it up. (https://dev.ckeditor.com/ticket/5789)\n\t\t\tdata = protectPreFormatted( data );\n\n\t\t\t// There are attributes which may execute JavaScript code inside fixBin.\n\t\t\t// Encode them greedily. They will be unprotected right after getting HTML from fixBin. (https://dev.ckeditor.com/ticket/10)\n\t\t\tdata = protectInsecureAttributes( data );\n\n\t\t\tvar fixBin = evtData.context || editor.editable().getName(),\n\t\t\t\tisPre;\n\n\t\t\t// Old IEs loose formats when load html into <pre>.\n\t\t\tif ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 && fixBin == 'pre' ) {\n\t\t\t\tfixBin = 'div';\n\t\t\t\tdata = '<pre>' + data + '</pre>';\n\t\t\t\tisPre = 1;\n\t\t\t}\n\n\t\t\t// Call the browser to help us fixing a possibly invalid HTML\n\t\t\t// structure.\n\t\t\tvar el = editor.document.createElement( fixBin );\n\t\t\t// Add fake character to workaround IE comments bug. (https://dev.ckeditor.com/ticket/3801)\n\t\t\tel.setHtml( 'a' + data );\n\t\t\tdata = el.getHtml().substr( 1 );\n\n\t\t\t// Restore shortly protected attribute names.\n\t\t\tdata = data.replace( new RegExp( 'data-cke-' + CKEDITOR.rnd + '-', 'ig' ), '' );\n\n\t\t\tisPre && ( data = data.replace( /^<pre>|<\\/pre>$/gi, '' ) );\n\n\t\t\t// Unprotect \"some\" of the protected elements at this point.\n\t\t\tdata = unprotectElementNames( data );\n\n\t\t\tdata = unprotectElements( data );\n\n\t\t\t// Restore the comments that have been protected, in this way they\n\t\t\t// can be properly filtered.\n\t\t\tdata = unprotectRealComments( data );\n\n\t\t\tif ( evtData.fixForBody === false ) {\n\t\t\t\tfixBodyTag = false;\n\t\t\t} else {\n\t\t\t\tfixBodyTag = getFixBodyTag( evtData.enterMode, editor.config.autoParagraph );\n\t\t\t}\n\n\t\t\t// Now use our parser to make further fixes to the structure, as\n\t\t\t// well as apply the filter.\n\t\t\tdata = CKEDITOR.htmlParser.fragment.fromHtml( data, evtData.context, fixBodyTag );\n\n\t\t\t// The empty root element needs to be fixed by adding 'p' or 'div' into it.\n\t\t\t// This avoids the need to create that element on the first focus (https://dev.ckeditor.com/ticket/12630).\n\t\t\tif ( fixBodyTag ) {\n\t\t\t\tfixEmptyRoot( data, fixBodyTag );\n\t\t\t}\n\n\t\t\tevtData.dataValue = data;\n\t\t}, null, null, 5 );\n\n\t\t// Filter incoming \"data\".\n\t\t// Add element filter before htmlDataProcessor.dataFilter when purifying input data to correct html.\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tif ( evt.data.filter.applyTo( evt.data.dataValue, true, evt.data.dontFilter, evt.data.enterMode ) )\n\t\t\t\teditor.fire( 'dataFiltered' );\n\t\t}, null, null, 6 );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tevt.data.dataValue.filterChildren( that.dataFilter, true );\n\t\t}, null, null, 10 );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tvar evtData = evt.data,\n\t\t\t\tdata = evtData.dataValue,\n\t\t\t\twriter = new CKEDITOR.htmlParser.basicWriter();\n\n\t\t\tdata.writeChildrenHtml( writer );\n\t\t\tdata = writer.getHtml( true );\n\n\t\t\t// Protect the real comments again.\n\t\t\tevtData.dataValue = protectRealComments( data );\n\t\t}, null, null, 15 );\n\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tvar data = evt.data.dataValue;\n\n\t\t\t// https://dev.ckeditor.com/ticket/10854 - we need to strip leading blockless <br> which FF adds\n\t\t\t// automatically when editable contains only non-editable content.\n\t\t\t// We do that for every browser (so it's a constant behavior) and\n\t\t\t// not in BR mode, in which chance of valid leading blockless <br> is higher.\n\t\t\tif ( evt.data.enterMode != CKEDITOR.ENTER_BR )\n\t\t\t\tdata = data.replace( /^<br *\\/?>/i, '' );\n\n\t\t\tevt.data.dataValue = CKEDITOR.htmlParser.fragment.fromHtml(\n\t\t\t\tdata, evt.data.context, getFixBodyTag( evt.data.enterMode, editor.config.autoParagraph ) );\n\t\t}, null, null, 5 );\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tevt.data.dataValue.filterChildren( that.htmlFilter, true );\n\t\t}, null, null, 10 );\n\n\t\t// Transform outcoming \"data\".\n\t\t// Add element filter after htmlDataProcessor.htmlFilter when preparing output data HTML.\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tevt.data.filter.applyTo( evt.data.dataValue, false, true );\n\t\t}, null, null, 11 );\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tvar data = evt.data.dataValue,\n\t\t\t\twriter = that.writer;\n\n\t\t\twriter.reset();\n\t\t\tdata.writeChildrenHtml( writer );\n\t\t\tdata = writer.getHtml( true );\n\n\t\t\t// Restore those non-HTML protected source. (https://dev.ckeditor.com/ticket/4475,https://dev.ckeditor.com/ticket/4880)\n\t\t\tdata = unprotectRealComments( data );\n\t\t\tdata = unprotectSource( data, editor );\n\n\t\t\tevt.data.dataValue = data;\n\t\t}, null, null, 15 );\n\t};\n\n\tCKEDITOR.htmlDataProcessor.prototype = {\n\t\t/**\n\t\t * Processes the (potentially malformed) input HTML to a purified form which\n\t\t * is suitable for using in the WYSIWYG editable.\n\t\t *\n\t\t * This method fires the {@link CKEDITOR.editor#toHtml} event which makes it possible\n\t\t * to hook into the process at various stages.\n\t\t *\n\t\t * **Note:** Since CKEditor 4.3.0 the signature of this method changed and all options\n\t\t * are now grouped in one `options` object. Previously `context`, `fixForBody` and `dontFilter`\n\t\t * were passed separately.\n\t\t *\n\t\t * @param {String} data The raw data.\n\t\t * @param {Object} [options] The options object.\n\t\t * @param {String} [options.context] The tag name of a context element within which\n\t\t * the input is to be processed, defaults to the editable element.\n\t\t * If `null` is passed, then data will be parsed without context (as children of {@link CKEDITOR.htmlParser.fragment}).\n\t\t * See {@link CKEDITOR.htmlParser.fragment#fromHtml} for more details.\n\t\t * @param {Boolean} [options.fixForBody=true] Whether to trigger the auto paragraph for non-block content.\n\t\t * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\n\t\t * the passed instance will be used to filter the content.\n\t\t * @param {Boolean} [options.dontFilter] Do not filter data with {@link CKEDITOR.filter} (note: transformations\n\t\t * will still be applied).\n\t\t * @param {Number} [options.enterMode] When specified, it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\n\t\t * @param {Boolean} [options.protectedWhitespaces] Indicates that content was wrapped with `<span>` elements to preserve\n\t\t * leading and trailing whitespaces. Option used by the {@link CKEDITOR.editor#method-insertHtml} method.\n\t\t * @returns {String}\n\t\t */\n\t\ttoHtml: function( data, options, fixForBody, dontFilter ) {\n\t\t\tvar editor = this.editor,\n\t\t\t\tcontext, filter, enterMode, protectedWhitespaces;\n\n\t\t\t// Typeof null == 'object', so check truthiness of options too.\n\t\t\tif ( options && typeof options == 'object' ) {\n\t\t\t\tcontext = options.context;\n\t\t\t\tfixForBody = options.fixForBody;\n\t\t\t\tdontFilter = options.dontFilter;\n\t\t\t\tfilter = options.filter;\n\t\t\t\tenterMode = options.enterMode;\n\t\t\t\tprotectedWhitespaces = options.protectedWhitespaces;\n\t\t\t}\n\t\t\t// Backward compatibility. Since CKEDITOR 4.3.0 every option was a separate argument.\n\t\t\telse {\n\t\t\t\tcontext = options;\n\t\t\t}\n\n\t\t\t// Fall back to the editable as context if not specified.\n\t\t\tif ( !context && context !== null )\n\t\t\t\tcontext = editor.editable().getName();\n\n\t\t\treturn editor.fire( 'toHtml', {\n\t\t\t\tdataValue: data,\n\t\t\t\tcontext: context,\n\t\t\t\tfixForBody: fixForBody,\n\t\t\t\tdontFilter: dontFilter,\n\t\t\t\tfilter: filter || editor.filter,\n\t\t\t\tenterMode: enterMode || editor.enterMode,\n\t\t\t\tprotectedWhitespaces: protectedWhitespaces\n\t\t\t} ).dataValue;\n\t\t},\n\n\t\t/**\n\t\t * See {@link CKEDITOR.dataProcessor#toDataFormat}.\n\t\t *\n\t\t * This method fires the {@link CKEDITOR.editor#toDataFormat} event which makes it possible\n\t\t * to hook into the process at various stages.\n\t\t *\n\t\t * @param {String} html\n\t\t * @param {Object} [options] The options object.\n\t\t * @param {String} [options.context] The tag name of the context element within which\n\t\t * the input is to be processed, defaults to the editable element.\n\t\t * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\n\t\t * the passed instance will be used to apply content transformations to the content.\n\t\t * @param {Number} [options.enterMode] When specified, it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\n\t\t * @returns {String}\n\t\t */\n\t\ttoDataFormat: function( html, options ) {\n\t\t\tvar context, filter, enterMode;\n\n\t\t\t// Do not shorten this to `options && options.xxx`, because\n\t\t\t// falsy `options` will be passed instead of undefined.\n\t\t\tif ( options ) {\n\t\t\t\tcontext = options.context;\n\t\t\t\tfilter = options.filter;\n\t\t\t\tenterMode = options.enterMode;\n\t\t\t}\n\n\t\t\t// Fall back to the editable as context if not specified.\n\t\t\tif ( !context && context !== null )\n\t\t\t\tcontext = this.editor.editable().getName();\n\n\t\t\treturn this.editor.fire( 'toDataFormat', {\n\t\t\t\tdataValue: html,\n\t\t\t\tfilter: filter || this.editor.filter,\n\t\t\t\tcontext: context,\n\t\t\t\tenterMode: enterMode || this.editor.enterMode\n\t\t\t} ).dataValue;\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.1\n\t\t * @private\n\t\t * @param {String} data\n\t\t */\n\t\tprotectSource: function( data ) {\n\t\t\treturn protectSource( data, this.editor );\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.1\n\t\t * @private\n\t\t * @param {String} html\n\t\t */\n\t\tunprotectSource: function( html ) {\n\t\t\treturn unprotectSource( html, this.editor );\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.2\n\t\t * @private\n\t\t * @param {String} html\n\t\t */\n\t\tunprotectRealComments: function( html ) {\n\t\t\treturn unprotectRealComments( html );\n\t\t}\n\t};\n\n\t// Produce a set of filtering rules that handles bogus and filler node at the\n\t// end of block/pseudo block, in the following consequence:\n\t// 1. elements:<block> - this filter removes any bogus node, then check\n\t// if it's an empty block that requires a filler.\n\t// 2. elements:<br> - After cleaned with bogus, this filter checks the real\n\t// line-break BR to compensate a filler after it.\n\t//\n\t// Terms definitions:\n\t// filler: An element that's either <BR> or &NBSP; at the end of block that established line height.\n\t// bogus: Whenever a filler is proceeded with inline content, it becomes a bogus which is subjected to be removed.\n\t//\n\t// Various forms of the filler:\n\t// In output HTML: Filler should be consistently &NBSP; <BR> at the end of block is always considered as bogus.\n\t// In Wysiwyg HTML: Browser dependent - see env.needsBrFiller. Either BR for when needsBrFiller is true, or &NBSP; otherwise.\n\t// <BR> is NEVER considered as bogus when needsBrFiller is true.\n\tfunction createBogusAndFillerRules( editor, type ) {\n\t\tfunction createFiller( isOutput ) {\n\t\t\treturn isOutput || CKEDITOR.env.needsNbspFiller ?\n\t\t\t\tnew CKEDITOR.htmlParser.text( '\\xa0' ) :\n\t\t\t\tnew CKEDITOR.htmlParser.element( 'br', { 'data-cke-bogus': 1 } );\n\t\t}\n\n\t\t// This text block filter, remove any bogus and create the filler on demand.\n\t\tfunction blockFilter( isOutput, fillEmptyBlock ) {\n\n\t\t\treturn function( block ) {\n\t\t\t\t// DO NOT apply the filler if it's a fragment node.\n\t\t\t\tif ( block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\t\treturn;\n\n\t\t\t\tcleanBogus( block );\n\n\t\t\t\t// Add fillers to input (always) and to output (if fillEmptyBlock is ok with that).\n\t\t\t\tvar shouldFillBlock = !isOutput ||\n\t\t\t\t\t( typeof fillEmptyBlock == 'function' ? fillEmptyBlock( block ) : fillEmptyBlock ) !== false;\n\n\t\t\t\tif ( shouldFillBlock && isEmptyBlockNeedFiller( block ) ) {\n\t\t\t\t\tblock.add( createFiller( isOutput ) );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Append a filler right after the last line-break BR, found at the end of block.\n\t\tfunction brFilter( isOutput ) {\n\t\t\treturn function( br ) {\n\t\t\t\t// DO NOT apply the filer if parent's a fragment node.\n\t\t\t\tif ( br.parent.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\t\treturn;\n\n\t\t\t\tvar attrs = br.attributes;\n\t\t\t\t// Dismiss BRs that are either bogus or eol marker.\n\t\t\t\tif ( 'data-cke-bogus' in attrs || 'data-cke-eol' in attrs ) {\n\t\t\t\t\tdelete attrs [ 'data-cke-bogus' ];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Judge the tail line-break BR, and to insert bogus after it.\n\t\t\t\tvar next = getNext( br ), previous = getPrevious( br );\n\n\t\t\t\tif ( !next && isBlockBoundary( br.parent ) )\n\t\t\t\t\tappend( br.parent, createFiller( isOutput ) );\n\t\t\t\telse if ( isBlockBoundary( next ) && previous && !isBlockBoundary( previous ) )\n\t\t\t\t\tcreateFiller( isOutput ).insertBefore( next );\n\t\t\t};\n\t\t}\n\n\t\t// Determinate whether this node is potentially a bogus node.\n\t\tfunction maybeBogus( node, atBlockEnd ) {\n\n\t\t\t// BR that's not from IE<11 DOM, except for a EOL marker.\n\t\t\tif ( !( isOutput && !CKEDITOR.env.needsBrFiller ) &&\n\t\t\t\t\tnode.type == CKEDITOR.NODE_ELEMENT && node.name == 'br' &&\n\t\t\t\t\t!node.attributes[ 'data-cke-eol' ] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar match;\n\n\t\t\t// NBSP, possibly.\n\t\t\tif ( node.type == CKEDITOR.NODE_TEXT && ( match = node.value.match( tailNbspRegex ) ) ) {\n\t\t\t\t// We need to separate tail NBSP out of a text node, for later removal.\n\t\t\t\tif ( match.index ) {\n\t\t\t\t\t( new CKEDITOR.htmlParser.text( node.value.substring( 0, match.index ) ) ).insertBefore( node );\n\t\t\t\t\tnode.value = match[ 0 ];\n\t\t\t\t}\n\n\t\t\t\t// From IE<11 DOM, at the end of a text block, or before block boundary.\n\t\t\t\tif ( !CKEDITOR.env.needsBrFiller && isOutput && ( !atBlockEnd || node.parent.name in textBlockTags ) )\n\t\t\t\t\treturn true;\n\n\t\t\t\t// From the output.\n\t\t\t\tif ( !isOutput ) {\n\t\t\t\t\tvar previous = node.previous;\n\n\t\t\t\t\t// Following a line-break at the end of block.\n\t\t\t\t\tif ( previous && previous.name == 'br' )\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t// Or a single NBSP between two blocks.\n\t\t\t\t\tif ( !previous || isBlockBoundary( previous ) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// Removes all bogus inside of this block, and to convert fillers into the proper form.\n\t\tfunction cleanBogus( block ) {\n\t\t\tvar bogus = [];\n\t\t\tvar last = getLast( block ), node, previous;\n\n\t\t\tif ( last ) {\n\t\t\t\t// Check for bogus at the end of this block.\n\t\t\t\t// e.g. <p>foo<br /></p>\n\t\t\t\tmaybeBogus( last, 1 ) && bogus.push( last );\n\n\t\t\t\twhile ( last ) {\n\t\t\t\t\t// Check for bogus at the end of any pseudo block contained.\n\t\t\t\t\tif ( isBlockBoundary( last ) && ( node = getPrevious( last ) ) && maybeBogus( node ) ) {\n\t\t\t\t\t\t// Bogus must have inline proceeding, instead single BR between two blocks,\n\t\t\t\t\t\t// is considered as filler, e.g. <hr /><br /><hr />\n\t\t\t\t\t\tif ( ( previous = getPrevious( node ) ) && !isBlockBoundary( previous ) )\n\t\t\t\t\t\t\tbogus.push( node );\n\t\t\t\t\t\t// Convert the filler into appropriate form.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcreateFiller( isOutput ).insertAfter( node );\n\t\t\t\t\t\t\tnode.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlast = last.previous;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now remove all bogus collected from above.\n\t\t\tfor ( var i = 0 ; i < bogus.length ; i++ )\n\t\t\t\tbogus[ i ].remove();\n\t\t}\n\n\t\t// Judge whether it's an empty block that requires a filler node.\n\t\tfunction isEmptyBlockNeedFiller( block ) {\n\n\t\t\t// DO NOT fill empty editable in IE<11.\n\t\t\tif ( !isOutput && !CKEDITOR.env.needsBrFiller && block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\treturn false;\n\n\t\t\t// 1. For IE version >=8,  empty blocks are displayed correctly themself in wysiwiyg;\n\t\t\t// 2. For the rest, at least table cell and list item need no filler space. (https://dev.ckeditor.com/ticket/6248)\n\t\t\tif ( !isOutput && !CKEDITOR.env.needsBrFiller &&\n\t\t\t\t( document.documentMode > 7 ||\n\t\t\t\t\tblock.name in CKEDITOR.dtd.tr ||\n\t\t\t\t\tblock.name in CKEDITOR.dtd.$listItem ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar last = getLast( block );\n\t\t\treturn !last || block.name == 'form' && last.name == 'input' ;\n\t\t}\n\n\t\tvar rules = { elements: {} },\n\t\t\tisOutput = type == 'html',\n\t\t\ttextBlockTags = CKEDITOR.tools.extend( {}, blockLikeTags );\n\n\t\t// Build the list of text blocks.\n\t\tfor ( var i in textBlockTags ) {\n\t\t\tif ( !( '#' in dtd[ i ] ) )\n\t\t\t\tdelete textBlockTags[ i ];\n\t\t}\n\n\t\tfor ( i in textBlockTags )\n\t\t\trules.elements[ i ] = blockFilter( isOutput, editor.config.fillEmptyBlocks );\n\n\t\t// Editable element has to be checked separately.\n\t\trules.root = blockFilter( isOutput, false );\n\t\trules.elements.br = brFilter( isOutput );\n\t\treturn rules;\n\t}\n\n\tfunction getFixBodyTag( enterMode, autoParagraph ) {\n\t\treturn ( enterMode != CKEDITOR.ENTER_BR && autoParagraph !== false ) ? enterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p' : false;\n\t}\n\n\t// Regex to scan for &nbsp; at the end of blocks, which are actually placeholders.\n\t// Safari transforms the &nbsp; to \\xa0. (https://dev.ckeditor.com/ticket/4172)\n\tvar tailNbspRegex = /(?:&nbsp;|\\xa0)$/;\n\n\tvar protectedSourceMarker = '{cke_protected}';\n\n\tfunction getLast( node ) {\n\t\tvar last = node.children[ node.children.length - 1 ];\n\t\twhile ( last && isEmpty( last ) )\n\t\t\tlast = last.previous;\n\t\treturn last;\n\t}\n\n\tfunction getNext( node ) {\n\t\tvar next = node.next;\n\t\twhile ( next && isEmpty( next ) )\n\t\t\tnext = next.next;\n\t\treturn next;\n\t}\n\n\tfunction getPrevious( node ) {\n\t\tvar previous = node.previous;\n\t\twhile ( previous && isEmpty( previous ) )\n\t\t\tprevious = previous.previous;\n\t\treturn previous;\n\t}\n\n\t// Judge whether the node is an ghost node to be ignored, when traversing.\n\tfunction isEmpty( node ) {\n\t\treturn node.type == CKEDITOR.NODE_TEXT &&\n\t\t\t!CKEDITOR.tools.trim( node.value ) ||\n\t\t\tnode.type == CKEDITOR.NODE_ELEMENT &&\n\t\t\tnode.attributes[ 'data-cke-bookmark' ];\n\t}\n\n\t// Judge whether the node is a block-like element.\n\tfunction isBlockBoundary( node ) {\n\t\treturn node &&\n\t\t\t( node.type == CKEDITOR.NODE_ELEMENT && node.name in blockLikeTags ||\n\t\t\tnode.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT );\n\t}\n\n\tfunction append( parent, node ) {\n\t\tvar last = parent.children[ parent.children.length - 1 ];\n\t\tparent.children.push( node );\n\t\tnode.parent = parent;\n\t\tif ( last ) {\n\t\t\tlast.next = node;\n\t\t\tnode.previous = last;\n\t\t}\n\t}\n\n\tfunction getNodeIndex( node ) {\n\t\treturn node.parent ? node.getIndex() : -1;\n\t}\n\n\tvar dtd = CKEDITOR.dtd,\n\t\t// Define orders of table elements.\n\t\ttableOrder = [ 'caption', 'colgroup', 'col', 'thead', 'tfoot', 'tbody' ],\n\t\t// List of all block elements.\n\t\tblockLikeTags = CKEDITOR.tools.extend( {}, dtd.$blockLimit, dtd.$block );\n\n\t//\n\t// DATA filter rules ------------------------------------------------------\n\t//\n\n\tvar defaultDataFilterRulesEditableOnly = {\n\t\telements: {\n\t\t\tinput: protectReadOnly,\n\t\t\ttextarea: protectReadOnly\n\t\t}\n\t};\n\n\t// These rules will also be applied to non-editable content.\n\tvar defaultDataFilterRulesForAll = {\n\t\tattributeNames: [\n\t\t\t// Event attributes (onXYZ) must not be directly set. They can become\n\t\t\t// active in the editing area (IE|WebKit).\n\t\t\t[ ( /^on/ ), 'data-cke-pa-on' ],\n\n\t\t\t// Prevent iframe's srcdoc attribute from being evaluated in the editable.\n\t\t\t[ ( /^srcdoc/ ), 'data-cke-pa-srcdoc' ],\n\n\t\t\t// Don't let some old expando enter editor. Concerns only IE8,\n\t\t\t// but for consistency remove on all browsers.\n\t\t\t[ ( /^data-cke-expando$/ ), '' ]\n\t\t],\n\n\t\telements: {\n\t\t\t// Prevent iframe's src attribute with javascript code or data protocol from being evaluated in the editable.\n\t\t\tiframe: function( element ) {\n\t\t\t\tif ( element.attributes && element.attributes.src ) {\n\n\t\t\t\t\tvar src = element.attributes.src.toLowerCase().replace( /[^a-z]/gi, '' );\n\t\t\t\t\tif ( src.indexOf( 'javascript' ) === 0 || src.indexOf( 'data' ) === 0 ) {\n\t\t\t\t\t\telement.attributes[ 'data-cke-pa-src' ] = element.attributes.src;\n\t\t\t\t\t\tdelete element.attributes.src;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Disable form elements editing mode provided by some browsers. (https://dev.ckeditor.com/ticket/5746)\n\tfunction protectReadOnly( element ) {\n\t\tvar attrs = element.attributes;\n\n\t\t// We should flag that the element was locked by our code so\n\t\t// it'll be editable by the editor functions (https://dev.ckeditor.com/ticket/6046).\n\t\tif ( attrs.contenteditable != 'false' )\n\t\t\tattrs[ 'data-cke-editable' ] = attrs.contenteditable ? 'true' : 1;\n\n\t\tattrs.contenteditable = 'false';\n\t}\n\n\t//\n\t// HTML filter rules ------------------------------------------------------\n\t//\n\n\tvar defaultHtmlFilterRulesEditableOnly = {\n\t\telements: {\n\t\t\tembed: function( element ) {\n\t\t\t\tvar parent = element.parent;\n\n\t\t\t\t// If the <embed> is child of a <object>, copy the width\n\t\t\t\t// and height attributes from it.\n\t\t\t\tif ( parent && parent.name == 'object' ) {\n\t\t\t\t\tvar parentWidth = parent.attributes.width,\n\t\t\t\t\t\tparentHeight = parent.attributes.height;\n\t\t\t\t\tif ( parentWidth )\n\t\t\t\t\t\telement.attributes.width = parentWidth;\n\t\t\t\t\tif ( parentHeight )\n\t\t\t\t\t\telement.attributes.height = parentHeight;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Remove empty link but not empty anchor. (https://dev.ckeditor.com/ticket/3829, https://dev.ckeditor.com/ticket/13516)\n\t\t\ta: function( element ) {\n\t\t\t\tvar attrs = element.attributes;\n\n\t\t\t\tif ( !( element.children.length || attrs.name || attrs.id || element.attributes[ 'data-cke-saved-name' ] ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n\n\t// These rules will also be applied to non-editable content.\n\tvar defaultHtmlFilterRulesForAll = {\n\t\telementNames: [\n\t\t\t// Remove the \"cke:\" namespace prefix.\n\t\t\t[ ( /^cke:/ ), '' ],\n\n\t\t\t// Ignore <?xml:namespace> tags.\n\t\t\t[ ( /^\\?xml:namespace$/ ), '' ]\n\t\t],\n\n\t\tattributeNames: [\n\t\t\t// Attributes saved for changes and protected attributes.\n\t\t\t[ ( /^data-cke-(saved|pa)-/ ), '' ],\n\n\t\t\t// All \"data-cke-\" attributes are to be ignored.\n\t\t\t[ ( /^data-cke-.*/ ), '' ],\n\n\t\t\t[ 'hidefocus', '' ]\n\t\t],\n\n\t\telements: {\n\t\t\t$: function( element ) {\n\t\t\t\tvar attribs = element.attributes;\n\n\t\t\t\tif ( attribs ) {\n\t\t\t\t\t// Elements marked as temporary are to be ignored.\n\t\t\t\t\tif ( attribs[ 'data-cke-temp' ] )\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t// Remove duplicated attributes - https://dev.ckeditor.com/ticket/3789.\n\t\t\t\t\tvar attributeNames = [ 'name', 'href', 'src' ],\n\t\t\t\t\t\tsavedAttributeName;\n\t\t\t\t\tfor ( var i = 0; i < attributeNames.length; i++ ) {\n\t\t\t\t\t\tsavedAttributeName = 'data-cke-saved-' + attributeNames[ i ];\n\t\t\t\t\t\tsavedAttributeName in attribs && ( delete attribs[ attributeNames[ i ] ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn element;\n\t\t\t},\n\n\t\t\t// The contents of table should be in correct order (https://dev.ckeditor.com/ticket/4809).\n\t\t\ttable: function( element ) {\n\t\t\t\t// Clone the array as it would become empty during the sort call.\n\t\t\t\tvar children = element.children.slice( 0 );\n\n\t\t\t\tchildren.sort( function( node1, node2 ) {\n\t\t\t\t\tvar index1, index2;\n\n\t\t\t\t\t// Compare in the predefined order.\n\t\t\t\t\tif ( node1.type == CKEDITOR.NODE_ELEMENT && node2.type == node1.type ) {\n\t\t\t\t\t\tindex1 = CKEDITOR.tools.indexOf( tableOrder, node1.name );\n\t\t\t\t\t\tindex2 = CKEDITOR.tools.indexOf( tableOrder, node2.name );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make sure the sort is stable, if no order can be established above.\n\t\t\t\t\tif ( !( index1 > -1 && index2 > -1 && index1 != index2 ) ) {\n\t\t\t\t\t\tindex1 = getNodeIndex( node1 );\n\t\t\t\t\t\tindex2 = getNodeIndex( node2 );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn index1 > index2 ? 1 : -1;\n\t\t\t\t} );\n\t\t\t},\n\n\t\t\t// Restore param elements into self-closing.\n\t\t\tparam: function( param ) {\n\t\t\t\tparam.children = [];\n\t\t\t\tparam.isEmpty = true;\n\t\t\t\treturn param;\n\t\t\t},\n\n\t\t\t// Remove dummy span in webkit.\n\t\t\tspan: function( element ) {\n\t\t\t\tif ( element.attributes[ 'class' ] == 'Apple-style-span' )\n\t\t\t\t\tdelete element.name;\n\t\t\t},\n\n\t\t\thtml: function( element ) {\n\t\t\t\tdelete element.attributes.contenteditable;\n\t\t\t\tdelete element.attributes[ 'class' ];\n\t\t\t},\n\n\t\t\tbody: function( element ) {\n\t\t\t\tdelete element.attributes.spellcheck;\n\t\t\t\tdelete element.attributes.contenteditable;\n\t\t\t},\n\n\t\t\tstyle: function( element ) {\n\t\t\t\tvar child = element.children[ 0 ];\n\t\t\t\tif ( child && child.value )\n\t\t\t\t\tchild.value = CKEDITOR.tools.trim( child.value );\n\n\t\t\t\tif ( !element.attributes.type )\n\t\t\t\t\telement.attributes.type = 'text/css';\n\t\t\t},\n\n\t\t\ttitle: function( element ) {\n\t\t\t\tvar titleText = element.children[ 0 ];\n\n\t\t\t\t// Append text-node to title tag if not present (i.e. non-IEs) (https://dev.ckeditor.com/ticket/9882).\n\t\t\t\t!titleText && append( element, titleText = new CKEDITOR.htmlParser.text() );\n\n\t\t\t\t// Transfer data-saved title to title tag.\n\t\t\t\ttitleText.value = element.attributes[ 'data-cke-title' ] || '';\n\t\t\t},\n\n\t\t\tinput: unprotectReadyOnly,\n\t\t\ttextarea: unprotectReadyOnly\n\t\t},\n\n\t\tattributes: {\n\t\t\t'class': function( value ) {\n\t\t\t\t// Remove all class names starting with \"cke_\".\n\t\t\t\treturn CKEDITOR.tools.ltrim( value.replace( /(?:^|\\s+)cke_[^\\s]*/g, '' ) ) || false;\n\t\t\t}\n\t\t}\n\t};\n\n\tif ( CKEDITOR.env.ie ) {\n\t\t// IE outputs style attribute in capital letters. We should convert\n\t\t// them back to lower case, while not hurting the values (https://dev.ckeditor.com/ticket/5930)\n\t\tdefaultHtmlFilterRulesForAll.attributes.style = function( value ) {\n\t\t\treturn value.replace( /(^|;)([^\\:]+)/g, function( match ) {\n\t\t\t\treturn match.toLowerCase();\n\t\t\t} );\n\t\t};\n\t}\n\n\t// Disable form elements editing mode provided by some browsers. (https://dev.ckeditor.com/ticket/5746)\n\tfunction unprotectReadyOnly( element ) {\n\t\tvar attrs = element.attributes;\n\t\tswitch ( attrs[ 'data-cke-editable' ] ) {\n\t\t\tcase 'true':\n\t\t\t\tattrs.contenteditable = 'true';\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tdelete attrs.contenteditable;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//\n\t// Preprocessor filters ---------------------------------------------------\n\t//\n\n\tvar protectElementRegex = /<(a|area|img|input|source)\\b([^>]*)>/gi,\n\t\t// Be greedy while looking for protected attributes. This will let us avoid an unfortunate\n\t\t// situation when \"nested attributes\", which may appear valid, are also protected.\n\t\t// I.e. if we consider the following HTML:\n\t\t//\n\t\t// \t<img data-x=\"&lt;a href=&quot;X&quot;\" />\n\t\t//\n\t\t// then the \"non-greedy match\" returns:\n\t\t//\n\t\t// \t'href' => '&quot;X&quot;' // It's wrong! Href is not an attribute of <img>.\n\t\t//\n\t\t// while greedy match returns:\n\t\t//\n\t\t// \t'data-x' => '&lt;a href=&quot;X&quot;'\n\t\t//\n\t\t// which, can be easily filtered out (https://dev.ckeditor.com/ticket/11508).\n\t\tprotectAttributeRegex = /([\\w-:]+)\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|(?:[^ \"'>]+))/gi,\n\t\tprotectAttributeNameRegex = /^(href|src|name)$/i;\n\n\t\t// Note: we use lazy star '*?' to prevent eating everything up to the last occurrence of </style> or </textarea>.\n\tvar protectElementsRegex = /(?:<style(?=[ >])[^>]*>[\\s\\S]*?<\\/style>)|(?:<(:?link|meta|base)[^>]*>)/gi,\n\t\tprotectTextareaRegex = /(<textarea(?=[ >])[^>]*>)([\\s\\S]*?)(?:<\\/textarea>)/gi,\n\t\tencodedElementsRegex = /<cke:encoded>([^<]*)<\\/cke:encoded>/gi;\n\n\t\t// Element name should be followed by space or closing angle bracket '>' to not protect custom tags (#988).\n\tvar protectElementNamesRegex = /(<\\/?)((?:object|embed|param|html|body|head|title)([\\s][^>]*)?>)/gi,\n\t\tunprotectElementNamesRegex = /(<\\/?)cke:((?:html|body|head|title)[^>]*>)/gi;\n\n\tvar protectSelfClosingRegex = /<cke:(param|embed)([^>]*?)\\/?>(?!\\s*<\\/cke:\\1)/gi;\n\n\tfunction protectAttributes( html ) {\n\t\treturn html.replace( protectElementRegex, function( element, tag, attributes ) {\n\t\t\treturn '<' + tag + attributes.replace( protectAttributeRegex, function( fullAttr, attrName ) {\n\t\t\t\t// Avoid corrupting the inline event attributes (https://dev.ckeditor.com/ticket/7243).\n\t\t\t\t// We should not rewrite the existed protected attributes, e.g. clipboard content from editor. (https://dev.ckeditor.com/ticket/5218)\n\t\t\t\tif ( protectAttributeNameRegex.test( attrName ) && attributes.indexOf( 'data-cke-saved-' + attrName ) == -1 )\n\t\t\t\t\treturn ' data-cke-saved-' + fullAttr + ' data-cke-' + CKEDITOR.rnd + '-' + fullAttr;\n\n\t\t\t\treturn fullAttr;\n\t\t\t} ) + '>';\n\t\t} );\n\t}\n\n\tfunction protectElements( html, regex ) {\n\t\treturn html.replace( regex, function( match, tag, content ) {\n\t\t\t// Encode < and > in textarea because this won't be done by a browser, since\n\t\t\t// textarea will be protected during passing data through fix bin.\n\t\t\tif ( match.indexOf( '<textarea' ) === 0 )\n\t\t\t\tmatch = tag + unprotectRealComments( content ).replace( /</g, '&lt;' ).replace( />/g, '&gt;' ) + '</textarea>';\n\n\t\t\treturn '<cke:encoded>' + encodeURIComponent( match ) + '</cke:encoded>';\n\t\t} );\n\t}\n\n\tfunction unprotectElements( html ) {\n\t\treturn html.replace( encodedElementsRegex, function( match, encoded ) {\n\t\t\treturn decodeURIComponent( encoded );\n\t\t} );\n\t}\n\n\tfunction protectElementsNames( html ) {\n\t\treturn html.replace( protectElementNamesRegex, '$1cke:$2' );\n\t}\n\n\tfunction unprotectElementNames( html ) {\n\t\treturn html.replace( unprotectElementNamesRegex, '$1$2' );\n\t}\n\n\tfunction protectSelfClosingElements( html ) {\n\t\treturn html.replace( protectSelfClosingRegex, '<cke:$1$2></cke:$1>' );\n\t}\n\n\tfunction protectPreFormatted( html ) {\n\t\treturn html.replace( /(<pre\\b[^>]*>)(\\r\\n|\\n)/g, '$1$2$2' );\n\t}\n\n\tfunction protectRealComments( html ) {\n\t\treturn html.replace( /<!--(?!{cke_protected})[\\s\\S]+?-->/g, function( match ) {\n\t\t\treturn '<!--' + protectedSourceMarker +\n\t\t\t\t'{C}' +\n\t\t\t\tencodeURIComponent( match ).replace( /--/g, '%2D%2D' ) +\n\t\t\t\t'-->';\n\t\t} );\n\t}\n\n\t// Replace all \"on\\w{3,}\" strings which are not:\n\t// * opening tags - e.g. `<onfoo`,\n\t// * closing tags - e.g. </onfoo> (tested in \"false positive 1\"),\n\t// * part of other attribute - e.g. `data-onfoo` or `fonfoo`.\n\tfunction protectInsecureAttributes( html ) {\n\t\treturn html.replace( /([^a-z0-9<\\-])(on\\w{3,})(?!>)/gi, '$1data-cke-' + CKEDITOR.rnd + '-$2' );\n\t}\n\n\tfunction unprotectRealComments( html ) {\n\t\treturn html.replace( /<!--\\{cke_protected\\}\\{C\\}([\\s\\S]+?)-->/g, function( match, data ) {\n\t\t\treturn decodeURIComponent( data );\n\t\t} );\n\t}\n\n\tfunction unprotectSource( html, editor ) {\n\t\tvar store = editor._.dataStore;\n\n\t\treturn html.replace( /<!--\\{cke_protected\\}([\\s\\S]+?)-->/g, function( match, data ) {\n\t\t\treturn decodeURIComponent( data );\n\t\t} ).replace( /\\{cke_protected_(\\d+)\\}/g, function( match, id ) {\n\t\t\treturn store && store[ id ] || '';\n\t\t} );\n\t}\n\n\tfunction protectSource( data, editor ) {\n\t\tvar protectedHtml = [],\n\t\t\tprotectRegexes = editor.config.protectedSource,\n\t\t\tstore = editor._.dataStore || ( editor._.dataStore = { id: 1 } ),\n\t\t\ttempRegex = /<\\!--\\{cke_temp(comment)?\\}(\\d*?)-->/g;\n\n\t\tvar regexes = [\n\t\t\t// Script tags will also be forced to be protected, otherwise\n\t\t\t// IE will execute them.\n\t\t\t( /<script[\\s\\S]*?(<\\/script>|$)/gi ),\n\n\t\t\t// <noscript> tags (get lost in IE and messed up in FF).\n\t\t\t/<noscript[\\s\\S]*?<\\/noscript>/gi,\n\n\t\t\t// Avoid meta tags being stripped (https://dev.ckeditor.com/ticket/8117).\n\t\t\t/<meta[\\s\\S]*?\\/?>/gi\n\t\t].concat( protectRegexes );\n\n\t\t// First of any other protection, we must protect all comments\n\t\t// to avoid loosing them (of course, IE related).\n\t\t// Note that we use a different tag for comments, as we need to\n\t\t// transform them when applying filters.\n\t\tdata = data.replace( ( /<!--[\\s\\S]*?-->/g ), function( match ) {\n\t\t\treturn '<!--{cke_tempcomment}' + ( protectedHtml.push( match ) - 1 ) + '-->';\n\t\t} );\n\n\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\tdata = data.replace( regexes[ i ], function( match ) {\n\t\t\t\tmatch = match.replace( tempRegex, // There could be protected source inside another one. (https://dev.ckeditor.com/ticket/3869).\n\t\t\t\tfunction( $, isComment, id ) {\n\t\t\t\t\treturn protectedHtml[ id ];\n\t\t\t\t} );\n\n\t\t\t\t// Avoid protecting over protected, e.g. /\\{.*?\\}/\n\t\t\t\treturn ( /cke_temp(comment)?/ ).test( match ) ? match : '<!--{cke_temp}' + ( protectedHtml.push( match ) - 1 ) + '-->';\n\t\t\t} );\n\t\t}\n\t\tdata = data.replace( tempRegex, function( $, isComment, id ) {\n\t\t\treturn '<!--' + protectedSourceMarker +\n\t\t\t\t( isComment ? '{C}' : '' ) +\n\t\t\t\tencodeURIComponent( protectedHtml[ id ] ).replace( /--/g, '%2D%2D' ) +\n\t\t\t\t'-->';\n\t\t} );\n\n\t\t// Different protection pattern is used for those that\n\t\t// live in attributes to avoid from being HTML encoded.\n\t\t// Why so serious? See https://dev.ckeditor.com/ticket/9205, https://dev.ckeditor.com/ticket/8216, https://dev.ckeditor.com/ticket/7805,\n\t\t// https://dev.ckeditor.com/ticket/11754, https://dev.ckeditor.com/ticket/11846.\n\t\tdata = data.replace( /<\\w+(?:\\s+(?:(?:[^\\s=>]+\\s*=\\s*(?:[^'\"\\s>]+|'[^']*'|\"[^\"]*\"))|[^\\s=\\/>]+))+\\s*\\/?>/g, function( match ) {\n\t\t\treturn match.replace( /<!--\\{cke_protected\\}([^>]*)-->/g, function( match, data ) {\n\t\t\t\tstore[ store.id ] = decodeURIComponent( data );\n\t\t\t\treturn '{cke_protected_' + ( store.id++ ) + '}';\n\t\t\t} );\n\t\t} );\n\n\t\t// This RegExp searches for innerText in all the title/iframe/textarea elements.\n\t\t// This is because browser doesn't allow HTML in these elements, that's why we can't\n\t\t// nest comments in there. (https://dev.ckeditor.com/ticket/11223)\n\t\tdata = data.replace( /<(title|iframe|textarea)([^>]*)>([\\s\\S]*?)<\\/\\1>/g, function( match, tagName, tagAttributes, innerText ) {\n\t\t\treturn '<' + tagName + tagAttributes + '>' + unprotectSource( unprotectRealComments( innerText ), editor ) + '</' + tagName + '>';\n\t\t} );\n\n\t\treturn data;\n\t}\n\n\t// Creates a block if the root element is empty.\n\tfunction fixEmptyRoot( root, fixBodyTag ) {\n\t\tif ( !root.children.length && CKEDITOR.dtd[ root.name ][ fixBodyTag ] ) {\n\t\t\tvar fixBodyElement = new CKEDITOR.htmlParser.element( fixBodyTag );\n\t\t\troot.add( fixBodyElement );\n\t\t}\n\t}\n\n\t// Removes reserved htmldataprocessor keywords ensuring that they are only used internally.\n\t// This function produces very complicated regex code. Using IIFE ensures that the regex\n\t// is build only once for this module.\n\tremoveReservedKeywords = ( function() {\n\t\tvar regexes = [\n\t\t\tcreateEncodedKeywordRegex(),\n\t\t\tcreateSourceKeywordRegex(),\n\t\t\tcreateIncorrectCommentRegex()\n\t\t];\n\n\t\treturn function( data ) {\n\t\t\twhile( isContentMatchingAnyPattern( regexes, data ) ) {\n\t\t\t\tdata = removeMatchingContent( regexes, data );\n\t\t\t}\n\n\t\t\treturn data;\n\t\t};\n\n\t\tfunction isContentMatchingAnyPattern( regexes, data ) {\n\t\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\t\tvar regex = regexes[ i ];\n\n\t\t\t\tregex.lastIndex = 0;\n\n\t\t\t\tif ( regex.test( data ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction removeMatchingContent( regexes, data ) {\n\t\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\t\tdata = data.replace( regexes[ i ], '' );\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction createIncorrectCommentRegex() {\n\t\t\treturn /<!(?:\\s*-\\s*){2,3}!?\\s*>/g;\n\t\t}\n\n\t\t// Produces regex matching `cke:encoded` element.\n\t\tfunction createEncodedKeywordRegex() {\n\t\t\treturn new RegExp( '(' +\n\t\t\t\t// Create closed element regex i.e `<cke:encoded>xxx</cke:encoded>`.\n\t\t\t\tcreateEncodedRegex( '<cke:encoded>' ) +\n\t\t\t\t'(.*?)' +\n\t\t\t\tcreateEncodedRegex( '</cke:encoded>' ) +\n\t\t\t\t')|(' +\n\t\t\t\t// Create unclosed element regex i.e `<cke:encoded>xxx` or `xxx</cke:encoded>` to make sure that\n\t\t\t\t// element won't be closed by HTML parser and matched by `unprotectElements` function.\n\t\t\t\tcreateEncodedRegex( '<' ) +\n\t\t\t\tcreateEncodedRegex( '/' ) + '?' +\n\t\t\t\tcreateEncodedRegex( 'cke:encoded>' ) +\n\t\t\t\t')', 'gi' );\n\t\t}\n\n\t\t// Produces regex matching `{cke_protected}` and `{cke_protected_id}` keywords.\n\t\tfunction createSourceKeywordRegex() {\n\t\t\treturn new RegExp( '((' +\n\t\t\t\tcreateEncodedRegex( '{cke_protected' ) +\n\t\t\t\t')(_[0-9]*)?' +\n\t\t\t\tcreateEncodedRegex( '}' ) +\n\t\t\t\t')' , 'gi' );\n\t\t}\n\n\t\tfunction createEncodedRegex( str ) {\n\t\t\treturn CKEDITOR.tools.array.reduce( str.split( '' ), function( cur, character ) {\n\t\t\t\t// Produce case insensitive regex. `i` flag is not enough thus code entities differs\n\t\t\t\t// depending on case sensitivity.\n\t\t\t\tvar lowerCase = character.toLowerCase(),\n\t\t\t\t\tupperCase = character.toUpperCase(),\n\t\t\t\t\tregex = createCharacterEncodedRegex( lowerCase );\n\n\t\t\t\tif ( lowerCase !== upperCase ) {\n\t\t\t\t\tregex += '|' + createCharacterEncodedRegex( upperCase );\n\t\t\t\t}\n\n\t\t\t\tcur += '(' + regex + ')';\n\n\t\t\t\treturn cur;\n\t\t\t}, '' );\n\t\t}\n\n\t\tfunction createCharacterEncodedRegex( character ) {\n\t\t\tvar map = getCharRegexMap( character ),\n\t\t\t\tcharRegex = character;\n\n\t\t\tfor ( var code in map ) {\n\t\t\t\tif ( map[ code ] ) {\n\t\t\t\t\tcharRegex += '|' + map[ code ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn charRegex;\n\t\t}\n\n\t\tfunction getCharRegexMap( character ) {\n\t\t\tvar entities = {\n\t\t\t\t'<': '&lt;',\n\t\t\t\t'>': '&gt;',\n\t\t\t\t':': '&colon;'\n\t\t\t},\n\t\t\t\tcharCode = character.charCodeAt( 0 ),\n\t\t\t\thex = charCode.toString( 16 );\n\n\t\t\treturn {\n\t\t\t\t// `;` is optional and HTML parser is able to recognize codes without it.\n\t\t\t\thtmlCode: '&#' + charCode + ';?',\n\t\t\t\t// Hexadecimal value is valid despite leading zero padding e.g. `&#x0065` === `&#x65`.\n\t\t\t\thex: '&#x0*' + hex + ';?',\n\t\t\t\tentity: entities[ character ]\n\t\t\t};\n\t\t}\n\t} )();\n} )();\n\n/**\n * Whether a filler text (non-breaking space entity &mdash; `&nbsp;`) will be\n * inserted into empty block elements in HTML output.\n * This is used to render block elements properly with `line-height`.\n * When a function is specified instead, it will be passed a {@link CKEDITOR.htmlParser.element}\n * to decide whether adding the filler text by expecting a Boolean return value.\n *\n *\t\tconfig.fillEmptyBlocks = false; // Prevent filler nodes in all empty blocks.\n *\n *\t\t// Prevent filler node only in float cleaners.\n *\t\tconfig.fillEmptyBlocks = function( element ) {\n *\t\t\tif ( element.attributes[ 'class' ].indexOf( 'clear-both' ) != -1 )\n *\t\t\t\treturn false;\n *\t\t};\n *\n * @since 3.5.0\n * @cfg {Boolean/Function} [fillEmptyBlocks=true]\n * @member CKEDITOR.config\n */\n\n/**\n * This event is fired by the {@link CKEDITOR.htmlDataProcessor} when input HTML\n * is to be purified by the {@link CKEDITOR.htmlDataProcessor#toHtml} method.\n *\n * By adding listeners with different priorities it is possible\n * to process input HTML on different stages:\n *\n *\t* 1-4: Data is available in the original string format.\n *\t* 5: Data is initially filtered with regexp patterns and parsed to\n *\t\t{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\n *\t* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#dataFilter}\n *\t\tis not applied yet.\n *\t* 6: Data is filtered with the {@link CKEDITOR.filter content filter}.\n *\t* 10: Data is processed with {@link CKEDITOR.htmlDataProcessor#dataFilter}.\n *\t* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#dataFilter}\n *\t\thas already been applied.\n *\t* 15: Data is written back to an HTML string.\n *\t* 15-*: Data is available in an HTML string.\n *\n * For example to be able to process parsed, but not yet filtered data add listener this way:\n *\n *\t\teditor.on( 'toHtml', function( evt) {\n *\t\t\tevt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\n *\t\t}, null, null, 7 );\n *\n * @since 4.1.0\n * @event toHtml\n * @member CKEDITOR.editor\n * @param {CKEDITOR.editor} editor This editor instance.\n * @param data\n * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Input data to be purified.\n * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toHtml} The `context` argument.\n * @param {Boolean} data.fixForBody See {@link CKEDITOR.htmlDataProcessor#toHtml} The `fixForBody` argument.\n * @param {Boolean} data.dontFilter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `dontFilter` argument.\n * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `filter` argument.\n * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toHtml} The `enterMode` argument.\n * @param {Boolean} [data.protectedWhitespaces] See {@link CKEDITOR.htmlDataProcessor#toHtml} The `protectedWhitespaces` argument.\n */\n\n/**\n * This event is fired when {@link CKEDITOR.htmlDataProcessor} is converting\n * internal HTML to output data HTML.\n *\n * By adding listeners with different priorities it is possible\n * to process input HTML on different stages:\n *\n *\t* 1-4: Data is available in the original string format.\n *\t* 5: Data is initially filtered with regexp patterns and parsed to\n *\t\t{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\n *\t* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#htmlFilter}\n *\t\tis not applied yet.\n *\t* 10: Data is filtered with {@link CKEDITOR.htmlDataProcessor#htmlFilter}.\n *  * 11: Data is filtered with the {CKEDITOR.filter content filter} (on output the content filter makes\n *\t\tonly transformations, without filtering).\n *\t* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#htmlFilter}\n *\t\thas already been applied.\n *\t* 15: Data is written back to an HTML string.\n *\t* 15-*: Data is available in an HTML string.\n *\n * For example to be able to process parsed and already processed data add listener this way:\n *\n *\t\teditor.on( 'toDataFormat', function( evt) {\n *\t\t\tevt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\n *\t\t}, null, null, 12 );\n *\n * @since 4.1.0\n * @event toDataFormat\n * @member CKEDITOR.editor\n * @param {CKEDITOR.editor} editor This editor instance.\n * @param data\n * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Output data to be prepared.\n * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `context` argument.\n * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `filter` argument.\n * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `enterMode` argument.\n */\n"], "fixing_code": ["/**\n * @license Copyright (c) 2003-2022, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\n\n( function() {\n\tvar removeReservedKeywords;\n\n\t/**\n\t * Represents an HTML data processor, which is responsible for translating and\n\t * transforming the editor data on input and output.\n\t *\n\t * @class\n\t * @extends CKEDITOR.dataProcessor\n\t * @constructor Creates an htmlDataProcessor class instance.\n\t * @param {CKEDITOR.editor} editor\n\t */\n\tCKEDITOR.htmlDataProcessor = function( editor ) {\n\t\tvar dataFilter, htmlFilter,\n\t\t\tthat = this;\n\n\t\tthis.editor = editor;\n\n\t\t/**\n\t\t * Data filter used when processing input by {@link #toHtml}.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.filter}\n\t\t */\n\t\tthis.dataFilter = dataFilter = new CKEDITOR.htmlParser.filter();\n\n\t\t/**\n\t\t * HTML filter used when processing output by {@link #toDataFormat}.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.filter}\n\t\t */\n\t\tthis.htmlFilter = htmlFilter = new CKEDITOR.htmlParser.filter();\n\n\t\t/**\n\t\t * The HTML writer used by this data processor to format the output.\n\t\t *\n\t\t * @property {CKEDITOR.htmlParser.basicWriter}\n\t\t */\n\t\tthis.writer = new CKEDITOR.htmlParser.basicWriter();\n\n\t\tdataFilter.addRules( defaultDataFilterRulesEditableOnly );\n\t\tdataFilter.addRules( defaultDataFilterRulesForAll, { applyToAll: true } );\n\t\tdataFilter.addRules( createBogusAndFillerRules( editor, 'data' ), { applyToAll: true } );\n\t\thtmlFilter.addRules( defaultHtmlFilterRulesEditableOnly );\n\t\thtmlFilter.addRules( defaultHtmlFilterRulesForAll, { applyToAll: true } );\n\t\thtmlFilter.addRules( createBogusAndFillerRules( editor, 'html' ), { applyToAll: true } );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tvar randomNumber = generateRandomNumber(),\n\t\t\t\tevtData = evt.data,\n\t\t\t\tdata = evtData.dataValue,\n\t\t\t\tfixBodyTag;\n\n\t\t\t// Before we start protecting markup, make sure there are no externally injected\n\t\t\t// protection keywords.\n\t\t\tdata = removeReservedKeywords( data, randomNumber );\n\n\t\t\t// The source data is already HTML, but we need to clean\n\t\t\t// it up and apply the filter.\n\t\t\tdata = protectSource( data, editor, randomNumber );\n\n\t\t\t// Protect content of textareas. (https://dev.ckeditor.com/ticket/9995)\n\t\t\t// Do this before protecting attributes to avoid breaking:\n\t\t\t// <textarea><img src=\"...\" /></textarea>\n\t\t\tdata = protectElements( data, protectTextareaRegex );\n\n\t\t\t// Before anything, we must protect the URL attributes as the\n\t\t\t// browser may changing them when setting the innerHTML later in\n\t\t\t// the code.\n\t\t\tdata = protectAttributes( data, randomNumber );\n\n\t\t\t// Protect elements than can't be set inside a DIV. E.g. IE removes\n\t\t\t// style tags from innerHTML. (https://dev.ckeditor.com/ticket/3710)\n\t\t\tdata = protectElements( data, protectElementsRegex );\n\n\t\t\t// Certain elements has problem to go through DOM operation, protect\n\t\t\t// them by prefixing 'cke' namespace. (https://dev.ckeditor.com/ticket/3591)\n\t\t\tdata = protectElementsNames( data );\n\n\t\t\t// All none-IE browsers ignore self-closed custom elements,\n\t\t\t// protecting them into open-close. (https://dev.ckeditor.com/ticket/3591)\n\t\t\tdata = protectSelfClosingElements( data );\n\n\t\t\t// Compensate one leading line break after <pre> open as browsers\n\t\t\t// eat it up. (https://dev.ckeditor.com/ticket/5789)\n\t\t\tdata = protectPreFormatted( data );\n\n\t\t\t// There are attributes which may execute JavaScript code inside fixBin.\n\t\t\t// Encode them greedily. They will be unprotected right after getting HTML from fixBin. (https://dev.ckeditor.com/ticket/10)\n\t\t\tdata = protectInsecureAttributes( data, randomNumber );\n\n\t\t\tvar fixBin = evtData.context || editor.editable().getName(),\n\t\t\t\tisPre;\n\n\t\t\t// Old IEs loose formats when load html into <pre>.\n\t\t\tif ( CKEDITOR.env.ie && CKEDITOR.env.version < 9 && fixBin == 'pre' ) {\n\t\t\t\tfixBin = 'div';\n\t\t\t\tdata = '<pre>' + data + '</pre>';\n\t\t\t\tisPre = 1;\n\t\t\t}\n\n\t\t\t// Call the browser to help us fixing a possibly invalid HTML\n\t\t\t// structure.\n\t\t\tvar el = editor.document.createElement( fixBin );\n\t\t\t// Add fake character to workaround IE comments bug. (https://dev.ckeditor.com/ticket/3801)\n\t\t\tel.setHtml( 'a' + data );\n\t\t\tdata = el.getHtml().substr( 1 );\n\n\t\t\t// Restore shortly protected attribute names.\n\t\t\tdata = data.replace( new RegExp( 'data-cke-' + randomNumber + '-', 'ig' ), '' );\n\n\t\t\tisPre && ( data = data.replace( /^<pre>|<\\/pre>$/gi, '' ) );\n\n\t\t\t// Unprotect \"some\" of the protected elements at this point.\n\t\t\tdata = unprotectElementNames( data );\n\n\t\t\tdata = unprotectElements( data );\n\n\t\t\t// Restore the comments that have been protected, in this way they\n\t\t\t// can be properly filtered.\n\t\t\tdata = unprotectRealComments( data );\n\n\t\t\tif ( evtData.fixForBody === false ) {\n\t\t\t\tfixBodyTag = false;\n\t\t\t} else {\n\t\t\t\tfixBodyTag = getFixBodyTag( evtData.enterMode, editor.config.autoParagraph );\n\t\t\t}\n\n\t\t\t// Now use our parser to make further fixes to the structure, as\n\t\t\t// well as apply the filter.\n\t\t\tdata = CKEDITOR.htmlParser.fragment.fromHtml( data, evtData.context, fixBodyTag );\n\n\t\t\t// The empty root element needs to be fixed by adding 'p' or 'div' into it.\n\t\t\t// This avoids the need to create that element on the first focus (https://dev.ckeditor.com/ticket/12630).\n\t\t\tif ( fixBodyTag ) {\n\t\t\t\tfixEmptyRoot( data, fixBodyTag );\n\t\t\t}\n\n\t\t\tevtData.dataValue = data;\n\t\t}, null, null, 5 );\n\n\t\t// Filter incoming \"data\".\n\t\t// Add element filter before htmlDataProcessor.dataFilter when purifying input data to correct html.\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tif ( evt.data.filter.applyTo( evt.data.dataValue, true, evt.data.dontFilter, evt.data.enterMode ) )\n\t\t\t\teditor.fire( 'dataFiltered' );\n\t\t}, null, null, 6 );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tevt.data.dataValue.filterChildren( that.dataFilter, true );\n\t\t}, null, null, 10 );\n\n\t\teditor.on( 'toHtml', function( evt ) {\n\t\t\tvar evtData = evt.data,\n\t\t\t\tdata = evtData.dataValue,\n\t\t\t\twriter = new CKEDITOR.htmlParser.basicWriter();\n\n\t\t\tdata.writeChildrenHtml( writer );\n\t\t\tdata = writer.getHtml( true );\n\n\t\t\t// Protect the real comments again.\n\t\t\tevtData.dataValue = protectRealComments( data );\n\t\t}, null, null, 15 );\n\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tvar data = evt.data.dataValue;\n\n\t\t\t// https://dev.ckeditor.com/ticket/10854 - we need to strip leading blockless <br> which FF adds\n\t\t\t// automatically when editable contains only non-editable content.\n\t\t\t// We do that for every browser (so it's a constant behavior) and\n\t\t\t// not in BR mode, in which chance of valid leading blockless <br> is higher.\n\t\t\tif ( evt.data.enterMode != CKEDITOR.ENTER_BR )\n\t\t\t\tdata = data.replace( /^<br *\\/?>/i, '' );\n\n\t\t\tevt.data.dataValue = CKEDITOR.htmlParser.fragment.fromHtml(\n\t\t\t\tdata, evt.data.context, getFixBodyTag( evt.data.enterMode, editor.config.autoParagraph ) );\n\t\t}, null, null, 5 );\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tevt.data.dataValue.filterChildren( that.htmlFilter, true );\n\t\t}, null, null, 10 );\n\n\t\t// Transform outcoming \"data\".\n\t\t// Add element filter after htmlDataProcessor.htmlFilter when preparing output data HTML.\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tevt.data.filter.applyTo( evt.data.dataValue, false, true );\n\t\t}, null, null, 11 );\n\n\t\teditor.on( 'toDataFormat', function( evt ) {\n\t\t\tvar data = evt.data.dataValue,\n\t\t\t\twriter = that.writer;\n\n\t\t\twriter.reset();\n\t\t\tdata.writeChildrenHtml( writer );\n\t\t\tdata = writer.getHtml( true );\n\n\t\t\t// Restore those non-HTML protected source. (https://dev.ckeditor.com/ticket/4475,https://dev.ckeditor.com/ticket/4880)\n\t\t\tdata = unprotectRealComments( data );\n\t\t\tdata = unprotectSource( data, editor );\n\n\t\t\tevt.data.dataValue = data;\n\t\t}, null, null, 15 );\n\t};\n\n\tCKEDITOR.htmlDataProcessor.prototype = {\n\t\t/**\n\t\t * Processes the (potentially malformed) input HTML to a purified form which\n\t\t * is suitable for using in the WYSIWYG editable.\n\t\t *\n\t\t * This method fires the {@link CKEDITOR.editor#toHtml} event which makes it possible\n\t\t * to hook into the process at various stages.\n\t\t *\n\t\t * **Note:** Since CKEditor 4.3.0 the signature of this method changed and all options\n\t\t * are now grouped in one `options` object. Previously `context`, `fixForBody` and `dontFilter`\n\t\t * were passed separately.\n\t\t *\n\t\t * @param {String} data The raw data.\n\t\t * @param {Object} [options] The options object.\n\t\t * @param {String} [options.context] The tag name of a context element within which\n\t\t * the input is to be processed, defaults to the editable element.\n\t\t * If `null` is passed, then data will be parsed without context (as children of {@link CKEDITOR.htmlParser.fragment}).\n\t\t * See {@link CKEDITOR.htmlParser.fragment#fromHtml} for more details.\n\t\t * @param {Boolean} [options.fixForBody=true] Whether to trigger the auto paragraph for non-block content.\n\t\t * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\n\t\t * the passed instance will be used to filter the content.\n\t\t * @param {Boolean} [options.dontFilter] Do not filter data with {@link CKEDITOR.filter} (note: transformations\n\t\t * will still be applied).\n\t\t * @param {Number} [options.enterMode] When specified, it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\n\t\t * @param {Boolean} [options.protectedWhitespaces] Indicates that content was wrapped with `<span>` elements to preserve\n\t\t * leading and trailing whitespaces. Option used by the {@link CKEDITOR.editor#method-insertHtml} method.\n\t\t * @returns {String}\n\t\t */\n\t\ttoHtml: function( data, options, fixForBody, dontFilter ) {\n\t\t\tvar editor = this.editor,\n\t\t\t\tcontext, filter, enterMode, protectedWhitespaces;\n\n\t\t\t// Typeof null == 'object', so check truthiness of options too.\n\t\t\tif ( options && typeof options == 'object' ) {\n\t\t\t\tcontext = options.context;\n\t\t\t\tfixForBody = options.fixForBody;\n\t\t\t\tdontFilter = options.dontFilter;\n\t\t\t\tfilter = options.filter;\n\t\t\t\tenterMode = options.enterMode;\n\t\t\t\tprotectedWhitespaces = options.protectedWhitespaces;\n\t\t\t}\n\t\t\t// Backward compatibility. Since CKEDITOR 4.3.0 every option was a separate argument.\n\t\t\telse {\n\t\t\t\tcontext = options;\n\t\t\t}\n\n\t\t\t// Fall back to the editable as context if not specified.\n\t\t\tif ( !context && context !== null )\n\t\t\t\tcontext = editor.editable().getName();\n\n\t\t\treturn editor.fire( 'toHtml', {\n\t\t\t\tdataValue: data,\n\t\t\t\tcontext: context,\n\t\t\t\tfixForBody: fixForBody,\n\t\t\t\tdontFilter: dontFilter,\n\t\t\t\tfilter: filter || editor.filter,\n\t\t\t\tenterMode: enterMode || editor.enterMode,\n\t\t\t\tprotectedWhitespaces: protectedWhitespaces\n\t\t\t} ).dataValue;\n\t\t},\n\n\t\t/**\n\t\t * See {@link CKEDITOR.dataProcessor#toDataFormat}.\n\t\t *\n\t\t * This method fires the {@link CKEDITOR.editor#toDataFormat} event which makes it possible\n\t\t * to hook into the process at various stages.\n\t\t *\n\t\t * @param {String} html\n\t\t * @param {Object} [options] The options object.\n\t\t * @param {String} [options.context] The tag name of the context element within which\n\t\t * the input is to be processed, defaults to the editable element.\n\t\t * @param {CKEDITOR.filter} [options.filter] When specified, instead of using the {@link CKEDITOR.editor#filter main filter},\n\t\t * the passed instance will be used to apply content transformations to the content.\n\t\t * @param {Number} [options.enterMode] When specified, it will be used instead of the {@link CKEDITOR.editor#enterMode main enterMode}.\n\t\t * @returns {String}\n\t\t */\n\t\ttoDataFormat: function( html, options ) {\n\t\t\tvar context, filter, enterMode;\n\n\t\t\t// Do not shorten this to `options && options.xxx`, because\n\t\t\t// falsy `options` will be passed instead of undefined.\n\t\t\tif ( options ) {\n\t\t\t\tcontext = options.context;\n\t\t\t\tfilter = options.filter;\n\t\t\t\tenterMode = options.enterMode;\n\t\t\t}\n\n\t\t\t// Fall back to the editable as context if not specified.\n\t\t\tif ( !context && context !== null )\n\t\t\t\tcontext = this.editor.editable().getName();\n\n\t\t\treturn this.editor.fire( 'toDataFormat', {\n\t\t\t\tdataValue: html,\n\t\t\t\tfilter: filter || this.editor.filter,\n\t\t\t\tcontext: context,\n\t\t\t\tenterMode: enterMode || this.editor.enterMode\n\t\t\t} ).dataValue;\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.1\n\t\t * @private\n\t\t * @param {String} data\n\t\t */\n\t\tprotectSource: function( data ) {\n\t\t\treturn protectSource( data, this.editor );\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.1\n\t\t * @private\n\t\t * @param {String} html\n\t\t */\n\t\tunprotectSource: function( html ) {\n\t\t\treturn unprotectSource( html, this.editor );\n\t\t},\n\n\t\t/**\n\t\t * @since 4.16.2\n\t\t * @private\n\t\t * @param {String} html\n\t\t */\n\t\tunprotectRealComments: function( html ) {\n\t\t\treturn unprotectRealComments( html );\n\t\t}\n\t};\n\n\t// Produce a set of filtering rules that handles bogus and filler node at the\n\t// end of block/pseudo block, in the following consequence:\n\t// 1. elements:<block> - this filter removes any bogus node, then check\n\t// if it's an empty block that requires a filler.\n\t// 2. elements:<br> - After cleaned with bogus, this filter checks the real\n\t// line-break BR to compensate a filler after it.\n\t//\n\t// Terms definitions:\n\t// filler: An element that's either <BR> or &NBSP; at the end of block that established line height.\n\t// bogus: Whenever a filler is proceeded with inline content, it becomes a bogus which is subjected to be removed.\n\t//\n\t// Various forms of the filler:\n\t// In output HTML: Filler should be consistently &NBSP; <BR> at the end of block is always considered as bogus.\n\t// In Wysiwyg HTML: Browser dependent - see env.needsBrFiller. Either BR for when needsBrFiller is true, or &NBSP; otherwise.\n\t// <BR> is NEVER considered as bogus when needsBrFiller is true.\n\tfunction createBogusAndFillerRules( editor, type ) {\n\t\tfunction createFiller( isOutput ) {\n\t\t\treturn isOutput || CKEDITOR.env.needsNbspFiller ?\n\t\t\t\tnew CKEDITOR.htmlParser.text( '\\xa0' ) :\n\t\t\t\tnew CKEDITOR.htmlParser.element( 'br', { 'data-cke-bogus': 1 } );\n\t\t}\n\n\t\t// This text block filter, remove any bogus and create the filler on demand.\n\t\tfunction blockFilter( isOutput, fillEmptyBlock ) {\n\n\t\t\treturn function( block ) {\n\t\t\t\t// DO NOT apply the filler if it's a fragment node.\n\t\t\t\tif ( block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\t\treturn;\n\n\t\t\t\tcleanBogus( block );\n\n\t\t\t\t// Add fillers to input (always) and to output (if fillEmptyBlock is ok with that).\n\t\t\t\tvar shouldFillBlock = !isOutput ||\n\t\t\t\t\t( typeof fillEmptyBlock == 'function' ? fillEmptyBlock( block ) : fillEmptyBlock ) !== false;\n\n\t\t\t\tif ( shouldFillBlock && isEmptyBlockNeedFiller( block ) ) {\n\t\t\t\t\tblock.add( createFiller( isOutput ) );\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\t// Append a filler right after the last line-break BR, found at the end of block.\n\t\tfunction brFilter( isOutput ) {\n\t\t\treturn function( br ) {\n\t\t\t\t// DO NOT apply the filer if parent's a fragment node.\n\t\t\t\tif ( br.parent.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\t\treturn;\n\n\t\t\t\tvar attrs = br.attributes;\n\t\t\t\t// Dismiss BRs that are either bogus or eol marker.\n\t\t\t\tif ( 'data-cke-bogus' in attrs || 'data-cke-eol' in attrs ) {\n\t\t\t\t\tdelete attrs [ 'data-cke-bogus' ];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Judge the tail line-break BR, and to insert bogus after it.\n\t\t\t\tvar next = getNext( br ), previous = getPrevious( br );\n\n\t\t\t\tif ( !next && isBlockBoundary( br.parent ) )\n\t\t\t\t\tappend( br.parent, createFiller( isOutput ) );\n\t\t\t\telse if ( isBlockBoundary( next ) && previous && !isBlockBoundary( previous ) )\n\t\t\t\t\tcreateFiller( isOutput ).insertBefore( next );\n\t\t\t};\n\t\t}\n\n\t\t// Determinate whether this node is potentially a bogus node.\n\t\tfunction maybeBogus( node, atBlockEnd ) {\n\n\t\t\t// BR that's not from IE<11 DOM, except for a EOL marker.\n\t\t\tif ( !( isOutput && !CKEDITOR.env.needsBrFiller ) &&\n\t\t\t\t\tnode.type == CKEDITOR.NODE_ELEMENT && node.name == 'br' &&\n\t\t\t\t\t!node.attributes[ 'data-cke-eol' ] ) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar match;\n\n\t\t\t// NBSP, possibly.\n\t\t\tif ( node.type == CKEDITOR.NODE_TEXT && ( match = node.value.match( tailNbspRegex ) ) ) {\n\t\t\t\t// We need to separate tail NBSP out of a text node, for later removal.\n\t\t\t\tif ( match.index ) {\n\t\t\t\t\t( new CKEDITOR.htmlParser.text( node.value.substring( 0, match.index ) ) ).insertBefore( node );\n\t\t\t\t\tnode.value = match[ 0 ];\n\t\t\t\t}\n\n\t\t\t\t// From IE<11 DOM, at the end of a text block, or before block boundary.\n\t\t\t\tif ( !CKEDITOR.env.needsBrFiller && isOutput && ( !atBlockEnd || node.parent.name in textBlockTags ) )\n\t\t\t\t\treturn true;\n\n\t\t\t\t// From the output.\n\t\t\t\tif ( !isOutput ) {\n\t\t\t\t\tvar previous = node.previous;\n\n\t\t\t\t\t// Following a line-break at the end of block.\n\t\t\t\t\tif ( previous && previous.name == 'br' )\n\t\t\t\t\t\treturn true;\n\n\t\t\t\t\t// Or a single NBSP between two blocks.\n\t\t\t\t\tif ( !previous || isBlockBoundary( previous ) )\n\t\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t// Removes all bogus inside of this block, and to convert fillers into the proper form.\n\t\tfunction cleanBogus( block ) {\n\t\t\tvar bogus = [];\n\t\t\tvar last = getLast( block ), node, previous;\n\n\t\t\tif ( last ) {\n\t\t\t\t// Check for bogus at the end of this block.\n\t\t\t\t// e.g. <p>foo<br /></p>\n\t\t\t\tmaybeBogus( last, 1 ) && bogus.push( last );\n\n\t\t\t\twhile ( last ) {\n\t\t\t\t\t// Check for bogus at the end of any pseudo block contained.\n\t\t\t\t\tif ( isBlockBoundary( last ) && ( node = getPrevious( last ) ) && maybeBogus( node ) ) {\n\t\t\t\t\t\t// Bogus must have inline proceeding, instead single BR between two blocks,\n\t\t\t\t\t\t// is considered as filler, e.g. <hr /><br /><hr />\n\t\t\t\t\t\tif ( ( previous = getPrevious( node ) ) && !isBlockBoundary( previous ) )\n\t\t\t\t\t\t\tbogus.push( node );\n\t\t\t\t\t\t// Convert the filler into appropriate form.\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcreateFiller( isOutput ).insertAfter( node );\n\t\t\t\t\t\t\tnode.remove();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tlast = last.previous;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Now remove all bogus collected from above.\n\t\t\tfor ( var i = 0 ; i < bogus.length ; i++ )\n\t\t\t\tbogus[ i ].remove();\n\t\t}\n\n\t\t// Judge whether it's an empty block that requires a filler node.\n\t\tfunction isEmptyBlockNeedFiller( block ) {\n\n\t\t\t// DO NOT fill empty editable in IE<11.\n\t\t\tif ( !isOutput && !CKEDITOR.env.needsBrFiller && block.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT )\n\t\t\t\treturn false;\n\n\t\t\t// 1. For IE version >=8,  empty blocks are displayed correctly themself in wysiwiyg;\n\t\t\t// 2. For the rest, at least table cell and list item need no filler space. (https://dev.ckeditor.com/ticket/6248)\n\t\t\tif ( !isOutput && !CKEDITOR.env.needsBrFiller &&\n\t\t\t\t( document.documentMode > 7 ||\n\t\t\t\t\tblock.name in CKEDITOR.dtd.tr ||\n\t\t\t\t\tblock.name in CKEDITOR.dtd.$listItem ) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tvar last = getLast( block );\n\t\t\treturn !last || block.name == 'form' && last.name == 'input' ;\n\t\t}\n\n\t\tvar rules = { elements: {} },\n\t\t\tisOutput = type == 'html',\n\t\t\ttextBlockTags = CKEDITOR.tools.extend( {}, blockLikeTags );\n\n\t\t// Build the list of text blocks.\n\t\tfor ( var i in textBlockTags ) {\n\t\t\tif ( !( '#' in dtd[ i ] ) )\n\t\t\t\tdelete textBlockTags[ i ];\n\t\t}\n\n\t\tfor ( i in textBlockTags )\n\t\t\trules.elements[ i ] = blockFilter( isOutput, editor.config.fillEmptyBlocks );\n\n\t\t// Editable element has to be checked separately.\n\t\trules.root = blockFilter( isOutput, false );\n\t\trules.elements.br = brFilter( isOutput );\n\t\treturn rules;\n\t}\n\n\tfunction getFixBodyTag( enterMode, autoParagraph ) {\n\t\treturn ( enterMode != CKEDITOR.ENTER_BR && autoParagraph !== false ) ? enterMode == CKEDITOR.ENTER_DIV ? 'div' : 'p' : false;\n\t}\n\n\t// Regex to scan for &nbsp; at the end of blocks, which are actually placeholders.\n\t// Safari transforms the &nbsp; to \\xa0. (https://dev.ckeditor.com/ticket/4172)\n\tvar tailNbspRegex = /(?:&nbsp;|\\xa0)$/;\n\n\tvar protectedSourceMarker = '{cke_protected}';\n\n\tfunction getLast( node ) {\n\t\tvar last = node.children[ node.children.length - 1 ];\n\t\twhile ( last && isEmpty( last ) )\n\t\t\tlast = last.previous;\n\t\treturn last;\n\t}\n\n\tfunction getNext( node ) {\n\t\tvar next = node.next;\n\t\twhile ( next && isEmpty( next ) )\n\t\t\tnext = next.next;\n\t\treturn next;\n\t}\n\n\tfunction getPrevious( node ) {\n\t\tvar previous = node.previous;\n\t\twhile ( previous && isEmpty( previous ) )\n\t\t\tprevious = previous.previous;\n\t\treturn previous;\n\t}\n\n\t// Judge whether the node is an ghost node to be ignored, when traversing.\n\tfunction isEmpty( node ) {\n\t\treturn node.type == CKEDITOR.NODE_TEXT &&\n\t\t\t!CKEDITOR.tools.trim( node.value ) ||\n\t\t\tnode.type == CKEDITOR.NODE_ELEMENT &&\n\t\t\tnode.attributes[ 'data-cke-bookmark' ];\n\t}\n\n\t// Judge whether the node is a block-like element.\n\tfunction isBlockBoundary( node ) {\n\t\treturn node &&\n\t\t\t( node.type == CKEDITOR.NODE_ELEMENT && node.name in blockLikeTags ||\n\t\t\tnode.type == CKEDITOR.NODE_DOCUMENT_FRAGMENT );\n\t}\n\n\tfunction append( parent, node ) {\n\t\tvar last = parent.children[ parent.children.length - 1 ];\n\t\tparent.children.push( node );\n\t\tnode.parent = parent;\n\t\tif ( last ) {\n\t\t\tlast.next = node;\n\t\t\tnode.previous = last;\n\t\t}\n\t}\n\n\tfunction getNodeIndex( node ) {\n\t\treturn node.parent ? node.getIndex() : -1;\n\t}\n\n\tvar dtd = CKEDITOR.dtd,\n\t\t// Define orders of table elements.\n\t\ttableOrder = [ 'caption', 'colgroup', 'col', 'thead', 'tfoot', 'tbody' ],\n\t\t// List of all block elements.\n\t\tblockLikeTags = CKEDITOR.tools.extend( {}, dtd.$blockLimit, dtd.$block );\n\n\t//\n\t// DATA filter rules ------------------------------------------------------\n\t//\n\n\tvar defaultDataFilterRulesEditableOnly = {\n\t\telements: {\n\t\t\tinput: protectReadOnly,\n\t\t\ttextarea: protectReadOnly\n\t\t}\n\t};\n\n\t// These rules will also be applied to non-editable content.\n\tvar defaultDataFilterRulesForAll = {\n\t\tattributeNames: [\n\t\t\t// Event attributes (onXYZ) must not be directly set. They can become\n\t\t\t// active in the editing area (IE|WebKit).\n\t\t\t[ ( /^on/ ), 'data-cke-pa-on' ],\n\n\t\t\t// Prevent iframe's srcdoc attribute from being evaluated in the editable.\n\t\t\t[ ( /^srcdoc/ ), 'data-cke-pa-srcdoc' ],\n\n\t\t\t// Don't let some old expando enter editor. Concerns only IE8,\n\t\t\t// but for consistency remove on all browsers.\n\t\t\t[ ( /^data-cke-expando$/ ), '' ]\n\t\t],\n\n\t\telements: {\n\t\t\t// Prevent iframe's src attribute with javascript code or data protocol from being evaluated in the editable.\n\t\t\tiframe: function( element ) {\n\t\t\t\tif ( element.attributes && element.attributes.src ) {\n\n\t\t\t\t\tvar src = element.attributes.src.toLowerCase().replace( /[^a-z]/gi, '' );\n\t\t\t\t\tif ( src.indexOf( 'javascript' ) === 0 || src.indexOf( 'data' ) === 0 ) {\n\t\t\t\t\t\telement.attributes[ 'data-cke-pa-src' ] = element.attributes.src;\n\t\t\t\t\t\tdelete element.attributes.src;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Disable form elements editing mode provided by some browsers. (https://dev.ckeditor.com/ticket/5746)\n\tfunction protectReadOnly( element ) {\n\t\tvar attrs = element.attributes;\n\n\t\t// We should flag that the element was locked by our code so\n\t\t// it'll be editable by the editor functions (https://dev.ckeditor.com/ticket/6046).\n\t\tif ( attrs.contenteditable != 'false' )\n\t\t\tattrs[ 'data-cke-editable' ] = attrs.contenteditable ? 'true' : 1;\n\n\t\tattrs.contenteditable = 'false';\n\t}\n\n\t//\n\t// HTML filter rules ------------------------------------------------------\n\t//\n\n\tvar defaultHtmlFilterRulesEditableOnly = {\n\t\telements: {\n\t\t\tembed: function( element ) {\n\t\t\t\tvar parent = element.parent;\n\n\t\t\t\t// If the <embed> is child of a <object>, copy the width\n\t\t\t\t// and height attributes from it.\n\t\t\t\tif ( parent && parent.name == 'object' ) {\n\t\t\t\t\tvar parentWidth = parent.attributes.width,\n\t\t\t\t\t\tparentHeight = parent.attributes.height;\n\t\t\t\t\tif ( parentWidth )\n\t\t\t\t\t\telement.attributes.width = parentWidth;\n\t\t\t\t\tif ( parentHeight )\n\t\t\t\t\t\telement.attributes.height = parentHeight;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// Remove empty link but not empty anchor. (https://dev.ckeditor.com/ticket/3829, https://dev.ckeditor.com/ticket/13516)\n\t\t\ta: function( element ) {\n\t\t\t\tvar attrs = element.attributes;\n\n\t\t\t\tif ( !( element.children.length || attrs.name || attrs.id || element.attributes[ 'data-cke-saved-name' ] ) )\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t};\n\n\t// These rules will also be applied to non-editable content.\n\tvar defaultHtmlFilterRulesForAll = {\n\t\telementNames: [\n\t\t\t// Remove the \"cke:\" namespace prefix.\n\t\t\t[ ( /^cke:/ ), '' ],\n\n\t\t\t// Ignore <?xml:namespace> tags.\n\t\t\t[ ( /^\\?xml:namespace$/ ), '' ]\n\t\t],\n\n\t\tattributeNames: [\n\t\t\t// Attributes saved for changes and protected attributes.\n\t\t\t[ ( /^data-cke-(saved|pa)-/ ), '' ],\n\n\t\t\t// All \"data-cke-\" attributes are to be ignored.\n\t\t\t[ ( /^data-cke-.*/ ), '' ],\n\n\t\t\t[ 'hidefocus', '' ]\n\t\t],\n\n\t\telements: {\n\t\t\t$: function( element ) {\n\t\t\t\tvar attribs = element.attributes;\n\n\t\t\t\tif ( attribs ) {\n\t\t\t\t\t// Elements marked as temporary are to be ignored.\n\t\t\t\t\tif ( attribs[ 'data-cke-temp' ] )\n\t\t\t\t\t\treturn false;\n\n\t\t\t\t\t// Remove duplicated attributes - https://dev.ckeditor.com/ticket/3789.\n\t\t\t\t\tvar attributeNames = [ 'name', 'href', 'src' ],\n\t\t\t\t\t\tsavedAttributeName;\n\t\t\t\t\tfor ( var i = 0; i < attributeNames.length; i++ ) {\n\t\t\t\t\t\tsavedAttributeName = 'data-cke-saved-' + attributeNames[ i ];\n\t\t\t\t\t\tsavedAttributeName in attribs && ( delete attribs[ attributeNames[ i ] ] );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn element;\n\t\t\t},\n\n\t\t\t// The contents of table should be in correct order (https://dev.ckeditor.com/ticket/4809).\n\t\t\ttable: function( element ) {\n\t\t\t\t// Clone the array as it would become empty during the sort call.\n\t\t\t\tvar children = element.children.slice( 0 );\n\n\t\t\t\tchildren.sort( function( node1, node2 ) {\n\t\t\t\t\tvar index1, index2;\n\n\t\t\t\t\t// Compare in the predefined order.\n\t\t\t\t\tif ( node1.type == CKEDITOR.NODE_ELEMENT && node2.type == node1.type ) {\n\t\t\t\t\t\tindex1 = CKEDITOR.tools.indexOf( tableOrder, node1.name );\n\t\t\t\t\t\tindex2 = CKEDITOR.tools.indexOf( tableOrder, node2.name );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Make sure the sort is stable, if no order can be established above.\n\t\t\t\t\tif ( !( index1 > -1 && index2 > -1 && index1 != index2 ) ) {\n\t\t\t\t\t\tindex1 = getNodeIndex( node1 );\n\t\t\t\t\t\tindex2 = getNodeIndex( node2 );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn index1 > index2 ? 1 : -1;\n\t\t\t\t} );\n\t\t\t},\n\n\t\t\t// Restore param elements into self-closing.\n\t\t\tparam: function( param ) {\n\t\t\t\tparam.children = [];\n\t\t\t\tparam.isEmpty = true;\n\t\t\t\treturn param;\n\t\t\t},\n\n\t\t\t// Remove dummy span in webkit.\n\t\t\tspan: function( element ) {\n\t\t\t\tif ( element.attributes[ 'class' ] == 'Apple-style-span' )\n\t\t\t\t\tdelete element.name;\n\t\t\t},\n\n\t\t\thtml: function( element ) {\n\t\t\t\tdelete element.attributes.contenteditable;\n\t\t\t\tdelete element.attributes[ 'class' ];\n\t\t\t},\n\n\t\t\tbody: function( element ) {\n\t\t\t\tdelete element.attributes.spellcheck;\n\t\t\t\tdelete element.attributes.contenteditable;\n\t\t\t},\n\n\t\t\tstyle: function( element ) {\n\t\t\t\tvar child = element.children[ 0 ];\n\t\t\t\tif ( child && child.value )\n\t\t\t\t\tchild.value = CKEDITOR.tools.trim( child.value );\n\n\t\t\t\tif ( !element.attributes.type )\n\t\t\t\t\telement.attributes.type = 'text/css';\n\t\t\t},\n\n\t\t\ttitle: function( element ) {\n\t\t\t\tvar titleText = element.children[ 0 ];\n\n\t\t\t\t// Append text-node to title tag if not present (i.e. non-IEs) (https://dev.ckeditor.com/ticket/9882).\n\t\t\t\t!titleText && append( element, titleText = new CKEDITOR.htmlParser.text() );\n\n\t\t\t\t// Transfer data-saved title to title tag.\n\t\t\t\ttitleText.value = element.attributes[ 'data-cke-title' ] || '';\n\t\t\t},\n\n\t\t\tinput: unprotectReadyOnly,\n\t\t\ttextarea: unprotectReadyOnly\n\t\t},\n\n\t\tattributes: {\n\t\t\t'class': function( value ) {\n\t\t\t\t// Remove all class names starting with \"cke_\".\n\t\t\t\treturn CKEDITOR.tools.ltrim( value.replace( /(?:^|\\s+)cke_[^\\s]*/g, '' ) ) || false;\n\t\t\t}\n\t\t}\n\t};\n\n\tif ( CKEDITOR.env.ie ) {\n\t\t// IE outputs style attribute in capital letters. We should convert\n\t\t// them back to lower case, while not hurting the values (https://dev.ckeditor.com/ticket/5930)\n\t\tdefaultHtmlFilterRulesForAll.attributes.style = function( value ) {\n\t\t\treturn value.replace( /(^|;)([^\\:]+)/g, function( match ) {\n\t\t\t\treturn match.toLowerCase();\n\t\t\t} );\n\t\t};\n\t}\n\n\t// Disable form elements editing mode provided by some browsers. (https://dev.ckeditor.com/ticket/5746)\n\tfunction unprotectReadyOnly( element ) {\n\t\tvar attrs = element.attributes;\n\t\tswitch ( attrs[ 'data-cke-editable' ] ) {\n\t\t\tcase 'true':\n\t\t\t\tattrs.contenteditable = 'true';\n\t\t\t\tbreak;\n\t\t\tcase '1':\n\t\t\t\tdelete attrs.contenteditable;\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t//\n\t// Preprocessor filters ---------------------------------------------------\n\t//\n\n\tvar protectElementRegex = /<(a|area|img|input|source)\\b([^>]*)>/gi,\n\t\t// Be greedy while looking for protected attributes. This will let us avoid an unfortunate\n\t\t// situation when \"nested attributes\", which may appear valid, are also protected.\n\t\t// I.e. if we consider the following HTML:\n\t\t//\n\t\t// \t<img data-x=\"&lt;a href=&quot;X&quot;\" />\n\t\t//\n\t\t// then the \"non-greedy match\" returns:\n\t\t//\n\t\t// \t'href' => '&quot;X&quot;' // It's wrong! Href is not an attribute of <img>.\n\t\t//\n\t\t// while greedy match returns:\n\t\t//\n\t\t// \t'data-x' => '&lt;a href=&quot;X&quot;'\n\t\t//\n\t\t// which, can be easily filtered out (https://dev.ckeditor.com/ticket/11508).\n\t\tprotectAttributeRegex = /([\\w-:]+)\\s*=\\s*(?:(?:\"[^\"]*\")|(?:'[^']*')|(?:[^ \"'>]+))/gi,\n\t\tprotectAttributeNameRegex = /^(href|src|name)$/i;\n\n\t\t// Note: we use lazy star '*?' to prevent eating everything up to the last occurrence of </style> or </textarea>.\n\tvar protectElementsRegex = /(?:<style(?=[ >])[^>]*>[\\s\\S]*?<\\/style>)|(?:<(:?link|meta|base)[^>]*>)/gi,\n\t\tprotectTextareaRegex = /(<textarea(?=[ >])[^>]*>)([\\s\\S]*?)(?:<\\/textarea>)/gi,\n\t\tencodedElementsRegex = /<cke:encoded>([^<]*)<\\/cke:encoded>/gi;\n\n\t\t// Element name should be followed by space or closing angle bracket '>' to not protect custom tags (#988).\n\tvar protectElementNamesRegex = /(<\\/?)((?:object|embed|param|html|body|head|title)([\\s][^>]*)?>)/gi,\n\t\tunprotectElementNamesRegex = /(<\\/?)cke:((?:html|body|head|title)[^>]*>)/gi;\n\n\tvar protectSelfClosingRegex = /<cke:(param|embed)([^>]*?)\\/?>(?!\\s*<\\/cke:\\1)/gi;\n\n\tfunction protectAttributes( html, randomNumber ) {\n\t\treturn html.replace( protectElementRegex, function( element, tag, attributes ) {\n\t\t\treturn '<' + tag + attributes.replace( protectAttributeRegex, function( fullAttr, attrName ) {\n\t\t\t\t// Avoid corrupting the inline event attributes (https://dev.ckeditor.com/ticket/7243).\n\t\t\t\t// We should not rewrite the existed protected attributes, e.g. clipboard content from editor. (https://dev.ckeditor.com/ticket/5218)\n\t\t\t\tif ( protectAttributeNameRegex.test( attrName ) && attributes.indexOf( 'data-cke-saved-' + attrName ) == -1 )\n\t\t\t\t\treturn ' data-cke-saved-' + fullAttr + ' data-cke-' + randomNumber + '-' + fullAttr;\n\n\t\t\t\treturn fullAttr;\n\t\t\t} ) + '>';\n\t\t} );\n\t}\n\n\tfunction protectElements( html, regex ) {\n\t\treturn html.replace( regex, function( match, tag, content ) {\n\t\t\t// Encode < and > in textarea because this won't be done by a browser, since\n\t\t\t// textarea will be protected during passing data through fix bin.\n\t\t\tif ( match.indexOf( '<textarea' ) === 0 )\n\t\t\t\tmatch = tag + unprotectRealComments( content ).replace( /</g, '&lt;' ).replace( />/g, '&gt;' ) + '</textarea>';\n\n\t\t\treturn '<cke:encoded>' + encodeURIComponent( match ) + '</cke:encoded>';\n\t\t} );\n\t}\n\n\tfunction unprotectElements( html ) {\n\t\treturn html.replace( encodedElementsRegex, function( match, encoded ) {\n\t\t\treturn decodeURIComponent( encoded );\n\t\t} );\n\t}\n\n\tfunction protectElementsNames( html ) {\n\t\treturn html.replace( protectElementNamesRegex, '$1cke:$2' );\n\t}\n\n\tfunction unprotectElementNames( html ) {\n\t\treturn html.replace( unprotectElementNamesRegex, '$1$2' );\n\t}\n\n\tfunction protectSelfClosingElements( html ) {\n\t\treturn html.replace( protectSelfClosingRegex, '<cke:$1$2></cke:$1>' );\n\t}\n\n\tfunction protectPreFormatted( html ) {\n\t\treturn html.replace( /(<pre\\b[^>]*>)(\\r\\n|\\n)/g, '$1$2$2' );\n\t}\n\n\tfunction protectRealComments( html ) {\n\t\treturn html.replace( /<!--(?!{cke_protected})[\\s\\S]+?-->/g, function( match ) {\n\t\t\treturn '<!--' + protectedSourceMarker +\n\t\t\t\t'{C}' +\n\t\t\t\tencodeURIComponent( match ).replace( /--/g, '%2D%2D' ) +\n\t\t\t\t'-->';\n\t\t} );\n\t}\n\n\t// Replace all \"on\\w{3,}\" strings which are not:\n\t// * opening tags - e.g. `<onfoo`,\n\t// * closing tags - e.g. </onfoo> (tested in \"false positive 1\"),\n\t// * part of other attribute - e.g. `data-onfoo` or `fonfoo`.\n\tfunction protectInsecureAttributes( html, randomNumber ) {\n\t\treturn html.replace( /([^a-z0-9<\\-])(on\\w{3,})(?!>)/gi, '$1data-cke-' + randomNumber + '-$2' );\n\t}\n\n\tfunction unprotectRealComments( html ) {\n\t\treturn html.replace( /<!--\\{cke_protected\\}\\{C\\}([\\s\\S]+?)-->/g, function( match, data ) {\n\t\t\treturn decodeURIComponent( data );\n\t\t} );\n\t}\n\n\tfunction unprotectSource( html, editor ) {\n\t\tvar store = editor._.dataStore;\n\n\t\treturn html.replace( /<!--\\{cke_protected\\}([\\s\\S]+?)-->/g, function( match, data ) {\n\t\t\treturn decodeURIComponent( data );\n\t\t} ).replace( /\\{cke_protected_(\\d+)\\}/g, function( match, id ) {\n\t\t\treturn store && store[ id ] || '';\n\t\t} );\n\t}\n\n\tfunction protectSource( data, editor, randomNumber ) {\n\t\tvar protectedHtml = [],\n\t\t\tprotectRegexes = editor.config.protectedSource,\n\t\t\tstore = editor._.dataStore || ( editor._.dataStore = { id: 1 } ),\n\t\t\ttempRegex = new RegExp('<\\\\!--\\\\{cke_temp_' + randomNumber + '(comment)?\\\\}(\\\\d*?)-->', 'g' );\n\n\t\tvar regexes = [\n\t\t\t// Script tags will also be forced to be protected, otherwise\n\t\t\t// IE will execute them.\n\t\t\t( /<script[\\s\\S]*?(<\\/script>|$)/gi ),\n\n\t\t\t// <noscript> tags (get lost in IE and messed up in FF).\n\t\t\t/<noscript[\\s\\S]*?<\\/noscript>/gi,\n\n\t\t\t// Avoid meta tags being stripped (https://dev.ckeditor.com/ticket/8117).\n\t\t\t/<meta[\\s\\S]*?\\/?>/gi\n\t\t].concat( protectRegexes );\n\n\t\t// First of any other protection, we must protect all comments\n\t\t// to avoid loosing them (of course, IE related).\n\t\t// Note that we use a different tag for comments, as we need to\n\t\t// transform them when applying filters.\n\t\tdata = data.replace( ( /<!--[\\s\\S]*?-->/g ), function( match ) {\n\t\t\treturn '<!--{cke_temp_' + randomNumber + 'comment}' + ( protectedHtml.push( match ) - 1 ) + '-->';\n\t\t} );\n\n\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\tdata = data.replace( regexes[ i ], function( match ) {\n\t\t\t\tmatch = match.replace( tempRegex, // There could be protected source inside another one. (https://dev.ckeditor.com/ticket/3869).\n\t\t\t\tfunction( $, isComment, id ) {\n\t\t\t\t\treturn protectedHtml[ id ];\n\t\t\t\t} );\n\n\t\t\t\t// Avoid protecting over protected, e.g. /\\{.*?\\}/\n\t\t\t\treturn ( tempRegex ).test( match ) ? match : '<!--{cke_temp_' + randomNumber + '}' +\n\t\t\t\t\t( protectedHtml.push( match ) - 1 ) + '-->';\n\t\t\t} );\n\t\t}\n\t\tdata = data.replace( tempRegex, function( $, isComment, id ) {\n\t\t\treturn '<!--' + protectedSourceMarker +\n\t\t\t\t( isComment ? '{C}' : '' ) +\n\t\t\t\tencodeURIComponent( protectedHtml[ id ] ).replace( /--/g, '%2D%2D' ) +\n\t\t\t\t'-->';\n\t\t} );\n\n\t\t// Different protection pattern is used for those that\n\t\t// live in attributes to avoid from being HTML encoded.\n\t\t// Why so serious? See https://dev.ckeditor.com/ticket/9205, https://dev.ckeditor.com/ticket/8216, https://dev.ckeditor.com/ticket/7805,\n\t\t// https://dev.ckeditor.com/ticket/11754, https://dev.ckeditor.com/ticket/11846.\n\t\tdata = data.replace( /<\\w+(?:\\s+(?:(?:[^\\s=>]+\\s*=\\s*(?:[^'\"\\s>]+|'[^']*'|\"[^\"]*\"))|[^\\s=\\/>]+))+\\s*\\/?>/g, function( match ) {\n\t\t\treturn match.replace( /<!--\\{cke_protected\\}([^>]*)-->/g, function( match, data ) {\n\t\t\t\tstore[ store.id ] = decodeURIComponent( data );\n\t\t\t\treturn '{cke_protected_' + ( store.id++ ) + '}';\n\t\t\t} );\n\t\t} );\n\n\t\t// This RegExp searches for innerText in all the title/iframe/textarea elements.\n\t\t// This is because browser doesn't allow HTML in these elements, that's why we can't\n\t\t// nest comments in there. (https://dev.ckeditor.com/ticket/11223)\n\t\tdata = data.replace( /<(title|iframe|textarea)([^>]*)>([\\s\\S]*?)<\\/\\1>/g, function( match, tagName, tagAttributes, innerText ) {\n\t\t\treturn '<' + tagName + tagAttributes + '>' + unprotectSource( unprotectRealComments( innerText ), editor ) + '</' + tagName + '>';\n\t\t} );\n\n\t\treturn data;\n\t}\n\n\t// Creates a block if the root element is empty.\n\tfunction fixEmptyRoot( root, fixBodyTag ) {\n\t\tif ( !root.children.length && CKEDITOR.dtd[ root.name ][ fixBodyTag ] ) {\n\t\t\tvar fixBodyElement = new CKEDITOR.htmlParser.element( fixBodyTag );\n\t\t\troot.add( fixBodyElement );\n\t\t}\n\t}\n\n\t// Removes reserved htmldataprocessor keywords ensuring that they are only used internally.\n\t// This function produces very complicated regex code. Using IIFE ensures that the regex\n\t// is build only once for this module.\n\tremoveReservedKeywords = ( function() {\n\t\tvar regexes = [\n\t\t\tcreateEncodedKeywordRegex(),\n\t\t\tcreateSourceKeywordRegex(),\n\t\t\tcreateIncorrectCommentRegex()\n\t\t];\n\n\t\treturn function( data ) {\n\t\t\twhile( isContentMatchingAnyPattern( regexes, data ) ) {\n\t\t\t\tdata = removeMatchingContent( regexes, data );\n\t\t\t}\n\n\t\t\treturn data;\n\t\t};\n\n\t\tfunction isContentMatchingAnyPattern( regexes, data ) {\n\t\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\t\tvar regex = regexes[ i ];\n\n\t\t\t\tregex.lastIndex = 0;\n\n\t\t\t\tif ( regex.test( data ) ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tfunction removeMatchingContent( regexes, data ) {\n\t\t\tfor ( var i = 0; i < regexes.length; i++ ) {\n\t\t\t\tdata = data.replace( regexes[ i ], '' );\n\t\t\t}\n\t\t\treturn data;\n\t\t}\n\n\t\tfunction createIncorrectCommentRegex() {\n\t\t\treturn /<!(?:\\s*-\\s*){2,3}!?\\s*>/g;\n\t\t}\n\n\t\t// Produces regex matching `cke:encoded` element.\n\t\tfunction createEncodedKeywordRegex() {\n\t\t\treturn new RegExp( '(' +\n\t\t\t\t// Create closed element regex i.e `<cke:encoded>xxx</cke:encoded>`.\n\t\t\t\tcreateEncodedRegex( '<cke:encoded>' ) +\n\t\t\t\t'(.*?)' +\n\t\t\t\tcreateEncodedRegex( '</cke:encoded>' ) +\n\t\t\t\t')|(' +\n\t\t\t\t// Create unclosed element regex i.e `<cke:encoded>xxx` or `xxx</cke:encoded>` to make sure that\n\t\t\t\t// element won't be closed by HTML parser and matched by `unprotectElements` function.\n\t\t\t\tcreateEncodedRegex( '<' ) +\n\t\t\t\tcreateEncodedRegex( '/' ) + '?' +\n\t\t\t\tcreateEncodedRegex( 'cke:encoded>' ) +\n\t\t\t\t')', 'gi' );\n\t\t}\n\n\t\t// Produces regex matching `{cke_protected}` and `{cke_protected_id}` keywords.\n\t\tfunction createSourceKeywordRegex() {\n\t\t\treturn new RegExp( '((' +\n\t\t\t\tcreateEncodedRegex( '{cke_protected' ) +\n\t\t\t\t')(_[0-9]*)?' +\n\t\t\t\tcreateEncodedRegex( '}' ) +\n\t\t\t\t')' , 'gi' );\n\t\t}\n\n\t\tfunction createEncodedRegex( str ) {\n\t\t\treturn CKEDITOR.tools.array.reduce( str.split( '' ), function( cur, character ) {\n\t\t\t\t// Produce case insensitive regex. `i` flag is not enough thus code entities differs\n\t\t\t\t// depending on case sensitivity.\n\t\t\t\tvar lowerCase = character.toLowerCase(),\n\t\t\t\t\tupperCase = character.toUpperCase(),\n\t\t\t\t\tregex = createCharacterEncodedRegex( lowerCase );\n\n\t\t\t\tif ( lowerCase !== upperCase ) {\n\t\t\t\t\tregex += '|' + createCharacterEncodedRegex( upperCase );\n\t\t\t\t}\n\n\t\t\t\tcur += '(' + regex + ')';\n\n\t\t\t\treturn cur;\n\t\t\t}, '' );\n\t\t}\n\n\t\tfunction createCharacterEncodedRegex( character ) {\n\t\t\tvar map = getCharRegexMap( character ),\n\t\t\t\tcharRegex = character;\n\n\t\t\tfor ( var code in map ) {\n\t\t\t\tif ( map[ code ] ) {\n\t\t\t\t\tcharRegex += '|' + map[ code ];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn charRegex;\n\t\t}\n\n\t\tfunction getCharRegexMap( character ) {\n\t\t\tvar entities = {\n\t\t\t\t'<': '&lt;',\n\t\t\t\t'>': '&gt;',\n\t\t\t\t':': '&colon;'\n\t\t\t},\n\t\t\t\tcharCode = character.charCodeAt( 0 ),\n\t\t\t\thex = charCode.toString( 16 );\n\n\t\t\treturn {\n\t\t\t\t// `;` is optional and HTML parser is able to recognize codes without it.\n\t\t\t\thtmlCode: '&#' + charCode + ';?',\n\t\t\t\t// Hexadecimal value is valid despite leading zero padding e.g. `&#x0065` === `&#x65`.\n\t\t\t\thex: '&#x0*' + hex + ';?',\n\t\t\t\tentity: entities[ character ]\n\t\t\t};\n\t\t}\n\t} )();\n\n\tfunction generateRandomNumber() {\n\t\tvar cryptoApi = window.crypto || window.msCrypto;\n\n\t\tif ( cryptoApi ) {\n\t\t\treturn cryptoApi.getRandomValues( new Uint32Array( 1 ) )[ 0 ];\n\t\t}\n\n\t\treturn Math.floor( Math.random() *  9000000000 + 1000000000 );\n\t}\n} )();\n\n/**\n * Whether a filler text (non-breaking space entity &mdash; `&nbsp;`) will be\n * inserted into empty block elements in HTML output.\n * This is used to render block elements properly with `line-height`.\n * When a function is specified instead, it will be passed a {@link CKEDITOR.htmlParser.element}\n * to decide whether adding the filler text by expecting a Boolean return value.\n *\n *\t\tconfig.fillEmptyBlocks = false; // Prevent filler nodes in all empty blocks.\n *\n *\t\t// Prevent filler node only in float cleaners.\n *\t\tconfig.fillEmptyBlocks = function( element ) {\n *\t\t\tif ( element.attributes[ 'class' ].indexOf( 'clear-both' ) != -1 )\n *\t\t\t\treturn false;\n *\t\t};\n *\n * @since 3.5.0\n * @cfg {Boolean/Function} [fillEmptyBlocks=true]\n * @member CKEDITOR.config\n */\n\n/**\n * This event is fired by the {@link CKEDITOR.htmlDataProcessor} when input HTML\n * is to be purified by the {@link CKEDITOR.htmlDataProcessor#toHtml} method.\n *\n * By adding listeners with different priorities it is possible\n * to process input HTML on different stages:\n *\n *\t* 1-4: Data is available in the original string format.\n *\t* 5: Data is initially filtered with regexp patterns and parsed to\n *\t\t{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\n *\t* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#dataFilter}\n *\t\tis not applied yet.\n *\t* 6: Data is filtered with the {@link CKEDITOR.filter content filter}.\n *\t* 10: Data is processed with {@link CKEDITOR.htmlDataProcessor#dataFilter}.\n *\t* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#dataFilter}\n *\t\thas already been applied.\n *\t* 15: Data is written back to an HTML string.\n *\t* 15-*: Data is available in an HTML string.\n *\n * For example to be able to process parsed, but not yet filtered data add listener this way:\n *\n *\t\teditor.on( 'toHtml', function( evt) {\n *\t\t\tevt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\n *\t\t}, null, null, 7 );\n *\n * @since 4.1.0\n * @event toHtml\n * @member CKEDITOR.editor\n * @param {CKEDITOR.editor} editor This editor instance.\n * @param data\n * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Input data to be purified.\n * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toHtml} The `context` argument.\n * @param {Boolean} data.fixForBody See {@link CKEDITOR.htmlDataProcessor#toHtml} The `fixForBody` argument.\n * @param {Boolean} data.dontFilter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `dontFilter` argument.\n * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toHtml} The `filter` argument.\n * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toHtml} The `enterMode` argument.\n * @param {Boolean} [data.protectedWhitespaces] See {@link CKEDITOR.htmlDataProcessor#toHtml} The `protectedWhitespaces` argument.\n */\n\n/**\n * This event is fired when {@link CKEDITOR.htmlDataProcessor} is converting\n * internal HTML to output data HTML.\n *\n * By adding listeners with different priorities it is possible\n * to process input HTML on different stages:\n *\n *\t* 1-4: Data is available in the original string format.\n *\t* 5: Data is initially filtered with regexp patterns and parsed to\n *\t\t{@link CKEDITOR.htmlParser.fragment} {@link CKEDITOR.htmlParser.element}.\n *\t* 5-9: Data is available in the parsed format, but {@link CKEDITOR.htmlDataProcessor#htmlFilter}\n *\t\tis not applied yet.\n *\t* 10: Data is filtered with {@link CKEDITOR.htmlDataProcessor#htmlFilter}.\n *  * 11: Data is filtered with the {CKEDITOR.filter content filter} (on output the content filter makes\n *\t\tonly transformations, without filtering).\n *\t* 10-14: Data is available in the parsed format and {@link CKEDITOR.htmlDataProcessor#htmlFilter}\n *\t\thas already been applied.\n *\t* 15: Data is written back to an HTML string.\n *\t* 15-*: Data is available in an HTML string.\n *\n * For example to be able to process parsed and already processed data add listener this way:\n *\n *\t\teditor.on( 'toDataFormat', function( evt) {\n *\t\t\tevt.data.dataValue; // -> CKEDITOR.htmlParser.fragment instance\n *\t\t}, null, null, 12 );\n *\n * @since 4.1.0\n * @event toDataFormat\n * @member CKEDITOR.editor\n * @param {CKEDITOR.editor} editor This editor instance.\n * @param data\n * @param {String/CKEDITOR.htmlParser.fragment/CKEDITOR.htmlParser.element} data.dataValue Output data to be prepared.\n * @param {String} data.context See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `context` argument.\n * @param {Boolean} data.filter See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `filter` argument.\n * @param {Boolean} data.enterMode See {@link CKEDITOR.htmlDataProcessor#toDataFormat} The `enterMode` argument.\n */\n"], "filenames": ["core/htmldataprocessor.js"], "buggy_code_start_loc": [53], "buggy_code_end_loc": [1109], "fixing_code_start_loc": [53], "fixing_code_end_loc": [1122], "type": "CWE-79", "message": "CKEditor4 is an open source what-you-see-is-what-you-get HTML editor. A vulnerability has been discovered in the core HTML processing module and may affect all plugins used by CKEditor 4 prior to version 4.18.0. The vulnerability allows someone to inject malformed HTML bypassing content sanitization, which could result in executing JavaScript code. This problem has been patched in version 4.18.0. There are currently no known workarounds.", "other": {"cve": {"id": "CVE-2022-24728", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-16T16:15:10.907", "lastModified": "2022-12-08T22:22:03.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "CKEditor4 is an open source what-you-see-is-what-you-get HTML editor. A vulnerability has been discovered in the core HTML processing module and may affect all plugins used by CKEditor 4 prior to version 4.18.0. The vulnerability allows someone to inject malformed HTML bypassing content sanitization, which could result in executing JavaScript code. This problem has been patched in version 4.18.0. There are currently no known workarounds."}, {"lang": "es", "value": "CKEditor4 es un editor HTML de c\u00f3digo abierto \"lo que visualizas es lo que obtienes\". Se ha detectado una vulnerabilidad en el m\u00f3dulo central de procesamiento de HTML y puede afectar a todos los plugins usados por CKEditor 4 versiones anteriores a 4.18.0. La vulnerabilidad permite que alguien inyecte HTML malformado omitiendo el saneo del contenido, lo que podr\u00eda resultar en una ejecuci\u00f3n de c\u00f3digo JavaScript. Este problema ha sido parcheado en versi\u00f3n 4.18.0. Actualmente no se presentan medidas de mitigaci\u00f3n conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ckeditor:ckeditor:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.0", "versionEndExcluding": "4.18.0", "matchCriteriaId": "EC4BF70E-8D8F-4E6E-87BC-0103C0ED541F"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.0", "versionEndExcluding": "9.2.15", "matchCriteriaId": "40450340-0D4F-4A9F-AADB-1708F844690A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:drupal:drupal:*:*:*:*:*:*:*:*", "versionStartIncluding": "9.3.0", "versionEndExcluding": "9.3.8", "matchCriteriaId": "A9992D37-51EB-4011-9335-D1653AE2D59B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:application_express:*:*:*:*:*:*:*:*", "versionEndExcluding": "22.1.1", "matchCriteriaId": "48B23728-0050-4AF0-B8B0-A959CBAB4505"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:commerce_merchandising:11.3.2:*:*:*:*:*:*:*", "matchCriteriaId": "C91E0944-A93B-4E6C-9547-4FC1A01DEAC6"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.0.7.0.0", "versionEndIncluding": "8.1.0.0.0", "matchCriteriaId": "6135501A-3F3C-42BA-B2C4-79403F3510D8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "3CC69CF0-6269-40F5-871B-16CFD5EC4C45"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "172BECE8-9626-4910-AAA1-A2FA9C7139E3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_analytical_applications_infrastructure:8.1.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "ACB82398-7281-47CF-81F9-A8A67D9C9DFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_behavior_detection_platform:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.1.1.0", "versionEndIncluding": "8.1.2.1", "matchCriteriaId": "AD9AC3A6-9B91-4B55-A320-A40E95F21058"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_behavior_detection_platform:8.0.7.0:*:*:*:*:*:*:*", "matchCriteriaId": "B0EF38D2-EF89-4DBC-B305-1A5D5FC0B186"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_behavior_detection_platform:8.0.8.0:*:*:*:*:*:*:*", "matchCriteriaId": "155FF008-1054-4943-B1C3-9117E3E51AC3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_trade-based_anti_money_laundering:8.0.7:*:*:*:enterprise:*:*:*", "matchCriteriaId": "B57ECC6E-CC64-4DE7-B657-3BA54EDDFFF4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:financial_services_trade-based_anti_money_laundering:8.0.8:*:*:*:enterprise:*:*:*", "matchCriteriaId": "10BBAD37-51A1-4819-807B-2642E9D4A69C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.58:*:*:*:*:*:*:*", "matchCriteriaId": "D9DB4A14-2EF5-4B54-95D2-75E6CF9AA0A9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oracle:peoplesoft_enterprise_peopletools:8.59:*:*:*:*:*:*:*", "matchCriteriaId": "C8AF00C6-B97F-414D-A8DF-057E6BFD8597"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}]}]}], "references": [{"url": "https://ckeditor.com/cke4/release/CKEditor-4.18.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/ckeditor/ckeditor4/commit/d158413449692d920a778503502dcb22881bc949", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ckeditor/ckeditor4/security/advisories/GHSA-4fc4-4p5g-6w89", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VR76VBN5GW5QUBJFHVXRX36UZ6YTCMW6/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WOZGMCYDB2OKKULFXZKM6V7JJW4ZZHJP/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.drupal.org/sa-core-2022-005", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpujul2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ckeditor/ckeditor4/commit/d158413449692d920a778503502dcb22881bc949"}}