{"buggy_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2012, Sun Microsystems, Inc., Kohsuke Kawaguchi, Erik Ramfelt,\n * Tom Huybrechts, Vincent Latombe\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.google.common.base.Predicate;\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.*;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.SecurityRealm;\nimport hudson.security.UserMayOrMayNotExistException;\nimport hudson.util.FormApply;\nimport hudson.util.FormValidation;\nimport hudson.util.RunList;\nimport hudson.util.XStream2;\nimport jenkins.model.IdStrategy;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ModelObjectWithContextMenu;\nimport jenkins.security.ImpersonatingUserDetailsService;\nimport jenkins.security.LastGrantedAuthoritiesProperty;\nimport net.sf.json.JSONObject;\n\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.providers.UsernamePasswordAuthenticationToken;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.userdetails.UsernameNotFoundException;\nimport org.springframework.dao.DataAccessException;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.apache.commons.io.filefilter.DirectoryFileFilter;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.annotation.concurrent.GuardedBy;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.FileFilter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\n/**\n * Represents a user.\n *\n * <p>\n * In Hudson, {@link User} objects are created in on-demand basis;\n * for example, when a build is performed, its change log is computed\n * and as a result commits from users who Hudson has never seen may be discovered.\n * When this happens, new {@link User} object is created.\n *\n * <p>\n * If the persisted record for an user exists, the information is loaded at\n * that point, but if there's no such record, a fresh instance is created from\n * thin air (this is where {@link UserPropertyDescriptor#newInstance(User)} is\n * called to provide initial {@link UserProperty} objects.\n *\n * <p>\n * Such newly created {@link User} objects will be simply GC-ed without\n * ever leaving the persisted record, unless {@link User#save()} method\n * is explicitly invoked (perhaps as a result of a browser submitting a\n * configuration.)\n *\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic class User extends AbstractModelObject implements AccessControlled, DescriptorByNameOwner, Saveable, Comparable<User>, ModelObjectWithContextMenu {\n\n    /**\n     * The username of the 'unknown' user used to avoid null user references.\n     */\n    private static final String UKNOWN_USERNAME = \"unknown\";\n\n    /**\n     * These usernames should not be used by real users logging into Jenkins. Therefore, we prevent\n     * users with these names from being saved.\n     */\n    private static final String[] ILLEGAL_PERSISTED_USERNAMES = new String[]{ACL.ANONYMOUS_USERNAME,\n            ACL.SYSTEM_USERNAME, UKNOWN_USERNAME};\n    private transient final String id;\n\n    private volatile String fullName;\n\n    private volatile String description;\n\n    /**\n     * List of {@link UserProperty}s configured for this project.\n     */\n    @CopyOnWrite\n    private volatile List<UserProperty> properties = new ArrayList<UserProperty>();\n\n\n    private User(String id, String fullName) {\n        this.id = id;\n        this.fullName = fullName;\n        load();\n    }\n\n    /**\n     * Returns the {@link jenkins.model.IdStrategy} for use with {@link User} instances. See\n     * {@link hudson.security.SecurityRealm#getUserIdStrategy()}\n     *\n     * @return the {@link jenkins.model.IdStrategy} for use with {@link User} instances.\n     * @since 1.566\n     */\n    @Nonnull\n    public static IdStrategy idStrategy() {\n        Jenkins j = Jenkins.getInstance();\n        if (j == null) {\n            return IdStrategy.CASE_INSENSITIVE;\n        }\n        SecurityRealm realm = j.getSecurityRealm();\n        if (realm == null) {\n            return IdStrategy.CASE_INSENSITIVE;\n        }\n        return realm.getUserIdStrategy();\n    }\n\n    public int compareTo(User that) {\n        return idStrategy().compare(this.id, that.id);\n    }\n\n    /**\n     * Loads the other data from disk if it's available.\n     */\n    private synchronized void load() {\n        properties.clear();\n\n        XmlFile config = getConfigFile();\n        try {\n            if(config.exists())\n                config.unmarshal(this);\n        } catch (IOException e) {\n            LOGGER.log(Level.SEVERE, \"Failed to load \"+config,e);\n        }\n\n        // remove nulls that have failed to load\n        for (Iterator<UserProperty> itr = properties.iterator(); itr.hasNext();) {\n            if(itr.next()==null)\n                itr.remove();            \n        }\n\n        // allocate default instances if needed.\n        // doing so after load makes sure that newly added user properties do get reflected\n        for (UserPropertyDescriptor d : UserProperty.all()) {\n            if(getProperty(d.clazz)==null) {\n                UserProperty up = d.newInstance(this);\n                if(up!=null)\n                    properties.add(up);\n            }\n        }\n\n        for (UserProperty p : properties)\n            p.setUser(this);\n    }\n\n    @Exported\n    public String getId() {\n        return id;\n    }\n\n    public @Nonnull String getUrl() {\n        return \"user/\"+Util.rawEncode(idStrategy().keyFor(id));\n    }\n\n    public @Nonnull String getSearchUrl() {\n        return \"/user/\"+Util.rawEncode(idStrategy().keyFor(id));\n    }\n\n    /**\n     * The URL of the user page.\n     */\n    @Exported(visibility=999)\n    public @Nonnull String getAbsoluteUrl() {\n        return Jenkins.getInstance().getRootUrl()+getUrl();\n    }\n\n    /**\n     * Gets the human readable name of this user.\n     * This is configurable by the user.\n     */\n    @Exported(visibility=999)\n    public @Nonnull String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Sets the human readable name of the user.\n     * If the input parameter is empty, the user's ID will be set.\n     */\n    public void setFullName(String name) {\n        if(Util.fixEmptyAndTrim(name)==null)    name=id;\n        this.fullName = name;\n    }\n\n    @Exported\n    public @CheckForNull String getDescription() {\n        return description;\n    }\n\n\n    /**\n     * Sets the description of the user.\n     * @since 1.609\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * Gets the user properties configured for this user.\n     */\n    public Map<Descriptor<UserProperty>,UserProperty> getProperties() {\n        return Descriptor.toMap(properties);\n    }\n\n    /**\n     * Updates the user object by adding a property.\n     */\n    public synchronized void addProperty(@Nonnull UserProperty p) throws IOException {\n        UserProperty old = getProperty(p.getClass());\n        List<UserProperty> ps = new ArrayList<UserProperty>(properties);\n        if(old!=null)\n            ps.remove(old);\n        ps.add(p);\n        p.setUser(this);\n        properties = ps;\n        save();\n    }\n\n    /**\n     * List of all {@link UserProperty}s exposed primarily for the remoting API.\n     */\n    @Exported(name=\"property\",inline=true)\n    public List<UserProperty> getAllProperties() {\n        return Collections.unmodifiableList(properties);\n    }\n    \n    /**\n     * Gets the specific property, or null.\n     */\n    public <T extends UserProperty> T getProperty(Class<T> clazz) {\n        for (UserProperty p : properties) {\n            if(clazz.isInstance(p))\n                return clazz.cast(p);\n        }\n        return null;\n    }\n\n    /**\n     * Creates an {@link Authentication} object that represents this user.\n     *\n     * This method checks with {@link SecurityRealm} if the user is a valid user that can login to the security realm.\n     * If {@link SecurityRealm} is a kind that does not support querying information about other users, this will\n     * use {@link LastGrantedAuthoritiesProperty} to pick up the granted authorities as of the last time the user has\n     * logged in.\n     *\n     * @throws UsernameNotFoundException\n     *      If this user is not a valid user in the backend {@link SecurityRealm}.\n     * @since 1.419\n     */\n    public @Nonnull Authentication impersonate() throws UsernameNotFoundException {\n        try {\n            UserDetails u = new ImpersonatingUserDetailsService(\n                    Jenkins.getInstance().getSecurityRealm().getSecurityComponents().userDetails).loadUserByUsername(id);\n            return new UsernamePasswordAuthenticationToken(u.getUsername(), \"\", u.getAuthorities());\n        } catch (UserMayOrMayNotExistException e) {\n            // backend can't load information about other users. so use the stored information if available\n        } catch (UsernameNotFoundException e) {\n            // if the user no longer exists in the backend, we need to refuse impersonating this user\n            if (!ALLOW_NON_EXISTENT_USER_TO_LOGIN)\n                throw e;\n        } catch (DataAccessException e) {\n            // seems like it's in the same boat as UserMayOrMayNotExistException\n        }\n\n        // seems like a legitimate user we have no idea about. proceed with minimum access\n        return new UsernamePasswordAuthenticationToken(id, \"\",\n            new GrantedAuthority[]{SecurityRealm.AUTHENTICATED_AUTHORITY});\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(Jenkins.ADMINISTER);\n\n        description = req.getParameter(\"description\");\n        save();\n        \n        rsp.sendRedirect(\".\");  // go to the top page\n    }\n\n    /**\n     * Gets the fallback \"unknown\" user instance.\n     * <p>\n     * This is used to avoid null {@link User} instance.\n     */\n    public static @Nonnull User getUnknown() {\n        return getById(UKNOWN_USERNAME, true);\n    }\n\n    /**\n     * Gets the {@link User} object by its id or full name.\n     *\n     * @param create\n     *      If true, this method will never return null for valid input\n     *      (by creating a new {@link User} object if none exists.)\n     *      If false, this method will return null if {@link User} object\n     *      with the given name doesn't exist.\n     * @return Requested user. May be {@code null} if a user does not exist and\n     *      {@code create} is false.\n     * @deprecated use {@link User#get(String, boolean, java.util.Map)}\n     */\n    @Deprecated\n    public static @Nullable User get(String idOrFullName, boolean create) {\n        return get(idOrFullName, create, Collections.emptyMap());\n    }\n\n    /**\n     * Gets the {@link User} object by its id or full name.\n     *\n     * @param create\n     *      If true, this method will never return null for valid input\n     *      (by creating a new {@link User} object if none exists.)\n     *      If false, this method will return null if {@link User} object\n     *      with the given name doesn't exist.\n     *\n     * @param context\n     *      contextual environment this user idOfFullName was retrieved from,\n     *      that can help resolve the user ID\n     * \n     * @return\n     *      An existing or created user. May be {@code null} if a user does not exist and\n     *      {@code create} is false.\n     */\n    public static @Nullable User get(String idOrFullName, boolean create, Map context) {\n\n        if(idOrFullName==null)\n            return null;\n\n        // sort resolvers by priority\n        List<CanonicalIdResolver> resolvers = new ArrayList<CanonicalIdResolver>(ExtensionList.lookup(CanonicalIdResolver.class));\n        Collections.sort(resolvers);\n\n        String id = null;\n        for (CanonicalIdResolver resolver : resolvers) {\n            id = resolver.resolveCanonicalId(idOrFullName, context);\n            if (id != null) {\n                LOGGER.log(Level.FINE, \"{0} mapped {1} to {2}\", new Object[] {resolver, idOrFullName, id});\n                break;\n            }\n        }\n        // DefaultUserCanonicalIdResolver will always return a non-null id if all other CanonicalIdResolver failed\n        if (id == null) {\n            throw new IllegalStateException(\"The user id should be always non-null thanks to DefaultUserCanonicalIdResolver\");\n        }\n        return getOrCreate(id, idOrFullName, create);\n    }\n\n    /**\n     * Retrieve a user by its ID, and create a new one if requested.\n     * @return\n     *      An existing or created user. May be {@code null} if a user does not exist and\n     *      {@code create} is false.\n     */\n    private static @Nullable User getOrCreate(@Nonnull String id, @Nonnull String fullName, boolean create) {\n        String idkey = idStrategy().keyFor(id);\n\n        byNameLock.readLock().lock();\n        User u;\n        try {\n            u = byName.get(idkey);\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        final File configFile = getConfigFileFor(id);\n        if (!configFile.isFile() && !configFile.getParentFile().isDirectory()) {\n            // check for legacy users and migrate if safe to do so.\n            File[] legacy = getLegacyConfigFilesFor(id);\n            if (legacy != null && legacy.length > 0) {\n                for (File legacyUserDir : legacy) {\n                    final XmlFile legacyXml = new XmlFile(XSTREAM, new File(legacyUserDir, \"config.xml\"));\n                    try {\n                        Object o = legacyXml.read();\n                        if (o instanceof User) {\n                            if (idStrategy().equals(id, legacyUserDir.getName()) && !idStrategy().filenameOf(legacyUserDir.getName())\n                                    .equals(legacyUserDir.getName())) {\n                                if (!legacyUserDir.renameTo(configFile.getParentFile())) {\n                                    LOGGER.log(Level.WARNING, \"Failed to migrate user record from {0} to {1}\",\n                                            new Object[]{legacyUserDir, configFile.getParentFile()});\n                                }\n                                break;\n                            }\n                        } else {\n                            LOGGER.log(Level.FINE, \"Unexpected object loaded from {0}: {1}\",\n                                    new Object[]{ legacyUserDir, o });\n                        }\n                    } catch (IOException e) {\n                        LOGGER.log(Level.FINE, String.format(\"Exception trying to load user from {0}: {1}\",\n                                new Object[]{ legacyUserDir, e.getMessage() }), e);\n                    }\n                }\n            }\n        }\n        if (u==null && (create || configFile.exists())) {\n            User tmp = new User(id, fullName);\n            User prev;\n            byNameLock.readLock().lock();\n            try {\n                prev = byName.putIfAbsent(idkey, u = tmp);\n            } finally {\n                byNameLock.readLock().unlock();\n            }\n            if (prev != null) {\n                u = prev; // if some has already put a value in the map, use it\n                if (LOGGER.isLoggable(Level.FINE) && !fullName.equals(prev.getFullName())) {\n                    LOGGER.log(Level.FINE, \"mismatch on fullName (\u2018\" + fullName + \"\u2019 vs. \u2018\" + prev.getFullName() + \"\u2019) for \u2018\" + id + \"\u2019\", new Throwable());\n                }\n            } else if (!id.equals(fullName) && !configFile.exists()) {\n                // JENKINS-16332: since the fullName may not be recoverable from the id, and various code may store the id only, we must save the fullName\n                try {\n                    u.save();\n                } catch (IOException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n            }\n        }\n        return u;\n    }\n\n    /**\n     * Gets the {@link User} object by its id or full name.\n     * Use {@link #getById} when you know you have an ID.\n     */\n    public static @Nonnull User get(String idOrFullName) {\n        return get(idOrFullName,true);\n    }\n\n    /**\n     * Gets the {@link User} object representing the currently logged-in user, or null\n     * if the current user is anonymous.\n     * @since 1.172\n     */\n    public static @CheckForNull User current() {\n        return get(Jenkins.getAuthentication());\n    }\n\n    /**\n     * Gets the {@link User} object representing the supplied {@link Authentication} or\n     * {@code null} if the supplied {@link Authentication} is either anonymous or {@code null}\n     * @param a the supplied {@link Authentication} .\n     * @return a {@link User} object for the supplied {@link Authentication} or {@code null}\n     * @since 1.609\n     */\n    public static @CheckForNull User get(@CheckForNull Authentication a) {\n        if(a == null || a instanceof AnonymousAuthenticationToken)\n            return null;\n\n        // Since we already know this is a name, we can just call getOrCreate with the name directly.\n        String id = a.getName();\n        return getById(id, true);\n    }\n\n    /**\n     * Gets the {@link User} object by its <code>id</code>\n     *\n     * @param id\n     *            the id of the user to retrieve and optionally create if it does not exist.\n     * @param create\n     *            If <code>true</code>, this method will never return <code>null</code> for valid input (by creating a\n     *            new {@link User} object if none exists.) If <code>false</code>, this method will return\n     *            <code>null</code> if {@link User} object with the given id doesn't exist.\n     * @return the a User whose id is <code>id</code>, or <code>null</code> if <code>create</code> is <code>false</code>\n     *         and the user does not exist.\n     */\n    public static @Nullable User getById(String id, boolean create) {\n        return getOrCreate(id, id, create);\n    }\n\n    private static volatile long lastScanned;\n\n    /**\n     * Gets all the users.\n     */\n    public static @Nonnull Collection<User> getAll() {\n        final IdStrategy strategy = idStrategy();\n        if(System.currentTimeMillis() -lastScanned>10000) {\n            // occasionally scan the file system to check new users\n            // whether we should do this only once at start up or not is debatable.\n            // set this right away to avoid another thread from doing the same thing while we do this.\n            // having two threads doing the work won't cause race condition, but it's waste of time.\n            lastScanned = System.currentTimeMillis();\n\n            File[] subdirs = getRootDir().listFiles((FileFilter)DirectoryFileFilter.INSTANCE);\n            if(subdirs==null)       return Collections.emptyList(); // shall never happen\n\n            for (File subdir : subdirs)\n                if(new File(subdir,\"config.xml\").exists()) {\n                    String name = strategy.idFromFilename(subdir.getName());\n                    User.getOrCreate(name, name, true);\n                }\n\n            lastScanned = System.currentTimeMillis();\n        }\n\n        byNameLock.readLock().lock();\n        ArrayList<User> r;\n        try {\n            r = new ArrayList<User>(byName.values());\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        Collections.sort(r,new Comparator<User>() {\n\n            public int compare(User o1, User o2) {\n                return strategy.compare(o1.getId(), o2.getId());\n            }\n        });\n        return r;\n    }\n\n    /**\n     * Reloads the configuration from disk.\n     */\n    public static void reload() {\n        byNameLock.readLock().lock();\n        try {\n            for (User u : byName.values()) {\n                u.load();\n            }\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n    }\n\n    /**\n     * Stop gap hack. Don't use it. To be removed in the trunk.\n     */\n    public static void clear() {\n        byNameLock.writeLock().lock();\n        try {\n            byName.clear();\n        } finally {\n            byNameLock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Called when changing the {@link IdStrategy}.\n     * @since 1.566\n     */\n    public static void rekey() {\n        final IdStrategy strategy = idStrategy();\n        byNameLock.writeLock().lock();\n        try {\n            for (Map.Entry<String, User> e : byName.entrySet()) {\n                String idkey = strategy.keyFor(e.getValue().id);\n                if (!idkey.equals(e.getKey())) {\n                    // need to remap\n                    byName.remove(e.getKey());\n                    byName.putIfAbsent(idkey, e.getValue());\n                }\n            }\n        } finally {\n            byNameLock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Returns the user name.\n     */\n    public @Nonnull String getDisplayName() {\n        return getFullName();\n    }\n\n    /** true if {@link AbstractBuild#hasParticipant} or {@link hudson.model.Cause.UserIdCause} */\n    private boolean relatedTo(@Nonnull AbstractBuild<?,?> b) {\n        if (b.hasParticipant(this)) {\n            return true;\n        }\n        for (Cause cause : b.getCauses()) {\n            if (cause instanceof Cause.UserIdCause) {\n                String userId = ((Cause.UserIdCause) cause).getUserId();\n                if (userId != null && idStrategy().equals(userId, getId())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Gets the list of {@link Build}s that include changes by this user,\n     * by the timestamp order.\n     */\n    @WithBridgeMethods(List.class)\n    public @Nonnull RunList getBuilds() {\n    \treturn new RunList<Run<?,?>>(Jenkins.getInstance().getAllItems(Job.class)).filter(new Predicate<Run<?,?>>() {\n            @Override public boolean apply(Run<?,?> r) {\n                return r instanceof AbstractBuild && relatedTo((AbstractBuild<?,?>) r);\n            }\n        });\n    }\n\n    /**\n     * Gets all the {@link AbstractProject}s that this user has committed to.\n     * @since 1.191\n     */\n    public @Nonnull Set<AbstractProject<?,?>> getProjects() {\n        Set<AbstractProject<?,?>> r = new HashSet<AbstractProject<?,?>>();\n        for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class))\n            if(p.hasParticipant(this))\n                r.add(p);\n        return r;\n    }\n\n    public @Override String toString() {\n        return fullName;\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    protected final XmlFile getConfigFile() {\n        return new XmlFile(XSTREAM,getConfigFileFor(id));\n    }\n\n    private static final File getConfigFileFor(String id) {\n        return new File(getRootDir(), idStrategy().filenameOf(id) +\"/config.xml\");\n    }\n\n    private static final File[] getLegacyConfigFilesFor(final String id) {\n        return getRootDir().listFiles(new FileFilter() {\n            @Override\n            public boolean accept(File pathname) {\n                return pathname.isDirectory() && new File(pathname, \"config.xml\").isFile() && idStrategy().equals(\n                        pathname.getName(), id);\n            }\n        });\n    }\n\n    /**\n     * Gets the directory where Hudson stores user information.\n     */\n    private static File getRootDir() {\n        return new File(Jenkins.getInstance().getRootDir(), \"users\");\n    }\n\n    /**\n     * Is the ID allowed? Some are prohibited for security reasons. See SECURITY-166.\n     * <p/>\n     * Note that this is only enforced when saving. These users are often created\n     * via the constructor (and even listed on /asynchPeople), but our goal is to\n     * prevent anyone from logging in as these users. Therefore, we prevent\n     * saving a User with one of these ids.\n     *\n     * @return true if the username or fullname is valid\n     * @since 1.600\n     */\n    public static boolean isIdOrFullnameAllowed(String id) {\n        for (String invalidId : ILLEGAL_PERSISTED_USERNAMES) {\n            if (id.equalsIgnoreCase(invalidId))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException, FormValidation {\n        if (! isIdOrFullnameAllowed(id)) {\n            throw FormValidation.error(Messages.User_IllegalUsername(id));\n        }\n        if (! isIdOrFullnameAllowed(fullName)) {\n            throw FormValidation.error(Messages.User_IllegalFullname(fullName));\n        }\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n    /**\n     * Deletes the data directory and removes this user from Hudson.\n     *\n     * @throws IOException\n     *      if we fail to delete.\n     */\n    public synchronized void delete() throws IOException {\n        final IdStrategy strategy = idStrategy();\n        byNameLock.readLock().lock();\n        try {\n            byName.remove(strategy.keyFor(id));\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        Util.deleteRecursive(new File(getRootDir(), strategy.filenameOf(id)));\n    }\n\n    /**\n     * Exposed remote API.\n     */\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Accepts submission from the configuration page.\n     */\n    @RequirePOST\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(Jenkins.ADMINISTER);\n\n        JSONObject json = req.getSubmittedForm();\n\n        fullName = json.getString(\"fullName\");\n        description = json.getString(\"description\");\n\n        List<UserProperty> props = new ArrayList<UserProperty>();\n        int i = 0;\n        for (UserPropertyDescriptor d : UserProperty.all()) {\n            UserProperty p = getProperty(d.clazz);\n\n            JSONObject o = json.optJSONObject(\"userProperty\" + (i++));\n            if (o!=null) {\n                if (p != null) {\n                    p = p.reconfigure(req, o);\n                } else {\n                    p = d.newInstance(req, o);\n                }\n                p.setUser(this);\n            }\n\n            if (p!=null)\n                props.add(p);\n        }\n        this.properties = props;\n\n        save();\n\n        FormApply.success(\".\").generateResponse(req,rsp,this);\n    }\n\n    /**\n     * Deletes this user from Hudson.\n     */\n    @RequirePOST\n    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(Jenkins.ADMINISTER);\n        if (idStrategy().equals(id, Jenkins.getAuthentication().getName())) {\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Cannot delete self\");\n            return;\n        }\n\n        delete();\n\n        rsp.sendRedirect2(\"../..\");\n    }\n\n    public void doRssAll(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        rss(req, rsp, \" all builds\", getBuilds(), Run.FEED_ADAPTER);\n    }\n\n    public void doRssFailed(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        rss(req, rsp, \" regression builds\", getBuilds().regressionOnly(), Run.FEED_ADAPTER);\n    }\n\n    public void doRssLatest(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        final List<Run> lastBuilds = new ArrayList<Run>();\n        for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class)) {\n            for (AbstractBuild<?,?> b = p.getLastBuild(); b != null; b = b.getPreviousBuild()) {\n                if (relatedTo(b)) {\n                    lastBuilds.add(b);\n                    break;\n                }\n            }\n        }\n        rss(req, rsp, \" latest build\", RunList.fromRuns(lastBuilds), Run.FEED_ADAPTER_LATEST);\n    }\n\n    private void rss(StaplerRequest req, StaplerResponse rsp, String suffix, RunList runs, FeedAdapter adapter)\n            throws IOException, ServletException {\n        RSS.forwardToRss(getDisplayName()+ suffix, getUrl(), runs.newBuilds(), adapter, req, rsp);\n    }\n\n    /**\n     * Keyed by {@link User#id}. This map is used to ensure\n     * singleton-per-id semantics of {@link User} objects.\n     *\n     * The key needs to be generated by {@link IdStrategy#keyFor(String)}.\n     */\n    @GuardedBy(\"byNameLock\")\n    private static final ConcurrentMap<String,User> byName = new ConcurrentHashMap<String, User>();\n\n    /**\n     * This lock is used to guard access to the {@link #byName} map. Use\n     * {@link java.util.concurrent.locks.ReadWriteLock#readLock()} for normal access and\n     * {@link java.util.concurrent.locks.ReadWriteLock#writeLock()} for {@link #rekey()} or any other operation\n     * that requires operating on the map as a whole.\n     */\n    private static final ReadWriteLock byNameLock = new ReentrantReadWriteLock();\n\n    /**\n     * Used to load/save user configuration.\n     */\n    public static final XStream2 XSTREAM = new XStream2();\n\n    private static final Logger LOGGER = Logger.getLogger(User.class.getName());\n\n    static {\n        XSTREAM.alias(\"user\",User.class);\n    }\n\n    public ACL getACL() {\n        final ACL base = Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n        // always allow a non-anonymous user full control of himself.\n        return new ACL() {\n            public boolean hasPermission(Authentication a, Permission permission) {\n                return (idStrategy().equals(a.getName(), id) && !(a instanceof AnonymousAuthenticationToken))\n                        || base.hasPermission(a, permission);\n            }\n        };\n    }\n\n    public void checkPermission(Permission permission) {\n        getACL().checkPermission(permission);\n    }\n\n    public boolean hasPermission(Permission permission) {\n        return getACL().hasPermission(permission);\n    }\n\n    /**\n     * With ADMINISTER permission, can delete users with persisted data but can't delete self.\n     */\n    public boolean canDelete() {\n        final IdStrategy strategy = idStrategy();\n        return hasPermission(Jenkins.ADMINISTER) && !strategy.equals(id, Jenkins.getAuthentication().getName())\n                && new File(getRootDir(), strategy.filenameOf(id)).exists();\n    }\n\n    /**\n     * Checks for authorities (groups) associated with this user.\n     * If the caller lacks {@link Jenkins#ADMINISTER}, or any problems arise, returns an empty list.\n     * {@link SecurityRealm#AUTHENTICATED_AUTHORITY} and the username, if present, are omitted.\n     * @since 1.498\n     * @return a possibly empty list\n     */\n    public @Nonnull List<String> getAuthorities() {\n        if (!Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER)) {\n            return Collections.emptyList();\n        }\n        List<String> r = new ArrayList<String>();\n        Authentication authentication;\n        try {\n            authentication = impersonate();\n        } catch (UsernameNotFoundException x) {\n            LOGGER.log(Level.FINE, \"cannot look up authorities for \" + id, x);\n            return Collections.emptyList();\n        }\n        for (GrantedAuthority a : authentication.getAuthorities()) {\n            if (a.equals(SecurityRealm.AUTHENTICATED_AUTHORITY)) {\n                continue;\n            }\n            String n = a.getAuthority();\n            if (n != null && !idStrategy().equals(n, id)) {\n                r.add(n);\n            }\n        }\n        Collections.sort(r, String.CASE_INSENSITIVE_ORDER);\n        return r;\n    }\n\n    public Descriptor getDescriptorByName(String className) {\n        return Jenkins.getInstance().getDescriptorByName(className);\n    }\n    \n    public Object getDynamic(String token) {\n        for(Action action: getTransientActions()){\n            if(action.getUrlName().equals(token))\n                return action;\n        }\n        for(Action action: getPropertyActions()){\n            if(action.getUrlName().equals(token))\n                return action;\n        }\n        return null;\n    }\n    \n    /**\n     * Return all properties that are also actions.\n     * \n     * @return the list can be empty but never null. read only.\n     */\n    public List<Action> getPropertyActions() {\n        List<Action> actions = new ArrayList<Action>();\n        for (UserProperty userProp : getProperties().values()) {\n            if (userProp instanceof Action) {\n                actions.add((Action) userProp);\n            }\n        }\n        return Collections.unmodifiableList(actions);\n    }\n    \n    /**\n     * Return all transient actions associated with this user.\n     * \n     * @return the list can be empty but never null. read only.\n     */\n    public List<Action> getTransientActions() {\n        List<Action> actions = new ArrayList<Action>();\n        for (TransientUserActionFactory factory: TransientUserActionFactory.all()) {\n            actions.addAll(factory.createFor(this));\n        }\n        return Collections.unmodifiableList(actions);\n    }\n\n    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {\n        return new ContextMenu().from(this,request,response);\n    }\n\n    public static abstract class CanonicalIdResolver extends AbstractDescribableImpl<CanonicalIdResolver> implements ExtensionPoint, Comparable<CanonicalIdResolver> {\n\n        /**\n         * context key for realm (domain) where idOrFullName has been retreived from.\n         * Can be used (for example) to distinguish ambiguous committer ID using the SCM URL.\n         * Associated Value is a {@link String}\n         */\n        public static final String REALM = \"realm\";\n\n        public int compareTo(CanonicalIdResolver o) {\n            // reverse priority order\n            int i = getPriority();\n            int j = o.getPriority();\n            return i>j ? -1 : (i==j ? 0:1);\n        }\n\n        /**\n         * extract user ID from idOrFullName with help from contextual infos.\n         * can return <code>null</code> if no user ID matched the input\n         */\n        public abstract @CheckForNull String resolveCanonicalId(String idOrFullName, Map<String, ?> context);\n\n        public int getPriority() {\n            return 1;\n        }\n\n    }\n\n\n    /**\n     * Resolve user ID from full name\n     */\n    @Extension\n    public static class FullNameIdResolver extends CanonicalIdResolver {\n\n        @Override\n        public String resolveCanonicalId(String idOrFullName, Map<String, ?> context) {\n            for (User user : getAll()) {\n                if (idOrFullName.equals(user.getFullName())) return user.getId();\n            }\n            return null;\n        }\n\n        @Override\n        public int getPriority() {\n            return -1; // lower than default\n        }\n    }\n\n\n    /**\n     * Tries to verify if an ID is valid.\n     * If so, we do not want to even consider users who might have the same full name.\n     */\n    @Extension\n    @Restricted(NoExternalUse.class)\n    public static class UserIDCanonicalIdResolver extends User.CanonicalIdResolver {\n\n        private static /* not final */ boolean SECURITY_243_FULL_DEFENSE = Boolean.parseBoolean(System.getProperty(User.class.getName() + \".SECURITY_243_FULL_DEFENSE\", \"true\"));\n\n        private static final ThreadLocal<Boolean> resolving = new ThreadLocal<Boolean>() {\n            @Override\n            protected Boolean initialValue() {\n                return false;\n            }\n        };\n\n        @Override\n        public String resolveCanonicalId(String idOrFullName, Map<String, ?> context) {\n            User existing = getById(idOrFullName, false);\n            if (existing != null) {\n                return existing.getId();\n            }\n            if (SECURITY_243_FULL_DEFENSE) {\n                Jenkins j = Jenkins.getInstance();\n                if (j != null) {\n                    if (!resolving.get()) {\n                        resolving.set(true);\n                        try {\n                            return j.getSecurityRealm().loadUserByUsername(idOrFullName).getUsername();\n                        } catch (UsernameNotFoundException x) {\n                            LOGGER.log(Level.FINE, \"not sure whether \" + idOrFullName + \" is a valid username or not\", x);\n                        } catch (DataAccessException x) {\n                            LOGGER.log(Level.FINE, \"could not look up \" + idOrFullName, x);\n                        } finally {\n                            resolving.set(false);\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public int getPriority() {\n            // should always come first so that ID that are ids get mapped correctly\n            return Integer.MAX_VALUE;\n        }\n\n    }\n\n    /**\n     * Jenkins now refuses to let the user login if he/she doesn't exist in {@link SecurityRealm},\n     * which was necessary to make sure users removed from the backend will get removed from the frontend.\n     * <p>\n     * Unfortunately this infringed some legitimate use cases of creating Jenkins-local users for\n     * automation purposes. This escape hatch switch can be enabled to resurrect that behaviour.\n     *\n     * JENKINS-22346.\n     */\n    public static boolean ALLOW_NON_EXISTENT_USER_TO_LOGIN = Boolean.getBoolean(User.class.getName()+\".allowNonExistentUserToLogin\");\n}\n\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Erik Ramfelt, Koichi Fujikawa, Red Hat, Inc., Seiji Sogabe,\n * Stephen Connolly, Tom Huybrechts, Yahoo! Inc., Alan Harder, CloudBees, Inc.,\n * Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport antlr.ANTLRException;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Injector;\nimport com.thoughtworks.xstream.XStream;\nimport hudson.BulkChange;\nimport hudson.DNSMultiCast;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.ExtensionComponent;\nimport hudson.ExtensionFinder;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport hudson.Launcher;\nimport hudson.Launcher.LocalLauncher;\nimport hudson.LocalPluginManager;\nimport hudson.Lookup;\nimport hudson.Plugin;\nimport hudson.PluginManager;\nimport hudson.PluginWrapper;\nimport hudson.ProxyConfiguration;\nimport hudson.TcpSlaveAgentListener;\nimport hudson.UDPBroadcastThread;\nimport hudson.Util;\nimport hudson.WebAppMain;\nimport hudson.XmlFile;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.init.InitMilestone;\nimport hudson.init.InitStrategy;\nimport hudson.init.TerminatorFinder;\nimport hudson.lifecycle.Lifecycle;\nimport hudson.lifecycle.RestartNotSupportedException;\nimport hudson.logging.LogRecorderManager;\nimport hudson.markup.EscapedMarkupFormatter;\nimport hudson.markup.MarkupFormatter;\nimport hudson.model.AbstractCIBase;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.AdministrativeMonitor;\nimport hudson.model.AllView;\nimport hudson.model.Api;\nimport hudson.model.Computer;\nimport hudson.model.ComputerSet;\nimport hudson.model.DependencyGraph;\nimport hudson.model.Describable;\nimport hudson.model.Descriptor;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.DescriptorByNameOwner;\nimport hudson.model.DirectoryBrowserSupport;\nimport hudson.model.Failure;\nimport hudson.model.Fingerprint;\nimport hudson.model.FingerprintCleanupThread;\nimport hudson.model.FingerprintMap;\nimport hudson.model.Hudson;\nimport hudson.model.Item;\nimport hudson.model.ItemGroup;\nimport hudson.model.ItemGroupMixIn;\nimport hudson.model.Items;\nimport hudson.model.JDK;\nimport hudson.model.Job;\nimport hudson.model.JobPropertyDescriptor;\nimport hudson.model.Label;\nimport hudson.model.ListView;\nimport hudson.model.LoadBalancer;\nimport hudson.model.LoadStatistics;\nimport hudson.model.ManagementLink;\nimport hudson.model.Messages;\nimport hudson.model.ModifiableViewGroup;\nimport hudson.model.NoFingerprintMatch;\nimport hudson.model.Node;\nimport hudson.model.OverallLoadStatistics;\nimport hudson.model.PaneStatusProperties;\nimport hudson.model.Project;\nimport hudson.model.Queue;\nimport hudson.model.Queue.FlyweightTask;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.Slave;\nimport hudson.model.TaskListener;\nimport hudson.model.TopLevelItem;\nimport hudson.model.TopLevelItemDescriptor;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.UpdateCenter;\nimport hudson.model.User;\nimport hudson.model.View;\nimport hudson.model.ViewGroupMixIn;\nimport hudson.model.WorkspaceCleanupThread;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.listeners.ItemListener;\nimport hudson.model.listeners.SCMListener;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.remoting.Callable;\nimport hudson.remoting.LocalChannel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.scm.RepositoryBrowser;\nimport hudson.scm.SCM;\nimport hudson.search.CollectionSearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.search.SearchItem;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.BasicAuthenticationFilter;\nimport hudson.security.FederatedLoginService;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonFilter;\nimport hudson.security.LegacyAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.security.SecurityMode;\nimport hudson.security.SecurityRealm;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.EphemeralNode;\nimport hudson.slaves.NodeDescriptor;\nimport hudson.slaves.NodeList;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.NodeProvisioner;\nimport hudson.slaves.OfflineCause;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SafeTimerTask;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AdministrativeError;\nimport hudson.util.CaseInsensitiveComparator;\nimport hudson.util.ClockDifference;\nimport hudson.util.CopyOnWriteList;\nimport hudson.util.CopyOnWriteMap;\nimport hudson.util.DaemonThreadFactory;\nimport hudson.util.DescribableList;\nimport hudson.util.FormApply;\nimport hudson.util.FormValidation;\nimport hudson.util.Futures;\nimport hudson.util.HudsonIsLoading;\nimport hudson.util.HudsonIsRestarting;\nimport hudson.util.IOUtils;\nimport hudson.util.Iterators;\nimport hudson.util.JenkinsReloadFailed;\nimport hudson.util.Memoizer;\nimport hudson.util.MultipartFormDataParser;\nimport hudson.util.NamingThreadFactory;\nimport hudson.util.RemotingDiagnostics;\nimport hudson.util.RemotingDiagnostics.HeapDump;\nimport hudson.util.TextFile;\nimport hudson.util.TimeUnit2;\nimport hudson.util.VersionNumber;\nimport hudson.util.XStream2;\nimport hudson.views.DefaultMyViewsTabBar;\nimport hudson.views.DefaultViewsTabBar;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.Widget;\nimport jenkins.ExtensionComponentSet;\nimport jenkins.ExtensionRefreshException;\nimport jenkins.InitReactorRunner;\nimport jenkins.model.ProjectNamingStrategy.DefaultProjectNamingStrategy;\nimport jenkins.security.ConfidentialKey;\nimport jenkins.security.ConfidentialStore;\nimport jenkins.security.SecurityListener;\nimport jenkins.security.MasterToSlaveCallable;\nimport jenkins.slaves.WorkspaceLocator;\nimport jenkins.util.Timer;\nimport jenkins.util.io.FileBoolean;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.AccessDeniedException;\nimport org.acegisecurity.AcegiSecurityException;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.GrantedAuthorityImpl;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.acegisecurity.ui.AbstractProcessingFilter;\nimport org.apache.commons.jelly.JellyException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.logging.LogFactory;\nimport org.jvnet.hudson.reactor.Executable;\nimport org.jvnet.hudson.reactor.Reactor;\nimport org.jvnet.hudson.reactor.ReactorException;\nimport org.jvnet.hudson.reactor.Task;\nimport org.jvnet.hudson.reactor.TaskBuilder;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder.Handle;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.MetaClass;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerFallback;\nimport org.kohsuke.stapler.StaplerProxy;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebApp;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.stapler.framework.adjunct.AdjunctManager;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.kohsuke.stapler.jelly.JellyClassLoaderTearOff;\nimport org.kohsuke.stapler.jelly.JellyRequestDispatcher;\nimport org.xml.sax.InputSource;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.crypto.SecretKey;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.net.BindException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\n\nimport static hudson.Util.*;\nimport static hudson.init.InitMilestone.*;\nimport hudson.util.LogTaskListener;\nimport static java.util.logging.Level.*;\nimport static javax.servlet.http.HttpServletResponse.*;\nimport org.kohsuke.stapler.WebMethod;\n\n/**\n * Root object of the system.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic class Jenkins extends AbstractCIBase implements DirectlyModifiableTopLevelItemGroup, StaplerProxy, StaplerFallback,\n        ModifiableViewGroup, AccessControlled, DescriptorByNameOwner,\n        ModelObjectWithContextMenu, ModelObjectWithChildren {\n    private transient final Queue queue;\n\n    /**\n     * Stores various objects scoped to {@link Jenkins}.\n     */\n    public transient final Lookup lookup = new Lookup();\n\n    /**\n     * We update this field to the current version of Jenkins whenever we save {@code config.xml}.\n     * This can be used to detect when an upgrade happens from one version to next.\n     *\n     * <p>\n     * Since this field is introduced starting 1.301, \"1.0\" is used to represent every version\n     * up to 1.300. This value may also include non-standard versions like \"1.301-SNAPSHOT\" or\n     * \"?\", etc., so parsing needs to be done with a care.\n     *\n     * @since 1.301\n     */\n    // this field needs to be at the very top so that other components can look at this value even during unmarshalling\n    private String version = \"1.0\";\n\n    /**\n     * Number of executors of the master node.\n     */\n    private int numExecutors = 2;\n\n    /**\n     * Job allocation strategy.\n     */\n    private Mode mode = Mode.NORMAL;\n\n    /**\n     * False to enable anyone to do anything.\n     * Left as a field so that we can still read old data that uses this flag.\n     *\n     * @see #authorizationStrategy\n     * @see #securityRealm\n     */\n    private Boolean useSecurity;\n\n    /**\n     * Controls how the\n     * <a href=\"http://en.wikipedia.org/wiki/Authorization\">authorization</a>\n     * is handled in Jenkins.\n     * <p>\n     * This ultimately controls who has access to what.\n     *\n     * Never null.\n     */\n    private volatile AuthorizationStrategy authorizationStrategy = AuthorizationStrategy.UNSECURED;\n\n    /**\n     * Controls a part of the\n     * <a href=\"http://en.wikipedia.org/wiki/Authentication\">authentication</a>\n     * handling in Jenkins.\n     * <p>\n     * Intuitively, this corresponds to the user database.\n     *\n     * See {@link HudsonFilter} for the concrete authentication protocol.\n     *\n     * Never null. Always use {@link #setSecurityRealm(SecurityRealm)} to\n     * update this field.\n     *\n     * @see #getSecurity()\n     * @see #setSecurityRealm(SecurityRealm)\n     */\n    private volatile SecurityRealm securityRealm = SecurityRealm.NO_AUTHENTICATION;\n\n    /**\n     * Disables the remember me on this computer option in the standard login screen.\n     *\n     * @since 1.534\n     */\n    private volatile boolean disableRememberMe;\n\n    /**\n     * The project naming strategy defines/restricts the names which can be given to a project/job. e.g. does the name have to follow a naming convention?\n     */\n    private ProjectNamingStrategy projectNamingStrategy = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n\n    /**\n     * Root directory for the workspaces.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getWorkspaceFor(TopLevelItem)\n     */\n    private String workspaceDir = \"${ITEM_ROOTDIR}/\"+WORKSPACE_DIRNAME;\n\n    /**\n     * Root directory for the builds.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getBuildDirFor(Job)\n     */\n    private String buildsDir = \"${ITEM_ROOTDIR}/builds\";\n\n    /**\n     * Message displayed in the top page.\n     */\n    private String systemMessage;\n\n    private MarkupFormatter markupFormatter;\n\n    /**\n     * Root directory of the system.\n     */\n    public transient final File root;\n\n    /**\n     * Where are we in the initialization?\n     */\n    private transient volatile InitMilestone initLevel = InitMilestone.STARTED;\n\n    /**\n     * All {@link Item}s keyed by their {@link Item#getName() name}s.\n     */\n    /*package*/ transient final Map<String,TopLevelItem> items = new CopyOnWriteMap.Tree<String,TopLevelItem>(CaseInsensitiveComparator.INSTANCE);\n\n    /**\n     * The sole instance.\n     */\n    private static Jenkins theInstance;\n\n    private transient volatile boolean isQuietingDown;\n    private transient volatile boolean terminating;\n\n    private List<JDK> jdks = new ArrayList<JDK>();\n\n    private transient volatile DependencyGraph dependencyGraph;\n    private final transient AtomicBoolean dependencyGraphDirty = new AtomicBoolean();\n\n    /**\n     * Currently active Views tab bar.\n     */\n    private volatile ViewsTabBar viewsTabBar = new DefaultViewsTabBar();\n\n    /**\n     * Currently active My Views tab bar.\n     */\n    private volatile MyViewsTabBar myViewsTabBar = new DefaultMyViewsTabBar();\n\n    /**\n     * All {@link ExtensionList} keyed by their {@link ExtensionList#extensionType}.\n     */\n    private transient final Memoizer<Class,ExtensionList> extensionLists = new Memoizer<Class,ExtensionList>() {\n        public ExtensionList compute(Class key) {\n            return ExtensionList.create(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * All {@link DescriptorExtensionList} keyed by their {@link DescriptorExtensionList#describableType}.\n     */\n    private transient final Memoizer<Class,DescriptorExtensionList> descriptorLists = new Memoizer<Class,DescriptorExtensionList>() {\n        public DescriptorExtensionList compute(Class key) {\n            return DescriptorExtensionList.createDescriptorList(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * {@link Computer}s in this Jenkins system. Read-only.\n     */\n    protected transient final Map<Node,Computer> computers = new CopyOnWriteMap.Hash<Node,Computer>();\n\n    /**\n     * Active {@link Cloud}s.\n     */\n    public final Hudson.CloudList clouds = new Hudson.CloudList(this);\n\n    public static class CloudList extends DescribableList<Cloud,Descriptor<Cloud>> {\n        public CloudList(Jenkins h) {\n            super(h);\n        }\n\n        public CloudList() {// needed for XStream deserialization\n        }\n\n        public Cloud getByName(String name) {\n            for (Cloud c : this)\n                if (c.name.equals(name))\n                    return c;\n            return null;\n        }\n\n        @Override\n        protected void onModified() throws IOException {\n            super.onModified();\n            Jenkins.getInstance().trimLabels();\n        }\n    }\n\n    /**\n     * Legacy store of the set of installed cluster nodes.\n     * @deprecated in favour of {@link Nodes}\n     */\n    @Deprecated\n    protected transient volatile NodeList slaves;\n\n    /**\n     * The holder of the set of installed cluster nodes.\n     *\n     * @since 1.607\n     */\n    private transient final Nodes nodes = new Nodes(this);\n\n    /**\n     * Quiet period.\n     *\n     * This is {@link Integer} so that we can initialize it to '5' for upgrading users.\n     */\n    /*package*/ Integer quietPeriod;\n\n    /**\n     * Global default for {@link AbstractProject#getScmCheckoutRetryCount()}\n     */\n    /*package*/ int scmCheckoutRetryCount;\n\n    /**\n     * {@link View}s.\n     */\n    private final CopyOnWriteArrayList<View> views = new CopyOnWriteArrayList<View>();\n\n    /**\n     * Name of the primary view.\n     * <p>\n     * Start with null, so that we can upgrade pre-1.269 data well.\n     * @since 1.269\n     */\n    private volatile String primaryView;\n\n    private transient final ViewGroupMixIn viewGroupMixIn = new ViewGroupMixIn(this) {\n        protected List<View> views() { return views; }\n        protected String primaryView() { return primaryView; }\n        protected void primaryView(String name) { primaryView=name; }\n    };\n\n\n    private transient final FingerprintMap fingerprintMap = new FingerprintMap();\n\n    /**\n     * Loaded plugins.\n     */\n    public transient final PluginManager pluginManager;\n\n    public transient volatile TcpSlaveAgentListener tcpSlaveAgentListener;\n\n    private transient UDPBroadcastThread udpBroadcastThread;\n\n    private transient DNSMultiCast dnsMultiCast;\n\n    /**\n     * List of registered {@link SCMListener}s.\n     */\n    private transient final CopyOnWriteList<SCMListener> scmListeners = new CopyOnWriteList<SCMListener>();\n\n    /**\n     * TCP slave agent port.\n     * 0 for random, -1 to disable.\n     */\n    private int slaveAgentPort =0;\n\n    /**\n     * Whitespace-separated labels assigned to the master as a {@link Node}.\n     */\n    private String label=\"\";\n\n    /**\n     * {@link hudson.security.csrf.CrumbIssuer}\n     */\n    private volatile CrumbIssuer crumbIssuer;\n\n    /**\n     * All labels known to Jenkins. This allows us to reuse the same label instances\n     * as much as possible, even though that's not a strict requirement.\n     */\n    private transient final ConcurrentHashMap<String,Label> labels = new ConcurrentHashMap<String,Label>();\n\n    /**\n     * Load statistics of the entire system.\n     *\n     * This includes every executor and every job in the system.\n     */\n    @Exported\n    public transient final OverallLoadStatistics overallLoad = new OverallLoadStatistics();\n\n    /**\n     * Load statistics of the free roaming jobs and slaves.\n     *\n     * This includes all executors on {@link hudson.model.Node.Mode#NORMAL} nodes and jobs that do not have any assigned nodes.\n     *\n     * @since 1.467\n     */\n    @Exported\n    public transient final LoadStatistics unlabeledLoad = new UnlabeledLoadStatistics();\n\n    /**\n     * {@link NodeProvisioner} that reacts to {@link #unlabeledLoad}.\n     * @since 1.467\n     */\n    public transient final NodeProvisioner unlabeledNodeProvisioner = new NodeProvisioner(null,unlabeledLoad);\n\n    /**\n     * @deprecated as of 1.467\n     *      Use {@link #unlabeledNodeProvisioner}.\n     *      This was broken because it was tracking all the executors in the system, but it was only tracking\n     *      free-roaming jobs in the queue. So {@link Cloud} fails to launch nodes when you have some exclusive\n     *      slaves and free-roaming jobs in the queue.\n     */\n    @Restricted(NoExternalUse.class)\n    @Deprecated\n    public transient final NodeProvisioner overallNodeProvisioner = unlabeledNodeProvisioner;\n\n\n    public transient final ServletContext servletContext;\n\n    /**\n     * Transient action list. Useful for adding navigation items to the navigation bar\n     * on the left.\n     */\n    private transient final List<Action> actions = new CopyOnWriteArrayList<Action>();\n\n    /**\n     * List of master node properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> nodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * List of global properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> globalNodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * {@link AdministrativeMonitor}s installed on this system.\n     *\n     * @see AdministrativeMonitor\n     */\n    public transient final List<AdministrativeMonitor> administrativeMonitors = getExtensionList(AdministrativeMonitor.class);\n\n    /**\n     * Widgets on Jenkins.\n     */\n    private transient final List<Widget> widgets = getExtensionList(Widget.class);\n\n    /**\n     * {@link AdjunctManager}\n     */\n    private transient final AdjunctManager adjuncts;\n\n    /**\n     * Code that handles {@link ItemGroup} work.\n     */\n    private transient final ItemGroupMixIn itemGroupMixIn = new ItemGroupMixIn(this,this) {\n        @Override\n        protected void add(TopLevelItem item) {\n            items.put(item.getName(),item);\n        }\n\n        @Override\n        protected File getRootDirFor(String name) {\n            return Jenkins.this.getRootDirFor(name);\n        }\n    };\n\n\n    /**\n     * Hook for a test harness to intercept Jenkins.getInstance()\n     *\n     * Do not use in the production code as the signature may change.\n     */\n    public interface JenkinsHolder {\n        @CheckForNull Jenkins getInstance();\n    }\n\n    static JenkinsHolder HOLDER = new JenkinsHolder() {\n        public @CheckForNull Jenkins getInstance() {\n            return theInstance;\n        }\n    };\n\n    /**\n     * Gets the {@link Jenkins} singleton.\n     * {@link #getInstance()} provides the unchecked versions of the method.\n     * @return {@link Jenkins} instance\n     * @throws IllegalStateException {@link Jenkins} has not been started, or was already shut down\n     * @since 1.590\n     */\n    public static @Nonnull Jenkins getActiveInstance() throws IllegalStateException {\n        Jenkins instance = HOLDER.getInstance();\n        if (instance == null) {\n            throw new IllegalStateException(\"Jenkins has not been started, or was already shut down\");\n        }\n        return instance;\n    }\n\n    /**\n     * Gets the {@link Jenkins} singleton.\n     * {@link #getActiveInstance()} provides the checked versions of the method.\n     * @return The instance. Null if the {@link Jenkins} instance has not been started,\n     * or was already shut down\n     */\n    @CLIResolver\n    @CheckForNull\n    public static Jenkins getInstance() {\n        return HOLDER.getInstance();\n    }\n\n    /**\n     * Secret key generated once and used for a long time, beyond\n     * container start/stop. Persisted outside <tt>config.xml</tt> to avoid\n     * accidental exposure.\n     */\n    private transient final String secretKey;\n\n    private transient final UpdateCenter updateCenter = new UpdateCenter();\n\n    /**\n     * True if the user opted out from the statistics tracking. We'll never send anything if this is true.\n     */\n    private Boolean noUsageStatistics;\n\n    /**\n     * HTTP proxy configuration.\n     */\n    public transient volatile ProxyConfiguration proxy;\n\n    /**\n     * Bound to \"/log\".\n     */\n    private transient final LogRecorderManager log = new LogRecorderManager();\n\n    protected Jenkins(File root, ServletContext context) throws IOException, InterruptedException, ReactorException {\n        this(root,context,null);\n    }\n\n    /**\n     * @param pluginManager\n     *      If non-null, use existing plugin manager.  create a new one.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings({\n        \"SC_START_IN_CTOR\", // bug in FindBugs. It flags UDPBroadcastThread.start() call but that's for another class\n        \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\" // Trigger.timer\n    })\n    protected Jenkins(File root, ServletContext context, PluginManager pluginManager) throws IOException, InterruptedException, ReactorException {\n        long start = System.currentTimeMillis();\n\n    \t// As Jenkins is starting, grant this process full control\n        ACL.impersonate(ACL.SYSTEM);\n        try {\n            this.root = root;\n            this.servletContext = context;\n            computeVersion(context);\n            if(theInstance!=null)\n                throw new IllegalStateException(\"second instance\");\n            theInstance = this;\n\n            if (!new File(root,\"jobs\").exists()) {\n                // if this is a fresh install, use more modern default layout that's consistent with slaves\n                workspaceDir = \"${JENKINS_HOME}/workspace/${ITEM_FULLNAME}\";\n            }\n\n            // doing this early allows InitStrategy to set environment upfront\n            final InitStrategy is = InitStrategy.get(Thread.currentThread().getContextClassLoader());\n\n            Trigger.timer = new java.util.Timer(\"Jenkins cron thread\");\n            queue = new Queue(LoadBalancer.CONSISTENT_HASH);\n\n            try {\n                dependencyGraph = DependencyGraph.EMPTY;\n            } catch (InternalError e) {\n                if(e.getMessage().contains(\"window server\")) {\n                    throw new Error(\"Looks like the server runs without X. Please specify -Djava.awt.headless=true as JVM option\",e);\n                }\n                throw e;\n            }\n\n            // get or create the secret\n            TextFile secretFile = new TextFile(new File(getRootDir(),\"secret.key\"));\n            if(secretFile.exists()) {\n                secretKey = secretFile.readTrim();\n            } else {\n                SecureRandom sr = new SecureRandom();\n                byte[] random = new byte[32];\n                sr.nextBytes(random);\n                secretKey = Util.toHexString(random);\n                secretFile.write(secretKey);\n\n                // this marker indicates that the secret.key is generated by the version of Jenkins post SECURITY-49.\n                // this indicates that there's no need to rewrite secrets on disk\n                new FileBoolean(new File(root,\"secret.key.not-so-secret\")).on();\n            }\n\n            try {\n                proxy = ProxyConfiguration.load();\n            } catch (IOException e) {\n                LOGGER.log(SEVERE, \"Failed to load proxy configuration\", e);\n            }\n\n            if (pluginManager==null)\n                pluginManager = new LocalPluginManager(this);\n            this.pluginManager = pluginManager;\n            // JSON binding needs to be able to see all the classes from all the plugins\n            WebApp.get(servletContext).setClassLoader(pluginManager.uberClassLoader);\n\n            adjuncts = new AdjunctManager(servletContext, pluginManager.uberClassLoader,\"adjuncts/\"+SESSION_HASH, TimeUnit2.DAYS.toMillis(365));\n\n            // initialization consists of ...\n            executeReactor( is,\n                    pluginManager.initTasks(is),    // loading and preparing plugins\n                    loadTasks(),                    // load jobs\n                    InitMilestone.ordering()        // forced ordering among key milestones\n            );\n\n            if(KILL_AFTER_LOAD)\n                System.exit(0);\n\n            if(slaveAgentPort!=-1) {\n                try {\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n                } catch (BindException e) {\n                    new AdministrativeError(getClass().getName()+\".tcpBind\",\n                            \"Failed to listen to incoming slave connection\",\n                            \"Failed to listen to incoming slave connection. <a href='configure'>Change the port number</a> to solve the problem.\",e);\n                }\n            } else\n                tcpSlaveAgentListener = null;\n\n            if (UDPBroadcastThread.PORT != -1) {\n                try {\n                    udpBroadcastThread = new UDPBroadcastThread(this);\n                    udpBroadcastThread.start();\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to broadcast over UDP (use -Dhudson.udp=-1 to disable)\", e);\n                }\n            }\n            dnsMultiCast = new DNSMultiCast(this);\n\n            Timer.get().scheduleAtFixedRate(new SafeTimerTask() {\n                @Override\n                protected void doRun() throws Exception {\n                    trimLabels();\n                }\n            }, TimeUnit2.MINUTES.toMillis(5), TimeUnit2.MINUTES.toMillis(5), TimeUnit.MILLISECONDS);\n\n            updateComputerList();\n\n            {// master is online now\n                Computer c = toComputer();\n                if(c!=null)\n                    for (ComputerListener cl : ComputerListener.all())\n                        cl.onOnline(c, new LogTaskListener(LOGGER, INFO));\n            }\n\n            for (ItemListener l : ItemListener.all()) {\n                long itemListenerStart = System.currentTimeMillis();\n                try {\n                    l.onLoaded();\n                } catch (RuntimeException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n                if (LOG_STARTUP_PERFORMANCE)\n                    LOGGER.info(String.format(\"Took %dms for item listener %s startup\",\n                            System.currentTimeMillis()-itemListenerStart,l.getClass().getName()));\n            }\n\n            if (LOG_STARTUP_PERFORMANCE)\n                LOGGER.info(String.format(\"Took %dms for complete Jenkins startup\",\n                        System.currentTimeMillis()-start));\n        } finally {\n            SecurityContextHolder.clearContext();\n        }\n    }\n\n    /**\n     * Executes a reactor.\n     *\n     * @param is\n     *      If non-null, this can be consulted for ignoring some tasks. Only used during the initialization of Jenkins.\n     */\n    private void executeReactor(final InitStrategy is, TaskBuilder... builders) throws IOException, InterruptedException, ReactorException {\n        Reactor reactor = new Reactor(builders) {\n            /**\n             * Sets the thread name to the task for better diagnostics.\n             */\n            @Override\n            protected void runTask(Task task) throws Exception {\n                if (is!=null && is.skipInitTask(task))  return;\n\n                ACL.impersonate(ACL.SYSTEM); // full access in the initialization thread\n                String taskName = task.getDisplayName();\n\n                Thread t = Thread.currentThread();\n                String name = t.getName();\n                if (taskName !=null)\n                    t.setName(taskName);\n                try {\n                    long start = System.currentTimeMillis();\n                    super.runTask(task);\n                    if(LOG_STARTUP_PERFORMANCE)\n                        LOGGER.info(String.format(\"Took %dms for %s by %s\",\n                                System.currentTimeMillis()-start, taskName, name));\n                } finally {\n                    t.setName(name);\n                    SecurityContextHolder.clearContext();\n                }\n            }\n        };\n\n        new InitReactorRunner() {\n            @Override\n            protected void onInitMilestoneAttained(InitMilestone milestone) {\n                initLevel = milestone;\n            }\n        }.run(reactor);\n    }\n\n\n    public TcpSlaveAgentListener getTcpSlaveAgentListener() {\n        return tcpSlaveAgentListener;\n    }\n\n    /**\n     * Makes {@link AdjunctManager} URL-bound.\n     * The dummy parameter allows us to use different URLs for the same adjunct,\n     * for proper cache handling.\n     */\n    public AdjunctManager getAdjuncts(String dummy) {\n        return adjuncts;\n    }\n\n    @Exported\n    public int getSlaveAgentPort() {\n        return slaveAgentPort;\n    }\n\n    /**\n     * @param port\n     *      0 to indicate random available TCP port. -1 to disable this service.\n     */\n    public void setSlaveAgentPort(int port) throws IOException {\n        this.slaveAgentPort = port;\n\n        // relaunch the agent\n        if(tcpSlaveAgentListener==null) {\n            if(slaveAgentPort!=-1)\n                tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n        } else {\n            if(tcpSlaveAgentListener.configuredPort!=slaveAgentPort) {\n                tcpSlaveAgentListener.shutdown();\n                tcpSlaveAgentListener = null;\n                if(slaveAgentPort!=-1)\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n            }\n        }\n    }\n\n    public void setNodeName(String name) {\n        throw new UnsupportedOperationException(); // not allowed\n    }\n\n    public String getNodeDescription() {\n        return Messages.Hudson_NodeDescription();\n    }\n\n    @Exported\n    public String getDescription() {\n        return systemMessage;\n    }\n\n    public PluginManager getPluginManager() {\n        return pluginManager;\n    }\n\n    public UpdateCenter getUpdateCenter() {\n        return updateCenter;\n    }\n\n    public boolean isUsageStatisticsCollected() {\n        return noUsageStatistics==null || !noUsageStatistics;\n    }\n\n    public void setNoUsageStatistics(Boolean noUsageStatistics) throws IOException {\n        this.noUsageStatistics = noUsageStatistics;\n        save();\n    }\n\n    public View.People getPeople() {\n        return new View.People(this);\n    }\n\n    /**\n     * @since 1.484\n     */\n    public View.AsynchPeople getAsynchPeople() {\n        return new View.AsynchPeople(this);\n    }\n\n    /**\n     * Does this {@link View} has any associated user information recorded?\n     * @deprecated Potentially very expensive call; do not use from Jelly views.\n     */\n    @Deprecated\n    public boolean hasPeople() {\n        return View.People.isApplicable(items.values());\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns a secret key that survives across container start/stop.\n     * <p>\n     * This value is useful for implementing some of the security features.\n     *\n     * @deprecated\n     *      Due to the past security advisory, this value should not be used any more to protect sensitive information.\n     *      See {@link ConfidentialStore} and {@link ConfidentialKey} for how to store secrets.\n     */\n    @Deprecated\n    public String getSecretKey() {\n        return secretKey;\n    }\n\n    /**\n     * Gets {@linkplain #getSecretKey() the secret key} as a key for AES-128.\n     * @since 1.308\n     * @deprecated\n     *       See {@link #getSecretKey()}.\n     */\n    @Deprecated\n    public SecretKey getSecretKeyAsAES128() {\n        return Util.toAes128Key(secretKey);\n    }\n\n    /**\n     * Returns the unique identifier of this Jenkins that has been historically used to identify\n     * this Jenkins to the outside world.\n     *\n     * <p>\n     * This form of identifier is weak in that it can be impersonated by others. See\n     * https://wiki.jenkins-ci.org/display/JENKINS/Instance+Identity for more modern form of instance ID\n     * that can be challenged and verified.\n     *\n     * @since 1.498\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getLegacyInstanceId() {\n        return Util.getDigestOf(getSecretKey());\n    }\n\n    /**\n     * Gets the SCM descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SCM> getScm(String shortClassName) {\n        return findDescriptor(shortClassName,SCM.all());\n    }\n\n    /**\n     * Gets the repository browser descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RepositoryBrowser<?>> getRepositoryBrowser(String shortClassName) {\n        return findDescriptor(shortClassName,RepositoryBrowser.all());\n    }\n\n    /**\n     * Gets the builder descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Builder> getBuilder(String shortClassName) {\n        return findDescriptor(shortClassName, Builder.all());\n    }\n\n    /**\n     * Gets the build wrapper descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<BuildWrapper> getBuildWrapper(String shortClassName) {\n        return findDescriptor(shortClassName, BuildWrapper.all());\n    }\n\n    /**\n     * Gets the publisher descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Publisher> getPublisher(String shortClassName) {\n        return findDescriptor(shortClassName, Publisher.all());\n    }\n\n    /**\n     * Gets the trigger descriptor by name. Primarily used for making them web-visible.\n     */\n    public TriggerDescriptor getTrigger(String shortClassName) {\n        return (TriggerDescriptor) findDescriptor(shortClassName, Trigger.all());\n    }\n\n    /**\n     * Gets the retention strategy descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RetentionStrategy<?>> getRetentionStrategy(String shortClassName) {\n        return findDescriptor(shortClassName, RetentionStrategy.all());\n    }\n\n    /**\n     * Gets the {@link JobPropertyDescriptor} by name. Primarily used for making them web-visible.\n     */\n    public JobPropertyDescriptor getJobProperty(String shortClassName) {\n        // combining these two lines triggers javac bug. See issue #610.\n        Descriptor d = findDescriptor(shortClassName, JobPropertyDescriptor.all());\n        return (JobPropertyDescriptor) d;\n    }\n\n    /**\n     * @deprecated\n     *      UI method. Not meant to be used programatically.\n     */\n    @Deprecated\n    public ComputerSet getComputer() {\n        return new ComputerSet();\n    }\n\n    /**\n     * Exposes {@link Descriptor} by its name to URL.\n     *\n     * After doing all the {@code getXXX(shortClassName)} methods, I finally realized that\n     * this just doesn't scale.\n     *\n     * @param id\n     *      Either {@link Descriptor#getId()} (recommended) or the short name of a {@link Describable} subtype (for compatibility)\n     * @throws IllegalArgumentException if a short name was passed which matches multiple IDs (fail fast)\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // too late to fix\n    public Descriptor getDescriptor(String id) {\n        // legacy descriptors that are reigstered manually doesn't show up in getExtensionList, so check them explicitly.\n        Iterable<Descriptor> descriptors = Iterators.sequence(getExtensionList(Descriptor.class), DescriptorExtensionList.listLegacyInstances());\n        for (Descriptor d : descriptors) {\n            if (d.getId().equals(id)) {\n                return d;\n            }\n        }\n        Descriptor candidate = null;\n        for (Descriptor d : descriptors) {\n            String name = d.getId();\n            if (name.substring(name.lastIndexOf('.') + 1).equals(id)) {\n                if (candidate == null) {\n                    candidate = d;\n                } else {\n                    throw new IllegalArgumentException(id + \" is ambiguous; matches both \" + name + \" and \" + candidate.getId());\n                }\n            }\n        }\n        return candidate;\n    }\n\n    /**\n     * Alias for {@link #getDescriptor(String)}.\n     */\n    public Descriptor getDescriptorByName(String id) {\n        return getDescriptor(id);\n    }\n\n    /**\n     * Gets the {@link Descriptor} that corresponds to the given {@link Describable} type.\n     * <p>\n     * If you have an instance of {@code type} and call {@link Describable#getDescriptor()},\n     * you'll get the same instance that this method returns.\n     */\n    public Descriptor getDescriptor(Class<? extends Describable> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.clazz==type)\n                return d;\n        return null;\n    }\n\n    /**\n     * Works just like {@link #getDescriptor(Class)} but don't take no for an answer.\n     *\n     * @throws AssertionError\n     *      If the descriptor is missing.\n     * @since 1.326\n     */\n    public Descriptor getDescriptorOrDie(Class<? extends Describable> type) {\n        Descriptor d = getDescriptor(type);\n        if (d==null)\n            throw new AssertionError(type+\" is missing its descriptor\");\n        return d;\n    }\n\n    /**\n     * Gets the {@link Descriptor} instance in the current Jenkins by its type.\n     */\n    public <T extends Descriptor> T getDescriptorByType(Class<T> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.getClass()==type)\n                return type.cast(d);\n        return null;\n    }\n\n    /**\n     * Gets the {@link SecurityRealm} descriptors by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SecurityRealm> getSecurityRealms(String shortClassName) {\n        return findDescriptor(shortClassName,SecurityRealm.all());\n    }\n\n    /**\n     * Finds a descriptor that has the specified name.\n     */\n    private <T extends Describable<T>>\n    Descriptor<T> findDescriptor(String shortClassName, Collection<? extends Descriptor<T>> descriptors) {\n        String name = '.'+shortClassName;\n        for (Descriptor<T> d : descriptors) {\n            if(d.clazz.getName().endsWith(name))\n                return d;\n        }\n        return null;\n    }\n\n    protected void updateComputerList() {\n        updateComputerList(AUTOMATIC_SLAVE_LAUNCH);\n    }\n\n    /** @deprecated Use {@link SCMListener#all} instead. */\n    @Deprecated\n    public CopyOnWriteList<SCMListener> getSCMListeners() {\n        return scmListeners;\n    }\n\n    /**\n     * Gets the plugin object from its short name.\n     *\n     * <p>\n     * This allows URL <tt>hudson/plugin/ID</tt> to be served by the views\n     * of the plugin class.\n     */\n    public Plugin getPlugin(String shortName) {\n        PluginWrapper p = pluginManager.getPlugin(shortName);\n        if(p==null)     return null;\n        return p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin object from its class.\n     *\n     * <p>\n     * This allows easy storage of plugin information in the plugin singleton without\n     * every plugin reimplementing the singleton pattern.\n     *\n     * @param clazz The plugin class (beware class-loader fun, this will probably only work\n     * from within the jpi that defines the plugin class, it may or may not work in other cases)\n     *\n     * @return The plugin instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <P extends Plugin> P getPlugin(Class<P> clazz) {\n        PluginWrapper p = pluginManager.getPlugin(clazz);\n        if(p==null)     return null;\n        return (P) p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin objects from their super-class.\n     *\n     * @param clazz The plugin class (beware class-loader fun)\n     *\n     * @return The plugin instances.\n     */\n    public <P extends Plugin> List<P> getPlugins(Class<P> clazz) {\n        List<P> result = new ArrayList<P>();\n        for (PluginWrapper w: pluginManager.getPlugins(clazz)) {\n            result.add((P)w.getPlugin());\n        }\n        return Collections.unmodifiableList(result);\n    }\n\n    /**\n     * Synonym for {@link #getDescription}.\n     */\n    public String getSystemMessage() {\n        return systemMessage;\n    }\n\n    /**\n     * Gets the markup formatter used in the system.\n     *\n     * @return\n     *      never null.\n     * @since 1.391\n     */\n    public @Nonnull MarkupFormatter getMarkupFormatter() {\n        MarkupFormatter f = markupFormatter;\n        return f != null ? f : new EscapedMarkupFormatter();\n    }\n\n    /**\n     * Sets the markup formatter used in the system globally.\n     *\n     * @since 1.391\n     */\n    public void setMarkupFormatter(MarkupFormatter f) {\n        this.markupFormatter = f;\n    }\n\n    /**\n     * Sets the system message.\n     */\n    public void setSystemMessage(String message) throws IOException {\n        this.systemMessage = message;\n        save();\n    }\n\n    public FederatedLoginService getFederatedLoginService(String name) {\n        for (FederatedLoginService fls : FederatedLoginService.all()) {\n            if (fls.getUrlName().equals(name))\n                return fls;\n        }\n        return null;\n    }\n\n    public List<FederatedLoginService> getFederatedLoginServices() {\n        return FederatedLoginService.all();\n    }\n\n    public Launcher createLauncher(TaskListener listener) {\n        return new LocalLauncher(listener).decorateFor(this);\n    }\n\n\n    public String getFullName() {\n        return \"\";\n    }\n\n    public String getFullDisplayName() {\n        return \"\";\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the top page.\n     *\n     * <p>\n     * Adding {@link Action} is primarily useful for plugins to contribute\n     * an item to the navigation bar of the top page. See existing {@link Action}\n     * implementation for it affects the GUI.\n     *\n     * <p>\n     * To register an {@link Action}, implement {@link RootAction} extension point, or write code like\n     * {@code Jenkins.getInstance().getActions().add(...)}.\n     *\n     * @return\n     *      Live list where the changes can be made. Can be empty but never null.\n     * @since 1.172\n     */\n    public List<Action> getActions() {\n        return actions;\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins}.\n     *\n     * @see #getAllItems(Class)\n     */\n    @Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n\t\tif (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n\t\t\tauthorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n\t\t\treturn new ArrayList(items.values());\n\t\t}\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\n        return viewableItems;\n    }\n\n    /**\n     * Returns the read-only view of all the {@link TopLevelItem}s keyed by their names.\n     * <p>\n     * This method is efficient, as it doesn't involve any copying.\n     *\n     * @since 1.296\n     */\n    public Map<String,TopLevelItem> getItemMap() {\n        return Collections.unmodifiableMap(items);\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins} but of the given type.\n     */\n    public <T> List<T> getItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        for (TopLevelItem i : getItems())\n            if (type.isInstance(i))\n                 r.add(type.cast(i));\n        return r;\n    }\n\n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     */\n    public <T extends Item> List<T> getAllItems(Class<T> type) {\n        return Items.getAllItems(this, type);\n    }\n\n    /**\n     * Gets all the items recursively.\n     *\n     * @since 1.402\n     */\n    public List<Item> getAllItems() {\n        return getAllItems(Item.class);\n    }\n\n    /**\n     * Gets a list of simple top-level projects.\n     * @deprecated This method will ignore Maven and matrix projects, as well as projects inside containers such as folders.\n     * You may prefer to call {@link #getAllItems(Class)} on {@link AbstractProject},\n     * perhaps also using {@link Util#createSubList} to consider only {@link TopLevelItem}s.\n     * (That will also consider the caller's permissions.)\n     * If you really want to get just {@link Project}s at top level, ignoring permissions,\n     * you can filter the values from {@link #getItemMap} using {@link Util#createSubList}.\n     */\n    @Deprecated\n    public List<Project> getProjects() {\n        return Util.createSubList(items.values(),Project.class);\n    }\n\n    /**\n     * Gets the names of all the {@link Job}s.\n     */\n    public Collection<String> getJobNames() {\n        List<String> names = new ArrayList<String>();\n        for (Job j : getAllItems(Job.class))\n            names.add(j.getFullName());\n        return names;\n    }\n\n    public List<Action> getViewActions() {\n        return getActions();\n    }\n\n    /**\n     * Gets the names of all the {@link TopLevelItem}s.\n     */\n    public Collection<String> getTopLevelItemNames() {\n        List<String> names = new ArrayList<String>();\n        for (TopLevelItem j : items.values())\n            names.add(j.getName());\n        return names;\n    }\n\n    public View getView(String name) {\n        return viewGroupMixIn.getView(name);\n    }\n\n    /**\n     * Gets the read-only list of all {@link View}s.\n     */\n    @Exported\n    public Collection<View> getViews() {\n        return viewGroupMixIn.getViews();\n    }\n\n    @Override\n    public void addView(View v) throws IOException {\n        viewGroupMixIn.addView(v);\n    }\n\n    public boolean canDelete(View view) {\n        return viewGroupMixIn.canDelete(view);\n    }\n\n    public synchronized void deleteView(View view) throws IOException {\n        viewGroupMixIn.deleteView(view);\n    }\n\n    public void onViewRenamed(View view, String oldName, String newName) {\n        viewGroupMixIn.onViewRenamed(view,oldName,newName);\n    }\n\n    /**\n     * Returns the primary {@link View} that renders the top-page of Jenkins.\n     */\n    @Exported\n    public View getPrimaryView() {\n        return viewGroupMixIn.getPrimaryView();\n     }\n\n    public void setPrimaryView(View v) {\n        this.primaryView = v.getViewName();\n    }\n\n    public ViewsTabBar getViewsTabBar() {\n        return viewsTabBar;\n    }\n\n    public void setViewsTabBar(ViewsTabBar viewsTabBar) {\n        this.viewsTabBar = viewsTabBar;\n    }\n\n    public Jenkins getItemGroup() {\n        return this;\n   }\n\n    public MyViewsTabBar getMyViewsTabBar() {\n        return myViewsTabBar;\n    }\n\n    public void setMyViewsTabBar(MyViewsTabBar myViewsTabBar) {\n        this.myViewsTabBar = myViewsTabBar;\n    }\n\n    /**\n     * Returns true if the current running Jenkins is upgraded from a version earlier than the specified version.\n     *\n     * <p>\n     * This method continues to return true until the system configuration is saved, at which point\n     * {@link #version} will be overwritten and Jenkins forgets the upgrade history.\n     *\n     * <p>\n     * To handle SNAPSHOTS correctly, pass in \"1.N.*\" to test if it's upgrading from the version\n     * equal or younger than N. So say if you implement a feature in 1.301 and you want to check\n     * if the installation upgraded from pre-1.301, pass in \"1.300.*\"\n     *\n     * @since 1.301\n     */\n    public boolean isUpgradedFromBefore(VersionNumber v) {\n        try {\n            return new VersionNumber(version).isOlderThan(v);\n        } catch (IllegalArgumentException e) {\n            // fail to parse this version number\n            return false;\n        }\n    }\n\n    /**\n     * Gets the read-only list of all {@link Computer}s.\n     */\n    public Computer[] getComputers() {\n        Computer[] r = computers.values().toArray(new Computer[computers.size()]);\n        Arrays.sort(r,new Comparator<Computer>() {\n            @Override public int compare(Computer lhs, Computer rhs) {\n                if(lhs.getNode()==Jenkins.this)  return -1;\n                if(rhs.getNode()==Jenkins.this)  return 1;\n                return lhs.getName().compareTo(rhs.getName());\n            }\n        });\n        return r;\n    }\n\n    @CLIResolver\n    public @CheckForNull Computer getComputer(@Argument(required=true,metaVar=\"NAME\",usage=\"Node name\") @Nonnull String name) {\n        if(name.equals(\"(master)\"))\n            name = \"\";\n\n        for (Computer c : computers.values()) {\n            if(c.getName().equals(name))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the label that exists on this system by the name.\n     *\n     * @return null if name is null.\n     * @see Label#parseExpression(String) (String)\n     */\n    public Label getLabel(String expr) {\n        if(expr==null)  return null;\n        expr = hudson.util.QuotedStringTokenizer.unquote(expr);\n        while(true) {\n            Label l = labels.get(expr);\n            if(l!=null)\n                return l;\n\n            // non-existent\n            try {\n                labels.putIfAbsent(expr,Label.parseExpression(expr));\n            } catch (ANTLRException e) {\n                // laxly accept it as a single label atom for backward compatibility\n                return getLabelAtom(expr);\n            }\n        }\n    }\n\n    /**\n     * Returns the label atom of the given name.\n     * @return non-null iff name is non-null\n     */\n    public @Nullable LabelAtom getLabelAtom(@CheckForNull String name) {\n        if (name==null)  return null;\n\n        while(true) {\n            Label l = labels.get(name);\n            if(l!=null)\n                return (LabelAtom)l;\n\n            // non-existent\n            LabelAtom la = new LabelAtom(name);\n            if (labels.putIfAbsent(name, la)==null)\n                la.load();\n        }\n    }\n\n    /**\n     * Gets all the active labels in the current system.\n     */\n    public Set<Label> getLabels() {\n        Set<Label> r = new TreeSet<Label>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty())\n                r.add(l);\n        }\n        return r;\n    }\n\n    public Set<LabelAtom> getLabelAtoms() {\n        Set<LabelAtom> r = new TreeSet<LabelAtom>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty() && l instanceof LabelAtom)\n                r.add((LabelAtom)l);\n        }\n        return r;\n    }\n\n    public Queue getQueue() {\n        return queue;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return Messages.Hudson_DisplayName();\n    }\n\n    public synchronized List<JDK> getJDKs() {\n        if(jdks==null)\n            jdks = new ArrayList<JDK>();\n        return jdks;\n    }\n\n    /**\n     * Replaces all JDK installations with those from the given collection.\n     *\n     * Use {@link hudson.model.JDK.DescriptorImpl#setInstallations(JDK...)} to\n     * set JDK installations from external code.\n     */\n    @Restricted(NoExternalUse.class)\n    public synchronized void setJDKs(Collection<? extends JDK> jdks) {\n        this.jdks = new ArrayList<JDK>(jdks);\n    }\n\n    /**\n     * Gets the JDK installation of the given name, or returns null.\n     */\n    public JDK getJDK(String name) {\n        if(name==null) {\n            // if only one JDK is configured, \"default JDK\" should mean that JDK.\n            List<JDK> jdks = getJDKs();\n            if(jdks.size()==1)  return jdks.get(0);\n            return null;\n        }\n        for (JDK j : getJDKs()) {\n            if(j.getName().equals(name))\n                return j;\n        }\n        return null;\n    }\n\n\n\n    /**\n     * Gets the slave node of the give name, hooked under this Jenkins.\n     */\n    public @CheckForNull Node getNode(String name) {\n        return nodes.getNode(name);\n    }\n\n    /**\n     * Gets a {@link Cloud} by {@link Cloud#name its name}, or null.\n     */\n    public Cloud getCloud(String name) {\n        return clouds.getByName(name);\n    }\n\n    protected Map<Node,Computer> getComputerMap() {\n        return computers;\n    }\n\n    /**\n     * Returns all {@link Node}s in the system, excluding {@link Jenkins} instance itself which\n     * represents the master.\n     */\n    public List<Node> getNodes() {\n        return nodes.getNodes();\n    }\n\n    /**\n     * Get the {@link Nodes} object that handles maintaining individual {@link Node}s.\n     * @return The Nodes object.\n     */\n    @Restricted(NoExternalUse.class)\n    public Nodes getNodesObject() {\n        // TODO replace this with something better when we properly expose Nodes.\n        return nodes;\n    }\n\n    /**\n     * Adds one more {@link Node} to Jenkins.\n     */\n    public void addNode(Node n) throws IOException {\n        nodes.addNode(n);\n    }\n\n    /**\n     * Removes a {@link Node} from Jenkins.\n     */\n    public void removeNode(@Nonnull Node n) throws IOException {\n        nodes.removeNode(n);\n    }\n\n    public void setNodes(final List<? extends Node> n) throws IOException {\n        nodes.setNodes(n);\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getNodeProperties() {\n    \treturn nodeProperties;\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getGlobalNodeProperties() {\n    \treturn globalNodeProperties;\n    }\n\n    /**\n     * Resets all labels and remove invalid ones.\n     *\n     * This should be called when the assumptions behind label cache computation changes,\n     * but we also call this periodically to self-heal any data out-of-sync issue.\n     */\n    /*package*/ void trimLabels() {\n        for (Iterator<Label> itr = labels.values().iterator(); itr.hasNext();) {\n            Label l = itr.next();\n            resetLabel(l);\n            if(l.isEmpty())\n                itr.remove();\n        }\n    }\n\n    /**\n     * Binds {@link AdministrativeMonitor}s to URL.\n     */\n    public AdministrativeMonitor getAdministrativeMonitor(String id) {\n        for (AdministrativeMonitor m : administrativeMonitors)\n            if(m.id.equals(id))\n                return m;\n        return null;\n    }\n\n    public NodeDescriptor getDescriptor() {\n        return DescriptorImpl.INSTANCE;\n    }\n\n    public static final class DescriptorImpl extends NodeDescriptor {\n        @Extension\n        public static final DescriptorImpl INSTANCE = new DescriptorImpl();\n\n        public String getDisplayName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isInstantiable() {\n            return false;\n        }\n\n        public FormValidation doCheckNumExecutors(@QueryParameter String value) {\n            return FormValidation.validateNonNegativeInteger(value);\n        }\n\n        public FormValidation doCheckRawBuildsDir(@QueryParameter String value) {\n            // do essentially what expandVariablesForDirectory does, without an Item\n            String replacedValue = expandVariablesForDirectory(value,\n                    \"doCheckRawBuildsDir-Marker:foo\",\n                    Jenkins.getInstance().getRootDir().getPath() + \"/jobs/doCheckRawBuildsDir-Marker$foo\");\n\n            File replacedFile = new File(replacedValue);\n            if (!replacedFile.isAbsolute()) {\n                return FormValidation.error(value + \" does not resolve to an absolute path\");\n            }\n\n            if (!replacedValue.contains(\"doCheckRawBuildsDir-Marker\")) {\n                return FormValidation.error(value + \" does not contain ${ITEM_FULL_NAME} or ${ITEM_ROOTDIR}, cannot distinguish between projects\");\n            }\n\n            if (replacedValue.contains(\"doCheckRawBuildsDir-Marker:foo\")) {\n                // make sure platform can handle colon\n                try {\n                    File tmp = File.createTempFile(\"Jenkins-doCheckRawBuildsDir\", \"foo:bar\");\n                    tmp.delete();\n                } catch (IOException e) {\n                    return FormValidation.error(value + \" contains ${ITEM_FULLNAME} but your system does not support it (JENKINS-12251). Use ${ITEM_FULL_NAME} instead\");\n                }\n            }\n\n            File d = new File(replacedValue);\n            if (!d.isDirectory()) {\n                // if dir does not exist (almost guaranteed) need to make sure nearest existing ancestor can be written to\n                d = d.getParentFile();\n                while (!d.exists()) {\n                    d = d.getParentFile();\n                }\n                if (!d.canWrite()) {\n                    return FormValidation.error(value + \" does not exist and probably cannot be created\");\n                }\n            }\n\n            return FormValidation.ok();\n        }\n\n        // to route /descriptor/FQCN/xxx to getDescriptor(FQCN).xxx\n        public Object getDynamic(String token) {\n            return Jenkins.getInstance().getDescriptor(token);\n        }\n    }\n\n    /**\n     * Gets the system default quiet period.\n     */\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : 5;\n    }\n\n    /**\n     * Sets the global quiet period.\n     *\n     * @param quietPeriod\n     *      null to the default value.\n     */\n    public void setQuietPeriod(Integer quietPeriod) throws IOException {\n        this.quietPeriod = quietPeriod;\n        save();\n    }\n\n    /**\n     * Gets the global SCM check out retry count.\n     */\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount;\n    }\n\n    public void setScmCheckoutRetryCount(int scmCheckoutRetryCount) throws IOException {\n        this.scmCheckoutRetryCount = scmCheckoutRetryCount;\n        save();\n    }\n\n    @Override\n    public String getSearchUrl() {\n        return \"\";\n    }\n\n    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }\n                protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return viewGroupMixIn.getViews(); }\n            });\n    }\n\n    public String getUrlChildPrefix() {\n        return \"job\";\n    }\n\n    /**\n     * Gets the absolute URL of Jenkins, such as {@code http://localhost/jenkins/}.\n     *\n     * <p>\n     * This method first tries to use the manually configured value, then\n     * fall back to {@link #getRootUrlFromRequest}.\n     * It is done in this order so that it can work correctly even in the face\n     * of a reverse proxy.\n     *\n     * @return null if this parameter is not configured by the user and the calling thread is not in an HTTP request; otherwise the returned URL will always have the trailing {@code /}\n     * @since 1.66\n     * @see <a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML\">Hyperlinks in HTML</a>\n     */\n    public @Nullable String getRootUrl() {\n        String url = JenkinsLocationConfiguration.get().getUrl();\n        if(url!=null) {\n            return Util.ensureEndsWith(url,\"/\");\n        }\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            return getRootUrlFromRequest();\n        return null;\n    }\n\n    /**\n     * Is Jenkins running in HTTPS?\n     *\n     * Note that we can't really trust {@link StaplerRequest#isSecure()} because HTTPS might be terminated\n     * in the reverse proxy.\n     */\n    public boolean isRootUrlSecure() {\n        String url = getRootUrl();\n        return url!=null && url.startsWith(\"https\");\n    }\n\n    /**\n     * Gets the absolute URL of Jenkins top page, such as {@code http://localhost/jenkins/}.\n     *\n     * <p>\n     * Unlike {@link #getRootUrl()}, which uses the manually configured value,\n     * this one uses the current request to reconstruct the URL. The benefit is\n     * that this is immune to the configuration mistake (users often fail to set the root URL\n     * correctly, especially when a migration is involved), but the downside\n     * is that unless you are processing a request, this method doesn't work.\n     *\n     * <p>Please note that this will not work in all cases if Jenkins is running behind a\n     * reverse proxy which has not been fully configured.\n     * Specifically the {@code Host} and {@code X-Forwarded-Proto} headers must be set.\n     * <a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Running+Jenkins+behind+Apache\">Running Jenkins behind Apache</a>\n     * shows some examples of configuration.\n     * @since 1.263\n     */\n    public @Nonnull String getRootUrlFromRequest() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if (req == null) {\n            throw new IllegalStateException(\"cannot call getRootUrlFromRequest from outside a request handling thread\");\n        }\n        StringBuilder buf = new StringBuilder();\n        String scheme = getXForwardedHeader(req, \"X-Forwarded-Proto\", req.getScheme());\n        buf.append(scheme).append(\"://\");\n        String host = getXForwardedHeader(req, \"X-Forwarded-Host\", req.getServerName());\n        int index = host.indexOf(':');\n        int port = req.getServerPort();\n        if (index == -1) {\n            // Almost everyone else except Nginx put the host and port in separate headers\n            buf.append(host);\n        } else {\n            // Nginx uses the same spec as for the Host header, i.e. hostanme:port\n            buf.append(host.substring(0, index));\n            if (index + 1 < host.length()) {\n                try {\n                    port = Integer.parseInt(host.substring(index + 1));\n                } catch (NumberFormatException e) {\n                    // ignore\n                }\n            }\n            // but if a user has configured Nginx with an X-Forwarded-Port, that will win out.\n        }\n        String forwardedPort = getXForwardedHeader(req, \"X-Forwarded-Port\", null);\n        if (forwardedPort != null) {\n            try {\n                port = Integer.parseInt(forwardedPort);\n            } catch (NumberFormatException e) {\n                // ignore\n            }\n        }\n        if (port != (\"https\".equals(scheme) ? 443 : 80)) {\n            buf.append(':').append(port);\n        }\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    /**\n     * Gets the originating \"X-Forwarded-...\" header from the request. If there are multiple headers the originating\n     * header is the first header. If the originating header contains a comma separated list, the originating entry\n     * is the first one.\n     * @param req the request\n     * @param header the header name\n     * @param defaultValue the value to return if the header is absent.\n     * @return the originating entry of the header or the default value if the header was not present.\n     */\n    private static String getXForwardedHeader(StaplerRequest req, String header, String defaultValue) {\n        String value = req.getHeader(header);\n        if (value != null) {\n            int index = value.indexOf(',');\n            return index == -1 ? value.trim() : value.substring(0,index).trim();\n        }\n        return defaultValue;\n    }\n\n    public File getRootDir() {\n        return root;\n    }\n\n    public FilePath getWorkspaceFor(TopLevelItem item) {\n        for (WorkspaceLocator l : WorkspaceLocator.all()) {\n            FilePath workspace = l.locate(item, this);\n            if (workspace != null) {\n                return workspace;\n            }\n        }\n\n        return new FilePath(expandVariablesForDirectory(workspaceDir, item));\n    }\n\n    public File getBuildDirFor(Job job) {\n        return expandVariablesForDirectory(buildsDir, job);\n    }\n\n    private File expandVariablesForDirectory(String base, Item item) {\n        return new File(expandVariablesForDirectory(base, item.getFullName(), item.getRootDir().getPath()));\n    }\n\n    @Restricted(NoExternalUse.class)\n    static String expandVariablesForDirectory(String base, String itemFullName, String itemRootDir) {\n        return Util.replaceMacro(base, ImmutableMap.of(\n                \"JENKINS_HOME\", Jenkins.getInstance().getRootDir().getPath(),\n                \"ITEM_ROOTDIR\", itemRootDir,\n                \"ITEM_FULLNAME\", itemFullName,   // legacy, deprecated\n                \"ITEM_FULL_NAME\", itemFullName.replace(':','$'))); // safe, see JENKINS-12251\n\n    }\n\n    public String getRawWorkspaceDir() {\n        return workspaceDir;\n    }\n\n    public String getRawBuildsDir() {\n        return buildsDir;\n    }\n\n    @Restricted(NoExternalUse.class)\n    public void setRawBuildsDir(String buildsDir) {\n        this.buildsDir = buildsDir;\n    }\n\n    @Override public @Nonnull FilePath getRootPath() {\n        return new FilePath(getRootDir());\n    }\n\n    @Override\n    public FilePath createPath(String absolutePath) {\n        return new FilePath((VirtualChannel)null,absolutePath);\n    }\n\n    public ClockDifference getClockDifference() {\n        return ClockDifference.ZERO;\n    }\n\n    @Override\n    public Callable<ClockDifference, IOException> getClockDifferenceCallable() {\n        return new MasterToSlaveCallable<ClockDifference, IOException>() {\n            public ClockDifference call() throws IOException {\n                return new ClockDifference(0);\n            }\n        };\n    }\n\n    /**\n     * For binding {@link LogRecorderManager} to \"/log\".\n     * Everything below here is admin-only, so do the check here.\n     */\n    public LogRecorderManager getLog() {\n        checkPermission(ADMINISTER);\n        return log;\n    }\n\n    /**\n     * A convenience method to check if there's some security\n     * restrictions in place.\n     */\n    @Exported\n    public boolean isUseSecurity() {\n        return securityRealm!=SecurityRealm.NO_AUTHENTICATION || authorizationStrategy!=AuthorizationStrategy.UNSECURED;\n    }\n\n    public boolean isUseProjectNamingStrategy(){\n        return projectNamingStrategy != DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n    }\n\n    /**\n     * If true, all the POST requests to Jenkins would have to have crumb in it to protect\n     * Jenkins from CSRF vulnerabilities.\n     */\n    @Exported\n    public boolean isUseCrumbs() {\n        return crumbIssuer!=null;\n    }\n\n    /**\n     * Returns the constant that captures the three basic security modes in Jenkins.\n     */\n    public SecurityMode getSecurity() {\n        // fix the variable so that this code works under concurrent modification to securityRealm.\n        SecurityRealm realm = securityRealm;\n\n        if(realm==SecurityRealm.NO_AUTHENTICATION)\n            return SecurityMode.UNSECURED;\n        if(realm instanceof LegacySecurityRealm)\n            return SecurityMode.LEGACY;\n        return SecurityMode.SECURED;\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public SecurityRealm getSecurityRealm() {\n        return securityRealm;\n    }\n\n    public void setSecurityRealm(SecurityRealm securityRealm) {\n        if(securityRealm==null)\n            securityRealm= SecurityRealm.NO_AUTHENTICATION;\n        this.useSecurity = true;\n        IdStrategy oldUserIdStrategy = this.securityRealm == null\n                ? securityRealm.getUserIdStrategy() // don't trigger rekey on Jenkins load\n                : this.securityRealm.getUserIdStrategy();\n        this.securityRealm = securityRealm;\n        // reset the filters and proxies for the new SecurityRealm\n        try {\n            HudsonFilter filter = HudsonFilter.get(servletContext);\n            if (filter == null) {\n                // Fix for #3069: This filter is not necessarily initialized before the servlets.\n                // when HudsonFilter does come back, it'll initialize itself.\n                LOGGER.fine(\"HudsonFilter has not yet been initialized: Can't perform security setup for now\");\n            } else {\n                LOGGER.fine(\"HudsonFilter has been previously initialized: Setting security up\");\n                filter.reset(securityRealm);\n                LOGGER.fine(\"Security is now fully set up\");\n            }\n            if (!oldUserIdStrategy.equals(this.securityRealm.getUserIdStrategy())) {\n                User.rekey();\n            }\n        } catch (ServletException e) {\n            // for binary compatibility, this method cannot throw a checked exception\n            throw new AcegiSecurityException(\"Failed to configure filter\",e) {};\n        }\n    }\n\n    public void setAuthorizationStrategy(AuthorizationStrategy a) {\n        if (a == null)\n            a = AuthorizationStrategy.UNSECURED;\n        useSecurity = true;\n        authorizationStrategy = a;\n    }\n\n    public boolean isDisableRememberMe() {\n        return disableRememberMe;\n    }\n\n    public void setDisableRememberMe(boolean disableRememberMe) {\n        this.disableRememberMe = disableRememberMe;\n    }\n\n    public void disableSecurity() {\n        useSecurity = null;\n        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n    }\n\n    public void setProjectNamingStrategy(ProjectNamingStrategy ns) {\n        if(ns == null){\n            ns = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n        }\n        projectNamingStrategy = ns;\n    }\n\n    public Lifecycle getLifecycle() {\n        return Lifecycle.get();\n    }\n\n    /**\n     * Gets the dependency injection container that hosts all the extension implementations and other\n     * components in Jenkins.\n     *\n     * @since 1.433\n     */\n    public Injector getInjector() {\n        return lookup(Injector.class);\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered instances for the given extension type.\n     *\n     * @param extensionType\n     *      The base type that represents the extension point. Normally {@link ExtensionPoint} subtype\n     *      but that's not a hard requirement.\n     * @return\n     *      Can be an empty list but never null.\n     * @see ExtensionList#lookup\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T> ExtensionList<T> getExtensionList(Class<T> extensionType) {\n        return extensionLists.get(extensionType);\n    }\n\n    /**\n     * Used to bind {@link ExtensionList}s to URLs.\n     *\n     * @since 1.349\n     */\n    public ExtensionList getExtensionList(String extensionType) throws ClassNotFoundException {\n        return getExtensionList(pluginManager.uberClassLoader.loadClass(extensionType));\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered {@link Descriptor} instances for the given\n     * kind of {@link Describable}.\n     *\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends Describable<T>,D extends Descriptor<T>> DescriptorExtensionList<T,D> getDescriptorList(Class<T> type) {\n        return descriptorLists.get(type);\n    }\n\n    /**\n     * Refresh {@link ExtensionList}s by adding all the newly discovered extensions.\n     *\n     * Exposed only for {@link PluginManager#dynamicLoad(File)}.\n     */\n    public void refreshExtensions() throws ExtensionRefreshException {\n        ExtensionList<ExtensionFinder> finders = getExtensionList(ExtensionFinder.class);\n        for (ExtensionFinder ef : finders) {\n            if (!ef.isRefreshable())\n                throw new ExtensionRefreshException(ef+\" doesn't support refresh\");\n        }\n\n        List<ExtensionComponentSet> fragments = Lists.newArrayList();\n        for (ExtensionFinder ef : finders) {\n            fragments.add(ef.refresh());\n        }\n        ExtensionComponentSet delta = ExtensionComponentSet.union(fragments).filtered();\n\n        // if we find a new ExtensionFinder, we need it to list up all the extension points as well\n        List<ExtensionComponent<ExtensionFinder>> newFinders = Lists.newArrayList(delta.find(ExtensionFinder.class));\n        while (!newFinders.isEmpty()) {\n            ExtensionFinder f = newFinders.remove(newFinders.size()-1).getInstance();\n\n            ExtensionComponentSet ecs = ExtensionComponentSet.allOf(f).filtered();\n            newFinders.addAll(ecs.find(ExtensionFinder.class));\n            delta = ExtensionComponentSet.union(delta, ecs);\n        }\n\n        for (ExtensionList el : extensionLists.values()) {\n            el.refresh(delta);\n        }\n        for (ExtensionList el : descriptorLists.values()) {\n            el.refresh(delta);\n        }\n\n        // TODO: we need some generalization here so that extension points can be notified when a refresh happens?\n        for (ExtensionComponent<RootAction> ea : delta.find(RootAction.class)) {\n            Action a = ea.getInstance();\n            if (!actions.contains(a)) actions.add(a);\n        }\n    }\n\n    /**\n     * Returns the root {@link ACL}.\n     *\n     * @see AuthorizationStrategy#getRootACL()\n     */\n    @Override\n    public ACL getACL() {\n        return authorizationStrategy.getRootACL();\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public AuthorizationStrategy getAuthorizationStrategy() {\n        return authorizationStrategy;\n    }\n\n    /**\n     * The strategy used to check the project names.\n     * @return never <code>null</code>\n     */\n    public ProjectNamingStrategy getProjectNamingStrategy() {\n        return projectNamingStrategy == null ? ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY : projectNamingStrategy;\n    }\n\n    /**\n     * Returns true if Jenkins is quieting down.\n     * <p>\n     * No further jobs will be executed unless it\n     * can be finished while other current pending builds\n     * are still in progress.\n     */\n    @Exported\n    public boolean isQuietingDown() {\n        return isQuietingDown;\n    }\n\n    /**\n     * Returns true if the container initiated the termination of the web application.\n     */\n    public boolean isTerminating() {\n        return terminating;\n    }\n\n    /**\n     * Gets the initialization milestone that we've already reached.\n     *\n     * @return\n     *      {@link InitMilestone#STARTED} even if the initialization hasn't been started, so that this method\n     *      never returns null.\n     */\n    public InitMilestone getInitLevel() {\n        return initLevel;\n    }\n\n    public void setNumExecutors(int n) throws IOException {\n        if (this.numExecutors != n) {\n            this.numExecutors = n;\n            updateComputerList();\n            save();\n        }\n    }\n\n\n\n    /**\n     * {@inheritDoc}.\n     *\n     * Note that the look up is case-insensitive.\n     */\n    @Override public TopLevelItem getItem(String name) throws AccessDeniedException {\n        if (name==null)    return null;\n    \tTopLevelItem item = items.get(name);\n        if (item==null)\n            return null;\n        if (!item.hasPermission(Item.READ)) {\n            if (item.hasPermission(Item.DISCOVER)) {\n                throw new AccessDeniedException(\"Please login to access job \" + name);\n            }\n            return null;\n        }\n        return item;\n    }\n\n    /**\n     * Gets the item by its path name from the given context\n     *\n     * <h2>Path Names</h2>\n     * <p>\n     * If the name starts from '/', like \"/foo/bar/zot\", then it's interpreted as absolute.\n     * Otherwise, the name should be something like \"foo/bar\" and it's interpreted like\n     * relative path name in the file system is, against the given context.\n     * <p>For compatibility, as a fallback when nothing else matches, a simple path\n     * like {@code foo/bar} can also be treated with {@link #getItemByFullName}.\n     * @param context\n     *      null is interpreted as {@link Jenkins}. Base 'directory' of the interpretation.\n     * @since 1.406\n     */\n    public Item getItem(String pathName, ItemGroup context) {\n        if (context==null)  context = this;\n        if (pathName==null) return null;\n\n        if (pathName.startsWith(\"/\"))   // absolute\n            return getItemByFullName(pathName);\n\n        Object/*Item|ItemGroup*/ ctx = context;\n\n        StringTokenizer tokens = new StringTokenizer(pathName,\"/\");\n        while (tokens.hasMoreTokens()) {\n            String s = tokens.nextToken();\n            if (s.equals(\"..\")) {\n                if (ctx instanceof Item) {\n                    ctx = ((Item)ctx).getParent();\n                    continue;\n                }\n\n                ctx=null;    // can't go up further\n                break;\n            }\n            if (s.equals(\".\")) {\n                continue;\n            }\n\n            if (ctx instanceof ItemGroup) {\n                ItemGroup g = (ItemGroup) ctx;\n                Item i = g.getItem(s);\n                if (i==null || !i.hasPermission(Item.READ)) { // TODO consider DISCOVER\n                    ctx=null;    // can't go up further\n                    break;\n                }\n                ctx=i;\n            } else {\n                return null;\n            }\n        }\n\n        if (ctx instanceof Item)\n            return (Item)ctx;\n\n        // fall back to the classic interpretation\n        return getItemByFullName(pathName);\n    }\n\n    public final Item getItem(String pathName, Item context) {\n        return getItem(pathName,context!=null?context.getParent():null);\n    }\n\n    public final <T extends Item> T getItem(String pathName, ItemGroup context, @Nonnull Class<T> type) {\n        Item r = getItem(pathName, context);\n        if (type.isInstance(r))\n            return type.cast(r);\n        return null;\n    }\n\n    public final <T extends Item> T getItem(String pathName, Item context, Class<T> type) {\n        return getItem(pathName,context!=null?context.getParent():null,type);\n    }\n\n    public File getRootDirFor(TopLevelItem child) {\n        return getRootDirFor(child.getName());\n    }\n\n    private File getRootDirFor(String name) {\n        return new File(new File(getRootDir(),\"jobs\"), name);\n    }\n\n    /**\n     * Gets the {@link Item} object by its full name.\n     * Full names are like path names, where each name of {@link Item} is\n     * combined by '/'.\n     *\n     * @return\n     *      null if either such {@link Item} doesn't exist under the given full name,\n     *      or it exists but it's no an instance of the given type.\n     * @throws AccessDeniedException as per {@link ItemGroup#getItem}\n     */\n    public @CheckForNull <T extends Item> T getItemByFullName(String fullName, Class<T> type) throws AccessDeniedException {\n        StringTokenizer tokens = new StringTokenizer(fullName,\"/\");\n        ItemGroup parent = this;\n\n        if(!tokens.hasMoreTokens()) return null;    // for example, empty full name.\n\n        while(true) {\n            Item item = parent.getItem(tokens.nextToken());\n            if(!tokens.hasMoreTokens()) {\n                if(type.isInstance(item))\n                    return type.cast(item);\n                else\n                    return null;\n            }\n\n            if(!(item instanceof ItemGroup))\n                return null;    // this item can't have any children\n\n            if (!item.hasPermission(Item.READ))\n                return null; // TODO consider DISCOVER\n\n            parent = (ItemGroup) item;\n        }\n    }\n\n    public @CheckForNull Item getItemByFullName(String fullName) {\n        return getItemByFullName(fullName,Item.class);\n    }\n\n    /**\n     * Gets the user of the given name.\n     *\n     * @return the user of the given name (which may or may not be an id), if that person exists or the invoker {@link #hasPermission} on {@link #ADMINISTER}; else null\n     * @see User#get(String,boolean), {@link User#getById(String, boolean)}\n     */\n    public @CheckForNull User getUser(String name) {\n        return User.get(name,hasPermission(ADMINISTER));\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name ) throws IOException {\n        return createProject(type, name, true);\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify ) throws IOException {\n        return itemGroupMixIn.createProject(type,name,notify);\n    }\n\n    /**\n     * Overwrites the existing item by new one.\n     *\n     * <p>\n     * This is a short cut for deleting an existing job and adding a new one.\n     */\n    public synchronized void putItem(TopLevelItem item) throws IOException, InterruptedException {\n        String name = item.getName();\n        TopLevelItem old = items.get(name);\n        if (old ==item)  return; // noop\n\n        checkPermission(Item.CREATE);\n        if (old!=null)\n            old.delete();\n        items.put(name,item);\n        ItemListener.fireOnCreated(item);\n    }\n\n    /**\n     * Creates a new job.\n     *\n     * <p>\n     * This version infers the descriptor from the type of the top-level item.\n     *\n     * @throws IllegalArgumentException\n     *      if the project of the given name already exists.\n     */\n    public synchronized <T extends TopLevelItem> T createProject( Class<T> type, String name ) throws IOException {\n        return type.cast(createProject((TopLevelItemDescriptor)getDescriptor(type),name));\n    }\n\n    /**\n     * Called by {@link Job#renameTo(String)} to update relevant data structure.\n     * assumed to be synchronized on Jenkins by the caller.\n     */\n    public void onRenamed(TopLevelItem job, String oldName, String newName) throws IOException {\n        items.remove(oldName);\n        items.put(newName,job);\n\n        // For compatibility with old views:\n        for (View v : views)\n            v.onJobRenamed(job, oldName, newName);\n    }\n\n    /**\n     * Called in response to {@link Job#doDoDelete(StaplerRequest, StaplerResponse)}\n     */\n    public void onDeleted(TopLevelItem item) throws IOException {\n        ItemListener.fireOnDeleted(item);\n\n        items.remove(item.getName());\n        // For compatibility with old views:\n        for (View v : views)\n            v.onJobRenamed(item, item.getName(), null);\n    }\n\n    @Override public boolean canAdd(TopLevelItem item) {\n        return true;\n    }\n\n    @Override synchronized public <I extends TopLevelItem> I add(I item, String name) throws IOException, IllegalArgumentException {\n        if (items.containsKey(name)) {\n            throw new IllegalArgumentException(\"already an item '\" + name + \"'\");\n        }\n        items.put(name, item);\n        return item;\n    }\n\n    @Override public void remove(TopLevelItem item) throws IOException, IllegalArgumentException {\n        items.remove(item.getName());\n    }\n\n    public FingerprintMap getFingerprintMap() {\n        return fingerprintMap;\n    }\n\n    // if no finger print matches, display \"not found page\".\n    public Object getFingerprint( String md5sum ) throws IOException {\n        Fingerprint r = fingerprintMap.get(md5sum);\n        if(r==null)     return new NoFingerprintMatch(md5sum);\n        else            return r;\n    }\n\n    /**\n     * Gets a {@link Fingerprint} object if it exists.\n     * Otherwise null.\n     */\n    public Fingerprint _getFingerprint( String md5sum ) throws IOException {\n        return fingerprintMap.get(md5sum);\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    private XmlFile getConfigFile() {\n        return new XmlFile(XSTREAM, new File(root,\"config.xml\"));\n    }\n\n    public int getNumExecutors() {\n        return numExecutors;\n    }\n\n    public Mode getMode() {\n        return mode;\n    }\n\n    public void setMode(Mode m) throws IOException {\n        this.mode = m;\n        save();\n    }\n\n    public String getLabelString() {\n        return fixNull(label).trim();\n    }\n\n    @Override\n    public void setLabelString(String label) throws IOException {\n        this.label = label;\n        save();\n    }\n\n    @Override\n    public LabelAtom getSelfLabel() {\n        return getLabelAtom(\"master\");\n    }\n\n    public Computer createComputer() {\n        return new Hudson.MasterComputer();\n    }\n\n    private synchronized TaskBuilder loadTasks() throws IOException {\n        File projectsDir = new File(root,\"jobs\");\n        if(!projectsDir.getCanonicalFile().isDirectory() && !projectsDir.mkdirs()) {\n            if(projectsDir.exists())\n                throw new IOException(projectsDir+\" is not a directory\");\n            throw new IOException(\"Unable to create \"+projectsDir+\"\\nPermission issue? Please create this directory manually.\");\n        }\n        File[] subdirs = projectsDir.listFiles();\n\n        final Set<String> loadedNames = Collections.synchronizedSet(new HashSet<String>());\n\n        TaskGraphBuilder g = new TaskGraphBuilder();\n        Handle loadJenkins = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(\"Loading global config\", new Executable() {\n            public void run(Reactor session) throws Exception {\n                XmlFile cfg = getConfigFile();\n                if (cfg.exists()) {\n                    // reset some data that may not exist in the disk file\n                    // so that we can take a proper compensation action later.\n                    primaryView = null;\n                    views.clear();\n\n                    // load from disk\n                    cfg.unmarshal(Jenkins.this);\n                }\n\n                // if we are loading old data that doesn't have this field\n                if (slaves != null && !slaves.isEmpty() && nodes.isLegacy()) {\n                    nodes.setNodes(slaves);\n                    slaves = null;\n                } else {\n                    nodes.load();\n                }\n\n                clouds.setOwner(Jenkins.this);\n            }\n        });\n\n        for (final File subdir : subdirs) {\n            g.requires(loadJenkins).attains(JOB_LOADED).notFatal().add(\"Loading job \"+subdir.getName(),new Executable() {\n                public void run(Reactor session) throws Exception {\n                    if(!Items.getConfigFile(subdir).exists()) {\n                        //Does not have job config file, so it is not a jenkins job hence skip it\n                        return;\n                    }\n                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);\n                    items.put(item.getName(), item);\n                    loadedNames.add(item.getName());\n                }\n            });\n        }\n\n        g.requires(JOB_LOADED).add(\"Cleaning up old builds\",new Executable() {\n            public void run(Reactor reactor) throws Exception {\n                // anything we didn't load from disk, throw them away.\n                // doing this after loading from disk allows newly loaded items\n                // to inspect what already existed in memory (in case of reloading)\n\n                // retainAll doesn't work well because of CopyOnWriteMap implementation, so remove one by one\n                // hopefully there shouldn't be too many of them.\n                for (String name : items.keySet()) {\n                    if (!loadedNames.contains(name))\n                        items.remove(name);\n                }\n            }\n        });\n\n        g.requires(JOB_LOADED).add(\"Finalizing set up\",new Executable() {\n            public void run(Reactor session) throws Exception {\n                rebuildDependencyGraph();\n\n                {// recompute label objects - populates the labels mapping.\n                    for (Node slave : nodes.getNodes())\n                        // Note that not all labels are visible until the slaves have connected.\n                        slave.getAssignedLabels();\n                    getAssignedLabels();\n                }\n\n                // initialize views by inserting the default view if necessary\n                // this is both for clean Jenkins and for backward compatibility.\n                if(views.size()==0 || primaryView==null) {\n                    View v = new AllView(Messages.Hudson_ViewName());\n                    setViewOwner(v);\n                    views.add(0,v);\n                    primaryView = v.getViewName();\n                }\n\n                if (useSecurity!=null && !useSecurity) {\n                    // forced reset to the unsecure mode.\n                    // this works as an escape hatch for people who locked themselves out.\n                    authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                } else {\n                    // read in old data that doesn't have the security field set\n                    if(authorizationStrategy==null) {\n                        if(useSecurity==null)\n                            authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                        else\n                            authorizationStrategy = new LegacyAuthorizationStrategy();\n                    }\n                    if(securityRealm==null) {\n                        if(useSecurity==null)\n                            setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                        else\n                            setSecurityRealm(new LegacySecurityRealm());\n                    } else {\n                        // force the set to proxy\n                        setSecurityRealm(securityRealm);\n                    }\n                }\n\n\n                // Initialize the filter with the crumb issuer\n                setCrumbIssuer(crumbIssuer);\n\n                // auto register root actions\n                for (Action a : getExtensionList(RootAction.class))\n                    if (!actions.contains(a)) actions.add(a);\n            }\n        });\n\n        return g;\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException {\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n\n    /**\n     * Called to shut down the system.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n    public void cleanUp() {\n        for (ItemListener l : ItemListener.all())\n            l.onBeforeShutdown();\n\n        try {\n            final TerminatorFinder tf = new TerminatorFinder(\n                    pluginManager != null ? pluginManager.uberClassLoader : Thread.currentThread().getContextClassLoader());\n            new Reactor(tf).execute(new Executor() {\n                @Override\n                public void execute(Runnable command) {\n                    command.run();\n                }\n            });\n        } catch (InterruptedException e) {\n            LOGGER.log(SEVERE, \"Failed to execute termination\",e);\n            e.printStackTrace();\n        } catch (ReactorException e) {\n            LOGGER.log(SEVERE, \"Failed to execute termination\",e);\n        } catch (IOException e) {\n            LOGGER.log(SEVERE, \"Failed to execute termination\",e);\n        }\n\n        final Set<Future<?>> pending = new HashSet<Future<?>>();\n        terminating = true;\n        // JENKINS-28840 we know we will be interrupting all the Computers so get the Queue lock once for all\n        Queue.withLock(new Runnable() {\n            @Override\n            public void run() {\n                for( Computer c : computers.values() ) {\n                    c.interrupt();\n                    killComputer(c);\n                    pending.add(c.disconnect(null));\n                }\n            }\n        });\n        if(udpBroadcastThread!=null)\n            udpBroadcastThread.shutdown();\n        if(dnsMultiCast!=null)\n            dnsMultiCast.close();\n        interruptReloadThread();\n\n        java.util.Timer timer = Trigger.timer;\n        if (timer != null) {\n            timer.cancel();\n        }\n        // TODO: how to wait for the completion of the last job?\n        Trigger.timer = null;\n\n        Timer.shutdown();\n\n        if(tcpSlaveAgentListener!=null)\n            tcpSlaveAgentListener.shutdown();\n\n        if(pluginManager!=null) // be defensive. there could be some ugly timing related issues\n            pluginManager.stop();\n\n        if(getRootDir().exists())\n            // if we are aborting because we failed to create JENKINS_HOME,\n            // don't try to save. Issue #536\n            getQueue().save();\n\n        threadPoolForLoad.shutdown();\n        for (Future<?> f : pending)\n            try {\n                f.get(10, TimeUnit.SECONDS);    // if clean up operation didn't complete in time, we fail the test\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;  // someone wants us to die now. quick!\n            } catch (ExecutionException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            } catch (TimeoutException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            }\n\n        LogFactory.releaseAll();\n\n        theInstance = null;\n    }\n\n    public Object getDynamic(String token) {\n        for (Action a : getActions()) {\n            String url = a.getUrlName();\n            if (url==null)  continue;\n            if (url.equals(token) || url.equals('/' + token))\n                return a;\n        }\n        for (Action a : getManagementLinks())\n            if(a.getUrlName().equals(token))\n                return a;\n        return null;\n    }\n\n\n//\n//\n// actions\n//\n//\n    /**\n     * Accepts submission from the configuration page.\n     */\n    public synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        BulkChange bc = new BulkChange(this);\n        try {\n            checkPermission(ADMINISTER);\n\n            JSONObject json = req.getSubmittedForm();\n\n            workspaceDir = json.getString(\"rawWorkspaceDir\");\n            buildsDir = json.getString(\"rawBuildsDir\");\n\n            systemMessage = Util.nullify(req.getParameter(\"system_message\"));\n\n            setJDKs(req.bindJSONToList(JDK.class, json.get(\"jdks\")));\n\n            boolean result = true;\n            for (Descriptor<?> d : Functions.getSortedDescriptorsForGlobalConfigUnclassified())\n                result &= configureDescriptor(req,json,d);\n\n            version = VERSION;\n\n            save();\n            updateComputerList();\n            if(result)\n                FormApply.success(req.getContextPath()+'/').generateResponse(req, rsp, null);\n            else\n                FormApply.success(\"configure\").generateResponse(req, rsp, null);    // back to config\n        } finally {\n            bc.commit();\n        }\n    }\n\n    /**\n     * Gets the {@link CrumbIssuer} currently in use.\n     *\n     * @return null if none is in use.\n     */\n    public CrumbIssuer getCrumbIssuer() {\n        return crumbIssuer;\n    }\n\n    public void setCrumbIssuer(CrumbIssuer issuer) {\n        crumbIssuer = issuer;\n    }\n\n    public synchronized void doTestPost( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rsp.sendRedirect(\"foo\");\n    }\n\n    private boolean configureDescriptor(StaplerRequest req, JSONObject json, Descriptor<?> d) throws FormException {\n        // collapse the structure to remain backward compatible with the JSON structure before 1.\n        String name = d.getJsonSafeClassName();\n        JSONObject js = json.has(name) ? json.getJSONObject(name) : new JSONObject(); // if it doesn't have the property, the method returns invalid null object.\n        json.putAll(js);\n        return d.configure(req, js);\n    }\n\n    /**\n     * Accepts submission from the node configuration page.\n     */\n    @RequirePOST\n    public synchronized void doConfigExecutorsSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(ADMINISTER);\n\n        BulkChange bc = new BulkChange(this);\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            MasterBuildConfiguration mbc = MasterBuildConfiguration.all().get(MasterBuildConfiguration.class);\n            if (mbc!=null)\n                mbc.configure(req,json);\n\n            getNodeProperties().rebuild(req, json.optJSONObject(\"nodeProperties\"), NodeProperty.all());\n        } finally {\n            bc.commit();\n        }\n\n        updateComputerList();\n\n        rsp.sendRedirect(req.getContextPath()+'/'+toComputer().getUrl());  // back to the computer page\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    @RequirePOST\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        getPrimaryView().doSubmitDescription(req, rsp);\n    }\n\n    @RequirePOST // TODO does not seem to work on _either_ overload!\n    public synchronized HttpRedirect doQuietDown() throws IOException {\n        try {\n            return doQuietDown(false,0);\n        } catch (InterruptedException e) {\n            throw new AssertionError(); // impossible\n        }\n    }\n\n    @CLIMethod(name=\"quiet-down\")\n    @RequirePOST\n    public HttpRedirect doQuietDown(\n            @Option(name=\"-block\",usage=\"Block until the system really quiets down and no builds are running\") @QueryParameter boolean block,\n            @Option(name=\"-timeout\",usage=\"If non-zero, only block up to the specified number of milliseconds\") @QueryParameter int timeout) throws InterruptedException, IOException {\n        synchronized (this) {\n            checkPermission(ADMINISTER);\n            isQuietingDown = true;\n        }\n        if (block) {\n            long waitUntil = timeout;\n            if (timeout > 0) waitUntil += System.currentTimeMillis();\n            while (isQuietingDown\n                   && (timeout <= 0 || System.currentTimeMillis() < waitUntil)\n                   && !RestartListener.isAllReady()) {\n                Thread.sleep(1000);\n            }\n        }\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"cancel-quiet-down\")\n    @RequirePOST // TODO the cancel link needs to be updated accordingly\n    public synchronized HttpRedirect doCancelQuietDown() {\n        checkPermission(ADMINISTER);\n        isQuietingDown = false;\n        getQueue().scheduleMaintenance();\n        return new HttpRedirect(\".\");\n    }\n\n    public HttpResponse doToggleCollapse() throws ServletException, IOException {\n    \tfinal StaplerRequest request = Stapler.getCurrentRequest();\n    \tfinal String paneId = request.getParameter(\"paneId\");\n\n    \tPaneStatusProperties.forCurrentUser().toggleCollapsed(paneId);\n\n        return HttpResponses.forwardToPreviousPage();\n    }\n\n    /**\n     * Backward compatibility. Redirect to the thread dump.\n     */\n    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {\n        rsp.sendRedirect2(\"threadDump\");\n    }\n\n    /**\n     * Obtains the thread dump of all slaves (including the master.)\n     *\n     * <p>\n     * Since this is for diagnostics, it has a built-in precautionary measure against hang slaves.\n     */\n    public Map<String,Map<String,String>> getAllThreadDumps() throws IOException, InterruptedException {\n        checkPermission(ADMINISTER);\n\n        // issue the requests all at once\n        Map<String,Future<Map<String,String>>> future = new HashMap<String, Future<Map<String, String>>>();\n\n        for (Computer c : getComputers()) {\n            try {\n                future.put(c.getName(), RemotingDiagnostics.getThreadDumpAsync(c.getChannel()));\n            } catch(Exception e) {\n                LOGGER.info(\"Failed to get thread dump for node \" + c.getName() + \": \" + e.getMessage());\n            }\n        }\n\t\tif (toComputer() == null) {\n\t\t\tfuture.put(\"master\", RemotingDiagnostics.getThreadDumpAsync(FilePath.localChannel));\n\t\t}\n\n        // if the result isn't available in 5 sec, ignore that.\n        // this is a precaution against hang nodes\n        long endTime = System.currentTimeMillis() + 5000;\n\n        Map<String,Map<String,String>> r = new HashMap<String, Map<String, String>>();\n        for (Entry<String, Future<Map<String, String>>> e : future.entrySet()) {\n            try {\n                r.put(e.getKey(), e.getValue().get(endTime-System.currentTimeMillis(), TimeUnit.MILLISECONDS));\n            } catch (Exception x) {\n                StringWriter sw = new StringWriter();\n                x.printStackTrace(new PrintWriter(sw,true));\n                r.put(e.getKey(), Collections.singletonMap(\"Failed to retrieve thread dump\",sw.toString()));\n            }\n        }\n        return Collections.unmodifiableSortedMap(new TreeMap<String, Map<String, String>>(r));\n    }\n\n    @RequirePOST\n    public synchronized TopLevelItem doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        return itemGroupMixIn.createTopLevelItem(req, rsp);\n    }\n\n    /**\n     * @since 1.319\n     */\n    public TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        return itemGroupMixIn.createProjectFromXML(name, xml);\n    }\n\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends TopLevelItem> T copy(T src, String name) throws IOException {\n        return itemGroupMixIn.copy(src, name);\n    }\n\n    // a little more convenient overloading that assumes the caller gives us the right type\n    // (or else it will fail with ClassCastException)\n    public <T extends AbstractProject<?,?>> T copy(T src, String name) throws IOException {\n        return (T)copy((TopLevelItem)src,name);\n    }\n\n    @RequirePOST\n    public synchronized void doCreateView( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(View.CREATE);\n        addView(View.create(req,rsp, this));\n    }\n\n    /**\n     * Check if the given name is suitable as a name\n     * for job, view, etc.\n     *\n     * @throws Failure\n     *      if the given name is not good\n     */\n    public static void checkGoodName(String name) throws Failure {\n        if(name==null || name.length()==0)\n            throw new Failure(Messages.Hudson_NoName());\n\n        if(\".\".equals(name.trim()))\n            throw new Failure(Messages.Jenkins_NotAllowedName(\".\"));\n        if(\"..\".equals(name.trim()))\n            throw new Failure(Messages.Jenkins_NotAllowedName(\"..\"));\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch)) {\n                throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));\n            }\n            if(\"?*/\\\\%!@#$^&|<>[]:;\".indexOf(ch)!=-1)\n                throw new Failure(Messages.Hudson_UnsafeChar(ch));\n        }\n\n        // looks good\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     * @return trimmed name if valid; throws Failure if not\n     */\n    private String checkJobName(String name) throws Failure {\n        checkGoodName(name);\n        name = name.trim();\n        projectNamingStrategy.checkName(name);\n        if(getItem(name)!=null)\n            throw new Failure(Messages.Hudson_JobAlreadyExists(name));\n        // looks good\n        return name;\n    }\n\n    private static String toPrintableName(String name) {\n        StringBuilder printableName = new StringBuilder();\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch))\n                printableName.append(\"\\\\u\").append((int)ch).append(';');\n            else\n                printableName.append(ch);\n        }\n        return printableName.toString();\n    }\n\n    /**\n     * Checks if the user was successfully authenticated.\n     *\n     * @see BasicAuthenticationFilter\n     */\n    public void doSecured( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        // TODO fire something in SecurityListener? (seems to be used only for REST calls when LegacySecurityRealm is active)\n\n        if(req.getUserPrincipal()==null) {\n            // authentication must have failed\n            rsp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        // the user is now authenticated, so send him back to the target\n        String path = req.getContextPath()+req.getOriginalRestOfPath();\n        String q = req.getQueryString();\n        if(q!=null)\n            path += '?'+q;\n\n        rsp.sendRedirect2(path);\n    }\n\n    /**\n     * Called once the user logs in. Just forward to the top page.\n     * Used only by {@link LegacySecurityRealm}.\n     */\n    public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        if(req.getUserPrincipal()==null) {\n            rsp.sendRedirect2(\"noPrincipal\");\n            return;\n        }\n\n        // TODO fire something in SecurityListener?\n\n        String from = req.getParameter(\"from\");\n        if(from!=null && from.startsWith(\"/\") && !from.equals(\"/loginError\")) {\n            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redircted to other sites, make sure the URL falls into this domain\n            return;\n        }\n\n        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);\n        if(url!=null) {\n            // if the login redirect is initiated by Acegi\n            // this should send the user back to where s/he was from.\n            rsp.sendRedirect2(url);\n            return;\n        }\n\n        rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Logs out the user.\n     */\n    public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String user = getAuthentication().getName();\n        securityRealm.doLogout(req, rsp);\n        SecurityListener.fireLoggedOut(user);\n    }\n\n    /**\n     * Serves jar files for JNLP slave agents.\n     */\n    public Slave.JnlpJar getJnlpJars(String fileName) {\n        return new Slave.JnlpJar(fileName);\n    }\n\n    public Slave.JnlpJar doJnlpJars(StaplerRequest req) {\n        return new Slave.JnlpJar(req.getRestOfPath().substring(1));\n    }\n\n    /**\n     * Reloads the configuration.\n     */\n    @CLIMethod(name=\"reload-configuration\")\n    @RequirePOST\n    public synchronized HttpResponse doReload() throws IOException {\n        checkPermission(ADMINISTER);\n\n        // engage \"loading ...\" UI and then run the actual task in a separate thread\n        servletContext.setAttribute(\"app\", new HudsonIsLoading());\n\n        new Thread(\"Jenkins config reload thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    reload();\n                } catch (Exception e) {\n                    LOGGER.log(SEVERE,\"Failed to reload Jenkins config\",e);\n                    new JenkinsReloadFailed(e).publish(servletContext,root);\n                }\n            }\n        }.start();\n\n        return HttpResponses.redirectViaContextPath(\"/\");\n    }\n\n    /**\n     * Reloads the configuration synchronously.\n     */\n    public void reload() throws IOException, InterruptedException, ReactorException {\n        executeReactor(null, loadTasks());\n        User.reload();\n        servletContext.setAttribute(\"app\", this);\n    }\n\n    /**\n     * Do a finger-print check.\n     */\n    public void doDoFingerprintCheck( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        // Parse the request\n        MultipartFormDataParser p = new MultipartFormDataParser(req);\n        if(isUseCrumbs() && !getCrumbIssuer().validateCrumb(req, p)) {\n            rsp.sendError(HttpServletResponse.SC_FORBIDDEN,\"No crumb found\");\n        }\n        try {\n            rsp.sendRedirect2(req.getContextPath()+\"/fingerprint/\"+\n                Util.getDigestOf(p.getFileItem(\"name\").getInputStream())+'/');\n        } finally {\n            p.cleanUp();\n        }\n    }\n\n    /**\n     * For debugging. Expose URL to perform GC.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"DM_GC\")\n    @RequirePOST\n    public void doGc(StaplerResponse rsp) throws IOException {\n        checkPermission(Jenkins.ADMINISTER);\n        System.gc();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"GCed\");\n    }\n\n    /**\n     * End point that intentionally throws an exception to test the error behaviour.\n     * @since 1.467\n     */\n    public void doException() {\n        throw new RuntimeException();\n    }\n\n    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws IOException, JellyException {\n        ContextMenu menu = new ContextMenu().from(this, request, response);\n        for (MenuItem i : menu.items) {\n            if (i.url.equals(request.getContextPath() + \"/manage\")) {\n                // add \"Manage Jenkins\" subitems\n                i.subMenu = new ContextMenu().from(this, request, response, \"manage\");\n            }\n        }\n        return menu;\n    }\n\n    public ContextMenu doChildrenContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {\n        ContextMenu menu = new ContextMenu();\n        for (View view : getViews()) {\n            menu.add(view.getViewUrl(),view.getDisplayName());\n        }\n        return menu;\n    }\n\n    /**\n     * Obtains the heap dump.\n     */\n    public HeapDump getHeapDump() throws IOException {\n        return new HeapDump(this,FilePath.localChannel);\n    }\n\n    /**\n     * Simulates OutOfMemoryError.\n     * Useful to make sure OutOfMemoryHeapDump setting.\n     */\n    @RequirePOST\n    public void doSimulateOutOfMemory() throws IOException {\n        checkPermission(ADMINISTER);\n\n        System.out.println(\"Creating artificial OutOfMemoryError situation\");\n        List<Object> args = new ArrayList<Object>();\n        while (true)\n            args.add(new byte[1024*1024]);\n    }\n\n    /**\n     * Binds /userContent/... to $JENKINS_HOME/userContent.\n     */\n    public DirectoryBrowserSupport doUserContent() {\n        return new DirectoryBrowserSupport(this,getRootPath().child(\"userContent\"),\"User content\",\"folder.png\",true);\n    }\n\n    /**\n     * Perform a restart of Jenkins, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     */\n    @CLIMethod(name=\"restart\")\n    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\")) {\n            req.getView(this,\"_restart.jelly\").forward(req,rsp);\n            return;\n        }\n\n        restart();\n\n        if (rsp != null) // null for CLI\n            rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Queues up a restart of Jenkins for when there are no builds running, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     *\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-restart\")\n    public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\"))\n            return HttpResponses.forwardToView(this,\"_safeRestart.jelly\");\n\n        safeRestart();\n\n        return HttpResponses.redirectToDot();\n    }\n\n    /**\n     * Performs a restart.\n     */\n    public void restart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Jenkins is restartable\n        servletContext.setAttribute(\"app\", new HudsonIsRestarting());\n\n        new Thread(\"restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // give some time for the browser to load the \"reloading\" page\n                    Thread.sleep(5000);\n                    LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                    for (RestartListener listener : RestartListener.all())\n                        listener.onRestart();\n                    lifecycle.restart();\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Queues up a restart to be performed once there are no builds currently running.\n     * @since 1.332\n     */\n    public void safeRestart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Jenkins is restartable\n        // Quiet down so that we won't launch new builds.\n        isQuietingDown = true;\n\n        new Thread(\"safe-restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // Wait 'til we have no active executors.\n                    doQuietDown(true, 0);\n\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        servletContext.setAttribute(\"app\",new HudsonIsRestarting());\n                        // give some time for the browser to load the \"reloading\" page\n                        LOGGER.info(\"Restart in 10 seconds\");\n                        Thread.sleep(10000);\n                        LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                        for (RestartListener listener : RestartListener.all())\n                            listener.onRestart();\n                        lifecycle.restart();\n                    } else {\n                        LOGGER.info(\"Safe-restart mode cancelled\");\n                    }\n                } catch (Throwable e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\",e);\n                }\n            }\n        }.start();\n    }\n\n    @Extension @Restricted(NoExternalUse.class)\n    public static class MasterRestartNotifyier extends RestartListener {\n\n        @Override\n        public void onRestart() {\n            Computer computer = Jenkins.getInstance().toComputer();\n            if (computer == null) return;\n            RestartCause cause = new RestartCause();\n            for (ComputerListener listener: ComputerListener.all()) {\n                listener.onOffline(computer, cause);\n            }\n        }\n\n        @Override\n        public boolean isReadyToRestart() throws IOException, InterruptedException {\n            return true;\n        }\n\n        private static class RestartCause extends OfflineCause.SimpleOfflineCause {\n            protected RestartCause() {\n                super(Messages._Jenkins_IsRestarting());\n            }\n        }\n    }\n\n    /**\n     * Shutdown the system.\n     * @since 1.161\n     */\n    @CLIMethod(name=\"shutdown\")\n    @RequirePOST\n    public void doExit( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        checkPermission(ADMINISTER);\n        LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                getAuthentication().getName(), req!=null?req.getRemoteAddr():\"???\"));\n        if (rsp!=null) {\n            rsp.setStatus(HttpServletResponse.SC_OK);\n            rsp.setContentType(\"text/plain\");\n            PrintWriter w = rsp.getWriter();\n            w.println(\"Shutting down\");\n            w.close();\n        }\n\n        System.exit(0);\n    }\n\n\n    /**\n     * Shutdown the system safely.\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-shutdown\")\n    @RequirePOST\n    public HttpResponse doSafeExit(StaplerRequest req) throws IOException {\n        checkPermission(ADMINISTER);\n        isQuietingDown = true;\n        final String exitUser = getAuthentication().getName();\n        final String exitAddr = req!=null ? req.getRemoteAddr() : \"unknown\";\n        new Thread(\"safe-exit thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                                                exitUser, exitAddr));\n                    // Wait 'til we have no active executors.\n                    doQuietDown(true, 0);\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        cleanUp();\n                        System.exit(0);\n                    }\n                } catch (Exception e) {\n                    LOGGER.log(Level.WARNING, \"Failed to shut down Jenkins\", e);\n                }\n            }\n        }.start();\n\n        return HttpResponses.plainText(\"Shutting down as soon as all jobs are complete\");\n    }\n\n    /**\n     * Gets the {@link Authentication} object that represents the user\n     * associated with the current request.\n     */\n    public static @Nonnull Authentication getAuthentication() {\n        Authentication a = SecurityContextHolder.getContext().getAuthentication();\n        // on Tomcat while serving the login page, this is null despite the fact\n        // that we have filters. Looking at the stack trace, Tomcat doesn't seem to\n        // run the request through filters when this is the login request.\n        // see http://www.nabble.com/Matrix-authorization-problem-tp14602081p14886312.html\n        if(a==null)\n            a = ANONYMOUS;\n        return a;\n    }\n\n    /**\n     * For system diagnostics.\n     * Run arbitrary Groovy script.\n     */\n    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, req.getView(this, \"_script.jelly\"), FilePath.localChannel, getACL());\n    }\n\n    /**\n     * Run arbitrary Groovy script and return result as plain text.\n     */\n    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, req.getView(this, \"_scriptText.jelly\"), FilePath.localChannel, getACL());\n    }\n\n    /**\n     * @since 1.509.1\n     */\n    public static void _doScript(StaplerRequest req, StaplerResponse rsp, RequestDispatcher view, VirtualChannel channel, ACL acl) throws IOException, ServletException {\n        // ability to run arbitrary script is dangerous\n        acl.checkPermission(RUN_SCRIPTS);\n\n        String text = req.getParameter(\"script\");\n        if (text != null) {\n            if (!\"POST\".equals(req.getMethod())) {\n                throw HttpResponses.error(HttpURLConnection.HTTP_BAD_METHOD, \"requires POST\");\n            }\n\n            if (channel == null) {\n                throw HttpResponses.error(HttpURLConnection.HTTP_NOT_FOUND, \"Node is offline\");\n            }\n\n            try {\n                req.setAttribute(\"output\",\n                        RemotingDiagnostics.executeGroovy(text, channel));\n            } catch (InterruptedException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        view.forward(req, rsp);\n    }\n\n    /**\n     * Evaluates the Jelly script submitted by the client.\n     *\n     * This is useful for system administration as well as unit testing.\n     */\n    @RequirePOST\n    public void doEval(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(RUN_SCRIPTS);\n\n        try {\n            MetaClass mc = WebApp.getCurrent().getMetaClass(getClass());\n            Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));\n            new JellyRequestDispatcher(this,script).forward(req,rsp);\n        } catch (JellyException e) {\n            throw new ServletException(e);\n        }\n    }\n\n    /**\n     * Sign up for the user account.\n     */\n    public void doSignup( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        if (getSecurityRealm().allowsSignup()) {\n            req.getView(getSecurityRealm(), \"signup.jelly\").forward(req, rsp);\n            return;\n        }\n        req.getView(SecurityRealm.class, \"signup.jelly\").forward(req, rsp);\n    }\n\n    /**\n     * Changes the icon size by changing the cookie\n     */\n    public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null)\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", Functions.validateIconSize(qs));\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }\n\n    @RequirePOST\n    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {\n        checkPermission(ADMINISTER);\n        FingerprintCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    @RequirePOST\n    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {\n        checkPermission(ADMINISTER);\n        WorkspaceCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    /**\n     * If the user chose the default JDK, make sure we got 'java' in PATH.\n     */\n    public FormValidation doDefaultJDKCheck(StaplerRequest request, @QueryParameter String value) {\n        if(!value.equals(JDK.DEFAULT_NAME))\n            // assume the user configured named ones properly in system config ---\n            // or else system config should have reported form field validation errors.\n            return FormValidation.ok();\n\n        // default JDK selected. Does such java really exist?\n        if(JDK.isDefaultJDKValid(Jenkins.this))\n            return FormValidation.ok();\n        else\n            return FormValidation.errorWithMarkup(Messages.Hudson_NoJavaInPath(request.getContextPath()));\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     */\n    public FormValidation doCheckJobName(@QueryParameter String value) {\n        // this method can be used to check if a file exists anywhere in the file system,\n        // so it should be protected.\n        checkPermission(Item.CREATE);\n\n        if(fixEmpty(value)==null)\n            return FormValidation.ok();\n\n        try {\n            checkJobName(value);\n            return FormValidation.ok();\n        } catch (Failure e) {\n            return FormValidation.error(e.getMessage());\n        }\n    }\n\n    /**\n     * Checks if a top-level view with the given name exists and\n     * make sure that the name is good as a view name.\n     */\n    public FormValidation doCheckViewName(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String name = fixEmpty(value);\n        if (name == null)\n            return FormValidation.ok();\n\n        // already exists?\n        if (getView(name) != null)\n            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(name));\n\n        // good view name?\n        try {\n            checkGoodName(name);\n        } catch (Failure e) {\n            return FormValidation.error(e.getMessage());\n        }\n\n        return FormValidation.ok();\n    }\n\n    /**\n     * Checks if a top-level view with the given name exists.\n     * @deprecated 1.512\n     */\n    @Deprecated\n    public FormValidation doViewExistsCheck(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String view = fixEmpty(value);\n        if(view==null) return FormValidation.ok();\n\n        if(getView(view)==null)\n            return FormValidation.ok();\n        else\n            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(view));\n    }\n\n    /**\n     * Serves static resources placed along with Jelly view files.\n     * <p>\n     * This method can serve a lot of files, so care needs to be taken\n     * to make this method secure. It's not clear to me what's the best\n     * strategy here, though the current implementation is based on\n     * file extensions.\n     */\n    public void doResources(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        // cut off the \"...\" portion of /resources/.../path/to/file\n        // as this is only used to make path unique (which in turn\n        // allows us to set a long expiration date\n        path = path.substring(path.indexOf('/',1)+1);\n\n        int idx = path.lastIndexOf('.');\n        String extension = path.substring(idx+1);\n        if(ALLOWED_RESOURCE_EXTENSIONS.contains(extension)) {\n            URL url = pluginManager.uberClassLoader.getResource(path);\n            if(url!=null) {\n                long expires = MetaClass.NO_CACHE ? 0 : 365L * 24 * 60 * 60 * 1000; /*1 year*/\n                rsp.serveFile(req,url,expires);\n                return;\n            }\n        }\n        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    /**\n     * Extension list that {@link #doResources(StaplerRequest, StaplerResponse)} can serve.\n     * This set is mutable to allow plugins to add additional extensions.\n     */\n    public static final Set<String> ALLOWED_RESOURCE_EXTENSIONS = new HashSet<String>(Arrays.asList(\n        \"js|css|jpeg|jpg|png|gif|html|htm\".split(\"\\\\|\")\n    ));\n\n    /**\n     * Checks if container uses UTF-8 to decode URLs. See\n     * http://wiki.jenkins-ci.org/display/JENKINS/Tomcat#Tomcat-i18n\n     */\n    public FormValidation doCheckURIEncoding(StaplerRequest request) throws IOException {\n        // expected is non-ASCII String\n        final String expected = \"\\u57f7\\u4e8b\";\n        final String value = fixEmpty(request.getParameter(\"value\"));\n        if (!expected.equals(value))\n            return FormValidation.warningWithMarkup(Messages.Hudson_NotUsesUTF8ToDecodeURL());\n        return FormValidation.ok();\n    }\n\n    /**\n     * Does not check when system default encoding is \"ISO-8859-1\".\n     */\n    public static boolean isCheckURIEncodingEnabled() {\n        return !\"ISO-8859-1\".equalsIgnoreCase(System.getProperty(\"file.encoding\"));\n    }\n\n    /**\n     * Rebuilds the dependency map.\n     */\n    public void rebuildDependencyGraph() {\n        DependencyGraph graph = new DependencyGraph();\n        graph.build();\n        // volatile acts a as a memory barrier here and therefore guarantees\n        // that graph is fully build, before it's visible to other threads\n        dependencyGraph = graph;\n        dependencyGraphDirty.set(false);\n    }\n\n    /**\n     * Rebuilds the dependency map asynchronously.\n     *\n     * <p>\n     * This would keep the UI thread more responsive and helps avoid the deadlocks,\n     * as dependency graph recomputation tends to touch a lot of other things.\n     *\n     * @since 1.522\n     */\n    public Future<DependencyGraph> rebuildDependencyGraphAsync() {\n        dependencyGraphDirty.set(true);\n        return Timer.get().schedule(new java.util.concurrent.Callable<DependencyGraph>() {\n            @Override\n            public DependencyGraph call() throws Exception {\n                if (dependencyGraphDirty.get()) {\n                    rebuildDependencyGraph();\n                }\n                return dependencyGraph;\n            }\n        }, 500, TimeUnit.MILLISECONDS);\n    }\n\n    public DependencyGraph getDependencyGraph() {\n        return dependencyGraph;\n    }\n\n    // for Jelly\n    public List<ManagementLink> getManagementLinks() {\n        return ManagementLink.all();\n    }\n\n    /**\n     * Exposes the current user to <tt>/me</tt> URL.\n     */\n    public User getMe() {\n        User u = User.current();\n        if (u == null)\n            throw new AccessDeniedException(\"/me is not available when not logged in\");\n        return u;\n    }\n\n    /**\n     * Gets the {@link Widget}s registered on this object.\n     *\n     * <p>\n     * Plugins who wish to contribute boxes on the side panel can add widgets\n     * by {@code getWidgets().add(new MyWidget())} from {@link Plugin#start()}.\n     */\n    public List<Widget> getWidgets() {\n        return widgets;\n    }\n\n    public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            if(rest.startsWith(\"/login\")\n            || rest.startsWith(\"/logout\")\n            || rest.startsWith(\"/accessDenied\")\n            || rest.startsWith(\"/adjuncts/\")\n            || rest.startsWith(\"/error\")\n            || rest.startsWith(\"/oops\")\n            || rest.startsWith(\"/signup\")\n            || rest.startsWith(\"/tcpSlaveAgentListener\")\n            // TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\n            || rest.matches(\"/computer/[^/]+/slave-agent[.]jnlp\") && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))\n            || rest.startsWith(\"/federatedLoginService/\")\n            || rest.startsWith(\"/securityRealm\"))\n                return this;    // URLs that are always visible without READ permission\n\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"/\" + name + \"/\") || rest.equals(\"/\" + name)) {\n                    return this;\n                }\n            }\n\n            throw e;\n        }\n        return this;\n    }\n\n    /**\n     * Gets a list of unprotected root actions.\n     * These URL prefixes should be exempted from access control checks by container-managed security.\n     * Ideally would be synchronized with {@link #getTarget}.\n     * @return a list of {@linkplain Action#getUrlName URL names}\n     * @since 1.495\n     */\n    public Collection<String> getUnprotectedRootActions() {\n        Set<String> names = new TreeSet<String>();\n        names.add(\"jnlpJars\"); // TODO cleaner to refactor doJnlpJars into a URA\n        // TODO consider caching (expiring cache when actions changes)\n        for (Action a : getActions()) {\n            if (a instanceof UnprotectedRootAction) {\n                names.add(a.getUrlName());\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Fallback to the primary view.\n     */\n    public View getStaplerFallback() {\n        return getPrimaryView();\n    }\n\n    /**\n     * This method checks all existing jobs to see if displayName is\n     * unique. It does not check the displayName against the displayName of the\n     * job that the user is configuring though to prevent a validation warning\n     * if the user sets the displayName to what it currently is.\n     * @param displayName\n     * @param currentJobName\n     */\n    boolean isDisplayNameUnique(String displayName, String currentJobName) {\n        Collection<TopLevelItem> itemCollection = items.values();\n\n        // if there are a lot of projects, we'll have to store their\n        // display names in a HashSet or something for a quick check\n        for(TopLevelItem item : itemCollection) {\n            if(item.getName().equals(currentJobName)) {\n                // we won't compare the candidate displayName against the current\n                // item. This is to prevent an validation warning if the user\n                // sets the displayName to what the existing display name is\n                continue;\n            }\n            else if(displayName.equals(item.getDisplayName())) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * True if there is no item in Jenkins that has this name\n     * @param name The name to test\n     * @param currentJobName The name of the job that the user is configuring\n     */\n    boolean isNameUnique(String name, String currentJobName) {\n        Item item = getItem(name);\n\n        if(null==item) {\n            // the candidate name didn't return any items so the name is unique\n            return true;\n        }\n        else if(item.getName().equals(currentJobName)) {\n            // the candidate name returned an item, but the item is the item\n            // that the user is configuring so this is ok\n            return true;\n        }\n        else {\n            // the candidate name returned an item, so it is not unique\n            return false;\n        }\n    }\n\n    /**\n     * Checks to see if the candidate displayName collides with any\n     * existing display names or project names\n     * @param displayName The display name to test\n     * @param jobName The name of the job the user is configuring\n     */\n    public FormValidation doCheckDisplayName(@QueryParameter String displayName,\n            @QueryParameter String jobName) {\n        displayName = displayName.trim();\n\n        if(LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Current job name is \" + jobName);\n        }\n\n        if(!isNameUnique(displayName, jobName)) {\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));\n        }\n        else if(!isDisplayNameUnique(displayName, jobName)){\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));\n        }\n        else {\n            return FormValidation.ok();\n        }\n    }\n\n    public static class MasterComputer extends Computer {\n        protected MasterComputer() {\n            super(Jenkins.getInstance());\n        }\n\n        /**\n         * Returns \"\" to match with {@link Jenkins#getNodeName()}.\n         */\n        @Override\n        public String getName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isConnecting() {\n            return false;\n        }\n\n        @Override\n        public String getDisplayName() {\n            return Messages.Hudson_Computer_DisplayName();\n        }\n\n        @Override\n        public String getCaption() {\n            return Messages.Hudson_Computer_Caption();\n        }\n\n        @Override\n        public String getUrl() {\n            return \"computer/(master)/\";\n        }\n\n        public RetentionStrategy getRetentionStrategy() {\n            return RetentionStrategy.NOOP;\n        }\n\n        /**\n         * Will always keep this guy alive so that it can function as a fallback to\n         * execute {@link FlyweightTask}s. See JENKINS-7291.\n         */\n        @Override\n        protected boolean isAlive() {\n            return true;\n        }\n\n        @Override\n        public Boolean isUnix() {\n            return !Functions.isWindows();\n        }\n\n        /**\n         * Report an error.\n         */\n        @Override\n        public HttpResponse doDoDelete() throws IOException {\n            throw HttpResponses.status(SC_BAD_REQUEST);\n        }\n\n        @Override\n        public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n            Jenkins.getInstance().doConfigExecutorsSubmit(req, rsp);\n        }\n\n        @WebMethod(name=\"config.xml\")\n        @Override\n        public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            throw HttpResponses.status(SC_BAD_REQUEST);\n        }\n\n        @Override\n        public boolean hasPermission(Permission permission) {\n            // no one should be allowed to delete the master.\n            // this hides the \"delete\" link from the /computer/(master) page.\n            if(permission==Computer.DELETE)\n                return false;\n            // Configuration of master node requires ADMINISTER permission\n            return super.hasPermission(permission==Computer.CONFIGURE ? Jenkins.ADMINISTER : permission);\n        }\n\n        @Override\n        public VirtualChannel getChannel() {\n            return FilePath.localChannel;\n        }\n\n        @Override\n        public Charset getDefaultCharset() {\n            return Charset.defaultCharset();\n        }\n\n        public List<LogRecord> getLogRecords() throws IOException, InterruptedException {\n            return logRecords;\n        }\n\n        @RequirePOST\n        public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            // this computer never returns null from channel, so\n            // this method shall never be invoked.\n            rsp.sendError(SC_NOT_FOUND);\n        }\n\n        protected Future<?> _connect(boolean forceReconnect) {\n            return Futures.precomputed(null);\n        }\n\n        /**\n         * {@link LocalChannel} instance that can be used to execute programs locally.\n         *\n         * @deprecated as of 1.558\n         *      Use {@link FilePath#localChannel}\n         */\n        @Deprecated\n        public static final LocalChannel localChannel = FilePath.localChannel;\n    }\n\n    /**\n     * Shortcut for {@code Jenkins.getInstance().lookup.get(type)}\n     */\n    public static @CheckForNull <T> T lookup(Class<T> type) {\n        Jenkins j = Jenkins.getInstance();\n        return j != null ? j.lookup.get(type) : null;\n    }\n\n    /**\n     * Live view of recent {@link LogRecord}s produced by Jenkins.\n     */\n    public static List<LogRecord> logRecords = Collections.emptyList(); // initialized to dummy value to avoid NPE\n\n    /**\n     * Thread-safe reusable {@link XStream}.\n     */\n    public static final XStream XSTREAM;\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2;\n\n    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);\n\n    /**\n     * Thread pool used to load configuration in parallel, to improve the start up time.\n     * <p>\n     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.\n     */\n    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(\n        TWICE_CPU_NUM, TWICE_CPU_NUM,\n        5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamingThreadFactory(new DaemonThreadFactory(), \"Jenkins load\"));\n\n\n    private static void computeVersion(ServletContext context) {\n        // set the version\n        Properties props = new Properties();\n        InputStream is = null;\n        try {\n            is = Jenkins.class.getResourceAsStream(\"jenkins-version.properties\");\n            if(is!=null)\n                props.load(is);\n        } catch (IOException e) {\n            e.printStackTrace(); // if the version properties is missing, that's OK.\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n        String ver = props.getProperty(\"version\");\n        if(ver==null)   ver=\"?\";\n        VERSION = ver;\n        context.setAttribute(\"version\",ver);\n\n        VERSION_HASH = Util.getDigestOf(ver).substring(0, 8);\n        SESSION_HASH = Util.getDigestOf(ver+System.currentTimeMillis()).substring(0, 8);\n\n        if(ver.equals(\"?\") || Boolean.getBoolean(\"hudson.script.noCache\"))\n            RESOURCE_PATH = \"\";\n        else\n            RESOURCE_PATH = \"/static/\"+SESSION_HASH;\n\n        VIEW_RESOURCE_PATH = \"/resources/\"+ SESSION_HASH;\n    }\n\n    /**\n     * Version number of this Jenkins.\n     */\n    public static String VERSION=\"?\";\n\n    /**\n     * Parses {@link #VERSION} into {@link VersionNumber}, or null if it's not parseable as a version number\n     * (such as when Jenkins is run with \"mvn hudson-dev:run\")\n     */\n    public static VersionNumber getVersion() {\n        try {\n            return new VersionNumber(VERSION);\n        } catch (NumberFormatException e) {\n            try {\n                // for non-released version of Jenkins, this looks like \"1.345 (private-foobar), so try to approximate.\n                int idx = VERSION.indexOf(' ');\n                if (idx>0)\n                    return new VersionNumber(VERSION.substring(0,idx));\n            } catch (NumberFormatException _) {\n                // fall through\n            }\n\n            // totally unparseable\n            return null;\n        } catch (IllegalArgumentException e) {\n            // totally unparseable\n            return null;\n        }\n    }\n\n    /**\n     * Hash of {@link #VERSION}.\n     */\n    public static String VERSION_HASH;\n\n    /**\n     * Unique random token that identifies the current session.\n     * Used to make {@link #RESOURCE_PATH} unique so that we can set long \"Expires\" header.\n     *\n     * We used to use {@link #VERSION_HASH}, but making this session local allows us to\n     * reuse the same {@link #RESOURCE_PATH} for static resources in plugins.\n     */\n    public static String SESSION_HASH;\n\n    /**\n     * Prefix to static resources like images and javascripts in the war file.\n     * Either \"\" or strings like \"/static/VERSION\", which avoids Jenkins to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String RESOURCE_PATH = \"\";\n\n    /**\n     * Prefix to resources alongside view scripts.\n     * Strings like \"/resources/VERSION\", which avoids Jenkins to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String VIEW_RESOURCE_PATH = \"/resources/TBD\";\n\n    public static boolean PARALLEL_LOAD = Configuration.getBooleanConfigParameter(\"parallelLoad\", true);\n    public static boolean KILL_AFTER_LOAD = Configuration.getBooleanConfigParameter(\"killAfterLoad\", false);\n    /**\n     * @deprecated No longer used.\n     */\n    @Deprecated\n    public static boolean FLYWEIGHT_SUPPORT = true;\n\n    /**\n     * Tentative switch to activate the concurrent build behavior.\n     * When we merge this back to the trunk, this allows us to keep\n     * this feature hidden for a while until we iron out the kinks.\n     * @see AbstractProject#isConcurrentBuild()\n     * @deprecated as of 1.464\n     *      This flag will have no effect.\n     */\n    @Restricted(NoExternalUse.class)\n    @Deprecated\n    public static boolean CONCURRENT_BUILD = true;\n\n    /**\n     * Switch to enable people to use a shorter workspace name.\n     */\n    private static final String WORKSPACE_DIRNAME = Configuration.getStringConfigParameter(\"workspaceDirName\", \"workspace\");\n\n    /**\n     * Automatically try to launch a slave when Jenkins is initialized or a new slave is created.\n     */\n    public static boolean AUTOMATIC_SLAVE_LAUNCH = true;\n\n    private static final Logger LOGGER = Logger.getLogger(Jenkins.class.getName());\n\n    public static final PermissionGroup PERMISSIONS = Permission.HUDSON_PERMISSIONS;\n    public static final Permission ADMINISTER = Permission.HUDSON_ADMINISTER;\n    public static final Permission READ = new Permission(PERMISSIONS,\"Read\",Messages._Hudson_ReadPermission_Description(),Permission.READ,PermissionScope.JENKINS);\n    public static final Permission RUN_SCRIPTS = new Permission(PERMISSIONS, \"RunScripts\", Messages._Hudson_RunScriptsPermission_Description(),ADMINISTER,PermissionScope.JENKINS);\n\n    /**\n     * {@link Authentication} object that represents the anonymous user.\n     * Because Acegi creates its own {@link AnonymousAuthenticationToken} instances, the code must not\n     * expect the singleton semantics. This is just a convenient instance.\n     *\n     * @since 1.343\n     */\n    public static final Authentication ANONYMOUS;\n\n    static {\n        try {\n            ANONYMOUS = new AnonymousAuthenticationToken(\n                    \"anonymous\", \"anonymous\", new GrantedAuthority[]{new GrantedAuthorityImpl(\"anonymous\")});\n            XSTREAM = XSTREAM2 = new XStream2();\n\n            XSTREAM.alias(\"jenkins\", Jenkins.class);\n            XSTREAM.alias(\"slave\", DumbSlave.class);\n            XSTREAM.alias(\"jdk\", JDK.class);\n            // for backward compatibility with <1.75, recognize the tag name \"view\" as well.\n            XSTREAM.alias(\"view\", ListView.class);\n            XSTREAM.alias(\"listView\", ListView.class);\n            XSTREAM2.addCriticalField(Jenkins.class, \"securityRealm\");\n            XSTREAM2.addCriticalField(Jenkins.class, \"authorizationStrategy\");\n            // this seems to be necessary to force registration of converter early enough\n            Mode.class.getEnumConstants();\n\n            // double check that initialization order didn't do any harm\n            assert PERMISSIONS != null;\n            assert ADMINISTER != null;\n        } catch (RuntimeException e) {\n            // when loaded on a slave and this fails, subsequent NoClassDefFoundError will fail to chain the cause.\n            // see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8051847\n            // As we don't know where the first exception will go, let's also send this to logging so that\n            // we have a known place to look at.\n            LOGGER.log(SEVERE, \"Failed to load Jenkins.class\", e);\n            throw e;\n        } catch (Error e) {\n            LOGGER.log(SEVERE, \"Failed to load Jenkins.class\", e);\n            throw e;\n        }\n    }\n\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.HttpMethod;\nimport com.gargoylesoftware.htmlunit.Page;\nimport com.gargoylesoftware.htmlunit.WebRequest;\nimport com.gargoylesoftware.htmlunit.WebResponse;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\n\nimport hudson.maven.MavenModuleSet;\nimport hudson.maven.MavenModuleSetBuild;\nimport hudson.model.Failure;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.User;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonPrivateSecurityRealm;\nimport hudson.util.HttpResponses;\nimport hudson.model.FreeStyleProject;\nimport hudson.security.GlobalMatrixAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.OfflineCause;\nimport hudson.util.FormValidation;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.ExtractResourceSCM;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.WebClient;\nimport org.jvnet.hudson.test.TestExtension;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mockito;\n\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n/**\n * @author kingfai\n *\n */\npublic class JenkinsTest {\n\n    @Rule public JenkinsRule j = new JenkinsRule();\n\n    @Test\n    public void testIsDisplayNameUniqueTrue() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(\"displayName\");\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertTrue(jenkins.isDisplayNameUnique(\"displayName1\", curJobName));\n        assertTrue(jenkins.isDisplayNameUnique(jobName, curJobName));\n    }\n\n    @Test\n    public void testIsDisplayNameUniqueFalse() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        \n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));\n    }\n    \n    @Test\n    public void testIsDisplayNameUniqueSameAsCurrentJob() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String displayName = \"currentProjectDisplayName\";\n        \n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        // should be true as we don't test against the current job\n        assertTrue(jenkins.isDisplayNameUnique(displayName, curJobName));\n    }\n    \n    @Test\n    public void testIsNameUniqueTrue() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertTrue(jenkins.isNameUnique(\"jobName1\", curJobName));\n    }\n\n    @Test\n    public void testIsNameUniqueFalse() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertFalse(jenkins.isNameUnique(jobName, curJobName));\n    }\n\n    @Test\n    public void testIsNameUniqueSameAsCurrentJob() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        // true because we don't test against the current job\n        assertTrue(jenkins.isNameUnique(curJobName, curJobName));\n    }\n    \n    @Test\n    public void testDoCheckDisplayNameUnique() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(\"displayName\");\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(\"1displayName\", curJobName);\n        assertEquals(FormValidation.ok(), v);\n    }\n\n    @Test\n    public void testDoCheckDisplayNameSameAsDisplayName() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(displayName, curJobName);\n        assertEquals(FormValidation.Kind.WARNING, v.kind);\n    }\n\n    @Test\n    public void testDoCheckDisplayNameSameAsJobName() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(jobName, curJobName);\n        assertEquals(FormValidation.Kind.WARNING, v.kind);\n    }\n\n    @Test\n    public void testDoCheckViewName_GoodName() throws Exception {\n        String[] viewNames = new String[] {\n            \"\", \"Jenkins\"    \n        };\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        for (String viewName : viewNames) {\n            FormValidation v = jenkins.doCheckViewName(viewName);\n            assertEquals(FormValidation.Kind.OK, v.kind);\n        }\n    }\n\n    @Test\n    public void testDoCheckViewName_NotGoodName() throws Exception {\n        String[] viewNames = new String[] {\n            \"Jenkins?\", \"Jenkins*\", \"Jenkin/s\", \"Jenkin\\\\s\", \"jenkins%\", \n            \"Jenkins!\", \"Jenkins[]\", \"Jenkin<>s\", \"^Jenkins\", \"..\"    \n        };\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        \n        for (String viewName : viewNames) {\n            FormValidation v = jenkins.doCheckViewName(viewName);\n            assertEquals(FormValidation.Kind.ERROR, v.kind);\n        }\n    }\n    \n    @Test @Issue(\"JENKINS-12251\")\n    public void testItemFullNameExpansion() throws Exception {\n        HtmlForm f = j.createWebClient().goTo(\"configure\").getFormByName(\"config\");\n        f.getInputByName(\"_.rawBuildsDir\").setValueAttribute(\"${JENKINS_HOME}/test12251_builds/${ITEM_FULL_NAME}\");\n        f.getInputByName(\"_.rawWorkspaceDir\").setValueAttribute(\"${JENKINS_HOME}/test12251_ws/${ITEM_FULL_NAME}\");\n        j.submit(f);\n\n        // build a dummy project\n        MavenModuleSet m = j.createMavenProject();\n        m.setScm(new ExtractResourceSCM(getClass().getResource(\"/simple-projects.zip\")));\n        MavenModuleSetBuild b = m.scheduleBuild2(0).get();\n\n        // make sure these changes are effective\n        assertTrue(b.getWorkspace().getRemote().contains(\"test12251_ws\"));\n        assertTrue(b.getRootDir().toString().contains(\"test12251_builds\"));\n    }\n\n    /**\n     * Makes sure access to \"/foobar\" for UnprotectedRootAction gets through.\n     */\n    @Test @Issue(\"JENKINS-14113\")\n    public void testUnprotectedRootAction() throws Exception {\n        j.jenkins.setSecurityRealm(j.createDummySecurityRealm());\n        j.jenkins.setAuthorizationStrategy(new FullControlOnceLoggedInAuthorizationStrategy());\n        WebClient wc = j.createWebClient();\n        wc.goTo(\"foobar\");\n        wc.goTo(\"foobar/\");\n        wc.goTo(\"foobar/zot\");\n\n        // and make sure this fails\n        wc.assertFails(\"foobar-zot/\", HttpURLConnection.HTTP_INTERNAL_ERROR);\n\n        assertEquals(3,j.jenkins.getExtensionList(RootAction.class).get(RootActionImpl.class).count);\n    }\n\n    @Test\n    public void testDoScript() throws Exception {\n        j.jenkins.setSecurityRealm(new LegacySecurityRealm());\n        GlobalMatrixAuthorizationStrategy gmas = new GlobalMatrixAuthorizationStrategy() {\n            @Override public boolean hasPermission(String sid, Permission p) {\n                return p == Jenkins.RUN_SCRIPTS ? hasExplicitPermission(sid, p) : super.hasPermission(sid, p);\n            }\n        };\n        gmas.add(Jenkins.ADMINISTER, \"alice\");\n        gmas.add(Jenkins.RUN_SCRIPTS, \"alice\");\n        gmas.add(Jenkins.READ, \"bob\");\n        gmas.add(Jenkins.ADMINISTER, \"charlie\");\n        j.jenkins.setAuthorizationStrategy(gmas);\n        WebClient wc = j.createWebClient();\n        wc.login(\"alice\");\n        wc.goTo(\"script\");\n        wc.assertFails(\"script?script=System.setProperty('hack','me')\", HttpURLConnection.HTTP_BAD_METHOD);\n        assertNull(System.getProperty(\"hack\"));\n        WebRequest req = new WebRequest(new URL(wc.getContextPath() + \"script?script=System.setProperty('hack','me')\"), HttpMethod.POST);\n        wc.getPage(wc.addCrumb(req));\n        assertEquals(\"me\", System.getProperty(\"hack\"));\n        wc.assertFails(\"scriptText?script=System.setProperty('hack','me')\", HttpURLConnection.HTTP_BAD_METHOD);\n        req = new WebRequest(new URL(wc.getContextPath() + \"scriptText?script=System.setProperty('huck','you')\"), HttpMethod.POST);\n        wc.getPage(wc.addCrumb(req));\n        assertEquals(\"you\", System.getProperty(\"huck\"));\n        wc.login(\"bob\");\n        wc.assertFails(\"script\", HttpURLConnection.HTTP_FORBIDDEN);\n        wc.login(\"charlie\");\n        wc.assertFails(\"script\", HttpURLConnection.HTTP_FORBIDDEN);\n    }\n\n    @Test\n    public void testDoEval() throws Exception {\n        j.jenkins.setSecurityRealm(new LegacySecurityRealm());\n        GlobalMatrixAuthorizationStrategy gmas = new GlobalMatrixAuthorizationStrategy() {\n            @Override public boolean hasPermission(String sid, Permission p) {\n                return p == Jenkins.RUN_SCRIPTS ? hasExplicitPermission(sid, p) : super.hasPermission(sid, p);\n            }\n        };\n        gmas.add(Jenkins.ADMINISTER, \"alice\");\n        gmas.add(Jenkins.RUN_SCRIPTS, \"alice\");\n        gmas.add(Jenkins.READ, \"bob\");\n        gmas.add(Jenkins.ADMINISTER, \"charlie\");\n        j.jenkins.setAuthorizationStrategy(gmas);\n        WebClient wc = j.createWebClient();\n        wc.login(\"alice\");\n        wc.assertFails(\"eval\", HttpURLConnection.HTTP_BAD_METHOD);\n        assertEquals(\"3\", eval(wc));\n        wc.login(\"bob\");\n        try {\n            eval(wc);\n            fail(\"bob has only READ\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n        wc.login(\"charlie\");\n        try {\n            eval(wc);\n            fail(\"charlie has ADMINISTER but not RUN_SCRIPTS\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n    }\n    private String eval(WebClient wc) throws Exception {\n        WebRequest req = new WebRequest(wc.createCrumbedUrl(\"eval\"), HttpMethod.POST);\n        req.setEncodingType(null);\n        req.setRequestBody(\"<j:jelly xmlns:j='jelly:core'>${1+2}</j:jelly>\");\n        return wc.getPage(req).getWebResponse().getContentAsString();\n    }\n\n    @TestExtension(\"testUnprotectedRootAction\")\n    public static class RootActionImpl implements UnprotectedRootAction {\n        private int count;\n\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"foobar\";\n        }\n\n        public HttpResponse doDynamic() {\n            assertTrue(Jenkins.getInstance().getAuthentication().getName().equals(\"anonymous\"));\n            count++;\n            return HttpResponses.html(\"OK\");\n        }\n    }\n\n    @TestExtension(\"testUnprotectedRootAction\")\n    public static class ProtectedRootActionImpl implements RootAction {\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"foobar-zot\";\n        }\n\n        public HttpResponse doDynamic() {\n            throw new AssertionError();\n        }\n    }\n\n    @Test @Issue(\"JENKINS-20866\")\n    public void testErrorPageShouldBeAnonymousAccessible() throws Exception {\n        HudsonPrivateSecurityRealm s = new HudsonPrivateSecurityRealm(false, false, null);\n        User alice = s.createAccount(\"alice\", \"alice\");\n        j.jenkins.setSecurityRealm(s);\n\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        j.jenkins.setAuthorizationStrategy(auth);\n\n        // no anonymous read access\n        assertTrue(!Jenkins.getInstance().getACL().hasPermission(Jenkins.ANONYMOUS,Jenkins.READ));\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        HtmlPage p = wc.goTo(\"error/reportError\");\n\n        assertEquals(p.asText(), 400, p.getWebResponse().getStatusCode());  // not 403 forbidden\n        assertTrue(p.getWebResponse().getContentAsString().contains(\"My car is black\"));\n    }\n\n    @TestExtension(\"testErrorPageShouldBeAnonymousAccessible\")\n    public static class ReportError implements UnprotectedRootAction {\n\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"error\";\n        }\n\n        public HttpResponse doReportError() {\n            return new Failure(\"My car is black\");\n        }\n    }\n\n    @Test @Issue(\"JENKINS-23551\")\n    public void testComputerListenerNotifiedOnRestart() {\n        // Simulate restart calling listeners\n        for (RestartListener listener : RestartListener.all())\n            listener.onRestart();\n\n        ArgumentCaptor<OfflineCause> captor = ArgumentCaptor.forClass(OfflineCause.class);\n        Mockito.verify(listenerMock).onOffline(Mockito.eq(j.jenkins.toComputer()), captor.capture());\n        assertTrue(captor.getValue().toString().contains(\"restart\"));\n    }\n\n    @TestExtension(value = \"testComputerListenerNotifiedOnRestart\")\n    public static final ComputerListener listenerMock = Mockito.mock(ComputerListener.class);\n\n    @Test\n    public void runScriptOnOfflineComputer() throws Exception {\n        DumbSlave slave = j.createSlave(true);\n        j.disconnectSlave(slave);\n\n        URL url = new URL(j.getURL(), \"computer/\" + slave.getNodeName() + \"/scriptText?script=println(42)\");\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n\n        WebRequest req = new WebRequest(url, HttpMethod.POST);\n        Page page = wc.getPage(wc.addCrumb(req));\n        WebResponse rsp = page.getWebResponse();\n\n        assertThat(rsp.getContentAsString(), containsString(\"Node is offline\"));\n        assertThat(rsp.getStatusCode(), equalTo(404));\n    }\n}\n"], "fixing_code": ["/*\n * The MIT License\n * \n * Copyright (c) 2004-2012, Sun Microsystems, Inc., Kohsuke Kawaguchi, Erik Ramfelt,\n * Tom Huybrechts, Vincent Latombe\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.google.common.base.Predicate;\nimport com.infradna.tool.bridge_method_injector.WithBridgeMethods;\nimport hudson.*;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.Permission;\nimport hudson.security.SecurityRealm;\nimport hudson.security.UserMayOrMayNotExistException;\nimport hudson.util.FormApply;\nimport hudson.util.FormValidation;\nimport hudson.util.RunList;\nimport hudson.util.XStream2;\nimport jenkins.model.IdStrategy;\nimport jenkins.model.Jenkins;\nimport jenkins.model.ModelObjectWithContextMenu;\nimport jenkins.security.ImpersonatingUserDetailsService;\nimport jenkins.security.LastGrantedAuthoritiesProperty;\nimport net.sf.json.JSONObject;\n\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.providers.UsernamePasswordAuthenticationToken;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.userdetails.UsernameNotFoundException;\nimport org.springframework.dao.DataAccessException;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.apache.commons.io.filefilter.DirectoryFileFilter;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\nimport javax.annotation.concurrent.GuardedBy;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.FileFilter;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.locks.ReadWriteLock;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\n/**\n * Represents a user.\n *\n * <p>\n * In Hudson, {@link User} objects are created in on-demand basis;\n * for example, when a build is performed, its change log is computed\n * and as a result commits from users who Hudson has never seen may be discovered.\n * When this happens, new {@link User} object is created.\n *\n * <p>\n * If the persisted record for an user exists, the information is loaded at\n * that point, but if there's no such record, a fresh instance is created from\n * thin air (this is where {@link UserPropertyDescriptor#newInstance(User)} is\n * called to provide initial {@link UserProperty} objects.\n *\n * <p>\n * Such newly created {@link User} objects will be simply GC-ed without\n * ever leaving the persisted record, unless {@link User#save()} method\n * is explicitly invoked (perhaps as a result of a browser submitting a\n * configuration.)\n *\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic class User extends AbstractModelObject implements AccessControlled, DescriptorByNameOwner, Saveable, Comparable<User>, ModelObjectWithContextMenu {\n\n    /**\n     * The username of the 'unknown' user used to avoid null user references.\n     */\n    private static final String UKNOWN_USERNAME = \"unknown\";\n\n    /**\n     * These usernames should not be used by real users logging into Jenkins. Therefore, we prevent\n     * users with these names from being saved.\n     */\n    private static final String[] ILLEGAL_PERSISTED_USERNAMES = new String[]{ACL.ANONYMOUS_USERNAME,\n            ACL.SYSTEM_USERNAME, UKNOWN_USERNAME};\n    private transient final String id;\n\n    private volatile String fullName;\n\n    private volatile String description;\n\n    /**\n     * List of {@link UserProperty}s configured for this project.\n     */\n    @CopyOnWrite\n    private volatile List<UserProperty> properties = new ArrayList<UserProperty>();\n\n\n    private User(String id, String fullName) {\n        this.id = id;\n        this.fullName = fullName;\n        load();\n    }\n\n    /**\n     * Returns the {@link jenkins.model.IdStrategy} for use with {@link User} instances. See\n     * {@link hudson.security.SecurityRealm#getUserIdStrategy()}\n     *\n     * @return the {@link jenkins.model.IdStrategy} for use with {@link User} instances.\n     * @since 1.566\n     */\n    @Nonnull\n    public static IdStrategy idStrategy() {\n        Jenkins j = Jenkins.getInstance();\n        if (j == null) {\n            return IdStrategy.CASE_INSENSITIVE;\n        }\n        SecurityRealm realm = j.getSecurityRealm();\n        if (realm == null) {\n            return IdStrategy.CASE_INSENSITIVE;\n        }\n        return realm.getUserIdStrategy();\n    }\n\n    public int compareTo(User that) {\n        return idStrategy().compare(this.id, that.id);\n    }\n\n    /**\n     * Loads the other data from disk if it's available.\n     */\n    private synchronized void load() {\n        properties.clear();\n\n        XmlFile config = getConfigFile();\n        try {\n            if(config.exists())\n                config.unmarshal(this);\n        } catch (IOException e) {\n            LOGGER.log(Level.SEVERE, \"Failed to load \"+config,e);\n        }\n\n        // remove nulls that have failed to load\n        for (Iterator<UserProperty> itr = properties.iterator(); itr.hasNext();) {\n            if(itr.next()==null)\n                itr.remove();            \n        }\n\n        // allocate default instances if needed.\n        // doing so after load makes sure that newly added user properties do get reflected\n        for (UserPropertyDescriptor d : UserProperty.all()) {\n            if(getProperty(d.clazz)==null) {\n                UserProperty up = d.newInstance(this);\n                if(up!=null)\n                    properties.add(up);\n            }\n        }\n\n        for (UserProperty p : properties)\n            p.setUser(this);\n    }\n\n    @Exported\n    public String getId() {\n        return id;\n    }\n\n    public @Nonnull String getUrl() {\n        return \"user/\"+Util.rawEncode(idStrategy().keyFor(id));\n    }\n\n    public @Nonnull String getSearchUrl() {\n        return \"/user/\"+Util.rawEncode(idStrategy().keyFor(id));\n    }\n\n    /**\n     * The URL of the user page.\n     */\n    @Exported(visibility=999)\n    public @Nonnull String getAbsoluteUrl() {\n        return Jenkins.getInstance().getRootUrl()+getUrl();\n    }\n\n    /**\n     * Gets the human readable name of this user.\n     * This is configurable by the user.\n     */\n    @Exported(visibility=999)\n    public @Nonnull String getFullName() {\n        return fullName;\n    }\n\n    /**\n     * Sets the human readable name of the user.\n     * If the input parameter is empty, the user's ID will be set.\n     */\n    public void setFullName(String name) {\n        if(Util.fixEmptyAndTrim(name)==null)    name=id;\n        this.fullName = name;\n    }\n\n    @Exported\n    public @CheckForNull String getDescription() {\n        return description;\n    }\n\n\n    /**\n     * Sets the description of the user.\n     * @since 1.609\n     */\n    public void setDescription(String description) {\n        this.description = description;\n    }\n\n    /**\n     * Gets the user properties configured for this user.\n     */\n    public Map<Descriptor<UserProperty>,UserProperty> getProperties() {\n        return Descriptor.toMap(properties);\n    }\n\n    /**\n     * Updates the user object by adding a property.\n     */\n    public synchronized void addProperty(@Nonnull UserProperty p) throws IOException {\n        UserProperty old = getProperty(p.getClass());\n        List<UserProperty> ps = new ArrayList<UserProperty>(properties);\n        if(old!=null)\n            ps.remove(old);\n        ps.add(p);\n        p.setUser(this);\n        properties = ps;\n        save();\n    }\n\n    /**\n     * List of all {@link UserProperty}s exposed primarily for the remoting API.\n     */\n    @Exported(name=\"property\",inline=true)\n    public List<UserProperty> getAllProperties() {\n        return Collections.unmodifiableList(properties);\n    }\n    \n    /**\n     * Gets the specific property, or null.\n     */\n    public <T extends UserProperty> T getProperty(Class<T> clazz) {\n        for (UserProperty p : properties) {\n            if(clazz.isInstance(p))\n                return clazz.cast(p);\n        }\n        return null;\n    }\n\n    /**\n     * Creates an {@link Authentication} object that represents this user.\n     *\n     * This method checks with {@link SecurityRealm} if the user is a valid user that can login to the security realm.\n     * If {@link SecurityRealm} is a kind that does not support querying information about other users, this will\n     * use {@link LastGrantedAuthoritiesProperty} to pick up the granted authorities as of the last time the user has\n     * logged in.\n     *\n     * @throws UsernameNotFoundException\n     *      If this user is not a valid user in the backend {@link SecurityRealm}.\n     * @since 1.419\n     */\n    public @Nonnull Authentication impersonate() throws UsernameNotFoundException {\n        try {\n            UserDetails u = new ImpersonatingUserDetailsService(\n                    Jenkins.getInstance().getSecurityRealm().getSecurityComponents().userDetails).loadUserByUsername(id);\n            return new UsernamePasswordAuthenticationToken(u.getUsername(), \"\", u.getAuthorities());\n        } catch (UserMayOrMayNotExistException e) {\n            // backend can't load information about other users. so use the stored information if available\n        } catch (UsernameNotFoundException e) {\n            // if the user no longer exists in the backend, we need to refuse impersonating this user\n            if (!ALLOW_NON_EXISTENT_USER_TO_LOGIN)\n                throw e;\n        } catch (DataAccessException e) {\n            // seems like it's in the same boat as UserMayOrMayNotExistException\n        }\n\n        // seems like a legitimate user we have no idea about. proceed with minimum access\n        return new UsernamePasswordAuthenticationToken(id, \"\",\n            new GrantedAuthority[]{SecurityRealm.AUTHENTICATED_AUTHORITY});\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        checkPermission(Jenkins.ADMINISTER);\n\n        description = req.getParameter(\"description\");\n        save();\n        \n        rsp.sendRedirect(\".\");  // go to the top page\n    }\n\n    /**\n     * Gets the fallback \"unknown\" user instance.\n     * <p>\n     * This is used to avoid null {@link User} instance.\n     */\n    public static @Nonnull User getUnknown() {\n        return getById(UKNOWN_USERNAME, true);\n    }\n\n    /**\n     * Gets the {@link User} object by its id or full name.\n     *\n     * @param create\n     *      If true, this method will never return null for valid input\n     *      (by creating a new {@link User} object if none exists.)\n     *      If false, this method will return null if {@link User} object\n     *      with the given name doesn't exist.\n     * @return Requested user. May be {@code null} if a user does not exist and\n     *      {@code create} is false.\n     * @deprecated use {@link User#get(String, boolean, java.util.Map)}\n     */\n    @Deprecated\n    public static @Nullable User get(String idOrFullName, boolean create) {\n        return get(idOrFullName, create, Collections.emptyMap());\n    }\n\n    /**\n     * Gets the {@link User} object by its id or full name.\n     *\n     * @param create\n     *      If true, this method will never return null for valid input\n     *      (by creating a new {@link User} object if none exists.)\n     *      If false, this method will return null if {@link User} object\n     *      with the given name doesn't exist.\n     *\n     * @param context\n     *      contextual environment this user idOfFullName was retrieved from,\n     *      that can help resolve the user ID\n     * \n     * @return\n     *      An existing or created user. May be {@code null} if a user does not exist and\n     *      {@code create} is false.\n     */\n    public static @Nullable User get(String idOrFullName, boolean create, Map context) {\n\n        if(idOrFullName==null)\n            return null;\n\n        // sort resolvers by priority\n        List<CanonicalIdResolver> resolvers = new ArrayList<CanonicalIdResolver>(ExtensionList.lookup(CanonicalIdResolver.class));\n        Collections.sort(resolvers);\n\n        String id = null;\n        for (CanonicalIdResolver resolver : resolvers) {\n            id = resolver.resolveCanonicalId(idOrFullName, context);\n            if (id != null) {\n                LOGGER.log(Level.FINE, \"{0} mapped {1} to {2}\", new Object[] {resolver, idOrFullName, id});\n                break;\n            }\n        }\n        // DefaultUserCanonicalIdResolver will always return a non-null id if all other CanonicalIdResolver failed\n        if (id == null) {\n            throw new IllegalStateException(\"The user id should be always non-null thanks to DefaultUserCanonicalIdResolver\");\n        }\n        return getOrCreate(id, idOrFullName, create);\n    }\n\n    /**\n     * Retrieve a user by its ID, and create a new one if requested.\n     * @return\n     *      An existing or created user. May be {@code null} if a user does not exist and\n     *      {@code create} is false.\n     */\n    private static @Nullable User getOrCreate(@Nonnull String id, @Nonnull String fullName, boolean create) {\n        String idkey = idStrategy().keyFor(id);\n\n        byNameLock.readLock().lock();\n        User u;\n        try {\n            u = byName.get(idkey);\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        final File configFile = getConfigFileFor(id);\n        if (!configFile.isFile() && !configFile.getParentFile().isDirectory()) {\n            // check for legacy users and migrate if safe to do so.\n            File[] legacy = getLegacyConfigFilesFor(id);\n            if (legacy != null && legacy.length > 0) {\n                for (File legacyUserDir : legacy) {\n                    final XmlFile legacyXml = new XmlFile(XSTREAM, new File(legacyUserDir, \"config.xml\"));\n                    try {\n                        Object o = legacyXml.read();\n                        if (o instanceof User) {\n                            if (idStrategy().equals(id, legacyUserDir.getName()) && !idStrategy().filenameOf(legacyUserDir.getName())\n                                    .equals(legacyUserDir.getName())) {\n                                if (!legacyUserDir.renameTo(configFile.getParentFile())) {\n                                    LOGGER.log(Level.WARNING, \"Failed to migrate user record from {0} to {1}\",\n                                            new Object[]{legacyUserDir, configFile.getParentFile()});\n                                }\n                                break;\n                            }\n                        } else {\n                            LOGGER.log(Level.FINE, \"Unexpected object loaded from {0}: {1}\",\n                                    new Object[]{ legacyUserDir, o });\n                        }\n                    } catch (IOException e) {\n                        LOGGER.log(Level.FINE, String.format(\"Exception trying to load user from {0}: {1}\",\n                                new Object[]{ legacyUserDir, e.getMessage() }), e);\n                    }\n                }\n            }\n        }\n        if (u==null && (create || configFile.exists())) {\n            User tmp = new User(id, fullName);\n            User prev;\n            byNameLock.readLock().lock();\n            try {\n                prev = byName.putIfAbsent(idkey, u = tmp);\n            } finally {\n                byNameLock.readLock().unlock();\n            }\n            if (prev != null) {\n                u = prev; // if some has already put a value in the map, use it\n                if (LOGGER.isLoggable(Level.FINE) && !fullName.equals(prev.getFullName())) {\n                    LOGGER.log(Level.FINE, \"mismatch on fullName (\u2018\" + fullName + \"\u2019 vs. \u2018\" + prev.getFullName() + \"\u2019) for \u2018\" + id + \"\u2019\", new Throwable());\n                }\n            } else if (!id.equals(fullName) && !configFile.exists()) {\n                // JENKINS-16332: since the fullName may not be recoverable from the id, and various code may store the id only, we must save the fullName\n                try {\n                    u.save();\n                } catch (IOException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n            }\n        }\n        return u;\n    }\n\n    /**\n     * Gets the {@link User} object by its id or full name.\n     * Use {@link #getById} when you know you have an ID.\n     */\n    public static @Nonnull User get(String idOrFullName) {\n        return get(idOrFullName,true);\n    }\n\n    /**\n     * Gets the {@link User} object representing the currently logged-in user, or null\n     * if the current user is anonymous.\n     * @since 1.172\n     */\n    public static @CheckForNull User current() {\n        return get(Jenkins.getAuthentication());\n    }\n\n    /**\n     * Gets the {@link User} object representing the supplied {@link Authentication} or\n     * {@code null} if the supplied {@link Authentication} is either anonymous or {@code null}\n     * @param a the supplied {@link Authentication} .\n     * @return a {@link User} object for the supplied {@link Authentication} or {@code null}\n     * @since 1.609\n     */\n    public static @CheckForNull User get(@CheckForNull Authentication a) {\n        if(a == null || a instanceof AnonymousAuthenticationToken)\n            return null;\n\n        // Since we already know this is a name, we can just call getOrCreate with the name directly.\n        String id = a.getName();\n        return getById(id, true);\n    }\n\n    /**\n     * Gets the {@link User} object by its <code>id</code>\n     *\n     * @param id\n     *            the id of the user to retrieve and optionally create if it does not exist.\n     * @param create\n     *            If <code>true</code>, this method will never return <code>null</code> for valid input (by creating a\n     *            new {@link User} object if none exists.) If <code>false</code>, this method will return\n     *            <code>null</code> if {@link User} object with the given id doesn't exist.\n     * @return the a User whose id is <code>id</code>, or <code>null</code> if <code>create</code> is <code>false</code>\n     *         and the user does not exist.\n     */\n    public static @Nullable User getById(String id, boolean create) {\n        return getOrCreate(id, id, create);\n    }\n\n    private static volatile long lastScanned;\n\n    /**\n     * Gets all the users.\n     */\n    public static @Nonnull Collection<User> getAll() {\n        final IdStrategy strategy = idStrategy();\n        if(System.currentTimeMillis() -lastScanned>10000) {\n            // occasionally scan the file system to check new users\n            // whether we should do this only once at start up or not is debatable.\n            // set this right away to avoid another thread from doing the same thing while we do this.\n            // having two threads doing the work won't cause race condition, but it's waste of time.\n            lastScanned = System.currentTimeMillis();\n\n            File[] subdirs = getRootDir().listFiles((FileFilter)DirectoryFileFilter.INSTANCE);\n            if(subdirs==null)       return Collections.emptyList(); // shall never happen\n\n            for (File subdir : subdirs)\n                if(new File(subdir,\"config.xml\").exists()) {\n                    String name = strategy.idFromFilename(subdir.getName());\n                    User.getOrCreate(name, name, true);\n                }\n\n            lastScanned = System.currentTimeMillis();\n        }\n\n        byNameLock.readLock().lock();\n        ArrayList<User> r;\n        try {\n            r = new ArrayList<User>(byName.values());\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        Collections.sort(r,new Comparator<User>() {\n\n            public int compare(User o1, User o2) {\n                return strategy.compare(o1.getId(), o2.getId());\n            }\n        });\n        return r;\n    }\n\n    /**\n     * Reloads the configuration from disk.\n     */\n    public static void reload() {\n        byNameLock.readLock().lock();\n        try {\n            for (User u : byName.values()) {\n                u.load();\n            }\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n    }\n\n    /**\n     * Stop gap hack. Don't use it. To be removed in the trunk.\n     */\n    public static void clear() {\n        byNameLock.writeLock().lock();\n        try {\n            byName.clear();\n        } finally {\n            byNameLock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Called when changing the {@link IdStrategy}.\n     * @since 1.566\n     */\n    public static void rekey() {\n        final IdStrategy strategy = idStrategy();\n        byNameLock.writeLock().lock();\n        try {\n            for (Map.Entry<String, User> e : byName.entrySet()) {\n                String idkey = strategy.keyFor(e.getValue().id);\n                if (!idkey.equals(e.getKey())) {\n                    // need to remap\n                    byName.remove(e.getKey());\n                    byName.putIfAbsent(idkey, e.getValue());\n                }\n            }\n        } finally {\n            byNameLock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Returns the user name.\n     */\n    public @Nonnull String getDisplayName() {\n        return getFullName();\n    }\n\n    /** true if {@link AbstractBuild#hasParticipant} or {@link hudson.model.Cause.UserIdCause} */\n    private boolean relatedTo(@Nonnull AbstractBuild<?,?> b) {\n        if (b.hasParticipant(this)) {\n            return true;\n        }\n        for (Cause cause : b.getCauses()) {\n            if (cause instanceof Cause.UserIdCause) {\n                String userId = ((Cause.UserIdCause) cause).getUserId();\n                if (userId != null && idStrategy().equals(userId, getId())) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Gets the list of {@link Build}s that include changes by this user,\n     * by the timestamp order.\n     */\n    @WithBridgeMethods(List.class)\n    public @Nonnull RunList getBuilds() {\n    \treturn new RunList<Run<?,?>>(Jenkins.getInstance().getAllItems(Job.class)).filter(new Predicate<Run<?,?>>() {\n            @Override public boolean apply(Run<?,?> r) {\n                return r instanceof AbstractBuild && relatedTo((AbstractBuild<?,?>) r);\n            }\n        });\n    }\n\n    /**\n     * Gets all the {@link AbstractProject}s that this user has committed to.\n     * @since 1.191\n     */\n    public @Nonnull Set<AbstractProject<?,?>> getProjects() {\n        Set<AbstractProject<?,?>> r = new HashSet<AbstractProject<?,?>>();\n        for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class))\n            if(p.hasParticipant(this))\n                r.add(p);\n        return r;\n    }\n\n    public @Override String toString() {\n        return fullName;\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    protected final XmlFile getConfigFile() {\n        return new XmlFile(XSTREAM,getConfigFileFor(id));\n    }\n\n    private static final File getConfigFileFor(String id) {\n        return new File(getRootDir(), idStrategy().filenameOf(id) +\"/config.xml\");\n    }\n\n    private static final File[] getLegacyConfigFilesFor(final String id) {\n        return getRootDir().listFiles(new FileFilter() {\n            @Override\n            public boolean accept(File pathname) {\n                return pathname.isDirectory() && new File(pathname, \"config.xml\").isFile() && idStrategy().equals(\n                        pathname.getName(), id);\n            }\n        });\n    }\n\n    /**\n     * Gets the directory where Hudson stores user information.\n     */\n    private static File getRootDir() {\n        return new File(Jenkins.getInstance().getRootDir(), \"users\");\n    }\n\n    /**\n     * Is the ID allowed? Some are prohibited for security reasons. See SECURITY-166.\n     * <p/>\n     * Note that this is only enforced when saving. These users are often created\n     * via the constructor (and even listed on /asynchPeople), but our goal is to\n     * prevent anyone from logging in as these users. Therefore, we prevent\n     * saving a User with one of these ids.\n     *\n     * @return true if the username or fullname is valid\n     * @since 1.600\n     */\n    public static boolean isIdOrFullnameAllowed(String id) {\n        for (String invalidId : ILLEGAL_PERSISTED_USERNAMES) {\n            if (id.equalsIgnoreCase(invalidId))\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException, FormValidation {\n        if (! isIdOrFullnameAllowed(id)) {\n            throw FormValidation.error(Messages.User_IllegalUsername(id));\n        }\n        if (! isIdOrFullnameAllowed(fullName)) {\n            throw FormValidation.error(Messages.User_IllegalFullname(fullName));\n        }\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n    /**\n     * Deletes the data directory and removes this user from Hudson.\n     *\n     * @throws IOException\n     *      if we fail to delete.\n     */\n    public synchronized void delete() throws IOException {\n        final IdStrategy strategy = idStrategy();\n        byNameLock.readLock().lock();\n        try {\n            byName.remove(strategy.keyFor(id));\n        } finally {\n            byNameLock.readLock().unlock();\n        }\n        Util.deleteRecursive(new File(getRootDir(), strategy.filenameOf(id)));\n    }\n\n    /**\n     * Exposed remote API.\n     */\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Accepts submission from the configuration page.\n     */\n    @RequirePOST\n    public void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(Jenkins.ADMINISTER);\n\n        JSONObject json = req.getSubmittedForm();\n\n        fullName = json.getString(\"fullName\");\n        description = json.getString(\"description\");\n\n        List<UserProperty> props = new ArrayList<UserProperty>();\n        int i = 0;\n        for (UserPropertyDescriptor d : UserProperty.all()) {\n            UserProperty p = getProperty(d.clazz);\n\n            JSONObject o = json.optJSONObject(\"userProperty\" + (i++));\n            if (o!=null) {\n                if (p != null) {\n                    p = p.reconfigure(req, o);\n                } else {\n                    p = d.newInstance(req, o);\n                }\n                p.setUser(this);\n            }\n\n            if (p!=null)\n                props.add(p);\n        }\n        this.properties = props;\n\n        save();\n\n        FormApply.success(\".\").generateResponse(req,rsp,this);\n    }\n\n    /**\n     * Deletes this user from Hudson.\n     */\n    @RequirePOST\n    public void doDoDelete(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(Jenkins.ADMINISTER);\n        if (idStrategy().equals(id, Jenkins.getAuthentication().getName())) {\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST, \"Cannot delete self\");\n            return;\n        }\n\n        delete();\n\n        rsp.sendRedirect2(\"../..\");\n    }\n\n    public void doRssAll(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        rss(req, rsp, \" all builds\", getBuilds(), Run.FEED_ADAPTER);\n    }\n\n    public void doRssFailed(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        rss(req, rsp, \" regression builds\", getBuilds().regressionOnly(), Run.FEED_ADAPTER);\n    }\n\n    public void doRssLatest(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        final List<Run> lastBuilds = new ArrayList<Run>();\n        for (AbstractProject<?,?> p : Jenkins.getInstance().getAllItems(AbstractProject.class)) {\n            for (AbstractBuild<?,?> b = p.getLastBuild(); b != null; b = b.getPreviousBuild()) {\n                if (relatedTo(b)) {\n                    lastBuilds.add(b);\n                    break;\n                }\n            }\n        }\n        rss(req, rsp, \" latest build\", RunList.fromRuns(lastBuilds), Run.FEED_ADAPTER_LATEST);\n    }\n\n    private void rss(StaplerRequest req, StaplerResponse rsp, String suffix, RunList runs, FeedAdapter adapter)\n            throws IOException, ServletException {\n        RSS.forwardToRss(getDisplayName()+ suffix, getUrl(), runs.newBuilds(), adapter, req, rsp);\n    }\n\n    /**\n     * Keyed by {@link User#id}. This map is used to ensure\n     * singleton-per-id semantics of {@link User} objects.\n     *\n     * The key needs to be generated by {@link IdStrategy#keyFor(String)}.\n     */\n    @GuardedBy(\"byNameLock\")\n    private static final ConcurrentMap<String,User> byName = new ConcurrentHashMap<String, User>();\n\n    /**\n     * This lock is used to guard access to the {@link #byName} map. Use\n     * {@link java.util.concurrent.locks.ReadWriteLock#readLock()} for normal access and\n     * {@link java.util.concurrent.locks.ReadWriteLock#writeLock()} for {@link #rekey()} or any other operation\n     * that requires operating on the map as a whole.\n     */\n    private static final ReadWriteLock byNameLock = new ReentrantReadWriteLock();\n\n    /**\n     * Used to load/save user configuration.\n     */\n    public static final XStream2 XSTREAM = new XStream2();\n\n    private static final Logger LOGGER = Logger.getLogger(User.class.getName());\n\n    static {\n        XSTREAM.alias(\"user\",User.class);\n    }\n\n    public ACL getACL() {\n        final ACL base = Jenkins.getInstance().getAuthorizationStrategy().getACL(this);\n        // always allow a non-anonymous user full control of himself.\n        return new ACL() {\n            public boolean hasPermission(Authentication a, Permission permission) {\n                return (idStrategy().equals(a.getName(), id) && !(a instanceof AnonymousAuthenticationToken))\n                        || base.hasPermission(a, permission);\n            }\n        };\n    }\n\n    public void checkPermission(Permission permission) {\n        getACL().checkPermission(permission);\n    }\n\n    public boolean hasPermission(Permission permission) {\n        return getACL().hasPermission(permission);\n    }\n\n    /**\n     * With ADMINISTER permission, can delete users with persisted data but can't delete self.\n     */\n    public boolean canDelete() {\n        final IdStrategy strategy = idStrategy();\n        return hasPermission(Jenkins.ADMINISTER) && !strategy.equals(id, Jenkins.getAuthentication().getName())\n                && new File(getRootDir(), strategy.filenameOf(id)).exists();\n    }\n\n    /**\n     * Checks for authorities (groups) associated with this user.\n     * If the caller lacks {@link Jenkins#ADMINISTER}, or any problems arise, returns an empty list.\n     * {@link SecurityRealm#AUTHENTICATED_AUTHORITY} and the username, if present, are omitted.\n     * @since 1.498\n     * @return a possibly empty list\n     */\n    public @Nonnull List<String> getAuthorities() {\n        if (!Jenkins.getInstance().hasPermission(Jenkins.ADMINISTER)) {\n            return Collections.emptyList();\n        }\n        List<String> r = new ArrayList<String>();\n        Authentication authentication;\n        try {\n            authentication = impersonate();\n        } catch (UsernameNotFoundException x) {\n            LOGGER.log(Level.FINE, \"cannot look up authorities for \" + id, x);\n            return Collections.emptyList();\n        }\n        for (GrantedAuthority a : authentication.getAuthorities()) {\n            if (a.equals(SecurityRealm.AUTHENTICATED_AUTHORITY)) {\n                continue;\n            }\n            String n = a.getAuthority();\n            if (n != null && !idStrategy().equals(n, id)) {\n                r.add(n);\n            }\n        }\n        Collections.sort(r, String.CASE_INSENSITIVE_ORDER);\n        return r;\n    }\n\n    public Descriptor getDescriptorByName(String className) {\n        return Jenkins.getInstance().getDescriptorByName(className);\n    }\n    \n    public Object getDynamic(String token) {\n        for(Action action: getTransientActions()){\n            if(action.getUrlName().equals(token))\n                return action;\n        }\n        for(Action action: getPropertyActions()){\n            if(action.getUrlName().equals(token))\n                return action;\n        }\n        return null;\n    }\n    \n    /**\n     * Return all properties that are also actions.\n     * \n     * @return the list can be empty but never null. read only.\n     */\n    public List<Action> getPropertyActions() {\n        List<Action> actions = new ArrayList<Action>();\n        for (UserProperty userProp : getProperties().values()) {\n            if (userProp instanceof Action) {\n                actions.add((Action) userProp);\n            }\n        }\n        return Collections.unmodifiableList(actions);\n    }\n    \n    /**\n     * Return all transient actions associated with this user.\n     * \n     * @return the list can be empty but never null. read only.\n     */\n    public List<Action> getTransientActions() {\n        List<Action> actions = new ArrayList<Action>();\n        for (TransientUserActionFactory factory: TransientUserActionFactory.all()) {\n            actions.addAll(factory.createFor(this));\n        }\n        return Collections.unmodifiableList(actions);\n    }\n\n    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {\n        return new ContextMenu().from(this,request,response);\n    }\n\n    public static abstract class CanonicalIdResolver extends AbstractDescribableImpl<CanonicalIdResolver> implements ExtensionPoint, Comparable<CanonicalIdResolver> {\n\n        /**\n         * context key for realm (domain) where idOrFullName has been retreived from.\n         * Can be used (for example) to distinguish ambiguous committer ID using the SCM URL.\n         * Associated Value is a {@link String}\n         */\n        public static final String REALM = \"realm\";\n\n        public int compareTo(CanonicalIdResolver o) {\n            // reverse priority order\n            int i = getPriority();\n            int j = o.getPriority();\n            return i>j ? -1 : (i==j ? 0:1);\n        }\n\n        /**\n         * extract user ID from idOrFullName with help from contextual infos.\n         * can return <code>null</code> if no user ID matched the input\n         */\n        public abstract @CheckForNull String resolveCanonicalId(String idOrFullName, Map<String, ?> context);\n\n        public int getPriority() {\n            return 1;\n        }\n\n    }\n\n\n    /**\n     * Resolve user ID from full name\n     */\n    @Extension\n    public static class FullNameIdResolver extends CanonicalIdResolver {\n\n        @Override\n        public String resolveCanonicalId(String idOrFullName, Map<String, ?> context) {\n            for (User user : getAll()) {\n                if (idOrFullName.equals(user.getFullName())) return user.getId();\n            }\n            return null;\n        }\n\n        @Override\n        public int getPriority() {\n            return -1; // lower than default\n        }\n    }\n\n\n    /**\n     * Tries to verify if an ID is valid.\n     * If so, we do not want to even consider users who might have the same full name.\n     */\n    @Extension\n    @Restricted(NoExternalUse.class)\n    public static class UserIDCanonicalIdResolver extends User.CanonicalIdResolver {\n\n        private static /* not final */ boolean SECURITY_243_FULL_DEFENSE = Boolean.parseBoolean(System.getProperty(User.class.getName() + \".SECURITY_243_FULL_DEFENSE\", \"true\"));\n\n        private static final ThreadLocal<Boolean> resolving = new ThreadLocal<Boolean>() {\n            @Override\n            protected Boolean initialValue() {\n                return false;\n            }\n        };\n\n        @Override\n        public String resolveCanonicalId(String idOrFullName, Map<String, ?> context) {\n            User existing = getById(idOrFullName, false);\n            if (existing != null) {\n                return existing.getId();\n            }\n            if (SECURITY_243_FULL_DEFENSE) {\n                Jenkins j = Jenkins.getInstance();\n                if (j != null) {\n                    if (!resolving.get()) {\n                        resolving.set(true);\n                        try {\n                            return j.getSecurityRealm().loadUserByUsername(idOrFullName).getUsername();\n                        } catch (UsernameNotFoundException x) {\n                            LOGGER.log(Level.FINE, \"not sure whether \" + idOrFullName + \" is a valid username or not\", x);\n                        } catch (DataAccessException x) {\n                            LOGGER.log(Level.FINE, \"could not look up \" + idOrFullName, x);\n                        } finally {\n                            resolving.set(false);\n                        }\n                    }\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public int getPriority() {\n            // should always come first so that ID that are ids get mapped correctly\n            return Integer.MAX_VALUE;\n        }\n\n    }\n\n    /**\n     * Jenkins now refuses to let the user login if he/she doesn't exist in {@link SecurityRealm},\n     * which was necessary to make sure users removed from the backend will get removed from the frontend.\n     * <p>\n     * Unfortunately this infringed some legitimate use cases of creating Jenkins-local users for\n     * automation purposes. This escape hatch switch can be enabled to resurrect that behaviour.\n     *\n     * JENKINS-22346.\n     */\n    public static boolean ALLOW_NON_EXISTENT_USER_TO_LOGIN = Boolean.getBoolean(User.class.getName()+\".allowNonExistentUserToLogin\");\n\n\n    /**\n     * Jenkins historically created a (usually) ephemeral user record when an user with Overall/Administer permission\n     * accesses a /user/arbitraryName URL.\n     * <p>\n     * Unfortunately this constitutes a CSRF vulnerability, as malicious users can make admins create arbitrary numbers\n     * of ephemeral user records, so the behavior was changed in Jenkins 2.TODO / 2.32.2.\n     * <p>\n     * As some users may be relying on the previous behavior, setting this to true restores the previous behavior. This\n     * is not recommended.\n     *\n     * SECURITY-406.\n     */\n    // TODO 2.4+ SystemProperties\n    @Restricted(NoExternalUse.class)\n    public static boolean ALLOW_USER_CREATION_VIA_URL = Boolean.getBoolean(User.class.getName() + \".allowUserCreationViaUrl\");\n}\n\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Sun Microsystems, Inc., Kohsuke Kawaguchi,\n * Erik Ramfelt, Koichi Fujikawa, Red Hat, Inc., Seiji Sogabe,\n * Stephen Connolly, Tom Huybrechts, Yahoo! Inc., Alan Harder, CloudBees, Inc.,\n * Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport antlr.ANTLRException;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.inject.Injector;\nimport com.thoughtworks.xstream.XStream;\nimport hudson.BulkChange;\nimport hudson.DNSMultiCast;\nimport hudson.DescriptorExtensionList;\nimport hudson.Extension;\nimport hudson.ExtensionComponent;\nimport hudson.ExtensionFinder;\nimport hudson.ExtensionList;\nimport hudson.ExtensionPoint;\nimport hudson.FilePath;\nimport hudson.Functions;\nimport hudson.Launcher;\nimport hudson.Launcher.LocalLauncher;\nimport hudson.LocalPluginManager;\nimport hudson.Lookup;\nimport hudson.Plugin;\nimport hudson.PluginManager;\nimport hudson.PluginWrapper;\nimport hudson.ProxyConfiguration;\nimport hudson.TcpSlaveAgentListener;\nimport hudson.UDPBroadcastThread;\nimport hudson.Util;\nimport hudson.WebAppMain;\nimport hudson.XmlFile;\nimport hudson.cli.declarative.CLIMethod;\nimport hudson.cli.declarative.CLIResolver;\nimport hudson.init.InitMilestone;\nimport hudson.init.InitStrategy;\nimport hudson.init.TerminatorFinder;\nimport hudson.lifecycle.Lifecycle;\nimport hudson.lifecycle.RestartNotSupportedException;\nimport hudson.logging.LogRecorderManager;\nimport hudson.markup.EscapedMarkupFormatter;\nimport hudson.markup.MarkupFormatter;\nimport hudson.model.AbstractCIBase;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.AdministrativeMonitor;\nimport hudson.model.AllView;\nimport hudson.model.Api;\nimport hudson.model.Computer;\nimport hudson.model.ComputerSet;\nimport hudson.model.DependencyGraph;\nimport hudson.model.Describable;\nimport hudson.model.Descriptor;\nimport hudson.model.Descriptor.FormException;\nimport hudson.model.DescriptorByNameOwner;\nimport hudson.model.DirectoryBrowserSupport;\nimport hudson.model.Failure;\nimport hudson.model.Fingerprint;\nimport hudson.model.FingerprintCleanupThread;\nimport hudson.model.FingerprintMap;\nimport hudson.model.Hudson;\nimport hudson.model.Item;\nimport hudson.model.ItemGroup;\nimport hudson.model.ItemGroupMixIn;\nimport hudson.model.Items;\nimport hudson.model.JDK;\nimport hudson.model.Job;\nimport hudson.model.JobPropertyDescriptor;\nimport hudson.model.Label;\nimport hudson.model.ListView;\nimport hudson.model.LoadBalancer;\nimport hudson.model.LoadStatistics;\nimport hudson.model.ManagementLink;\nimport hudson.model.Messages;\nimport hudson.model.ModifiableViewGroup;\nimport hudson.model.NoFingerprintMatch;\nimport hudson.model.Node;\nimport hudson.model.OverallLoadStatistics;\nimport hudson.model.PaneStatusProperties;\nimport hudson.model.Project;\nimport hudson.model.Queue;\nimport hudson.model.Queue.FlyweightTask;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.Slave;\nimport hudson.model.TaskListener;\nimport hudson.model.TopLevelItem;\nimport hudson.model.TopLevelItemDescriptor;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.UpdateCenter;\nimport hudson.model.User;\nimport hudson.model.View;\nimport hudson.model.ViewGroupMixIn;\nimport hudson.model.WorkspaceCleanupThread;\nimport hudson.model.labels.LabelAtom;\nimport hudson.model.listeners.ItemListener;\nimport hudson.model.listeners.SCMListener;\nimport hudson.model.listeners.SaveableListener;\nimport hudson.remoting.Callable;\nimport hudson.remoting.LocalChannel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.scm.RepositoryBrowser;\nimport hudson.scm.SCM;\nimport hudson.search.CollectionSearchIndex;\nimport hudson.search.SearchIndexBuilder;\nimport hudson.search.SearchItem;\nimport hudson.security.ACL;\nimport hudson.security.AccessControlled;\nimport hudson.security.AuthorizationStrategy;\nimport hudson.security.BasicAuthenticationFilter;\nimport hudson.security.FederatedLoginService;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonFilter;\nimport hudson.security.LegacyAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.security.PermissionGroup;\nimport hudson.security.PermissionScope;\nimport hudson.security.SecurityMode;\nimport hudson.security.SecurityRealm;\nimport hudson.security.csrf.CrumbIssuer;\nimport hudson.slaves.Cloud;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.EphemeralNode;\nimport hudson.slaves.NodeDescriptor;\nimport hudson.slaves.NodeList;\nimport hudson.slaves.NodeProperty;\nimport hudson.slaves.NodePropertyDescriptor;\nimport hudson.slaves.NodeProvisioner;\nimport hudson.slaves.OfflineCause;\nimport hudson.slaves.RetentionStrategy;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.Builder;\nimport hudson.tasks.Publisher;\nimport hudson.triggers.SafeTimerTask;\nimport hudson.triggers.Trigger;\nimport hudson.triggers.TriggerDescriptor;\nimport hudson.util.AdministrativeError;\nimport hudson.util.CaseInsensitiveComparator;\nimport hudson.util.ClockDifference;\nimport hudson.util.CopyOnWriteList;\nimport hudson.util.CopyOnWriteMap;\nimport hudson.util.DaemonThreadFactory;\nimport hudson.util.DescribableList;\nimport hudson.util.FormApply;\nimport hudson.util.FormValidation;\nimport hudson.util.Futures;\nimport hudson.util.HudsonIsLoading;\nimport hudson.util.HudsonIsRestarting;\nimport hudson.util.IOUtils;\nimport hudson.util.Iterators;\nimport hudson.util.JenkinsReloadFailed;\nimport hudson.util.Memoizer;\nimport hudson.util.MultipartFormDataParser;\nimport hudson.util.NamingThreadFactory;\nimport hudson.util.RemotingDiagnostics;\nimport hudson.util.RemotingDiagnostics.HeapDump;\nimport hudson.util.TextFile;\nimport hudson.util.TimeUnit2;\nimport hudson.util.VersionNumber;\nimport hudson.util.XStream2;\nimport hudson.views.DefaultMyViewsTabBar;\nimport hudson.views.DefaultViewsTabBar;\nimport hudson.views.MyViewsTabBar;\nimport hudson.views.ViewsTabBar;\nimport hudson.widgets.Widget;\nimport jenkins.ExtensionComponentSet;\nimport jenkins.ExtensionRefreshException;\nimport jenkins.InitReactorRunner;\nimport jenkins.model.ProjectNamingStrategy.DefaultProjectNamingStrategy;\nimport jenkins.security.ConfidentialKey;\nimport jenkins.security.ConfidentialStore;\nimport jenkins.security.SecurityListener;\nimport jenkins.security.MasterToSlaveCallable;\nimport jenkins.slaves.WorkspaceLocator;\nimport jenkins.util.Timer;\nimport jenkins.util.io.FileBoolean;\nimport net.sf.json.JSONObject;\nimport org.acegisecurity.AccessDeniedException;\nimport org.acegisecurity.AcegiSecurityException;\nimport org.acegisecurity.Authentication;\nimport org.acegisecurity.GrantedAuthority;\nimport org.acegisecurity.GrantedAuthorityImpl;\nimport org.acegisecurity.context.SecurityContextHolder;\nimport org.acegisecurity.providers.anonymous.AnonymousAuthenticationToken;\nimport org.acegisecurity.ui.AbstractProcessingFilter;\nimport org.apache.commons.jelly.JellyException;\nimport org.apache.commons.jelly.Script;\nimport org.apache.commons.logging.LogFactory;\nimport org.jvnet.hudson.reactor.Executable;\nimport org.jvnet.hudson.reactor.Reactor;\nimport org.jvnet.hudson.reactor.ReactorException;\nimport org.jvnet.hudson.reactor.Task;\nimport org.jvnet.hudson.reactor.TaskBuilder;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder;\nimport org.jvnet.hudson.reactor.TaskGraphBuilder.Handle;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.args4j.Argument;\nimport org.kohsuke.args4j.Option;\nimport org.kohsuke.stapler.HttpRedirect;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.kohsuke.stapler.HttpResponses;\nimport org.kohsuke.stapler.MetaClass;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerFallback;\nimport org.kohsuke.stapler.StaplerProxy;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.WebApp;\nimport org.kohsuke.stapler.export.Exported;\nimport org.kohsuke.stapler.export.ExportedBean;\nimport org.kohsuke.stapler.framework.adjunct.AdjunctManager;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\nimport org.kohsuke.stapler.jelly.JellyClassLoaderTearOff;\nimport org.kohsuke.stapler.jelly.JellyRequestDispatcher;\nimport org.xml.sax.InputSource;\n\nimport javax.annotation.CheckForNull;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.crypto.SecretKey;\nimport javax.servlet.RequestDispatcher;\nimport javax.servlet.ServletContext;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.Cookie;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.net.BindException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.security.SecureRandom;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.util.TreeMap;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.logging.Level;\nimport java.util.logging.LogRecord;\nimport java.util.logging.Logger;\n\nimport static hudson.Util.*;\nimport static hudson.init.InitMilestone.*;\nimport hudson.util.LogTaskListener;\nimport static java.util.logging.Level.*;\nimport static javax.servlet.http.HttpServletResponse.*;\nimport org.kohsuke.stapler.WebMethod;\n\n/**\n * Root object of the system.\n *\n * @author Kohsuke Kawaguchi\n */\n@ExportedBean\npublic class Jenkins extends AbstractCIBase implements DirectlyModifiableTopLevelItemGroup, StaplerProxy, StaplerFallback,\n        ModifiableViewGroup, AccessControlled, DescriptorByNameOwner,\n        ModelObjectWithContextMenu, ModelObjectWithChildren {\n    private transient final Queue queue;\n\n    /**\n     * Stores various objects scoped to {@link Jenkins}.\n     */\n    public transient final Lookup lookup = new Lookup();\n\n    /**\n     * We update this field to the current version of Jenkins whenever we save {@code config.xml}.\n     * This can be used to detect when an upgrade happens from one version to next.\n     *\n     * <p>\n     * Since this field is introduced starting 1.301, \"1.0\" is used to represent every version\n     * up to 1.300. This value may also include non-standard versions like \"1.301-SNAPSHOT\" or\n     * \"?\", etc., so parsing needs to be done with a care.\n     *\n     * @since 1.301\n     */\n    // this field needs to be at the very top so that other components can look at this value even during unmarshalling\n    private String version = \"1.0\";\n\n    /**\n     * Number of executors of the master node.\n     */\n    private int numExecutors = 2;\n\n    /**\n     * Job allocation strategy.\n     */\n    private Mode mode = Mode.NORMAL;\n\n    /**\n     * False to enable anyone to do anything.\n     * Left as a field so that we can still read old data that uses this flag.\n     *\n     * @see #authorizationStrategy\n     * @see #securityRealm\n     */\n    private Boolean useSecurity;\n\n    /**\n     * Controls how the\n     * <a href=\"http://en.wikipedia.org/wiki/Authorization\">authorization</a>\n     * is handled in Jenkins.\n     * <p>\n     * This ultimately controls who has access to what.\n     *\n     * Never null.\n     */\n    private volatile AuthorizationStrategy authorizationStrategy = AuthorizationStrategy.UNSECURED;\n\n    /**\n     * Controls a part of the\n     * <a href=\"http://en.wikipedia.org/wiki/Authentication\">authentication</a>\n     * handling in Jenkins.\n     * <p>\n     * Intuitively, this corresponds to the user database.\n     *\n     * See {@link HudsonFilter} for the concrete authentication protocol.\n     *\n     * Never null. Always use {@link #setSecurityRealm(SecurityRealm)} to\n     * update this field.\n     *\n     * @see #getSecurity()\n     * @see #setSecurityRealm(SecurityRealm)\n     */\n    private volatile SecurityRealm securityRealm = SecurityRealm.NO_AUTHENTICATION;\n\n    /**\n     * Disables the remember me on this computer option in the standard login screen.\n     *\n     * @since 1.534\n     */\n    private volatile boolean disableRememberMe;\n\n    /**\n     * The project naming strategy defines/restricts the names which can be given to a project/job. e.g. does the name have to follow a naming convention?\n     */\n    private ProjectNamingStrategy projectNamingStrategy = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n\n    /**\n     * Root directory for the workspaces.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getWorkspaceFor(TopLevelItem)\n     */\n    private String workspaceDir = \"${ITEM_ROOTDIR}/\"+WORKSPACE_DIRNAME;\n\n    /**\n     * Root directory for the builds.\n     * This value will be variable-expanded as per {@link #expandVariablesForDirectory}.\n     * @see #getBuildDirFor(Job)\n     */\n    private String buildsDir = \"${ITEM_ROOTDIR}/builds\";\n\n    /**\n     * Message displayed in the top page.\n     */\n    private String systemMessage;\n\n    private MarkupFormatter markupFormatter;\n\n    /**\n     * Root directory of the system.\n     */\n    public transient final File root;\n\n    /**\n     * Where are we in the initialization?\n     */\n    private transient volatile InitMilestone initLevel = InitMilestone.STARTED;\n\n    /**\n     * All {@link Item}s keyed by their {@link Item#getName() name}s.\n     */\n    /*package*/ transient final Map<String,TopLevelItem> items = new CopyOnWriteMap.Tree<String,TopLevelItem>(CaseInsensitiveComparator.INSTANCE);\n\n    /**\n     * The sole instance.\n     */\n    private static Jenkins theInstance;\n\n    private transient volatile boolean isQuietingDown;\n    private transient volatile boolean terminating;\n\n    private List<JDK> jdks = new ArrayList<JDK>();\n\n    private transient volatile DependencyGraph dependencyGraph;\n    private final transient AtomicBoolean dependencyGraphDirty = new AtomicBoolean();\n\n    /**\n     * Currently active Views tab bar.\n     */\n    private volatile ViewsTabBar viewsTabBar = new DefaultViewsTabBar();\n\n    /**\n     * Currently active My Views tab bar.\n     */\n    private volatile MyViewsTabBar myViewsTabBar = new DefaultMyViewsTabBar();\n\n    /**\n     * All {@link ExtensionList} keyed by their {@link ExtensionList#extensionType}.\n     */\n    private transient final Memoizer<Class,ExtensionList> extensionLists = new Memoizer<Class,ExtensionList>() {\n        public ExtensionList compute(Class key) {\n            return ExtensionList.create(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * All {@link DescriptorExtensionList} keyed by their {@link DescriptorExtensionList#describableType}.\n     */\n    private transient final Memoizer<Class,DescriptorExtensionList> descriptorLists = new Memoizer<Class,DescriptorExtensionList>() {\n        public DescriptorExtensionList compute(Class key) {\n            return DescriptorExtensionList.createDescriptorList(Jenkins.this,key);\n        }\n    };\n\n    /**\n     * {@link Computer}s in this Jenkins system. Read-only.\n     */\n    protected transient final Map<Node,Computer> computers = new CopyOnWriteMap.Hash<Node,Computer>();\n\n    /**\n     * Active {@link Cloud}s.\n     */\n    public final Hudson.CloudList clouds = new Hudson.CloudList(this);\n\n    public static class CloudList extends DescribableList<Cloud,Descriptor<Cloud>> {\n        public CloudList(Jenkins h) {\n            super(h);\n        }\n\n        public CloudList() {// needed for XStream deserialization\n        }\n\n        public Cloud getByName(String name) {\n            for (Cloud c : this)\n                if (c.name.equals(name))\n                    return c;\n            return null;\n        }\n\n        @Override\n        protected void onModified() throws IOException {\n            super.onModified();\n            Jenkins.getInstance().trimLabels();\n        }\n    }\n\n    /**\n     * Legacy store of the set of installed cluster nodes.\n     * @deprecated in favour of {@link Nodes}\n     */\n    @Deprecated\n    protected transient volatile NodeList slaves;\n\n    /**\n     * The holder of the set of installed cluster nodes.\n     *\n     * @since 1.607\n     */\n    private transient final Nodes nodes = new Nodes(this);\n\n    /**\n     * Quiet period.\n     *\n     * This is {@link Integer} so that we can initialize it to '5' for upgrading users.\n     */\n    /*package*/ Integer quietPeriod;\n\n    /**\n     * Global default for {@link AbstractProject#getScmCheckoutRetryCount()}\n     */\n    /*package*/ int scmCheckoutRetryCount;\n\n    /**\n     * {@link View}s.\n     */\n    private final CopyOnWriteArrayList<View> views = new CopyOnWriteArrayList<View>();\n\n    /**\n     * Name of the primary view.\n     * <p>\n     * Start with null, so that we can upgrade pre-1.269 data well.\n     * @since 1.269\n     */\n    private volatile String primaryView;\n\n    private transient final ViewGroupMixIn viewGroupMixIn = new ViewGroupMixIn(this) {\n        protected List<View> views() { return views; }\n        protected String primaryView() { return primaryView; }\n        protected void primaryView(String name) { primaryView=name; }\n    };\n\n\n    private transient final FingerprintMap fingerprintMap = new FingerprintMap();\n\n    /**\n     * Loaded plugins.\n     */\n    public transient final PluginManager pluginManager;\n\n    public transient volatile TcpSlaveAgentListener tcpSlaveAgentListener;\n\n    private transient UDPBroadcastThread udpBroadcastThread;\n\n    private transient DNSMultiCast dnsMultiCast;\n\n    /**\n     * List of registered {@link SCMListener}s.\n     */\n    private transient final CopyOnWriteList<SCMListener> scmListeners = new CopyOnWriteList<SCMListener>();\n\n    /**\n     * TCP slave agent port.\n     * 0 for random, -1 to disable.\n     */\n    private int slaveAgentPort =0;\n\n    /**\n     * Whitespace-separated labels assigned to the master as a {@link Node}.\n     */\n    private String label=\"\";\n\n    /**\n     * {@link hudson.security.csrf.CrumbIssuer}\n     */\n    private volatile CrumbIssuer crumbIssuer;\n\n    /**\n     * All labels known to Jenkins. This allows us to reuse the same label instances\n     * as much as possible, even though that's not a strict requirement.\n     */\n    private transient final ConcurrentHashMap<String,Label> labels = new ConcurrentHashMap<String,Label>();\n\n    /**\n     * Load statistics of the entire system.\n     *\n     * This includes every executor and every job in the system.\n     */\n    @Exported\n    public transient final OverallLoadStatistics overallLoad = new OverallLoadStatistics();\n\n    /**\n     * Load statistics of the free roaming jobs and slaves.\n     *\n     * This includes all executors on {@link hudson.model.Node.Mode#NORMAL} nodes and jobs that do not have any assigned nodes.\n     *\n     * @since 1.467\n     */\n    @Exported\n    public transient final LoadStatistics unlabeledLoad = new UnlabeledLoadStatistics();\n\n    /**\n     * {@link NodeProvisioner} that reacts to {@link #unlabeledLoad}.\n     * @since 1.467\n     */\n    public transient final NodeProvisioner unlabeledNodeProvisioner = new NodeProvisioner(null,unlabeledLoad);\n\n    /**\n     * @deprecated as of 1.467\n     *      Use {@link #unlabeledNodeProvisioner}.\n     *      This was broken because it was tracking all the executors in the system, but it was only tracking\n     *      free-roaming jobs in the queue. So {@link Cloud} fails to launch nodes when you have some exclusive\n     *      slaves and free-roaming jobs in the queue.\n     */\n    @Restricted(NoExternalUse.class)\n    @Deprecated\n    public transient final NodeProvisioner overallNodeProvisioner = unlabeledNodeProvisioner;\n\n\n    public transient final ServletContext servletContext;\n\n    /**\n     * Transient action list. Useful for adding navigation items to the navigation bar\n     * on the left.\n     */\n    private transient final List<Action> actions = new CopyOnWriteArrayList<Action>();\n\n    /**\n     * List of master node properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> nodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * List of global properties\n     */\n    private DescribableList<NodeProperty<?>,NodePropertyDescriptor> globalNodeProperties = new DescribableList<NodeProperty<?>,NodePropertyDescriptor>(this);\n\n    /**\n     * {@link AdministrativeMonitor}s installed on this system.\n     *\n     * @see AdministrativeMonitor\n     */\n    public transient final List<AdministrativeMonitor> administrativeMonitors = getExtensionList(AdministrativeMonitor.class);\n\n    /**\n     * Widgets on Jenkins.\n     */\n    private transient final List<Widget> widgets = getExtensionList(Widget.class);\n\n    /**\n     * {@link AdjunctManager}\n     */\n    private transient final AdjunctManager adjuncts;\n\n    /**\n     * Code that handles {@link ItemGroup} work.\n     */\n    private transient final ItemGroupMixIn itemGroupMixIn = new ItemGroupMixIn(this,this) {\n        @Override\n        protected void add(TopLevelItem item) {\n            items.put(item.getName(),item);\n        }\n\n        @Override\n        protected File getRootDirFor(String name) {\n            return Jenkins.this.getRootDirFor(name);\n        }\n    };\n\n\n    /**\n     * Hook for a test harness to intercept Jenkins.getInstance()\n     *\n     * Do not use in the production code as the signature may change.\n     */\n    public interface JenkinsHolder {\n        @CheckForNull Jenkins getInstance();\n    }\n\n    static JenkinsHolder HOLDER = new JenkinsHolder() {\n        public @CheckForNull Jenkins getInstance() {\n            return theInstance;\n        }\n    };\n\n    /**\n     * Gets the {@link Jenkins} singleton.\n     * {@link #getInstance()} provides the unchecked versions of the method.\n     * @return {@link Jenkins} instance\n     * @throws IllegalStateException {@link Jenkins} has not been started, or was already shut down\n     * @since 1.590\n     */\n    public static @Nonnull Jenkins getActiveInstance() throws IllegalStateException {\n        Jenkins instance = HOLDER.getInstance();\n        if (instance == null) {\n            throw new IllegalStateException(\"Jenkins has not been started, or was already shut down\");\n        }\n        return instance;\n    }\n\n    /**\n     * Gets the {@link Jenkins} singleton.\n     * {@link #getActiveInstance()} provides the checked versions of the method.\n     * @return The instance. Null if the {@link Jenkins} instance has not been started,\n     * or was already shut down\n     */\n    @CLIResolver\n    @CheckForNull\n    public static Jenkins getInstance() {\n        return HOLDER.getInstance();\n    }\n\n    /**\n     * Secret key generated once and used for a long time, beyond\n     * container start/stop. Persisted outside <tt>config.xml</tt> to avoid\n     * accidental exposure.\n     */\n    private transient final String secretKey;\n\n    private transient final UpdateCenter updateCenter = new UpdateCenter();\n\n    /**\n     * True if the user opted out from the statistics tracking. We'll never send anything if this is true.\n     */\n    private Boolean noUsageStatistics;\n\n    /**\n     * HTTP proxy configuration.\n     */\n    public transient volatile ProxyConfiguration proxy;\n\n    /**\n     * Bound to \"/log\".\n     */\n    private transient final LogRecorderManager log = new LogRecorderManager();\n\n    protected Jenkins(File root, ServletContext context) throws IOException, InterruptedException, ReactorException {\n        this(root,context,null);\n    }\n\n    /**\n     * @param pluginManager\n     *      If non-null, use existing plugin manager.  create a new one.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings({\n        \"SC_START_IN_CTOR\", // bug in FindBugs. It flags UDPBroadcastThread.start() call but that's for another class\n        \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\" // Trigger.timer\n    })\n    protected Jenkins(File root, ServletContext context, PluginManager pluginManager) throws IOException, InterruptedException, ReactorException {\n        long start = System.currentTimeMillis();\n\n    \t// As Jenkins is starting, grant this process full control\n        ACL.impersonate(ACL.SYSTEM);\n        try {\n            this.root = root;\n            this.servletContext = context;\n            computeVersion(context);\n            if(theInstance!=null)\n                throw new IllegalStateException(\"second instance\");\n            theInstance = this;\n\n            if (!new File(root,\"jobs\").exists()) {\n                // if this is a fresh install, use more modern default layout that's consistent with slaves\n                workspaceDir = \"${JENKINS_HOME}/workspace/${ITEM_FULLNAME}\";\n            }\n\n            // doing this early allows InitStrategy to set environment upfront\n            final InitStrategy is = InitStrategy.get(Thread.currentThread().getContextClassLoader());\n\n            Trigger.timer = new java.util.Timer(\"Jenkins cron thread\");\n            queue = new Queue(LoadBalancer.CONSISTENT_HASH);\n\n            try {\n                dependencyGraph = DependencyGraph.EMPTY;\n            } catch (InternalError e) {\n                if(e.getMessage().contains(\"window server\")) {\n                    throw new Error(\"Looks like the server runs without X. Please specify -Djava.awt.headless=true as JVM option\",e);\n                }\n                throw e;\n            }\n\n            // get or create the secret\n            TextFile secretFile = new TextFile(new File(getRootDir(),\"secret.key\"));\n            if(secretFile.exists()) {\n                secretKey = secretFile.readTrim();\n            } else {\n                SecureRandom sr = new SecureRandom();\n                byte[] random = new byte[32];\n                sr.nextBytes(random);\n                secretKey = Util.toHexString(random);\n                secretFile.write(secretKey);\n\n                // this marker indicates that the secret.key is generated by the version of Jenkins post SECURITY-49.\n                // this indicates that there's no need to rewrite secrets on disk\n                new FileBoolean(new File(root,\"secret.key.not-so-secret\")).on();\n            }\n\n            try {\n                proxy = ProxyConfiguration.load();\n            } catch (IOException e) {\n                LOGGER.log(SEVERE, \"Failed to load proxy configuration\", e);\n            }\n\n            if (pluginManager==null)\n                pluginManager = new LocalPluginManager(this);\n            this.pluginManager = pluginManager;\n            // JSON binding needs to be able to see all the classes from all the plugins\n            WebApp.get(servletContext).setClassLoader(pluginManager.uberClassLoader);\n\n            adjuncts = new AdjunctManager(servletContext, pluginManager.uberClassLoader,\"adjuncts/\"+SESSION_HASH, TimeUnit2.DAYS.toMillis(365));\n\n            // initialization consists of ...\n            executeReactor( is,\n                    pluginManager.initTasks(is),    // loading and preparing plugins\n                    loadTasks(),                    // load jobs\n                    InitMilestone.ordering()        // forced ordering among key milestones\n            );\n\n            if(KILL_AFTER_LOAD)\n                System.exit(0);\n\n            if(slaveAgentPort!=-1) {\n                try {\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n                } catch (BindException e) {\n                    new AdministrativeError(getClass().getName()+\".tcpBind\",\n                            \"Failed to listen to incoming slave connection\",\n                            \"Failed to listen to incoming slave connection. <a href='configure'>Change the port number</a> to solve the problem.\",e);\n                }\n            } else\n                tcpSlaveAgentListener = null;\n\n            if (UDPBroadcastThread.PORT != -1) {\n                try {\n                    udpBroadcastThread = new UDPBroadcastThread(this);\n                    udpBroadcastThread.start();\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to broadcast over UDP (use -Dhudson.udp=-1 to disable)\", e);\n                }\n            }\n            dnsMultiCast = new DNSMultiCast(this);\n\n            Timer.get().scheduleAtFixedRate(new SafeTimerTask() {\n                @Override\n                protected void doRun() throws Exception {\n                    trimLabels();\n                }\n            }, TimeUnit2.MINUTES.toMillis(5), TimeUnit2.MINUTES.toMillis(5), TimeUnit.MILLISECONDS);\n\n            updateComputerList();\n\n            {// master is online now\n                Computer c = toComputer();\n                if(c!=null)\n                    for (ComputerListener cl : ComputerListener.all())\n                        cl.onOnline(c, new LogTaskListener(LOGGER, INFO));\n            }\n\n            for (ItemListener l : ItemListener.all()) {\n                long itemListenerStart = System.currentTimeMillis();\n                try {\n                    l.onLoaded();\n                } catch (RuntimeException x) {\n                    LOGGER.log(Level.WARNING, null, x);\n                }\n                if (LOG_STARTUP_PERFORMANCE)\n                    LOGGER.info(String.format(\"Took %dms for item listener %s startup\",\n                            System.currentTimeMillis()-itemListenerStart,l.getClass().getName()));\n            }\n\n            if (LOG_STARTUP_PERFORMANCE)\n                LOGGER.info(String.format(\"Took %dms for complete Jenkins startup\",\n                        System.currentTimeMillis()-start));\n        } finally {\n            SecurityContextHolder.clearContext();\n        }\n    }\n\n    /**\n     * Executes a reactor.\n     *\n     * @param is\n     *      If non-null, this can be consulted for ignoring some tasks. Only used during the initialization of Jenkins.\n     */\n    private void executeReactor(final InitStrategy is, TaskBuilder... builders) throws IOException, InterruptedException, ReactorException {\n        Reactor reactor = new Reactor(builders) {\n            /**\n             * Sets the thread name to the task for better diagnostics.\n             */\n            @Override\n            protected void runTask(Task task) throws Exception {\n                if (is!=null && is.skipInitTask(task))  return;\n\n                ACL.impersonate(ACL.SYSTEM); // full access in the initialization thread\n                String taskName = task.getDisplayName();\n\n                Thread t = Thread.currentThread();\n                String name = t.getName();\n                if (taskName !=null)\n                    t.setName(taskName);\n                try {\n                    long start = System.currentTimeMillis();\n                    super.runTask(task);\n                    if(LOG_STARTUP_PERFORMANCE)\n                        LOGGER.info(String.format(\"Took %dms for %s by %s\",\n                                System.currentTimeMillis()-start, taskName, name));\n                } finally {\n                    t.setName(name);\n                    SecurityContextHolder.clearContext();\n                }\n            }\n        };\n\n        new InitReactorRunner() {\n            @Override\n            protected void onInitMilestoneAttained(InitMilestone milestone) {\n                initLevel = milestone;\n            }\n        }.run(reactor);\n    }\n\n\n    public TcpSlaveAgentListener getTcpSlaveAgentListener() {\n        return tcpSlaveAgentListener;\n    }\n\n    /**\n     * Makes {@link AdjunctManager} URL-bound.\n     * The dummy parameter allows us to use different URLs for the same adjunct,\n     * for proper cache handling.\n     */\n    public AdjunctManager getAdjuncts(String dummy) {\n        return adjuncts;\n    }\n\n    @Exported\n    public int getSlaveAgentPort() {\n        return slaveAgentPort;\n    }\n\n    /**\n     * @param port\n     *      0 to indicate random available TCP port. -1 to disable this service.\n     */\n    public void setSlaveAgentPort(int port) throws IOException {\n        this.slaveAgentPort = port;\n\n        // relaunch the agent\n        if(tcpSlaveAgentListener==null) {\n            if(slaveAgentPort!=-1)\n                tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n        } else {\n            if(tcpSlaveAgentListener.configuredPort!=slaveAgentPort) {\n                tcpSlaveAgentListener.shutdown();\n                tcpSlaveAgentListener = null;\n                if(slaveAgentPort!=-1)\n                    tcpSlaveAgentListener = new TcpSlaveAgentListener(slaveAgentPort);\n            }\n        }\n    }\n\n    public void setNodeName(String name) {\n        throw new UnsupportedOperationException(); // not allowed\n    }\n\n    public String getNodeDescription() {\n        return Messages.Hudson_NodeDescription();\n    }\n\n    @Exported\n    public String getDescription() {\n        return systemMessage;\n    }\n\n    public PluginManager getPluginManager() {\n        return pluginManager;\n    }\n\n    public UpdateCenter getUpdateCenter() {\n        return updateCenter;\n    }\n\n    public boolean isUsageStatisticsCollected() {\n        return noUsageStatistics==null || !noUsageStatistics;\n    }\n\n    public void setNoUsageStatistics(Boolean noUsageStatistics) throws IOException {\n        this.noUsageStatistics = noUsageStatistics;\n        save();\n    }\n\n    public View.People getPeople() {\n        return new View.People(this);\n    }\n\n    /**\n     * @since 1.484\n     */\n    public View.AsynchPeople getAsynchPeople() {\n        return new View.AsynchPeople(this);\n    }\n\n    /**\n     * Does this {@link View} has any associated user information recorded?\n     * @deprecated Potentially very expensive call; do not use from Jelly views.\n     */\n    @Deprecated\n    public boolean hasPeople() {\n        return View.People.isApplicable(items.values());\n    }\n\n    public Api getApi() {\n        return new Api(this);\n    }\n\n    /**\n     * Returns a secret key that survives across container start/stop.\n     * <p>\n     * This value is useful for implementing some of the security features.\n     *\n     * @deprecated\n     *      Due to the past security advisory, this value should not be used any more to protect sensitive information.\n     *      See {@link ConfidentialStore} and {@link ConfidentialKey} for how to store secrets.\n     */\n    @Deprecated\n    public String getSecretKey() {\n        return secretKey;\n    }\n\n    /**\n     * Gets {@linkplain #getSecretKey() the secret key} as a key for AES-128.\n     * @since 1.308\n     * @deprecated\n     *       See {@link #getSecretKey()}.\n     */\n    @Deprecated\n    public SecretKey getSecretKeyAsAES128() {\n        return Util.toAes128Key(secretKey);\n    }\n\n    /**\n     * Returns the unique identifier of this Jenkins that has been historically used to identify\n     * this Jenkins to the outside world.\n     *\n     * <p>\n     * This form of identifier is weak in that it can be impersonated by others. See\n     * https://wiki.jenkins-ci.org/display/JENKINS/Instance+Identity for more modern form of instance ID\n     * that can be challenged and verified.\n     *\n     * @since 1.498\n     */\n    @SuppressWarnings(\"deprecation\")\n    public String getLegacyInstanceId() {\n        return Util.getDigestOf(getSecretKey());\n    }\n\n    /**\n     * Gets the SCM descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SCM> getScm(String shortClassName) {\n        return findDescriptor(shortClassName,SCM.all());\n    }\n\n    /**\n     * Gets the repository browser descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RepositoryBrowser<?>> getRepositoryBrowser(String shortClassName) {\n        return findDescriptor(shortClassName,RepositoryBrowser.all());\n    }\n\n    /**\n     * Gets the builder descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Builder> getBuilder(String shortClassName) {\n        return findDescriptor(shortClassName, Builder.all());\n    }\n\n    /**\n     * Gets the build wrapper descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<BuildWrapper> getBuildWrapper(String shortClassName) {\n        return findDescriptor(shortClassName, BuildWrapper.all());\n    }\n\n    /**\n     * Gets the publisher descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<Publisher> getPublisher(String shortClassName) {\n        return findDescriptor(shortClassName, Publisher.all());\n    }\n\n    /**\n     * Gets the trigger descriptor by name. Primarily used for making them web-visible.\n     */\n    public TriggerDescriptor getTrigger(String shortClassName) {\n        return (TriggerDescriptor) findDescriptor(shortClassName, Trigger.all());\n    }\n\n    /**\n     * Gets the retention strategy descriptor by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<RetentionStrategy<?>> getRetentionStrategy(String shortClassName) {\n        return findDescriptor(shortClassName, RetentionStrategy.all());\n    }\n\n    /**\n     * Gets the {@link JobPropertyDescriptor} by name. Primarily used for making them web-visible.\n     */\n    public JobPropertyDescriptor getJobProperty(String shortClassName) {\n        // combining these two lines triggers javac bug. See issue #610.\n        Descriptor d = findDescriptor(shortClassName, JobPropertyDescriptor.all());\n        return (JobPropertyDescriptor) d;\n    }\n\n    /**\n     * @deprecated\n     *      UI method. Not meant to be used programatically.\n     */\n    @Deprecated\n    public ComputerSet getComputer() {\n        return new ComputerSet();\n    }\n\n    /**\n     * Exposes {@link Descriptor} by its name to URL.\n     *\n     * After doing all the {@code getXXX(shortClassName)} methods, I finally realized that\n     * this just doesn't scale.\n     *\n     * @param id\n     *      Either {@link Descriptor#getId()} (recommended) or the short name of a {@link Describable} subtype (for compatibility)\n     * @throws IllegalArgumentException if a short name was passed which matches multiple IDs (fail fast)\n     */\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"}) // too late to fix\n    public Descriptor getDescriptor(String id) {\n        // legacy descriptors that are reigstered manually doesn't show up in getExtensionList, so check them explicitly.\n        Iterable<Descriptor> descriptors = Iterators.sequence(getExtensionList(Descriptor.class), DescriptorExtensionList.listLegacyInstances());\n        for (Descriptor d : descriptors) {\n            if (d.getId().equals(id)) {\n                return d;\n            }\n        }\n        Descriptor candidate = null;\n        for (Descriptor d : descriptors) {\n            String name = d.getId();\n            if (name.substring(name.lastIndexOf('.') + 1).equals(id)) {\n                if (candidate == null) {\n                    candidate = d;\n                } else {\n                    throw new IllegalArgumentException(id + \" is ambiguous; matches both \" + name + \" and \" + candidate.getId());\n                }\n            }\n        }\n        return candidate;\n    }\n\n    /**\n     * Alias for {@link #getDescriptor(String)}.\n     */\n    public Descriptor getDescriptorByName(String id) {\n        return getDescriptor(id);\n    }\n\n    /**\n     * Gets the {@link Descriptor} that corresponds to the given {@link Describable} type.\n     * <p>\n     * If you have an instance of {@code type} and call {@link Describable#getDescriptor()},\n     * you'll get the same instance that this method returns.\n     */\n    public Descriptor getDescriptor(Class<? extends Describable> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.clazz==type)\n                return d;\n        return null;\n    }\n\n    /**\n     * Works just like {@link #getDescriptor(Class)} but don't take no for an answer.\n     *\n     * @throws AssertionError\n     *      If the descriptor is missing.\n     * @since 1.326\n     */\n    public Descriptor getDescriptorOrDie(Class<? extends Describable> type) {\n        Descriptor d = getDescriptor(type);\n        if (d==null)\n            throw new AssertionError(type+\" is missing its descriptor\");\n        return d;\n    }\n\n    /**\n     * Gets the {@link Descriptor} instance in the current Jenkins by its type.\n     */\n    public <T extends Descriptor> T getDescriptorByType(Class<T> type) {\n        for( Descriptor d : getExtensionList(Descriptor.class) )\n            if(d.getClass()==type)\n                return type.cast(d);\n        return null;\n    }\n\n    /**\n     * Gets the {@link SecurityRealm} descriptors by name. Primarily used for making them web-visible.\n     */\n    public Descriptor<SecurityRealm> getSecurityRealms(String shortClassName) {\n        return findDescriptor(shortClassName,SecurityRealm.all());\n    }\n\n    /**\n     * Finds a descriptor that has the specified name.\n     */\n    private <T extends Describable<T>>\n    Descriptor<T> findDescriptor(String shortClassName, Collection<? extends Descriptor<T>> descriptors) {\n        String name = '.'+shortClassName;\n        for (Descriptor<T> d : descriptors) {\n            if(d.clazz.getName().endsWith(name))\n                return d;\n        }\n        return null;\n    }\n\n    protected void updateComputerList() {\n        updateComputerList(AUTOMATIC_SLAVE_LAUNCH);\n    }\n\n    /** @deprecated Use {@link SCMListener#all} instead. */\n    @Deprecated\n    public CopyOnWriteList<SCMListener> getSCMListeners() {\n        return scmListeners;\n    }\n\n    /**\n     * Gets the plugin object from its short name.\n     *\n     * <p>\n     * This allows URL <tt>hudson/plugin/ID</tt> to be served by the views\n     * of the plugin class.\n     */\n    public Plugin getPlugin(String shortName) {\n        PluginWrapper p = pluginManager.getPlugin(shortName);\n        if(p==null)     return null;\n        return p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin object from its class.\n     *\n     * <p>\n     * This allows easy storage of plugin information in the plugin singleton without\n     * every plugin reimplementing the singleton pattern.\n     *\n     * @param clazz The plugin class (beware class-loader fun, this will probably only work\n     * from within the jpi that defines the plugin class, it may or may not work in other cases)\n     *\n     * @return The plugin instance.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <P extends Plugin> P getPlugin(Class<P> clazz) {\n        PluginWrapper p = pluginManager.getPlugin(clazz);\n        if(p==null)     return null;\n        return (P) p.getPlugin();\n    }\n\n    /**\n     * Gets the plugin objects from their super-class.\n     *\n     * @param clazz The plugin class (beware class-loader fun)\n     *\n     * @return The plugin instances.\n     */\n    public <P extends Plugin> List<P> getPlugins(Class<P> clazz) {\n        List<P> result = new ArrayList<P>();\n        for (PluginWrapper w: pluginManager.getPlugins(clazz)) {\n            result.add((P)w.getPlugin());\n        }\n        return Collections.unmodifiableList(result);\n    }\n\n    /**\n     * Synonym for {@link #getDescription}.\n     */\n    public String getSystemMessage() {\n        return systemMessage;\n    }\n\n    /**\n     * Gets the markup formatter used in the system.\n     *\n     * @return\n     *      never null.\n     * @since 1.391\n     */\n    public @Nonnull MarkupFormatter getMarkupFormatter() {\n        MarkupFormatter f = markupFormatter;\n        return f != null ? f : new EscapedMarkupFormatter();\n    }\n\n    /**\n     * Sets the markup formatter used in the system globally.\n     *\n     * @since 1.391\n     */\n    public void setMarkupFormatter(MarkupFormatter f) {\n        this.markupFormatter = f;\n    }\n\n    /**\n     * Sets the system message.\n     */\n    public void setSystemMessage(String message) throws IOException {\n        this.systemMessage = message;\n        save();\n    }\n\n    public FederatedLoginService getFederatedLoginService(String name) {\n        for (FederatedLoginService fls : FederatedLoginService.all()) {\n            if (fls.getUrlName().equals(name))\n                return fls;\n        }\n        return null;\n    }\n\n    public List<FederatedLoginService> getFederatedLoginServices() {\n        return FederatedLoginService.all();\n    }\n\n    public Launcher createLauncher(TaskListener listener) {\n        return new LocalLauncher(listener).decorateFor(this);\n    }\n\n\n    public String getFullName() {\n        return \"\";\n    }\n\n    public String getFullDisplayName() {\n        return \"\";\n    }\n\n    /**\n     * Returns the transient {@link Action}s associated with the top page.\n     *\n     * <p>\n     * Adding {@link Action} is primarily useful for plugins to contribute\n     * an item to the navigation bar of the top page. See existing {@link Action}\n     * implementation for it affects the GUI.\n     *\n     * <p>\n     * To register an {@link Action}, implement {@link RootAction} extension point, or write code like\n     * {@code Jenkins.getInstance().getActions().add(...)}.\n     *\n     * @return\n     *      Live list where the changes can be made. Can be empty but never null.\n     * @since 1.172\n     */\n    public List<Action> getActions() {\n        return actions;\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins}.\n     *\n     * @see #getAllItems(Class)\n     */\n    @Exported(name=\"jobs\")\n    public List<TopLevelItem> getItems() {\n\t\tif (authorizationStrategy instanceof AuthorizationStrategy.Unsecured ||\n\t\t\tauthorizationStrategy instanceof FullControlOnceLoggedInAuthorizationStrategy) {\n\t\t\treturn new ArrayList(items.values());\n\t\t}\n\n        List<TopLevelItem> viewableItems = new ArrayList<TopLevelItem>();\n        for (TopLevelItem item : items.values()) {\n            if (item.hasPermission(Item.READ))\n                viewableItems.add(item);\n        }\n\n        return viewableItems;\n    }\n\n    /**\n     * Returns the read-only view of all the {@link TopLevelItem}s keyed by their names.\n     * <p>\n     * This method is efficient, as it doesn't involve any copying.\n     *\n     * @since 1.296\n     */\n    public Map<String,TopLevelItem> getItemMap() {\n        return Collections.unmodifiableMap(items);\n    }\n\n    /**\n     * Gets just the immediate children of {@link Jenkins} but of the given type.\n     */\n    public <T> List<T> getItems(Class<T> type) {\n        List<T> r = new ArrayList<T>();\n        for (TopLevelItem i : getItems())\n            if (type.isInstance(i))\n                 r.add(type.cast(i));\n        return r;\n    }\n\n    /**\n     * Gets all the {@link Item}s recursively in the {@link ItemGroup} tree\n     * and filter them by the given type.\n     */\n    public <T extends Item> List<T> getAllItems(Class<T> type) {\n        return Items.getAllItems(this, type);\n    }\n\n    /**\n     * Gets all the items recursively.\n     *\n     * @since 1.402\n     */\n    public List<Item> getAllItems() {\n        return getAllItems(Item.class);\n    }\n\n    /**\n     * Gets a list of simple top-level projects.\n     * @deprecated This method will ignore Maven and matrix projects, as well as projects inside containers such as folders.\n     * You may prefer to call {@link #getAllItems(Class)} on {@link AbstractProject},\n     * perhaps also using {@link Util#createSubList} to consider only {@link TopLevelItem}s.\n     * (That will also consider the caller's permissions.)\n     * If you really want to get just {@link Project}s at top level, ignoring permissions,\n     * you can filter the values from {@link #getItemMap} using {@link Util#createSubList}.\n     */\n    @Deprecated\n    public List<Project> getProjects() {\n        return Util.createSubList(items.values(),Project.class);\n    }\n\n    /**\n     * Gets the names of all the {@link Job}s.\n     */\n    public Collection<String> getJobNames() {\n        List<String> names = new ArrayList<String>();\n        for (Job j : getAllItems(Job.class))\n            names.add(j.getFullName());\n        return names;\n    }\n\n    public List<Action> getViewActions() {\n        return getActions();\n    }\n\n    /**\n     * Gets the names of all the {@link TopLevelItem}s.\n     */\n    public Collection<String> getTopLevelItemNames() {\n        List<String> names = new ArrayList<String>();\n        for (TopLevelItem j : items.values())\n            names.add(j.getName());\n        return names;\n    }\n\n    public View getView(String name) {\n        return viewGroupMixIn.getView(name);\n    }\n\n    /**\n     * Gets the read-only list of all {@link View}s.\n     */\n    @Exported\n    public Collection<View> getViews() {\n        return viewGroupMixIn.getViews();\n    }\n\n    @Override\n    public void addView(View v) throws IOException {\n        viewGroupMixIn.addView(v);\n    }\n\n    public boolean canDelete(View view) {\n        return viewGroupMixIn.canDelete(view);\n    }\n\n    public synchronized void deleteView(View view) throws IOException {\n        viewGroupMixIn.deleteView(view);\n    }\n\n    public void onViewRenamed(View view, String oldName, String newName) {\n        viewGroupMixIn.onViewRenamed(view,oldName,newName);\n    }\n\n    /**\n     * Returns the primary {@link View} that renders the top-page of Jenkins.\n     */\n    @Exported\n    public View getPrimaryView() {\n        return viewGroupMixIn.getPrimaryView();\n     }\n\n    public void setPrimaryView(View v) {\n        this.primaryView = v.getViewName();\n    }\n\n    public ViewsTabBar getViewsTabBar() {\n        return viewsTabBar;\n    }\n\n    public void setViewsTabBar(ViewsTabBar viewsTabBar) {\n        this.viewsTabBar = viewsTabBar;\n    }\n\n    public Jenkins getItemGroup() {\n        return this;\n   }\n\n    public MyViewsTabBar getMyViewsTabBar() {\n        return myViewsTabBar;\n    }\n\n    public void setMyViewsTabBar(MyViewsTabBar myViewsTabBar) {\n        this.myViewsTabBar = myViewsTabBar;\n    }\n\n    /**\n     * Returns true if the current running Jenkins is upgraded from a version earlier than the specified version.\n     *\n     * <p>\n     * This method continues to return true until the system configuration is saved, at which point\n     * {@link #version} will be overwritten and Jenkins forgets the upgrade history.\n     *\n     * <p>\n     * To handle SNAPSHOTS correctly, pass in \"1.N.*\" to test if it's upgrading from the version\n     * equal or younger than N. So say if you implement a feature in 1.301 and you want to check\n     * if the installation upgraded from pre-1.301, pass in \"1.300.*\"\n     *\n     * @since 1.301\n     */\n    public boolean isUpgradedFromBefore(VersionNumber v) {\n        try {\n            return new VersionNumber(version).isOlderThan(v);\n        } catch (IllegalArgumentException e) {\n            // fail to parse this version number\n            return false;\n        }\n    }\n\n    /**\n     * Gets the read-only list of all {@link Computer}s.\n     */\n    public Computer[] getComputers() {\n        Computer[] r = computers.values().toArray(new Computer[computers.size()]);\n        Arrays.sort(r,new Comparator<Computer>() {\n            @Override public int compare(Computer lhs, Computer rhs) {\n                if(lhs.getNode()==Jenkins.this)  return -1;\n                if(rhs.getNode()==Jenkins.this)  return 1;\n                return lhs.getName().compareTo(rhs.getName());\n            }\n        });\n        return r;\n    }\n\n    @CLIResolver\n    public @CheckForNull Computer getComputer(@Argument(required=true,metaVar=\"NAME\",usage=\"Node name\") @Nonnull String name) {\n        if(name.equals(\"(master)\"))\n            name = \"\";\n\n        for (Computer c : computers.values()) {\n            if(c.getName().equals(name))\n                return c;\n        }\n        return null;\n    }\n\n    /**\n     * Gets the label that exists on this system by the name.\n     *\n     * @return null if name is null.\n     * @see Label#parseExpression(String) (String)\n     */\n    public Label getLabel(String expr) {\n        if(expr==null)  return null;\n        expr = hudson.util.QuotedStringTokenizer.unquote(expr);\n        while(true) {\n            Label l = labels.get(expr);\n            if(l!=null)\n                return l;\n\n            // non-existent\n            try {\n                labels.putIfAbsent(expr,Label.parseExpression(expr));\n            } catch (ANTLRException e) {\n                // laxly accept it as a single label atom for backward compatibility\n                return getLabelAtom(expr);\n            }\n        }\n    }\n\n    /**\n     * Returns the label atom of the given name.\n     * @return non-null iff name is non-null\n     */\n    public @Nullable LabelAtom getLabelAtom(@CheckForNull String name) {\n        if (name==null)  return null;\n\n        while(true) {\n            Label l = labels.get(name);\n            if(l!=null)\n                return (LabelAtom)l;\n\n            // non-existent\n            LabelAtom la = new LabelAtom(name);\n            if (labels.putIfAbsent(name, la)==null)\n                la.load();\n        }\n    }\n\n    /**\n     * Gets all the active labels in the current system.\n     */\n    public Set<Label> getLabels() {\n        Set<Label> r = new TreeSet<Label>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty())\n                r.add(l);\n        }\n        return r;\n    }\n\n    public Set<LabelAtom> getLabelAtoms() {\n        Set<LabelAtom> r = new TreeSet<LabelAtom>();\n        for (Label l : labels.values()) {\n            if(!l.isEmpty() && l instanceof LabelAtom)\n                r.add((LabelAtom)l);\n        }\n        return r;\n    }\n\n    public Queue getQueue() {\n        return queue;\n    }\n\n    @Override\n    public String getDisplayName() {\n        return Messages.Hudson_DisplayName();\n    }\n\n    public synchronized List<JDK> getJDKs() {\n        if(jdks==null)\n            jdks = new ArrayList<JDK>();\n        return jdks;\n    }\n\n    /**\n     * Replaces all JDK installations with those from the given collection.\n     *\n     * Use {@link hudson.model.JDK.DescriptorImpl#setInstallations(JDK...)} to\n     * set JDK installations from external code.\n     */\n    @Restricted(NoExternalUse.class)\n    public synchronized void setJDKs(Collection<? extends JDK> jdks) {\n        this.jdks = new ArrayList<JDK>(jdks);\n    }\n\n    /**\n     * Gets the JDK installation of the given name, or returns null.\n     */\n    public JDK getJDK(String name) {\n        if(name==null) {\n            // if only one JDK is configured, \"default JDK\" should mean that JDK.\n            List<JDK> jdks = getJDKs();\n            if(jdks.size()==1)  return jdks.get(0);\n            return null;\n        }\n        for (JDK j : getJDKs()) {\n            if(j.getName().equals(name))\n                return j;\n        }\n        return null;\n    }\n\n\n\n    /**\n     * Gets the slave node of the give name, hooked under this Jenkins.\n     */\n    public @CheckForNull Node getNode(String name) {\n        return nodes.getNode(name);\n    }\n\n    /**\n     * Gets a {@link Cloud} by {@link Cloud#name its name}, or null.\n     */\n    public Cloud getCloud(String name) {\n        return clouds.getByName(name);\n    }\n\n    protected Map<Node,Computer> getComputerMap() {\n        return computers;\n    }\n\n    /**\n     * Returns all {@link Node}s in the system, excluding {@link Jenkins} instance itself which\n     * represents the master.\n     */\n    public List<Node> getNodes() {\n        return nodes.getNodes();\n    }\n\n    /**\n     * Get the {@link Nodes} object that handles maintaining individual {@link Node}s.\n     * @return The Nodes object.\n     */\n    @Restricted(NoExternalUse.class)\n    public Nodes getNodesObject() {\n        // TODO replace this with something better when we properly expose Nodes.\n        return nodes;\n    }\n\n    /**\n     * Adds one more {@link Node} to Jenkins.\n     */\n    public void addNode(Node n) throws IOException {\n        nodes.addNode(n);\n    }\n\n    /**\n     * Removes a {@link Node} from Jenkins.\n     */\n    public void removeNode(@Nonnull Node n) throws IOException {\n        nodes.removeNode(n);\n    }\n\n    public void setNodes(final List<? extends Node> n) throws IOException {\n        nodes.setNodes(n);\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getNodeProperties() {\n    \treturn nodeProperties;\n    }\n\n    public DescribableList<NodeProperty<?>, NodePropertyDescriptor> getGlobalNodeProperties() {\n    \treturn globalNodeProperties;\n    }\n\n    /**\n     * Resets all labels and remove invalid ones.\n     *\n     * This should be called when the assumptions behind label cache computation changes,\n     * but we also call this periodically to self-heal any data out-of-sync issue.\n     */\n    /*package*/ void trimLabels() {\n        for (Iterator<Label> itr = labels.values().iterator(); itr.hasNext();) {\n            Label l = itr.next();\n            resetLabel(l);\n            if(l.isEmpty())\n                itr.remove();\n        }\n    }\n\n    /**\n     * Binds {@link AdministrativeMonitor}s to URL.\n     */\n    public AdministrativeMonitor getAdministrativeMonitor(String id) {\n        for (AdministrativeMonitor m : administrativeMonitors)\n            if(m.id.equals(id))\n                return m;\n        return null;\n    }\n\n    public NodeDescriptor getDescriptor() {\n        return DescriptorImpl.INSTANCE;\n    }\n\n    public static final class DescriptorImpl extends NodeDescriptor {\n        @Extension\n        public static final DescriptorImpl INSTANCE = new DescriptorImpl();\n\n        public String getDisplayName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isInstantiable() {\n            return false;\n        }\n\n        public FormValidation doCheckNumExecutors(@QueryParameter String value) {\n            return FormValidation.validateNonNegativeInteger(value);\n        }\n\n        public FormValidation doCheckRawBuildsDir(@QueryParameter String value) {\n            // do essentially what expandVariablesForDirectory does, without an Item\n            String replacedValue = expandVariablesForDirectory(value,\n                    \"doCheckRawBuildsDir-Marker:foo\",\n                    Jenkins.getInstance().getRootDir().getPath() + \"/jobs/doCheckRawBuildsDir-Marker$foo\");\n\n            File replacedFile = new File(replacedValue);\n            if (!replacedFile.isAbsolute()) {\n                return FormValidation.error(value + \" does not resolve to an absolute path\");\n            }\n\n            if (!replacedValue.contains(\"doCheckRawBuildsDir-Marker\")) {\n                return FormValidation.error(value + \" does not contain ${ITEM_FULL_NAME} or ${ITEM_ROOTDIR}, cannot distinguish between projects\");\n            }\n\n            if (replacedValue.contains(\"doCheckRawBuildsDir-Marker:foo\")) {\n                // make sure platform can handle colon\n                try {\n                    File tmp = File.createTempFile(\"Jenkins-doCheckRawBuildsDir\", \"foo:bar\");\n                    tmp.delete();\n                } catch (IOException e) {\n                    return FormValidation.error(value + \" contains ${ITEM_FULLNAME} but your system does not support it (JENKINS-12251). Use ${ITEM_FULL_NAME} instead\");\n                }\n            }\n\n            File d = new File(replacedValue);\n            if (!d.isDirectory()) {\n                // if dir does not exist (almost guaranteed) need to make sure nearest existing ancestor can be written to\n                d = d.getParentFile();\n                while (!d.exists()) {\n                    d = d.getParentFile();\n                }\n                if (!d.canWrite()) {\n                    return FormValidation.error(value + \" does not exist and probably cannot be created\");\n                }\n            }\n\n            return FormValidation.ok();\n        }\n\n        // to route /descriptor/FQCN/xxx to getDescriptor(FQCN).xxx\n        public Object getDynamic(String token) {\n            return Jenkins.getInstance().getDescriptor(token);\n        }\n    }\n\n    /**\n     * Gets the system default quiet period.\n     */\n    public int getQuietPeriod() {\n        return quietPeriod!=null ? quietPeriod : 5;\n    }\n\n    /**\n     * Sets the global quiet period.\n     *\n     * @param quietPeriod\n     *      null to the default value.\n     */\n    public void setQuietPeriod(Integer quietPeriod) throws IOException {\n        this.quietPeriod = quietPeriod;\n        save();\n    }\n\n    /**\n     * Gets the global SCM check out retry count.\n     */\n    public int getScmCheckoutRetryCount() {\n        return scmCheckoutRetryCount;\n    }\n\n    public void setScmCheckoutRetryCount(int scmCheckoutRetryCount) throws IOException {\n        this.scmCheckoutRetryCount = scmCheckoutRetryCount;\n        save();\n    }\n\n    @Override\n    public String getSearchUrl() {\n        return \"\";\n    }\n\n    @Override\n    public SearchIndexBuilder makeSearchIndex() {\n        return super.makeSearchIndex()\n            .add(\"configure\", \"config\",\"configure\")\n            .add(\"manage\")\n            .add(\"log\")\n            .add(new CollectionSearchIndex<TopLevelItem>() {\n                protected SearchItem get(String key) { return getItemByFullName(key, TopLevelItem.class); }\n                protected Collection<TopLevelItem> all() { return getAllItems(TopLevelItem.class); }\n            })\n            .add(getPrimaryView().makeSearchIndex())\n            .add(new CollectionSearchIndex() {// for computers\n                protected Computer get(String key) { return getComputer(key); }\n                protected Collection<Computer> all() { return computers.values(); }\n            })\n            .add(new CollectionSearchIndex() {// for users\n                protected User get(String key) { return User.get(key,false); }\n                protected Collection<User> all() { return User.getAll(); }\n            })\n            .add(new CollectionSearchIndex() {// for views\n                protected View get(String key) { return getView(key); }\n                protected Collection<View> all() { return viewGroupMixIn.getViews(); }\n            });\n    }\n\n    public String getUrlChildPrefix() {\n        return \"job\";\n    }\n\n    /**\n     * Gets the absolute URL of Jenkins, such as {@code http://localhost/jenkins/}.\n     *\n     * <p>\n     * This method first tries to use the manually configured value, then\n     * fall back to {@link #getRootUrlFromRequest}.\n     * It is done in this order so that it can work correctly even in the face\n     * of a reverse proxy.\n     *\n     * @return null if this parameter is not configured by the user and the calling thread is not in an HTTP request; otherwise the returned URL will always have the trailing {@code /}\n     * @since 1.66\n     * @see <a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Hyperlinks+in+HTML\">Hyperlinks in HTML</a>\n     */\n    public @Nullable String getRootUrl() {\n        String url = JenkinsLocationConfiguration.get().getUrl();\n        if(url!=null) {\n            return Util.ensureEndsWith(url,\"/\");\n        }\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if(req!=null)\n            return getRootUrlFromRequest();\n        return null;\n    }\n\n    /**\n     * Is Jenkins running in HTTPS?\n     *\n     * Note that we can't really trust {@link StaplerRequest#isSecure()} because HTTPS might be terminated\n     * in the reverse proxy.\n     */\n    public boolean isRootUrlSecure() {\n        String url = getRootUrl();\n        return url!=null && url.startsWith(\"https\");\n    }\n\n    /**\n     * Gets the absolute URL of Jenkins top page, such as {@code http://localhost/jenkins/}.\n     *\n     * <p>\n     * Unlike {@link #getRootUrl()}, which uses the manually configured value,\n     * this one uses the current request to reconstruct the URL. The benefit is\n     * that this is immune to the configuration mistake (users often fail to set the root URL\n     * correctly, especially when a migration is involved), but the downside\n     * is that unless you are processing a request, this method doesn't work.\n     *\n     * <p>Please note that this will not work in all cases if Jenkins is running behind a\n     * reverse proxy which has not been fully configured.\n     * Specifically the {@code Host} and {@code X-Forwarded-Proto} headers must be set.\n     * <a href=\"https://wiki.jenkins-ci.org/display/JENKINS/Running+Jenkins+behind+Apache\">Running Jenkins behind Apache</a>\n     * shows some examples of configuration.\n     * @since 1.263\n     */\n    public @Nonnull String getRootUrlFromRequest() {\n        StaplerRequest req = Stapler.getCurrentRequest();\n        if (req == null) {\n            throw new IllegalStateException(\"cannot call getRootUrlFromRequest from outside a request handling thread\");\n        }\n        StringBuilder buf = new StringBuilder();\n        String scheme = getXForwardedHeader(req, \"X-Forwarded-Proto\", req.getScheme());\n        buf.append(scheme).append(\"://\");\n        String host = getXForwardedHeader(req, \"X-Forwarded-Host\", req.getServerName());\n        int index = host.indexOf(':');\n        int port = req.getServerPort();\n        if (index == -1) {\n            // Almost everyone else except Nginx put the host and port in separate headers\n            buf.append(host);\n        } else {\n            // Nginx uses the same spec as for the Host header, i.e. hostanme:port\n            buf.append(host.substring(0, index));\n            if (index + 1 < host.length()) {\n                try {\n                    port = Integer.parseInt(host.substring(index + 1));\n                } catch (NumberFormatException e) {\n                    // ignore\n                }\n            }\n            // but if a user has configured Nginx with an X-Forwarded-Port, that will win out.\n        }\n        String forwardedPort = getXForwardedHeader(req, \"X-Forwarded-Port\", null);\n        if (forwardedPort != null) {\n            try {\n                port = Integer.parseInt(forwardedPort);\n            } catch (NumberFormatException e) {\n                // ignore\n            }\n        }\n        if (port != (\"https\".equals(scheme) ? 443 : 80)) {\n            buf.append(':').append(port);\n        }\n        buf.append(req.getContextPath()).append('/');\n        return buf.toString();\n    }\n\n    /**\n     * Gets the originating \"X-Forwarded-...\" header from the request. If there are multiple headers the originating\n     * header is the first header. If the originating header contains a comma separated list, the originating entry\n     * is the first one.\n     * @param req the request\n     * @param header the header name\n     * @param defaultValue the value to return if the header is absent.\n     * @return the originating entry of the header or the default value if the header was not present.\n     */\n    private static String getXForwardedHeader(StaplerRequest req, String header, String defaultValue) {\n        String value = req.getHeader(header);\n        if (value != null) {\n            int index = value.indexOf(',');\n            return index == -1 ? value.trim() : value.substring(0,index).trim();\n        }\n        return defaultValue;\n    }\n\n    public File getRootDir() {\n        return root;\n    }\n\n    public FilePath getWorkspaceFor(TopLevelItem item) {\n        for (WorkspaceLocator l : WorkspaceLocator.all()) {\n            FilePath workspace = l.locate(item, this);\n            if (workspace != null) {\n                return workspace;\n            }\n        }\n\n        return new FilePath(expandVariablesForDirectory(workspaceDir, item));\n    }\n\n    public File getBuildDirFor(Job job) {\n        return expandVariablesForDirectory(buildsDir, job);\n    }\n\n    private File expandVariablesForDirectory(String base, Item item) {\n        return new File(expandVariablesForDirectory(base, item.getFullName(), item.getRootDir().getPath()));\n    }\n\n    @Restricted(NoExternalUse.class)\n    static String expandVariablesForDirectory(String base, String itemFullName, String itemRootDir) {\n        return Util.replaceMacro(base, ImmutableMap.of(\n                \"JENKINS_HOME\", Jenkins.getInstance().getRootDir().getPath(),\n                \"ITEM_ROOTDIR\", itemRootDir,\n                \"ITEM_FULLNAME\", itemFullName,   // legacy, deprecated\n                \"ITEM_FULL_NAME\", itemFullName.replace(':','$'))); // safe, see JENKINS-12251\n\n    }\n\n    public String getRawWorkspaceDir() {\n        return workspaceDir;\n    }\n\n    public String getRawBuildsDir() {\n        return buildsDir;\n    }\n\n    @Restricted(NoExternalUse.class)\n    public void setRawBuildsDir(String buildsDir) {\n        this.buildsDir = buildsDir;\n    }\n\n    @Override public @Nonnull FilePath getRootPath() {\n        return new FilePath(getRootDir());\n    }\n\n    @Override\n    public FilePath createPath(String absolutePath) {\n        return new FilePath((VirtualChannel)null,absolutePath);\n    }\n\n    public ClockDifference getClockDifference() {\n        return ClockDifference.ZERO;\n    }\n\n    @Override\n    public Callable<ClockDifference, IOException> getClockDifferenceCallable() {\n        return new MasterToSlaveCallable<ClockDifference, IOException>() {\n            public ClockDifference call() throws IOException {\n                return new ClockDifference(0);\n            }\n        };\n    }\n\n    /**\n     * For binding {@link LogRecorderManager} to \"/log\".\n     * Everything below here is admin-only, so do the check here.\n     */\n    public LogRecorderManager getLog() {\n        checkPermission(ADMINISTER);\n        return log;\n    }\n\n    /**\n     * A convenience method to check if there's some security\n     * restrictions in place.\n     */\n    @Exported\n    public boolean isUseSecurity() {\n        return securityRealm!=SecurityRealm.NO_AUTHENTICATION || authorizationStrategy!=AuthorizationStrategy.UNSECURED;\n    }\n\n    public boolean isUseProjectNamingStrategy(){\n        return projectNamingStrategy != DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n    }\n\n    /**\n     * If true, all the POST requests to Jenkins would have to have crumb in it to protect\n     * Jenkins from CSRF vulnerabilities.\n     */\n    @Exported\n    public boolean isUseCrumbs() {\n        return crumbIssuer!=null;\n    }\n\n    /**\n     * Returns the constant that captures the three basic security modes in Jenkins.\n     */\n    public SecurityMode getSecurity() {\n        // fix the variable so that this code works under concurrent modification to securityRealm.\n        SecurityRealm realm = securityRealm;\n\n        if(realm==SecurityRealm.NO_AUTHENTICATION)\n            return SecurityMode.UNSECURED;\n        if(realm instanceof LegacySecurityRealm)\n            return SecurityMode.LEGACY;\n        return SecurityMode.SECURED;\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public SecurityRealm getSecurityRealm() {\n        return securityRealm;\n    }\n\n    public void setSecurityRealm(SecurityRealm securityRealm) {\n        if(securityRealm==null)\n            securityRealm= SecurityRealm.NO_AUTHENTICATION;\n        this.useSecurity = true;\n        IdStrategy oldUserIdStrategy = this.securityRealm == null\n                ? securityRealm.getUserIdStrategy() // don't trigger rekey on Jenkins load\n                : this.securityRealm.getUserIdStrategy();\n        this.securityRealm = securityRealm;\n        // reset the filters and proxies for the new SecurityRealm\n        try {\n            HudsonFilter filter = HudsonFilter.get(servletContext);\n            if (filter == null) {\n                // Fix for #3069: This filter is not necessarily initialized before the servlets.\n                // when HudsonFilter does come back, it'll initialize itself.\n                LOGGER.fine(\"HudsonFilter has not yet been initialized: Can't perform security setup for now\");\n            } else {\n                LOGGER.fine(\"HudsonFilter has been previously initialized: Setting security up\");\n                filter.reset(securityRealm);\n                LOGGER.fine(\"Security is now fully set up\");\n            }\n            if (!oldUserIdStrategy.equals(this.securityRealm.getUserIdStrategy())) {\n                User.rekey();\n            }\n        } catch (ServletException e) {\n            // for binary compatibility, this method cannot throw a checked exception\n            throw new AcegiSecurityException(\"Failed to configure filter\",e) {};\n        }\n    }\n\n    public void setAuthorizationStrategy(AuthorizationStrategy a) {\n        if (a == null)\n            a = AuthorizationStrategy.UNSECURED;\n        useSecurity = true;\n        authorizationStrategy = a;\n    }\n\n    public boolean isDisableRememberMe() {\n        return disableRememberMe;\n    }\n\n    public void setDisableRememberMe(boolean disableRememberMe) {\n        this.disableRememberMe = disableRememberMe;\n    }\n\n    public void disableSecurity() {\n        useSecurity = null;\n        setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n        authorizationStrategy = AuthorizationStrategy.UNSECURED;\n    }\n\n    public void setProjectNamingStrategy(ProjectNamingStrategy ns) {\n        if(ns == null){\n            ns = DefaultProjectNamingStrategy.DEFAULT_NAMING_STRATEGY;\n        }\n        projectNamingStrategy = ns;\n    }\n\n    public Lifecycle getLifecycle() {\n        return Lifecycle.get();\n    }\n\n    /**\n     * Gets the dependency injection container that hosts all the extension implementations and other\n     * components in Jenkins.\n     *\n     * @since 1.433\n     */\n    public Injector getInjector() {\n        return lookup(Injector.class);\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered instances for the given extension type.\n     *\n     * @param extensionType\n     *      The base type that represents the extension point. Normally {@link ExtensionPoint} subtype\n     *      but that's not a hard requirement.\n     * @return\n     *      Can be an empty list but never null.\n     * @see ExtensionList#lookup\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T> ExtensionList<T> getExtensionList(Class<T> extensionType) {\n        return extensionLists.get(extensionType);\n    }\n\n    /**\n     * Used to bind {@link ExtensionList}s to URLs.\n     *\n     * @since 1.349\n     */\n    public ExtensionList getExtensionList(String extensionType) throws ClassNotFoundException {\n        return getExtensionList(pluginManager.uberClassLoader.loadClass(extensionType));\n    }\n\n    /**\n     * Returns {@link ExtensionList} that retains the discovered {@link Descriptor} instances for the given\n     * kind of {@link Describable}.\n     *\n     * @return\n     *      Can be an empty list but never null.\n     */\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends Describable<T>,D extends Descriptor<T>> DescriptorExtensionList<T,D> getDescriptorList(Class<T> type) {\n        return descriptorLists.get(type);\n    }\n\n    /**\n     * Refresh {@link ExtensionList}s by adding all the newly discovered extensions.\n     *\n     * Exposed only for {@link PluginManager#dynamicLoad(File)}.\n     */\n    public void refreshExtensions() throws ExtensionRefreshException {\n        ExtensionList<ExtensionFinder> finders = getExtensionList(ExtensionFinder.class);\n        for (ExtensionFinder ef : finders) {\n            if (!ef.isRefreshable())\n                throw new ExtensionRefreshException(ef+\" doesn't support refresh\");\n        }\n\n        List<ExtensionComponentSet> fragments = Lists.newArrayList();\n        for (ExtensionFinder ef : finders) {\n            fragments.add(ef.refresh());\n        }\n        ExtensionComponentSet delta = ExtensionComponentSet.union(fragments).filtered();\n\n        // if we find a new ExtensionFinder, we need it to list up all the extension points as well\n        List<ExtensionComponent<ExtensionFinder>> newFinders = Lists.newArrayList(delta.find(ExtensionFinder.class));\n        while (!newFinders.isEmpty()) {\n            ExtensionFinder f = newFinders.remove(newFinders.size()-1).getInstance();\n\n            ExtensionComponentSet ecs = ExtensionComponentSet.allOf(f).filtered();\n            newFinders.addAll(ecs.find(ExtensionFinder.class));\n            delta = ExtensionComponentSet.union(delta, ecs);\n        }\n\n        for (ExtensionList el : extensionLists.values()) {\n            el.refresh(delta);\n        }\n        for (ExtensionList el : descriptorLists.values()) {\n            el.refresh(delta);\n        }\n\n        // TODO: we need some generalization here so that extension points can be notified when a refresh happens?\n        for (ExtensionComponent<RootAction> ea : delta.find(RootAction.class)) {\n            Action a = ea.getInstance();\n            if (!actions.contains(a)) actions.add(a);\n        }\n    }\n\n    /**\n     * Returns the root {@link ACL}.\n     *\n     * @see AuthorizationStrategy#getRootACL()\n     */\n    @Override\n    public ACL getACL() {\n        return authorizationStrategy.getRootACL();\n    }\n\n    /**\n     * @return\n     *      never null.\n     */\n    public AuthorizationStrategy getAuthorizationStrategy() {\n        return authorizationStrategy;\n    }\n\n    /**\n     * The strategy used to check the project names.\n     * @return never <code>null</code>\n     */\n    public ProjectNamingStrategy getProjectNamingStrategy() {\n        return projectNamingStrategy == null ? ProjectNamingStrategy.DEFAULT_NAMING_STRATEGY : projectNamingStrategy;\n    }\n\n    /**\n     * Returns true if Jenkins is quieting down.\n     * <p>\n     * No further jobs will be executed unless it\n     * can be finished while other current pending builds\n     * are still in progress.\n     */\n    @Exported\n    public boolean isQuietingDown() {\n        return isQuietingDown;\n    }\n\n    /**\n     * Returns true if the container initiated the termination of the web application.\n     */\n    public boolean isTerminating() {\n        return terminating;\n    }\n\n    /**\n     * Gets the initialization milestone that we've already reached.\n     *\n     * @return\n     *      {@link InitMilestone#STARTED} even if the initialization hasn't been started, so that this method\n     *      never returns null.\n     */\n    public InitMilestone getInitLevel() {\n        return initLevel;\n    }\n\n    public void setNumExecutors(int n) throws IOException {\n        if (this.numExecutors != n) {\n            this.numExecutors = n;\n            updateComputerList();\n            save();\n        }\n    }\n\n\n\n    /**\n     * {@inheritDoc}.\n     *\n     * Note that the look up is case-insensitive.\n     */\n    @Override public TopLevelItem getItem(String name) throws AccessDeniedException {\n        if (name==null)    return null;\n    \tTopLevelItem item = items.get(name);\n        if (item==null)\n            return null;\n        if (!item.hasPermission(Item.READ)) {\n            if (item.hasPermission(Item.DISCOVER)) {\n                throw new AccessDeniedException(\"Please login to access job \" + name);\n            }\n            return null;\n        }\n        return item;\n    }\n\n    /**\n     * Gets the item by its path name from the given context\n     *\n     * <h2>Path Names</h2>\n     * <p>\n     * If the name starts from '/', like \"/foo/bar/zot\", then it's interpreted as absolute.\n     * Otherwise, the name should be something like \"foo/bar\" and it's interpreted like\n     * relative path name in the file system is, against the given context.\n     * <p>For compatibility, as a fallback when nothing else matches, a simple path\n     * like {@code foo/bar} can also be treated with {@link #getItemByFullName}.\n     * @param context\n     *      null is interpreted as {@link Jenkins}. Base 'directory' of the interpretation.\n     * @since 1.406\n     */\n    public Item getItem(String pathName, ItemGroup context) {\n        if (context==null)  context = this;\n        if (pathName==null) return null;\n\n        if (pathName.startsWith(\"/\"))   // absolute\n            return getItemByFullName(pathName);\n\n        Object/*Item|ItemGroup*/ ctx = context;\n\n        StringTokenizer tokens = new StringTokenizer(pathName,\"/\");\n        while (tokens.hasMoreTokens()) {\n            String s = tokens.nextToken();\n            if (s.equals(\"..\")) {\n                if (ctx instanceof Item) {\n                    ctx = ((Item)ctx).getParent();\n                    continue;\n                }\n\n                ctx=null;    // can't go up further\n                break;\n            }\n            if (s.equals(\".\")) {\n                continue;\n            }\n\n            if (ctx instanceof ItemGroup) {\n                ItemGroup g = (ItemGroup) ctx;\n                Item i = g.getItem(s);\n                if (i==null || !i.hasPermission(Item.READ)) { // TODO consider DISCOVER\n                    ctx=null;    // can't go up further\n                    break;\n                }\n                ctx=i;\n            } else {\n                return null;\n            }\n        }\n\n        if (ctx instanceof Item)\n            return (Item)ctx;\n\n        // fall back to the classic interpretation\n        return getItemByFullName(pathName);\n    }\n\n    public final Item getItem(String pathName, Item context) {\n        return getItem(pathName,context!=null?context.getParent():null);\n    }\n\n    public final <T extends Item> T getItem(String pathName, ItemGroup context, @Nonnull Class<T> type) {\n        Item r = getItem(pathName, context);\n        if (type.isInstance(r))\n            return type.cast(r);\n        return null;\n    }\n\n    public final <T extends Item> T getItem(String pathName, Item context, Class<T> type) {\n        return getItem(pathName,context!=null?context.getParent():null,type);\n    }\n\n    public File getRootDirFor(TopLevelItem child) {\n        return getRootDirFor(child.getName());\n    }\n\n    private File getRootDirFor(String name) {\n        return new File(new File(getRootDir(),\"jobs\"), name);\n    }\n\n    /**\n     * Gets the {@link Item} object by its full name.\n     * Full names are like path names, where each name of {@link Item} is\n     * combined by '/'.\n     *\n     * @return\n     *      null if either such {@link Item} doesn't exist under the given full name,\n     *      or it exists but it's no an instance of the given type.\n     * @throws AccessDeniedException as per {@link ItemGroup#getItem}\n     */\n    public @CheckForNull <T extends Item> T getItemByFullName(String fullName, Class<T> type) throws AccessDeniedException {\n        StringTokenizer tokens = new StringTokenizer(fullName,\"/\");\n        ItemGroup parent = this;\n\n        if(!tokens.hasMoreTokens()) return null;    // for example, empty full name.\n\n        while(true) {\n            Item item = parent.getItem(tokens.nextToken());\n            if(!tokens.hasMoreTokens()) {\n                if(type.isInstance(item))\n                    return type.cast(item);\n                else\n                    return null;\n            }\n\n            if(!(item instanceof ItemGroup))\n                return null;    // this item can't have any children\n\n            if (!item.hasPermission(Item.READ))\n                return null; // TODO consider DISCOVER\n\n            parent = (ItemGroup) item;\n        }\n    }\n\n    public @CheckForNull Item getItemByFullName(String fullName) {\n        return getItemByFullName(fullName,Item.class);\n    }\n\n    /**\n     * Gets the user of the given name.\n     *\n     * @return the user of the given name (which may or may not be an id), if that person exists; else null\n     * @see User#get(String,boolean), {@link User#getById(String, boolean)}\n     */\n    public @CheckForNull User getUser(String name) {\n        return User.get(name, User.ALLOW_USER_CREATION_VIA_URL && hasPermission(ADMINISTER));\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name ) throws IOException {\n        return createProject(type, name, true);\n    }\n\n    public synchronized TopLevelItem createProject( TopLevelItemDescriptor type, String name, boolean notify ) throws IOException {\n        return itemGroupMixIn.createProject(type,name,notify);\n    }\n\n    /**\n     * Overwrites the existing item by new one.\n     *\n     * <p>\n     * This is a short cut for deleting an existing job and adding a new one.\n     */\n    public synchronized void putItem(TopLevelItem item) throws IOException, InterruptedException {\n        String name = item.getName();\n        TopLevelItem old = items.get(name);\n        if (old ==item)  return; // noop\n\n        checkPermission(Item.CREATE);\n        if (old!=null)\n            old.delete();\n        items.put(name,item);\n        ItemListener.fireOnCreated(item);\n    }\n\n    /**\n     * Creates a new job.\n     *\n     * <p>\n     * This version infers the descriptor from the type of the top-level item.\n     *\n     * @throws IllegalArgumentException\n     *      if the project of the given name already exists.\n     */\n    public synchronized <T extends TopLevelItem> T createProject( Class<T> type, String name ) throws IOException {\n        return type.cast(createProject((TopLevelItemDescriptor)getDescriptor(type),name));\n    }\n\n    /**\n     * Called by {@link Job#renameTo(String)} to update relevant data structure.\n     * assumed to be synchronized on Jenkins by the caller.\n     */\n    public void onRenamed(TopLevelItem job, String oldName, String newName) throws IOException {\n        items.remove(oldName);\n        items.put(newName,job);\n\n        // For compatibility with old views:\n        for (View v : views)\n            v.onJobRenamed(job, oldName, newName);\n    }\n\n    /**\n     * Called in response to {@link Job#doDoDelete(StaplerRequest, StaplerResponse)}\n     */\n    public void onDeleted(TopLevelItem item) throws IOException {\n        ItemListener.fireOnDeleted(item);\n\n        items.remove(item.getName());\n        // For compatibility with old views:\n        for (View v : views)\n            v.onJobRenamed(item, item.getName(), null);\n    }\n\n    @Override public boolean canAdd(TopLevelItem item) {\n        return true;\n    }\n\n    @Override synchronized public <I extends TopLevelItem> I add(I item, String name) throws IOException, IllegalArgumentException {\n        if (items.containsKey(name)) {\n            throw new IllegalArgumentException(\"already an item '\" + name + \"'\");\n        }\n        items.put(name, item);\n        return item;\n    }\n\n    @Override public void remove(TopLevelItem item) throws IOException, IllegalArgumentException {\n        items.remove(item.getName());\n    }\n\n    public FingerprintMap getFingerprintMap() {\n        return fingerprintMap;\n    }\n\n    // if no finger print matches, display \"not found page\".\n    public Object getFingerprint( String md5sum ) throws IOException {\n        Fingerprint r = fingerprintMap.get(md5sum);\n        if(r==null)     return new NoFingerprintMatch(md5sum);\n        else            return r;\n    }\n\n    /**\n     * Gets a {@link Fingerprint} object if it exists.\n     * Otherwise null.\n     */\n    public Fingerprint _getFingerprint( String md5sum ) throws IOException {\n        return fingerprintMap.get(md5sum);\n    }\n\n    /**\n     * The file we save our configuration.\n     */\n    private XmlFile getConfigFile() {\n        return new XmlFile(XSTREAM, new File(root,\"config.xml\"));\n    }\n\n    public int getNumExecutors() {\n        return numExecutors;\n    }\n\n    public Mode getMode() {\n        return mode;\n    }\n\n    public void setMode(Mode m) throws IOException {\n        this.mode = m;\n        save();\n    }\n\n    public String getLabelString() {\n        return fixNull(label).trim();\n    }\n\n    @Override\n    public void setLabelString(String label) throws IOException {\n        this.label = label;\n        save();\n    }\n\n    @Override\n    public LabelAtom getSelfLabel() {\n        return getLabelAtom(\"master\");\n    }\n\n    public Computer createComputer() {\n        return new Hudson.MasterComputer();\n    }\n\n    private synchronized TaskBuilder loadTasks() throws IOException {\n        File projectsDir = new File(root,\"jobs\");\n        if(!projectsDir.getCanonicalFile().isDirectory() && !projectsDir.mkdirs()) {\n            if(projectsDir.exists())\n                throw new IOException(projectsDir+\" is not a directory\");\n            throw new IOException(\"Unable to create \"+projectsDir+\"\\nPermission issue? Please create this directory manually.\");\n        }\n        File[] subdirs = projectsDir.listFiles();\n\n        final Set<String> loadedNames = Collections.synchronizedSet(new HashSet<String>());\n\n        TaskGraphBuilder g = new TaskGraphBuilder();\n        Handle loadJenkins = g.requires(EXTENSIONS_AUGMENTED).attains(JOB_LOADED).add(\"Loading global config\", new Executable() {\n            public void run(Reactor session) throws Exception {\n                XmlFile cfg = getConfigFile();\n                if (cfg.exists()) {\n                    // reset some data that may not exist in the disk file\n                    // so that we can take a proper compensation action later.\n                    primaryView = null;\n                    views.clear();\n\n                    // load from disk\n                    cfg.unmarshal(Jenkins.this);\n                }\n\n                // if we are loading old data that doesn't have this field\n                if (slaves != null && !slaves.isEmpty() && nodes.isLegacy()) {\n                    nodes.setNodes(slaves);\n                    slaves = null;\n                } else {\n                    nodes.load();\n                }\n\n                clouds.setOwner(Jenkins.this);\n            }\n        });\n\n        for (final File subdir : subdirs) {\n            g.requires(loadJenkins).attains(JOB_LOADED).notFatal().add(\"Loading job \"+subdir.getName(),new Executable() {\n                public void run(Reactor session) throws Exception {\n                    if(!Items.getConfigFile(subdir).exists()) {\n                        //Does not have job config file, so it is not a jenkins job hence skip it\n                        return;\n                    }\n                    TopLevelItem item = (TopLevelItem) Items.load(Jenkins.this, subdir);\n                    items.put(item.getName(), item);\n                    loadedNames.add(item.getName());\n                }\n            });\n        }\n\n        g.requires(JOB_LOADED).add(\"Cleaning up old builds\",new Executable() {\n            public void run(Reactor reactor) throws Exception {\n                // anything we didn't load from disk, throw them away.\n                // doing this after loading from disk allows newly loaded items\n                // to inspect what already existed in memory (in case of reloading)\n\n                // retainAll doesn't work well because of CopyOnWriteMap implementation, so remove one by one\n                // hopefully there shouldn't be too many of them.\n                for (String name : items.keySet()) {\n                    if (!loadedNames.contains(name))\n                        items.remove(name);\n                }\n            }\n        });\n\n        g.requires(JOB_LOADED).add(\"Finalizing set up\",new Executable() {\n            public void run(Reactor session) throws Exception {\n                rebuildDependencyGraph();\n\n                {// recompute label objects - populates the labels mapping.\n                    for (Node slave : nodes.getNodes())\n                        // Note that not all labels are visible until the slaves have connected.\n                        slave.getAssignedLabels();\n                    getAssignedLabels();\n                }\n\n                // initialize views by inserting the default view if necessary\n                // this is both for clean Jenkins and for backward compatibility.\n                if(views.size()==0 || primaryView==null) {\n                    View v = new AllView(Messages.Hudson_ViewName());\n                    setViewOwner(v);\n                    views.add(0,v);\n                    primaryView = v.getViewName();\n                }\n\n                if (useSecurity!=null && !useSecurity) {\n                    // forced reset to the unsecure mode.\n                    // this works as an escape hatch for people who locked themselves out.\n                    authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                    setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                } else {\n                    // read in old data that doesn't have the security field set\n                    if(authorizationStrategy==null) {\n                        if(useSecurity==null)\n                            authorizationStrategy = AuthorizationStrategy.UNSECURED;\n                        else\n                            authorizationStrategy = new LegacyAuthorizationStrategy();\n                    }\n                    if(securityRealm==null) {\n                        if(useSecurity==null)\n                            setSecurityRealm(SecurityRealm.NO_AUTHENTICATION);\n                        else\n                            setSecurityRealm(new LegacySecurityRealm());\n                    } else {\n                        // force the set to proxy\n                        setSecurityRealm(securityRealm);\n                    }\n                }\n\n\n                // Initialize the filter with the crumb issuer\n                setCrumbIssuer(crumbIssuer);\n\n                // auto register root actions\n                for (Action a : getExtensionList(RootAction.class))\n                    if (!actions.contains(a)) actions.add(a);\n            }\n        });\n\n        return g;\n    }\n\n    /**\n     * Save the settings to a file.\n     */\n    public synchronized void save() throws IOException {\n        if(BulkChange.contains(this))   return;\n        getConfigFile().write(this);\n        SaveableListener.fireOnChange(this, getConfigFile());\n    }\n\n\n    /**\n     * Called to shut down the system.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\")\n    public void cleanUp() {\n        for (ItemListener l : ItemListener.all())\n            l.onBeforeShutdown();\n\n        try {\n            final TerminatorFinder tf = new TerminatorFinder(\n                    pluginManager != null ? pluginManager.uberClassLoader : Thread.currentThread().getContextClassLoader());\n            new Reactor(tf).execute(new Executor() {\n                @Override\n                public void execute(Runnable command) {\n                    command.run();\n                }\n            });\n        } catch (InterruptedException e) {\n            LOGGER.log(SEVERE, \"Failed to execute termination\",e);\n            e.printStackTrace();\n        } catch (ReactorException e) {\n            LOGGER.log(SEVERE, \"Failed to execute termination\",e);\n        } catch (IOException e) {\n            LOGGER.log(SEVERE, \"Failed to execute termination\",e);\n        }\n\n        final Set<Future<?>> pending = new HashSet<Future<?>>();\n        terminating = true;\n        // JENKINS-28840 we know we will be interrupting all the Computers so get the Queue lock once for all\n        Queue.withLock(new Runnable() {\n            @Override\n            public void run() {\n                for( Computer c : computers.values() ) {\n                    c.interrupt();\n                    killComputer(c);\n                    pending.add(c.disconnect(null));\n                }\n            }\n        });\n        if(udpBroadcastThread!=null)\n            udpBroadcastThread.shutdown();\n        if(dnsMultiCast!=null)\n            dnsMultiCast.close();\n        interruptReloadThread();\n\n        java.util.Timer timer = Trigger.timer;\n        if (timer != null) {\n            timer.cancel();\n        }\n        // TODO: how to wait for the completion of the last job?\n        Trigger.timer = null;\n\n        Timer.shutdown();\n\n        if(tcpSlaveAgentListener!=null)\n            tcpSlaveAgentListener.shutdown();\n\n        if(pluginManager!=null) // be defensive. there could be some ugly timing related issues\n            pluginManager.stop();\n\n        if(getRootDir().exists())\n            // if we are aborting because we failed to create JENKINS_HOME,\n            // don't try to save. Issue #536\n            getQueue().save();\n\n        threadPoolForLoad.shutdown();\n        for (Future<?> f : pending)\n            try {\n                f.get(10, TimeUnit.SECONDS);    // if clean up operation didn't complete in time, we fail the test\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                break;  // someone wants us to die now. quick!\n            } catch (ExecutionException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            } catch (TimeoutException e) {\n                LOGGER.log(Level.WARNING, \"Failed to shut down properly\",e);\n            }\n\n        LogFactory.releaseAll();\n\n        theInstance = null;\n    }\n\n    public Object getDynamic(String token) {\n        for (Action a : getActions()) {\n            String url = a.getUrlName();\n            if (url==null)  continue;\n            if (url.equals(token) || url.equals('/' + token))\n                return a;\n        }\n        for (Action a : getManagementLinks())\n            if(a.getUrlName().equals(token))\n                return a;\n        return null;\n    }\n\n\n//\n//\n// actions\n//\n//\n    /**\n     * Accepts submission from the configuration page.\n     */\n    public synchronized void doConfigSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        BulkChange bc = new BulkChange(this);\n        try {\n            checkPermission(ADMINISTER);\n\n            JSONObject json = req.getSubmittedForm();\n\n            workspaceDir = json.getString(\"rawWorkspaceDir\");\n            buildsDir = json.getString(\"rawBuildsDir\");\n\n            systemMessage = Util.nullify(req.getParameter(\"system_message\"));\n\n            setJDKs(req.bindJSONToList(JDK.class, json.get(\"jdks\")));\n\n            boolean result = true;\n            for (Descriptor<?> d : Functions.getSortedDescriptorsForGlobalConfigUnclassified())\n                result &= configureDescriptor(req,json,d);\n\n            version = VERSION;\n\n            save();\n            updateComputerList();\n            if(result)\n                FormApply.success(req.getContextPath()+'/').generateResponse(req, rsp, null);\n            else\n                FormApply.success(\"configure\").generateResponse(req, rsp, null);    // back to config\n        } finally {\n            bc.commit();\n        }\n    }\n\n    /**\n     * Gets the {@link CrumbIssuer} currently in use.\n     *\n     * @return null if none is in use.\n     */\n    public CrumbIssuer getCrumbIssuer() {\n        return crumbIssuer;\n    }\n\n    public void setCrumbIssuer(CrumbIssuer issuer) {\n        crumbIssuer = issuer;\n    }\n\n    public synchronized void doTestPost( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        rsp.sendRedirect(\"foo\");\n    }\n\n    private boolean configureDescriptor(StaplerRequest req, JSONObject json, Descriptor<?> d) throws FormException {\n        // collapse the structure to remain backward compatible with the JSON structure before 1.\n        String name = d.getJsonSafeClassName();\n        JSONObject js = json.has(name) ? json.getJSONObject(name) : new JSONObject(); // if it doesn't have the property, the method returns invalid null object.\n        json.putAll(js);\n        return d.configure(req, js);\n    }\n\n    /**\n     * Accepts submission from the node configuration page.\n     */\n    @RequirePOST\n    public synchronized void doConfigExecutorsSubmit( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(ADMINISTER);\n\n        BulkChange bc = new BulkChange(this);\n        try {\n            JSONObject json = req.getSubmittedForm();\n\n            MasterBuildConfiguration mbc = MasterBuildConfiguration.all().get(MasterBuildConfiguration.class);\n            if (mbc!=null)\n                mbc.configure(req,json);\n\n            getNodeProperties().rebuild(req, json.optJSONObject(\"nodeProperties\"), NodeProperty.all());\n        } finally {\n            bc.commit();\n        }\n\n        updateComputerList();\n\n        rsp.sendRedirect(req.getContextPath()+'/'+toComputer().getUrl());  // back to the computer page\n    }\n\n    /**\n     * Accepts the new description.\n     */\n    @RequirePOST\n    public synchronized void doSubmitDescription( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        getPrimaryView().doSubmitDescription(req, rsp);\n    }\n\n    @RequirePOST // TODO does not seem to work on _either_ overload!\n    public synchronized HttpRedirect doQuietDown() throws IOException {\n        try {\n            return doQuietDown(false,0);\n        } catch (InterruptedException e) {\n            throw new AssertionError(); // impossible\n        }\n    }\n\n    @CLIMethod(name=\"quiet-down\")\n    @RequirePOST\n    public HttpRedirect doQuietDown(\n            @Option(name=\"-block\",usage=\"Block until the system really quiets down and no builds are running\") @QueryParameter boolean block,\n            @Option(name=\"-timeout\",usage=\"If non-zero, only block up to the specified number of milliseconds\") @QueryParameter int timeout) throws InterruptedException, IOException {\n        synchronized (this) {\n            checkPermission(ADMINISTER);\n            isQuietingDown = true;\n        }\n        if (block) {\n            long waitUntil = timeout;\n            if (timeout > 0) waitUntil += System.currentTimeMillis();\n            while (isQuietingDown\n                   && (timeout <= 0 || System.currentTimeMillis() < waitUntil)\n                   && !RestartListener.isAllReady()) {\n                Thread.sleep(1000);\n            }\n        }\n        return new HttpRedirect(\".\");\n    }\n\n    @CLIMethod(name=\"cancel-quiet-down\")\n    @RequirePOST // TODO the cancel link needs to be updated accordingly\n    public synchronized HttpRedirect doCancelQuietDown() {\n        checkPermission(ADMINISTER);\n        isQuietingDown = false;\n        getQueue().scheduleMaintenance();\n        return new HttpRedirect(\".\");\n    }\n\n    public HttpResponse doToggleCollapse() throws ServletException, IOException {\n    \tfinal StaplerRequest request = Stapler.getCurrentRequest();\n    \tfinal String paneId = request.getParameter(\"paneId\");\n\n    \tPaneStatusProperties.forCurrentUser().toggleCollapsed(paneId);\n\n        return HttpResponses.forwardToPreviousPage();\n    }\n\n    /**\n     * Backward compatibility. Redirect to the thread dump.\n     */\n    public void doClassicThreadDump(StaplerResponse rsp) throws IOException, ServletException {\n        rsp.sendRedirect2(\"threadDump\");\n    }\n\n    /**\n     * Obtains the thread dump of all slaves (including the master.)\n     *\n     * <p>\n     * Since this is for diagnostics, it has a built-in precautionary measure against hang slaves.\n     */\n    public Map<String,Map<String,String>> getAllThreadDumps() throws IOException, InterruptedException {\n        checkPermission(ADMINISTER);\n\n        // issue the requests all at once\n        Map<String,Future<Map<String,String>>> future = new HashMap<String, Future<Map<String, String>>>();\n\n        for (Computer c : getComputers()) {\n            try {\n                future.put(c.getName(), RemotingDiagnostics.getThreadDumpAsync(c.getChannel()));\n            } catch(Exception e) {\n                LOGGER.info(\"Failed to get thread dump for node \" + c.getName() + \": \" + e.getMessage());\n            }\n        }\n\t\tif (toComputer() == null) {\n\t\t\tfuture.put(\"master\", RemotingDiagnostics.getThreadDumpAsync(FilePath.localChannel));\n\t\t}\n\n        // if the result isn't available in 5 sec, ignore that.\n        // this is a precaution against hang nodes\n        long endTime = System.currentTimeMillis() + 5000;\n\n        Map<String,Map<String,String>> r = new HashMap<String, Map<String, String>>();\n        for (Entry<String, Future<Map<String, String>>> e : future.entrySet()) {\n            try {\n                r.put(e.getKey(), e.getValue().get(endTime-System.currentTimeMillis(), TimeUnit.MILLISECONDS));\n            } catch (Exception x) {\n                StringWriter sw = new StringWriter();\n                x.printStackTrace(new PrintWriter(sw,true));\n                r.put(e.getKey(), Collections.singletonMap(\"Failed to retrieve thread dump\",sw.toString()));\n            }\n        }\n        return Collections.unmodifiableSortedMap(new TreeMap<String, Map<String, String>>(r));\n    }\n\n    @RequirePOST\n    public synchronized TopLevelItem doCreateItem( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        return itemGroupMixIn.createTopLevelItem(req, rsp);\n    }\n\n    /**\n     * @since 1.319\n     */\n    public TopLevelItem createProjectFromXML(String name, InputStream xml) throws IOException {\n        return itemGroupMixIn.createProjectFromXML(name, xml);\n    }\n\n\n    @SuppressWarnings({\"unchecked\"})\n    public <T extends TopLevelItem> T copy(T src, String name) throws IOException {\n        return itemGroupMixIn.copy(src, name);\n    }\n\n    // a little more convenient overloading that assumes the caller gives us the right type\n    // (or else it will fail with ClassCastException)\n    public <T extends AbstractProject<?,?>> T copy(T src, String name) throws IOException {\n        return (T)copy((TopLevelItem)src,name);\n    }\n\n    @RequirePOST\n    public synchronized void doCreateView( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException, FormException {\n        checkPermission(View.CREATE);\n        addView(View.create(req,rsp, this));\n    }\n\n    /**\n     * Check if the given name is suitable as a name\n     * for job, view, etc.\n     *\n     * @throws Failure\n     *      if the given name is not good\n     */\n    public static void checkGoodName(String name) throws Failure {\n        if(name==null || name.length()==0)\n            throw new Failure(Messages.Hudson_NoName());\n\n        if(\".\".equals(name.trim()))\n            throw new Failure(Messages.Jenkins_NotAllowedName(\".\"));\n        if(\"..\".equals(name.trim()))\n            throw new Failure(Messages.Jenkins_NotAllowedName(\"..\"));\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch)) {\n                throw new Failure(Messages.Hudson_ControlCodeNotAllowed(toPrintableName(name)));\n            }\n            if(\"?*/\\\\%!@#$^&|<>[]:;\".indexOf(ch)!=-1)\n                throw new Failure(Messages.Hudson_UnsafeChar(ch));\n        }\n\n        // looks good\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     * @return trimmed name if valid; throws Failure if not\n     */\n    private String checkJobName(String name) throws Failure {\n        checkGoodName(name);\n        name = name.trim();\n        projectNamingStrategy.checkName(name);\n        if(getItem(name)!=null)\n            throw new Failure(Messages.Hudson_JobAlreadyExists(name));\n        // looks good\n        return name;\n    }\n\n    private static String toPrintableName(String name) {\n        StringBuilder printableName = new StringBuilder();\n        for( int i=0; i<name.length(); i++ ) {\n            char ch = name.charAt(i);\n            if(Character.isISOControl(ch))\n                printableName.append(\"\\\\u\").append((int)ch).append(';');\n            else\n                printableName.append(ch);\n        }\n        return printableName.toString();\n    }\n\n    /**\n     * Checks if the user was successfully authenticated.\n     *\n     * @see BasicAuthenticationFilter\n     */\n    public void doSecured( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        // TODO fire something in SecurityListener? (seems to be used only for REST calls when LegacySecurityRealm is active)\n\n        if(req.getUserPrincipal()==null) {\n            // authentication must have failed\n            rsp.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n            return;\n        }\n\n        // the user is now authenticated, so send him back to the target\n        String path = req.getContextPath()+req.getOriginalRestOfPath();\n        String q = req.getQueryString();\n        if(q!=null)\n            path += '?'+q;\n\n        rsp.sendRedirect2(path);\n    }\n\n    /**\n     * Called once the user logs in. Just forward to the top page.\n     * Used only by {@link LegacySecurityRealm}.\n     */\n    public void doLoginEntry( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        if(req.getUserPrincipal()==null) {\n            rsp.sendRedirect2(\"noPrincipal\");\n            return;\n        }\n\n        // TODO fire something in SecurityListener?\n\n        String from = req.getParameter(\"from\");\n        if(from!=null && from.startsWith(\"/\") && !from.equals(\"/loginError\")) {\n            rsp.sendRedirect2(from);    // I'm bit uncomfortable letting users redircted to other sites, make sure the URL falls into this domain\n            return;\n        }\n\n        String url = AbstractProcessingFilter.obtainFullRequestUrl(req);\n        if(url!=null) {\n            // if the login redirect is initiated by Acegi\n            // this should send the user back to where s/he was from.\n            rsp.sendRedirect2(url);\n            return;\n        }\n\n        rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Logs out the user.\n     */\n    public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String user = getAuthentication().getName();\n        securityRealm.doLogout(req, rsp);\n        SecurityListener.fireLoggedOut(user);\n    }\n\n    /**\n     * Serves jar files for JNLP slave agents.\n     */\n    public Slave.JnlpJar getJnlpJars(String fileName) {\n        return new Slave.JnlpJar(fileName);\n    }\n\n    public Slave.JnlpJar doJnlpJars(StaplerRequest req) {\n        return new Slave.JnlpJar(req.getRestOfPath().substring(1));\n    }\n\n    /**\n     * Reloads the configuration.\n     */\n    @CLIMethod(name=\"reload-configuration\")\n    @RequirePOST\n    public synchronized HttpResponse doReload() throws IOException {\n        checkPermission(ADMINISTER);\n\n        // engage \"loading ...\" UI and then run the actual task in a separate thread\n        servletContext.setAttribute(\"app\", new HudsonIsLoading());\n\n        new Thread(\"Jenkins config reload thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    reload();\n                } catch (Exception e) {\n                    LOGGER.log(SEVERE,\"Failed to reload Jenkins config\",e);\n                    new JenkinsReloadFailed(e).publish(servletContext,root);\n                }\n            }\n        }.start();\n\n        return HttpResponses.redirectViaContextPath(\"/\");\n    }\n\n    /**\n     * Reloads the configuration synchronously.\n     */\n    public void reload() throws IOException, InterruptedException, ReactorException {\n        executeReactor(null, loadTasks());\n        User.reload();\n        servletContext.setAttribute(\"app\", this);\n    }\n\n    /**\n     * Do a finger-print check.\n     */\n    public void doDoFingerprintCheck( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        // Parse the request\n        MultipartFormDataParser p = new MultipartFormDataParser(req);\n        if(isUseCrumbs() && !getCrumbIssuer().validateCrumb(req, p)) {\n            rsp.sendError(HttpServletResponse.SC_FORBIDDEN,\"No crumb found\");\n        }\n        try {\n            rsp.sendRedirect2(req.getContextPath()+\"/fingerprint/\"+\n                Util.getDigestOf(p.getFileItem(\"name\").getInputStream())+'/');\n        } finally {\n            p.cleanUp();\n        }\n    }\n\n    /**\n     * For debugging. Expose URL to perform GC.\n     */\n    @edu.umd.cs.findbugs.annotations.SuppressWarnings(\"DM_GC\")\n    @RequirePOST\n    public void doGc(StaplerResponse rsp) throws IOException {\n        checkPermission(Jenkins.ADMINISTER);\n        System.gc();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"GCed\");\n    }\n\n    /**\n     * End point that intentionally throws an exception to test the error behaviour.\n     * @since 1.467\n     */\n    public void doException() {\n        throw new RuntimeException();\n    }\n\n    public ContextMenu doContextMenu(StaplerRequest request, StaplerResponse response) throws IOException, JellyException {\n        ContextMenu menu = new ContextMenu().from(this, request, response);\n        for (MenuItem i : menu.items) {\n            if (i.url.equals(request.getContextPath() + \"/manage\")) {\n                // add \"Manage Jenkins\" subitems\n                i.subMenu = new ContextMenu().from(this, request, response, \"manage\");\n            }\n        }\n        return menu;\n    }\n\n    public ContextMenu doChildrenContextMenu(StaplerRequest request, StaplerResponse response) throws Exception {\n        ContextMenu menu = new ContextMenu();\n        for (View view : getViews()) {\n            menu.add(view.getViewUrl(),view.getDisplayName());\n        }\n        return menu;\n    }\n\n    /**\n     * Obtains the heap dump.\n     */\n    public HeapDump getHeapDump() throws IOException {\n        return new HeapDump(this,FilePath.localChannel);\n    }\n\n    /**\n     * Simulates OutOfMemoryError.\n     * Useful to make sure OutOfMemoryHeapDump setting.\n     */\n    @RequirePOST\n    public void doSimulateOutOfMemory() throws IOException {\n        checkPermission(ADMINISTER);\n\n        System.out.println(\"Creating artificial OutOfMemoryError situation\");\n        List<Object> args = new ArrayList<Object>();\n        while (true)\n            args.add(new byte[1024*1024]);\n    }\n\n    /**\n     * Binds /userContent/... to $JENKINS_HOME/userContent.\n     */\n    public DirectoryBrowserSupport doUserContent() {\n        return new DirectoryBrowserSupport(this,getRootPath().child(\"userContent\"),\"User content\",\"folder.png\",true);\n    }\n\n    /**\n     * Perform a restart of Jenkins, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     */\n    @CLIMethod(name=\"restart\")\n    public void doRestart(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\")) {\n            req.getView(this,\"_restart.jelly\").forward(req,rsp);\n            return;\n        }\n\n        restart();\n\n        if (rsp != null) // null for CLI\n            rsp.sendRedirect2(\".\");\n    }\n\n    /**\n     * Queues up a restart of Jenkins for when there are no builds running, if we can.\n     *\n     * This first replaces \"app\" to {@link HudsonIsRestarting}\n     *\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-restart\")\n    public HttpResponse doSafeRestart(StaplerRequest req) throws IOException, ServletException, RestartNotSupportedException {\n        checkPermission(ADMINISTER);\n        if (req != null && req.getMethod().equals(\"GET\"))\n            return HttpResponses.forwardToView(this,\"_safeRestart.jelly\");\n\n        safeRestart();\n\n        return HttpResponses.redirectToDot();\n    }\n\n    /**\n     * Performs a restart.\n     */\n    public void restart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Jenkins is restartable\n        servletContext.setAttribute(\"app\", new HudsonIsRestarting());\n\n        new Thread(\"restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // give some time for the browser to load the \"reloading\" page\n                    Thread.sleep(5000);\n                    LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                    for (RestartListener listener : RestartListener.all())\n                        listener.onRestart();\n                    lifecycle.restart();\n                } catch (InterruptedException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\",e);\n                } catch (IOException e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\",e);\n                }\n            }\n        }.start();\n    }\n\n    /**\n     * Queues up a restart to be performed once there are no builds currently running.\n     * @since 1.332\n     */\n    public void safeRestart() throws RestartNotSupportedException {\n        final Lifecycle lifecycle = Lifecycle.get();\n        lifecycle.verifyRestartable(); // verify that Jenkins is restartable\n        // Quiet down so that we won't launch new builds.\n        isQuietingDown = true;\n\n        new Thread(\"safe-restart thread\") {\n            final String exitUser = getAuthentication().getName();\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n\n                    // Wait 'til we have no active executors.\n                    doQuietDown(true, 0);\n\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        servletContext.setAttribute(\"app\",new HudsonIsRestarting());\n                        // give some time for the browser to load the \"reloading\" page\n                        LOGGER.info(\"Restart in 10 seconds\");\n                        Thread.sleep(10000);\n                        LOGGER.severe(String.format(\"Restarting VM as requested by %s\",exitUser));\n                        for (RestartListener listener : RestartListener.all())\n                            listener.onRestart();\n                        lifecycle.restart();\n                    } else {\n                        LOGGER.info(\"Safe-restart mode cancelled\");\n                    }\n                } catch (Throwable e) {\n                    LOGGER.log(Level.WARNING, \"Failed to restart Jenkins\",e);\n                }\n            }\n        }.start();\n    }\n\n    @Extension @Restricted(NoExternalUse.class)\n    public static class MasterRestartNotifyier extends RestartListener {\n\n        @Override\n        public void onRestart() {\n            Computer computer = Jenkins.getInstance().toComputer();\n            if (computer == null) return;\n            RestartCause cause = new RestartCause();\n            for (ComputerListener listener: ComputerListener.all()) {\n                listener.onOffline(computer, cause);\n            }\n        }\n\n        @Override\n        public boolean isReadyToRestart() throws IOException, InterruptedException {\n            return true;\n        }\n\n        private static class RestartCause extends OfflineCause.SimpleOfflineCause {\n            protected RestartCause() {\n                super(Messages._Jenkins_IsRestarting());\n            }\n        }\n    }\n\n    /**\n     * Shutdown the system.\n     * @since 1.161\n     */\n    @CLIMethod(name=\"shutdown\")\n    @RequirePOST\n    public void doExit( StaplerRequest req, StaplerResponse rsp ) throws IOException {\n        checkPermission(ADMINISTER);\n        LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                getAuthentication().getName(), req!=null?req.getRemoteAddr():\"???\"));\n        if (rsp!=null) {\n            rsp.setStatus(HttpServletResponse.SC_OK);\n            rsp.setContentType(\"text/plain\");\n            PrintWriter w = rsp.getWriter();\n            w.println(\"Shutting down\");\n            w.close();\n        }\n\n        System.exit(0);\n    }\n\n\n    /**\n     * Shutdown the system safely.\n     * @since 1.332\n     */\n    @CLIMethod(name=\"safe-shutdown\")\n    @RequirePOST\n    public HttpResponse doSafeExit(StaplerRequest req) throws IOException {\n        checkPermission(ADMINISTER);\n        isQuietingDown = true;\n        final String exitUser = getAuthentication().getName();\n        final String exitAddr = req!=null ? req.getRemoteAddr() : \"unknown\";\n        new Thread(\"safe-exit thread\") {\n            @Override\n            public void run() {\n                try {\n                    ACL.impersonate(ACL.SYSTEM);\n                    LOGGER.severe(String.format(\"Shutting down VM as requested by %s from %s\",\n                                                exitUser, exitAddr));\n                    // Wait 'til we have no active executors.\n                    doQuietDown(true, 0);\n                    // Make sure isQuietingDown is still true.\n                    if (isQuietingDown) {\n                        cleanUp();\n                        System.exit(0);\n                    }\n                } catch (Exception e) {\n                    LOGGER.log(Level.WARNING, \"Failed to shut down Jenkins\", e);\n                }\n            }\n        }.start();\n\n        return HttpResponses.plainText(\"Shutting down as soon as all jobs are complete\");\n    }\n\n    /**\n     * Gets the {@link Authentication} object that represents the user\n     * associated with the current request.\n     */\n    public static @Nonnull Authentication getAuthentication() {\n        Authentication a = SecurityContextHolder.getContext().getAuthentication();\n        // on Tomcat while serving the login page, this is null despite the fact\n        // that we have filters. Looking at the stack trace, Tomcat doesn't seem to\n        // run the request through filters when this is the login request.\n        // see http://www.nabble.com/Matrix-authorization-problem-tp14602081p14886312.html\n        if(a==null)\n            a = ANONYMOUS;\n        return a;\n    }\n\n    /**\n     * For system diagnostics.\n     * Run arbitrary Groovy script.\n     */\n    public void doScript(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, req.getView(this, \"_script.jelly\"), FilePath.localChannel, getACL());\n    }\n\n    /**\n     * Run arbitrary Groovy script and return result as plain text.\n     */\n    public void doScriptText(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        _doScript(req, rsp, req.getView(this, \"_scriptText.jelly\"), FilePath.localChannel, getACL());\n    }\n\n    /**\n     * @since 1.509.1\n     */\n    public static void _doScript(StaplerRequest req, StaplerResponse rsp, RequestDispatcher view, VirtualChannel channel, ACL acl) throws IOException, ServletException {\n        // ability to run arbitrary script is dangerous\n        acl.checkPermission(RUN_SCRIPTS);\n\n        String text = req.getParameter(\"script\");\n        if (text != null) {\n            if (!\"POST\".equals(req.getMethod())) {\n                throw HttpResponses.error(HttpURLConnection.HTTP_BAD_METHOD, \"requires POST\");\n            }\n\n            if (channel == null) {\n                throw HttpResponses.error(HttpURLConnection.HTTP_NOT_FOUND, \"Node is offline\");\n            }\n\n            try {\n                req.setAttribute(\"output\",\n                        RemotingDiagnostics.executeGroovy(text, channel));\n            } catch (InterruptedException e) {\n                throw new ServletException(e);\n            }\n        }\n\n        view.forward(req, rsp);\n    }\n\n    /**\n     * Evaluates the Jelly script submitted by the client.\n     *\n     * This is useful for system administration as well as unit testing.\n     */\n    @RequirePOST\n    public void doEval(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        checkPermission(RUN_SCRIPTS);\n\n        try {\n            MetaClass mc = WebApp.getCurrent().getMetaClass(getClass());\n            Script script = mc.classLoader.loadTearOff(JellyClassLoaderTearOff.class).createContext().compileScript(new InputSource(req.getReader()));\n            new JellyRequestDispatcher(this,script).forward(req,rsp);\n        } catch (JellyException e) {\n            throw new ServletException(e);\n        }\n    }\n\n    /**\n     * Sign up for the user account.\n     */\n    public void doSignup( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        if (getSecurityRealm().allowsSignup()) {\n            req.getView(getSecurityRealm(), \"signup.jelly\").forward(req, rsp);\n            return;\n        }\n        req.getView(SecurityRealm.class, \"signup.jelly\").forward(req, rsp);\n    }\n\n    /**\n     * Changes the icon size by changing the cookie\n     */\n    public void doIconSize( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {\n        String qs = req.getQueryString();\n        if(qs==null)\n            throw new ServletException();\n        Cookie cookie = new Cookie(\"iconSize\", Functions.validateIconSize(qs));\n        cookie.setMaxAge(/* ~4 mo. */9999999); // #762\n        rsp.addCookie(cookie);\n        String ref = req.getHeader(\"Referer\");\n        if(ref==null)   ref=\".\";\n        rsp.sendRedirect2(ref);\n    }\n\n    @RequirePOST\n    public void doFingerprintCleanup(StaplerResponse rsp) throws IOException {\n        checkPermission(ADMINISTER);\n        FingerprintCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    @RequirePOST\n    public void doWorkspaceCleanup(StaplerResponse rsp) throws IOException {\n        checkPermission(ADMINISTER);\n        WorkspaceCleanupThread.invoke();\n        rsp.setStatus(HttpServletResponse.SC_OK);\n        rsp.setContentType(\"text/plain\");\n        rsp.getWriter().println(\"Invoked\");\n    }\n\n    /**\n     * If the user chose the default JDK, make sure we got 'java' in PATH.\n     */\n    public FormValidation doDefaultJDKCheck(StaplerRequest request, @QueryParameter String value) {\n        if(!value.equals(JDK.DEFAULT_NAME))\n            // assume the user configured named ones properly in system config ---\n            // or else system config should have reported form field validation errors.\n            return FormValidation.ok();\n\n        // default JDK selected. Does such java really exist?\n        if(JDK.isDefaultJDKValid(Jenkins.this))\n            return FormValidation.ok();\n        else\n            return FormValidation.errorWithMarkup(Messages.Hudson_NoJavaInPath(request.getContextPath()));\n    }\n\n    /**\n     * Makes sure that the given name is good as a job name.\n     */\n    public FormValidation doCheckJobName(@QueryParameter String value) {\n        // this method can be used to check if a file exists anywhere in the file system,\n        // so it should be protected.\n        checkPermission(Item.CREATE);\n\n        if(fixEmpty(value)==null)\n            return FormValidation.ok();\n\n        try {\n            checkJobName(value);\n            return FormValidation.ok();\n        } catch (Failure e) {\n            return FormValidation.error(e.getMessage());\n        }\n    }\n\n    /**\n     * Checks if a top-level view with the given name exists and\n     * make sure that the name is good as a view name.\n     */\n    public FormValidation doCheckViewName(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String name = fixEmpty(value);\n        if (name == null)\n            return FormValidation.ok();\n\n        // already exists?\n        if (getView(name) != null)\n            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(name));\n\n        // good view name?\n        try {\n            checkGoodName(name);\n        } catch (Failure e) {\n            return FormValidation.error(e.getMessage());\n        }\n\n        return FormValidation.ok();\n    }\n\n    /**\n     * Checks if a top-level view with the given name exists.\n     * @deprecated 1.512\n     */\n    @Deprecated\n    public FormValidation doViewExistsCheck(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String view = fixEmpty(value);\n        if(view==null) return FormValidation.ok();\n\n        if(getView(view)==null)\n            return FormValidation.ok();\n        else\n            return FormValidation.error(Messages.Hudson_ViewAlreadyExists(view));\n    }\n\n    /**\n     * Serves static resources placed along with Jelly view files.\n     * <p>\n     * This method can serve a lot of files, so care needs to be taken\n     * to make this method secure. It's not clear to me what's the best\n     * strategy here, though the current implementation is based on\n     * file extensions.\n     */\n    public void doResources(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n        // cut off the \"...\" portion of /resources/.../path/to/file\n        // as this is only used to make path unique (which in turn\n        // allows us to set a long expiration date\n        path = path.substring(path.indexOf('/',1)+1);\n\n        int idx = path.lastIndexOf('.');\n        String extension = path.substring(idx+1);\n        if(ALLOWED_RESOURCE_EXTENSIONS.contains(extension)) {\n            URL url = pluginManager.uberClassLoader.getResource(path);\n            if(url!=null) {\n                long expires = MetaClass.NO_CACHE ? 0 : 365L * 24 * 60 * 60 * 1000; /*1 year*/\n                rsp.serveFile(req,url,expires);\n                return;\n            }\n        }\n        rsp.sendError(HttpServletResponse.SC_NOT_FOUND);\n    }\n\n    /**\n     * Extension list that {@link #doResources(StaplerRequest, StaplerResponse)} can serve.\n     * This set is mutable to allow plugins to add additional extensions.\n     */\n    public static final Set<String> ALLOWED_RESOURCE_EXTENSIONS = new HashSet<String>(Arrays.asList(\n        \"js|css|jpeg|jpg|png|gif|html|htm\".split(\"\\\\|\")\n    ));\n\n    /**\n     * Checks if container uses UTF-8 to decode URLs. See\n     * http://wiki.jenkins-ci.org/display/JENKINS/Tomcat#Tomcat-i18n\n     */\n    public FormValidation doCheckURIEncoding(StaplerRequest request) throws IOException {\n        // expected is non-ASCII String\n        final String expected = \"\\u57f7\\u4e8b\";\n        final String value = fixEmpty(request.getParameter(\"value\"));\n        if (!expected.equals(value))\n            return FormValidation.warningWithMarkup(Messages.Hudson_NotUsesUTF8ToDecodeURL());\n        return FormValidation.ok();\n    }\n\n    /**\n     * Does not check when system default encoding is \"ISO-8859-1\".\n     */\n    public static boolean isCheckURIEncodingEnabled() {\n        return !\"ISO-8859-1\".equalsIgnoreCase(System.getProperty(\"file.encoding\"));\n    }\n\n    /**\n     * Rebuilds the dependency map.\n     */\n    public void rebuildDependencyGraph() {\n        DependencyGraph graph = new DependencyGraph();\n        graph.build();\n        // volatile acts a as a memory barrier here and therefore guarantees\n        // that graph is fully build, before it's visible to other threads\n        dependencyGraph = graph;\n        dependencyGraphDirty.set(false);\n    }\n\n    /**\n     * Rebuilds the dependency map asynchronously.\n     *\n     * <p>\n     * This would keep the UI thread more responsive and helps avoid the deadlocks,\n     * as dependency graph recomputation tends to touch a lot of other things.\n     *\n     * @since 1.522\n     */\n    public Future<DependencyGraph> rebuildDependencyGraphAsync() {\n        dependencyGraphDirty.set(true);\n        return Timer.get().schedule(new java.util.concurrent.Callable<DependencyGraph>() {\n            @Override\n            public DependencyGraph call() throws Exception {\n                if (dependencyGraphDirty.get()) {\n                    rebuildDependencyGraph();\n                }\n                return dependencyGraph;\n            }\n        }, 500, TimeUnit.MILLISECONDS);\n    }\n\n    public DependencyGraph getDependencyGraph() {\n        return dependencyGraph;\n    }\n\n    // for Jelly\n    public List<ManagementLink> getManagementLinks() {\n        return ManagementLink.all();\n    }\n\n    /**\n     * Exposes the current user to <tt>/me</tt> URL.\n     */\n    public User getMe() {\n        User u = User.current();\n        if (u == null)\n            throw new AccessDeniedException(\"/me is not available when not logged in\");\n        return u;\n    }\n\n    /**\n     * Gets the {@link Widget}s registered on this object.\n     *\n     * <p>\n     * Plugins who wish to contribute boxes on the side panel can add widgets\n     * by {@code getWidgets().add(new MyWidget())} from {@link Plugin#start()}.\n     */\n    public List<Widget> getWidgets() {\n        return widgets;\n    }\n\n    public Object getTarget() {\n        try {\n            checkPermission(READ);\n        } catch (AccessDeniedException e) {\n            String rest = Stapler.getCurrentRequest().getRestOfPath();\n            if(rest.startsWith(\"/login\")\n            || rest.startsWith(\"/logout\")\n            || rest.startsWith(\"/accessDenied\")\n            || rest.startsWith(\"/adjuncts/\")\n            || rest.startsWith(\"/error\")\n            || rest.startsWith(\"/oops\")\n            || rest.startsWith(\"/signup\")\n            || rest.startsWith(\"/tcpSlaveAgentListener\")\n            // TODO SlaveComputer.doSlaveAgentJnlp; there should be an annotation to request unprotected access\n            || rest.matches(\"/computer/[^/]+/slave-agent[.]jnlp\") && \"true\".equals(Stapler.getCurrentRequest().getParameter(\"encrypt\"))\n            || rest.startsWith(\"/federatedLoginService/\")\n            || rest.startsWith(\"/securityRealm\"))\n                return this;    // URLs that are always visible without READ permission\n\n            for (String name : getUnprotectedRootActions()) {\n                if (rest.startsWith(\"/\" + name + \"/\") || rest.equals(\"/\" + name)) {\n                    return this;\n                }\n            }\n\n            throw e;\n        }\n        return this;\n    }\n\n    /**\n     * Gets a list of unprotected root actions.\n     * These URL prefixes should be exempted from access control checks by container-managed security.\n     * Ideally would be synchronized with {@link #getTarget}.\n     * @return a list of {@linkplain Action#getUrlName URL names}\n     * @since 1.495\n     */\n    public Collection<String> getUnprotectedRootActions() {\n        Set<String> names = new TreeSet<String>();\n        names.add(\"jnlpJars\"); // TODO cleaner to refactor doJnlpJars into a URA\n        // TODO consider caching (expiring cache when actions changes)\n        for (Action a : getActions()) {\n            if (a instanceof UnprotectedRootAction) {\n                names.add(a.getUrlName());\n            }\n        }\n        return names;\n    }\n\n    /**\n     * Fallback to the primary view.\n     */\n    public View getStaplerFallback() {\n        return getPrimaryView();\n    }\n\n    /**\n     * This method checks all existing jobs to see if displayName is\n     * unique. It does not check the displayName against the displayName of the\n     * job that the user is configuring though to prevent a validation warning\n     * if the user sets the displayName to what it currently is.\n     * @param displayName\n     * @param currentJobName\n     */\n    boolean isDisplayNameUnique(String displayName, String currentJobName) {\n        Collection<TopLevelItem> itemCollection = items.values();\n\n        // if there are a lot of projects, we'll have to store their\n        // display names in a HashSet or something for a quick check\n        for(TopLevelItem item : itemCollection) {\n            if(item.getName().equals(currentJobName)) {\n                // we won't compare the candidate displayName against the current\n                // item. This is to prevent an validation warning if the user\n                // sets the displayName to what the existing display name is\n                continue;\n            }\n            else if(displayName.equals(item.getDisplayName())) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * True if there is no item in Jenkins that has this name\n     * @param name The name to test\n     * @param currentJobName The name of the job that the user is configuring\n     */\n    boolean isNameUnique(String name, String currentJobName) {\n        Item item = getItem(name);\n\n        if(null==item) {\n            // the candidate name didn't return any items so the name is unique\n            return true;\n        }\n        else if(item.getName().equals(currentJobName)) {\n            // the candidate name returned an item, but the item is the item\n            // that the user is configuring so this is ok\n            return true;\n        }\n        else {\n            // the candidate name returned an item, so it is not unique\n            return false;\n        }\n    }\n\n    /**\n     * Checks to see if the candidate displayName collides with any\n     * existing display names or project names\n     * @param displayName The display name to test\n     * @param jobName The name of the job the user is configuring\n     */\n    public FormValidation doCheckDisplayName(@QueryParameter String displayName,\n            @QueryParameter String jobName) {\n        displayName = displayName.trim();\n\n        if(LOGGER.isLoggable(Level.FINE)) {\n            LOGGER.log(Level.FINE, \"Current job name is \" + jobName);\n        }\n\n        if(!isNameUnique(displayName, jobName)) {\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_NameNotUniqueWarning(displayName));\n        }\n        else if(!isDisplayNameUnique(displayName, jobName)){\n            return FormValidation.warning(Messages.Jenkins_CheckDisplayName_DisplayNameNotUniqueWarning(displayName));\n        }\n        else {\n            return FormValidation.ok();\n        }\n    }\n\n    public static class MasterComputer extends Computer {\n        protected MasterComputer() {\n            super(Jenkins.getInstance());\n        }\n\n        /**\n         * Returns \"\" to match with {@link Jenkins#getNodeName()}.\n         */\n        @Override\n        public String getName() {\n            return \"\";\n        }\n\n        @Override\n        public boolean isConnecting() {\n            return false;\n        }\n\n        @Override\n        public String getDisplayName() {\n            return Messages.Hudson_Computer_DisplayName();\n        }\n\n        @Override\n        public String getCaption() {\n            return Messages.Hudson_Computer_Caption();\n        }\n\n        @Override\n        public String getUrl() {\n            return \"computer/(master)/\";\n        }\n\n        public RetentionStrategy getRetentionStrategy() {\n            return RetentionStrategy.NOOP;\n        }\n\n        /**\n         * Will always keep this guy alive so that it can function as a fallback to\n         * execute {@link FlyweightTask}s. See JENKINS-7291.\n         */\n        @Override\n        protected boolean isAlive() {\n            return true;\n        }\n\n        @Override\n        public Boolean isUnix() {\n            return !Functions.isWindows();\n        }\n\n        /**\n         * Report an error.\n         */\n        @Override\n        public HttpResponse doDoDelete() throws IOException {\n            throw HttpResponses.status(SC_BAD_REQUEST);\n        }\n\n        @Override\n        public void doConfigSubmit(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException, FormException {\n            Jenkins.getInstance().doConfigExecutorsSubmit(req, rsp);\n        }\n\n        @WebMethod(name=\"config.xml\")\n        @Override\n        public void doConfigDotXml(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            throw HttpResponses.status(SC_BAD_REQUEST);\n        }\n\n        @Override\n        public boolean hasPermission(Permission permission) {\n            // no one should be allowed to delete the master.\n            // this hides the \"delete\" link from the /computer/(master) page.\n            if(permission==Computer.DELETE)\n                return false;\n            // Configuration of master node requires ADMINISTER permission\n            return super.hasPermission(permission==Computer.CONFIGURE ? Jenkins.ADMINISTER : permission);\n        }\n\n        @Override\n        public VirtualChannel getChannel() {\n            return FilePath.localChannel;\n        }\n\n        @Override\n        public Charset getDefaultCharset() {\n            return Charset.defaultCharset();\n        }\n\n        public List<LogRecord> getLogRecords() throws IOException, InterruptedException {\n            return logRecords;\n        }\n\n        @RequirePOST\n        public void doLaunchSlaveAgent(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n            // this computer never returns null from channel, so\n            // this method shall never be invoked.\n            rsp.sendError(SC_NOT_FOUND);\n        }\n\n        protected Future<?> _connect(boolean forceReconnect) {\n            return Futures.precomputed(null);\n        }\n\n        /**\n         * {@link LocalChannel} instance that can be used to execute programs locally.\n         *\n         * @deprecated as of 1.558\n         *      Use {@link FilePath#localChannel}\n         */\n        @Deprecated\n        public static final LocalChannel localChannel = FilePath.localChannel;\n    }\n\n    /**\n     * Shortcut for {@code Jenkins.getInstance().lookup.get(type)}\n     */\n    public static @CheckForNull <T> T lookup(Class<T> type) {\n        Jenkins j = Jenkins.getInstance();\n        return j != null ? j.lookup.get(type) : null;\n    }\n\n    /**\n     * Live view of recent {@link LogRecord}s produced by Jenkins.\n     */\n    public static List<LogRecord> logRecords = Collections.emptyList(); // initialized to dummy value to avoid NPE\n\n    /**\n     * Thread-safe reusable {@link XStream}.\n     */\n    public static final XStream XSTREAM;\n\n    /**\n     * Alias to {@link #XSTREAM} so that one can access additional methods on {@link XStream2} more easily.\n     */\n    public static final XStream2 XSTREAM2;\n\n    private static final int TWICE_CPU_NUM = Math.max(4, Runtime.getRuntime().availableProcessors() * 2);\n\n    /**\n     * Thread pool used to load configuration in parallel, to improve the start up time.\n     * <p>\n     * The idea here is to overlap the CPU and I/O, so we want more threads than CPU numbers.\n     */\n    /*package*/ transient final ExecutorService threadPoolForLoad = new ThreadPoolExecutor(\n        TWICE_CPU_NUM, TWICE_CPU_NUM,\n        5L, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>(), new NamingThreadFactory(new DaemonThreadFactory(), \"Jenkins load\"));\n\n\n    private static void computeVersion(ServletContext context) {\n        // set the version\n        Properties props = new Properties();\n        InputStream is = null;\n        try {\n            is = Jenkins.class.getResourceAsStream(\"jenkins-version.properties\");\n            if(is!=null)\n                props.load(is);\n        } catch (IOException e) {\n            e.printStackTrace(); // if the version properties is missing, that's OK.\n        } finally {\n            IOUtils.closeQuietly(is);\n        }\n        String ver = props.getProperty(\"version\");\n        if(ver==null)   ver=\"?\";\n        VERSION = ver;\n        context.setAttribute(\"version\",ver);\n\n        VERSION_HASH = Util.getDigestOf(ver).substring(0, 8);\n        SESSION_HASH = Util.getDigestOf(ver+System.currentTimeMillis()).substring(0, 8);\n\n        if(ver.equals(\"?\") || Boolean.getBoolean(\"hudson.script.noCache\"))\n            RESOURCE_PATH = \"\";\n        else\n            RESOURCE_PATH = \"/static/\"+SESSION_HASH;\n\n        VIEW_RESOURCE_PATH = \"/resources/\"+ SESSION_HASH;\n    }\n\n    /**\n     * Version number of this Jenkins.\n     */\n    public static String VERSION=\"?\";\n\n    /**\n     * Parses {@link #VERSION} into {@link VersionNumber}, or null if it's not parseable as a version number\n     * (such as when Jenkins is run with \"mvn hudson-dev:run\")\n     */\n    public static VersionNumber getVersion() {\n        try {\n            return new VersionNumber(VERSION);\n        } catch (NumberFormatException e) {\n            try {\n                // for non-released version of Jenkins, this looks like \"1.345 (private-foobar), so try to approximate.\n                int idx = VERSION.indexOf(' ');\n                if (idx>0)\n                    return new VersionNumber(VERSION.substring(0,idx));\n            } catch (NumberFormatException _) {\n                // fall through\n            }\n\n            // totally unparseable\n            return null;\n        } catch (IllegalArgumentException e) {\n            // totally unparseable\n            return null;\n        }\n    }\n\n    /**\n     * Hash of {@link #VERSION}.\n     */\n    public static String VERSION_HASH;\n\n    /**\n     * Unique random token that identifies the current session.\n     * Used to make {@link #RESOURCE_PATH} unique so that we can set long \"Expires\" header.\n     *\n     * We used to use {@link #VERSION_HASH}, but making this session local allows us to\n     * reuse the same {@link #RESOURCE_PATH} for static resources in plugins.\n     */\n    public static String SESSION_HASH;\n\n    /**\n     * Prefix to static resources like images and javascripts in the war file.\n     * Either \"\" or strings like \"/static/VERSION\", which avoids Jenkins to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String RESOURCE_PATH = \"\";\n\n    /**\n     * Prefix to resources alongside view scripts.\n     * Strings like \"/resources/VERSION\", which avoids Jenkins to pick up\n     * stale cache when the user upgrades to a different version.\n     * <p>\n     * Value computed in {@link WebAppMain}.\n     */\n    public static String VIEW_RESOURCE_PATH = \"/resources/TBD\";\n\n    public static boolean PARALLEL_LOAD = Configuration.getBooleanConfigParameter(\"parallelLoad\", true);\n    public static boolean KILL_AFTER_LOAD = Configuration.getBooleanConfigParameter(\"killAfterLoad\", false);\n    /**\n     * @deprecated No longer used.\n     */\n    @Deprecated\n    public static boolean FLYWEIGHT_SUPPORT = true;\n\n    /**\n     * Tentative switch to activate the concurrent build behavior.\n     * When we merge this back to the trunk, this allows us to keep\n     * this feature hidden for a while until we iron out the kinks.\n     * @see AbstractProject#isConcurrentBuild()\n     * @deprecated as of 1.464\n     *      This flag will have no effect.\n     */\n    @Restricted(NoExternalUse.class)\n    @Deprecated\n    public static boolean CONCURRENT_BUILD = true;\n\n    /**\n     * Switch to enable people to use a shorter workspace name.\n     */\n    private static final String WORKSPACE_DIRNAME = Configuration.getStringConfigParameter(\"workspaceDirName\", \"workspace\");\n\n    /**\n     * Automatically try to launch a slave when Jenkins is initialized or a new slave is created.\n     */\n    public static boolean AUTOMATIC_SLAVE_LAUNCH = true;\n\n    private static final Logger LOGGER = Logger.getLogger(Jenkins.class.getName());\n\n    public static final PermissionGroup PERMISSIONS = Permission.HUDSON_PERMISSIONS;\n    public static final Permission ADMINISTER = Permission.HUDSON_ADMINISTER;\n    public static final Permission READ = new Permission(PERMISSIONS,\"Read\",Messages._Hudson_ReadPermission_Description(),Permission.READ,PermissionScope.JENKINS);\n    public static final Permission RUN_SCRIPTS = new Permission(PERMISSIONS, \"RunScripts\", Messages._Hudson_RunScriptsPermission_Description(),ADMINISTER,PermissionScope.JENKINS);\n\n    /**\n     * {@link Authentication} object that represents the anonymous user.\n     * Because Acegi creates its own {@link AnonymousAuthenticationToken} instances, the code must not\n     * expect the singleton semantics. This is just a convenient instance.\n     *\n     * @since 1.343\n     */\n    public static final Authentication ANONYMOUS;\n\n    static {\n        try {\n            ANONYMOUS = new AnonymousAuthenticationToken(\n                    \"anonymous\", \"anonymous\", new GrantedAuthority[]{new GrantedAuthorityImpl(\"anonymous\")});\n            XSTREAM = XSTREAM2 = new XStream2();\n\n            XSTREAM.alias(\"jenkins\", Jenkins.class);\n            XSTREAM.alias(\"slave\", DumbSlave.class);\n            XSTREAM.alias(\"jdk\", JDK.class);\n            // for backward compatibility with <1.75, recognize the tag name \"view\" as well.\n            XSTREAM.alias(\"view\", ListView.class);\n            XSTREAM.alias(\"listView\", ListView.class);\n            XSTREAM2.addCriticalField(Jenkins.class, \"securityRealm\");\n            XSTREAM2.addCriticalField(Jenkins.class, \"authorizationStrategy\");\n            // this seems to be necessary to force registration of converter early enough\n            Mode.class.getEnumConstants();\n\n            // double check that initialization order didn't do any harm\n            assert PERMISSIONS != null;\n            assert ADMINISTER != null;\n        } catch (RuntimeException e) {\n            // when loaded on a slave and this fails, subsequent NoClassDefFoundError will fail to chain the cause.\n            // see http://bugs.java.com/bugdatabase/view_bug.do?bug_id=8051847\n            // As we don't know where the first exception will go, let's also send this to logging so that\n            // we have a known place to look at.\n            LOGGER.log(SEVERE, \"Failed to load Jenkins.class\", e);\n            throw e;\n        } catch (Error e) {\n            LOGGER.log(SEVERE, \"Failed to load Jenkins.class\", e);\n            throw e;\n        }\n    }\n\n}\n", "/*\n * The MIT License\n *\n * Copyright (c) 2004-2011, Yahoo!, Inc.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage jenkins.model;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.containsString;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.fail;\n\nimport com.gargoylesoftware.htmlunit.FailingHttpStatusCodeException;\nimport com.gargoylesoftware.htmlunit.HttpMethod;\nimport com.gargoylesoftware.htmlunit.Page;\nimport com.gargoylesoftware.htmlunit.WebRequest;\nimport com.gargoylesoftware.htmlunit.WebResponse;\nimport com.gargoylesoftware.htmlunit.html.HtmlForm;\nimport com.gargoylesoftware.htmlunit.html.HtmlPage;\n\nimport hudson.maven.MavenModuleSet;\nimport hudson.maven.MavenModuleSetBuild;\nimport hudson.model.Failure;\nimport hudson.model.RestartListener;\nimport hudson.model.RootAction;\nimport hudson.model.UnprotectedRootAction;\nimport hudson.model.User;\nimport hudson.security.FullControlOnceLoggedInAuthorizationStrategy;\nimport hudson.security.HudsonPrivateSecurityRealm;\nimport hudson.util.HttpResponses;\nimport hudson.model.FreeStyleProject;\nimport hudson.security.GlobalMatrixAuthorizationStrategy;\nimport hudson.security.LegacySecurityRealm;\nimport hudson.security.Permission;\nimport hudson.slaves.ComputerListener;\nimport hudson.slaves.DumbSlave;\nimport hudson.slaves.OfflineCause;\nimport hudson.util.FormValidation;\n\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.ExtractResourceSCM;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.JenkinsRule.WebClient;\nimport org.jvnet.hudson.test.TestExtension;\nimport org.kohsuke.stapler.HttpResponse;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Mockito;\n\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n/**\n * @author kingfai\n *\n */\npublic class JenkinsTest {\n\n    @Rule public JenkinsRule j = new JenkinsRule();\n\n    @Issue(\"SECURITY-406\")\n    @Test\n    public void testUserCreationFromUrlForAdmins() throws Exception {\n        WebClient wc = j.createWebClient();\n\n        assertNull(\"User not supposed to exist\", User.getById(\"nonexistent\", false));\n        wc.assertFails(\"user/nonexistent\", 404);\n        assertNull(\"User not supposed to exist\", User.getById(\"nonexistent\", false));\n\n        try {\n            User.ALLOW_USER_CREATION_VIA_URL = true;\n\n            // expected to work\n            wc.goTo(\"user/nonexistent2\");\n\n            assertNotNull(\"User supposed to exist\", User.getById(\"nonexistent2\", false));\n\n        } finally {\n            User.ALLOW_USER_CREATION_VIA_URL = false;\n        }\n    }\n\n    @Test\n    public void testIsDisplayNameUniqueTrue() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(\"displayName\");\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertTrue(jenkins.isDisplayNameUnique(\"displayName1\", curJobName));\n        assertTrue(jenkins.isDisplayNameUnique(jobName, curJobName));\n    }\n\n    @Test\n    public void testIsDisplayNameUniqueFalse() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        \n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertFalse(jenkins.isDisplayNameUnique(displayName, curJobName));\n    }\n    \n    @Test\n    public void testIsDisplayNameUniqueSameAsCurrentJob() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String displayName = \"currentProjectDisplayName\";\n        \n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        // should be true as we don't test against the current job\n        assertTrue(jenkins.isDisplayNameUnique(displayName, curJobName));\n    }\n    \n    @Test\n    public void testIsNameUniqueTrue() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertTrue(jenkins.isNameUnique(\"jobName1\", curJobName));\n    }\n\n    @Test\n    public void testIsNameUniqueFalse() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        assertFalse(jenkins.isNameUnique(jobName, curJobName));\n    }\n\n    @Test\n    public void testIsNameUniqueSameAsCurrentJob() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        j.createFreeStyleProject(curJobName);\n        j.createFreeStyleProject(jobName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        // true because we don't test against the current job\n        assertTrue(jenkins.isNameUnique(curJobName, curJobName));\n    }\n    \n    @Test\n    public void testDoCheckDisplayNameUnique() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(\"displayName\");\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(\"1displayName\", curJobName);\n        assertEquals(FormValidation.ok(), v);\n    }\n\n    @Test\n    public void testDoCheckDisplayNameSameAsDisplayName() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(displayName, curJobName);\n        assertEquals(FormValidation.Kind.WARNING, v.kind);\n    }\n\n    @Test\n    public void testDoCheckDisplayNameSameAsJobName() throws Exception {\n        final String curJobName = \"curJobName\";\n        final String jobName = \"jobName\";\n        final String displayName = \"displayName\";\n        FreeStyleProject curProject = j.createFreeStyleProject(curJobName);\n        curProject.setDisplayName(\"currentProjectDisplayName\");\n        \n        FreeStyleProject p = j.createFreeStyleProject(jobName);\n        p.setDisplayName(displayName);\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        FormValidation v = jenkins.doCheckDisplayName(jobName, curJobName);\n        assertEquals(FormValidation.Kind.WARNING, v.kind);\n    }\n\n    @Test\n    public void testDoCheckViewName_GoodName() throws Exception {\n        String[] viewNames = new String[] {\n            \"\", \"Jenkins\"    \n        };\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        for (String viewName : viewNames) {\n            FormValidation v = jenkins.doCheckViewName(viewName);\n            assertEquals(FormValidation.Kind.OK, v.kind);\n        }\n    }\n\n    @Test\n    public void testDoCheckViewName_NotGoodName() throws Exception {\n        String[] viewNames = new String[] {\n            \"Jenkins?\", \"Jenkins*\", \"Jenkin/s\", \"Jenkin\\\\s\", \"jenkins%\", \n            \"Jenkins!\", \"Jenkins[]\", \"Jenkin<>s\", \"^Jenkins\", \"..\"    \n        };\n        \n        Jenkins jenkins = Jenkins.getInstance();\n        \n        for (String viewName : viewNames) {\n            FormValidation v = jenkins.doCheckViewName(viewName);\n            assertEquals(FormValidation.Kind.ERROR, v.kind);\n        }\n    }\n    \n    @Test @Issue(\"JENKINS-12251\")\n    public void testItemFullNameExpansion() throws Exception {\n        HtmlForm f = j.createWebClient().goTo(\"configure\").getFormByName(\"config\");\n        f.getInputByName(\"_.rawBuildsDir\").setValueAttribute(\"${JENKINS_HOME}/test12251_builds/${ITEM_FULL_NAME}\");\n        f.getInputByName(\"_.rawWorkspaceDir\").setValueAttribute(\"${JENKINS_HOME}/test12251_ws/${ITEM_FULL_NAME}\");\n        j.submit(f);\n\n        // build a dummy project\n        MavenModuleSet m = j.createMavenProject();\n        m.setScm(new ExtractResourceSCM(getClass().getResource(\"/simple-projects.zip\")));\n        MavenModuleSetBuild b = m.scheduleBuild2(0).get();\n\n        // make sure these changes are effective\n        assertTrue(b.getWorkspace().getRemote().contains(\"test12251_ws\"));\n        assertTrue(b.getRootDir().toString().contains(\"test12251_builds\"));\n    }\n\n    /**\n     * Makes sure access to \"/foobar\" for UnprotectedRootAction gets through.\n     */\n    @Test @Issue(\"JENKINS-14113\")\n    public void testUnprotectedRootAction() throws Exception {\n        j.jenkins.setSecurityRealm(j.createDummySecurityRealm());\n        j.jenkins.setAuthorizationStrategy(new FullControlOnceLoggedInAuthorizationStrategy());\n        WebClient wc = j.createWebClient();\n        wc.goTo(\"foobar\");\n        wc.goTo(\"foobar/\");\n        wc.goTo(\"foobar/zot\");\n\n        // and make sure this fails\n        wc.assertFails(\"foobar-zot/\", HttpURLConnection.HTTP_INTERNAL_ERROR);\n\n        assertEquals(3,j.jenkins.getExtensionList(RootAction.class).get(RootActionImpl.class).count);\n    }\n\n    @Test\n    public void testDoScript() throws Exception {\n        j.jenkins.setSecurityRealm(new LegacySecurityRealm());\n        GlobalMatrixAuthorizationStrategy gmas = new GlobalMatrixAuthorizationStrategy() {\n            @Override public boolean hasPermission(String sid, Permission p) {\n                return p == Jenkins.RUN_SCRIPTS ? hasExplicitPermission(sid, p) : super.hasPermission(sid, p);\n            }\n        };\n        gmas.add(Jenkins.ADMINISTER, \"alice\");\n        gmas.add(Jenkins.RUN_SCRIPTS, \"alice\");\n        gmas.add(Jenkins.READ, \"bob\");\n        gmas.add(Jenkins.ADMINISTER, \"charlie\");\n        j.jenkins.setAuthorizationStrategy(gmas);\n        WebClient wc = j.createWebClient();\n        wc.login(\"alice\");\n        wc.goTo(\"script\");\n        wc.assertFails(\"script?script=System.setProperty('hack','me')\", HttpURLConnection.HTTP_BAD_METHOD);\n        assertNull(System.getProperty(\"hack\"));\n        WebRequest req = new WebRequest(new URL(wc.getContextPath() + \"script?script=System.setProperty('hack','me')\"), HttpMethod.POST);\n        wc.getPage(wc.addCrumb(req));\n        assertEquals(\"me\", System.getProperty(\"hack\"));\n        wc.assertFails(\"scriptText?script=System.setProperty('hack','me')\", HttpURLConnection.HTTP_BAD_METHOD);\n        req = new WebRequest(new URL(wc.getContextPath() + \"scriptText?script=System.setProperty('huck','you')\"), HttpMethod.POST);\n        wc.getPage(wc.addCrumb(req));\n        assertEquals(\"you\", System.getProperty(\"huck\"));\n        wc.login(\"bob\");\n        wc.assertFails(\"script\", HttpURLConnection.HTTP_FORBIDDEN);\n        wc.login(\"charlie\");\n        wc.assertFails(\"script\", HttpURLConnection.HTTP_FORBIDDEN);\n    }\n\n    @Test\n    public void testDoEval() throws Exception {\n        j.jenkins.setSecurityRealm(new LegacySecurityRealm());\n        GlobalMatrixAuthorizationStrategy gmas = new GlobalMatrixAuthorizationStrategy() {\n            @Override public boolean hasPermission(String sid, Permission p) {\n                return p == Jenkins.RUN_SCRIPTS ? hasExplicitPermission(sid, p) : super.hasPermission(sid, p);\n            }\n        };\n        gmas.add(Jenkins.ADMINISTER, \"alice\");\n        gmas.add(Jenkins.RUN_SCRIPTS, \"alice\");\n        gmas.add(Jenkins.READ, \"bob\");\n        gmas.add(Jenkins.ADMINISTER, \"charlie\");\n        j.jenkins.setAuthorizationStrategy(gmas);\n        WebClient wc = j.createWebClient();\n        wc.login(\"alice\");\n        wc.assertFails(\"eval\", HttpURLConnection.HTTP_BAD_METHOD);\n        assertEquals(\"3\", eval(wc));\n        wc.login(\"bob\");\n        try {\n            eval(wc);\n            fail(\"bob has only READ\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n        wc.login(\"charlie\");\n        try {\n            eval(wc);\n            fail(\"charlie has ADMINISTER but not RUN_SCRIPTS\");\n        } catch (FailingHttpStatusCodeException e) {\n            assertEquals(HttpURLConnection.HTTP_FORBIDDEN, e.getStatusCode());\n        }\n    }\n    private String eval(WebClient wc) throws Exception {\n        WebRequest req = new WebRequest(wc.createCrumbedUrl(\"eval\"), HttpMethod.POST);\n        req.setEncodingType(null);\n        req.setRequestBody(\"<j:jelly xmlns:j='jelly:core'>${1+2}</j:jelly>\");\n        return wc.getPage(req).getWebResponse().getContentAsString();\n    }\n\n    @TestExtension(\"testUnprotectedRootAction\")\n    public static class RootActionImpl implements UnprotectedRootAction {\n        private int count;\n\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"foobar\";\n        }\n\n        public HttpResponse doDynamic() {\n            assertTrue(Jenkins.getInstance().getAuthentication().getName().equals(\"anonymous\"));\n            count++;\n            return HttpResponses.html(\"OK\");\n        }\n    }\n\n    @TestExtension(\"testUnprotectedRootAction\")\n    public static class ProtectedRootActionImpl implements RootAction {\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"foobar-zot\";\n        }\n\n        public HttpResponse doDynamic() {\n            throw new AssertionError();\n        }\n    }\n\n    @Test @Issue(\"JENKINS-20866\")\n    public void testErrorPageShouldBeAnonymousAccessible() throws Exception {\n        HudsonPrivateSecurityRealm s = new HudsonPrivateSecurityRealm(false, false, null);\n        User alice = s.createAccount(\"alice\", \"alice\");\n        j.jenkins.setSecurityRealm(s);\n\n        GlobalMatrixAuthorizationStrategy auth = new GlobalMatrixAuthorizationStrategy();\n        j.jenkins.setAuthorizationStrategy(auth);\n\n        // no anonymous read access\n        assertTrue(!Jenkins.getInstance().getACL().hasPermission(Jenkins.ANONYMOUS,Jenkins.READ));\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n        HtmlPage p = wc.goTo(\"error/reportError\");\n\n        assertEquals(p.asText(), 400, p.getWebResponse().getStatusCode());  // not 403 forbidden\n        assertTrue(p.getWebResponse().getContentAsString().contains(\"My car is black\"));\n    }\n\n    @TestExtension(\"testErrorPageShouldBeAnonymousAccessible\")\n    public static class ReportError implements UnprotectedRootAction {\n\n        public String getIconFileName() {\n            return null;\n        }\n\n        public String getDisplayName() {\n            return null;\n        }\n\n        public String getUrlName() {\n            return \"error\";\n        }\n\n        public HttpResponse doReportError() {\n            return new Failure(\"My car is black\");\n        }\n    }\n\n    @Test @Issue(\"JENKINS-23551\")\n    public void testComputerListenerNotifiedOnRestart() {\n        // Simulate restart calling listeners\n        for (RestartListener listener : RestartListener.all())\n            listener.onRestart();\n\n        ArgumentCaptor<OfflineCause> captor = ArgumentCaptor.forClass(OfflineCause.class);\n        Mockito.verify(listenerMock).onOffline(Mockito.eq(j.jenkins.toComputer()), captor.capture());\n        assertTrue(captor.getValue().toString().contains(\"restart\"));\n    }\n\n    @TestExtension(value = \"testComputerListenerNotifiedOnRestart\")\n    public static final ComputerListener listenerMock = Mockito.mock(ComputerListener.class);\n\n    @Test\n    public void runScriptOnOfflineComputer() throws Exception {\n        DumbSlave slave = j.createSlave(true);\n        j.disconnectSlave(slave);\n\n        URL url = new URL(j.getURL(), \"computer/\" + slave.getNodeName() + \"/scriptText?script=println(42)\");\n\n        WebClient wc = j.createWebClient();\n        wc.getOptions().setThrowExceptionOnFailingStatusCode(false);\n\n        WebRequest req = new WebRequest(url, HttpMethod.POST);\n        Page page = wc.getPage(wc.addCrumb(req));\n        WebResponse rsp = page.getWebResponse();\n\n        assertThat(rsp.getContentAsString(), containsString(\"Node is offline\"));\n        assertThat(rsp.getStatusCode(), equalTo(404));\n    }\n}\n"], "filenames": ["core/src/main/java/hudson/model/User.java", "core/src/main/java/jenkins/model/Jenkins.java", "test/src/test/java/jenkins/model/JenkinsTest.java"], "buggy_code_start_loc": [1080, 2488, 28], "buggy_code_end_loc": [1080, 2493, 83], "fixing_code_start_loc": [1081, 2488, 29], "fixing_code_end_loc": [1098, 2493, 107], "type": "CWE-352", "message": "jenkins before versions 2.44, 2.32.2 is vulnerable to a user creation CSRF using GET by admins. While this user record was only retained until restart in most cases, administrators' web browsers could be manipulated to create a large number of user records (SECURITY-406).", "other": {"cve": {"id": "CVE-2017-2613", "sourceIdentifier": "secalert@redhat.com", "published": "2018-05-15T22:29:00.207", "lastModified": "2019-10-09T23:26:56.507", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "jenkins before versions 2.44, 2.32.2 is vulnerable to a user creation CSRF using GET by admins. While this user record was only retained until restart in most cases, administrators' web browsers could be manipulated to create a large number of user records (SECURITY-406)."}, {"lang": "es", "value": "Jenkins en versiones anteriores a la 2.44 y 2.32.2 es vulnerable a Cross-Site Request Forgery (CSRF) de creaci\u00f3n de usuarios mediante el uso de GET por parte de los administradores. Aunque este registro de usuarios solo se retiene hasta el reinicio en la mayor\u00eda de casos, los navegadores web de los administradores se podr\u00edan manipular para crear un gran n\u00famero de registros de usuario (SECURITY-406)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:lts:*:*:*", "versionEndExcluding": "2.32.2", "matchCriteriaId": "F1F48E96-6C2B-4773-98A4-BFF626A0811F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:jenkins:jenkins:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.44", "matchCriteriaId": "D4595374-F7F2-43D5-BB78-37E8377B1E45"}]}]}], "references": [{"url": "http://www.securityfocus.com/bid/95967", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=CVE-2017-2613", "source": "secalert@redhat.com", "tags": ["Issue Tracking"]}, {"url": "https://github.com/jenkinsci/jenkins/commit/b88b20ec473200db35d0a0d29dcf192069106601", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://jenkins.io/security/advisory/2017-02-01/", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/jenkinsci/jenkins/commit/b88b20ec473200db35d0a0d29dcf192069106601"}}