{"buggy_code": ["package cosy\n\nimport (\n\t\"fmt\"\n\t\"github.com/gin-gonic/gin\"\n\t\"gorm.io/gorm\"\n)\n\nfunc (c *Ctx[T]) SortOrder() func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tsort := c.ctx.DefaultQuery(\"order\", \"desc\")\n\t\torder := fmt.Sprintf(\"%s %s\", DefaultQuery(c.ctx, \"sort_by\", c.itemKey), sort)\n\t\treturn db.Order(order)\n\t}\n}\n\nfunc (c *Ctx[T]) OrderAndPaginate() func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tsort := c.ctx.DefaultQuery(\"order\", \"desc\")\n\n\t\torder := fmt.Sprintf(\"%s %s\", DefaultQuery(c.ctx, \"sort_by\", c.itemKey), sort)\n\t\tdb = db.Order(order)\n\n\t\t_, offset, pageSize := GetPagingParams(c.ctx)\n\n\t\treturn db.Offset(offset).Limit(pageSize)\n\t}\n}\n\nfunc DefaultValue(c *gin.Context, key string, defaultValue any) any {\n\tif value, ok := c.Get(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\nfunc DefaultQuery(c *gin.Context, key string, defaultValue any) string {\n\treturn c.DefaultQuery(key, DefaultValue(c, key, defaultValue).(string))\n}\n", "package model\n\nimport (\n\t\"fmt\"\n\t\"github.com/0xJacky/Nginx-UI/internal/logger\"\n\t\"github.com/0xJacky/Nginx-UI/settings\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/cast\"\n\t\"gorm.io/driver/sqlite\"\n\t\"gorm.io/gen\"\n\t\"gorm.io/gorm\"\n\tgormlogger \"gorm.io/gorm/logger\"\n\t\"path\"\n\t\"strings\"\n\t\"time\"\n)\n\nvar db *gorm.DB\n\ntype Model struct {\n\tID        int             `gorm:\"primary_key\" json:\"id\"`\n\tCreatedAt time.Time       `json:\"created_at\"`\n\tUpdatedAt time.Time       `json:\"updated_at\"`\n\tDeletedAt *gorm.DeletedAt `gorm:\"index\" json:\"deleted_at\"`\n}\n\nfunc GenerateAllModel() []any {\n\treturn []any{\n\t\tConfigBackup{},\n\t\tAuth{},\n\t\tAuthToken{},\n\t\tCert{},\n\t\tChatGPTLog{},\n\t\tSite{},\n\t\tStream{},\n\t\tDnsCredential{},\n\t\tEnvironment{},\n\t\tNotification{},\n\t}\n}\n\nfunc logMode() gormlogger.Interface {\n\tswitch settings.ServerSettings.RunMode {\n\tcase gin.ReleaseMode:\n\t\treturn gormlogger.Default.LogMode(gormlogger.Warn)\n\tdefault:\n\t\tfallthrough\n\tcase gin.DebugMode:\n\t\treturn gormlogger.Default.LogMode(gormlogger.Info)\n\t}\n}\n\nfunc UseDB() *gorm.DB {\n\treturn db\n}\n\nfunc Init() *gorm.DB {\n\tdbPath := path.Join(path.Dir(settings.ConfPath), fmt.Sprintf(\"%s.db\", settings.ServerSettings.Database))\n\n\tvar err error\n\tdb, err = gorm.Open(sqlite.Open(dbPath), &gorm.Config{\n\t\tLogger:                                   logMode(),\n\t\tPrepareStmt:                              true,\n\t\tDisableForeignKeyConstraintWhenMigrating: true,\n\t})\n\n\tif err != nil {\n\t\tlogger.Fatal(err.Error())\n\t}\n\n\t// Migrate the schema\n\terr = db.AutoMigrate(GenerateAllModel()...)\n\tif err != nil {\n\t\tlogger.Fatal(err.Error())\n\t}\n\n\treturn db\n}\n\ntype Pagination struct {\n\tTotal       int64 `json:\"total\"`\n\tPerPage     int   `json:\"per_page\"`\n\tCurrentPage int   `json:\"current_page\"`\n\tTotalPages  int64 `json:\"total_pages\"`\n}\n\ntype DataList struct {\n\tData       interface{} `json:\"data\"`\n\tPagination Pagination  `json:\"pagination,omitempty\"`\n}\n\nfunc SortOrder(c *gin.Context) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tsort := c.DefaultQuery(\"order\", \"desc\")\n\t\torder := fmt.Sprintf(\"`%s` %s\", DefaultQuery(c, \"sort_by\", \"id\"), sort)\n\t\treturn db.Order(order)\n\t}\n}\n\nfunc OrderAndPaginate(c *gin.Context) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tsort := c.DefaultQuery(\"order\", \"desc\")\n\n\t\torder := fmt.Sprintf(\"`%s` %s\", DefaultQuery(c, \"sort_by\", \"id\"), sort)\n\t\tdb = db.Order(order)\n\n\t\tpage := cast.ToInt(c.Query(\"page\"))\n\t\tif page == 0 {\n\t\t\tpage = 1\n\t\t}\n\t\tpageSize := settings.ServerSettings.PageSize\n\t\treqPageSize := c.Query(\"page_size\")\n\t\tif reqPageSize != \"\" {\n\t\t\tpageSize = cast.ToInt(reqPageSize)\n\t\t}\n\t\toffset := (page - 1) * pageSize\n\n\t\treturn db.Offset(offset).Limit(pageSize)\n\t}\n}\n\nfunc QueryToInSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tqueryArray := c.QueryArray(v + \"[]\")\n\t\tif len(queryArray) == 0 {\n\t\t\tqueryArray = c.QueryArray(v)\n\t\t}\n\t\tif len(queryArray) > 0 {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` IN ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Where(sb.String(), queryArray)\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToEqualSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` = ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Where(sb.String(), c.Query(v))\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToFussySearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` LIKE ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar sbValue strings.Builder\n\n\t\t\t_, err = fmt.Fprintf(&sbValue, \"%%%s%%\", c.Query(v))\n\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Where(sb.String(), sbValue.String())\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToFussyKeysSearch(c *gin.Context, db *gorm.DB, value string, keys ...string) *gorm.DB {\n\tif c.Query(value) == \"\" {\n\t\treturn db\n\t}\n\n\tvar condition *gorm.DB\n\tfor i, v := range keys {\n\t\tsb := v + \" LIKE ?\"\n\t\tsv := \"%\" + c.Query(value) + \"%\"\n\n\t\tswitch i {\n\t\tcase 0:\n\t\t\tcondition = db.Where(db.Where(sb, sv))\n\t\tdefault:\n\t\t\tcondition = condition.Or(sb, sv)\n\t\t}\n\t}\n\n\treturn db.Where(condition)\n}\n\nfunc QueryToOrInSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tqueryArray := c.QueryArray(v + \"[]\")\n\t\tif len(queryArray) == 0 {\n\t\t\tqueryArray = c.QueryArray(v)\n\t\t}\n\t\tif len(queryArray) > 0 {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` IN ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Or(sb.String(), queryArray)\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToOrEqualSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` = ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Or(sb.String(), c.Query(v))\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToOrFussySearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` LIKE ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar sbValue strings.Builder\n\n\t\t\t_, err = fmt.Fprintf(&sbValue, \"%%%s%%\", c.Query(v))\n\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Or(sb.String(), sbValue.String())\n\t\t}\n\t}\n\treturn db\n}\n\nfunc TotalPage(total int64, pageSize int) int64 {\n\tn := total / int64(pageSize)\n\tif total%int64(pageSize) > 0 {\n\t\tn++\n\t}\n\treturn n\n}\n\nfunc DefaultValue(c *gin.Context, key string, defaultValue any) any {\n\tif value, ok := c.Get(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\nfunc DefaultQuery(c *gin.Context, key string, defaultValue any) string {\n\treturn c.DefaultQuery(key, DefaultValue(c, key, defaultValue).(string))\n}\n\ntype Method interface {\n\t// FirstByID Where(\"id=@id\")\n\tFirstByID(id int) (*gen.T, error)\n\t// DeleteByID update @@table set deleted_at=strftime('%Y-%m-%d %H:%M:%S','now') where id=@id\n\tDeleteByID(id int) error\n}\n"], "fixing_code": ["package cosy\n\nimport (\n\t\"fmt\"\n\t\"github.com/0xJacky/Nginx-UI/internal/logger\"\n\t\"github.com/gin-gonic/gin\"\n\t\"gorm.io/gorm\"\n\t\"gorm.io/gorm/schema\"\n\t\"sync\"\n)\n\nfunc (c *Ctx[T]) SortOrder() func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tsort := c.ctx.DefaultQuery(\"order\", \"desc\")\n\t\tif sort != \"desc\" && sort != \"asc\" {\n\t\t\tsort = \"desc\"\n\t\t}\n\n\t\t// check if the order field is valid\n\t\t// todo: maybe we can use more generic way to check if the sort_by is valid\n\t\torder := DefaultQuery(c.ctx, \"sort_by\", c.itemKey)\n\t\ts, _ := schema.Parse(c.Model, &sync.Map{}, schema.NamingStrategy{})\n\t\tif _, ok := s.FieldsByDBName[order]; ok {\n\t\t\torder = fmt.Sprintf(\"%s %s\", order, sort)\n\t\t\treturn db.Order(order)\n\t\t} else {\n\t\t\tlogger.Error(\"invalid order field:\", order)\n\t\t}\n\n\t\treturn db\n\t}\n}\n\nfunc (c *Ctx[T]) OrderAndPaginate() func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tdb = c.SortOrder()(db)\n\t\t_, offset, pageSize := GetPagingParams(c.ctx)\n\t\treturn db.Offset(offset).Limit(pageSize)\n\t}\n}\n\nfunc DefaultValue(c *gin.Context, key string, defaultValue any) any {\n\tif value, ok := c.Get(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\nfunc DefaultQuery(c *gin.Context, key string, defaultValue any) string {\n\treturn c.DefaultQuery(key, DefaultValue(c, key, defaultValue).(string))\n}\n", "package model\n\nimport (\n\t\"fmt\"\n\t\"github.com/0xJacky/Nginx-UI/internal/logger\"\n\t\"github.com/0xJacky/Nginx-UI/settings\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/spf13/cast\"\n\t\"gorm.io/driver/sqlite\"\n\t\"gorm.io/gen\"\n\t\"gorm.io/gorm\"\n\tgormlogger \"gorm.io/gorm/logger\"\n\t\"gorm.io/gorm/schema\"\n\t\"path\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n)\n\nvar db *gorm.DB\n\ntype Model struct {\n\tID        int             `gorm:\"primary_key\" json:\"id\"`\n\tCreatedAt time.Time       `json:\"created_at\"`\n\tUpdatedAt time.Time       `json:\"updated_at\"`\n\tDeletedAt *gorm.DeletedAt `gorm:\"index\" json:\"deleted_at\"`\n}\n\nfunc GenerateAllModel() []any {\n\treturn []any{\n\t\tConfigBackup{},\n\t\tAuth{},\n\t\tAuthToken{},\n\t\tCert{},\n\t\tChatGPTLog{},\n\t\tSite{},\n\t\tStream{},\n\t\tDnsCredential{},\n\t\tEnvironment{},\n\t\tNotification{},\n\t}\n}\n\nfunc logMode() gormlogger.Interface {\n\tswitch settings.ServerSettings.RunMode {\n\tcase gin.ReleaseMode:\n\t\treturn gormlogger.Default.LogMode(gormlogger.Warn)\n\tdefault:\n\t\tfallthrough\n\tcase gin.DebugMode:\n\t\treturn gormlogger.Default.LogMode(gormlogger.Info)\n\t}\n}\n\nfunc UseDB() *gorm.DB {\n\treturn db\n}\n\nfunc Init() *gorm.DB {\n\tdbPath := path.Join(path.Dir(settings.ConfPath), fmt.Sprintf(\"%s.db\", settings.ServerSettings.Database))\n\n\tvar err error\n\tdb, err = gorm.Open(sqlite.Open(dbPath), &gorm.Config{\n\t\tLogger:                                   logMode(),\n\t\tPrepareStmt:                              true,\n\t\tDisableForeignKeyConstraintWhenMigrating: true,\n\t})\n\n\tif err != nil {\n\t\tlogger.Fatal(err.Error())\n\t}\n\n\t// Migrate the schema\n\terr = db.AutoMigrate(GenerateAllModel()...)\n\tif err != nil {\n\t\tlogger.Fatal(err.Error())\n\t}\n\n\treturn db\n}\n\ntype Pagination struct {\n\tTotal       int64 `json:\"total\"`\n\tPerPage     int   `json:\"per_page\"`\n\tCurrentPage int   `json:\"current_page\"`\n\tTotalPages  int64 `json:\"total_pages\"`\n}\n\ntype DataList struct {\n\tData       interface{} `json:\"data\"`\n\tPagination Pagination  `json:\"pagination,omitempty\"`\n}\n\nfunc SortOrder(c *gin.Context) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tsort := c.DefaultQuery(\"order\", \"desc\")\n\t\torder := fmt.Sprintf(\"`%s` %s\", DefaultQuery(c, \"sort_by\", \"id\"), sort)\n\t\treturn db.Order(order)\n\t}\n}\n\nfunc OrderAndPaginate(c *gin.Context) func(db *gorm.DB) *gorm.DB {\n\treturn func(db *gorm.DB) *gorm.DB {\n\t\tsort := c.DefaultQuery(\"order\", \"desc\")\n\t\tif sort != \"desc\" && sort != \"asc\" {\n\t\t\tsort = \"desc\"\n\t\t}\n\n\t\t// check if the order field is valid\n\t\torder := c.DefaultQuery(\"sort_by\", \"id\")\n\t\ts, _ := schema.Parse(db.Model, &sync.Map{}, schema.NamingStrategy{})\n\t\tif _, ok := s.FieldsByName[order]; ok {\n\t\t\torder = fmt.Sprintf(\"%s %s\", order, sort)\n\t\t\tdb = db.Order(order)\n\t\t} else {\n\t\t\tlogger.Error(\"invalid order field: \", order)\n\t\t}\n\n\t\tpage := cast.ToInt(c.Query(\"page\"))\n\t\tif page == 0 {\n\t\t\tpage = 1\n\t\t}\n\t\tpageSize := settings.ServerSettings.PageSize\n\t\treqPageSize := c.Query(\"page_size\")\n\t\tif reqPageSize != \"\" {\n\t\t\tpageSize = cast.ToInt(reqPageSize)\n\t\t}\n\t\toffset := (page - 1) * pageSize\n\n\t\treturn db.Offset(offset).Limit(pageSize)\n\t}\n}\n\nfunc QueryToInSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tqueryArray := c.QueryArray(v + \"[]\")\n\t\tif len(queryArray) == 0 {\n\t\t\tqueryArray = c.QueryArray(v)\n\t\t}\n\t\tif len(queryArray) > 0 {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` IN ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Where(sb.String(), queryArray)\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToEqualSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` = ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Where(sb.String(), c.Query(v))\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToFussySearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` LIKE ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar sbValue strings.Builder\n\n\t\t\t_, err = fmt.Fprintf(&sbValue, \"%%%s%%\", c.Query(v))\n\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Where(sb.String(), sbValue.String())\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToFussyKeysSearch(c *gin.Context, db *gorm.DB, value string, keys ...string) *gorm.DB {\n\tif c.Query(value) == \"\" {\n\t\treturn db\n\t}\n\n\tvar condition *gorm.DB\n\tfor i, v := range keys {\n\t\tsb := v + \" LIKE ?\"\n\t\tsv := \"%\" + c.Query(value) + \"%\"\n\n\t\tswitch i {\n\t\tcase 0:\n\t\t\tcondition = db.Where(db.Where(sb, sv))\n\t\tdefault:\n\t\t\tcondition = condition.Or(sb, sv)\n\t\t}\n\t}\n\n\treturn db.Where(condition)\n}\n\nfunc QueryToOrInSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tqueryArray := c.QueryArray(v + \"[]\")\n\t\tif len(queryArray) == 0 {\n\t\t\tqueryArray = c.QueryArray(v)\n\t\t}\n\t\tif len(queryArray) > 0 {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` IN ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Or(sb.String(), queryArray)\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToOrEqualSearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` = ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Or(sb.String(), c.Query(v))\n\t\t}\n\t}\n\treturn db\n}\n\nfunc QueryToOrFussySearch(c *gin.Context, db *gorm.DB, keys ...string) *gorm.DB {\n\tfor _, v := range keys {\n\t\tif c.Query(v) != \"\" {\n\t\t\tvar sb strings.Builder\n\n\t\t\t_, err := fmt.Fprintf(&sb, \"`%s` LIKE ?\", v)\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tvar sbValue strings.Builder\n\n\t\t\t_, err = fmt.Fprintf(&sbValue, \"%%%s%%\", c.Query(v))\n\n\t\t\tif err != nil {\n\t\t\t\tlogger.Error(err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tdb = db.Or(sb.String(), sbValue.String())\n\t\t}\n\t}\n\treturn db\n}\n\nfunc TotalPage(total int64, pageSize int) int64 {\n\tn := total / int64(pageSize)\n\tif total%int64(pageSize) > 0 {\n\t\tn++\n\t}\n\treturn n\n}\n\nfunc DefaultValue(c *gin.Context, key string, defaultValue any) any {\n\tif value, ok := c.Get(key); ok {\n\t\treturn value\n\t}\n\treturn defaultValue\n}\n\nfunc DefaultQuery(c *gin.Context, key string, defaultValue any) string {\n\treturn c.DefaultQuery(key, DefaultValue(c, key, defaultValue).(string))\n}\n\ntype Method interface {\n\t// FirstByID Where(\"id=@id\")\n\tFirstByID(id int) (*gen.T, error)\n\t// DeleteByID update @@table set deleted_at=strftime('%Y-%m-%d %H:%M:%S','now') where id=@id\n\tDeleteByID(id int) error\n}\n"], "filenames": ["api/cosy/sort.go", "model/model.go"], "buggy_code_start_loc": [4, 12], "buggy_code_end_loc": [26, 106], "fixing_code_start_loc": [5, 13], "fixing_code_end_loc": [37, 118], "type": "CWE-89", "message": "Nginx-UI is an online statistics for Server Indicators\u200b\u200b Monitor CPU usage, memory usage, load average, and disk usage in real-time. This issue may lead to information disclosure. By using `DefaultQuery`, the `\"desc\"` and `\"id\"` values are used as default values if the query parameters are not set. Thus, the `order` and `sort_by` query parameter are user-controlled and are being appended to the `order` variable without any sanitization. This issue has been patched in version 2.0.0.beta.9.\n\n", "other": {"cve": {"id": "CVE-2024-22196", "sourceIdentifier": "security-advisories@github.com", "published": "2024-01-11T20:15:44.923", "lastModified": "2024-02-29T01:44:05.347", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Nginx-UI is an online statistics for Server Indicators\u200b\u200b Monitor CPU usage, memory usage, load average, and disk usage in real-time. This issue may lead to information disclosure. By using `DefaultQuery`, the `\"desc\"` and `\"id\"` values are used as default values if the query parameters are not set. Thus, the `order` and `sort_by` query parameter are user-controlled and are being appended to the `order` variable without any sanitization. This issue has been patched in version 2.0.0.beta.9.\n\n"}, {"lang": "es", "value": "Nginx-UI es una estad\u00edstica en l\u00ednea para indicadores del servidor que monitorea el uso de la CPU, el uso de la memoria, el promedio de carga y el uso del disco en tiempo real. Este problema puede dar lugar a la divulgaci\u00f3n de informaci\u00f3n. Al utilizar `DefaultQuery`, los valores `\"desc\"` e `\"id\"` se utilizan como valores predeterminados si los par\u00e1metros de consulta no est\u00e1n configurados. Por lo tanto, los par\u00e1metros de consulta `order` y `sort_by` est\u00e1n controlados por el usuario y se agregan a la variable `order` sin ning\u00fan tipo de sanitizaci\u00f3n. Este problema se solucion\u00f3 en la versi\u00f3n 2.0.0.beta.9."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 4.7}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.0.0", "matchCriteriaId": "B4426F94-540E-497C-AE75-04126AF12112"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "3C287A7F-66B4-406A-B87B-B954A1CA6D44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "25DD91AC-465B-4A43-A79F-4DE47243741C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "115588C7-D947-4576-9E6C-B5AF1FCE9A29"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "BBB20EA3-F3CF-42AF-A217-D5DF7A7ADD70"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta4_patch:*:*:*:*:*:*", "matchCriteriaId": "81A6C732-FBF2-44A8-B810-456E54B59A09"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "8C5664E5-150E-4B4B-BA0C-420738820FF1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta5_patch:*:*:*:*:*:*", "matchCriteriaId": "7E764AA1-3060-441F-8F14-ADD165316741"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "04A3E84F-91AA-420A-B908-3393E037AC44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta6_patch:*:*:*:*:*:*", "matchCriteriaId": "828EAE87-24E5-4F31-B301-BA2F96BDEA42"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta6_patch2:*:*:*:*:*:*", "matchCriteriaId": "45710D36-954A-4450-B622-CB0F368DF544"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "2B57EEFB-5518-4BD5-998A-34B6690A6F4C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "8EDF4CEE-F24D-441B-92A8-7F5A2B41487E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:nginxui:nginx_ui:2.0.0:beta8_patch:*:*:*:*:*:*", "matchCriteriaId": "F0275FDF-BAE8-4909-8991-6FCE34B8905E"}]}]}], "references": [{"url": "https://github.com/0xJacky/nginx-ui/commit/ec93ab05a3ecbb6bcf464d9dca48d74452df8a5b", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/0xJacky/nginx-ui/security/advisories/GHSA-h374-mm57-879c", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/0xJacky/nginx-ui/commit/ec93ab05a3ecbb6bcf464d9dca48d74452df8a5b"}}