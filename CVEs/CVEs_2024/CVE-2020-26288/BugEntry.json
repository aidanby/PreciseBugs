{"buggy_code": ["const ldap = require('../lib/Adapters/Auth/ldap');\nconst mockLdapServer = require('./MockLdapServer');\nconst fs = require('fs');\nconst port = 12345;\nconst sslport = 12346;\n\nit('Should fail with missing options', done => {\n  ldap\n    .validateAuthData({ id: 'testuser', password: 'testpw' })\n    .then(done.fail)\n    .catch(err => {\n      jequal(err.message, 'LDAP auth configuration missing');\n      done();\n    });\n});\n\nit('Should return a resolved promise when validating the app id', done => {\n  ldap.validateAppId().then(done).catch(done.fail);\n});\n\nit('Should succeed with right credentials', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should succeed with right credentials when LDAPS is used and certifcate is not checked', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: { rejectUnauthorized: false }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should succeed when LDAPS is used and the presented certificate is the expected certificate', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/cert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail when LDAPS is used and the presented certificate is not the expected certificate', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/anothercert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAPS: Certificate mismatch');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail when LDAPS is used certifcate matches but credentials are wrong', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/cert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'wrong!' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP: Wrong username or password');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\n\nit('Should fail with wrong credentials', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'wrong!' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP: Wrong username or password');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should succeed if user is in given group', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail if user is not in given group', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'groupTheUserIsNotIn',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP: User not in group');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail if the LDAP server does not allow searching inside the provided suffix', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=invalid',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP group search failed');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail if the LDAP server encounters an error while searching', done => {\n  mockLdapServer(port, 'uid=testuser, o=example', true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP group search failed');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n", "const ldapjs = require('ldapjs');\nconst Parse = require('parse/node').Parse;\n\nfunction validateAuthData(authData, options) {\n  if (!optionsAreValid(options)) {\n    return new Promise((_, reject) => {\n      reject(\n        new Parse.Error(\n          Parse.Error.INTERNAL_SERVER_ERROR,\n          'LDAP auth configuration missing'\n        )\n      );\n    });\n  }\n  const clientOptions = (options.url.startsWith(\"ldaps://\")) ?\n    { url: options.url, tlsOptions: options.tlsOptions } : { url: options.url };\n\n  const client = ldapjs.createClient(clientOptions);\n  const userCn =\n    typeof options.dn === 'string'\n      ? options.dn.replace('{{id}}', authData.id)\n      : `uid=${authData.id},${options.suffix}`;\n\n  return new Promise((resolve, reject) => {\n    client.bind(userCn, authData.password, ldapError => {\n      if (ldapError) {\n        let error;\n        switch (ldapError.code) {\n          case 49:\n            error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'LDAP: Wrong username or password');\n            break;\n          case \"DEPTH_ZERO_SELF_SIGNED_CERT\":\n            error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'LDAPS: Certificate mismatch');\n            break;\n          default:\n            error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'LDAP: Somthing went wrong (' + ldapError.code + ')');\n        }\n        reject(error);\n        client.destroy(ldapError);\n        return;\n      }\n\n      if (\n        typeof options.groupCn === 'string' &&\n        typeof options.groupFilter === 'string'\n      ) {\n        searchForGroup(client, options, authData.id, resolve, reject);\n      } else {\n        client.unbind();\n        client.destroy();\n        resolve();\n      }\n    });\n  });\n}\n\nfunction optionsAreValid(options) {\n  return (\n    typeof options === 'object' &&\n    typeof options.suffix === 'string' &&\n    typeof options.url === 'string' &&\n    (options.url.startsWith('ldap://') ||\n     options.url.startsWith('ldaps://') && typeof options.tlsOptions === 'object')\n  );\n}\n\nfunction searchForGroup(client, options, id, resolve, reject) {\n  const filter = options.groupFilter.replace(/{{id}}/gi, id);\n  const opts = {\n    scope: 'sub',\n    filter: filter,\n  };\n  let found = false;\n  client.search(options.suffix, opts, (searchError, res) => {\n    if (searchError) {\n      client.unbind();\n      client.destroy();\n      return reject(\n        new Parse.Error(\n          Parse.Error.INTERNAL_SERVER_ERROR,\n          'LDAP group search failed'\n        )\n      );\n    }\n    res.on('searchEntry', entry => {\n      if (entry.object.cn === options.groupCn) {\n        found = true;\n        client.unbind();\n        client.destroy();\n        return resolve();\n      }\n    });\n    res.on('end', () => {\n      if (!found) {\n        client.unbind();\n        client.destroy();\n        return reject(\n          new Parse.Error(\n            Parse.Error.INTERNAL_SERVER_ERROR,\n            'LDAP: User not in group'\n          )\n        );\n      }\n    });\n    res.on('error', () => {\n      return reject(\n        new Parse.Error(\n          Parse.Error.INTERNAL_SERVER_ERROR,\n          'LDAP group search failed'\n        )\n      );\n    });\n  });\n}\n\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\nmodule.exports = {\n  validateAppId,\n  validateAuthData,\n};\n"], "fixing_code": ["const ldap = require('../lib/Adapters/Auth/ldap');\nconst mockLdapServer = require('./MockLdapServer');\nconst fs = require('fs');\nconst port = 12345;\nconst sslport = 12346;\n\nit('Should fail with missing options', done => {\n  ldap\n    .validateAuthData({ id: 'testuser', password: 'testpw' })\n    .then(done.fail)\n    .catch(err => {\n      jequal(err.message, 'LDAP auth configuration missing');\n      done();\n    });\n});\n\nit('Should return a resolved promise when validating the app id', done => {\n  ldap.validateAppId().then(done).catch(done.fail);\n});\n\nit('Should succeed with right credentials', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should succeed with right credentials when LDAPS is used and certifcate is not checked', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: { rejectUnauthorized: false }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should succeed when LDAPS is used and the presented certificate is the expected certificate', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/cert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail when LDAPS is used and the presented certificate is not the expected certificate', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/anothercert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAPS: Certificate mismatch');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail when LDAPS is used certifcate matches but credentials are wrong', done => {\n  mockLdapServer(sslport, 'uid=testuser, o=example', false, true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldaps://localhost:${sslport}`,\n      dn: 'uid={{id}}, o=example',\n      tlsOptions: {\n        ca: fs.readFileSync(__dirname + '/support/cert/cert.pem'),\n        rejectUnauthorized: true\n      }\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'wrong!' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP: Wrong username or password');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\n\nit('Should fail with wrong credentials', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n    };\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'wrong!' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP: Wrong username or password');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should succeed if user is in given group', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done)\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail if user is not in given group', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'groupTheUserIsNotIn',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP: User not in group');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail if the LDAP server does not allow searching inside the provided suffix', done => {\n  mockLdapServer(port, 'uid=testuser, o=example').then(server => {\n    const options = {\n      suffix: 'o=invalid',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP group search failed');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should fail if the LDAP server encounters an error while searching', done => {\n  mockLdapServer(port, 'uid=testuser, o=example', true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example',\n      groupCn: 'powerusers',\n      groupFilter: '(&(uniqueMember=uid={{id}}, o=example)(objectClass=groupOfUniqueNames))',\n    };\n\n    ldap\n      .validateAuthData({ id: 'testuser', password: 'secret' }, options)\n      .then(done.fail)\n      .catch(err => {\n        jequal(err.message, 'LDAP group search failed');\n        done();\n      })\n      .finally(() => server.close());\n  });\n});\n\nit('Should delete the password from authData after validation', done => {\n  mockLdapServer(port, 'uid=testuser, o=example', true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example'\n    };\n\n    const authData = { id: 'testuser', password: 'secret' };\n\n    ldap\n      .validateAuthData(authData, options)\n      .then(() => {\n        expect(authData).toEqual({ id: 'testuser' });\n        done();\n      })\n      .catch(done.fail)\n      .finally(() => server.close());\n  });\n});\n\nit('Should not save the password in the user record after authentication', done => {\n  mockLdapServer(port, 'uid=testuser, o=example', true).then(server => {\n    const options = {\n      suffix: 'o=example',\n      url: `ldap://localhost:${port}`,\n      dn: 'uid={{id}}, o=example'\n    };\n    reconfigureServer({ auth: { ldap: options } }).then(() => {\n      const authData = { authData: { id: 'testuser', password: 'secret' } };\n      Parse.User.logInWith('ldap', authData).then((returnedUser) => {\n        const query = new Parse.Query(\"User\");\n        query\n          .equalTo('objectId', returnedUser.id).first({ useMasterKey: true })\n          .then((user) => {\n            expect(user.get('authData')).toEqual({ ldap:{ id: 'testuser' }});\n            expect(user.get('authData').ldap.password).toBeUndefined();\n            done();\n          })\n          .catch(done.fail)\n          .finally(() => server.close())\n      })\n    });\n  });\n});\n", "const ldapjs = require('ldapjs');\nconst Parse = require('parse/node').Parse;\n\nfunction validateAuthData(authData, options) {\n  if (!optionsAreValid(options)) {\n    return new Promise((_, reject) => {\n      reject(\n        new Parse.Error(\n          Parse.Error.INTERNAL_SERVER_ERROR,\n          'LDAP auth configuration missing'\n        )\n      );\n    });\n  }\n  const clientOptions = (options.url.startsWith(\"ldaps://\")) ?\n    { url: options.url, tlsOptions: options.tlsOptions } : { url: options.url };\n\n  const client = ldapjs.createClient(clientOptions);\n  const userCn =\n    typeof options.dn === 'string'\n      ? options.dn.replace('{{id}}', authData.id)\n      : `uid=${authData.id},${options.suffix}`;\n\n  return new Promise((resolve, reject) => {\n    client.bind(userCn, authData.password, ldapError => {\n      delete(authData.password);\n      if (ldapError) {\n        let error;\n        switch (ldapError.code) {\n          case 49:\n            error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'LDAP: Wrong username or password');\n            break;\n          case \"DEPTH_ZERO_SELF_SIGNED_CERT\":\n            error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'LDAPS: Certificate mismatch');\n            break;\n          default:\n            error = new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'LDAP: Somthing went wrong (' + ldapError.code + ')');\n        }\n        reject(error);\n        client.destroy(ldapError);\n        return;\n      }\n\n      if (\n        typeof options.groupCn === 'string' &&\n        typeof options.groupFilter === 'string'\n      ) {\n        searchForGroup(client, options, authData.id, resolve, reject);\n      } else {\n        client.unbind();\n        client.destroy();\n        resolve();\n      }\n    });\n  });\n}\n\nfunction optionsAreValid(options) {\n  return (\n    typeof options === 'object' &&\n    typeof options.suffix === 'string' &&\n    typeof options.url === 'string' &&\n    (options.url.startsWith('ldap://') ||\n     options.url.startsWith('ldaps://') && typeof options.tlsOptions === 'object')\n  );\n}\n\nfunction searchForGroup(client, options, id, resolve, reject) {\n  const filter = options.groupFilter.replace(/{{id}}/gi, id);\n  const opts = {\n    scope: 'sub',\n    filter: filter,\n  };\n  let found = false;\n  client.search(options.suffix, opts, (searchError, res) => {\n    if (searchError) {\n      client.unbind();\n      client.destroy();\n      return reject(\n        new Parse.Error(\n          Parse.Error.INTERNAL_SERVER_ERROR,\n          'LDAP group search failed'\n        )\n      );\n    }\n    res.on('searchEntry', entry => {\n      if (entry.object.cn === options.groupCn) {\n        found = true;\n        client.unbind();\n        client.destroy();\n        return resolve();\n      }\n    });\n    res.on('end', () => {\n      if (!found) {\n        client.unbind();\n        client.destroy();\n        return reject(\n          new Parse.Error(\n            Parse.Error.INTERNAL_SERVER_ERROR,\n            'LDAP: User not in group'\n          )\n        );\n      }\n    });\n    res.on('error', () => {\n      return reject(\n        new Parse.Error(\n          Parse.Error.INTERNAL_SERVER_ERROR,\n          'LDAP group search failed'\n        )\n      );\n    });\n  });\n}\n\nfunction validateAppId() {\n  return Promise.resolve();\n}\n\nmodule.exports = {\n  validateAppId,\n  validateAuthData,\n};\n"], "filenames": ["spec/LdapAuth.spec.js", "src/Adapters/Auth/ldap.js"], "buggy_code_start_loc": [213, 25], "buggy_code_end_loc": [213, 25], "fixing_code_start_loc": [214, 26], "fixing_code_end_loc": [260, 27], "type": "CWE-312", "message": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. It is an npm package \"parse-server\". In Parse Server before version 4.5.0, user passwords involved in LDAP authentication are stored in cleartext. This is fixed in version 4.5.0 by stripping password after authentication to prevent cleartext password storage.", "other": {"cve": {"id": "CVE-2020-26288", "sourceIdentifier": "security-advisories@github.com", "published": "2020-12-30T20:15:15.267", "lastModified": "2021-01-04T21:01:31.620", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Parse Server is an open source backend that can be deployed to any infrastructure that can run Node.js. It is an npm package \"parse-server\". In Parse Server before version 4.5.0, user passwords involved in LDAP authentication are stored in cleartext. This is fixed in version 4.5.0 by stripping password after authentication to prevent cleartext password storage."}, {"lang": "es", "value": "Parse Server es un backend de c\u00f3digo abierto que puede ser implementado en cualquier infraestructura que pueda ejecutar Node.js.&#xa0;Es un paquete npm \"parse-server\".&#xa0;En Parse Server versiones anteriores a 4.5.0, las contrase\u00f1as de usuario involucradas en la autenticaci\u00f3n LDAP son almacenadas en texto sin cifrar.&#xa0;Esto es corregido en versi\u00f3n 4.5.0 al eliminar una contrase\u00f1a despu\u00e9s de la autenticaci\u00f3n para impedir un almacenamiento de contrase\u00f1a en texto sin cifrar."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.7, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.1, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-312"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:parseplatform:parse-server:*:*:*:*:*:node.js:*:*", "versionEndExcluding": "4.5.0", "matchCriteriaId": "4ABD5782-BD2E-4931-A732-E9FD231BC344"}]}]}], "references": [{"url": "https://github.com/parse-community/parse-server/commit/da905a357d062ab4fea727a21eac231acc2ed92a", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/releases/tag/4.5.0", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/parse-community/parse-server/security/advisories/GHSA-4w46-w44m-3jq3", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.npmjs.com/package/parse-server", "source": "security-advisories@github.com", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/parse-community/parse-server/commit/da905a357d062ab4fea727a21eac231acc2ed92a"}}