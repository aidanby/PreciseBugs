{"buggy_code": ["# needrestart - Restart daemons after library updates.\n#\n# Authors:\n#   Thomas Liske <thomas@fiasko-nw.net>\n#\n# Copyright Holder:\n#   2013 - 2022 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]\n#\n# License:\n#   This program is free software; you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation; either version 2 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this package; if not, write to the Free Software\n#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n\npackage NeedRestart::Interp::Perl;\n\nuse strict;\nuse warnings;\n\nuse parent qw(NeedRestart::Interp);\nuse Cwd qw(abs_path getcwd);\nuse Getopt::Std;\nuse NeedRestart qw(:interp);\nuse NeedRestart::Utils;\nuse Module::ScanDeps;\n\nmy $LOGPREF = '[Perl]';\n\nneedrestart_interp_register(__PACKAGE__);\n\nsub isa {\n    my $self = shift;\n    my $pid = shift;\n    my $bin = shift;\n\n    return 1 if($bin =~ m@/usr/(local/)?bin/perl@);\n\n    return 0;\n}\n\nsub source {\n    my $self = shift;\n    my $pid = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Perl's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('sTtuUWXhvV:cwdt:D:pnaF:l:0:I:m:M:fC:Sx:i:eE:', \\%opts);\n    }\n\n    # skip perl -e '...' calls\n    if(exists($opts{e}) || exists($opts{E})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    my $src = abs_path($ARGV[0]);\n    chdir($cwd);\n    unless(defined($src) && -r $src && -f $src) {\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    return $src;\n}\n\nsub files {\n    my $self = shift;\n    my $pid = shift;\n    my $cache = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Perl's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('sTtuUWXhvV:cwdt:D:pnaF:l:0:I:m:M:fC:Sx:i:eE:', \\%opts);\n    }\n\n    # skip perl -e '...' calls\n    if(exists($opts{e}) || exists($opts{E})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $src = abs_path ($ARGV[0]);\n    unless(defined($src) && -r $src && -f $src) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn ();\n    }\n    print STDERR \"$LOGPREF #$pid: source=$src\\n\" if($self->{debug});\n\n    # use cached data if avail\n    if(exists($cache->{files}->{(__PACKAGE__)}->{$src})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: use cached file list\\n\" if($self->{debug});\n\treturn %{ $cache->{files}->{(__PACKAGE__)}->{$src} };\n    }\n\n    # prepare include path environment variable\n    my %e = nr_parse_env($pid);\n    local %ENV;\n    if(exists($e{PERL5LIB})) {\n\t$ENV{PERL5LIB} = $e{PERL5LIB};\n    }\n    elsif(exists($ENV{PERL5LIB})) {\n\tdelete($ENV{PERL5LIB});\n    }\n\n    @Module::ScanDeps::IncludeLibs = (exists($opts{I}) ? ($opts{I}) : ());\n    my $href;\n    {\n\t# Silence warnings of Module::ScanDeps for dynamic loaded modules (github issue #41)\n\tlocal $SIG{__WARN__} = sub { };\n\n\t$href = scan_deps(\n\t    files => [$src],\n\t    recurse => 1,\n\t    );\n    }\n\n    my %ret = map {\n\tmy $stat = nr_stat(\"/proc/$pid/root/$href->{$_}->{file}\");\n\t$href->{$_}->{file} => ( defined($stat) ? $stat->{ctime} : undef );\n    } keys %$href;\n\n    chdir($cwd);\n\n    $cache->{files}->{(__PACKAGE__)}->{$src} = \\%ret;\n    return %ret;\n}\n\n1;\n", "# needrestart - Restart daemons after library updates.\n#\n# Authors:\n#   Thomas Liske <thomas@fiasko-nw.net>\n#\n# Copyright Holder:\n#   2013 - 2022 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]\n#\n# License:\n#   This program is free software; you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation; either version 2 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this package; if not, write to the Free Software\n#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n\npackage NeedRestart::Interp::Python;\n\nuse strict;\nuse warnings;\n\nuse parent qw(NeedRestart::Interp);\nuse Cwd qw(abs_path getcwd);\nuse Getopt::Std;\nuse NeedRestart qw(:interp);\nuse NeedRestart::Utils;\n\nmy $LOGPREF = '[Python]';\n\nneedrestart_interp_register(__PACKAGE__);\n\nsub isa {\n    my $self = shift;\n    my $pid = shift;\n    my $bin = shift;\n\n    return 1 if($bin =~ m@/usr/(local/)?bin/python@);\n\n    return 0;\n}\n\nsub _scan($$$$$) {\n    my $debug = shift;\n    my $pid = shift;\n    my $src = shift;\n    my $files = shift;\n    my $path = shift;\n\n    my $fh;\n    open($fh, '<', $src) || return;\n    # find used modules\n    my %modules = map {\n\t(/^\\s*import\\s+(\\S+)/ ? ($1 => 1) : (/^\\s*from\\s+(\\S+)\\s+import\\s+/ ? ($1 => 1) : ()))\n    } <$fh>;\n    close($fh);\n\n    # track file\n    $files->{$src}++;\n\n    # scan module files\n    if(scalar keys %modules) {\n\tforeach my $module (keys %modules) {\n\t    $module =~ s@\\.@/@g;\n\t    $module .= '.py';\n\n\t    foreach my $p (@$path) {\n\t\tmy $fn = ($p ne '' ? \"$p/\" : '').$module;\n\t\t&_scan($debug, $pid, $fn, $files, $path) if(!exists($files->{$fn}) && -r $fn && -f $fn);\n\t    }\n\t}\n    }\n}\n\nsub source {\n    my $self = shift;\n    my $pid = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Python's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('BdEhim:ORQ:sStuvVW:x3?c:', \\%opts);\n    }\n\n    # skip python -c '...' calls\n    if(exists($opts{c})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-c), skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    my $src = abs_path($ARGV[0]);\n    chdir($cwd);\n    unless(defined($src) && -r $src && -f $src) {\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    return $src;\n}\n\nsub files {\n    my $self = shift;\n    my $pid = shift;\n    my $cache = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Python's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('BdEhim:ORQ:sStuvVW:x3?c:', \\%opts);\n    }\n\n    # skip python -c '...' calls\n    if(exists($opts{c})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-c), skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $src = abs_path ($ARGV[0]);\n    unless(defined($src) && -r $src && -f $src) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn ();\n    }\n    print STDERR \"$LOGPREF #$pid: source=$src\\n\" if($self->{debug});\n\n    # use cached data if avail\n    if(exists($cache->{files}->{(__PACKAGE__)}->{$src})) {\n\tprint STDERR \"$LOGPREF #$pid: use cached file list\\n\" if($self->{debug});\n\treturn %{ $cache->{files}->{(__PACKAGE__)}->{$src} };\n    }\n\n    # prepare include path environment variable\n    my %e = nr_parse_env($pid);\n    local %ENV;\n    if(exists($e{PYTHONPATH})) {\n\t$ENV{PYTHONPATH} = $e{PYTHONPATH};\n    }\n    elsif(exists($ENV{PYTHONPATH})) {\n\tdelete($ENV{PYTHONPATH});\n    }\n\n    # get include path\n    my ($pyread, $pywrite) = nr_fork_pipe2($self->{debug}, $ptable->{exec}, '-');\n    print $pywrite \"import sys\\nprint(sys.path)\\n\";\n    close($pywrite);\n    my ($path) = <$pyread>;\n    close($pyread);\n\n    # look for module source files\n    my @path;\n    if(defined($path)) {\n\tchomp($path);\n\t$path =~ s/^\\['//;\n\t$path =~ s/'\\$//;\n\t@path = map { \"/proc/$pid/root/$_\"; } split(\"', '\", $path);\n    }\n    else {\n\tprint STDERR \"$LOGPREF #$pid: failed to retrieve include path\\n\" if($self->{debug});\n    }\n\n    my %files;\n    _scan($self->{debug}, $pid, $src, \\%files, \\@path);\n\n    my %ret = map {\n\tmy $stat = nr_stat(\"/proc/$pid/root/$_\");\n\t$_ => ( defined($stat) ? $stat->{ctime} : undef );\n    } keys %files;\n\n    chdir($cwd);\n\n    $cache->{files}->{(__PACKAGE__)}->{$src} = \\%ret;\n    return %ret;\n}\n\n1;\n", "# needrestart - Restart daemons after library updates.\n#\n# Authors:\n#   Thomas Liske <thomas@fiasko-nw.net>\n#\n# Copyright Holder:\n#   2013 - 2022 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]\n#\n# License:\n#   This program is free software; you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation; either version 2 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this package; if not, write to the Free Software\n#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n\npackage NeedRestart::Interp::Ruby;\n\nuse strict;\nuse warnings;\n\nuse parent qw(NeedRestart::Interp);\nuse Cwd qw(abs_path getcwd);\nuse Getopt::Std;\nuse NeedRestart qw(:interp);\nuse NeedRestart::Utils;\n\nmy $LOGPREF = '[Ruby]';\n\nneedrestart_interp_register(__PACKAGE__);\n\nsub isa {\n    my $self = shift;\n    my $pid = shift;\n    my $bin = shift;\n\n    return 1 if($bin =~ m@/usr/(local/)?bin/ruby@);\n\n    return 0;\n}\n\nsub _scan($$$$$) {\n    my $debug = shift;\n    my $pid = shift;\n    my $src = shift;\n    my $files = shift;\n    my $path = shift;\n\n    my $fh;\n    open($fh, '<', $src) || return;\n    # find used modules\n    my %modules = map {\n\t(/^\\s*load\\s+['\"]([^'\"]+)['\"]/ ? ($1 => 1) : (/^\\s*require\\s+['\"]([^'\"]+)['\"]/ ? (\"$1.rb\" => 1) : ()))\n    } <$fh>;\n    close($fh);\n\n    # track file\n    $files->{$src}++;\n\n    # scan module files\n    if(scalar keys %modules) {\n\tforeach my $module (keys %modules) {\n\t    foreach my $p (@$path) {\n\t\tmy $fn = ($p ne '' ? \"$p/\" : '').$module;\n\t\t&_scan($debug, $pid, $fn, $files, $path) if(!exists($files->{$fn}) && -r $fn && -f $fn);\n\t    }\n\t}\n    }\n}\n\nsub source {\n    my $self = shift;\n    my $pid = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Ruby's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('SUacdlnpswvy0:C:E:F:I:K:T:W:e:i:r:x:e:d:', \\%opts);\n    }\n\n    # skip ruby -e '...' calls\n    if(exists($opts{e})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    my $src = abs_path($ARGV[0]);\n    chdir($cwd);\n    unless(defined($src) && -r $src && -f $src) {\n\tprint STDERR \"$LOGPREF #$pid: source file '$src' not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    return $src;\n}\n\nsub files {\n    my $self = shift;\n    my $pid = shift;\n    my $cache = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Ruby's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('SUacdlnpswvy0:C:E:F:I:K:T:W:e:i:r:x:e:d:', \\%opts);\n    }\n\n    # skip ruby -e '...' calls\n    if(exists($opts{e})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $src = abs_path($ARGV[0]);\n    unless(-r $src && -f $src) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: source file '$src' not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn ();\n    }\n    print STDERR \"$LOGPREF #$pid: source=$src\\n\" if($self->{debug});\n\n    # use cached data if avail\n    if(exists($cache->{files}->{(__PACKAGE__)}->{$src})) {\n\tprint STDERR \"$LOGPREF #$pid: use cached file list\\n\" if($self->{debug});\n\treturn %{ $cache->{files}->{(__PACKAGE__)}->{$src} };\n    }\n\n    # prepare include path environment variable\n    my %e = nr_parse_env($pid);\n    local %ENV;\n    if(exists($e{RUBYLIB})) {\n\t$ENV{RUBYLIB} = $e{RUBYLIB};\n    }\n    elsif(exists($ENV{RUBYLIB})) {\n\tdelete($ENV{RUBYLIB});\n    }\n\n    # get include path\n    my $rbread = nr_fork_pipe($self->{debug}, $ptable->{exec}, '-e', 'puts $:');\n    my @path = map { \"/proc/$pid/root/$_\"; } <$rbread>;\n    close($rbread);\n    chomp(@path);\n\n    my %files;\n    _scan($self->{debug}, $pid, $src, \\%files, \\@path);\n\n    my %ret = map {\n\tmy $stat = nr_stat(\"/proc/$pid/root/$_\");\n\t$_ => ( defined($stat) ? $stat->{ctime} : undef );\n    } keys %files;\n\n    chdir($cwd);\n\n    $cache->{files}->{(__PACKAGE__)}->{$src} = \\%ret;\n    return %ret;\n}\n\n1;\n"], "fixing_code": ["# needrestart - Restart daemons after library updates.\n#\n# Authors:\n#   Thomas Liske <thomas@fiasko-nw.net>\n#\n# Copyright Holder:\n#   2013 - 2022 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]\n#\n# License:\n#   This program is free software; you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation; either version 2 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this package; if not, write to the Free Software\n#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n\npackage NeedRestart::Interp::Perl;\n\nuse strict;\nuse warnings;\n\nuse parent qw(NeedRestart::Interp);\nuse Cwd qw(abs_path getcwd);\nuse Getopt::Std;\nuse NeedRestart qw(:interp);\nuse NeedRestart::Utils;\nuse Module::ScanDeps;\n\nmy $LOGPREF = '[Perl]';\n\nneedrestart_interp_register(__PACKAGE__);\n\nsub isa {\n    my $self = shift;\n    my $pid = shift;\n    my $bin = shift;\n\n    return 1 if($bin =~ m@^/usr/(local/)?bin/perl(5[.\\d]*)?$@);\n\n    return 0;\n}\n\nsub source {\n    my $self = shift;\n    my $pid = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Perl's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('sTtuUWXhvV:cwdt:D:pnaF:l:0:I:m:M:fC:Sx:i:eE:', \\%opts);\n    }\n\n    # skip perl -e '...' calls\n    if(exists($opts{e}) || exists($opts{E})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    my $src = abs_path($ARGV[0]);\n    chdir($cwd);\n    unless(defined($src) && -r $src && -f $src) {\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    return $src;\n}\n\nsub files {\n    my $self = shift;\n    my $pid = shift;\n    my $cache = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Perl's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('sTtuUWXhvV:cwdt:D:pnaF:l:0:I:m:M:fC:Sx:i:eE:', \\%opts);\n    }\n\n    # skip perl -e '...' calls\n    if(exists($opts{e}) || exists($opts{E})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $src = abs_path ($ARGV[0]);\n    unless(defined($src) && -r $src && -f $src) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn ();\n    }\n    print STDERR \"$LOGPREF #$pid: source=$src\\n\" if($self->{debug});\n\n    # use cached data if avail\n    if(exists($cache->{files}->{(__PACKAGE__)}->{$src})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: use cached file list\\n\" if($self->{debug});\n\treturn %{ $cache->{files}->{(__PACKAGE__)}->{$src} };\n    }\n\n    # prepare include path environment variable\n    my %e = nr_parse_env($pid);\n    local %ENV;\n    if(exists($e{PERL5LIB})) {\n\t$ENV{PERL5LIB} = $e{PERL5LIB};\n    }\n    elsif(exists($ENV{PERL5LIB})) {\n\tdelete($ENV{PERL5LIB});\n    }\n\n    @Module::ScanDeps::IncludeLibs = (exists($opts{I}) ? ($opts{I}) : ());\n    my $href;\n    {\n\t# Silence warnings of Module::ScanDeps for dynamic loaded modules (github issue #41)\n\tlocal $SIG{__WARN__} = sub { };\n\n\t$href = scan_deps(\n\t    files => [$src],\n\t    recurse => 1,\n\t    );\n    }\n\n    my %ret = map {\n\tmy $stat = nr_stat(\"/proc/$pid/root/$href->{$_}->{file}\");\n\t$href->{$_}->{file} => ( defined($stat) ? $stat->{ctime} : undef );\n    } keys %$href;\n\n    chdir($cwd);\n\n    $cache->{files}->{(__PACKAGE__)}->{$src} = \\%ret;\n    return %ret;\n}\n\n1;\n", "# needrestart - Restart daemons after library updates.\n#\n# Authors:\n#   Thomas Liske <thomas@fiasko-nw.net>\n#\n# Copyright Holder:\n#   2013 - 2022 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]\n#\n# License:\n#   This program is free software; you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation; either version 2 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this package; if not, write to the Free Software\n#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n\npackage NeedRestart::Interp::Python;\n\nuse strict;\nuse warnings;\n\nuse parent qw(NeedRestart::Interp);\nuse Cwd qw(abs_path getcwd);\nuse Getopt::Std;\nuse NeedRestart qw(:interp);\nuse NeedRestart::Utils;\n\nmy $LOGPREF = '[Python]';\n\nneedrestart_interp_register(__PACKAGE__);\n\nsub isa {\n    my $self = shift;\n    my $pid = shift;\n    my $bin = shift;\n\n    return 1 if($bin =~ m@^/usr/(local/)?bin/python([23][.\\d]*)?$@);\n\n    return 0;\n}\n\nsub _scan($$$$$) {\n    my $debug = shift;\n    my $pid = shift;\n    my $src = shift;\n    my $files = shift;\n    my $path = shift;\n\n    my $fh;\n    open($fh, '<', $src) || return;\n    # find used modules\n    my %modules = map {\n\t(/^\\s*import\\s+(\\S+)/ ? ($1 => 1) : (/^\\s*from\\s+(\\S+)\\s+import\\s+/ ? ($1 => 1) : ()))\n    } <$fh>;\n    close($fh);\n\n    # track file\n    $files->{$src}++;\n\n    # scan module files\n    if(scalar keys %modules) {\n\tforeach my $module (keys %modules) {\n\t    $module =~ s@\\.@/@g;\n\t    $module .= '.py';\n\n\t    foreach my $p (@$path) {\n\t\tmy $fn = ($p ne '' ? \"$p/\" : '').$module;\n\t\t&_scan($debug, $pid, $fn, $files, $path) if(!exists($files->{$fn}) && -r $fn && -f $fn);\n\t    }\n\t}\n    }\n}\n\nsub source {\n    my $self = shift;\n    my $pid = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Python's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('BdEhim:ORQ:sStuvVW:x3?c:', \\%opts);\n    }\n\n    # skip python -c '...' calls\n    if(exists($opts{c})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-c), skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    my $src = abs_path($ARGV[0]);\n    chdir($cwd);\n    unless(defined($src) && -r $src && -f $src) {\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    return $src;\n}\n\nsub files {\n    my $self = shift;\n    my $pid = shift;\n    my $cache = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Python's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('BdEhim:ORQ:sStuvVW:x3?c:', \\%opts);\n    }\n\n    # skip python -c '...' calls\n    if(exists($opts{c})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-c), skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $src = abs_path ($ARGV[0]);\n    unless(defined($src) && -r $src && -f $src) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: source file not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn ();\n    }\n    print STDERR \"$LOGPREF #$pid: source=$src\\n\" if($self->{debug});\n\n    # use cached data if avail\n    if(exists($cache->{files}->{(__PACKAGE__)}->{$src})) {\n\tprint STDERR \"$LOGPREF #$pid: use cached file list\\n\" if($self->{debug});\n\treturn %{ $cache->{files}->{(__PACKAGE__)}->{$src} };\n    }\n\n    # prepare include path environment variable\n    my %e = nr_parse_env($pid);\n    local %ENV;\n    if(exists($e{PYTHONPATH})) {\n\t$ENV{PYTHONPATH} = $e{PYTHONPATH};\n    }\n    elsif(exists($ENV{PYTHONPATH})) {\n\tdelete($ENV{PYTHONPATH});\n    }\n\n    # get include path\n    my ($pyread, $pywrite) = nr_fork_pipe2($self->{debug}, $ptable->{exec}, '-');\n    print $pywrite \"import sys\\nprint(sys.path)\\n\";\n    close($pywrite);\n    my ($path) = <$pyread>;\n    close($pyread);\n\n    # look for module source files\n    my @path;\n    if(defined($path)) {\n\tchomp($path);\n\t$path =~ s/^\\['//;\n\t$path =~ s/'\\$//;\n\t@path = map { \"/proc/$pid/root/$_\"; } split(\"', '\", $path);\n    }\n    else {\n\tprint STDERR \"$LOGPREF #$pid: failed to retrieve include path\\n\" if($self->{debug});\n    }\n\n    my %files;\n    _scan($self->{debug}, $pid, $src, \\%files, \\@path);\n\n    my %ret = map {\n\tmy $stat = nr_stat(\"/proc/$pid/root/$_\");\n\t$_ => ( defined($stat) ? $stat->{ctime} : undef );\n    } keys %files;\n\n    chdir($cwd);\n\n    $cache->{files}->{(__PACKAGE__)}->{$src} = \\%ret;\n    return %ret;\n}\n\n1;\n", "# needrestart - Restart daemons after library updates.\n#\n# Authors:\n#   Thomas Liske <thomas@fiasko-nw.net>\n#\n# Copyright Holder:\n#   2013 - 2022 (C) Thomas Liske [http://fiasko-nw.net/~thomas/]\n#\n# License:\n#   This program is free software; you can redistribute it and/or modify\n#   it under the terms of the GNU General Public License as published by\n#   the Free Software Foundation; either version 2 of the License, or\n#   (at your option) any later version.\n#\n#   This program is distributed in the hope that it will be useful,\n#   but WITHOUT ANY WARRANTY; without even the implied warranty of\n#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n#   GNU General Public License for more details.\n#\n#   You should have received a copy of the GNU General Public License\n#   along with this package; if not, write to the Free Software\n#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA\n#\n\npackage NeedRestart::Interp::Ruby;\n\nuse strict;\nuse warnings;\n\nuse parent qw(NeedRestart::Interp);\nuse Cwd qw(abs_path getcwd);\nuse Getopt::Std;\nuse NeedRestart qw(:interp);\nuse NeedRestart::Utils;\n\nmy $LOGPREF = '[Ruby]';\n\nneedrestart_interp_register(__PACKAGE__);\n\nsub isa {\n    my $self = shift;\n    my $pid = shift;\n    my $bin = shift;\n\n    return 1 if($bin =~ m@^/usr/(local/)?bin/ruby$@);\n\n    return 0;\n}\n\nsub _scan($$$$$) {\n    my $debug = shift;\n    my $pid = shift;\n    my $src = shift;\n    my $files = shift;\n    my $path = shift;\n\n    my $fh;\n    open($fh, '<', $src) || return;\n    # find used modules\n    my %modules = map {\n\t(/^\\s*load\\s+['\"]([^'\"]+)['\"]/ ? ($1 => 1) : (/^\\s*require\\s+['\"]([^'\"]+)['\"]/ ? (\"$1.rb\" => 1) : ()))\n    } <$fh>;\n    close($fh);\n\n    # track file\n    $files->{$src}++;\n\n    # scan module files\n    if(scalar keys %modules) {\n\tforeach my $module (keys %modules) {\n\t    foreach my $p (@$path) {\n\t\tmy $fn = ($p ne '' ? \"$p/\" : '').$module;\n\t\t&_scan($debug, $pid, $fn, $files, $path) if(!exists($files->{$fn}) && -r $fn && -f $fn);\n\t    }\n\t}\n    }\n}\n\nsub source {\n    my $self = shift;\n    my $pid = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Ruby's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('SUacdlnpswvy0:C:E:F:I:K:T:W:e:i:r:x:e:d:', \\%opts);\n    }\n\n    # skip ruby -e '...' calls\n    if(exists($opts{e})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    my $src = abs_path($ARGV[0]);\n    chdir($cwd);\n    unless(defined($src) && -r $src && -f $src) {\n\tprint STDERR \"$LOGPREF #$pid: source file '$src' not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn undef;\n    }\n\n    return $src;\n}\n\nsub files {\n    my $self = shift;\n    my $pid = shift;\n    my $cache = shift;\n    my $ptable = nr_ptable_pid($pid);\n    unless($ptable->{cwd}) {\n\tprint STDERR \"$LOGPREF #$pid: could not get current working directory, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $cwd = getcwd();\n    chdir(\"/proc/$pid/root/$ptable->{cwd}\");\n\n    # skip the process if the cwd is unreachable (i.e. due to mnt ns)\n    unless(getcwd()) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: process cwd is unreachable\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # get original ARGV\n    (my $bin, local @ARGV) = nr_parse_cmd($pid);\n\n    # eat Ruby's command line options\n    my %opts;\n    {\n\tlocal $SIG{__WARN__} = sub { };\n\tgetopts('SUacdlnpswvy0:C:E:F:I:K:T:W:e:i:r:x:e:d:', \\%opts);\n    }\n\n    # skip ruby -e '...' calls\n    if(exists($opts{e})) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: uses no source file (-e), skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n\n    # extract source file\n    unless($#ARGV > -1) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: could not get a source file, skipping\\n\" if($self->{debug});\n\treturn ();\n    }\n    my $src = abs_path($ARGV[0]);\n    unless(-r $src && -f $src) {\n\tchdir($cwd);\n\tprint STDERR \"$LOGPREF #$pid: source file '$src' not found, skipping\\n\" if($self->{debug});\n\tprint STDERR \"$LOGPREF #$pid:  reduced ARGV: \".join(' ', @ARGV).\"\\n\" if($self->{debug});\n\treturn ();\n    }\n    print STDERR \"$LOGPREF #$pid: source=$src\\n\" if($self->{debug});\n\n    # use cached data if avail\n    if(exists($cache->{files}->{(__PACKAGE__)}->{$src})) {\n\tprint STDERR \"$LOGPREF #$pid: use cached file list\\n\" if($self->{debug});\n\treturn %{ $cache->{files}->{(__PACKAGE__)}->{$src} };\n    }\n\n    # prepare include path environment variable\n    my %e = nr_parse_env($pid);\n    local %ENV;\n    if(exists($e{RUBYLIB})) {\n\t$ENV{RUBYLIB} = $e{RUBYLIB};\n    }\n    elsif(exists($ENV{RUBYLIB})) {\n\tdelete($ENV{RUBYLIB});\n    }\n\n    # get include path\n    my $rbread = nr_fork_pipe($self->{debug}, $ptable->{exec}, '-e', 'puts $:');\n    my @path = map { \"/proc/$pid/root/$_\"; } <$rbread>;\n    close($rbread);\n    chomp(@path);\n\n    my %files;\n    _scan($self->{debug}, $pid, $src, \\%files, \\@path);\n\n    my %ret = map {\n\tmy $stat = nr_stat(\"/proc/$pid/root/$_\");\n\t$_ => ( defined($stat) ? $stat->{ctime} : undef );\n    } keys %files;\n\n    chdir($cwd);\n\n    $cache->{files}->{(__PACKAGE__)}->{$src} = \\%ret;\n    return %ret;\n}\n\n1;\n"], "filenames": ["perl/lib/NeedRestart/Interp/Perl.pm", "perl/lib/NeedRestart/Interp/Python.pm", "perl/lib/NeedRestart/Interp/Ruby.pm"], "buggy_code_start_loc": [46, 45, 45], "buggy_code_end_loc": [47, 46, 46], "fixing_code_start_loc": [46, 45, 45], "fixing_code_end_loc": [47, 46, 46], "type": "CWE-269", "message": "needrestart 0.8 through 3.5 before 3.6 is prone to local privilege escalation. Regexes to detect the Perl, Python, and Ruby interpreters are not anchored, allowing a local user to escalate privileges when needrestart tries to detect if interpreters are using old source files.", "other": {"cve": {"id": "CVE-2022-30688", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-17T19:15:08.743", "lastModified": "2022-05-25T18:30:19.417", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "needrestart 0.8 through 3.5 before 3.6 is prone to local privilege escalation. Regexes to detect the Perl, Python, and Ruby interpreters are not anchored, allowing a local user to escalate privileges when needrestart tries to detect if interpreters are using old source files."}, {"lang": "es", "value": "needrestart versiones 0.8 hasta 3.5 anteriores a 3.6, es propenso a una escalada de privilegios local. Las remezclas para detectar los int\u00e9rpretes de Perl, Python y Ruby no est\u00e1n ancladas, lo que permite a un usuario local escalar privilegios cuando needrestart intenta detectar si los int\u00e9rpretes est\u00e1n usando archivos fuente antiguos"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:needrestart_project:needrestart:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.8", "versionEndExcluding": "3.6", "matchCriteriaId": "B46177A6-8D37-4C1A-BD7C-81F58ACB7A27"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/05/17/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/liske/needrestart/commit/e6e58136e1e3c92296e2e810cb8372a5fe0dbd30", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/liske/needrestart/releases/tag/v3.6", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00024.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-security-announce/2022/msg00105.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5137", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/05/17/9", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/liske/needrestart/commit/e6e58136e1e3c92296e2e810cb8372a5fe0dbd30"}}