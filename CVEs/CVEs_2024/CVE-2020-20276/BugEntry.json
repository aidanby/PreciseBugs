{"buggy_code": ["/* FTP engine\n *\n * Copyright (c) 2014-2019  Joachim Nilsson <troglobit@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"uftpd.h\"\n#include <ctype.h>\n#include <arpa/ftp.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\ntypedef struct {\n\tchar *command;\n\tvoid (*cb)(ctrl_t *ctr, char *arg);\n} ftp_cmd_t;\n\nstatic ftp_cmd_t supported[];\n\nstatic void do_PORT(ctrl_t *ctrl, int pending);\nstatic void do_LIST(uev_t *w, void *arg, int events);\nstatic void do_RETR(uev_t *w, void *arg, int events);\nstatic void do_STOR(uev_t *w, void *arg, int events);\n\nstatic int is_cont(char *msg)\n{\n\tchar *ptr;\n\n\tptr = strchr(msg, '\\r');\n\tif (ptr) {\n\t\tptr++;\n\t\tif (strchr(ptr, '\\r'))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int send_msg(int sd, char *msg)\n{\n\tint n = 0;\n\tint l;\n\n\tif (!msg) {\n\terr:\n\t\tERR(EINVAL, \"Missing argument to send_msg()\");\n\t\treturn 1;\n\t}\n\n\tl = strlen(msg);\n\tif (l <= 0)\n\t\tgoto err;\n\n\twhile (n < l) {\n\t\tint result = send(sd, msg + n, l, 0);\n\n\t\tif (result < 0) {\n\t\t\tERR(errno, \"Failed sending message to client\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tn += result;\n\t}\n\n\tDBG(\"Sent: %s%s\", is_cont(msg) ? \"\\n\" : \"\", msg);\n\n\treturn 0;\n}\n\n/*\n * Receive message from client, split into command and argument\n */\nstatic int recv_msg(int sd, char *msg, size_t len, char **cmd, char **argument)\n{\n\tchar *ptr;\n\tssize_t bytes;\n\tuint8_t *raw = (uint8_t *)msg;\n\n\t/* Clear for every new command. */\n\tmemset(msg, 0, len);\n\n\t/* Save one byte (-1) for NUL termination */\n\tbytes = recv(sd, msg, len - 1, 0);\n\tif (bytes < 0) {\n\t\tif (EINTR == errno)\n\t\t\treturn 1;\n\n\t\tif (ECONNRESET == errno)\n\t\t\tDBG(\"Connection reset by client.\");\n\t\telse\n\t\t\tERR(errno, \"Failed reading client command\");\n\t\treturn 1;\n\t}\n\n\tif (!bytes) {\n\t\tINFO(\"Client disconnected.\");\n\t\treturn 1;\n\t}\n\n\tif (raw[0] == 0xff) {\n\t\tchar tmp[4];\n\t\tchar buf[20] = { 0 };\n\t\tint i;\n\n\t\ti = recv(sd, &msg[bytes], len - bytes - 1, MSG_OOB | MSG_DONTWAIT);\n\t\tif (i > 0)\n\t\t\tbytes += i;\n\n\t\tfor (i = 0; i < bytes; i++) {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%2X%s\", raw[i], i + 1 < bytes ? \" \" : \"\");\n\t\t\tstrlcat(buf, tmp, sizeof(buf));\n\t\t}\n\n\t\tstrlcpy(msg, buf, len);\n\t\t*cmd      = msg;\n\t\t*argument = NULL;\n\n\t\tDBG(\"Recv: [%s], %zd bytes\", msg, bytes);\n\n\t\treturn 0;\n\t}\n\n\t/* NUL terminate for strpbrk() */\n\tmsg[bytes] = 0;\n\n\t*cmd = msg;\n\tptr  = strpbrk(msg, \" \");\n\tif (ptr) {\n\t\t*ptr = 0;\n\t\tptr++;\n\t\t*argument = ptr;\n\t} else {\n\t\t*argument = NULL;\n\t\tptr = msg;\n\t}\n\n\tptr = strpbrk(ptr, \"\\r\\n\");\n\tif (ptr)\n\t\t*ptr = 0;\n\n\t/* Convert command to std ftp upper case, issue #18 */\n\tfor (ptr = msg; *ptr; ++ptr) *ptr = toupper(*ptr);\n\n\tDBG(\"Recv: %s %s\", *cmd, *argument ?: \"\");\n\n\treturn 0;\n}\n\nstatic int open_data_connection(ctrl_t *ctrl)\n{\n\tsocklen_t len = sizeof(struct sockaddr);\n\tstruct sockaddr_in sin;\n\n\t/* Previous PORT command from client */\n\tif (ctrl->data_address[0]) {\n\t\tint rc;\n\n\t\tctrl->data_sd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n\t\tif (-1 == ctrl->data_sd) {\n\t\t\tERR(errno, \"Failed creating data socket\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(ctrl->data_port);\n\t\tinet_aton(ctrl->data_address, &(sin.sin_addr));\n\n\t\trc = connect(ctrl->data_sd, (struct sockaddr *)&sin, len);\n\t\tif (rc == -1 && EINPROGRESS != errno) {\n\t\t\tERR(errno, \"Failed connecting data socket to client\");\n\t\t\tclose(ctrl->data_sd);\n\t\t\tctrl->data_sd = -1;\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tDBG(\"Connected successfully to client's previously requested address:PORT %s:%d\",\n\t\t    ctrl->data_address, ctrl->data_port);\n\t\treturn 0;\n\t}\n\n\t/* Previous PASV command, accept connect from client */\n\tif (ctrl->data_listen_sd > 0) {\n\t\tconst int const_int_1 = 1;\n\t\tint retries = 3;\n\t\tchar client_ip[100];\n\n\tretry:\n\t\tctrl->data_sd = accept(ctrl->data_listen_sd, (struct sockaddr *)&sin, &len);\n\t\tif (-1 == ctrl->data_sd) {\n\t\t\tif (EAGAIN == errno && --retries) {\n\t\t\t\tsleep(1);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tERR(errno, \"Failed accepting connection from client\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tsetsockopt(ctrl->data_sd, SOL_SOCKET, SO_KEEPALIVE, &const_int_1, sizeof(const_int_1));\n\t\tset_nonblock(ctrl->data_sd);\n\n\t\tinet_ntop(AF_INET, &(sin.sin_addr), client_ip, INET_ADDRSTRLEN);\n\t\tDBG(\"Client PASV data connection from %s:%d\", client_ip, ntohs(sin.sin_port));\n\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int close_data_connection(ctrl_t *ctrl)\n{\n\tint ret = 0;\n\n\tDBG(\"Closing data connection ...\");\n\n\t/* PASV server listening socket */\n\tif (ctrl->data_listen_sd > 0) {\n\t\tshutdown(ctrl->data_listen_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\tret++;\n\t}\n\n\t/* PASV client socket */\n\tif (ctrl->data_sd > 0) {\n\t\tshutdown(ctrl->data_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t\tret++;\n\t}\n\n\t/* PORT */\n\tif (ctrl->data_address[0]) {\n\t\tctrl->data_address[0] = 0;\n\t\tctrl->data_port = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int check_user_pass(ctrl_t *ctrl)\n{\n\tif (!ctrl->name[0])\n\t\treturn -1;\n\n\tif (!strcmp(\"anonymous\", ctrl->name))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int do_abort(ctrl_t *ctrl)\n{\n\tif (ctrl->d || ctrl->d_num) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tif (ctrl->d_num > 0)\n\t\t\tfree(ctrl->d);\n\t\tctrl->d_num = 0;\n\t\tctrl->d = NULL;\n\t\tctrl->i = 0;\n\n\t\tif (ctrl->file)\n\t\t\tfree(ctrl->file);\n\t\tctrl->file = NULL;\n\t}\n\n\tif (ctrl->file) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tfree(ctrl->file);\n\t\tctrl->file = NULL;\n\t}\n\n\tif (ctrl->fp) {\n\t\tfclose(ctrl->fp);\n\t\tctrl->fp = NULL;\n\t}\n\n\tctrl->pending = 0;\n\tctrl->offset = 0;\n\n\treturn close_data_connection(ctrl);\n}\n\nstatic void handle_ABOR(ctrl_t *ctrl, char *arg)\n{\n\tDBG(\"Aborting any current transfer ...\");\n\tif (do_abort(ctrl))\n\t\tsend_msg(ctrl->sd, \"426 Connection closed; transfer aborted.\\r\\n\");\n\n\tsend_msg(ctrl->sd, \"226 Closing data connection.\\r\\n\");\n}\n\nstatic void handle_USER(ctrl_t *ctrl, char *name)\n{\n\tif (ctrl->name[0]) {\n\t\tctrl->name[0] = 0;\n\t\tctrl->pass[0] = 0;\n\t}\n\n\tif (name) {\n\t\tstrlcpy(ctrl->name, name, sizeof(ctrl->name));\n\t\tif (check_user_pass(ctrl) == 1) {\n\t\t\tINFO(\"Guest logged in from %s\", ctrl->clientaddr);\n\t\t\tsend_msg(ctrl->sd, \"230 Guest login OK, access restrictions apply.\\r\\n\");\n\t\t} else {\n\t\t\tsend_msg(ctrl->sd, \"331 Login OK, please enter password.\\r\\n\");\n\t\t}\n\t} else {\n\t\tsend_msg(ctrl->sd, \"530 You must input your name.\\r\\n\");\n\t}\n}\n\nstatic void handle_PASS(ctrl_t *ctrl, char *pass)\n{\n\tif (!ctrl->name[0]) {\n\t\tsend_msg(ctrl->sd, \"503 No username given.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->pass, pass, sizeof(ctrl->pass));\n\tif (check_user_pass(ctrl) < 0) {\n\t\tLOG(\"User %s from %s, invalid password!\", ctrl->name, ctrl->clientaddr);\n\t\tsend_msg(ctrl->sd, \"530 username or password is unacceptable\\r\\n\");\n\t\treturn;\n\t}\n\n\tINFO(\"User %s login from %s\", ctrl->name, ctrl->clientaddr);\n\tsend_msg(ctrl->sd, \"230 Guest login OK, access restrictions apply.\\r\\n\");\n}\n\nstatic void handle_SYST(ctrl_t *ctrl, char *arg)\n{\n\tchar system[] = \"215 UNIX Type: L8\\r\\n\";\n\n\tsend_msg(ctrl->sd, system);\n}\n\nstatic void handle_TYPE(ctrl_t *ctrl, char *argument)\n{\n\tchar type[24]  = \"200 Type set to I.\\r\\n\";\n\tchar unknown[] = \"501 Invalid argument to TYPE.\\r\\n\";\n\n\tif (!argument)\n\t\targument = \"Z\";\n\n\tswitch (argument[0]) {\n\tcase 'A':\n\t\tctrl->type = TYPE_A; /* ASCII */\n\t\tbreak;\n\n\tcase 'I':\n\t\tctrl->type = TYPE_I; /* IMAGE/BINARY */\n\t\tbreak;\n\n\tdefault:\n\t\tsend_msg(ctrl->sd, unknown);\n\t\treturn;\n\t}\n\n\ttype[16] = argument[0];\n\tsend_msg(ctrl->sd, type);\n}\n\nstatic void handle_PWD(ctrl_t *ctrl, char *arg)\n{\n\tchar buf[sizeof(ctrl->cwd) + 10];\n\n\tsnprintf(buf, sizeof(buf), \"257 \\\"%s\\\"\\r\\n\", ctrl->cwd);\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic void handle_CWD(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tchar *dir;\n\n\tif (!path)\n\t\tgoto done;\n\n\t/*\n\t * Some FTP clients, most notably Chrome, use CWD to check if an\n\t * entry is a file or directory.\n\t */\n\tdir = compose_abspath(ctrl, path);\n\tif (!dir || stat(dir, &st) || !S_ISDIR(st.st_mode)) {\n\t\tDBG(\"chrooted:%d, ctrl->cwd: %s, home:%s, dir:%s, len:%zd, dirlen:%zd\",\n\t\t    chrooted, ctrl->cwd, home, dir, strlen(home), strlen(dir));\n\t\tsend_msg(ctrl->sd, \"550 No such directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"non-chrooted CWD, home:%s, dir:%s, len:%zd, dirlen:%zd\",\n\t\t    home, dir, len, strlen(dir));\n\t\tdir += len;\n\t}\n\n\tsnprintf(ctrl->cwd, sizeof(ctrl->cwd), \"%s\", dir);\n\tif (ctrl->cwd[0] == 0)\n\t\tsnprintf(ctrl->cwd, sizeof(ctrl->cwd), \"/\");\n\ndone:\n\tDBG(\"New CWD: '%s'\", ctrl->cwd);\n\tsend_msg(ctrl->sd, \"250 OK\\r\\n\");\n}\n\nstatic void handle_CDUP(ctrl_t *ctrl, char *path)\n{\n\thandle_CWD(ctrl, \"..\");\n}\n\nstatic void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsprintf(addr, \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}\n\nstatic void handle_EPRT(ctrl_t *ctrl, char *str)\n{\n\tsend_msg(ctrl->sd, \"502 Command not implemented.\\r\\n\");\n}\n\nstatic char *mode_to_str(mode_t m)\n{\n\tstatic char str[11];\n\n\tsnprintf(str, sizeof(str), \"%c%c%c%c%c%c%c%c%c%c\",\n\t\t S_ISDIR(m)  ? 'd' : '-',\n\t\t m & S_IRUSR ? 'r' : '-',\n\t\t m & S_IWUSR ? 'w' : '-',\n\t\t m & S_IXUSR ? 'x' : '-',\n\t\t m & S_IRGRP ? 'r' : '-',\n\t\t m & S_IWGRP ? 'w' : '-',\n\t\t m & S_IXGRP ? 'x' : '-',\n\t\t m & S_IROTH ? 'r' : '-',\n\t\t m & S_IWOTH ? 'w' : '-',\n\t\t m & S_IXOTH ? 'x' : '-');\n\n\treturn str;\n}\n\nstatic char *time_to_str(time_t mtime)\n{\n\tstruct tm *t = localtime(&mtime);\n\tstatic char str[20];\n\n\tsetlocale(LC_TIME, \"C\");\n\tstrftime(str, sizeof(str), \"%b %e %H:%M\", t);\n\n\treturn str;\n}\n\nstatic char *mlsd_time(time_t mtime)\n{\n\tstruct tm *t = localtime(&mtime);\n\tstatic char str[20];\n\n\tstrftime(str, sizeof(str), \"%Y%m%d%H%M%S\", t);\n\n\treturn str;\n}\n\nstatic const char *mlsd_type(char *name, int mode)\n{\n\tif (!strcmp(name, \".\"))\n\t\treturn \"cdir\";\n\tif (!strcmp(name, \"..\"))\n\t\treturn \"pdir\";\n\n\treturn S_ISDIR(mode) ? \"dir\" : \"file\";\n}\n\nvoid mlsd_fact(char fact, char *buf, size_t len, char *name, char *perms, struct stat *st)\n{\n\tchar size[20];\n\n\tswitch (fact) {\n\tcase 'm':\n\t\tstrlcat(buf, \"modify=\", len);\n\t\tstrlcat(buf, mlsd_time(st->st_mtime), len);\n\t\tbreak;\n\n\tcase 'p':\n\t\tstrlcat(buf, \"perm=\", len);\n\t\tstrlcat(buf, perms, len);\n\t\tbreak;\n\n\tcase 't':\n\t\tstrlcat(buf, \"type=\", len);\n\t\tstrlcat(buf, mlsd_type(name, st->st_mode), len);\n\t\tbreak;\n\n\n\tcase 's':\n\t\tif (S_ISDIR(st->st_mode))\n\t\t\treturn;\n\t\tsnprintf(size, sizeof(size), \"size=%\" PRIu64, st->st_size);\n\t\tstrlcat(buf, size, len);\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tstrlcat(buf, \";\", len);\n}\n\nstatic void mlsd_printf(ctrl_t *ctrl, char *buf, size_t len, char *path, char *name, struct stat *st)\n{\n\tchar perms[10] = \"\";\n\tint ro = !access(path, R_OK);\n\tint rw = !access(path, W_OK);\n\n\tif (S_ISDIR(st->st_mode)) {\n\t\t/* XXX: Verify 'e' by checking that we can CD to the 'name' */\n\t\tif (ro)\n\t\t\tstrlcat(perms, \"le\", sizeof(perms));\n\t\tif (rw)\n\t\t\tstrlcat(perms, \"pc\", sizeof(perms)); /* 'd' RMD, 'm' MKD */\n\t} else {\n\t\tif (ro)\n\t\t\tstrlcat(perms, \"r\", sizeof(perms));\n\t\tif (rw)\n\t\t\tstrlcat(perms, \"w\", sizeof(perms)); /* 'f' RNFR, 'd' DELE */\n\t}\n\n\tmemset(buf, 0, len);\n\tif (ctrl->d_num == -1 && (ctrl->list_mode & 0x0F) == 2)\n\t\tstrlcat(buf, \" \", len);\n\n\tfor (int i = 0; ctrl->facts[i]; i++)\n\t\tmlsd_fact(ctrl->facts[i], buf, len, name, perms, st);\n\n\tstrlcat(buf, \" \", len);\n\tstrlcat(buf, name, len);\n\tstrlcat(buf, \"\\r\\n\", len);\n}\n\nstatic int list_printf(ctrl_t *ctrl, char *buf, size_t len, char *path, char *name)\n{\n\tint dirs;\n\tint mode = ctrl->list_mode;\n\tstruct stat st;\n\n\tif (stat(path, &st))\n\t\treturn -1;\n\n\tdirs = mode & 0xF0;\n\tmode = mode & 0x0F;\n\n\tif (dirs && !S_ISDIR(st.st_mode))\n\t\treturn 1;\n\tif (!dirs && S_ISDIR(st.st_mode))\n\t\treturn 1;\n\n\tswitch (mode) {\n\tcase 3:\t\t\t/* MLSD */\n\t\t/* fallthrough */\n\tcase 2:\t\t\t/* MLST */\n\t\tmlsd_printf(ctrl, buf, len, path, name, &st);\n\t\tbreak;\n\n\tcase 1:\t\t\t/* NLST */\n\t\tsnprintf(buf, len, \"%s\\r\\n\", name);\n\t\tbreak;\n\n\tcase 0:\t\t\t/* LIST */\n\t\tsnprintf(buf, len, \"%s 1 %5d %5d %12\" PRIu64 \" %s %s\\r\\n\",\n\t\t\t mode_to_str(st.st_mode),\n\t\t\t 0, 0, (uint64_t)st.st_size,\n\t\t\t time_to_str(st.st_mtime), name);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void do_MLST(ctrl_t *ctrl)\n{\n\tsize_t len = 0;\n\tchar buf[512] = { 0 };\n\tint sd = ctrl->sd;\n\n\tif (ctrl->data_sd != -1)\n\t\tsd = ctrl->data_sd;\n\n\tsnprintf(buf, sizeof(buf), \"250- Listing %s\\r\\n\", ctrl->file);\n\tlen = strlen(buf);\n\n\tif (list_printf(ctrl, &buf[len], sizeof(buf) -  len, ctrl->file, basename(ctrl->file))) {\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcat(buf, \"250 End.\\r\\n\", sizeof(buf));\n\tsend_msg(sd, buf);\n}\n\nstatic void do_MLSD(ctrl_t *ctrl)\n{\n\tchar buf[512] = { 0 };\n\n\tif (list_printf(ctrl, buf, sizeof(buf), ctrl->file, basename(ctrl->file))) {\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsend_msg(ctrl->data_sd, buf);\n\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n}\n\nstatic void do_LIST(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tstruct timeval tv;\n\tssize_t bytes;\n\tchar buf[BUFFER_SIZE] = { 0 };\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tif (ctrl->d_num == -1) {\n\t\tif (ctrl->list_mode == 3)\n\t\t\tdo_MLSD(ctrl);\n\t\telse\n\t\t\tdo_MLST(ctrl);\n\t\tdo_abort(ctrl);\n\t\treturn;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\tif (tv.tv_sec - ctrl->tv.tv_sec > 3) {\n\t\tDBG(\"Sending LIST entry %d of %d to %s ...\", ctrl->i, ctrl->d_num, ctrl->clientaddr);\n\t\tctrl->tv.tv_sec = tv.tv_sec;\n\t}\n\n\tctrl->list_mode |= (ctrl->pending ? 0 : 0x80);\n\twhile (ctrl->i < ctrl->d_num) {\n\t\tstruct dirent *entry;\n\t\tchar *name, *path;\n\t\tchar cwd[PATH_MAX];\n\n\t\tentry = ctrl->d[ctrl->i++];\n\t\tname  = entry->d_name;\n\n\t\tDBG(\"Found directory entry %s\", name);\n\t\tif ((!strcmp(name, \".\") || !strcmp(name, \"..\")) && ctrl->list_mode < 2)\n\t\t\tcontinue;\n\n\t\tsnprintf(cwd, sizeof(cwd), \"%s%s%s\", ctrl->file,\n\t\t\t ctrl->file[strlen(ctrl->file) - 1] == '/' ? \"\" : \"/\", name);\n\t\tpath = compose_path(ctrl, cwd);\n\t\tif (!path) {\n\t\tfail:\n\t\t\tLOGIT(LOG_INFO, errno, \"Failed reading status for %s\", path ? path : name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (list_printf(ctrl, buf, sizeof(buf), path, name)) {\n\t\tcase -1:\n\t\t\tgoto fail;\n\t\tcase 1:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tDBG(\"LIST %s\", buf);\n\t\tfree(entry);\n\n\t\tbytes = send(ctrl->data_sd, buf, strlen(buf), 0);\n\t\tif (-1 == bytes) {\n\t\t\tif (ECONNRESET == errno)\n\t\t\t\tDBG(\"Connection reset by client.\");\n\t\t\telse\n\t\t\t\tERR(errno, \"Failed sending file %s to client\", ctrl->file);\n\n\t\t\twhile (ctrl->i < ctrl->d_num) {\n\t\t\t\tstruct dirent *entry = ctrl->d[ctrl->i++];\n\t\t\t\tfree(entry);\n\t\t\t}\n\t\t\tdo_abort(ctrl);\n\t\t\tsend_msg(ctrl->sd, \"426 TCP connection was established but then broken!\\r\\n\");\n\t\t}\n\n\t\treturn;\n\t}\n\tctrl->list_mode &= 0x0F;\n\n\t/* Rewind and list files */\n\tif (ctrl->pending == 0) {\n\t\tctrl->pending++;\n\t\tctrl->i = 0;\n\t\treturn;\n\t}\n\n\tdo_abort(ctrl);\n\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n}\n\nstatic void list(ctrl_t *ctrl, char *arg, int mode)\n{\n\tchar *path;\n\n\tif (string_valid(arg)) {\n\t\tchar *ptr, *quot;\n\n\t\t/* Check if client sends ls arguments ... */\n\t\tptr = arg;\n\t\twhile (*ptr) {\n\t\t\tif (isspace(*ptr))\n\t\t\t\tptr++;\n\n\t\t\tif (*ptr == '-') {\n\t\t\t\twhile (*ptr && !isspace(*ptr))\n\t\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Strip any \"\" from \"<arg>\" */\n\t\twhile ((quot = strchr(ptr, '\"'))) {\n\t\t\tchar *ptr2;\n\n\t\t\tptr2 = strchr(&quot[1], '\"');\n\t\t\tif (ptr2) {\n\t\t\t\tmemmove(ptr2, &ptr2[1], strlen(ptr2));\n\t\t\t\tmemmove(quot, &quot[1], strlen(quot));\n\t\t\t}\n\t\t}\n\t\targ = ptr;\n\t}\n\n\tif (mode >= 2)\n\t\tpath = compose_abspath(ctrl, arg);\n\telse\n\t\tpath = compose_path(ctrl, arg);\n\tif (!path) {\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tctrl->list_mode = mode;\n\tctrl->file = strdup(arg ? arg : \"\");\n\tctrl->i = 0;\n\tctrl->d_num = scandir(path, &ctrl->d, NULL, alphasort);\n\tif (ctrl->d_num == -1) {\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\tDBG(\"Failed reading directory '%s': %s\", path, strerror(errno));\n\t\treturn;\n\t}\n\n\tDBG(\"Reading directory %s ... %d number of entries\", path, ctrl->d_num);\n\tif (ctrl->data_sd > -1) {\n\t\tsend_msg(ctrl->sd, \"125 Data connection already open; transfer starting.\\r\\n\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_LIST, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\treturn;\n\t}\n\n\tdo_PORT(ctrl, 1);\n}\n\nstatic void handle_LIST(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 0);\n}\n\nstatic void handle_NLST(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 1);\n}\n\nstatic void handle_MLST(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 2);\n}\n\nstatic void handle_MLSD(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 3);\n}\n\nstatic void do_pasv_connection(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tint rc = 0;\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tDBG(\"error on data_listen_sd ...\");\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\tDBG(\"Event on data_listen_sd ...\");\n\tuev_io_stop(&ctrl->data_watcher);\n\tif (open_data_connection(ctrl))\n\t\treturn;\n\n\tswitch (ctrl->pending) {\n\tcase 3:\n\t\t/* fall-through */\n\tcase 2:\n\t\tif (ctrl->offset)\n\t\t\trc = fseek(ctrl->fp, ctrl->offset, SEEK_SET);\n\t\tif (rc) {\n\t\t\tdo_abort(ctrl);\n\t\t\tsend_msg(ctrl->sd, \"551 Failed seeking to that position in file.\\r\\n\");\n\t\t\treturn;\n\t\t}\n\t\t/* fall-through */\n\tcase 1:\n\t\tbreak;\n\n\tdefault:\n\t\tDBG(\"No pending command, waiting ...\");\n\t\treturn;\n\t}\n\n\tswitch (ctrl->pending) {\n\tcase 3:\t\t\t/* STOR */\n\t\tDBG(\"Pending STOR, starting ...\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_STOR, ctrl, ctrl->data_sd, UEV_READ);\n\t\tbreak;\n\n\tcase 2:\t\t\t/* RETR */\n\t\tDBG(\"Pending RETR, starting ...\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_RETR, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\n\tcase 1:\t\t\t/* LIST */\n\t\tDBG(\"Pending LIST, starting ...\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_LIST, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\t}\n\n\tif (ctrl->pending == 1 && ctrl->list_mode == 2)\n\t\tsend_msg(ctrl->sd, \"150 Opening ASCII mode data connection for MLSD.\\r\\n\");\n\telse\n\t\tsend_msg(ctrl->sd, \"150 Data connection accepted; transfer starting.\\r\\n\");\n\tctrl->pending = 0;\n}\n\nstatic int do_PASV(ctrl_t *ctrl, char *arg, struct sockaddr *data, socklen_t *len)\n{\n\tstruct sockaddr_in server;\n\n\tif (ctrl->data_sd > 0) {\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\tif (ctrl->data_listen_sd > 0)\n\t\tclose(ctrl->data_listen_sd);\n\n\tctrl->data_listen_sd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n\tif (ctrl->data_listen_sd < 0) {\n\t\tERR(errno, \"Failed opening data server socket\");\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\treturn 1;\n\t}\n\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family      = AF_INET;\n\tserver.sin_addr.s_addr = inet_addr(ctrl->serveraddr);\n\tserver.sin_port        = htons(0);\n\tif (bind(ctrl->data_listen_sd, (struct sockaddr *)&server, sizeof(server)) < 0) {\n\t\tERR(errno, \"Failed binding to client socket\");\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\treturn 1;\n\t}\n\n\tINFO(\"Data server port estabished.  Waiting for client to connect ...\");\n\tif (listen(ctrl->data_listen_sd, 1) < 0) {\n\t\tERR(errno, \"Client data connection failure\");\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\treturn 1;\n\t}\n\n\tmemset(data, 0, sizeof(*data));\n\tif (-1 == getsockname(ctrl->data_listen_sd, data, len)) {\n\t\tERR(errno, \"Cannot determine our address, need it if client should connect to us\");\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\treturn 1;\n\t}\n\n\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_pasv_connection, ctrl, ctrl->data_listen_sd, UEV_READ);\n\n\treturn 0;\n}\n\nstatic void handle_PASV(ctrl_t *ctrl, char *arg)\n{\n\tstruct sockaddr_in data;\n\tsocklen_t len = sizeof(data);\n\tchar *msg, *p, buf[200];\n\tint port;\n\n\tif (do_PASV(ctrl, arg, (struct sockaddr *)&data, &len))\n\t\treturn;\n\n\t/* Convert server IP address and port to comma separated list */\n\tmsg = strdup(ctrl->serveraddr);\n\tif (!msg) {\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\texit(1);\n\t}\n\tp = msg;\n\twhile ((p = strchr(p, '.')))\n\t\t*p++ = ',';\n\n\tport = ntohs(data.sin_port);\n\tsnprintf(buf, sizeof(buf), \"227 Entering Passive Mode (%s,%d,%d)\\r\\n\",\n\t\t msg, port / 256, port % 256);\n\tsend_msg(ctrl->sd, buf);\n\n\tfree(msg);\n}\n\nstatic void handle_EPSV(ctrl_t *ctrl, char *arg)\n{\n\tstruct sockaddr_in data;\n\tsocklen_t len = sizeof(data);\n\tchar buf[200];\n\n\tif (string_valid(arg) && string_case_compare(arg, \"ALL\")) {\n\t\tsend_msg(ctrl->sd, \"200 Command OK\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (do_PASV(ctrl, arg, (struct sockaddr *)&data, &len))\n\t\treturn;\n\n\tsnprintf(buf, sizeof(buf), \"229 Entering Extended Passive Mode (|||%d|)\\r\\n\", ntohs(data.sin_port));\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic void do_RETR(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tstruct timeval tv;\n\tssize_t bytes;\n\tsize_t num;\n\tchar buf[BUFFER_SIZE];\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tDBG(\"error on data_sd ...\");\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\tif (!ctrl->fp) {\n\t\tDBG(\"no fp for RETR, bailing.\");\n\t\treturn;\n\t}\n\n\tnum = fread(buf, sizeof(char), sizeof(buf), ctrl->fp);\n\tif (!num) {\n\t\tif (feof(ctrl->fp))\n\t\t\tINFO(\"User %s from %s downloaded %s\", ctrl->name, ctrl->clientaddr, ctrl->file);\n\t\telse if (ferror(ctrl->fp))\n\t\t\tERR(0, \"Error while reading %s\", ctrl->file);\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tgettimeofday(&tv, NULL);\n\tif (tv.tv_sec - ctrl->tv.tv_sec > 3) {\n\t\tDBG(\"Sending %zd bytes of %s to %s ...\", num, ctrl->file, ctrl->clientaddr);\n\t\tctrl->tv.tv_sec = tv.tv_sec;\n\t}\n\n\tbytes = send(ctrl->data_sd, buf, num, 0);\n\tif (-1 == bytes) {\n\t\tif (ECONNRESET == errno)\n\t\t\tDBG(\"Connection reset by client.\");\n\t\telse\n\t\t\tERR(errno, \"Failed sending file %s to client\", ctrl->file);\n\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"426 TCP connection was established but then broken!\\r\\n\");\n\t}\n}\n\n/*\n * Check if previous command was PORT, then connect to client and\n * transfer file/listing similar to what's done for PASV conns.\n */\nstatic void do_PORT(ctrl_t *ctrl, int pending)\n{\n\tif (!ctrl->data_address[0]) {\n\t\t/* Check if previous command was PASV */\n\t\tif (ctrl->data_sd == -1 && ctrl->data_listen_sd == -1) {\n\t\t\tif (pending == 1 && ctrl->d_num == -1)\n\t\t\t\tdo_MLST(ctrl);\n\t\t\treturn;\n\t\t}\n\n\t\tctrl->pending = pending;\n\t\treturn;\n\t}\n\n\tif (open_data_connection(ctrl)) {\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"425 TCP connection cannot be established.\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (pending != 1 || ctrl->list_mode != 2)\n\t\tsend_msg(ctrl->sd, \"150 Data connection opened; transfer starting.\\r\\n\");\n\n\tswitch (pending) {\n\tcase 3:\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_STOR, ctrl, ctrl->data_sd, UEV_READ);\n\t\tbreak;\n\n\tcase 2:\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_RETR, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\n\tcase 1:\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_LIST, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\t}\n\n\tctrl->pending = 0;\n}\n\nstatic void handle_RETR(ctrl_t *ctrl, char *file)\n{\n\tFILE *fp;\n\tchar *path;\n\tstruct stat st;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path || stat(path, &st) || !S_ISREG(st.st_mode)) {\n\t\tsend_msg(ctrl->sd, \"550 Not a regular file.\\r\\n\");\n\t\treturn;\n\t}\n\n\tfp = fopen(path, \"rb\");\n\tif (!fp) {\n\t\tif (errno != ENOENT)\n\t\t\tERR(errno, \"Failed RETR %s for %s\", path, ctrl->clientaddr);\n\t\tsend_msg(ctrl->sd, \"451 Trouble to RETR file.\\r\\n\");\n\t\treturn;\n\t}\n\n\tctrl->fp = fp;\n\tctrl->file = strdup(file);\n\n\tif (ctrl->data_sd > -1) {\n\t\tif (ctrl->offset) {\n\t\t\tDBG(\"Previous REST %ld of file size %ld\", ctrl->offset, st.st_size);\n\t\t\tif (fseek(fp, ctrl->offset, SEEK_SET)) {\n\t\t\t\tdo_abort(ctrl);\n\t\t\t\tsend_msg(ctrl->sd, \"551 Failed seeking to that position in file.\\r\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsend_msg(ctrl->sd, \"125 Data connection already open; transfer starting.\\r\\n\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_RETR, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\treturn;\n\t}\n\n\tdo_PORT(ctrl, 2);\n}\n\nstatic void handle_MDTM(ctrl_t *ctrl, char *file)\n{\n\tstruct stat st;\n\tstruct tm *tm;\n\tchar *path, *ptr;\n\tchar *mtime = NULL;\n\tchar buf[80];\n\n\t/* Request to set mtime, ncftp does this */\n\tptr = strchr(file, ' ');\n\tif (ptr) {\n\t\t*ptr++ = 0;\n\t\tmtime = file;\n\t\tfile  = ptr;\n\t}\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path || stat(path, &st) || !S_ISREG(st.st_mode)) {\n\t\tsend_msg(ctrl->sd, \"550 Not a regular file.\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (mtime) {\n\t\tstruct timespec times[2] = {\n\t\t\t{ 0, UTIME_OMIT },\n\t\t\t{ 0, 0 }\n\t\t};\n\t\tstruct tm tm;\n\t\tint rc;\n\n\t\tif (!strptime(mtime, \"%Y%m%d%H%M%S\", &tm)) {\n\t\tfail:\n\t\t\tsend_msg(ctrl->sd, \"550 Invalid time format\\r\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\ttimes[1].tv_sec = mktime(&tm);\n\t\trc = utimensat(0, path, times, 0);\n\t\tif (rc) {\n\t\t\tERR(errno, \"Failed setting MTIME %s of %s\", mtime, file);\n\t\t\tgoto fail;\n\t\t}\n\t\t(void)stat(path, &st);\n\t}\n\n\ttm = gmtime(&st.st_mtime);\n\tstrftime(buf, sizeof(buf), \"213 %Y%m%d%H%M%S\\r\\n\", tm);\n\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic void do_STOR(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tstruct timeval tv;\n\tssize_t bytes;\n\tsize_t num;\n\tchar buf[BUFFER_SIZE];\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tDBG(\"error on data_sd ...\");\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\tif (!ctrl->fp) {\n\t\tDBG(\"no fp for STOR, bailing.\");\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tbytes = recv(ctrl->data_sd, buf, sizeof(buf), 0);\n\tif (bytes < 0) {\n\t\tif (ECONNRESET == errno)\n\t\t\tDBG(\"Connection reset by client.\");\n\t\telse\n\t\t\tERR(errno, \"Failed receiving file %s from client\", ctrl->file);\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"426 TCP connection was established but then broken!\\r\\n\");\n\t\treturn;\n\t}\n\tif (bytes == 0) {\n\t\tINFO(\"User %s at %s uploaded file %s\", ctrl->name, ctrl->clientaddr, ctrl->file);\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n\t\treturn;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\tif (tv.tv_sec - ctrl->tv.tv_sec > 3) {\n\t\tDBG(\"Receiving %zd bytes of %s from %s ...\", bytes, ctrl->file, ctrl->clientaddr);\n\t\tctrl->tv.tv_sec = tv.tv_sec;\n\t}\n\n\tnum = fwrite(buf, 1, bytes, ctrl->fp);\n\tif ((size_t)bytes != num)\n\t\tERR(errno, \"552 Disk full.\");\n}\n\nstatic void handle_STOR(ctrl_t *ctrl, char *file)\n{\n\tFILE *fp = NULL;\n\tchar *path;\n\tint rc = 0;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path) {\n\t\tINFO(\"Invalid path for %s: %m\", file);\n\t\tgoto fail;\n\t}\n\n\tDBG(\"Trying to write to %s ...\", path);\n\tfp = fopen(path, \"wb\");\n\tif (!fp) {\n\t\t/* If EACCESS client is trying to do something disallowed */\n\t\tERR(errno, \"Failed writing %s\", path);\n\tfail:\n\t\tsend_msg(ctrl->sd, \"451 Trouble storing file.\\r\\n\");\n\t\tdo_abort(ctrl);\n\t\treturn;\n\t}\n\n\tctrl->fp = fp;\n\tctrl->file = strdup(file);\n\n\tif (ctrl->data_sd > -1) {\n\t\tif (ctrl->offset)\n\t\t\trc = fseek(fp, ctrl->offset, SEEK_SET);\n\t\tif (rc) {\n\t\t\tdo_abort(ctrl);\n\t\t\tsend_msg(ctrl->sd, \"551 Failed seeking to that position in file.\\r\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tsend_msg(ctrl->sd, \"125 Data connection already open; transfer starting.\\r\\n\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_STOR, ctrl, ctrl->data_sd, UEV_READ);\n\t\treturn;\n\t}\n\n\tdo_PORT(ctrl, 3);\n}\n\nstatic void handle_DELE(ctrl_t *ctrl, char *file)\n{\n\tchar *path;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path) {\n\t\tERR(errno, \"Cannot find %s\", file);\n\t\tgoto fail;\n\t}\n\n\tif (remove(path)) {\n\t\tif (ENOENT == errno)\n\t\tfail:\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\telse if (EPERM == errno)\n\t\t\tsend_msg(ctrl->sd, \"550 Not allowed to remove file or directory.\\r\\n\");\n\t\telse\n\t\t\tsend_msg(ctrl->sd, \"550 Unknown error.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsend_msg(ctrl->sd, \"200 Command OK\\r\\n\");\n}\n\nstatic void handle_MKD(ctrl_t *ctrl, char *arg)\n{\n\tchar *path;\n\n\tpath = compose_abspath(ctrl, arg);\n\tif (!path) {\n\t\tINFO(\"Invalid path for %s: %m\", arg);\n\t\tgoto fail;\n\t}\n\n\tif (mkdir(path, 0755)) {\n\t\tif (EPERM == errno)\n\t\tfail:\tsend_msg(ctrl->sd, \"550 Not allowed to create directory.\\r\\n\");\n\t\telse\n\t\t\tsend_msg(ctrl->sd, \"550 Unknown error.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsend_msg(ctrl->sd, \"200 Command OK\\r\\n\");\n}\n\nstatic void handle_RMD(ctrl_t *ctrl, char *arg)\n{\n\thandle_DELE(ctrl, arg);\n}\n\nstatic void handle_REST(ctrl_t *ctrl, char *arg)\n{\n\tconst char *errstr;\n\tchar buf[80];\n\n\tif (!string_valid(arg)) {\n\t\tsend_msg(ctrl->sd, \"550 Invalid argument.\\r\\n\");\n\t\treturn;\n\t}\n\n\tctrl->offset = strtonum(arg, 0, INT64_MAX, &errstr);\n\tsnprintf(buf, sizeof(buf), \"350 Restarting at %ld.  Send STOR or RETR to continue transfer.\\r\\n\", ctrl->offset);\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic size_t num_nl(char *file)\n{\n\tFILE *fp;\n\tchar buf[80];\n\tsize_t len, num = 0;\n\n\tfp = fopen(file, \"r\");\n\tif (!fp)\n\t\treturn 0;\n\n\tdo {\n\t\tchar *ptr = buf;\n\n\t\tlen = fread(buf, sizeof(char), sizeof(buf) - 1, fp);\n\t\tif (len > 0) {\n\t\t\tbuf[len] = 0;\n\t\t\twhile ((ptr = strchr(ptr, '\\n'))) {\n\t\t\t\tptr++;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t} while (len > 0);\n\tfclose(fp);\n\n\treturn num;\n}\n\nstatic void handle_SIZE(ctrl_t *ctrl, char *file)\n{\n\tchar *path;\n\tchar buf[80];\n\tsize_t extralen = 0;\n\tstruct stat st;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path || stat(path, &st) || S_ISDIR(st.st_mode)) {\n\t\tsend_msg(ctrl->sd, \"550 No such file, or argument is a directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tDBG(\"SIZE %s\", path);\n\n\tif (ctrl->type == TYPE_A)\n\t\textralen = num_nl(path);\n\n\tsnprintf(buf, sizeof(buf), \"213 %\"  PRIu64 \"\\r\\n\", (uint64_t)(st.st_size + extralen));\n\tsend_msg(ctrl->sd, buf);\n}\n\n/* No operation - used as session keepalive by clients. */\nstatic void handle_NOOP(ctrl_t *ctrl, char *arg)\n{\n\tsend_msg(ctrl->sd, \"200 NOOP OK.\\r\\n\");\n}\n\n#if 0\nstatic void handle_RNFR(ctrl_t *ctrl, char *arg)\n{\n}\n\nstatic void handle_RNTO(ctrl_t *ctrl, char *arg)\n{\n}\n#endif\n\nstatic void handle_QUIT(ctrl_t *ctrl, char *arg)\n{\n\tsend_msg(ctrl->sd, \"221 Goodbye.\\r\\n\");\n\tuev_exit(ctrl->ctx);\n}\n\nstatic void handle_CLNT(ctrl_t *ctrl, char *arg)\n{\n\tsend_msg(ctrl->sd, \"200 CLNT\\r\\n\");\n}\n\nstatic void handle_OPTS(ctrl_t *ctrl, char *arg)\n{\n\t/* OPTS MLST type;size;modify;perm; */\n\tif (strstr(arg, \"MLST\")) {\n\t\tsize_t i = 0;\n\t\tchar *ptr;\n\t\tchar buf[42] = \"200 MLST OPTS \";\n\t\tchar facts[10] = { 0 };\n\n\t\tptr = strtok(arg + 4, \" \\t;\");\n\t\twhile (ptr && i < sizeof(facts) - 1) {\n\t\t\tif (!strcmp(ptr, \"modify\") ||\n\t\t\t    !strcmp(ptr, \"perm\")   ||\n\t\t\t    !strcmp(ptr, \"size\")   ||\n\t\t\t    !strcmp(ptr, \"type\")) {\n\t\t\t\tfacts[i++] = ptr[0];\n\t\t\t\tstrlcat(buf, ptr, sizeof(buf));\n\t\t\t\tstrlcat(buf, \";\", sizeof(buf));\n\t\t\t}\n\n\t\t\tptr = strtok(NULL, \";\");\n\t\t}\n\t\tstrlcat(buf, \"\\r\\n\", sizeof(buf));\n\n\t\tDBG(\"New MLSD facts: %s\", facts);\n\t\tstrlcpy(ctrl->facts, facts, sizeof(ctrl->facts));\n\t\tsend_msg(ctrl->sd, buf);\n\t} else\n\t\tsend_msg(ctrl->sd, \"200 UTF8 OPTS ON\\r\\n\");\n}\n\nstatic void handle_HELP(ctrl_t *ctrl, char *arg)\n{\n\tint i = 0;\n\tchar buf[80];\n\tftp_cmd_t *cmd;\n\n\tif (string_valid(arg) && !string_compare(arg, \"SITE\")) {\n\t\tsend_msg(ctrl->sd, \"500 command HELP does not take any arguments on this server.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsnprintf(ctrl->buf, ctrl->bufsz, \"214-The following commands are recognized.\");\n\tfor (cmd = &supported[0]; cmd->command; cmd++, i++) {\n\t\tif (i % 14 == 0)\n\t\t\tstrlcat(ctrl->buf, \"\\r\\n\", ctrl->bufsz);\n\t\tsnprintf(buf, sizeof(buf), \" %s\", cmd->command);\n\t\tstrlcat(ctrl->buf, buf, ctrl->bufsz);\n\t}\n\tsnprintf(buf, sizeof(buf), \"\\r\\n214 Help OK.\\r\\n\");\n\tstrlcat(ctrl->buf, buf, ctrl->bufsz);\n\n\tsend_msg(ctrl->sd, ctrl->buf);\n}\n\nstatic void handle_FEAT(ctrl_t *ctrl, char *arg)\n{\n\tsnprintf(ctrl->buf, ctrl->bufsz, \"211-Features:\\r\\n\"\n\t\t \" EPSV\\r\\n\"\n\t\t \" PASV\\r\\n\"\n\t\t \" SIZE\\r\\n\"\n\t\t \" UTF8\\r\\n\"\n\t\t \" REST STREAM\\r\\n\"\n\t\t \" MLST modify*;perm*;size*;type*;\\r\\n\"\n\t\t \"211 End\\r\\n\");\n\tsend_msg(ctrl->sd, ctrl->buf);\n}\n\nstatic void handle_UNKNOWN(ctrl_t *ctrl, char *command)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"500 command '%s' not recognized by server.\\r\\n\", command);\n\tsend_msg(ctrl->sd, buf);\n}\n\n#define COMMAND(NAME) { #NAME, handle_ ## NAME }\n\nstatic ftp_cmd_t supported[] = {\n\tCOMMAND(ABOR),\n\tCOMMAND(DELE),\n\tCOMMAND(USER),\n\tCOMMAND(PASS),\n\tCOMMAND(SYST),\n\tCOMMAND(TYPE),\n\tCOMMAND(PORT),\n\tCOMMAND(EPRT),\n\tCOMMAND(RETR),\n\tCOMMAND(MKD),\n\tCOMMAND(RMD),\n\tCOMMAND(REST),\n\tCOMMAND(MDTM),\n\tCOMMAND(PASV),\n\tCOMMAND(EPSV),\n\tCOMMAND(QUIT),\n\tCOMMAND(LIST),\n\tCOMMAND(NLST),\n\tCOMMAND(MLST),\n\tCOMMAND(MLSD),\n\tCOMMAND(CLNT),\n\tCOMMAND(OPTS),\n\tCOMMAND(PWD),\n\tCOMMAND(STOR),\n\tCOMMAND(CWD),\n\tCOMMAND(CDUP),\n\tCOMMAND(SIZE),\n\tCOMMAND(NOOP),\n\tCOMMAND(HELP),\n\tCOMMAND(FEAT),\n\t{ NULL, NULL }\n};\n\nstatic void child_exit(uev_t *w, void *arg, int events)\n{\n\tDBG(\"Child exiting ...\");\n\tuev_exit(w->ctx);\n}\n\nstatic void read_client_command(uev_t *w, void *arg, int events)\n{\n\tchar *command, *argument;\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tftp_cmd_t *cmd;\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tif (recv_msg(w->fd, ctrl->buf, ctrl->bufsz, &command, &argument)) {\n\t\tDBG(\"Short read, exiting.\");\n\t\tuev_exit(ctrl->ctx);\n\t\treturn;\n\t}\n\n\tif (!string_valid(command))\n\t\treturn;\n\n\tif (string_match(command, \"FF F4\")) {\n\t\tDBG(\"Ignoring IAC command, client should send ABOR as well.\");\n\t\treturn;\n\t}\n\n\tfor (cmd = &supported[0]; cmd->command; cmd++) {\n\t\tif (string_compare(command, cmd->command)) {\n\t\t\tcmd->cb(ctrl, argument);\n\t\t\treturn;\n\t\t}\n\t}\n\n\thandle_UNKNOWN(ctrl, command);\n}\n\nstatic void ftp_command(ctrl_t *ctrl)\n{\n\tuev_t sigterm_watcher;\n\n\tctrl->bufsz = BUFFER_SIZE * sizeof(char);\n\tctrl->buf   = malloc(ctrl->bufsz);\n\tif (!ctrl->buf) {\n                WARN(errno, \"FTP session failed allocating buffer\");\n                exit(1);\n\t}\n\n\tsnprintf(ctrl->buf, ctrl->bufsz, \"220 %s (%s) ready.\\r\\n\", prognm, VERSION);\n\tsend_msg(ctrl->sd, ctrl->buf);\n\n\tuev_signal_init(ctrl->ctx, &sigterm_watcher, child_exit, NULL, SIGTERM);\n\tuev_io_init(ctrl->ctx, &ctrl->io_watcher, read_client_command, ctrl, ctrl->sd, UEV_READ);\n\tuev_run(ctrl->ctx, 0);\n}\n\nint ftp_session(uev_ctx_t *ctx, int sd)\n{\n\tint pid = 0;\n\tctrl_t *ctrl;\n\tsocklen_t len;\n\n\tctrl = new_session(ctx, sd, &pid);\n\tif (!ctrl) {\n\t\tif (pid < 0) {\n\t\t\tshutdown(sd, SHUT_RDWR);\n\t\t\tclose(sd);\n\t\t}\n\n\t\treturn pid;\n\t}\n\n\tlen = sizeof(ctrl->server_sa);\n\tif (-1 == getsockname(sd, (struct sockaddr *)&ctrl->server_sa, &len)) {\n\t\tERR(errno, \"Cannot determine our address\");\n\t\tgoto fail;\n\t}\n\tconvert_address(&ctrl->server_sa, ctrl->serveraddr, sizeof(ctrl->serveraddr));\n\n\tlen = sizeof(ctrl->client_sa);\n\tif (-1 == getpeername(sd, (struct sockaddr *)&ctrl->client_sa, &len)) {\n\t\tERR(errno, \"Cannot determine client address\");\n\t\tgoto fail;\n\t}\n\tconvert_address(&ctrl->client_sa, ctrl->clientaddr, sizeof(ctrl->clientaddr));\n\n\tctrl->type = TYPE_A;\n\tctrl->data_listen_sd = -1;\n\tctrl->data_sd = -1;\n\tctrl->name[0] = 0;\n\tctrl->pass[0] = 0;\n\tctrl->data_address[0] = 0;\n\tstrlcpy(ctrl->facts, \"mpst\", sizeof(ctrl->facts));\n\n\tINFO(\"Client connection from %s\", ctrl->clientaddr);\n\tftp_command(ctrl);\n\n\tDBG(\"Client exiting, bye\");\n\texit(del_session(ctrl, 1));\nfail:\n\tfree(ctrl);\n\tshutdown(sd, SHUT_RDWR);\n\tclose(sd);\n\n\treturn -1;\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "fixing_code": ["/* FTP engine\n *\n * Copyright (c) 2014-2019  Joachim Nilsson <troglobit@gmail.com>\n *\n * Permission to use, copy, modify, and/or distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"uftpd.h\"\n#include <ctype.h>\n#include <arpa/ftp.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\ntypedef struct {\n\tchar *command;\n\tvoid (*cb)(ctrl_t *ctr, char *arg);\n} ftp_cmd_t;\n\nstatic ftp_cmd_t supported[];\n\nstatic void do_PORT(ctrl_t *ctrl, int pending);\nstatic void do_LIST(uev_t *w, void *arg, int events);\nstatic void do_RETR(uev_t *w, void *arg, int events);\nstatic void do_STOR(uev_t *w, void *arg, int events);\n\nstatic int is_cont(char *msg)\n{\n\tchar *ptr;\n\n\tptr = strchr(msg, '\\r');\n\tif (ptr) {\n\t\tptr++;\n\t\tif (strchr(ptr, '\\r'))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int send_msg(int sd, char *msg)\n{\n\tint n = 0;\n\tint l;\n\n\tif (!msg) {\n\terr:\n\t\tERR(EINVAL, \"Missing argument to send_msg()\");\n\t\treturn 1;\n\t}\n\n\tl = strlen(msg);\n\tif (l <= 0)\n\t\tgoto err;\n\n\twhile (n < l) {\n\t\tint result = send(sd, msg + n, l, 0);\n\n\t\tif (result < 0) {\n\t\t\tERR(errno, \"Failed sending message to client\");\n\t\t\treturn 1;\n\t\t}\n\n\t\tn += result;\n\t}\n\n\tDBG(\"Sent: %s%s\", is_cont(msg) ? \"\\n\" : \"\", msg);\n\n\treturn 0;\n}\n\n/*\n * Receive message from client, split into command and argument\n */\nstatic int recv_msg(int sd, char *msg, size_t len, char **cmd, char **argument)\n{\n\tchar *ptr;\n\tssize_t bytes;\n\tuint8_t *raw = (uint8_t *)msg;\n\n\t/* Clear for every new command. */\n\tmemset(msg, 0, len);\n\n\t/* Save one byte (-1) for NUL termination */\n\tbytes = recv(sd, msg, len - 1, 0);\n\tif (bytes < 0) {\n\t\tif (EINTR == errno)\n\t\t\treturn 1;\n\n\t\tif (ECONNRESET == errno)\n\t\t\tDBG(\"Connection reset by client.\");\n\t\telse\n\t\t\tERR(errno, \"Failed reading client command\");\n\t\treturn 1;\n\t}\n\n\tif (!bytes) {\n\t\tINFO(\"Client disconnected.\");\n\t\treturn 1;\n\t}\n\n\tif (raw[0] == 0xff) {\n\t\tchar tmp[4];\n\t\tchar buf[20] = { 0 };\n\t\tint i;\n\n\t\ti = recv(sd, &msg[bytes], len - bytes - 1, MSG_OOB | MSG_DONTWAIT);\n\t\tif (i > 0)\n\t\t\tbytes += i;\n\n\t\tfor (i = 0; i < bytes; i++) {\n\t\t\tsnprintf(tmp, sizeof(tmp), \"%2X%s\", raw[i], i + 1 < bytes ? \" \" : \"\");\n\t\t\tstrlcat(buf, tmp, sizeof(buf));\n\t\t}\n\n\t\tstrlcpy(msg, buf, len);\n\t\t*cmd      = msg;\n\t\t*argument = NULL;\n\n\t\tDBG(\"Recv: [%s], %zd bytes\", msg, bytes);\n\n\t\treturn 0;\n\t}\n\n\t/* NUL terminate for strpbrk() */\n\tmsg[bytes] = 0;\n\n\t*cmd = msg;\n\tptr  = strpbrk(msg, \" \");\n\tif (ptr) {\n\t\t*ptr = 0;\n\t\tptr++;\n\t\t*argument = ptr;\n\t} else {\n\t\t*argument = NULL;\n\t\tptr = msg;\n\t}\n\n\tptr = strpbrk(ptr, \"\\r\\n\");\n\tif (ptr)\n\t\t*ptr = 0;\n\n\t/* Convert command to std ftp upper case, issue #18 */\n\tfor (ptr = msg; *ptr; ++ptr) *ptr = toupper(*ptr);\n\n\tDBG(\"Recv: %s %s\", *cmd, *argument ?: \"\");\n\n\treturn 0;\n}\n\nstatic int open_data_connection(ctrl_t *ctrl)\n{\n\tsocklen_t len = sizeof(struct sockaddr);\n\tstruct sockaddr_in sin;\n\n\t/* Previous PORT command from client */\n\tif (ctrl->data_address[0]) {\n\t\tint rc;\n\n\t\tctrl->data_sd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n\t\tif (-1 == ctrl->data_sd) {\n\t\t\tERR(errno, \"Failed creating data socket\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tmemset(&sin, 0, sizeof(sin));\n\t\tsin.sin_family = AF_INET;\n\t\tsin.sin_port = htons(ctrl->data_port);\n\t\tinet_aton(ctrl->data_address, &(sin.sin_addr));\n\n\t\trc = connect(ctrl->data_sd, (struct sockaddr *)&sin, len);\n\t\tif (rc == -1 && EINPROGRESS != errno) {\n\t\t\tERR(errno, \"Failed connecting data socket to client\");\n\t\t\tclose(ctrl->data_sd);\n\t\t\tctrl->data_sd = -1;\n\n\t\t\treturn -1;\n\t\t}\n\n\t\tDBG(\"Connected successfully to client's previously requested address:PORT %s:%d\",\n\t\t    ctrl->data_address, ctrl->data_port);\n\t\treturn 0;\n\t}\n\n\t/* Previous PASV command, accept connect from client */\n\tif (ctrl->data_listen_sd > 0) {\n\t\tconst int const_int_1 = 1;\n\t\tint retries = 3;\n\t\tchar client_ip[100];\n\n\tretry:\n\t\tctrl->data_sd = accept(ctrl->data_listen_sd, (struct sockaddr *)&sin, &len);\n\t\tif (-1 == ctrl->data_sd) {\n\t\t\tif (EAGAIN == errno && --retries) {\n\t\t\t\tsleep(1);\n\t\t\t\tgoto retry;\n\t\t\t}\n\n\t\t\tERR(errno, \"Failed accepting connection from client\");\n\t\t\treturn -1;\n\t\t}\n\n\t\tsetsockopt(ctrl->data_sd, SOL_SOCKET, SO_KEEPALIVE, &const_int_1, sizeof(const_int_1));\n\t\tset_nonblock(ctrl->data_sd);\n\n\t\tinet_ntop(AF_INET, &(sin.sin_addr), client_ip, INET_ADDRSTRLEN);\n\t\tDBG(\"Client PASV data connection from %s:%d\", client_ip, ntohs(sin.sin_port));\n\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t}\n\n\treturn 0;\n}\n\nstatic int close_data_connection(ctrl_t *ctrl)\n{\n\tint ret = 0;\n\n\tDBG(\"Closing data connection ...\");\n\n\t/* PASV server listening socket */\n\tif (ctrl->data_listen_sd > 0) {\n\t\tshutdown(ctrl->data_listen_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\tret++;\n\t}\n\n\t/* PASV client socket */\n\tif (ctrl->data_sd > 0) {\n\t\tshutdown(ctrl->data_sd, SHUT_RDWR);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t\tret++;\n\t}\n\n\t/* PORT */\n\tif (ctrl->data_address[0]) {\n\t\tctrl->data_address[0] = 0;\n\t\tctrl->data_port = 0;\n\t}\n\n\treturn ret;\n}\n\nstatic int check_user_pass(ctrl_t *ctrl)\n{\n\tif (!ctrl->name[0])\n\t\treturn -1;\n\n\tif (!strcmp(\"anonymous\", ctrl->name))\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic int do_abort(ctrl_t *ctrl)\n{\n\tif (ctrl->d || ctrl->d_num) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tif (ctrl->d_num > 0)\n\t\t\tfree(ctrl->d);\n\t\tctrl->d_num = 0;\n\t\tctrl->d = NULL;\n\t\tctrl->i = 0;\n\n\t\tif (ctrl->file)\n\t\t\tfree(ctrl->file);\n\t\tctrl->file = NULL;\n\t}\n\n\tif (ctrl->file) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tfree(ctrl->file);\n\t\tctrl->file = NULL;\n\t}\n\n\tif (ctrl->fp) {\n\t\tfclose(ctrl->fp);\n\t\tctrl->fp = NULL;\n\t}\n\n\tctrl->pending = 0;\n\tctrl->offset = 0;\n\n\treturn close_data_connection(ctrl);\n}\n\nstatic void handle_ABOR(ctrl_t *ctrl, char *arg)\n{\n\tDBG(\"Aborting any current transfer ...\");\n\tif (do_abort(ctrl))\n\t\tsend_msg(ctrl->sd, \"426 Connection closed; transfer aborted.\\r\\n\");\n\n\tsend_msg(ctrl->sd, \"226 Closing data connection.\\r\\n\");\n}\n\nstatic void handle_USER(ctrl_t *ctrl, char *name)\n{\n\tif (ctrl->name[0]) {\n\t\tctrl->name[0] = 0;\n\t\tctrl->pass[0] = 0;\n\t}\n\n\tif (name) {\n\t\tstrlcpy(ctrl->name, name, sizeof(ctrl->name));\n\t\tif (check_user_pass(ctrl) == 1) {\n\t\t\tINFO(\"Guest logged in from %s\", ctrl->clientaddr);\n\t\t\tsend_msg(ctrl->sd, \"230 Guest login OK, access restrictions apply.\\r\\n\");\n\t\t} else {\n\t\t\tsend_msg(ctrl->sd, \"331 Login OK, please enter password.\\r\\n\");\n\t\t}\n\t} else {\n\t\tsend_msg(ctrl->sd, \"530 You must input your name.\\r\\n\");\n\t}\n}\n\nstatic void handle_PASS(ctrl_t *ctrl, char *pass)\n{\n\tif (!ctrl->name[0]) {\n\t\tsend_msg(ctrl->sd, \"503 No username given.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->pass, pass, sizeof(ctrl->pass));\n\tif (check_user_pass(ctrl) < 0) {\n\t\tLOG(\"User %s from %s, invalid password!\", ctrl->name, ctrl->clientaddr);\n\t\tsend_msg(ctrl->sd, \"530 username or password is unacceptable\\r\\n\");\n\t\treturn;\n\t}\n\n\tINFO(\"User %s login from %s\", ctrl->name, ctrl->clientaddr);\n\tsend_msg(ctrl->sd, \"230 Guest login OK, access restrictions apply.\\r\\n\");\n}\n\nstatic void handle_SYST(ctrl_t *ctrl, char *arg)\n{\n\tchar system[] = \"215 UNIX Type: L8\\r\\n\";\n\n\tsend_msg(ctrl->sd, system);\n}\n\nstatic void handle_TYPE(ctrl_t *ctrl, char *argument)\n{\n\tchar type[24]  = \"200 Type set to I.\\r\\n\";\n\tchar unknown[] = \"501 Invalid argument to TYPE.\\r\\n\";\n\n\tif (!argument)\n\t\targument = \"Z\";\n\n\tswitch (argument[0]) {\n\tcase 'A':\n\t\tctrl->type = TYPE_A; /* ASCII */\n\t\tbreak;\n\n\tcase 'I':\n\t\tctrl->type = TYPE_I; /* IMAGE/BINARY */\n\t\tbreak;\n\n\tdefault:\n\t\tsend_msg(ctrl->sd, unknown);\n\t\treturn;\n\t}\n\n\ttype[16] = argument[0];\n\tsend_msg(ctrl->sd, type);\n}\n\nstatic void handle_PWD(ctrl_t *ctrl, char *arg)\n{\n\tchar buf[sizeof(ctrl->cwd) + 10];\n\n\tsnprintf(buf, sizeof(buf), \"257 \\\"%s\\\"\\r\\n\", ctrl->cwd);\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic void handle_CWD(ctrl_t *ctrl, char *path)\n{\n\tstruct stat st;\n\tchar *dir;\n\n\tif (!path)\n\t\tgoto done;\n\n\t/*\n\t * Some FTP clients, most notably Chrome, use CWD to check if an\n\t * entry is a file or directory.\n\t */\n\tdir = compose_abspath(ctrl, path);\n\tif (!dir || stat(dir, &st) || !S_ISDIR(st.st_mode)) {\n\t\tDBG(\"chrooted:%d, ctrl->cwd: %s, home:%s, dir:%s, len:%zd, dirlen:%zd\",\n\t\t    chrooted, ctrl->cwd, home, dir, strlen(home), strlen(dir));\n\t\tsend_msg(ctrl->sd, \"550 No such directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (!chrooted) {\n\t\tsize_t len = strlen(home);\n\n\t\tDBG(\"non-chrooted CWD, home:%s, dir:%s, len:%zd, dirlen:%zd\",\n\t\t    home, dir, len, strlen(dir));\n\t\tdir += len;\n\t}\n\n\tsnprintf(ctrl->cwd, sizeof(ctrl->cwd), \"%s\", dir);\n\tif (ctrl->cwd[0] == 0)\n\t\tsnprintf(ctrl->cwd, sizeof(ctrl->cwd), \"/\");\n\ndone:\n\tDBG(\"New CWD: '%s'\", ctrl->cwd);\n\tsend_msg(ctrl->sd, \"250 OK\\r\\n\");\n}\n\nstatic void handle_CDUP(ctrl_t *ctrl, char *path)\n{\n\thandle_CWD(ctrl, \"..\");\n}\n\nstatic void handle_PORT(ctrl_t *ctrl, char *str)\n{\n\tint a, b, c, d, e, f;\n\tchar addr[INET_ADDRSTRLEN];\n\tstruct sockaddr_in sin;\n\n\tif (ctrl->data_sd > 0) {\n\t\tuev_io_stop(&ctrl->data_watcher);\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\t/* Convert PORT command's argument to IP address + port */\n\tsscanf(str, \"%d,%d,%d,%d,%d,%d\", &a, &b, &c, &d, &e, &f);\n\tsnprintf(addr, sizeof(addr), \"%d.%d.%d.%d\", a, b, c, d);\n\n\t/* Check IPv4 address using inet_aton(), throw away converted result */\n\tif (!inet_aton(addr, &(sin.sin_addr))) {\n\t\tERR(0, \"Invalid address '%s' given to PORT command\", addr);\n\t\tsend_msg(ctrl->sd, \"500 Illegal PORT command.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcpy(ctrl->data_address, addr, sizeof(ctrl->data_address));\n\tctrl->data_port = e * 256 + f;\n\n\tDBG(\"Client PORT command accepted for %s:%d\", ctrl->data_address, ctrl->data_port);\n\tsend_msg(ctrl->sd, \"200 PORT command successful.\\r\\n\");\n}\n\nstatic void handle_EPRT(ctrl_t *ctrl, char *str)\n{\n\tsend_msg(ctrl->sd, \"502 Command not implemented.\\r\\n\");\n}\n\nstatic char *mode_to_str(mode_t m)\n{\n\tstatic char str[11];\n\n\tsnprintf(str, sizeof(str), \"%c%c%c%c%c%c%c%c%c%c\",\n\t\t S_ISDIR(m)  ? 'd' : '-',\n\t\t m & S_IRUSR ? 'r' : '-',\n\t\t m & S_IWUSR ? 'w' : '-',\n\t\t m & S_IXUSR ? 'x' : '-',\n\t\t m & S_IRGRP ? 'r' : '-',\n\t\t m & S_IWGRP ? 'w' : '-',\n\t\t m & S_IXGRP ? 'x' : '-',\n\t\t m & S_IROTH ? 'r' : '-',\n\t\t m & S_IWOTH ? 'w' : '-',\n\t\t m & S_IXOTH ? 'x' : '-');\n\n\treturn str;\n}\n\nstatic char *time_to_str(time_t mtime)\n{\n\tstruct tm *t = localtime(&mtime);\n\tstatic char str[20];\n\n\tsetlocale(LC_TIME, \"C\");\n\tstrftime(str, sizeof(str), \"%b %e %H:%M\", t);\n\n\treturn str;\n}\n\nstatic char *mlsd_time(time_t mtime)\n{\n\tstruct tm *t = localtime(&mtime);\n\tstatic char str[20];\n\n\tstrftime(str, sizeof(str), \"%Y%m%d%H%M%S\", t);\n\n\treturn str;\n}\n\nstatic const char *mlsd_type(char *name, int mode)\n{\n\tif (!strcmp(name, \".\"))\n\t\treturn \"cdir\";\n\tif (!strcmp(name, \"..\"))\n\t\treturn \"pdir\";\n\n\treturn S_ISDIR(mode) ? \"dir\" : \"file\";\n}\n\nvoid mlsd_fact(char fact, char *buf, size_t len, char *name, char *perms, struct stat *st)\n{\n\tchar size[20];\n\n\tswitch (fact) {\n\tcase 'm':\n\t\tstrlcat(buf, \"modify=\", len);\n\t\tstrlcat(buf, mlsd_time(st->st_mtime), len);\n\t\tbreak;\n\n\tcase 'p':\n\t\tstrlcat(buf, \"perm=\", len);\n\t\tstrlcat(buf, perms, len);\n\t\tbreak;\n\n\tcase 't':\n\t\tstrlcat(buf, \"type=\", len);\n\t\tstrlcat(buf, mlsd_type(name, st->st_mode), len);\n\t\tbreak;\n\n\n\tcase 's':\n\t\tif (S_ISDIR(st->st_mode))\n\t\t\treturn;\n\t\tsnprintf(size, sizeof(size), \"size=%\" PRIu64, st->st_size);\n\t\tstrlcat(buf, size, len);\n\t\tbreak;\n\n\tdefault:\n\t\treturn;\n\t}\n\n\tstrlcat(buf, \";\", len);\n}\n\nstatic void mlsd_printf(ctrl_t *ctrl, char *buf, size_t len, char *path, char *name, struct stat *st)\n{\n\tchar perms[10] = \"\";\n\tint ro = !access(path, R_OK);\n\tint rw = !access(path, W_OK);\n\n\tif (S_ISDIR(st->st_mode)) {\n\t\t/* XXX: Verify 'e' by checking that we can CD to the 'name' */\n\t\tif (ro)\n\t\t\tstrlcat(perms, \"le\", sizeof(perms));\n\t\tif (rw)\n\t\t\tstrlcat(perms, \"pc\", sizeof(perms)); /* 'd' RMD, 'm' MKD */\n\t} else {\n\t\tif (ro)\n\t\t\tstrlcat(perms, \"r\", sizeof(perms));\n\t\tif (rw)\n\t\t\tstrlcat(perms, \"w\", sizeof(perms)); /* 'f' RNFR, 'd' DELE */\n\t}\n\n\tmemset(buf, 0, len);\n\tif (ctrl->d_num == -1 && (ctrl->list_mode & 0x0F) == 2)\n\t\tstrlcat(buf, \" \", len);\n\n\tfor (int i = 0; ctrl->facts[i]; i++)\n\t\tmlsd_fact(ctrl->facts[i], buf, len, name, perms, st);\n\n\tstrlcat(buf, \" \", len);\n\tstrlcat(buf, name, len);\n\tstrlcat(buf, \"\\r\\n\", len);\n}\n\nstatic int list_printf(ctrl_t *ctrl, char *buf, size_t len, char *path, char *name)\n{\n\tint dirs;\n\tint mode = ctrl->list_mode;\n\tstruct stat st;\n\n\tif (stat(path, &st))\n\t\treturn -1;\n\n\tdirs = mode & 0xF0;\n\tmode = mode & 0x0F;\n\n\tif (dirs && !S_ISDIR(st.st_mode))\n\t\treturn 1;\n\tif (!dirs && S_ISDIR(st.st_mode))\n\t\treturn 1;\n\n\tswitch (mode) {\n\tcase 3:\t\t\t/* MLSD */\n\t\t/* fallthrough */\n\tcase 2:\t\t\t/* MLST */\n\t\tmlsd_printf(ctrl, buf, len, path, name, &st);\n\t\tbreak;\n\n\tcase 1:\t\t\t/* NLST */\n\t\tsnprintf(buf, len, \"%s\\r\\n\", name);\n\t\tbreak;\n\n\tcase 0:\t\t\t/* LIST */\n\t\tsnprintf(buf, len, \"%s 1 %5d %5d %12\" PRIu64 \" %s %s\\r\\n\",\n\t\t\t mode_to_str(st.st_mode),\n\t\t\t 0, 0, (uint64_t)st.st_size,\n\t\t\t time_to_str(st.st_mtime), name);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic void do_MLST(ctrl_t *ctrl)\n{\n\tsize_t len = 0;\n\tchar buf[512] = { 0 };\n\tint sd = ctrl->sd;\n\n\tif (ctrl->data_sd != -1)\n\t\tsd = ctrl->data_sd;\n\n\tsnprintf(buf, sizeof(buf), \"250- Listing %s\\r\\n\", ctrl->file);\n\tlen = strlen(buf);\n\n\tif (list_printf(ctrl, &buf[len], sizeof(buf) -  len, ctrl->file, basename(ctrl->file))) {\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tstrlcat(buf, \"250 End.\\r\\n\", sizeof(buf));\n\tsend_msg(sd, buf);\n}\n\nstatic void do_MLSD(ctrl_t *ctrl)\n{\n\tchar buf[512] = { 0 };\n\n\tif (list_printf(ctrl, buf, sizeof(buf), ctrl->file, basename(ctrl->file))) {\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsend_msg(ctrl->data_sd, buf);\n\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n}\n\nstatic void do_LIST(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tstruct timeval tv;\n\tssize_t bytes;\n\tchar buf[BUFFER_SIZE] = { 0 };\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tif (ctrl->d_num == -1) {\n\t\tif (ctrl->list_mode == 3)\n\t\t\tdo_MLSD(ctrl);\n\t\telse\n\t\t\tdo_MLST(ctrl);\n\t\tdo_abort(ctrl);\n\t\treturn;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\tif (tv.tv_sec - ctrl->tv.tv_sec > 3) {\n\t\tDBG(\"Sending LIST entry %d of %d to %s ...\", ctrl->i, ctrl->d_num, ctrl->clientaddr);\n\t\tctrl->tv.tv_sec = tv.tv_sec;\n\t}\n\n\tctrl->list_mode |= (ctrl->pending ? 0 : 0x80);\n\twhile (ctrl->i < ctrl->d_num) {\n\t\tstruct dirent *entry;\n\t\tchar *name, *path;\n\t\tchar cwd[PATH_MAX];\n\n\t\tentry = ctrl->d[ctrl->i++];\n\t\tname  = entry->d_name;\n\n\t\tDBG(\"Found directory entry %s\", name);\n\t\tif ((!strcmp(name, \".\") || !strcmp(name, \"..\")) && ctrl->list_mode < 2)\n\t\t\tcontinue;\n\n\t\tsnprintf(cwd, sizeof(cwd), \"%s%s%s\", ctrl->file,\n\t\t\t ctrl->file[strlen(ctrl->file) - 1] == '/' ? \"\" : \"/\", name);\n\t\tpath = compose_path(ctrl, cwd);\n\t\tif (!path) {\n\t\tfail:\n\t\t\tLOGIT(LOG_INFO, errno, \"Failed reading status for %s\", path ? path : name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch (list_printf(ctrl, buf, sizeof(buf), path, name)) {\n\t\tcase -1:\n\t\t\tgoto fail;\n\t\tcase 1:\n\t\t\tcontinue;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\n\t\tDBG(\"LIST %s\", buf);\n\t\tfree(entry);\n\n\t\tbytes = send(ctrl->data_sd, buf, strlen(buf), 0);\n\t\tif (-1 == bytes) {\n\t\t\tif (ECONNRESET == errno)\n\t\t\t\tDBG(\"Connection reset by client.\");\n\t\t\telse\n\t\t\t\tERR(errno, \"Failed sending file %s to client\", ctrl->file);\n\n\t\t\twhile (ctrl->i < ctrl->d_num) {\n\t\t\t\tstruct dirent *entry = ctrl->d[ctrl->i++];\n\t\t\t\tfree(entry);\n\t\t\t}\n\t\t\tdo_abort(ctrl);\n\t\t\tsend_msg(ctrl->sd, \"426 TCP connection was established but then broken!\\r\\n\");\n\t\t}\n\n\t\treturn;\n\t}\n\tctrl->list_mode &= 0x0F;\n\n\t/* Rewind and list files */\n\tif (ctrl->pending == 0) {\n\t\tctrl->pending++;\n\t\tctrl->i = 0;\n\t\treturn;\n\t}\n\n\tdo_abort(ctrl);\n\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n}\n\nstatic void list(ctrl_t *ctrl, char *arg, int mode)\n{\n\tchar *path;\n\n\tif (string_valid(arg)) {\n\t\tchar *ptr, *quot;\n\n\t\t/* Check if client sends ls arguments ... */\n\t\tptr = arg;\n\t\twhile (*ptr) {\n\t\t\tif (isspace(*ptr))\n\t\t\t\tptr++;\n\n\t\t\tif (*ptr == '-') {\n\t\t\t\twhile (*ptr && !isspace(*ptr))\n\t\t\t\t\tptr++;\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Strip any \"\" from \"<arg>\" */\n\t\twhile ((quot = strchr(ptr, '\"'))) {\n\t\t\tchar *ptr2;\n\n\t\t\tptr2 = strchr(&quot[1], '\"');\n\t\t\tif (ptr2) {\n\t\t\t\tmemmove(ptr2, &ptr2[1], strlen(ptr2));\n\t\t\t\tmemmove(quot, &quot[1], strlen(quot));\n\t\t\t}\n\t\t}\n\t\targ = ptr;\n\t}\n\n\tif (mode >= 2)\n\t\tpath = compose_abspath(ctrl, arg);\n\telse\n\t\tpath = compose_path(ctrl, arg);\n\tif (!path) {\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tctrl->list_mode = mode;\n\tctrl->file = strdup(arg ? arg : \"\");\n\tctrl->i = 0;\n\tctrl->d_num = scandir(path, &ctrl->d, NULL, alphasort);\n\tif (ctrl->d_num == -1) {\n\t\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\tDBG(\"Failed reading directory '%s': %s\", path, strerror(errno));\n\t\treturn;\n\t}\n\n\tDBG(\"Reading directory %s ... %d number of entries\", path, ctrl->d_num);\n\tif (ctrl->data_sd > -1) {\n\t\tsend_msg(ctrl->sd, \"125 Data connection already open; transfer starting.\\r\\n\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_LIST, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\treturn;\n\t}\n\n\tdo_PORT(ctrl, 1);\n}\n\nstatic void handle_LIST(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 0);\n}\n\nstatic void handle_NLST(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 1);\n}\n\nstatic void handle_MLST(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 2);\n}\n\nstatic void handle_MLSD(ctrl_t *ctrl, char *arg)\n{\n\tlist(ctrl, arg, 3);\n}\n\nstatic void do_pasv_connection(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tint rc = 0;\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tDBG(\"error on data_listen_sd ...\");\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\tDBG(\"Event on data_listen_sd ...\");\n\tuev_io_stop(&ctrl->data_watcher);\n\tif (open_data_connection(ctrl))\n\t\treturn;\n\n\tswitch (ctrl->pending) {\n\tcase 3:\n\t\t/* fall-through */\n\tcase 2:\n\t\tif (ctrl->offset)\n\t\t\trc = fseek(ctrl->fp, ctrl->offset, SEEK_SET);\n\t\tif (rc) {\n\t\t\tdo_abort(ctrl);\n\t\t\tsend_msg(ctrl->sd, \"551 Failed seeking to that position in file.\\r\\n\");\n\t\t\treturn;\n\t\t}\n\t\t/* fall-through */\n\tcase 1:\n\t\tbreak;\n\n\tdefault:\n\t\tDBG(\"No pending command, waiting ...\");\n\t\treturn;\n\t}\n\n\tswitch (ctrl->pending) {\n\tcase 3:\t\t\t/* STOR */\n\t\tDBG(\"Pending STOR, starting ...\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_STOR, ctrl, ctrl->data_sd, UEV_READ);\n\t\tbreak;\n\n\tcase 2:\t\t\t/* RETR */\n\t\tDBG(\"Pending RETR, starting ...\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_RETR, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\n\tcase 1:\t\t\t/* LIST */\n\t\tDBG(\"Pending LIST, starting ...\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_LIST, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\t}\n\n\tif (ctrl->pending == 1 && ctrl->list_mode == 2)\n\t\tsend_msg(ctrl->sd, \"150 Opening ASCII mode data connection for MLSD.\\r\\n\");\n\telse\n\t\tsend_msg(ctrl->sd, \"150 Data connection accepted; transfer starting.\\r\\n\");\n\tctrl->pending = 0;\n}\n\nstatic int do_PASV(ctrl_t *ctrl, char *arg, struct sockaddr *data, socklen_t *len)\n{\n\tstruct sockaddr_in server;\n\n\tif (ctrl->data_sd > 0) {\n\t\tclose(ctrl->data_sd);\n\t\tctrl->data_sd = -1;\n\t}\n\n\tif (ctrl->data_listen_sd > 0)\n\t\tclose(ctrl->data_listen_sd);\n\n\tctrl->data_listen_sd = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, 0);\n\tif (ctrl->data_listen_sd < 0) {\n\t\tERR(errno, \"Failed opening data server socket\");\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\treturn 1;\n\t}\n\n\tmemset(&server, 0, sizeof(server));\n\tserver.sin_family      = AF_INET;\n\tserver.sin_addr.s_addr = inet_addr(ctrl->serveraddr);\n\tserver.sin_port        = htons(0);\n\tif (bind(ctrl->data_listen_sd, (struct sockaddr *)&server, sizeof(server)) < 0) {\n\t\tERR(errno, \"Failed binding to client socket\");\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\treturn 1;\n\t}\n\n\tINFO(\"Data server port estabished.  Waiting for client to connect ...\");\n\tif (listen(ctrl->data_listen_sd, 1) < 0) {\n\t\tERR(errno, \"Client data connection failure\");\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\treturn 1;\n\t}\n\n\tmemset(data, 0, sizeof(*data));\n\tif (-1 == getsockname(ctrl->data_listen_sd, data, len)) {\n\t\tERR(errno, \"Cannot determine our address, need it if client should connect to us\");\n\t\tclose(ctrl->data_listen_sd);\n\t\tctrl->data_listen_sd = -1;\n\t\treturn 1;\n\t}\n\n\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_pasv_connection, ctrl, ctrl->data_listen_sd, UEV_READ);\n\n\treturn 0;\n}\n\nstatic void handle_PASV(ctrl_t *ctrl, char *arg)\n{\n\tstruct sockaddr_in data;\n\tsocklen_t len = sizeof(data);\n\tchar *msg, *p, buf[200];\n\tint port;\n\n\tif (do_PASV(ctrl, arg, (struct sockaddr *)&data, &len))\n\t\treturn;\n\n\t/* Convert server IP address and port to comma separated list */\n\tmsg = strdup(ctrl->serveraddr);\n\tif (!msg) {\n\t\tsend_msg(ctrl->sd, \"426 Internal server error.\\r\\n\");\n\t\texit(1);\n\t}\n\tp = msg;\n\twhile ((p = strchr(p, '.')))\n\t\t*p++ = ',';\n\n\tport = ntohs(data.sin_port);\n\tsnprintf(buf, sizeof(buf), \"227 Entering Passive Mode (%s,%d,%d)\\r\\n\",\n\t\t msg, port / 256, port % 256);\n\tsend_msg(ctrl->sd, buf);\n\n\tfree(msg);\n}\n\nstatic void handle_EPSV(ctrl_t *ctrl, char *arg)\n{\n\tstruct sockaddr_in data;\n\tsocklen_t len = sizeof(data);\n\tchar buf[200];\n\n\tif (string_valid(arg) && string_case_compare(arg, \"ALL\")) {\n\t\tsend_msg(ctrl->sd, \"200 Command OK\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (do_PASV(ctrl, arg, (struct sockaddr *)&data, &len))\n\t\treturn;\n\n\tsnprintf(buf, sizeof(buf), \"229 Entering Extended Passive Mode (|||%d|)\\r\\n\", ntohs(data.sin_port));\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic void do_RETR(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tstruct timeval tv;\n\tssize_t bytes;\n\tsize_t num;\n\tchar buf[BUFFER_SIZE];\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tDBG(\"error on data_sd ...\");\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\tif (!ctrl->fp) {\n\t\tDBG(\"no fp for RETR, bailing.\");\n\t\treturn;\n\t}\n\n\tnum = fread(buf, sizeof(char), sizeof(buf), ctrl->fp);\n\tif (!num) {\n\t\tif (feof(ctrl->fp))\n\t\t\tINFO(\"User %s from %s downloaded %s\", ctrl->name, ctrl->clientaddr, ctrl->file);\n\t\telse if (ferror(ctrl->fp))\n\t\t\tERR(0, \"Error while reading %s\", ctrl->file);\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tgettimeofday(&tv, NULL);\n\tif (tv.tv_sec - ctrl->tv.tv_sec > 3) {\n\t\tDBG(\"Sending %zd bytes of %s to %s ...\", num, ctrl->file, ctrl->clientaddr);\n\t\tctrl->tv.tv_sec = tv.tv_sec;\n\t}\n\n\tbytes = send(ctrl->data_sd, buf, num, 0);\n\tif (-1 == bytes) {\n\t\tif (ECONNRESET == errno)\n\t\t\tDBG(\"Connection reset by client.\");\n\t\telse\n\t\t\tERR(errno, \"Failed sending file %s to client\", ctrl->file);\n\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"426 TCP connection was established but then broken!\\r\\n\");\n\t}\n}\n\n/*\n * Check if previous command was PORT, then connect to client and\n * transfer file/listing similar to what's done for PASV conns.\n */\nstatic void do_PORT(ctrl_t *ctrl, int pending)\n{\n\tif (!ctrl->data_address[0]) {\n\t\t/* Check if previous command was PASV */\n\t\tif (ctrl->data_sd == -1 && ctrl->data_listen_sd == -1) {\n\t\t\tif (pending == 1 && ctrl->d_num == -1)\n\t\t\t\tdo_MLST(ctrl);\n\t\t\treturn;\n\t\t}\n\n\t\tctrl->pending = pending;\n\t\treturn;\n\t}\n\n\tif (open_data_connection(ctrl)) {\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"425 TCP connection cannot be established.\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (pending != 1 || ctrl->list_mode != 2)\n\t\tsend_msg(ctrl->sd, \"150 Data connection opened; transfer starting.\\r\\n\");\n\n\tswitch (pending) {\n\tcase 3:\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_STOR, ctrl, ctrl->data_sd, UEV_READ);\n\t\tbreak;\n\n\tcase 2:\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_RETR, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\n\tcase 1:\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_LIST, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\tbreak;\n\t}\n\n\tctrl->pending = 0;\n}\n\nstatic void handle_RETR(ctrl_t *ctrl, char *file)\n{\n\tFILE *fp;\n\tchar *path;\n\tstruct stat st;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path || stat(path, &st) || !S_ISREG(st.st_mode)) {\n\t\tsend_msg(ctrl->sd, \"550 Not a regular file.\\r\\n\");\n\t\treturn;\n\t}\n\n\tfp = fopen(path, \"rb\");\n\tif (!fp) {\n\t\tif (errno != ENOENT)\n\t\t\tERR(errno, \"Failed RETR %s for %s\", path, ctrl->clientaddr);\n\t\tsend_msg(ctrl->sd, \"451 Trouble to RETR file.\\r\\n\");\n\t\treturn;\n\t}\n\n\tctrl->fp = fp;\n\tctrl->file = strdup(file);\n\n\tif (ctrl->data_sd > -1) {\n\t\tif (ctrl->offset) {\n\t\t\tDBG(\"Previous REST %ld of file size %ld\", ctrl->offset, st.st_size);\n\t\t\tif (fseek(fp, ctrl->offset, SEEK_SET)) {\n\t\t\t\tdo_abort(ctrl);\n\t\t\t\tsend_msg(ctrl->sd, \"551 Failed seeking to that position in file.\\r\\n\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tsend_msg(ctrl->sd, \"125 Data connection already open; transfer starting.\\r\\n\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_RETR, ctrl, ctrl->data_sd, UEV_WRITE);\n\t\treturn;\n\t}\n\n\tdo_PORT(ctrl, 2);\n}\n\nstatic void handle_MDTM(ctrl_t *ctrl, char *file)\n{\n\tstruct stat st;\n\tstruct tm *tm;\n\tchar *path, *ptr;\n\tchar *mtime = NULL;\n\tchar buf[80];\n\n\t/* Request to set mtime, ncftp does this */\n\tptr = strchr(file, ' ');\n\tif (ptr) {\n\t\t*ptr++ = 0;\n\t\tmtime = file;\n\t\tfile  = ptr;\n\t}\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path || stat(path, &st) || !S_ISREG(st.st_mode)) {\n\t\tsend_msg(ctrl->sd, \"550 Not a regular file.\\r\\n\");\n\t\treturn;\n\t}\n\n\tif (mtime) {\n\t\tstruct timespec times[2] = {\n\t\t\t{ 0, UTIME_OMIT },\n\t\t\t{ 0, 0 }\n\t\t};\n\t\tstruct tm tm;\n\t\tint rc;\n\n\t\tif (!strptime(mtime, \"%Y%m%d%H%M%S\", &tm)) {\n\t\tfail:\n\t\t\tsend_msg(ctrl->sd, \"550 Invalid time format\\r\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\ttimes[1].tv_sec = mktime(&tm);\n\t\trc = utimensat(0, path, times, 0);\n\t\tif (rc) {\n\t\t\tERR(errno, \"Failed setting MTIME %s of %s\", mtime, file);\n\t\t\tgoto fail;\n\t\t}\n\t\t(void)stat(path, &st);\n\t}\n\n\ttm = gmtime(&st.st_mtime);\n\tstrftime(buf, sizeof(buf), \"213 %Y%m%d%H%M%S\\r\\n\", tm);\n\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic void do_STOR(uev_t *w, void *arg, int events)\n{\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tstruct timeval tv;\n\tssize_t bytes;\n\tsize_t num;\n\tchar buf[BUFFER_SIZE];\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tDBG(\"error on data_sd ...\");\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\tif (!ctrl->fp) {\n\t\tDBG(\"no fp for STOR, bailing.\");\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tbytes = recv(ctrl->data_sd, buf, sizeof(buf), 0);\n\tif (bytes < 0) {\n\t\tif (ECONNRESET == errno)\n\t\t\tDBG(\"Connection reset by client.\");\n\t\telse\n\t\t\tERR(errno, \"Failed receiving file %s from client\", ctrl->file);\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"426 TCP connection was established but then broken!\\r\\n\");\n\t\treturn;\n\t}\n\tif (bytes == 0) {\n\t\tINFO(\"User %s at %s uploaded file %s\", ctrl->name, ctrl->clientaddr, ctrl->file);\n\t\tdo_abort(ctrl);\n\t\tsend_msg(ctrl->sd, \"226 Transfer complete.\\r\\n\");\n\t\treturn;\n\t}\n\n\tgettimeofday(&tv, NULL);\n\tif (tv.tv_sec - ctrl->tv.tv_sec > 3) {\n\t\tDBG(\"Receiving %zd bytes of %s from %s ...\", bytes, ctrl->file, ctrl->clientaddr);\n\t\tctrl->tv.tv_sec = tv.tv_sec;\n\t}\n\n\tnum = fwrite(buf, 1, bytes, ctrl->fp);\n\tif ((size_t)bytes != num)\n\t\tERR(errno, \"552 Disk full.\");\n}\n\nstatic void handle_STOR(ctrl_t *ctrl, char *file)\n{\n\tFILE *fp = NULL;\n\tchar *path;\n\tint rc = 0;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path) {\n\t\tINFO(\"Invalid path for %s: %m\", file);\n\t\tgoto fail;\n\t}\n\n\tDBG(\"Trying to write to %s ...\", path);\n\tfp = fopen(path, \"wb\");\n\tif (!fp) {\n\t\t/* If EACCESS client is trying to do something disallowed */\n\t\tERR(errno, \"Failed writing %s\", path);\n\tfail:\n\t\tsend_msg(ctrl->sd, \"451 Trouble storing file.\\r\\n\");\n\t\tdo_abort(ctrl);\n\t\treturn;\n\t}\n\n\tctrl->fp = fp;\n\tctrl->file = strdup(file);\n\n\tif (ctrl->data_sd > -1) {\n\t\tif (ctrl->offset)\n\t\t\trc = fseek(fp, ctrl->offset, SEEK_SET);\n\t\tif (rc) {\n\t\t\tdo_abort(ctrl);\n\t\t\tsend_msg(ctrl->sd, \"551 Failed seeking to that position in file.\\r\\n\");\n\t\t\treturn;\n\t\t}\n\n\t\tsend_msg(ctrl->sd, \"125 Data connection already open; transfer starting.\\r\\n\");\n\t\tuev_io_init(ctrl->ctx, &ctrl->data_watcher, do_STOR, ctrl, ctrl->data_sd, UEV_READ);\n\t\treturn;\n\t}\n\n\tdo_PORT(ctrl, 3);\n}\n\nstatic void handle_DELE(ctrl_t *ctrl, char *file)\n{\n\tchar *path;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path) {\n\t\tERR(errno, \"Cannot find %s\", file);\n\t\tgoto fail;\n\t}\n\n\tif (remove(path)) {\n\t\tif (ENOENT == errno)\n\t\tfail:\tsend_msg(ctrl->sd, \"550 No such file or directory.\\r\\n\");\n\t\telse if (EPERM == errno)\n\t\t\tsend_msg(ctrl->sd, \"550 Not allowed to remove file or directory.\\r\\n\");\n\t\telse\n\t\t\tsend_msg(ctrl->sd, \"550 Unknown error.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsend_msg(ctrl->sd, \"200 Command OK\\r\\n\");\n}\n\nstatic void handle_MKD(ctrl_t *ctrl, char *arg)\n{\n\tchar *path;\n\n\tpath = compose_abspath(ctrl, arg);\n\tif (!path) {\n\t\tINFO(\"Invalid path for %s: %m\", arg);\n\t\tgoto fail;\n\t}\n\n\tif (mkdir(path, 0755)) {\n\t\tif (EPERM == errno)\n\t\tfail:\tsend_msg(ctrl->sd, \"550 Not allowed to create directory.\\r\\n\");\n\t\telse\n\t\t\tsend_msg(ctrl->sd, \"550 Unknown error.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsend_msg(ctrl->sd, \"200 Command OK\\r\\n\");\n}\n\nstatic void handle_RMD(ctrl_t *ctrl, char *arg)\n{\n\thandle_DELE(ctrl, arg);\n}\n\nstatic void handle_REST(ctrl_t *ctrl, char *arg)\n{\n\tconst char *errstr;\n\tchar buf[80];\n\n\tif (!string_valid(arg)) {\n\t\tsend_msg(ctrl->sd, \"550 Invalid argument.\\r\\n\");\n\t\treturn;\n\t}\n\n\tctrl->offset = strtonum(arg, 0, INT64_MAX, &errstr);\n\tsnprintf(buf, sizeof(buf), \"350 Restarting at %ld.  Send STOR or RETR to continue transfer.\\r\\n\", ctrl->offset);\n\tsend_msg(ctrl->sd, buf);\n}\n\nstatic size_t num_nl(char *file)\n{\n\tFILE *fp;\n\tchar buf[80];\n\tsize_t len, num = 0;\n\n\tfp = fopen(file, \"r\");\n\tif (!fp)\n\t\treturn 0;\n\n\tdo {\n\t\tchar *ptr = buf;\n\n\t\tlen = fread(buf, sizeof(char), sizeof(buf) - 1, fp);\n\t\tif (len > 0) {\n\t\t\tbuf[len] = 0;\n\t\t\twhile ((ptr = strchr(ptr, '\\n'))) {\n\t\t\t\tptr++;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t}\n\t} while (len > 0);\n\tfclose(fp);\n\n\treturn num;\n}\n\nstatic void handle_SIZE(ctrl_t *ctrl, char *file)\n{\n\tchar *path;\n\tchar buf[80];\n\tsize_t extralen = 0;\n\tstruct stat st;\n\n\tpath = compose_abspath(ctrl, file);\n\tif (!path || stat(path, &st) || S_ISDIR(st.st_mode)) {\n\t\tsend_msg(ctrl->sd, \"550 No such file, or argument is a directory.\\r\\n\");\n\t\treturn;\n\t}\n\n\tDBG(\"SIZE %s\", path);\n\n\tif (ctrl->type == TYPE_A)\n\t\textralen = num_nl(path);\n\n\tsnprintf(buf, sizeof(buf), \"213 %\"  PRIu64 \"\\r\\n\", (uint64_t)(st.st_size + extralen));\n\tsend_msg(ctrl->sd, buf);\n}\n\n/* No operation - used as session keepalive by clients. */\nstatic void handle_NOOP(ctrl_t *ctrl, char *arg)\n{\n\tsend_msg(ctrl->sd, \"200 NOOP OK.\\r\\n\");\n}\n\n#if 0\nstatic void handle_RNFR(ctrl_t *ctrl, char *arg)\n{\n}\n\nstatic void handle_RNTO(ctrl_t *ctrl, char *arg)\n{\n}\n#endif\n\nstatic void handle_QUIT(ctrl_t *ctrl, char *arg)\n{\n\tsend_msg(ctrl->sd, \"221 Goodbye.\\r\\n\");\n\tuev_exit(ctrl->ctx);\n}\n\nstatic void handle_CLNT(ctrl_t *ctrl, char *arg)\n{\n\tsend_msg(ctrl->sd, \"200 CLNT\\r\\n\");\n}\n\nstatic void handle_OPTS(ctrl_t *ctrl, char *arg)\n{\n\t/* OPTS MLST type;size;modify;perm; */\n\tif (strstr(arg, \"MLST\")) {\n\t\tsize_t i = 0;\n\t\tchar *ptr;\n\t\tchar buf[42] = \"200 MLST OPTS \";\n\t\tchar facts[10] = { 0 };\n\n\t\tptr = strtok(arg + 4, \" \\t;\");\n\t\twhile (ptr && i < sizeof(facts) - 1) {\n\t\t\tif (!strcmp(ptr, \"modify\") ||\n\t\t\t    !strcmp(ptr, \"perm\")   ||\n\t\t\t    !strcmp(ptr, \"size\")   ||\n\t\t\t    !strcmp(ptr, \"type\")) {\n\t\t\t\tfacts[i++] = ptr[0];\n\t\t\t\tstrlcat(buf, ptr, sizeof(buf));\n\t\t\t\tstrlcat(buf, \";\", sizeof(buf));\n\t\t\t}\n\n\t\t\tptr = strtok(NULL, \";\");\n\t\t}\n\t\tstrlcat(buf, \"\\r\\n\", sizeof(buf));\n\n\t\tDBG(\"New MLSD facts: %s\", facts);\n\t\tstrlcpy(ctrl->facts, facts, sizeof(ctrl->facts));\n\t\tsend_msg(ctrl->sd, buf);\n\t} else\n\t\tsend_msg(ctrl->sd, \"200 UTF8 OPTS ON\\r\\n\");\n}\n\nstatic void handle_HELP(ctrl_t *ctrl, char *arg)\n{\n\tint i = 0;\n\tchar buf[80];\n\tftp_cmd_t *cmd;\n\n\tif (string_valid(arg) && !string_compare(arg, \"SITE\")) {\n\t\tsend_msg(ctrl->sd, \"500 command HELP does not take any arguments on this server.\\r\\n\");\n\t\treturn;\n\t}\n\n\tsnprintf(ctrl->buf, ctrl->bufsz, \"214-The following commands are recognized.\");\n\tfor (cmd = &supported[0]; cmd->command; cmd++, i++) {\n\t\tif (i % 14 == 0)\n\t\t\tstrlcat(ctrl->buf, \"\\r\\n\", ctrl->bufsz);\n\t\tsnprintf(buf, sizeof(buf), \" %s\", cmd->command);\n\t\tstrlcat(ctrl->buf, buf, ctrl->bufsz);\n\t}\n\tsnprintf(buf, sizeof(buf), \"\\r\\n214 Help OK.\\r\\n\");\n\tstrlcat(ctrl->buf, buf, ctrl->bufsz);\n\n\tsend_msg(ctrl->sd, ctrl->buf);\n}\n\nstatic void handle_FEAT(ctrl_t *ctrl, char *arg)\n{\n\tsnprintf(ctrl->buf, ctrl->bufsz, \"211-Features:\\r\\n\"\n\t\t \" EPSV\\r\\n\"\n\t\t \" PASV\\r\\n\"\n\t\t \" SIZE\\r\\n\"\n\t\t \" UTF8\\r\\n\"\n\t\t \" REST STREAM\\r\\n\"\n\t\t \" MLST modify*;perm*;size*;type*;\\r\\n\"\n\t\t \"211 End\\r\\n\");\n\tsend_msg(ctrl->sd, ctrl->buf);\n}\n\nstatic void handle_UNKNOWN(ctrl_t *ctrl, char *command)\n{\n\tchar buf[128];\n\n\tsnprintf(buf, sizeof(buf), \"500 command '%s' not recognized by server.\\r\\n\", command);\n\tsend_msg(ctrl->sd, buf);\n}\n\n#define COMMAND(NAME) { #NAME, handle_ ## NAME }\n\nstatic ftp_cmd_t supported[] = {\n\tCOMMAND(ABOR),\n\tCOMMAND(DELE),\n\tCOMMAND(USER),\n\tCOMMAND(PASS),\n\tCOMMAND(SYST),\n\tCOMMAND(TYPE),\n\tCOMMAND(PORT),\n\tCOMMAND(EPRT),\n\tCOMMAND(RETR),\n\tCOMMAND(MKD),\n\tCOMMAND(RMD),\n\tCOMMAND(REST),\n\tCOMMAND(MDTM),\n\tCOMMAND(PASV),\n\tCOMMAND(EPSV),\n\tCOMMAND(QUIT),\n\tCOMMAND(LIST),\n\tCOMMAND(NLST),\n\tCOMMAND(MLST),\n\tCOMMAND(MLSD),\n\tCOMMAND(CLNT),\n\tCOMMAND(OPTS),\n\tCOMMAND(PWD),\n\tCOMMAND(STOR),\n\tCOMMAND(CWD),\n\tCOMMAND(CDUP),\n\tCOMMAND(SIZE),\n\tCOMMAND(NOOP),\n\tCOMMAND(HELP),\n\tCOMMAND(FEAT),\n\t{ NULL, NULL }\n};\n\nstatic void child_exit(uev_t *w, void *arg, int events)\n{\n\tDBG(\"Child exiting ...\");\n\tuev_exit(w->ctx);\n}\n\nstatic void read_client_command(uev_t *w, void *arg, int events)\n{\n\tchar *command, *argument;\n\tctrl_t *ctrl = (ctrl_t *)arg;\n\tftp_cmd_t *cmd;\n\n\tif (UEV_ERROR == events || UEV_HUP == events) {\n\t\tuev_io_start(w);\n\t\treturn;\n\t}\n\n\t/* Reset inactivity timer. */\n\tuev_timer_set(&ctrl->timeout_watcher, INACTIVITY_TIMER, 0);\n\n\tif (recv_msg(w->fd, ctrl->buf, ctrl->bufsz, &command, &argument)) {\n\t\tDBG(\"Short read, exiting.\");\n\t\tuev_exit(ctrl->ctx);\n\t\treturn;\n\t}\n\n\tif (!string_valid(command))\n\t\treturn;\n\n\tif (string_match(command, \"FF F4\")) {\n\t\tDBG(\"Ignoring IAC command, client should send ABOR as well.\");\n\t\treturn;\n\t}\n\n\tfor (cmd = &supported[0]; cmd->command; cmd++) {\n\t\tif (string_compare(command, cmd->command)) {\n\t\t\tcmd->cb(ctrl, argument);\n\t\t\treturn;\n\t\t}\n\t}\n\n\thandle_UNKNOWN(ctrl, command);\n}\n\nstatic void ftp_command(ctrl_t *ctrl)\n{\n\tuev_t sigterm_watcher;\n\n\tctrl->bufsz = BUFFER_SIZE * sizeof(char);\n\tctrl->buf   = malloc(ctrl->bufsz);\n\tif (!ctrl->buf) {\n                WARN(errno, \"FTP session failed allocating buffer\");\n                exit(1);\n\t}\n\n\tsnprintf(ctrl->buf, ctrl->bufsz, \"220 %s (%s) ready.\\r\\n\", prognm, VERSION);\n\tsend_msg(ctrl->sd, ctrl->buf);\n\n\tuev_signal_init(ctrl->ctx, &sigterm_watcher, child_exit, NULL, SIGTERM);\n\tuev_io_init(ctrl->ctx, &ctrl->io_watcher, read_client_command, ctrl, ctrl->sd, UEV_READ);\n\tuev_run(ctrl->ctx, 0);\n}\n\nint ftp_session(uev_ctx_t *ctx, int sd)\n{\n\tint pid = 0;\n\tctrl_t *ctrl;\n\tsocklen_t len;\n\n\tctrl = new_session(ctx, sd, &pid);\n\tif (!ctrl) {\n\t\tif (pid < 0) {\n\t\t\tshutdown(sd, SHUT_RDWR);\n\t\t\tclose(sd);\n\t\t}\n\n\t\treturn pid;\n\t}\n\n\tlen = sizeof(ctrl->server_sa);\n\tif (-1 == getsockname(sd, (struct sockaddr *)&ctrl->server_sa, &len)) {\n\t\tERR(errno, \"Cannot determine our address\");\n\t\tgoto fail;\n\t}\n\tconvert_address(&ctrl->server_sa, ctrl->serveraddr, sizeof(ctrl->serveraddr));\n\n\tlen = sizeof(ctrl->client_sa);\n\tif (-1 == getpeername(sd, (struct sockaddr *)&ctrl->client_sa, &len)) {\n\t\tERR(errno, \"Cannot determine client address\");\n\t\tgoto fail;\n\t}\n\tconvert_address(&ctrl->client_sa, ctrl->clientaddr, sizeof(ctrl->clientaddr));\n\n\tctrl->type = TYPE_A;\n\tctrl->data_listen_sd = -1;\n\tctrl->data_sd = -1;\n\tctrl->name[0] = 0;\n\tctrl->pass[0] = 0;\n\tctrl->data_address[0] = 0;\n\tstrlcpy(ctrl->facts, \"mpst\", sizeof(ctrl->facts));\n\n\tINFO(\"Client connection from %s\", ctrl->clientaddr);\n\tftp_command(ctrl);\n\n\tDBG(\"Client exiting, bye\");\n\texit(del_session(ctrl, 1));\nfail:\n\tfree(ctrl);\n\tshutdown(sd, SHUT_RDWR);\n\tclose(sd);\n\n\treturn -1;\n}\n\n/**\n * Local Variables:\n *  indent-tabs-mode: t\n *  c-file-style: \"linux\"\n * End:\n */\n"], "filenames": ["src/ftpcmd.c"], "buggy_code_start_loc": [444], "buggy_code_end_loc": [445], "fixing_code_start_loc": [444], "fixing_code_end_loc": [445], "type": "CWE-787", "message": "An unauthenticated stack-based buffer overflow vulnerability in common.c's handle_PORT in uftpd FTP server versions 2.10 and earlier can be abused to cause a crash and could potentially lead to remote code execution.", "other": {"cve": {"id": "CVE-2020-20276", "sourceIdentifier": "cve@mitre.org", "published": "2020-12-18T19:15:14.047", "lastModified": "2020-12-22T18:44:36.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An unauthenticated stack-based buffer overflow vulnerability in common.c's handle_PORT in uftpd FTP server versions 2.10 and earlier can be abused to cause a crash and could potentially lead to remote code execution."}, {"lang": "es", "value": "Una vulnerabilidad de desbordamiento de b\u00fafer en la regi\u00f3n stack de la memoria no autenticada en la funci\u00f3n handle_PORT del archivo common.c en el servidor FTP de uftpd versiones 2.10 y anteriores podr\u00eda ser abusada para causar un bloqueo y podr\u00eda conllevar potencialmente a una ejecuci\u00f3n de c\u00f3digo remota"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:troglobit:uftpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.10", "matchCriteriaId": "009CC74D-BC79-471C-91A1-426627A72170"}]}]}], "references": [{"url": "https://arinerron.com/blog/posts/6", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/troglobit/uftpd/commit/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/troglobit/uftpd/commit/0fb2c031ce0ace07cc19cd2cb2143c4b5a63c9dd"}}