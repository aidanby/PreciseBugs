{"buggy_code": ["/* $OpenBSD: x509_verify.c,v 1.60 2022/08/05 14:46:52 beck Exp $ */\n/*\n * Copyright (c) 2020-2021 Bob Beck <beck@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* x509_verify - inspired by golang's crypto/x509.Verify */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <openssl/safestack.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n#include \"x509_internal.h\"\n#include \"x509_issuer_cache.h\"\n\nstatic int x509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain);\nstatic int x509_verify_cert_hostname(struct x509_verify_ctx *ctx, X509 *cert,\n    char *name);\nstatic void x509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain, char *name);\nstatic int x509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert,\n    size_t depth, int error, int ok);\nstatic void x509_verify_chain_free(struct x509_verify_chain *chain);\n\n/*\n * Parse an asn1 to a representable time_t as per RFC 5280 rules.\n * Returns -1 if that can't be done for any reason.\n */\ntime_t\nx509_verify_asn1_time_to_time_t(const ASN1_TIME *atime, int notAfter)\n{\n\tstruct tm tm = { 0 };\n\tint type;\n\n\ttype = ASN1_time_parse(atime->data, atime->length, &tm, atime->type);\n\tif (type == -1)\n\t\treturn -1;\n\n\t/* RFC 5280 section 4.1.2.5 */\n\tif (tm.tm_year < 150 && type != V_ASN1_UTCTIME)\n\t\treturn -1;\n\tif (tm.tm_year >= 150 && type != V_ASN1_GENERALIZEDTIME)\n\t\treturn -1;\n\n\tif (notAfter) {\n\t\t/*\n\t\t * If we are a completely broken operating system with a\n\t\t * 32 bit time_t, and we have been told this is a notAfter\n\t\t * date, limit the date to a 32 bit representable value.\n\t\t */\n\t\tif (!ASN1_time_tm_clamp_notafter(&tm))\n\t\t\treturn -1;\n\t}\n\n\t/*\n\t * Defensively fail if the time string is not representable as\n\t * a time_t. A time_t must be sane if you care about times after\n\t * Jan 19 2038.\n\t */\n\treturn timegm(&tm);\n}\n\n/*\n * Cache certificate hash, and values parsed out of an X509.\n * called from cache_extensions()\n */\nvoid\nx509_verify_cert_info_populate(X509 *cert)\n{\n\t/*\n\t * Parse and save the cert times, or remember that they\n\t * are unacceptable/unparsable.\n\t */\n\tcert->not_before = x509_verify_asn1_time_to_time_t(X509_get_notBefore(cert), 0);\n\tcert->not_after = x509_verify_asn1_time_to_time_t(X509_get_notAfter(cert), 1);\n}\n\nstruct x509_verify_chain *\nx509_verify_chain_new(void)\n{\n\tstruct x509_verify_chain *chain;\n\n\tif ((chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((chain->certs = sk_X509_new_null()) == NULL)\n\t\tgoto err;\n\tif ((chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tif ((chain->names =\n\t    x509_constraints_names_new(X509_VERIFY_MAX_CHAIN_NAMES)) == NULL)\n\t\tgoto err;\n\n\treturn chain;\n err:\n\tx509_verify_chain_free(chain);\n\treturn NULL;\n}\n\nstatic void\nx509_verify_chain_clear(struct x509_verify_chain *chain)\n{\n\tsk_X509_pop_free(chain->certs, X509_free);\n\tchain->certs = NULL;\n\tfree(chain->cert_errors);\n\tchain->cert_errors = NULL;\n\tx509_constraints_names_free(chain->names);\n\tchain->names = NULL;\n}\n\nstatic void\nx509_verify_chain_free(struct x509_verify_chain *chain)\n{\n\tif (chain == NULL)\n\t\treturn;\n\tx509_verify_chain_clear(chain);\n\tfree(chain);\n}\n\nstatic struct x509_verify_chain *\nx509_verify_chain_dup(struct x509_verify_chain *chain)\n{\n\tstruct x509_verify_chain *new_chain;\n\n\tif ((new_chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((new_chain->certs = X509_chain_up_ref(chain->certs)) == NULL)\n\t\tgoto err;\n\tif ((new_chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tmemcpy(new_chain->cert_errors, chain->cert_errors,\n\t    X509_VERIFY_MAX_CHAIN_CERTS * sizeof(int));\n\tif ((new_chain->names =\n\t    x509_constraints_names_dup(chain->names)) == NULL)\n\t\tgoto err;\n\treturn(new_chain);\n err:\n\tx509_verify_chain_free(new_chain);\n\treturn NULL;\n}\n\nstatic int\nx509_verify_chain_append(struct x509_verify_chain *chain, X509 *cert,\n    int *error)\n{\n\tint verify_err = X509_V_ERR_UNSPECIFIED;\n\tsize_t idx;\n\n\tif (!x509_constraints_extract_names(chain->names, cert,\n\t    sk_X509_num(chain->certs) == 0, &verify_err)) {\n\t\t*error = verify_err;\n\t\treturn 0;\n\t}\n\n\tX509_up_ref(cert);\n\tif (!sk_X509_push(chain->certs, cert)) {\n\t\tX509_free(cert);\n\t\t*error = X509_V_ERR_OUT_OF_MEM;\n\t\treturn 0;\n\t}\n\n\tidx = sk_X509_num(chain->certs) - 1;\n\tchain->cert_errors[idx] = *error;\n\n\t/*\n\t * We've just added the issuer for the previous certificate,\n\t * clear its error if appropriate.\n\t */\n\tif (idx > 1 && chain->cert_errors[idx - 1] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[idx - 1] = X509_V_OK;\n\n\treturn 1;\n}\n\nstatic X509 *\nx509_verify_chain_last(struct x509_verify_chain *chain)\n{\n\tint last;\n\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\tif ((last = sk_X509_num(chain->certs) - 1) < 0)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, last);\n}\n\nX509 *\nx509_verify_chain_leaf(struct x509_verify_chain *chain)\n{\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, 0);\n}\n\nstatic void\nx509_verify_ctx_reset(struct x509_verify_ctx *ctx)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->chains_count; i++)\n\t\tx509_verify_chain_free(ctx->chains[i]);\n\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\tctx->saved_error = 0;\n\tctx->saved_error_depth = 0;\n\tctx->error = 0;\n\tctx->error_depth = 0;\n\tctx->chains_count = 0;\n\tctx->sig_checks = 0;\n\tctx->check_time = NULL;\n}\n\nstatic void\nx509_verify_ctx_clear(struct x509_verify_ctx *ctx)\n{\n\tx509_verify_ctx_reset(ctx);\n\tsk_X509_pop_free(ctx->intermediates, X509_free);\n\tfree(ctx->chains);\n\n}\n\nstatic int\nx509_verify_cert_cache_extensions(X509 *cert)\n{\n\tif (!(cert->ex_flags & EXFLAG_SET)) {\n\t\tCRYPTO_w_lock(CRYPTO_LOCK_X509);\n\t\tx509v3_cache_extensions(cert);\n\t\tCRYPTO_w_unlock(CRYPTO_LOCK_X509);\n\t}\n\tif (cert->ex_flags & EXFLAG_INVALID)\n\t\treturn 0;\n\n\treturn (cert->ex_flags & EXFLAG_SET);\n}\n\nstatic int\nx509_verify_cert_self_signed(X509 *cert)\n{\n\treturn (cert->ex_flags & EXFLAG_SS) ? 1 : 0;\n}\n\n/* XXX beck - clean up this mess of is_root */\nstatic int\nx509_verify_check_chain_end(X509 *cert, int full_chain)\n{\n\tif (full_chain)\n\t\treturn x509_verify_cert_self_signed(cert);\n\treturn 1;\n}\n\nstatic int\nx509_verify_ctx_cert_is_root(struct x509_verify_ctx *ctx, X509 *cert,\n    int full_chain)\n{\n\tX509 *match = NULL;\n\tint i;\n\n\tif (!x509_verify_cert_cache_extensions(cert))\n\t\treturn 0;\n\n\t/* Check by lookup if we have a legacy xsc */\n\tif (ctx->xsc != NULL) {\n\t\tif ((match = x509_vfy_lookup_cert_match(ctx->xsc,\n\t\t    cert)) != NULL) {\n\t\t\tX509_free(match);\n\t\t\treturn x509_verify_check_chain_end(cert, full_chain);\n\n\t\t}\n\t} else {\n\t\t/* Check the provided roots */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tif (X509_cmp(sk_X509_value(ctx->roots, i), cert) == 0)\n\t\t\t\treturn x509_verify_check_chain_end(cert,\n\t\t\t\t    full_chain);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nx509_verify_ctx_set_xsc_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, int set_error, int is_trusted)\n{\n\tsize_t num_untrusted;\n\tint i;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * XXX num_untrusted is the number of untrusted certs at the\n\t * bottom of the chain. This works now since we stop at the first\n\t * trusted cert. This will need fixing once we allow more than one\n\t * trusted certificate.\n\t */\n\tnum_untrusted = sk_X509_num(chain->certs);\n\tif (is_trusted && num_untrusted > 0)\n\t\tnum_untrusted--;\n\tctx->xsc->num_untrusted = num_untrusted;\n\n\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\tctx->xsc->chain = X509_chain_up_ref(chain->certs);\n\tif (ctx->xsc->chain == NULL)\n\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\n\tif (set_error) {\n\t\tctx->xsc->error = X509_V_OK;\n\t\tctx->xsc->error_depth = 0;\n\t\tfor (i = 0; i < sk_X509_num(chain->certs); i++) {\n\t\t\tif (chain->cert_errors[i] != X509_V_OK) {\n\t\t\t\tctx->xsc->error = chain->cert_errors[i];\n\t\t\t\tctx->xsc->error_depth = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/*\n * Save the error state and unvalidated chain off of the xsc for\n * later.\n */\nstatic int\nx509_verify_ctx_save_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->xsc->chain != NULL) {\n\t\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\t\tctx->saved_error_chain = X509_chain_up_ref(ctx->xsc->chain);\n\t\tif (ctx->saved_error_chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->saved_error = ctx->xsc->error;\n\t\tctx->saved_error_depth = ctx->xsc->error_depth;\n\t}\n\treturn 1;\n}\n\n/*\n * Restore the saved error state and unvalidated chain to the xsc\n * if we do not have a validated chain.\n */\nstatic int\nx509_verify_ctx_restore_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->chains_count == 0 &&\n\t    ctx->saved_error_chain != NULL) {\n\t\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\t\tctx->xsc->chain = X509_chain_up_ref(ctx->saved_error_chain);\n\t\tif (ctx->xsc->chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->xsc->error = ctx->saved_error;\n\t\tctx->xsc->error_depth = ctx->saved_error_depth;\n\t}\n\treturn 1;\n}\n\n/* Perform legacy style validation of a chain */\nstatic int\nx509_verify_ctx_validate_legacy_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, size_t depth)\n{\n\tint ret = 0, trust;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * If we have a legacy xsc, choose a validated chain, and\n\t * apply the extensions, revocation, and policy checks just\n\t * like the legacy code did. We do this here instead of as\n\t * building the chains to more easily support the callback and\n\t * the bewildering array of VERIFY_PARAM knobs that are there\n\t * for the fiddling.\n\t */\n\n\t/* These may be set in one of the following calls. */\n\tctx->xsc->error = X509_V_OK;\n\tctx->xsc->error_depth = 0;\n\n\tif (!x509_verify_ctx_set_xsc_chain(ctx, chain, 0, 1))\n\t\tgoto err;\n\n\t/*\n\t * Call the legacy code to walk the chain and check trust\n\t * in the legacy way to handle partial chains and get the\n\t * callback fired correctly.\n\t */\n\ttrust = x509_vfy_check_trust(ctx->xsc);\n\tif (trust == X509_TRUST_REJECTED)\n\t\tgoto err; /* callback was called in x509_vfy_check_trust */\n\tif (trust != X509_TRUST_TRUSTED) {\n\t\t/* NOTREACHED */\n\t\tgoto err;  /* should not happen if we get in here - abort? */\n\t}\n\n\t/*\n\t * XXX currently this duplicates some work done in chain\n\t * build, but we keep it here until we have feature parity\n\t */\n\tif (!x509_vfy_check_chain_extensions(ctx->xsc))\n\t\tgoto err;\n\n#ifndef OPENSSL_NO_RFC3779\n\tif (!X509v3_asid_validate_path(ctx->xsc))\n\t\tgoto err;\n\n\tif (!X509v3_addr_validate_path(ctx->xsc))\n\t\tgoto err;\n#endif\n\n\tif (!x509_vfy_check_security_level(ctx->xsc))\n\t\tgoto err;\n\n\tif (!x509_constraints_chain(ctx->xsc->chain,\n\t\t&ctx->xsc->error, &ctx->xsc->error_depth)) {\n\t\tX509 *cert = sk_X509_value(ctx->xsc->chain, depth);\n\t\tif (!x509_verify_cert_error(ctx, cert,\n\t\t\tctx->xsc->error_depth, ctx->xsc->error, 0))\n\t\t\tgoto err;\n\t}\n\n\tif (!x509_vfy_check_revocation(ctx->xsc))\n\t\tgoto err;\n\n\tif (!x509_vfy_check_policy(ctx->xsc))\n\t\tgoto err;\n\n\tret = 1;\n\n err:\n\t/*\n\t * The above checks may have set ctx->xsc->error and\n\t * ctx->xsc->error_depth - save these for later on.\n\t */\n\tif (ctx->xsc->error != X509_V_OK) {\n\t\tif (ctx->xsc->error_depth < 0 ||\n\t\t    ctx->xsc->error_depth >= X509_VERIFY_MAX_CHAIN_CERTS)\n\t\t\treturn 0;\n\t\tchain->cert_errors[ctx->xsc->error_depth] =\n\t\t    ctx->xsc->error;\n\t\tctx->error_depth = ctx->xsc->error_depth;\n\t}\n\n\treturn ret;\n}\n\n/* Add a validated chain to our list of valid chains */\nstatic int\nx509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\n\t/* Clear a get issuer failure for a root certificate. */\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\n\t/*\n\t * In the non-legacy code, extensions and purpose are dealt\n\t * with as the chain is built.\n\t *\n\t * The non-legacy api returns multiple chains but does not do\n\t * any revocation checking (it must be done by the caller on\n\t * any chain they wish to use)\n\t */\n\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}\n\nstatic int\nx509_verify_potential_parent(struct x509_verify_ctx *ctx, X509 *parent,\n    X509 *child)\n{\n\tif (!x509_verify_cert_cache_extensions(parent))\n\t\treturn 0;\n\tif (ctx->xsc != NULL)\n\t\treturn (ctx->xsc->check_issued(ctx->xsc, child, parent));\n\n\t/* XXX key usage */\n\treturn X509_check_issued(child, parent) != X509_V_OK;\n}\n\nstatic int\nx509_verify_parent_signature(X509 *parent, X509 *child, int *error)\n{\n\tEVP_PKEY *pkey;\n\tint cached;\n\tint ret = 0;\n\n\t/* Use cached value if we have it */\n\tif ((cached = x509_issuer_cache_find(parent->hash, child->hash)) >= 0)\n\t\treturn cached;\n\n\t/* Check signature. Did parent sign child? */\n\tif ((pkey = X509_get_pubkey(parent)) == NULL) {\n\t\t*error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\treturn 0;\n\t}\n\tif (X509_verify(child, pkey) <= 0)\n\t\t*error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\n\telse\n\t\tret = 1;\n\n\t/* Add result to cache */\n\tx509_issuer_cache_add(parent->hash, child->hash, ret);\n\n\tEVP_PKEY_free(pkey);\n\n\treturn ret;\n}\n\nstatic int\nx509_verify_consider_candidate(struct x509_verify_ctx *ctx, X509 *cert,\n    int is_root_cert, X509 *candidate, struct x509_verify_chain *current_chain,\n    int full_chain, char *name)\n{\n\tint depth = sk_X509_num(current_chain->certs);\n\tstruct x509_verify_chain *new_chain;\n\tint i;\n\n\t/* Fail if the certificate is already in the chain */\n\tfor (i = 0; i < sk_X509_num(current_chain->certs); i++) {\n\t\tif (X509_cmp(sk_X509_value(current_chain->certs, i),\n\t\t    candidate) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx->sig_checks++ > X509_VERIFY_MAX_SIGCHECKS) {\n\t\t/* don't allow callback to override safety check */\n\t\t(void) x509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\t\treturn 0;\n\t}\n\n\tif (!x509_verify_parent_signature(candidate, cert, &ctx->error)) {\n\t\tif (!x509_verify_cert_error(ctx, candidate, depth,\n\t\t    ctx->error, 0))\n\t\t\treturn 0;\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, candidate, current_chain))\n\t\treturn 0;\n\n\t/* candidate is good, add it to a copy of the current chain */\n\tif ((new_chain = x509_verify_chain_dup(current_chain)) == NULL) {\n\t\tx509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\treturn 0;\n\t}\n\tif (!x509_verify_chain_append(new_chain, candidate, &ctx->error)) {\n\t\tx509_verify_cert_error(ctx, candidate, depth, ctx->error, 0);\n\t\tx509_verify_chain_free(new_chain);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If candidate is a trusted root, we have a validated chain,\n\t * so we save it.  Otherwise, recurse until we find a root or\n\t * give up.\n\t */\n\tif (is_root_cert) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, new_chain, 0, 1)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!x509_verify_ctx_add_chain(ctx, new_chain, name)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tx509_verify_build_chains(ctx, candidate, new_chain, full_chain, name);\n\n done:\n\tx509_verify_chain_free(new_chain);\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert, size_t depth,\n    int error, int ok)\n{\n\tctx->error = error;\n\tctx->error_depth = depth;\n\tif (ctx->xsc != NULL) {\n\t\tctx->xsc->error = error;\n\t\tctx->xsc->error_depth = depth;\n\t\tctx->xsc->current_cert = cert;\n\t\treturn ctx->xsc->verify_cb(ok, ctx->xsc);\n\t}\n\treturn ok;\n}\n\nstatic void\nx509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain, char *name)\n{\n\tX509 *candidate;\n\tint i, depth, count, ret, is_root;\n\n\t/*\n\t * If we are finding chains with an xsc, just stop after we have\n\t * one chain, there's no point in finding more, it just exercises\n\t * the potentially buggy callback processing in the calling software.\n\t */\n\tif (ctx->xsc != NULL && ctx->chains_count > 0)\n\t\treturn;\n\n\tdepth = sk_X509_num(current_chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (depth >= ctx->max_depth &&\n\t    !x509_verify_cert_error(ctx, cert, depth,\n\t\tX509_V_ERR_CERT_CHAIN_TOO_LONG, 0))\n\t\treturn;\n\n\tcount = ctx->chains_count;\n\n\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n\tctx->error_depth = depth;\n\n\tif (ctx->saved_error != 0)\n\t\tctx->error = ctx->saved_error;\n\tif (ctx->saved_error_depth != 0)\n\t\tctx->error_depth = ctx->saved_error_depth;\n\n\tif (ctx->xsc != NULL) {\n\t\t/*\n\t\t * Long ago experiments at Muppet labs resulted in a\n\t\t * situation where software not only sees these errors\n\t\t * but forced developers to expect them in certain cases.\n\t\t * so we must mimic this awfulness for the legacy case.\n\t\t */\n\t\tif (cert->ex_flags & EXFLAG_SS)\n\t\t\tctx->error = (depth == 0) ?\n\t\t\t    X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n\t\t\t    X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n\t}\n\n\t/* Check for legacy mode roots */\n\tif (ctx->xsc != NULL) {\n\t\tif ((ret = ctx->xsc->get_issuer(&candidate, ctx->xsc, cert)) < 0) {\n\t\t\tx509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_STORE_LOOKUP, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = x509_verify_check_chain_end(candidate,\n\t\t\t\t    full_chain);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain, name);\n\t\t\t}\n\t\t\tX509_free(candidate);\n\t\t}\n\t} else {\n\t\t/* Check to see if we have a trusted root issuer. */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->roots, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = x509_verify_check_chain_end(candidate,\n\t\t\t\t    full_chain);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain, name);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check intermediates after checking roots */\n\tif (ctx->intermediates != NULL) {\n\t\tfor (i = 0; i < sk_X509_num(ctx->intermediates); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->intermediates, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    0, candidate, current_chain,\n\t\t\t\t    full_chain, name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->chains_count > count) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tctx->xsc->error = X509_V_OK;\n\t\t\tctx->xsc->error_depth = depth;\n\t\t\tctx->xsc->current_cert = cert;\n\t\t}\n\t} else if (ctx->error_depth == depth) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, current_chain, 0, 0))\n\t\t\treturn;\n\t}\n}\n\nstatic int\nx509_verify_cert_hostname(struct x509_verify_ctx *ctx, X509 *cert, char *name)\n{\n\tchar *candidate;\n\tsize_t len;\n\n\tif (name == NULL) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tint ret;\n\n\t\t\tif ((ret = x509_vfy_check_id(ctx->xsc)) == 0)\n\t\t\t\tctx->error = ctx->xsc->error;\n\t\t\treturn ret;\n\t\t}\n\t\treturn 1;\n\t}\n\tif ((candidate = strdup(name)) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\tif ((len = strlen(candidate)) < 1) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED; /* XXX */\n\t\tgoto err;\n\t}\n\n\t/* IP addresses may be written in [ ]. */\n\tif (candidate[0] == '[' && candidate[len - 1] == ']') {\n\t\tcandidate[len - 1] = '\\0';\n\t\tif (X509_check_ip_asc(cert, candidate + 1, 0) <= 0) {\n\t\t\tctx->error = X509_V_ERR_IP_ADDRESS_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (ctx->xsc == NULL)\n\t\t\tflags = X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;\n\n\t\tif (X509_check_host(cert, candidate, len, flags, NULL) <= 0) {\n\t\t\tctx->error = X509_V_ERR_HOSTNAME_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree(candidate);\n\treturn 1;\n err:\n\tfree(candidate);\n\treturn x509_verify_cert_error(ctx, cert, 0, ctx->error, 0);\n}\n\nstatic int\nx509_verify_set_check_time(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL)  {\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_USE_CHECK_TIME) {\n\t\t\tctx->check_time = &ctx->xsc->param->check_time;\n\t\t\treturn 1;\n\t\t}\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\t\treturn 0;\n\t}\n\n\tctx->check_time = NULL;\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_times(X509 *cert, time_t *cmp_time, int *error)\n{\n\ttime_t when;\n\n\tif (cmp_time == NULL)\n\t\twhen = time(NULL);\n\telse\n\t\twhen = *cmp_time;\n\n\tif (cert->not_before == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n\t\treturn 0;\n\t}\n\tif (when < cert->not_before) {\n\t\t*error = X509_V_ERR_CERT_NOT_YET_VALID;\n\t\treturn 0;\n\t}\n\tif (cert->not_after == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n\t\treturn 0;\n\t}\n\tif (when > cert->not_after) {\n\t\t*error = X509_V_ERR_CERT_HAS_EXPIRED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nx509_verify_validate_constraints(X509 *cert,\n    struct x509_verify_chain *current_chain, int *error)\n{\n\tstruct x509_constraints_names *excluded = NULL;\n\tstruct x509_constraints_names *permitted = NULL;\n\tint err = X509_V_ERR_UNSPECIFIED;\n\n\tif (current_chain == NULL)\n\t\treturn 1;\n\n\tif (cert->nc != NULL) {\n\t\tif ((permitted = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif ((excluded = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!x509_constraints_extract_constraints(cert,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tif (!x509_constraints_check(current_chain->names,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tx509_constraints_names_free(excluded);\n\t\tx509_constraints_names_free(permitted);\n\t}\n\n\treturn 1;\n err:\n\t*error = err;\n\tx509_constraints_names_free(excluded);\n\tx509_constraints_names_free(permitted);\n\treturn 0;\n}\n\nstatic int\nx509_verify_cert_extensions(struct x509_verify_ctx *ctx, X509 *cert, int need_ca)\n{\n\tif (!x509_verify_cert_cache_extensions(cert)) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\treturn 0;\n\t}\n\n\tif (ctx->xsc != NULL)\n\t\treturn 1;\t/* legacy is checked after chain is built */\n\n\tif (cert->ex_flags & EXFLAG_CRITICAL) {\n\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n\t\treturn 0;\n\t}\n\t/* No we don't care about v1, netscape, and other ancient silliness */\n\tif (need_ca && (!(cert->ex_flags & EXFLAG_BCONS) &&\n\t    (cert->ex_flags & EXFLAG_CA))) {\n\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\treturn 0;\n\t}\n\tif (ctx->purpose > 0 && X509_check_purpose(cert, ctx->purpose, need_ca)) {\n\t\tctx->error = X509_V_ERR_INVALID_PURPOSE;\n\t\treturn 0;\n\t}\n\n\t/* XXX support proxy certs later in new api */\n\tif (ctx->xsc == NULL && cert->ex_flags & EXFLAG_PROXY) {\n\t\tctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Validate that cert is a possible candidate to append to current_chain */\nstatic int\nx509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain)\n{\n\tX509 *issuer_candidate;\n\tint should_be_ca = current_chain != NULL;\n\tsize_t depth = 0;\n\n\tif (current_chain != NULL)\n\t\tdepth = sk_X509_num(current_chain->certs);\n\n\tif (!x509_verify_cert_extensions(ctx, cert, should_be_ca))\n\t\treturn 0;\n\n\tif (should_be_ca) {\n\t\tissuer_candidate = x509_verify_chain_last(current_chain);\n\t\tif (issuer_candidate != NULL &&\n\t\t    !X509_check_issued(issuer_candidate, cert))\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_SUBJECT_ISSUER_MISMATCH, 0))\n\t\t\t\treturn 0;\n\t}\n\n\tif (x509_verify_set_check_time(ctx)) {\n\t\tif (!x509_verify_cert_times(cert, ctx->check_time,\n\t\t    &ctx->error)) {\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    ctx->error, 0))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!x509_verify_validate_constraints(cert, current_chain,\n\t    &ctx->error) && !x509_verify_cert_error(ctx, cert, depth,\n\t    ctx->error, 0))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new_from_xsc(X509_STORE_CTX *xsc)\n{\n\tstruct x509_verify_ctx *ctx;\n\tsize_t max_depth;\n\n\tif (xsc == NULL)\n\t\treturn NULL;\n\n\tif ((ctx = x509_verify_ctx_new(NULL)) == NULL)\n\t\treturn NULL;\n\n\tctx->xsc = xsc;\n\n\tif (xsc->untrusted &&\n\t    (ctx->intermediates = X509_chain_up_ref(xsc->untrusted)) == NULL)\n\t\tgoto err;\n\n\tmax_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tif (xsc->param->depth > 0 && xsc->param->depth < X509_VERIFY_MAX_CHAIN_CERTS)\n\t\tmax_depth = xsc->param->depth;\n\tif (!x509_verify_ctx_set_max_depth(ctx, max_depth))\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\n/* Public API */\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new(STACK_OF(X509) *roots)\n{\n\tstruct x509_verify_ctx *ctx;\n\n\tif ((ctx = calloc(1, sizeof(struct x509_verify_ctx))) == NULL)\n\t\treturn NULL;\n\n\tif (roots != NULL) {\n\t\tif  ((ctx->roots = X509_chain_up_ref(roots)) == NULL)\n\t\t\tgoto err;\n\t} else {\n\t\tif ((ctx->roots = sk_X509_new_null()) == NULL)\n\t\t\tgoto err;\n\t}\n\n\tctx->max_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tctx->max_chains = X509_VERIFY_MAX_CHAINS;\n\tctx->max_sigs = X509_VERIFY_MAX_SIGCHECKS;\n\n\tif ((ctx->chains = calloc(X509_VERIFY_MAX_CHAINS,\n\t    sizeof(*ctx->chains))) == NULL)\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\nvoid\nx509_verify_ctx_free(struct x509_verify_ctx *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\tsk_X509_pop_free(ctx->roots, X509_free);\n\tx509_verify_ctx_clear(ctx);\n\tfree(ctx);\n}\n\nint\nx509_verify_ctx_set_max_depth(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAIN_CERTS)\n\t\treturn 0;\n\tctx->max_depth = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_chains(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAINS)\n\t\treturn 0;\n\tctx->max_chains = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_signatures(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > 100000)\n\t\treturn 0;\n\tctx->max_sigs = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_purpose(struct x509_verify_ctx *ctx, int purpose)\n{\n\tif (purpose < X509_PURPOSE_MIN || purpose > X509_PURPOSE_MAX)\n\t\treturn 0;\n\tctx->purpose = purpose;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_intermediates(struct x509_verify_ctx *ctx,\n    STACK_OF(X509) *intermediates)\n{\n\tif ((ctx->intermediates = X509_chain_up_ref(intermediates)) == NULL)\n\t\treturn 0;\n\treturn 1;\n}\n\nconst char *\nx509_verify_ctx_error_string(struct x509_verify_ctx *ctx)\n{\n\treturn X509_verify_cert_error_string(ctx->error);\n}\n\nsize_t\nx509_verify_ctx_error_depth(struct x509_verify_ctx *ctx)\n{\n\treturn ctx->error_depth;\n}\n\nSTACK_OF(X509) *\nx509_verify_ctx_chain(struct x509_verify_ctx *ctx, size_t i)\n{\n\tif (i >= ctx->chains_count)\n\t\treturn NULL;\n\treturn ctx->chains[i]->certs;\n}\n\nsize_t\nx509_verify(struct x509_verify_ctx *ctx, X509 *leaf, char *name)\n{\n\tstruct x509_verify_chain *current_chain;\n\tint retry_chain_build, full_chain = 0;\n\n\tif (ctx->roots == NULL || ctx->max_depth == 0) {\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\tgoto err;\n\t}\n\n\tif (ctx->xsc != NULL) {\n\t\tif (leaf != NULL || name != NULL) {\n\t\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\t\tgoto err;\n\t\t}\n\t\tleaf = ctx->xsc->cert;\n\n\t\t/* XXX */\n\t\tfull_chain = 1;\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)\n\t\t\tfull_chain = 0;\n\t\t/*\n\t\t * XXX\n\t\t * The legacy code expects the top level cert to be\n\t\t * there, even if we didn't find a chain. So put it\n\t\t * there, we will clobber it later if we find a valid\n\t\t * chain.\n\t\t */\n\t\tif ((ctx->xsc->chain = sk_X509_new_null()) == NULL) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!X509_up_ref(leaf)) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!sk_X509_push(ctx->xsc->chain, leaf)) {\n\t\t\tX509_free(leaf);\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tctx->xsc->error_depth = 0;\n\t\tctx->xsc->current_cert = leaf;\n\t}\n\n\tif ((current_chain = x509_verify_chain_new()) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Add the leaf to the chain and try to build chains from it.\n\t * Note that unlike Go's verifier, we have not yet checked\n\t * anything about the leaf, This is intentional, so that we\n\t * report failures in chain building before we report problems\n\t * with the leaf.\n\t */\n\tif (!x509_verify_chain_append(current_chain, leaf, &ctx->error)) {\n\t\tx509_verify_chain_free(current_chain);\n\t\tgoto err;\n\t}\n\tdo {\n\t\tretry_chain_build = 0;\n\t\tif (x509_verify_ctx_cert_is_root(ctx, leaf, full_chain)) {\n\t\t\tif (!x509_verify_ctx_add_chain(ctx, current_chain,\n\t\t\t    name)) {\n\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tx509_verify_build_chains(ctx, leaf, current_chain,\n\t\t\t    full_chain, name);\n\t\t\tif (full_chain && ctx->chains_count == 0) {\n\t\t\t\t/*\n\t\t\t\t * Save the error state from the xsc\n\t\t\t\t * at this point to put back on the\n\t\t\t\t * xsc in case we do not find a chain\n\t\t\t\t * that is trusted but not a full\n\t\t\t\t * chain to a self signed root. This\n\t\t\t\t * is because the unvalidated chain is\n\t\t\t\t * used by the autochain batshittery\n\t\t\t\t * on failure and will be needed for\n\t\t\t\t * that.\n\t\t\t\t */\n\t\t\t\tctx->xsc->error_depth = ctx->error_depth;\n\t\t\t\tif (!x509_verify_ctx_save_xsc_error(ctx)) {\n\t\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tfull_chain = 0;\n\t\t\t\tretry_chain_build = 1;\n\t\t\t}\n\t\t}\n\t} while (retry_chain_build);\n\n\tx509_verify_chain_free(current_chain);\n\n\t/*\n\t * Do the new verifier style return, where we don't have an xsc\n\t * that allows a crazy callback to turn invalid things into valid.\n\t */\n\tif (ctx->xsc == NULL) {\n\t\t/*\n\t\t * Safety net:\n\t\t * We could not find a validated chain, and for some reason do not\n\t\t * have an error set.\n\t\t */\n\t\tif (ctx->chains_count == 0 && ctx->error == X509_V_OK)\n\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\t\t/*\n\t\t * If we are not using an xsc, and have no possibility for the\n\t\t * crazy OpenSSL callback API changing the results of\n\t\t * validation steps (because the callback can make validation\n\t\t * proceed in the presence of invalid certs), any chains we\n\t\t * have here are correctly built and verified.\n\t\t */\n\t\tif (ctx->chains_count > 0)\n\t\t\tctx->error = X509_V_OK;\n\n\t\treturn ctx->chains_count;\n\t}\n\n\t/*\n\t * Otherwise we are doing compatibility with an xsc, which means that we\n\t * will have one chain, which might actually be a bogus chain because\n\t * the callback told us to ignore errors and proceed to build an invalid\n\t * chain. Possible return values from this include returning 1 with an\n\t * invalid chain and a value of xsc->error != X509_V_OK (It's tradition\n\t * that makes it ok).\n\t */\n\n\tif (ctx->chains_count > 0) {\n\t\t/*\n\t\t * The chain we have using an xsc might not be a verified chain\n\t\t * if the callback perverted things while we built it to ignore\n\t\t * failures and proceed with chain building. We put this chain\n\t\t * and the error associated with it on the xsc.\n\t\t */\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, ctx->chains[0], 1, 1))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Call the callback for completion up our built\n\t\t * chain. The callback could still tell us to\n\t\t * fail. Since this chain might exist as the result of\n\t\t * callback doing perversions, we could still return\n\t\t * \"success\" with something other than X509_V_OK set\n\t\t * as the error.\n\t\t */\n\t\tif (!x509_vfy_callback_indicate_completion(ctx->xsc))\n\t\t\tgoto err;\n\t} else {\n\t\t/*\n\t\t * We did not find a chain. Bring back the failure\n\t\t * case we wanted to the xsc if we saved one. If we\n\t\t * did not we should have just the leaf on the xsc.\n\t\t */\n\t\tif (!x509_verify_ctx_restore_xsc_error(ctx))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Safety net, ensure we have an error set in the\n\t\t * failing case.\n\t\t */\n\t\tif (ctx->xsc->error == X509_V_OK) {\n\t\t\tif (ctx->error == X509_V_OK)\n\t\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\t\tctx->xsc->error = ctx->error;\n\t\t}\n\n\t\t/*\n\t\t * Let the callback override the return value\n\t\t * at depth 0 if it chooses to\n\t\t */\n\t\treturn ctx->xsc->verify_cb(0, ctx->xsc);\n\t}\n\n\t/* We only ever find one chain in compat mode with an xsc. */\n\treturn 1;\n\n err:\n\tif (ctx->error == X509_V_OK)\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\tif (ctx->xsc != NULL) {\n\t\tif (ctx->xsc->error == X509_V_OK)\n\t\t\tctx->xsc->error = X509_V_ERR_UNSPECIFIED;\n\t\tctx->error = ctx->xsc->error;\n\t}\n\n\treturn 0;\n}\n"], "fixing_code": ["/* $OpenBSD: x509_verify.c,v 1.61 2022/10/17 18:56:54 jsing Exp $ */\n/*\n * Copyright (c) 2020-2021 Bob Beck <beck@openbsd.org>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n/* x509_verify - inspired by golang's crypto/x509.Verify */\n\n#include <errno.h>\n#include <stdio.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <openssl/safestack.h>\n#include <openssl/x509.h>\n#include <openssl/x509v3.h>\n\n#include \"x509_internal.h\"\n#include \"x509_issuer_cache.h\"\n\nstatic int x509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain);\nstatic int x509_verify_cert_hostname(struct x509_verify_ctx *ctx, X509 *cert,\n    char *name);\nstatic void x509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain, char *name);\nstatic int x509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert,\n    size_t depth, int error, int ok);\nstatic void x509_verify_chain_free(struct x509_verify_chain *chain);\n\n/*\n * Parse an asn1 to a representable time_t as per RFC 5280 rules.\n * Returns -1 if that can't be done for any reason.\n */\ntime_t\nx509_verify_asn1_time_to_time_t(const ASN1_TIME *atime, int notAfter)\n{\n\tstruct tm tm = { 0 };\n\tint type;\n\n\ttype = ASN1_time_parse(atime->data, atime->length, &tm, atime->type);\n\tif (type == -1)\n\t\treturn -1;\n\n\t/* RFC 5280 section 4.1.2.5 */\n\tif (tm.tm_year < 150 && type != V_ASN1_UTCTIME)\n\t\treturn -1;\n\tif (tm.tm_year >= 150 && type != V_ASN1_GENERALIZEDTIME)\n\t\treturn -1;\n\n\tif (notAfter) {\n\t\t/*\n\t\t * If we are a completely broken operating system with a\n\t\t * 32 bit time_t, and we have been told this is a notAfter\n\t\t * date, limit the date to a 32 bit representable value.\n\t\t */\n\t\tif (!ASN1_time_tm_clamp_notafter(&tm))\n\t\t\treturn -1;\n\t}\n\n\t/*\n\t * Defensively fail if the time string is not representable as\n\t * a time_t. A time_t must be sane if you care about times after\n\t * Jan 19 2038.\n\t */\n\treturn timegm(&tm);\n}\n\n/*\n * Cache certificate hash, and values parsed out of an X509.\n * called from cache_extensions()\n */\nvoid\nx509_verify_cert_info_populate(X509 *cert)\n{\n\t/*\n\t * Parse and save the cert times, or remember that they\n\t * are unacceptable/unparsable.\n\t */\n\tcert->not_before = x509_verify_asn1_time_to_time_t(X509_get_notBefore(cert), 0);\n\tcert->not_after = x509_verify_asn1_time_to_time_t(X509_get_notAfter(cert), 1);\n}\n\nstruct x509_verify_chain *\nx509_verify_chain_new(void)\n{\n\tstruct x509_verify_chain *chain;\n\n\tif ((chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((chain->certs = sk_X509_new_null()) == NULL)\n\t\tgoto err;\n\tif ((chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tif ((chain->names =\n\t    x509_constraints_names_new(X509_VERIFY_MAX_CHAIN_NAMES)) == NULL)\n\t\tgoto err;\n\n\treturn chain;\n err:\n\tx509_verify_chain_free(chain);\n\treturn NULL;\n}\n\nstatic void\nx509_verify_chain_clear(struct x509_verify_chain *chain)\n{\n\tsk_X509_pop_free(chain->certs, X509_free);\n\tchain->certs = NULL;\n\tfree(chain->cert_errors);\n\tchain->cert_errors = NULL;\n\tx509_constraints_names_free(chain->names);\n\tchain->names = NULL;\n}\n\nstatic void\nx509_verify_chain_free(struct x509_verify_chain *chain)\n{\n\tif (chain == NULL)\n\t\treturn;\n\tx509_verify_chain_clear(chain);\n\tfree(chain);\n}\n\nstatic struct x509_verify_chain *\nx509_verify_chain_dup(struct x509_verify_chain *chain)\n{\n\tstruct x509_verify_chain *new_chain;\n\n\tif ((new_chain = calloc(1, sizeof(*chain))) == NULL)\n\t\tgoto err;\n\tif ((new_chain->certs = X509_chain_up_ref(chain->certs)) == NULL)\n\t\tgoto err;\n\tif ((new_chain->cert_errors = calloc(X509_VERIFY_MAX_CHAIN_CERTS,\n\t    sizeof(int))) == NULL)\n\t\tgoto err;\n\tmemcpy(new_chain->cert_errors, chain->cert_errors,\n\t    X509_VERIFY_MAX_CHAIN_CERTS * sizeof(int));\n\tif ((new_chain->names =\n\t    x509_constraints_names_dup(chain->names)) == NULL)\n\t\tgoto err;\n\treturn(new_chain);\n err:\n\tx509_verify_chain_free(new_chain);\n\treturn NULL;\n}\n\nstatic int\nx509_verify_chain_append(struct x509_verify_chain *chain, X509 *cert,\n    int *error)\n{\n\tint verify_err = X509_V_ERR_UNSPECIFIED;\n\tsize_t idx;\n\n\tif (!x509_constraints_extract_names(chain->names, cert,\n\t    sk_X509_num(chain->certs) == 0, &verify_err)) {\n\t\t*error = verify_err;\n\t\treturn 0;\n\t}\n\n\tX509_up_ref(cert);\n\tif (!sk_X509_push(chain->certs, cert)) {\n\t\tX509_free(cert);\n\t\t*error = X509_V_ERR_OUT_OF_MEM;\n\t\treturn 0;\n\t}\n\n\tidx = sk_X509_num(chain->certs) - 1;\n\tchain->cert_errors[idx] = *error;\n\n\t/*\n\t * We've just added the issuer for the previous certificate,\n\t * clear its error if appropriate.\n\t */\n\tif (idx > 1 && chain->cert_errors[idx - 1] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[idx - 1] = X509_V_OK;\n\n\treturn 1;\n}\n\nstatic X509 *\nx509_verify_chain_last(struct x509_verify_chain *chain)\n{\n\tint last;\n\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\tif ((last = sk_X509_num(chain->certs) - 1) < 0)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, last);\n}\n\nX509 *\nx509_verify_chain_leaf(struct x509_verify_chain *chain)\n{\n\tif (chain->certs == NULL)\n\t\treturn NULL;\n\treturn sk_X509_value(chain->certs, 0);\n}\n\nstatic void\nx509_verify_ctx_reset(struct x509_verify_ctx *ctx)\n{\n\tsize_t i;\n\n\tfor (i = 0; i < ctx->chains_count; i++)\n\t\tx509_verify_chain_free(ctx->chains[i]);\n\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\tctx->saved_error = 0;\n\tctx->saved_error_depth = 0;\n\tctx->error = 0;\n\tctx->error_depth = 0;\n\tctx->chains_count = 0;\n\tctx->sig_checks = 0;\n\tctx->check_time = NULL;\n}\n\nstatic void\nx509_verify_ctx_clear(struct x509_verify_ctx *ctx)\n{\n\tx509_verify_ctx_reset(ctx);\n\tsk_X509_pop_free(ctx->intermediates, X509_free);\n\tfree(ctx->chains);\n\n}\n\nstatic int\nx509_verify_cert_cache_extensions(X509 *cert)\n{\n\tif (!(cert->ex_flags & EXFLAG_SET)) {\n\t\tCRYPTO_w_lock(CRYPTO_LOCK_X509);\n\t\tx509v3_cache_extensions(cert);\n\t\tCRYPTO_w_unlock(CRYPTO_LOCK_X509);\n\t}\n\tif (cert->ex_flags & EXFLAG_INVALID)\n\t\treturn 0;\n\n\treturn (cert->ex_flags & EXFLAG_SET);\n}\n\nstatic int\nx509_verify_cert_self_signed(X509 *cert)\n{\n\treturn (cert->ex_flags & EXFLAG_SS) ? 1 : 0;\n}\n\n/* XXX beck - clean up this mess of is_root */\nstatic int\nx509_verify_check_chain_end(X509 *cert, int full_chain)\n{\n\tif (full_chain)\n\t\treturn x509_verify_cert_self_signed(cert);\n\treturn 1;\n}\n\nstatic int\nx509_verify_ctx_cert_is_root(struct x509_verify_ctx *ctx, X509 *cert,\n    int full_chain)\n{\n\tX509 *match = NULL;\n\tint i;\n\n\tif (!x509_verify_cert_cache_extensions(cert))\n\t\treturn 0;\n\n\t/* Check by lookup if we have a legacy xsc */\n\tif (ctx->xsc != NULL) {\n\t\tif ((match = x509_vfy_lookup_cert_match(ctx->xsc,\n\t\t    cert)) != NULL) {\n\t\t\tX509_free(match);\n\t\t\treturn x509_verify_check_chain_end(cert, full_chain);\n\n\t\t}\n\t} else {\n\t\t/* Check the provided roots */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tif (X509_cmp(sk_X509_value(ctx->roots, i), cert) == 0)\n\t\t\t\treturn x509_verify_check_chain_end(cert,\n\t\t\t\t    full_chain);\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int\nx509_verify_ctx_set_xsc_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, int set_error, int is_trusted)\n{\n\tsize_t num_untrusted;\n\tint i;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * XXX num_untrusted is the number of untrusted certs at the\n\t * bottom of the chain. This works now since we stop at the first\n\t * trusted cert. This will need fixing once we allow more than one\n\t * trusted certificate.\n\t */\n\tnum_untrusted = sk_X509_num(chain->certs);\n\tif (is_trusted && num_untrusted > 0)\n\t\tnum_untrusted--;\n\tctx->xsc->num_untrusted = num_untrusted;\n\n\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\tctx->xsc->chain = X509_chain_up_ref(chain->certs);\n\tif (ctx->xsc->chain == NULL)\n\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\n\tif (set_error) {\n\t\tctx->xsc->error = X509_V_OK;\n\t\tctx->xsc->error_depth = 0;\n\t\tfor (i = 0; i < sk_X509_num(chain->certs); i++) {\n\t\t\tif (chain->cert_errors[i] != X509_V_OK) {\n\t\t\t\tctx->xsc->error = chain->cert_errors[i];\n\t\t\t\tctx->xsc->error_depth = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\n/*\n * Save the error state and unvalidated chain off of the xsc for\n * later.\n */\nstatic int\nx509_verify_ctx_save_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->xsc->chain != NULL) {\n\t\tsk_X509_pop_free(ctx->saved_error_chain, X509_free);\n\t\tctx->saved_error_chain = X509_chain_up_ref(ctx->xsc->chain);\n\t\tif (ctx->saved_error_chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->saved_error = ctx->xsc->error;\n\t\tctx->saved_error_depth = ctx->xsc->error_depth;\n\t}\n\treturn 1;\n}\n\n/*\n * Restore the saved error state and unvalidated chain to the xsc\n * if we do not have a validated chain.\n */\nstatic int\nx509_verify_ctx_restore_xsc_error(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL && ctx->chains_count == 0 &&\n\t    ctx->saved_error_chain != NULL) {\n\t\tsk_X509_pop_free(ctx->xsc->chain, X509_free);\n\t\tctx->xsc->chain = X509_chain_up_ref(ctx->saved_error_chain);\n\t\tif (ctx->xsc->chain == NULL)\n\t\t\treturn x509_verify_cert_error(ctx, NULL, 0,\n\t\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\tctx->xsc->error = ctx->saved_error;\n\t\tctx->xsc->error_depth = ctx->saved_error_depth;\n\t}\n\treturn 1;\n}\n\n/* Perform legacy style validation of a chain */\nstatic int\nx509_verify_ctx_validate_legacy_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, size_t depth)\n{\n\tint ret = 0, trust;\n\n\tif (ctx->xsc == NULL)\n\t\treturn 1;\n\n\t/*\n\t * If we have a legacy xsc, choose a validated chain, and\n\t * apply the extensions, revocation, and policy checks just\n\t * like the legacy code did. We do this here instead of as\n\t * building the chains to more easily support the callback and\n\t * the bewildering array of VERIFY_PARAM knobs that are there\n\t * for the fiddling.\n\t */\n\n\t/* These may be set in one of the following calls. */\n\tctx->xsc->error = X509_V_OK;\n\tctx->xsc->error_depth = 0;\n\n\tif (!x509_verify_ctx_set_xsc_chain(ctx, chain, 0, 1))\n\t\tgoto err;\n\n\t/*\n\t * Call the legacy code to walk the chain and check trust\n\t * in the legacy way to handle partial chains and get the\n\t * callback fired correctly.\n\t */\n\ttrust = x509_vfy_check_trust(ctx->xsc);\n\tif (trust == X509_TRUST_REJECTED)\n\t\tgoto err; /* callback was called in x509_vfy_check_trust */\n\tif (trust != X509_TRUST_TRUSTED) {\n\t\t/* NOTREACHED */\n\t\tgoto err;  /* should not happen if we get in here - abort? */\n\t}\n\n\t/*\n\t * XXX currently this duplicates some work done in chain\n\t * build, but we keep it here until we have feature parity\n\t */\n\tif (!x509_vfy_check_chain_extensions(ctx->xsc))\n\t\tgoto err;\n\n#ifndef OPENSSL_NO_RFC3779\n\tif (!X509v3_asid_validate_path(ctx->xsc))\n\t\tgoto err;\n\n\tif (!X509v3_addr_validate_path(ctx->xsc))\n\t\tgoto err;\n#endif\n\n\tif (!x509_vfy_check_security_level(ctx->xsc))\n\t\tgoto err;\n\n\tif (!x509_constraints_chain(ctx->xsc->chain,\n\t\t&ctx->xsc->error, &ctx->xsc->error_depth)) {\n\t\tX509 *cert = sk_X509_value(ctx->xsc->chain, depth);\n\t\tif (!x509_verify_cert_error(ctx, cert,\n\t\t\tctx->xsc->error_depth, ctx->xsc->error, 0))\n\t\t\tgoto err;\n\t}\n\n\tif (!x509_vfy_check_revocation(ctx->xsc))\n\t\tgoto err;\n\n\tif (!x509_vfy_check_policy(ctx->xsc))\n\t\tgoto err;\n\n\tret = 1;\n\n err:\n\t/*\n\t * The above checks may have set ctx->xsc->error and\n\t * ctx->xsc->error_depth - save these for later on.\n\t */\n\tif (ctx->xsc->error != X509_V_OK) {\n\t\tif (ctx->xsc->error_depth < 0 ||\n\t\t    ctx->xsc->error_depth >= X509_VERIFY_MAX_CHAIN_CERTS)\n\t\t\treturn 0;\n\t\tchain->cert_errors[ctx->xsc->error_depth] =\n\t\t    ctx->xsc->error;\n\t\tctx->error_depth = ctx->xsc->error_depth;\n\t}\n\n\treturn ret;\n}\n\n/* Add a validated chain to our list of valid chains */\nstatic int\nx509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\n\t/* Clear a get issuer failure for a root certificate. */\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\n\t/* Verify the leaf certificate and store any resulting error. */\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tif (ctx->error_depth == 0 &&\n\t    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[0] = ctx->error;\n\n\t/*\n\t * In the non-legacy code, extensions and purpose are dealt\n\t * with as the chain is built.\n\t *\n\t * The non-legacy api returns multiple chains but does not do\n\t * any revocation checking (it must be done by the caller on\n\t * any chain they wish to use)\n\t */\n\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tctx->chains_count++;\n\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\n\treturn 1;\n}\n\nstatic int\nx509_verify_potential_parent(struct x509_verify_ctx *ctx, X509 *parent,\n    X509 *child)\n{\n\tif (!x509_verify_cert_cache_extensions(parent))\n\t\treturn 0;\n\tif (ctx->xsc != NULL)\n\t\treturn (ctx->xsc->check_issued(ctx->xsc, child, parent));\n\n\t/* XXX key usage */\n\treturn X509_check_issued(child, parent) != X509_V_OK;\n}\n\nstatic int\nx509_verify_parent_signature(X509 *parent, X509 *child, int *error)\n{\n\tEVP_PKEY *pkey;\n\tint cached;\n\tint ret = 0;\n\n\t/* Use cached value if we have it */\n\tif ((cached = x509_issuer_cache_find(parent->hash, child->hash)) >= 0)\n\t\treturn cached;\n\n\t/* Check signature. Did parent sign child? */\n\tif ((pkey = X509_get_pubkey(parent)) == NULL) {\n\t\t*error = X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\n\t\treturn 0;\n\t}\n\tif (X509_verify(child, pkey) <= 0)\n\t\t*error = X509_V_ERR_CERT_SIGNATURE_FAILURE;\n\telse\n\t\tret = 1;\n\n\t/* Add result to cache */\n\tx509_issuer_cache_add(parent->hash, child->hash, ret);\n\n\tEVP_PKEY_free(pkey);\n\n\treturn ret;\n}\n\nstatic int\nx509_verify_consider_candidate(struct x509_verify_ctx *ctx, X509 *cert,\n    int is_root_cert, X509 *candidate, struct x509_verify_chain *current_chain,\n    int full_chain, char *name)\n{\n\tint depth = sk_X509_num(current_chain->certs);\n\tstruct x509_verify_chain *new_chain;\n\tint i;\n\n\t/* Fail if the certificate is already in the chain */\n\tfor (i = 0; i < sk_X509_num(current_chain->certs); i++) {\n\t\tif (X509_cmp(sk_X509_value(current_chain->certs, i),\n\t\t    candidate) == 0)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx->sig_checks++ > X509_VERIFY_MAX_SIGCHECKS) {\n\t\t/* don't allow callback to override safety check */\n\t\t(void) x509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\t\treturn 0;\n\t}\n\n\tif (!x509_verify_parent_signature(candidate, cert, &ctx->error)) {\n\t\tif (!x509_verify_cert_error(ctx, candidate, depth,\n\t\t    ctx->error, 0))\n\t\t\treturn 0;\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, candidate, current_chain))\n\t\treturn 0;\n\n\t/* candidate is good, add it to a copy of the current chain */\n\tif ((new_chain = x509_verify_chain_dup(current_chain)) == NULL) {\n\t\tx509_verify_cert_error(ctx, candidate, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t\treturn 0;\n\t}\n\tif (!x509_verify_chain_append(new_chain, candidate, &ctx->error)) {\n\t\tx509_verify_cert_error(ctx, candidate, depth, ctx->error, 0);\n\t\tx509_verify_chain_free(new_chain);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If candidate is a trusted root, we have a validated chain,\n\t * so we save it.  Otherwise, recurse until we find a root or\n\t * give up.\n\t */\n\tif (is_root_cert) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, new_chain, 0, 1)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!x509_verify_ctx_add_chain(ctx, new_chain, name)) {\n\t\t\tx509_verify_chain_free(new_chain);\n\t\t\treturn 0;\n\t\t}\n\t\tgoto done;\n\t}\n\n\tx509_verify_build_chains(ctx, candidate, new_chain, full_chain, name);\n\n done:\n\tx509_verify_chain_free(new_chain);\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_error(struct x509_verify_ctx *ctx, X509 *cert, size_t depth,\n    int error, int ok)\n{\n\tctx->error = error;\n\tctx->error_depth = depth;\n\tif (ctx->xsc != NULL) {\n\t\tctx->xsc->error = error;\n\t\tctx->xsc->error_depth = depth;\n\t\tctx->xsc->current_cert = cert;\n\t\treturn ctx->xsc->verify_cb(ok, ctx->xsc);\n\t}\n\treturn ok;\n}\n\nstatic void\nx509_verify_build_chains(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain, int full_chain, char *name)\n{\n\tX509 *candidate;\n\tint i, depth, count, ret, is_root;\n\n\t/*\n\t * If we are finding chains with an xsc, just stop after we have\n\t * one chain, there's no point in finding more, it just exercises\n\t * the potentially buggy callback processing in the calling software.\n\t */\n\tif (ctx->xsc != NULL && ctx->chains_count > 0)\n\t\treturn;\n\n\tdepth = sk_X509_num(current_chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (depth >= ctx->max_depth &&\n\t    !x509_verify_cert_error(ctx, cert, depth,\n\t\tX509_V_ERR_CERT_CHAIN_TOO_LONG, 0))\n\t\treturn;\n\n\tcount = ctx->chains_count;\n\n\tctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n\tctx->error_depth = depth;\n\n\tif (ctx->saved_error != 0)\n\t\tctx->error = ctx->saved_error;\n\tif (ctx->saved_error_depth != 0)\n\t\tctx->error_depth = ctx->saved_error_depth;\n\n\tif (ctx->xsc != NULL) {\n\t\t/*\n\t\t * Long ago experiments at Muppet labs resulted in a\n\t\t * situation where software not only sees these errors\n\t\t * but forced developers to expect them in certain cases.\n\t\t * so we must mimic this awfulness for the legacy case.\n\t\t */\n\t\tif (cert->ex_flags & EXFLAG_SS)\n\t\t\tctx->error = (depth == 0) ?\n\t\t\t    X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT:\n\t\t\t    X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n\t}\n\n\t/* Check for legacy mode roots */\n\tif (ctx->xsc != NULL) {\n\t\tif ((ret = ctx->xsc->get_issuer(&candidate, ctx->xsc, cert)) < 0) {\n\t\t\tx509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_STORE_LOOKUP, 0);\n\t\t\treturn;\n\t\t}\n\t\tif (ret > 0) {\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = x509_verify_check_chain_end(candidate,\n\t\t\t\t    full_chain);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain, name);\n\t\t\t}\n\t\t\tX509_free(candidate);\n\t\t}\n\t} else {\n\t\t/* Check to see if we have a trusted root issuer. */\n\t\tfor (i = 0; i < sk_X509_num(ctx->roots); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->roots, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tis_root = x509_verify_check_chain_end(candidate,\n\t\t\t\t    full_chain);\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    is_root, candidate, current_chain,\n\t\t\t\t    full_chain, name);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Check intermediates after checking roots */\n\tif (ctx->intermediates != NULL) {\n\t\tfor (i = 0; i < sk_X509_num(ctx->intermediates); i++) {\n\t\t\tcandidate = sk_X509_value(ctx->intermediates, i);\n\t\t\tif (x509_verify_potential_parent(ctx, candidate, cert)) {\n\t\t\t\tx509_verify_consider_candidate(ctx, cert,\n\t\t\t\t    0, candidate, current_chain,\n\t\t\t\t    full_chain, name);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ctx->chains_count > count) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tctx->xsc->error = X509_V_OK;\n\t\t\tctx->xsc->error_depth = depth;\n\t\t\tctx->xsc->current_cert = cert;\n\t\t}\n\t} else if (ctx->error_depth == depth) {\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, current_chain, 0, 0))\n\t\t\treturn;\n\t}\n}\n\nstatic int\nx509_verify_cert_hostname(struct x509_verify_ctx *ctx, X509 *cert, char *name)\n{\n\tchar *candidate;\n\tsize_t len;\n\n\tif (name == NULL) {\n\t\tif (ctx->xsc != NULL) {\n\t\t\tint ret;\n\n\t\t\tif ((ret = x509_vfy_check_id(ctx->xsc)) == 0)\n\t\t\t\tctx->error = ctx->xsc->error;\n\t\t\treturn ret;\n\t\t}\n\t\treturn 1;\n\t}\n\tif ((candidate = strdup(name)) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\tif ((len = strlen(candidate)) < 1) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED; /* XXX */\n\t\tgoto err;\n\t}\n\n\t/* IP addresses may be written in [ ]. */\n\tif (candidate[0] == '[' && candidate[len - 1] == ']') {\n\t\tcandidate[len - 1] = '\\0';\n\t\tif (X509_check_ip_asc(cert, candidate + 1, 0) <= 0) {\n\t\t\tctx->error = X509_V_ERR_IP_ADDRESS_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t} else {\n\t\tint flags = 0;\n\n\t\tif (ctx->xsc == NULL)\n\t\t\tflags = X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;\n\n\t\tif (X509_check_host(cert, candidate, len, flags, NULL) <= 0) {\n\t\t\tctx->error = X509_V_ERR_HOSTNAME_MISMATCH;\n\t\t\tgoto err;\n\t\t}\n\t}\n\tfree(candidate);\n\treturn 1;\n err:\n\tfree(candidate);\n\treturn x509_verify_cert_error(ctx, cert, 0, ctx->error, 0);\n}\n\nstatic int\nx509_verify_set_check_time(struct x509_verify_ctx *ctx)\n{\n\tif (ctx->xsc != NULL)  {\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_USE_CHECK_TIME) {\n\t\t\tctx->check_time = &ctx->xsc->param->check_time;\n\t\t\treturn 1;\n\t\t}\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_NO_CHECK_TIME)\n\t\t\treturn 0;\n\t}\n\n\tctx->check_time = NULL;\n\treturn 1;\n}\n\nstatic int\nx509_verify_cert_times(X509 *cert, time_t *cmp_time, int *error)\n{\n\ttime_t when;\n\n\tif (cmp_time == NULL)\n\t\twhen = time(NULL);\n\telse\n\t\twhen = *cmp_time;\n\n\tif (cert->not_before == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\n\t\treturn 0;\n\t}\n\tif (when < cert->not_before) {\n\t\t*error = X509_V_ERR_CERT_NOT_YET_VALID;\n\t\treturn 0;\n\t}\n\tif (cert->not_after == -1) {\n\t\t*error = X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\n\t\treturn 0;\n\t}\n\tif (when > cert->not_after) {\n\t\t*error = X509_V_ERR_CERT_HAS_EXPIRED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int\nx509_verify_validate_constraints(X509 *cert,\n    struct x509_verify_chain *current_chain, int *error)\n{\n\tstruct x509_constraints_names *excluded = NULL;\n\tstruct x509_constraints_names *permitted = NULL;\n\tint err = X509_V_ERR_UNSPECIFIED;\n\n\tif (current_chain == NULL)\n\t\treturn 1;\n\n\tif (cert->nc != NULL) {\n\t\tif ((permitted = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif ((excluded = x509_constraints_names_new(\n\t\t    X509_VERIFY_MAX_CHAIN_CONSTRAINTS)) == NULL) {\n\t\t\terr = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!x509_constraints_extract_constraints(cert,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tif (!x509_constraints_check(current_chain->names,\n\t\t    permitted, excluded, &err))\n\t\t\tgoto err;\n\t\tx509_constraints_names_free(excluded);\n\t\tx509_constraints_names_free(permitted);\n\t}\n\n\treturn 1;\n err:\n\t*error = err;\n\tx509_constraints_names_free(excluded);\n\tx509_constraints_names_free(permitted);\n\treturn 0;\n}\n\nstatic int\nx509_verify_cert_extensions(struct x509_verify_ctx *ctx, X509 *cert, int need_ca)\n{\n\tif (!x509_verify_cert_cache_extensions(cert)) {\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\treturn 0;\n\t}\n\n\tif (ctx->xsc != NULL)\n\t\treturn 1;\t/* legacy is checked after chain is built */\n\n\tif (cert->ex_flags & EXFLAG_CRITICAL) {\n\t\tctx->error = X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\n\t\treturn 0;\n\t}\n\t/* No we don't care about v1, netscape, and other ancient silliness */\n\tif (need_ca && (!(cert->ex_flags & EXFLAG_BCONS) &&\n\t    (cert->ex_flags & EXFLAG_CA))) {\n\t\tctx->error = X509_V_ERR_INVALID_CA;\n\t\treturn 0;\n\t}\n\tif (ctx->purpose > 0 && X509_check_purpose(cert, ctx->purpose, need_ca)) {\n\t\tctx->error = X509_V_ERR_INVALID_PURPOSE;\n\t\treturn 0;\n\t}\n\n\t/* XXX support proxy certs later in new api */\n\tif (ctx->xsc == NULL && cert->ex_flags & EXFLAG_PROXY) {\n\t\tctx->error = X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n/* Validate that cert is a possible candidate to append to current_chain */\nstatic int\nx509_verify_cert_valid(struct x509_verify_ctx *ctx, X509 *cert,\n    struct x509_verify_chain *current_chain)\n{\n\tX509 *issuer_candidate;\n\tint should_be_ca = current_chain != NULL;\n\tsize_t depth = 0;\n\n\tif (current_chain != NULL)\n\t\tdepth = sk_X509_num(current_chain->certs);\n\n\tif (!x509_verify_cert_extensions(ctx, cert, should_be_ca))\n\t\treturn 0;\n\n\tif (should_be_ca) {\n\t\tissuer_candidate = x509_verify_chain_last(current_chain);\n\t\tif (issuer_candidate != NULL &&\n\t\t    !X509_check_issued(issuer_candidate, cert))\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    X509_V_ERR_SUBJECT_ISSUER_MISMATCH, 0))\n\t\t\t\treturn 0;\n\t}\n\n\tif (x509_verify_set_check_time(ctx)) {\n\t\tif (!x509_verify_cert_times(cert, ctx->check_time,\n\t\t    &ctx->error)) {\n\t\t\tif (!x509_verify_cert_error(ctx, cert, depth,\n\t\t\t    ctx->error, 0))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!x509_verify_validate_constraints(cert, current_chain,\n\t    &ctx->error) && !x509_verify_cert_error(ctx, cert, depth,\n\t    ctx->error, 0))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new_from_xsc(X509_STORE_CTX *xsc)\n{\n\tstruct x509_verify_ctx *ctx;\n\tsize_t max_depth;\n\n\tif (xsc == NULL)\n\t\treturn NULL;\n\n\tif ((ctx = x509_verify_ctx_new(NULL)) == NULL)\n\t\treturn NULL;\n\n\tctx->xsc = xsc;\n\n\tif (xsc->untrusted &&\n\t    (ctx->intermediates = X509_chain_up_ref(xsc->untrusted)) == NULL)\n\t\tgoto err;\n\n\tmax_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tif (xsc->param->depth > 0 && xsc->param->depth < X509_VERIFY_MAX_CHAIN_CERTS)\n\t\tmax_depth = xsc->param->depth;\n\tif (!x509_verify_ctx_set_max_depth(ctx, max_depth))\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\n/* Public API */\n\nstruct x509_verify_ctx *\nx509_verify_ctx_new(STACK_OF(X509) *roots)\n{\n\tstruct x509_verify_ctx *ctx;\n\n\tif ((ctx = calloc(1, sizeof(struct x509_verify_ctx))) == NULL)\n\t\treturn NULL;\n\n\tif (roots != NULL) {\n\t\tif  ((ctx->roots = X509_chain_up_ref(roots)) == NULL)\n\t\t\tgoto err;\n\t} else {\n\t\tif ((ctx->roots = sk_X509_new_null()) == NULL)\n\t\t\tgoto err;\n\t}\n\n\tctx->max_depth = X509_VERIFY_MAX_CHAIN_CERTS;\n\tctx->max_chains = X509_VERIFY_MAX_CHAINS;\n\tctx->max_sigs = X509_VERIFY_MAX_SIGCHECKS;\n\n\tif ((ctx->chains = calloc(X509_VERIFY_MAX_CHAINS,\n\t    sizeof(*ctx->chains))) == NULL)\n\t\tgoto err;\n\n\treturn ctx;\n err:\n\tx509_verify_ctx_free(ctx);\n\treturn NULL;\n}\n\nvoid\nx509_verify_ctx_free(struct x509_verify_ctx *ctx)\n{\n\tif (ctx == NULL)\n\t\treturn;\n\tsk_X509_pop_free(ctx->roots, X509_free);\n\tx509_verify_ctx_clear(ctx);\n\tfree(ctx);\n}\n\nint\nx509_verify_ctx_set_max_depth(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAIN_CERTS)\n\t\treturn 0;\n\tctx->max_depth = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_chains(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > X509_VERIFY_MAX_CHAINS)\n\t\treturn 0;\n\tctx->max_chains = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_max_signatures(struct x509_verify_ctx *ctx, size_t max)\n{\n\tif (max < 1 || max > 100000)\n\t\treturn 0;\n\tctx->max_sigs = max;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_purpose(struct x509_verify_ctx *ctx, int purpose)\n{\n\tif (purpose < X509_PURPOSE_MIN || purpose > X509_PURPOSE_MAX)\n\t\treturn 0;\n\tctx->purpose = purpose;\n\treturn 1;\n}\n\nint\nx509_verify_ctx_set_intermediates(struct x509_verify_ctx *ctx,\n    STACK_OF(X509) *intermediates)\n{\n\tif ((ctx->intermediates = X509_chain_up_ref(intermediates)) == NULL)\n\t\treturn 0;\n\treturn 1;\n}\n\nconst char *\nx509_verify_ctx_error_string(struct x509_verify_ctx *ctx)\n{\n\treturn X509_verify_cert_error_string(ctx->error);\n}\n\nsize_t\nx509_verify_ctx_error_depth(struct x509_verify_ctx *ctx)\n{\n\treturn ctx->error_depth;\n}\n\nSTACK_OF(X509) *\nx509_verify_ctx_chain(struct x509_verify_ctx *ctx, size_t i)\n{\n\tif (i >= ctx->chains_count)\n\t\treturn NULL;\n\treturn ctx->chains[i]->certs;\n}\n\nsize_t\nx509_verify(struct x509_verify_ctx *ctx, X509 *leaf, char *name)\n{\n\tstruct x509_verify_chain *current_chain;\n\tint retry_chain_build, full_chain = 0;\n\n\tif (ctx->roots == NULL || ctx->max_depth == 0) {\n\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\tgoto err;\n\t}\n\n\tif (ctx->xsc != NULL) {\n\t\tif (leaf != NULL || name != NULL) {\n\t\t\tctx->error = X509_V_ERR_INVALID_CALL;\n\t\t\tgoto err;\n\t\t}\n\t\tleaf = ctx->xsc->cert;\n\n\t\t/* XXX */\n\t\tfull_chain = 1;\n\t\tif (ctx->xsc->param->flags & X509_V_FLAG_PARTIAL_CHAIN)\n\t\t\tfull_chain = 0;\n\t\t/*\n\t\t * XXX\n\t\t * The legacy code expects the top level cert to be\n\t\t * there, even if we didn't find a chain. So put it\n\t\t * there, we will clobber it later if we find a valid\n\t\t * chain.\n\t\t */\n\t\tif ((ctx->xsc->chain = sk_X509_new_null()) == NULL) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!X509_up_ref(leaf)) {\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tif (!sk_X509_push(ctx->xsc->chain, leaf)) {\n\t\t\tX509_free(leaf);\n\t\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\t\tgoto err;\n\t\t}\n\t\tctx->xsc->error_depth = 0;\n\t\tctx->xsc->current_cert = leaf;\n\t}\n\n\tif ((current_chain = x509_verify_chain_new()) == NULL) {\n\t\tctx->error = X509_V_ERR_OUT_OF_MEM;\n\t\tgoto err;\n\t}\n\n\t/*\n\t * Add the leaf to the chain and try to build chains from it.\n\t * Note that unlike Go's verifier, we have not yet checked\n\t * anything about the leaf, This is intentional, so that we\n\t * report failures in chain building before we report problems\n\t * with the leaf.\n\t */\n\tif (!x509_verify_chain_append(current_chain, leaf, &ctx->error)) {\n\t\tx509_verify_chain_free(current_chain);\n\t\tgoto err;\n\t}\n\tdo {\n\t\tretry_chain_build = 0;\n\t\tif (x509_verify_ctx_cert_is_root(ctx, leaf, full_chain)) {\n\t\t\tif (!x509_verify_ctx_add_chain(ctx, current_chain,\n\t\t\t    name)) {\n\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t} else {\n\t\t\tx509_verify_build_chains(ctx, leaf, current_chain,\n\t\t\t    full_chain, name);\n\t\t\tif (full_chain && ctx->chains_count == 0) {\n\t\t\t\t/*\n\t\t\t\t * Save the error state from the xsc\n\t\t\t\t * at this point to put back on the\n\t\t\t\t * xsc in case we do not find a chain\n\t\t\t\t * that is trusted but not a full\n\t\t\t\t * chain to a self signed root. This\n\t\t\t\t * is because the unvalidated chain is\n\t\t\t\t * used by the autochain batshittery\n\t\t\t\t * on failure and will be needed for\n\t\t\t\t * that.\n\t\t\t\t */\n\t\t\t\tctx->xsc->error_depth = ctx->error_depth;\n\t\t\t\tif (!x509_verify_ctx_save_xsc_error(ctx)) {\n\t\t\t\t\tx509_verify_chain_free(current_chain);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tfull_chain = 0;\n\t\t\t\tretry_chain_build = 1;\n\t\t\t}\n\t\t}\n\t} while (retry_chain_build);\n\n\tx509_verify_chain_free(current_chain);\n\n\t/*\n\t * Do the new verifier style return, where we don't have an xsc\n\t * that allows a crazy callback to turn invalid things into valid.\n\t */\n\tif (ctx->xsc == NULL) {\n\t\t/*\n\t\t * Safety net:\n\t\t * We could not find a validated chain, and for some reason do not\n\t\t * have an error set.\n\t\t */\n\t\tif (ctx->chains_count == 0 && ctx->error == X509_V_OK)\n\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\t\t/*\n\t\t * If we are not using an xsc, and have no possibility for the\n\t\t * crazy OpenSSL callback API changing the results of\n\t\t * validation steps (because the callback can make validation\n\t\t * proceed in the presence of invalid certs), any chains we\n\t\t * have here are correctly built and verified.\n\t\t */\n\t\tif (ctx->chains_count > 0)\n\t\t\tctx->error = X509_V_OK;\n\n\t\treturn ctx->chains_count;\n\t}\n\n\t/*\n\t * Otherwise we are doing compatibility with an xsc, which means that we\n\t * will have one chain, which might actually be a bogus chain because\n\t * the callback told us to ignore errors and proceed to build an invalid\n\t * chain. Possible return values from this include returning 1 with an\n\t * invalid chain and a value of xsc->error != X509_V_OK (It's tradition\n\t * that makes it ok).\n\t */\n\n\tif (ctx->chains_count > 0) {\n\t\t/*\n\t\t * The chain we have using an xsc might not be a verified chain\n\t\t * if the callback perverted things while we built it to ignore\n\t\t * failures and proceed with chain building. We put this chain\n\t\t * and the error associated with it on the xsc.\n\t\t */\n\t\tif (!x509_verify_ctx_set_xsc_chain(ctx, ctx->chains[0], 1, 1))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Call the callback for completion up our built\n\t\t * chain. The callback could still tell us to\n\t\t * fail. Since this chain might exist as the result of\n\t\t * callback doing perversions, we could still return\n\t\t * \"success\" with something other than X509_V_OK set\n\t\t * as the error.\n\t\t */\n\t\tif (!x509_vfy_callback_indicate_completion(ctx->xsc))\n\t\t\tgoto err;\n\t} else {\n\t\t/*\n\t\t * We did not find a chain. Bring back the failure\n\t\t * case we wanted to the xsc if we saved one. If we\n\t\t * did not we should have just the leaf on the xsc.\n\t\t */\n\t\tif (!x509_verify_ctx_restore_xsc_error(ctx))\n\t\t\tgoto err;\n\n\t\t/*\n\t\t * Safety net, ensure we have an error set in the\n\t\t * failing case.\n\t\t */\n\t\tif (ctx->xsc->error == X509_V_OK) {\n\t\t\tif (ctx->error == X509_V_OK)\n\t\t\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\t\t\tctx->xsc->error = ctx->error;\n\t\t}\n\n\t\t/*\n\t\t * Let the callback override the return value\n\t\t * at depth 0 if it chooses to\n\t\t */\n\t\treturn ctx->xsc->verify_cb(0, ctx->xsc);\n\t}\n\n\t/* We only ever find one chain in compat mode with an xsc. */\n\treturn 1;\n\n err:\n\tif (ctx->error == X509_V_OK)\n\t\tctx->error = X509_V_ERR_UNSPECIFIED;\n\n\tif (ctx->xsc != NULL) {\n\t\tif (ctx->xsc->error == X509_V_OK)\n\t\t\tctx->xsc->error = X509_V_ERR_UNSPECIFIED;\n\t\tctx->error = ctx->xsc->error;\n\t}\n\n\treturn 0;\n}\n"], "filenames": ["lib/libcrypto/x509/x509_verify.c"], "buggy_code_start_loc": [1], "buggy_code_end_loc": [520], "fixing_code_start_loc": [1], "fixing_code_end_loc": [525], "type": "CWE-295", "message": "An issue was discovered in x509/x509_verify.c in LibreSSL before 3.6.1, and in OpenBSD before 7.2 errata 001. x509_verify_ctx_add_chain does not store errors that occur during leaf certificate verification, and therefore an incorrect error is returned. This behavior occurs when there is an installed verification callback that instructs the verifier to continue upon detecting an invalid certificate.", "other": {"cve": {"id": "CVE-2022-48437", "sourceIdentifier": "cve@mitre.org", "published": "2023-04-12T05:15:07.653", "lastModified": "2023-04-21T14:17:04.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in x509/x509_verify.c in LibreSSL before 3.6.1, and in OpenBSD before 7.2 errata 001. x509_verify_ctx_add_chain does not store errors that occur during leaf certificate verification, and therefore an incorrect error is returned. This behavior occurs when there is an installed verification callback that instructs the verifier to continue upon detecting an invalid certificate."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 3.9, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-295"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:openbsd:libressl:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.6.1", "matchCriteriaId": "0298D8BA-8BA9-42DF-994A-4A79D2371D45"}, {"vulnerable": true, "criteria": "cpe:2.3:o:openbsd:openbsd:*:*:*:*:*:*:*:*", "versionEndExcluding": "7.2", "matchCriteriaId": "F42281B6-FE3A-408F-83DA-180AC67F2C3D"}]}]}], "references": [{"url": "https://ftp.openbsd.org/pub/OpenBSD/patches/7.2/common/001_x509.patch.sig", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/openbsd/src/commit/4f94258c65a918ee3d8670e93916d15bf879e6ec", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/openbsd/src/commit/4f94258c65a918ee3d8670e93916d15bf879e6ec"}}