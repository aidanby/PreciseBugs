{"buggy_code": ["// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage nistec_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/elliptic\"\n\t\"math/big\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"filippo.io/nistec\"\n)\n\nfunc TestAllocations(t *testing.T) {\n\tt.Run(\"P224\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP224Point().SetGenerator()\n\t\t\tscalar := make([]byte, 28)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP224Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n\tt.Run(\"P256\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP256Point().SetGenerator()\n\t\t\tscalar := make([]byte, 32)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP256Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n\tt.Run(\"P384\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP384Point().SetGenerator()\n\t\t\tscalar := make([]byte, 48)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP384Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n\tt.Run(\"P521\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP521Point().SetGenerator()\n\t\t\tscalar := make([]byte, 66)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP521Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n}\n\ntype nistPoint[T any] interface {\n\tBytes() []byte\n\tSetGenerator() T\n\tSetBytes([]byte) (T, error)\n\tAdd(T, T) T\n\tDouble(T) T\n\tScalarMult(T, []byte) (T, error)\n\tScalarBaseMult([]byte) (T, error)\n}\n\nfunc TestEquivalents(t *testing.T) {\n\tt.Run(\"P224\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP224Point, elliptic.P224())\n\t})\n\tt.Run(\"P256\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP256Point, elliptic.P256())\n\t})\n\tt.Run(\"P384\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP384Point, elliptic.P384())\n\t})\n\tt.Run(\"P521\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP521Point, elliptic.P521())\n\t})\n}\n\nfunc testEquivalents[P nistPoint[P]](t *testing.T, newPoint func() P, c elliptic.Curve) {\n\tp := newPoint().SetGenerator()\n\n\telementSize := (c.Params().BitSize + 7) / 8\n\ttwo := make([]byte, elementSize)\n\ttwo[len(two)-1] = 2\n\tnPlusTwo := make([]byte, elementSize)\n\tnew(big.Int).Add(c.Params().N, big.NewInt(2)).FillBytes(nPlusTwo)\n\n\tp1 := newPoint().Double(p)\n\tp2 := newPoint().Add(p, p)\n\tp3, err := newPoint().ScalarMult(p, two)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp4, err := newPoint().ScalarBaseMult(two)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp5, err := newPoint().ScalarMult(p, nPlusTwo)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp6, err := newPoint().ScalarBaseMult(nPlusTwo)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !bytes.Equal(p1.Bytes(), p2.Bytes()) {\n\t\tt.Error(\"P+P != 2*P\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p3.Bytes()) {\n\t\tt.Error(\"P+P != [2]P\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p4.Bytes()) {\n\t\tt.Error(\"G+G != [2]G\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p5.Bytes()) {\n\t\tt.Error(\"P+P != [N+2]P\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p6.Bytes()) {\n\t\tt.Error(\"G+G != [N+2]G\")\n\t}\n}\n\nfunc BenchmarkScalarMult(b *testing.B) {\n\tb.Run(\"P224\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP224Point().SetGenerator(), 28)\n\t})\n\tb.Run(\"P256\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP256Point().SetGenerator(), 32)\n\t})\n\tb.Run(\"P384\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP384Point().SetGenerator(), 48)\n\t})\n\tb.Run(\"P521\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP521Point().SetGenerator(), 66)\n\t})\n}\n\nfunc benchmarkScalarMult[P nistPoint[P]](b *testing.B, p P, scalarSize int) {\n\tscalar := make([]byte, scalarSize)\n\trand.Read(scalar)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tp.ScalarMult(p, scalar)\n\t}\n}\n\nfunc BenchmarkScalarBaseMult(b *testing.B) {\n\tb.Run(\"P224\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP224Point().SetGenerator(), 28)\n\t})\n\tb.Run(\"P256\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP256Point().SetGenerator(), 32)\n\t})\n\tb.Run(\"P384\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP384Point().SetGenerator(), 48)\n\t})\n\tb.Run(\"P521\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP521Point().SetGenerator(), 66)\n\t})\n}\n\nfunc benchmarkScalarBaseMult[P nistPoint[P]](b *testing.B, p P, scalarSize int) {\n\tscalar := make([]byte, scalarSize)\n\trand.Read(scalar)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tp.ScalarBaseMult(scalar)\n\t}\n}\n", "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains the Go wrapper for the constant-time, 64-bit assembly\n// implementation of P256. The optimizations performed here are described in\n// detail in:\n// S.Gueron and V.Krasnov, \"Fast prime field elliptic-curve cryptography with\n//                          256-bit primes\"\n// https://link.springer.com/article/10.1007%2Fs13389-014-0090-x\n// https://eprint.iacr.org/2013/816.pdf\n\n//go:build !purego && (amd64 || arm64 || (ppc64le && go1.19) || s390x)\n\npackage nistec\n\nimport (\n\t_ \"embed\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"math/bits\"\n\t\"runtime\"\n\t\"unsafe\"\n)\n\n// p256Element is a P-256 base field element in [0, P-1] in the Montgomery\n// domain (with R 2\u00b2\u2075\u2076) as four limbs in little-endian order value.\ntype p256Element [4]uint64\n\n// p256One is one in the Montgomery domain.\nvar p256One = p256Element{0x0000000000000001, 0xffffffff00000000,\n\t0xffffffffffffffff, 0x00000000fffffffe}\n\nvar p256Zero = p256Element{}\n\n// p256P is 2\u00b2\u2075\u2076 - 2\u00b2\u00b2\u2074 + 2\u00b9\u2079\u00b2 + 2\u2079\u2076 - 1 in the Montgomery domain.\nvar p256P = p256Element{0xffffffffffffffff, 0x00000000ffffffff,\n\t0x0000000000000000, 0xffffffff00000001}\n\n// P256Point is a P-256 point. The zero value should not be assumed to be valid\n// (although it is in this implementation).\ntype P256Point struct {\n\t// (X:Y:Z) are Jacobian coordinates where x = X/Z\u00b2 and y = Y/Z\u00b3. The point\n\t// at infinity can be represented by any set of coordinates with Z = 0.\n\tx, y, z p256Element\n}\n\n// NewP256Point returns a new P256Point representing the point at infinity.\nfunc NewP256Point() *P256Point {\n\treturn &P256Point{\n\t\tx: p256One, y: p256One, z: p256Zero,\n\t}\n}\n\n// SetGenerator sets p to the canonical generator and returns p.\nfunc (p *P256Point) SetGenerator() *P256Point {\n\tp.x = p256Element{0x79e730d418a9143c, 0x75ba95fc5fedb601,\n\t\t0x79fb732b77622510, 0x18905f76a53755c6}\n\tp.y = p256Element{0xddf25357ce95560a, 0x8b4ab8e4ba19e45c,\n\t\t0xd2e88688dd21f325, 0x8571ff1825885d85}\n\tp.z = p256One\n\treturn p\n}\n\n// Set sets p = q and returns p.\nfunc (p *P256Point) Set(q *P256Point) *P256Point {\n\tp.x, p.y, p.z = q.x, q.y, q.z\n\treturn p\n}\n\nconst p256ElementLength = 32\nconst p256UncompressedLength = 1 + 2*p256ElementLength\nconst p256CompressedLength = 1 + p256ElementLength\n\n// SetBytes sets p to the compressed, uncompressed, or infinity value encoded in\n// b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on\n// the curve, it returns nil and an error, and the receiver is unchanged.\n// Otherwise, it returns p.\nfunc (p *P256Point) SetBytes(b []byte) (*P256Point, error) {\n\t// p256Mul operates in the Montgomery domain with R = 2\u00b2\u2075\u2076 mod p. Thus rr\n\t// here is R in the Montgomery domain, or R\u00d7R mod p. See comment in\n\t// P256OrdInverse about how this is used.\n\trr := p256Element{0x0000000000000003, 0xfffffffbffffffff,\n\t\t0xfffffffffffffffe, 0x00000004fffffffd}\n\n\tswitch {\n\t// Point at infinity.\n\tcase len(b) == 1 && b[0] == 0:\n\t\treturn p.Set(NewP256Point()), nil\n\n\t// Uncompressed form.\n\tcase len(b) == p256UncompressedLength && b[0] == 4:\n\t\tvar r P256Point\n\t\tp256BigToLittle(&r.x, (*[32]byte)(b[1:33]))\n\t\tp256BigToLittle(&r.y, (*[32]byte)(b[33:65]))\n\t\tif p256LessThanP(&r.x) == 0 || p256LessThanP(&r.y) == 0 {\n\t\t\treturn nil, errors.New(\"invalid P256 element encoding\")\n\t\t}\n\t\tp256Mul(&r.x, &r.x, &rr)\n\t\tp256Mul(&r.y, &r.y, &rr)\n\t\tif err := p256CheckOnCurve(&r.x, &r.y); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.z = p256One\n\t\treturn p.Set(&r), nil\n\n\t// Compressed form.\n\tcase len(b) == p256CompressedLength && (b[0] == 2 || b[0] == 3):\n\t\tvar r P256Point\n\t\tp256BigToLittle(&r.x, (*[32]byte)(b[1:33]))\n\t\tif p256LessThanP(&r.x) == 0 {\n\t\t\treturn nil, errors.New(\"invalid P256 element encoding\")\n\t\t}\n\t\tp256Mul(&r.x, &r.x, &rr)\n\n\t\t// y\u00b2 = x\u00b3 - 3x + b\n\t\tp256Polynomial(&r.y, &r.x)\n\t\tif !p256Sqrt(&r.y, &r.y) {\n\t\t\treturn nil, errors.New(\"invalid P256 compressed point encoding\")\n\t\t}\n\n\t\t// Select the positive or negative root, as indicated by the least\n\t\t// significant bit, based on the encoding type byte.\n\t\tyy := new(p256Element)\n\t\tp256FromMont(yy, &r.y)\n\t\tcond := int(yy[0]&1) ^ int(b[0]&1)\n\t\tp256NegCond(&r.y, cond)\n\n\t\tr.z = p256One\n\t\treturn p.Set(&r), nil\n\n\tdefault:\n\t\treturn nil, errors.New(\"invalid P256 point encoding\")\n\t}\n}\n\n// p256Polynomial sets y2 to x\u00b3 - 3x + b, and returns y2.\nfunc p256Polynomial(y2, x *p256Element) *p256Element {\n\tx3 := new(p256Element)\n\tp256Sqr(x3, x, 1)\n\tp256Mul(x3, x3, x)\n\n\tthreeX := new(p256Element)\n\tp256Add(threeX, x, x)\n\tp256Add(threeX, threeX, x)\n\tp256NegCond(threeX, 1)\n\n\tp256B := &p256Element{0xd89cdf6229c4bddf, 0xacf005cd78843090,\n\t\t0xe5a220abf7212ed6, 0xdc30061d04874834}\n\n\tp256Add(x3, x3, threeX)\n\tp256Add(x3, x3, p256B)\n\n\t*y2 = *x3\n\treturn y2\n}\n\nfunc p256CheckOnCurve(x, y *p256Element) error {\n\t// y\u00b2 = x\u00b3 - 3x + b\n\trhs := p256Polynomial(new(p256Element), x)\n\tlhs := new(p256Element)\n\tp256Sqr(lhs, y, 1)\n\tif p256Equal(lhs, rhs) != 1 {\n\t\treturn errors.New(\"P256 point not on curve\")\n\t}\n\treturn nil\n}\n\n// p256LessThanP returns 1 if x < p, and 0 otherwise. Note that a p256Element is\n// not allowed to be equal to or greater than p, so if this function returns 0\n// then x is invalid.\nfunc p256LessThanP(x *p256Element) int {\n\tvar b uint64\n\t_, b = bits.Sub64(x[0], p256P[0], b)\n\t_, b = bits.Sub64(x[1], p256P[1], b)\n\t_, b = bits.Sub64(x[2], p256P[2], b)\n\t_, b = bits.Sub64(x[3], p256P[3], b)\n\treturn int(b)\n}\n\n// p256Add sets res = x + y.\nfunc p256Add(res, x, y *p256Element) {\n\tvar c, b uint64\n\tt1 := make([]uint64, 4)\n\tt1[0], c = bits.Add64(x[0], y[0], 0)\n\tt1[1], c = bits.Add64(x[1], y[1], c)\n\tt1[2], c = bits.Add64(x[2], y[2], c)\n\tt1[3], c = bits.Add64(x[3], y[3], c)\n\tt2 := make([]uint64, 4)\n\tt2[0], b = bits.Sub64(t1[0], p256P[0], 0)\n\tt2[1], b = bits.Sub64(t1[1], p256P[1], b)\n\tt2[2], b = bits.Sub64(t1[2], p256P[2], b)\n\tt2[3], b = bits.Sub64(t1[3], p256P[3], b)\n\t// Three options:\n\t//   - a+b < p\n\t//     then c is 0, b is 1, and t1 is correct\n\t//   - p <= a+b < 2^256\n\t//     then c is 0, b is 0, and t2 is correct\n\t//   - 2^256 <= a+b\n\t//     then c is 1, b is 1, and t2 is correct\n\tt2Mask := (c ^ b) - 1\n\tres[0] = (t1[0] & ^t2Mask) | (t2[0] & t2Mask)\n\tres[1] = (t1[1] & ^t2Mask) | (t2[1] & t2Mask)\n\tres[2] = (t1[2] & ^t2Mask) | (t2[2] & t2Mask)\n\tres[3] = (t1[3] & ^t2Mask) | (t2[3] & t2Mask)\n}\n\n// p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns\n// false and e is unchanged. e and x can overlap.\nfunc p256Sqrt(e, x *p256Element) (isSquare bool) {\n\tt0, t1 := new(p256Element), new(p256Element)\n\n\t// Since p = 3 mod 4, exponentiation by (p + 1) / 4 yields a square root candidate.\n\t//\n\t// The sequence of 7 multiplications and 253 squarings is derived from the\n\t// following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.\n\t//\n\t//\t_10       = 2*1\n\t//\t_11       = 1 + _10\n\t//\t_1100     = _11 << 2\n\t//\t_1111     = _11 + _1100\n\t//\t_11110000 = _1111 << 4\n\t//\t_11111111 = _1111 + _11110000\n\t//\tx16       = _11111111 << 8 + _11111111\n\t//\tx32       = x16 << 16 + x16\n\t//\treturn      ((x32 << 32 + 1) << 96 + 1) << 94\n\t//\n\tp256Sqr(t0, x, 1)\n\tp256Mul(t0, x, t0)\n\tp256Sqr(t1, t0, 2)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t1, t0, 4)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t1, t0, 8)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t1, t0, 16)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t0, t0, 32)\n\tp256Mul(t0, x, t0)\n\tp256Sqr(t0, t0, 96)\n\tp256Mul(t0, x, t0)\n\tp256Sqr(t0, t0, 94)\n\n\tp256Sqr(t1, t0, 1)\n\tif p256Equal(t1, x) != 1 {\n\t\treturn false\n\t}\n\t*e = *t0\n\treturn true\n}\n\n// The following assembly functions are implemented in p256_asm_*.s\n\n// Montgomery multiplication. Sets res = in1 * in2 * R\u207b\u00b9 mod p.\n//\n//go:noescape\nfunc p256Mul(res, in1, in2 *p256Element)\n\n// Montgomery square, repeated n times (n >= 1).\n//\n//go:noescape\nfunc p256Sqr(res, in *p256Element, n int)\n\n// Montgomery multiplication by R\u207b\u00b9, or 1 outside the domain.\n// Sets res = in * R\u207b\u00b9, bringing res out of the Montgomery domain.\n//\n//go:noescape\nfunc p256FromMont(res, in *p256Element)\n\n// If cond is not 0, sets val = -val mod p.\n//\n//go:noescape\nfunc p256NegCond(val *p256Element, cond int)\n\n// If cond is 0, sets res = b, otherwise sets res = a.\n//\n//go:noescape\nfunc p256MovCond(res, a, b *P256Point, cond int)\n\n//go:noescape\nfunc p256BigToLittle(res *p256Element, in *[32]byte)\n\n//go:noescape\nfunc p256LittleToBig(res *[32]byte, in *p256Element)\n\n//go:noescape\nfunc p256OrdBigToLittle(res *p256OrdElement, in *[32]byte)\n\n//go:noescape\nfunc p256OrdLittleToBig(res *[32]byte, in *p256OrdElement)\n\n// p256Table is a table of the first 16 multiples of a point. Points are stored\n// at an index offset of -1 so [8]P is at index 7, P is at 0, and [16]P is at 15.\n// [0]P is the point at infinity and it's not stored.\ntype p256Table [16]P256Point\n\n// p256Select sets res to the point at index idx in the table.\n// idx must be in [0, 15]. It executes in constant time.\n//\n//go:noescape\nfunc p256Select(res *P256Point, table *p256Table, idx int)\n\n// p256AffinePoint is a point in affine coordinates (x, y). x and y are still\n// Montgomery domain elements. The point can't be the point at infinity.\ntype p256AffinePoint struct {\n\tx, y p256Element\n}\n\n// p256AffineTable is a table of the first 32 multiples of a point. Points are\n// stored at an index offset of -1 like in p256Table, and [0]P is not stored.\ntype p256AffineTable [32]p256AffinePoint\n\n// p256Precomputed is a series of precomputed multiples of G, the canonical\n// generator. The first p256AffineTable contains multiples of G. The second one\n// multiples of [2\u2076]G, the third one of [2\u00b9\u00b2]G, and so on, where each successive\n// table is the previous table doubled six times. Six is the width of the\n// sliding window used in p256ScalarMult, and having each table already\n// pre-doubled lets us avoid the doublings between windows entirely. This table\n// MUST NOT be modified, as it aliases into p256PrecomputedEmbed below.\nvar p256Precomputed *[43]p256AffineTable\n\n//go:embed p256_asm_table.bin\nvar p256PrecomputedEmbed string\n\nfunc init() {\n\tp256PrecomputedPtr := (*unsafe.Pointer)(unsafe.Pointer(&p256PrecomputedEmbed))\n\tif runtime.GOARCH == \"s390x\" {\n\t\tvar newTable [43 * 32 * 2 * 4]uint64\n\t\tfor i, x := range (*[43 * 32 * 2 * 4][8]byte)(*p256PrecomputedPtr) {\n\t\t\tnewTable[i] = binary.LittleEndian.Uint64(x[:])\n\t\t}\n\t\tnewTablePtr := unsafe.Pointer(&newTable)\n\t\tp256PrecomputedPtr = &newTablePtr\n\t}\n\tp256Precomputed = (*[43]p256AffineTable)(*p256PrecomputedPtr)\n}\n\n// p256SelectAffine sets res to the point at index idx in the table.\n// idx must be in [0, 31]. It executes in constant time.\n//\n//go:noescape\nfunc p256SelectAffine(res *p256AffinePoint, table *p256AffineTable, idx int)\n\n// Point addition with an affine point and constant time conditions.\n// If zero is 0, sets res = in2. If sel is 0, sets res = in1.\n// If sign is not 0, sets res = in1 + -in2. Otherwise, sets res = in1 + in2\n//\n//go:noescape\nfunc p256PointAddAffineAsm(res, in1 *P256Point, in2 *p256AffinePoint, sign, sel, zero int)\n\n// Point addition. Sets res = in1 + in2. Returns one if the two input points\n// were equal and zero otherwise. If in1 or in2 are the point at infinity, res\n// and the return value are undefined.\n//\n//go:noescape\nfunc p256PointAddAsm(res, in1, in2 *P256Point) int\n\n// Point doubling. Sets res = in + in. in can be the point at infinity.\n//\n//go:noescape\nfunc p256PointDoubleAsm(res, in *P256Point)\n\n// p256OrdElement is a P-256 scalar field element in [0, ord(G)-1] in the\n// Montgomery domain (with R 2\u00b2\u2075\u2076) as four uint64 limbs in little-endian order.\ntype p256OrdElement [4]uint64\n\n// Add sets q = p1 + p2, and returns q. The points may overlap.\nfunc (q *P256Point) Add(r1, r2 *P256Point) *P256Point {\n\tvar sum, double P256Point\n\tr1IsInfinity := r1.isInfinity()\n\tr2IsInfinity := r2.isInfinity()\n\tpointsEqual := p256PointAddAsm(&sum, r1, r2)\n\tp256PointDoubleAsm(&double, r1)\n\tp256MovCond(&sum, &double, &sum, pointsEqual)\n\tp256MovCond(&sum, r1, &sum, r2IsInfinity)\n\tp256MovCond(&sum, r2, &sum, r1IsInfinity)\n\treturn q.Set(&sum)\n}\n\n// Double sets q = p + p, and returns q. The points may overlap.\nfunc (q *P256Point) Double(p *P256Point) *P256Point {\n\tvar double P256Point\n\tp256PointDoubleAsm(&double, p)\n\treturn q.Set(&double)\n}\n\n// ScalarBaseMult sets r = scalar * generator, where scalar is a 32-byte big\n// endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult\n// returns an error and the receiver is unchanged.\nfunc (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error) {\n\tif len(scalar) != 32 {\n\t\treturn nil, errors.New(\"invalid scalar length\")\n\t}\n\tscalarReversed := new(p256OrdElement)\n\tp256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))\n\n\tr.p256BaseMult(scalarReversed)\n\treturn r, nil\n}\n\n// ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,\n// and returns r. If scalar is not 32 bytes long, ScalarBaseMult returns an\n// error and the receiver is unchanged.\nfunc (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error) {\n\tif len(scalar) != 32 {\n\t\treturn nil, errors.New(\"invalid scalar length\")\n\t}\n\tscalarReversed := new(p256OrdElement)\n\tp256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))\n\n\tr.Set(q).p256ScalarMult(scalarReversed)\n\treturn r, nil\n}\n\n// uint64IsZero returns 1 if x is zero and zero otherwise.\nfunc uint64IsZero(x uint64) int {\n\tx = ^x\n\tx &= x >> 32\n\tx &= x >> 16\n\tx &= x >> 8\n\tx &= x >> 4\n\tx &= x >> 2\n\tx &= x >> 1\n\treturn int(x & 1)\n}\n\n// p256Equal returns 1 if a and b are equal and 0 otherwise.\nfunc p256Equal(a, b *p256Element) int {\n\tvar acc uint64\n\tfor i := range a {\n\t\tacc |= a[i] ^ b[i]\n\t}\n\treturn uint64IsZero(acc)\n}\n\n// isInfinity returns 1 if p is the point at infinity and 0 otherwise.\nfunc (p *P256Point) isInfinity() int {\n\treturn p256Equal(&p.z, &p256Zero)\n}\n\n// Bytes returns the uncompressed or infinity encoding of p, as specified in\n// SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at\n// infinity is shorter than all other encodings.\nfunc (p *P256Point) Bytes() []byte {\n\t// This function is outlined to make the allocations inline in the caller\n\t// rather than happen on the heap.\n\tvar out [p256UncompressedLength]byte\n\treturn p.bytes(&out)\n}\n\nfunc (p *P256Point) bytes(out *[p256UncompressedLength]byte) []byte {\n\t// The proper representation of the point at infinity is a single zero byte.\n\tif p.isInfinity() == 1 {\n\t\treturn append(out[:0], 0)\n\t}\n\n\tx, y := new(p256Element), new(p256Element)\n\tp.affineFromMont(x, y)\n\n\tout[0] = 4 // Uncompressed form.\n\tp256LittleToBig((*[32]byte)(out[1:33]), x)\n\tp256LittleToBig((*[32]byte)(out[33:65]), y)\n\n\treturn out[:]\n}\n\n// affineFromMont sets (x, y) to the affine coordinates of p, converted out of the\n// Montgomery domain.\nfunc (p *P256Point) affineFromMont(x, y *p256Element) {\n\tp256Inverse(y, &p.z)\n\tp256Sqr(x, y, 1)\n\tp256Mul(y, y, x)\n\n\tp256Mul(x, &p.x, x)\n\tp256Mul(y, &p.y, y)\n\n\tp256FromMont(x, x)\n\tp256FromMont(y, y)\n}\n\n// BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,\n// Version 2.0, Section 2.3.5, or an error if p is the point at infinity.\nfunc (p *P256Point) BytesX() ([]byte, error) {\n\t// This function is outlined to make the allocations inline in the caller\n\t// rather than happen on the heap.\n\tvar out [p256ElementLength]byte\n\treturn p.bytesX(&out)\n}\n\nfunc (p *P256Point) bytesX(out *[p256ElementLength]byte) ([]byte, error) {\n\tif p.isInfinity() == 1 {\n\t\treturn nil, errors.New(\"P256 point is the point at infinity\")\n\t}\n\n\tx := new(p256Element)\n\tp256Inverse(x, &p.z)\n\tp256Sqr(x, x, 1)\n\tp256Mul(x, &p.x, x)\n\tp256FromMont(x, x)\n\tp256LittleToBig((*[32]byte)(out[:]), x)\n\n\treturn out[:], nil\n}\n\n// BytesCompressed returns the compressed or infinity encoding of p, as\n// specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the\n// point at infinity is shorter than all other encodings.\nfunc (p *P256Point) BytesCompressed() []byte {\n\t// This function is outlined to make the allocations inline in the caller\n\t// rather than happen on the heap.\n\tvar out [p256CompressedLength]byte\n\treturn p.bytesCompressed(&out)\n}\n\nfunc (p *P256Point) bytesCompressed(out *[p256CompressedLength]byte) []byte {\n\tif p.isInfinity() == 1 {\n\t\treturn append(out[:0], 0)\n\t}\n\n\tx, y := new(p256Element), new(p256Element)\n\tp.affineFromMont(x, y)\n\n\tout[0] = 2 | byte(y[0]&1)\n\tp256LittleToBig((*[32]byte)(out[1:33]), x)\n\n\treturn out[:]\n}\n\n// Select sets q to p1 if cond == 1, and to p2 if cond == 0.\nfunc (q *P256Point) Select(p1, p2 *P256Point, cond int) *P256Point {\n\tp256MovCond(q, p1, p2, cond)\n\treturn q\n}\n\n// p256Inverse sets out to in\u207b\u00b9 mod p. If in is zero, out will be zero.\nfunc p256Inverse(out, in *p256Element) {\n\t// Inversion is calculated through exponentiation by p - 2, per Fermat's\n\t// little theorem.\n\t//\n\t// The sequence of 12 multiplications and 255 squarings is derived from the\n\t// following addition chain generated with github.com/mmcloughlin/addchain\n\t// v0.4.0.\n\t//\n\t//  _10     = 2*1\n\t//  _11     = 1 + _10\n\t//  _110    = 2*_11\n\t//  _111    = 1 + _110\n\t//  _111000 = _111 << 3\n\t//  _111111 = _111 + _111000\n\t//  x12     = _111111 << 6 + _111111\n\t//  x15     = x12 << 3 + _111\n\t//  x16     = 2*x15 + 1\n\t//  x32     = x16 << 16 + x16\n\t//  i53     = x32 << 15\n\t//  x47     = x15 + i53\n\t//  i263    = ((i53 << 17 + 1) << 143 + x47) << 47\n\t//  return    (x47 + i263) << 2 + 1\n\t//\n\tvar z = new(p256Element)\n\tvar t0 = new(p256Element)\n\tvar t1 = new(p256Element)\n\n\tp256Sqr(z, in, 1)\n\tp256Mul(z, in, z)\n\tp256Sqr(z, z, 1)\n\tp256Mul(z, in, z)\n\tp256Sqr(t0, z, 3)\n\tp256Mul(t0, z, t0)\n\tp256Sqr(t1, t0, 6)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t0, t0, 3)\n\tp256Mul(z, z, t0)\n\tp256Sqr(t0, z, 1)\n\tp256Mul(t0, in, t0)\n\tp256Sqr(t1, t0, 16)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t0, t0, 15)\n\tp256Mul(z, z, t0)\n\tp256Sqr(t0, t0, 17)\n\tp256Mul(t0, in, t0)\n\tp256Sqr(t0, t0, 143)\n\tp256Mul(t0, z, t0)\n\tp256Sqr(t0, t0, 47)\n\tp256Mul(z, z, t0)\n\tp256Sqr(z, z, 2)\n\tp256Mul(out, in, z)\n}\n\nfunc boothW5(in uint) (int, int) {\n\tvar s uint = ^((in >> 5) - 1)\n\tvar d uint = (1 << 6) - in - 1\n\td = (d & s) | (in & (^s))\n\td = (d >> 1) + (d & 1)\n\treturn int(d), int(s & 1)\n}\n\nfunc boothW6(in uint) (int, int) {\n\tvar s uint = ^((in >> 6) - 1)\n\tvar d uint = (1 << 7) - in - 1\n\td = (d & s) | (in & (^s))\n\td = (d >> 1) + (d & 1)\n\treturn int(d), int(s & 1)\n}\n\nfunc (p *P256Point) p256BaseMult(scalar *p256OrdElement) {\n\tvar t0 p256AffinePoint\n\n\twvalue := (scalar[0] << 1) & 0x7f\n\tsel, sign := boothW6(uint(wvalue))\n\tp256SelectAffine(&t0, &p256Precomputed[0], sel)\n\tp.x, p.y, p.z = t0.x, t0.y, p256One\n\tp256NegCond(&p.y, sign)\n\n\tindex := uint(5)\n\tzero := sel\n\n\tfor i := 1; i < 43; i++ {\n\t\tif index < 192 {\n\t\t\twvalue = ((scalar[index/64] >> (index % 64)) + (scalar[index/64+1] << (64 - (index % 64)))) & 0x7f\n\t\t} else {\n\t\t\twvalue = (scalar[index/64] >> (index % 64)) & 0x7f\n\t\t}\n\t\tindex += 6\n\t\tsel, sign = boothW6(uint(wvalue))\n\t\tp256SelectAffine(&t0, &p256Precomputed[i], sel)\n\t\tp256PointAddAffineAsm(p, p, &t0, sign, sel, zero)\n\t\tzero |= sel\n\t}\n\n\t// If the whole scalar was zero, set to the point at infinity.\n\tp256MovCond(p, p, NewP256Point(), zero)\n}\n\nfunc (p *P256Point) p256ScalarMult(scalar *p256OrdElement) {\n\t// precomp is a table of precomputed points that stores powers of p\n\t// from p^1 to p^16.\n\tvar precomp p256Table\n\tvar t0, t1, t2, t3 P256Point\n\n\t// Prepare the table\n\tprecomp[0] = *p // 1\n\n\tp256PointDoubleAsm(&t0, p)\n\tp256PointDoubleAsm(&t1, &t0)\n\tp256PointDoubleAsm(&t2, &t1)\n\tp256PointDoubleAsm(&t3, &t2)\n\tprecomp[1] = t0  // 2\n\tprecomp[3] = t1  // 4\n\tprecomp[7] = t2  // 8\n\tprecomp[15] = t3 // 16\n\n\tp256PointAddAsm(&t0, &t0, p)\n\tp256PointAddAsm(&t1, &t1, p)\n\tp256PointAddAsm(&t2, &t2, p)\n\tprecomp[2] = t0 // 3\n\tprecomp[4] = t1 // 5\n\tprecomp[8] = t2 // 9\n\n\tp256PointDoubleAsm(&t0, &t0)\n\tp256PointDoubleAsm(&t1, &t1)\n\tprecomp[5] = t0 // 6\n\tprecomp[9] = t1 // 10\n\n\tp256PointAddAsm(&t2, &t0, p)\n\tp256PointAddAsm(&t1, &t1, p)\n\tprecomp[6] = t2  // 7\n\tprecomp[10] = t1 // 11\n\n\tp256PointDoubleAsm(&t0, &t0)\n\tp256PointDoubleAsm(&t2, &t2)\n\tprecomp[11] = t0 // 12\n\tprecomp[13] = t2 // 14\n\n\tp256PointAddAsm(&t0, &t0, p)\n\tp256PointAddAsm(&t2, &t2, p)\n\tprecomp[12] = t0 // 13\n\tprecomp[14] = t2 // 15\n\n\t// Start scanning the window from top bit\n\tindex := uint(254)\n\tvar sel, sign int\n\n\twvalue := (scalar[index/64] >> (index % 64)) & 0x3f\n\tsel, _ = boothW5(uint(wvalue))\n\n\tp256Select(p, &precomp, sel)\n\tzero := sel\n\n\tfor index > 4 {\n\t\tindex -= 5\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\n\t\tif index < 192 {\n\t\t\twvalue = ((scalar[index/64] >> (index % 64)) + (scalar[index/64+1] << (64 - (index % 64)))) & 0x3f\n\t\t} else {\n\t\t\twvalue = (scalar[index/64] >> (index % 64)) & 0x3f\n\t\t}\n\n\t\tsel, sign = boothW5(uint(wvalue))\n\n\t\tp256Select(&t0, &precomp, sel)\n\t\tp256NegCond(&t0.y, sign)\n\t\tp256PointAddAsm(&t1, p, &t0)\n\t\tp256MovCond(&t1, &t1, p, sel)\n\t\tp256MovCond(p, &t1, &t0, zero)\n\t\tzero |= sel\n\t}\n\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\n\twvalue = (scalar[0] << 1) & 0x3f\n\tsel, sign = boothW5(uint(wvalue))\n\n\tp256Select(&t0, &precomp, sel)\n\tp256NegCond(&t0.y, sign)\n\tp256PointAddAsm(&t1, p, &t0)\n\tp256MovCond(&t1, &t1, p, sel)\n\tp256MovCond(p, &t1, &t0, zero)\n}\n", "// Copyright 2022 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !purego && (amd64 || arm64)\n\npackage nistec\n\nimport \"errors\"\n\n// Montgomery multiplication modulo org(G). Sets res = in1 * in2 * R\u207b\u00b9.\n//\n//go:noescape\nfunc p256OrdMul(res, in1, in2 *p256OrdElement)\n\n// Montgomery square modulo org(G), repeated n times (n >= 1).\n//\n//go:noescape\nfunc p256OrdSqr(res, in *p256OrdElement, n int)\n\nfunc p256OrdInverse(k []byte) ([]byte, error) {\n\tif len(k) != 32 {\n\t\treturn nil, errors.New(\"invalid scalar length\")\n\t}\n\n\tx := new(p256OrdElement)\n\tp256OrdBigToLittle(x, (*[32]byte)(k))\n\n\t// Inversion is implemented as exponentiation by n - 2, per Fermat's little theorem.\n\t//\n\t// The sequence of 38 multiplications and 254 squarings is derived from\n\t// https://briansmith.org/ecc-inversion-addition-chains-01#p256_scalar_inversion\n\t_1 := new(p256OrdElement)\n\t_11 := new(p256OrdElement)\n\t_101 := new(p256OrdElement)\n\t_111 := new(p256OrdElement)\n\t_1111 := new(p256OrdElement)\n\t_10101 := new(p256OrdElement)\n\t_101111 := new(p256OrdElement)\n\tt := new(p256OrdElement)\n\n\t// This code operates in the Montgomery domain where R = 2\u00b2\u2075\u2076 mod n and n is\n\t// the order of the scalar field. Elements in the Montgomery domain take the\n\t// form a\u00d7R and p256OrdMul calculates (a \u00d7 b \u00d7 R\u207b\u00b9) mod n. RR is R in the\n\t// domain, or R\u00d7R mod n, thus p256OrdMul(x, RR) gives x\u00d7R, i.e. converts x\n\t// into the Montgomery domain.\n\tRR := &p256OrdElement{0x83244c95be79eea2, 0x4699799c49bd6fa6,\n\t\t0x2845b2392b6bec59, 0x66e12d94f3d95620}\n\n\tp256OrdMul(_1, x, RR)      // _1\n\tp256OrdSqr(x, _1, 1)       // _10\n\tp256OrdMul(_11, x, _1)     // _11\n\tp256OrdMul(_101, x, _11)   // _101\n\tp256OrdMul(_111, x, _101)  // _111\n\tp256OrdSqr(x, _101, 1)     // _1010\n\tp256OrdMul(_1111, _101, x) // _1111\n\n\tp256OrdSqr(t, x, 1)          // _10100\n\tp256OrdMul(_10101, t, _1)    // _10101\n\tp256OrdSqr(x, _10101, 1)     // _101010\n\tp256OrdMul(_101111, _101, x) // _101111\n\tp256OrdMul(x, _10101, x)     // _111111 = x6\n\tp256OrdSqr(t, x, 2)          // _11111100\n\tp256OrdMul(t, t, _11)        // _11111111 = x8\n\tp256OrdSqr(x, t, 8)          // _ff00\n\tp256OrdMul(x, x, t)          // _ffff = x16\n\tp256OrdSqr(t, x, 16)         // _ffff0000\n\tp256OrdMul(t, t, x)          // _ffffffff = x32\n\n\tp256OrdSqr(x, t, 64)\n\tp256OrdMul(x, x, t)\n\tp256OrdSqr(x, x, 32)\n\tp256OrdMul(x, x, t)\n\n\tsqrs := []int{\n\t\t6, 5, 4, 5, 5,\n\t\t4, 3, 3, 5, 9,\n\t\t6, 2, 5, 6, 5,\n\t\t4, 5, 5, 3, 10,\n\t\t2, 5, 5, 3, 7, 6}\n\tmuls := []*p256OrdElement{\n\t\t_101111, _111, _11, _1111, _10101,\n\t\t_101, _101, _101, _111, _101111,\n\t\t_1111, _1, _1, _1111, _111,\n\t\t_111, _111, _101, _11, _101111,\n\t\t_11, _11, _11, _1, _10101, _1111}\n\n\tfor i, s := range sqrs {\n\t\tp256OrdSqr(x, x, s)\n\t\tp256OrdMul(x, x, muls[i])\n\t}\n\n\t// Montgomery multiplication by R\u207b\u00b9, or 1 outside the domain as R\u207b\u00b9\u00d7R = 1,\n\t// converts a Montgomery value out of the domain.\n\tone := &p256OrdElement{1}\n\tp256OrdMul(x, x, one)\n\n\tvar xOut [32]byte\n\tp256OrdLittleToBig(&xOut, x)\n\treturn xOut[:], nil\n}\n"], "fixing_code": ["// Copyright 2021 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\npackage nistec_test\n\nimport (\n\t\"bytes\"\n\t\"crypto/elliptic\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"math/rand\"\n\t\"testing\"\n\n\t\"filippo.io/nistec\"\n)\n\nfunc TestAllocations(t *testing.T) {\n\tt.Run(\"P224\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP224Point().SetGenerator()\n\t\t\tscalar := make([]byte, 28)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP224Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n\tt.Run(\"P256\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP256Point().SetGenerator()\n\t\t\tscalar := make([]byte, 32)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP256Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n\tt.Run(\"P384\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP384Point().SetGenerator()\n\t\t\tscalar := make([]byte, 48)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP384Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n\tt.Run(\"P521\", func(t *testing.T) {\n\t\tif allocs := testing.AllocsPerRun(100, func() {\n\t\t\tp := nistec.NewP521Point().SetGenerator()\n\t\t\tscalar := make([]byte, 66)\n\t\t\trand.Read(scalar)\n\t\t\tp.ScalarBaseMult(scalar)\n\t\t\tp.ScalarMult(p, scalar)\n\t\t\tout := p.Bytes()\n\t\t\tif _, err := nistec.NewP521Point().SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t\tout = p.BytesCompressed()\n\t\t\tif _, err := p.SetBytes(out); err != nil {\n\t\t\t\tt.Fatal(err)\n\t\t\t}\n\t\t}); allocs > 0 {\n\t\t\tt.Errorf(\"expected zero allocations, got %0.1f\", allocs)\n\t\t}\n\t})\n}\n\ntype nistPoint[T any] interface {\n\tBytes() []byte\n\tSetGenerator() T\n\tSetBytes([]byte) (T, error)\n\tAdd(T, T) T\n\tDouble(T) T\n\tScalarMult(T, []byte) (T, error)\n\tScalarBaseMult([]byte) (T, error)\n}\n\nfunc TestEquivalents(t *testing.T) {\n\tt.Run(\"P224\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP224Point, elliptic.P224())\n\t})\n\tt.Run(\"P256\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP256Point, elliptic.P256())\n\t})\n\tt.Run(\"P384\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP384Point, elliptic.P384())\n\t})\n\tt.Run(\"P521\", func(t *testing.T) {\n\t\ttestEquivalents(t, nistec.NewP521Point, elliptic.P521())\n\t})\n}\n\nfunc testEquivalents[P nistPoint[P]](t *testing.T, newPoint func() P, c elliptic.Curve) {\n\tp := newPoint().SetGenerator()\n\n\telementSize := (c.Params().BitSize + 7) / 8\n\ttwo := make([]byte, elementSize)\n\ttwo[len(two)-1] = 2\n\tnPlusTwo := make([]byte, elementSize)\n\tnew(big.Int).Add(c.Params().N, big.NewInt(2)).FillBytes(nPlusTwo)\n\n\tp1 := newPoint().Double(p)\n\tp2 := newPoint().Add(p, p)\n\tp3, err := newPoint().ScalarMult(p, two)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp4, err := newPoint().ScalarBaseMult(two)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp5, err := newPoint().ScalarMult(p, nPlusTwo)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\tp6, err := newPoint().ScalarBaseMult(nPlusTwo)\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n\n\tif !bytes.Equal(p1.Bytes(), p2.Bytes()) {\n\t\tt.Error(\"P+P != 2*P\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p3.Bytes()) {\n\t\tt.Error(\"P+P != [2]P\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p4.Bytes()) {\n\t\tt.Error(\"G+G != [2]G\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p5.Bytes()) {\n\t\tt.Error(\"P+P != [N+2]P\")\n\t}\n\tif !bytes.Equal(p1.Bytes(), p6.Bytes()) {\n\t\tt.Error(\"G+G != [N+2]G\")\n\t}\n}\n\nfunc TestScalarMult(t *testing.T) {\n\tt.Run(\"P224\", func(t *testing.T) {\n\t\ttestScalarMult(t, nistec.NewP224Point, elliptic.P224())\n\t})\n\tt.Run(\"P256\", func(t *testing.T) {\n\t\ttestScalarMult(t, nistec.NewP256Point, elliptic.P256())\n\t})\n\tt.Run(\"P384\", func(t *testing.T) {\n\t\ttestScalarMult(t, nistec.NewP384Point, elliptic.P384())\n\t})\n\tt.Run(\"P521\", func(t *testing.T) {\n\t\ttestScalarMult(t, nistec.NewP521Point, elliptic.P521())\n\t})\n}\n\nfunc testScalarMult[P nistPoint[P]](t *testing.T, newPoint func() P, c elliptic.Curve) {\n\tG := newPoint().SetGenerator()\n\tcheckScalar := func(t *testing.T, scalar []byte) {\n\t\tp1, err := newPoint().ScalarBaseMult(scalar)\n\t\tfatalIfErr(t, err)\n\t\tp2, err := newPoint().ScalarMult(G, scalar)\n\t\tfatalIfErr(t, err)\n\t\tif !bytes.Equal(p1.Bytes(), p2.Bytes()) {\n\t\t\tt.Error(\"[k]G != ScalarBaseMult(k)\")\n\t\t}\n\n\t\td := new(big.Int).SetBytes(scalar)\n\t\td.Sub(c.Params().N, d)\n\t\td.Mod(d, c.Params().N)\n\t\tg1, err := newPoint().ScalarBaseMult(d.FillBytes(make([]byte, len(scalar))))\n\t\tfatalIfErr(t, err)\n\t\tg1.Add(g1, p1)\n\t\tif !bytes.Equal(g1.Bytes(), newPoint().Bytes()) {\n\t\t\tt.Error(\"[N - k]G + [k]G != \u221e\")\n\t\t}\n\t}\n\n\tbyteLen := len(c.Params().N.Bytes())\n\tbitLen := c.Params().N.BitLen()\n\tt.Run(\"0\", func(t *testing.T) { checkScalar(t, make([]byte, byteLen)) })\n\tt.Run(\"1\", func(t *testing.T) {\n\t\tcheckScalar(t, big.NewInt(1).FillBytes(make([]byte, byteLen)))\n\t})\n\tt.Run(\"N-1\", func(t *testing.T) {\n\t\tcheckScalar(t, new(big.Int).Sub(c.Params().N, big.NewInt(1)).Bytes())\n\t})\n\tt.Run(\"N\", func(t *testing.T) { checkScalar(t, c.Params().N.Bytes()) })\n\tt.Run(\"N+1\", func(t *testing.T) {\n\t\tcheckScalar(t, new(big.Int).Add(c.Params().N, big.NewInt(1)).Bytes())\n\t})\n\tt.Run(\"all1s\", func(t *testing.T) {\n\t\ts := new(big.Int).Lsh(big.NewInt(1), uint(bitLen))\n\t\ts.Sub(s, big.NewInt(1))\n\t\tcheckScalar(t, s.Bytes())\n\t})\n\tif testing.Short() {\n\t\treturn\n\t}\n\tfor i := 0; i < bitLen; i++ {\n\t\tt.Run(fmt.Sprintf(\"1<<%d\", i), func(t *testing.T) {\n\t\t\ts := new(big.Int).Lsh(big.NewInt(1), uint(i))\n\t\t\tcheckScalar(t, s.FillBytes(make([]byte, byteLen)))\n\t\t})\n\t}\n\t// Test N+1...N+32 since they risk overlapping with precomputed table values\n\t// in the final additions.\n\tfor i := int64(2); i <= 32; i++ {\n\t\tt.Run(fmt.Sprintf(\"N+%d\", i), func(t *testing.T) {\n\t\t\tcheckScalar(t, new(big.Int).Add(c.Params().N, big.NewInt(i)).Bytes())\n\t\t})\n\t}\n}\n\nfunc fatalIfErr(t *testing.T, err error) {\n\tt.Helper()\n\tif err != nil {\n\t\tt.Fatal(err)\n\t}\n}\n\nfunc BenchmarkScalarMult(b *testing.B) {\n\tb.Run(\"P224\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP224Point().SetGenerator(), 28)\n\t})\n\tb.Run(\"P256\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP256Point().SetGenerator(), 32)\n\t})\n\tb.Run(\"P384\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP384Point().SetGenerator(), 48)\n\t})\n\tb.Run(\"P521\", func(b *testing.B) {\n\t\tbenchmarkScalarMult(b, nistec.NewP521Point().SetGenerator(), 66)\n\t})\n}\n\nfunc benchmarkScalarMult[P nistPoint[P]](b *testing.B, p P, scalarSize int) {\n\tscalar := make([]byte, scalarSize)\n\trand.Read(scalar)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tp.ScalarMult(p, scalar)\n\t}\n}\n\nfunc BenchmarkScalarBaseMult(b *testing.B) {\n\tb.Run(\"P224\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP224Point().SetGenerator(), 28)\n\t})\n\tb.Run(\"P256\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP256Point().SetGenerator(), 32)\n\t})\n\tb.Run(\"P384\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP384Point().SetGenerator(), 48)\n\t})\n\tb.Run(\"P521\", func(b *testing.B) {\n\t\tbenchmarkScalarBaseMult(b, nistec.NewP521Point().SetGenerator(), 66)\n\t})\n}\n\nfunc benchmarkScalarBaseMult[P nistPoint[P]](b *testing.B, p P, scalarSize int) {\n\tscalar := make([]byte, scalarSize)\n\trand.Read(scalar)\n\tb.ReportAllocs()\n\tb.ResetTimer()\n\tfor i := 0; i < b.N; i++ {\n\t\tp.ScalarBaseMult(scalar)\n\t}\n}\n", "// Copyright 2015 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n// This file contains the Go wrapper for the constant-time, 64-bit assembly\n// implementation of P256. The optimizations performed here are described in\n// detail in:\n// S.Gueron and V.Krasnov, \"Fast prime field elliptic-curve cryptography with\n//                          256-bit primes\"\n// https://link.springer.com/article/10.1007%2Fs13389-014-0090-x\n// https://eprint.iacr.org/2013/816.pdf\n\n//go:build !purego && (amd64 || arm64 || (ppc64le && go1.19) || s390x)\n\npackage nistec\n\nimport (\n\t_ \"embed\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"math/bits\"\n\t\"runtime\"\n\t\"unsafe\"\n)\n\n// p256Element is a P-256 base field element in [0, P-1] in the Montgomery\n// domain (with R 2\u00b2\u2075\u2076) as four limbs in little-endian order value.\ntype p256Element [4]uint64\n\n// p256One is one in the Montgomery domain.\nvar p256One = p256Element{0x0000000000000001, 0xffffffff00000000,\n\t0xffffffffffffffff, 0x00000000fffffffe}\n\nvar p256Zero = p256Element{}\n\n// p256P is 2\u00b2\u2075\u2076 - 2\u00b2\u00b2\u2074 + 2\u00b9\u2079\u00b2 + 2\u2079\u2076 - 1 in the Montgomery domain.\nvar p256P = p256Element{0xffffffffffffffff, 0x00000000ffffffff,\n\t0x0000000000000000, 0xffffffff00000001}\n\n// P256Point is a P-256 point. The zero value should not be assumed to be valid\n// (although it is in this implementation).\ntype P256Point struct {\n\t// (X:Y:Z) are Jacobian coordinates where x = X/Z\u00b2 and y = Y/Z\u00b3. The point\n\t// at infinity can be represented by any set of coordinates with Z = 0.\n\tx, y, z p256Element\n}\n\n// NewP256Point returns a new P256Point representing the point at infinity.\nfunc NewP256Point() *P256Point {\n\treturn &P256Point{\n\t\tx: p256One, y: p256One, z: p256Zero,\n\t}\n}\n\n// SetGenerator sets p to the canonical generator and returns p.\nfunc (p *P256Point) SetGenerator() *P256Point {\n\tp.x = p256Element{0x79e730d418a9143c, 0x75ba95fc5fedb601,\n\t\t0x79fb732b77622510, 0x18905f76a53755c6}\n\tp.y = p256Element{0xddf25357ce95560a, 0x8b4ab8e4ba19e45c,\n\t\t0xd2e88688dd21f325, 0x8571ff1825885d85}\n\tp.z = p256One\n\treturn p\n}\n\n// Set sets p = q and returns p.\nfunc (p *P256Point) Set(q *P256Point) *P256Point {\n\tp.x, p.y, p.z = q.x, q.y, q.z\n\treturn p\n}\n\nconst p256ElementLength = 32\nconst p256UncompressedLength = 1 + 2*p256ElementLength\nconst p256CompressedLength = 1 + p256ElementLength\n\n// SetBytes sets p to the compressed, uncompressed, or infinity value encoded in\n// b, as specified in SEC 1, Version 2.0, Section 2.3.4. If the point is not on\n// the curve, it returns nil and an error, and the receiver is unchanged.\n// Otherwise, it returns p.\nfunc (p *P256Point) SetBytes(b []byte) (*P256Point, error) {\n\t// p256Mul operates in the Montgomery domain with R = 2\u00b2\u2075\u2076 mod p. Thus rr\n\t// here is R in the Montgomery domain, or R\u00d7R mod p. See comment in\n\t// P256OrdInverse about how this is used.\n\trr := p256Element{0x0000000000000003, 0xfffffffbffffffff,\n\t\t0xfffffffffffffffe, 0x00000004fffffffd}\n\n\tswitch {\n\t// Point at infinity.\n\tcase len(b) == 1 && b[0] == 0:\n\t\treturn p.Set(NewP256Point()), nil\n\n\t// Uncompressed form.\n\tcase len(b) == p256UncompressedLength && b[0] == 4:\n\t\tvar r P256Point\n\t\tp256BigToLittle(&r.x, (*[32]byte)(b[1:33]))\n\t\tp256BigToLittle(&r.y, (*[32]byte)(b[33:65]))\n\t\tif p256LessThanP(&r.x) == 0 || p256LessThanP(&r.y) == 0 {\n\t\t\treturn nil, errors.New(\"invalid P256 element encoding\")\n\t\t}\n\t\tp256Mul(&r.x, &r.x, &rr)\n\t\tp256Mul(&r.y, &r.y, &rr)\n\t\tif err := p256CheckOnCurve(&r.x, &r.y); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tr.z = p256One\n\t\treturn p.Set(&r), nil\n\n\t// Compressed form.\n\tcase len(b) == p256CompressedLength && (b[0] == 2 || b[0] == 3):\n\t\tvar r P256Point\n\t\tp256BigToLittle(&r.x, (*[32]byte)(b[1:33]))\n\t\tif p256LessThanP(&r.x) == 0 {\n\t\t\treturn nil, errors.New(\"invalid P256 element encoding\")\n\t\t}\n\t\tp256Mul(&r.x, &r.x, &rr)\n\n\t\t// y\u00b2 = x\u00b3 - 3x + b\n\t\tp256Polynomial(&r.y, &r.x)\n\t\tif !p256Sqrt(&r.y, &r.y) {\n\t\t\treturn nil, errors.New(\"invalid P256 compressed point encoding\")\n\t\t}\n\n\t\t// Select the positive or negative root, as indicated by the least\n\t\t// significant bit, based on the encoding type byte.\n\t\tyy := new(p256Element)\n\t\tp256FromMont(yy, &r.y)\n\t\tcond := int(yy[0]&1) ^ int(b[0]&1)\n\t\tp256NegCond(&r.y, cond)\n\n\t\tr.z = p256One\n\t\treturn p.Set(&r), nil\n\n\tdefault:\n\t\treturn nil, errors.New(\"invalid P256 point encoding\")\n\t}\n}\n\n// p256Polynomial sets y2 to x\u00b3 - 3x + b, and returns y2.\nfunc p256Polynomial(y2, x *p256Element) *p256Element {\n\tx3 := new(p256Element)\n\tp256Sqr(x3, x, 1)\n\tp256Mul(x3, x3, x)\n\n\tthreeX := new(p256Element)\n\tp256Add(threeX, x, x)\n\tp256Add(threeX, threeX, x)\n\tp256NegCond(threeX, 1)\n\n\tp256B := &p256Element{0xd89cdf6229c4bddf, 0xacf005cd78843090,\n\t\t0xe5a220abf7212ed6, 0xdc30061d04874834}\n\n\tp256Add(x3, x3, threeX)\n\tp256Add(x3, x3, p256B)\n\n\t*y2 = *x3\n\treturn y2\n}\n\nfunc p256CheckOnCurve(x, y *p256Element) error {\n\t// y\u00b2 = x\u00b3 - 3x + b\n\trhs := p256Polynomial(new(p256Element), x)\n\tlhs := new(p256Element)\n\tp256Sqr(lhs, y, 1)\n\tif p256Equal(lhs, rhs) != 1 {\n\t\treturn errors.New(\"P256 point not on curve\")\n\t}\n\treturn nil\n}\n\n// p256LessThanP returns 1 if x < p, and 0 otherwise. Note that a p256Element is\n// not allowed to be equal to or greater than p, so if this function returns 0\n// then x is invalid.\nfunc p256LessThanP(x *p256Element) int {\n\tvar b uint64\n\t_, b = bits.Sub64(x[0], p256P[0], b)\n\t_, b = bits.Sub64(x[1], p256P[1], b)\n\t_, b = bits.Sub64(x[2], p256P[2], b)\n\t_, b = bits.Sub64(x[3], p256P[3], b)\n\treturn int(b)\n}\n\n// p256Add sets res = x + y.\nfunc p256Add(res, x, y *p256Element) {\n\tvar c, b uint64\n\tt1 := make([]uint64, 4)\n\tt1[0], c = bits.Add64(x[0], y[0], 0)\n\tt1[1], c = bits.Add64(x[1], y[1], c)\n\tt1[2], c = bits.Add64(x[2], y[2], c)\n\tt1[3], c = bits.Add64(x[3], y[3], c)\n\tt2 := make([]uint64, 4)\n\tt2[0], b = bits.Sub64(t1[0], p256P[0], 0)\n\tt2[1], b = bits.Sub64(t1[1], p256P[1], b)\n\tt2[2], b = bits.Sub64(t1[2], p256P[2], b)\n\tt2[3], b = bits.Sub64(t1[3], p256P[3], b)\n\t// Three options:\n\t//   - a+b < p\n\t//     then c is 0, b is 1, and t1 is correct\n\t//   - p <= a+b < 2^256\n\t//     then c is 0, b is 0, and t2 is correct\n\t//   - 2^256 <= a+b\n\t//     then c is 1, b is 1, and t2 is correct\n\tt2Mask := (c ^ b) - 1\n\tres[0] = (t1[0] & ^t2Mask) | (t2[0] & t2Mask)\n\tres[1] = (t1[1] & ^t2Mask) | (t2[1] & t2Mask)\n\tres[2] = (t1[2] & ^t2Mask) | (t2[2] & t2Mask)\n\tres[3] = (t1[3] & ^t2Mask) | (t2[3] & t2Mask)\n}\n\n// p256Sqrt sets e to a square root of x. If x is not a square, p256Sqrt returns\n// false and e is unchanged. e and x can overlap.\nfunc p256Sqrt(e, x *p256Element) (isSquare bool) {\n\tt0, t1 := new(p256Element), new(p256Element)\n\n\t// Since p = 3 mod 4, exponentiation by (p + 1) / 4 yields a square root candidate.\n\t//\n\t// The sequence of 7 multiplications and 253 squarings is derived from the\n\t// following addition chain generated with github.com/mmcloughlin/addchain v0.4.0.\n\t//\n\t//\t_10       = 2*1\n\t//\t_11       = 1 + _10\n\t//\t_1100     = _11 << 2\n\t//\t_1111     = _11 + _1100\n\t//\t_11110000 = _1111 << 4\n\t//\t_11111111 = _1111 + _11110000\n\t//\tx16       = _11111111 << 8 + _11111111\n\t//\tx32       = x16 << 16 + x16\n\t//\treturn      ((x32 << 32 + 1) << 96 + 1) << 94\n\t//\n\tp256Sqr(t0, x, 1)\n\tp256Mul(t0, x, t0)\n\tp256Sqr(t1, t0, 2)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t1, t0, 4)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t1, t0, 8)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t1, t0, 16)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t0, t0, 32)\n\tp256Mul(t0, x, t0)\n\tp256Sqr(t0, t0, 96)\n\tp256Mul(t0, x, t0)\n\tp256Sqr(t0, t0, 94)\n\n\tp256Sqr(t1, t0, 1)\n\tif p256Equal(t1, x) != 1 {\n\t\treturn false\n\t}\n\t*e = *t0\n\treturn true\n}\n\n// The following assembly functions are implemented in p256_asm_*.s\n\n// Montgomery multiplication. Sets res = in1 * in2 * R\u207b\u00b9 mod p.\n//\n//go:noescape\nfunc p256Mul(res, in1, in2 *p256Element)\n\n// Montgomery square, repeated n times (n >= 1).\n//\n//go:noescape\nfunc p256Sqr(res, in *p256Element, n int)\n\n// Montgomery multiplication by R\u207b\u00b9, or 1 outside the domain.\n// Sets res = in * R\u207b\u00b9, bringing res out of the Montgomery domain.\n//\n//go:noescape\nfunc p256FromMont(res, in *p256Element)\n\n// If cond is not 0, sets val = -val mod p.\n//\n//go:noescape\nfunc p256NegCond(val *p256Element, cond int)\n\n// If cond is 0, sets res = b, otherwise sets res = a.\n//\n//go:noescape\nfunc p256MovCond(res, a, b *P256Point, cond int)\n\n//go:noescape\nfunc p256BigToLittle(res *p256Element, in *[32]byte)\n\n//go:noescape\nfunc p256LittleToBig(res *[32]byte, in *p256Element)\n\n//go:noescape\nfunc p256OrdBigToLittle(res *p256OrdElement, in *[32]byte)\n\n//go:noescape\nfunc p256OrdLittleToBig(res *[32]byte, in *p256OrdElement)\n\n// p256Table is a table of the first 16 multiples of a point. Points are stored\n// at an index offset of -1 so [8]P is at index 7, P is at 0, and [16]P is at 15.\n// [0]P is the point at infinity and it's not stored.\ntype p256Table [16]P256Point\n\n// p256Select sets res to the point at index idx in the table.\n// idx must be in [0, 15]. It executes in constant time.\n//\n//go:noescape\nfunc p256Select(res *P256Point, table *p256Table, idx int)\n\n// p256AffinePoint is a point in affine coordinates (x, y). x and y are still\n// Montgomery domain elements. The point can't be the point at infinity.\ntype p256AffinePoint struct {\n\tx, y p256Element\n}\n\n// p256AffineTable is a table of the first 32 multiples of a point. Points are\n// stored at an index offset of -1 like in p256Table, and [0]P is not stored.\ntype p256AffineTable [32]p256AffinePoint\n\n// p256Precomputed is a series of precomputed multiples of G, the canonical\n// generator. The first p256AffineTable contains multiples of G. The second one\n// multiples of [2\u2076]G, the third one of [2\u00b9\u00b2]G, and so on, where each successive\n// table is the previous table doubled six times. Six is the width of the\n// sliding window used in p256ScalarMult, and having each table already\n// pre-doubled lets us avoid the doublings between windows entirely. This table\n// MUST NOT be modified, as it aliases into p256PrecomputedEmbed below.\nvar p256Precomputed *[43]p256AffineTable\n\n//go:embed p256_asm_table.bin\nvar p256PrecomputedEmbed string\n\nfunc init() {\n\tp256PrecomputedPtr := (*unsafe.Pointer)(unsafe.Pointer(&p256PrecomputedEmbed))\n\tif runtime.GOARCH == \"s390x\" {\n\t\tvar newTable [43 * 32 * 2 * 4]uint64\n\t\tfor i, x := range (*[43 * 32 * 2 * 4][8]byte)(*p256PrecomputedPtr) {\n\t\t\tnewTable[i] = binary.LittleEndian.Uint64(x[:])\n\t\t}\n\t\tnewTablePtr := unsafe.Pointer(&newTable)\n\t\tp256PrecomputedPtr = &newTablePtr\n\t}\n\tp256Precomputed = (*[43]p256AffineTable)(*p256PrecomputedPtr)\n}\n\n// p256SelectAffine sets res to the point at index idx in the table.\n// idx must be in [0, 31]. It executes in constant time.\n//\n//go:noescape\nfunc p256SelectAffine(res *p256AffinePoint, table *p256AffineTable, idx int)\n\n// Point addition with an affine point and constant time conditions.\n// If zero is 0, sets res = in2. If sel is 0, sets res = in1.\n// If sign is not 0, sets res = in1 + -in2. Otherwise, sets res = in1 + in2\n//\n//go:noescape\nfunc p256PointAddAffineAsm(res, in1 *P256Point, in2 *p256AffinePoint, sign, sel, zero int)\n\n// Point addition. Sets res = in1 + in2. Returns one if the two input points\n// were equal and zero otherwise. If in1 or in2 are the point at infinity, res\n// and the return value are undefined.\n//\n//go:noescape\nfunc p256PointAddAsm(res, in1, in2 *P256Point) int\n\n// Point doubling. Sets res = in + in. in can be the point at infinity.\n//\n//go:noescape\nfunc p256PointDoubleAsm(res, in *P256Point)\n\n// p256OrdElement is a P-256 scalar field element in [0, ord(G)-1] in the\n// Montgomery domain (with R 2\u00b2\u2075\u2076) as four uint64 limbs in little-endian order.\ntype p256OrdElement [4]uint64\n\n// p256OrdReduce ensures s is in the range [0, ord(G)-1].\nfunc p256OrdReduce(s *p256OrdElement) {\n\t// Since 2 * ord(G) > 2\u00b2\u2075\u2076, we can just conditionally subtract ord(G),\n\t// keeping the result if it doesn't underflow.\n\tt0, b := bits.Sub64(s[0], 0xf3b9cac2fc632551, 0)\n\tt1, b := bits.Sub64(s[1], 0xbce6faada7179e84, b)\n\tt2, b := bits.Sub64(s[2], 0xffffffffffffffff, b)\n\tt3, b := bits.Sub64(s[3], 0xffffffff00000000, b)\n\ttMask := b - 1 // zero if subtraction underflowed\n\ts[0] ^= (t0 ^ s[0]) & tMask\n\ts[1] ^= (t1 ^ s[1]) & tMask\n\ts[2] ^= (t2 ^ s[2]) & tMask\n\ts[3] ^= (t3 ^ s[3]) & tMask\n}\n\n// Add sets q = p1 + p2, and returns q. The points may overlap.\nfunc (q *P256Point) Add(r1, r2 *P256Point) *P256Point {\n\tvar sum, double P256Point\n\tr1IsInfinity := r1.isInfinity()\n\tr2IsInfinity := r2.isInfinity()\n\tpointsEqual := p256PointAddAsm(&sum, r1, r2)\n\tp256PointDoubleAsm(&double, r1)\n\tp256MovCond(&sum, &double, &sum, pointsEqual)\n\tp256MovCond(&sum, r1, &sum, r2IsInfinity)\n\tp256MovCond(&sum, r2, &sum, r1IsInfinity)\n\treturn q.Set(&sum)\n}\n\n// Double sets q = p + p, and returns q. The points may overlap.\nfunc (q *P256Point) Double(p *P256Point) *P256Point {\n\tvar double P256Point\n\tp256PointDoubleAsm(&double, p)\n\treturn q.Set(&double)\n}\n\n// ScalarBaseMult sets r = scalar * generator, where scalar is a 32-byte big\n// endian value, and returns r. If scalar is not 32 bytes long, ScalarBaseMult\n// returns an error and the receiver is unchanged.\nfunc (r *P256Point) ScalarBaseMult(scalar []byte) (*P256Point, error) {\n\tif len(scalar) != 32 {\n\t\treturn nil, errors.New(\"invalid scalar length\")\n\t}\n\tscalarReversed := new(p256OrdElement)\n\tp256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))\n\tp256OrdReduce(scalarReversed)\n\n\tr.p256BaseMult(scalarReversed)\n\treturn r, nil\n}\n\n// ScalarMult sets r = scalar * q, where scalar is a 32-byte big endian value,\n// and returns r. If scalar is not 32 bytes long, ScalarBaseMult returns an\n// error and the receiver is unchanged.\nfunc (r *P256Point) ScalarMult(q *P256Point, scalar []byte) (*P256Point, error) {\n\tif len(scalar) != 32 {\n\t\treturn nil, errors.New(\"invalid scalar length\")\n\t}\n\tscalarReversed := new(p256OrdElement)\n\tp256OrdBigToLittle(scalarReversed, (*[32]byte)(scalar))\n\tp256OrdReduce(scalarReversed)\n\n\tr.Set(q).p256ScalarMult(scalarReversed)\n\treturn r, nil\n}\n\n// uint64IsZero returns 1 if x is zero and zero otherwise.\nfunc uint64IsZero(x uint64) int {\n\tx = ^x\n\tx &= x >> 32\n\tx &= x >> 16\n\tx &= x >> 8\n\tx &= x >> 4\n\tx &= x >> 2\n\tx &= x >> 1\n\treturn int(x & 1)\n}\n\n// p256Equal returns 1 if a and b are equal and 0 otherwise.\nfunc p256Equal(a, b *p256Element) int {\n\tvar acc uint64\n\tfor i := range a {\n\t\tacc |= a[i] ^ b[i]\n\t}\n\treturn uint64IsZero(acc)\n}\n\n// isInfinity returns 1 if p is the point at infinity and 0 otherwise.\nfunc (p *P256Point) isInfinity() int {\n\treturn p256Equal(&p.z, &p256Zero)\n}\n\n// Bytes returns the uncompressed or infinity encoding of p, as specified in\n// SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the point at\n// infinity is shorter than all other encodings.\nfunc (p *P256Point) Bytes() []byte {\n\t// This function is outlined to make the allocations inline in the caller\n\t// rather than happen on the heap.\n\tvar out [p256UncompressedLength]byte\n\treturn p.bytes(&out)\n}\n\nfunc (p *P256Point) bytes(out *[p256UncompressedLength]byte) []byte {\n\t// The proper representation of the point at infinity is a single zero byte.\n\tif p.isInfinity() == 1 {\n\t\treturn append(out[:0], 0)\n\t}\n\n\tx, y := new(p256Element), new(p256Element)\n\tp.affineFromMont(x, y)\n\n\tout[0] = 4 // Uncompressed form.\n\tp256LittleToBig((*[32]byte)(out[1:33]), x)\n\tp256LittleToBig((*[32]byte)(out[33:65]), y)\n\n\treturn out[:]\n}\n\n// affineFromMont sets (x, y) to the affine coordinates of p, converted out of the\n// Montgomery domain.\nfunc (p *P256Point) affineFromMont(x, y *p256Element) {\n\tp256Inverse(y, &p.z)\n\tp256Sqr(x, y, 1)\n\tp256Mul(y, y, x)\n\n\tp256Mul(x, &p.x, x)\n\tp256Mul(y, &p.y, y)\n\n\tp256FromMont(x, x)\n\tp256FromMont(y, y)\n}\n\n// BytesX returns the encoding of the x-coordinate of p, as specified in SEC 1,\n// Version 2.0, Section 2.3.5, or an error if p is the point at infinity.\nfunc (p *P256Point) BytesX() ([]byte, error) {\n\t// This function is outlined to make the allocations inline in the caller\n\t// rather than happen on the heap.\n\tvar out [p256ElementLength]byte\n\treturn p.bytesX(&out)\n}\n\nfunc (p *P256Point) bytesX(out *[p256ElementLength]byte) ([]byte, error) {\n\tif p.isInfinity() == 1 {\n\t\treturn nil, errors.New(\"P256 point is the point at infinity\")\n\t}\n\n\tx := new(p256Element)\n\tp256Inverse(x, &p.z)\n\tp256Sqr(x, x, 1)\n\tp256Mul(x, &p.x, x)\n\tp256FromMont(x, x)\n\tp256LittleToBig((*[32]byte)(out[:]), x)\n\n\treturn out[:], nil\n}\n\n// BytesCompressed returns the compressed or infinity encoding of p, as\n// specified in SEC 1, Version 2.0, Section 2.3.3. Note that the encoding of the\n// point at infinity is shorter than all other encodings.\nfunc (p *P256Point) BytesCompressed() []byte {\n\t// This function is outlined to make the allocations inline in the caller\n\t// rather than happen on the heap.\n\tvar out [p256CompressedLength]byte\n\treturn p.bytesCompressed(&out)\n}\n\nfunc (p *P256Point) bytesCompressed(out *[p256CompressedLength]byte) []byte {\n\tif p.isInfinity() == 1 {\n\t\treturn append(out[:0], 0)\n\t}\n\n\tx, y := new(p256Element), new(p256Element)\n\tp.affineFromMont(x, y)\n\n\tout[0] = 2 | byte(y[0]&1)\n\tp256LittleToBig((*[32]byte)(out[1:33]), x)\n\n\treturn out[:]\n}\n\n// Select sets q to p1 if cond == 1, and to p2 if cond == 0.\nfunc (q *P256Point) Select(p1, p2 *P256Point, cond int) *P256Point {\n\tp256MovCond(q, p1, p2, cond)\n\treturn q\n}\n\n// p256Inverse sets out to in\u207b\u00b9 mod p. If in is zero, out will be zero.\nfunc p256Inverse(out, in *p256Element) {\n\t// Inversion is calculated through exponentiation by p - 2, per Fermat's\n\t// little theorem.\n\t//\n\t// The sequence of 12 multiplications and 255 squarings is derived from the\n\t// following addition chain generated with github.com/mmcloughlin/addchain\n\t// v0.4.0.\n\t//\n\t//  _10     = 2*1\n\t//  _11     = 1 + _10\n\t//  _110    = 2*_11\n\t//  _111    = 1 + _110\n\t//  _111000 = _111 << 3\n\t//  _111111 = _111 + _111000\n\t//  x12     = _111111 << 6 + _111111\n\t//  x15     = x12 << 3 + _111\n\t//  x16     = 2*x15 + 1\n\t//  x32     = x16 << 16 + x16\n\t//  i53     = x32 << 15\n\t//  x47     = x15 + i53\n\t//  i263    = ((i53 << 17 + 1) << 143 + x47) << 47\n\t//  return    (x47 + i263) << 2 + 1\n\t//\n\tvar z = new(p256Element)\n\tvar t0 = new(p256Element)\n\tvar t1 = new(p256Element)\n\n\tp256Sqr(z, in, 1)\n\tp256Mul(z, in, z)\n\tp256Sqr(z, z, 1)\n\tp256Mul(z, in, z)\n\tp256Sqr(t0, z, 3)\n\tp256Mul(t0, z, t0)\n\tp256Sqr(t1, t0, 6)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t0, t0, 3)\n\tp256Mul(z, z, t0)\n\tp256Sqr(t0, z, 1)\n\tp256Mul(t0, in, t0)\n\tp256Sqr(t1, t0, 16)\n\tp256Mul(t0, t0, t1)\n\tp256Sqr(t0, t0, 15)\n\tp256Mul(z, z, t0)\n\tp256Sqr(t0, t0, 17)\n\tp256Mul(t0, in, t0)\n\tp256Sqr(t0, t0, 143)\n\tp256Mul(t0, z, t0)\n\tp256Sqr(t0, t0, 47)\n\tp256Mul(z, z, t0)\n\tp256Sqr(z, z, 2)\n\tp256Mul(out, in, z)\n}\n\nfunc boothW5(in uint) (int, int) {\n\tvar s uint = ^((in >> 5) - 1)\n\tvar d uint = (1 << 6) - in - 1\n\td = (d & s) | (in & (^s))\n\td = (d >> 1) + (d & 1)\n\treturn int(d), int(s & 1)\n}\n\nfunc boothW6(in uint) (int, int) {\n\tvar s uint = ^((in >> 6) - 1)\n\tvar d uint = (1 << 7) - in - 1\n\td = (d & s) | (in & (^s))\n\td = (d >> 1) + (d & 1)\n\treturn int(d), int(s & 1)\n}\n\nfunc (p *P256Point) p256BaseMult(scalar *p256OrdElement) {\n\tvar t0 p256AffinePoint\n\n\twvalue := (scalar[0] << 1) & 0x7f\n\tsel, sign := boothW6(uint(wvalue))\n\tp256SelectAffine(&t0, &p256Precomputed[0], sel)\n\tp.x, p.y, p.z = t0.x, t0.y, p256One\n\tp256NegCond(&p.y, sign)\n\n\tindex := uint(5)\n\tzero := sel\n\n\tfor i := 1; i < 43; i++ {\n\t\tif index < 192 {\n\t\t\twvalue = ((scalar[index/64] >> (index % 64)) + (scalar[index/64+1] << (64 - (index % 64)))) & 0x7f\n\t\t} else {\n\t\t\twvalue = (scalar[index/64] >> (index % 64)) & 0x7f\n\t\t}\n\t\tindex += 6\n\t\tsel, sign = boothW6(uint(wvalue))\n\t\tp256SelectAffine(&t0, &p256Precomputed[i], sel)\n\t\tp256PointAddAffineAsm(p, p, &t0, sign, sel, zero)\n\t\tzero |= sel\n\t}\n\n\t// If the whole scalar was zero, set to the point at infinity.\n\tp256MovCond(p, p, NewP256Point(), zero)\n}\n\nfunc (p *P256Point) p256ScalarMult(scalar *p256OrdElement) {\n\t// precomp is a table of precomputed points that stores powers of p\n\t// from p^1 to p^16.\n\tvar precomp p256Table\n\tvar t0, t1, t2, t3 P256Point\n\n\t// Prepare the table\n\tprecomp[0] = *p // 1\n\n\tp256PointDoubleAsm(&t0, p)\n\tp256PointDoubleAsm(&t1, &t0)\n\tp256PointDoubleAsm(&t2, &t1)\n\tp256PointDoubleAsm(&t3, &t2)\n\tprecomp[1] = t0  // 2\n\tprecomp[3] = t1  // 4\n\tprecomp[7] = t2  // 8\n\tprecomp[15] = t3 // 16\n\n\tp256PointAddAsm(&t0, &t0, p)\n\tp256PointAddAsm(&t1, &t1, p)\n\tp256PointAddAsm(&t2, &t2, p)\n\tprecomp[2] = t0 // 3\n\tprecomp[4] = t1 // 5\n\tprecomp[8] = t2 // 9\n\n\tp256PointDoubleAsm(&t0, &t0)\n\tp256PointDoubleAsm(&t1, &t1)\n\tprecomp[5] = t0 // 6\n\tprecomp[9] = t1 // 10\n\n\tp256PointAddAsm(&t2, &t0, p)\n\tp256PointAddAsm(&t1, &t1, p)\n\tprecomp[6] = t2  // 7\n\tprecomp[10] = t1 // 11\n\n\tp256PointDoubleAsm(&t0, &t0)\n\tp256PointDoubleAsm(&t2, &t2)\n\tprecomp[11] = t0 // 12\n\tprecomp[13] = t2 // 14\n\n\tp256PointAddAsm(&t0, &t0, p)\n\tp256PointAddAsm(&t2, &t2, p)\n\tprecomp[12] = t0 // 13\n\tprecomp[14] = t2 // 15\n\n\t// Start scanning the window from top bit\n\tindex := uint(254)\n\tvar sel, sign int\n\n\twvalue := (scalar[index/64] >> (index % 64)) & 0x3f\n\tsel, _ = boothW5(uint(wvalue))\n\n\tp256Select(p, &precomp, sel)\n\tzero := sel\n\n\tfor index > 4 {\n\t\tindex -= 5\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\t\tp256PointDoubleAsm(p, p)\n\n\t\tif index < 192 {\n\t\t\twvalue = ((scalar[index/64] >> (index % 64)) + (scalar[index/64+1] << (64 - (index % 64)))) & 0x3f\n\t\t} else {\n\t\t\twvalue = (scalar[index/64] >> (index % 64)) & 0x3f\n\t\t}\n\n\t\tsel, sign = boothW5(uint(wvalue))\n\n\t\tp256Select(&t0, &precomp, sel)\n\t\tp256NegCond(&t0.y, sign)\n\t\tp256PointAddAsm(&t1, p, &t0)\n\t\tp256MovCond(&t1, &t1, p, sel)\n\t\tp256MovCond(p, &t1, &t0, zero)\n\t\tzero |= sel\n\t}\n\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\tp256PointDoubleAsm(p, p)\n\n\twvalue = (scalar[0] << 1) & 0x3f\n\tsel, sign = boothW5(uint(wvalue))\n\n\tp256Select(&t0, &precomp, sel)\n\tp256NegCond(&t0.y, sign)\n\tp256PointAddAsm(&t1, p, &t0)\n\tp256MovCond(&t1, &t1, p, sel)\n\tp256MovCond(p, &t1, &t0, zero)\n}\n", "// Copyright 2022 The Go Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style\n// license that can be found in the LICENSE file.\n\n//go:build !purego && (amd64 || arm64)\n\npackage nistec\n\nimport \"errors\"\n\n// Montgomery multiplication modulo org(G). Sets res = in1 * in2 * R\u207b\u00b9.\n//\n//go:noescape\nfunc p256OrdMul(res, in1, in2 *p256OrdElement)\n\n// Montgomery square modulo org(G), repeated n times (n >= 1).\n//\n//go:noescape\nfunc p256OrdSqr(res, in *p256OrdElement, n int)\n\nfunc p256OrdInverse(k []byte) ([]byte, error) {\n\tif len(k) != 32 {\n\t\treturn nil, errors.New(\"invalid scalar length\")\n\t}\n\n\tx := new(p256OrdElement)\n\tp256OrdBigToLittle(x, (*[32]byte)(k))\n\tp256OrdReduce(x)\n\n\t// Inversion is implemented as exponentiation by n - 2, per Fermat's little theorem.\n\t//\n\t// The sequence of 38 multiplications and 254 squarings is derived from\n\t// https://briansmith.org/ecc-inversion-addition-chains-01#p256_scalar_inversion\n\t_1 := new(p256OrdElement)\n\t_11 := new(p256OrdElement)\n\t_101 := new(p256OrdElement)\n\t_111 := new(p256OrdElement)\n\t_1111 := new(p256OrdElement)\n\t_10101 := new(p256OrdElement)\n\t_101111 := new(p256OrdElement)\n\tt := new(p256OrdElement)\n\n\t// This code operates in the Montgomery domain where R = 2\u00b2\u2075\u2076 mod n and n is\n\t// the order of the scalar field. Elements in the Montgomery domain take the\n\t// form a\u00d7R and p256OrdMul calculates (a \u00d7 b \u00d7 R\u207b\u00b9) mod n. RR is R in the\n\t// domain, or R\u00d7R mod n, thus p256OrdMul(x, RR) gives x\u00d7R, i.e. converts x\n\t// into the Montgomery domain.\n\tRR := &p256OrdElement{0x83244c95be79eea2, 0x4699799c49bd6fa6,\n\t\t0x2845b2392b6bec59, 0x66e12d94f3d95620}\n\n\tp256OrdMul(_1, x, RR)      // _1\n\tp256OrdSqr(x, _1, 1)       // _10\n\tp256OrdMul(_11, x, _1)     // _11\n\tp256OrdMul(_101, x, _11)   // _101\n\tp256OrdMul(_111, x, _101)  // _111\n\tp256OrdSqr(x, _101, 1)     // _1010\n\tp256OrdMul(_1111, _101, x) // _1111\n\n\tp256OrdSqr(t, x, 1)          // _10100\n\tp256OrdMul(_10101, t, _1)    // _10101\n\tp256OrdSqr(x, _10101, 1)     // _101010\n\tp256OrdMul(_101111, _101, x) // _101111\n\tp256OrdMul(x, _10101, x)     // _111111 = x6\n\tp256OrdSqr(t, x, 2)          // _11111100\n\tp256OrdMul(t, t, _11)        // _11111111 = x8\n\tp256OrdSqr(x, t, 8)          // _ff00\n\tp256OrdMul(x, x, t)          // _ffff = x16\n\tp256OrdSqr(t, x, 16)         // _ffff0000\n\tp256OrdMul(t, t, x)          // _ffffffff = x32\n\n\tp256OrdSqr(x, t, 64)\n\tp256OrdMul(x, x, t)\n\tp256OrdSqr(x, x, 32)\n\tp256OrdMul(x, x, t)\n\n\tsqrs := []int{\n\t\t6, 5, 4, 5, 5,\n\t\t4, 3, 3, 5, 9,\n\t\t6, 2, 5, 6, 5,\n\t\t4, 5, 5, 3, 10,\n\t\t2, 5, 5, 3, 7, 6}\n\tmuls := []*p256OrdElement{\n\t\t_101111, _111, _11, _1111, _10101,\n\t\t_101, _101, _101, _111, _101111,\n\t\t_1111, _1, _1, _1111, _111,\n\t\t_111, _111, _101, _11, _101111,\n\t\t_11, _11, _11, _1, _10101, _1111}\n\n\tfor i, s := range sqrs {\n\t\tp256OrdSqr(x, x, s)\n\t\tp256OrdMul(x, x, muls[i])\n\t}\n\n\t// Montgomery multiplication by R\u207b\u00b9, or 1 outside the domain as R\u207b\u00b9\u00d7R = 1,\n\t// converts a Montgomery value out of the domain.\n\tone := &p256OrdElement{1}\n\tp256OrdMul(x, x, one)\n\n\tvar xOut [32]byte\n\tp256OrdLittleToBig(&xOut, x)\n\treturn xOut[:], nil\n}\n"], "filenames": ["nistec_test.go", "p256_asm.go", "p256_ordinv.go"], "buggy_code_start_loc": [9, 366, 27], "buggy_code_end_loc": [165, 409, 27], "fixing_code_start_loc": [10, 367, 28], "fixing_code_end_loc": [247, 427, 29], "type": "CWE-682", "message": "Multiplication of certain unreduced P-256 scalars produce incorrect results. There are no protocols known at this time that can be attacked due to this.", "other": {"cve": {"id": "CVE-2023-24533", "sourceIdentifier": "security@golang.org", "published": "2023-03-08T20:15:09.497", "lastModified": "2023-03-15T17:58:45.570", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Multiplication of certain unreduced P-256 scalars produce incorrect results. There are no protocols known at this time that can be attacked due to this."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-682"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-682"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nistec_project:nistec:*:*:*:*:*:go:*:*", "versionEndExcluding": "0.0.2", "matchCriteriaId": "977207C5-A6D3-4511-A6C2-9758580B2F13"}]}]}], "references": [{"url": "https://github.com/FiloSottile/nistec/commit/c58aa1223ccf3943513e1e661cebce95af137244", "source": "security@golang.org", "tags": ["Patch"]}, {"url": "https://go.dev/issue/58647", "source": "security@golang.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://pkg.go.dev/vuln/GO-2023-1595", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FiloSottile/nistec/commit/c58aa1223ccf3943513e1e661cebce95af137244"}}