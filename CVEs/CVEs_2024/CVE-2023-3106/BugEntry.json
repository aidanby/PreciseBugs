{"buggy_code": ["/* xfrm_user.c: User interface to configure xfrm engine.\n *\n * Copyright (C) 2002 David S. Miller (davem@redhat.com)\n *\n * Changes:\n *\tMitsuru KANDA @USAGI\n * \tKazunori MIYAZAWA @USAGI\n * \tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n * \t\tIPv6 support\n *\n */\n\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <net/sock.h>\n#include <net/xfrm.h>\n#include <net/netlink.h>\n#include <net/ah.h>\n#include <asm/uaccess.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#endif\n#include <asm/unaligned.h>\n\nstatic int verify_one_alg(struct nlattr **attrs, enum xfrm_attr_type_t type)\n{\n\tstruct nlattr *rt = attrs[type];\n\tstruct xfrm_algo *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_len(algp))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase XFRMA_ALG_AUTH:\n\tcase XFRMA_ALG_CRYPT:\n\tcase XFRMA_ALG_COMP:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_auth_trunc(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AUTH_TRUNC];\n\tstruct xfrm_algo_auth *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_auth_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_aead(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AEAD];\n\tstruct xfrm_algo_aead *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < aead_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic void verify_one_addr(struct nlattr **attrs, enum xfrm_attr_type_t type,\n\t\t\t   xfrm_address_t **addrp)\n{\n\tstruct nlattr *rt = attrs[type];\n\n\tif (rt && addrp)\n\t\t*addrp = nla_data(rt);\n}\n\nstatic inline int verify_sec_ctx_len(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\tif (uctx->len != (sizeof(struct xfrm_user_sec_ctx) + uctx->ctx_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int verify_replay(struct xfrm_usersa_info *p,\n\t\t\t\tstruct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct xfrm_replay_state_esn *rs;\n\n\tif (p->flags & XFRM_STATE_ESN) {\n\t\tif (!rt)\n\t\t\treturn -EINVAL;\n\n\t\trs = nla_data(rt);\n\n\t\tif (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&\n\t\t    nla_len(rt) != sizeof(*rs))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rt)\n\t\treturn 0;\n\n\t/* As only ESP and AH support ESN feature. */\n\tif ((p->id.proto != IPPROTO_ESP) && (p->id.proto != IPPROTO_AH))\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int verify_newsa_info(struct xfrm_usersa_info *p,\n\t\t\t     struct nlattr **attrs)\n{\n\tint err;\n\n\terr = -EINVAL;\n\tswitch (p->family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = -EINVAL;\n\tswitch (p->id.proto) {\n\tcase IPPROTO_AH:\n\t\tif ((!attrs[XFRMA_ALG_AUTH]\t&&\n\t\t     !attrs[XFRMA_ALG_AUTH_TRUNC]) ||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_ESP:\n\t\tif (attrs[XFRMA_ALG_COMP])\n\t\t\tgoto out;\n\t\tif (!attrs[XFRMA_ALG_AUTH] &&\n\t\t    !attrs[XFRMA_ALG_AUTH_TRUNC] &&\n\t\t    !attrs[XFRMA_ALG_CRYPT] &&\n\t\t    !attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif ((attrs[XFRMA_ALG_AUTH] ||\n\t\t     attrs[XFRMA_ALG_AUTH_TRUNC] ||\n\t\t     attrs[XFRMA_ALG_CRYPT]) &&\n\t\t    attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif (attrs[XFRMA_TFCPAD] &&\n\t\t    p->mode != XFRM_MODE_TUNNEL)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\tif (!attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    (ntohl(p->id.spi) >= 0x10000))\n\t\t\tgoto out;\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_DSTOPTS:\n\tcase IPPROTO_ROUTING:\n\t\tif (attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ENCAP]\t\t||\n\t\t    attrs[XFRMA_SEC_CTX]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    !attrs[XFRMA_COADDR])\n\t\t\tgoto out;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif ((err = verify_aead(attrs)))\n\t\tgoto out;\n\tif ((err = verify_auth_trunc(attrs)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))\n\t\tgoto out;\n\tif ((err = verify_sec_ctx_len(attrs)))\n\t\tgoto out;\n\tif ((err = verify_replay(p, attrs)))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tswitch (p->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_BEET:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic int attach_one_algo(struct xfrm_algo **algpp, u8 *props,\n\t\t\t   struct xfrm_algo_desc *(*get_byname)(const char *, int),\n\t\t\t   struct nlattr *rta)\n{\n\tstruct xfrm_algo *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_crypt(struct xfrm_state *x, struct nlattr *rta)\n{\n\tstruct xfrm_algo *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_ealg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tx->props.ealgo = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tx->ealg = p;\n\tx->geniv = algo->uinfo.encr.geniv;\n\treturn 0;\n}\n\nstatic int attach_auth(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_algo *ualg;\n\tstruct xfrm_algo_auth *p;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmalloc(sizeof(*p) + (ualg->alg_key_len + 7) / 8, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tp->alg_key_len = ualg->alg_key_len;\n\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\tmemcpy(p->alg_key, ualg->alg_key, (ualg->alg_key_len + 7) / 8);\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_auth_trunc(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t\t     struct nlattr *rta)\n{\n\tstruct xfrm_algo_auth *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tif (ualg->alg_trunc_len > algo->uinfo.auth.icv_fullbits)\n\t\treturn -EINVAL;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_auth_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tif (!p->alg_trunc_len)\n\t\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_aead(struct xfrm_state *x, struct nlattr *rta)\n{\n\tstruct xfrm_algo_aead *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aead_get_byname(ualg->alg_name, ualg->alg_icv_len, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tx->props.ealgo = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, aead_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tx->aead = p;\n\tx->geniv = algo->uinfo.aead.geniv;\n\treturn 0;\n}\n\nstatic inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\n\t\t\t\t       struct xfrm_replay_state_esn **preplay_esn,\n\t\t\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_replay_state_esn *p, *pp, *up;\n\tint klen, ulen;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tup = nla_data(rta);\n\tklen = xfrm_replay_state_esn_len(up);\n\tulen = nla_len(rta) >= klen ? klen : sizeof(*up);\n\n\tp = kzalloc(klen, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpp = kzalloc(klen, GFP_KERNEL);\n\tif (!pp) {\n\t\tkfree(p);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(p, up, ulen);\n\tmemcpy(pp, up, ulen);\n\n\t*replay_esn = p;\n\t*preplay_esn = pp;\n\n\treturn 0;\n}\n\nstatic inline int xfrm_user_sec_ctx_size(struct xfrm_sec_ctx *xfrm_ctx)\n{\n\tint len = 0;\n\n\tif (xfrm_ctx) {\n\t\tlen += sizeof(struct xfrm_user_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t}\n\treturn len;\n}\n\nstatic void copy_from_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemcpy(&x->id, &p->id, sizeof(x->id));\n\tmemcpy(&x->sel, &p->sel, sizeof(x->sel));\n\tmemcpy(&x->lft, &p->lft, sizeof(x->lft));\n\tx->props.mode = p->mode;\n\tx->props.replay_window = min_t(unsigned int, p->replay_window,\n\t\t\t\t\tsizeof(x->replay.bitmap) * 8);\n\tx->props.reqid = p->reqid;\n\tx->props.family = p->family;\n\tmemcpy(&x->props.saddr, &p->saddr, sizeof(x->props.saddr));\n\tx->props.flags = p->flags;\n\n\tif (!x->sel.family && !(p->flags & XFRM_STATE_AF_UNSPEC))\n\t\tx->sel.family = p->family;\n}\n\n/*\n * someday when pfkey also has support, we could have the code\n * somehow made shareable and move it to xfrm_state.c - JHS\n *\n*/\nstatic void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs,\n\t\t\t\t  int update_esn)\n{\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = update_esn ? attrs[XFRMA_REPLAY_ESN_VAL] : NULL;\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (re) {\n\t\tstruct xfrm_replay_state_esn *replay_esn;\n\t\treplay_esn = nla_data(re);\n\t\tmemcpy(x->replay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t\tmemcpy(x->preplay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t}\n\n\tif (rp) {\n\t\tstruct xfrm_replay_state *replay;\n\t\treplay = nla_data(rp);\n\t\tmemcpy(&x->replay, replay, sizeof(*replay));\n\t\tmemcpy(&x->preplay, replay, sizeof(*replay));\n\t}\n\n\tif (lt) {\n\t\tstruct xfrm_lifetime_cur *ltime;\n\t\tltime = nla_data(lt);\n\t\tx->curlft.bytes = ltime->bytes;\n\t\tx->curlft.packets = ltime->packets;\n\t\tx->curlft.add_time = ltime->add_time;\n\t\tx->curlft.use_time = ltime->use_time;\n\t}\n\n\tif (et)\n\t\tx->replay_maxage = nla_get_u32(et);\n\n\tif (rt)\n\t\tx->replay_maxdiff = nla_get_u32(rt);\n}\n\nstatic struct xfrm_state *xfrm_state_construct(struct net *net,\n\t\t\t\t\t       struct xfrm_usersa_info *p,\n\t\t\t\t\t       struct nlattr **attrs,\n\t\t\t\t\t       int *errp)\n{\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto error_no_put;\n\n\tcopy_from_user_state(x, p);\n\n\tif (attrs[XFRMA_SA_EXTRA_FLAGS])\n\t\tx->props.extra_flags = nla_get_u32(attrs[XFRMA_SA_EXTRA_FLAGS]);\n\n\tif ((err = attach_aead(x, attrs[XFRMA_ALG_AEAD])))\n\t\tgoto error;\n\tif ((err = attach_auth_trunc(&x->aalg, &x->props.aalgo,\n\t\t\t\t     attrs[XFRMA_ALG_AUTH_TRUNC])))\n\t\tgoto error;\n\tif (!x->props.aalgo) {\n\t\tif ((err = attach_auth(&x->aalg, &x->props.aalgo,\n\t\t\t\t       attrs[XFRMA_ALG_AUTH])))\n\t\t\tgoto error;\n\t}\n\tif ((err = attach_crypt(x, attrs[XFRMA_ALG_CRYPT])))\n\t\tgoto error;\n\tif ((err = attach_one_algo(&x->calg, &x->props.calgo,\n\t\t\t\t   xfrm_calg_get_byname,\n\t\t\t\t   attrs[XFRMA_ALG_COMP])))\n\t\tgoto error;\n\n\tif (attrs[XFRMA_ENCAP]) {\n\t\tx->encap = kmemdup(nla_data(attrs[XFRMA_ENCAP]),\n\t\t\t\t   sizeof(*x->encap), GFP_KERNEL);\n\t\tif (x->encap == NULL)\n\t\t\tgoto error;\n\t}\n\n\tif (attrs[XFRMA_TFCPAD])\n\t\tx->tfcpad = nla_get_u32(attrs[XFRMA_TFCPAD]);\n\n\tif (attrs[XFRMA_COADDR]) {\n\t\tx->coaddr = kmemdup(nla_data(attrs[XFRMA_COADDR]),\n\t\t\t\t    sizeof(*x->coaddr), GFP_KERNEL);\n\t\tif (x->coaddr == NULL)\n\t\t\tgoto error;\n\t}\n\n\txfrm_mark_get(attrs, &x->mark);\n\n\terr = __xfrm_init_state(x, false);\n\tif (err)\n\t\tgoto error;\n\n\tif (attrs[XFRMA_SEC_CTX] &&\n\t    security_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])))\n\t\tgoto error;\n\n\tif ((err = xfrm_alloc_replay_state_esn(&x->replay_esn, &x->preplay_esn,\n\t\t\t\t\t       attrs[XFRMA_REPLAY_ESN_VAL])))\n\t\tgoto error;\n\n\tx->km.seq = p->seq;\n\tx->replay_maxdiff = net->xfrm.sysctl_aevent_rseqth;\n\t/* sysctl_xfrm_aevent_etime is in 100ms units */\n\tx->replay_maxage = (net->xfrm.sysctl_aevent_etime*HZ)/XFRM_AE_ETH_M;\n\n\tif ((err = xfrm_init_replay(x)))\n\t\tgoto error;\n\n\t/* override default values from above */\n\txfrm_update_ae_params(x, attrs, 0);\n\n\treturn x;\n\nerror:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\nerror_no_put:\n\t*errp = err;\n\treturn NULL;\n}\n\nstatic int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_info *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\n\terr = verify_newsa_info(p, attrs);\n\tif (err)\n\t\treturn err;\n\n\tx = xfrm_state_construct(net, p, attrs, &err);\n\tif (!x)\n\t\treturn err;\n\n\txfrm_state_hold(x);\n\tif (nlh->nlmsg_type == XFRM_MSG_NEWSA)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic struct xfrm_state *xfrm_user_state_lookup(struct net *net,\n\t\t\t\t\t\t struct xfrm_usersa_id *p,\n\t\t\t\t\t\t struct nlattr **attrs,\n\t\t\t\t\t\t int *errp)\n{\n\tstruct xfrm_state *x = NULL;\n\tstruct xfrm_mark m;\n\tint err;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tif (xfrm_id_proto_match(p->proto, IPSEC_PROTO_ANY)) {\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup(net, mark, &p->daddr, p->spi, p->proto, p->family);\n\t} else {\n\t\txfrm_address_t *saddr = NULL;\n\n\t\tverify_one_addr(attrs, XFRMA_SRCADDR, &saddr);\n\t\tif (!saddr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup_byaddr(net, mark,\n\t\t\t\t\t     &p->daddr, saddr,\n\t\t\t\t\t     p->proto, p->family);\n\t}\n\n out:\n\tif (!x && errp)\n\t\t*errp = err;\n\treturn x;\n}\n\nstatic int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err = -ESRCH;\n\tstruct km_event c;\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\treturn err;\n\n\tif ((err = security_xfrm_state_delete(x)) != 0)\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\tkm_state_notify(x, &c);\n\nout:\n\txfrm_audit_state_delete(x, err ? 0 : 1, true);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tput_unaligned(x->stats.replay_window, &p->stats.replay_window);\n\tput_unaligned(x->stats.replay, &p->stats.replay);\n\tput_unaligned(x->stats.integrity_failed, &p->stats.integrity_failed);\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n\nstruct xfrm_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstatic int copy_sec_ctx(struct xfrm_sec_ctx *s, struct sk_buff *skb)\n{\n\tstruct xfrm_user_sec_ctx *uctx;\n\tstruct nlattr *attr;\n\tint ctx_size = sizeof(*uctx) + s->ctx_len;\n\n\tattr = nla_reserve(skb, XFRMA_SEC_CTX, ctx_size);\n\tif (attr == NULL)\n\t\treturn -EMSGSIZE;\n\n\tuctx = nla_data(attr);\n\tuctx->exttype = XFRMA_SEC_CTX;\n\tuctx->len = ctx_size;\n\tuctx->ctx_doi = s->ctx_doi;\n\tuctx->ctx_alg = s->ctx_alg;\n\tuctx->ctx_len = s->ctx_len;\n\tmemcpy(uctx + 1, s->ctx_str, s->ctx_len);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}\n\n/* Don't change this without updating xfrm_sa_len! */\nstatic int copy_to_user_state_extra(struct xfrm_state *x,\n\t\t\t\t    struct xfrm_usersa_info *p,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tint ret = 0;\n\n\tcopy_to_user_state(x, p);\n\n\tif (x->props.extra_flags) {\n\t\tret = nla_put_u32(skb, XFRMA_SA_EXTRA_FLAGS,\n\t\t\t\t  x->props.extra_flags);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (x->coaddr) {\n\t\tret = nla_put(skb, XFRMA_COADDR, sizeof(*x->coaddr), x->coaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->lastused) {\n\t\tret = nla_put_u64_64bit(skb, XFRMA_LASTUSED, x->lastused,\n\t\t\t\t\tXFRMA_PAD);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aead) {\n\t\tret = nla_put(skb, XFRMA_ALG_AEAD, aead_len(x->aead), x->aead);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aalg) {\n\t\tret = copy_to_user_auth(x->aalg, skb);\n\t\tif (!ret)\n\t\t\tret = nla_put(skb, XFRMA_ALG_AUTH_TRUNC,\n\t\t\t\t      xfrm_alg_auth_len(x->aalg), x->aalg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->ealg) {\n\t\tret = nla_put(skb, XFRMA_ALG_CRYPT, xfrm_alg_len(x->ealg), x->ealg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->calg) {\n\t\tret = nla_put(skb, XFRMA_ALG_COMP, sizeof(*(x->calg)), x->calg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->encap) {\n\t\tret = nla_put(skb, XFRMA_ENCAP, sizeof(*x->encap), x->encap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->tfcpad) {\n\t\tret = nla_put_u32(skb, XFRMA_TFCPAD, x->tfcpad);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = xfrm_mark_put(skb, &x->mark);\n\tif (ret)\n\t\tgoto out;\n\tif (x->replay_esn)\n\t\tret = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\telse\n\t\tret = nla_put(skb, XFRMA_REPLAY_VAL, sizeof(x->replay),\n\t\t\t      &x->replay);\n\tif (ret)\n\t\tgoto out;\n\tif (x->security)\n\t\tret = copy_sec_ctx(x->security, skb);\nout:\n\treturn ret;\n}\n\nstatic int dump_one_state(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct xfrm_usersa_info *p;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWSA, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\n\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}\n\nstatic const struct nla_policy xfrma_policy[XFRMA_MAX+1];\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\tcb->args[0] = 1;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_state(x, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\n/* A wrapper for nlmsg_multicast() checking that nlsk is still available.\n * Must be called with RCU read lock.\n */\nstatic inline int xfrm_nlmsg_multicast(struct net *net, struct sk_buff *skb,\n\t\t\t\t       u32 pid, unsigned int group)\n{\n\tstruct sock *nlsk = rcu_dereference(net->xfrm.nlsk);\n\n\tif (nlsk)\n\t\treturn nlmsg_multicast(nlsk, skb, pid, group, GFP_ATOMIC);\n\telse\n\t\treturn -1;\n}\n\nstatic inline size_t xfrm_spdinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_spdinfo))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhinfo))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhthresh))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhthresh));\n}\n\nstatic int build_spdinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_spdinfo si;\n\tstruct xfrmu_spdinfo spc;\n\tstruct xfrmu_spdhinfo sph;\n\tstruct xfrmu_spdhthresh spt4, spt6;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\tunsigned lseq;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSPDINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_spd_getinfo(net, &si);\n\tspc.incnt = si.incnt;\n\tspc.outcnt = si.outcnt;\n\tspc.fwdcnt = si.fwdcnt;\n\tspc.inscnt = si.inscnt;\n\tspc.outscnt = si.outscnt;\n\tspc.fwdscnt = si.fwdscnt;\n\tsph.spdhcnt = si.spdhcnt;\n\tsph.spdhmcnt = si.spdhmcnt;\n\n\tdo {\n\t\tlseq = read_seqbegin(&net->xfrm.policy_hthresh.lock);\n\n\t\tspt4.lbits = net->xfrm.policy_hthresh.lbits4;\n\t\tspt4.rbits = net->xfrm.policy_hthresh.rbits4;\n\t\tspt6.lbits = net->xfrm.policy_hthresh.lbits6;\n\t\tspt6.rbits = net->xfrm.policy_hthresh.rbits6;\n\t} while (read_seqretry(&net->xfrm.policy_hthresh.lock, lseq));\n\n\terr = nla_put(skb, XFRMA_SPD_INFO, sizeof(spc), &spc);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_HINFO, sizeof(sph), &sph);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_IPV4_HTHRESH, sizeof(spt4), &spt4);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_IPV6_HTHRESH, sizeof(spt6), &spt6);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_set_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrmu_spdhthresh *thresh4 = NULL;\n\tstruct xfrmu_spdhthresh *thresh6 = NULL;\n\n\t/* selector prefixlen thresholds to hash policies */\n\tif (attrs[XFRMA_SPD_IPV4_HTHRESH]) {\n\t\tstruct nlattr *rta = attrs[XFRMA_SPD_IPV4_HTHRESH];\n\n\t\tif (nla_len(rta) < sizeof(*thresh4))\n\t\t\treturn -EINVAL;\n\t\tthresh4 = nla_data(rta);\n\t\tif (thresh4->lbits > 32 || thresh4->rbits > 32)\n\t\t\treturn -EINVAL;\n\t}\n\tif (attrs[XFRMA_SPD_IPV6_HTHRESH]) {\n\t\tstruct nlattr *rta = attrs[XFRMA_SPD_IPV6_HTHRESH];\n\n\t\tif (nla_len(rta) < sizeof(*thresh6))\n\t\t\treturn -EINVAL;\n\t\tthresh6 = nla_data(rta);\n\t\tif (thresh6->lbits > 128 || thresh6->rbits > 128)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (thresh4 || thresh6) {\n\t\twrite_seqlock(&net->xfrm.policy_hthresh.lock);\n\t\tif (thresh4) {\n\t\t\tnet->xfrm.policy_hthresh.lbits4 = thresh4->lbits;\n\t\t\tnet->xfrm.policy_hthresh.rbits4 = thresh4->rbits;\n\t\t}\n\t\tif (thresh6) {\n\t\t\tnet->xfrm.policy_hthresh.lbits6 = thresh6->lbits;\n\t\t\tnet->xfrm.policy_hthresh.rbits6 = thresh6->rbits;\n\t\t}\n\t\twrite_sequnlock(&net->xfrm.policy_hthresh.lock);\n\n\t\txfrm_policy_hash_rebuild(net);\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm_get_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_spdinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_spdinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic inline size_t xfrm_sadinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_sadhinfo))\n\t       + nla_total_size(4); /* XFRMA_SAD_CNT */\n}\n\nstatic int build_sadinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_sadinfo si;\n\tstruct xfrmu_sadhinfo sh;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSADINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_sad_getinfo(net, &si);\n\n\tsh.sadhmcnt = si.sadhmcnt;\n\tsh.sadhcnt = si.sadhcnt;\n\n\terr = nla_put_u32(skb, XFRMA_SAD_CNT, si.sadcnt);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SAD_HINFO, sizeof(sh), &sh);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_get_sadinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_sadinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_sadinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic int xfrm_get_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *resp_skb;\n\tint err = -ESRCH;\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t} else {\n\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\t}\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int xfrm_alloc_userspi(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct xfrm_userspi_info *p;\n\tstruct sk_buff *resp_skb;\n\txfrm_address_t *daddr;\n\tint family;\n\tint err;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\n\tp = nlmsg_data(nlh);\n\terr = verify_spi_info(p->info.id.proto, p->min, p->max);\n\tif (err)\n\t\tgoto out_noput;\n\n\tfamily = p->info.family;\n\tdaddr = &p->info.id.daddr;\n\n\tx = NULL;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\tif (p->info.seq) {\n\t\tx = xfrm_find_acq_byseq(net, mark, p->info.seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, daddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &m, p->info.mode, p->info.reqid,\n\t\t\t\t  p->info.id.proto, daddr,\n\t\t\t\t  &p->info.saddr, 1,\n\t\t\t\t  family);\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\terr = xfrm_alloc_spi(x, p->min, p->max);\n\tif (err)\n\t\tgoto out;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t\tgoto out;\n\t}\n\n\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\nout:\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int verify_policy_dir(u8 dir)\n{\n\tswitch (dir) {\n\tcase XFRM_POLICY_IN:\n\tcase XFRM_POLICY_OUT:\n\tcase XFRM_POLICY_FWD:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_policy_type(u8 type)\n{\n\tswitch (type) {\n\tcase XFRM_POLICY_TYPE_MAIN:\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tcase XFRM_POLICY_TYPE_SUB:\n#endif\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int copy_from_user_sec_ctx(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\treturn security_xfrm_policy_alloc(&pol->security, uctx, GFP_KERNEL);\n}\n\nstatic void copy_templates(struct xfrm_policy *xp, struct xfrm_user_tmpl *ut,\n\t\t\t   int nr)\n{\n\tint i;\n\n\txp->xfrm_nr = nr;\n\tfor (i = 0; i < nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\n\t\tmemcpy(&t->id, &ut->id, sizeof(struct xfrm_id));\n\t\tmemcpy(&t->saddr, &ut->saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tt->reqid = ut->reqid;\n\t\tt->mode = ut->mode;\n\t\tt->share = ut->share;\n\t\tt->optional = ut->optional;\n\t\tt->aalgos = ut->aalgos;\n\t\tt->ealgos = ut->ealgos;\n\t\tt->calgos = ut->calgos;\n\t\t/* If all masks are ~0, then we allow all algorithms. */\n\t\tt->allalgs = !~(t->aalgos & t->ealgos & t->calgos);\n\t\tt->encap_family = ut->family;\n\t}\n}\n\nstatic int validate_tmpl(int nr, struct xfrm_user_tmpl *ut, u16 family)\n{\n\tint i;\n\n\tif (nr > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr; i++) {\n\t\t/* We never validated the ut->family value, so many\n\t\t * applications simply leave it at zero.  The check was\n\t\t * never made and ut->family was ignored because all\n\t\t * templates could be assumed to have the same family as\n\t\t * the policy itself.  Now that we will have ipv4-in-ipv6\n\t\t * and ipv6-in-ipv4 tunnels, this is no longer true.\n\t\t */\n\t\tif (!ut[i].family)\n\t\t\tut[i].family = family;\n\n\t\tswitch (ut[i].family) {\n\t\tcase AF_INET:\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase AF_INET6:\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int copy_from_user_tmpl(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\n\tif (!rt) {\n\t\tpol->xfrm_nr = 0;\n\t} else {\n\t\tstruct xfrm_user_tmpl *utmpl = nla_data(rt);\n\t\tint nr = nla_len(rt) / sizeof(*utmpl);\n\t\tint err;\n\n\t\terr = validate_tmpl(nr, utmpl, pol->family);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcopy_templates(pol, utmpl, nr);\n\t}\n\treturn 0;\n}\n\nstatic int copy_from_user_policy_type(u8 *tp, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_POLICY_TYPE];\n\tstruct xfrm_userpolicy_type *upt;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\n\tif (rt) {\n\t\tupt = nla_data(rt);\n\t\ttype = upt->type;\n\t}\n\n\terr = verify_policy_type(type);\n\tif (err)\n\t\treturn err;\n\n\t*tp = type;\n\treturn 0;\n}\n\nstatic void copy_from_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p)\n{\n\txp->priority = p->priority;\n\txp->index = p->index;\n\tmemcpy(&xp->selector, &p->sel, sizeof(xp->selector));\n\tmemcpy(&xp->lft, &p->lft, sizeof(xp->lft));\n\txp->action = p->action;\n\txp->flags = p->flags;\n\txp->family = p->sel.family;\n\t/* XXX xp->share = p->share; */\n}\n\nstatic void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}\n\nstatic struct xfrm_policy *xfrm_policy_construct(struct net *net, struct xfrm_userpolicy_info *p, struct nlattr **attrs, int *errp)\n{\n\tstruct xfrm_policy *xp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tint err;\n\n\tif (!xp) {\n\t\t*errp = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\n\terr = copy_from_user_policy_type(&xp->type, attrs);\n\tif (err)\n\t\tgoto error;\n\n\tif (!(err = copy_from_user_tmpl(xp, attrs)))\n\t\terr = copy_from_user_sec_ctx(xp, attrs);\n\tif (err)\n\t\tgoto error;\n\n\txfrm_mark_get(attrs, &xp->mark);\n\n\treturn xp;\n error:\n\t*errp = err;\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_userpolicy_info *p = nlmsg_data(nlh);\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tint err;\n\tint excl;\n\n\terr = verify_newpolicy_info(p);\n\tif (err)\n\t\treturn err;\n\terr = verify_sec_ctx_len(attrs);\n\tif (err)\n\t\treturn err;\n\n\txp = xfrm_policy_construct(net, p, attrs, &err);\n\tif (!xp)\n\t\treturn err;\n\n\t/* shouldn't excl be based on nlh flags??\n\t * Aha! this is anti-netlink really i.e  more pfkey derived\n\t * in netlink excl is a flag and you wouldnt need\n\t * a type XFRM_MSG_UPDPOLICY - JHS */\n\texcl = nlh->nlmsg_type == XFRM_MSG_NEWPOLICY;\n\terr = xfrm_policy_insert(p->dir, xp, excl);\n\txfrm_audit_policy_add(xp, err ? 0 : 1, true);\n\n\tif (err) {\n\t\tsecurity_xfrm_policy_free(xp->security);\n\t\tkfree(xp);\n\t\treturn err;\n\t}\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tkm_policy_notify(xp, p->dir, &c);\n\n\txfrm_pol_put(xp);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n\nstatic inline int copy_to_user_state_sec_ctx(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tif (x->security) {\n\t\treturn copy_sec_ctx(x->security, skb);\n\t}\n\treturn 0;\n}\n\nstatic inline int copy_to_user_sec_ctx(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tif (xp->security)\n\t\treturn copy_sec_ctx(xp->security, skb);\n\treturn 0;\n}\nstatic inline size_t userpolicy_type_attrsize(void)\n{\n#ifdef CONFIG_XFRM_SUB_POLICY\n\treturn nla_total_size(sizeof(struct xfrm_userpolicy_type));\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef CONFIG_XFRM_SUB_POLICY\nstatic int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\tstruct xfrm_userpolicy_type upt = {\n\t\t.type = type,\n\t};\n\n\treturn nla_put(skb, XFRMA_POLICY_TYPE, sizeof(upt), &upt);\n}\n\n#else\nstatic inline int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\treturn 0;\n}\n#endif\n\nstatic int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct xfrm_userpolicy_info *p;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWPOLICY, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_policy_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_policy *xp,\n\t\t\t\t\t  int dir, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_policy(xp, dir, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic int xfrm_get_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_userpolicy_id *p;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\tstruct km_event c;\n\tint delete;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tp = nlmsg_data(nlh);\n\tdelete = nlh->nlmsg_type == XFRM_MSG_DELPOLICY;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, delete, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir, &p->sel,\n\t\t\t\t\t   ctx, delete, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (!delete) {\n\t\tstruct sk_buff *resp_skb;\n\n\t\tresp_skb = xfrm_policy_netlink(skb, xp, p->dir, nlh->nlmsg_seq);\n\t\tif (IS_ERR(resp_skb)) {\n\t\t\terr = PTR_ERR(resp_skb);\n\t\t} else {\n\t\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb,\n\t\t\t\t\t    NETLINK_CB(skb).portid);\n\t\t}\n\t} else {\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1, true);\n\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\tc.data.byid = p->index;\n\t\tc.event = nlh->nlmsg_type;\n\t\tc.seq = nlh->nlmsg_seq;\n\t\tc.portid = nlh->nlmsg_pid;\n\t\tkm_policy_notify(xp, p->dir, &c);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\tif (delete && err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int xfrm_flush_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tstruct xfrm_usersa_flush *p = nlmsg_data(nlh);\n\tint err;\n\n\terr = xfrm_state_flush(net, p->proto, true);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tc.data.proto = p->proto;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic inline size_t xfrm_aevent_msgsize(struct xfrm_state *x)\n{\n\tsize_t replay_size = x->replay_esn ?\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn) :\n\t\t\t      sizeof(struct xfrm_replay_state);\n\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_aevent_id))\n\t       + nla_total_size(replay_size)\n\t       + nla_total_size_64bit(sizeof(struct xfrm_lifetime_cur))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(4) /* XFRM_AE_RTHR */\n\t       + nla_total_size(4); /* XFRM_AE_ETHR */\n}\n\nstatic int build_aevent(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_aevent_id *id;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_NEWAE, sizeof(*id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tid = nlmsg_data(nlh);\n\tmemcpy(&id->sa_id.daddr, &x->id.daddr, sizeof(x->id.daddr));\n\tid->sa_id.spi = x->id.spi;\n\tid->sa_id.family = x->props.family;\n\tid->sa_id.proto = x->id.proto;\n\tmemcpy(&id->saddr, &x->props.saddr, sizeof(x->props.saddr));\n\tid->reqid = x->props.reqid;\n\tid->flags = c->data.aevent;\n\n\tif (x->replay_esn) {\n\t\terr = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\t} else {\n\t\terr = nla_put(skb, XFRMA_REPLAY_VAL, sizeof(x->replay),\n\t\t\t      &x->replay);\n\t}\n\tif (err)\n\t\tgoto out_cancel;\n\terr = nla_put_64bit(skb, XFRMA_LTIME_VAL, sizeof(x->curlft), &x->curlft,\n\t\t\t    XFRMA_PAD);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tif (id->flags & XFRM_AE_RTHR) {\n\t\terr = nla_put_u32(skb, XFRMA_REPLAY_THRESH, x->replay_maxdiff);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\tif (id->flags & XFRM_AE_ETHR) {\n\t\terr = nla_put_u32(skb, XFRMA_ETIMER_THRESH,\n\t\t\t\t  x->replay_maxage * 10 / HZ);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_get_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *r_skb;\n\tint err;\n\tstruct km_event c;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct xfrm_usersa_id *id = &p->sa_id;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &id->daddr, id->spi, id->proto, id->family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tr_skb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (r_skb == NULL) {\n\t\txfrm_state_put(x);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * XXX: is this lock really needed - none of the other\n\t * gets lock (the concern is things getting updated\n\t * while we are still reading) - jhs\n\t*/\n\tspin_lock_bh(&x->lock);\n\tc.data.aevent = p->flags;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\n\tif (build_aevent(r_skb, x, &c) < 0)\n\t\tBUG();\n\terr = nlmsg_unicast(net->xfrm.nlsk, r_skb, NETLINK_CB(skb).portid);\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_new_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err = -EINVAL;\n\tu32 mark = 0;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (!lt && !rp && !re && !et && !rt)\n\t\treturn err;\n\n\t/* pedantic mode - thou shalt sayeth replaceth */\n\tif (!(nlh->nlmsg_flags&NLM_F_REPLACE))\n\t\treturn err;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->sa_id.daddr, p->sa_id.spi, p->sa_id.proto, p->sa_id.family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\n\terr = xfrm_replay_verify_len(x->replay_esn, re);\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock_bh(&x->lock);\n\txfrm_update_ae_params(x, attrs, 1);\n\tspin_unlock_bh(&x->lock);\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.data.aevent = XFRM_AE_CU;\n\tkm_state_notify(x, &c);\n\terr = 0;\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_flush_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = xfrm_policy_flush(net, type, true);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = type;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\treturn 0;\n}\n\nstatic int xfrm_add_pol_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_polexpire *up = nlmsg_data(nlh);\n\tstruct xfrm_userpolicy_info *p = &up->pol;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err = -ENOENT;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, 0, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir,\n\t\t\t\t\t   &p->sel, ctx, 0, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (unlikely(xp->walk.dead))\n\t\tgoto out;\n\n\terr = 0;\n\tif (up->hard) {\n\t\txfrm_policy_delete(xp, p->dir);\n\t\txfrm_audit_policy_delete(xp, 1, true);\n\t} else {\n\t\t// reset the timers here?\n\t\tWARN(1, \"Don't know what to do with soft policy expire\\n\");\n\t}\n\tkm_policy_expired(xp, p->dir, up->hard, nlh->nlmsg_pid);\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int xfrm_add_sa_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct xfrm_user_expire *ue = nlmsg_data(nlh);\n\tstruct xfrm_usersa_info *p = &ue->state;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->id.daddr, p->id.spi, p->id.proto, p->family);\n\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\treturn err;\n\n\tspin_lock_bh(&x->lock);\n\terr = -EINVAL;\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\tkm_state_expired(x, ue->hard, nlh->nlmsg_pid);\n\n\tif (ue->hard) {\n\t\t__xfrm_state_delete(x);\n\t\txfrm_audit_state_delete(x, 1, true);\n\t}\n\terr = 0;\nout:\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_add_acquire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_tmpl *ut;\n\tint i;\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\tstruct xfrm_mark mark;\n\n\tstruct xfrm_user_acquire *ua = nlmsg_data(nlh);\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto nomem;\n\n\txfrm_mark_get(attrs, &mark);\n\n\terr = verify_newpolicy_info(&ua->policy);\n\tif (err)\n\t\tgoto bad_policy;\n\n\t/*   build an XP */\n\txp = xfrm_policy_construct(net, &ua->policy, attrs, &err);\n\tif (!xp)\n\t\tgoto free_state;\n\n\tmemcpy(&x->id, &ua->id, sizeof(ua->id));\n\tmemcpy(&x->props.saddr, &ua->saddr, sizeof(ua->saddr));\n\tmemcpy(&x->sel, &ua->sel, sizeof(ua->sel));\n\txp->mark.m = x->mark.m = mark.m;\n\txp->mark.v = x->mark.v = mark.v;\n\tut = nla_data(rt);\n\t/* extract the templates and for each call km_key */\n\tfor (i = 0; i < xp->xfrm_nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\t\tmemcpy(&x->id, &t->id, sizeof(x->id));\n\t\tx->props.mode = t->mode;\n\t\tx->props.reqid = t->reqid;\n\t\tx->props.family = ut->family;\n\t\tt->aalgos = ua->aalgos;\n\t\tt->ealgos = ua->ealgos;\n\t\tt->calgos = ua->calgos;\n\t\terr = km_query(x, t, xp);\n\n\t}\n\n\tkfree(x);\n\tkfree(xp);\n\n\treturn 0;\n\nbad_policy:\n\tWARN(1, \"BAD policy passed\\n\");\nfree_state:\n\tkfree(x);\nnomem:\n\treturn err;\n}\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_from_user_migrate(struct xfrm_migrate *ma,\n\t\t\t\t  struct xfrm_kmaddress *k,\n\t\t\t\t  struct nlattr **attrs, int *num)\n{\n\tstruct nlattr *rt = attrs[XFRMA_MIGRATE];\n\tstruct xfrm_user_migrate *um;\n\tint i, num_migrate;\n\n\tif (k != NULL) {\n\t\tstruct xfrm_user_kmaddress *uk;\n\n\t\tuk = nla_data(attrs[XFRMA_KMADDRESS]);\n\t\tmemcpy(&k->local, &uk->local, sizeof(k->local));\n\t\tmemcpy(&k->remote, &uk->remote, sizeof(k->remote));\n\t\tk->family = uk->family;\n\t\tk->reserved = uk->reserved;\n\t}\n\n\tum = nla_data(rt);\n\tnum_migrate = nla_len(rt) / sizeof(*um);\n\n\tif (num_migrate <= 0 || num_migrate > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_migrate; i++, um++, ma++) {\n\t\tmemcpy(&ma->old_daddr, &um->old_daddr, sizeof(ma->old_daddr));\n\t\tmemcpy(&ma->old_saddr, &um->old_saddr, sizeof(ma->old_saddr));\n\t\tmemcpy(&ma->new_daddr, &um->new_daddr, sizeof(ma->new_daddr));\n\t\tmemcpy(&ma->new_saddr, &um->new_saddr, sizeof(ma->new_saddr));\n\n\t\tma->proto = um->proto;\n\t\tma->mode = um->mode;\n\t\tma->reqid = um->reqid;\n\n\t\tma->old_family = um->old_family;\n\t\tma->new_family = um->new_family;\n\t}\n\n\t*num = i;\n\treturn 0;\n}\n\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\tstruct xfrm_userpolicy_id *pi = nlmsg_data(nlh);\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress km, *kmp;\n\tu8 type;\n\tint err;\n\tint n = 0;\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (attrs[XFRMA_MIGRATE] == NULL)\n\t\treturn -EINVAL;\n\n\tkmp = attrs[XFRMA_KMADDRESS] ? &km : NULL;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = copy_from_user_migrate((struct xfrm_migrate *)m, kmp, attrs, &n);\n\tif (err)\n\t\treturn err;\n\n\tif (!n)\n\t\treturn 0;\n\n\txfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp, net);\n\n\treturn 0;\n}\n#else\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_to_user_migrate(const struct xfrm_migrate *m, struct sk_buff *skb)\n{\n\tstruct xfrm_user_migrate um;\n\n\tmemset(&um, 0, sizeof(um));\n\tum.proto = m->proto;\n\tum.mode = m->mode;\n\tum.reqid = m->reqid;\n\tum.old_family = m->old_family;\n\tmemcpy(&um.old_daddr, &m->old_daddr, sizeof(um.old_daddr));\n\tmemcpy(&um.old_saddr, &m->old_saddr, sizeof(um.old_saddr));\n\tum.new_family = m->new_family;\n\tmemcpy(&um.new_daddr, &m->new_daddr, sizeof(um.new_daddr));\n\tmemcpy(&um.new_saddr, &m->new_saddr, sizeof(um.new_saddr));\n\n\treturn nla_put(skb, XFRMA_MIGRATE, sizeof(um), &um);\n}\n\nstatic int copy_to_user_kmaddress(const struct xfrm_kmaddress *k, struct sk_buff *skb)\n{\n\tstruct xfrm_user_kmaddress uk;\n\n\tmemset(&uk, 0, sizeof(uk));\n\tuk.family = k->family;\n\tuk.reserved = k->reserved;\n\tmemcpy(&uk.local, &k->local, sizeof(uk.local));\n\tmemcpy(&uk.remote, &k->remote, sizeof(uk.remote));\n\n\treturn nla_put(skb, XFRMA_KMADDRESS, sizeof(uk), &uk);\n}\n\nstatic inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))\n\t      + (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)\n\t      + nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)\n\t      + userpolicy_type_attrsize();\n}\n\nstatic int build_migrate(struct sk_buff *skb, const struct xfrm_migrate *m,\n\t\t\t int num_migrate, const struct xfrm_kmaddress *k,\n\t\t\t const struct xfrm_selector *sel, u8 dir, u8 type)\n{\n\tconst struct xfrm_migrate *mp;\n\tstruct xfrm_userpolicy_id *pol_id;\n\tstruct nlmsghdr *nlh;\n\tint i, err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MIGRATE, sizeof(*pol_id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tpol_id = nlmsg_data(nlh);\n\t/* copy data from selector, dir, and type to the pol_id */\n\tmemset(pol_id, 0, sizeof(*pol_id));\n\tmemcpy(&pol_id->sel, sel, sizeof(pol_id->sel));\n\tpol_id->dir = dir;\n\n\tif (k != NULL) {\n\t\terr = copy_to_user_kmaddress(k, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = copy_to_user_policy_type(type, skb);\n\tif (err)\n\t\tgoto out_cancel;\n\tfor (i = 0, mp = m ; i < num_migrate; i++, mp++) {\n\t\terr = copy_to_user_migrate(mp, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\tstruct net *net = &init_net;\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_migrate_msgsize(num_migrate, !!k), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t/* build migrate */\n\tif (build_migrate(skb, m, num_migrate, k, sel, dir, type) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_MIGRATE);\n}\n#else\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#define XMSGSIZE(type) sizeof(struct type)\n\nstatic const int xfrm_msg_min[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userspi_info),\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_acquire),\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_expire),\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_polexpire),\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_flush),\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = 0,\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_REPORT      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_report),\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n};\n\n#undef XMSGSIZE\n\nstatic const struct nla_policy xfrma_policy[XFRMA_MAX+1] = {\n\t[XFRMA_SA]\t\t= { .len = sizeof(struct xfrm_usersa_info)},\n\t[XFRMA_POLICY]\t\t= { .len = sizeof(struct xfrm_userpolicy_info)},\n\t[XFRMA_LASTUSED]\t= { .type = NLA_U64},\n\t[XFRMA_ALG_AUTH_TRUNC]\t= { .len = sizeof(struct xfrm_algo_auth)},\n\t[XFRMA_ALG_AEAD]\t= { .len = sizeof(struct xfrm_algo_aead) },\n\t[XFRMA_ALG_AUTH]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_CRYPT]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_COMP]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ENCAP]\t\t= { .len = sizeof(struct xfrm_encap_tmpl) },\n\t[XFRMA_TMPL]\t\t= { .len = sizeof(struct xfrm_user_tmpl) },\n\t[XFRMA_SEC_CTX]\t\t= { .len = sizeof(struct xfrm_sec_ctx) },\n\t[XFRMA_LTIME_VAL]\t= { .len = sizeof(struct xfrm_lifetime_cur) },\n\t[XFRMA_REPLAY_VAL]\t= { .len = sizeof(struct xfrm_replay_state) },\n\t[XFRMA_REPLAY_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_ETIMER_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_SRCADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_COADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_POLICY_TYPE]\t= { .len = sizeof(struct xfrm_userpolicy_type)},\n\t[XFRMA_MIGRATE]\t\t= { .len = sizeof(struct xfrm_user_migrate) },\n\t[XFRMA_KMADDRESS]\t= { .len = sizeof(struct xfrm_user_kmaddress) },\n\t[XFRMA_MARK]\t\t= { .len = sizeof(struct xfrm_mark) },\n\t[XFRMA_TFCPAD]\t\t= { .type = NLA_U32 },\n\t[XFRMA_REPLAY_ESN_VAL]\t= { .len = sizeof(struct xfrm_replay_state_esn) },\n\t[XFRMA_SA_EXTRA_FLAGS]\t= { .type = NLA_U32 },\n\t[XFRMA_PROTO]\t\t= { .type = NLA_U8 },\n\t[XFRMA_ADDRESS_FILTER]\t= { .len = sizeof(struct xfrm_address_filter) },\n};\n\nstatic const struct nla_policy xfrma_spd_policy[XFRMA_SPD_MAX+1] = {\n\t[XFRMA_SPD_IPV4_HTHRESH] = { .len = sizeof(struct xfrmu_spdhthresh) },\n\t[XFRMA_SPD_IPV6_HTHRESH] = { .len = sizeof(struct xfrmu_spdhthresh) },\n};\n\nstatic const struct xfrm_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n\tconst struct nla_policy *nla_pol;\n\tint nla_max;\n} xfrm_dispatch[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = { .doit = xfrm_del_sa        },\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = { .doit = xfrm_get_sa,\n\t\t\t\t\t\t   .dump = xfrm_dump_sa,\n\t\t\t\t\t\t   .done = xfrm_dump_sa_done  },\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,\n\t\t\t\t\t\t   .dump = xfrm_dump_policy,\n\t\t\t\t\t\t   .done = xfrm_dump_policy_done },\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = { .doit = xfrm_add_acquire   },\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = { .doit = xfrm_add_sa_expire },\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = { .doit = xfrm_add_pol_expire},\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = { .doit = xfrm_flush_sa      },\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_flush_policy  },\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = { .doit = xfrm_new_ae  },\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = { .doit = xfrm_get_ae  },\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = { .doit = xfrm_do_migrate    },\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_sadinfo   },\n\t[XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_set_spdinfo,\n\t\t\t\t\t\t   .nla_pol = xfrma_spd_policy,\n\t\t\t\t\t\t   .nla_max = XFRMA_SPD_MAX },\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_spdinfo   },\n};\n\nstatic int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -ENOTSUPP;\n#endif\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void xfrm_netlink_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\n\tmutex_lock(&net->xfrm.xfrm_cfg_mutex);\n\tnetlink_rcv_skb(skb, &xfrm_user_rcv_msg);\n\tmutex_unlock(&net->xfrm.xfrm_cfg_mutex);\n}\n\nstatic inline size_t xfrm_expire_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_expire))\n\t       + nla_total_size(sizeof(struct xfrm_mark));\n}\n\nstatic int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_user_expire *ue;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tue = nlmsg_data(nlh);\n\tcopy_to_user_state(x, &ue->state);\n\tue->hard = (c->data.hard != 0) ? 1 : 0;\n\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\treturn err;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_exp_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_expire_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_expire(skb, x, c) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);\n}\n\nstatic int xfrm_aevent_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_aevent(skb, x, c) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_AEVENTS);\n}\n\nstatic int xfrm_notify_sa_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct xfrm_usersa_flush *p;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = NLMSG_ALIGN(sizeof(struct xfrm_usersa_flush));\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHSA, sizeof(*p), 0);\n\tif (nlh == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tp = nlmsg_data(nlh);\n\tp->proto = c->data.proto;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_SA);\n}\n\nstatic inline size_t xfrm_sa_len(struct xfrm_state *x)\n{\n\tsize_t l = 0;\n\tif (x->aead)\n\t\tl += nla_total_size(aead_len(x->aead));\n\tif (x->aalg) {\n\t\tl += nla_total_size(sizeof(struct xfrm_algo) +\n\t\t\t\t    (x->aalg->alg_key_len + 7) / 8);\n\t\tl += nla_total_size(xfrm_alg_auth_len(x->aalg));\n\t}\n\tif (x->ealg)\n\t\tl += nla_total_size(xfrm_alg_len(x->ealg));\n\tif (x->calg)\n\t\tl += nla_total_size(sizeof(*x->calg));\n\tif (x->encap)\n\t\tl += nla_total_size(sizeof(*x->encap));\n\tif (x->tfcpad)\n\t\tl += nla_total_size(sizeof(x->tfcpad));\n\tif (x->replay_esn)\n\t\tl += nla_total_size(xfrm_replay_state_esn_len(x->replay_esn));\n\telse\n\t\tl += nla_total_size(sizeof(struct xfrm_replay_state));\n\tif (x->security)\n\t\tl += nla_total_size(sizeof(struct xfrm_user_sec_ctx) +\n\t\t\t\t    x->security->ctx_len);\n\tif (x->coaddr)\n\t\tl += nla_total_size(sizeof(*x->coaddr));\n\tif (x->props.extra_flags)\n\t\tl += nla_total_size(sizeof(x->props.extra_flags));\n\n\t/* Must count x->lastused as it may become non-zero behind our back. */\n\tl += nla_total_size_64bit(sizeof(u64));\n\n\treturn l;\n}\n\nstatic int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_usersa_info *p;\n\tstruct xfrm_usersa_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = xfrm_sa_len(x);\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\t}\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemcpy(&id->daddr, &x->id.daddr, sizeof(id->daddr));\n\t\tid->spi = x->id.spi;\n\t\tid->family = x->props.family;\n\t\tid->proto = x->id.proto;\n\n\t\tattr = nla_reserve(skb, XFRMA_SA, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_SA);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn xfrm_exp_state_notify(x, c);\n\tcase XFRM_MSG_NEWAE:\n\t\treturn xfrm_aevent_state_notify(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_UPDSA:\n\tcase XFRM_MSG_NEWSA:\n\t\treturn xfrm_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn xfrm_notify_sa_flush(c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown SA event %d\\n\",\n\t\t       c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_acquire_msgsize(struct xfrm_state *x,\n\t\t\t\t\t  struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_acquire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(xfrm_user_sec_ctx_size(x->security))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_acquire(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t struct xfrm_tmpl *xt, struct xfrm_policy *xp)\n{\n\t__u32 seq = xfrm_get_acqseq();\n\tstruct xfrm_user_acquire *ua;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_ACQUIRE, sizeof(*ua), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tua = nlmsg_data(nlh);\n\tmemcpy(&ua->id, &x->id, sizeof(ua->id));\n\tmemcpy(&ua->saddr, &x->props.saddr, sizeof(ua->saddr));\n\tmemcpy(&ua->sel, &x->sel, sizeof(ua->sel));\n\tcopy_to_user_policy(xp, &ua->policy, XFRM_POLICY_OUT);\n\tua->aalgos = xt->aalgos;\n\tua->ealgos = xt->ealgos;\n\tua->calgos = xt->calgos;\n\tua->seq = x->km.seq = seq;\n\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_state_sec_ctx(x, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *xt,\n\t\t\t     struct xfrm_policy *xp)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_acquire_msgsize(x, xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_acquire(skb, x, xt, xp) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_ACQUIRE);\n}\n\n/* User gives us xfrm_user_policy_info followed by an array of 0\n * or more templates.\n */\nstatic struct xfrm_policy *xfrm_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t       u8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_userpolicy_info *p = (struct xfrm_userpolicy_info *)data;\n\tstruct xfrm_user_tmpl *ut = (struct xfrm_user_tmpl *) (p + 1);\n\tstruct xfrm_policy *xp;\n\tint nr;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(*p) ||\n\t    verify_newpolicy_info(p))\n\t\treturn NULL;\n\n\tnr = ((len - sizeof(*p)) / sizeof(*ut));\n\tif (validate_tmpl(nr, ut, p->sel.family))\n\t\treturn NULL;\n\n\tif (p->dir > XFRM_POLICY_OUT)\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\txp->type = XFRM_POLICY_TYPE_MAIN;\n\tcopy_templates(xp, ut, nr);\n\n\t*dir = p->dir;\n\n\treturn xp;\n}\n\nstatic inline size_t xfrm_polexpire_msgsize(struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_polexpire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(xfrm_user_sec_ctx_size(xp->security))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_polexpire(struct sk_buff *skb, struct xfrm_policy *xp,\n\t\t\t   int dir, const struct km_event *c)\n{\n\tstruct xfrm_user_polexpire *upe;\n\tint hard = c->data.hard;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_POLEXPIRE, sizeof(*upe), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tupe = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, &upe->pol, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tupe->hard = !!hard;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_polexpire(skb, xp, dir, c) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);\n}\n\nstatic int xfrm_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tint len = nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr);\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_userpolicy_info *p;\n\tstruct xfrm_userpolicy_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t}\n\tlen += userpolicy_type_attrsize();\n\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemset(id, 0, sizeof(*id));\n\t\tid->dir = dir;\n\t\tif (c->data.byid)\n\t\t\tid->index = xp->index;\n\t\telse\n\t\t\tmemcpy(&id->sel, &xp->selector, sizeof(id->sel));\n\n\t\tattr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_POLICY);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_notify_policy_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(userpolicy_type_attrsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHPOLICY, 0, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\terr = copy_to_user_policy_type(c->data.type, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_POLICY);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn xfrm_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\treturn xfrm_notify_policy_flush(c);\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn xfrm_exp_policy_notify(xp, dir, c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown Policy event %d\\n\",\n\t\t       c->event);\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_report_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_report));\n}\n\nstatic int build_report(struct sk_buff *skb, u8 proto,\n\t\t\tstruct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct xfrm_user_report *ur;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_REPORT, sizeof(*ur), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tur = nlmsg_data(nlh);\n\tur->proto = proto;\n\tmemcpy(&ur->sel, sel, sizeof(ur->sel));\n\n\tif (addr) {\n\t\tint err = nla_put(skb, XFRMA_COADDR, sizeof(*addr), addr);\n\t\tif (err) {\n\t\t\tnlmsg_cancel(skb, nlh);\n\t\t\treturn err;\n\t\t}\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_send_report(struct net *net, u8 proto,\n\t\t\t    struct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_report_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_report(skb, proto, sel, addr) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_REPORT);\n}\n\nstatic inline size_t xfrm_mapping_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_mapping));\n}\n\nstatic int build_mapping(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t xfrm_address_t *new_saddr, __be16 new_sport)\n{\n\tstruct xfrm_user_mapping *um;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MAPPING, sizeof(*um), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tum = nlmsg_data(nlh);\n\n\tmemcpy(&um->id.daddr, &x->id.daddr, sizeof(um->id.daddr));\n\tum->id.spi = x->id.spi;\n\tum->id.family = x->props.family;\n\tum->id.proto = x->id.proto;\n\tmemcpy(&um->new_saddr, new_saddr, sizeof(um->new_saddr));\n\tmemcpy(&um->old_saddr, &x->props.saddr, sizeof(um->old_saddr));\n\tum->new_sport = new_sport;\n\tum->old_sport = x->encap->encap_sport;\n\tum->reqid = x->props.reqid;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_send_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,\n\t\t\t     __be16 sport)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tif (x->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tskb = nlmsg_new(xfrm_mapping_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_mapping(skb, x, ipaddr, sport) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_MAPPING);\n}\n\nstatic bool xfrm_is_alive(const struct km_event *c)\n{\n\treturn (bool)xfrm_acquire_is_on(c->net);\n}\n\nstatic struct xfrm_mgr netlink_mgr = {\n\t.id\t\t= \"netlink\",\n\t.notify\t\t= xfrm_send_state_notify,\n\t.acquire\t= xfrm_send_acquire,\n\t.compile_policy\t= xfrm_compile_policy,\n\t.notify_policy\t= xfrm_send_policy_notify,\n\t.report\t\t= xfrm_send_report,\n\t.migrate\t= xfrm_send_migrate,\n\t.new_mapping\t= xfrm_send_mapping,\n\t.is_alive\t= xfrm_is_alive,\n};\n\nstatic int __net_init xfrm_user_net_init(struct net *net)\n{\n\tstruct sock *nlsk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= XFRMNLGRP_MAX,\n\t\t.input\t= xfrm_netlink_rcv,\n\t};\n\n\tnlsk = netlink_kernel_create(net, NETLINK_XFRM, &cfg);\n\tif (nlsk == NULL)\n\t\treturn -ENOMEM;\n\tnet->xfrm.nlsk_stash = nlsk; /* Don't set to NULL */\n\trcu_assign_pointer(net->xfrm.nlsk, nlsk);\n\treturn 0;\n}\n\nstatic void __net_exit xfrm_user_net_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->xfrm.nlsk, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->xfrm.nlsk_stash);\n}\n\nstatic struct pernet_operations xfrm_user_net_ops = {\n\t.init\t    = xfrm_user_net_init,\n\t.exit_batch = xfrm_user_net_exit,\n};\n\nstatic int __init xfrm_user_init(void)\n{\n\tint rv;\n\n\tprintk(KERN_INFO \"Initializing XFRM netlink socket\\n\");\n\n\trv = register_pernet_subsys(&xfrm_user_net_ops);\n\tif (rv < 0)\n\t\treturn rv;\n\trv = xfrm_register_km(&netlink_mgr);\n\tif (rv < 0)\n\t\tunregister_pernet_subsys(&xfrm_user_net_ops);\n\treturn rv;\n}\n\nstatic void __exit xfrm_user_exit(void)\n{\n\txfrm_unregister_km(&netlink_mgr);\n\tunregister_pernet_subsys(&xfrm_user_net_ops);\n}\n\nmodule_init(xfrm_user_init);\nmodule_exit(xfrm_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_XFRM);\n\n"], "fixing_code": ["/* xfrm_user.c: User interface to configure xfrm engine.\n *\n * Copyright (C) 2002 David S. Miller (davem@redhat.com)\n *\n * Changes:\n *\tMitsuru KANDA @USAGI\n * \tKazunori MIYAZAWA @USAGI\n * \tKunihiro Ishiguro <kunihiro@ipinfusion.com>\n * \t\tIPv6 support\n *\n */\n\n#include <linux/crypto.h>\n#include <linux/module.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n#include <linux/slab.h>\n#include <linux/socket.h>\n#include <linux/string.h>\n#include <linux/net.h>\n#include <linux/skbuff.h>\n#include <linux/pfkeyv2.h>\n#include <linux/ipsec.h>\n#include <linux/init.h>\n#include <linux/security.h>\n#include <net/sock.h>\n#include <net/xfrm.h>\n#include <net/netlink.h>\n#include <net/ah.h>\n#include <asm/uaccess.h>\n#if IS_ENABLED(CONFIG_IPV6)\n#include <linux/in6.h>\n#endif\n#include <asm/unaligned.h>\n\nstatic int verify_one_alg(struct nlattr **attrs, enum xfrm_attr_type_t type)\n{\n\tstruct nlattr *rt = attrs[type];\n\tstruct xfrm_algo *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_len(algp))\n\t\treturn -EINVAL;\n\n\tswitch (type) {\n\tcase XFRMA_ALG_AUTH:\n\tcase XFRMA_ALG_CRYPT:\n\tcase XFRMA_ALG_COMP:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_auth_trunc(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AUTH_TRUNC];\n\tstruct xfrm_algo_auth *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < xfrm_alg_auth_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic int verify_aead(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_ALG_AEAD];\n\tstruct xfrm_algo_aead *algp;\n\n\tif (!rt)\n\t\treturn 0;\n\n\talgp = nla_data(rt);\n\tif (nla_len(rt) < aead_len(algp))\n\t\treturn -EINVAL;\n\n\talgp->alg_name[CRYPTO_MAX_ALG_NAME - 1] = '\\0';\n\treturn 0;\n}\n\nstatic void verify_one_addr(struct nlattr **attrs, enum xfrm_attr_type_t type,\n\t\t\t   xfrm_address_t **addrp)\n{\n\tstruct nlattr *rt = attrs[type];\n\n\tif (rt && addrp)\n\t\t*addrp = nla_data(rt);\n}\n\nstatic inline int verify_sec_ctx_len(struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\tif (uctx->len != (sizeof(struct xfrm_user_sec_ctx) + uctx->ctx_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic inline int verify_replay(struct xfrm_usersa_info *p,\n\t\t\t\tstruct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct xfrm_replay_state_esn *rs;\n\n\tif (p->flags & XFRM_STATE_ESN) {\n\t\tif (!rt)\n\t\t\treturn -EINVAL;\n\n\t\trs = nla_data(rt);\n\n\t\tif (rs->bmp_len > XFRMA_REPLAY_ESN_MAX / sizeof(rs->bmp[0]) / 8)\n\t\t\treturn -EINVAL;\n\n\t\tif (nla_len(rt) < xfrm_replay_state_esn_len(rs) &&\n\t\t    nla_len(rt) != sizeof(*rs))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!rt)\n\t\treturn 0;\n\n\t/* As only ESP and AH support ESN feature. */\n\tif ((p->id.proto != IPPROTO_ESP) && (p->id.proto != IPPROTO_AH))\n\t\treturn -EINVAL;\n\n\tif (p->replay_window != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int verify_newsa_info(struct xfrm_usersa_info *p,\n\t\t\t     struct nlattr **attrs)\n{\n\tint err;\n\n\terr = -EINVAL;\n\tswitch (p->family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\terr = -EAFNOSUPPORT;\n\t\tgoto out;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = -EINVAL;\n\tswitch (p->id.proto) {\n\tcase IPPROTO_AH:\n\t\tif ((!attrs[XFRMA_ALG_AUTH]\t&&\n\t\t     !attrs[XFRMA_ALG_AUTH_TRUNC]) ||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_TFCPAD])\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_ESP:\n\t\tif (attrs[XFRMA_ALG_COMP])\n\t\t\tgoto out;\n\t\tif (!attrs[XFRMA_ALG_AUTH] &&\n\t\t    !attrs[XFRMA_ALG_AUTH_TRUNC] &&\n\t\t    !attrs[XFRMA_ALG_CRYPT] &&\n\t\t    !attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif ((attrs[XFRMA_ALG_AUTH] ||\n\t\t     attrs[XFRMA_ALG_AUTH_TRUNC] ||\n\t\t     attrs[XFRMA_ALG_CRYPT]) &&\n\t\t    attrs[XFRMA_ALG_AEAD])\n\t\t\tgoto out;\n\t\tif (attrs[XFRMA_TFCPAD] &&\n\t\t    p->mode != XFRM_MODE_TUNNEL)\n\t\t\tgoto out;\n\t\tbreak;\n\n\tcase IPPROTO_COMP:\n\t\tif (!attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    (ntohl(p->id.spi) >= 0x10000))\n\t\t\tgoto out;\n\t\tbreak;\n\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase IPPROTO_DSTOPTS:\n\tcase IPPROTO_ROUTING:\n\t\tif (attrs[XFRMA_ALG_COMP]\t||\n\t\t    attrs[XFRMA_ALG_AUTH]\t||\n\t\t    attrs[XFRMA_ALG_AUTH_TRUNC]\t||\n\t\t    attrs[XFRMA_ALG_AEAD]\t||\n\t\t    attrs[XFRMA_ALG_CRYPT]\t||\n\t\t    attrs[XFRMA_ENCAP]\t\t||\n\t\t    attrs[XFRMA_SEC_CTX]\t||\n\t\t    attrs[XFRMA_TFCPAD]\t\t||\n\t\t    !attrs[XFRMA_COADDR])\n\t\t\tgoto out;\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\tif ((err = verify_aead(attrs)))\n\t\tgoto out;\n\tif ((err = verify_auth_trunc(attrs)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_AUTH)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_CRYPT)))\n\t\tgoto out;\n\tif ((err = verify_one_alg(attrs, XFRMA_ALG_COMP)))\n\t\tgoto out;\n\tif ((err = verify_sec_ctx_len(attrs)))\n\t\tgoto out;\n\tif ((err = verify_replay(p, attrs)))\n\t\tgoto out;\n\n\terr = -EINVAL;\n\tswitch (p->mode) {\n\tcase XFRM_MODE_TRANSPORT:\n\tcase XFRM_MODE_TUNNEL:\n\tcase XFRM_MODE_ROUTEOPTIMIZATION:\n\tcase XFRM_MODE_BEET:\n\t\tbreak;\n\n\tdefault:\n\t\tgoto out;\n\t}\n\n\terr = 0;\n\nout:\n\treturn err;\n}\n\nstatic int attach_one_algo(struct xfrm_algo **algpp, u8 *props,\n\t\t\t   struct xfrm_algo_desc *(*get_byname)(const char *, int),\n\t\t\t   struct nlattr *rta)\n{\n\tstruct xfrm_algo *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_crypt(struct xfrm_state *x, struct nlattr *rta)\n{\n\tstruct xfrm_algo *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_ealg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tx->props.ealgo = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tx->ealg = p;\n\tx->geniv = algo->uinfo.encr.geniv;\n\treturn 0;\n}\n\nstatic int attach_auth(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_algo *ualg;\n\tstruct xfrm_algo_auth *p;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmalloc(sizeof(*p) + (ualg->alg_key_len + 7) / 8, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tp->alg_key_len = ualg->alg_key_len;\n\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\tmemcpy(p->alg_key, ualg->alg_key, (ualg->alg_key_len + 7) / 8);\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_auth_trunc(struct xfrm_algo_auth **algpp, u8 *props,\n\t\t\t     struct nlattr *rta)\n{\n\tstruct xfrm_algo_auth *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aalg_get_byname(ualg->alg_name, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tif (ualg->alg_trunc_len > algo->uinfo.auth.icv_fullbits)\n\t\treturn -EINVAL;\n\t*props = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, xfrm_alg_auth_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tif (!p->alg_trunc_len)\n\t\tp->alg_trunc_len = algo->uinfo.auth.icv_truncbits;\n\n\t*algpp = p;\n\treturn 0;\n}\n\nstatic int attach_aead(struct xfrm_state *x, struct nlattr *rta)\n{\n\tstruct xfrm_algo_aead *p, *ualg;\n\tstruct xfrm_algo_desc *algo;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tualg = nla_data(rta);\n\n\talgo = xfrm_aead_get_byname(ualg->alg_name, ualg->alg_icv_len, 1);\n\tif (!algo)\n\t\treturn -ENOSYS;\n\tx->props.ealgo = algo->desc.sadb_alg_id;\n\n\tp = kmemdup(ualg, aead_len(ualg), GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tstrcpy(p->alg_name, algo->name);\n\tx->aead = p;\n\tx->geniv = algo->uinfo.aead.geniv;\n\treturn 0;\n}\n\nstatic inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n\t\t\t\t\t struct nlattr *rp)\n{\n\tstruct xfrm_replay_state_esn *up;\n\tint ulen;\n\n\tif (!replay_esn || !rp)\n\t\treturn 0;\n\n\tup = nla_data(rp);\n\tulen = xfrm_replay_state_esn_len(up);\n\n\tif (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int xfrm_alloc_replay_state_esn(struct xfrm_replay_state_esn **replay_esn,\n\t\t\t\t       struct xfrm_replay_state_esn **preplay_esn,\n\t\t\t\t       struct nlattr *rta)\n{\n\tstruct xfrm_replay_state_esn *p, *pp, *up;\n\tint klen, ulen;\n\n\tif (!rta)\n\t\treturn 0;\n\n\tup = nla_data(rta);\n\tklen = xfrm_replay_state_esn_len(up);\n\tulen = nla_len(rta) >= klen ? klen : sizeof(*up);\n\n\tp = kzalloc(klen, GFP_KERNEL);\n\tif (!p)\n\t\treturn -ENOMEM;\n\n\tpp = kzalloc(klen, GFP_KERNEL);\n\tif (!pp) {\n\t\tkfree(p);\n\t\treturn -ENOMEM;\n\t}\n\n\tmemcpy(p, up, ulen);\n\tmemcpy(pp, up, ulen);\n\n\t*replay_esn = p;\n\t*preplay_esn = pp;\n\n\treturn 0;\n}\n\nstatic inline int xfrm_user_sec_ctx_size(struct xfrm_sec_ctx *xfrm_ctx)\n{\n\tint len = 0;\n\n\tif (xfrm_ctx) {\n\t\tlen += sizeof(struct xfrm_user_sec_ctx);\n\t\tlen += xfrm_ctx->ctx_len;\n\t}\n\treturn len;\n}\n\nstatic void copy_from_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemcpy(&x->id, &p->id, sizeof(x->id));\n\tmemcpy(&x->sel, &p->sel, sizeof(x->sel));\n\tmemcpy(&x->lft, &p->lft, sizeof(x->lft));\n\tx->props.mode = p->mode;\n\tx->props.replay_window = min_t(unsigned int, p->replay_window,\n\t\t\t\t\tsizeof(x->replay.bitmap) * 8);\n\tx->props.reqid = p->reqid;\n\tx->props.family = p->family;\n\tmemcpy(&x->props.saddr, &p->saddr, sizeof(x->props.saddr));\n\tx->props.flags = p->flags;\n\n\tif (!x->sel.family && !(p->flags & XFRM_STATE_AF_UNSPEC))\n\t\tx->sel.family = p->family;\n}\n\n/*\n * someday when pfkey also has support, we could have the code\n * somehow made shareable and move it to xfrm_state.c - JHS\n *\n*/\nstatic void xfrm_update_ae_params(struct xfrm_state *x, struct nlattr **attrs,\n\t\t\t\t  int update_esn)\n{\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = update_esn ? attrs[XFRMA_REPLAY_ESN_VAL] : NULL;\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (re) {\n\t\tstruct xfrm_replay_state_esn *replay_esn;\n\t\treplay_esn = nla_data(re);\n\t\tmemcpy(x->replay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t\tmemcpy(x->preplay_esn, replay_esn,\n\t\t       xfrm_replay_state_esn_len(replay_esn));\n\t}\n\n\tif (rp) {\n\t\tstruct xfrm_replay_state *replay;\n\t\treplay = nla_data(rp);\n\t\tmemcpy(&x->replay, replay, sizeof(*replay));\n\t\tmemcpy(&x->preplay, replay, sizeof(*replay));\n\t}\n\n\tif (lt) {\n\t\tstruct xfrm_lifetime_cur *ltime;\n\t\tltime = nla_data(lt);\n\t\tx->curlft.bytes = ltime->bytes;\n\t\tx->curlft.packets = ltime->packets;\n\t\tx->curlft.add_time = ltime->add_time;\n\t\tx->curlft.use_time = ltime->use_time;\n\t}\n\n\tif (et)\n\t\tx->replay_maxage = nla_get_u32(et);\n\n\tif (rt)\n\t\tx->replay_maxdiff = nla_get_u32(rt);\n}\n\nstatic struct xfrm_state *xfrm_state_construct(struct net *net,\n\t\t\t\t\t       struct xfrm_usersa_info *p,\n\t\t\t\t\t       struct nlattr **attrs,\n\t\t\t\t\t       int *errp)\n{\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto error_no_put;\n\n\tcopy_from_user_state(x, p);\n\n\tif (attrs[XFRMA_SA_EXTRA_FLAGS])\n\t\tx->props.extra_flags = nla_get_u32(attrs[XFRMA_SA_EXTRA_FLAGS]);\n\n\tif ((err = attach_aead(x, attrs[XFRMA_ALG_AEAD])))\n\t\tgoto error;\n\tif ((err = attach_auth_trunc(&x->aalg, &x->props.aalgo,\n\t\t\t\t     attrs[XFRMA_ALG_AUTH_TRUNC])))\n\t\tgoto error;\n\tif (!x->props.aalgo) {\n\t\tif ((err = attach_auth(&x->aalg, &x->props.aalgo,\n\t\t\t\t       attrs[XFRMA_ALG_AUTH])))\n\t\t\tgoto error;\n\t}\n\tif ((err = attach_crypt(x, attrs[XFRMA_ALG_CRYPT])))\n\t\tgoto error;\n\tif ((err = attach_one_algo(&x->calg, &x->props.calgo,\n\t\t\t\t   xfrm_calg_get_byname,\n\t\t\t\t   attrs[XFRMA_ALG_COMP])))\n\t\tgoto error;\n\n\tif (attrs[XFRMA_ENCAP]) {\n\t\tx->encap = kmemdup(nla_data(attrs[XFRMA_ENCAP]),\n\t\t\t\t   sizeof(*x->encap), GFP_KERNEL);\n\t\tif (x->encap == NULL)\n\t\t\tgoto error;\n\t}\n\n\tif (attrs[XFRMA_TFCPAD])\n\t\tx->tfcpad = nla_get_u32(attrs[XFRMA_TFCPAD]);\n\n\tif (attrs[XFRMA_COADDR]) {\n\t\tx->coaddr = kmemdup(nla_data(attrs[XFRMA_COADDR]),\n\t\t\t\t    sizeof(*x->coaddr), GFP_KERNEL);\n\t\tif (x->coaddr == NULL)\n\t\t\tgoto error;\n\t}\n\n\txfrm_mark_get(attrs, &x->mark);\n\n\terr = __xfrm_init_state(x, false);\n\tif (err)\n\t\tgoto error;\n\n\tif (attrs[XFRMA_SEC_CTX] &&\n\t    security_xfrm_state_alloc(x, nla_data(attrs[XFRMA_SEC_CTX])))\n\t\tgoto error;\n\n\tif ((err = xfrm_alloc_replay_state_esn(&x->replay_esn, &x->preplay_esn,\n\t\t\t\t\t       attrs[XFRMA_REPLAY_ESN_VAL])))\n\t\tgoto error;\n\n\tx->km.seq = p->seq;\n\tx->replay_maxdiff = net->xfrm.sysctl_aevent_rseqth;\n\t/* sysctl_xfrm_aevent_etime is in 100ms units */\n\tx->replay_maxage = (net->xfrm.sysctl_aevent_etime*HZ)/XFRM_AE_ETH_M;\n\n\tif ((err = xfrm_init_replay(x)))\n\t\tgoto error;\n\n\t/* override default values from above */\n\txfrm_update_ae_params(x, attrs, 0);\n\n\treturn x;\n\nerror:\n\tx->km.state = XFRM_STATE_DEAD;\n\txfrm_state_put(x);\nerror_no_put:\n\t*errp = err;\n\treturn NULL;\n}\n\nstatic int xfrm_add_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_info *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct km_event c;\n\n\terr = verify_newsa_info(p, attrs);\n\tif (err)\n\t\treturn err;\n\n\tx = xfrm_state_construct(net, p, attrs, &err);\n\tif (!x)\n\t\treturn err;\n\n\txfrm_state_hold(x);\n\tif (nlh->nlmsg_type == XFRM_MSG_NEWSA)\n\t\terr = xfrm_state_add(x);\n\telse\n\t\terr = xfrm_state_update(x);\n\n\txfrm_audit_state_add(x, err ? 0 : 1, true);\n\n\tif (err < 0) {\n\t\tx->km.state = XFRM_STATE_DEAD;\n\t\t__xfrm_state_put(x);\n\t\tgoto out;\n\t}\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\n\tkm_state_notify(x, &c);\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic struct xfrm_state *xfrm_user_state_lookup(struct net *net,\n\t\t\t\t\t\t struct xfrm_usersa_id *p,\n\t\t\t\t\t\t struct nlattr **attrs,\n\t\t\t\t\t\t int *errp)\n{\n\tstruct xfrm_state *x = NULL;\n\tstruct xfrm_mark m;\n\tint err;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tif (xfrm_id_proto_match(p->proto, IPSEC_PROTO_ANY)) {\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup(net, mark, &p->daddr, p->spi, p->proto, p->family);\n\t} else {\n\t\txfrm_address_t *saddr = NULL;\n\n\t\tverify_one_addr(attrs, XFRMA_SRCADDR, &saddr);\n\t\tif (!saddr) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = -ESRCH;\n\t\tx = xfrm_state_lookup_byaddr(net, mark,\n\t\t\t\t\t     &p->daddr, saddr,\n\t\t\t\t\t     p->proto, p->family);\n\t}\n\n out:\n\tif (!x && errp)\n\t\t*errp = err;\n\treturn x;\n}\n\nstatic int xfrm_del_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err = -ESRCH;\n\tstruct km_event c;\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\treturn err;\n\n\tif ((err = security_xfrm_state_delete(x)) != 0)\n\t\tgoto out;\n\n\tif (xfrm_state_kern(x)) {\n\t\terr = -EPERM;\n\t\tgoto out;\n\t}\n\n\terr = xfrm_state_delete(x);\n\n\tif (err < 0)\n\t\tgoto out;\n\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.event = nlh->nlmsg_type;\n\tkm_state_notify(x, &c);\n\nout:\n\txfrm_audit_state_delete(x, err ? 0 : 1, true);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic void copy_to_user_state(struct xfrm_state *x, struct xfrm_usersa_info *p)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->id, &x->id, sizeof(p->id));\n\tmemcpy(&p->sel, &x->sel, sizeof(p->sel));\n\tmemcpy(&p->lft, &x->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &x->curlft, sizeof(p->curlft));\n\tput_unaligned(x->stats.replay_window, &p->stats.replay_window);\n\tput_unaligned(x->stats.replay, &p->stats.replay);\n\tput_unaligned(x->stats.integrity_failed, &p->stats.integrity_failed);\n\tmemcpy(&p->saddr, &x->props.saddr, sizeof(p->saddr));\n\tp->mode = x->props.mode;\n\tp->replay_window = x->props.replay_window;\n\tp->reqid = x->props.reqid;\n\tp->family = x->props.family;\n\tp->flags = x->props.flags;\n\tp->seq = x->km.seq;\n}\n\nstruct xfrm_dump_info {\n\tstruct sk_buff *in_skb;\n\tstruct sk_buff *out_skb;\n\tu32 nlmsg_seq;\n\tu16 nlmsg_flags;\n};\n\nstatic int copy_sec_ctx(struct xfrm_sec_ctx *s, struct sk_buff *skb)\n{\n\tstruct xfrm_user_sec_ctx *uctx;\n\tstruct nlattr *attr;\n\tint ctx_size = sizeof(*uctx) + s->ctx_len;\n\n\tattr = nla_reserve(skb, XFRMA_SEC_CTX, ctx_size);\n\tif (attr == NULL)\n\t\treturn -EMSGSIZE;\n\n\tuctx = nla_data(attr);\n\tuctx->exttype = XFRMA_SEC_CTX;\n\tuctx->len = ctx_size;\n\tuctx->ctx_doi = s->ctx_doi;\n\tuctx->ctx_alg = s->ctx_alg;\n\tuctx->ctx_len = s->ctx_len;\n\tmemcpy(uctx + 1, s->ctx_str, s->ctx_len);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_auth(struct xfrm_algo_auth *auth, struct sk_buff *skb)\n{\n\tstruct xfrm_algo *algo;\n\tstruct nlattr *nla;\n\n\tnla = nla_reserve(skb, XFRMA_ALG_AUTH,\n\t\t\t  sizeof(*algo) + (auth->alg_key_len + 7) / 8);\n\tif (!nla)\n\t\treturn -EMSGSIZE;\n\n\talgo = nla_data(nla);\n\tstrncpy(algo->alg_name, auth->alg_name, sizeof(algo->alg_name));\n\tmemcpy(algo->alg_key, auth->alg_key, (auth->alg_key_len + 7) / 8);\n\talgo->alg_key_len = auth->alg_key_len;\n\n\treturn 0;\n}\n\n/* Don't change this without updating xfrm_sa_len! */\nstatic int copy_to_user_state_extra(struct xfrm_state *x,\n\t\t\t\t    struct xfrm_usersa_info *p,\n\t\t\t\t    struct sk_buff *skb)\n{\n\tint ret = 0;\n\n\tcopy_to_user_state(x, p);\n\n\tif (x->props.extra_flags) {\n\t\tret = nla_put_u32(skb, XFRMA_SA_EXTRA_FLAGS,\n\t\t\t\t  x->props.extra_flags);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (x->coaddr) {\n\t\tret = nla_put(skb, XFRMA_COADDR, sizeof(*x->coaddr), x->coaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->lastused) {\n\t\tret = nla_put_u64_64bit(skb, XFRMA_LASTUSED, x->lastused,\n\t\t\t\t\tXFRMA_PAD);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aead) {\n\t\tret = nla_put(skb, XFRMA_ALG_AEAD, aead_len(x->aead), x->aead);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->aalg) {\n\t\tret = copy_to_user_auth(x->aalg, skb);\n\t\tif (!ret)\n\t\t\tret = nla_put(skb, XFRMA_ALG_AUTH_TRUNC,\n\t\t\t\t      xfrm_alg_auth_len(x->aalg), x->aalg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->ealg) {\n\t\tret = nla_put(skb, XFRMA_ALG_CRYPT, xfrm_alg_len(x->ealg), x->ealg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->calg) {\n\t\tret = nla_put(skb, XFRMA_ALG_COMP, sizeof(*(x->calg)), x->calg);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->encap) {\n\t\tret = nla_put(skb, XFRMA_ENCAP, sizeof(*x->encap), x->encap);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tif (x->tfcpad) {\n\t\tret = nla_put_u32(skb, XFRMA_TFCPAD, x->tfcpad);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = xfrm_mark_put(skb, &x->mark);\n\tif (ret)\n\t\tgoto out;\n\tif (x->replay_esn)\n\t\tret = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\telse\n\t\tret = nla_put(skb, XFRMA_REPLAY_VAL, sizeof(x->replay),\n\t\t\t      &x->replay);\n\tif (ret)\n\t\tgoto out;\n\tif (x->security)\n\t\tret = copy_sec_ctx(x->security, skb);\nout:\n\treturn ret;\n}\n\nstatic int dump_one_state(struct xfrm_state *x, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct xfrm_usersa_info *p;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWSA, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_sa_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct sock *sk = cb->skb->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cb->args[0])\n\t\txfrm_state_walk_done(walk, net);\n\treturn 0;\n}\n\nstatic const struct nla_policy xfrma_policy[XFRMA_MAX+1];\nstatic int xfrm_dump_sa(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state_walk *walk = (struct xfrm_state_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_state_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tstruct nlattr *attrs[XFRMA_MAX+1];\n\t\tstruct xfrm_address_filter *filter = NULL;\n\t\tu8 proto = 0;\n\t\tint err;\n\n\t\terr = nlmsg_parse(cb->nlh, 0, attrs, XFRMA_MAX,\n\t\t\t\t  xfrma_policy);\n\t\tif (err < 0)\n\t\t\treturn err;\n\n\t\tif (attrs[XFRMA_ADDRESS_FILTER]) {\n\t\t\tfilter = kmemdup(nla_data(attrs[XFRMA_ADDRESS_FILTER]),\n\t\t\t\t\t sizeof(*filter), GFP_KERNEL);\n\t\t\tif (filter == NULL)\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tif (attrs[XFRMA_PROTO])\n\t\t\tproto = nla_get_u8(attrs[XFRMA_PROTO]);\n\n\t\txfrm_state_walk_init(walk, proto, filter);\n\t\tcb->args[0] = 1;\n\t}\n\n\t(void) xfrm_state_walk(net, walk, dump_one_state, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_state_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_state *x, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_ATOMIC);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_state(x, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\n/* A wrapper for nlmsg_multicast() checking that nlsk is still available.\n * Must be called with RCU read lock.\n */\nstatic inline int xfrm_nlmsg_multicast(struct net *net, struct sk_buff *skb,\n\t\t\t\t       u32 pid, unsigned int group)\n{\n\tstruct sock *nlsk = rcu_dereference(net->xfrm.nlsk);\n\n\tif (nlsk)\n\t\treturn nlmsg_multicast(nlsk, skb, pid, group, GFP_ATOMIC);\n\telse\n\t\treturn -1;\n}\n\nstatic inline size_t xfrm_spdinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_spdinfo))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhinfo))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhthresh))\n\t       + nla_total_size(sizeof(struct xfrmu_spdhthresh));\n}\n\nstatic int build_spdinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_spdinfo si;\n\tstruct xfrmu_spdinfo spc;\n\tstruct xfrmu_spdhinfo sph;\n\tstruct xfrmu_spdhthresh spt4, spt6;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\tunsigned lseq;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSPDINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_spd_getinfo(net, &si);\n\tspc.incnt = si.incnt;\n\tspc.outcnt = si.outcnt;\n\tspc.fwdcnt = si.fwdcnt;\n\tspc.inscnt = si.inscnt;\n\tspc.outscnt = si.outscnt;\n\tspc.fwdscnt = si.fwdscnt;\n\tsph.spdhcnt = si.spdhcnt;\n\tsph.spdhmcnt = si.spdhmcnt;\n\n\tdo {\n\t\tlseq = read_seqbegin(&net->xfrm.policy_hthresh.lock);\n\n\t\tspt4.lbits = net->xfrm.policy_hthresh.lbits4;\n\t\tspt4.rbits = net->xfrm.policy_hthresh.rbits4;\n\t\tspt6.lbits = net->xfrm.policy_hthresh.lbits6;\n\t\tspt6.rbits = net->xfrm.policy_hthresh.rbits6;\n\t} while (read_seqretry(&net->xfrm.policy_hthresh.lock, lseq));\n\n\terr = nla_put(skb, XFRMA_SPD_INFO, sizeof(spc), &spc);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_HINFO, sizeof(sph), &sph);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_IPV4_HTHRESH, sizeof(spt4), &spt4);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SPD_IPV6_HTHRESH, sizeof(spt6), &spt6);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_set_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t    struct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrmu_spdhthresh *thresh4 = NULL;\n\tstruct xfrmu_spdhthresh *thresh6 = NULL;\n\n\t/* selector prefixlen thresholds to hash policies */\n\tif (attrs[XFRMA_SPD_IPV4_HTHRESH]) {\n\t\tstruct nlattr *rta = attrs[XFRMA_SPD_IPV4_HTHRESH];\n\n\t\tif (nla_len(rta) < sizeof(*thresh4))\n\t\t\treturn -EINVAL;\n\t\tthresh4 = nla_data(rta);\n\t\tif (thresh4->lbits > 32 || thresh4->rbits > 32)\n\t\t\treturn -EINVAL;\n\t}\n\tif (attrs[XFRMA_SPD_IPV6_HTHRESH]) {\n\t\tstruct nlattr *rta = attrs[XFRMA_SPD_IPV6_HTHRESH];\n\n\t\tif (nla_len(rta) < sizeof(*thresh6))\n\t\t\treturn -EINVAL;\n\t\tthresh6 = nla_data(rta);\n\t\tif (thresh6->lbits > 128 || thresh6->rbits > 128)\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (thresh4 || thresh6) {\n\t\twrite_seqlock(&net->xfrm.policy_hthresh.lock);\n\t\tif (thresh4) {\n\t\t\tnet->xfrm.policy_hthresh.lbits4 = thresh4->lbits;\n\t\t\tnet->xfrm.policy_hthresh.rbits4 = thresh4->rbits;\n\t\t}\n\t\tif (thresh6) {\n\t\t\tnet->xfrm.policy_hthresh.lbits6 = thresh6->lbits;\n\t\t\tnet->xfrm.policy_hthresh.rbits6 = thresh6->rbits;\n\t\t}\n\t\twrite_sequnlock(&net->xfrm.policy_hthresh.lock);\n\n\t\txfrm_policy_hash_rebuild(net);\n\t}\n\n\treturn 0;\n}\n\nstatic int xfrm_get_spdinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_spdinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_spdinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic inline size_t xfrm_sadinfo_msgsize(void)\n{\n\treturn NLMSG_ALIGN(4)\n\t       + nla_total_size(sizeof(struct xfrmu_sadhinfo))\n\t       + nla_total_size(4); /* XFRMA_SAD_CNT */\n}\n\nstatic int build_sadinfo(struct sk_buff *skb, struct net *net,\n\t\t\t u32 portid, u32 seq, u32 flags)\n{\n\tstruct xfrmk_sadinfo si;\n\tstruct xfrmu_sadhinfo sh;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\tu32 *f;\n\n\tnlh = nlmsg_put(skb, portid, seq, XFRM_MSG_NEWSADINFO, sizeof(u32), 0);\n\tif (nlh == NULL) /* shouldn't really happen ... */\n\t\treturn -EMSGSIZE;\n\n\tf = nlmsg_data(nlh);\n\t*f = flags;\n\txfrm_sad_getinfo(net, &si);\n\n\tsh.sadhmcnt = si.sadhmcnt;\n\tsh.sadhcnt = si.sadhcnt;\n\n\terr = nla_put_u32(skb, XFRMA_SAD_CNT, si.sadcnt);\n\tif (!err)\n\t\terr = nla_put(skb, XFRMA_SAD_HINFO, sizeof(sh), &sh);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_get_sadinfo(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct sk_buff *r_skb;\n\tu32 *flags = nlmsg_data(nlh);\n\tu32 sportid = NETLINK_CB(skb).portid;\n\tu32 seq = nlh->nlmsg_seq;\n\n\tr_skb = nlmsg_new(xfrm_sadinfo_msgsize(), GFP_ATOMIC);\n\tif (r_skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_sadinfo(r_skb, net, sportid, seq, *flags) < 0)\n\t\tBUG();\n\n\treturn nlmsg_unicast(net->xfrm.nlsk, r_skb, sportid);\n}\n\nstatic int xfrm_get_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_usersa_id *p = nlmsg_data(nlh);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *resp_skb;\n\tint err = -ESRCH;\n\n\tx = xfrm_user_state_lookup(net, p, attrs, &err);\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t} else {\n\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\t}\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int xfrm_alloc_userspi(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct xfrm_userspi_info *p;\n\tstruct sk_buff *resp_skb;\n\txfrm_address_t *daddr;\n\tint family;\n\tint err;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\n\tp = nlmsg_data(nlh);\n\terr = verify_spi_info(p->info.id.proto, p->min, p->max);\n\tif (err)\n\t\tgoto out_noput;\n\n\tfamily = p->info.family;\n\tdaddr = &p->info.id.daddr;\n\n\tx = NULL;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\tif (p->info.seq) {\n\t\tx = xfrm_find_acq_byseq(net, mark, p->info.seq);\n\t\tif (x && !xfrm_addr_equal(&x->id.daddr, daddr, family)) {\n\t\t\txfrm_state_put(x);\n\t\t\tx = NULL;\n\t\t}\n\t}\n\n\tif (!x)\n\t\tx = xfrm_find_acq(net, &m, p->info.mode, p->info.reqid,\n\t\t\t\t  p->info.id.proto, daddr,\n\t\t\t\t  &p->info.saddr, 1,\n\t\t\t\t  family);\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\tgoto out_noput;\n\n\terr = xfrm_alloc_spi(x, p->min, p->max);\n\tif (err)\n\t\tgoto out;\n\n\tresp_skb = xfrm_state_netlink(skb, x, nlh->nlmsg_seq);\n\tif (IS_ERR(resp_skb)) {\n\t\terr = PTR_ERR(resp_skb);\n\t\tgoto out;\n\t}\n\n\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb, NETLINK_CB(skb).portid);\n\nout:\n\txfrm_state_put(x);\nout_noput:\n\treturn err;\n}\n\nstatic int verify_policy_dir(u8 dir)\n{\n\tswitch (dir) {\n\tcase XFRM_POLICY_IN:\n\tcase XFRM_POLICY_OUT:\n\tcase XFRM_POLICY_FWD:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_policy_type(u8 type)\n{\n\tswitch (type) {\n\tcase XFRM_POLICY_TYPE_MAIN:\n#ifdef CONFIG_XFRM_SUB_POLICY\n\tcase XFRM_POLICY_TYPE_SUB:\n#endif\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}\n\nstatic int verify_newpolicy_info(struct xfrm_userpolicy_info *p)\n{\n\tint ret;\n\n\tswitch (p->share) {\n\tcase XFRM_SHARE_ANY:\n\tcase XFRM_SHARE_SESSION:\n\tcase XFRM_SHARE_USER:\n\tcase XFRM_SHARE_UNIQUE:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->action) {\n\tcase XFRM_POLICY_ALLOW:\n\tcase XFRM_POLICY_BLOCK:\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (p->sel.family) {\n\tcase AF_INET:\n\t\tbreak;\n\n\tcase AF_INET6:\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tbreak;\n#else\n\t\treturn  -EAFNOSUPPORT;\n#endif\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tret = verify_policy_dir(p->dir);\n\tif (ret)\n\t\treturn ret;\n\tif (p->index && ((p->index & XFRM_POLICY_MAX) != p->dir))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\nstatic int copy_from_user_sec_ctx(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\tstruct xfrm_user_sec_ctx *uctx;\n\n\tif (!rt)\n\t\treturn 0;\n\n\tuctx = nla_data(rt);\n\treturn security_xfrm_policy_alloc(&pol->security, uctx, GFP_KERNEL);\n}\n\nstatic void copy_templates(struct xfrm_policy *xp, struct xfrm_user_tmpl *ut,\n\t\t\t   int nr)\n{\n\tint i;\n\n\txp->xfrm_nr = nr;\n\tfor (i = 0; i < nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\n\t\tmemcpy(&t->id, &ut->id, sizeof(struct xfrm_id));\n\t\tmemcpy(&t->saddr, &ut->saddr,\n\t\t       sizeof(xfrm_address_t));\n\t\tt->reqid = ut->reqid;\n\t\tt->mode = ut->mode;\n\t\tt->share = ut->share;\n\t\tt->optional = ut->optional;\n\t\tt->aalgos = ut->aalgos;\n\t\tt->ealgos = ut->ealgos;\n\t\tt->calgos = ut->calgos;\n\t\t/* If all masks are ~0, then we allow all algorithms. */\n\t\tt->allalgs = !~(t->aalgos & t->ealgos & t->calgos);\n\t\tt->encap_family = ut->family;\n\t}\n}\n\nstatic int validate_tmpl(int nr, struct xfrm_user_tmpl *ut, u16 family)\n{\n\tint i;\n\n\tif (nr > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < nr; i++) {\n\t\t/* We never validated the ut->family value, so many\n\t\t * applications simply leave it at zero.  The check was\n\t\t * never made and ut->family was ignored because all\n\t\t * templates could be assumed to have the same family as\n\t\t * the policy itself.  Now that we will have ipv4-in-ipv6\n\t\t * and ipv6-in-ipv4 tunnels, this is no longer true.\n\t\t */\n\t\tif (!ut[i].family)\n\t\t\tut[i].family = family;\n\n\t\tswitch (ut[i].family) {\n\t\tcase AF_INET:\n\t\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\t\tcase AF_INET6:\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int copy_from_user_tmpl(struct xfrm_policy *pol, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\n\tif (!rt) {\n\t\tpol->xfrm_nr = 0;\n\t} else {\n\t\tstruct xfrm_user_tmpl *utmpl = nla_data(rt);\n\t\tint nr = nla_len(rt) / sizeof(*utmpl);\n\t\tint err;\n\n\t\terr = validate_tmpl(nr, utmpl, pol->family);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tcopy_templates(pol, utmpl, nr);\n\t}\n\treturn 0;\n}\n\nstatic int copy_from_user_policy_type(u8 *tp, struct nlattr **attrs)\n{\n\tstruct nlattr *rt = attrs[XFRMA_POLICY_TYPE];\n\tstruct xfrm_userpolicy_type *upt;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\n\tif (rt) {\n\t\tupt = nla_data(rt);\n\t\ttype = upt->type;\n\t}\n\n\terr = verify_policy_type(type);\n\tif (err)\n\t\treturn err;\n\n\t*tp = type;\n\treturn 0;\n}\n\nstatic void copy_from_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p)\n{\n\txp->priority = p->priority;\n\txp->index = p->index;\n\tmemcpy(&xp->selector, &p->sel, sizeof(xp->selector));\n\tmemcpy(&xp->lft, &p->lft, sizeof(xp->lft));\n\txp->action = p->action;\n\txp->flags = p->flags;\n\txp->family = p->sel.family;\n\t/* XXX xp->share = p->share; */\n}\n\nstatic void copy_to_user_policy(struct xfrm_policy *xp, struct xfrm_userpolicy_info *p, int dir)\n{\n\tmemset(p, 0, sizeof(*p));\n\tmemcpy(&p->sel, &xp->selector, sizeof(p->sel));\n\tmemcpy(&p->lft, &xp->lft, sizeof(p->lft));\n\tmemcpy(&p->curlft, &xp->curlft, sizeof(p->curlft));\n\tp->priority = xp->priority;\n\tp->index = xp->index;\n\tp->sel.family = xp->family;\n\tp->dir = dir;\n\tp->action = xp->action;\n\tp->flags = xp->flags;\n\tp->share = XFRM_SHARE_ANY; /* XXX xp->share */\n}\n\nstatic struct xfrm_policy *xfrm_policy_construct(struct net *net, struct xfrm_userpolicy_info *p, struct nlattr **attrs, int *errp)\n{\n\tstruct xfrm_policy *xp = xfrm_policy_alloc(net, GFP_KERNEL);\n\tint err;\n\n\tif (!xp) {\n\t\t*errp = -ENOMEM;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\n\terr = copy_from_user_policy_type(&xp->type, attrs);\n\tif (err)\n\t\tgoto error;\n\n\tif (!(err = copy_from_user_tmpl(xp, attrs)))\n\t\terr = copy_from_user_sec_ctx(xp, attrs);\n\tif (err)\n\t\tgoto error;\n\n\txfrm_mark_get(attrs, &xp->mark);\n\n\treturn xp;\n error:\n\t*errp = err;\n\txp->walk.dead = 1;\n\txfrm_policy_destroy(xp);\n\treturn NULL;\n}\n\nstatic int xfrm_add_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_userpolicy_info *p = nlmsg_data(nlh);\n\tstruct xfrm_policy *xp;\n\tstruct km_event c;\n\tint err;\n\tint excl;\n\n\terr = verify_newpolicy_info(p);\n\tif (err)\n\t\treturn err;\n\terr = verify_sec_ctx_len(attrs);\n\tif (err)\n\t\treturn err;\n\n\txp = xfrm_policy_construct(net, p, attrs, &err);\n\tif (!xp)\n\t\treturn err;\n\n\t/* shouldn't excl be based on nlh flags??\n\t * Aha! this is anti-netlink really i.e  more pfkey derived\n\t * in netlink excl is a flag and you wouldnt need\n\t * a type XFRM_MSG_UPDPOLICY - JHS */\n\texcl = nlh->nlmsg_type == XFRM_MSG_NEWPOLICY;\n\terr = xfrm_policy_insert(p->dir, xp, excl);\n\txfrm_audit_policy_add(xp, err ? 0 : 1, true);\n\n\tif (err) {\n\t\tsecurity_xfrm_policy_free(xp->security);\n\t\tkfree(xp);\n\t\treturn err;\n\t}\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tkm_policy_notify(xp, p->dir, &c);\n\n\txfrm_pol_put(xp);\n\n\treturn 0;\n}\n\nstatic int copy_to_user_tmpl(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tstruct xfrm_user_tmpl vec[XFRM_MAX_DEPTH];\n\tint i;\n\n\tif (xp->xfrm_nr == 0)\n\t\treturn 0;\n\n\tfor (i = 0; i < xp->xfrm_nr; i++) {\n\t\tstruct xfrm_user_tmpl *up = &vec[i];\n\t\tstruct xfrm_tmpl *kp = &xp->xfrm_vec[i];\n\n\t\tmemset(up, 0, sizeof(*up));\n\t\tmemcpy(&up->id, &kp->id, sizeof(up->id));\n\t\tup->family = kp->encap_family;\n\t\tmemcpy(&up->saddr, &kp->saddr, sizeof(up->saddr));\n\t\tup->reqid = kp->reqid;\n\t\tup->mode = kp->mode;\n\t\tup->share = kp->share;\n\t\tup->optional = kp->optional;\n\t\tup->aalgos = kp->aalgos;\n\t\tup->ealgos = kp->ealgos;\n\t\tup->calgos = kp->calgos;\n\t}\n\n\treturn nla_put(skb, XFRMA_TMPL,\n\t\t       sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr, vec);\n}\n\nstatic inline int copy_to_user_state_sec_ctx(struct xfrm_state *x, struct sk_buff *skb)\n{\n\tif (x->security) {\n\t\treturn copy_sec_ctx(x->security, skb);\n\t}\n\treturn 0;\n}\n\nstatic inline int copy_to_user_sec_ctx(struct xfrm_policy *xp, struct sk_buff *skb)\n{\n\tif (xp->security)\n\t\treturn copy_sec_ctx(xp->security, skb);\n\treturn 0;\n}\nstatic inline size_t userpolicy_type_attrsize(void)\n{\n#ifdef CONFIG_XFRM_SUB_POLICY\n\treturn nla_total_size(sizeof(struct xfrm_userpolicy_type));\n#else\n\treturn 0;\n#endif\n}\n\n#ifdef CONFIG_XFRM_SUB_POLICY\nstatic int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\tstruct xfrm_userpolicy_type upt = {\n\t\t.type = type,\n\t};\n\n\treturn nla_put(skb, XFRMA_POLICY_TYPE, sizeof(upt), &upt);\n}\n\n#else\nstatic inline int copy_to_user_policy_type(u8 type, struct sk_buff *skb)\n{\n\treturn 0;\n}\n#endif\n\nstatic int dump_one_policy(struct xfrm_policy *xp, int dir, int count, void *ptr)\n{\n\tstruct xfrm_dump_info *sp = ptr;\n\tstruct xfrm_userpolicy_info *p;\n\tstruct sk_buff *in_skb = sp->in_skb;\n\tstruct sk_buff *skb = sp->out_skb;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, NETLINK_CB(in_skb).portid, sp->nlmsg_seq,\n\t\t\tXFRM_MSG_NEWPOLICY, sizeof(*p), sp->nlmsg_flags);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tp = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy_done(struct netlink_callback *cb)\n{\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct net *net = sock_net(cb->skb->sk);\n\n\txfrm_policy_walk_done(walk, net);\n\treturn 0;\n}\n\nstatic int xfrm_dump_policy(struct sk_buff *skb, struct netlink_callback *cb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy_walk *walk = (struct xfrm_policy_walk *) &cb->args[1];\n\tstruct xfrm_dump_info info;\n\n\tBUILD_BUG_ON(sizeof(struct xfrm_policy_walk) >\n\t\t     sizeof(cb->args) - sizeof(cb->args[0]));\n\n\tinfo.in_skb = cb->skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = cb->nlh->nlmsg_seq;\n\tinfo.nlmsg_flags = NLM_F_MULTI;\n\n\tif (!cb->args[0]) {\n\t\tcb->args[0] = 1;\n\t\txfrm_policy_walk_init(walk, XFRM_POLICY_TYPE_ANY);\n\t}\n\n\t(void) xfrm_policy_walk(net, walk, dump_one_policy, &info);\n\n\treturn skb->len;\n}\n\nstatic struct sk_buff *xfrm_policy_netlink(struct sk_buff *in_skb,\n\t\t\t\t\t  struct xfrm_policy *xp,\n\t\t\t\t\t  int dir, u32 seq)\n{\n\tstruct xfrm_dump_info info;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo.in_skb = in_skb;\n\tinfo.out_skb = skb;\n\tinfo.nlmsg_seq = seq;\n\tinfo.nlmsg_flags = 0;\n\n\terr = dump_one_policy(xp, dir, 0, &info);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn skb;\n}\n\nstatic int xfrm_get_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_userpolicy_id *p;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\tstruct km_event c;\n\tint delete;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tp = nlmsg_data(nlh);\n\tdelete = nlh->nlmsg_type == XFRM_MSG_DELPOLICY;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, delete, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir, &p->sel,\n\t\t\t\t\t   ctx, delete, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (!delete) {\n\t\tstruct sk_buff *resp_skb;\n\n\t\tresp_skb = xfrm_policy_netlink(skb, xp, p->dir, nlh->nlmsg_seq);\n\t\tif (IS_ERR(resp_skb)) {\n\t\t\terr = PTR_ERR(resp_skb);\n\t\t} else {\n\t\t\terr = nlmsg_unicast(net->xfrm.nlsk, resp_skb,\n\t\t\t\t\t    NETLINK_CB(skb).portid);\n\t\t}\n\t} else {\n\t\txfrm_audit_policy_delete(xp, err ? 0 : 1, true);\n\n\t\tif (err != 0)\n\t\t\tgoto out;\n\n\t\tc.data.byid = p->index;\n\t\tc.event = nlh->nlmsg_type;\n\t\tc.seq = nlh->nlmsg_seq;\n\t\tc.portid = nlh->nlmsg_pid;\n\t\tkm_policy_notify(xp, p->dir, &c);\n\t}\n\nout:\n\txfrm_pol_put(xp);\n\tif (delete && err == 0)\n\t\txfrm_garbage_collect(net);\n\treturn err;\n}\n\nstatic int xfrm_flush_sa(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tstruct xfrm_usersa_flush *p = nlmsg_data(nlh);\n\tint err;\n\n\terr = xfrm_state_flush(net, p->proto, true);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tc.data.proto = p->proto;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_state_notify(NULL, &c);\n\n\treturn 0;\n}\n\nstatic inline size_t xfrm_aevent_msgsize(struct xfrm_state *x)\n{\n\tsize_t replay_size = x->replay_esn ?\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn) :\n\t\t\t      sizeof(struct xfrm_replay_state);\n\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_aevent_id))\n\t       + nla_total_size(replay_size)\n\t       + nla_total_size_64bit(sizeof(struct xfrm_lifetime_cur))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(4) /* XFRM_AE_RTHR */\n\t       + nla_total_size(4); /* XFRM_AE_ETHR */\n}\n\nstatic int build_aevent(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_aevent_id *id;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_NEWAE, sizeof(*id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tid = nlmsg_data(nlh);\n\tmemcpy(&id->sa_id.daddr, &x->id.daddr, sizeof(x->id.daddr));\n\tid->sa_id.spi = x->id.spi;\n\tid->sa_id.family = x->props.family;\n\tid->sa_id.proto = x->id.proto;\n\tmemcpy(&id->saddr, &x->props.saddr, sizeof(x->props.saddr));\n\tid->reqid = x->props.reqid;\n\tid->flags = c->data.aevent;\n\n\tif (x->replay_esn) {\n\t\terr = nla_put(skb, XFRMA_REPLAY_ESN_VAL,\n\t\t\t      xfrm_replay_state_esn_len(x->replay_esn),\n\t\t\t      x->replay_esn);\n\t} else {\n\t\terr = nla_put(skb, XFRMA_REPLAY_VAL, sizeof(x->replay),\n\t\t\t      &x->replay);\n\t}\n\tif (err)\n\t\tgoto out_cancel;\n\terr = nla_put_64bit(skb, XFRMA_LTIME_VAL, sizeof(x->curlft), &x->curlft,\n\t\t\t    XFRMA_PAD);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tif (id->flags & XFRM_AE_RTHR) {\n\t\terr = nla_put_u32(skb, XFRMA_REPLAY_THRESH, x->replay_maxdiff);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\tif (id->flags & XFRM_AE_ETHR) {\n\t\terr = nla_put_u32(skb, XFRMA_ETIMER_THRESH,\n\t\t\t\t  x->replay_maxage * 10 / HZ);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\tgoto out_cancel;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_get_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct sk_buff *r_skb;\n\tint err;\n\tstruct km_event c;\n\tu32 mark;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct xfrm_usersa_id *id = &p->sa_id;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &id->daddr, id->spi, id->proto, id->family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tr_skb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (r_skb == NULL) {\n\t\txfrm_state_put(x);\n\t\treturn -ENOMEM;\n\t}\n\n\t/*\n\t * XXX: is this lock really needed - none of the other\n\t * gets lock (the concern is things getting updated\n\t * while we are still reading) - jhs\n\t*/\n\tspin_lock_bh(&x->lock);\n\tc.data.aevent = p->flags;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\n\tif (build_aevent(r_skb, x, &c) < 0)\n\t\tBUG();\n\terr = nlmsg_unicast(net->xfrm.nlsk, r_skb, NETLINK_CB(skb).portid);\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_new_ae(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tstruct km_event c;\n\tint err = -EINVAL;\n\tu32 mark = 0;\n\tstruct xfrm_mark m;\n\tstruct xfrm_aevent_id *p = nlmsg_data(nlh);\n\tstruct nlattr *rp = attrs[XFRMA_REPLAY_VAL];\n\tstruct nlattr *re = attrs[XFRMA_REPLAY_ESN_VAL];\n\tstruct nlattr *lt = attrs[XFRMA_LTIME_VAL];\n\tstruct nlattr *et = attrs[XFRMA_ETIMER_THRESH];\n\tstruct nlattr *rt = attrs[XFRMA_REPLAY_THRESH];\n\n\tif (!lt && !rp && !re && !et && !rt)\n\t\treturn err;\n\n\t/* pedantic mode - thou shalt sayeth replaceth */\n\tif (!(nlh->nlmsg_flags&NLM_F_REPLACE))\n\t\treturn err;\n\n\tmark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->sa_id.daddr, p->sa_id.spi, p->sa_id.proto, p->sa_id.family);\n\tif (x == NULL)\n\t\treturn -ESRCH;\n\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\n\terr = xfrm_replay_verify_len(x->replay_esn, re);\n\tif (err)\n\t\tgoto out;\n\n\tspin_lock_bh(&x->lock);\n\txfrm_update_ae_params(x, attrs, 1);\n\tspin_unlock_bh(&x->lock);\n\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.data.aevent = XFRM_AE_CU;\n\tkm_state_notify(x, &c);\n\terr = 0;\nout:\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_flush_policy(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct km_event c;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = xfrm_policy_flush(net, type, true);\n\tif (err) {\n\t\tif (err == -ESRCH) /* empty table */\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\n\tc.data.type = type;\n\tc.event = nlh->nlmsg_type;\n\tc.seq = nlh->nlmsg_seq;\n\tc.portid = nlh->nlmsg_pid;\n\tc.net = net;\n\tkm_policy_notify(NULL, 0, &c);\n\treturn 0;\n}\n\nstatic int xfrm_add_pol_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_polexpire *up = nlmsg_data(nlh);\n\tstruct xfrm_userpolicy_info *p = &up->pol;\n\tu8 type = XFRM_POLICY_TYPE_MAIN;\n\tint err = -ENOENT;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = verify_policy_dir(p->dir);\n\tif (err)\n\t\treturn err;\n\n\tif (p->index)\n\t\txp = xfrm_policy_byid(net, mark, type, p->dir, p->index, 0, &err);\n\telse {\n\t\tstruct nlattr *rt = attrs[XFRMA_SEC_CTX];\n\t\tstruct xfrm_sec_ctx *ctx;\n\n\t\terr = verify_sec_ctx_len(attrs);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tctx = NULL;\n\t\tif (rt) {\n\t\t\tstruct xfrm_user_sec_ctx *uctx = nla_data(rt);\n\n\t\t\terr = security_xfrm_policy_alloc(&ctx, uctx, GFP_KERNEL);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\txp = xfrm_policy_bysel_ctx(net, mark, type, p->dir,\n\t\t\t\t\t   &p->sel, ctx, 0, &err);\n\t\tsecurity_xfrm_policy_free(ctx);\n\t}\n\tif (xp == NULL)\n\t\treturn -ENOENT;\n\n\tif (unlikely(xp->walk.dead))\n\t\tgoto out;\n\n\terr = 0;\n\tif (up->hard) {\n\t\txfrm_policy_delete(xp, p->dir);\n\t\txfrm_audit_policy_delete(xp, 1, true);\n\t} else {\n\t\t// reset the timers here?\n\t\tWARN(1, \"Don't know what to do with soft policy expire\\n\");\n\t}\n\tkm_policy_expired(xp, p->dir, up->hard, nlh->nlmsg_pid);\n\nout:\n\txfrm_pol_put(xp);\n\treturn err;\n}\n\nstatic int xfrm_add_sa_expire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_state *x;\n\tint err;\n\tstruct xfrm_user_expire *ue = nlmsg_data(nlh);\n\tstruct xfrm_usersa_info *p = &ue->state;\n\tstruct xfrm_mark m;\n\tu32 mark = xfrm_mark_get(attrs, &m);\n\n\tx = xfrm_state_lookup(net, mark, &p->id.daddr, p->id.spi, p->id.proto, p->family);\n\n\terr = -ENOENT;\n\tif (x == NULL)\n\t\treturn err;\n\n\tspin_lock_bh(&x->lock);\n\terr = -EINVAL;\n\tif (x->km.state != XFRM_STATE_VALID)\n\t\tgoto out;\n\tkm_state_expired(x, ue->hard, nlh->nlmsg_pid);\n\n\tif (ue->hard) {\n\t\t__xfrm_state_delete(x);\n\t\txfrm_audit_state_delete(x, 1, true);\n\t}\n\terr = 0;\nout:\n\tspin_unlock_bh(&x->lock);\n\txfrm_state_put(x);\n\treturn err;\n}\n\nstatic int xfrm_add_acquire(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\tstruct nlattr **attrs)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct xfrm_policy *xp;\n\tstruct xfrm_user_tmpl *ut;\n\tint i;\n\tstruct nlattr *rt = attrs[XFRMA_TMPL];\n\tstruct xfrm_mark mark;\n\n\tstruct xfrm_user_acquire *ua = nlmsg_data(nlh);\n\tstruct xfrm_state *x = xfrm_state_alloc(net);\n\tint err = -ENOMEM;\n\n\tif (!x)\n\t\tgoto nomem;\n\n\txfrm_mark_get(attrs, &mark);\n\n\terr = verify_newpolicy_info(&ua->policy);\n\tif (err)\n\t\tgoto bad_policy;\n\n\t/*   build an XP */\n\txp = xfrm_policy_construct(net, &ua->policy, attrs, &err);\n\tif (!xp)\n\t\tgoto free_state;\n\n\tmemcpy(&x->id, &ua->id, sizeof(ua->id));\n\tmemcpy(&x->props.saddr, &ua->saddr, sizeof(ua->saddr));\n\tmemcpy(&x->sel, &ua->sel, sizeof(ua->sel));\n\txp->mark.m = x->mark.m = mark.m;\n\txp->mark.v = x->mark.v = mark.v;\n\tut = nla_data(rt);\n\t/* extract the templates and for each call km_key */\n\tfor (i = 0; i < xp->xfrm_nr; i++, ut++) {\n\t\tstruct xfrm_tmpl *t = &xp->xfrm_vec[i];\n\t\tmemcpy(&x->id, &t->id, sizeof(x->id));\n\t\tx->props.mode = t->mode;\n\t\tx->props.reqid = t->reqid;\n\t\tx->props.family = ut->family;\n\t\tt->aalgos = ua->aalgos;\n\t\tt->ealgos = ua->ealgos;\n\t\tt->calgos = ua->calgos;\n\t\terr = km_query(x, t, xp);\n\n\t}\n\n\tkfree(x);\n\tkfree(xp);\n\n\treturn 0;\n\nbad_policy:\n\tWARN(1, \"BAD policy passed\\n\");\nfree_state:\n\tkfree(x);\nnomem:\n\treturn err;\n}\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_from_user_migrate(struct xfrm_migrate *ma,\n\t\t\t\t  struct xfrm_kmaddress *k,\n\t\t\t\t  struct nlattr **attrs, int *num)\n{\n\tstruct nlattr *rt = attrs[XFRMA_MIGRATE];\n\tstruct xfrm_user_migrate *um;\n\tint i, num_migrate;\n\n\tif (k != NULL) {\n\t\tstruct xfrm_user_kmaddress *uk;\n\n\t\tuk = nla_data(attrs[XFRMA_KMADDRESS]);\n\t\tmemcpy(&k->local, &uk->local, sizeof(k->local));\n\t\tmemcpy(&k->remote, &uk->remote, sizeof(k->remote));\n\t\tk->family = uk->family;\n\t\tk->reserved = uk->reserved;\n\t}\n\n\tum = nla_data(rt);\n\tnum_migrate = nla_len(rt) / sizeof(*um);\n\n\tif (num_migrate <= 0 || num_migrate > XFRM_MAX_DEPTH)\n\t\treturn -EINVAL;\n\n\tfor (i = 0; i < num_migrate; i++, um++, ma++) {\n\t\tmemcpy(&ma->old_daddr, &um->old_daddr, sizeof(ma->old_daddr));\n\t\tmemcpy(&ma->old_saddr, &um->old_saddr, sizeof(ma->old_saddr));\n\t\tmemcpy(&ma->new_daddr, &um->new_daddr, sizeof(ma->new_daddr));\n\t\tmemcpy(&ma->new_saddr, &um->new_saddr, sizeof(ma->new_saddr));\n\n\t\tma->proto = um->proto;\n\t\tma->mode = um->mode;\n\t\tma->reqid = um->reqid;\n\n\t\tma->old_family = um->old_family;\n\t\tma->new_family = um->new_family;\n\t}\n\n\t*num = i;\n\treturn 0;\n}\n\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\tstruct xfrm_userpolicy_id *pi = nlmsg_data(nlh);\n\tstruct xfrm_migrate m[XFRM_MAX_DEPTH];\n\tstruct xfrm_kmaddress km, *kmp;\n\tu8 type;\n\tint err;\n\tint n = 0;\n\tstruct net *net = sock_net(skb->sk);\n\n\tif (attrs[XFRMA_MIGRATE] == NULL)\n\t\treturn -EINVAL;\n\n\tkmp = attrs[XFRMA_KMADDRESS] ? &km : NULL;\n\n\terr = copy_from_user_policy_type(&type, attrs);\n\tif (err)\n\t\treturn err;\n\n\terr = copy_from_user_migrate((struct xfrm_migrate *)m, kmp, attrs, &n);\n\tif (err)\n\t\treturn err;\n\n\tif (!n)\n\t\treturn 0;\n\n\txfrm_migrate(&pi->sel, pi->dir, type, m, n, kmp, net);\n\n\treturn 0;\n}\n#else\nstatic int xfrm_do_migrate(struct sk_buff *skb, struct nlmsghdr *nlh,\n\t\t\t   struct nlattr **attrs)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#ifdef CONFIG_XFRM_MIGRATE\nstatic int copy_to_user_migrate(const struct xfrm_migrate *m, struct sk_buff *skb)\n{\n\tstruct xfrm_user_migrate um;\n\n\tmemset(&um, 0, sizeof(um));\n\tum.proto = m->proto;\n\tum.mode = m->mode;\n\tum.reqid = m->reqid;\n\tum.old_family = m->old_family;\n\tmemcpy(&um.old_daddr, &m->old_daddr, sizeof(um.old_daddr));\n\tmemcpy(&um.old_saddr, &m->old_saddr, sizeof(um.old_saddr));\n\tum.new_family = m->new_family;\n\tmemcpy(&um.new_daddr, &m->new_daddr, sizeof(um.new_daddr));\n\tmemcpy(&um.new_saddr, &m->new_saddr, sizeof(um.new_saddr));\n\n\treturn nla_put(skb, XFRMA_MIGRATE, sizeof(um), &um);\n}\n\nstatic int copy_to_user_kmaddress(const struct xfrm_kmaddress *k, struct sk_buff *skb)\n{\n\tstruct xfrm_user_kmaddress uk;\n\n\tmemset(&uk, 0, sizeof(uk));\n\tuk.family = k->family;\n\tuk.reserved = k->reserved;\n\tmemcpy(&uk.local, &k->local, sizeof(uk.local));\n\tmemcpy(&uk.remote, &k->remote, sizeof(uk.remote));\n\n\treturn nla_put(skb, XFRMA_KMADDRESS, sizeof(uk), &uk);\n}\n\nstatic inline size_t xfrm_migrate_msgsize(int num_migrate, int with_kma)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_userpolicy_id))\n\t      + (with_kma ? nla_total_size(sizeof(struct xfrm_kmaddress)) : 0)\n\t      + nla_total_size(sizeof(struct xfrm_user_migrate) * num_migrate)\n\t      + userpolicy_type_attrsize();\n}\n\nstatic int build_migrate(struct sk_buff *skb, const struct xfrm_migrate *m,\n\t\t\t int num_migrate, const struct xfrm_kmaddress *k,\n\t\t\t const struct xfrm_selector *sel, u8 dir, u8 type)\n{\n\tconst struct xfrm_migrate *mp;\n\tstruct xfrm_userpolicy_id *pol_id;\n\tstruct nlmsghdr *nlh;\n\tint i, err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MIGRATE, sizeof(*pol_id), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tpol_id = nlmsg_data(nlh);\n\t/* copy data from selector, dir, and type to the pol_id */\n\tmemset(pol_id, 0, sizeof(*pol_id));\n\tmemcpy(&pol_id->sel, sel, sizeof(pol_id->sel));\n\tpol_id->dir = dir;\n\n\tif (k != NULL) {\n\t\terr = copy_to_user_kmaddress(k, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\terr = copy_to_user_policy_type(type, skb);\n\tif (err)\n\t\tgoto out_cancel;\n\tfor (i = 0, mp = m ; i < num_migrate; i++, mp++) {\n\t\terr = copy_to_user_migrate(mp, skb);\n\t\tif (err)\n\t\t\tgoto out_cancel;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n\nout_cancel:\n\tnlmsg_cancel(skb, nlh);\n\treturn err;\n}\n\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\tstruct net *net = &init_net;\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_migrate_msgsize(num_migrate, !!k), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\t/* build migrate */\n\tif (build_migrate(skb, m, num_migrate, k, sel, dir, type) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_MIGRATE);\n}\n#else\nstatic int xfrm_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,\n\t\t\t     const struct xfrm_migrate *m, int num_migrate,\n\t\t\t     const struct xfrm_kmaddress *k)\n{\n\treturn -ENOPROTOOPT;\n}\n#endif\n\n#define XMSGSIZE(type) sizeof(struct type)\n\nstatic const int xfrm_msg_min[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_id),\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userspi_info),\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_acquire),\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_expire),\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_info),\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_info),\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_polexpire),\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_usersa_flush),\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = 0,\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = XMSGSIZE(xfrm_aevent_id),\n\t[XFRM_MSG_REPORT      - XFRM_MSG_BASE] = XMSGSIZE(xfrm_user_report),\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = XMSGSIZE(xfrm_userpolicy_id),\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = sizeof(u32),\n};\n\n#undef XMSGSIZE\n\nstatic const struct nla_policy xfrma_policy[XFRMA_MAX+1] = {\n\t[XFRMA_SA]\t\t= { .len = sizeof(struct xfrm_usersa_info)},\n\t[XFRMA_POLICY]\t\t= { .len = sizeof(struct xfrm_userpolicy_info)},\n\t[XFRMA_LASTUSED]\t= { .type = NLA_U64},\n\t[XFRMA_ALG_AUTH_TRUNC]\t= { .len = sizeof(struct xfrm_algo_auth)},\n\t[XFRMA_ALG_AEAD]\t= { .len = sizeof(struct xfrm_algo_aead) },\n\t[XFRMA_ALG_AUTH]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_CRYPT]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ALG_COMP]\t= { .len = sizeof(struct xfrm_algo) },\n\t[XFRMA_ENCAP]\t\t= { .len = sizeof(struct xfrm_encap_tmpl) },\n\t[XFRMA_TMPL]\t\t= { .len = sizeof(struct xfrm_user_tmpl) },\n\t[XFRMA_SEC_CTX]\t\t= { .len = sizeof(struct xfrm_sec_ctx) },\n\t[XFRMA_LTIME_VAL]\t= { .len = sizeof(struct xfrm_lifetime_cur) },\n\t[XFRMA_REPLAY_VAL]\t= { .len = sizeof(struct xfrm_replay_state) },\n\t[XFRMA_REPLAY_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_ETIMER_THRESH]\t= { .type = NLA_U32 },\n\t[XFRMA_SRCADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_COADDR]\t\t= { .len = sizeof(xfrm_address_t) },\n\t[XFRMA_POLICY_TYPE]\t= { .len = sizeof(struct xfrm_userpolicy_type)},\n\t[XFRMA_MIGRATE]\t\t= { .len = sizeof(struct xfrm_user_migrate) },\n\t[XFRMA_KMADDRESS]\t= { .len = sizeof(struct xfrm_user_kmaddress) },\n\t[XFRMA_MARK]\t\t= { .len = sizeof(struct xfrm_mark) },\n\t[XFRMA_TFCPAD]\t\t= { .type = NLA_U32 },\n\t[XFRMA_REPLAY_ESN_VAL]\t= { .len = sizeof(struct xfrm_replay_state_esn) },\n\t[XFRMA_SA_EXTRA_FLAGS]\t= { .type = NLA_U32 },\n\t[XFRMA_PROTO]\t\t= { .type = NLA_U8 },\n\t[XFRMA_ADDRESS_FILTER]\t= { .len = sizeof(struct xfrm_address_filter) },\n};\n\nstatic const struct nla_policy xfrma_spd_policy[XFRMA_SPD_MAX+1] = {\n\t[XFRMA_SPD_IPV4_HTHRESH] = { .len = sizeof(struct xfrmu_spdhthresh) },\n\t[XFRMA_SPD_IPV6_HTHRESH] = { .len = sizeof(struct xfrmu_spdhthresh) },\n};\n\nstatic const struct xfrm_link {\n\tint (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);\n\tint (*dump)(struct sk_buff *, struct netlink_callback *);\n\tint (*done)(struct netlink_callback *);\n\tconst struct nla_policy *nla_pol;\n\tint nla_max;\n} xfrm_dispatch[XFRM_NR_MSGTYPES] = {\n\t[XFRM_MSG_NEWSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_DELSA       - XFRM_MSG_BASE] = { .doit = xfrm_del_sa        },\n\t[XFRM_MSG_GETSA       - XFRM_MSG_BASE] = { .doit = xfrm_get_sa,\n\t\t\t\t\t\t   .dump = xfrm_dump_sa,\n\t\t\t\t\t\t   .done = xfrm_dump_sa_done  },\n\t[XFRM_MSG_NEWPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_DELPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy    },\n\t[XFRM_MSG_GETPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_get_policy,\n\t\t\t\t\t\t   .dump = xfrm_dump_policy,\n\t\t\t\t\t\t   .done = xfrm_dump_policy_done },\n\t[XFRM_MSG_ALLOCSPI    - XFRM_MSG_BASE] = { .doit = xfrm_alloc_userspi },\n\t[XFRM_MSG_ACQUIRE     - XFRM_MSG_BASE] = { .doit = xfrm_add_acquire   },\n\t[XFRM_MSG_EXPIRE      - XFRM_MSG_BASE] = { .doit = xfrm_add_sa_expire },\n\t[XFRM_MSG_UPDPOLICY   - XFRM_MSG_BASE] = { .doit = xfrm_add_policy    },\n\t[XFRM_MSG_UPDSA       - XFRM_MSG_BASE] = { .doit = xfrm_add_sa        },\n\t[XFRM_MSG_POLEXPIRE   - XFRM_MSG_BASE] = { .doit = xfrm_add_pol_expire},\n\t[XFRM_MSG_FLUSHSA     - XFRM_MSG_BASE] = { .doit = xfrm_flush_sa      },\n\t[XFRM_MSG_FLUSHPOLICY - XFRM_MSG_BASE] = { .doit = xfrm_flush_policy  },\n\t[XFRM_MSG_NEWAE       - XFRM_MSG_BASE] = { .doit = xfrm_new_ae  },\n\t[XFRM_MSG_GETAE       - XFRM_MSG_BASE] = { .doit = xfrm_get_ae  },\n\t[XFRM_MSG_MIGRATE     - XFRM_MSG_BASE] = { .doit = xfrm_do_migrate    },\n\t[XFRM_MSG_GETSADINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_sadinfo   },\n\t[XFRM_MSG_NEWSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_set_spdinfo,\n\t\t\t\t\t\t   .nla_pol = xfrma_spd_policy,\n\t\t\t\t\t\t   .nla_max = XFRMA_SPD_MAX },\n\t[XFRM_MSG_GETSPDINFO  - XFRM_MSG_BASE] = { .doit = xfrm_get_spdinfo   },\n};\n\nstatic int xfrm_user_rcv_msg(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n\tstruct net *net = sock_net(skb->sk);\n\tstruct nlattr *attrs[XFRMA_MAX+1];\n\tconst struct xfrm_link *link;\n\tint type, err;\n\n#ifdef CONFIG_COMPAT\n\tif (in_compat_syscall())\n\t\treturn -ENOTSUPP;\n#endif\n\n\ttype = nlh->nlmsg_type;\n\tif (type > XFRM_MSG_MAX)\n\t\treturn -EINVAL;\n\n\ttype -= XFRM_MSG_BASE;\n\tlink = &xfrm_dispatch[type];\n\n\t/* All operations require privileges, even GET */\n\tif (!netlink_net_capable(skb, CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif ((type == (XFRM_MSG_GETSA - XFRM_MSG_BASE) ||\n\t     type == (XFRM_MSG_GETPOLICY - XFRM_MSG_BASE)) &&\n\t    (nlh->nlmsg_flags & NLM_F_DUMP)) {\n\t\tif (link->dump == NULL)\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct netlink_dump_control c = {\n\t\t\t\t.dump = link->dump,\n\t\t\t\t.done = link->done,\n\t\t\t};\n\t\t\treturn netlink_dump_start(net->xfrm.nlsk, skb, nlh, &c);\n\t\t}\n\t}\n\n\terr = nlmsg_parse(nlh, xfrm_msg_min[type], attrs,\n\t\t\t  link->nla_max ? : XFRMA_MAX,\n\t\t\t  link->nla_pol ? : xfrma_policy);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (link->doit == NULL)\n\t\treturn -EINVAL;\n\n\treturn link->doit(skb, nlh, attrs);\n}\n\nstatic void xfrm_netlink_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = sock_net(skb->sk);\n\n\tmutex_lock(&net->xfrm.xfrm_cfg_mutex);\n\tnetlink_rcv_skb(skb, &xfrm_user_rcv_msg);\n\tmutex_unlock(&net->xfrm.xfrm_cfg_mutex);\n}\n\nstatic inline size_t xfrm_expire_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_expire))\n\t       + nla_total_size(sizeof(struct xfrm_mark));\n}\n\nstatic int build_expire(struct sk_buff *skb, struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct xfrm_user_expire *ue;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_EXPIRE, sizeof(*ue), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tue = nlmsg_data(nlh);\n\tcopy_to_user_state(x, &ue->state);\n\tue->hard = (c->data.hard != 0) ? 1 : 0;\n\n\terr = xfrm_mark_put(skb, &x->mark);\n\tif (err)\n\t\treturn err;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_exp_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_expire_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_expire(skb, x, c) < 0) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);\n}\n\nstatic int xfrm_aevent_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_aevent_msgsize(x), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_aevent(skb, x, c) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_AEVENTS);\n}\n\nstatic int xfrm_notify_sa_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct xfrm_usersa_flush *p;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = NLMSG_ALIGN(sizeof(struct xfrm_usersa_flush));\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHSA, sizeof(*p), 0);\n\tif (nlh == NULL) {\n\t\tkfree_skb(skb);\n\t\treturn -EMSGSIZE;\n\t}\n\n\tp = nlmsg_data(nlh);\n\tp->proto = c->data.proto;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_SA);\n}\n\nstatic inline size_t xfrm_sa_len(struct xfrm_state *x)\n{\n\tsize_t l = 0;\n\tif (x->aead)\n\t\tl += nla_total_size(aead_len(x->aead));\n\tif (x->aalg) {\n\t\tl += nla_total_size(sizeof(struct xfrm_algo) +\n\t\t\t\t    (x->aalg->alg_key_len + 7) / 8);\n\t\tl += nla_total_size(xfrm_alg_auth_len(x->aalg));\n\t}\n\tif (x->ealg)\n\t\tl += nla_total_size(xfrm_alg_len(x->ealg));\n\tif (x->calg)\n\t\tl += nla_total_size(sizeof(*x->calg));\n\tif (x->encap)\n\t\tl += nla_total_size(sizeof(*x->encap));\n\tif (x->tfcpad)\n\t\tl += nla_total_size(sizeof(x->tfcpad));\n\tif (x->replay_esn)\n\t\tl += nla_total_size(xfrm_replay_state_esn_len(x->replay_esn));\n\telse\n\t\tl += nla_total_size(sizeof(struct xfrm_replay_state));\n\tif (x->security)\n\t\tl += nla_total_size(sizeof(struct xfrm_user_sec_ctx) +\n\t\t\t\t    x->security->ctx_len);\n\tif (x->coaddr)\n\t\tl += nla_total_size(sizeof(*x->coaddr));\n\tif (x->props.extra_flags)\n\t\tl += nla_total_size(sizeof(x->props.extra_flags));\n\n\t/* Must count x->lastused as it may become non-zero behind our back. */\n\tl += nla_total_size_64bit(sizeof(u64));\n\n\treturn l;\n}\n\nstatic int xfrm_notify_sa(struct xfrm_state *x, const struct km_event *c)\n{\n\tstruct net *net = xs_net(x);\n\tstruct xfrm_usersa_info *p;\n\tstruct xfrm_usersa_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint len = xfrm_sa_len(x);\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\t}\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELSA) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemcpy(&id->daddr, &x->id.daddr, sizeof(id->daddr));\n\t\tid->spi = x->id.spi;\n\t\tid->family = x->props.family;\n\t\tid->proto = x->id.proto;\n\n\t\tattr = nla_reserve(skb, XFRMA_SA, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\terr = copy_to_user_state_extra(x, p, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_SA);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_state_notify(struct xfrm_state *x, const struct km_event *c)\n{\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_EXPIRE:\n\t\treturn xfrm_exp_state_notify(x, c);\n\tcase XFRM_MSG_NEWAE:\n\t\treturn xfrm_aevent_state_notify(x, c);\n\tcase XFRM_MSG_DELSA:\n\tcase XFRM_MSG_UPDSA:\n\tcase XFRM_MSG_NEWSA:\n\t\treturn xfrm_notify_sa(x, c);\n\tcase XFRM_MSG_FLUSHSA:\n\t\treturn xfrm_notify_sa_flush(c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown SA event %d\\n\",\n\t\t       c->event);\n\t\tbreak;\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_acquire_msgsize(struct xfrm_state *x,\n\t\t\t\t\t  struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_acquire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + nla_total_size(xfrm_user_sec_ctx_size(x->security))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_acquire(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t struct xfrm_tmpl *xt, struct xfrm_policy *xp)\n{\n\t__u32 seq = xfrm_get_acqseq();\n\tstruct xfrm_user_acquire *ua;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_ACQUIRE, sizeof(*ua), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tua = nlmsg_data(nlh);\n\tmemcpy(&ua->id, &x->id, sizeof(ua->id));\n\tmemcpy(&ua->saddr, &x->props.saddr, sizeof(ua->saddr));\n\tmemcpy(&ua->sel, &x->sel, sizeof(ua->sel));\n\tcopy_to_user_policy(xp, &ua->policy, XFRM_POLICY_OUT);\n\tua->aalgos = xt->aalgos;\n\tua->ealgos = xt->ealgos;\n\tua->calgos = xt->calgos;\n\tua->seq = x->km.seq = seq;\n\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_state_sec_ctx(x, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *xt,\n\t\t\t     struct xfrm_policy *xp)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_acquire_msgsize(x, xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_acquire(skb, x, xt, xp) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_ACQUIRE);\n}\n\n/* User gives us xfrm_user_policy_info followed by an array of 0\n * or more templates.\n */\nstatic struct xfrm_policy *xfrm_compile_policy(struct sock *sk, int opt,\n\t\t\t\t\t       u8 *data, int len, int *dir)\n{\n\tstruct net *net = sock_net(sk);\n\tstruct xfrm_userpolicy_info *p = (struct xfrm_userpolicy_info *)data;\n\tstruct xfrm_user_tmpl *ut = (struct xfrm_user_tmpl *) (p + 1);\n\tstruct xfrm_policy *xp;\n\tint nr;\n\n\tswitch (sk->sk_family) {\n\tcase AF_INET:\n\t\tif (opt != IP_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#if IS_ENABLED(CONFIG_IPV6)\n\tcase AF_INET6:\n\t\tif (opt != IPV6_XFRM_POLICY) {\n\t\t\t*dir = -EOPNOTSUPP;\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n#endif\n\tdefault:\n\t\t*dir = -EINVAL;\n\t\treturn NULL;\n\t}\n\n\t*dir = -EINVAL;\n\n\tif (len < sizeof(*p) ||\n\t    verify_newpolicy_info(p))\n\t\treturn NULL;\n\n\tnr = ((len - sizeof(*p)) / sizeof(*ut));\n\tif (validate_tmpl(nr, ut, p->sel.family))\n\t\treturn NULL;\n\n\tif (p->dir > XFRM_POLICY_OUT)\n\t\treturn NULL;\n\n\txp = xfrm_policy_alloc(net, GFP_ATOMIC);\n\tif (xp == NULL) {\n\t\t*dir = -ENOBUFS;\n\t\treturn NULL;\n\t}\n\n\tcopy_from_user_policy(xp, p);\n\txp->type = XFRM_POLICY_TYPE_MAIN;\n\tcopy_templates(xp, ut, nr);\n\n\t*dir = p->dir;\n\n\treturn xp;\n}\n\nstatic inline size_t xfrm_polexpire_msgsize(struct xfrm_policy *xp)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_polexpire))\n\t       + nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr)\n\t       + nla_total_size(xfrm_user_sec_ctx_size(xp->security))\n\t       + nla_total_size(sizeof(struct xfrm_mark))\n\t       + userpolicy_type_attrsize();\n}\n\nstatic int build_polexpire(struct sk_buff *skb, struct xfrm_policy *xp,\n\t\t\t   int dir, const struct km_event *c)\n{\n\tstruct xfrm_user_polexpire *upe;\n\tint hard = c->data.hard;\n\tstruct nlmsghdr *nlh;\n\tint err;\n\n\tnlh = nlmsg_put(skb, c->portid, 0, XFRM_MSG_POLEXPIRE, sizeof(*upe), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tupe = nlmsg_data(nlh);\n\tcopy_to_user_policy(xp, &upe->pol, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_sec_ctx(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err) {\n\t\tnlmsg_cancel(skb, nlh);\n\t\treturn err;\n\t}\n\tupe->hard = !!hard;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_exp_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tstruct net *net = xp_net(xp);\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_polexpire_msgsize(xp), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_polexpire(skb, xp, dir, c) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_EXPIRE);\n}\n\nstatic int xfrm_notify_policy(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\tint len = nla_total_size(sizeof(struct xfrm_user_tmpl) * xp->xfrm_nr);\n\tstruct net *net = xp_net(xp);\n\tstruct xfrm_userpolicy_info *p;\n\tstruct xfrm_userpolicy_id *id;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint headlen, err;\n\n\theadlen = sizeof(*p);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tlen += nla_total_size(headlen);\n\t\theadlen = sizeof(*id);\n\t}\n\tlen += userpolicy_type_attrsize();\n\tlen += nla_total_size(sizeof(struct xfrm_mark));\n\tlen += NLMSG_ALIGN(headlen);\n\n\tskb = nlmsg_new(len, GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, c->event, headlen, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\n\tp = nlmsg_data(nlh);\n\tif (c->event == XFRM_MSG_DELPOLICY) {\n\t\tstruct nlattr *attr;\n\n\t\tid = nlmsg_data(nlh);\n\t\tmemset(id, 0, sizeof(*id));\n\t\tid->dir = dir;\n\t\tif (c->data.byid)\n\t\t\tid->index = xp->index;\n\t\telse\n\t\t\tmemcpy(&id->sel, &xp->selector, sizeof(id->sel));\n\n\t\tattr = nla_reserve(skb, XFRMA_POLICY, sizeof(*p));\n\t\terr = -EMSGSIZE;\n\t\tif (attr == NULL)\n\t\t\tgoto out_free_skb;\n\n\t\tp = nla_data(attr);\n\t}\n\n\tcopy_to_user_policy(xp, p, dir);\n\terr = copy_to_user_tmpl(xp, skb);\n\tif (!err)\n\t\terr = copy_to_user_policy_type(xp->type, skb);\n\tif (!err)\n\t\terr = xfrm_mark_put(skb, &xp->mark);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_POLICY);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_notify_policy_flush(const struct km_event *c)\n{\n\tstruct net *net = c->net;\n\tstruct nlmsghdr *nlh;\n\tstruct sk_buff *skb;\n\tint err;\n\n\tskb = nlmsg_new(userpolicy_type_attrsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tnlh = nlmsg_put(skb, c->portid, c->seq, XFRM_MSG_FLUSHPOLICY, 0, 0);\n\terr = -EMSGSIZE;\n\tif (nlh == NULL)\n\t\tgoto out_free_skb;\n\terr = copy_to_user_policy_type(c->data.type, skb);\n\tif (err)\n\t\tgoto out_free_skb;\n\n\tnlmsg_end(skb, nlh);\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_POLICY);\n\nout_free_skb:\n\tkfree_skb(skb);\n\treturn err;\n}\n\nstatic int xfrm_send_policy_notify(struct xfrm_policy *xp, int dir, const struct km_event *c)\n{\n\n\tswitch (c->event) {\n\tcase XFRM_MSG_NEWPOLICY:\n\tcase XFRM_MSG_UPDPOLICY:\n\tcase XFRM_MSG_DELPOLICY:\n\t\treturn xfrm_notify_policy(xp, dir, c);\n\tcase XFRM_MSG_FLUSHPOLICY:\n\t\treturn xfrm_notify_policy_flush(c);\n\tcase XFRM_MSG_POLEXPIRE:\n\t\treturn xfrm_exp_policy_notify(xp, dir, c);\n\tdefault:\n\t\tprintk(KERN_NOTICE \"xfrm_user: Unknown Policy event %d\\n\",\n\t\t       c->event);\n\t}\n\n\treturn 0;\n\n}\n\nstatic inline size_t xfrm_report_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_report));\n}\n\nstatic int build_report(struct sk_buff *skb, u8 proto,\n\t\t\tstruct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct xfrm_user_report *ur;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_REPORT, sizeof(*ur), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tur = nlmsg_data(nlh);\n\tur->proto = proto;\n\tmemcpy(&ur->sel, sel, sizeof(ur->sel));\n\n\tif (addr) {\n\t\tint err = nla_put(skb, XFRMA_COADDR, sizeof(*addr), addr);\n\t\tif (err) {\n\t\t\tnlmsg_cancel(skb, nlh);\n\t\t\treturn err;\n\t\t}\n\t}\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_send_report(struct net *net, u8 proto,\n\t\t\t    struct xfrm_selector *sel, xfrm_address_t *addr)\n{\n\tstruct sk_buff *skb;\n\n\tskb = nlmsg_new(xfrm_report_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_report(skb, proto, sel, addr) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_REPORT);\n}\n\nstatic inline size_t xfrm_mapping_msgsize(void)\n{\n\treturn NLMSG_ALIGN(sizeof(struct xfrm_user_mapping));\n}\n\nstatic int build_mapping(struct sk_buff *skb, struct xfrm_state *x,\n\t\t\t xfrm_address_t *new_saddr, __be16 new_sport)\n{\n\tstruct xfrm_user_mapping *um;\n\tstruct nlmsghdr *nlh;\n\n\tnlh = nlmsg_put(skb, 0, 0, XFRM_MSG_MAPPING, sizeof(*um), 0);\n\tif (nlh == NULL)\n\t\treturn -EMSGSIZE;\n\n\tum = nlmsg_data(nlh);\n\n\tmemcpy(&um->id.daddr, &x->id.daddr, sizeof(um->id.daddr));\n\tum->id.spi = x->id.spi;\n\tum->id.family = x->props.family;\n\tum->id.proto = x->id.proto;\n\tmemcpy(&um->new_saddr, new_saddr, sizeof(um->new_saddr));\n\tmemcpy(&um->old_saddr, &x->props.saddr, sizeof(um->old_saddr));\n\tum->new_sport = new_sport;\n\tum->old_sport = x->encap->encap_sport;\n\tum->reqid = x->props.reqid;\n\n\tnlmsg_end(skb, nlh);\n\treturn 0;\n}\n\nstatic int xfrm_send_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,\n\t\t\t     __be16 sport)\n{\n\tstruct net *net = xs_net(x);\n\tstruct sk_buff *skb;\n\n\tif (x->id.proto != IPPROTO_ESP)\n\t\treturn -EINVAL;\n\n\tif (!x->encap)\n\t\treturn -EINVAL;\n\n\tskb = nlmsg_new(xfrm_mapping_msgsize(), GFP_ATOMIC);\n\tif (skb == NULL)\n\t\treturn -ENOMEM;\n\n\tif (build_mapping(skb, x, ipaddr, sport) < 0)\n\t\tBUG();\n\n\treturn xfrm_nlmsg_multicast(net, skb, 0, XFRMNLGRP_MAPPING);\n}\n\nstatic bool xfrm_is_alive(const struct km_event *c)\n{\n\treturn (bool)xfrm_acquire_is_on(c->net);\n}\n\nstatic struct xfrm_mgr netlink_mgr = {\n\t.id\t\t= \"netlink\",\n\t.notify\t\t= xfrm_send_state_notify,\n\t.acquire\t= xfrm_send_acquire,\n\t.compile_policy\t= xfrm_compile_policy,\n\t.notify_policy\t= xfrm_send_policy_notify,\n\t.report\t\t= xfrm_send_report,\n\t.migrate\t= xfrm_send_migrate,\n\t.new_mapping\t= xfrm_send_mapping,\n\t.is_alive\t= xfrm_is_alive,\n};\n\nstatic int __net_init xfrm_user_net_init(struct net *net)\n{\n\tstruct sock *nlsk;\n\tstruct netlink_kernel_cfg cfg = {\n\t\t.groups\t= XFRMNLGRP_MAX,\n\t\t.input\t= xfrm_netlink_rcv,\n\t};\n\n\tnlsk = netlink_kernel_create(net, NETLINK_XFRM, &cfg);\n\tif (nlsk == NULL)\n\t\treturn -ENOMEM;\n\tnet->xfrm.nlsk_stash = nlsk; /* Don't set to NULL */\n\trcu_assign_pointer(net->xfrm.nlsk, nlsk);\n\treturn 0;\n}\n\nstatic void __net_exit xfrm_user_net_exit(struct list_head *net_exit_list)\n{\n\tstruct net *net;\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tRCU_INIT_POINTER(net->xfrm.nlsk, NULL);\n\tsynchronize_net();\n\tlist_for_each_entry(net, net_exit_list, exit_list)\n\t\tnetlink_kernel_release(net->xfrm.nlsk_stash);\n}\n\nstatic struct pernet_operations xfrm_user_net_ops = {\n\t.init\t    = xfrm_user_net_init,\n\t.exit_batch = xfrm_user_net_exit,\n};\n\nstatic int __init xfrm_user_init(void)\n{\n\tint rv;\n\n\tprintk(KERN_INFO \"Initializing XFRM netlink socket\\n\");\n\n\trv = register_pernet_subsys(&xfrm_user_net_ops);\n\tif (rv < 0)\n\t\treturn rv;\n\trv = xfrm_register_km(&netlink_mgr);\n\tif (rv < 0)\n\t\tunregister_pernet_subsys(&xfrm_user_net_ops);\n\treturn rv;\n}\n\nstatic void __exit xfrm_user_exit(void)\n{\n\txfrm_unregister_km(&netlink_mgr);\n\tunregister_pernet_subsys(&xfrm_user_net_ops);\n}\n\nmodule_init(xfrm_user_init);\nmodule_exit(xfrm_user_exit);\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS_NET_PF_PROTO(PF_NETLINK, NETLINK_XFRM);\n\n"], "filenames": ["net/xfrm/xfrm_user.c"], "buggy_code_start_loc": [899], "buggy_code_end_loc": [941], "fixing_code_start_loc": [899], "fixing_code_end_loc": [942], "type": "CWE-476", "message": "A NULL pointer dereference vulnerability was found in netlink_dump. This issue can occur when the Netlink socket receives the message(sendmsg) for the XFRM_MSG_GETSA, XFRM_MSG_GETPOLICY type message, and the DUMP flag is set and can cause a denial of service or possibly another unspecified impact. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is unlikely.", "other": {"cve": {"id": "CVE-2023-3106", "sourceIdentifier": "secalert@redhat.com", "published": "2023-07-12T09:15:14.550", "lastModified": "2024-02-15T16:03:47.757", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A NULL pointer dereference vulnerability was found in netlink_dump. This issue can occur when the Netlink socket receives the message(sendmsg) for the XFRM_MSG_GETSA, XFRM_MSG_GETPOLICY type message, and the DUMP flag is set and can cause a denial of service or possibly another unspecified impact. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is unlikely."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "secalert@redhat.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 6.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.7}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.15", "versionEndExcluding": "3.16.39", "matchCriteriaId": "7C441EE1-EC9F-4D9D-95A4-3FD494363278"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "4.4.223", "matchCriteriaId": "8C132AFE-2E0B-47FD-BBAB-B5D5E3AC6DD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.7.10", "matchCriteriaId": "C6C1817C-C779-47B1-B9F7-A77838991F27"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.8:rc1:*:*:*:*:*:*", "matchCriteriaId": "4DCA12A5-2DA5-4357-9C9A-D57CA605BAB0"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.8:rc2:*:*:*:*:*:*", "matchCriteriaId": "9A2F7F5F-5684-4D0A-8AB9-22F739A4CA38"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.8:rc3:*:*:*:*:*:*", "matchCriteriaId": "35868503-6ECC-47B7-A31E-1030CDBD9AC3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.8:rc4:*:*:*:*:*:*", "matchCriteriaId": "5A6BD9A6-A3A8-4277-80ED-A169FD374D5A"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.8:rc5:*:*:*:*:*:*", "matchCriteriaId": "22786B53-9B60-4708-9176-276DF0767E9B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:4.8:rc6:*:*:*:*:*:*", "matchCriteriaId": "1AAE030D-F039-4E93-BFA5-74456E2FC4A5"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}]}]}], "references": [{"url": "https://access.redhat.com/security/cve/CVE-2023-3106", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=2221501", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/1ba5bf993c6a3142e18e68ea6452b347f9cb5635", "source": "secalert@redhat.com", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/1ba5bf993c6a3142e18e68ea6452b347f9cb5635"}}