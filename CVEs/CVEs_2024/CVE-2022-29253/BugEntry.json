{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.skin;\n\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport org.apache.commons.configuration2.BaseConfiguration;\nimport org.apache.commons.configuration2.Configuration;\nimport org.apache.commons.configuration2.builder.fluent.Configurations;\nimport org.apache.commons.configuration2.ex.ConfigurationException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\n\nimport static org.apache.commons.lang3.exception.ExceptionUtils.getRootCauseMessage;\n\n/**\n * Common abstract class for the skins that manipulate resources.\n *\n * @version $Id$\n * @since 13.8RC1\n */\npublic abstract class AbstractResourceSkin extends AbstractSkin\n{\n    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractResourceSkin.class);\n\n    private Configuration properties;\n\n    /**\n     * Default constructor.\n     *\n     * @param id the skin id (for instance, {@code \"flamingo\"})\n     * @param skinManager the skin manager that instantiates this skin\n     * @param configuration the skin internal configuration, used to access the default parent skin id\n     * @param logger a logger used to log warning in case of error when parsin a skin's syntax\n     */\n    public AbstractResourceSkin(String id, InternalSkinManager skinManager,\n        InternalSkinConfiguration configuration, Logger logger)\n    {\n        super(id, skinManager, configuration, logger);\n    }\n\n    abstract AbstractResource<InputSource> createResource(String resourcePath, String resourceName);\n\n    abstract URL getResourceURL(String resourcePath);\n\n    @Override\n    public String getOutputSyntaxString()\n    {\n        return getProperties().getString(\"outputSyntax\");\n    }\n\n    @Override\n    protected Skin createParent()\n    {\n        Skin skin;\n\n        String parentId = getProperties().getString(\"parent\");\n\n        if (parentId != null) {\n            if (parentId.isEmpty()) {\n                // There is explicitly no parent (make sure to not fallback on default parent skin)\n                skin = VOID;\n            } else {\n                skin = this.skinManager.getSkin(parentId);\n            }\n        } else {\n            skin = null;\n        }\n\n        return skin;\n    }\n\n    @Override\n    public Resource<?> getLocalResource(String resourceName)\n    {\n        String resourcePath = getSkinResourcePath(resourceName);\n\n        if (resourcePath != null && getResourceURL(resourcePath) != null) {\n            return createResource(resourcePath, resourceName);\n        }\n\n        return null;\n    }\n\n    protected String getPropertiesPath()\n    {\n        return getSkinFolder() + \"skin.properties\";\n    }\n\n    protected String getSkinFolder()\n    {\n        return \"skins/\" + this.id + '/';\n    }\n\n    protected Configuration getProperties()\n    {\n        if (this.properties == null) {\n            URL url = getResourceURL(getPropertiesPath());\n            if (url != null) {\n                try {\n                    this.properties = new Configurations().properties(url);\n                } catch (ConfigurationException e) {\n                    LOGGER.error(\"Failed to load skin [{}] properties file ([])\", this.id, url,\n                        getRootCauseMessage(e));\n\n                    this.properties = new BaseConfiguration();\n                }\n            } else {\n                LOGGER.debug(\"No properties found for skin [{}]\", this.id);\n\n                this.properties = new BaseConfiguration();\n            }\n        }\n\n        return this.properties;\n    }\n\n    private String getSkinResourcePath(String resource)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = skinFolder + resource;\n\n        // Prevent inclusion of templates from other directories\n        Path normalizedResource = Paths.get(resourcePath).normalize();\n        // Protect against directory attacks.\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);\n            return null;\n        }\n\n        return resourcePath;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.template;\n\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.util.AbstractSet;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.environment.Environment;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.filter.input.InputStreamInputSource;\nimport org.xwiki.filter.input.ReaderInputSource;\nimport org.xwiki.filter.input.StringInputSource;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.properties.BeanManager;\nimport org.xwiki.properties.ConverterManager;\nimport org.xwiki.properties.PropertyException;\nimport org.xwiki.properties.RawProperties;\nimport org.xwiki.properties.annotation.PropertyHidden;\nimport org.xwiki.properties.annotation.PropertyId;\nimport org.xwiki.rendering.async.internal.AsyncRendererConfiguration;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererExecutor;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.CompositeBlock;\nimport org.xwiki.rendering.block.RawBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.parser.ContentParser;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.renderer.printer.WriterWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.rendering.util.ErrorBlockGenerator;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.ResourceRepository;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.template.Template;\nimport org.xwiki.template.TemplateContent;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.internal.skin.AbstractSkinResource;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiResource;\nimport com.xpn.xwiki.user.api.XWikiRightService;\n\n/**\n * Internal toolkit to experiment on templates.\n *\n * @version $Id$\n * @since 7.0M1\n */\n@Component(roles = InternalTemplateManager.class)\n@Singleton\npublic class InternalTemplateManager implements Initializable\n{\n    /**\n     * The reference of the superadmin user.\n     */\n    public static final DocumentReference SUPERADMIN_REFERENCE =\n        new DocumentReference(\"xwiki\", XWiki.SYSTEM_SPACE, XWikiRightService.SUPERADMIN_USER);\n\n    private static final Pattern PROPERTY_LINE = Pattern.compile(\"^##!(.+)=(.*)$\\r?\\n?\", Pattern.MULTILINE);\n\n    private static final String TEMPLATE_RESOURCE_SUFFIX = \"/templates/\";\n\n    @Inject\n    private Environment environment;\n\n    @Inject\n    private ContentParser parser;\n\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Inject\n    private RenderingContext renderingContext;\n\n    @Inject\n    @Named(\"plain/1.0\")\n    private BlockRenderer plainRenderer;\n\n    @Inject\n    @Named(\"xwikicfg\")\n    private ConfigurationSource xwikicfg;\n\n    @Inject\n    @Named(\"all\")\n    private ConfigurationSource allConfiguration;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    @Inject\n    private BeanManager beanManager;\n\n    @Inject\n    private ConverterManager converter;\n\n    @Inject\n    private InternalSkinManager skins;\n\n    @Inject\n    private JobProgressManager progress;\n\n    @Inject\n    private Provider<TemplateAsyncRenderer> rendererProvider;\n\n    @Inject\n    private BlockAsyncRendererExecutor asyncExecutor;\n\n    @Inject\n    private TemplateContext templateContext;\n\n    @Inject\n    private VelocityTemplateEvaluator evaluator;\n\n    @Inject\n    private Provider<ErrorBlockGenerator> errorBlockGeneratorProvider;\n\n    @Inject\n    private Logger logger;\n\n    private String templateRootURL;\n\n    private static abstract class AbtractTemplate<T extends TemplateContent, R extends Resource<?>> implements Template\n    {\n        protected R resource;\n\n        protected T content;\n\n        public AbtractTemplate(R resource)\n        {\n            this.resource = resource;\n        }\n\n        @Override\n        public String getId()\n        {\n            return this.resource.getId();\n        }\n\n        @Override\n        public String getPath()\n        {\n            return this.resource.getPath();\n        }\n\n        @Override\n        public TemplateContent getContent() throws Exception\n        {\n            if (this.content == null) {\n                // TODO: work with streams instead of forcing String\n                String strinContent;\n\n                try (InputSource source = this.resource.getInputSource()) {\n                    if (source instanceof StringInputSource) {\n                        strinContent = source.toString();\n                    } else if (source instanceof ReaderInputSource) {\n                        strinContent = IOUtils.toString(((ReaderInputSource) source).getReader());\n                    } else if (source instanceof InputStreamInputSource) {\n                        // It's impossible to know the real attachment encoding, but let's assume that they respect the\n                        // standard and use UTF-8 (which is required for the files located on the filesystem)\n                        strinContent = IOUtils.toString(((InputStreamInputSource) source).getInputStream(),\n                            StandardCharsets.UTF_8);\n                    } else {\n                        return null;\n                    }\n                }\n\n                this.content = getContentInternal(strinContent);\n            }\n\n            return this.content;\n        }\n\n        protected abstract T getContentInternal(String content) throws Exception;\n\n        @Override\n        public String toString()\n        {\n            return this.resource.getId();\n        }\n    }\n\n    private class EnvironmentTemplate extends AbtractTemplate<FilesystemTemplateContent, AbstractSkinResource>\n    {\n        EnvironmentTemplate(AbstractSkinResource resource)\n        {\n            super(resource);\n        }\n\n        @Override\n        protected FilesystemTemplateContent getContentInternal(String content)\n        {\n            return new FilesystemTemplateContent(content);\n        }\n    }\n\n    private class ClassloaderTemplate extends AbtractTemplate<FilesystemTemplateContent, ClassloaderResource>\n    {\n        ClassloaderTemplate(ClassloaderResource resource)\n        {\n            super(resource);\n        }\n\n        @Override\n        protected FilesystemTemplateContent getContentInternal(String content)\n        {\n            return new FilesystemTemplateContent(content);\n        }\n    }\n\n    private class DefaultTemplate extends AbtractTemplate<DefaultTemplateContent, Resource<?>>\n    {\n        DefaultTemplate(Resource<?> resource)\n        {\n            super(resource);\n        }\n\n        @Override\n        protected DefaultTemplateContent getContentInternal(String content)\n        {\n            if (this.resource instanceof WikiResource) {\n                WikiResource<?> wikiResource = ((WikiResource<?>) this.resource);\n                return new DefaultTemplateContent(content, wikiResource.getAuthorReference(),\n                    wikiResource.getDocumentReference());\n            } else {\n                return new DefaultTemplateContent(content);\n            }\n        }\n    }\n\n    private class StringTemplate extends DefaultTemplate\n    {\n        StringTemplate(String content, DocumentReference authorReference, DocumentReference documentReference)\n            throws Exception\n        {\n            super(new StringResource(content));\n\n            // As StringTemplate extends DefaultTemplate, the TemplateContent is DefaultTemplateContent\n            ((DefaultTemplateContent) this.getContent()).setAuthorReference(authorReference);\n            ((DefaultTemplateContent) this.getContent()).setDocumentReference(documentReference);\n        }\n    }\n\n    private class DefaultTemplateContent implements RawProperties, TemplateContent\n    {\n        // TODO: work with streams instead\n        protected String content;\n\n        protected boolean authorProvided;\n\n        protected DocumentReference authorReference;\n\n        protected DocumentReference documentReference;\n\n        @PropertyId(\"source.syntax\")\n        public Syntax sourceSyntax;\n\n        @PropertyId(\"raw.syntax\")\n        public Syntax rawSyntax;\n\n        public boolean cacheAllowed;\n\n        public boolean asyncAllowed;\n\n        public Set<String> contextEntries;\n\n        public UniqueContext unique;\n\n        protected Map<String, Object> properties = new HashMap<>();\n\n        DefaultTemplateContent(String content)\n        {\n            this.content = content;\n\n            init();\n        }\n\n        DefaultTemplateContent(String content, DocumentReference authorReference)\n        {\n            this(content);\n\n            setAuthorReference(authorReference);\n        }\n\n        DefaultTemplateContent(String content, DocumentReference authorReference, DocumentReference sourceReference)\n        {\n            this(content, authorReference);\n\n            setDocumentReference(sourceReference);\n        }\n\n        @Override\n        public Syntax getSourceSyntax()\n        {\n            return this.sourceSyntax;\n        }\n\n        @Override\n        public Syntax getRawSyntax()\n        {\n            return this.rawSyntax;\n        }\n\n        @Override\n        public boolean isAsyncAllowed()\n        {\n            return this.asyncAllowed;\n        }\n\n        @Override\n        public boolean isCacheAllowed()\n        {\n            return this.cacheAllowed;\n        }\n\n        @Override\n        public UniqueContext getUnique()\n        {\n            return this.unique;\n        }\n\n        @Override\n        public Set<String> getContextEntries()\n        {\n            if (this.contextEntries == null) {\n                return Collections.emptySet();\n            }\n\n            if (this.contextEntries instanceof AbstractSet) {\n                this.contextEntries = Collections.unmodifiableSet(this.contextEntries);\n            }\n\n            return this.contextEntries;\n        }\n\n        @Override\n        public <T> T getProperty(String name, T def)\n        {\n            if (!this.properties.containsKey(name)) {\n                return def;\n            }\n\n            if (def != null) {\n                return getProperty(name, def.getClass());\n            }\n\n            return (T) this.properties.get(name);\n        }\n\n        @Override\n        public <T> T getProperty(String name, Type type)\n        {\n            return converter.convert(type, this.properties.get(name));\n        }\n\n        protected void init()\n        {\n            Matcher matcher = PROPERTY_LINE.matcher(this.content);\n\n            Map<String, String> map = new HashMap<>();\n            while (matcher.find()) {\n                String key = matcher.group(1);\n                String value = matcher.group(2);\n\n                map.put(key, value);\n\n                // Remove the line from the content\n                this.content = this.content.substring(matcher.end());\n            }\n\n            try {\n                InternalTemplateManager.this.beanManager.populate(this, map);\n            } catch (PropertyException e) {\n                // Should never happen\n                InternalTemplateManager.this.logger.error(\"Failed to populate properties of template\", e);\n            }\n        }\n\n        @Override\n        public String getContent()\n        {\n            return this.content;\n        }\n\n        @PropertyHidden\n        @Override\n        public boolean isAuthorProvided()\n        {\n            return this.authorProvided;\n        }\n\n        @PropertyId(\"author\")\n        @Override\n        public DocumentReference getAuthorReference()\n        {\n            return this.authorReference;\n        }\n\n        protected void setAuthorReference(DocumentReference authorReference)\n        {\n            this.authorReference = authorReference;\n            this.authorProvided = true;\n        }\n\n        @Override\n        public DocumentReference getDocumentReference()\n        {\n            return this.documentReference;\n        }\n\n        protected void setDocumentReference(DocumentReference documentReference)\n        {\n            this.documentReference = documentReference;\n        }\n\n        // RawProperties\n\n        @Override\n        public void set(String propertyName, Object value)\n        {\n            this.properties.put(propertyName, value);\n        }\n    }\n\n    private class FilesystemTemplateContent extends DefaultTemplateContent\n    {\n        public FilesystemTemplateContent(String content)\n        {\n            super(content);\n\n            // Give programming right to filesystem templates by default\n            setPrivileged(true);\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Allow filesystem template to indicate the user to executed them with.\n         * </p>\n         *\n         * @see #setAuthorReference(DocumentReference)\n         */\n        @Override\n        public void setAuthorReference(DocumentReference authorReference)\n        {\n            super.setAuthorReference(authorReference);\n        }\n\n        /**\n         * Made public to be seen as bean property.\n         *\n         * @since 6.3.1\n         * @since 6.4M1\n         */\n        @SuppressWarnings(\"unused\")\n        public boolean isPrivileged()\n        {\n            return SUPERADMIN_REFERENCE.equals(getAuthorReference());\n        }\n\n        /**\n         * Made public to be seen as bean property.\n         *\n         * @since 6.3.1\n         * @since 6.4M1\n         */\n        public void setPrivileged(boolean privileged)\n        {\n            if (privileged) {\n                setAuthorReference(SUPERADMIN_REFERENCE);\n            } else {\n                // Reset author\n                this.authorReference = null;\n                this.authorProvided = false;\n            }\n        }\n    }\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        getTemplateRootPath();\n    }\n\n    private String getTemplateRootPath()\n    {\n        if (this.templateRootURL == null) {\n            URL url = this.environment.getResource(TEMPLATE_RESOURCE_SUFFIX);\n\n            if (url != null) {\n                this.templateRootURL = url.toString();\n            }\n        }\n\n        return this.templateRootURL;\n    }\n\n    private String getTemplateResourcePath(String templateName)\n    {\n        String templatePath = TEMPLATE_RESOURCE_SUFFIX + templateName;\n\n        URL templateURL = this.environment.getResource(templatePath);\n\n        // Check if the resource exist\n        if (templateURL == null) {\n            return null;\n        }\n\n        // Prevent inclusion of templates from other directories\n        String rootTemplate = getTemplateRootPath();\n        if (rootTemplate != null) {\n            String templateURLString = templateURL.toString();\n            if (!templateURLString.startsWith(getTemplateRootPath())) {\n                this.logger.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\",\n                    templateURLString);\n\n                return null;\n            }\n        }\n\n        return templatePath;\n    }\n\n    private void renderError(Throwable throwable, boolean inline, Writer writer)\n    {\n        Block block = generateError(throwable, inline);\n\n        render(block, writer);\n    }\n\n    private Block generateError(Throwable throwable, boolean inline)\n    {\n        List<Block> errorBlocks = this.errorBlockGeneratorProvider.get().generateErrorBlocks(inline, null,\n            \"Failed to execute template\", null, throwable);\n\n        if (inline) {\n            if (errorBlocks.size() == 1) {\n                return errorBlocks.get(0);\n            } else {\n                return new CompositeBlock(errorBlocks);\n            }\n        } else {\n            return new XDOM(errorBlocks);\n        }\n    }\n\n    /**\n     * @param templateName the template to parse\n     * @return the result of the template parsing\n     */\n    public XDOM getXDOMNoException(String templateName)\n    {\n        XDOM xdom;\n\n        try {\n            xdom = getXDOM(templateName);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while getting template [{}] XDOM\", templateName, e);\n\n            xdom = (XDOM) generateError(e, false);\n        }\n\n        return xdom;\n    }\n\n    /**\n     * @param template the template to parse\n     * @return the result of the template parsing\n     * @since 8.3RC1\n     */\n    public XDOM getXDOMNoException(Template template)\n    {\n        XDOM xdom;\n\n        try {\n            xdom = getXDOM(template);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while getting template [{}] XDOM\", template.getId(), e);\n\n            xdom = (XDOM) generateError(e, false);\n        }\n\n        return xdom;\n    }\n\n    public XDOM getXDOM(Template template) throws Exception\n    {\n        XDOM xdom;\n\n        if (template != null) {\n            xdom = getXDOM(template, template.getContent());\n        } else {\n            xdom = new XDOM(Collections.<Block>emptyList());\n        }\n\n        return xdom;\n    }\n\n    private XDOM getXDOM(Template template, TemplateContent content) throws Exception\n    {\n        XDOM xdom;\n\n        if (content.getSourceSyntax() != null) {\n            xdom = this.parser.parse(content.getContent(), content.getSourceSyntax());\n        } else {\n            String result = evaluateContent(template, content);\n            if (StringUtils.isEmpty(result)) {\n                xdom = new XDOM(Collections.emptyList());\n            } else {\n                xdom = new XDOM(Arrays.asList(new RawBlock(result, content.getRawSyntax() != null\n                    ? content.getRawSyntax() : this.renderingContext.getTargetSyntax())));\n            }\n        }\n\n        return xdom;\n    }\n\n    public XDOM getXDOM(String templateName) throws Exception\n    {\n        Template template = getTemplate(templateName);\n\n        return getXDOM(template);\n    }\n\n    public String renderNoException(String template, boolean inline)\n    {\n        Writer writer = new StringWriter();\n\n        renderNoException(template, inline, writer);\n\n        return writer.toString();\n    }\n\n    public void renderNoException(String templateName, boolean inline, Writer writer)\n    {\n        try {\n            render(templateName, inline, writer);\n        } catch (Exception e) {\n            this.logger.error(\"Error while rendering template [{}]\", templateName, e);\n\n            renderError(e, inline, writer);\n        }\n    }\n\n    /**\n     * @since 8.3RC1\n     */\n    public void renderNoException(Template template, boolean inline, Writer writer)\n    {\n        try {\n            render(template, inline, writer);\n        } catch (Exception e) {\n            this.logger.error(\"Error while rendering template [{}]\", template, e);\n\n            renderError(e, inline, writer);\n        }\n    }\n\n    public String render(String templateName, boolean inline) throws Exception\n    {\n        return renderFromSkin(templateName, (Skin) null, inline);\n    }\n\n    public String renderFromSkin(String templateName, String skinId, boolean inline) throws Exception\n    {\n        Skin skin = this.skins.getSkin(skinId);\n\n        return skin != null ? renderFromSkin(templateName, skin, inline) : null;\n    }\n\n    public String renderFromSkin(String templateName, Skin skin, boolean inline) throws Exception\n    {\n        Writer writer = new StringWriter();\n\n        renderFromSkin(templateName, skin, inline, writer);\n\n        return writer.toString();\n    }\n\n    public void render(String templateName, boolean inline, Writer writer) throws Exception\n    {\n        renderFromSkin(templateName, null, inline, writer);\n    }\n\n    public void renderFromSkin(final String templateName, ResourceRepository repository, boolean inline,\n        final Writer writer) throws Exception\n    {\n        this.progress.startStep(templateName, \"template.render.message\", \"Render template [{}]\", templateName);\n\n        try {\n            final Template template =\n                repository != null ? getTemplate(templateName, repository) : getTemplate(templateName);\n\n            if (template != null) {\n                render(template, inline, writer);\n            }\n        } finally {\n            this.progress.endStep(templateName);\n        }\n    }\n\n    public void render(Template template, boolean inline, Writer writer) throws Exception\n    {\n        if (!shouldExecute(template)) {\n            return;\n        }\n\n        TemplateAsyncRenderer renderer = this.rendererProvider.get();\n\n        Set<String> contextEntries = renderer.initialize(template, inline, false);\n\n        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();\n\n        configuration.setContextEntries(contextEntries);\n\n        TemplateContent templateContent = template.getContent();\n        if (templateContent.isAuthorProvided()) {\n            configuration.setSecureReference(templateContent.getDocumentReference(),\n                templateContent.getAuthorReference());\n        }\n\n        String result = this.asyncExecutor.render(renderer, configuration);\n\n        writer.append(result);\n    }\n\n    private boolean shouldExecute(Template template) throws Exception\n    {\n        return template != null\n            && (template.getContent().getUnique() == null || !this.templateContext.isExecuted(template));\n    }\n\n    private void render(Block block, Writer writer)\n    {\n        WikiPrinter printer = new WriterWikiPrinter(writer);\n\n        BlockRenderer blockRenderer;\n        try {\n            blockRenderer =\n                this.componentManagerProvider.get().getInstance(BlockRenderer.class, getTargetSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            blockRenderer = this.plainRenderer;\n        }\n\n        blockRenderer.render(block, printer);\n    }\n\n    public Block executeNoException(String templateName, boolean inline)\n    {\n        Block block;\n\n        try {\n            block = execute(templateName, inline);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while executing template [{}]\", templateName, e);\n\n            block = generateError(e, inline);\n        }\n\n        return block;\n    }\n\n    /**\n     * @since 14.0RC1\n     */\n    public Block executeNoException(Template template, boolean inline)\n    {\n        Block block;\n\n        try {\n            block = execute(template, inline);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while executing template [{}]\", template.getId(), e);\n\n            block = generateError(e, inline);\n        }\n\n        return block;\n    }\n\n    /**\n     * @since 14.0RC1\n     */\n    public Block execute(String templateName, boolean inline) throws Exception\n    {\n        final Template template = getTemplate(templateName);\n\n        return execute(template, inline);\n    }\n\n    /**\n     * @since 14.0RC1\n     */\n    public Block execute(Template template, boolean inline) throws Exception\n    {\n        if (!shouldExecute(template)) {\n            return new XDOM(Collections.emptyList());\n        }\n\n        TemplateAsyncRenderer renderer = this.rendererProvider.get();\n\n        Set<String> contextEntries = renderer.initialize(template, inline, true);\n\n        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();\n\n        configuration.setContextEntries(contextEntries);\n\n        if (template.getContent().isAuthorProvided()) {\n            configuration.setSecureReference(template.getContent().getDocumentReference(),\n                template.getContent().getAuthorReference());\n        }\n\n        Block block = this.asyncExecutor.execute(renderer, configuration);\n\n        if (inline) {\n            return block;\n        }\n\n        if (block instanceof XDOM) {\n            return (XDOM) block;\n        }\n\n        return new XDOM(Collections.singletonList(block));\n    }\n\n    private String evaluateContent(Template template, TemplateContent content) throws Exception\n    {\n        Writer writer = new StringWriter();\n\n        this.evaluator.evaluateContent(template, content, writer);\n\n        return writer.toString();\n    }\n\n    private Syntax getTargetSyntax()\n    {\n        Syntax targetSyntax = this.renderingContext.getTargetSyntax();\n\n        return targetSyntax != null ? targetSyntax : Syntax.PLAIN_1_0;\n    }\n\n    private EnvironmentTemplate getFileSystemTemplate(String templateName)\n    {\n        String path = getTemplateResourcePath(templateName);\n\n        return path != null ? new EnvironmentTemplate(new TemplateSkinResource(path, templateName, this.environment))\n            : null;\n    }\n\n    private Template getClassloaderTemplate(String suffixPath, String templateName)\n    {\n        return getClassloaderTemplate(Thread.currentThread().getContextClassLoader(), suffixPath, templateName);\n    }\n\n    private Template getClassloaderTemplate(ClassLoader classloader, String suffixPath, String templateName)\n    {\n        String templatePath = suffixPath + templateName;\n\n        URL url = classloader.getResource(templatePath);\n\n        return url != null ? new ClassloaderTemplate(new ClassloaderResource(url, templateName)) : null;\n    }\n\n    private Template createTemplate(Resource<?> resource)\n    {\n        Template template;\n\n        if (resource instanceof AbstractSkinResource) {\n            template = new EnvironmentTemplate((AbstractSkinResource) resource);\n        } else {\n            template = new DefaultTemplate(resource);\n        }\n\n        return template;\n    }\n\n    public Template getResourceTemplate(String templateName, ResourceRepository repository)\n    {\n        Resource<?> resource = repository.getLocalResource(templateName);\n        if (resource != null) {\n            return createTemplate(resource);\n        }\n\n        return null;\n    }\n\n    public Template getTemplate(String templateName, ResourceRepository repository)\n    {\n        Resource<?> resource = repository.getResource(templateName);\n        if (resource != null) {\n            return createTemplate(resource);\n        }\n\n        return null;\n    }\n\n    public Template getTemplate(String templateName)\n    {\n        Template template = null;\n\n        // Try from skin\n        Skin skin = this.skins.getCurrentSkin(false);\n        if (skin != null) {\n            template = getTemplate(templateName, skin);\n        }\n\n        // Try from base skin if no skin is set\n        if (skin == null) {\n            Skin baseSkin = this.skins.getCurrentParentSkin(false);\n            if (baseSkin != null) {\n                template = getTemplate(templateName, baseSkin);\n            }\n        }\n\n        // Try from /templates/ environment resources\n        if (template == null) {\n            template = getFileSystemTemplate(templateName);\n        }\n\n        // Try from current Thread classloader\n        if (template == null) {\n            template = getClassloaderTemplate(\"templates/\", templateName);\n        }\n\n        return template;\n    }\n\n    /**\n     * Create a new template using a given content and a specific author and source document.\n     *\n     * @param content the template content\n     * @param author the template author\n     * @param sourceReference the reference of the document associated with the {@link Callable} (which will be used to\n     *            test the author right)\n     * @return the template\n     * @throws Exception if an error occurred during template instantiation\n     * @since 14.0RC1\n     */\n    public Template createStringTemplate(String content, DocumentReference author, DocumentReference sourceReference)\n        throws Exception\n    {\n        return new StringTemplate(content, author, sourceReference);\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.skin;\n\nimport java.net.URL;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport org.apache.commons.configuration2.BaseConfiguration;\nimport org.apache.commons.configuration2.Configuration;\nimport org.apache.commons.configuration2.builder.fluent.Configurations;\nimport org.apache.commons.configuration2.ex.ConfigurationException;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.Skin;\n\nimport static org.apache.commons.lang3.exception.ExceptionUtils.getRootCauseMessage;\n\n/**\n * Common abstract class for the skins that manipulate resources.\n *\n * @version $Id$\n * @since 13.8RC1\n */\npublic abstract class AbstractResourceSkin extends AbstractSkin\n{\n    protected static final Logger LOGGER = LoggerFactory.getLogger(AbstractResourceSkin.class);\n\n    private Configuration properties;\n\n    /**\n     * Default constructor.\n     *\n     * @param id the skin id (for instance, {@code \"flamingo\"})\n     * @param skinManager the skin manager that instantiates this skin\n     * @param configuration the skin internal configuration, used to access the default parent skin id\n     * @param logger a logger used to log warning in case of error when parsin a skin's syntax\n     */\n    public AbstractResourceSkin(String id, InternalSkinManager skinManager,\n        InternalSkinConfiguration configuration, Logger logger)\n    {\n        super(id, skinManager, configuration, logger);\n    }\n\n    abstract AbstractResource<InputSource> createResource(String resourcePath, String resourceName);\n\n    abstract URL getResourceURL(String resourcePath);\n\n    @Override\n    public String getOutputSyntaxString()\n    {\n        return getProperties().getString(\"outputSyntax\");\n    }\n\n    @Override\n    protected Skin createParent()\n    {\n        Skin skin;\n\n        String parentId = getProperties().getString(\"parent\");\n\n        if (parentId != null) {\n            if (parentId.isEmpty()) {\n                // There is explicitly no parent (make sure to not fallback on default parent skin)\n                skin = VOID;\n            } else {\n                skin = this.skinManager.getSkin(parentId);\n            }\n        } else {\n            skin = null;\n        }\n\n        return skin;\n    }\n\n    @Override\n    public Resource<?> getLocalResource(String resourceName)\n    {\n        String resourcePath = getSkinResourcePath(resourceName);\n\n        if (resourcePath != null && getResourceURL(resourcePath) != null) {\n            return createResource(resourcePath, resourceName);\n        }\n\n        return null;\n    }\n\n    protected String getPropertiesPath()\n    {\n        return getSkinFolder() + \"skin.properties\";\n    }\n\n    protected String getSkinFolder()\n    {\n        return \"skins/\" + this.id + '/';\n    }\n\n    protected Configuration getProperties()\n    {\n        if (this.properties == null) {\n            URL url = getResourceURL(getPropertiesPath());\n            if (url != null) {\n                try {\n                    this.properties = new Configurations().properties(url);\n                } catch (ConfigurationException e) {\n                    LOGGER.error(\"Failed to load skin [{}] properties file ([])\", this.id, url,\n                        getRootCauseMessage(e));\n\n                    this.properties = new BaseConfiguration();\n                }\n            } else {\n                LOGGER.debug(\"No properties found for skin [{}]\", this.id);\n\n                this.properties = new BaseConfiguration();\n            }\n        }\n\n        return this.properties;\n    }\n\n    private String getSkinResourcePath(String resource)\n    {\n        String skinFolder = getSkinFolder();\n        String resourcePath = skinFolder + resource;\n\n        // Prevent access to resources from other directories\n        Path normalizedResource = Paths.get(resourcePath).normalize();\n        // Protect against directory attacks.\n        if (!normalizedResource.startsWith(skinFolder)) {\n            LOGGER.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);\n            return null;\n        }\n\n        return resourcePath;\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage com.xpn.xwiki.internal.template;\n\nimport java.io.StringWriter;\nimport java.io.Writer;\nimport java.lang.reflect.Type;\nimport java.net.URL;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.AbstractSet;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\nimport javax.inject.Singleton;\n\nimport org.apache.commons.io.IOUtils;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.component.manager.ComponentLookupException;\nimport org.xwiki.component.manager.ComponentManager;\nimport org.xwiki.component.phase.Initializable;\nimport org.xwiki.component.phase.InitializationException;\nimport org.xwiki.configuration.ConfigurationSource;\nimport org.xwiki.environment.Environment;\nimport org.xwiki.filter.input.InputSource;\nimport org.xwiki.filter.input.InputStreamInputSource;\nimport org.xwiki.filter.input.ReaderInputSource;\nimport org.xwiki.filter.input.StringInputSource;\nimport org.xwiki.job.event.status.JobProgressManager;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.DocumentReferenceResolver;\nimport org.xwiki.properties.BeanManager;\nimport org.xwiki.properties.ConverterManager;\nimport org.xwiki.properties.PropertyException;\nimport org.xwiki.properties.RawProperties;\nimport org.xwiki.properties.annotation.PropertyHidden;\nimport org.xwiki.properties.annotation.PropertyId;\nimport org.xwiki.rendering.async.internal.AsyncRendererConfiguration;\nimport org.xwiki.rendering.async.internal.block.BlockAsyncRendererExecutor;\nimport org.xwiki.rendering.block.Block;\nimport org.xwiki.rendering.block.CompositeBlock;\nimport org.xwiki.rendering.block.RawBlock;\nimport org.xwiki.rendering.block.XDOM;\nimport org.xwiki.rendering.parser.ContentParser;\nimport org.xwiki.rendering.renderer.BlockRenderer;\nimport org.xwiki.rendering.renderer.printer.WikiPrinter;\nimport org.xwiki.rendering.renderer.printer.WriterWikiPrinter;\nimport org.xwiki.rendering.syntax.Syntax;\nimport org.xwiki.rendering.transformation.RenderingContext;\nimport org.xwiki.rendering.util.ErrorBlockGenerator;\nimport org.xwiki.skin.Resource;\nimport org.xwiki.skin.ResourceRepository;\nimport org.xwiki.skin.Skin;\nimport org.xwiki.template.Template;\nimport org.xwiki.template.TemplateContent;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.internal.skin.AbstractSkinResource;\nimport com.xpn.xwiki.internal.skin.InternalSkinManager;\nimport com.xpn.xwiki.internal.skin.WikiResource;\nimport com.xpn.xwiki.user.api.XWikiRightService;\n\n/**\n * Internal toolkit to experiment on templates.\n *\n * @version $Id$\n * @since 7.0M1\n */\n@Component(roles = InternalTemplateManager.class)\n@Singleton\npublic class InternalTemplateManager implements Initializable\n{\n    /**\n     * The reference of the superadmin user.\n     */\n    public static final DocumentReference SUPERADMIN_REFERENCE =\n        new DocumentReference(\"xwiki\", XWiki.SYSTEM_SPACE, XWikiRightService.SUPERADMIN_USER);\n\n    private static final Pattern PROPERTY_LINE = Pattern.compile(\"^##!(.+)=(.*)$\\r?\\n?\", Pattern.MULTILINE);\n\n    private static final String TEMPLATE_RESOURCE_SUFFIX = \"/templates/\";\n\n    @Inject\n    private Environment environment;\n\n    @Inject\n    private ContentParser parser;\n\n    @Inject\n    @Named(\"context\")\n    private Provider<ComponentManager> componentManagerProvider;\n\n    @Inject\n    private RenderingContext renderingContext;\n\n    @Inject\n    @Named(\"plain/1.0\")\n    private BlockRenderer plainRenderer;\n\n    @Inject\n    @Named(\"xwikicfg\")\n    private ConfigurationSource xwikicfg;\n\n    @Inject\n    @Named(\"all\")\n    private ConfigurationSource allConfiguration;\n\n    @Inject\n    @Named(\"currentmixed\")\n    private DocumentReferenceResolver<String> currentMixedDocumentReferenceResolver;\n\n    @Inject\n    private BeanManager beanManager;\n\n    @Inject\n    private ConverterManager converter;\n\n    @Inject\n    private InternalSkinManager skins;\n\n    @Inject\n    private JobProgressManager progress;\n\n    @Inject\n    private Provider<TemplateAsyncRenderer> rendererProvider;\n\n    @Inject\n    private BlockAsyncRendererExecutor asyncExecutor;\n\n    @Inject\n    private TemplateContext templateContext;\n\n    @Inject\n    private VelocityTemplateEvaluator evaluator;\n\n    @Inject\n    private Provider<ErrorBlockGenerator> errorBlockGeneratorProvider;\n\n    @Inject\n    private Logger logger;\n\n    private String templateRootURL;\n\n    private static abstract class AbtractTemplate<T extends TemplateContent, R extends Resource<?>> implements Template\n    {\n        protected R resource;\n\n        protected T content;\n\n        public AbtractTemplate(R resource)\n        {\n            this.resource = resource;\n        }\n\n        @Override\n        public String getId()\n        {\n            return this.resource.getId();\n        }\n\n        @Override\n        public String getPath()\n        {\n            return this.resource.getPath();\n        }\n\n        @Override\n        public TemplateContent getContent() throws Exception\n        {\n            if (this.content == null) {\n                // TODO: work with streams instead of forcing String\n                String strinContent;\n\n                try (InputSource source = this.resource.getInputSource()) {\n                    if (source instanceof StringInputSource) {\n                        strinContent = source.toString();\n                    } else if (source instanceof ReaderInputSource) {\n                        strinContent = IOUtils.toString(((ReaderInputSource) source).getReader());\n                    } else if (source instanceof InputStreamInputSource) {\n                        // It's impossible to know the real attachment encoding, but let's assume that they respect the\n                        // standard and use UTF-8 (which is required for the files located on the filesystem)\n                        strinContent = IOUtils.toString(((InputStreamInputSource) source).getInputStream(),\n                            StandardCharsets.UTF_8);\n                    } else {\n                        return null;\n                    }\n                }\n\n                this.content = getContentInternal(strinContent);\n            }\n\n            return this.content;\n        }\n\n        protected abstract T getContentInternal(String content) throws Exception;\n\n        @Override\n        public String toString()\n        {\n            return this.resource.getId();\n        }\n    }\n\n    private class EnvironmentTemplate extends AbtractTemplate<FilesystemTemplateContent, AbstractSkinResource>\n    {\n        EnvironmentTemplate(AbstractSkinResource resource)\n        {\n            super(resource);\n        }\n\n        @Override\n        protected FilesystemTemplateContent getContentInternal(String content)\n        {\n            return new FilesystemTemplateContent(content);\n        }\n    }\n\n    private class ClassloaderTemplate extends AbtractTemplate<FilesystemTemplateContent, ClassloaderResource>\n    {\n        ClassloaderTemplate(ClassloaderResource resource)\n        {\n            super(resource);\n        }\n\n        @Override\n        protected FilesystemTemplateContent getContentInternal(String content)\n        {\n            return new FilesystemTemplateContent(content);\n        }\n    }\n\n    private class DefaultTemplate extends AbtractTemplate<DefaultTemplateContent, Resource<?>>\n    {\n        DefaultTemplate(Resource<?> resource)\n        {\n            super(resource);\n        }\n\n        @Override\n        protected DefaultTemplateContent getContentInternal(String content)\n        {\n            if (this.resource instanceof WikiResource) {\n                WikiResource<?> wikiResource = ((WikiResource<?>) this.resource);\n                return new DefaultTemplateContent(content, wikiResource.getAuthorReference(),\n                    wikiResource.getDocumentReference());\n            } else {\n                return new DefaultTemplateContent(content);\n            }\n        }\n    }\n\n    private class StringTemplate extends DefaultTemplate\n    {\n        StringTemplate(String content, DocumentReference authorReference, DocumentReference documentReference)\n            throws Exception\n        {\n            super(new StringResource(content));\n\n            // As StringTemplate extends DefaultTemplate, the TemplateContent is DefaultTemplateContent\n            ((DefaultTemplateContent) this.getContent()).setAuthorReference(authorReference);\n            ((DefaultTemplateContent) this.getContent()).setDocumentReference(documentReference);\n        }\n    }\n\n    private class DefaultTemplateContent implements RawProperties, TemplateContent\n    {\n        // TODO: work with streams instead\n        protected String content;\n\n        protected boolean authorProvided;\n\n        protected DocumentReference authorReference;\n\n        protected DocumentReference documentReference;\n\n        @PropertyId(\"source.syntax\")\n        public Syntax sourceSyntax;\n\n        @PropertyId(\"raw.syntax\")\n        public Syntax rawSyntax;\n\n        public boolean cacheAllowed;\n\n        public boolean asyncAllowed;\n\n        public Set<String> contextEntries;\n\n        public UniqueContext unique;\n\n        protected Map<String, Object> properties = new HashMap<>();\n\n        DefaultTemplateContent(String content)\n        {\n            this.content = content;\n\n            init();\n        }\n\n        DefaultTemplateContent(String content, DocumentReference authorReference)\n        {\n            this(content);\n\n            setAuthorReference(authorReference);\n        }\n\n        DefaultTemplateContent(String content, DocumentReference authorReference, DocumentReference sourceReference)\n        {\n            this(content, authorReference);\n\n            setDocumentReference(sourceReference);\n        }\n\n        @Override\n        public Syntax getSourceSyntax()\n        {\n            return this.sourceSyntax;\n        }\n\n        @Override\n        public Syntax getRawSyntax()\n        {\n            return this.rawSyntax;\n        }\n\n        @Override\n        public boolean isAsyncAllowed()\n        {\n            return this.asyncAllowed;\n        }\n\n        @Override\n        public boolean isCacheAllowed()\n        {\n            return this.cacheAllowed;\n        }\n\n        @Override\n        public UniqueContext getUnique()\n        {\n            return this.unique;\n        }\n\n        @Override\n        public Set<String> getContextEntries()\n        {\n            if (this.contextEntries == null) {\n                return Collections.emptySet();\n            }\n\n            if (this.contextEntries instanceof AbstractSet) {\n                this.contextEntries = Collections.unmodifiableSet(this.contextEntries);\n            }\n\n            return this.contextEntries;\n        }\n\n        @Override\n        public <T> T getProperty(String name, T def)\n        {\n            if (!this.properties.containsKey(name)) {\n                return def;\n            }\n\n            if (def != null) {\n                return getProperty(name, def.getClass());\n            }\n\n            return (T) this.properties.get(name);\n        }\n\n        @Override\n        public <T> T getProperty(String name, Type type)\n        {\n            return converter.convert(type, this.properties.get(name));\n        }\n\n        protected void init()\n        {\n            Matcher matcher = PROPERTY_LINE.matcher(this.content);\n\n            Map<String, String> map = new HashMap<>();\n            while (matcher.find()) {\n                String key = matcher.group(1);\n                String value = matcher.group(2);\n\n                map.put(key, value);\n\n                // Remove the line from the content\n                this.content = this.content.substring(matcher.end());\n            }\n\n            try {\n                InternalTemplateManager.this.beanManager.populate(this, map);\n            } catch (PropertyException e) {\n                // Should never happen\n                InternalTemplateManager.this.logger.error(\"Failed to populate properties of template\", e);\n            }\n        }\n\n        @Override\n        public String getContent()\n        {\n            return this.content;\n        }\n\n        @PropertyHidden\n        @Override\n        public boolean isAuthorProvided()\n        {\n            return this.authorProvided;\n        }\n\n        @PropertyId(\"author\")\n        @Override\n        public DocumentReference getAuthorReference()\n        {\n            return this.authorReference;\n        }\n\n        protected void setAuthorReference(DocumentReference authorReference)\n        {\n            this.authorReference = authorReference;\n            this.authorProvided = true;\n        }\n\n        @Override\n        public DocumentReference getDocumentReference()\n        {\n            return this.documentReference;\n        }\n\n        protected void setDocumentReference(DocumentReference documentReference)\n        {\n            this.documentReference = documentReference;\n        }\n\n        // RawProperties\n\n        @Override\n        public void set(String propertyName, Object value)\n        {\n            this.properties.put(propertyName, value);\n        }\n    }\n\n    private class FilesystemTemplateContent extends DefaultTemplateContent\n    {\n        public FilesystemTemplateContent(String content)\n        {\n            super(content);\n\n            // Give programming right to filesystem templates by default\n            setPrivileged(true);\n        }\n\n        /**\n         * {@inheritDoc}\n         * <p>\n         * Allow filesystem template to indicate the user to executed them with.\n         * </p>\n         *\n         * @see #setAuthorReference(DocumentReference)\n         */\n        @Override\n        public void setAuthorReference(DocumentReference authorReference)\n        {\n            super.setAuthorReference(authorReference);\n        }\n\n        /**\n         * Made public to be seen as bean property.\n         *\n         * @since 6.3.1\n         * @since 6.4M1\n         */\n        @SuppressWarnings(\"unused\")\n        public boolean isPrivileged()\n        {\n            return SUPERADMIN_REFERENCE.equals(getAuthorReference());\n        }\n\n        /**\n         * Made public to be seen as bean property.\n         *\n         * @since 6.3.1\n         * @since 6.4M1\n         */\n        public void setPrivileged(boolean privileged)\n        {\n            if (privileged) {\n                setAuthorReference(SUPERADMIN_REFERENCE);\n            } else {\n                // Reset author\n                this.authorReference = null;\n                this.authorProvided = false;\n            }\n        }\n    }\n\n    @Override\n    public void initialize() throws InitializationException\n    {\n        getTemplateRootPath();\n    }\n\n    private String getTemplateRootPath()\n    {\n        if (this.templateRootURL == null) {\n            URL url = this.environment.getResource(TEMPLATE_RESOURCE_SUFFIX);\n\n            if (url != null) {\n                this.templateRootURL = url.toString();\n            }\n        }\n\n        return this.templateRootURL;\n    }\n\n    private String getTemplateResourcePath(String templateName)\n    {\n        String templatePath = TEMPLATE_RESOURCE_SUFFIX + templateName;\n\n        URL templateURL = this.environment.getResource(templatePath);\n\n        // Check if the resource exist\n        if (templateURL == null) {\n            return null;\n        }\n\n        // Prevent inclusion of templates from other directories\n        String rootTemplate = getTemplateRootPath();\n        if (rootTemplate != null) {\n            String templateURLString = templateURL.toString();\n            if (!templateURLString.startsWith(getTemplateRootPath())) {\n                this.logger.warn(\"Direct access to template file [{}] refused. Possible break-in attempt!\",\n                    templateURLString);\n\n                return null;\n            }\n        }\n\n        return templatePath;\n    }\n\n    private void renderError(Throwable throwable, boolean inline, Writer writer)\n    {\n        Block block = generateError(throwable, inline);\n\n        render(block, writer);\n    }\n\n    private Block generateError(Throwable throwable, boolean inline)\n    {\n        List<Block> errorBlocks = this.errorBlockGeneratorProvider.get().generateErrorBlocks(inline, null,\n            \"Failed to execute template\", null, throwable);\n\n        if (inline) {\n            if (errorBlocks.size() == 1) {\n                return errorBlocks.get(0);\n            } else {\n                return new CompositeBlock(errorBlocks);\n            }\n        } else {\n            return new XDOM(errorBlocks);\n        }\n    }\n\n    /**\n     * @param templateName the template to parse\n     * @return the result of the template parsing\n     */\n    public XDOM getXDOMNoException(String templateName)\n    {\n        XDOM xdom;\n\n        try {\n            xdom = getXDOM(templateName);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while getting template [{}] XDOM\", templateName, e);\n\n            xdom = (XDOM) generateError(e, false);\n        }\n\n        return xdom;\n    }\n\n    /**\n     * @param template the template to parse\n     * @return the result of the template parsing\n     * @since 8.3RC1\n     */\n    public XDOM getXDOMNoException(Template template)\n    {\n        XDOM xdom;\n\n        try {\n            xdom = getXDOM(template);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while getting template [{}] XDOM\", template.getId(), e);\n\n            xdom = (XDOM) generateError(e, false);\n        }\n\n        return xdom;\n    }\n\n    public XDOM getXDOM(Template template) throws Exception\n    {\n        XDOM xdom;\n\n        if (template != null) {\n            xdom = getXDOM(template, template.getContent());\n        } else {\n            xdom = new XDOM(Collections.<Block>emptyList());\n        }\n\n        return xdom;\n    }\n\n    private XDOM getXDOM(Template template, TemplateContent content) throws Exception\n    {\n        XDOM xdom;\n\n        if (content.getSourceSyntax() != null) {\n            xdom = this.parser.parse(content.getContent(), content.getSourceSyntax());\n        } else {\n            String result = evaluateContent(template, content);\n            if (StringUtils.isEmpty(result)) {\n                xdom = new XDOM(Collections.emptyList());\n            } else {\n                xdom = new XDOM(Arrays.asList(new RawBlock(result, content.getRawSyntax() != null\n                    ? content.getRawSyntax() : this.renderingContext.getTargetSyntax())));\n            }\n        }\n\n        return xdom;\n    }\n\n    public XDOM getXDOM(String templateName) throws Exception\n    {\n        Template template = getTemplate(templateName);\n\n        return getXDOM(template);\n    }\n\n    public String renderNoException(String template, boolean inline)\n    {\n        Writer writer = new StringWriter();\n\n        renderNoException(template, inline, writer);\n\n        return writer.toString();\n    }\n\n    public void renderNoException(String templateName, boolean inline, Writer writer)\n    {\n        try {\n            render(templateName, inline, writer);\n        } catch (Exception e) {\n            this.logger.error(\"Error while rendering template [{}]\", templateName, e);\n\n            renderError(e, inline, writer);\n        }\n    }\n\n    /**\n     * @since 8.3RC1\n     */\n    public void renderNoException(Template template, boolean inline, Writer writer)\n    {\n        try {\n            render(template, inline, writer);\n        } catch (Exception e) {\n            this.logger.error(\"Error while rendering template [{}]\", template, e);\n\n            renderError(e, inline, writer);\n        }\n    }\n\n    public String render(String templateName, boolean inline) throws Exception\n    {\n        return renderFromSkin(templateName, (Skin) null, inline);\n    }\n\n    public String renderFromSkin(String templateName, String skinId, boolean inline) throws Exception\n    {\n        Skin skin = this.skins.getSkin(skinId);\n\n        return skin != null ? renderFromSkin(templateName, skin, inline) : null;\n    }\n\n    public String renderFromSkin(String templateName, Skin skin, boolean inline) throws Exception\n    {\n        Writer writer = new StringWriter();\n\n        renderFromSkin(templateName, skin, inline, writer);\n\n        return writer.toString();\n    }\n\n    public void render(String templateName, boolean inline, Writer writer) throws Exception\n    {\n        renderFromSkin(templateName, null, inline, writer);\n    }\n\n    public void renderFromSkin(final String templateName, ResourceRepository repository, boolean inline,\n        final Writer writer) throws Exception\n    {\n        this.progress.startStep(templateName, \"template.render.message\", \"Render template [{}]\", templateName);\n\n        try {\n            final Template template =\n                repository != null ? getTemplate(templateName, repository) : getTemplate(templateName);\n\n            if (template != null) {\n                render(template, inline, writer);\n            }\n        } finally {\n            this.progress.endStep(templateName);\n        }\n    }\n\n    public void render(Template template, boolean inline, Writer writer) throws Exception\n    {\n        if (!shouldExecute(template)) {\n            return;\n        }\n\n        TemplateAsyncRenderer renderer = this.rendererProvider.get();\n\n        Set<String> contextEntries = renderer.initialize(template, inline, false);\n\n        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();\n\n        configuration.setContextEntries(contextEntries);\n\n        TemplateContent templateContent = template.getContent();\n        if (templateContent.isAuthorProvided()) {\n            configuration.setSecureReference(templateContent.getDocumentReference(),\n                templateContent.getAuthorReference());\n        }\n\n        String result = this.asyncExecutor.render(renderer, configuration);\n\n        writer.append(result);\n    }\n\n    private boolean shouldExecute(Template template) throws Exception\n    {\n        return template != null\n            && (template.getContent().getUnique() == null || !this.templateContext.isExecuted(template));\n    }\n\n    private void render(Block block, Writer writer)\n    {\n        WikiPrinter printer = new WriterWikiPrinter(writer);\n\n        BlockRenderer blockRenderer;\n        try {\n            blockRenderer =\n                this.componentManagerProvider.get().getInstance(BlockRenderer.class, getTargetSyntax().toIdString());\n        } catch (ComponentLookupException e) {\n            blockRenderer = this.plainRenderer;\n        }\n\n        blockRenderer.render(block, printer);\n    }\n\n    public Block executeNoException(String templateName, boolean inline)\n    {\n        Block block;\n\n        try {\n            block = execute(templateName, inline);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while executing template [{}]\", templateName, e);\n\n            block = generateError(e, inline);\n        }\n\n        return block;\n    }\n\n    /**\n     * @since 14.0RC1\n     */\n    public Block executeNoException(Template template, boolean inline)\n    {\n        Block block;\n\n        try {\n            block = execute(template, inline);\n        } catch (Throwable e) {\n            this.logger.error(\"Error while executing template [{}]\", template.getId(), e);\n\n            block = generateError(e, inline);\n        }\n\n        return block;\n    }\n\n    /**\n     * @since 14.0RC1\n     */\n    public Block execute(String templateName, boolean inline) throws Exception\n    {\n        final Template template = getTemplate(templateName);\n\n        return execute(template, inline);\n    }\n\n    /**\n     * @since 14.0RC1\n     */\n    public Block execute(Template template, boolean inline) throws Exception\n    {\n        if (!shouldExecute(template)) {\n            return new XDOM(Collections.emptyList());\n        }\n\n        TemplateAsyncRenderer renderer = this.rendererProvider.get();\n\n        Set<String> contextEntries = renderer.initialize(template, inline, true);\n\n        AsyncRendererConfiguration configuration = new AsyncRendererConfiguration();\n\n        configuration.setContextEntries(contextEntries);\n\n        if (template.getContent().isAuthorProvided()) {\n            configuration.setSecureReference(template.getContent().getDocumentReference(),\n                template.getContent().getAuthorReference());\n        }\n\n        Block block = this.asyncExecutor.execute(renderer, configuration);\n\n        if (inline) {\n            return block;\n        }\n\n        if (block instanceof XDOM) {\n            return (XDOM) block;\n        }\n\n        return new XDOM(Collections.singletonList(block));\n    }\n\n    private String evaluateContent(Template template, TemplateContent content) throws Exception\n    {\n        Writer writer = new StringWriter();\n\n        this.evaluator.evaluateContent(template, content, writer);\n\n        return writer.toString();\n    }\n\n    private Syntax getTargetSyntax()\n    {\n        Syntax targetSyntax = this.renderingContext.getTargetSyntax();\n\n        return targetSyntax != null ? targetSyntax : Syntax.PLAIN_1_0;\n    }\n\n    private EnvironmentTemplate getFileSystemTemplate(String templateName)\n    {\n        String path = getTemplateResourcePath(templateName);\n\n        return path != null ? new EnvironmentTemplate(new TemplateSkinResource(path, templateName, this.environment))\n            : null;\n    }\n\n    private Template getClassloaderTemplate(String prefixPath, String templateName)\n    {\n        return getClassloaderTemplate(Thread.currentThread().getContextClassLoader(), prefixPath, templateName);\n    }\n\n    private Template getClassloaderTemplate(ClassLoader classloader, String prefixPath, String templateName)\n    {\n        String templatePath = prefixPath + templateName;\n\n        // Prevent access to resources from other directories\n        Path normalizedResource = Paths.get(templatePath).normalize();\n        // Protect against directory attacks.\n        if (!normalizedResource.startsWith(prefixPath)) {\n            this.logger.warn(\"Direct access to skin file [{}] refused. Possible break-in attempt!\", normalizedResource);\n\n            return null;\n        }\n\n        URL url = classloader.getResource(templatePath);\n\n        return url != null ? new ClassloaderTemplate(new ClassloaderResource(url, templateName)) : null;\n    }\n\n    private Template createTemplate(Resource<?> resource)\n    {\n        Template template;\n\n        if (resource instanceof AbstractSkinResource) {\n            template = new EnvironmentTemplate((AbstractSkinResource) resource);\n        } else {\n            template = new DefaultTemplate(resource);\n        }\n\n        return template;\n    }\n\n    public Template getResourceTemplate(String templateName, ResourceRepository repository)\n    {\n        Resource<?> resource = repository.getLocalResource(templateName);\n        if (resource != null) {\n            return createTemplate(resource);\n        }\n\n        return null;\n    }\n\n    public Template getTemplate(String templateName, ResourceRepository repository)\n    {\n        Resource<?> resource = repository.getResource(templateName);\n        if (resource != null) {\n            return createTemplate(resource);\n        }\n\n        return null;\n    }\n\n    public Template getTemplate(String templateName)\n    {\n        Template template = null;\n\n        // Try from skin\n        Skin skin = this.skins.getCurrentSkin(false);\n        if (skin != null) {\n            template = getTemplate(templateName, skin);\n        }\n\n        // Try from base skin if no skin is set\n        if (skin == null) {\n            Skin baseSkin = this.skins.getCurrentParentSkin(false);\n            if (baseSkin != null) {\n                template = getTemplate(templateName, baseSkin);\n            }\n        }\n\n        // Try from /templates/ environment resources\n        if (template == null) {\n            template = getFileSystemTemplate(templateName);\n        }\n\n        // Try from current Thread classloader\n        if (template == null) {\n            template = getClassloaderTemplate(\"templates/\", templateName);\n        }\n\n        return template;\n    }\n\n    /**\n     * Create a new template using a given content and a specific author and source document.\n     *\n     * @param content the template content\n     * @param author the template author\n     * @param sourceReference the reference of the document associated with the {@link Callable} (which will be used to\n     *            test the author right)\n     * @return the template\n     * @throws Exception if an error occurred during template instantiation\n     * @since 14.0RC1\n     */\n    public Template createStringTemplate(String content, DocumentReference author, DocumentReference sourceReference)\n        throws Exception\n    {\n        return new StringTemplate(content, author, sourceReference);\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/internal/skin/AbstractResourceSkin.java", "xwiki-platform-core/xwiki-platform-oldcore/src/main/java/com/xpn/xwiki/internal/template/InternalTemplateManager.java"], "buggy_code_start_loc": [145, 26], "buggy_code_end_loc": [146, 907], "fixing_code_start_loc": [145, 27], "fixing_code_end_loc": [146, 918], "type": "CWE-22", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting with version 8.3-rc-1 and prior to versions 12.10.3 and 14.0, one can ask for any file located in the classloader using the template API and a path with \"..\" in it. The issue is patched in versions 14.0 and 13.10.3. There is no easy workaround for this issue.", "other": {"cve": {"id": "CVE-2022-29253", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-25T21:15:08.470", "lastModified": "2022-06-07T19:48:48.287", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting with version 8.3-rc-1 and prior to versions 12.10.3 and 14.0, one can ask for any file located in the classloader using the template API and a path with \"..\" in it. The issue is patched in versions 14.0 and 13.10.3. There is no easy workaround for this issue."}, {"lang": "es", "value": "La plataforma XWiki es una plataforma wiki gen\u00e9rica que ofrece servicios de tiempo de ejecuci\u00f3n para las aplicaciones construidas sobre ella. A partir de la versi\u00f3n 8.3-rc-1 y en versiones anteriores a 12.10.3 y 14.0, puede solicitarse cualquier archivo ubicado en el cargador de clases usando la API de plantillas y una ruta con \"..\" en ella. El problema est\u00e1 parcheado en las versiones 14.0 y 13.10.3. No se presenta una mitigaci\u00f3n f\u00e1cil para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.7, "baseSeverity": "LOW"}, "exploitabilityScore": 1.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}, {"lang": "en", "value": "CWE-24"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "8.4", "versionEndExcluding": "13.10.3", "matchCriteriaId": "0171AD53-37B6-4C36-8F83-4BDE9C69A85D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:8.3:rc1:*:*:*:*:*:*", "matchCriteriaId": "49DDDADA-8295-4CF6-946D-3C1592095B6C"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/4917c8f355717bb636d763844528b1fe0f95e8e2", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-9qrp-h7fw-42hg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-19349", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/4917c8f355717bb636d763844528b1fe0f95e8e2"}}