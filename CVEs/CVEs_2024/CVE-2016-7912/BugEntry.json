{"buggy_code": ["/*\n * f_fs.c -- user mode file system API for USB composite function controllers\n *\n * Copyright (C) 2010 Samsung Electronics\n * Author: Michal Nazarewicz <mina86@mina86.com>\n *\n * Based on inode.c (GadgetFS) which was:\n * Copyright (C) 2003-2004 David Brownell\n * Copyright (C) 2003 Agilent Technologies\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n\n/* #define DEBUG */\n/* #define VERBOSE_DEBUG */\n\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/uio.h>\n#include <asm/unaligned.h>\n\n#include <linux/usb/composite.h>\n#include <linux/usb/functionfs.h>\n\n#include <linux/aio.h>\n#include <linux/mmu_context.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n\n#include \"u_fs.h\"\n#include \"u_f.h\"\n#include \"u_os_desc.h\"\n#include \"configfs.h\"\n\n#define FUNCTIONFS_MAGIC\t0xa647361 /* Chosen by a honest dice roll ;) */\n\n/* Reference counter handling */\nstatic void ffs_data_get(struct ffs_data *ffs);\nstatic void ffs_data_put(struct ffs_data *ffs);\n/* Creates new ffs_data object. */\nstatic struct ffs_data *__must_check ffs_data_new(void) __attribute__((malloc));\n\n/* Opened counter handling. */\nstatic void ffs_data_opened(struct ffs_data *ffs);\nstatic void ffs_data_closed(struct ffs_data *ffs);\n\n/* Called with ffs->mutex held; take over ownership of data. */\nstatic int __must_check\n__ffs_data_got_descs(struct ffs_data *ffs, char *data, size_t len);\nstatic int __must_check\n__ffs_data_got_strings(struct ffs_data *ffs, char *data, size_t len);\n\n\n/* The function structure ***************************************************/\n\nstruct ffs_ep;\n\nstruct ffs_function {\n\tstruct usb_configuration\t*conf;\n\tstruct usb_gadget\t\t*gadget;\n\tstruct ffs_data\t\t\t*ffs;\n\n\tstruct ffs_ep\t\t\t*eps;\n\tu8\t\t\t\teps_revmap[16];\n\tshort\t\t\t\t*interfaces_nums;\n\n\tstruct usb_function\t\tfunction;\n};\n\n\nstatic struct ffs_function *ffs_func_from_usb(struct usb_function *f)\n{\n\treturn container_of(f, struct ffs_function, function);\n}\n\n\nstatic inline enum ffs_setup_state\nffs_setup_state_clear_cancelled(struct ffs_data *ffs)\n{\n\treturn (enum ffs_setup_state)\n\t\tcmpxchg(&ffs->setup_state, FFS_SETUP_CANCELLED, FFS_NO_SETUP);\n}\n\n\nstatic void ffs_func_eps_disable(struct ffs_function *func);\nstatic int __must_check ffs_func_eps_enable(struct ffs_function *func);\n\nstatic int ffs_func_bind(struct usb_configuration *,\n\t\t\t struct usb_function *);\nstatic int ffs_func_set_alt(struct usb_function *, unsigned, unsigned);\nstatic void ffs_func_disable(struct usb_function *);\nstatic int ffs_func_setup(struct usb_function *,\n\t\t\t  const struct usb_ctrlrequest *);\nstatic void ffs_func_suspend(struct usb_function *);\nstatic void ffs_func_resume(struct usb_function *);\n\n\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num);\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf);\n\n\n/* The endpoints structures *************************************************/\n\nstruct ffs_ep {\n\tstruct usb_ep\t\t\t*ep;\t/* P: ffs->eps_lock */\n\tstruct usb_request\t\t*req;\t/* P: epfile->mutex */\n\n\t/* [0]: full speed, [1]: high speed, [2]: super speed */\n\tstruct usb_endpoint_descriptor\t*descs[3];\n\n\tu8\t\t\t\tnum;\n\n\tint\t\t\t\tstatus;\t/* P: epfile->mutex */\n};\n\nstruct ffs_epfile {\n\t/* Protects ep->ep and ep->req. */\n\tstruct mutex\t\t\tmutex;\n\twait_queue_head_t\t\twait;\n\n\tstruct ffs_data\t\t\t*ffs;\n\tstruct ffs_ep\t\t\t*ep;\t/* P: ffs->eps_lock */\n\n\tstruct dentry\t\t\t*dentry;\n\n\tchar\t\t\t\tname[5];\n\n\tunsigned char\t\t\tin;\t/* P: ffs->eps_lock */\n\tunsigned char\t\t\tisoc;\t/* P: ffs->eps_lock */\n\n\tunsigned char\t\t\t_pad;\n};\n\n/*  ffs_io_data structure ***************************************************/\n\nstruct ffs_io_data {\n\tbool aio;\n\tbool read;\n\n\tstruct kiocb *kiocb;\n\tstruct iov_iter data;\n\tconst void *to_free;\n\tchar *buf;\n\n\tstruct mm_struct *mm;\n\tstruct work_struct work;\n\n\tstruct usb_ep *ep;\n\tstruct usb_request *req;\n\n\tstruct ffs_data *ffs;\n};\n\nstruct ffs_desc_helper {\n\tstruct ffs_data *ffs;\n\tunsigned interfaces_count;\n\tunsigned eps_count;\n};\n\nstatic int  __must_check ffs_epfiles_create(struct ffs_data *ffs);\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count);\n\nstatic struct dentry *\nffs_sb_create_file(struct super_block *sb, const char *name, void *data,\n\t\t   const struct file_operations *fops);\n\n/* Devices management *******************************************************/\n\nDEFINE_MUTEX(ffs_lock);\nEXPORT_SYMBOL_GPL(ffs_lock);\n\nstatic struct ffs_dev *_ffs_find_dev(const char *name);\nstatic struct ffs_dev *_ffs_alloc_dev(void);\nstatic int _ffs_name_dev(struct ffs_dev *dev, const char *name);\nstatic void _ffs_free_dev(struct ffs_dev *dev);\nstatic void *ffs_acquire_dev(const char *dev_name);\nstatic void ffs_release_dev(struct ffs_data *ffs_data);\nstatic int ffs_ready(struct ffs_data *ffs);\nstatic void ffs_closed(struct ffs_data *ffs);\n\n/* Misc helper functions ****************************************************/\n\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\n\t__attribute__((warn_unused_result, nonnull));\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\n\t__attribute__((warn_unused_result, nonnull));\n\n\n/* Control file aka ep0 *****************************************************/\n\nstatic void ffs_ep0_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ffs_data *ffs = req->context;\n\n\tcomplete_all(&ffs->ep0req_completion);\n}\n\nstatic int __ffs_ep0_queue_wait(struct ffs_data *ffs, char *data, size_t len)\n{\n\tstruct usb_request *req = ffs->ep0req;\n\tint ret;\n\n\treq->zero     = len < le16_to_cpu(ffs->ev.setup.wLength);\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\treq->buf      = data;\n\treq->length   = len;\n\n\t/*\n\t * UDC layer requires to provide a buffer even for ZLP, but should\n\t * not use it at all. Let's provide some poisoned pointer to catch\n\t * possible bug in the driver.\n\t */\n\tif (req->buf == NULL)\n\t\treq->buf = (void *)0xDEADBABE;\n\n\treinit_completion(&ffs->ep0req_completion);\n\n\tret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = wait_for_completion_interruptible(&ffs->ep0req_completion);\n\tif (unlikely(ret)) {\n\t\tusb_ep_dequeue(ffs->gadget->ep0, req);\n\t\treturn -EINTR;\n\t}\n\n\tffs->setup_state = FFS_NO_SETUP;\n\treturn req->status ? req->status : req->actual;\n}\n\nstatic int __ffs_ep0_stall(struct ffs_data *ffs)\n{\n\tif (ffs->ev.can_stall) {\n\t\tpr_vdebug(\"ep0 stall\\n\");\n\t\tusb_ep_set_halt(ffs->gadget->ep0);\n\t\tffs->setup_state = FFS_NO_SETUP;\n\t\treturn -EL2HLT;\n\t} else {\n\t\tpr_debug(\"bogus ep0 stall!\\n\");\n\t\treturn -ESRCH;\n\t}\n}\n\nstatic ssize_t ffs_ep0_write(struct file *file, const char __user *buf,\n\t\t\t     size_t len, loff_t *ptr)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tssize_t ret;\n\tchar *data;\n\n\tENTER();\n\n\t/* Fast check if setup was canceled */\n\tif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\n\t\treturn -EIDRM;\n\n\t/* Acquire mutex */\n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\t/* Check state */\n\tswitch (ffs->state) {\n\tcase FFS_READ_DESCRIPTORS:\n\tcase FFS_READ_STRINGS:\n\t\t/* Copy data */\n\t\tif (unlikely(len < 16)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata = ffs_prepare_buffer(buf, len);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Handle data */\n\t\tif (ffs->state == FFS_READ_DESCRIPTORS) {\n\t\t\tpr_info(\"read descriptors\\n\");\n\t\t\tret = __ffs_data_got_descs(ffs, data, len);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\tbreak;\n\n\t\t\tffs->state = FFS_READ_STRINGS;\n\t\t\tret = len;\n\t\t} else {\n\t\t\tpr_info(\"read strings\\n\");\n\t\t\tret = __ffs_data_got_strings(ffs, data, len);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\tbreak;\n\n\t\t\tret = ffs_epfiles_create(ffs);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tffs->state = FFS_CLOSING;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tffs->state = FFS_ACTIVE;\n\t\t\tmutex_unlock(&ffs->mutex);\n\n\t\t\tret = ffs_ready(ffs);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tffs->state = FFS_CLOSING;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t\tbreak;\n\n\tcase FFS_ACTIVE:\n\t\tdata = NULL;\n\t\t/*\n\t\t * We're called from user space, we can use _irq\n\t\t * rather then _irqsave\n\t\t */\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\t\tswitch (ffs_setup_state_clear_cancelled(ffs)) {\n\t\tcase FFS_SETUP_CANCELLED:\n\t\t\tret = -EIDRM;\n\t\t\tgoto done_spin;\n\n\t\tcase FFS_NO_SETUP:\n\t\t\tret = -ESRCH;\n\t\t\tgoto done_spin;\n\n\t\tcase FFS_SETUP_PENDING:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* FFS_SETUP_PENDING */\n\t\tif (!(ffs->ev.setup.bRequestType & USB_DIR_IN)) {\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t\tret = __ffs_ep0_stall(ffs);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* FFS_SETUP_PENDING and not stall */\n\t\tlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\n\n\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\t\tdata = ffs_prepare_buffer(buf, len);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\t\t/*\n\t\t * We are guaranteed to be still in FFS_ACTIVE state\n\t\t * but the state of setup could have changed from\n\t\t * FFS_SETUP_PENDING to FFS_SETUP_CANCELLED so we need\n\t\t * to check for that.  If that happened we copied data\n\t\t * from user space in vain but it's unlikely.\n\t\t *\n\t\t * For sure we are not in FFS_NO_SETUP since this is\n\t\t * the only place FFS_SETUP_PENDING -> FFS_NO_SETUP\n\t\t * transition can be performed and it's protected by\n\t\t * mutex.\n\t\t */\n\t\tif (ffs_setup_state_clear_cancelled(ffs) ==\n\t\t    FFS_SETUP_CANCELLED) {\n\t\t\tret = -EIDRM;\ndone_spin:\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t} else {\n\t\t\t/* unlocks spinlock */\n\t\t\tret = __ffs_ep0_queue_wait(ffs, data, len);\n\t\t}\n\t\tkfree(data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EBADFD;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ffs->mutex);\n\treturn ret;\n}\n\n/* Called with ffs->ev.waitq.lock and ffs->mutex held, both released on exit. */\nstatic ssize_t __ffs_ep0_read_events(struct ffs_data *ffs, char __user *buf,\n\t\t\t\t     size_t n)\n{\n\t/*\n\t * n cannot be bigger than ffs->ev.count, which cannot be bigger than\n\t * size of ffs->ev.types array (which is four) so that's how much space\n\t * we reserve.\n\t */\n\tstruct usb_functionfs_event events[ARRAY_SIZE(ffs->ev.types)];\n\tconst size_t size = n * sizeof *events;\n\tunsigned i = 0;\n\n\tmemset(events, 0, size);\n\n\tdo {\n\t\tevents[i].type = ffs->ev.types[i];\n\t\tif (events[i].type == FUNCTIONFS_SETUP) {\n\t\t\tevents[i].u.setup = ffs->ev.setup;\n\t\t\tffs->setup_state = FFS_SETUP_PENDING;\n\t\t}\n\t} while (++i < n);\n\n\tffs->ev.count -= n;\n\tif (ffs->ev.count)\n\t\tmemmove(ffs->ev.types, ffs->ev.types + n,\n\t\t\tffs->ev.count * sizeof *ffs->ev.types);\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\tmutex_unlock(&ffs->mutex);\n\n\treturn unlikely(copy_to_user(buf, events, size)) ? -EFAULT : size;\n}\n\nstatic ssize_t ffs_ep0_read(struct file *file, char __user *buf,\n\t\t\t    size_t len, loff_t *ptr)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tchar *data = NULL;\n\tsize_t n;\n\tint ret;\n\n\tENTER();\n\n\t/* Fast check if setup was canceled */\n\tif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\n\t\treturn -EIDRM;\n\n\t/* Acquire mutex */\n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\t/* Check state */\n\tif (ffs->state != FFS_ACTIVE) {\n\t\tret = -EBADFD;\n\t\tgoto done_mutex;\n\t}\n\n\t/*\n\t * We're called from user space, we can use _irq rather then\n\t * _irqsave\n\t */\n\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\tswitch (ffs_setup_state_clear_cancelled(ffs)) {\n\tcase FFS_SETUP_CANCELLED:\n\t\tret = -EIDRM;\n\t\tbreak;\n\n\tcase FFS_NO_SETUP:\n\t\tn = len / sizeof(struct usb_functionfs_event);\n\t\tif (unlikely(!n)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((file->f_flags & O_NONBLOCK) && !ffs->ev.count) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wait_event_interruptible_exclusive_locked_irq(ffs->ev.waitq,\n\t\t\t\t\t\t\tffs->ev.count)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn __ffs_ep0_read_events(ffs, buf,\n\t\t\t\t\t     min(n, (size_t)ffs->ev.count));\n\n\tcase FFS_SETUP_PENDING:\n\t\tif (ffs->ev.setup.bRequestType & USB_DIR_IN) {\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t\tret = __ffs_ep0_stall(ffs);\n\t\t\tgoto done_mutex;\n\t\t}\n\n\t\tlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\n\n\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\t\tif (likely(len)) {\n\t\t\tdata = kmalloc(len, GFP_KERNEL);\n\t\t\tif (unlikely(!data)) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done_mutex;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\t\t/* See ffs_ep0_write() */\n\t\tif (ffs_setup_state_clear_cancelled(ffs) ==\n\t\t    FFS_SETUP_CANCELLED) {\n\t\t\tret = -EIDRM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* unlocks spinlock */\n\t\tret = __ffs_ep0_queue_wait(ffs, data, len);\n\t\tif (likely(ret > 0) && unlikely(copy_to_user(buf, data, len)))\n\t\t\tret = -EFAULT;\n\t\tgoto done_mutex;\n\n\tdefault:\n\t\tret = -EBADFD;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\ndone_mutex:\n\tmutex_unlock(&ffs->mutex);\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int ffs_ep0_open(struct inode *inode, struct file *file)\n{\n\tstruct ffs_data *ffs = inode->i_private;\n\n\tENTER();\n\n\tif (unlikely(ffs->state == FFS_CLOSING))\n\t\treturn -EBUSY;\n\n\tfile->private_data = ffs;\n\tffs_data_opened(ffs);\n\n\treturn 0;\n}\n\nstatic int ffs_ep0_release(struct inode *inode, struct file *file)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\n\tENTER();\n\n\tffs_data_closed(ffs);\n\n\treturn 0;\n}\n\nstatic long ffs_ep0_ioctl(struct file *file, unsigned code, unsigned long value)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tstruct usb_gadget *gadget = ffs->gadget;\n\tlong ret;\n\n\tENTER();\n\n\tif (code == FUNCTIONFS_INTERFACE_REVMAP) {\n\t\tstruct ffs_function *func = ffs->func;\n\t\tret = func ? ffs_func_revmap_intf(func, value) : -ENODEV;\n\t} else if (gadget && gadget->ops->ioctl) {\n\t\tret = gadget->ops->ioctl(gadget, code, value);\n\t} else {\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned int ffs_ep0_poll(struct file *file, poll_table *wait)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tunsigned int mask = POLLWRNORM;\n\tint ret;\n\n\tpoll_wait(file, &ffs->ev.waitq, wait);\n\n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret < 0))\n\t\treturn mask;\n\n\tswitch (ffs->state) {\n\tcase FFS_READ_DESCRIPTORS:\n\tcase FFS_READ_STRINGS:\n\t\tmask |= POLLOUT;\n\t\tbreak;\n\n\tcase FFS_ACTIVE:\n\t\tswitch (ffs->setup_state) {\n\t\tcase FFS_NO_SETUP:\n\t\t\tif (ffs->ev.count)\n\t\t\t\tmask |= POLLIN;\n\t\t\tbreak;\n\n\t\tcase FFS_SETUP_PENDING:\n\t\tcase FFS_SETUP_CANCELLED:\n\t\t\tmask |= (POLLIN | POLLOUT);\n\t\t\tbreak;\n\t\t}\n\tcase FFS_CLOSING:\n\t\tbreak;\n\tcase FFS_DEACTIVATED:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ffs->mutex);\n\n\treturn mask;\n}\n\nstatic const struct file_operations ffs_ep0_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tffs_ep0_open,\n\t.write =\tffs_ep0_write,\n\t.read =\t\tffs_ep0_read,\n\t.release =\tffs_ep0_release,\n\t.unlocked_ioctl =\tffs_ep0_ioctl,\n\t.poll =\t\tffs_ep0_poll,\n};\n\n\n/* \"Normal\" endpoints operations ********************************************/\n\nstatic void ffs_epfile_io_complete(struct usb_ep *_ep, struct usb_request *req)\n{\n\tENTER();\n\tif (likely(req->context)) {\n\t\tstruct ffs_ep *ep = _ep->driver_data;\n\t\tep->status = req->status ? req->status : req->actual;\n\t\tcomplete(req->context);\n\t}\n}\n\nstatic void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd &&\n\t    !(io_data->kiocb->ki_flags & IOCB_EVENTFD))\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tio_data->kiocb->private = NULL;\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}\n\nstatic void ffs_epfile_async_io_complete(struct usb_ep *_ep,\n\t\t\t\t\t struct usb_request *req)\n{\n\tstruct ffs_io_data *io_data = req->context;\n\n\tENTER();\n\n\tINIT_WORK(&io_data->work, ffs_user_copy_worker);\n\tschedule_work(&io_data->work);\n}\n\nstatic ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)\n{\n\tstruct ffs_epfile *epfile = file->private_data;\n\tstruct usb_request *req;\n\tstruct ffs_ep *ep;\n\tchar *data = NULL;\n\tssize_t ret, data_len = -EINVAL;\n\tint halt;\n\n\t/* Are we still active? */\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\t/* Wait for endpoint to be enabled */\n\tep = epfile->ep;\n\tif (!ep) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(epfile->wait, (ep = epfile->ep));\n\t\tif (ret)\n\t\t\treturn -EINTR;\n\t}\n\n\t/* Do we halt? */\n\thalt = (!io_data->read == !epfile->in);\n\tif (halt && epfile->isoc)\n\t\treturn -EINVAL;\n\n\t/* Allocate & copy */\n\tif (!halt) {\n\t\t/*\n\t\t * if we _do_ wait above, the epfile->ffs->gadget might be NULL\n\t\t * before the waiting completes, so do not assign to 'gadget'\n\t\t * earlier\n\t\t */\n\t\tstruct usb_gadget *gadget = epfile->ffs->gadget;\n\t\tsize_t copied;\n\n\t\tspin_lock_irq(&epfile->ffs->eps_lock);\n\t\t/* In the meantime, endpoint got disabled or changed. */\n\t\tif (epfile->ep != ep) {\n\t\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\t\t\treturn -ESHUTDOWN;\n\t\t}\n\t\tdata_len = iov_iter_count(&io_data->data);\n\t\t/*\n\t\t * Controller may require buffer size to be aligned to\n\t\t * maxpacketsize of an out endpoint.\n\t\t */\n\t\tif (io_data->read)\n\t\t\tdata_len = usb_ep_align_maybe(gadget, ep->ep, data_len);\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\t\tdata = kmalloc(data_len, GFP_KERNEL);\n\t\tif (unlikely(!data))\n\t\t\treturn -ENOMEM;\n\t\tif (!io_data->read) {\n\t\t\tcopied = copy_from_iter(data, data_len, &io_data->data);\n\t\t\tif (copied != data_len) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* We will be using request */\n\tret = ffs_mutex_lock(&epfile->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret))\n\t\tgoto error;\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\n\tif (epfile->ep != ep) {\n\t\t/* In the meantime, endpoint got disabled or changed. */\n\t\tret = -ESHUTDOWN;\n\t} else if (halt) {\n\t\t/* Halt */\n\t\tif (likely(epfile->ep == ep) && !WARN_ON(!ep->ep))\n\t\t\tusb_ep_set_halt(ep->ep);\n\t\tret = -EBADMSG;\n\t} else if (unlikely(data_len == -EINVAL)) {\n\t\t/*\n\t\t * Sanity Check: even though data_len can't be used\n\t\t * uninitialized at the time I write this comment, some\n\t\t * compilers complain about this situation.\n\t\t * In order to keep the code clean from warnings, data_len is\n\t\t * being initialized to -EINVAL during its declaration, which\n\t\t * means we can't rely on compiler anymore to warn no future\n\t\t * changes won't result in data_len being used uninitialized.\n\t\t * For such reason, we're adding this redundant sanity check\n\t\t * here.\n\t\t */\n\t\tWARN(1, \"%s: data_len == -EINVAL\\n\", __func__);\n\t\tret = -EINVAL;\n\t} else if (!io_data->aio) {\n\t\tDECLARE_COMPLETION_ONSTACK(done);\n\t\tbool interrupted = false;\n\n\t\treq = ep->req;\n\t\treq->buf      = data;\n\t\treq->length   = data_len;\n\n\t\treq->context  = &done;\n\t\treq->complete = ffs_epfile_io_complete;\n\n\t\tret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error_lock;\n\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\t\tif (unlikely(wait_for_completion_interruptible(&done))) {\n\t\t\t/*\n\t\t\t * To avoid race condition with ffs_epfile_io_complete,\n\t\t\t * dequeue the request first then check\n\t\t\t * status. usb_ep_dequeue API should guarantee no race\n\t\t\t * condition with req->complete callback.\n\t\t\t */\n\t\t\tusb_ep_dequeue(ep->ep, req);\n\t\t\tinterrupted = ep->status < 0;\n\t\t}\n\n\t\t/*\n\t\t * XXX We may end up silently droping data here.  Since data_len\n\t\t * (i.e. req->length) may be bigger than len (after being\n\t\t * rounded up to maxpacketsize), we may end up with more data\n\t\t * then user space has space for.\n\t\t */\n\t\tret = interrupted ? -EINTR : ep->status;\n\t\tif (io_data->read && ret > 0) {\n\t\t\tret = copy_to_iter(data, ret, &io_data->data);\n\t\t\tif (!ret)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t\tgoto error_mutex;\n\t} else if (!(req = usb_ep_alloc_request(ep->ep, GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t} else {\n\t\treq->buf      = data;\n\t\treq->length   = data_len;\n\n\t\tio_data->buf = data;\n\t\tio_data->ep = ep->ep;\n\t\tio_data->req = req;\n\t\tio_data->ffs = epfile->ffs;\n\n\t\treq->context  = io_data;\n\t\treq->complete = ffs_epfile_async_io_complete;\n\n\t\tret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\n\t\tif (unlikely(ret)) {\n\t\t\tusb_ep_free_request(ep->ep, req);\n\t\t\tgoto error_lock;\n\t\t}\n\n\t\tret = -EIOCBQUEUED;\n\t\t/*\n\t\t * Do not kfree the buffer in this function.  It will be freed\n\t\t * by ffs_user_copy_worker.\n\t\t */\n\t\tdata = NULL;\n\t}\n\nerror_lock:\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\nerror_mutex:\n\tmutex_unlock(&epfile->mutex);\nerror:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int\nffs_epfile_open(struct inode *inode, struct file *file)\n{\n\tstruct ffs_epfile *epfile = inode->i_private;\n\n\tENTER();\n\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\tfile->private_data = epfile;\n\tffs_data_opened(epfile->ffs);\n\n\treturn 0;\n}\n\nstatic int ffs_aio_cancel(struct kiocb *kiocb)\n{\n\tstruct ffs_io_data *io_data = kiocb->private;\n\tstruct ffs_epfile *epfile = kiocb->ki_filp->private_data;\n\tint value;\n\n\tENTER();\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\n\tif (likely(io_data && io_data->ep && io_data->req))\n\t\tvalue = usb_ep_dequeue(io_data->ep, io_data->req);\n\telse\n\t\tvalue = -EINVAL;\n\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\treturn value;\n}\n\nstatic ssize_t ffs_epfile_write_iter(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tENTER();\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kmalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tp->aio = false;\n\t}\n\n\tp->read = false;\n\tp->kiocb = kiocb;\n\tp->data = *from;\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n\tif (res == -EIOCBQUEUED)\n\t\treturn res;\n\tif (p->aio)\n\t\tkfree(p);\n\telse\n\t\t*from = p->data;\n\treturn res;\n}\n\nstatic ssize_t ffs_epfile_read_iter(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tENTER();\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kmalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tp->aio = false;\n\t}\n\n\tp->read = true;\n\tp->kiocb = kiocb;\n\tif (p->aio) {\n\t\tp->to_free = dup_iter(&p->data, to, GFP_KERNEL);\n\t\tif (!p->to_free) {\n\t\t\tkfree(p);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tp->data = *to;\n\t\tp->to_free = NULL;\n\t}\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n\tif (res == -EIOCBQUEUED)\n\t\treturn res;\n\n\tif (p->aio) {\n\t\tkfree(p->to_free);\n\t\tkfree(p);\n\t} else {\n\t\t*to = p->data;\n\t}\n\treturn res;\n}\n\nstatic int\nffs_epfile_release(struct inode *inode, struct file *file)\n{\n\tstruct ffs_epfile *epfile = inode->i_private;\n\n\tENTER();\n\n\tffs_data_closed(epfile->ffs);\n\n\treturn 0;\n}\n\nstatic long ffs_epfile_ioctl(struct file *file, unsigned code,\n\t\t\t     unsigned long value)\n{\n\tstruct ffs_epfile *epfile = file->private_data;\n\tint ret;\n\n\tENTER();\n\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\tif (likely(epfile->ep)) {\n\t\tswitch (code) {\n\t\tcase FUNCTIONFS_FIFO_STATUS:\n\t\t\tret = usb_ep_fifo_status(epfile->ep->ep);\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_FIFO_FLUSH:\n\t\t\tusb_ep_fifo_flush(epfile->ep->ep);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_CLEAR_HALT:\n\t\t\tret = usb_ep_clear_halt(epfile->ep->ep);\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_ENDPOINT_REVMAP:\n\t\t\tret = epfile->ep->num;\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_ENDPOINT_DESC:\n\t\t{\n\t\t\tint desc_idx;\n\t\t\tstruct usb_endpoint_descriptor *desc;\n\n\t\t\tswitch (epfile->ffs->gadget->speed) {\n\t\t\tcase USB_SPEED_SUPER:\n\t\t\t\tdesc_idx = 2;\n\t\t\t\tbreak;\n\t\t\tcase USB_SPEED_HIGH:\n\t\t\t\tdesc_idx = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdesc_idx = 0;\n\t\t\t}\n\t\t\tdesc = epfile->ep->descs[desc_idx];\n\n\t\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\t\t\tret = copy_to_user((void *)value, desc, sizeof(*desc));\n\t\t\tif (ret)\n\t\t\t\tret = -EFAULT;\n\t\t\treturn ret;\n\t\t}\n\t\tdefault:\n\t\t\tret = -ENOTTY;\n\t\t}\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\treturn ret;\n}\n\nstatic const struct file_operations ffs_epfile_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tffs_epfile_open,\n\t.write_iter =\tffs_epfile_write_iter,\n\t.read_iter =\tffs_epfile_read_iter,\n\t.release =\tffs_epfile_release,\n\t.unlocked_ioctl =\tffs_epfile_ioctl,\n};\n\n\n/* File system and super block operations ***********************************/\n\n/*\n * Mounting the file system creates a controller file, used first for\n * function configuration then later for event monitoring.\n */\n\nstatic struct inode *__must_check\nffs_sb_make_inode(struct super_block *sb, void *data,\n\t\t  const struct file_operations *fops,\n\t\t  const struct inode_operations *iops,\n\t\t  struct ffs_file_perms *perms)\n{\n\tstruct inode *inode;\n\n\tENTER();\n\n\tinode = new_inode(sb);\n\n\tif (likely(inode)) {\n\t\tstruct timespec current_time = CURRENT_TIME;\n\n\t\tinode->i_ino\t = get_next_ino();\n\t\tinode->i_mode    = perms->mode;\n\t\tinode->i_uid     = perms->uid;\n\t\tinode->i_gid     = perms->gid;\n\t\tinode->i_atime   = current_time;\n\t\tinode->i_mtime   = current_time;\n\t\tinode->i_ctime   = current_time;\n\t\tinode->i_private = data;\n\t\tif (fops)\n\t\t\tinode->i_fop = fops;\n\t\tif (iops)\n\t\t\tinode->i_op  = iops;\n\t}\n\n\treturn inode;\n}\n\n/* Create \"regular\" file */\nstatic struct dentry *ffs_sb_create_file(struct super_block *sb,\n\t\t\t\t\tconst char *name, void *data,\n\t\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct ffs_data\t*ffs = sb->s_fs_info;\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\n\tENTER();\n\n\tdentry = d_alloc_name(sb->s_root, name);\n\tif (unlikely(!dentry))\n\t\treturn NULL;\n\n\tinode = ffs_sb_make_inode(sb, data, fops, NULL, &ffs->file_perms);\n\tif (unlikely(!inode)) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\td_add(dentry, inode);\n\treturn dentry;\n}\n\n/* Super block */\nstatic const struct super_operations ffs_sb_operations = {\n\t.statfs =\tsimple_statfs,\n\t.drop_inode =\tgeneric_delete_inode,\n};\n\nstruct ffs_sb_fill_data {\n\tstruct ffs_file_perms perms;\n\tumode_t root_mode;\n\tconst char *dev_name;\n\tbool no_disconnect;\n\tstruct ffs_data *ffs_data;\n};\n\nstatic int ffs_sb_fill(struct super_block *sb, void *_data, int silent)\n{\n\tstruct ffs_sb_fill_data *data = _data;\n\tstruct inode\t*inode;\n\tstruct ffs_data\t*ffs = data->ffs_data;\n\n\tENTER();\n\n\tffs->sb              = sb;\n\tdata->ffs_data       = NULL;\n\tsb->s_fs_info        = ffs;\n\tsb->s_blocksize      = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic          = FUNCTIONFS_MAGIC;\n\tsb->s_op             = &ffs_sb_operations;\n\tsb->s_time_gran      = 1;\n\n\t/* Root inode */\n\tdata->perms.mode = data->root_mode;\n\tinode = ffs_sb_make_inode(sb, NULL,\n\t\t\t\t  &simple_dir_operations,\n\t\t\t\t  &simple_dir_inode_operations,\n\t\t\t\t  &data->perms);\n\tsb->s_root = d_make_root(inode);\n\tif (unlikely(!sb->s_root))\n\t\treturn -ENOMEM;\n\n\t/* EP0 file */\n\tif (unlikely(!ffs_sb_create_file(sb, \"ep0\", ffs,\n\t\t\t\t\t &ffs_ep0_operations)))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts)\n{\n\tENTER();\n\n\tif (!opts || !*opts)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tunsigned long value;\n\t\tchar *eq, *comma;\n\n\t\t/* Option limit */\n\t\tcomma = strchr(opts, ',');\n\t\tif (comma)\n\t\t\t*comma = 0;\n\n\t\t/* Value limit */\n\t\teq = strchr(opts, '=');\n\t\tif (unlikely(!eq)) {\n\t\t\tpr_err(\"'=' missing in %s\\n\", opts);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*eq = 0;\n\n\t\t/* Parse value */\n\t\tif (kstrtoul(eq + 1, 0, &value)) {\n\t\t\tpr_err(\"%s: invalid value: %s\\n\", opts, eq + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Interpret option */\n\t\tswitch (eq - opts) {\n\t\tcase 13:\n\t\t\tif (!memcmp(opts, \"no_disconnect\", 13))\n\t\t\t\tdata->no_disconnect = !!value;\n\t\t\telse\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (!memcmp(opts, \"rmode\", 5))\n\t\t\t\tdata->root_mode  = (value & 0555) | S_IFDIR;\n\t\t\telse if (!memcmp(opts, \"fmode\", 5))\n\t\t\t\tdata->perms.mode = (value & 0666) | S_IFREG;\n\t\t\telse\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tif (!memcmp(opts, \"mode\", 4)) {\n\t\t\t\tdata->root_mode  = (value & 0555) | S_IFDIR;\n\t\t\t\tdata->perms.mode = (value & 0666) | S_IFREG;\n\t\t\t} else {\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tif (!memcmp(opts, \"uid\", 3)) {\n\t\t\t\tdata->perms.uid = make_kuid(current_user_ns(), value);\n\t\t\t\tif (!uid_valid(data->perms.uid)) {\n\t\t\t\t\tpr_err(\"%s: unmapped value: %lu\\n\", opts, value);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else if (!memcmp(opts, \"gid\", 3)) {\n\t\t\t\tdata->perms.gid = make_kgid(current_user_ns(), value);\n\t\t\t\tif (!gid_valid(data->perms.gid)) {\n\t\t\t\t\tpr_err(\"%s: unmapped value: %lu\\n\", opts, value);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\ninvalid:\n\t\t\tpr_err(\"%s: invalid option\\n\", opts);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Next iteration */\n\t\tif (!comma)\n\t\t\tbreak;\n\t\topts = comma + 1;\n\t}\n\n\treturn 0;\n}\n\n/* \"mount -t functionfs dev_name /dev/function\" ends up here */\n\nstatic struct dentry *\nffs_fs_mount(struct file_system_type *t, int flags,\n\t      const char *dev_name, void *opts)\n{\n\tstruct ffs_sb_fill_data data = {\n\t\t.perms = {\n\t\t\t.mode = S_IFREG | 0600,\n\t\t\t.uid = GLOBAL_ROOT_UID,\n\t\t\t.gid = GLOBAL_ROOT_GID,\n\t\t},\n\t\t.root_mode = S_IFDIR | 0500,\n\t\t.no_disconnect = false,\n\t};\n\tstruct dentry *rv;\n\tint ret;\n\tvoid *ffs_dev;\n\tstruct ffs_data\t*ffs;\n\n\tENTER();\n\n\tret = ffs_fs_parse_opts(&data, opts);\n\tif (unlikely(ret < 0))\n\t\treturn ERR_PTR(ret);\n\n\tffs = ffs_data_new();\n\tif (unlikely(!ffs))\n\t\treturn ERR_PTR(-ENOMEM);\n\tffs->file_perms = data.perms;\n\tffs->no_disconnect = data.no_disconnect;\n\n\tffs->dev_name = kstrdup(dev_name, GFP_KERNEL);\n\tif (unlikely(!ffs->dev_name)) {\n\t\tffs_data_put(ffs);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tffs_dev = ffs_acquire_dev(dev_name);\n\tif (IS_ERR(ffs_dev)) {\n\t\tffs_data_put(ffs);\n\t\treturn ERR_CAST(ffs_dev);\n\t}\n\tffs->private_data = ffs_dev;\n\tdata.ffs_data = ffs;\n\n\trv = mount_nodev(t, flags, &data, ffs_sb_fill);\n\tif (IS_ERR(rv) && data.ffs_data) {\n\t\tffs_release_dev(data.ffs_data);\n\t\tffs_data_put(data.ffs_data);\n\t}\n\treturn rv;\n}\n\nstatic void\nffs_fs_kill_sb(struct super_block *sb)\n{\n\tENTER();\n\n\tkill_litter_super(sb);\n\tif (sb->s_fs_info) {\n\t\tffs_release_dev(sb->s_fs_info);\n\t\tffs_data_closed(sb->s_fs_info);\n\t\tffs_data_put(sb->s_fs_info);\n\t}\n}\n\nstatic struct file_system_type ffs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"functionfs\",\n\t.mount\t\t= ffs_fs_mount,\n\t.kill_sb\t= ffs_fs_kill_sb,\n};\nMODULE_ALIAS_FS(\"functionfs\");\n\n\n/* Driver's main init/cleanup functions *************************************/\n\nstatic int functionfs_init(void)\n{\n\tint ret;\n\n\tENTER();\n\n\tret = register_filesystem(&ffs_fs_type);\n\tif (likely(!ret))\n\t\tpr_info(\"file system registered\\n\");\n\telse\n\t\tpr_err(\"failed registering file system (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void functionfs_cleanup(void)\n{\n\tENTER();\n\n\tpr_info(\"unloading\\n\");\n\tunregister_filesystem(&ffs_fs_type);\n}\n\n\n/* ffs_data and ffs_function construction and destruction code **************/\n\nstatic void ffs_data_clear(struct ffs_data *ffs);\nstatic void ffs_data_reset(struct ffs_data *ffs);\n\nstatic void ffs_data_get(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tatomic_inc(&ffs->ref);\n}\n\nstatic void ffs_data_opened(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tatomic_inc(&ffs->ref);\n\tif (atomic_add_return(1, &ffs->opened) == 1 &&\n\t\t\tffs->state == FFS_DEACTIVATED) {\n\t\tffs->state = FFS_CLOSING;\n\t\tffs_data_reset(ffs);\n\t}\n}\n\nstatic void ffs_data_put(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tif (unlikely(atomic_dec_and_test(&ffs->ref))) {\n\t\tpr_info(\"%s(): freeing\\n\", __func__);\n\t\tffs_data_clear(ffs);\n\t\tBUG_ON(waitqueue_active(&ffs->ev.waitq) ||\n\t\t       waitqueue_active(&ffs->ep0req_completion.wait));\n\t\tkfree(ffs->dev_name);\n\t\tkfree(ffs);\n\t}\n}\n\nstatic void ffs_data_closed(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tif (atomic_dec_and_test(&ffs->opened)) {\n\t\tif (ffs->no_disconnect) {\n\t\t\tffs->state = FFS_DEACTIVATED;\n\t\t\tif (ffs->epfiles) {\n\t\t\t\tffs_epfiles_destroy(ffs->epfiles,\n\t\t\t\t\t\t   ffs->eps_count);\n\t\t\t\tffs->epfiles = NULL;\n\t\t\t}\n\t\t\tif (ffs->setup_state == FFS_SETUP_PENDING)\n\t\t\t\t__ffs_ep0_stall(ffs);\n\t\t} else {\n\t\t\tffs->state = FFS_CLOSING;\n\t\t\tffs_data_reset(ffs);\n\t\t}\n\t}\n\tif (atomic_read(&ffs->opened) < 0) {\n\t\tffs->state = FFS_CLOSING;\n\t\tffs_data_reset(ffs);\n\t}\n\n\tffs_data_put(ffs);\n}\n\nstatic struct ffs_data *ffs_data_new(void)\n{\n\tstruct ffs_data *ffs = kzalloc(sizeof *ffs, GFP_KERNEL);\n\tif (unlikely(!ffs))\n\t\treturn NULL;\n\n\tENTER();\n\n\tatomic_set(&ffs->ref, 1);\n\tatomic_set(&ffs->opened, 0);\n\tffs->state = FFS_READ_DESCRIPTORS;\n\tmutex_init(&ffs->mutex);\n\tspin_lock_init(&ffs->eps_lock);\n\tinit_waitqueue_head(&ffs->ev.waitq);\n\tinit_completion(&ffs->ep0req_completion);\n\n\t/* XXX REVISIT need to update it in some places, or do we? */\n\tffs->ev.can_stall = 1;\n\n\treturn ffs;\n}\n\nstatic void ffs_data_clear(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tffs_closed(ffs);\n\n\tBUG_ON(ffs->gadget);\n\n\tif (ffs->epfiles)\n\t\tffs_epfiles_destroy(ffs->epfiles, ffs->eps_count);\n\n\tif (ffs->ffs_eventfd)\n\t\teventfd_ctx_put(ffs->ffs_eventfd);\n\n\tkfree(ffs->raw_descs_data);\n\tkfree(ffs->raw_strings);\n\tkfree(ffs->stringtabs);\n}\n\nstatic void ffs_data_reset(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tffs_data_clear(ffs);\n\n\tffs->epfiles = NULL;\n\tffs->raw_descs_data = NULL;\n\tffs->raw_descs = NULL;\n\tffs->raw_strings = NULL;\n\tffs->stringtabs = NULL;\n\n\tffs->raw_descs_length = 0;\n\tffs->fs_descs_count = 0;\n\tffs->hs_descs_count = 0;\n\tffs->ss_descs_count = 0;\n\n\tffs->strings_count = 0;\n\tffs->interfaces_count = 0;\n\tffs->eps_count = 0;\n\n\tffs->ev.count = 0;\n\n\tffs->state = FFS_READ_DESCRIPTORS;\n\tffs->setup_state = FFS_NO_SETUP;\n\tffs->flags = 0;\n}\n\n\nstatic int functionfs_bind(struct ffs_data *ffs, struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget_strings **lang;\n\tint first_id;\n\n\tENTER();\n\n\tif (WARN_ON(ffs->state != FFS_ACTIVE\n\t\t || test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))\n\t\treturn -EBADFD;\n\n\tfirst_id = usb_string_ids_n(cdev, ffs->strings_count);\n\tif (unlikely(first_id < 0))\n\t\treturn first_id;\n\n\tffs->ep0req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);\n\tif (unlikely(!ffs->ep0req))\n\t\treturn -ENOMEM;\n\tffs->ep0req->complete = ffs_ep0_complete;\n\tffs->ep0req->context = ffs;\n\n\tlang = ffs->stringtabs;\n\tif (lang) {\n\t\tfor (; *lang; ++lang) {\n\t\t\tstruct usb_string *str = (*lang)->strings;\n\t\t\tint id = first_id;\n\t\t\tfor (; str->s; ++id, ++str)\n\t\t\t\tstr->id = id;\n\t\t}\n\t}\n\n\tffs->gadget = cdev->gadget;\n\tffs_data_get(ffs);\n\treturn 0;\n}\n\nstatic void functionfs_unbind(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tif (!WARN_ON(!ffs->gadget)) {\n\t\tusb_ep_free_request(ffs->gadget->ep0, ffs->ep0req);\n\t\tffs->ep0req = NULL;\n\t\tffs->gadget = NULL;\n\t\tclear_bit(FFS_FL_BOUND, &ffs->flags);\n\t\tffs_data_put(ffs);\n\t}\n}\n\nstatic int ffs_epfiles_create(struct ffs_data *ffs)\n{\n\tstruct ffs_epfile *epfile, *epfiles;\n\tunsigned i, count;\n\n\tENTER();\n\n\tcount = ffs->eps_count;\n\tepfiles = kcalloc(count, sizeof(*epfiles), GFP_KERNEL);\n\tif (!epfiles)\n\t\treturn -ENOMEM;\n\n\tepfile = epfiles;\n\tfor (i = 1; i <= count; ++i, ++epfile) {\n\t\tepfile->ffs = ffs;\n\t\tmutex_init(&epfile->mutex);\n\t\tinit_waitqueue_head(&epfile->wait);\n\t\tif (ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tsprintf(epfile->name, \"ep%02x\", ffs->eps_addrmap[i]);\n\t\telse\n\t\t\tsprintf(epfile->name, \"ep%u\", i);\n\t\tepfile->dentry = ffs_sb_create_file(ffs->sb, epfile->name,\n\t\t\t\t\t\t epfile,\n\t\t\t\t\t\t &ffs_epfile_operations);\n\t\tif (unlikely(!epfile->dentry)) {\n\t\t\tffs_epfiles_destroy(epfiles, i - 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tffs->epfiles = epfiles;\n\treturn 0;\n}\n\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count)\n{\n\tstruct ffs_epfile *epfile = epfiles;\n\n\tENTER();\n\n\tfor (; count; --count, ++epfile) {\n\t\tBUG_ON(mutex_is_locked(&epfile->mutex) ||\n\t\t       waitqueue_active(&epfile->wait));\n\t\tif (epfile->dentry) {\n\t\t\td_delete(epfile->dentry);\n\t\t\tdput(epfile->dentry);\n\t\t\tepfile->dentry = NULL;\n\t\t}\n\t}\n\n\tkfree(epfiles);\n}\n\nstatic void ffs_func_eps_disable(struct ffs_function *func)\n{\n\tstruct ffs_ep *ep         = func->eps;\n\tstruct ffs_epfile *epfile = func->ffs->epfiles;\n\tunsigned count            = func->ffs->eps_count;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tdo {\n\t\t/* pending requests get nuked */\n\t\tif (likely(ep->ep))\n\t\t\tusb_ep_disable(ep->ep);\n\t\t++ep;\n\n\t\tif (epfile) {\n\t\t\tepfile->ep = NULL;\n\t\t\t++epfile;\n\t\t}\n\t} while (--count);\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n}\n\nstatic int ffs_func_eps_enable(struct ffs_function *func)\n{\n\tstruct ffs_data *ffs      = func->ffs;\n\tstruct ffs_ep *ep         = func->eps;\n\tstruct ffs_epfile *epfile = ffs->epfiles;\n\tunsigned count            = ffs->eps_count;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tdo {\n\t\tstruct usb_endpoint_descriptor *ds;\n\t\tint desc_idx;\n\n\t\tif (ffs->gadget->speed == USB_SPEED_SUPER)\n\t\t\tdesc_idx = 2;\n\t\telse if (ffs->gadget->speed == USB_SPEED_HIGH)\n\t\t\tdesc_idx = 1;\n\t\telse\n\t\t\tdesc_idx = 0;\n\n\t\t/* fall-back to lower speed if desc missing for current speed */\n\t\tdo {\n\t\t\tds = ep->descs[desc_idx];\n\t\t} while (!ds && --desc_idx >= 0);\n\n\t\tif (!ds) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tep->ep->driver_data = ep;\n\t\tep->ep->desc = ds;\n\t\tret = usb_ep_enable(ep->ep);\n\t\tif (likely(!ret)) {\n\t\t\tepfile->ep = ep;\n\t\t\tepfile->in = usb_endpoint_dir_in(ds);\n\t\t\tepfile->isoc = usb_endpoint_xfer_isoc(ds);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\twake_up(&epfile->wait);\n\n\t\t++ep;\n\t\t++epfile;\n\t} while (--count);\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n\n\treturn ret;\n}\n\n\n/* Parsing and building descriptors and strings *****************************/\n\n/*\n * This validates if data pointed by data is a valid USB descriptor as\n * well as record how many interfaces, endpoints and strings are\n * required by given configuration.  Returns address after the\n * descriptor or NULL if data is invalid.\n */\n\nenum ffs_entity_type {\n\tFFS_DESCRIPTOR, FFS_INTERFACE, FFS_STRING, FFS_ENDPOINT\n};\n\nenum ffs_os_desc_type {\n\tFFS_OS_DESC, FFS_OS_DESC_EXT_COMPAT, FFS_OS_DESC_EXT_PROP\n};\n\ntypedef int (*ffs_entity_callback)(enum ffs_entity_type entity,\n\t\t\t\t   u8 *valuep,\n\t\t\t\t   struct usb_descriptor_header *desc,\n\t\t\t\t   void *priv);\n\ntypedef int (*ffs_os_desc_callback)(enum ffs_os_desc_type entity,\n\t\t\t\t    struct usb_os_desc_header *h, void *data,\n\t\t\t\t    unsigned len, void *priv);\n\nstatic int __must_check ffs_do_single_desc(char *data, unsigned len,\n\t\t\t\t\t   ffs_entity_callback entity,\n\t\t\t\t\t   void *priv)\n{\n\tstruct usb_descriptor_header *_ds = (void *)data;\n\tu8 length;\n\tint ret;\n\n\tENTER();\n\n\t/* At least two bytes are required: length and type */\n\tif (len < 2) {\n\t\tpr_vdebug(\"descriptor too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we have at least as many bytes as the descriptor takes? */\n\tlength = _ds->bLength;\n\tif (len < length) {\n\t\tpr_vdebug(\"descriptor longer then available data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n#define __entity_check_INTERFACE(val)  1\n#define __entity_check_STRING(val)     (val)\n#define __entity_check_ENDPOINT(val)   ((val) & USB_ENDPOINT_NUMBER_MASK)\n#define __entity(type, val) do {\t\t\t\t\t\\\n\t\tpr_vdebug(\"entity \" #type \"(%02x)\\n\", (val));\t\t\\\n\t\tif (unlikely(!__entity_check_ ##type(val))) {\t\t\\\n\t\t\tpr_vdebug(\"invalid entity's value\\n\");\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tret = entity(FFS_ ##type, &val, _ds, priv);\t\t\\\n\t\tif (unlikely(ret < 0)) {\t\t\t\t\\\n\t\t\tpr_debug(\"entity \" #type \"(%02x); ret = %d\\n\",\t\\\n\t\t\t\t (val), ret);\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\t/* Parse descriptor depending on type. */\n\tswitch (_ds->bDescriptorType) {\n\tcase USB_DT_DEVICE:\n\tcase USB_DT_CONFIG:\n\tcase USB_DT_STRING:\n\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t/* function can't have any of those */\n\t\tpr_vdebug(\"descriptor reserved for gadget: %d\\n\",\n\t\t      _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\n\tcase USB_DT_INTERFACE: {\n\t\tstruct usb_interface_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"interface descriptor\\n\");\n\t\tif (length != sizeof *ds)\n\t\t\tgoto inv_length;\n\n\t\t__entity(INTERFACE, ds->bInterfaceNumber);\n\t\tif (ds->iInterface)\n\t\t\t__entity(STRING, ds->iInterface);\n\t}\n\t\tbreak;\n\n\tcase USB_DT_ENDPOINT: {\n\t\tstruct usb_endpoint_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"endpoint descriptor\\n\");\n\t\tif (length != USB_DT_ENDPOINT_SIZE &&\n\t\t    length != USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\t\tgoto inv_length;\n\t\t__entity(ENDPOINT, ds->bEndpointAddress);\n\t}\n\t\tbreak;\n\n\tcase HID_DT_HID:\n\t\tpr_vdebug(\"hid descriptor\\n\");\n\t\tif (length != sizeof(struct hid_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_OTG:\n\t\tif (length != sizeof(struct usb_otg_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_INTERFACE_ASSOCIATION: {\n\t\tstruct usb_interface_assoc_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"interface association descriptor\\n\");\n\t\tif (length != sizeof *ds)\n\t\t\tgoto inv_length;\n\t\tif (ds->iFunction)\n\t\t\t__entity(STRING, ds->iFunction);\n\t}\n\t\tbreak;\n\n\tcase USB_DT_SS_ENDPOINT_COMP:\n\t\tpr_vdebug(\"EP SS companion descriptor\\n\");\n\t\tif (length != sizeof(struct usb_ss_ep_comp_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_OTHER_SPEED_CONFIG:\n\tcase USB_DT_INTERFACE_POWER:\n\tcase USB_DT_DEBUG:\n\tcase USB_DT_SECURITY:\n\tcase USB_DT_CS_RADIO_CONTROL:\n\t\t/* TODO */\n\t\tpr_vdebug(\"unimplemented descriptor: %d\\n\", _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\t/* We should never be here */\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\ninv_length:\n\t\tpr_vdebug(\"invalid length: %d (descriptor %d)\\n\",\n\t\t\t  _ds->bLength, _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\t}\n\n#undef __entity\n#undef __entity_check_DESCRIPTOR\n#undef __entity_check_INTERFACE\n#undef __entity_check_STRING\n#undef __entity_check_ENDPOINT\n\n\treturn length;\n}\n\nstatic int __must_check ffs_do_descs(unsigned count, char *data, unsigned len,\n\t\t\t\t     ffs_entity_callback entity, void *priv)\n{\n\tconst unsigned _len = len;\n\tunsigned long num = 0;\n\n\tENTER();\n\n\tfor (;;) {\n\t\tint ret;\n\n\t\tif (num == count)\n\t\t\tdata = NULL;\n\n\t\t/* Record \"descriptor\" entity */\n\t\tret = entity(FFS_DESCRIPTOR, (u8 *)num, (void *)data, priv);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"entity DESCRIPTOR(%02lx); ret = %d\\n\",\n\t\t\t\t num, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!data)\n\t\t\treturn _len - len;\n\n\t\tret = ffs_do_single_desc(data, len, entity, priv);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"%s returns %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen -= ret;\n\t\tdata += ret;\n\t\t++num;\n\t}\n}\n\nstatic int __ffs_data_do_entity(enum ffs_entity_type type,\n\t\t\t\tu8 *valuep, struct usb_descriptor_header *desc,\n\t\t\t\tvoid *priv)\n{\n\tstruct ffs_desc_helper *helper = priv;\n\tstruct usb_endpoint_descriptor *d;\n\n\tENTER();\n\n\tswitch (type) {\n\tcase FFS_DESCRIPTOR:\n\t\tbreak;\n\n\tcase FFS_INTERFACE:\n\t\t/*\n\t\t * Interfaces are indexed from zero so if we\n\t\t * encountered interface \"n\" then there are at least\n\t\t * \"n+1\" interfaces.\n\t\t */\n\t\tif (*valuep >= helper->interfaces_count)\n\t\t\thelper->interfaces_count = *valuep + 1;\n\t\tbreak;\n\n\tcase FFS_STRING:\n\t\t/*\n\t\t * Strings are indexed from 1 (0 is magic ;) reserved\n\t\t * for languages list or some such)\n\t\t */\n\t\tif (*valuep > helper->ffs->strings_count)\n\t\t\thelper->ffs->strings_count = *valuep;\n\t\tbreak;\n\n\tcase FFS_ENDPOINT:\n\t\td = (void *)desc;\n\t\thelper->eps_count++;\n\t\tif (helper->eps_count >= 15)\n\t\t\treturn -EINVAL;\n\t\t/* Check if descriptors for any speed were already parsed */\n\t\tif (!helper->ffs->eps_count && !helper->ffs->interfaces_count)\n\t\t\thelper->ffs->eps_addrmap[helper->eps_count] =\n\t\t\t\td->bEndpointAddress;\n\t\telse if (helper->ffs->eps_addrmap[helper->eps_count] !=\n\t\t\t\td->bEndpointAddress)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ffs_do_os_desc_header(enum ffs_os_desc_type *next_type,\n\t\t\t\t   struct usb_os_desc_header *desc)\n{\n\tu16 bcd_version = le16_to_cpu(desc->bcdVersion);\n\tu16 w_index = le16_to_cpu(desc->wIndex);\n\n\tif (bcd_version != 1) {\n\t\tpr_vdebug(\"unsupported os descriptors version: %d\",\n\t\t\t  bcd_version);\n\t\treturn -EINVAL;\n\t}\n\tswitch (w_index) {\n\tcase 0x4:\n\t\t*next_type = FFS_OS_DESC_EXT_COMPAT;\n\t\tbreak;\n\tcase 0x5:\n\t\t*next_type = FFS_OS_DESC_EXT_PROP;\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unsupported os descriptor type: %d\", w_index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn sizeof(*desc);\n}\n\n/*\n * Process all extended compatibility/extended property descriptors\n * of a feature descriptor\n */\nstatic int __must_check ffs_do_single_os_desc(char *data, unsigned len,\n\t\t\t\t\t      enum ffs_os_desc_type type,\n\t\t\t\t\t      u16 feature_count,\n\t\t\t\t\t      ffs_os_desc_callback entity,\n\t\t\t\t\t      void *priv,\n\t\t\t\t\t      struct usb_os_desc_header *h)\n{\n\tint ret;\n\tconst unsigned _len = len;\n\n\tENTER();\n\n\t/* loop over all ext compat/ext prop descriptors */\n\twhile (feature_count--) {\n\t\tret = entity(type, h, data, len, priv);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"bad OS descriptor, type: %d\\n\", type);\n\t\t\treturn ret;\n\t\t}\n\t\tdata += ret;\n\t\tlen -= ret;\n\t}\n\treturn _len - len;\n}\n\n/* Process a number of complete Feature Descriptors (Ext Compat or Ext Prop) */\nstatic int __must_check ffs_do_os_descs(unsigned count,\n\t\t\t\t\tchar *data, unsigned len,\n\t\t\t\t\tffs_os_desc_callback entity, void *priv)\n{\n\tconst unsigned _len = len;\n\tunsigned long num = 0;\n\n\tENTER();\n\n\tfor (num = 0; num < count; ++num) {\n\t\tint ret;\n\t\tenum ffs_os_desc_type type;\n\t\tu16 feature_count;\n\t\tstruct usb_os_desc_header *desc = (void *)data;\n\n\t\tif (len < sizeof(*desc))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Record \"descriptor\" entity.\n\t\t * Process dwLength, bcdVersion, wIndex, get b/wCount.\n\t\t * Move the data pointer to the beginning of extended\n\t\t * compatibilities proper or extended properties proper\n\t\t * portions of the data\n\t\t */\n\t\tif (le32_to_cpu(desc->dwLength) > len)\n\t\t\treturn -EINVAL;\n\n\t\tret = __ffs_do_os_desc_header(&type, desc);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"entity OS_DESCRIPTOR(%02lx); ret = %d\\n\",\n\t\t\t\t num, ret);\n\t\t\treturn ret;\n\t\t}\n\t\t/*\n\t\t * 16-bit hex \"?? 00\" Little Endian looks like 8-bit hex \"??\"\n\t\t */\n\t\tfeature_count = le16_to_cpu(desc->wCount);\n\t\tif (type == FFS_OS_DESC_EXT_COMPAT &&\n\t\t    (feature_count > 255 || desc->Reserved))\n\t\t\t\treturn -EINVAL;\n\t\tlen -= ret;\n\t\tdata += ret;\n\n\t\t/*\n\t\t * Process all function/property descriptors\n\t\t * of this Feature Descriptor\n\t\t */\n\t\tret = ffs_do_single_os_desc(data, len, type,\n\t\t\t\t\t    feature_count, entity, priv, desc);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"%s returns %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen -= ret;\n\t\tdata += ret;\n\t}\n\treturn _len - len;\n}\n\n/**\n * Validate contents of the buffer from userspace related to OS descriptors.\n */\nstatic int __ffs_data_do_os_desc(enum ffs_os_desc_type type,\n\t\t\t\t struct usb_os_desc_header *h, void *data,\n\t\t\t\t unsigned len, void *priv)\n{\n\tstruct ffs_data *ffs = priv;\n\tu8 length;\n\n\tENTER();\n\n\tswitch (type) {\n\tcase FFS_OS_DESC_EXT_COMPAT: {\n\t\tstruct usb_ext_compat_desc *d = data;\n\t\tint i;\n\n\t\tif (len < sizeof(*d) ||\n\t\t    d->bFirstInterfaceNumber >= ffs->interfaces_count ||\n\t\t    d->Reserved1)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(d->Reserved2); ++i)\n\t\t\tif (d->Reserved2[i])\n\t\t\t\treturn -EINVAL;\n\n\t\tlength = sizeof(struct usb_ext_compat_desc);\n\t}\n\t\tbreak;\n\tcase FFS_OS_DESC_EXT_PROP: {\n\t\tstruct usb_ext_prop_desc *d = data;\n\t\tu32 type, pdl;\n\t\tu16 pnl;\n\n\t\tif (len < sizeof(*d) || h->interface >= ffs->interfaces_count)\n\t\t\treturn -EINVAL;\n\t\tlength = le32_to_cpu(d->dwSize);\n\t\ttype = le32_to_cpu(d->dwPropertyDataType);\n\t\tif (type < USB_EXT_PROP_UNICODE ||\n\t\t    type > USB_EXT_PROP_UNICODE_MULTI) {\n\t\t\tpr_vdebug(\"unsupported os descriptor property type: %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpnl = le16_to_cpu(d->wPropertyNameLength);\n\t\tpdl = le32_to_cpu(*(u32 *)((u8 *)data + 10 + pnl));\n\t\tif (length != 14 + pnl + pdl) {\n\t\t\tpr_vdebug(\"invalid os descriptor length: %d pnl:%d pdl:%d (descriptor %d)\\n\",\n\t\t\t\t  length, pnl, pdl, type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t++ffs->ms_os_descs_ext_prop_count;\n\t\t/* property name reported to the host as \"WCHAR\"s */\n\t\tffs->ms_os_descs_ext_prop_name_len += pnl * 2;\n\t\tffs->ms_os_descs_ext_prop_data_len += pdl;\n\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\treturn length;\n}\n\nstatic int __ffs_data_got_descs(struct ffs_data *ffs,\n\t\t\t\tchar *const _data, size_t len)\n{\n\tchar *data = _data, *raw_descs;\n\tunsigned os_descs_count = 0, counts[3], flags;\n\tint ret = -EINVAL, i;\n\tstruct ffs_desc_helper helper;\n\n\tENTER();\n\n\tif (get_unaligned_le32(data + 4) != len)\n\t\tgoto error;\n\n\tswitch (get_unaligned_le32(data)) {\n\tcase FUNCTIONFS_DESCRIPTORS_MAGIC:\n\t\tflags = FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC;\n\t\tdata += 8;\n\t\tlen  -= 8;\n\t\tbreak;\n\tcase FUNCTIONFS_DESCRIPTORS_MAGIC_V2:\n\t\tflags = get_unaligned_le32(data + 8);\n\t\tffs->user_flags = flags;\n\t\tif (flags & ~(FUNCTIONFS_HAS_FS_DESC |\n\t\t\t      FUNCTIONFS_HAS_HS_DESC |\n\t\t\t      FUNCTIONFS_HAS_SS_DESC |\n\t\t\t      FUNCTIONFS_HAS_MS_OS_DESC |\n\t\t\t      FUNCTIONFS_VIRTUAL_ADDR |\n\t\t\t      FUNCTIONFS_EVENTFD)) {\n\t\t\tret = -ENOSYS;\n\t\t\tgoto error;\n\t\t}\n\t\tdata += 12;\n\t\tlen  -= 12;\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\n\tif (flags & FUNCTIONFS_EVENTFD) {\n\t\tif (len < 4)\n\t\t\tgoto error;\n\t\tffs->ffs_eventfd =\n\t\t\teventfd_ctx_fdget((int)get_unaligned_le32(data));\n\t\tif (IS_ERR(ffs->ffs_eventfd)) {\n\t\t\tret = PTR_ERR(ffs->ffs_eventfd);\n\t\t\tffs->ffs_eventfd = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\tdata += 4;\n\t\tlen  -= 4;\n\t}\n\n\t/* Read fs_count, hs_count and ss_count (if present) */\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (!(flags & (1 << i))) {\n\t\t\tcounts[i] = 0;\n\t\t} else if (len < 4) {\n\t\t\tgoto error;\n\t\t} else {\n\t\t\tcounts[i] = get_unaligned_le32(data);\n\t\t\tdata += 4;\n\t\t\tlen  -= 4;\n\t\t}\n\t}\n\tif (flags & (1 << i)) {\n\t\tos_descs_count = get_unaligned_le32(data);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t};\n\n\t/* Read descriptors */\n\traw_descs = data;\n\thelper.ffs = ffs;\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (!counts[i])\n\t\t\tcontinue;\n\t\thelper.interfaces_count = 0;\n\t\thelper.eps_count = 0;\n\t\tret = ffs_do_descs(counts[i], data, len,\n\t\t\t\t   __ffs_data_do_entity, &helper);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (!ffs->eps_count && !ffs->interfaces_count) {\n\t\t\tffs->eps_count = helper.eps_count;\n\t\t\tffs->interfaces_count = helper.interfaces_count;\n\t\t} else {\n\t\t\tif (ffs->eps_count != helper.eps_count) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (ffs->interfaces_count != helper.interfaces_count) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tdata += ret;\n\t\tlen  -= ret;\n\t}\n\tif (os_descs_count) {\n\t\tret = ffs_do_os_descs(os_descs_count, data, len,\n\t\t\t\t      __ffs_data_do_os_desc, ffs);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tdata += ret;\n\t\tlen -= ret;\n\t}\n\n\tif (raw_descs == data || len) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tffs->raw_descs_data\t= _data;\n\tffs->raw_descs\t\t= raw_descs;\n\tffs->raw_descs_length\t= data - raw_descs;\n\tffs->fs_descs_count\t= counts[0];\n\tffs->hs_descs_count\t= counts[1];\n\tffs->ss_descs_count\t= counts[2];\n\tffs->ms_os_descs_count\t= os_descs_count;\n\n\treturn 0;\n\nerror:\n\tkfree(_data);\n\treturn ret;\n}\n\nstatic int __ffs_data_got_strings(struct ffs_data *ffs,\n\t\t\t\t  char *const _data, size_t len)\n{\n\tu32 str_count, needed_count, lang_count;\n\tstruct usb_gadget_strings **stringtabs, *t;\n\tstruct usb_string *strings, *s;\n\tconst char *data = _data;\n\n\tENTER();\n\n\tif (unlikely(get_unaligned_le32(data) != FUNCTIONFS_STRINGS_MAGIC ||\n\t\t     get_unaligned_le32(data + 4) != len))\n\t\tgoto error;\n\tstr_count  = get_unaligned_le32(data + 8);\n\tlang_count = get_unaligned_le32(data + 12);\n\n\t/* if one is zero the other must be zero */\n\tif (unlikely(!str_count != !lang_count))\n\t\tgoto error;\n\n\t/* Do we have at least as many strings as descriptors need? */\n\tneeded_count = ffs->strings_count;\n\tif (unlikely(str_count < needed_count))\n\t\tgoto error;\n\n\t/*\n\t * If we don't need any strings just return and free all\n\t * memory.\n\t */\n\tif (!needed_count) {\n\t\tkfree(_data);\n\t\treturn 0;\n\t}\n\n\t/* Allocate everything in one chunk so there's less maintenance. */\n\t{\n\t\tunsigned i = 0;\n\t\tvla_group(d);\n\t\tvla_item(d, struct usb_gadget_strings *, stringtabs,\n\t\t\tlang_count + 1);\n\t\tvla_item(d, struct usb_gadget_strings, stringtab, lang_count);\n\t\tvla_item(d, struct usb_string, strings,\n\t\t\tlang_count*(needed_count+1));\n\n\t\tchar *vlabuf = kmalloc(vla_group_size(d), GFP_KERNEL);\n\n\t\tif (unlikely(!vlabuf)) {\n\t\t\tkfree(_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* Initialize the VLA pointers */\n\t\tstringtabs = vla_ptr(vlabuf, d, stringtabs);\n\t\tt = vla_ptr(vlabuf, d, stringtab);\n\t\ti = lang_count;\n\t\tdo {\n\t\t\t*stringtabs++ = t++;\n\t\t} while (--i);\n\t\t*stringtabs = NULL;\n\n\t\t/* stringtabs = vlabuf = d_stringtabs for later kfree */\n\t\tstringtabs = vla_ptr(vlabuf, d, stringtabs);\n\t\tt = vla_ptr(vlabuf, d, stringtab);\n\t\ts = vla_ptr(vlabuf, d, strings);\n\t\tstrings = s;\n\t}\n\n\t/* For each language */\n\tdata += 16;\n\tlen -= 16;\n\n\tdo { /* lang_count > 0 so we can use do-while */\n\t\tunsigned needed = needed_count;\n\n\t\tif (unlikely(len < 3))\n\t\t\tgoto error_free;\n\t\tt->language = get_unaligned_le16(data);\n\t\tt->strings  = s;\n\t\t++t;\n\n\t\tdata += 2;\n\t\tlen -= 2;\n\n\t\t/* For each string */\n\t\tdo { /* str_count > 0 so we can use do-while */\n\t\t\tsize_t length = strnlen(data, len);\n\n\t\t\tif (unlikely(length == len))\n\t\t\t\tgoto error_free;\n\n\t\t\t/*\n\t\t\t * User may provide more strings then we need,\n\t\t\t * if that's the case we simply ignore the\n\t\t\t * rest\n\t\t\t */\n\t\t\tif (likely(needed)) {\n\t\t\t\t/*\n\t\t\t\t * s->id will be set while adding\n\t\t\t\t * function to configuration so for\n\t\t\t\t * now just leave garbage here.\n\t\t\t\t */\n\t\t\t\ts->s = data;\n\t\t\t\t--needed;\n\t\t\t\t++s;\n\t\t\t}\n\n\t\t\tdata += length + 1;\n\t\t\tlen -= length + 1;\n\t\t} while (--str_count);\n\n\t\ts->id = 0;   /* terminator */\n\t\ts->s = NULL;\n\t\t++s;\n\n\t} while (--lang_count);\n\n\t/* Some garbage left? */\n\tif (unlikely(len))\n\t\tgoto error_free;\n\n\t/* Done! */\n\tffs->stringtabs = stringtabs;\n\tffs->raw_strings = _data;\n\n\treturn 0;\n\nerror_free:\n\tkfree(stringtabs);\nerror:\n\tkfree(_data);\n\treturn -EINVAL;\n}\n\n\n/* Events handling and management *******************************************/\n\nstatic void __ffs_event_add(struct ffs_data *ffs,\n\t\t\t    enum usb_functionfs_event_type type)\n{\n\tenum usb_functionfs_event_type rem_type1, rem_type2 = type;\n\tint neg = 0;\n\n\t/*\n\t * Abort any unhandled setup\n\t *\n\t * We do not need to worry about some cmpxchg() changing value\n\t * of ffs->setup_state without holding the lock because when\n\t * state is FFS_SETUP_PENDING cmpxchg() in several places in\n\t * the source does nothing.\n\t */\n\tif (ffs->setup_state == FFS_SETUP_PENDING)\n\t\tffs->setup_state = FFS_SETUP_CANCELLED;\n\n\t/*\n\t * Logic of this function guarantees that there are at most four pending\n\t * evens on ffs->ev.types queue.  This is important because the queue\n\t * has space for four elements only and __ffs_ep0_read_events function\n\t * depends on that limit as well.  If more event types are added, those\n\t * limits have to be revisited or guaranteed to still hold.\n\t */\n\tswitch (type) {\n\tcase FUNCTIONFS_RESUME:\n\t\trem_type2 = FUNCTIONFS_SUSPEND;\n\t\t/* FALL THROUGH */\n\tcase FUNCTIONFS_SUSPEND:\n\tcase FUNCTIONFS_SETUP:\n\t\trem_type1 = type;\n\t\t/* Discard all similar events */\n\t\tbreak;\n\n\tcase FUNCTIONFS_BIND:\n\tcase FUNCTIONFS_UNBIND:\n\tcase FUNCTIONFS_DISABLE:\n\tcase FUNCTIONFS_ENABLE:\n\t\t/* Discard everything other then power management. */\n\t\trem_type1 = FUNCTIONFS_SUSPEND;\n\t\trem_type2 = FUNCTIONFS_RESUME;\n\t\tneg = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"%d: unknown event, this should not happen\\n\", type);\n\t\treturn;\n\t}\n\n\t{\n\t\tu8 *ev  = ffs->ev.types, *out = ev;\n\t\tunsigned n = ffs->ev.count;\n\t\tfor (; n; --n, ++ev)\n\t\t\tif ((*ev == rem_type1 || *ev == rem_type2) == neg)\n\t\t\t\t*out++ = *ev;\n\t\t\telse\n\t\t\t\tpr_vdebug(\"purging event %d\\n\", *ev);\n\t\tffs->ev.count = out - ffs->ev.types;\n\t}\n\n\tpr_vdebug(\"adding event %d\\n\", type);\n\tffs->ev.types[ffs->ev.count++] = type;\n\twake_up_locked(&ffs->ev.waitq);\n\tif (ffs->ffs_eventfd)\n\t\teventfd_signal(ffs->ffs_eventfd, 1);\n}\n\nstatic void ffs_event_add(struct ffs_data *ffs,\n\t\t\t  enum usb_functionfs_event_type type)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\n\t__ffs_event_add(ffs, type);\n\tspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\n}\n\n/* Bind/unbind USB function hooks *******************************************/\n\nstatic int ffs_ep_addr2idx(struct ffs_data *ffs, u8 endpoint_address)\n{\n\tint i;\n\n\tfor (i = 1; i < ARRAY_SIZE(ffs->eps_addrmap); ++i)\n\t\tif (ffs->eps_addrmap[i] == endpoint_address)\n\t\t\treturn i;\n\treturn -ENOENT;\n}\n\nstatic int __ffs_func_bind_do_descs(enum ffs_entity_type type, u8 *valuep,\n\t\t\t\t    struct usb_descriptor_header *desc,\n\t\t\t\t    void *priv)\n{\n\tstruct usb_endpoint_descriptor *ds = (void *)desc;\n\tstruct ffs_function *func = priv;\n\tstruct ffs_ep *ffs_ep;\n\tunsigned ep_desc_id;\n\tint idx;\n\tstatic const char *speed_names[] = { \"full\", \"high\", \"super\" };\n\n\tif (type != FFS_DESCRIPTOR)\n\t\treturn 0;\n\n\t/*\n\t * If ss_descriptors is not NULL, we are reading super speed\n\t * descriptors; if hs_descriptors is not NULL, we are reading high\n\t * speed descriptors; otherwise, we are reading full speed\n\t * descriptors.\n\t */\n\tif (func->function.ss_descriptors) {\n\t\tep_desc_id = 2;\n\t\tfunc->function.ss_descriptors[(long)valuep] = desc;\n\t} else if (func->function.hs_descriptors) {\n\t\tep_desc_id = 1;\n\t\tfunc->function.hs_descriptors[(long)valuep] = desc;\n\t} else {\n\t\tep_desc_id = 0;\n\t\tfunc->function.fs_descriptors[(long)valuep]    = desc;\n\t}\n\n\tif (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn 0;\n\n\tidx = ffs_ep_addr2idx(func->ffs, ds->bEndpointAddress) - 1;\n\tif (idx < 0)\n\t\treturn idx;\n\n\tffs_ep = func->eps + idx;\n\n\tif (unlikely(ffs_ep->descs[ep_desc_id])) {\n\t\tpr_err(\"two %sspeed descriptors for EP %d\\n\",\n\t\t\t  speed_names[ep_desc_id],\n\t\t\t  ds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t\treturn -EINVAL;\n\t}\n\tffs_ep->descs[ep_desc_id] = ds;\n\n\tffs_dump_mem(\": Original  ep desc\", ds, ds->bLength);\n\tif (ffs_ep->ep) {\n\t\tds->bEndpointAddress = ffs_ep->descs[0]->bEndpointAddress;\n\t\tif (!ds->wMaxPacketSize)\n\t\t\tds->wMaxPacketSize = ffs_ep->descs[0]->wMaxPacketSize;\n\t} else {\n\t\tstruct usb_request *req;\n\t\tstruct usb_ep *ep;\n\t\tu8 bEndpointAddress;\n\n\t\t/*\n\t\t * We back up bEndpointAddress because autoconfig overwrites\n\t\t * it with physical endpoint address.\n\t\t */\n\t\tbEndpointAddress = ds->bEndpointAddress;\n\t\tpr_vdebug(\"autoconfig\\n\");\n\t\tep = usb_ep_autoconfig(func->gadget, ds);\n\t\tif (unlikely(!ep))\n\t\t\treturn -ENOTSUPP;\n\t\tep->driver_data = func->eps + idx;\n\n\t\treq = usb_ep_alloc_request(ep, GFP_KERNEL);\n\t\tif (unlikely(!req))\n\t\t\treturn -ENOMEM;\n\n\t\tffs_ep->ep  = ep;\n\t\tffs_ep->req = req;\n\t\tfunc->eps_revmap[ds->bEndpointAddress &\n\t\t\t\t USB_ENDPOINT_NUMBER_MASK] = idx + 1;\n\t\t/*\n\t\t * If we use virtual address mapping, we restore\n\t\t * original bEndpointAddress value.\n\t\t */\n\t\tif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tds->bEndpointAddress = bEndpointAddress;\n\t}\n\tffs_dump_mem(\": Rewritten ep desc\", ds, ds->bLength);\n\n\treturn 0;\n}\n\nstatic int __ffs_func_bind_do_nums(enum ffs_entity_type type, u8 *valuep,\n\t\t\t\t   struct usb_descriptor_header *desc,\n\t\t\t\t   void *priv)\n{\n\tstruct ffs_function *func = priv;\n\tunsigned idx;\n\tu8 newValue;\n\n\tswitch (type) {\n\tdefault:\n\tcase FFS_DESCRIPTOR:\n\t\t/* Handled in previous pass by __ffs_func_bind_do_descs() */\n\t\treturn 0;\n\n\tcase FFS_INTERFACE:\n\t\tidx = *valuep;\n\t\tif (func->interfaces_nums[idx] < 0) {\n\t\t\tint id = usb_interface_id(func->conf, &func->function);\n\t\t\tif (unlikely(id < 0))\n\t\t\t\treturn id;\n\t\t\tfunc->interfaces_nums[idx] = id;\n\t\t}\n\t\tnewValue = func->interfaces_nums[idx];\n\t\tbreak;\n\n\tcase FFS_STRING:\n\t\t/* String' IDs are allocated when fsf_data is bound to cdev */\n\t\tnewValue = func->ffs->stringtabs[0]->strings[*valuep - 1].id;\n\t\tbreak;\n\n\tcase FFS_ENDPOINT:\n\t\t/*\n\t\t * USB_DT_ENDPOINT are handled in\n\t\t * __ffs_func_bind_do_descs().\n\t\t */\n\t\tif (desc->bDescriptorType == USB_DT_ENDPOINT)\n\t\t\treturn 0;\n\n\t\tidx = (*valuep & USB_ENDPOINT_NUMBER_MASK) - 1;\n\t\tif (unlikely(!func->eps[idx].ep))\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct usb_endpoint_descriptor **descs;\n\t\t\tdescs = func->eps[idx].descs;\n\t\t\tnewValue = descs[descs[0] ? 0 : 1]->bEndpointAddress;\n\t\t}\n\t\tbreak;\n\t}\n\n\tpr_vdebug(\"%02x -> %02x\\n\", *valuep, newValue);\n\t*valuep = newValue;\n\treturn 0;\n}\n\nstatic int __ffs_func_bind_do_os_desc(enum ffs_os_desc_type type,\n\t\t\t\t      struct usb_os_desc_header *h, void *data,\n\t\t\t\t      unsigned len, void *priv)\n{\n\tstruct ffs_function *func = priv;\n\tu8 length = 0;\n\n\tswitch (type) {\n\tcase FFS_OS_DESC_EXT_COMPAT: {\n\t\tstruct usb_ext_compat_desc *desc = data;\n\t\tstruct usb_os_desc_table *t;\n\n\t\tt = &func->function.os_desc_table[desc->bFirstInterfaceNumber];\n\t\tt->if_id = func->interfaces_nums[desc->bFirstInterfaceNumber];\n\t\tmemcpy(t->os_desc->ext_compat_id, &desc->CompatibleID,\n\t\t       ARRAY_SIZE(desc->CompatibleID) +\n\t\t       ARRAY_SIZE(desc->SubCompatibleID));\n\t\tlength = sizeof(*desc);\n\t}\n\t\tbreak;\n\tcase FFS_OS_DESC_EXT_PROP: {\n\t\tstruct usb_ext_prop_desc *desc = data;\n\t\tstruct usb_os_desc_table *t;\n\t\tstruct usb_os_desc_ext_prop *ext_prop;\n\t\tchar *ext_prop_name;\n\t\tchar *ext_prop_data;\n\n\t\tt = &func->function.os_desc_table[h->interface];\n\t\tt->if_id = func->interfaces_nums[h->interface];\n\n\t\text_prop = func->ffs->ms_os_descs_ext_prop_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_avail += sizeof(*ext_prop);\n\n\t\text_prop->type = le32_to_cpu(desc->dwPropertyDataType);\n\t\text_prop->name_len = le16_to_cpu(desc->wPropertyNameLength);\n\t\text_prop->data_len = le32_to_cpu(*(u32 *)\n\t\t\tusb_ext_prop_data_len_ptr(data, ext_prop->name_len));\n\t\tlength = ext_prop->name_len + ext_prop->data_len + 14;\n\n\t\text_prop_name = func->ffs->ms_os_descs_ext_prop_name_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_name_avail +=\n\t\t\text_prop->name_len;\n\n\t\text_prop_data = func->ffs->ms_os_descs_ext_prop_data_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_data_avail +=\n\t\t\text_prop->data_len;\n\t\tmemcpy(ext_prop_data,\n\t\t       usb_ext_prop_data_ptr(data, ext_prop->name_len),\n\t\t       ext_prop->data_len);\n\t\t/* unicode data reported to the host as \"WCHAR\"s */\n\t\tswitch (ext_prop->type) {\n\t\tcase USB_EXT_PROP_UNICODE:\n\t\tcase USB_EXT_PROP_UNICODE_ENV:\n\t\tcase USB_EXT_PROP_UNICODE_LINK:\n\t\tcase USB_EXT_PROP_UNICODE_MULTI:\n\t\t\text_prop->data_len *= 2;\n\t\t\tbreak;\n\t\t}\n\t\text_prop->data = ext_prop_data;\n\n\t\tmemcpy(ext_prop_name, usb_ext_prop_name_ptr(data),\n\t\t       ext_prop->name_len);\n\t\t/* property name reported to the host as \"WCHAR\"s */\n\t\text_prop->name_len *= 2;\n\t\text_prop->name = ext_prop_name;\n\n\t\tt->os_desc->ext_prop_len +=\n\t\t\text_prop->name_len + ext_prop->data_len + 14;\n\t\t++t->os_desc->ext_prop_count;\n\t\tlist_add_tail(&ext_prop->entry, &t->os_desc->ext_prop);\n\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", type);\n\t}\n\n\treturn length;\n}\n\nstatic inline struct f_fs_opts *ffs_do_functionfs_bind(struct usb_function *f,\n\t\t\t\t\t\tstruct usb_configuration *c)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct f_fs_opts *ffs_opts =\n\t\tcontainer_of(f->fi, struct f_fs_opts, func_inst);\n\tint ret;\n\n\tENTER();\n\n\t/*\n\t * Legacy gadget triggers binding in functionfs_ready_callback,\n\t * which already uses locking; taking the same lock here would\n\t * cause a deadlock.\n\t *\n\t * Configfs-enabled gadgets however do need ffs_dev_lock.\n\t */\n\tif (!ffs_opts->no_configfs)\n\t\tffs_dev_lock();\n\tret = ffs_opts->dev->desc_ready ? 0 : -ENODEV;\n\tfunc->ffs = ffs_opts->dev->ffs_data;\n\tif (!ffs_opts->no_configfs)\n\t\tffs_dev_unlock();\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tfunc->conf = c;\n\tfunc->gadget = c->cdev->gadget;\n\n\t/*\n\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()\n\t * configurations are bound in sequence with list_for_each_entry,\n\t * in each configuration its functions are bound in sequence\n\t * with list_for_each_entry, so we assume no race condition\n\t * with regard to ffs_opts->bound access\n\t */\n\tif (!ffs_opts->refcnt) {\n\t\tret = functionfs_bind(func->ffs, c->cdev);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tffs_opts->refcnt++;\n\tfunc->function.strings = func->ffs->stringtabs;\n\n\treturn ffs_opts;\n}\n\nstatic int _ffs_func_bind(struct usb_configuration *c,\n\t\t\t  struct usb_function *f)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\n\tconst int full = !!func->ffs->fs_descs_count;\n\tconst int high = gadget_is_dualspeed(func->gadget) &&\n\t\tfunc->ffs->hs_descs_count;\n\tconst int super = gadget_is_superspeed(func->gadget) &&\n\t\tfunc->ffs->ss_descs_count;\n\n\tint fs_len, hs_len, ss_len, ret, i;\n\n\t/* Make it a single chunk, less management later on */\n\tvla_group(d);\n\tvla_item_with_sz(d, struct ffs_ep, eps, ffs->eps_count);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, fs_descs,\n\t\tfull ? ffs->fs_descs_count + 1 : 0);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, hs_descs,\n\t\thigh ? ffs->hs_descs_count + 1 : 0);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, ss_descs,\n\t\tsuper ? ffs->ss_descs_count + 1 : 0);\n\tvla_item_with_sz(d, short, inums, ffs->interfaces_count);\n\tvla_item_with_sz(d, struct usb_os_desc_table, os_desc_table,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, char[16], ext_compat,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, struct usb_os_desc, os_desc,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, struct usb_os_desc_ext_prop, ext_prop,\n\t\t\t ffs->ms_os_descs_ext_prop_count);\n\tvla_item_with_sz(d, char, ext_prop_name,\n\t\t\t ffs->ms_os_descs_ext_prop_name_len);\n\tvla_item_with_sz(d, char, ext_prop_data,\n\t\t\t ffs->ms_os_descs_ext_prop_data_len);\n\tvla_item_with_sz(d, char, raw_descs, ffs->raw_descs_length);\n\tchar *vlabuf;\n\n\tENTER();\n\n\t/* Has descriptors only for speeds gadget does not support */\n\tif (unlikely(!(full | high | super)))\n\t\treturn -ENOTSUPP;\n\n\t/* Allocate a single chunk, less management later on */\n\tvlabuf = kzalloc(vla_group_size(d), GFP_KERNEL);\n\tif (unlikely(!vlabuf))\n\t\treturn -ENOMEM;\n\n\tffs->ms_os_descs_ext_prop_avail = vla_ptr(vlabuf, d, ext_prop);\n\tffs->ms_os_descs_ext_prop_name_avail =\n\t\tvla_ptr(vlabuf, d, ext_prop_name);\n\tffs->ms_os_descs_ext_prop_data_avail =\n\t\tvla_ptr(vlabuf, d, ext_prop_data);\n\n\t/* Copy descriptors  */\n\tmemcpy(vla_ptr(vlabuf, d, raw_descs), ffs->raw_descs,\n\t       ffs->raw_descs_length);\n\n\tmemset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);\n\tfor (ret = ffs->eps_count; ret; --ret) {\n\t\tstruct ffs_ep *ptr;\n\n\t\tptr = vla_ptr(vlabuf, d, eps);\n\t\tptr[ret].num = -1;\n\t}\n\n\t/* Save pointers\n\t * d_eps == vlabuf, func->eps used to kfree vlabuf later\n\t*/\n\tfunc->eps             = vla_ptr(vlabuf, d, eps);\n\tfunc->interfaces_nums = vla_ptr(vlabuf, d, inums);\n\n\t/*\n\t * Go through all the endpoint descriptors and allocate\n\t * endpoints first, so that later we can rewrite the endpoint\n\t * numbers without worrying that it may be described later on.\n\t */\n\tif (likely(full)) {\n\t\tfunc->function.fs_descriptors = vla_ptr(vlabuf, d, fs_descs);\n\t\tfs_len = ffs_do_descs(ffs->fs_descs_count,\n\t\t\t\t      vla_ptr(vlabuf, d, raw_descs),\n\t\t\t\t      d_raw_descs__sz,\n\t\t\t\t      __ffs_func_bind_do_descs, func);\n\t\tif (unlikely(fs_len < 0)) {\n\t\t\tret = fs_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tfs_len = 0;\n\t}\n\n\tif (likely(high)) {\n\t\tfunc->function.hs_descriptors = vla_ptr(vlabuf, d, hs_descs);\n\t\ths_len = ffs_do_descs(ffs->hs_descs_count,\n\t\t\t\t      vla_ptr(vlabuf, d, raw_descs) + fs_len,\n\t\t\t\t      d_raw_descs__sz - fs_len,\n\t\t\t\t      __ffs_func_bind_do_descs, func);\n\t\tif (unlikely(hs_len < 0)) {\n\t\t\tret = hs_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\ths_len = 0;\n\t}\n\n\tif (likely(super)) {\n\t\tfunc->function.ss_descriptors = vla_ptr(vlabuf, d, ss_descs);\n\t\tss_len = ffs_do_descs(ffs->ss_descs_count,\n\t\t\t\tvla_ptr(vlabuf, d, raw_descs) + fs_len + hs_len,\n\t\t\t\td_raw_descs__sz - fs_len - hs_len,\n\t\t\t\t__ffs_func_bind_do_descs, func);\n\t\tif (unlikely(ss_len < 0)) {\n\t\t\tret = ss_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tss_len = 0;\n\t}\n\n\t/*\n\t * Now handle interface numbers allocation and interface and\n\t * endpoint numbers rewriting.  We can do that in one go\n\t * now.\n\t */\n\tret = ffs_do_descs(ffs->fs_descs_count +\n\t\t\t   (high ? ffs->hs_descs_count : 0) +\n\t\t\t   (super ? ffs->ss_descs_count : 0),\n\t\t\t   vla_ptr(vlabuf, d, raw_descs), d_raw_descs__sz,\n\t\t\t   __ffs_func_bind_do_nums, func);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tfunc->function.os_desc_table = vla_ptr(vlabuf, d, os_desc_table);\n\tif (c->cdev->use_os_string)\n\t\tfor (i = 0; i < ffs->interfaces_count; ++i) {\n\t\t\tstruct usb_os_desc *desc;\n\n\t\t\tdesc = func->function.os_desc_table[i].os_desc =\n\t\t\t\tvla_ptr(vlabuf, d, os_desc) +\n\t\t\t\ti * sizeof(struct usb_os_desc);\n\t\t\tdesc->ext_compat_id =\n\t\t\t\tvla_ptr(vlabuf, d, ext_compat) + i * 16;\n\t\t\tINIT_LIST_HEAD(&desc->ext_prop);\n\t\t}\n\tret = ffs_do_os_descs(ffs->ms_os_descs_count,\n\t\t\t      vla_ptr(vlabuf, d, raw_descs) +\n\t\t\t      fs_len + hs_len + ss_len,\n\t\t\t      d_raw_descs__sz - fs_len - hs_len - ss_len,\n\t\t\t      __ffs_func_bind_do_os_desc, func);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\tfunc->function.os_desc_n =\n\t\tc->cdev->use_os_string ? ffs->interfaces_count : 0;\n\n\t/* And we're done */\n\tffs_event_add(ffs, FUNCTIONFS_BIND);\n\treturn 0;\n\nerror:\n\t/* XXX Do we need to release all claimed endpoints here? */\n\treturn ret;\n}\n\nstatic int ffs_func_bind(struct usb_configuration *c,\n\t\t\t struct usb_function *f)\n{\n\tstruct f_fs_opts *ffs_opts = ffs_do_functionfs_bind(f, c);\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tint ret;\n\n\tif (IS_ERR(ffs_opts))\n\t\treturn PTR_ERR(ffs_opts);\n\n\tret = _ffs_func_bind(c, f);\n\tif (ret && !--ffs_opts->refcnt)\n\t\tfunctionfs_unbind(func->ffs);\n\n\treturn ret;\n}\n\n\n/* Other USB function hooks *************************************************/\n\nstatic void ffs_reset_work(struct work_struct *work)\n{\n\tstruct ffs_data *ffs = container_of(work,\n\t\tstruct ffs_data, reset_work);\n\tffs_data_reset(ffs);\n}\n\nstatic int ffs_func_set_alt(struct usb_function *f,\n\t\t\t    unsigned interface, unsigned alt)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tint ret = 0, intf;\n\n\tif (alt != (unsigned)-1) {\n\t\tintf = ffs_func_revmap_intf(func, interface);\n\t\tif (unlikely(intf < 0))\n\t\t\treturn intf;\n\t}\n\n\tif (ffs->func)\n\t\tffs_func_eps_disable(ffs->func);\n\n\tif (ffs->state == FFS_DEACTIVATED) {\n\t\tffs->state = FFS_CLOSING;\n\t\tINIT_WORK(&ffs->reset_work, ffs_reset_work);\n\t\tschedule_work(&ffs->reset_work);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ffs->state != FFS_ACTIVE)\n\t\treturn -ENODEV;\n\n\tif (alt == (unsigned)-1) {\n\t\tffs->func = NULL;\n\t\tffs_event_add(ffs, FUNCTIONFS_DISABLE);\n\t\treturn 0;\n\t}\n\n\tffs->func = func;\n\tret = ffs_func_eps_enable(func);\n\tif (likely(ret >= 0))\n\t\tffs_event_add(ffs, FUNCTIONFS_ENABLE);\n\treturn ret;\n}\n\nstatic void ffs_func_disable(struct usb_function *f)\n{\n\tffs_func_set_alt(f, 0, (unsigned)-1);\n}\n\nstatic int ffs_func_setup(struct usb_function *f,\n\t\t\t  const struct usb_ctrlrequest *creq)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tunsigned long flags;\n\tint ret;\n\n\tENTER();\n\n\tpr_vdebug(\"creq->bRequestType = %02x\\n\", creq->bRequestType);\n\tpr_vdebug(\"creq->bRequest     = %02x\\n\", creq->bRequest);\n\tpr_vdebug(\"creq->wValue       = %04x\\n\", le16_to_cpu(creq->wValue));\n\tpr_vdebug(\"creq->wIndex       = %04x\\n\", le16_to_cpu(creq->wIndex));\n\tpr_vdebug(\"creq->wLength      = %04x\\n\", le16_to_cpu(creq->wLength));\n\n\t/*\n\t * Most requests directed to interface go through here\n\t * (notable exceptions are set/get interface) so we need to\n\t * handle them.  All other either handled by composite or\n\t * passed to usb_configuration->setup() (if one is set).  No\n\t * matter, we will handle requests directed to endpoint here\n\t * as well (as it's straightforward) but what to do with any\n\t * other request?\n\t */\n\tif (ffs->state != FFS_ACTIVE)\n\t\treturn -ENODEV;\n\n\tswitch (creq->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_INTERFACE:\n\t\tret = ffs_func_revmap_intf(func, le16_to_cpu(creq->wIndex));\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tret = ffs_func_revmap_ep(func, le16_to_cpu(creq->wIndex));\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tret = func->ffs->eps_addrmap[ret];\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\n\tffs->ev.setup = *creq;\n\tffs->ev.setup.wIndex = cpu_to_le16(ret);\n\t__ffs_event_add(ffs, FUNCTIONFS_SETUP);\n\tspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\n\n\treturn 0;\n}\n\nstatic void ffs_func_suspend(struct usb_function *f)\n{\n\tENTER();\n\tffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_SUSPEND);\n}\n\nstatic void ffs_func_resume(struct usb_function *f)\n{\n\tENTER();\n\tffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_RESUME);\n}\n\n\n/* Endpoint and interface numbers reverse mapping ***************************/\n\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num)\n{\n\tnum = func->eps_revmap[num & USB_ENDPOINT_NUMBER_MASK];\n\treturn num ? num : -EDOM;\n}\n\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)\n{\n\tshort *nums = func->interfaces_nums;\n\tunsigned count = func->ffs->interfaces_count;\n\n\tfor (; count; --count, ++nums) {\n\t\tif (*nums >= 0 && *nums == intf)\n\t\t\treturn nums - func->interfaces_nums;\n\t}\n\n\treturn -EDOM;\n}\n\n\n/* Devices management *******************************************************/\n\nstatic LIST_HEAD(ffs_devices);\n\nstatic struct ffs_dev *_ffs_do_find_dev(const char *name)\n{\n\tstruct ffs_dev *dev;\n\n\tlist_for_each_entry(dev, &ffs_devices, entry) {\n\t\tif (!dev->name || !name)\n\t\t\tcontinue;\n\t\tif (strcmp(dev->name, name) == 0)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic struct ffs_dev *_ffs_get_single_dev(void)\n{\n\tstruct ffs_dev *dev;\n\n\tif (list_is_singular(&ffs_devices)) {\n\t\tdev = list_first_entry(&ffs_devices, struct ffs_dev, entry);\n\t\tif (dev->single)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic struct ffs_dev *_ffs_find_dev(const char *name)\n{\n\tstruct ffs_dev *dev;\n\n\tdev = _ffs_get_single_dev();\n\tif (dev)\n\t\treturn dev;\n\n\treturn _ffs_do_find_dev(name);\n}\n\n/* Configfs support *********************************************************/\n\nstatic inline struct f_fs_opts *to_ffs_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_fs_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void ffs_attr_release(struct config_item *item)\n{\n\tstruct f_fs_opts *opts = to_ffs_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations ffs_item_ops = {\n\t.release\t= ffs_attr_release,\n};\n\nstatic struct config_item_type ffs_func_type = {\n\t.ct_item_ops\t= &ffs_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n\n/* Function registration interface ******************************************/\n\nstatic void ffs_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_fs_opts *opts;\n\n\topts = to_f_fs_opts(f);\n\tffs_dev_lock();\n\t_ffs_free_dev(opts->dev);\n\tffs_dev_unlock();\n\tkfree(opts);\n}\n\n#define MAX_INST_NAME_LEN\t40\n\nstatic int ffs_set_inst_name(struct usb_function_instance *fi, const char *name)\n{\n\tstruct f_fs_opts *opts;\n\tchar *ptr;\n\tconst char *tmp;\n\tint name_len, ret;\n\n\tname_len = strlen(name) + 1;\n\tif (name_len > MAX_INST_NAME_LEN)\n\t\treturn -ENAMETOOLONG;\n\n\tptr = kstrndup(name, name_len, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\topts = to_f_fs_opts(fi);\n\ttmp = NULL;\n\n\tffs_dev_lock();\n\n\ttmp = opts->dev->name_allocated ? opts->dev->name : NULL;\n\tret = _ffs_name_dev(opts->dev, ptr);\n\tif (ret) {\n\t\tkfree(ptr);\n\t\tffs_dev_unlock();\n\t\treturn ret;\n\t}\n\topts->dev->name_allocated = true;\n\n\tffs_dev_unlock();\n\n\tkfree(tmp);\n\n\treturn 0;\n}\n\nstatic struct usb_function_instance *ffs_alloc_inst(void)\n{\n\tstruct f_fs_opts *opts;\n\tstruct ffs_dev *dev;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts->func_inst.set_inst_name = ffs_set_inst_name;\n\topts->func_inst.free_func_inst = ffs_free_inst;\n\tffs_dev_lock();\n\tdev = _ffs_alloc_dev();\n\tffs_dev_unlock();\n\tif (IS_ERR(dev)) {\n\t\tkfree(opts);\n\t\treturn ERR_CAST(dev);\n\t}\n\topts->dev = dev;\n\tdev->opts = opts;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &ffs_func_type);\n\treturn &opts->func_inst;\n}\n\nstatic void ffs_free(struct usb_function *f)\n{\n\tkfree(ffs_func_from_usb(f));\n}\n\nstatic void ffs_func_unbind(struct usb_configuration *c,\n\t\t\t    struct usb_function *f)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tstruct f_fs_opts *opts =\n\t\tcontainer_of(f->fi, struct f_fs_opts, func_inst);\n\tstruct ffs_ep *ep = func->eps;\n\tunsigned count = ffs->eps_count;\n\tunsigned long flags;\n\n\tENTER();\n\tif (ffs->func == func) {\n\t\tffs_func_eps_disable(func);\n\t\tffs->func = NULL;\n\t}\n\n\tif (!--opts->refcnt)\n\t\tfunctionfs_unbind(ffs);\n\n\t/* cleanup after autoconfig */\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tdo {\n\t\tif (ep->ep && ep->req)\n\t\t\tusb_ep_free_request(ep->ep, ep->req);\n\t\tep->req = NULL;\n\t\t++ep;\n\t} while (--count);\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n\tkfree(func->eps);\n\tfunc->eps = NULL;\n\t/*\n\t * eps, descriptors and interfaces_nums are allocated in the\n\t * same chunk so only one free is required.\n\t */\n\tfunc->function.fs_descriptors = NULL;\n\tfunc->function.hs_descriptors = NULL;\n\tfunc->function.ss_descriptors = NULL;\n\tfunc->interfaces_nums = NULL;\n\n\tffs_event_add(ffs, FUNCTIONFS_UNBIND);\n}\n\nstatic struct usb_function *ffs_alloc(struct usb_function_instance *fi)\n{\n\tstruct ffs_function *func;\n\n\tENTER();\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (unlikely(!func))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfunc->function.name    = \"Function FS Gadget\";\n\n\tfunc->function.bind    = ffs_func_bind;\n\tfunc->function.unbind  = ffs_func_unbind;\n\tfunc->function.set_alt = ffs_func_set_alt;\n\tfunc->function.disable = ffs_func_disable;\n\tfunc->function.setup   = ffs_func_setup;\n\tfunc->function.suspend = ffs_func_suspend;\n\tfunc->function.resume  = ffs_func_resume;\n\tfunc->function.free_func = ffs_free;\n\n\treturn &func->function;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic struct ffs_dev *_ffs_alloc_dev(void)\n{\n\tstruct ffs_dev *dev;\n\tint ret;\n\n\tif (_ffs_get_single_dev())\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (list_empty(&ffs_devices)) {\n\t\tret = functionfs_init();\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tlist_add(&dev->entry, &ffs_devices);\n\n\treturn dev;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n * The caller is responsible for \"name\" being available whenever f_fs needs it\n */\nstatic int _ffs_name_dev(struct ffs_dev *dev, const char *name)\n{\n\tstruct ffs_dev *existing;\n\n\texisting = _ffs_do_find_dev(name);\n\tif (existing)\n\t\treturn -EBUSY;\n\n\tdev->name = name;\n\n\treturn 0;\n}\n\n/*\n * The caller is responsible for \"name\" being available whenever f_fs needs it\n */\nint ffs_name_dev(struct ffs_dev *dev, const char *name)\n{\n\tint ret;\n\n\tffs_dev_lock();\n\tret = _ffs_name_dev(dev, name);\n\tffs_dev_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ffs_name_dev);\n\nint ffs_single_dev(struct ffs_dev *dev)\n{\n\tint ret;\n\n\tret = 0;\n\tffs_dev_lock();\n\n\tif (!list_is_singular(&ffs_devices))\n\t\tret = -EBUSY;\n\telse\n\t\tdev->single = true;\n\n\tffs_dev_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ffs_single_dev);\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic void _ffs_free_dev(struct ffs_dev *dev)\n{\n\tlist_del(&dev->entry);\n\tif (dev->name_allocated)\n\t\tkfree(dev->name);\n\tkfree(dev);\n\tif (list_empty(&ffs_devices))\n\t\tfunctionfs_cleanup();\n}\n\nstatic void *ffs_acquire_dev(const char *dev_name)\n{\n\tstruct ffs_dev *ffs_dev;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_dev = _ffs_find_dev(dev_name);\n\tif (!ffs_dev)\n\t\tffs_dev = ERR_PTR(-ENOENT);\n\telse if (ffs_dev->mounted)\n\t\tffs_dev = ERR_PTR(-EBUSY);\n\telse if (ffs_dev->ffs_acquire_dev_callback &&\n\t    ffs_dev->ffs_acquire_dev_callback(ffs_dev))\n\t\tffs_dev = ERR_PTR(-ENOENT);\n\telse\n\t\tffs_dev->mounted = true;\n\n\tffs_dev_unlock();\n\treturn ffs_dev;\n}\n\nstatic void ffs_release_dev(struct ffs_data *ffs_data)\n{\n\tstruct ffs_dev *ffs_dev;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_dev = ffs_data->private_data;\n\tif (ffs_dev) {\n\t\tffs_dev->mounted = false;\n\n\t\tif (ffs_dev->ffs_release_dev_callback)\n\t\t\tffs_dev->ffs_release_dev_callback(ffs_dev);\n\t}\n\n\tffs_dev_unlock();\n}\n\nstatic int ffs_ready(struct ffs_data *ffs)\n{\n\tstruct ffs_dev *ffs_obj;\n\tint ret = 0;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_obj = ffs->private_data;\n\tif (!ffs_obj) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (WARN_ON(ffs_obj->desc_ready)) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tffs_obj->desc_ready = true;\n\tffs_obj->ffs_data = ffs;\n\n\tif (ffs_obj->ffs_ready_callback) {\n\t\tret = ffs_obj->ffs_ready_callback(ffs);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tset_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags);\ndone:\n\tffs_dev_unlock();\n\treturn ret;\n}\n\nstatic void ffs_closed(struct ffs_data *ffs)\n{\n\tstruct ffs_dev *ffs_obj;\n\tstruct f_fs_opts *opts;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_obj = ffs->private_data;\n\tif (!ffs_obj)\n\t\tgoto done;\n\n\tffs_obj->desc_ready = false;\n\n\tif (test_and_clear_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags) &&\n\t    ffs_obj->ffs_closed_callback)\n\t\tffs_obj->ffs_closed_callback(ffs);\n\n\tif (ffs_obj->opts)\n\t\topts = ffs_obj->opts;\n\telse\n\t\tgoto done;\n\n\tif (opts->no_configfs || !opts->func_inst.group.cg_item.ci_parent\n\t    || !atomic_read(&opts->func_inst.group.cg_item.ci_kref.refcount))\n\t\tgoto done;\n\n\tunregister_gadget_item(ffs_obj->opts->\n\t\t\t       func_inst.group.cg_item.ci_parent->ci_parent);\ndone:\n\tffs_dev_unlock();\n}\n\n/* Misc helper functions ****************************************************/\n\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\n{\n\treturn nonblock\n\t\t? likely(mutex_trylock(mutex)) ? 0 : -EAGAIN\n\t\t: mutex_lock_interruptible(mutex);\n}\n\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\n{\n\tchar *data;\n\n\tif (unlikely(!len))\n\t\treturn NULL;\n\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(copy_from_user(data, buf, len))) {\n\t\tkfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\tpr_vdebug(\"Buffer from user space:\\n\");\n\tffs_dump_mem(\"\", data, len);\n\n\treturn data;\n}\n\nDECLARE_USB_FUNCTION_INIT(ffs, ffs_alloc_inst, ffs_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michal Nazarewicz\");\n"], "fixing_code": ["/*\n * f_fs.c -- user mode file system API for USB composite function controllers\n *\n * Copyright (C) 2010 Samsung Electronics\n * Author: Michal Nazarewicz <mina86@mina86.com>\n *\n * Based on inode.c (GadgetFS) which was:\n * Copyright (C) 2003-2004 David Brownell\n * Copyright (C) 2003 Agilent Technologies\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n */\n\n\n/* #define DEBUG */\n/* #define VERBOSE_DEBUG */\n\n#include <linux/blkdev.h>\n#include <linux/pagemap.h>\n#include <linux/export.h>\n#include <linux/hid.h>\n#include <linux/module.h>\n#include <linux/uio.h>\n#include <asm/unaligned.h>\n\n#include <linux/usb/composite.h>\n#include <linux/usb/functionfs.h>\n\n#include <linux/aio.h>\n#include <linux/mmu_context.h>\n#include <linux/poll.h>\n#include <linux/eventfd.h>\n\n#include \"u_fs.h\"\n#include \"u_f.h\"\n#include \"u_os_desc.h\"\n#include \"configfs.h\"\n\n#define FUNCTIONFS_MAGIC\t0xa647361 /* Chosen by a honest dice roll ;) */\n\n/* Reference counter handling */\nstatic void ffs_data_get(struct ffs_data *ffs);\nstatic void ffs_data_put(struct ffs_data *ffs);\n/* Creates new ffs_data object. */\nstatic struct ffs_data *__must_check ffs_data_new(void) __attribute__((malloc));\n\n/* Opened counter handling. */\nstatic void ffs_data_opened(struct ffs_data *ffs);\nstatic void ffs_data_closed(struct ffs_data *ffs);\n\n/* Called with ffs->mutex held; take over ownership of data. */\nstatic int __must_check\n__ffs_data_got_descs(struct ffs_data *ffs, char *data, size_t len);\nstatic int __must_check\n__ffs_data_got_strings(struct ffs_data *ffs, char *data, size_t len);\n\n\n/* The function structure ***************************************************/\n\nstruct ffs_ep;\n\nstruct ffs_function {\n\tstruct usb_configuration\t*conf;\n\tstruct usb_gadget\t\t*gadget;\n\tstruct ffs_data\t\t\t*ffs;\n\n\tstruct ffs_ep\t\t\t*eps;\n\tu8\t\t\t\teps_revmap[16];\n\tshort\t\t\t\t*interfaces_nums;\n\n\tstruct usb_function\t\tfunction;\n};\n\n\nstatic struct ffs_function *ffs_func_from_usb(struct usb_function *f)\n{\n\treturn container_of(f, struct ffs_function, function);\n}\n\n\nstatic inline enum ffs_setup_state\nffs_setup_state_clear_cancelled(struct ffs_data *ffs)\n{\n\treturn (enum ffs_setup_state)\n\t\tcmpxchg(&ffs->setup_state, FFS_SETUP_CANCELLED, FFS_NO_SETUP);\n}\n\n\nstatic void ffs_func_eps_disable(struct ffs_function *func);\nstatic int __must_check ffs_func_eps_enable(struct ffs_function *func);\n\nstatic int ffs_func_bind(struct usb_configuration *,\n\t\t\t struct usb_function *);\nstatic int ffs_func_set_alt(struct usb_function *, unsigned, unsigned);\nstatic void ffs_func_disable(struct usb_function *);\nstatic int ffs_func_setup(struct usb_function *,\n\t\t\t  const struct usb_ctrlrequest *);\nstatic void ffs_func_suspend(struct usb_function *);\nstatic void ffs_func_resume(struct usb_function *);\n\n\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num);\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf);\n\n\n/* The endpoints structures *************************************************/\n\nstruct ffs_ep {\n\tstruct usb_ep\t\t\t*ep;\t/* P: ffs->eps_lock */\n\tstruct usb_request\t\t*req;\t/* P: epfile->mutex */\n\n\t/* [0]: full speed, [1]: high speed, [2]: super speed */\n\tstruct usb_endpoint_descriptor\t*descs[3];\n\n\tu8\t\t\t\tnum;\n\n\tint\t\t\t\tstatus;\t/* P: epfile->mutex */\n};\n\nstruct ffs_epfile {\n\t/* Protects ep->ep and ep->req. */\n\tstruct mutex\t\t\tmutex;\n\twait_queue_head_t\t\twait;\n\n\tstruct ffs_data\t\t\t*ffs;\n\tstruct ffs_ep\t\t\t*ep;\t/* P: ffs->eps_lock */\n\n\tstruct dentry\t\t\t*dentry;\n\n\tchar\t\t\t\tname[5];\n\n\tunsigned char\t\t\tin;\t/* P: ffs->eps_lock */\n\tunsigned char\t\t\tisoc;\t/* P: ffs->eps_lock */\n\n\tunsigned char\t\t\t_pad;\n};\n\n/*  ffs_io_data structure ***************************************************/\n\nstruct ffs_io_data {\n\tbool aio;\n\tbool read;\n\n\tstruct kiocb *kiocb;\n\tstruct iov_iter data;\n\tconst void *to_free;\n\tchar *buf;\n\n\tstruct mm_struct *mm;\n\tstruct work_struct work;\n\n\tstruct usb_ep *ep;\n\tstruct usb_request *req;\n\n\tstruct ffs_data *ffs;\n};\n\nstruct ffs_desc_helper {\n\tstruct ffs_data *ffs;\n\tunsigned interfaces_count;\n\tunsigned eps_count;\n};\n\nstatic int  __must_check ffs_epfiles_create(struct ffs_data *ffs);\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count);\n\nstatic struct dentry *\nffs_sb_create_file(struct super_block *sb, const char *name, void *data,\n\t\t   const struct file_operations *fops);\n\n/* Devices management *******************************************************/\n\nDEFINE_MUTEX(ffs_lock);\nEXPORT_SYMBOL_GPL(ffs_lock);\n\nstatic struct ffs_dev *_ffs_find_dev(const char *name);\nstatic struct ffs_dev *_ffs_alloc_dev(void);\nstatic int _ffs_name_dev(struct ffs_dev *dev, const char *name);\nstatic void _ffs_free_dev(struct ffs_dev *dev);\nstatic void *ffs_acquire_dev(const char *dev_name);\nstatic void ffs_release_dev(struct ffs_data *ffs_data);\nstatic int ffs_ready(struct ffs_data *ffs);\nstatic void ffs_closed(struct ffs_data *ffs);\n\n/* Misc helper functions ****************************************************/\n\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\n\t__attribute__((warn_unused_result, nonnull));\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\n\t__attribute__((warn_unused_result, nonnull));\n\n\n/* Control file aka ep0 *****************************************************/\n\nstatic void ffs_ep0_complete(struct usb_ep *ep, struct usb_request *req)\n{\n\tstruct ffs_data *ffs = req->context;\n\n\tcomplete_all(&ffs->ep0req_completion);\n}\n\nstatic int __ffs_ep0_queue_wait(struct ffs_data *ffs, char *data, size_t len)\n{\n\tstruct usb_request *req = ffs->ep0req;\n\tint ret;\n\n\treq->zero     = len < le16_to_cpu(ffs->ev.setup.wLength);\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\treq->buf      = data;\n\treq->length   = len;\n\n\t/*\n\t * UDC layer requires to provide a buffer even for ZLP, but should\n\t * not use it at all. Let's provide some poisoned pointer to catch\n\t * possible bug in the driver.\n\t */\n\tif (req->buf == NULL)\n\t\treq->buf = (void *)0xDEADBABE;\n\n\treinit_completion(&ffs->ep0req_completion);\n\n\tret = usb_ep_queue(ffs->gadget->ep0, req, GFP_ATOMIC);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tret = wait_for_completion_interruptible(&ffs->ep0req_completion);\n\tif (unlikely(ret)) {\n\t\tusb_ep_dequeue(ffs->gadget->ep0, req);\n\t\treturn -EINTR;\n\t}\n\n\tffs->setup_state = FFS_NO_SETUP;\n\treturn req->status ? req->status : req->actual;\n}\n\nstatic int __ffs_ep0_stall(struct ffs_data *ffs)\n{\n\tif (ffs->ev.can_stall) {\n\t\tpr_vdebug(\"ep0 stall\\n\");\n\t\tusb_ep_set_halt(ffs->gadget->ep0);\n\t\tffs->setup_state = FFS_NO_SETUP;\n\t\treturn -EL2HLT;\n\t} else {\n\t\tpr_debug(\"bogus ep0 stall!\\n\");\n\t\treturn -ESRCH;\n\t}\n}\n\nstatic ssize_t ffs_ep0_write(struct file *file, const char __user *buf,\n\t\t\t     size_t len, loff_t *ptr)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tssize_t ret;\n\tchar *data;\n\n\tENTER();\n\n\t/* Fast check if setup was canceled */\n\tif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\n\t\treturn -EIDRM;\n\n\t/* Acquire mutex */\n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\t/* Check state */\n\tswitch (ffs->state) {\n\tcase FFS_READ_DESCRIPTORS:\n\tcase FFS_READ_STRINGS:\n\t\t/* Copy data */\n\t\tif (unlikely(len < 16)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tdata = ffs_prepare_buffer(buf, len);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Handle data */\n\t\tif (ffs->state == FFS_READ_DESCRIPTORS) {\n\t\t\tpr_info(\"read descriptors\\n\");\n\t\t\tret = __ffs_data_got_descs(ffs, data, len);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\tbreak;\n\n\t\t\tffs->state = FFS_READ_STRINGS;\n\t\t\tret = len;\n\t\t} else {\n\t\t\tpr_info(\"read strings\\n\");\n\t\t\tret = __ffs_data_got_strings(ffs, data, len);\n\t\t\tif (unlikely(ret < 0))\n\t\t\t\tbreak;\n\n\t\t\tret = ffs_epfiles_create(ffs);\n\t\t\tif (unlikely(ret)) {\n\t\t\t\tffs->state = FFS_CLOSING;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tffs->state = FFS_ACTIVE;\n\t\t\tmutex_unlock(&ffs->mutex);\n\n\t\t\tret = ffs_ready(ffs);\n\t\t\tif (unlikely(ret < 0)) {\n\t\t\t\tffs->state = FFS_CLOSING;\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn len;\n\t\t}\n\t\tbreak;\n\n\tcase FFS_ACTIVE:\n\t\tdata = NULL;\n\t\t/*\n\t\t * We're called from user space, we can use _irq\n\t\t * rather then _irqsave\n\t\t */\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\t\tswitch (ffs_setup_state_clear_cancelled(ffs)) {\n\t\tcase FFS_SETUP_CANCELLED:\n\t\t\tret = -EIDRM;\n\t\t\tgoto done_spin;\n\n\t\tcase FFS_NO_SETUP:\n\t\t\tret = -ESRCH;\n\t\t\tgoto done_spin;\n\n\t\tcase FFS_SETUP_PENDING:\n\t\t\tbreak;\n\t\t}\n\n\t\t/* FFS_SETUP_PENDING */\n\t\tif (!(ffs->ev.setup.bRequestType & USB_DIR_IN)) {\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t\tret = __ffs_ep0_stall(ffs);\n\t\t\tbreak;\n\t\t}\n\n\t\t/* FFS_SETUP_PENDING and not stall */\n\t\tlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\n\n\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\t\tdata = ffs_prepare_buffer(buf, len);\n\t\tif (IS_ERR(data)) {\n\t\t\tret = PTR_ERR(data);\n\t\t\tbreak;\n\t\t}\n\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\t\t/*\n\t\t * We are guaranteed to be still in FFS_ACTIVE state\n\t\t * but the state of setup could have changed from\n\t\t * FFS_SETUP_PENDING to FFS_SETUP_CANCELLED so we need\n\t\t * to check for that.  If that happened we copied data\n\t\t * from user space in vain but it's unlikely.\n\t\t *\n\t\t * For sure we are not in FFS_NO_SETUP since this is\n\t\t * the only place FFS_SETUP_PENDING -> FFS_NO_SETUP\n\t\t * transition can be performed and it's protected by\n\t\t * mutex.\n\t\t */\n\t\tif (ffs_setup_state_clear_cancelled(ffs) ==\n\t\t    FFS_SETUP_CANCELLED) {\n\t\t\tret = -EIDRM;\ndone_spin:\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t} else {\n\t\t\t/* unlocks spinlock */\n\t\t\tret = __ffs_ep0_queue_wait(ffs, data, len);\n\t\t}\n\t\tkfree(data);\n\t\tbreak;\n\n\tdefault:\n\t\tret = -EBADFD;\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ffs->mutex);\n\treturn ret;\n}\n\n/* Called with ffs->ev.waitq.lock and ffs->mutex held, both released on exit. */\nstatic ssize_t __ffs_ep0_read_events(struct ffs_data *ffs, char __user *buf,\n\t\t\t\t     size_t n)\n{\n\t/*\n\t * n cannot be bigger than ffs->ev.count, which cannot be bigger than\n\t * size of ffs->ev.types array (which is four) so that's how much space\n\t * we reserve.\n\t */\n\tstruct usb_functionfs_event events[ARRAY_SIZE(ffs->ev.types)];\n\tconst size_t size = n * sizeof *events;\n\tunsigned i = 0;\n\n\tmemset(events, 0, size);\n\n\tdo {\n\t\tevents[i].type = ffs->ev.types[i];\n\t\tif (events[i].type == FUNCTIONFS_SETUP) {\n\t\t\tevents[i].u.setup = ffs->ev.setup;\n\t\t\tffs->setup_state = FFS_SETUP_PENDING;\n\t\t}\n\t} while (++i < n);\n\n\tffs->ev.count -= n;\n\tif (ffs->ev.count)\n\t\tmemmove(ffs->ev.types, ffs->ev.types + n,\n\t\t\tffs->ev.count * sizeof *ffs->ev.types);\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\tmutex_unlock(&ffs->mutex);\n\n\treturn unlikely(copy_to_user(buf, events, size)) ? -EFAULT : size;\n}\n\nstatic ssize_t ffs_ep0_read(struct file *file, char __user *buf,\n\t\t\t    size_t len, loff_t *ptr)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tchar *data = NULL;\n\tsize_t n;\n\tint ret;\n\n\tENTER();\n\n\t/* Fast check if setup was canceled */\n\tif (ffs_setup_state_clear_cancelled(ffs) == FFS_SETUP_CANCELLED)\n\t\treturn -EIDRM;\n\n\t/* Acquire mutex */\n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\t/* Check state */\n\tif (ffs->state != FFS_ACTIVE) {\n\t\tret = -EBADFD;\n\t\tgoto done_mutex;\n\t}\n\n\t/*\n\t * We're called from user space, we can use _irq rather then\n\t * _irqsave\n\t */\n\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\tswitch (ffs_setup_state_clear_cancelled(ffs)) {\n\tcase FFS_SETUP_CANCELLED:\n\t\tret = -EIDRM;\n\t\tbreak;\n\n\tcase FFS_NO_SETUP:\n\t\tn = len / sizeof(struct usb_functionfs_event);\n\t\tif (unlikely(!n)) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((file->f_flags & O_NONBLOCK) && !ffs->ev.count) {\n\t\t\tret = -EAGAIN;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (wait_event_interruptible_exclusive_locked_irq(ffs->ev.waitq,\n\t\t\t\t\t\t\tffs->ev.count)) {\n\t\t\tret = -EINTR;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn __ffs_ep0_read_events(ffs, buf,\n\t\t\t\t\t     min(n, (size_t)ffs->ev.count));\n\n\tcase FFS_SETUP_PENDING:\n\t\tif (ffs->ev.setup.bRequestType & USB_DIR_IN) {\n\t\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\t\t\tret = __ffs_ep0_stall(ffs);\n\t\t\tgoto done_mutex;\n\t\t}\n\n\t\tlen = min(len, (size_t)le16_to_cpu(ffs->ev.setup.wLength));\n\n\t\tspin_unlock_irq(&ffs->ev.waitq.lock);\n\n\t\tif (likely(len)) {\n\t\t\tdata = kmalloc(len, GFP_KERNEL);\n\t\t\tif (unlikely(!data)) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto done_mutex;\n\t\t\t}\n\t\t}\n\n\t\tspin_lock_irq(&ffs->ev.waitq.lock);\n\n\t\t/* See ffs_ep0_write() */\n\t\tif (ffs_setup_state_clear_cancelled(ffs) ==\n\t\t    FFS_SETUP_CANCELLED) {\n\t\t\tret = -EIDRM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* unlocks spinlock */\n\t\tret = __ffs_ep0_queue_wait(ffs, data, len);\n\t\tif (likely(ret > 0) && unlikely(copy_to_user(buf, data, len)))\n\t\t\tret = -EFAULT;\n\t\tgoto done_mutex;\n\n\tdefault:\n\t\tret = -EBADFD;\n\t\tbreak;\n\t}\n\n\tspin_unlock_irq(&ffs->ev.waitq.lock);\ndone_mutex:\n\tmutex_unlock(&ffs->mutex);\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int ffs_ep0_open(struct inode *inode, struct file *file)\n{\n\tstruct ffs_data *ffs = inode->i_private;\n\n\tENTER();\n\n\tif (unlikely(ffs->state == FFS_CLOSING))\n\t\treturn -EBUSY;\n\n\tfile->private_data = ffs;\n\tffs_data_opened(ffs);\n\n\treturn 0;\n}\n\nstatic int ffs_ep0_release(struct inode *inode, struct file *file)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\n\tENTER();\n\n\tffs_data_closed(ffs);\n\n\treturn 0;\n}\n\nstatic long ffs_ep0_ioctl(struct file *file, unsigned code, unsigned long value)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tstruct usb_gadget *gadget = ffs->gadget;\n\tlong ret;\n\n\tENTER();\n\n\tif (code == FUNCTIONFS_INTERFACE_REVMAP) {\n\t\tstruct ffs_function *func = ffs->func;\n\t\tret = func ? ffs_func_revmap_intf(func, value) : -ENODEV;\n\t} else if (gadget && gadget->ops->ioctl) {\n\t\tret = gadget->ops->ioctl(gadget, code, value);\n\t} else {\n\t\tret = -ENOTTY;\n\t}\n\n\treturn ret;\n}\n\nstatic unsigned int ffs_ep0_poll(struct file *file, poll_table *wait)\n{\n\tstruct ffs_data *ffs = file->private_data;\n\tunsigned int mask = POLLWRNORM;\n\tint ret;\n\n\tpoll_wait(file, &ffs->ev.waitq, wait);\n\n\tret = ffs_mutex_lock(&ffs->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret < 0))\n\t\treturn mask;\n\n\tswitch (ffs->state) {\n\tcase FFS_READ_DESCRIPTORS:\n\tcase FFS_READ_STRINGS:\n\t\tmask |= POLLOUT;\n\t\tbreak;\n\n\tcase FFS_ACTIVE:\n\t\tswitch (ffs->setup_state) {\n\t\tcase FFS_NO_SETUP:\n\t\t\tif (ffs->ev.count)\n\t\t\t\tmask |= POLLIN;\n\t\t\tbreak;\n\n\t\tcase FFS_SETUP_PENDING:\n\t\tcase FFS_SETUP_CANCELLED:\n\t\t\tmask |= (POLLIN | POLLOUT);\n\t\t\tbreak;\n\t\t}\n\tcase FFS_CLOSING:\n\t\tbreak;\n\tcase FFS_DEACTIVATED:\n\t\tbreak;\n\t}\n\n\tmutex_unlock(&ffs->mutex);\n\n\treturn mask;\n}\n\nstatic const struct file_operations ffs_ep0_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tffs_ep0_open,\n\t.write =\tffs_ep0_write,\n\t.read =\t\tffs_ep0_read,\n\t.release =\tffs_ep0_release,\n\t.unlocked_ioctl =\tffs_ep0_ioctl,\n\t.poll =\t\tffs_ep0_poll,\n};\n\n\n/* \"Normal\" endpoints operations ********************************************/\n\nstatic void ffs_epfile_io_complete(struct usb_ep *_ep, struct usb_request *req)\n{\n\tENTER();\n\tif (likely(req->context)) {\n\t\tstruct ffs_ep *ep = _ep->driver_data;\n\t\tep->status = req->status ? req->status : req->actual;\n\t\tcomplete(req->context);\n\t}\n}\n\nstatic void ffs_user_copy_worker(struct work_struct *work)\n{\n\tstruct ffs_io_data *io_data = container_of(work, struct ffs_io_data,\n\t\t\t\t\t\t   work);\n\tint ret = io_data->req->status ? io_data->req->status :\n\t\t\t\t\t io_data->req->actual;\n\tbool kiocb_has_eventfd = io_data->kiocb->ki_flags & IOCB_EVENTFD;\n\n\tif (io_data->read && ret > 0) {\n\t\tuse_mm(io_data->mm);\n\t\tret = copy_to_iter(io_data->buf, ret, &io_data->data);\n\t\tif (iov_iter_count(&io_data->data))\n\t\t\tret = -EFAULT;\n\t\tunuse_mm(io_data->mm);\n\t}\n\n\tio_data->kiocb->ki_complete(io_data->kiocb, ret, ret);\n\n\tif (io_data->ffs->ffs_eventfd && !kiocb_has_eventfd)\n\t\teventfd_signal(io_data->ffs->ffs_eventfd, 1);\n\n\tusb_ep_free_request(io_data->ep, io_data->req);\n\n\tif (io_data->read)\n\t\tkfree(io_data->to_free);\n\tkfree(io_data->buf);\n\tkfree(io_data);\n}\n\nstatic void ffs_epfile_async_io_complete(struct usb_ep *_ep,\n\t\t\t\t\t struct usb_request *req)\n{\n\tstruct ffs_io_data *io_data = req->context;\n\n\tENTER();\n\n\tINIT_WORK(&io_data->work, ffs_user_copy_worker);\n\tschedule_work(&io_data->work);\n}\n\nstatic ssize_t ffs_epfile_io(struct file *file, struct ffs_io_data *io_data)\n{\n\tstruct ffs_epfile *epfile = file->private_data;\n\tstruct usb_request *req;\n\tstruct ffs_ep *ep;\n\tchar *data = NULL;\n\tssize_t ret, data_len = -EINVAL;\n\tint halt;\n\n\t/* Are we still active? */\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\t/* Wait for endpoint to be enabled */\n\tep = epfile->ep;\n\tif (!ep) {\n\t\tif (file->f_flags & O_NONBLOCK)\n\t\t\treturn -EAGAIN;\n\n\t\tret = wait_event_interruptible(epfile->wait, (ep = epfile->ep));\n\t\tif (ret)\n\t\t\treturn -EINTR;\n\t}\n\n\t/* Do we halt? */\n\thalt = (!io_data->read == !epfile->in);\n\tif (halt && epfile->isoc)\n\t\treturn -EINVAL;\n\n\t/* Allocate & copy */\n\tif (!halt) {\n\t\t/*\n\t\t * if we _do_ wait above, the epfile->ffs->gadget might be NULL\n\t\t * before the waiting completes, so do not assign to 'gadget'\n\t\t * earlier\n\t\t */\n\t\tstruct usb_gadget *gadget = epfile->ffs->gadget;\n\t\tsize_t copied;\n\n\t\tspin_lock_irq(&epfile->ffs->eps_lock);\n\t\t/* In the meantime, endpoint got disabled or changed. */\n\t\tif (epfile->ep != ep) {\n\t\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\t\t\treturn -ESHUTDOWN;\n\t\t}\n\t\tdata_len = iov_iter_count(&io_data->data);\n\t\t/*\n\t\t * Controller may require buffer size to be aligned to\n\t\t * maxpacketsize of an out endpoint.\n\t\t */\n\t\tif (io_data->read)\n\t\t\tdata_len = usb_ep_align_maybe(gadget, ep->ep, data_len);\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\t\tdata = kmalloc(data_len, GFP_KERNEL);\n\t\tif (unlikely(!data))\n\t\t\treturn -ENOMEM;\n\t\tif (!io_data->read) {\n\t\t\tcopied = copy_from_iter(data, data_len, &io_data->data);\n\t\t\tif (copied != data_len) {\n\t\t\t\tret = -EFAULT;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* We will be using request */\n\tret = ffs_mutex_lock(&epfile->mutex, file->f_flags & O_NONBLOCK);\n\tif (unlikely(ret))\n\t\tgoto error;\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\n\tif (epfile->ep != ep) {\n\t\t/* In the meantime, endpoint got disabled or changed. */\n\t\tret = -ESHUTDOWN;\n\t} else if (halt) {\n\t\t/* Halt */\n\t\tif (likely(epfile->ep == ep) && !WARN_ON(!ep->ep))\n\t\t\tusb_ep_set_halt(ep->ep);\n\t\tret = -EBADMSG;\n\t} else if (unlikely(data_len == -EINVAL)) {\n\t\t/*\n\t\t * Sanity Check: even though data_len can't be used\n\t\t * uninitialized at the time I write this comment, some\n\t\t * compilers complain about this situation.\n\t\t * In order to keep the code clean from warnings, data_len is\n\t\t * being initialized to -EINVAL during its declaration, which\n\t\t * means we can't rely on compiler anymore to warn no future\n\t\t * changes won't result in data_len being used uninitialized.\n\t\t * For such reason, we're adding this redundant sanity check\n\t\t * here.\n\t\t */\n\t\tWARN(1, \"%s: data_len == -EINVAL\\n\", __func__);\n\t\tret = -EINVAL;\n\t} else if (!io_data->aio) {\n\t\tDECLARE_COMPLETION_ONSTACK(done);\n\t\tbool interrupted = false;\n\n\t\treq = ep->req;\n\t\treq->buf      = data;\n\t\treq->length   = data_len;\n\n\t\treq->context  = &done;\n\t\treq->complete = ffs_epfile_io_complete;\n\n\t\tret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\n\t\tif (unlikely(ret < 0))\n\t\t\tgoto error_lock;\n\n\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\t\tif (unlikely(wait_for_completion_interruptible(&done))) {\n\t\t\t/*\n\t\t\t * To avoid race condition with ffs_epfile_io_complete,\n\t\t\t * dequeue the request first then check\n\t\t\t * status. usb_ep_dequeue API should guarantee no race\n\t\t\t * condition with req->complete callback.\n\t\t\t */\n\t\t\tusb_ep_dequeue(ep->ep, req);\n\t\t\tinterrupted = ep->status < 0;\n\t\t}\n\n\t\t/*\n\t\t * XXX We may end up silently droping data here.  Since data_len\n\t\t * (i.e. req->length) may be bigger than len (after being\n\t\t * rounded up to maxpacketsize), we may end up with more data\n\t\t * then user space has space for.\n\t\t */\n\t\tret = interrupted ? -EINTR : ep->status;\n\t\tif (io_data->read && ret > 0) {\n\t\t\tret = copy_to_iter(data, ret, &io_data->data);\n\t\t\tif (!ret)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\t\tgoto error_mutex;\n\t} else if (!(req = usb_ep_alloc_request(ep->ep, GFP_KERNEL))) {\n\t\tret = -ENOMEM;\n\t} else {\n\t\treq->buf      = data;\n\t\treq->length   = data_len;\n\n\t\tio_data->buf = data;\n\t\tio_data->ep = ep->ep;\n\t\tio_data->req = req;\n\t\tio_data->ffs = epfile->ffs;\n\n\t\treq->context  = io_data;\n\t\treq->complete = ffs_epfile_async_io_complete;\n\n\t\tret = usb_ep_queue(ep->ep, req, GFP_ATOMIC);\n\t\tif (unlikely(ret)) {\n\t\t\tusb_ep_free_request(ep->ep, req);\n\t\t\tgoto error_lock;\n\t\t}\n\n\t\tret = -EIOCBQUEUED;\n\t\t/*\n\t\t * Do not kfree the buffer in this function.  It will be freed\n\t\t * by ffs_user_copy_worker.\n\t\t */\n\t\tdata = NULL;\n\t}\n\nerror_lock:\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\nerror_mutex:\n\tmutex_unlock(&epfile->mutex);\nerror:\n\tkfree(data);\n\treturn ret;\n}\n\nstatic int\nffs_epfile_open(struct inode *inode, struct file *file)\n{\n\tstruct ffs_epfile *epfile = inode->i_private;\n\n\tENTER();\n\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\tfile->private_data = epfile;\n\tffs_data_opened(epfile->ffs);\n\n\treturn 0;\n}\n\nstatic int ffs_aio_cancel(struct kiocb *kiocb)\n{\n\tstruct ffs_io_data *io_data = kiocb->private;\n\tstruct ffs_epfile *epfile = kiocb->ki_filp->private_data;\n\tint value;\n\n\tENTER();\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\n\tif (likely(io_data && io_data->ep && io_data->req))\n\t\tvalue = usb_ep_dequeue(io_data->ep, io_data->req);\n\telse\n\t\tvalue = -EINVAL;\n\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\treturn value;\n}\n\nstatic ssize_t ffs_epfile_write_iter(struct kiocb *kiocb, struct iov_iter *from)\n{\n\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tENTER();\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kmalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tp->aio = false;\n\t}\n\n\tp->read = false;\n\tp->kiocb = kiocb;\n\tp->data = *from;\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n\tif (res == -EIOCBQUEUED)\n\t\treturn res;\n\tif (p->aio)\n\t\tkfree(p);\n\telse\n\t\t*from = p->data;\n\treturn res;\n}\n\nstatic ssize_t ffs_epfile_read_iter(struct kiocb *kiocb, struct iov_iter *to)\n{\n\tstruct ffs_io_data io_data, *p = &io_data;\n\tssize_t res;\n\n\tENTER();\n\n\tif (!is_sync_kiocb(kiocb)) {\n\t\tp = kmalloc(sizeof(io_data), GFP_KERNEL);\n\t\tif (unlikely(!p))\n\t\t\treturn -ENOMEM;\n\t\tp->aio = true;\n\t} else {\n\t\tp->aio = false;\n\t}\n\n\tp->read = true;\n\tp->kiocb = kiocb;\n\tif (p->aio) {\n\t\tp->to_free = dup_iter(&p->data, to, GFP_KERNEL);\n\t\tif (!p->to_free) {\n\t\t\tkfree(p);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t} else {\n\t\tp->data = *to;\n\t\tp->to_free = NULL;\n\t}\n\tp->mm = current->mm;\n\n\tkiocb->private = p;\n\n\tif (p->aio)\n\t\tkiocb_set_cancel_fn(kiocb, ffs_aio_cancel);\n\n\tres = ffs_epfile_io(kiocb->ki_filp, p);\n\tif (res == -EIOCBQUEUED)\n\t\treturn res;\n\n\tif (p->aio) {\n\t\tkfree(p->to_free);\n\t\tkfree(p);\n\t} else {\n\t\t*to = p->data;\n\t}\n\treturn res;\n}\n\nstatic int\nffs_epfile_release(struct inode *inode, struct file *file)\n{\n\tstruct ffs_epfile *epfile = inode->i_private;\n\n\tENTER();\n\n\tffs_data_closed(epfile->ffs);\n\n\treturn 0;\n}\n\nstatic long ffs_epfile_ioctl(struct file *file, unsigned code,\n\t\t\t     unsigned long value)\n{\n\tstruct ffs_epfile *epfile = file->private_data;\n\tint ret;\n\n\tENTER();\n\n\tif (WARN_ON(epfile->ffs->state != FFS_ACTIVE))\n\t\treturn -ENODEV;\n\n\tspin_lock_irq(&epfile->ffs->eps_lock);\n\tif (likely(epfile->ep)) {\n\t\tswitch (code) {\n\t\tcase FUNCTIONFS_FIFO_STATUS:\n\t\t\tret = usb_ep_fifo_status(epfile->ep->ep);\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_FIFO_FLUSH:\n\t\t\tusb_ep_fifo_flush(epfile->ep->ep);\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_CLEAR_HALT:\n\t\t\tret = usb_ep_clear_halt(epfile->ep->ep);\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_ENDPOINT_REVMAP:\n\t\t\tret = epfile->ep->num;\n\t\t\tbreak;\n\t\tcase FUNCTIONFS_ENDPOINT_DESC:\n\t\t{\n\t\t\tint desc_idx;\n\t\t\tstruct usb_endpoint_descriptor *desc;\n\n\t\t\tswitch (epfile->ffs->gadget->speed) {\n\t\t\tcase USB_SPEED_SUPER:\n\t\t\t\tdesc_idx = 2;\n\t\t\t\tbreak;\n\t\t\tcase USB_SPEED_HIGH:\n\t\t\t\tdesc_idx = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tdesc_idx = 0;\n\t\t\t}\n\t\t\tdesc = epfile->ep->descs[desc_idx];\n\n\t\t\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\t\t\tret = copy_to_user((void *)value, desc, sizeof(*desc));\n\t\t\tif (ret)\n\t\t\t\tret = -EFAULT;\n\t\t\treturn ret;\n\t\t}\n\t\tdefault:\n\t\t\tret = -ENOTTY;\n\t\t}\n\t} else {\n\t\tret = -ENODEV;\n\t}\n\tspin_unlock_irq(&epfile->ffs->eps_lock);\n\n\treturn ret;\n}\n\nstatic const struct file_operations ffs_epfile_operations = {\n\t.llseek =\tno_llseek,\n\n\t.open =\t\tffs_epfile_open,\n\t.write_iter =\tffs_epfile_write_iter,\n\t.read_iter =\tffs_epfile_read_iter,\n\t.release =\tffs_epfile_release,\n\t.unlocked_ioctl =\tffs_epfile_ioctl,\n};\n\n\n/* File system and super block operations ***********************************/\n\n/*\n * Mounting the file system creates a controller file, used first for\n * function configuration then later for event monitoring.\n */\n\nstatic struct inode *__must_check\nffs_sb_make_inode(struct super_block *sb, void *data,\n\t\t  const struct file_operations *fops,\n\t\t  const struct inode_operations *iops,\n\t\t  struct ffs_file_perms *perms)\n{\n\tstruct inode *inode;\n\n\tENTER();\n\n\tinode = new_inode(sb);\n\n\tif (likely(inode)) {\n\t\tstruct timespec current_time = CURRENT_TIME;\n\n\t\tinode->i_ino\t = get_next_ino();\n\t\tinode->i_mode    = perms->mode;\n\t\tinode->i_uid     = perms->uid;\n\t\tinode->i_gid     = perms->gid;\n\t\tinode->i_atime   = current_time;\n\t\tinode->i_mtime   = current_time;\n\t\tinode->i_ctime   = current_time;\n\t\tinode->i_private = data;\n\t\tif (fops)\n\t\t\tinode->i_fop = fops;\n\t\tif (iops)\n\t\t\tinode->i_op  = iops;\n\t}\n\n\treturn inode;\n}\n\n/* Create \"regular\" file */\nstatic struct dentry *ffs_sb_create_file(struct super_block *sb,\n\t\t\t\t\tconst char *name, void *data,\n\t\t\t\t\tconst struct file_operations *fops)\n{\n\tstruct ffs_data\t*ffs = sb->s_fs_info;\n\tstruct dentry\t*dentry;\n\tstruct inode\t*inode;\n\n\tENTER();\n\n\tdentry = d_alloc_name(sb->s_root, name);\n\tif (unlikely(!dentry))\n\t\treturn NULL;\n\n\tinode = ffs_sb_make_inode(sb, data, fops, NULL, &ffs->file_perms);\n\tif (unlikely(!inode)) {\n\t\tdput(dentry);\n\t\treturn NULL;\n\t}\n\n\td_add(dentry, inode);\n\treturn dentry;\n}\n\n/* Super block */\nstatic const struct super_operations ffs_sb_operations = {\n\t.statfs =\tsimple_statfs,\n\t.drop_inode =\tgeneric_delete_inode,\n};\n\nstruct ffs_sb_fill_data {\n\tstruct ffs_file_perms perms;\n\tumode_t root_mode;\n\tconst char *dev_name;\n\tbool no_disconnect;\n\tstruct ffs_data *ffs_data;\n};\n\nstatic int ffs_sb_fill(struct super_block *sb, void *_data, int silent)\n{\n\tstruct ffs_sb_fill_data *data = _data;\n\tstruct inode\t*inode;\n\tstruct ffs_data\t*ffs = data->ffs_data;\n\n\tENTER();\n\n\tffs->sb              = sb;\n\tdata->ffs_data       = NULL;\n\tsb->s_fs_info        = ffs;\n\tsb->s_blocksize      = PAGE_SIZE;\n\tsb->s_blocksize_bits = PAGE_SHIFT;\n\tsb->s_magic          = FUNCTIONFS_MAGIC;\n\tsb->s_op             = &ffs_sb_operations;\n\tsb->s_time_gran      = 1;\n\n\t/* Root inode */\n\tdata->perms.mode = data->root_mode;\n\tinode = ffs_sb_make_inode(sb, NULL,\n\t\t\t\t  &simple_dir_operations,\n\t\t\t\t  &simple_dir_inode_operations,\n\t\t\t\t  &data->perms);\n\tsb->s_root = d_make_root(inode);\n\tif (unlikely(!sb->s_root))\n\t\treturn -ENOMEM;\n\n\t/* EP0 file */\n\tif (unlikely(!ffs_sb_create_file(sb, \"ep0\", ffs,\n\t\t\t\t\t &ffs_ep0_operations)))\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}\n\nstatic int ffs_fs_parse_opts(struct ffs_sb_fill_data *data, char *opts)\n{\n\tENTER();\n\n\tif (!opts || !*opts)\n\t\treturn 0;\n\n\tfor (;;) {\n\t\tunsigned long value;\n\t\tchar *eq, *comma;\n\n\t\t/* Option limit */\n\t\tcomma = strchr(opts, ',');\n\t\tif (comma)\n\t\t\t*comma = 0;\n\n\t\t/* Value limit */\n\t\teq = strchr(opts, '=');\n\t\tif (unlikely(!eq)) {\n\t\t\tpr_err(\"'=' missing in %s\\n\", opts);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t*eq = 0;\n\n\t\t/* Parse value */\n\t\tif (kstrtoul(eq + 1, 0, &value)) {\n\t\t\tpr_err(\"%s: invalid value: %s\\n\", opts, eq + 1);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Interpret option */\n\t\tswitch (eq - opts) {\n\t\tcase 13:\n\t\t\tif (!memcmp(opts, \"no_disconnect\", 13))\n\t\t\t\tdata->no_disconnect = !!value;\n\t\t\telse\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tif (!memcmp(opts, \"rmode\", 5))\n\t\t\t\tdata->root_mode  = (value & 0555) | S_IFDIR;\n\t\t\telse if (!memcmp(opts, \"fmode\", 5))\n\t\t\t\tdata->perms.mode = (value & 0666) | S_IFREG;\n\t\t\telse\n\t\t\t\tgoto invalid;\n\t\t\tbreak;\n\n\t\tcase 4:\n\t\t\tif (!memcmp(opts, \"mode\", 4)) {\n\t\t\t\tdata->root_mode  = (value & 0555) | S_IFDIR;\n\t\t\t\tdata->perms.mode = (value & 0666) | S_IFREG;\n\t\t\t} else {\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 3:\n\t\t\tif (!memcmp(opts, \"uid\", 3)) {\n\t\t\t\tdata->perms.uid = make_kuid(current_user_ns(), value);\n\t\t\t\tif (!uid_valid(data->perms.uid)) {\n\t\t\t\t\tpr_err(\"%s: unmapped value: %lu\\n\", opts, value);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else if (!memcmp(opts, \"gid\", 3)) {\n\t\t\t\tdata->perms.gid = make_kgid(current_user_ns(), value);\n\t\t\t\tif (!gid_valid(data->perms.gid)) {\n\t\t\t\t\tpr_err(\"%s: unmapped value: %lu\\n\", opts, value);\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tgoto invalid;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\ninvalid:\n\t\t\tpr_err(\"%s: invalid option\\n\", opts);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\t/* Next iteration */\n\t\tif (!comma)\n\t\t\tbreak;\n\t\topts = comma + 1;\n\t}\n\n\treturn 0;\n}\n\n/* \"mount -t functionfs dev_name /dev/function\" ends up here */\n\nstatic struct dentry *\nffs_fs_mount(struct file_system_type *t, int flags,\n\t      const char *dev_name, void *opts)\n{\n\tstruct ffs_sb_fill_data data = {\n\t\t.perms = {\n\t\t\t.mode = S_IFREG | 0600,\n\t\t\t.uid = GLOBAL_ROOT_UID,\n\t\t\t.gid = GLOBAL_ROOT_GID,\n\t\t},\n\t\t.root_mode = S_IFDIR | 0500,\n\t\t.no_disconnect = false,\n\t};\n\tstruct dentry *rv;\n\tint ret;\n\tvoid *ffs_dev;\n\tstruct ffs_data\t*ffs;\n\n\tENTER();\n\n\tret = ffs_fs_parse_opts(&data, opts);\n\tif (unlikely(ret < 0))\n\t\treturn ERR_PTR(ret);\n\n\tffs = ffs_data_new();\n\tif (unlikely(!ffs))\n\t\treturn ERR_PTR(-ENOMEM);\n\tffs->file_perms = data.perms;\n\tffs->no_disconnect = data.no_disconnect;\n\n\tffs->dev_name = kstrdup(dev_name, GFP_KERNEL);\n\tif (unlikely(!ffs->dev_name)) {\n\t\tffs_data_put(ffs);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tffs_dev = ffs_acquire_dev(dev_name);\n\tif (IS_ERR(ffs_dev)) {\n\t\tffs_data_put(ffs);\n\t\treturn ERR_CAST(ffs_dev);\n\t}\n\tffs->private_data = ffs_dev;\n\tdata.ffs_data = ffs;\n\n\trv = mount_nodev(t, flags, &data, ffs_sb_fill);\n\tif (IS_ERR(rv) && data.ffs_data) {\n\t\tffs_release_dev(data.ffs_data);\n\t\tffs_data_put(data.ffs_data);\n\t}\n\treturn rv;\n}\n\nstatic void\nffs_fs_kill_sb(struct super_block *sb)\n{\n\tENTER();\n\n\tkill_litter_super(sb);\n\tif (sb->s_fs_info) {\n\t\tffs_release_dev(sb->s_fs_info);\n\t\tffs_data_closed(sb->s_fs_info);\n\t\tffs_data_put(sb->s_fs_info);\n\t}\n}\n\nstatic struct file_system_type ffs_fs_type = {\n\t.owner\t\t= THIS_MODULE,\n\t.name\t\t= \"functionfs\",\n\t.mount\t\t= ffs_fs_mount,\n\t.kill_sb\t= ffs_fs_kill_sb,\n};\nMODULE_ALIAS_FS(\"functionfs\");\n\n\n/* Driver's main init/cleanup functions *************************************/\n\nstatic int functionfs_init(void)\n{\n\tint ret;\n\n\tENTER();\n\n\tret = register_filesystem(&ffs_fs_type);\n\tif (likely(!ret))\n\t\tpr_info(\"file system registered\\n\");\n\telse\n\t\tpr_err(\"failed registering file system (%d)\\n\", ret);\n\n\treturn ret;\n}\n\nstatic void functionfs_cleanup(void)\n{\n\tENTER();\n\n\tpr_info(\"unloading\\n\");\n\tunregister_filesystem(&ffs_fs_type);\n}\n\n\n/* ffs_data and ffs_function construction and destruction code **************/\n\nstatic void ffs_data_clear(struct ffs_data *ffs);\nstatic void ffs_data_reset(struct ffs_data *ffs);\n\nstatic void ffs_data_get(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tatomic_inc(&ffs->ref);\n}\n\nstatic void ffs_data_opened(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tatomic_inc(&ffs->ref);\n\tif (atomic_add_return(1, &ffs->opened) == 1 &&\n\t\t\tffs->state == FFS_DEACTIVATED) {\n\t\tffs->state = FFS_CLOSING;\n\t\tffs_data_reset(ffs);\n\t}\n}\n\nstatic void ffs_data_put(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tif (unlikely(atomic_dec_and_test(&ffs->ref))) {\n\t\tpr_info(\"%s(): freeing\\n\", __func__);\n\t\tffs_data_clear(ffs);\n\t\tBUG_ON(waitqueue_active(&ffs->ev.waitq) ||\n\t\t       waitqueue_active(&ffs->ep0req_completion.wait));\n\t\tkfree(ffs->dev_name);\n\t\tkfree(ffs);\n\t}\n}\n\nstatic void ffs_data_closed(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tif (atomic_dec_and_test(&ffs->opened)) {\n\t\tif (ffs->no_disconnect) {\n\t\t\tffs->state = FFS_DEACTIVATED;\n\t\t\tif (ffs->epfiles) {\n\t\t\t\tffs_epfiles_destroy(ffs->epfiles,\n\t\t\t\t\t\t   ffs->eps_count);\n\t\t\t\tffs->epfiles = NULL;\n\t\t\t}\n\t\t\tif (ffs->setup_state == FFS_SETUP_PENDING)\n\t\t\t\t__ffs_ep0_stall(ffs);\n\t\t} else {\n\t\t\tffs->state = FFS_CLOSING;\n\t\t\tffs_data_reset(ffs);\n\t\t}\n\t}\n\tif (atomic_read(&ffs->opened) < 0) {\n\t\tffs->state = FFS_CLOSING;\n\t\tffs_data_reset(ffs);\n\t}\n\n\tffs_data_put(ffs);\n}\n\nstatic struct ffs_data *ffs_data_new(void)\n{\n\tstruct ffs_data *ffs = kzalloc(sizeof *ffs, GFP_KERNEL);\n\tif (unlikely(!ffs))\n\t\treturn NULL;\n\n\tENTER();\n\n\tatomic_set(&ffs->ref, 1);\n\tatomic_set(&ffs->opened, 0);\n\tffs->state = FFS_READ_DESCRIPTORS;\n\tmutex_init(&ffs->mutex);\n\tspin_lock_init(&ffs->eps_lock);\n\tinit_waitqueue_head(&ffs->ev.waitq);\n\tinit_completion(&ffs->ep0req_completion);\n\n\t/* XXX REVISIT need to update it in some places, or do we? */\n\tffs->ev.can_stall = 1;\n\n\treturn ffs;\n}\n\nstatic void ffs_data_clear(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tffs_closed(ffs);\n\n\tBUG_ON(ffs->gadget);\n\n\tif (ffs->epfiles)\n\t\tffs_epfiles_destroy(ffs->epfiles, ffs->eps_count);\n\n\tif (ffs->ffs_eventfd)\n\t\teventfd_ctx_put(ffs->ffs_eventfd);\n\n\tkfree(ffs->raw_descs_data);\n\tkfree(ffs->raw_strings);\n\tkfree(ffs->stringtabs);\n}\n\nstatic void ffs_data_reset(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tffs_data_clear(ffs);\n\n\tffs->epfiles = NULL;\n\tffs->raw_descs_data = NULL;\n\tffs->raw_descs = NULL;\n\tffs->raw_strings = NULL;\n\tffs->stringtabs = NULL;\n\n\tffs->raw_descs_length = 0;\n\tffs->fs_descs_count = 0;\n\tffs->hs_descs_count = 0;\n\tffs->ss_descs_count = 0;\n\n\tffs->strings_count = 0;\n\tffs->interfaces_count = 0;\n\tffs->eps_count = 0;\n\n\tffs->ev.count = 0;\n\n\tffs->state = FFS_READ_DESCRIPTORS;\n\tffs->setup_state = FFS_NO_SETUP;\n\tffs->flags = 0;\n}\n\n\nstatic int functionfs_bind(struct ffs_data *ffs, struct usb_composite_dev *cdev)\n{\n\tstruct usb_gadget_strings **lang;\n\tint first_id;\n\n\tENTER();\n\n\tif (WARN_ON(ffs->state != FFS_ACTIVE\n\t\t || test_and_set_bit(FFS_FL_BOUND, &ffs->flags)))\n\t\treturn -EBADFD;\n\n\tfirst_id = usb_string_ids_n(cdev, ffs->strings_count);\n\tif (unlikely(first_id < 0))\n\t\treturn first_id;\n\n\tffs->ep0req = usb_ep_alloc_request(cdev->gadget->ep0, GFP_KERNEL);\n\tif (unlikely(!ffs->ep0req))\n\t\treturn -ENOMEM;\n\tffs->ep0req->complete = ffs_ep0_complete;\n\tffs->ep0req->context = ffs;\n\n\tlang = ffs->stringtabs;\n\tif (lang) {\n\t\tfor (; *lang; ++lang) {\n\t\t\tstruct usb_string *str = (*lang)->strings;\n\t\t\tint id = first_id;\n\t\t\tfor (; str->s; ++id, ++str)\n\t\t\t\tstr->id = id;\n\t\t}\n\t}\n\n\tffs->gadget = cdev->gadget;\n\tffs_data_get(ffs);\n\treturn 0;\n}\n\nstatic void functionfs_unbind(struct ffs_data *ffs)\n{\n\tENTER();\n\n\tif (!WARN_ON(!ffs->gadget)) {\n\t\tusb_ep_free_request(ffs->gadget->ep0, ffs->ep0req);\n\t\tffs->ep0req = NULL;\n\t\tffs->gadget = NULL;\n\t\tclear_bit(FFS_FL_BOUND, &ffs->flags);\n\t\tffs_data_put(ffs);\n\t}\n}\n\nstatic int ffs_epfiles_create(struct ffs_data *ffs)\n{\n\tstruct ffs_epfile *epfile, *epfiles;\n\tunsigned i, count;\n\n\tENTER();\n\n\tcount = ffs->eps_count;\n\tepfiles = kcalloc(count, sizeof(*epfiles), GFP_KERNEL);\n\tif (!epfiles)\n\t\treturn -ENOMEM;\n\n\tepfile = epfiles;\n\tfor (i = 1; i <= count; ++i, ++epfile) {\n\t\tepfile->ffs = ffs;\n\t\tmutex_init(&epfile->mutex);\n\t\tinit_waitqueue_head(&epfile->wait);\n\t\tif (ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tsprintf(epfile->name, \"ep%02x\", ffs->eps_addrmap[i]);\n\t\telse\n\t\t\tsprintf(epfile->name, \"ep%u\", i);\n\t\tepfile->dentry = ffs_sb_create_file(ffs->sb, epfile->name,\n\t\t\t\t\t\t epfile,\n\t\t\t\t\t\t &ffs_epfile_operations);\n\t\tif (unlikely(!epfile->dentry)) {\n\t\t\tffs_epfiles_destroy(epfiles, i - 1);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\tffs->epfiles = epfiles;\n\treturn 0;\n}\n\nstatic void ffs_epfiles_destroy(struct ffs_epfile *epfiles, unsigned count)\n{\n\tstruct ffs_epfile *epfile = epfiles;\n\n\tENTER();\n\n\tfor (; count; --count, ++epfile) {\n\t\tBUG_ON(mutex_is_locked(&epfile->mutex) ||\n\t\t       waitqueue_active(&epfile->wait));\n\t\tif (epfile->dentry) {\n\t\t\td_delete(epfile->dentry);\n\t\t\tdput(epfile->dentry);\n\t\t\tepfile->dentry = NULL;\n\t\t}\n\t}\n\n\tkfree(epfiles);\n}\n\nstatic void ffs_func_eps_disable(struct ffs_function *func)\n{\n\tstruct ffs_ep *ep         = func->eps;\n\tstruct ffs_epfile *epfile = func->ffs->epfiles;\n\tunsigned count            = func->ffs->eps_count;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tdo {\n\t\t/* pending requests get nuked */\n\t\tif (likely(ep->ep))\n\t\t\tusb_ep_disable(ep->ep);\n\t\t++ep;\n\n\t\tif (epfile) {\n\t\t\tepfile->ep = NULL;\n\t\t\t++epfile;\n\t\t}\n\t} while (--count);\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n}\n\nstatic int ffs_func_eps_enable(struct ffs_function *func)\n{\n\tstruct ffs_data *ffs      = func->ffs;\n\tstruct ffs_ep *ep         = func->eps;\n\tstruct ffs_epfile *epfile = ffs->epfiles;\n\tunsigned count            = ffs->eps_count;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tdo {\n\t\tstruct usb_endpoint_descriptor *ds;\n\t\tint desc_idx;\n\n\t\tif (ffs->gadget->speed == USB_SPEED_SUPER)\n\t\t\tdesc_idx = 2;\n\t\telse if (ffs->gadget->speed == USB_SPEED_HIGH)\n\t\t\tdesc_idx = 1;\n\t\telse\n\t\t\tdesc_idx = 0;\n\n\t\t/* fall-back to lower speed if desc missing for current speed */\n\t\tdo {\n\t\t\tds = ep->descs[desc_idx];\n\t\t} while (!ds && --desc_idx >= 0);\n\n\t\tif (!ds) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tep->ep->driver_data = ep;\n\t\tep->ep->desc = ds;\n\t\tret = usb_ep_enable(ep->ep);\n\t\tif (likely(!ret)) {\n\t\t\tepfile->ep = ep;\n\t\t\tepfile->in = usb_endpoint_dir_in(ds);\n\t\t\tepfile->isoc = usb_endpoint_xfer_isoc(ds);\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\twake_up(&epfile->wait);\n\n\t\t++ep;\n\t\t++epfile;\n\t} while (--count);\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n\n\treturn ret;\n}\n\n\n/* Parsing and building descriptors and strings *****************************/\n\n/*\n * This validates if data pointed by data is a valid USB descriptor as\n * well as record how many interfaces, endpoints and strings are\n * required by given configuration.  Returns address after the\n * descriptor or NULL if data is invalid.\n */\n\nenum ffs_entity_type {\n\tFFS_DESCRIPTOR, FFS_INTERFACE, FFS_STRING, FFS_ENDPOINT\n};\n\nenum ffs_os_desc_type {\n\tFFS_OS_DESC, FFS_OS_DESC_EXT_COMPAT, FFS_OS_DESC_EXT_PROP\n};\n\ntypedef int (*ffs_entity_callback)(enum ffs_entity_type entity,\n\t\t\t\t   u8 *valuep,\n\t\t\t\t   struct usb_descriptor_header *desc,\n\t\t\t\t   void *priv);\n\ntypedef int (*ffs_os_desc_callback)(enum ffs_os_desc_type entity,\n\t\t\t\t    struct usb_os_desc_header *h, void *data,\n\t\t\t\t    unsigned len, void *priv);\n\nstatic int __must_check ffs_do_single_desc(char *data, unsigned len,\n\t\t\t\t\t   ffs_entity_callback entity,\n\t\t\t\t\t   void *priv)\n{\n\tstruct usb_descriptor_header *_ds = (void *)data;\n\tu8 length;\n\tint ret;\n\n\tENTER();\n\n\t/* At least two bytes are required: length and type */\n\tif (len < 2) {\n\t\tpr_vdebug(\"descriptor too short\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\t/* If we have at least as many bytes as the descriptor takes? */\n\tlength = _ds->bLength;\n\tif (len < length) {\n\t\tpr_vdebug(\"descriptor longer then available data\\n\");\n\t\treturn -EINVAL;\n\t}\n\n#define __entity_check_INTERFACE(val)  1\n#define __entity_check_STRING(val)     (val)\n#define __entity_check_ENDPOINT(val)   ((val) & USB_ENDPOINT_NUMBER_MASK)\n#define __entity(type, val) do {\t\t\t\t\t\\\n\t\tpr_vdebug(\"entity \" #type \"(%02x)\\n\", (val));\t\t\\\n\t\tif (unlikely(!__entity_check_ ##type(val))) {\t\t\\\n\t\t\tpr_vdebug(\"invalid entity's value\\n\");\t\t\\\n\t\t\treturn -EINVAL;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\tret = entity(FFS_ ##type, &val, _ds, priv);\t\t\\\n\t\tif (unlikely(ret < 0)) {\t\t\t\t\\\n\t\t\tpr_debug(\"entity \" #type \"(%02x); ret = %d\\n\",\t\\\n\t\t\t\t (val), ret);\t\t\t\t\\\n\t\t\treturn ret;\t\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n\t/* Parse descriptor depending on type. */\n\tswitch (_ds->bDescriptorType) {\n\tcase USB_DT_DEVICE:\n\tcase USB_DT_CONFIG:\n\tcase USB_DT_STRING:\n\tcase USB_DT_DEVICE_QUALIFIER:\n\t\t/* function can't have any of those */\n\t\tpr_vdebug(\"descriptor reserved for gadget: %d\\n\",\n\t\t      _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\n\tcase USB_DT_INTERFACE: {\n\t\tstruct usb_interface_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"interface descriptor\\n\");\n\t\tif (length != sizeof *ds)\n\t\t\tgoto inv_length;\n\n\t\t__entity(INTERFACE, ds->bInterfaceNumber);\n\t\tif (ds->iInterface)\n\t\t\t__entity(STRING, ds->iInterface);\n\t}\n\t\tbreak;\n\n\tcase USB_DT_ENDPOINT: {\n\t\tstruct usb_endpoint_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"endpoint descriptor\\n\");\n\t\tif (length != USB_DT_ENDPOINT_SIZE &&\n\t\t    length != USB_DT_ENDPOINT_AUDIO_SIZE)\n\t\t\tgoto inv_length;\n\t\t__entity(ENDPOINT, ds->bEndpointAddress);\n\t}\n\t\tbreak;\n\n\tcase HID_DT_HID:\n\t\tpr_vdebug(\"hid descriptor\\n\");\n\t\tif (length != sizeof(struct hid_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_OTG:\n\t\tif (length != sizeof(struct usb_otg_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_INTERFACE_ASSOCIATION: {\n\t\tstruct usb_interface_assoc_descriptor *ds = (void *)_ds;\n\t\tpr_vdebug(\"interface association descriptor\\n\");\n\t\tif (length != sizeof *ds)\n\t\t\tgoto inv_length;\n\t\tif (ds->iFunction)\n\t\t\t__entity(STRING, ds->iFunction);\n\t}\n\t\tbreak;\n\n\tcase USB_DT_SS_ENDPOINT_COMP:\n\t\tpr_vdebug(\"EP SS companion descriptor\\n\");\n\t\tif (length != sizeof(struct usb_ss_ep_comp_descriptor))\n\t\t\tgoto inv_length;\n\t\tbreak;\n\n\tcase USB_DT_OTHER_SPEED_CONFIG:\n\tcase USB_DT_INTERFACE_POWER:\n\tcase USB_DT_DEBUG:\n\tcase USB_DT_SECURITY:\n\tcase USB_DT_CS_RADIO_CONTROL:\n\t\t/* TODO */\n\t\tpr_vdebug(\"unimplemented descriptor: %d\\n\", _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\n\tdefault:\n\t\t/* We should never be here */\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\ninv_length:\n\t\tpr_vdebug(\"invalid length: %d (descriptor %d)\\n\",\n\t\t\t  _ds->bLength, _ds->bDescriptorType);\n\t\treturn -EINVAL;\n\t}\n\n#undef __entity\n#undef __entity_check_DESCRIPTOR\n#undef __entity_check_INTERFACE\n#undef __entity_check_STRING\n#undef __entity_check_ENDPOINT\n\n\treturn length;\n}\n\nstatic int __must_check ffs_do_descs(unsigned count, char *data, unsigned len,\n\t\t\t\t     ffs_entity_callback entity, void *priv)\n{\n\tconst unsigned _len = len;\n\tunsigned long num = 0;\n\n\tENTER();\n\n\tfor (;;) {\n\t\tint ret;\n\n\t\tif (num == count)\n\t\t\tdata = NULL;\n\n\t\t/* Record \"descriptor\" entity */\n\t\tret = entity(FFS_DESCRIPTOR, (u8 *)num, (void *)data, priv);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"entity DESCRIPTOR(%02lx); ret = %d\\n\",\n\t\t\t\t num, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (!data)\n\t\t\treturn _len - len;\n\n\t\tret = ffs_do_single_desc(data, len, entity, priv);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"%s returns %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen -= ret;\n\t\tdata += ret;\n\t\t++num;\n\t}\n}\n\nstatic int __ffs_data_do_entity(enum ffs_entity_type type,\n\t\t\t\tu8 *valuep, struct usb_descriptor_header *desc,\n\t\t\t\tvoid *priv)\n{\n\tstruct ffs_desc_helper *helper = priv;\n\tstruct usb_endpoint_descriptor *d;\n\n\tENTER();\n\n\tswitch (type) {\n\tcase FFS_DESCRIPTOR:\n\t\tbreak;\n\n\tcase FFS_INTERFACE:\n\t\t/*\n\t\t * Interfaces are indexed from zero so if we\n\t\t * encountered interface \"n\" then there are at least\n\t\t * \"n+1\" interfaces.\n\t\t */\n\t\tif (*valuep >= helper->interfaces_count)\n\t\t\thelper->interfaces_count = *valuep + 1;\n\t\tbreak;\n\n\tcase FFS_STRING:\n\t\t/*\n\t\t * Strings are indexed from 1 (0 is magic ;) reserved\n\t\t * for languages list or some such)\n\t\t */\n\t\tif (*valuep > helper->ffs->strings_count)\n\t\t\thelper->ffs->strings_count = *valuep;\n\t\tbreak;\n\n\tcase FFS_ENDPOINT:\n\t\td = (void *)desc;\n\t\thelper->eps_count++;\n\t\tif (helper->eps_count >= 15)\n\t\t\treturn -EINVAL;\n\t\t/* Check if descriptors for any speed were already parsed */\n\t\tif (!helper->ffs->eps_count && !helper->ffs->interfaces_count)\n\t\t\thelper->ffs->eps_addrmap[helper->eps_count] =\n\t\t\t\td->bEndpointAddress;\n\t\telse if (helper->ffs->eps_addrmap[helper->eps_count] !=\n\t\t\t\td->bEndpointAddress)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic int __ffs_do_os_desc_header(enum ffs_os_desc_type *next_type,\n\t\t\t\t   struct usb_os_desc_header *desc)\n{\n\tu16 bcd_version = le16_to_cpu(desc->bcdVersion);\n\tu16 w_index = le16_to_cpu(desc->wIndex);\n\n\tif (bcd_version != 1) {\n\t\tpr_vdebug(\"unsupported os descriptors version: %d\",\n\t\t\t  bcd_version);\n\t\treturn -EINVAL;\n\t}\n\tswitch (w_index) {\n\tcase 0x4:\n\t\t*next_type = FFS_OS_DESC_EXT_COMPAT;\n\t\tbreak;\n\tcase 0x5:\n\t\t*next_type = FFS_OS_DESC_EXT_PROP;\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unsupported os descriptor type: %d\", w_index);\n\t\treturn -EINVAL;\n\t}\n\n\treturn sizeof(*desc);\n}\n\n/*\n * Process all extended compatibility/extended property descriptors\n * of a feature descriptor\n */\nstatic int __must_check ffs_do_single_os_desc(char *data, unsigned len,\n\t\t\t\t\t      enum ffs_os_desc_type type,\n\t\t\t\t\t      u16 feature_count,\n\t\t\t\t\t      ffs_os_desc_callback entity,\n\t\t\t\t\t      void *priv,\n\t\t\t\t\t      struct usb_os_desc_header *h)\n{\n\tint ret;\n\tconst unsigned _len = len;\n\n\tENTER();\n\n\t/* loop over all ext compat/ext prop descriptors */\n\twhile (feature_count--) {\n\t\tret = entity(type, h, data, len, priv);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"bad OS descriptor, type: %d\\n\", type);\n\t\t\treturn ret;\n\t\t}\n\t\tdata += ret;\n\t\tlen -= ret;\n\t}\n\treturn _len - len;\n}\n\n/* Process a number of complete Feature Descriptors (Ext Compat or Ext Prop) */\nstatic int __must_check ffs_do_os_descs(unsigned count,\n\t\t\t\t\tchar *data, unsigned len,\n\t\t\t\t\tffs_os_desc_callback entity, void *priv)\n{\n\tconst unsigned _len = len;\n\tunsigned long num = 0;\n\n\tENTER();\n\n\tfor (num = 0; num < count; ++num) {\n\t\tint ret;\n\t\tenum ffs_os_desc_type type;\n\t\tu16 feature_count;\n\t\tstruct usb_os_desc_header *desc = (void *)data;\n\n\t\tif (len < sizeof(*desc))\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Record \"descriptor\" entity.\n\t\t * Process dwLength, bcdVersion, wIndex, get b/wCount.\n\t\t * Move the data pointer to the beginning of extended\n\t\t * compatibilities proper or extended properties proper\n\t\t * portions of the data\n\t\t */\n\t\tif (le32_to_cpu(desc->dwLength) > len)\n\t\t\treturn -EINVAL;\n\n\t\tret = __ffs_do_os_desc_header(&type, desc);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"entity OS_DESCRIPTOR(%02lx); ret = %d\\n\",\n\t\t\t\t num, ret);\n\t\t\treturn ret;\n\t\t}\n\t\t/*\n\t\t * 16-bit hex \"?? 00\" Little Endian looks like 8-bit hex \"??\"\n\t\t */\n\t\tfeature_count = le16_to_cpu(desc->wCount);\n\t\tif (type == FFS_OS_DESC_EXT_COMPAT &&\n\t\t    (feature_count > 255 || desc->Reserved))\n\t\t\t\treturn -EINVAL;\n\t\tlen -= ret;\n\t\tdata += ret;\n\n\t\t/*\n\t\t * Process all function/property descriptors\n\t\t * of this Feature Descriptor\n\t\t */\n\t\tret = ffs_do_single_os_desc(data, len, type,\n\t\t\t\t\t    feature_count, entity, priv, desc);\n\t\tif (unlikely(ret < 0)) {\n\t\t\tpr_debug(\"%s returns %d\\n\", __func__, ret);\n\t\t\treturn ret;\n\t\t}\n\n\t\tlen -= ret;\n\t\tdata += ret;\n\t}\n\treturn _len - len;\n}\n\n/**\n * Validate contents of the buffer from userspace related to OS descriptors.\n */\nstatic int __ffs_data_do_os_desc(enum ffs_os_desc_type type,\n\t\t\t\t struct usb_os_desc_header *h, void *data,\n\t\t\t\t unsigned len, void *priv)\n{\n\tstruct ffs_data *ffs = priv;\n\tu8 length;\n\n\tENTER();\n\n\tswitch (type) {\n\tcase FFS_OS_DESC_EXT_COMPAT: {\n\t\tstruct usb_ext_compat_desc *d = data;\n\t\tint i;\n\n\t\tif (len < sizeof(*d) ||\n\t\t    d->bFirstInterfaceNumber >= ffs->interfaces_count ||\n\t\t    d->Reserved1)\n\t\t\treturn -EINVAL;\n\t\tfor (i = 0; i < ARRAY_SIZE(d->Reserved2); ++i)\n\t\t\tif (d->Reserved2[i])\n\t\t\t\treturn -EINVAL;\n\n\t\tlength = sizeof(struct usb_ext_compat_desc);\n\t}\n\t\tbreak;\n\tcase FFS_OS_DESC_EXT_PROP: {\n\t\tstruct usb_ext_prop_desc *d = data;\n\t\tu32 type, pdl;\n\t\tu16 pnl;\n\n\t\tif (len < sizeof(*d) || h->interface >= ffs->interfaces_count)\n\t\t\treturn -EINVAL;\n\t\tlength = le32_to_cpu(d->dwSize);\n\t\ttype = le32_to_cpu(d->dwPropertyDataType);\n\t\tif (type < USB_EXT_PROP_UNICODE ||\n\t\t    type > USB_EXT_PROP_UNICODE_MULTI) {\n\t\t\tpr_vdebug(\"unsupported os descriptor property type: %d\",\n\t\t\t\t  type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tpnl = le16_to_cpu(d->wPropertyNameLength);\n\t\tpdl = le32_to_cpu(*(u32 *)((u8 *)data + 10 + pnl));\n\t\tif (length != 14 + pnl + pdl) {\n\t\t\tpr_vdebug(\"invalid os descriptor length: %d pnl:%d pdl:%d (descriptor %d)\\n\",\n\t\t\t\t  length, pnl, pdl, type);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\t++ffs->ms_os_descs_ext_prop_count;\n\t\t/* property name reported to the host as \"WCHAR\"s */\n\t\tffs->ms_os_descs_ext_prop_name_len += pnl * 2;\n\t\tffs->ms_os_descs_ext_prop_data_len += pdl;\n\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\treturn length;\n}\n\nstatic int __ffs_data_got_descs(struct ffs_data *ffs,\n\t\t\t\tchar *const _data, size_t len)\n{\n\tchar *data = _data, *raw_descs;\n\tunsigned os_descs_count = 0, counts[3], flags;\n\tint ret = -EINVAL, i;\n\tstruct ffs_desc_helper helper;\n\n\tENTER();\n\n\tif (get_unaligned_le32(data + 4) != len)\n\t\tgoto error;\n\n\tswitch (get_unaligned_le32(data)) {\n\tcase FUNCTIONFS_DESCRIPTORS_MAGIC:\n\t\tflags = FUNCTIONFS_HAS_FS_DESC | FUNCTIONFS_HAS_HS_DESC;\n\t\tdata += 8;\n\t\tlen  -= 8;\n\t\tbreak;\n\tcase FUNCTIONFS_DESCRIPTORS_MAGIC_V2:\n\t\tflags = get_unaligned_le32(data + 8);\n\t\tffs->user_flags = flags;\n\t\tif (flags & ~(FUNCTIONFS_HAS_FS_DESC |\n\t\t\t      FUNCTIONFS_HAS_HS_DESC |\n\t\t\t      FUNCTIONFS_HAS_SS_DESC |\n\t\t\t      FUNCTIONFS_HAS_MS_OS_DESC |\n\t\t\t      FUNCTIONFS_VIRTUAL_ADDR |\n\t\t\t      FUNCTIONFS_EVENTFD)) {\n\t\t\tret = -ENOSYS;\n\t\t\tgoto error;\n\t\t}\n\t\tdata += 12;\n\t\tlen  -= 12;\n\t\tbreak;\n\tdefault:\n\t\tgoto error;\n\t}\n\n\tif (flags & FUNCTIONFS_EVENTFD) {\n\t\tif (len < 4)\n\t\t\tgoto error;\n\t\tffs->ffs_eventfd =\n\t\t\teventfd_ctx_fdget((int)get_unaligned_le32(data));\n\t\tif (IS_ERR(ffs->ffs_eventfd)) {\n\t\t\tret = PTR_ERR(ffs->ffs_eventfd);\n\t\t\tffs->ffs_eventfd = NULL;\n\t\t\tgoto error;\n\t\t}\n\t\tdata += 4;\n\t\tlen  -= 4;\n\t}\n\n\t/* Read fs_count, hs_count and ss_count (if present) */\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (!(flags & (1 << i))) {\n\t\t\tcounts[i] = 0;\n\t\t} else if (len < 4) {\n\t\t\tgoto error;\n\t\t} else {\n\t\t\tcounts[i] = get_unaligned_le32(data);\n\t\t\tdata += 4;\n\t\t\tlen  -= 4;\n\t\t}\n\t}\n\tif (flags & (1 << i)) {\n\t\tos_descs_count = get_unaligned_le32(data);\n\t\tdata += 4;\n\t\tlen -= 4;\n\t};\n\n\t/* Read descriptors */\n\traw_descs = data;\n\thelper.ffs = ffs;\n\tfor (i = 0; i < 3; ++i) {\n\t\tif (!counts[i])\n\t\t\tcontinue;\n\t\thelper.interfaces_count = 0;\n\t\thelper.eps_count = 0;\n\t\tret = ffs_do_descs(counts[i], data, len,\n\t\t\t\t   __ffs_data_do_entity, &helper);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tif (!ffs->eps_count && !ffs->interfaces_count) {\n\t\t\tffs->eps_count = helper.eps_count;\n\t\t\tffs->interfaces_count = helper.interfaces_count;\n\t\t} else {\n\t\t\tif (ffs->eps_count != helper.eps_count) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tif (ffs->interfaces_count != helper.interfaces_count) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t\tdata += ret;\n\t\tlen  -= ret;\n\t}\n\tif (os_descs_count) {\n\t\tret = ffs_do_os_descs(os_descs_count, data, len,\n\t\t\t\t      __ffs_data_do_os_desc, ffs);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tdata += ret;\n\t\tlen -= ret;\n\t}\n\n\tif (raw_descs == data || len) {\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\n\tffs->raw_descs_data\t= _data;\n\tffs->raw_descs\t\t= raw_descs;\n\tffs->raw_descs_length\t= data - raw_descs;\n\tffs->fs_descs_count\t= counts[0];\n\tffs->hs_descs_count\t= counts[1];\n\tffs->ss_descs_count\t= counts[2];\n\tffs->ms_os_descs_count\t= os_descs_count;\n\n\treturn 0;\n\nerror:\n\tkfree(_data);\n\treturn ret;\n}\n\nstatic int __ffs_data_got_strings(struct ffs_data *ffs,\n\t\t\t\t  char *const _data, size_t len)\n{\n\tu32 str_count, needed_count, lang_count;\n\tstruct usb_gadget_strings **stringtabs, *t;\n\tstruct usb_string *strings, *s;\n\tconst char *data = _data;\n\n\tENTER();\n\n\tif (unlikely(get_unaligned_le32(data) != FUNCTIONFS_STRINGS_MAGIC ||\n\t\t     get_unaligned_le32(data + 4) != len))\n\t\tgoto error;\n\tstr_count  = get_unaligned_le32(data + 8);\n\tlang_count = get_unaligned_le32(data + 12);\n\n\t/* if one is zero the other must be zero */\n\tif (unlikely(!str_count != !lang_count))\n\t\tgoto error;\n\n\t/* Do we have at least as many strings as descriptors need? */\n\tneeded_count = ffs->strings_count;\n\tif (unlikely(str_count < needed_count))\n\t\tgoto error;\n\n\t/*\n\t * If we don't need any strings just return and free all\n\t * memory.\n\t */\n\tif (!needed_count) {\n\t\tkfree(_data);\n\t\treturn 0;\n\t}\n\n\t/* Allocate everything in one chunk so there's less maintenance. */\n\t{\n\t\tunsigned i = 0;\n\t\tvla_group(d);\n\t\tvla_item(d, struct usb_gadget_strings *, stringtabs,\n\t\t\tlang_count + 1);\n\t\tvla_item(d, struct usb_gadget_strings, stringtab, lang_count);\n\t\tvla_item(d, struct usb_string, strings,\n\t\t\tlang_count*(needed_count+1));\n\n\t\tchar *vlabuf = kmalloc(vla_group_size(d), GFP_KERNEL);\n\n\t\tif (unlikely(!vlabuf)) {\n\t\t\tkfree(_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\t/* Initialize the VLA pointers */\n\t\tstringtabs = vla_ptr(vlabuf, d, stringtabs);\n\t\tt = vla_ptr(vlabuf, d, stringtab);\n\t\ti = lang_count;\n\t\tdo {\n\t\t\t*stringtabs++ = t++;\n\t\t} while (--i);\n\t\t*stringtabs = NULL;\n\n\t\t/* stringtabs = vlabuf = d_stringtabs for later kfree */\n\t\tstringtabs = vla_ptr(vlabuf, d, stringtabs);\n\t\tt = vla_ptr(vlabuf, d, stringtab);\n\t\ts = vla_ptr(vlabuf, d, strings);\n\t\tstrings = s;\n\t}\n\n\t/* For each language */\n\tdata += 16;\n\tlen -= 16;\n\n\tdo { /* lang_count > 0 so we can use do-while */\n\t\tunsigned needed = needed_count;\n\n\t\tif (unlikely(len < 3))\n\t\t\tgoto error_free;\n\t\tt->language = get_unaligned_le16(data);\n\t\tt->strings  = s;\n\t\t++t;\n\n\t\tdata += 2;\n\t\tlen -= 2;\n\n\t\t/* For each string */\n\t\tdo { /* str_count > 0 so we can use do-while */\n\t\t\tsize_t length = strnlen(data, len);\n\n\t\t\tif (unlikely(length == len))\n\t\t\t\tgoto error_free;\n\n\t\t\t/*\n\t\t\t * User may provide more strings then we need,\n\t\t\t * if that's the case we simply ignore the\n\t\t\t * rest\n\t\t\t */\n\t\t\tif (likely(needed)) {\n\t\t\t\t/*\n\t\t\t\t * s->id will be set while adding\n\t\t\t\t * function to configuration so for\n\t\t\t\t * now just leave garbage here.\n\t\t\t\t */\n\t\t\t\ts->s = data;\n\t\t\t\t--needed;\n\t\t\t\t++s;\n\t\t\t}\n\n\t\t\tdata += length + 1;\n\t\t\tlen -= length + 1;\n\t\t} while (--str_count);\n\n\t\ts->id = 0;   /* terminator */\n\t\ts->s = NULL;\n\t\t++s;\n\n\t} while (--lang_count);\n\n\t/* Some garbage left? */\n\tif (unlikely(len))\n\t\tgoto error_free;\n\n\t/* Done! */\n\tffs->stringtabs = stringtabs;\n\tffs->raw_strings = _data;\n\n\treturn 0;\n\nerror_free:\n\tkfree(stringtabs);\nerror:\n\tkfree(_data);\n\treturn -EINVAL;\n}\n\n\n/* Events handling and management *******************************************/\n\nstatic void __ffs_event_add(struct ffs_data *ffs,\n\t\t\t    enum usb_functionfs_event_type type)\n{\n\tenum usb_functionfs_event_type rem_type1, rem_type2 = type;\n\tint neg = 0;\n\n\t/*\n\t * Abort any unhandled setup\n\t *\n\t * We do not need to worry about some cmpxchg() changing value\n\t * of ffs->setup_state without holding the lock because when\n\t * state is FFS_SETUP_PENDING cmpxchg() in several places in\n\t * the source does nothing.\n\t */\n\tif (ffs->setup_state == FFS_SETUP_PENDING)\n\t\tffs->setup_state = FFS_SETUP_CANCELLED;\n\n\t/*\n\t * Logic of this function guarantees that there are at most four pending\n\t * evens on ffs->ev.types queue.  This is important because the queue\n\t * has space for four elements only and __ffs_ep0_read_events function\n\t * depends on that limit as well.  If more event types are added, those\n\t * limits have to be revisited or guaranteed to still hold.\n\t */\n\tswitch (type) {\n\tcase FUNCTIONFS_RESUME:\n\t\trem_type2 = FUNCTIONFS_SUSPEND;\n\t\t/* FALL THROUGH */\n\tcase FUNCTIONFS_SUSPEND:\n\tcase FUNCTIONFS_SETUP:\n\t\trem_type1 = type;\n\t\t/* Discard all similar events */\n\t\tbreak;\n\n\tcase FUNCTIONFS_BIND:\n\tcase FUNCTIONFS_UNBIND:\n\tcase FUNCTIONFS_DISABLE:\n\tcase FUNCTIONFS_ENABLE:\n\t\t/* Discard everything other then power management. */\n\t\trem_type1 = FUNCTIONFS_SUSPEND;\n\t\trem_type2 = FUNCTIONFS_RESUME;\n\t\tneg = 1;\n\t\tbreak;\n\n\tdefault:\n\t\tWARN(1, \"%d: unknown event, this should not happen\\n\", type);\n\t\treturn;\n\t}\n\n\t{\n\t\tu8 *ev  = ffs->ev.types, *out = ev;\n\t\tunsigned n = ffs->ev.count;\n\t\tfor (; n; --n, ++ev)\n\t\t\tif ((*ev == rem_type1 || *ev == rem_type2) == neg)\n\t\t\t\t*out++ = *ev;\n\t\t\telse\n\t\t\t\tpr_vdebug(\"purging event %d\\n\", *ev);\n\t\tffs->ev.count = out - ffs->ev.types;\n\t}\n\n\tpr_vdebug(\"adding event %d\\n\", type);\n\tffs->ev.types[ffs->ev.count++] = type;\n\twake_up_locked(&ffs->ev.waitq);\n\tif (ffs->ffs_eventfd)\n\t\teventfd_signal(ffs->ffs_eventfd, 1);\n}\n\nstatic void ffs_event_add(struct ffs_data *ffs,\n\t\t\t  enum usb_functionfs_event_type type)\n{\n\tunsigned long flags;\n\tspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\n\t__ffs_event_add(ffs, type);\n\tspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\n}\n\n/* Bind/unbind USB function hooks *******************************************/\n\nstatic int ffs_ep_addr2idx(struct ffs_data *ffs, u8 endpoint_address)\n{\n\tint i;\n\n\tfor (i = 1; i < ARRAY_SIZE(ffs->eps_addrmap); ++i)\n\t\tif (ffs->eps_addrmap[i] == endpoint_address)\n\t\t\treturn i;\n\treturn -ENOENT;\n}\n\nstatic int __ffs_func_bind_do_descs(enum ffs_entity_type type, u8 *valuep,\n\t\t\t\t    struct usb_descriptor_header *desc,\n\t\t\t\t    void *priv)\n{\n\tstruct usb_endpoint_descriptor *ds = (void *)desc;\n\tstruct ffs_function *func = priv;\n\tstruct ffs_ep *ffs_ep;\n\tunsigned ep_desc_id;\n\tint idx;\n\tstatic const char *speed_names[] = { \"full\", \"high\", \"super\" };\n\n\tif (type != FFS_DESCRIPTOR)\n\t\treturn 0;\n\n\t/*\n\t * If ss_descriptors is not NULL, we are reading super speed\n\t * descriptors; if hs_descriptors is not NULL, we are reading high\n\t * speed descriptors; otherwise, we are reading full speed\n\t * descriptors.\n\t */\n\tif (func->function.ss_descriptors) {\n\t\tep_desc_id = 2;\n\t\tfunc->function.ss_descriptors[(long)valuep] = desc;\n\t} else if (func->function.hs_descriptors) {\n\t\tep_desc_id = 1;\n\t\tfunc->function.hs_descriptors[(long)valuep] = desc;\n\t} else {\n\t\tep_desc_id = 0;\n\t\tfunc->function.fs_descriptors[(long)valuep]    = desc;\n\t}\n\n\tif (!desc || desc->bDescriptorType != USB_DT_ENDPOINT)\n\t\treturn 0;\n\n\tidx = ffs_ep_addr2idx(func->ffs, ds->bEndpointAddress) - 1;\n\tif (idx < 0)\n\t\treturn idx;\n\n\tffs_ep = func->eps + idx;\n\n\tif (unlikely(ffs_ep->descs[ep_desc_id])) {\n\t\tpr_err(\"two %sspeed descriptors for EP %d\\n\",\n\t\t\t  speed_names[ep_desc_id],\n\t\t\t  ds->bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);\n\t\treturn -EINVAL;\n\t}\n\tffs_ep->descs[ep_desc_id] = ds;\n\n\tffs_dump_mem(\": Original  ep desc\", ds, ds->bLength);\n\tif (ffs_ep->ep) {\n\t\tds->bEndpointAddress = ffs_ep->descs[0]->bEndpointAddress;\n\t\tif (!ds->wMaxPacketSize)\n\t\t\tds->wMaxPacketSize = ffs_ep->descs[0]->wMaxPacketSize;\n\t} else {\n\t\tstruct usb_request *req;\n\t\tstruct usb_ep *ep;\n\t\tu8 bEndpointAddress;\n\n\t\t/*\n\t\t * We back up bEndpointAddress because autoconfig overwrites\n\t\t * it with physical endpoint address.\n\t\t */\n\t\tbEndpointAddress = ds->bEndpointAddress;\n\t\tpr_vdebug(\"autoconfig\\n\");\n\t\tep = usb_ep_autoconfig(func->gadget, ds);\n\t\tif (unlikely(!ep))\n\t\t\treturn -ENOTSUPP;\n\t\tep->driver_data = func->eps + idx;\n\n\t\treq = usb_ep_alloc_request(ep, GFP_KERNEL);\n\t\tif (unlikely(!req))\n\t\t\treturn -ENOMEM;\n\n\t\tffs_ep->ep  = ep;\n\t\tffs_ep->req = req;\n\t\tfunc->eps_revmap[ds->bEndpointAddress &\n\t\t\t\t USB_ENDPOINT_NUMBER_MASK] = idx + 1;\n\t\t/*\n\t\t * If we use virtual address mapping, we restore\n\t\t * original bEndpointAddress value.\n\t\t */\n\t\tif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tds->bEndpointAddress = bEndpointAddress;\n\t}\n\tffs_dump_mem(\": Rewritten ep desc\", ds, ds->bLength);\n\n\treturn 0;\n}\n\nstatic int __ffs_func_bind_do_nums(enum ffs_entity_type type, u8 *valuep,\n\t\t\t\t   struct usb_descriptor_header *desc,\n\t\t\t\t   void *priv)\n{\n\tstruct ffs_function *func = priv;\n\tunsigned idx;\n\tu8 newValue;\n\n\tswitch (type) {\n\tdefault:\n\tcase FFS_DESCRIPTOR:\n\t\t/* Handled in previous pass by __ffs_func_bind_do_descs() */\n\t\treturn 0;\n\n\tcase FFS_INTERFACE:\n\t\tidx = *valuep;\n\t\tif (func->interfaces_nums[idx] < 0) {\n\t\t\tint id = usb_interface_id(func->conf, &func->function);\n\t\t\tif (unlikely(id < 0))\n\t\t\t\treturn id;\n\t\t\tfunc->interfaces_nums[idx] = id;\n\t\t}\n\t\tnewValue = func->interfaces_nums[idx];\n\t\tbreak;\n\n\tcase FFS_STRING:\n\t\t/* String' IDs are allocated when fsf_data is bound to cdev */\n\t\tnewValue = func->ffs->stringtabs[0]->strings[*valuep - 1].id;\n\t\tbreak;\n\n\tcase FFS_ENDPOINT:\n\t\t/*\n\t\t * USB_DT_ENDPOINT are handled in\n\t\t * __ffs_func_bind_do_descs().\n\t\t */\n\t\tif (desc->bDescriptorType == USB_DT_ENDPOINT)\n\t\t\treturn 0;\n\n\t\tidx = (*valuep & USB_ENDPOINT_NUMBER_MASK) - 1;\n\t\tif (unlikely(!func->eps[idx].ep))\n\t\t\treturn -EINVAL;\n\n\t\t{\n\t\t\tstruct usb_endpoint_descriptor **descs;\n\t\t\tdescs = func->eps[idx].descs;\n\t\t\tnewValue = descs[descs[0] ? 0 : 1]->bEndpointAddress;\n\t\t}\n\t\tbreak;\n\t}\n\n\tpr_vdebug(\"%02x -> %02x\\n\", *valuep, newValue);\n\t*valuep = newValue;\n\treturn 0;\n}\n\nstatic int __ffs_func_bind_do_os_desc(enum ffs_os_desc_type type,\n\t\t\t\t      struct usb_os_desc_header *h, void *data,\n\t\t\t\t      unsigned len, void *priv)\n{\n\tstruct ffs_function *func = priv;\n\tu8 length = 0;\n\n\tswitch (type) {\n\tcase FFS_OS_DESC_EXT_COMPAT: {\n\t\tstruct usb_ext_compat_desc *desc = data;\n\t\tstruct usb_os_desc_table *t;\n\n\t\tt = &func->function.os_desc_table[desc->bFirstInterfaceNumber];\n\t\tt->if_id = func->interfaces_nums[desc->bFirstInterfaceNumber];\n\t\tmemcpy(t->os_desc->ext_compat_id, &desc->CompatibleID,\n\t\t       ARRAY_SIZE(desc->CompatibleID) +\n\t\t       ARRAY_SIZE(desc->SubCompatibleID));\n\t\tlength = sizeof(*desc);\n\t}\n\t\tbreak;\n\tcase FFS_OS_DESC_EXT_PROP: {\n\t\tstruct usb_ext_prop_desc *desc = data;\n\t\tstruct usb_os_desc_table *t;\n\t\tstruct usb_os_desc_ext_prop *ext_prop;\n\t\tchar *ext_prop_name;\n\t\tchar *ext_prop_data;\n\n\t\tt = &func->function.os_desc_table[h->interface];\n\t\tt->if_id = func->interfaces_nums[h->interface];\n\n\t\text_prop = func->ffs->ms_os_descs_ext_prop_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_avail += sizeof(*ext_prop);\n\n\t\text_prop->type = le32_to_cpu(desc->dwPropertyDataType);\n\t\text_prop->name_len = le16_to_cpu(desc->wPropertyNameLength);\n\t\text_prop->data_len = le32_to_cpu(*(u32 *)\n\t\t\tusb_ext_prop_data_len_ptr(data, ext_prop->name_len));\n\t\tlength = ext_prop->name_len + ext_prop->data_len + 14;\n\n\t\text_prop_name = func->ffs->ms_os_descs_ext_prop_name_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_name_avail +=\n\t\t\text_prop->name_len;\n\n\t\text_prop_data = func->ffs->ms_os_descs_ext_prop_data_avail;\n\t\tfunc->ffs->ms_os_descs_ext_prop_data_avail +=\n\t\t\text_prop->data_len;\n\t\tmemcpy(ext_prop_data,\n\t\t       usb_ext_prop_data_ptr(data, ext_prop->name_len),\n\t\t       ext_prop->data_len);\n\t\t/* unicode data reported to the host as \"WCHAR\"s */\n\t\tswitch (ext_prop->type) {\n\t\tcase USB_EXT_PROP_UNICODE:\n\t\tcase USB_EXT_PROP_UNICODE_ENV:\n\t\tcase USB_EXT_PROP_UNICODE_LINK:\n\t\tcase USB_EXT_PROP_UNICODE_MULTI:\n\t\t\text_prop->data_len *= 2;\n\t\t\tbreak;\n\t\t}\n\t\text_prop->data = ext_prop_data;\n\n\t\tmemcpy(ext_prop_name, usb_ext_prop_name_ptr(data),\n\t\t       ext_prop->name_len);\n\t\t/* property name reported to the host as \"WCHAR\"s */\n\t\text_prop->name_len *= 2;\n\t\text_prop->name = ext_prop_name;\n\n\t\tt->os_desc->ext_prop_len +=\n\t\t\text_prop->name_len + ext_prop->data_len + 14;\n\t\t++t->os_desc->ext_prop_count;\n\t\tlist_add_tail(&ext_prop->entry, &t->os_desc->ext_prop);\n\t}\n\t\tbreak;\n\tdefault:\n\t\tpr_vdebug(\"unknown descriptor: %d\\n\", type);\n\t}\n\n\treturn length;\n}\n\nstatic inline struct f_fs_opts *ffs_do_functionfs_bind(struct usb_function *f,\n\t\t\t\t\t\tstruct usb_configuration *c)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct f_fs_opts *ffs_opts =\n\t\tcontainer_of(f->fi, struct f_fs_opts, func_inst);\n\tint ret;\n\n\tENTER();\n\n\t/*\n\t * Legacy gadget triggers binding in functionfs_ready_callback,\n\t * which already uses locking; taking the same lock here would\n\t * cause a deadlock.\n\t *\n\t * Configfs-enabled gadgets however do need ffs_dev_lock.\n\t */\n\tif (!ffs_opts->no_configfs)\n\t\tffs_dev_lock();\n\tret = ffs_opts->dev->desc_ready ? 0 : -ENODEV;\n\tfunc->ffs = ffs_opts->dev->ffs_data;\n\tif (!ffs_opts->no_configfs)\n\t\tffs_dev_unlock();\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tfunc->conf = c;\n\tfunc->gadget = c->cdev->gadget;\n\n\t/*\n\t * in drivers/usb/gadget/configfs.c:configfs_composite_bind()\n\t * configurations are bound in sequence with list_for_each_entry,\n\t * in each configuration its functions are bound in sequence\n\t * with list_for_each_entry, so we assume no race condition\n\t * with regard to ffs_opts->bound access\n\t */\n\tif (!ffs_opts->refcnt) {\n\t\tret = functionfs_bind(func->ffs, c->cdev);\n\t\tif (ret)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\tffs_opts->refcnt++;\n\tfunc->function.strings = func->ffs->stringtabs;\n\n\treturn ffs_opts;\n}\n\nstatic int _ffs_func_bind(struct usb_configuration *c,\n\t\t\t  struct usb_function *f)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\n\tconst int full = !!func->ffs->fs_descs_count;\n\tconst int high = gadget_is_dualspeed(func->gadget) &&\n\t\tfunc->ffs->hs_descs_count;\n\tconst int super = gadget_is_superspeed(func->gadget) &&\n\t\tfunc->ffs->ss_descs_count;\n\n\tint fs_len, hs_len, ss_len, ret, i;\n\n\t/* Make it a single chunk, less management later on */\n\tvla_group(d);\n\tvla_item_with_sz(d, struct ffs_ep, eps, ffs->eps_count);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, fs_descs,\n\t\tfull ? ffs->fs_descs_count + 1 : 0);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, hs_descs,\n\t\thigh ? ffs->hs_descs_count + 1 : 0);\n\tvla_item_with_sz(d, struct usb_descriptor_header *, ss_descs,\n\t\tsuper ? ffs->ss_descs_count + 1 : 0);\n\tvla_item_with_sz(d, short, inums, ffs->interfaces_count);\n\tvla_item_with_sz(d, struct usb_os_desc_table, os_desc_table,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, char[16], ext_compat,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, struct usb_os_desc, os_desc,\n\t\t\t c->cdev->use_os_string ? ffs->interfaces_count : 0);\n\tvla_item_with_sz(d, struct usb_os_desc_ext_prop, ext_prop,\n\t\t\t ffs->ms_os_descs_ext_prop_count);\n\tvla_item_with_sz(d, char, ext_prop_name,\n\t\t\t ffs->ms_os_descs_ext_prop_name_len);\n\tvla_item_with_sz(d, char, ext_prop_data,\n\t\t\t ffs->ms_os_descs_ext_prop_data_len);\n\tvla_item_with_sz(d, char, raw_descs, ffs->raw_descs_length);\n\tchar *vlabuf;\n\n\tENTER();\n\n\t/* Has descriptors only for speeds gadget does not support */\n\tif (unlikely(!(full | high | super)))\n\t\treturn -ENOTSUPP;\n\n\t/* Allocate a single chunk, less management later on */\n\tvlabuf = kzalloc(vla_group_size(d), GFP_KERNEL);\n\tif (unlikely(!vlabuf))\n\t\treturn -ENOMEM;\n\n\tffs->ms_os_descs_ext_prop_avail = vla_ptr(vlabuf, d, ext_prop);\n\tffs->ms_os_descs_ext_prop_name_avail =\n\t\tvla_ptr(vlabuf, d, ext_prop_name);\n\tffs->ms_os_descs_ext_prop_data_avail =\n\t\tvla_ptr(vlabuf, d, ext_prop_data);\n\n\t/* Copy descriptors  */\n\tmemcpy(vla_ptr(vlabuf, d, raw_descs), ffs->raw_descs,\n\t       ffs->raw_descs_length);\n\n\tmemset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);\n\tfor (ret = ffs->eps_count; ret; --ret) {\n\t\tstruct ffs_ep *ptr;\n\n\t\tptr = vla_ptr(vlabuf, d, eps);\n\t\tptr[ret].num = -1;\n\t}\n\n\t/* Save pointers\n\t * d_eps == vlabuf, func->eps used to kfree vlabuf later\n\t*/\n\tfunc->eps             = vla_ptr(vlabuf, d, eps);\n\tfunc->interfaces_nums = vla_ptr(vlabuf, d, inums);\n\n\t/*\n\t * Go through all the endpoint descriptors and allocate\n\t * endpoints first, so that later we can rewrite the endpoint\n\t * numbers without worrying that it may be described later on.\n\t */\n\tif (likely(full)) {\n\t\tfunc->function.fs_descriptors = vla_ptr(vlabuf, d, fs_descs);\n\t\tfs_len = ffs_do_descs(ffs->fs_descs_count,\n\t\t\t\t      vla_ptr(vlabuf, d, raw_descs),\n\t\t\t\t      d_raw_descs__sz,\n\t\t\t\t      __ffs_func_bind_do_descs, func);\n\t\tif (unlikely(fs_len < 0)) {\n\t\t\tret = fs_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tfs_len = 0;\n\t}\n\n\tif (likely(high)) {\n\t\tfunc->function.hs_descriptors = vla_ptr(vlabuf, d, hs_descs);\n\t\ths_len = ffs_do_descs(ffs->hs_descs_count,\n\t\t\t\t      vla_ptr(vlabuf, d, raw_descs) + fs_len,\n\t\t\t\t      d_raw_descs__sz - fs_len,\n\t\t\t\t      __ffs_func_bind_do_descs, func);\n\t\tif (unlikely(hs_len < 0)) {\n\t\t\tret = hs_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\ths_len = 0;\n\t}\n\n\tif (likely(super)) {\n\t\tfunc->function.ss_descriptors = vla_ptr(vlabuf, d, ss_descs);\n\t\tss_len = ffs_do_descs(ffs->ss_descs_count,\n\t\t\t\tvla_ptr(vlabuf, d, raw_descs) + fs_len + hs_len,\n\t\t\t\td_raw_descs__sz - fs_len - hs_len,\n\t\t\t\t__ffs_func_bind_do_descs, func);\n\t\tif (unlikely(ss_len < 0)) {\n\t\t\tret = ss_len;\n\t\t\tgoto error;\n\t\t}\n\t} else {\n\t\tss_len = 0;\n\t}\n\n\t/*\n\t * Now handle interface numbers allocation and interface and\n\t * endpoint numbers rewriting.  We can do that in one go\n\t * now.\n\t */\n\tret = ffs_do_descs(ffs->fs_descs_count +\n\t\t\t   (high ? ffs->hs_descs_count : 0) +\n\t\t\t   (super ? ffs->ss_descs_count : 0),\n\t\t\t   vla_ptr(vlabuf, d, raw_descs), d_raw_descs__sz,\n\t\t\t   __ffs_func_bind_do_nums, func);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\n\tfunc->function.os_desc_table = vla_ptr(vlabuf, d, os_desc_table);\n\tif (c->cdev->use_os_string)\n\t\tfor (i = 0; i < ffs->interfaces_count; ++i) {\n\t\t\tstruct usb_os_desc *desc;\n\n\t\t\tdesc = func->function.os_desc_table[i].os_desc =\n\t\t\t\tvla_ptr(vlabuf, d, os_desc) +\n\t\t\t\ti * sizeof(struct usb_os_desc);\n\t\t\tdesc->ext_compat_id =\n\t\t\t\tvla_ptr(vlabuf, d, ext_compat) + i * 16;\n\t\t\tINIT_LIST_HEAD(&desc->ext_prop);\n\t\t}\n\tret = ffs_do_os_descs(ffs->ms_os_descs_count,\n\t\t\t      vla_ptr(vlabuf, d, raw_descs) +\n\t\t\t      fs_len + hs_len + ss_len,\n\t\t\t      d_raw_descs__sz - fs_len - hs_len - ss_len,\n\t\t\t      __ffs_func_bind_do_os_desc, func);\n\tif (unlikely(ret < 0))\n\t\tgoto error;\n\tfunc->function.os_desc_n =\n\t\tc->cdev->use_os_string ? ffs->interfaces_count : 0;\n\n\t/* And we're done */\n\tffs_event_add(ffs, FUNCTIONFS_BIND);\n\treturn 0;\n\nerror:\n\t/* XXX Do we need to release all claimed endpoints here? */\n\treturn ret;\n}\n\nstatic int ffs_func_bind(struct usb_configuration *c,\n\t\t\t struct usb_function *f)\n{\n\tstruct f_fs_opts *ffs_opts = ffs_do_functionfs_bind(f, c);\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tint ret;\n\n\tif (IS_ERR(ffs_opts))\n\t\treturn PTR_ERR(ffs_opts);\n\n\tret = _ffs_func_bind(c, f);\n\tif (ret && !--ffs_opts->refcnt)\n\t\tfunctionfs_unbind(func->ffs);\n\n\treturn ret;\n}\n\n\n/* Other USB function hooks *************************************************/\n\nstatic void ffs_reset_work(struct work_struct *work)\n{\n\tstruct ffs_data *ffs = container_of(work,\n\t\tstruct ffs_data, reset_work);\n\tffs_data_reset(ffs);\n}\n\nstatic int ffs_func_set_alt(struct usb_function *f,\n\t\t\t    unsigned interface, unsigned alt)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tint ret = 0, intf;\n\n\tif (alt != (unsigned)-1) {\n\t\tintf = ffs_func_revmap_intf(func, interface);\n\t\tif (unlikely(intf < 0))\n\t\t\treturn intf;\n\t}\n\n\tif (ffs->func)\n\t\tffs_func_eps_disable(ffs->func);\n\n\tif (ffs->state == FFS_DEACTIVATED) {\n\t\tffs->state = FFS_CLOSING;\n\t\tINIT_WORK(&ffs->reset_work, ffs_reset_work);\n\t\tschedule_work(&ffs->reset_work);\n\t\treturn -ENODEV;\n\t}\n\n\tif (ffs->state != FFS_ACTIVE)\n\t\treturn -ENODEV;\n\n\tif (alt == (unsigned)-1) {\n\t\tffs->func = NULL;\n\t\tffs_event_add(ffs, FUNCTIONFS_DISABLE);\n\t\treturn 0;\n\t}\n\n\tffs->func = func;\n\tret = ffs_func_eps_enable(func);\n\tif (likely(ret >= 0))\n\t\tffs_event_add(ffs, FUNCTIONFS_ENABLE);\n\treturn ret;\n}\n\nstatic void ffs_func_disable(struct usb_function *f)\n{\n\tffs_func_set_alt(f, 0, (unsigned)-1);\n}\n\nstatic int ffs_func_setup(struct usb_function *f,\n\t\t\t  const struct usb_ctrlrequest *creq)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tunsigned long flags;\n\tint ret;\n\n\tENTER();\n\n\tpr_vdebug(\"creq->bRequestType = %02x\\n\", creq->bRequestType);\n\tpr_vdebug(\"creq->bRequest     = %02x\\n\", creq->bRequest);\n\tpr_vdebug(\"creq->wValue       = %04x\\n\", le16_to_cpu(creq->wValue));\n\tpr_vdebug(\"creq->wIndex       = %04x\\n\", le16_to_cpu(creq->wIndex));\n\tpr_vdebug(\"creq->wLength      = %04x\\n\", le16_to_cpu(creq->wLength));\n\n\t/*\n\t * Most requests directed to interface go through here\n\t * (notable exceptions are set/get interface) so we need to\n\t * handle them.  All other either handled by composite or\n\t * passed to usb_configuration->setup() (if one is set).  No\n\t * matter, we will handle requests directed to endpoint here\n\t * as well (as it's straightforward) but what to do with any\n\t * other request?\n\t */\n\tif (ffs->state != FFS_ACTIVE)\n\t\treturn -ENODEV;\n\n\tswitch (creq->bRequestType & USB_RECIP_MASK) {\n\tcase USB_RECIP_INTERFACE:\n\t\tret = ffs_func_revmap_intf(func, le16_to_cpu(creq->wIndex));\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase USB_RECIP_ENDPOINT:\n\t\tret = ffs_func_revmap_ep(func, le16_to_cpu(creq->wIndex));\n\t\tif (unlikely(ret < 0))\n\t\t\treturn ret;\n\t\tif (func->ffs->user_flags & FUNCTIONFS_VIRTUAL_ADDR)\n\t\t\tret = func->ffs->eps_addrmap[ret];\n\t\tbreak;\n\n\tdefault:\n\t\treturn -EOPNOTSUPP;\n\t}\n\n\tspin_lock_irqsave(&ffs->ev.waitq.lock, flags);\n\tffs->ev.setup = *creq;\n\tffs->ev.setup.wIndex = cpu_to_le16(ret);\n\t__ffs_event_add(ffs, FUNCTIONFS_SETUP);\n\tspin_unlock_irqrestore(&ffs->ev.waitq.lock, flags);\n\n\treturn 0;\n}\n\nstatic void ffs_func_suspend(struct usb_function *f)\n{\n\tENTER();\n\tffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_SUSPEND);\n}\n\nstatic void ffs_func_resume(struct usb_function *f)\n{\n\tENTER();\n\tffs_event_add(ffs_func_from_usb(f)->ffs, FUNCTIONFS_RESUME);\n}\n\n\n/* Endpoint and interface numbers reverse mapping ***************************/\n\nstatic int ffs_func_revmap_ep(struct ffs_function *func, u8 num)\n{\n\tnum = func->eps_revmap[num & USB_ENDPOINT_NUMBER_MASK];\n\treturn num ? num : -EDOM;\n}\n\nstatic int ffs_func_revmap_intf(struct ffs_function *func, u8 intf)\n{\n\tshort *nums = func->interfaces_nums;\n\tunsigned count = func->ffs->interfaces_count;\n\n\tfor (; count; --count, ++nums) {\n\t\tif (*nums >= 0 && *nums == intf)\n\t\t\treturn nums - func->interfaces_nums;\n\t}\n\n\treturn -EDOM;\n}\n\n\n/* Devices management *******************************************************/\n\nstatic LIST_HEAD(ffs_devices);\n\nstatic struct ffs_dev *_ffs_do_find_dev(const char *name)\n{\n\tstruct ffs_dev *dev;\n\n\tlist_for_each_entry(dev, &ffs_devices, entry) {\n\t\tif (!dev->name || !name)\n\t\t\tcontinue;\n\t\tif (strcmp(dev->name, name) == 0)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic struct ffs_dev *_ffs_get_single_dev(void)\n{\n\tstruct ffs_dev *dev;\n\n\tif (list_is_singular(&ffs_devices)) {\n\t\tdev = list_first_entry(&ffs_devices, struct ffs_dev, entry);\n\t\tif (dev->single)\n\t\t\treturn dev;\n\t}\n\n\treturn NULL;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic struct ffs_dev *_ffs_find_dev(const char *name)\n{\n\tstruct ffs_dev *dev;\n\n\tdev = _ffs_get_single_dev();\n\tif (dev)\n\t\treturn dev;\n\n\treturn _ffs_do_find_dev(name);\n}\n\n/* Configfs support *********************************************************/\n\nstatic inline struct f_fs_opts *to_ffs_opts(struct config_item *item)\n{\n\treturn container_of(to_config_group(item), struct f_fs_opts,\n\t\t\t    func_inst.group);\n}\n\nstatic void ffs_attr_release(struct config_item *item)\n{\n\tstruct f_fs_opts *opts = to_ffs_opts(item);\n\n\tusb_put_function_instance(&opts->func_inst);\n}\n\nstatic struct configfs_item_operations ffs_item_ops = {\n\t.release\t= ffs_attr_release,\n};\n\nstatic struct config_item_type ffs_func_type = {\n\t.ct_item_ops\t= &ffs_item_ops,\n\t.ct_owner\t= THIS_MODULE,\n};\n\n\n/* Function registration interface ******************************************/\n\nstatic void ffs_free_inst(struct usb_function_instance *f)\n{\n\tstruct f_fs_opts *opts;\n\n\topts = to_f_fs_opts(f);\n\tffs_dev_lock();\n\t_ffs_free_dev(opts->dev);\n\tffs_dev_unlock();\n\tkfree(opts);\n}\n\n#define MAX_INST_NAME_LEN\t40\n\nstatic int ffs_set_inst_name(struct usb_function_instance *fi, const char *name)\n{\n\tstruct f_fs_opts *opts;\n\tchar *ptr;\n\tconst char *tmp;\n\tint name_len, ret;\n\n\tname_len = strlen(name) + 1;\n\tif (name_len > MAX_INST_NAME_LEN)\n\t\treturn -ENAMETOOLONG;\n\n\tptr = kstrndup(name, name_len, GFP_KERNEL);\n\tif (!ptr)\n\t\treturn -ENOMEM;\n\n\topts = to_f_fs_opts(fi);\n\ttmp = NULL;\n\n\tffs_dev_lock();\n\n\ttmp = opts->dev->name_allocated ? opts->dev->name : NULL;\n\tret = _ffs_name_dev(opts->dev, ptr);\n\tif (ret) {\n\t\tkfree(ptr);\n\t\tffs_dev_unlock();\n\t\treturn ret;\n\t}\n\topts->dev->name_allocated = true;\n\n\tffs_dev_unlock();\n\n\tkfree(tmp);\n\n\treturn 0;\n}\n\nstatic struct usb_function_instance *ffs_alloc_inst(void)\n{\n\tstruct f_fs_opts *opts;\n\tstruct ffs_dev *dev;\n\n\topts = kzalloc(sizeof(*opts), GFP_KERNEL);\n\tif (!opts)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\topts->func_inst.set_inst_name = ffs_set_inst_name;\n\topts->func_inst.free_func_inst = ffs_free_inst;\n\tffs_dev_lock();\n\tdev = _ffs_alloc_dev();\n\tffs_dev_unlock();\n\tif (IS_ERR(dev)) {\n\t\tkfree(opts);\n\t\treturn ERR_CAST(dev);\n\t}\n\topts->dev = dev;\n\tdev->opts = opts;\n\n\tconfig_group_init_type_name(&opts->func_inst.group, \"\",\n\t\t\t\t    &ffs_func_type);\n\treturn &opts->func_inst;\n}\n\nstatic void ffs_free(struct usb_function *f)\n{\n\tkfree(ffs_func_from_usb(f));\n}\n\nstatic void ffs_func_unbind(struct usb_configuration *c,\n\t\t\t    struct usb_function *f)\n{\n\tstruct ffs_function *func = ffs_func_from_usb(f);\n\tstruct ffs_data *ffs = func->ffs;\n\tstruct f_fs_opts *opts =\n\t\tcontainer_of(f->fi, struct f_fs_opts, func_inst);\n\tstruct ffs_ep *ep = func->eps;\n\tunsigned count = ffs->eps_count;\n\tunsigned long flags;\n\n\tENTER();\n\tif (ffs->func == func) {\n\t\tffs_func_eps_disable(func);\n\t\tffs->func = NULL;\n\t}\n\n\tif (!--opts->refcnt)\n\t\tfunctionfs_unbind(ffs);\n\n\t/* cleanup after autoconfig */\n\tspin_lock_irqsave(&func->ffs->eps_lock, flags);\n\tdo {\n\t\tif (ep->ep && ep->req)\n\t\t\tusb_ep_free_request(ep->ep, ep->req);\n\t\tep->req = NULL;\n\t\t++ep;\n\t} while (--count);\n\tspin_unlock_irqrestore(&func->ffs->eps_lock, flags);\n\tkfree(func->eps);\n\tfunc->eps = NULL;\n\t/*\n\t * eps, descriptors and interfaces_nums are allocated in the\n\t * same chunk so only one free is required.\n\t */\n\tfunc->function.fs_descriptors = NULL;\n\tfunc->function.hs_descriptors = NULL;\n\tfunc->function.ss_descriptors = NULL;\n\tfunc->interfaces_nums = NULL;\n\n\tffs_event_add(ffs, FUNCTIONFS_UNBIND);\n}\n\nstatic struct usb_function *ffs_alloc(struct usb_function_instance *fi)\n{\n\tstruct ffs_function *func;\n\n\tENTER();\n\n\tfunc = kzalloc(sizeof(*func), GFP_KERNEL);\n\tif (unlikely(!func))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfunc->function.name    = \"Function FS Gadget\";\n\n\tfunc->function.bind    = ffs_func_bind;\n\tfunc->function.unbind  = ffs_func_unbind;\n\tfunc->function.set_alt = ffs_func_set_alt;\n\tfunc->function.disable = ffs_func_disable;\n\tfunc->function.setup   = ffs_func_setup;\n\tfunc->function.suspend = ffs_func_suspend;\n\tfunc->function.resume  = ffs_func_resume;\n\tfunc->function.free_func = ffs_free;\n\n\treturn &func->function;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic struct ffs_dev *_ffs_alloc_dev(void)\n{\n\tstruct ffs_dev *dev;\n\tint ret;\n\n\tif (_ffs_get_single_dev())\n\t\t\treturn ERR_PTR(-EBUSY);\n\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (list_empty(&ffs_devices)) {\n\t\tret = functionfs_init();\n\t\tif (ret) {\n\t\t\tkfree(dev);\n\t\t\treturn ERR_PTR(ret);\n\t\t}\n\t}\n\n\tlist_add(&dev->entry, &ffs_devices);\n\n\treturn dev;\n}\n\n/*\n * ffs_lock must be taken by the caller of this function\n * The caller is responsible for \"name\" being available whenever f_fs needs it\n */\nstatic int _ffs_name_dev(struct ffs_dev *dev, const char *name)\n{\n\tstruct ffs_dev *existing;\n\n\texisting = _ffs_do_find_dev(name);\n\tif (existing)\n\t\treturn -EBUSY;\n\n\tdev->name = name;\n\n\treturn 0;\n}\n\n/*\n * The caller is responsible for \"name\" being available whenever f_fs needs it\n */\nint ffs_name_dev(struct ffs_dev *dev, const char *name)\n{\n\tint ret;\n\n\tffs_dev_lock();\n\tret = _ffs_name_dev(dev, name);\n\tffs_dev_unlock();\n\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ffs_name_dev);\n\nint ffs_single_dev(struct ffs_dev *dev)\n{\n\tint ret;\n\n\tret = 0;\n\tffs_dev_lock();\n\n\tif (!list_is_singular(&ffs_devices))\n\t\tret = -EBUSY;\n\telse\n\t\tdev->single = true;\n\n\tffs_dev_unlock();\n\treturn ret;\n}\nEXPORT_SYMBOL_GPL(ffs_single_dev);\n\n/*\n * ffs_lock must be taken by the caller of this function\n */\nstatic void _ffs_free_dev(struct ffs_dev *dev)\n{\n\tlist_del(&dev->entry);\n\tif (dev->name_allocated)\n\t\tkfree(dev->name);\n\tkfree(dev);\n\tif (list_empty(&ffs_devices))\n\t\tfunctionfs_cleanup();\n}\n\nstatic void *ffs_acquire_dev(const char *dev_name)\n{\n\tstruct ffs_dev *ffs_dev;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_dev = _ffs_find_dev(dev_name);\n\tif (!ffs_dev)\n\t\tffs_dev = ERR_PTR(-ENOENT);\n\telse if (ffs_dev->mounted)\n\t\tffs_dev = ERR_PTR(-EBUSY);\n\telse if (ffs_dev->ffs_acquire_dev_callback &&\n\t    ffs_dev->ffs_acquire_dev_callback(ffs_dev))\n\t\tffs_dev = ERR_PTR(-ENOENT);\n\telse\n\t\tffs_dev->mounted = true;\n\n\tffs_dev_unlock();\n\treturn ffs_dev;\n}\n\nstatic void ffs_release_dev(struct ffs_data *ffs_data)\n{\n\tstruct ffs_dev *ffs_dev;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_dev = ffs_data->private_data;\n\tif (ffs_dev) {\n\t\tffs_dev->mounted = false;\n\n\t\tif (ffs_dev->ffs_release_dev_callback)\n\t\t\tffs_dev->ffs_release_dev_callback(ffs_dev);\n\t}\n\n\tffs_dev_unlock();\n}\n\nstatic int ffs_ready(struct ffs_data *ffs)\n{\n\tstruct ffs_dev *ffs_obj;\n\tint ret = 0;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_obj = ffs->private_data;\n\tif (!ffs_obj) {\n\t\tret = -EINVAL;\n\t\tgoto done;\n\t}\n\tif (WARN_ON(ffs_obj->desc_ready)) {\n\t\tret = -EBUSY;\n\t\tgoto done;\n\t}\n\n\tffs_obj->desc_ready = true;\n\tffs_obj->ffs_data = ffs;\n\n\tif (ffs_obj->ffs_ready_callback) {\n\t\tret = ffs_obj->ffs_ready_callback(ffs);\n\t\tif (ret)\n\t\t\tgoto done;\n\t}\n\n\tset_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags);\ndone:\n\tffs_dev_unlock();\n\treturn ret;\n}\n\nstatic void ffs_closed(struct ffs_data *ffs)\n{\n\tstruct ffs_dev *ffs_obj;\n\tstruct f_fs_opts *opts;\n\n\tENTER();\n\tffs_dev_lock();\n\n\tffs_obj = ffs->private_data;\n\tif (!ffs_obj)\n\t\tgoto done;\n\n\tffs_obj->desc_ready = false;\n\n\tif (test_and_clear_bit(FFS_FL_CALL_CLOSED_CALLBACK, &ffs->flags) &&\n\t    ffs_obj->ffs_closed_callback)\n\t\tffs_obj->ffs_closed_callback(ffs);\n\n\tif (ffs_obj->opts)\n\t\topts = ffs_obj->opts;\n\telse\n\t\tgoto done;\n\n\tif (opts->no_configfs || !opts->func_inst.group.cg_item.ci_parent\n\t    || !atomic_read(&opts->func_inst.group.cg_item.ci_kref.refcount))\n\t\tgoto done;\n\n\tunregister_gadget_item(ffs_obj->opts->\n\t\t\t       func_inst.group.cg_item.ci_parent->ci_parent);\ndone:\n\tffs_dev_unlock();\n}\n\n/* Misc helper functions ****************************************************/\n\nstatic int ffs_mutex_lock(struct mutex *mutex, unsigned nonblock)\n{\n\treturn nonblock\n\t\t? likely(mutex_trylock(mutex)) ? 0 : -EAGAIN\n\t\t: mutex_lock_interruptible(mutex);\n}\n\nstatic char *ffs_prepare_buffer(const char __user *buf, size_t len)\n{\n\tchar *data;\n\n\tif (unlikely(!len))\n\t\treturn NULL;\n\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (unlikely(!data))\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tif (unlikely(copy_from_user(data, buf, len))) {\n\t\tkfree(data);\n\t\treturn ERR_PTR(-EFAULT);\n\t}\n\n\tpr_vdebug(\"Buffer from user space:\\n\");\n\tffs_dump_mem(\"\", data, len);\n\n\treturn data;\n}\n\nDECLARE_USB_FUNCTION_INIT(ffs, ffs_alloc_inst, ffs_alloc);\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"Michal Nazarewicz\");\n"], "filenames": ["drivers/usb/gadget/function/f_fs.c"], "buggy_code_start_loc": [648], "buggy_code_end_loc": [667], "fixing_code_start_loc": [649], "fixing_code_end_loc": [665], "type": "CWE-416", "message": "Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call.", "other": {"cve": {"id": "CVE-2016-7912", "sourceIdentifier": "security@android.com", "published": "2016-11-16T05:59:07.140", "lastModified": "2023-01-19T16:07:54.107", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call."}, {"lang": "es", "value": "Vulnerabilidad de uso despu\u00e9s de liberaci\u00f3n de memoria en la funci\u00f3n ffs_user_copy_worker en drivers/usb/gadget/function/f_fs.c en el kernel de Linux en versiones anteriores a 4.5.3 permite a usuarios locales obtener privilegios accediendo a una estructura de datos I/O despues de cierta devoluci\u00f3n de llamada."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.15", "versionEndExcluding": "3.16.40", "matchCriteriaId": "8044E5E3-F206-4F04-844C-EC3BC8FE2FD1"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17", "versionEndExcluding": "4.1.24", "matchCriteriaId": "18BCB55C-2C7E-457F-A780-E7CF9610104F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.9", "matchCriteriaId": "0D383D96-EBCF-47EA-A479-DA86045C1C1D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5", "versionEndExcluding": "4.5.3", "matchCriteriaId": "159A2E6D-BE26-4EC9-9346-1E5F3B6B5D36"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=38740a5b87d53ceb89eb2c970150f6e94e00373a", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://source.android.com/security/bulletin/2016-11-01.html", "source": "security@android.com", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.5.3", "source": "security@android.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/94197", "source": "security@android.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a", "source": "security@android.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a"}}