{"buggy_code": ["# pylint: disable=unused-argument, no-self-use, avoid-list-comprehension\nimport difflib\n\nfrom django.db.models import signals\nfrom django.http import HttpResponseRedirect\nfrom django.template.defaultfilters import safe\nfrom django.utils.translation import gettext_lazy as _\nfrom simple_history.admin import SimpleHistoryAdmin\nfrom simple_history.models import HistoricalRecords\n\n\ndef diff_objects(old_instance, new_instance, fields):\n    \"\"\"\n    Diff two objects by examining the given fields and\n    return a string.\n    \"\"\"\n    full_diff = []\n\n    for field in fields:\n        field_diff = []\n        old_value = getattr(old_instance, field.attname)\n        new_value = getattr(new_instance, field.attname)\n        for line in difflib.unified_diff(\n            str(old_value).split(\"\\n\"),\n            str(new_value).split(\"\\n\"),\n            fromfile=field.attname,\n            tofile=field.attname,\n            lineterm=\"\",\n        ):\n            field_diff.append(line)\n        full_diff.extend(field_diff)\n\n    return \"\\n\".join(full_diff)\n\n\ndef history_email_for(instance, title):\n    \"\"\"\n    Generate the subject and email body that is sent via\n    email notifications post update!\n    \"\"\"\n    history = instance.history.latest()\n\n    subject = _(\"UPDATE: %(model_name)s #%(pk)d - %(title)s\") % {\n        \"model_name\": instance.__class__.__name__,\n        \"pk\": instance.pk,\n        \"title\": title,\n    }\n\n    body = (\n        _(\n            \"\"\"Updated on %(history_date)s\nUpdated by %(username)s\n\n%(diff)s\n\nFor more information:\n%(instance_url)s\"\"\"\n        )\n        % {\n            \"history_date\": history.history_date.strftime(\"%c\"),\n            \"username\": getattr(history.history_user, \"username\", \"\"),\n            \"diff\": history.history_change_reason,\n            \"instance_url\": instance.get_full_url(),\n        }\n    )\n    return subject, body\n\n\nclass KiwiHistoricalRecords(HistoricalRecords):\n    \"\"\"\n    This class will keep track of what fields were changed\n    inside of the ``history_change_reason`` field. This gives us\n    a crude changelog until upstream introduces their new interface.\n    \"\"\"\n\n    def pre_save(self, instance, **kwargs):\n        \"\"\"\n        Signal handlers don't have access to the previous version of\n        an object so we have to load it from the database!\n        \"\"\"\n        if kwargs.get(\"raw\", False):\n            return\n\n        if instance.pk and hasattr(instance, \"history\"):\n            instance.previous = instance.__class__.objects.filter(\n                pk=instance.pk\n            ).first()\n\n    def post_save(self, instance, created, using=None, **kwargs):\n        \"\"\"\n        Calculate the changelog and call the inherited method to\n        write the data into the database.\n        \"\"\"\n        if kwargs.get(\"raw\", False):\n            return\n\n        if hasattr(instance, \"previous\") and instance.previous:\n            # note: simple_history.utils.update_change_reason() performs an extra\n            # DB query so it is better to use the private field instead!\n            # In older simple_history version this field wasn't private but was renamed\n            # in 2.10.0 hence the pylint disable!\n            instance._change_reason = diff_objects(  # pylint: disable=protected-access\n                instance.previous, instance, self.fields_included(instance)\n            )\n        super().post_save(instance, created, using, **kwargs)\n\n    def finalize(self, sender, **kwargs):\n        \"\"\"\n        Connect the pre_save signal handler after calling the inherited method.\n        \"\"\"\n        super().finalize(sender, **kwargs)\n        signals.pre_save.connect(self.pre_save, sender=sender, weak=False)\n\n\nclass ReadOnlyHistoryAdmin(SimpleHistoryAdmin):\n    \"\"\"\n    Custom history admin which shows all fields\n    as read-only.\n    \"\"\"\n\n    history_list_display = [\"Diff\"]\n\n    def Diff(self, obj):  # pylint: disable=invalid-name\n        return safe(f\"<pre>{obj.history_change_reason}</pre>\")\n\n    def get_readonly_fields(self, request, obj=None):\n        # make all fields readonly\n        readonly_fields = list(\n            set(\n                [field.name for field in self.opts.local_fields]\n                + [field.name for field in self.opts.local_many_to_many]\n            )\n        )\n        return readonly_fields\n\n    def response_change(self, request, obj):\n        super().response_change(request, obj)\n        return HttpResponseRedirect(obj.get_absolute_url())\n"], "fixing_code": ["# pylint: disable=unused-argument, no-self-use, avoid-list-comprehension\nimport difflib\n\nfrom django.db.models import signals\nfrom django.http import HttpResponseRedirect\nfrom django.template.defaultfilters import safe\nfrom django.utils.translation import gettext_lazy as _\nfrom simple_history.admin import SimpleHistoryAdmin\nfrom simple_history.models import HistoricalRecords\n\nfrom tcms.core.templatetags.extra_filters import bleach_input\n\n\ndef diff_objects(old_instance, new_instance, fields):\n    \"\"\"\n    Diff two objects by examining the given fields and\n    return a string.\n    \"\"\"\n    full_diff = []\n\n    for field in fields:\n        field_diff = []\n        old_value = getattr(old_instance, field.attname)\n        new_value = getattr(new_instance, field.attname)\n\n        # clean stored XSS\n        if isinstance(old_value, str):\n            old_value = bleach_input(old_value)\n        if isinstance(new_value, str):\n            new_value = bleach_input(new_value)\n\n        for line in difflib.unified_diff(\n            str(old_value).split(\"\\n\"),\n            str(new_value).split(\"\\n\"),\n            fromfile=field.attname,\n            tofile=field.attname,\n            lineterm=\"\",\n        ):\n            field_diff.append(line)\n        full_diff.extend(field_diff)\n\n    return \"\\n\".join(full_diff)\n\n\ndef history_email_for(instance, title):\n    \"\"\"\n    Generate the subject and email body that is sent via\n    email notifications post update!\n    \"\"\"\n    history = instance.history.latest()\n\n    subject = _(\"UPDATE: %(model_name)s #%(pk)d - %(title)s\") % {\n        \"model_name\": instance.__class__.__name__,\n        \"pk\": instance.pk,\n        \"title\": title,\n    }\n\n    body = (\n        _(\n            \"\"\"Updated on %(history_date)s\nUpdated by %(username)s\n\n%(diff)s\n\nFor more information:\n%(instance_url)s\"\"\"\n        )\n        % {\n            \"history_date\": history.history_date.strftime(\"%c\"),\n            \"username\": getattr(history.history_user, \"username\", \"\"),\n            \"diff\": history.history_change_reason,\n            \"instance_url\": instance.get_full_url(),\n        }\n    )\n    return subject, body\n\n\nclass KiwiHistoricalRecords(HistoricalRecords):\n    \"\"\"\n    This class will keep track of what fields were changed\n    inside of the ``history_change_reason`` field. This gives us\n    a crude changelog until upstream introduces their new interface.\n    \"\"\"\n\n    def pre_save(self, instance, **kwargs):\n        \"\"\"\n        Signal handlers don't have access to the previous version of\n        an object so we have to load it from the database!\n        \"\"\"\n        if kwargs.get(\"raw\", False):\n            return\n\n        if instance.pk and hasattr(instance, \"history\"):\n            instance.previous = instance.__class__.objects.filter(\n                pk=instance.pk\n            ).first()\n\n    def post_save(self, instance, created, using=None, **kwargs):\n        \"\"\"\n        Calculate the changelog and call the inherited method to\n        write the data into the database.\n        \"\"\"\n        if kwargs.get(\"raw\", False):\n            return\n\n        if hasattr(instance, \"previous\") and instance.previous:\n            # note: simple_history.utils.update_change_reason() performs an extra\n            # DB query so it is better to use the private field instead!\n            # In older simple_history version this field wasn't private but was renamed\n            # in 2.10.0 hence the pylint disable!\n            instance._change_reason = diff_objects(  # pylint: disable=protected-access\n                instance.previous, instance, self.fields_included(instance)\n            )\n        super().post_save(instance, created, using, **kwargs)\n\n    def finalize(self, sender, **kwargs):\n        \"\"\"\n        Connect the pre_save signal handler after calling the inherited method.\n        \"\"\"\n        super().finalize(sender, **kwargs)\n        signals.pre_save.connect(self.pre_save, sender=sender, weak=False)\n\n\nclass ReadOnlyHistoryAdmin(SimpleHistoryAdmin):\n    \"\"\"\n    Custom history admin which shows all fields\n    as read-only.\n    \"\"\"\n\n    history_list_display = [\"Diff\"]\n\n    def Diff(self, obj):  # pylint: disable=invalid-name\n        return safe(f\"<pre>{obj.history_change_reason}</pre>\")\n\n    def get_readonly_fields(self, request, obj=None):\n        # make all fields readonly\n        readonly_fields = list(\n            set(\n                [field.name for field in self.opts.local_fields]\n                + [field.name for field in self.opts.local_many_to_many]\n            )\n        )\n        return readonly_fields\n\n    def response_change(self, request, obj):\n        super().response_change(request, obj)\n        return HttpResponseRedirect(obj.get_absolute_url())\n"], "filenames": ["tcms/core/history.py"], "buggy_code_start_loc": [9], "buggy_code_end_loc": [22], "fixing_code_start_loc": [10], "fixing_code_end_loc": [32], "type": "CWE-79", "message": "A stored XSS in a kiwi Test Plan can run malicious javascript which could be chained with an HTML injection to perform a UI redressing attack (clickjacking) and an HTML injection which disables the use of the history page.", "other": {"cve": {"id": "CVE-2022-4105", "sourceIdentifier": "security@huntr.dev", "published": "2022-11-21T20:15:11.870", "lastModified": "2022-11-23T18:25:10.333", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A stored XSS in a kiwi Test Plan can run malicious javascript which could be chained with an HTML injection to perform a UI redressing attack (clickjacking) and an HTML injection which disables the use of the history page."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.3, "impactScore": 2.7}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 4.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kiwitcms:kiwi_tcms:*:*:*:*:*:*:*:*", "versionEndExcluding": "11.6", "matchCriteriaId": "D8D938CC-BEFF-4D8B-A74F-7FE6B874B768"}]}]}], "references": [{"url": "https://github.com/kiwitcms/kiwi/commit/a2b169ffdef1d7c1755bade8138578423b35011b", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/386417e9-0cd5-4d80-8137-b0fd5c30b8f8", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/kiwitcms/kiwi/commit/a2b169ffdef1d7c1755bade8138578423b35011b"}}