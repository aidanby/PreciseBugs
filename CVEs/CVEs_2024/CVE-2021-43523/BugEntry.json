{"buggy_code": ["/* resolv.c: DNS Resolver\n *\n * Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>,\n *                     The Silver Hammer Group, Ltd.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n */\n/*\n * Portions Copyright (c) 1985, 1993\n *    The Regents of the University of California.  All rights reserved.\n * Portions Copyright \u00a9 2021 mirabilos <m@mirbsd.org>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * Portions Copyright (c) 1993 by Digital Equipment Corporation.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies, and that\n * the name of Digital Equipment Corporation not be used in advertising or\n * publicity pertaining to distribution of the document or software without\n * specific, written prior permission.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL\n * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT\n * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n * SOFTWARE.\n */\n/*\n * Portions Copyright (c) 1996-1999 by Internet Software Consortium.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS\n * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE\n * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n * SOFTWARE.\n */\n/* RFC 1035\n...\nWhenever an octet represents a numeric quantity, the left most bit\nin the diagram is the high order or most significant bit.\nThat is, the bit labeled 0 is the most significant bit.\n...\n\n4.1.1. Header section format\n      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   OPCODE  |AA|TC|RD|RA| 0  0  0|   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nID      16 bit random identifier assigned by querying peer.\n        Used to match query/response.\nQR      message is a query (0), or a response (1).\nOPCODE  0   standard query (QUERY)\n        1   inverse query (IQUERY)\n        2   server status request (STATUS)\nAA      Authoritative Answer - this bit is valid in responses.\n        Responding name server is an authority for the domain name\n        in question section. Answer section may have multiple owner names\n        because of aliases.  The AA bit corresponds to the name which matches\n        the query name, or the first owner name in the answer section.\nTC      TrunCation - this message was truncated.\nRD      Recursion Desired - this bit may be set in a query and\n        is copied into the response.  If RD is set, it directs\n        the name server to pursue the query recursively.\n        Recursive query support is optional.\nRA      Recursion Available - this be is set or cleared in a\n        response, and denotes whether recursive query support is\n        available in the name server.\nRCODE   Response code.\n        0   No error condition\n        1   Format error\n        2   Server failure - server was unable to process the query\n            due to a problem with the name server.\n        3   Name Error - meaningful only for responses from\n            an authoritative name server. The referenced domain name\n            does not exist.\n        4   Not Implemented.\n        5   Refused.\nQDCOUNT number of entries in the question section.\nANCOUNT number of records in the answer section.\nNSCOUNT number of records in the authority records section.\nARCOUNT number of records in the additional records section.\n\n4.1.2. Question section format\n\nThe section contains QDCOUNT (usually 1) entries, each of this format:\n      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /                     QNAME                     /\n    /                                               /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     QTYPE                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     QCLASS                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nQNAME   a domain name represented as a sequence of labels, where\n        each label consists of a length octet followed by that\n        number of octets. The domain name terminates with the\n        zero length octet for the null label of the root. Note\n        that this field may be an odd number of octets; no\n        padding is used.\nQTYPE   a two octet type of the query.\n          1 a host address [REQ_A const]\n          2 an authoritative name server\n          3 a mail destination (Obsolete - use MX)\n          4 a mail forwarder (Obsolete - use MX)\n          5 the canonical name for an alias\n          6 marks the start of a zone of authority\n          7 a mailbox domain name (EXPERIMENTAL)\n          8 a mail group member (EXPERIMENTAL)\n          9 a mail rename domain name (EXPERIMENTAL)\n         10 a null RR (EXPERIMENTAL)\n         11 a well known service description\n         12 a domain name pointer [REQ_PTR const]\n         13 host information\n         14 mailbox or mail list information\n         15 mail exchange\n         16 text strings\n       0x1c IPv6?\n        252 a request for a transfer of an entire zone\n        253 a request for mailbox-related records (MB, MG or MR)\n        254 a request for mail agent RRs (Obsolete - see MX)\n        255 a request for all records\nQCLASS  a two octet code that specifies the class of the query.\n          1 the Internet\n        (others are historic only)\n        255 any class\n\n4.1.3. Resource record format\n\nThe answer, authority, and additional sections all share the same format:\na variable number of resource records, where the number of records\nis specified in the corresponding count field in the header.\nEach resource record has this format:\n      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /                                               /\n    /                      NAME                     /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      TYPE                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     CLASS                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      TTL                      |\n    |                                               |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                   RDLENGTH                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n    /                     RDATA                     /\n    /                                               /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nNAME    a domain name to which this resource record pertains.\nTYPE    two octets containing one of the RR type codes.  This\n        field specifies the meaning of the data in the RDATA field.\nCLASS   two octets which specify the class of the data in the RDATA field.\nTTL     a 32 bit unsigned integer that specifies the time interval\n        (in seconds) that the record may be cached.\nRDLENGTH a 16 bit integer, length in octets of the RDATA field.\nRDATA   a variable length string of octets that describes the resource.\n        The format of this information varies according to the TYPE\n        and CLASS of the resource record.\n        If the TYPE is A and the CLASS is IN, it's a 4 octet IP address.\n\n4.1.4. Message compression\n\nIn order to reduce the size of messages, domain names can be compressed.\nAn entire domain name or a list of labels at the end of a domain name\nis replaced with a pointer to a prior occurance of the same name.\n\nThe pointer takes the form of a two octet sequence:\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    | 1  1|                OFFSET                   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nThe first two bits are ones.  This allows a pointer to be distinguished\nfrom a label, since the label must begin with two zero bits because\nlabels are restricted to 63 octets or less.  The OFFSET field specifies\nan offset from the start of the message (i.e., the first octet\nof the ID field in the domain header).\nA zero offset specifies the first byte of the ID field, etc.\nDomain name in a message can be represented as either:\n   - a sequence of labels ending in a zero octet\n   - a pointer\n   - a sequence of labels ending with a pointer\n */\n\n#include <string.h>\n#include <stdio.h>\n#include <stdio_ext.h>\n#include <signal.h>\n#include <malloc.h>\n#include <errno.h>\n#include <sys/poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <time.h>\n#include <arpa/nameser.h>\n#include <sys/utsname.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <bits/uClibc_mutex.h>\n#include \"internal/parse_config.h\"\n\n/* poll() is not supported in kernel <= 2.0, therefore if __NR_poll is\n * not available, we assume an old Linux kernel is in use and we will\n * use select() instead. */\n#include <sys/syscall.h>\n#ifndef __NR_poll\n# define USE_SELECT\n#endif\n\n#if defined __UCLIBC_HAS_IPV4__ && defined __UCLIBC_HAS_IPV6__\n#define IF_HAS_BOTH(...) __VA_ARGS__\n#else\n#define IF_HAS_BOTH(...)\n#endif\n\n\n#define MAX_RECURSE    5\n#define MAXALIASES  (4)\n/* 1:ip + 1:full + MAX_ALIASES:aliases + 1:NULL */\n#define ALIAS_DIM   (2 + MAXALIASES + 1)\n#define BUFSZ       (80) /* one line */\n\n#define NS_TYPE_ELT\t\t\t\t\t0x40 /*%< EDNS0 extended label type */\n#define DNS_LABELTYPE_BITSTRING\t\t0x41\n\n#undef DEBUG\n/* #define DEBUG */\n\n#ifdef DEBUG\n#define DPRINTF(X,args...) fprintf(stderr, X, ##args)\n#else\n#define DPRINTF(X,args...)\n#endif\n\n/* Make sure the incoming char * buffer is aligned enough to handle our random\n * structures.  This define is the same as we use for malloc alignment (which\n * has same requirements).  The offset is the number of bytes we need to adjust\n * in order to attain desired alignment.\n */\n#define ALIGN_ATTR __alignof__(double __attribute_aligned__ (sizeof(size_t)))\n#define ALIGN_BUFFER_OFFSET(buf) ((ALIGN_ATTR - ((size_t)buf % ALIGN_ATTR)) % ALIGN_ATTR)\n\n\n/* Structs */\nstruct resolv_header {\n\tint id;\n\tint qr, opcode, aa, tc, rd, ra, rcode;\n\tint qdcount;\n\tint ancount;\n\tint nscount;\n\tint arcount;\n};\n\nstruct resolv_question {\n\tchar *dotted;\n\tint qtype;\n\tint qclass;\n};\n\nstruct resolv_answer {\n\tchar *dotted;\n\tint atype;\n\tint aclass;\n\tint ttl;\n\tint rdlength;\n\tconst unsigned char *rdata;\n\tint rdoffset;\n\tchar* buf;\n\tsize_t buflen;\n\tsize_t add_count;\n};\n\nenum etc_hosts_action {\n\tGET_HOSTS_BYNAME = 0,\n\tGETHOSTENT,\n\tGET_HOSTS_BYADDR,\n};\n\ntypedef union sockaddr46_t {\n\tstruct sockaddr sa;\n#ifdef __UCLIBC_HAS_IPV4__\n\tstruct sockaddr_in sa4;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\tstruct sockaddr_in6 sa6;\n#endif\n} sockaddr46_t;\n\n\n__UCLIBC_MUTEX_EXTERN(__resolv_lock) attribute_hidden;\n\n/* Protected by __resolv_lock */\nextern void (*__res_sync)(void) attribute_hidden;\n/*extern uint32_t __resolv_opts attribute_hidden; */\nextern uint8_t __resolv_timeout attribute_hidden;\nextern uint8_t __resolv_attempts attribute_hidden;\nextern unsigned __nameservers attribute_hidden;\nextern unsigned __searchdomains attribute_hidden;\nextern sockaddr46_t *__nameserver attribute_hidden;\nextern char **__searchdomain attribute_hidden;\n#ifdef __UCLIBC_HAS_IPV4__\nextern const struct sockaddr_in __local_nameserver attribute_hidden;\n#else\nextern const struct sockaddr_in6 __local_nameserver attribute_hidden;\n#endif\n/* Arbitrary */\n#define MAXLEN_searchdomain 128\n\n\n/* prototypes for internal functions */\nextern void endhostent_unlocked(void) attribute_hidden;\nextern int __get_hosts_byname_r(const char *name,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop) attribute_hidden;\nextern int __get_hosts_byaddr_r(const char *addr,\n\t\tint len,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop) attribute_hidden;\nextern parser_t *__open_etc_hosts(void) attribute_hidden;\nextern int __read_etc_hosts_r(parser_t *parser,\n\t\tconst char *name,\n\t\tint type,\n\t\tenum etc_hosts_action action,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop) attribute_hidden;\nextern int __dns_lookup(const char *name,\n\t\tint type,\n\t\tunsigned char **outpacket,\n\t\tstruct resolv_answer *a) attribute_hidden;\nextern int __encode_header(struct resolv_header *h,\n\t\tunsigned char *dest,\n\t\tint maxlen) attribute_hidden;\nextern void __decode_header(unsigned char *data,\n\t\tstruct resolv_header *h) attribute_hidden;\nextern int __encode_question(const struct resolv_question *q,\n\t\tunsigned char *dest,\n\t\tint maxlen) attribute_hidden;\nextern int __encode_answer(struct resolv_answer *a,\n\t\tunsigned char *dest,\n\t\tint maxlen) attribute_hidden;\nextern void __open_nameservers(void) attribute_hidden;\nextern void __close_nameservers(void) attribute_hidden;\n\n#define __encode_dotted(dotted,dest,maxlen) \\\n\tdn_comp((dotted), (dest), (maxlen), NULL, NULL)\n#define __decode_dotted(packet,offset,packet_len,dest,dest_len) \\\n\tdn_expand((packet), (packet) + (packet_len), (packet) + (offset), \\\n\t    (dest), (dest_len))\n\n/*\n * Theory of operation.\n *\n * gethostbyname, getaddrinfo and friends end up here, and they sometimes\n * need to talk to DNS servers. In order to do this, we need to read /etc/resolv.conf\n * and determine servers' addresses and the like. resolv.conf format:\n *\n * nameserver <IP[v6]>\n *\t\tAddress of DNS server. Cumulative.\n *\t\tIf not specified, assumed to be on localhost.\n * search <domain1>[ <domain2>]...\n *\t\tAppend these domains to unqualified names.\n *\t\tSee ndots:n option.\n *\t\t$LOCALDOMAIN (space-separated list) overrides this.\n * domain <domain>\n *\t\tEffectively same as \"search\" with one domain.\n *\t\tIf no \"domain\" line is present, the domain is determined\n *\t\tfrom the local host name returned by gethostname();\n *\t\tthe domain part is taken to be everything after the first dot.\n *\t\tIf there are no dots, there will be no \"domain\".\n *\t\tThe domain and search keywords are mutually exclusive.\n *\t\tIf more than one instance of these keywords is present,\n *\t\tthe last instance wins.\n * sortlist 130.155.160.0[/255.255.240.0] 130.155.0.0\n *\t\tAllows addresses returned by gethostbyname to be sorted.\n *\t\tNot supported.\n * options option[ option]...\n *\t\t(so far we support timeout:n and attempts:n)\n *\t\t$RES_OPTIONS (space-separated list) is to be added to \"options\"\n *  debug\tsets RES_DEBUG in _res.options\n *  ndots:n\thow many dots there should be so that name will be tried\n *\t\tfirst as an absolute name before any search list elements\n *\t\tare appended to it. Default 1\n *  timeout:n   how long to wait for response. Default 5\n *\t\t(sun seems to have retrans:n synonym)\n *  attempts:n\tnumber of rounds to do before giving up and returning\n *\t\tan error. Default 2\n *\t\t(sun seems to have retry:n synonym)\n *  rotate\tsets RES_ROTATE in _res.options, round robin\n *\t\tselection of nameservers. Otherwise try\n *\t\tthe first listed server first every time\n *  no-check-names\n *\t\tsets RES_NOCHECKNAME in _res.options, which disables\n *\t\tchecking of incoming host names for invalid characters\n *\t\tsuch as underscore (_), non-ASCII, or control characters\n *  inet6\tsets RES_USE_INET6 in _res.options. Try a AAAA query\n *\t\tbefore an A query inside the gethostbyname(), and map\n *\t\tIPv4 responses in IPv6 \"tunnelled form\" if no AAAA records\n *\t\tare found but an A record set exists\n *  no_tld_query (FreeBSDism?)\n *\t\tdo not attempt to resolve names without dots\n *\n * We will read and analyze /etc/resolv.conf as needed before\n * we do a DNS request. This happens in __dns_lookup.\n * It is reread if its mtime is changed.\n *\n * BSD has res_init routine which is used to initialize resolver state\n * which is held in global structure _res.\n * Generally, programs call res_init, then fiddle with _res.XXX\n * (_res.options and _res.nscount, _res.nsaddr_list[N]\n * are popular targets of fiddling) and expect subsequent calls\n * to gethostbyname, getaddrinfo, etc to use modified information.\n *\n * However, historical _res structure is quite awkward.\n * Using it for storing /etc/resolv.conf info is not desirable,\n * and __dns_lookup does not use it.\n *\n * We would like to avoid using it unless absolutely necessary.\n * If user doesn't use res_init, we should arrange it so that\n * _res structure doesn't even *get linked in* into user's application\n * (imagine static uclibc build here).\n *\n * The solution is a __res_sync function pointer, which is normally NULL.\n * But if res_init is called, it gets set and any subsequent gethostbyname\n * et al \"syncronizes\" our internal structures with potentially\n * modified _res.XXX stuff by calling __res_sync.\n * The trick here is that if res_init is not used and not linked in,\n * gethostbyname itself won't reference _res and _res won't be linked in\n * either. Other possible methods like\n * if (__res_sync_just_an_int_flag)\n *\t__sync_me_with_res()\n * would pull in __sync_me_with_res, which pulls in _res. Bad.\n */\n\n\n#ifdef L_encodeh\n\nint __encode_header(struct resolv_header *h, unsigned char *dest, int maxlen)\n{\n\tif (maxlen < HFIXEDSZ)\n\t\treturn -1;\n\n\tdest[0] = (h->id & 0xff00) >> 8;\n\tdest[1] = (h->id & 0x00ff) >> 0;\n\tdest[2] = (h->qr ? 0x80 : 0) |\n\t\t((h->opcode & 0x0f) << 3) |\n\t\t(h->aa ? 0x04 : 0) |\n\t\t(h->tc ? 0x02 : 0) |\n\t\t(h->rd ? 0x01 : 0);\n\tdest[3] = (h->ra ? 0x80 : 0) | (h->rcode & 0x0f);\n\tdest[4] = (h->qdcount & 0xff00) >> 8;\n\tdest[5] = (h->qdcount & 0x00ff) >> 0;\n\tdest[6] = (h->ancount & 0xff00) >> 8;\n\tdest[7] = (h->ancount & 0x00ff) >> 0;\n\tdest[8] = (h->nscount & 0xff00) >> 8;\n\tdest[9] = (h->nscount & 0x00ff) >> 0;\n\tdest[10] = (h->arcount & 0xff00) >> 8;\n\tdest[11] = (h->arcount & 0x00ff) >> 0;\n\n\treturn HFIXEDSZ;\n}\n#endif /* L_encodeh */\n\n\n#ifdef L_decodeh\n\nvoid __decode_header(unsigned char *data,\n\t\tstruct resolv_header *h)\n{\n\th->id = (data[0] << 8) | data[1];\n\th->qr = (data[2] & 0x80) ? 1 : 0;\n\th->opcode = (data[2] >> 3) & 0x0f;\n\th->aa = (data[2] & 0x04) ? 1 : 0;\n\th->tc = (data[2] & 0x02) ? 1 : 0;\n\th->rd = (data[2] & 0x01) ? 1 : 0;\n\th->ra = (data[3] & 0x80) ? 1 : 0;\n\th->rcode = data[3] & 0x0f;\n\th->qdcount = (data[4] << 8) | data[5];\n\th->ancount = (data[6] << 8) | data[7];\n\th->nscount = (data[8] << 8) | data[9];\n\th->arcount = (data[10] << 8) | data[11];\n}\n#endif /* L_decodeh */\n\n\n#ifdef L_encodeq\n\nint __encode_question(const struct resolv_question *q,\n\t\tunsigned char *dest,\n\t\tint maxlen)\n{\n\tint i;\n\n\ti = __encode_dotted(q->dotted, dest, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tdest += i;\n\tmaxlen -= i;\n\n\tif (maxlen < 4)\n\t\treturn -1;\n\n\tdest[0] = (q->qtype & 0xff00) >> 8;\n\tdest[1] = (q->qtype & 0x00ff) >> 0;\n\tdest[2] = (q->qclass & 0xff00) >> 8;\n\tdest[3] = (q->qclass & 0x00ff) >> 0;\n\n\treturn i + 4;\n}\n#endif /* L_encodeq */\n\n\n#ifdef L_encodea\n\nint __encode_answer(struct resolv_answer *a, unsigned char *dest, int maxlen)\n{\n\tint i;\n\n\ti = __encode_dotted(a->dotted, dest, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tdest += i;\n\tmaxlen -= i;\n\n\tif (maxlen < (RRFIXEDSZ + a->rdlength))\n\t\treturn -1;\n\n\t*dest++ = (a->atype & 0xff00) >> 8;\n\t*dest++ = (a->atype & 0x00ff) >> 0;\n\t*dest++ = (a->aclass & 0xff00) >> 8;\n\t*dest++ = (a->aclass & 0x00ff) >> 0;\n\t*dest++ = (a->ttl & 0xff000000) >> 24;\n\t*dest++ = (a->ttl & 0x00ff0000) >> 16;\n\t*dest++ = (a->ttl & 0x0000ff00) >> 8;\n\t*dest++ = (a->ttl & 0x000000ff) >> 0;\n\t*dest++ = (a->rdlength & 0xff00) >> 8;\n\t*dest++ = (a->rdlength & 0x00ff) >> 0;\n\tmemcpy(dest, a->rdata, a->rdlength);\n\n\treturn i + RRFIXEDSZ + a->rdlength;\n}\n#endif /* L_encodea */\n\n\n#ifdef CURRENTLY_UNUSED\n#ifdef L_encodep\n\nint __encode_packet(struct resolv_header *h,\n\t\tstruct resolv_question **q,\n\t\tstruct resolv_answer **an,\n\t\tstruct resolv_answer **ns,\n\t\tstruct resolv_answer **ar,\n\t\tunsigned char *dest, int maxlen) attribute_hidden;\nint __encode_packet(struct resolv_header *h,\n\t\tstruct resolv_question **q,\n\t\tstruct resolv_answer **an,\n\t\tstruct resolv_answer **ns,\n\t\tstruct resolv_answer **ar,\n\t\tunsigned char *dest, int maxlen)\n{\n\tint i, total = 0;\n\tunsigned j;\n\n\ti = __encode_header(h, dest, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tdest += i;\n\tmaxlen -= i;\n\ttotal += i;\n\n\tfor (j = 0; j < h->qdcount; j++) {\n\t\ti = __encode_question(q[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\n\tfor (j = 0; j < h->ancount; j++) {\n\t\ti = __encode_answer(an[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\tfor (j = 0; j < h->nscount; j++) {\n\t\ti = __encode_answer(ns[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\tfor (j = 0; j < h->arcount; j++) {\n\t\ti = __encode_answer(ar[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\n\treturn total;\n}\n#endif /* L_encodep */\n\n\n#ifdef L_decodep\n\nint __decode_packet(unsigned char *data, struct resolv_header *h) attribute_hidden;\nint __decode_packet(unsigned char *data, struct resolv_header *h)\n{\n\t__decode_header(data, h);\n\treturn HFIXEDSZ;\n}\n#endif /* L_decodep */\n\n\n#ifdef L_formquery\n\nint __form_query(int id,\n\t\tconst char *name,\n\t\tint type,\n\t\tunsigned char *packet,\n\t\tint maxlen) attribute_hidden;\nint __form_query(int id,\n\t\tconst char *name,\n\t\tint type,\n\t\tunsigned char *packet,\n\t\tint maxlen)\n{\n\tstruct resolv_header h;\n\tstruct resolv_question q;\n\tint i, j;\n\n\tmemset(&h, 0, sizeof(h));\n\th.id = id;\n\th.qdcount = 1;\n\n\tq.dotted = (char *) name;\n\tq.qtype = type;\n\tq.qclass = C_IN; /* CLASS_IN */\n\n\ti = __encode_header(&h, packet, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tj = __encode_question(&q, packet + i, maxlen - i);\n\tif (j < 0)\n\t\treturn j;\n\n\treturn i + j;\n}\n#endif /* L_formquery */\n#endif /* CURRENTLY_UNUSED */\n\n\n#ifdef L_opennameservers\n\n# if __BYTE_ORDER == __LITTLE_ENDIAN\n#define NAMESERVER_PORT_N (__bswap_constant_16(NAMESERVER_PORT))\n#else\n#define NAMESERVER_PORT_N NAMESERVER_PORT\n#endif\n\n__UCLIBC_MUTEX_INIT(__resolv_lock, PTHREAD_MUTEX_INITIALIZER);\n\n/* Protected by __resolv_lock */\nvoid (*__res_sync)(void);\n/*uint32_t __resolv_opts; */\nuint8_t __resolv_timeout = RES_TIMEOUT;\nuint8_t __resolv_attempts = RES_DFLRETRY;\nunsigned __nameservers;\nunsigned __searchdomains;\nsockaddr46_t *__nameserver;\nchar **__searchdomain;\n#ifdef __UCLIBC_HAS_IPV4__\nconst struct sockaddr_in __local_nameserver = {\n\t.sin_family = AF_INET,\n\t.sin_port = NAMESERVER_PORT_N,\n};\n#else\nconst struct sockaddr_in6 __local_nameserver = {\n\t.sin6_family = AF_INET6,\n\t.sin6_port = NAMESERVER_PORT_N,\n};\n#endif\n\n/* Helpers. Both stop on EOL, if it's '\\n', it is converted to NUL first */\nstatic char *skip_nospace(char *p)\n{\n\twhile (*p != '\\0' && !isspace(*p)) {\n\t\tif (*p == '\\n') {\n\t\t\t*p = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}\nstatic char *skip_and_NUL_space(char *p)\n{\n\t/* NB: '\\n' is not isspace! */\n\twhile (1) {\n\t\tchar c = *p;\n\t\tif (c == '\\0' || !isspace(c))\n\t\t\tbreak;\n\t\t*p = '\\0';\n\t\tif (c == '\\n' || c == '#')\n\t\t\tbreak;\n\t\tp++;\n\t}\n\treturn p;\n}\n\n/* Must be called under __resolv_lock. */\nvoid __open_nameservers(void)\n{\n\tstatic uint32_t resolv_conf_mtime;\n\n\tchar szBuffer[MAXLEN_searchdomain];\n\tFILE *fp;\n\tint i;\n\tsockaddr46_t sa;\n\n\tif (!__res_sync) {\n\t\t/* Reread /etc/resolv.conf if it was modified.  */\n\t\tstruct stat sb;\n\t\tif (stat(_PATH_RESCONF, &sb) != 0)\n\t\t\tsb.st_mtime = 0;\n\t\tif (resolv_conf_mtime != (uint32_t)sb.st_mtime) {\n\t\t\tresolv_conf_mtime = sb.st_mtime;\n\t\t\t__close_nameservers(); /* force config reread */\n\t\t}\n\t}\n\n\tif (__nameservers)\n\t\tgoto sync;\n\n\t__resolv_timeout = RES_TIMEOUT;\n\t__resolv_attempts = RES_DFLRETRY;\n\n\tfp = fopen(_PATH_RESCONF, \"r\");\n#ifdef FALLBACK_TO_CONFIG_RESOLVCONF\n\tif (!fp) {\n\t\t/* If we do not have a pre-populated /etc/resolv.conf then\n\t\t   try to use the one from /etc/config which exists on numerous\n\t\t   systems ranging from some uClinux to IRIX installations and\n\t\t   may be the only /etc dir that was mounted rw.  */\n\t\tfp = fopen(\"/etc/config/resolv.conf\", \"r\");\n\t}\n#endif\n\n\tif (fp) {\n\t\twhile (fgets(szBuffer, sizeof(szBuffer), fp) != NULL) {\n\t\t\tvoid *ptr;\n\t\t\tchar *keyword, *p;\n\n\t\t\tkeyword = p = skip_and_NUL_space(szBuffer);\n\t\t\t/* skip keyword */\n\t\t\tp = skip_nospace(p);\n\t\t\t/* find next word */\n\t\t\tp = skip_and_NUL_space(p);\n\n\t\t\tif (strcmp(keyword, \"nameserver\") == 0) {\n\t\t\t\t/* terminate IP addr */\n\t\t\t\t*skip_nospace(p) = '\\0';\n\t\t\t\tmemset(&sa, 0, sizeof(sa));\n\t\t\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\telse if (inet_pton(AF_INET6, p, &sa.sa6.sin6_addr) > 0) {\n\t\t\t\t\tsa.sa6.sin6_family = AF_INET6;\n\t\t\t\t\tsa.sa6.sin6_port = htons(NAMESERVER_PORT);\n\t\t\t\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\t\telse if (inet_pton(AF_INET, p, &sa.sa4.sin_addr) > 0) {\n\t\t\t\t\tsa.sa4.sin_family = AF_INET;\n\t\t\t\t\tsa.sa4.sin_port = htons(NAMESERVER_PORT);\n\t\t\t\t}\n#endif\n\t\t\t\telse\n\t\t\t\t\tcontinue; /* garbage on this line */\n\t\t\t\tptr = realloc(__nameserver, (__nameservers + 1) * sizeof(__nameserver[0]));\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\t__nameserver = ptr;\n\t\t\t\t__nameserver[__nameservers++] = sa; /* struct copy */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(keyword, \"domain\") == 0 || strcmp(keyword, \"search\") == 0) {\n\t\t\t\tchar *p1;\n\n\t\t\t\t/* free old domains (\"last 'domain' or 'search' wins\" rule) */\n\t\t\t\twhile (__searchdomains)\n\t\t\t\t\tfree(__searchdomain[--__searchdomains]);\n\t\t\t\t/*free(__searchdomain);*/\n\t\t\t\t/*__searchdomain = NULL; - not necessary */\n next_word:\n\t\t\t\t/* terminate current word */\n\t\t\t\tp1 = skip_nospace(p);\n\t\t\t\t/* find next word (maybe) */\n\t\t\t\tp1 = skip_and_NUL_space(p1);\n\t\t\t\t/* add it */\n\t\t\t\tptr = realloc(__searchdomain, (__searchdomains + 1) * sizeof(__searchdomain[0]));\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\t__searchdomain = ptr;\n\t\t\t\t/* NB: strlen(p) <= MAXLEN_searchdomain) because szBuffer[] is smaller */\n\t\t\t\tptr = strdup(p);\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\tDPRINTF(\"adding search %s\\n\", (char*)ptr);\n\t\t\t\t__searchdomain[__searchdomains++] = (char*)ptr;\n\t\t\t\tp = p1;\n\t\t\t\tif (*p)\n\t\t\t\t\tgoto next_word;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* if (strcmp(keyword, \"sortlist\") == 0)... */\n\t\t\tif (strcmp(keyword, \"options\") == 0) {\n\t\t\t\tchar *p1;\n\t\t\t\tuint8_t *what;\n\n\t\t\t\tif (p == NULL || (p1 = strchr(p, ':')) == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\t*p1++ = '\\0';\n\t\t\t\tif (strcmp(p, \"timeout\") == 0)\n\t\t\t\t\twhat = &__resolv_timeout;\n\t\t\t\telse if (strcmp(p, \"attempts\") == 0)\n\t\t\t\t\twhat = &__resolv_attempts;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t\t*what = atoi(p1);\n\t\t\t\tDPRINTF(\"option %s:%d\\n\", p, *what);\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t}\n\tif (__nameservers == 0) {\n\t\t/* Have to handle malloc failure! What a mess...\n\t\t * And it's not only here, we need to be careful\n\t\t * to never write into __nameserver[0] if it points\n\t\t * to constant __local_nameserver, or free it. */\n\t\t__nameserver = malloc(sizeof(__nameserver[0]));\n\t\tif (__nameserver)\n\t\t\tmemcpy(__nameserver, &__local_nameserver, sizeof(__local_nameserver));\n\t\telse\n\t\t\t__nameserver = (void*) &__local_nameserver;\n\t\t__nameservers++;\n\t}\n\tif (__searchdomains == 0) {\n\t\tchar buf[256];\n\t\tchar *p;\n\t\ti = gethostname(buf, sizeof(buf) - 1);\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tif (i == 0 && (p = strchr(buf, '.')) != NULL && p[1]) {\n\t\t\tp = strdup(p + 1);\n\t\t\tif (!p)\n\t\t\t\tgoto err;\n\t\t\t__searchdomain = malloc(sizeof(__searchdomain[0]));\n\t\t\tif (!__searchdomain) {\n\t\t\t\tfree(p);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t__searchdomain[0] = p;\n\t\t\t__searchdomains++;\n err: ;\n\t\t}\n\t}\n\tDPRINTF(\"nameservers = %d\\n\", __nameservers);\n\n sync:\n\tif (__res_sync)\n\t\t__res_sync();\n}\n#endif /* L_opennameservers */\n\n\n#ifdef L_closenameservers\n\n/* Must be called under __resolv_lock. */\nvoid __close_nameservers(void)\n{\n\tif (__nameserver != (void*) &__local_nameserver)\n\t\tfree(__nameserver);\n\t__nameserver = NULL;\n\t__nameservers = 0;\n\twhile (__searchdomains)\n\t\tfree(__searchdomain[--__searchdomains]);\n\tfree(__searchdomain);\n\t__searchdomain = NULL;\n\t/*__searchdomains = 0; - already is */\n}\n#endif /* L_closenameservers */\n\n\n#ifdef L_dnslookup\n\n/* Helpers */\nstatic int __length_question(const unsigned char *data, int maxlen)\n{\n\tconst unsigned char *start;\n\tunsigned b;\n\n\tif (!data)\n\t\treturn -1;\n\n\tstart = data;\n\twhile (1) {\n\t\tif (maxlen <= 0)\n\t\t\treturn -1;\n\t\tb = *data++;\n\t\tif (b == 0)\n\t\t\tbreak;\n\t\tif ((b & 0xc0) == 0xc0) {\n\t\t\t/* It's a \"compressed\" name. */\n\t\t\tdata++; /* skip lsb of redirected offset */\n\t\t\tmaxlen -= 2;\n\t\t\tbreak;\n\t\t}\n\t\tdata += b;\n\t\tmaxlen -= (b + 1); /* account for data++ above */\n\t}\n\t/* Up to here we were skipping encoded name */\n\n\t/* Account for QTYPE and QCLASS fields */\n\tif (maxlen < 4)\n\t\treturn -1;\n\treturn data - start + 2 + 2;\n}\n\nstatic int __decode_answer(const unsigned char *message, /* packet */\n\t\tint offset,\n\t\tint len, /* total packet len */\n\t\tstruct resolv_answer *a)\n{\n\tchar temp[256];\n\tint i;\n\n\tDPRINTF(\"decode_answer(start): off %d, len %d\\n\", offset, len);\n\ti = __decode_dotted(message, offset, len, temp, sizeof(temp));\n\tif (i < 0)\n\t\treturn i;\n\n\tmessage += offset + i;\n\tlen -= i + RRFIXEDSZ + offset;\n\tif (len < 0) {\n\t\tDPRINTF(\"decode_answer: off %d, len %d, i %d\\n\", offset, len, i);\n\t\treturn len;\n\t}\n\n/* TODO: what if strdup fails? */\n\ta->dotted = strdup(temp);\n\ta->atype = (message[0] << 8) | message[1];\n\tmessage += 2;\n\ta->aclass = (message[0] << 8) | message[1];\n\tmessage += 2;\n\ta->ttl = (message[0] << 24) |\n\t\t(message[1] << 16) | (message[2] << 8) | (message[3] << 0);\n\tmessage += 4;\n\ta->rdlength = (message[0] << 8) | message[1];\n\tmessage += 2;\n\ta->rdata = message;\n\ta->rdoffset = offset + i + RRFIXEDSZ;\n\n\tDPRINTF(\"i=%d,rdlength=%d\\n\", i, a->rdlength);\n\n\tif (len < a->rdlength)\n\t\treturn -1;\n\treturn i + RRFIXEDSZ + a->rdlength;\n}\n\n/* On entry:\n *  a.buf(len) = auxiliary buffer for IP addresses after first one\n *  a.add_count = how many additional addresses are there already\n *  outpacket = where to save ptr to raw packet? can be NULL\n * On exit:\n *  ret < 0: error, all other data is not valid\n *  ret >= 0: length of reply packet\n *  a.add_count & a.buf: updated\n *  a.rdlength: length of addresses (4 bytes for IPv4)\n *  *outpacket: updated (packet is malloced, you need to free it)\n *  a.rdata: points into *outpacket to 1st IP addr\n *      NB: don't pass outpacket == NULL if you need to use a.rdata!\n *  a.atype: type of query?\n *  a.dotted: which name we _actually_ used. May contain search domains\n *      appended. (why the filed is called \"dotted\" I have no idea)\n *      This is a malloced string. May be NULL because strdup failed.\n */\nint __dns_lookup(const char *name,\n\t\tint type,\n\t\tunsigned char **outpacket,\n\t\tstruct resolv_answer *a)\n{\n\t/* Protected by __resolv_lock: */\n\tstatic int last_ns_num = 0;\n\tstatic uint16_t last_id = 1;\n\n\tint i, j, fd, rc;\n\tint packet_len;\n\tint name_len;\n#ifdef USE_SELECT\n\tstruct timeval tv;\n\tfd_set fds;\n#else\n\tstruct pollfd fds;\n#endif\n\tstruct resolv_header h;\n\tstruct resolv_question q;\n\tstruct resolv_answer ma;\n\tbool first_answer = 1;\n\tint retries_left;\n\tunsigned char *packet = malloc(PACKETSZ);\n\tchar *lookup;\n\tint variant = -1;  /* search domain to append, -1: none */\n\tint local_ns_num = -1; /* Nth server to use */\n\tint local_id = local_id; /* for compiler */\n\tint sdomains = 0;\n\tbool ends_with_dot;\n\tbool contains_dot;\n\tsockaddr46_t sa;\n\n\tfd = -1;\n\tlookup = NULL;\n\tname_len = strlen(name);\n\tif ((unsigned)name_len >= MAXDNAME - MAXLEN_searchdomain - 2)\n\t\tgoto fail; /* paranoia */\n\tlookup = malloc(name_len + 1/*for '.'*/ + MAXLEN_searchdomain + 1);\n\tif (!packet || !lookup || !name[0])\n\t\tgoto fail;\n\tends_with_dot = (name[name_len - 1] == '.');\n\tcontains_dot = strchr(name, '.') != NULL;\n\t/* no strcpy! paranoia, user might change name[] under us */\n\tmemcpy(lookup, name, name_len);\n\n\tDPRINTF(\"Looking up type %d answer for '%s'\\n\", type, name);\n\tretries_left = 0; /* for compiler */\n\tdo {\n\t\tunsigned act_variant;\n\t\tint pos;\n\t\tunsigned reply_timeout;\n\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\n\t\t/* Mess with globals while under lock */\n\t\t/* NB: even data *pointed to* by globals may vanish\n\t\t * outside the locks. We should assume any and all\n\t\t * globals can completely change between locked\n\t\t * code regions. OTOH, this is rare, so we don't need\n\t\t * to handle it \"nicely\" (do not skip servers,\n\t\t * search domains, etc), we only need to ensure\n\t\t * we do not SEGV, use freed+overwritten data\n\t\t * or do other Really Bad Things. */\n\t\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t\t__open_nameservers();\n\t\tif (type != T_PTR) {\n\t\t\tsdomains = __searchdomains;\n\t\t}\n\t\tlookup[name_len] = '\\0';\n\t\t/* For qualified names, act_variant = MAX_UINT, 0, .., sdomains-1\n\t\t *  => Try original name first, then append search domains\n\t\t * For names without domain, act_variant = 0, 1, .., sdomains\n\t\t *  => Try search domains first, original name last */\n\t\tact_variant = contains_dot ? variant : variant + 1;\n\t\tif (act_variant < sdomains) {\n\t\t\t/* lookup is name_len + 1 + MAXLEN_searchdomain + 1 long */\n\t\t\t/* __searchdomain[] is not bigger than MAXLEN_searchdomain */\n\t\t\tlookup[name_len] = '.';\n\t\t\tstrcpy(&lookup[name_len + 1], __searchdomain[act_variant]);\n\t\t}\n\t\t/* first time? pick starting server etc */\n\t\tif (local_ns_num < 0) {\n\t\t\tlocal_id = last_id;\n/*TODO: implement /etc/resolv.conf's \"options rotate\"\n (a.k.a. RES_ROTATE bit in _res.options)\n\t\t\tlocal_ns_num = 0;\n\t\t\tif (_res.options & RES_ROTATE) */\n\t\t\t\tlocal_ns_num = last_ns_num;\n\t\t\tretries_left = __nameservers * __resolv_attempts;\n\t\t}\n\t\tif (local_ns_num >= __nameservers)\n\t\t\tlocal_ns_num = 0;\n\t\tlocal_id++;\n\t\tlocal_id &= 0xffff;\n\t\t/* write new values back while still under lock */\n\t\tlast_id = local_id;\n\t\tlast_ns_num = local_ns_num;\n\t\t/* struct copy */\n\t\t/* can't just take a pointer, __nameserver[x]\n\t\t * is not safe to use outside of locks */\n\t\tsa = __nameserver[local_ns_num];\n\t\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\n\t\tmemset(packet, 0, PACKETSZ);\n\t\tmemset(&h, 0, sizeof(h));\n\n\t\t/* encode header */\n\t\th.id = local_id;\n\t\th.qdcount = 1;\n\t\th.rd = 1;\n\t\tDPRINTF(\"encoding header\\n\", h.rd);\n\t\ti = __encode_header(&h, packet, PACKETSZ);\n\t\tif (i < 0)\n\t\t\tgoto fail;\n\n\t\t/* encode question */\n\t\tDPRINTF(\"lookup name: %s\\n\", lookup);\n\t\tq.dotted = lookup;\n\t\tq.qtype = type;\n\t\tq.qclass = C_IN; /* CLASS_IN */\n\t\tj = __encode_question(&q, packet+i, PACKETSZ-i);\n\t\tif (j < 0)\n\t\t\tgoto fail;\n\t\tpacket_len = i + j;\n\n\t\t/* send packet */\n#ifdef DEBUG\n\t\t{\n\t\t\tconst socklen_t plen = sa.sa.sa_family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN;\n\t\t\tchar *pbuf = malloc(plen);\n\t\t\tif (pbuf == NULL) ;/* nothing */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\telse if (sa.sa.sa_family == AF_INET6)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET6, &sa.sa6.sin6_addr, pbuf, plen);\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\telse if (sa.sa.sa_family == AF_INET)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET, &sa.sa4.sin_addr, pbuf, plen);\n#endif\n\t\t\tDPRINTF(\"On try %d, sending query to %s, port %d\\n\",\n\t\t\t\tretries_left, pbuf, NAMESERVER_PORT);\n\t\t\tfree(pbuf);\n\t\t}\n#endif\n\t\tfd = socket(sa.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\t\tif (fd < 0) /* paranoia */\n\t\t\tgoto try_next_server;\n\t\trc = connect(fd, &sa.sa, sizeof(sa));\n\t\tif (rc < 0) {\n\t\t\t/*if (errno == ENETUNREACH) { */\n\t\t\t\t/* routing error, presume not transient */\n\t\t\t\tgoto try_next_server;\n\t\t\t/*} */\n/*For example, what transient error this can be? Can't think of any */\n\t\t\t/* retry */\n\t\t\t/*continue; */\n\t\t}\n\t\tDPRINTF(\"Xmit packet len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\t/* no error check - if it fails, we time out on recv */\n\t\tsend(fd, packet, packet_len, 0);\n\n#ifdef USE_SELECT\n\t\treply_timeout = __resolv_timeout;\n wait_again:\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(fd, &fds);\n\t\ttv.tv_sec = reply_timeout;\n\t\ttv.tv_usec = 0;\n\t\tif (select(fd + 1, &fds, NULL, NULL, &tv) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\treply_timeout--;\n#else /* !USE_SELECT */\n\t\treply_timeout = __resolv_timeout * 1000;\n wait_again:\n\t\tfds.fd = fd;\n\t\tfds.events = POLLIN;\n\t\tif (poll(&fds, 1, reply_timeout) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\tif (fds.revents & (POLLERR | POLLHUP | POLLNVAL)) {\n\t\t\tDPRINTF(\"Bad event\\n\");\n\t\t\tgoto try_next_server;\n\t\t}\n/*TODO: better timeout accounting?*/\n\t\treply_timeout -= 1000;\n#endif /* USE_SELECT */\n\n/* vda: a bogus response seen in real world (caused SEGV in uclibc):\n * \"ping www.google.com\" sending AAAA query and getting\n * response with one answer... with answer part missing!\n * Fixed by thorough checks for not going past the packet's end.\n */\n#ifdef DEBUG\n\t\t{\n\t\t\tstatic const char test_query[32] = \"\\0\\2\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tstatic const char test_respn[32] = \"\\0\\2\\201\\200\\0\\1\\0\\1\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tpos = memcmp(packet + 2, test_query + 2, 30);\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n\t\t\tif (pos == 0) {\n\t\t\t\tpacket_len = 32;\n\t\t\t\tmemcpy(packet + 2, test_respn + 2, 30);\n\t\t\t}\n\t\t}\n#else\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n#endif\n\n\t\tif (packet_len < HFIXEDSZ) {\n\t\t\t/* too short!\n\t\t\t * If the peer did shutdown then retry later,\n\t\t\t * try next peer on error.\n\t\t\t * it's just a bogus packet from somewhere */\n bogus_packet:\n\t\t\tif (packet_len >= 0 && reply_timeout)\n\t\t\t\tgoto wait_again;\n\t\t\tgoto try_next_server;\n\t\t}\n\t\t__decode_header(packet, &h);\n\t\tDPRINTF(\"len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\tif (h.id != local_id || !h.qr) {\n\t\t\t/* unsolicited */\n\t\t\tgoto bogus_packet;\n\t\t}\n\n\t\tDPRINTF(\"Got response (i think)!\\n\");\n\t\tDPRINTF(\"qrcount=%d,ancount=%d,nscount=%d,arcount=%d\\n\",\n\t\t\t\th.qdcount, h.ancount, h.nscount, h.arcount);\n\t\tDPRINTF(\"opcode=%d,aa=%d,tc=%d,rd=%d,ra=%d,rcode=%d\\n\",\n\t\t\t\th.opcode, h.aa, h.tc, h.rd, h.ra, h.rcode);\n\n\t\t/* bug 660 says we treat negative response as an error\n\t\t * and retry, which is, eh, an error. :)\n\t\t * We were incurring long delays because of this. */\n\t\tif (h.rcode == NXDOMAIN || h.rcode == SERVFAIL) {\n\t\t\t/* if possible, try next search domain */\n\t\t\tif (!ends_with_dot) {\n\t\t\t\tDPRINTF(\"variant:%d sdomains:%d\\n\", variant, sdomains);\n\t\t\t\tif (variant < sdomains - 1) {\n\t\t\t\t\t/* next search domain */\n\t\t\t\t\tvariant++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* no more search domains to try */\n\t\t\t}\n\t\t\tif (h.rcode != SERVFAIL) {\n\t\t\t\t/* dont loop, this is \"no such host\" situation */\n\t\t\t\th_errno = HOST_NOT_FOUND;\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* Insert other non-fatal errors here, which do not warrant\n\t\t * switching to next nameserver */\n\n\t\t/* Strange error, assuming this nameserver is feeling bad */\n\t\tif (h.rcode != 0)\n\t\t\tgoto try_next_server;\n\n\t\t/* Code below won't work correctly with h.ancount == 0, so... */\n\t\tif (h.ancount <= 0) {\n\t\t\th_errno = NO_DATA; /* [is this correct code to check for?] */\n\t\t\tgoto fail1;\n\t\t}\n\t\tpos = HFIXEDSZ;\n\t\tfor (j = 0; j < h.qdcount; j++) {\n\t\t\tDPRINTF(\"Skipping question %d at %d\\n\", j, pos);\n\t\t\ti = __length_question(packet + pos, packet_len - pos);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"Packet'question section \"\n\t\t\t\t\t\"is truncated, trying next server\\n\");\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\t\t\tDPRINTF(\"Length of question %d is %d\\n\", j, i);\n\t\t}\n\t\tDPRINTF(\"Decoding answer at pos %d\\n\", pos);\n\n\t\tfirst_answer = 1;\n\t\ta->dotted = NULL;\n\t\tfor (j = 0; j < h.ancount; j++) {\n\t\t\ti = __decode_answer(packet, pos, packet_len, &ma);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"failed decode %d\\n\", i);\n\t\t\t\t/* If the message was truncated but we have\n\t\t\t\t * decoded some answers, pretend it's OK */\n\t\t\t\tif (j && h.tc)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\n\t\t\tif (first_answer) {\n\t\t\t\tma.buf = a->buf;\n\t\t\t\tma.buflen = a->buflen;\n\t\t\t\tma.add_count = a->add_count;\n\t\t\t\tfree(a->dotted);\n\t\t\t\tmemcpy(a, &ma, sizeof(ma));\n\t\t\t\tif (a->atype != T_SIG && (NULL == a->buf || (type != T_A && type != T_AAAA)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a->atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\ta->add_count = h.ancount - j - 1;\n\t\t\t\tif ((a->rdlength + sizeof(struct in_addr*)) * a->add_count > a->buflen)\n\t\t\t\t\tbreak;\n\t\t\t\ta->add_count = 0;\n\t\t\t\tfirst_answer = 0;\n\t\t\t} else {\n\t\t\t\tfree(ma.dotted);\n\t\t\t\tif (ma.atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (a->rdlength != ma.rdlength) {\n\t\t\t\t\tfree(a->dotted);\n\t\t\t\t\tDPRINTF(\"Answer address len(%u) differs from original(%u)\\n\",\n\t\t\t\t\t\t\tma.rdlength, a->rdlength);\n\t\t\t\t\tgoto try_next_server;\n\t\t\t\t}\n\t\t\t\tmemcpy(a->buf + (a->add_count * ma.rdlength), ma.rdata, ma.rdlength);\n\t\t\t\t++a->add_count;\n\t\t\t}\n\t\t}\n\n\t\t/* Success! */\n\t\tDPRINTF(\"Answer name = |%s|\\n\", a->dotted);\n\t\tDPRINTF(\"Answer type = |%d|\\n\", a->atype);\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tif (outpacket)\n\t\t\t*outpacket = packet;\n\t\telse\n\t\t\tfree(packet);\n\t\tfree(lookup);\n\t\treturn packet_len;\n\n try_next_server:\n\t\t/* Try next nameserver */\n\t\tretries_left--;\n\t\tlocal_ns_num++;\n\t\tvariant = -1;\n\t} while (retries_left > 0);\n\n fail:\n\th_errno = NETDB_INTERNAL;\n fail1:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(lookup);\n\tfree(packet);\n\treturn -1;\n}\n#endif /* L_dnslookup */\n\n\n#ifdef L_read_etc_hosts_r\n\nparser_t * __open_etc_hosts(void)\n{\n\tparser_t *parser;\n\tparser = config_open(\"/etc/hosts\");\n#ifdef FALLBACK_TO_CONFIG_RESOLVCONF\n\tif (parser == NULL)\n\t\tparser = config_open(\"/etc/config/hosts\");\n#endif\n\treturn parser;\n}\n\n#define MINTOKENS 2 /* ip address + canonical name */\n#define MAXTOKENS (MINTOKENS + MAXALIASES)\n#define HALISTOFF (sizeof(char*) * (MAXTOKENS + 1))\t/* reserve space for list terminator */\n#define INADDROFF (HALISTOFF + 2 * sizeof(char*))\n\nint __read_etc_hosts_r(\n\t\tparser_t * parser,\n\t\tconst char *name,\n\t\tint type,\n\t\tenum etc_hosts_action action,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf, size_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n\tchar **tok = NULL;\n\tstruct in_addr *h_addr0 = NULL;\n\tconst size_t aliaslen = INADDROFF +\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\t\t\t\tsizeof(struct in6_addr)\n#else\n\t\t\t\t\t\t\tsizeof(struct in_addr)\n#endif\n\t\t\t\t\t\t\t;\n\tint ret = HOST_NOT_FOUND;\n\t/* make sure pointer is aligned */\n\tint i = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\n\t*h_errnop = NETDB_INTERNAL;\n\tif (/* (ssize_t)buflen < 0 || */ buflen < aliaslen\n\t\t|| (buflen - aliaslen) < BUFSZ + 1)\n\t\treturn ERANGE;\n\tif (parser == NULL)\n\t\tparser = __open_etc_hosts();\n\tif (parser == NULL) {\n\t\t*result = NULL;\n\t\treturn errno;\n\t}\n\t/* Layout in buf:\n\t * char *alias[MAXTOKENS]  = {address, name, aliases...}\n\t * char **h_addr_list[1]   = {*in[6]_addr, NULL}\n\t * struct in[6]_addr\n\t * char line_buffer[BUFSZ+];\n\t */\n\tparser->data = buf;\n\tparser->data_len = aliaslen;\n\tparser->line_len = buflen - aliaslen;\n\t*h_errnop = HOST_NOT_FOUND;\n\t/* <ip>[[:space:]][<aliases>] */\n\twhile (config_read(parser, &tok, MAXTOKENS, MINTOKENS, \"# \\t\", PARSE_NORMAL)) {\n\t\tresult_buf->h_aliases = tok+1;\n\t\tif (action == GETHOSTENT) {\n\t\t\t/* Return whatever the next entry happens to be. */\n\t\t\t;\n\t\t} else if (action == GET_HOSTS_BYADDR) {\n\t\t\tif (strcmp(name, *tok) != 0)\n\t\t\t\tcontinue;\n\t\t} else { /* GET_HOSTS_BYNAME */\n\t\t\tint aliases = 0;\n\t\t\tchar **alias = tok + 1;\n\t\t\twhile (aliases < MAXALIASES) {\n\t\t\t\tchar *tmp = *(alias+aliases++);\n\t\t\t\tif (tmp && strcasecmp(name, tmp) == 0)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\nfound:\n\t\tresult_buf->h_name = *(result_buf->h_aliases++);\n\t\tresult_buf->h_addr_list = (char**)(buf + HALISTOFF);\n\t\t*(result_buf->h_addr_list + 1) = '\\0';\n\t\th_addr0 = (struct in_addr*)(buf + INADDROFF);\n\t\tresult_buf->h_addr = (char*)h_addr0;\n\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV4__\n\t\telse if (type == AF_INET\n\t\t\t\t&& inet_pton(AF_INET, *tok, h_addr0) > 0) {\n\t\t\tDPRINTF(\"Found INET\\n\");\n\t\t\tresult_buf->h_addrtype = AF_INET;\n\t\t\tresult_buf->h_length = sizeof(struct in_addr);\n\t\t\t*result = result_buf;\n\t\t\tret = NETDB_SUCCESS;\n\t\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n#define in6 ((struct in6_addr *)buf)\n\t\telse if (type == AF_INET6\n\t\t\t\t&& inet_pton(AF_INET6, *tok, h_addr0) > 0) {\n\t\t\tDPRINTF(\"Found INET6\\n\");\n\t\t\tresult_buf->h_addrtype = AF_INET6;\n\t\t\tresult_buf->h_length = sizeof(struct in6_addr);\n\t\t\t*result = result_buf;\n\t\t\tret = NETDB_SUCCESS;\n\t\t}\n#endif\n\t\telse {\n\t\t\t/* continue parsing in the hope the user has multiple\n\t\t\t * host types listed in the database like so:\n\t\t\t * <ipv4 addr> host\n\t\t\t * <ipv6 addr> host\n\t\t\t * If looking for an IPv6 addr, don't bail when we got the IPv4\n\t\t\t */\n\t\t\tDPRINTF(\"Error: Found host but different address family\\n\");\n\t\t\t/* NB: gethostbyname2_r depends on this feature\n\t\t\t * to avoid looking for IPv6 addr of \"localhost\" etc */\n\t\t\tret = TRY_AGAIN;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (action != GETHOSTENT)\n\t\tconfig_close(parser);\n\treturn ret;\n#undef in6\n}\n#endif /* L_read_etc_hosts_r */\n\n\n#ifdef L_get_hosts_byname_r\n\nint __get_hosts_byname_r(const char *name,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n\treturn __read_etc_hosts_r(NULL, name, type, GET_HOSTS_BYNAME,\n\t                          result_buf, buf, buflen, result, h_errnop);\n}\n#endif /* L_get_hosts_byname_r */\n\n\n#ifdef L_get_hosts_byaddr_r\n\nint __get_hosts_byaddr_r(const char *addr,\n\t\tint len,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n#ifndef __UCLIBC_HAS_IPV6__\n\tchar\tipaddr[INET_ADDRSTRLEN];\n#else\n\tchar\tipaddr[INET6_ADDRSTRLEN];\n#endif\n\n\tswitch (type) {\n#ifdef __UCLIBC_HAS_IPV4__\n\t\tcase AF_INET:\n\t\t\tif (len != sizeof(struct in_addr))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n\t\t\tif (len != sizeof(struct in6_addr))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\tinet_ntop(type, addr, ipaddr, sizeof(ipaddr));\n\n\treturn __read_etc_hosts_r(NULL, ipaddr, type, GET_HOSTS_BYADDR,\n\t\t\t\tresult_buf, buf, buflen, result, h_errnop);\n}\n#endif /* L_get_hosts_byaddr_r */\n\n\n#ifdef L_getnameinfo\n\nint getnameinfo(const struct sockaddr *sa,\n\t\tsocklen_t addrlen,\n\t\tchar *host,\n\t\tsocklen_t hostlen,\n\t\tchar *serv,\n\t\tsocklen_t servlen,\n\t\tunsigned flags)\n{\n\tint serrno = errno;\n\tbool ok = 0;\n\tstruct hostent *hoste = NULL;\n\tchar domain[256];\n\n\tif (flags & ~(NI_NUMERICHOST|NI_NUMERICSERV|NI_NOFQDN|NI_NAMEREQD|NI_DGRAM))\n\t\treturn EAI_BADFLAGS;\n\n\tif (sa == NULL || addrlen < sizeof(sa_family_t))\n\t\treturn EAI_FAMILY;\n\n\tif ((flags & NI_NAMEREQD) && host == NULL && serv == NULL)\n\t\treturn EAI_NONAME;\n\n\tif (sa->sa_family == AF_LOCAL) /* valid */;\n#ifdef __UCLIBC_HAS_IPV4__\n\telse if (sa->sa_family == AF_INET) {\n\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\treturn EAI_FAMILY;\n\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\telse if (sa->sa_family == AF_INET6) {\n\t\tif (addrlen < sizeof(struct sockaddr_in6))\n\t\t\treturn EAI_FAMILY;\n\t}\n#endif\n\telse\n\t\treturn EAI_FAMILY;\n\n\tif (host != NULL && hostlen > 0)\n\t\tswitch (sa->sa_family) {\n\t\tcase AF_INET:\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n#endif\n\t\t\tif (!(flags & NI_NUMERICHOST)) {\n\t\t\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\telse if (sa->sa_family == AF_INET6)\n\t\t\t\t\thoste = gethostbyaddr((const void *)\n\t\t\t\t\t\t&(((const struct sockaddr_in6 *) sa)->sin6_addr),\n\t\t\t\t\t\tsizeof(struct in6_addr), AF_INET6);\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\t\telse\n\t\t\t\t\thoste = gethostbyaddr((const void *)\n\t\t\t\t\t\t&(((const struct sockaddr_in *)sa)->sin_addr),\n\t\t\t\t\t\tsizeof(struct in_addr), AF_INET);\n#endif\n\n\t\t\t\tif (hoste) {\n\t\t\t\t\tchar *c;\n\t\t\t\t\tif ((flags & NI_NOFQDN)\n\t\t\t\t\t && (getdomainname(domain, sizeof(domain)) == 0)\n\t\t\t\t\t && (c = strstr(hoste->h_name, domain)) != NULL\n\t\t\t\t\t && (c != hoste->h_name) && (*(--c) == '.')\n\t\t\t\t\t) {\n\t\t\t\t\t\tstrncpy(host, hoste->h_name,\n\t\t\t\t\t\t\tMIN(hostlen, (size_t) (c - hoste->h_name)));\n\t\t\t\t\t\thost[MIN(hostlen - 1, (size_t) (c - hoste->h_name))] = '\\0';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy(host, hoste->h_name, hostlen);\n\t\t\t\t\t}\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ok) {\n\t\t\t\tconst char *c = NULL;\n\n\t\t\t\tif (flags & NI_NAMEREQD) {\n\t\t\t\t\terrno = serrno;\n\t\t\t\t\treturn EAI_NONAME;\n\t\t\t\t}\n\t\t\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\telse if (sa->sa_family == AF_INET6) {\n\t\t\t\t\tconst struct sockaddr_in6 *sin6p;\n\n\t\t\t\t\tsin6p = (const struct sockaddr_in6 *) sa;\n\t\t\t\t\tc = inet_ntop(AF_INET6,\n\t\t\t\t\t\t(const void *) &sin6p->sin6_addr,\n\t\t\t\t\t\thost, hostlen);\n#if 0\n\t\t\t\t\t/* Does scope id need to be supported? */\n\t\t\t\t\tuint32_t scopeid;\n\t\t\t\t\tscopeid = sin6p->sin6_scope_id;\n\t\t\t\t\tif (scopeid != 0) {\n\t\t\t\t\t\t/* Buffer is >= IFNAMSIZ+1.  */\n\t\t\t\t\t\tchar scopebuf[IFNAMSIZ + 1];\n\t\t\t\t\t\tchar *scopeptr;\n\t\t\t\t\t\tint ni_numericscope = 0;\n\t\t\t\t\t\tsize_t real_hostlen = strnlen(host, hostlen);\n\t\t\t\t\t\tsize_t scopelen = 0;\n\n\t\t\t\t\t\tscopebuf[0] = SCOPE_DELIMITER;\n\t\t\t\t\t\tscopebuf[1] = '\\0';\n\t\t\t\t\t\tscopeptr = &scopebuf[1];\n\n\t\t\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6p->sin6_addr)\n\t\t\t\t\t\t    || IN6_IS_ADDR_MC_LINKLOCAL(&sin6p->sin6_addr)) {\n\t\t\t\t\t\t\tif (if_indextoname(scopeid, scopeptr) == NULL)\n\t\t\t\t\t\t\t\t++ni_numericscope;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tscopelen = strlen(scopebuf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t++ni_numericscope;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ni_numericscope)\n\t\t\t\t\t\t\tscopelen = 1 + snprintf(scopeptr,\n\t\t\t\t\t\t\t\t(scopebuf\n\t\t\t\t\t\t\t\t+ sizeof scopebuf\n\t\t\t\t\t\t\t\t- scopeptr),\n\t\t\t\t\t\t\t\t\"%u\", scopeid);\n\n\t\t\t\t\t\tif (real_hostlen + scopelen + 1 > hostlen)\n\t\t\t\t\t\t\treturn EAI_SYSTEM;\n\t\t\t\t\t\tmemcpy(host + real_hostlen, scopebuf, scopelen + 1);\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n#endif /* __UCLIBC_HAS_IPV6__ */\n#if defined __UCLIBC_HAS_IPV4__\n\t\t\t\telse {\n\t\t\t\t\tc = inet_ntop(AF_INET, (const void *)\n\t\t\t\t\t\t&(((const struct sockaddr_in *) sa)->sin_addr),\n\t\t\t\t\t\thost, hostlen);\n\t\t\t\t}\n#endif\n\t\t\t\tif (c == NULL) {\n\t\t\t\t\terrno = serrno;\n\t\t\t\t\treturn EAI_SYSTEM;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AF_LOCAL:\n\t\t\tif (!(flags & NI_NUMERICHOST)) {\n\t\t\t\tstruct utsname utsname;\n\n\t\t\t\tif (!uname(&utsname)) {\n\t\t\t\t\tstrncpy(host, utsname.nodename, hostlen);\n\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tif (flags & NI_NAMEREQD) {\n\t\t\t\terrno = serrno;\n\t\t\t\treturn EAI_NONAME;\n\t\t\t}\n\n\t\t\tstrncpy(host, \"localhost\", hostlen);\n\t\t\tbreak;\n/* Already checked above\n\t\tdefault:\n\t\t\treturn EAI_FAMILY;\n*/\n\t}\n\n\tif (serv && (servlen > 0)) {\n\t\tif (sa->sa_family == AF_LOCAL) {\n\t\t\tstrncpy(serv, ((const struct sockaddr_un *) sa)->sun_path, servlen);\n\t\t} else { /* AF_INET || AF_INET6 */\n\t\t\tif (!(flags & NI_NUMERICSERV)) {\n\t\t\t\tstruct servent *s;\n\t\t\t\ts = getservbyport(((const struct sockaddr_in *) sa)->sin_port,\n\t\t\t\t      ((flags & NI_DGRAM) ? \"udp\" : \"tcp\"));\n\t\t\t\tif (s) {\n\t\t\t\t\tstrncpy(serv, s->s_name, servlen);\n\t\t\t\t\tgoto DONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnprintf(serv, servlen, \"%d\",\n\t\t\t\tntohs(((const struct sockaddr_in *) sa)->sin_port));\n\t\t}\n\t}\nDONE:\n\tif (host && (hostlen > 0))\n\t\thost[hostlen-1] = 0;\n\tif (serv && (servlen > 0))\n\t\tserv[servlen-1] = 0;\n\terrno = serrno;\n\treturn 0;\n}\nlibc_hidden_def(getnameinfo)\n#endif /* L_getnameinfo */\n\n\n#ifdef L_gethostbyname_r\n\n/* Bug 671 says:\n * \"uClibc resolver's gethostbyname does not return the requested name\n * as an alias, but instead returns the canonical name. glibc's\n * gethostbyname has a similar bug where it returns the requested name\n * with the search domain name appended (to make a FQDN) as an alias,\n * but not the original name itself. Both contradict POSIX, which says\n * that the name argument passed to gethostbyname must be in the alias list\"\n * This is fixed now, and we differ from glibc:\n *\n * $ ./gethostbyname_uclibc wer.google.com\n * h_name:'c13-ss-2-lb.cnet.com'\n * h_length:4\n * h_addrtype:2 AF_INET\n * alias:'wer.google.com' <===\n * addr: 0x4174efd8 '216.239.116.65'\n *\n * $ ./gethostbyname_glibc wer.google.com\n * h_name:'c13-ss-2-lb.cnet.com'\n * h_length:4\n * h_addrtype:2 AF_INET\n * alias:'wer.google.com.com' <===\n * addr:'216.239.116.65'\n *\n * When examples were run, /etc/resolv.conf contained \"search com\" line.\n */\nint gethostbyname_r(const char *name,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n\tstruct in_addr **addr_list;\n\tchar **alias;\n\tchar *alias0;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint wrong_af = 0;\n\n\t*result = NULL;\n\tif (!name)\n\t\treturn EINVAL;\n\n\t/* do /etc/hosts first */\n\t{\n\t\tint old_errno = errno;  /* save the old errno and reset errno */\n\t\t__set_errno(0);         /* to check for missing /etc/hosts. */\n\t\ti = __get_hosts_byname_r(name, AF_INET, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\t\tif (i == NETDB_SUCCESS) {\n\t\t\t__set_errno(old_errno);\n\t\t\treturn i;\n\t\t}\n\t\tswitch (*h_errnop) {\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\twrong_af = (i == TRY_AGAIN);\n\t\t\tcase NO_ADDRESS:\n\t\t\t\tbreak;\n\t\t\tcase NETDB_INTERNAL:\n\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else fall through */\n\t\t\tdefault:\n\t\t\t\treturn i;\n\t\t}\n\t\t__set_errno(old_errno);\n\t}\n\n\tDPRINTF(\"Nothing found in /etc/hosts\\n\");\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* prepare future h_aliases[0] */\n\ti = strlen(name) + 1;\n\tif ((ssize_t)buflen <= i)\n\t\treturn ERANGE;\n\tmemcpy(buf, name, i); /* paranoia: name might change */\n\talias0 = buf;\n\tbuf += i;\n\tbuflen -= i;\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[2];\n\t * struct in_addr* addr_list[NN+1];\n\t * struct in_addr* in[NN];\n\t */\n\talias = (char **)buf;\n\tbuf += sizeof(alias[0]) * 2;\n\tbuflen -= sizeof(alias[0]) * 2;\n\taddr_list = (struct in_addr **)buf;\n\t/* buflen may be < 0, must do signed compare */\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\n\t/* we store only one \"alias\" - the name itself */\n\talias[0] = alias0;\n\talias[1] = NULL;\n\n\t/* maybe it is already an address? */\n\t{\n\t\tstruct in_addr *in = (struct in_addr *)(buf + sizeof(addr_list[0]) * 2);\n\t\tif (inet_aton(name, in)) {\n\t\t\taddr_list[0] = in;\n\t\t\taddr_list[1] = NULL;\n\t\t\tresult_buf->h_name = alias0;\n\t\t\tresult_buf->h_aliases = alias;\n\t\t\tresult_buf->h_addrtype = AF_INET;\n\t\t\tresult_buf->h_length = sizeof(struct in_addr);\n\t\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t\t*result = result_buf;\n\t\t\t*h_errnop = NETDB_SUCCESS;\n\t\t\treturn NETDB_SUCCESS;\n\t\t}\n\t}\n\n\t/* what if /etc/hosts has it but it's not IPv4?\n\t * F.e. \"::1 localhost6\". We don't do DNS query for such hosts -\n\t * \"ping localhost6\" should be fast even if DNS server is down! */\n\tif (wrong_af) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\treturn TRY_AGAIN;\n\t}\n\n\t/* talk to DNS servers */\n\ta.buf = buf;\n\t/* take into account that at least one address will be there,\n\t * we'll need space for one in_addr + two addr_list[] elems */\n\ta.buflen = buflen - ((sizeof(addr_list[0]) * 2 + sizeof(struct in_addr)));\n\ta.add_count = 0;\n\tpacket_len = __dns_lookup(name, T_A, &packet, &a);\n\tif (packet_len < 0) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\tDPRINTF(\"__dns_lookup returned < 0\\n\");\n\t\treturn TRY_AGAIN;\n\t}\n\n\tif (a.atype == T_A) { /* ADDRESS */\n\t\t/* we need space for addr_list[] and one IPv4 address */\n\t\t/* + 1 accounting for 1st addr (it's in a.rdata),\n\t\t * another + 1 for NULL in last addr_list[]: */\n\t\tint need_bytes = sizeof(addr_list[0]) * (a.add_count + 1 + 1)\n\t\t\t\t/* for 1st addr (it's in a.rdata): */\n\t\t\t\t+ sizeof(struct in_addr);\n\t\t/* how many bytes will 2nd and following addresses take? */\n\t\tint ips_len = a.add_count * a.rdlength;\n\n\t\tbuflen -= (need_bytes + ips_len);\n\t\tif ((ssize_t)buflen < 0) {\n\t\t\tDPRINTF(\"buffer too small for all addresses\\n\");\n\t\t\t/* *h_errnop = NETDB_INTERNAL; - already is */\n\t\t\ti = ERANGE;\n\t\t\tgoto free_and_ret;\n\t\t}\n\n\t\t/* if there are additional addresses in buf,\n\t\t * move them forward so that they are not destroyed */\n\t\tDPRINTF(\"a.add_count:%d a.rdlength:%d a.rdata:%p\\n\", a.add_count, a.rdlength, a.rdata);\n\t\tmemmove(buf + need_bytes, buf, ips_len);\n\n\t\t/* 1st address is in a.rdata, insert it  */\n\t\tbuf += need_bytes - sizeof(struct in_addr);\n\t\tmemcpy(buf, a.rdata, sizeof(struct in_addr));\n\n\t\t/* fill addr_list[] */\n\t\tfor (i = 0; i <= a.add_count; i++) {\n\t\t\taddr_list[i] = (struct in_addr*)buf;\n\t\t\tbuf += sizeof(struct in_addr);\n\t\t}\n\t\taddr_list[i] = NULL;\n\n\t\t/* if we have enough space, we can report \"better\" name\n\t\t * (it may contain search domains attached by __dns_lookup,\n\t\t * or CNAME of the host if it is different from the name\n\t\t * we used to find it) */\n\t\tif (a.dotted && buflen > strlen(a.dotted)) {\n\t\t\tstrcpy(buf, a.dotted);\n\t\t\talias0 = buf;\n\t\t}\n\n\t\tresult_buf->h_name = alias0;\n\t\tresult_buf->h_aliases = alias;\n\t\tresult_buf->h_addrtype = AF_INET;\n\t\tresult_buf->h_length = sizeof(struct in_addr);\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\ti = NETDB_SUCCESS;\n\t\tgoto free_and_ret;\n\t}\n\n\t*h_errnop = HOST_NOT_FOUND;\n\t__set_h_errno(HOST_NOT_FOUND);\n\ti = TRY_AGAIN;\n\n free_and_ret:\n\tfree(a.dotted);\n\tfree(packet);\n\treturn i;\n}\nlibc_hidden_def(gethostbyname_r)\n#endif /* L_gethostbyname_r */\n\n\n#ifdef L_gethostbyname2_r\n\nint gethostbyname2_r(const char *name,\n\t\tint family,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n#ifndef __UCLIBC_HAS_IPV6__\n\treturn family == (AF_INET)\n\t\t? gethostbyname_r(name, result_buf, buf, buflen, result, h_errnop)\n\t\t: HOST_NOT_FOUND;\n#else\n\tstruct in6_addr **addr_list;\n\tchar **alias;\n\tchar *alias0;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint wrong_af = 0;\n\n\tif (family == AF_INET)\n\t\treturn gethostbyname_r(name, result_buf, buf, buflen, result, h_errnop);\n\n\t*result = NULL;\n\tif (family != AF_INET6)\n\t\treturn EINVAL;\n\n\tif (!name)\n\t\treturn EINVAL;\n\n\t/* do /etc/hosts first */\n\t{\n\t\tint old_errno = errno;  /* save the old errno and reset errno */\n\t\t__set_errno(0);         /* to check for missing /etc/hosts. */\n\t\ti = __get_hosts_byname_r(name, AF_INET6 /*family*/, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\t\tif (i == NETDB_SUCCESS) {\n\t\t\t__set_errno(old_errno);\n\t\t\treturn i;\n\t\t}\n\t\tswitch (*h_errnop) {\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\twrong_af = (i == TRY_AGAIN);\n\t\t\tcase NO_ADDRESS:\n\t\t\t\tbreak;\n\t\t\tcase NETDB_INTERNAL:\n\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else fall through */\n\t\t\tdefault:\n\t\t\t\treturn i;\n\t\t}\n\t\t__set_errno(old_errno);\n\t}\n\n\tDPRINTF(\"Nothing found in /etc/hosts\\n\");\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* prepare future h_aliases[0] */\n\ti = strlen(name) + 1;\n\tif ((ssize_t)buflen <= i)\n\t\treturn ERANGE;\n\tmemcpy(buf, name, i); /* paranoia: name might change */\n\talias0 = buf;\n\tbuf += i;\n\tbuflen -= i;\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[2];\n\t * struct in6_addr* addr_list[NN+1];\n\t * struct in6_addr* in[NN];\n\t */\n\talias = (char **)buf;\n\tbuf += sizeof(alias[0]) * 2;\n\tbuflen -= sizeof(alias[0]) * 2;\n\taddr_list = (struct in6_addr **)buf;\n\t/* buflen may be < 0, must do signed compare */\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\n\t/* we store only one \"alias\" - the name itself */\n\talias[0] = alias0;\n\talias[1] = NULL;\n\n\t/* maybe it is already an address? */\n\t{\n\t\tstruct in6_addr *in = (struct in6_addr *)(buf + sizeof(addr_list[0]) * 2);\n\t\tif (inet_pton(AF_INET6, name, in)) {\n\t\t\taddr_list[0] = in;\n\t\t\taddr_list[1] = NULL;\n\t\t\tresult_buf->h_name = alias0;\n\t\t\tresult_buf->h_aliases = alias;\n\t\t\tresult_buf->h_addrtype = AF_INET6;\n\t\t\tresult_buf->h_length = sizeof(struct in6_addr);\n\t\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t\t*result = result_buf;\n\t\t\t*h_errnop = NETDB_SUCCESS;\n\t\t\treturn NETDB_SUCCESS;\n\t\t}\n\t}\n\n\t/* what if /etc/hosts has it but it's not IPv6?\n\t * F.e. \"127.0.0.1 localhost\". We don't do DNS query for such hosts -\n\t * \"ping localhost\" should be fast even if DNS server is down! */\n\tif (wrong_af) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\treturn TRY_AGAIN;\n\t}\n\n\t/* talk to DNS servers */\n\ta.buf = buf;\n\t/* take into account that at least one address will be there,\n\t * we'll need space of one in6_addr + two addr_list[] elems */\n\ta.buflen = buflen - ((sizeof(addr_list[0]) * 2 + sizeof(struct in6_addr)));\n\ta.add_count = 0;\n\tpacket_len = __dns_lookup(name, T_AAAA, &packet, &a);\n\tif (packet_len < 0) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\tDPRINTF(\"__dns_lookup returned < 0\\n\");\n\t\treturn TRY_AGAIN;\n\t}\n\n\tif (a.atype == T_AAAA) { /* ADDRESS */\n\t\t/* we need space for addr_list[] and one IPv6 address */\n\t\t/* + 1 accounting for 1st addr (it's in a.rdata),\n\t\t * another + 1 for NULL in last addr_list[]: */\n\t\tint need_bytes = sizeof(addr_list[0]) * (a.add_count + 1 + 1)\n\t\t\t\t/* for 1st addr (it's in a.rdata): */\n\t\t\t\t+ sizeof(struct in6_addr);\n\t\t/* how many bytes will 2nd and following addresses take? */\n\t\tint ips_len = a.add_count * a.rdlength;\n\n\t\tbuflen -= (need_bytes + ips_len);\n\t\tif ((ssize_t)buflen < 0) {\n\t\t\tDPRINTF(\"buffer too small for all addresses\\n\");\n\t\t\t/* *h_errnop = NETDB_INTERNAL; - already is */\n\t\t\ti = ERANGE;\n\t\t\tgoto free_and_ret;\n\t\t}\n\n\t\t/* if there are additional addresses in buf,\n\t\t * move them forward so that they are not destroyed */\n\t\tDPRINTF(\"a.add_count:%d a.rdlength:%d a.rdata:%p\\n\", a.add_count, a.rdlength, a.rdata);\n\t\tmemmove(buf + need_bytes, buf, ips_len);\n\n\t\t/* 1st address is in a.rdata, insert it  */\n\t\tbuf += need_bytes - sizeof(struct in6_addr);\n\t\tmemcpy(buf, a.rdata, sizeof(struct in6_addr));\n\n\t\t/* fill addr_list[] */\n\t\tfor (i = 0; i <= a.add_count; i++) {\n\t\t\taddr_list[i] = (struct in6_addr*)buf;\n\t\t\tbuf += sizeof(struct in6_addr);\n\t\t}\n\t\taddr_list[i] = NULL;\n\n\t\t/* if we have enough space, we can report \"better\" name\n\t\t * (it may contain search domains attached by __dns_lookup,\n\t\t * or CNAME of the host if it is different from the name\n\t\t * we used to find it) */\n\t\tif (a.dotted && buflen > strlen(a.dotted)) {\n\t\t\tstrcpy(buf, a.dotted);\n\t\t\talias0 = buf;\n\t\t}\n\n\t\tresult_buf->h_name = alias0;\n\t\tresult_buf->h_aliases = alias;\n\t\tresult_buf->h_addrtype = AF_INET6;\n\t\tresult_buf->h_length = sizeof(struct in6_addr);\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\ti = NETDB_SUCCESS;\n\t\tgoto free_and_ret;\n\t}\n\n\t*h_errnop = HOST_NOT_FOUND;\n\t__set_h_errno(HOST_NOT_FOUND);\n\ti = TRY_AGAIN;\n\n free_and_ret:\n\tfree(a.dotted);\n\tfree(packet);\n\treturn i;\n#endif /* __UCLIBC_HAS_IPV6__ */\n}\nlibc_hidden_def(gethostbyname2_r)\n#endif /* L_gethostbyname2_r */\n\n\n#ifdef L_gethostbyaddr_r\n\nint gethostbyaddr_r(const void *addr, socklen_t addrlen,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf, size_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n\n{\n\tstruct in_addr *in;\n\tstruct in_addr **addr_list;\n\tchar **alias;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint nest = 0;\n\n\t*result = NULL;\n\tif (!addr)\n\t\treturn EINVAL;\n\n\tswitch (type) {\n#ifdef __UCLIBC_HAS_IPV4__\n\t\tcase AF_INET:\n\t\t\tif (addrlen != sizeof(struct in_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n\t\t\tif (addrlen != sizeof(struct in6_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t}\n\n\t/* do /etc/hosts first */\n\ti = __get_hosts_byaddr_r(addr, addrlen, type, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\tif (i == 0)\n\t\treturn i;\n\tswitch (*h_errnop) {\n\t\tcase HOST_NOT_FOUND:\n\t\tcase NO_ADDRESS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn i;\n\t}\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[ALIAS_DIM];\n\t * struct in[6]_addr* addr_list[2];\n\t * struct in[6]_addr in;\n\t * char scratch_buffer[256+];\n\t */\n#define in6 ((struct in6_addr *)in)\n\talias = (char **)buf;\n\taddr_list = (struct in_addr**)buf;\n\tbuf += sizeof(*addr_list) * 2;\n\tbuflen -= sizeof(*addr_list) * 2;\n\tin = (struct in_addr*)buf;\n#ifndef __UCLIBC_HAS_IPV6__\n\tbuf += sizeof(*in);\n\tbuflen -= sizeof(*in);\n\tif (addrlen > sizeof(*in))\n\t\treturn ERANGE;\n#else\n\tbuf += sizeof(*in6);\n\tbuflen -= sizeof(*in6);\n\tif (addrlen > sizeof(*in6))\n\t\treturn ERANGE;\n#endif\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\talias[0] = buf;\n\talias[1] = NULL;\n\taddr_list[0] = in;\n\taddr_list[1] = NULL;\n\tmemcpy(in, addr, addrlen);\n\n\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV4__\n\telse IF_HAS_BOTH(if (type == AF_INET)) {\n\t\tunsigned char *tp = (unsigned char *)addr;\n\t\tsprintf(buf, \"%u.%u.%u.%u.in-addr.arpa\",\n\t\t\t\ttp[3], tp[2], tp[1], tp[0]);\n\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\telse {\n\t\tchar *dst = buf;\n\t\tunsigned char *tp = (unsigned char *)addr + addrlen - 1;\n\t\tdo {\n\t\t\tdst += sprintf(dst, \"%x.%x.\", tp[0] & 0xf, tp[0] >> 4);\n\t\t\ttp--;\n\t\t} while (tp >= (unsigned char *)addr);\n\t\tstrcpy(dst, \"ip6.arpa\");\n\t}\n#endif\n\n\tmemset(&a, '\\0', sizeof(a));\n\tfor (;;) {\n/* Hmm why we memset(a) to zeros only once? */\n\t\tpacket_len = __dns_lookup(buf, T_PTR, &packet, &a);\n\t\tif (packet_len < 0) {\n\t\t\t*h_errnop = HOST_NOT_FOUND;\n\t\t\treturn TRY_AGAIN;\n\t\t}\n\n\t\tstrncpy(buf, a.dotted, buflen);\n\t\tfree(a.dotted);\n\t\tif (a.atype != T_CNAME)\n\t\t\tbreak;\n\n\t\tDPRINTF(\"Got a CNAME in gethostbyaddr()\\n\");\n\t\tif (++nest > MAX_RECURSE) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\t/* Decode CNAME into buf, feed it to __dns_lookup() again */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tif (i < 0) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (a.atype == T_PTR) {\t/* ADDRESS */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tresult_buf->h_name = buf;\n\t\tresult_buf->h_addrtype = type;\n\t\tresult_buf->h_length = addrlen;\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\tresult_buf->h_aliases = alias;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\treturn NETDB_SUCCESS;\n\t}\n\n\tfree(packet);\n\t*h_errnop = NO_ADDRESS;\n\treturn TRY_AGAIN;\n#undef in6\n}\nlibc_hidden_def(gethostbyaddr_r)\n#endif /* L_gethostbyaddr_r */\n\n\n#ifdef L_gethostent_r\n\n__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);\n\nstatic parser_t *hostp = NULL;\nstatic smallint host_stayopen;\n\nvoid endhostent_unlocked(void)\n{\n\tif (hostp) {\n\t\tconfig_close(hostp);\n\t\thostp = NULL;\n\t}\n\thost_stayopen = 0;\n}\nvoid endhostent(void)\n{\n\t__UCLIBC_MUTEX_LOCK(mylock);\n\tendhostent_unlocked();\n\t__UCLIBC_MUTEX_UNLOCK(mylock);\n}\n\nvoid sethostent(int stay_open)\n{\n\t__UCLIBC_MUTEX_LOCK(mylock);\n\tif (stay_open)\n\t\thost_stayopen = 1;\n\t__UCLIBC_MUTEX_UNLOCK(mylock);\n}\n\nint gethostent_r(struct hostent *result_buf, char *buf, size_t buflen,\n\tstruct hostent **result, int *h_errnop)\n{\n\tint ret;\n\n\t__UCLIBC_MUTEX_LOCK(mylock);\n\tif (hostp == NULL) {\n\t\thostp = __open_etc_hosts();\n\t\tif (hostp == NULL) {\n\t\t\t*result = NULL;\n\t\t\tret = TRY_AGAIN;\n\t\t\tgoto DONE;\n\t\t}\n\t}\n\n\tret = __read_etc_hosts_r(hostp, NULL, AF_INET, GETHOSTENT,\n\t\t   result_buf, buf, buflen, result, h_errnop);\n\tif (!host_stayopen)\n\t\tendhostent_unlocked();\nDONE:\n\t__UCLIBC_MUTEX_UNLOCK(mylock);\n\treturn ret;\n}\nlibc_hidden_def(gethostent_r)\n#endif /* L_gethostent_r */\n\n\n#ifndef __UCLIBC_HAS_IPV6__\n #define GETXX_BUFSZ \t(sizeof(struct in_addr) + sizeof(struct in_addr *) * 2 + \\\n\t\t\t/*sizeof(char *)*ALIAS_DIM */+ 384/*namebuffer*/ + 32/* margin */)\n#else\n #define GETXX_BUFSZ \t(sizeof(struct in6_addr) + sizeof(struct in6_addr *) * 2 + \\\n\t\t\t/*sizeof(char *)*ALIAS_DIM */+ 384/*namebuffer*/ + 32/* margin */)\n#endif /* __UCLIBC_HAS_IPV6__ */\n\n#define __INIT_GETXX_BUF(sz)\t\t\t\t\t\\\n\tif (buf == NULL)\t\t\t\t\t\\\n\t\tbuf = (char *)__uc_malloc((sz));\n\n#ifdef L_gethostent\n\nstruct hostent *gethostent(void)\n{\n\tstatic struct hostent hoste;\n\tstatic char *buf = NULL;\n\tstruct hostent *host = NULL;\n#ifndef __UCLIBC_HAS_IPV6__\n #define HOSTENT_BUFSZ\t(sizeof(struct in_addr) + sizeof(struct in_addr *) * 2 + \\\n\t\t\tsizeof(char *)*ALIAS_DIM + BUFSZ /*namebuffer*/ + 2 /* margin */)\n#else\n #define HOSTENT_BUFSZ\t(sizeof(struct in6_addr) + sizeof(struct in6_addr *) * 2 + \\\n\t\t\tsizeof(char *)*ALIAS_DIM + BUFSZ /*namebuffer*/ + 2 /* margin */)\n#endif /* __UCLIBC_HAS_IPV6__ */\n\n\t__INIT_GETXX_BUF(HOSTENT_BUFSZ);\n\tgethostent_r(&hoste, buf, HOSTENT_BUFSZ, &host, &h_errno);\n\treturn host;\n}\n#undef HOSTENT_BUFSZ\n#endif /* L_gethostent */\n\n\n#ifdef L_gethostbyname2\n\nstruct hostent *gethostbyname2(const char *name, int family)\n{\n\tstatic struct hostent hoste;\n\tstatic char *buf = NULL;\n\tstruct hostent *hp;\n\n\t__INIT_GETXX_BUF(GETXX_BUFSZ);\n#ifndef __UCLIBC_HAS_IPV6__\n\tif (family != AF_INET)\n\t\treturn (struct hostent*)NULL;\n\tgethostbyname_r(name, &hoste, buf, GETXX_BUFSZ, &hp, &h_errno);\n#else\n\tgethostbyname2_r(name, family, &hoste, buf, GETXX_BUFSZ, &hp, &h_errno);\n#endif /* __UCLIBC_HAS_IPV6__ */\n\n\treturn hp;\n}\nlibc_hidden_def(gethostbyname2)\n#endif /* L_gethostbyname2 */\n\n\n#ifdef L_gethostbyname\n\nstruct hostent *gethostbyname(const char *name)\n{\n\treturn gethostbyname2(name, AF_INET);\n}\nlibc_hidden_def(gethostbyname)\n#endif /* L_gethostbyname */\n\n\n#ifdef L_gethostbyaddr\n\nstruct hostent *gethostbyaddr(const void *addr, socklen_t len, int type)\n{\n\tstatic struct hostent hoste;\n\tstatic char *buf = NULL;\n\tstruct hostent *hp;\n\n\t__INIT_GETXX_BUF(GETXX_BUFSZ);\n\tgethostbyaddr_r(addr, len, type, &hoste, buf, GETXX_BUFSZ, &hp, &h_errno);\n\treturn hp;\n}\nlibc_hidden_def(gethostbyaddr)\n#endif /* L_gethostbyaddr */\n\n\n#ifdef L_res_comp\n\n/*\n * Expand compressed domain name 'comp_dn' to full domain name.\n * 'msg' is a pointer to the begining of the message,\n * 'eomorig' points to the first location after the message,\n * 'exp_dn' is a pointer to a buffer of size 'length' for the result.\n * Return size of compressed name or -1 if there was an error.\n */\nint dn_expand(const u_char *msg, const u_char *eom, const u_char *src,\n\t\t\t\tchar *dst, int dstsiz)\n{\n\tint n = ns_name_uncompress(msg, eom, src, dst, (size_t)dstsiz);\n\n\tif (n > 0 && dst[0] == '.')\n\t\tdst[0] = '\\0';\n\treturn n;\n}\nlibc_hidden_def(dn_expand)\n\n/*\n * Pack domain name 'exp_dn' in presentation form into 'comp_dn'.\n * Return the size of the compressed name or -1.\n * 'length' is the size of the array pointed to by 'comp_dn'.\n */\nint\ndn_comp(const char *src, u_char *dst, int dstsiz,\n\t\tu_char **dnptrs, u_char **lastdnptr)\n{\n\treturn ns_name_compress(src, dst, (size_t) dstsiz,\n\t\t\t(const u_char **) dnptrs,\n\t\t\t(const u_char **) lastdnptr);\n}\nlibc_hidden_def(dn_comp)\n#endif /* L_res_comp */\n\n\n#ifdef L_ns_name\n\n/* Thinking in noninternationalized USASCII (per the DNS spec),\n * is this character visible and not a space when printed ?\n */\nstatic int printable(int ch)\n{\n\treturn (ch > 0x20 && ch < 0x7f);\n}\n/* Thinking in noninternationalized USASCII (per the DNS spec),\n * is this characted special (\"in need of quoting\") ?\n */\nstatic int special(int ch)\n{\n\tswitch (ch) {\n\t\tcase 0x22: /* '\"' */\n\t\tcase 0x2E: /* '.' */\n\t\tcase 0x3B: /* ';' */\n\t\tcase 0x5C: /* '\\\\' */\n\t\t\t/* Special modifiers in zone files. */\n\t\tcase 0x40: /* '@' */\n\t\tcase 0x24: /* '$' */\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n/*\n * ns_name_uncompress(msg, eom, src, dst, dstsiz)\n *      Expand compressed domain name to presentation format.\n * return:\n *      Number of bytes read out of `src', or -1 (with errno set).\n * note:\n *      Root domain returns as \".\" not \"\".\n */\nint ns_name_uncompress(const u_char *msg, const u_char *eom,\n\t\tconst u_char *src, char *dst, size_t dstsiz)\n{\n\tu_char tmp[NS_MAXCDNAME];\n\tint n;\n\n\tn = ns_name_unpack(msg, eom, src, tmp, sizeof tmp);\n\tif (n == -1)\n\t\treturn -1;\n\tif (ns_name_ntop(tmp, dst, dstsiz) == -1)\n\t\treturn -1;\n\treturn n;\n}\nlibc_hidden_def(ns_name_uncompress)\n\n/*\n * ns_name_ntop(src, dst, dstsiz)\n *      Convert an encoded domain name to printable ascii as per RFC1035.\n * return:\n *      Number of bytes written to buffer, or -1 (with errno set)\n * notes:\n *      The root is returned as \".\"\n *      All other domains are returned in non absolute form\n */\nint ns_name_ntop(const u_char *src, char *dst, size_t dstsiz)\n{\n\tconst u_char *cp;\n\tchar *dn, *eom;\n\tu_char c;\n\tu_int n;\n\n\tcp = src;\n\tdn = dst;\n\teom = dst + dstsiz;\n\n\twhile ((n = *cp++) != 0) {\n\t\tif ((n & NS_CMPRSFLGS) != 0) {\n\t\t\t/* Some kind of compression pointer. */\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dn != dst) {\n\t\t\tif (dn >= eom) {\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*dn++ = '.';\n\t\t}\n\t\tif (dn + n >= eom) {\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\tfor (; n > 0; n--) {\n\t\t\tc = *cp++;\n\t\t\tif (special(c)) {\n\t\t\t\tif (dn + 1 >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = '\\\\';\n\t\t\t\t*dn++ = (char)c;\n\t\t\t} else if (!printable(c)) {\n\t\t\t\tif (dn + 3 >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = '\\\\';\n\t\t\t\t*dn++ = \"0123456789\"[c / 100];\n\t\t\t\tc = c % 100;\n\t\t\t\t*dn++ = \"0123456789\"[c / 10];\n\t\t\t\t*dn++ = \"0123456789\"[c % 10];\n\t\t\t} else {\n\t\t\t\tif (dn >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = (char)c;\n\t\t\t}\n\t\t}\n\t}\n\tif (dn == dst) {\n\t\tif (dn >= eom) {\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\t*dn++ = '.';\n\t}\n\tif (dn >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t*dn++ = '\\0';\n\treturn (dn - dst);\n}\nlibc_hidden_def(ns_name_ntop)\n\nstatic int encode_bitstring(const char **bp, const char *end,\n\t\t\t\t\t\t\tunsigned char **labelp,\n\t\t\t\t\t\t\tunsigned char ** dst,\n\t\t\t\t\t\t\tunsigned const char *eom)\n{\n\tint afterslash = 0;\n\tconst char *cp = *bp;\n\tunsigned char *tp;\n\tconst char *beg_blen;\n\tint value = 0, count = 0, tbcount = 0, blen = 0;\n\n\tbeg_blen = NULL;\n\n\t/* a bitstring must contain at least 2 characters */\n\tif (end - cp < 2)\n\t\treturn EINVAL;\n\n\t/* XXX: currently, only hex strings are supported */\n\tif (*cp++ != 'x')\n\t\treturn EINVAL;\n\tif (!isxdigit((unsigned char) *cp)) /*%< reject '\\[x/BLEN]' */\n\t\treturn EINVAL;\n\n\tfor (tp = *dst + 1; cp < end && tp < eom; cp++) {\n\t\tunsigned char c = *cp;\n\n\t\tswitch (c) {\n\t\tcase ']':       /*%< end of the bitstring */\n\t\t\tif (afterslash) {\n\t\t\t\tchar *end_blen;\n\t\t\t\tif (beg_blen == NULL)\n\t\t\t\t\treturn EINVAL;\n\t\t\t\tblen = (int)strtol(beg_blen, &end_blen, 10);\n\t\t\t\tif (*end_blen != ']')\n\t\t\t\t\treturn EINVAL;\n\t\t\t}\n\t\t\tif (count)\n\t\t\t\t*tp++ = ((value << 4) & 0xff);\n\t\t\tcp++;   /*%< skip ']' */\n\t\t\tgoto done;\n\t\tcase '/':\n\t\t\tafterslash = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (afterslash) {\n\t\t\t\tif (!__isdigit_char(c))\n\t\t\t\t\treturn EINVAL;\n\t\t\t\tif (beg_blen == NULL) {\n\t\t\t\t\tif (c == '0') {\n\t\t\t\t\t\t/* blen never begings with 0 */\n\t\t\t\t\t\treturn EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\tbeg_blen = cp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!__isdigit_char(c)) {\n\t\t\t\t\tc = c | 0x20; /* lowercase */\n\t\t\t\t\tc = c - 'a';\n\t\t\t\t\tif (c > 5) /* not a-f? */\n\t\t\t\t\t\treturn EINVAL;\n\t\t\t\t\tc += 10 + '0';\n\t\t\t\t}\n\t\t\t\tvalue <<= 4;\n\t\t\t\tvalue += (c - '0');\n\t\t\t\tcount += 4;\n\t\t\t\ttbcount += 4;\n\t\t\t\tif (tbcount > 256)\n\t\t\t\t\treturn EINVAL;\n\t\t\t\tif (count == 8) {\n\t\t\t\t\t*tp++ = value;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n  done:\n\tif (cp >= end || tp >= eom)\n\t\treturn EMSGSIZE;\n\n\t/*\n\t * bit length validation:\n\t * If a <length> is present, the number of digits in the <bit-data>\n\t * MUST be just sufficient to contain the number of bits specified\n\t * by the <length>. If there are insignificant bits in a final\n\t * hexadecimal or octal digit, they MUST be zero.\n\t * RFC2673, Section 3.2.\n\t */\n\tif (blen > 0) {\n\t\tint traillen;\n\n\t\tif (((blen + 3) & ~3) != tbcount)\n\t\t\treturn EINVAL;\n\t\ttraillen = tbcount - blen; /*%< between 0 and 3 */\n\t\tif (((value << (8 - traillen)) & 0xff) != 0)\n\t\t\treturn EINVAL;\n\t}\n\telse\n\t\tblen = tbcount;\n\tif (blen == 256)\n\t\tblen = 0;\n\n\t/* encode the type and the significant bit fields */\n\t**labelp = DNS_LABELTYPE_BITSTRING;\n\t**dst = blen;\n\n\t*bp = cp;\n\t*dst = tp;\n\n\treturn 0;\n}\n\nint ns_name_pton(const char *src, u_char *dst, size_t dstsiz)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tu_char *label, *bp, *eom;\n\tint c, n, escaped, e = 0;\n\tchar *cp;\n\n\tescaped = 0;\n\tbp = dst;\n\teom = dst + dstsiz;\n\tlabel = bp++;\n\n\twhile ((c = *src++) != 0) {\n\t\tif (escaped) {\n\t\t\tif (c == '[') { /*%< start a bit string label */\n\t\t\t\tcp = strchr(src, ']');\n\t\t\t\tif (cp == NULL) {\n\t\t\t\t\terrno = EINVAL; /*%< ??? */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\te = encode_bitstring(&src, cp + 2,\n\t\t\t\t\t\t\t &label, &bp, eom);\n\t\t\t\tif (e != 0) {\n\t\t\t\t\terrno = e;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tescaped = 0;\n\t\t\t\tlabel = bp++;\n\t\t\t\tc = *src++;\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tgoto done;\n\t\t\t\tif (c != '.') {\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcp = strchr(digits, c);\n\t\t\tif (cp != NULL) {\n\t\t\t\tn = (cp - digits) * 100;\n\t\t\t\tc = *src++;\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tcp = strchr(digits, c);\n\t\t\t\tif (cp == NULL)\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tn += (cp - digits) * 10;\n\t\t\t\tc = *src++;\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tcp = strchr(digits, c);\n\t\t\t\tif (cp == NULL)\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tn += (cp - digits);\n\t\t\t\tif (n > 255)\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tc = n;\n\t\t\t}\n\t\t\tescaped = 0;\n\t\t} else if (c == '\\\\') {\n\t\t\tescaped = 1;\n\t\t\tcontinue;\n\t\t} else if (c == '.') {\n\t\t\tc = (bp - label - 1);\n\t\t\tif ((c & NS_CMPRSFLGS) != 0) {  /*%< Label too big. */\n\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t}\n\t\t\tif (label >= eom) {\n\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t}\n\t\t\t*label = c;\n\t\t\t/* Fully qualified ? */\n\t\t\tif (*src == '\\0') {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\tif (bp >= eom) {\n\t\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\t\t}\n\t\t\t\t\t*bp++ = '\\0';\n\t\t\t\t}\n\t\t\t\tif ((bp - dst) > MAXCDNAME) {\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\t}\n\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (c == 0 || *src == '.') {\n\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t}\n\t\t\tlabel = bp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bp >= eom) {\n\t\t\tgoto ret_EMSGSIZE;\n\t\t}\n\t\t*bp++ = (u_char)c;\n\t}\n\tc = (bp - label - 1);\n\tif ((c & NS_CMPRSFLGS) != 0) {\t  /*%< Label too big. */\n\t\tgoto ret_EMSGSIZE;\n\t}\n done:\n\tif (label >= eom) {\n\t\tgoto ret_EMSGSIZE;\n\t}\n\t*label = c;\n\tif (c != 0) {\n\t\tif (bp >= eom) {\n\t\t\tgoto ret_EMSGSIZE;\n\t\t}\n\t\t*bp++ = 0;\n\t}\n\tif ((bp - dst) > MAXCDNAME) {   /*%< src too big */\n\t\tgoto ret_EMSGSIZE;\n\t}\n\n\treturn 0;\n\n ret_EMSGSIZE:\n\terrno = EMSGSIZE;\n\treturn -1;\n}\nlibc_hidden_def(ns_name_pton)\n\n/*\n * ns_name_unpack(msg, eom, src, dst, dstsiz)\n *      Unpack a domain name from a message, source may be compressed.\n * return:\n *      -1 if it fails, or consumed octets if it succeeds.\n */\nint ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,\n               u_char *dst, size_t dstsiz)\n{\n\tconst u_char *srcp, *dstlim;\n\tu_char *dstp;\n\tint n, len, checked;\n\n\tlen = -1;\n\tchecked = 0;\n\tdstp = dst;\n\tsrcp = src;\n\tdstlim = dst + dstsiz;\n\tif (srcp < msg || srcp >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t/* Fetch next label in domain name. */\n\twhile ((n = *srcp++) != 0) {\n\t\t/* Check for indirection. */\n\t\tswitch (n & NS_CMPRSFLGS) {\n\t\t\tcase 0:\n\t\t\t\t/* Limit checks. */\n\t\t\t\tif (dstp + n + 1 >= dstlim || srcp + n >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += n + 1;\n\t\t\t\t*dstp++ = n;\n\t\t\t\tmemcpy(dstp, srcp, n);\n\t\t\t\tdstp += n;\n\t\t\t\tsrcp += n;\n\t\t\t\tbreak;\n\n\t\t\tcase NS_CMPRSFLGS:\n\t\t\t\tif (srcp >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = srcp - src + 1;\n\t\t\t\tsrcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));\n\t\t\t\tif (srcp < msg || srcp >= eom) {  /* Out of range. */\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += 2;\n\t\t\t\t/*\n\t\t\t\t * Check for loops in the compressed name;\n\t\t\t\t * if we've looked at the whole message,\n\t\t\t\t * there must be a loop.\n\t\t\t\t */\n\t\t\t\tif (checked >= eom - msg) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;                    /* flag error */\n\t\t}\n\t}\n\t*dstp = '\\0';\n\tif (len < 0)\n\t\tlen = srcp - src;\n\treturn len;\n}\nlibc_hidden_def(ns_name_unpack)\n\nstatic int labellen(const unsigned char *lp)\n{\n\tunsigned bitlen;\n\tunsigned char l = *lp;\n\n\tif ((l & NS_CMPRSFLGS) == NS_CMPRSFLGS) {\n\t\t/* should be avoided by the caller */\n\t\treturn -1;\n\t}\n\n\tif ((l & NS_CMPRSFLGS) == NS_TYPE_ELT) {\n\t\tif (l == DNS_LABELTYPE_BITSTRING) {\n\t\t\tbitlen = lp[1];\n\t\t\tif (bitlen == 0)\n\t\t\t\tbitlen = 256;\n\t\t\treturn ((bitlen + 7 ) / 8 + 1);\n\t\t}\n\n\t\treturn -1;    /*%< unknwon ELT */\n\t}\n\n\treturn l;\n}\n\nstatic int mklower(int ch)\n{\n\tif (ch >= 0x41 && ch <= 0x5A)\n\t\treturn (ch + 0x20);\n\n\treturn ch;\n}\n\nstatic int dn_find(const unsigned char *domain,\n\t\t\t\t   const unsigned char *msg,\n\t\t\t\t   const unsigned char * const *dnptrs,\n\t\t\t\t   const unsigned char * const *lastdnptr)\n{\n\tconst unsigned char *dn, *cp, *sp;\n\tconst unsigned char * const *cpp;\n\tu_int n;\n\n\tfor (cpp = dnptrs; cpp < lastdnptr; cpp++) {\n\t\tsp = *cpp;\n\t\t/*\n\t\t * terminate search on:\n\t\t * root label\n\t\t * compression pointer\n\t\t * unusable offset\n\t\t */\n\t\twhile (*sp != 0 && (*sp & NS_CMPRSFLGS) == 0 &&\n\t\t\t\t(sp - msg) < 0x4000) {\n\t\t\tdn = domain;\n\t\t\tcp = sp;\n\n\t\t\twhile ((n = *cp++) != 0) {\n\t\t\t\t/*\n\t\t\t\t * check for indirection\n\t\t\t\t */\n\t\t\t\tswitch (n & NS_CMPRSFLGS) {\n\t\t\t\tcase 0:\t /*%< normal case, n == len */\n\t\t\t\t\tn = labellen(cp - 1); /*%< XXX */\n\t\t\t\t\tif (n != *dn++)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\tfor (; n > 0; n--)\n\t\t\t\t\t\tif (mklower(*dn++) !=\n\t\t\t\t\t\t    mklower(*cp++))\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t/* Is next root for both ? */\n\t\t\t\t\tif (*dn == '\\0' && *cp == '\\0')\n\t\t\t\t\t\treturn (sp - msg);\n\t\t\t\t\tif (*dn)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tgoto next;\n\t\t\t\tcase NS_CMPRSFLGS:      /*%< indirection */\n\t\t\t\t\tcp = msg + (((n & 0x3f) << 8) | *cp);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t/*%< illegal type */\n\t\t\t\t\terrno = EMSGSIZE;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tsp += *sp + 1;\n\t\t}\n\t}\n\n\terrno = ENOENT;\n\treturn -1;\n}\n\nint ns_name_pack(const unsigned char *src,\n\t\t\t\t unsigned char *dst, int dstsiz,\n\t\t\t\t const unsigned char **dnptrs,\n\t\t\t\t const unsigned char **lastdnptr)\n{\n\tunsigned char *dstp;\n\tconst unsigned char **cpp, **lpp, *eob, *msg;\n\tconst unsigned char *srcp;\n\tint n, l, first = 1;\n\n\tsrcp = src;\n\tdstp = dst;\n\teob = dstp + dstsiz;\n\tlpp = cpp = NULL;\n\n\tif (dnptrs != NULL) {\n\t\tmsg = *dnptrs++;\n\t\tif (msg != NULL) {\n\t\t\tfor (cpp = dnptrs; *cpp != NULL; cpp++)\n\t\t\t\tcontinue;\n\n\t\t\tlpp = cpp;      /*%< end of list to search */\n\t\t}\n\t} else {\n\t\tmsg = NULL;\n\t}\n\n\t/* make sure the domain we are about to add is legal */\n\tl = 0;\n\tdo {\n\t\tint l0;\n\n\t\tn = *srcp;\n\t\tif ((n & NS_CMPRSFLGS) == NS_CMPRSFLGS) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tl0 = labellen(srcp);\n\t\tif (l0 < 0) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tl += l0 + 1;\n\t\tif (l > MAXCDNAME) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tsrcp += l0 + 1;\n\t} while (n != 0);\n\n\t/* from here on we need to reset compression pointer array on error */\n\tsrcp = src;\n\n\tdo {\n\t\t/* Look to see if we can use pointers. */\n\t\tn = *srcp;\n\n\t\tif (n != 0 && msg != NULL) {\n\t\t\tl = dn_find(srcp, msg, (const unsigned char * const *) dnptrs,\n\t\t\t\t\t\t(const unsigned char * const *) lpp);\n\t\t\tif (l >= 0) {\n\t\t\t\tif (dstp + 1 >= eob) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\t*dstp++ = ((u_int32_t)l >> 8) | NS_CMPRSFLGS;\n\t\t\t\t*dstp++ = l % 256;\n\t\t\t\treturn (dstp - dst);\n\t\t\t}\n\n\t\t\t/* Not found, save it. */\n\t\t\tif (lastdnptr != NULL && cpp < lastdnptr - 1 &&\n\t\t\t\t(dstp - msg) < 0x4000 && first) {\n\t\t\t\t*cpp++ = dstp;\n\t\t\t\t*cpp = NULL;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* copy label to buffer */\n\t\tif ((n & NS_CMPRSFLGS) == NS_CMPRSFLGS) {\n\t\t\t/* Should not happen. */\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tn = labellen(srcp);\n\t\tif (dstp + 1 + n >= eob) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tmemcpy(dstp, srcp, (size_t)(n + 1));\n\t\tsrcp += n + 1;\n\t\tdstp += n + 1;\n\t} while (n != 0);\n\n\tif (dstp > eob) {\ncleanup:\n\t\tif (msg != NULL)\n\t\t\t*lpp = NULL;\n\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t}\n\n\treturn dstp - dst;\n}\nlibc_hidden_def(ns_name_pack)\n\nint ns_name_compress(const char *src,\n\t\t\t\t\t unsigned char *dst, size_t dstsiz,\n\t\t\t\t\t const unsigned char **dnptrs,\n\t\t\t\t\t const unsigned char **lastdnptr)\n{\n\tunsigned char tmp[NS_MAXCDNAME];\n\n\tif (ns_name_pton(src, tmp, sizeof(tmp)) == -1)\n\t\treturn -1;\n\n\treturn ns_name_pack(tmp, dst, dstsiz, dnptrs, lastdnptr);\n}\nlibc_hidden_def(ns_name_compress)\n\nint ns_name_skip(const unsigned char **ptrptr,\n\t\t\t\t const unsigned char *eom)\n{\n\tconst unsigned char *cp;\n\tu_int n;\n\tint l;\n\n\tcp = *ptrptr;\n\twhile (cp < eom && (n = *cp++) != 0) {\n\t\t/* Check for indirection. */\n\t\tswitch (n & NS_CMPRSFLGS) {\n\t\tcase 0:\t\t /*%< normal case, n == len */\n\t\t\tcp += n;\n\t\t\tcontinue;\n\t\tcase NS_TYPE_ELT: /*%< EDNS0 extended label */\n\t\t\tl = labellen(cp - 1);\n\t\t\tif (l < 0) {\n\t\t\t\terrno = EMSGSIZE; /*%< XXX */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcp += l;\n\t\t\tcontinue;\n\t\tcase NS_CMPRSFLGS:      /*%< indirection */\n\t\t\tcp++;\n\t\t\tbreak;\n\t\tdefault:\t\t/*%< illegal type */\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (cp > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\t*ptrptr = cp;\n\n\treturn 0;\n}\nlibc_hidden_def(ns_name_skip)\n\nint dn_skipname(const unsigned char *ptr, const unsigned char *eom)\n{\n\tconst unsigned char *saveptr = ptr;\n\n\tif (ns_name_skip(&ptr, eom) == -1)\n\t\treturn -1;\n\n\treturn ptr - saveptr;\n}\nlibc_hidden_def(dn_skipname)\n#endif /* L_ns_name */\n\n\n#ifdef L_res_init\n\n/* Will be called under __resolv_lock. */\nstatic void res_sync_func(void)\n{\n\tstruct __res_state *rp = &(_res);\n\tint n;\n\n\t/* If we didn't get malloc failure earlier... */\n\tif (__nameserver != (void*) &__local_nameserver) {\n\t\t/* TODO:\n\t\t * if (__nameservers < rp->nscount) - try to grow __nameserver[]?\n\t\t */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tif (__nameservers > rp->_u._ext.nscount)\n\t\t\t__nameservers = rp->_u._ext.nscount;\n\t\tn = __nameservers;\n\t\twhile (--n >= 0)\n\t\t\t__nameserver[n].sa6 = *rp->_u._ext.nsaddrs[n]; /* struct copy */\n#else /* IPv4 only */\n\t\tif (__nameservers > rp->nscount)\n\t\t\t__nameservers = rp->nscount;\n\t\tn = __nameservers;\n\t\twhile (--n >= 0)\n\t\t\t__nameserver[n].sa4 = rp->nsaddr_list[n]; /* struct copy */\n#endif\n\t}\n\t__resolv_timeout = rp->retrans ? : RES_TIMEOUT;\n\t__resolv_attempts = rp->retry ? : RES_DFLRETRY;\n\t/* Extend and comment what program is known\n\t * to use which _res.XXX member(s).\n\n\t   __resolv_opts = rp->options;\n\t   ...\n\t */\n}\n\n/* has to be called under __resolv_lock */\nstatic int\n__res_vinit(res_state rp, int preinit)\n{\n\tint i, n, options, retrans, retry, ndots;\n#ifdef __UCLIBC_HAS_IPV6__\n\tint m = 0;\n#endif\n\n\t__close_nameservers();\n\t__open_nameservers();\n\n\tif (preinit) {\n\t\toptions = rp->options;\n\t\tretrans = rp->retrans;\n\t\tretry = rp->retry;\n\t\tndots = rp->ndots;\n\t}\n\n\tmemset(rp, 0, sizeof(*rp));\n\n\tif (!preinit) {\n\t\trp->options = RES_DEFAULT;\n\t\trp->retrans = RES_TIMEOUT;\n\t\trp->retry = RES_DFLRETRY;\n\t\trp->ndots = 1;\n\t} else {\n\t\trp->options = options;\n\t\trp->retrans = retrans;\n\t\trp->retry = retry;\n\t\trp->ndots = ndots;\n\t}\n\n#ifdef __UCLIBC_HAS_COMPAT_RES_STATE__\n\t/* Was: \"rp->id = random();\" but:\n\t * - random() pulls in largish static buffers\n\t * - isn't actually random unless, say, srandom(time(NULL)) was called\n\t * - is not used by uclibc anyway :)\n\t */\n\t/* rp->id = 0; - memset did it */\n#endif\n#ifdef __UCLIBC_HAS_EXTRA_COMPAT_RES_STATE__\n\trp->_vcsock = -1;\n#endif\n\n\tn = __searchdomains;\n\tif (n > ARRAY_SIZE(rp->dnsrch))\n\t\tn = ARRAY_SIZE(rp->dnsrch);\n\tfor (i = 0; i < n; i++)\n\t\trp->dnsrch[i] = __searchdomain[i];\n\n\t/* copy nameservers' addresses */\n\ti = 0;\n#ifdef __UCLIBC_HAS_IPV4__\n\tn = 0;\n\twhile (n < ARRAY_SIZE(rp->nsaddr_list) && i < __nameservers) {\n\t\tif (__nameserver[i].sa.sa_family == AF_INET) {\n\t\t\trp->nsaddr_list[n] = __nameserver[i].sa4; /* struct copy */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\tif (m < ARRAY_SIZE(rp->_u._ext.nsaddrs)) {\n\t\t\t\trp->_u._ext.nsaddrs[m] = (void*) &rp->nsaddr_list[n];\n\t\t\t\tm++;\n\t\t\t}\n#endif\n\t\t\tn++;\n\t\t}\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tif (__nameserver[i].sa.sa_family == AF_INET6\n\t\t && m < ARRAY_SIZE(rp->_u._ext.nsaddrs)\n\t\t) {\n\t\t\tstruct sockaddr_in6 *sa6 = malloc(sizeof(*sa6));\n\t\t\tif (sa6) {\n\t\t\t\t*sa6 = __nameserver[i].sa6; /* struct copy */\n\t\t\t\trp->_u._ext.nsaddrs[m] = sa6;\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n#endif\n\t\ti++;\n\t}\n\trp->nscount = n;\n#ifdef __UCLIBC_HAS_IPV6__\n\trp->_u._ext.nscount = m;\n#endif\n\n#else /* IPv6 only */\n\twhile (m < ARRAY_SIZE(rp->_u._ext.nsaddrs) && i < __nameservers) {\n\t\tstruct sockaddr_in6 *sa6 = malloc(sizeof(*sa6));\n\t\tif (sa6) {\n\t\t\t*sa6 = __nameserver[i].sa6; /* struct copy */\n\t\t\trp->_u._ext.nsaddrs[m] = sa6;\n\t\t\tm++;\n\t\t}\n\t\ti++;\n\t}\n\trp->_u._ext.nscount = m;\n#endif\n\n\trp->options |= RES_INIT;\n\n\treturn 0;\n}\n\nstatic unsigned int\nres_randomid(void)\n{\n\treturn 0xffff & getpid();\n}\n\n/* Our res_init never fails (always returns 0) */\nint\nres_init(void)\n{\n\t/*\n\t * These three fields used to be statically initialized.  This made\n\t * it hard to use this code in a shared library.  It is necessary,\n\t * now that we're doing dynamic initialization here, that we preserve\n\t * the old semantics: if an application modifies one of these three\n\t * fields of _res before res_init() is called, res_init() will not\n\t * alter them.  Of course, if an application is setting them to\n\t * _zero_ before calling res_init(), hoping to override what used\n\t * to be the static default, we can't detect it and unexpected results\n\t * will follow.  Zero for any of these fields would make no sense,\n\t * so one can safely assume that the applications were already getting\n\t * unexpected results.\n\t *\n\t * _res.options is tricky since some apps were known to diddle the bits\n\t * before res_init() was first called. We can't replicate that semantic\n\t * with dynamic initialization (they may have turned bits off that are\n\t * set in RES_DEFAULT).  Our solution is to declare such applications\n\t * \"broken\".  They could fool us by setting RES_INIT but none do (yet).\n\t */\n\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\n\tif (!_res.retrans)\n\t\t_res.retrans = RES_TIMEOUT;\n\tif (!_res.retry)\n\t\t_res.retry = 4;\n\tif (!(_res.options & RES_INIT))\n\t\t_res.options = RES_DEFAULT;\n\n\t/*\n\t * This one used to initialize implicitly to zero, so unless the app\n\t * has set it to something in particular, we can randomize it now.\n\t */\n\tif (!_res.id)\n\t\t_res.id = res_randomid();\n\n\t__res_sync = NULL;\n\t__res_vinit(&_res, 1);\n\t__res_sync = res_sync_func;\n\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\n\treturn 0;\n}\nlibc_hidden_def(res_init)\n\nstatic void\n__res_iclose(res_state statp)\n{\n\tstruct __res_state * rp = statp;\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\tif (rp == NULL)\n\t\trp = __res_state();\n\t__close_nameservers();\n\t__res_sync = NULL;\n#ifdef __UCLIBC_HAS_IPV6__\n\t{\n\t\tchar *p1 = (char*) &(rp->nsaddr_list[0]);\n\t\tunsigned int m = 0;\n\t\t/* free nsaddrs[m] if they do not point to nsaddr_list[x] */\n\t\twhile (m < ARRAY_SIZE(rp->_u._ext.nsaddrs)) {\n\t\t\tchar *p2 = (char*)(rp->_u._ext.nsaddrs[m++]);\n\t\t\tif (p2 < p1 || (p2 - p1) > (signed)sizeof(rp->nsaddr_list))\n\t\t\t\tfree(p2);\n\t\t}\n\t}\n#endif\n\tmemset(rp, 0, sizeof(struct __res_state));\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n}\n\n/*\n * This routine is for closing the socket if a virtual circuit is used and\n * the program wants to close it.  This provides support for endhostent()\n * which expects to close the socket.\n *\n * This routine is not expected to be user visible.\n */\n\nvoid\nres_nclose(res_state statp)\n{\n\t__res_iclose(statp);\n}\n\n#ifdef __UCLIBC_HAS_BSD_RES_CLOSE__\nvoid res_close(void)\n{\n\t__res_iclose(NULL);\n}\n#endif\n\n#ifdef __UCLIBC_HAS_BSD_B64_NTOP_B64_PTON__\n#define Assert(Cond) if (!(Cond)) abort()\n\nstatic const char Base64[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nstatic const char Pad64 = '=';\n\n/* (From RFC1521 and draft-ietf-dnssec-secext-03.txt)\n   The following encoding technique is taken from RFC 1521 by Borenstein\n   and Freed.  It is reproduced here in a slightly edited form for\n   convenience.\n\n   A 65-character subset of US-ASCII is used, enabling 6 bits to be\n   represented per printable character. (The extra 65th character, \"=\",\n   is used to signify a special processing function.)\n\n   The encoding process represents 24-bit groups of input bits as output\n   strings of 4 encoded characters. Proceeding from left to right, a\n   24-bit input group is formed by concatenating 3 8-bit input groups.\n   These 24 bits are then treated as 4 concatenated 6-bit groups, each\n   of which is translated into a single digit in the base64 alphabet.\n\n   Each 6-bit group is used as an index into an array of 64 printable\n   characters. The character referenced by the index is placed in the\n   output string.\n\n                         Table 1: The Base64 Alphabet\n\n      Value Encoding  Value Encoding  Value Encoding  Value Encoding\n          0 A            17 R            34 i            51 z\n          1 B            18 S            35 j            52 0\n          2 C            19 T            36 k            53 1\n          3 D            20 U            37 l            54 2\n          4 E            21 V            38 m            55 3\n          5 F            22 W            39 n            56 4\n          6 G            23 X            40 o            57 5\n          7 H            24 Y            41 p            58 6\n          8 I            25 Z            42 q            59 7\n          9 J            26 a            43 r            60 8\n         10 K            27 b            44 s            61 9\n         11 L            28 c            45 t            62 +\n         12 M            29 d            46 u            63 /\n         13 N            30 e            47 v\n         14 O            31 f            48 w         (pad) =\n         15 P            32 g            49 x\n         16 Q            33 h            50 y\n\n   Special processing is performed if fewer than 24 bits are available\n   at the end of the data being encoded.  A full encoding quantum is\n   always completed at the end of a quantity.  When fewer than 24 input\n   bits are available in an input group, zero bits are added (on the\n   right) to form an integral number of 6-bit groups.  Padding at the\n   end of the data is performed using the '=' character.\n\n   Since all base64 input is an integral number of octets, only the\n         -------------------------------------------------\n   following cases can arise:\n\n       (1) the final quantum of encoding input is an integral\n           multiple of 24 bits; here, the final unit of encoded\n\t   output will be an integral multiple of 4 characters\n\t   with no \"=\" padding,\n       (2) the final quantum of encoding input is exactly 8 bits;\n           here, the final unit of encoded output will be two\n\t   characters followed by two \"=\" padding characters, or\n       (3) the final quantum of encoding input is exactly 16 bits;\n           here, the final unit of encoded output will be three\n\t   characters followed by one \"=\" padding character.\n   */\n\nint\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize) {\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tsize_t i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\t\tAssert(output[0] < 64);\n\t\tAssert(output[1] < 64);\n\t\tAssert(output[2] < 64);\n\t\tAssert(output[3] < 64);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n\n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\tAssert(output[0] < 64);\n\t\tAssert(output[1] < 64);\n\t\tAssert(output[2] < 64);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}\n/* libc_hidden_def (b64_ntop) */\n\n/* skips all whitespace anywhere.\n   converts characters, four at a time, starting at (or after)\n   src from base - 64 numbers into three 8 bit bytes in the target area.\n   it returns the number of data bytes stored at the target, or -1 on error.\n */\n\nint\nb64_pton (char const *src, u_char *target, size_t targsize)\n{\n\tint tarindex, state, ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor ((void)NULL; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor ((void)NULL; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}\n#endif\n\n/* This needs to be after the use of _res in res_init, above.  */\n#undef _res\n\n#ifndef __UCLIBC_HAS_THREADS__\n/* The resolver state for use by single-threaded programs.\n   This differs from plain `struct __res_state _res;' in that it doesn't\n   create a common definition, but a plain symbol that resides in .bss,\n   which can have an alias.  */\nstruct __res_state _res __attribute__((section (\".bss\")));\nstruct __res_state *__resp = &_res;\n#else /* __UCLIBC_HAS_THREADS__ */\nstruct __res_state _res __attribute__((section (\".bss\"))) attribute_hidden;\n\n# if defined __UCLIBC_HAS_TLS__\n#  undef __resp\n__thread struct __res_state *__resp = &_res;\nextern __thread struct __res_state *__libc_resp\n       __attribute__ ((alias (\"__resp\"))) attribute_hidden attribute_tls_model_ie;\n# else\n#  undef __resp\nstruct __res_state *__resp = &_res;\n# endif\n#endif /* !__UCLIBC_HAS_THREADS__ */\n\n/*\n * Set up default settings.  If the configuration file exist, the values\n * there will have precedence.  Otherwise, the server address is set to\n * INADDR_ANY and the default domain name comes from the gethostname().\n *\n * An interrim version of this code (BIND 4.9, pre-4.4BSD) used 127.0.0.1\n * rather than INADDR_ANY (\"0.0.0.0\") as the default name server address\n * since it was noted that INADDR_ANY actually meant ``the first interface\n * you \"ifconfig\"'d at boot time'' and if this was a SLIP or PPP interface,\n * it had to be \"up\" in order for you to reach your own name server.  It\n * was later decided that since the recommended practice is to always\n * install local static routes through 127.0.0.1 for all your network\n * interfaces, that we could solve this problem without a code change.\n *\n * The configuration file should always be used, since it is the only way\n * to specify a default domain.  If you are running a server on your local\n * machine, you should say \"nameserver 0.0.0.0\" or \"nameserver 127.0.0.1\"\n * in the configuration file.\n *\n * Return 0 if completes successfully, -1 on error\n */\nint\nres_ninit(res_state statp)\n{\n\tint ret;\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\tret = __res_vinit(statp, 0);\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\treturn ret;\n}\n\n#endif /* L_res_init */\n\n#ifdef L_res_state\n# if defined __UCLIBC_HAS_TLS__\nstruct __res_state *\n__res_state (void)\n{\n       return __resp;\n}\n# else\n#  undef _res\nextern struct __res_state _res;\n\n/* When threaded, _res may be a per-thread variable.  */\nstruct __res_state *\nweak_const_function\n__res_state (void)\n{\n       return &_res;\n}\n# endif\n\n#endif /* L_res_state */\n\n\n#ifdef L_res_query\n\nint res_query(const char *dname, int class, int type,\n              unsigned char *answer, int anslen)\n{\n\tint i;\n\tunsigned char *packet = NULL;\n\tstruct resolv_answer a;\n\n\tif (!dname || class != 1 /* CLASS_IN */) {\n\t\th_errno = NO_RECOVERY;\n\t\treturn -1;\n\t}\n\n\tmemset(&a, '\\0', sizeof(a));\n\ti = __dns_lookup(dname, type, &packet, &a);\n\n\tif (i < 0) {\n\t\tif (!h_errno) /* TODO: can this ever happen? */\n\t\t\th_errno = TRY_AGAIN;\n\t\treturn -1;\n\t}\n\n\tfree(a.dotted);\n\n\tif (i > anslen)\n\t\ti = anslen;\n\tmemcpy(answer, packet, i);\n\n\tfree(packet);\n\treturn i;\n}\nlibc_hidden_def(res_query)\n\n/*\n * Formulate a normal query, send, and retrieve answer in supplied buffer.\n * Return the size of the response on success, -1 on error.\n * If enabled, implement search rules until answer or unrecoverable failure\n * is detected.  Error code, if any, is left in h_errno.\n */\n#define __TRAILING_DOT\t(1<<0)\n#define __GOT_NODATA\t(1<<1)\n#define __GOT_SERVFAIL\t(1<<2)\n#define __TRIED_AS_IS\t(1<<3)\nint res_search(const char *name, int class, int type, u_char *answer,\n\t\tint anslen)\n{\n\tconst char *cp;\n\tchar **domain;\n\tHEADER *hp = (HEADER *)(void *)answer;\n\tunsigned dots;\n\tunsigned state;\n\tint ret, saved_herrno;\n\tuint32_t _res_options;\n\tunsigned _res_ndots;\n\tchar **_res_dnsrch;\n\n\tif (!name || !answer) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn -1;\n\t}\n\n again:\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t_res_options = _res.options;\n\t_res_ndots = _res.ndots;\n\t_res_dnsrch = _res.dnsrch;\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\tif (!(_res_options & RES_INIT)) {\n\t\tres_init(); /* our res_init never fails */\n\t\tgoto again;\n\t}\n\n\tstate = 0;\n\terrno = 0;\n\th_errno = HOST_NOT_FOUND;\t/* default, if we never query */\n\tdots = 0;\n\tfor (cp = name; *cp; cp++)\n\t\tdots += (*cp == '.');\n\n\tif (cp > name && *--cp == '.')\n\t\tstate |= __TRAILING_DOT;\n\n\t/*\n\t * If there are dots in the name already, let's just give it a try\n\t * 'as is'.  The threshold can be set with the \"ndots\" option.\n\t */\n\tsaved_herrno = -1;\n\tif (dots >= _res_ndots) {\n\t\tret = res_querydomain(name, NULL, class, type, answer, anslen);\n\t\tif (ret > 0)\n\t\t\treturn ret;\n\t\tsaved_herrno = h_errno;\n\t\tstate |= __TRIED_AS_IS;\n\t}\n\n\t/*\n\t * We do at least one level of search if\n\t *\t- there is no dot and RES_DEFNAME is set, or\n\t *\t- there is at least one dot, there is no trailing dot,\n\t *\t  and RES_DNSRCH is set.\n\t */\n\tif ((!dots && (_res_options & RES_DEFNAMES))\n\t || (dots && !(state & __TRAILING_DOT) && (_res_options & RES_DNSRCH))\n\t) {\n\t\tbool done = 0;\n\n\t\tfor (domain = _res_dnsrch; *domain && !done; domain++) {\n\n\t\t\tret = res_querydomain(name, *domain, class, type,\n\t\t\t\t\t\t\t\t  answer, anslen);\n\t\t\tif (ret > 0)\n\t\t\t\treturn ret;\n\n\t\t\t/*\n\t\t\t * If no server present, give up.\n\t\t\t * If name isn't found in this domain,\n\t\t\t * keep trying higher domains in the search list\n\t\t\t * (if that's enabled).\n\t\t\t * On a NO_DATA error, keep trying, otherwise\n\t\t\t * a wildcard entry of another type could keep us\n\t\t\t * from finding this entry higher in the domain.\n\t\t\t * If we get some other error (negative answer or\n\t\t\t * server failure), then stop searching up,\n\t\t\t * but try the input name below in case it's\n\t\t\t * fully-qualified.\n\t\t\t */\n\t\t\tif (errno == ECONNREFUSED) {\n\t\t\t\th_errno = TRY_AGAIN;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tswitch (h_errno) {\n\t\t\t\tcase NO_DATA:\n\t\t\t\t\tstate |= __GOT_NODATA;\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\t\t/* keep trying */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TRY_AGAIN:\n\t\t\t\t\tif (hp->rcode == SERVFAIL) {\n\t\t\t\t\t\t/* try next search element, if any */\n\t\t\t\t\t\tstate |= __GOT_SERVFAIL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tdefault:\n\t\t\t\t\t/* anything else implies that we're done */\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we got here for some reason other than DNSRCH,\n\t\t\t * we only wanted one iteration of the loop, so stop.\n\t\t\t */\n\t\t\tif (!(_res_options & RES_DNSRCH))\n\t\t\t\tdone = 1;\n\t\t}\n\t}\n\n\t/*\n\t * if we have not already tried the name \"as is\", do that now.\n\t * note that we do this regardless of how many dots were in the\n\t * name or whether it ends with a dot.\n\t */\n\tif (!(state & __TRIED_AS_IS)) {\n\t\tret = res_querydomain(name, NULL, class, type, answer, anslen);\n\t\tif (ret > 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * if we got here, we didn't satisfy the search.\n\t * if we did an initial full query, return that query's h_errno\n\t * (note that we wouldn't be here if that query had succeeded).\n\t * else if we ever got a nodata, send that back as the reason.\n\t * else send back meaningless h_errno, that being the one from\n\t * the last DNSRCH we did.\n\t */\n\tif (saved_herrno != -1)\n\t\th_errno = saved_herrno;\n\telse if (state & __GOT_NODATA)\n\t\th_errno = NO_DATA;\n\telse if (state & __GOT_SERVFAIL)\n\t\th_errno = TRY_AGAIN;\n\treturn -1;\n}\n#undef __TRAILING_DOT\n#undef __GOT_NODATA\n#undef __GOT_SERVFAIL\n#undef __TRIED_AS_IS\n/*\n * Perform a call on res_query on the concatenation of name and domain,\n * removing a trailing dot from name if domain is NULL.\n */\nint res_querydomain(const char *name, const char *domain, int class, int type,\n\t\t\tu_char *answer, int anslen)\n{\n\tchar nbuf[MAXDNAME];\n\tconst char *longname = nbuf;\n\tsize_t n, d;\n#ifdef DEBUG\n\tuint32_t _res_options;\n#endif\n\n\tif (!name || !answer) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n again:\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t_res_options = _res.options;\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\tif (!(_res_options & RES_INIT)) {\n\t\tres_init(); /* our res_init never fails */\n\t\tgoto again;\n\t}\n\tif (_res_options & RES_DEBUG)\n\t\tprintf(\";; res_querydomain(%s, %s, %d, %d)\\n\",\n\t\t\t   name, (domain ? domain : \"<Nil>\"), class, type);\n#endif\n\tif (domain == NULL) {\n\t\t/*\n\t\t * Check for trailing '.';\n\t\t * copy without '.' if present.\n\t\t */\n\t\tn = strlen(name);\n\t\tif (n + 1 > sizeof(nbuf)) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tif (n > 0 && name[--n] == '.') {\n\t\t\tstrncpy(nbuf, name, n);\n\t\t\tnbuf[n] = '\\0';\n\t\t} else\n\t\t\tlongname = name;\n\t} else {\n\t\tn = strlen(name);\n\t\td = strlen(domain);\n\t\tif (n + 1 + d + 1 > sizeof(nbuf)) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tsnprintf(nbuf, sizeof(nbuf), \"%s.%s\", name, domain);\n\t}\n\treturn res_query(longname, class, type, answer, anslen);\n}\nlibc_hidden_def(res_querydomain)\n#endif /* L_res_query */\n\n#ifdef L_ns_netint\nunsigned int ns_get16(const unsigned char *src)\n{\n\tunsigned int dst;\n\tNS_GET16(dst, src);\n\treturn dst;\n}\n\nunsigned long ns_get32(const unsigned char *src)\n{\n\tunsigned long dst;\n\tNS_GET32(dst, src);\n\treturn dst;\n}\n\nvoid ns_put16(unsigned int src, unsigned char *dst)\n{\n\tNS_PUT16(src, dst);\n}\n\nvoid ns_put32(unsigned long src, unsigned char *dst)\n{\n\tNS_PUT32(src, dst);\n}\n#endif /* L_ns_netint */\n\n#ifdef L_ns_parse\n/* These need to be in the same order as the nres.h:ns_flag enum. */\nstruct _ns_flagdata { unsigned short mask, shift; };\nstatic const struct _ns_flagdata _ns_flagdata[16] = {\n\t{ 0x8000, 15 },         /*%< qr. */\n\t{ 0x7800, 11 },         /*%< opcode. */\n\t{ 0x0400, 10 },         /*%< aa. */\n\t{ 0x0200, 9 },          /*%< tc. */\n\t{ 0x0100, 8 },          /*%< rd. */\n\t{ 0x0080, 7 },          /*%< ra. */\n\t{ 0x0040, 6 },          /*%< z. */\n\t{ 0x0020, 5 },          /*%< ad. */\n\t{ 0x0010, 4 },          /*%< cd. */\n\t{ 0x000f, 0 },          /*%< rcode. */\n\t{ 0x0000, 0 },          /*%< expansion (1/6). */\n\t{ 0x0000, 0 },          /*%< expansion (2/6). */\n\t{ 0x0000, 0 },          /*%< expansion (3/6). */\n\t{ 0x0000, 0 },          /*%< expansion (4/6). */\n\t{ 0x0000, 0 },          /*%< expansion (5/6). */\n\t{ 0x0000, 0 },          /*%< expansion (6/6). */\n};\n\nstatic void setsection(ns_msg *msg, ns_sect sect)\n{\n\tmsg->_sect = sect;\n\tif (sect == ns_s_max) {\n\t\tmsg->_rrnum = -1;\n\t\tmsg->_ptr = NULL;\n\t} else {\n\t\tmsg->_rrnum = 0;\n\t\tmsg->_ptr = msg->_sections[(int)sect];\n\t}\n}\n\nint ns_skiprr(const unsigned char *ptr,\n\t\t\t  const unsigned char *eom,\n\t\t\t  ns_sect section, int count)\n{\n\tconst u_char *optr = ptr;\n\n\tfor (; count > 0; count--) {\n\t\tint b, rdlength;\n\n\t\tb = dn_skipname(ptr, eom);\n\t\tif (b < 0) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tptr += b/*Name*/ + NS_INT16SZ/*Type*/ + NS_INT16SZ/*Class*/;\n\t\tif (section != ns_s_qd) {\n\t\t\tif (ptr + NS_INT32SZ + NS_INT16SZ > eom) {\n\t\t\t\terrno = EMSGSIZE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tptr += NS_INT32SZ/*TTL*/;\n\t\t\tNS_GET16(rdlength, ptr);\n\t\t\tptr += rdlength/*RData*/;\n\t\t}\n\t}\n\n\tif (ptr > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\treturn ptr - optr;\n}\nlibc_hidden_def(ns_skiprr)\n\nint\nns_initparse(const unsigned char *msg, int msglen, ns_msg *handle)\n{\n\tconst u_char *eom = msg + msglen;\n\tint i;\n\n\thandle->_msg = msg;\n\thandle->_eom = eom;\n\tif (msg + NS_INT16SZ > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\tNS_GET16(handle->_id, msg);\n\tif (msg + NS_INT16SZ > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\tNS_GET16(handle->_flags, msg);\n\tfor (i = 0; i < ns_s_max; i++) {\n\t\tif (msg + NS_INT16SZ > eom) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tNS_GET16(handle->_counts[i], msg);\n\t}\n\tfor (i = 0; i < ns_s_max; i++)\n\t\tif (handle->_counts[i] == 0)\n\t\t\thandle->_sections[i] = NULL;\n\t\telse {\n\t\t\tint b = ns_skiprr(msg, eom, (ns_sect)i,\n\t\t\t\t\t  handle->_counts[i]);\n\n\t\t\tif (b < 0)\n\t\t\t\treturn -1;\n\t\t\thandle->_sections[i] = msg;\n\t\t\tmsg += b;\n\t\t}\n\n\tif (msg != eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\tsetsection(handle, ns_s_max);\n\treturn 0;\n}\n\nint\nns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr)\n{\n\tint b;\n\tint tmp;\n\n\t/* Make section right. */\n\ttmp = section;\n\tif (tmp < 0 || section >= ns_s_max) {\n\t\terrno = ENODEV;\n\t\treturn -1;\n\t}\n\n\tif (section != handle->_sect)\n\t\tsetsection(handle, section);\n\n\t/* Make rrnum right. */\n\tif (rrnum == -1)\n\t\trrnum = handle->_rrnum;\n\tif (rrnum < 0 || rrnum >= handle->_counts[(int)section]) {\n\t\terrno = ENODEV;\n\t\treturn -1;\n\t}\n\tif (rrnum < handle->_rrnum)\n\t\tsetsection(handle, section);\n\tif (rrnum > handle->_rrnum) {\n\t\tb = ns_skiprr(handle->_ptr, handle->_eom, section,\n\t\t\t      rrnum - handle->_rrnum);\n\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\thandle->_ptr += b;\n\t\thandle->_rrnum = rrnum;\n\t}\n\n\t/* Do the parse. */\n\tb = dn_expand(handle->_msg, handle->_eom,\n\t\t      handle->_ptr, rr->name, NS_MAXDNAME);\n\tif (b < 0)\n\t\treturn -1;\n\thandle->_ptr += b;\n\tif (handle->_ptr + NS_INT16SZ + NS_INT16SZ > handle->_eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\tNS_GET16(rr->type, handle->_ptr);\n\tNS_GET16(rr->rr_class, handle->_ptr);\n\tif (section == ns_s_qd) {\n\t\trr->ttl = 0;\n\t\trr->rdlength = 0;\n\t\trr->rdata = NULL;\n\t} else {\n\t\tif (handle->_ptr + NS_INT32SZ + NS_INT16SZ > handle->_eom) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\t\tNS_GET32(rr->ttl, handle->_ptr);\n\t\tNS_GET16(rr->rdlength, handle->_ptr);\n\t\tif (handle->_ptr + rr->rdlength > handle->_eom) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\t\trr->rdata = handle->_ptr;\n\t\thandle->_ptr += rr->rdlength;\n\t}\n\tif (++handle->_rrnum > handle->_counts[(int)section])\n\t\tsetsection(handle, (ns_sect)((int)section + 1));\n\n\treturn 0;\n}\n\nint ns_msg_getflag(ns_msg handle, int flag)\n{\n\treturn ((handle)._flags & _ns_flagdata[flag].mask) >> _ns_flagdata[flag].shift;\n}\n#endif /* L_ns_parse */\n\n#ifdef L_res_data\nint res_mkquery(int op, const char *dname, int class, int type,\n\t\t\t\tconst unsigned char *data, int datalen,\n\t\t\t\tconst unsigned char *newrr_in,\n\t\t\t\tunsigned char *buf, int buflen)\n{\n\tHEADER *hp;\n\tunsigned char *cp, *ep;\n\tunsigned char *dnptrs[20], **dpp, **lastdnptr;\n\tuint32_t _res_options;\n\tint n;\n\n\tif (!buf || buflen < HFIXEDSZ) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn -1;\n\t}\n\n again:\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t_res_options = _res.options;\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\tif (!(_res_options & RES_INIT)) {\n\t\tres_init(); /* our res_init never fails */\n\t\tgoto again;\n\t}\n\n#ifdef DEBUG\n\tif (_res_options & RES_DEBUG)\n\t\tprintf(\";; res_mkquery(%d, %s, %d, %d)\\n\",\n\t\t\t   op, dname && *dname ? dname : \"<null>\", class, type);\n#endif\n\n\tmemset(buf, 0, HFIXEDSZ);\n\thp = (HEADER *) buf;\n\thp->id = getpid() & 0xffff;\n\thp->opcode = op;\n\thp->rd = (_res_options & RES_RECURSE) != 0U;\n\thp->rcode = NOERROR;\n\n\tcp = buf + HFIXEDSZ;\n\tep = buf + buflen;\n\tdpp = dnptrs;\n\t*dpp++ = buf;\n\t*dpp++ = NULL;\n\tlastdnptr = dnptrs + sizeof dnptrs / sizeof dnptrs[0];\n\n\t/*\n\t * perform opcode specific processing\n\t */\n\tswitch (op) {\n\tcase QUERY:\n\tcase NS_NOTIFY_OP:\n\t\tif (ep - cp < QFIXEDSZ)\n\t\t\treturn -1;\n\n\t\tn = dn_comp(dname, cp, ep - cp - QFIXEDSZ, dnptrs, lastdnptr);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\n\t\tcp += n;\n\t\tNS_PUT16(type, cp);\n\t\tNS_PUT16(class, cp);\n\t\thp->qdcount = htons(1);\n\n\t\tif (op == QUERY || data == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Make an additional record for completion domain.\n\t\t */\n\t\tif ((ep - cp) < RRFIXEDSZ)\n\t\t\treturn -1;\n\n\t\tn = dn_comp((const char *)data, cp, ep - cp - RRFIXEDSZ,\n\t\t\t\t\t dnptrs, lastdnptr);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\n\t\tcp += n;\n\t\tNS_PUT16(T_NULL, cp);\n\t\tNS_PUT16(class, cp);\n\t\tNS_PUT32(0, cp);\n\t\tNS_PUT16(0, cp);\n\t\thp->arcount = htons(1);\n\n\t\tbreak;\n\n\tcase IQUERY:\n\t\t/*\n\t\t * Initialize answer section\n\t\t */\n\t\tif (ep - cp < 1 + RRFIXEDSZ + datalen)\n\t\t\treturn -1;\n\n\t\t*cp++ = '\\0';   /*%< no domain name */\n\t\tNS_PUT16(type, cp);\n\t\tNS_PUT16(class, cp);\n\t\tNS_PUT32(0, cp);\n\t\tNS_PUT16(datalen, cp);\n\n\t\tif (datalen) {\n\t\t\tmemcpy(cp, data, (size_t)datalen);\n\t\t\tcp += datalen;\n\t\t}\n\n\t\thp->ancount = htons(1);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn cp - buf;\n}\n#endif /* L_res_data */\n\n/* Unimplemented: */\n/* res_send */\n"], "fixing_code": ["/* resolv.c: DNS Resolver\n *\n * Copyright (C) 1998  Kenneth Albanowski <kjahds@kjahds.com>,\n *                     The Silver Hammer Group, Ltd.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Library General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n */\n/*\n * Portions Copyright (c) 1985, 1993\n *    The Regents of the University of California.  All rights reserved.\n * Portions Copyright \u00a9 2021 mirabilos <m@mirbsd.org>\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n * 4. Neither the name of the University nor the names of its contributors\n *    may be used to endorse or promote products derived from this software\n *    without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n/*\n * Portions Copyright (c) 1993 by Digital Equipment Corporation.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies, and that\n * the name of Digital Equipment Corporation not be used in advertising or\n * publicity pertaining to distribution of the document or software without\n * specific, written prior permission.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL\n * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT\n * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n * SOFTWARE.\n */\n/*\n * Portions Copyright (c) 1996-1999 by Internet Software Consortium.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS\n * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES\n * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE\n * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS\n * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS\n * SOFTWARE.\n */\n/* RFC 1035\n...\nWhenever an octet represents a numeric quantity, the left most bit\nin the diagram is the high order or most significant bit.\nThat is, the bit labeled 0 is the most significant bit.\n...\n\n4.1.1. Header section format\n      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   OPCODE  |AA|TC|RD|RA| 0  0  0|   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nID      16 bit random identifier assigned by querying peer.\n        Used to match query/response.\nQR      message is a query (0), or a response (1).\nOPCODE  0   standard query (QUERY)\n        1   inverse query (IQUERY)\n        2   server status request (STATUS)\nAA      Authoritative Answer - this bit is valid in responses.\n        Responding name server is an authority for the domain name\n        in question section. Answer section may have multiple owner names\n        because of aliases.  The AA bit corresponds to the name which matches\n        the query name, or the first owner name in the answer section.\nTC      TrunCation - this message was truncated.\nRD      Recursion Desired - this bit may be set in a query and\n        is copied into the response.  If RD is set, it directs\n        the name server to pursue the query recursively.\n        Recursive query support is optional.\nRA      Recursion Available - this be is set or cleared in a\n        response, and denotes whether recursive query support is\n        available in the name server.\nRCODE   Response code.\n        0   No error condition\n        1   Format error\n        2   Server failure - server was unable to process the query\n            due to a problem with the name server.\n        3   Name Error - meaningful only for responses from\n            an authoritative name server. The referenced domain name\n            does not exist.\n        4   Not Implemented.\n        5   Refused.\nQDCOUNT number of entries in the question section.\nANCOUNT number of records in the answer section.\nNSCOUNT number of records in the authority records section.\nARCOUNT number of records in the additional records section.\n\n4.1.2. Question section format\n\nThe section contains QDCOUNT (usually 1) entries, each of this format:\n      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /                     QNAME                     /\n    /                                               /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     QTYPE                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     QCLASS                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nQNAME   a domain name represented as a sequence of labels, where\n        each label consists of a length octet followed by that\n        number of octets. The domain name terminates with the\n        zero length octet for the null label of the root. Note\n        that this field may be an odd number of octets; no\n        padding is used.\nQTYPE   a two octet type of the query.\n          1 a host address [REQ_A const]\n          2 an authoritative name server\n          3 a mail destination (Obsolete - use MX)\n          4 a mail forwarder (Obsolete - use MX)\n          5 the canonical name for an alias\n          6 marks the start of a zone of authority\n          7 a mailbox domain name (EXPERIMENTAL)\n          8 a mail group member (EXPERIMENTAL)\n          9 a mail rename domain name (EXPERIMENTAL)\n         10 a null RR (EXPERIMENTAL)\n         11 a well known service description\n         12 a domain name pointer [REQ_PTR const]\n         13 host information\n         14 mailbox or mail list information\n         15 mail exchange\n         16 text strings\n       0x1c IPv6?\n        252 a request for a transfer of an entire zone\n        253 a request for mailbox-related records (MB, MG or MR)\n        254 a request for mail agent RRs (Obsolete - see MX)\n        255 a request for all records\nQCLASS  a two octet code that specifies the class of the query.\n          1 the Internet\n        (others are historic only)\n        255 any class\n\n4.1.3. Resource record format\n\nThe answer, authority, and additional sections all share the same format:\na variable number of resource records, where the number of records\nis specified in the corresponding count field in the header.\nEach resource record has this format:\n      0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    /                                               /\n    /                      NAME                     /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      TYPE                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                     CLASS                     |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      TTL                      |\n    |                                               |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                   RDLENGTH                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--|\n    /                     RDATA                     /\n    /                                               /\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nNAME    a domain name to which this resource record pertains.\nTYPE    two octets containing one of the RR type codes.  This\n        field specifies the meaning of the data in the RDATA field.\nCLASS   two octets which specify the class of the data in the RDATA field.\nTTL     a 32 bit unsigned integer that specifies the time interval\n        (in seconds) that the record may be cached.\nRDLENGTH a 16 bit integer, length in octets of the RDATA field.\nRDATA   a variable length string of octets that describes the resource.\n        The format of this information varies according to the TYPE\n        and CLASS of the resource record.\n        If the TYPE is A and the CLASS is IN, it's a 4 octet IP address.\n\n4.1.4. Message compression\n\nIn order to reduce the size of messages, domain names can be compressed.\nAn entire domain name or a list of labels at the end of a domain name\nis replaced with a pointer to a prior occurance of the same name.\n\nThe pointer takes the form of a two octet sequence:\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    | 1  1|                OFFSET                   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\nThe first two bits are ones.  This allows a pointer to be distinguished\nfrom a label, since the label must begin with two zero bits because\nlabels are restricted to 63 octets or less.  The OFFSET field specifies\nan offset from the start of the message (i.e., the first octet\nof the ID field in the domain header).\nA zero offset specifies the first byte of the ID field, etc.\nDomain name in a message can be represented as either:\n   - a sequence of labels ending in a zero octet\n   - a pointer\n   - a sequence of labels ending with a pointer\n */\n\n#include <string.h>\n#include <stdio.h>\n#include <stdio_ext.h>\n#include <signal.h>\n#include <malloc.h>\n#include <errno.h>\n#include <sys/poll.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <resolv.h>\n#include <netdb.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <time.h>\n#include <arpa/nameser.h>\n#include <sys/utsname.h>\n#include <sys/un.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <bits/uClibc_mutex.h>\n#include \"internal/parse_config.h\"\n\n/* poll() is not supported in kernel <= 2.0, therefore if __NR_poll is\n * not available, we assume an old Linux kernel is in use and we will\n * use select() instead. */\n#include <sys/syscall.h>\n#ifndef __NR_poll\n# define USE_SELECT\n#endif\n\n#if defined __UCLIBC_HAS_IPV4__ && defined __UCLIBC_HAS_IPV6__\n#define IF_HAS_BOTH(...) __VA_ARGS__\n#else\n#define IF_HAS_BOTH(...)\n#endif\n\n\n#define MAX_RECURSE    5\n#define MAXALIASES  (4)\n/* 1:ip + 1:full + MAX_ALIASES:aliases + 1:NULL */\n#define ALIAS_DIM   (2 + MAXALIASES + 1)\n#define BUFSZ       (80) /* one line */\n\n#define NS_TYPE_ELT\t\t\t\t\t0x40 /*%< EDNS0 extended label type */\n#define DNS_LABELTYPE_BITSTRING\t\t0x41\n\n#undef DEBUG\n/* #define DEBUG */\n\n#ifdef DEBUG\n#define DPRINTF(X,args...) fprintf(stderr, X, ##args)\n#else\n#define DPRINTF(X,args...)\n#endif\n\n/* Make sure the incoming char * buffer is aligned enough to handle our random\n * structures.  This define is the same as we use for malloc alignment (which\n * has same requirements).  The offset is the number of bytes we need to adjust\n * in order to attain desired alignment.\n */\n#define ALIGN_ATTR __alignof__(double __attribute_aligned__ (sizeof(size_t)))\n#define ALIGN_BUFFER_OFFSET(buf) ((ALIGN_ATTR - ((size_t)buf % ALIGN_ATTR)) % ALIGN_ATTR)\n\n\n/* Structs */\nstruct resolv_header {\n\tint id;\n\tint qr, opcode, aa, tc, rd, ra, rcode;\n\tint qdcount;\n\tint ancount;\n\tint nscount;\n\tint arcount;\n};\n\nstruct resolv_question {\n\tchar *dotted;\n\tint qtype;\n\tint qclass;\n};\n\nstruct resolv_answer {\n\tchar *dotted;\n\tint atype;\n\tint aclass;\n\tint ttl;\n\tint rdlength;\n\tconst unsigned char *rdata;\n\tint rdoffset;\n\tchar* buf;\n\tsize_t buflen;\n\tsize_t add_count;\n};\n\nenum etc_hosts_action {\n\tGET_HOSTS_BYNAME = 0,\n\tGETHOSTENT,\n\tGET_HOSTS_BYADDR,\n};\n\ntypedef union sockaddr46_t {\n\tstruct sockaddr sa;\n#ifdef __UCLIBC_HAS_IPV4__\n\tstruct sockaddr_in sa4;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\tstruct sockaddr_in6 sa6;\n#endif\n} sockaddr46_t;\n\n\n__UCLIBC_MUTEX_EXTERN(__resolv_lock) attribute_hidden;\n\n/* Protected by __resolv_lock */\nextern void (*__res_sync)(void) attribute_hidden;\n/*extern uint32_t __resolv_opts attribute_hidden; */\nextern uint8_t __resolv_timeout attribute_hidden;\nextern uint8_t __resolv_attempts attribute_hidden;\nextern unsigned __nameservers attribute_hidden;\nextern unsigned __searchdomains attribute_hidden;\nextern sockaddr46_t *__nameserver attribute_hidden;\nextern char **__searchdomain attribute_hidden;\n#ifdef __UCLIBC_HAS_IPV4__\nextern const struct sockaddr_in __local_nameserver attribute_hidden;\n#else\nextern const struct sockaddr_in6 __local_nameserver attribute_hidden;\n#endif\n/* Arbitrary */\n#define MAXLEN_searchdomain 128\n\n\n/* prototypes for internal functions */\nextern void endhostent_unlocked(void) attribute_hidden;\nextern int __get_hosts_byname_r(const char *name,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop) attribute_hidden;\nextern int __get_hosts_byaddr_r(const char *addr,\n\t\tint len,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop) attribute_hidden;\nextern parser_t *__open_etc_hosts(void) attribute_hidden;\nextern int __read_etc_hosts_r(parser_t *parser,\n\t\tconst char *name,\n\t\tint type,\n\t\tenum etc_hosts_action action,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop) attribute_hidden;\nextern int __dns_lookup(const char *name,\n\t\tint type,\n\t\tunsigned char **outpacket,\n\t\tstruct resolv_answer *a) attribute_hidden;\nextern int __encode_header(struct resolv_header *h,\n\t\tunsigned char *dest,\n\t\tint maxlen) attribute_hidden;\nextern void __decode_header(unsigned char *data,\n\t\tstruct resolv_header *h) attribute_hidden;\nextern int __encode_question(const struct resolv_question *q,\n\t\tunsigned char *dest,\n\t\tint maxlen) attribute_hidden;\nextern int __encode_answer(struct resolv_answer *a,\n\t\tunsigned char *dest,\n\t\tint maxlen) attribute_hidden;\nextern void __open_nameservers(void) attribute_hidden;\nextern void __close_nameservers(void) attribute_hidden;\nextern int __hnbad(const char *dotted) attribute_hidden;\n\n#define __encode_dotted(dotted,dest,maxlen) \\\n\tdn_comp((dotted), (dest), (maxlen), NULL, NULL)\n#define __decode_dotted(packet,offset,packet_len,dest,dest_len) \\\n\tdn_expand((packet), (packet) + (packet_len), (packet) + (offset), \\\n\t    (dest), (dest_len))\n\n/*\n * Theory of operation.\n *\n * gethostbyname, getaddrinfo and friends end up here, and they sometimes\n * need to talk to DNS servers. In order to do this, we need to read /etc/resolv.conf\n * and determine servers' addresses and the like. resolv.conf format:\n *\n * nameserver <IP[v6]>\n *\t\tAddress of DNS server. Cumulative.\n *\t\tIf not specified, assumed to be on localhost.\n * search <domain1>[ <domain2>]...\n *\t\tAppend these domains to unqualified names.\n *\t\tSee ndots:n option.\n *\t\t$LOCALDOMAIN (space-separated list) overrides this.\n * domain <domain>\n *\t\tEffectively same as \"search\" with one domain.\n *\t\tIf no \"domain\" line is present, the domain is determined\n *\t\tfrom the local host name returned by gethostname();\n *\t\tthe domain part is taken to be everything after the first dot.\n *\t\tIf there are no dots, there will be no \"domain\".\n *\t\tThe domain and search keywords are mutually exclusive.\n *\t\tIf more than one instance of these keywords is present,\n *\t\tthe last instance wins.\n * sortlist 130.155.160.0[/255.255.240.0] 130.155.0.0\n *\t\tAllows addresses returned by gethostbyname to be sorted.\n *\t\tNot supported.\n * options option[ option]...\n *\t\t(so far we support timeout:n and attempts:n)\n *\t\t$RES_OPTIONS (space-separated list) is to be added to \"options\"\n *  debug\tsets RES_DEBUG in _res.options\n *  ndots:n\thow many dots there should be so that name will be tried\n *\t\tfirst as an absolute name before any search list elements\n *\t\tare appended to it. Default 1\n *  timeout:n   how long to wait for response. Default 5\n *\t\t(sun seems to have retrans:n synonym)\n *  attempts:n\tnumber of rounds to do before giving up and returning\n *\t\tan error. Default 2\n *\t\t(sun seems to have retry:n synonym)\n *  rotate\tsets RES_ROTATE in _res.options, round robin\n *\t\tselection of nameservers. Otherwise try\n *\t\tthe first listed server first every time\n *  no-check-names\n *\t\tsets RES_NOCHECKNAME in _res.options, which disables\n *\t\tchecking of incoming host names for invalid characters\n *\t\tsuch as underscore (_), non-ASCII, or control characters\n *  inet6\tsets RES_USE_INET6 in _res.options. Try a AAAA query\n *\t\tbefore an A query inside the gethostbyname(), and map\n *\t\tIPv4 responses in IPv6 \"tunnelled form\" if no AAAA records\n *\t\tare found but an A record set exists\n *  no_tld_query (FreeBSDism?)\n *\t\tdo not attempt to resolve names without dots\n *\n * We will read and analyze /etc/resolv.conf as needed before\n * we do a DNS request. This happens in __dns_lookup.\n * It is reread if its mtime is changed.\n *\n * BSD has res_init routine which is used to initialize resolver state\n * which is held in global structure _res.\n * Generally, programs call res_init, then fiddle with _res.XXX\n * (_res.options and _res.nscount, _res.nsaddr_list[N]\n * are popular targets of fiddling) and expect subsequent calls\n * to gethostbyname, getaddrinfo, etc to use modified information.\n *\n * However, historical _res structure is quite awkward.\n * Using it for storing /etc/resolv.conf info is not desirable,\n * and __dns_lookup does not use it.\n *\n * We would like to avoid using it unless absolutely necessary.\n * If user doesn't use res_init, we should arrange it so that\n * _res structure doesn't even *get linked in* into user's application\n * (imagine static uclibc build here).\n *\n * The solution is a __res_sync function pointer, which is normally NULL.\n * But if res_init is called, it gets set and any subsequent gethostbyname\n * et al \"syncronizes\" our internal structures with potentially\n * modified _res.XXX stuff by calling __res_sync.\n * The trick here is that if res_init is not used and not linked in,\n * gethostbyname itself won't reference _res and _res won't be linked in\n * either. Other possible methods like\n * if (__res_sync_just_an_int_flag)\n *\t__sync_me_with_res()\n * would pull in __sync_me_with_res, which pulls in _res. Bad.\n */\n\n\n#ifdef L_encodeh\n\nint __encode_header(struct resolv_header *h, unsigned char *dest, int maxlen)\n{\n\tif (maxlen < HFIXEDSZ)\n\t\treturn -1;\n\n\tdest[0] = (h->id & 0xff00) >> 8;\n\tdest[1] = (h->id & 0x00ff) >> 0;\n\tdest[2] = (h->qr ? 0x80 : 0) |\n\t\t((h->opcode & 0x0f) << 3) |\n\t\t(h->aa ? 0x04 : 0) |\n\t\t(h->tc ? 0x02 : 0) |\n\t\t(h->rd ? 0x01 : 0);\n\tdest[3] = (h->ra ? 0x80 : 0) | (h->rcode & 0x0f);\n\tdest[4] = (h->qdcount & 0xff00) >> 8;\n\tdest[5] = (h->qdcount & 0x00ff) >> 0;\n\tdest[6] = (h->ancount & 0xff00) >> 8;\n\tdest[7] = (h->ancount & 0x00ff) >> 0;\n\tdest[8] = (h->nscount & 0xff00) >> 8;\n\tdest[9] = (h->nscount & 0x00ff) >> 0;\n\tdest[10] = (h->arcount & 0xff00) >> 8;\n\tdest[11] = (h->arcount & 0x00ff) >> 0;\n\n\treturn HFIXEDSZ;\n}\n#endif /* L_encodeh */\n\n\n#ifdef L_decodeh\n\nvoid __decode_header(unsigned char *data,\n\t\tstruct resolv_header *h)\n{\n\th->id = (data[0] << 8) | data[1];\n\th->qr = (data[2] & 0x80) ? 1 : 0;\n\th->opcode = (data[2] >> 3) & 0x0f;\n\th->aa = (data[2] & 0x04) ? 1 : 0;\n\th->tc = (data[2] & 0x02) ? 1 : 0;\n\th->rd = (data[2] & 0x01) ? 1 : 0;\n\th->ra = (data[3] & 0x80) ? 1 : 0;\n\th->rcode = data[3] & 0x0f;\n\th->qdcount = (data[4] << 8) | data[5];\n\th->ancount = (data[6] << 8) | data[7];\n\th->nscount = (data[8] << 8) | data[9];\n\th->arcount = (data[10] << 8) | data[11];\n}\n#endif /* L_decodeh */\n\n\n#ifdef L_encodeq\n\nint __encode_question(const struct resolv_question *q,\n\t\tunsigned char *dest,\n\t\tint maxlen)\n{\n\tint i;\n\n\ti = __encode_dotted(q->dotted, dest, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tdest += i;\n\tmaxlen -= i;\n\n\tif (maxlen < 4)\n\t\treturn -1;\n\n\tdest[0] = (q->qtype & 0xff00) >> 8;\n\tdest[1] = (q->qtype & 0x00ff) >> 0;\n\tdest[2] = (q->qclass & 0xff00) >> 8;\n\tdest[3] = (q->qclass & 0x00ff) >> 0;\n\n\treturn i + 4;\n}\n#endif /* L_encodeq */\n\n\n#ifdef L_encodea\n\nint __encode_answer(struct resolv_answer *a, unsigned char *dest, int maxlen)\n{\n\tint i;\n\n\ti = __encode_dotted(a->dotted, dest, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tdest += i;\n\tmaxlen -= i;\n\n\tif (maxlen < (RRFIXEDSZ + a->rdlength))\n\t\treturn -1;\n\n\t*dest++ = (a->atype & 0xff00) >> 8;\n\t*dest++ = (a->atype & 0x00ff) >> 0;\n\t*dest++ = (a->aclass & 0xff00) >> 8;\n\t*dest++ = (a->aclass & 0x00ff) >> 0;\n\t*dest++ = (a->ttl & 0xff000000) >> 24;\n\t*dest++ = (a->ttl & 0x00ff0000) >> 16;\n\t*dest++ = (a->ttl & 0x0000ff00) >> 8;\n\t*dest++ = (a->ttl & 0x000000ff) >> 0;\n\t*dest++ = (a->rdlength & 0xff00) >> 8;\n\t*dest++ = (a->rdlength & 0x00ff) >> 0;\n\tmemcpy(dest, a->rdata, a->rdlength);\n\n\treturn i + RRFIXEDSZ + a->rdlength;\n}\n#endif /* L_encodea */\n\n\n#ifdef CURRENTLY_UNUSED\n#ifdef L_encodep\n\nint __encode_packet(struct resolv_header *h,\n\t\tstruct resolv_question **q,\n\t\tstruct resolv_answer **an,\n\t\tstruct resolv_answer **ns,\n\t\tstruct resolv_answer **ar,\n\t\tunsigned char *dest, int maxlen) attribute_hidden;\nint __encode_packet(struct resolv_header *h,\n\t\tstruct resolv_question **q,\n\t\tstruct resolv_answer **an,\n\t\tstruct resolv_answer **ns,\n\t\tstruct resolv_answer **ar,\n\t\tunsigned char *dest, int maxlen)\n{\n\tint i, total = 0;\n\tunsigned j;\n\n\ti = __encode_header(h, dest, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tdest += i;\n\tmaxlen -= i;\n\ttotal += i;\n\n\tfor (j = 0; j < h->qdcount; j++) {\n\t\ti = __encode_question(q[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\n\tfor (j = 0; j < h->ancount; j++) {\n\t\ti = __encode_answer(an[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\tfor (j = 0; j < h->nscount; j++) {\n\t\ti = __encode_answer(ns[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\tfor (j = 0; j < h->arcount; j++) {\n\t\ti = __encode_answer(ar[j], dest, maxlen);\n\t\tif (i < 0)\n\t\t\treturn i;\n\t\tdest += i;\n\t\tmaxlen -= i;\n\t\ttotal += i;\n\t}\n\n\treturn total;\n}\n#endif /* L_encodep */\n\n\n#ifdef L_decodep\n\nint __decode_packet(unsigned char *data, struct resolv_header *h) attribute_hidden;\nint __decode_packet(unsigned char *data, struct resolv_header *h)\n{\n\t__decode_header(data, h);\n\treturn HFIXEDSZ;\n}\n#endif /* L_decodep */\n\n\n#ifdef L_formquery\n\nint __form_query(int id,\n\t\tconst char *name,\n\t\tint type,\n\t\tunsigned char *packet,\n\t\tint maxlen) attribute_hidden;\nint __form_query(int id,\n\t\tconst char *name,\n\t\tint type,\n\t\tunsigned char *packet,\n\t\tint maxlen)\n{\n\tstruct resolv_header h;\n\tstruct resolv_question q;\n\tint i, j;\n\n\tmemset(&h, 0, sizeof(h));\n\th.id = id;\n\th.qdcount = 1;\n\n\tq.dotted = (char *) name;\n\tq.qtype = type;\n\tq.qclass = C_IN; /* CLASS_IN */\n\n\ti = __encode_header(&h, packet, maxlen);\n\tif (i < 0)\n\t\treturn i;\n\n\tj = __encode_question(&q, packet + i, maxlen - i);\n\tif (j < 0)\n\t\treturn j;\n\n\treturn i + j;\n}\n#endif /* L_formquery */\n#endif /* CURRENTLY_UNUSED */\n\n\n#ifdef L_opennameservers\n\n# if __BYTE_ORDER == __LITTLE_ENDIAN\n#define NAMESERVER_PORT_N (__bswap_constant_16(NAMESERVER_PORT))\n#else\n#define NAMESERVER_PORT_N NAMESERVER_PORT\n#endif\n\n__UCLIBC_MUTEX_INIT(__resolv_lock, PTHREAD_MUTEX_INITIALIZER);\n\n/* Protected by __resolv_lock */\nvoid (*__res_sync)(void);\n/*uint32_t __resolv_opts; */\nuint8_t __resolv_timeout = RES_TIMEOUT;\nuint8_t __resolv_attempts = RES_DFLRETRY;\nunsigned __nameservers;\nunsigned __searchdomains;\nsockaddr46_t *__nameserver;\nchar **__searchdomain;\n#ifdef __UCLIBC_HAS_IPV4__\nconst struct sockaddr_in __local_nameserver = {\n\t.sin_family = AF_INET,\n\t.sin_port = NAMESERVER_PORT_N,\n};\n#else\nconst struct sockaddr_in6 __local_nameserver = {\n\t.sin6_family = AF_INET6,\n\t.sin6_port = NAMESERVER_PORT_N,\n};\n#endif\n\n/* Helpers. Both stop on EOL, if it's '\\n', it is converted to NUL first */\nstatic char *skip_nospace(char *p)\n{\n\twhile (*p != '\\0' && !isspace(*p)) {\n\t\tif (*p == '\\n') {\n\t\t\t*p = '\\0';\n\t\t\tbreak;\n\t\t}\n\t\tp++;\n\t}\n\treturn p;\n}\nstatic char *skip_and_NUL_space(char *p)\n{\n\t/* NB: '\\n' is not isspace! */\n\twhile (1) {\n\t\tchar c = *p;\n\t\tif (c == '\\0' || !isspace(c))\n\t\t\tbreak;\n\t\t*p = '\\0';\n\t\tif (c == '\\n' || c == '#')\n\t\t\tbreak;\n\t\tp++;\n\t}\n\treturn p;\n}\n\n/* Must be called under __resolv_lock. */\nvoid __open_nameservers(void)\n{\n\tstatic uint32_t resolv_conf_mtime;\n\n\tchar szBuffer[MAXLEN_searchdomain];\n\tFILE *fp;\n\tint i;\n\tsockaddr46_t sa;\n\n\tif (!__res_sync) {\n\t\t/* Reread /etc/resolv.conf if it was modified.  */\n\t\tstruct stat sb;\n\t\tif (stat(_PATH_RESCONF, &sb) != 0)\n\t\t\tsb.st_mtime = 0;\n\t\tif (resolv_conf_mtime != (uint32_t)sb.st_mtime) {\n\t\t\tresolv_conf_mtime = sb.st_mtime;\n\t\t\t__close_nameservers(); /* force config reread */\n\t\t}\n\t}\n\n\tif (__nameservers)\n\t\tgoto sync;\n\n\t__resolv_timeout = RES_TIMEOUT;\n\t__resolv_attempts = RES_DFLRETRY;\n\n\tfp = fopen(_PATH_RESCONF, \"r\");\n#ifdef FALLBACK_TO_CONFIG_RESOLVCONF\n\tif (!fp) {\n\t\t/* If we do not have a pre-populated /etc/resolv.conf then\n\t\t   try to use the one from /etc/config which exists on numerous\n\t\t   systems ranging from some uClinux to IRIX installations and\n\t\t   may be the only /etc dir that was mounted rw.  */\n\t\tfp = fopen(\"/etc/config/resolv.conf\", \"r\");\n\t}\n#endif\n\n\tif (fp) {\n\t\twhile (fgets(szBuffer, sizeof(szBuffer), fp) != NULL) {\n\t\t\tvoid *ptr;\n\t\t\tchar *keyword, *p;\n\n\t\t\tkeyword = p = skip_and_NUL_space(szBuffer);\n\t\t\t/* skip keyword */\n\t\t\tp = skip_nospace(p);\n\t\t\t/* find next word */\n\t\t\tp = skip_and_NUL_space(p);\n\n\t\t\tif (strcmp(keyword, \"nameserver\") == 0) {\n\t\t\t\t/* terminate IP addr */\n\t\t\t\t*skip_nospace(p) = '\\0';\n\t\t\t\tmemset(&sa, 0, sizeof(sa));\n\t\t\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\telse if (inet_pton(AF_INET6, p, &sa.sa6.sin6_addr) > 0) {\n\t\t\t\t\tsa.sa6.sin6_family = AF_INET6;\n\t\t\t\t\tsa.sa6.sin6_port = htons(NAMESERVER_PORT);\n\t\t\t\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\t\telse if (inet_pton(AF_INET, p, &sa.sa4.sin_addr) > 0) {\n\t\t\t\t\tsa.sa4.sin_family = AF_INET;\n\t\t\t\t\tsa.sa4.sin_port = htons(NAMESERVER_PORT);\n\t\t\t\t}\n#endif\n\t\t\t\telse\n\t\t\t\t\tcontinue; /* garbage on this line */\n\t\t\t\tptr = realloc(__nameserver, (__nameservers + 1) * sizeof(__nameserver[0]));\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\t__nameserver = ptr;\n\t\t\t\t__nameserver[__nameservers++] = sa; /* struct copy */\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (strcmp(keyword, \"domain\") == 0 || strcmp(keyword, \"search\") == 0) {\n\t\t\t\tchar *p1;\n\n\t\t\t\t/* free old domains (\"last 'domain' or 'search' wins\" rule) */\n\t\t\t\twhile (__searchdomains)\n\t\t\t\t\tfree(__searchdomain[--__searchdomains]);\n\t\t\t\t/*free(__searchdomain);*/\n\t\t\t\t/*__searchdomain = NULL; - not necessary */\n next_word:\n\t\t\t\t/* terminate current word */\n\t\t\t\tp1 = skip_nospace(p);\n\t\t\t\t/* find next word (maybe) */\n\t\t\t\tp1 = skip_and_NUL_space(p1);\n\t\t\t\t/* add it */\n\t\t\t\tptr = realloc(__searchdomain, (__searchdomains + 1) * sizeof(__searchdomain[0]));\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\t__searchdomain = ptr;\n\t\t\t\t/* NB: strlen(p) <= MAXLEN_searchdomain) because szBuffer[] is smaller */\n\t\t\t\tptr = strdup(p);\n\t\t\t\tif (!ptr)\n\t\t\t\t\tcontinue;\n\t\t\t\tDPRINTF(\"adding search %s\\n\", (char*)ptr);\n\t\t\t\t__searchdomain[__searchdomains++] = (char*)ptr;\n\t\t\t\tp = p1;\n\t\t\t\tif (*p)\n\t\t\t\t\tgoto next_word;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* if (strcmp(keyword, \"sortlist\") == 0)... */\n\t\t\tif (strcmp(keyword, \"options\") == 0) {\n\t\t\t\tchar *p1;\n\t\t\t\tuint8_t *what;\n\n\t\t\t\tif (p == NULL || (p1 = strchr(p, ':')) == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\t*p1++ = '\\0';\n\t\t\t\tif (strcmp(p, \"timeout\") == 0)\n\t\t\t\t\twhat = &__resolv_timeout;\n\t\t\t\telse if (strcmp(p, \"attempts\") == 0)\n\t\t\t\t\twhat = &__resolv_attempts;\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t\t*what = atoi(p1);\n\t\t\t\tDPRINTF(\"option %s:%d\\n\", p, *what);\n\t\t\t}\n\t\t}\n\t\tfclose(fp);\n\t}\n\tif (__nameservers == 0) {\n\t\t/* Have to handle malloc failure! What a mess...\n\t\t * And it's not only here, we need to be careful\n\t\t * to never write into __nameserver[0] if it points\n\t\t * to constant __local_nameserver, or free it. */\n\t\t__nameserver = malloc(sizeof(__nameserver[0]));\n\t\tif (__nameserver)\n\t\t\tmemcpy(__nameserver, &__local_nameserver, sizeof(__local_nameserver));\n\t\telse\n\t\t\t__nameserver = (void*) &__local_nameserver;\n\t\t__nameservers++;\n\t}\n\tif (__searchdomains == 0) {\n\t\tchar buf[256];\n\t\tchar *p;\n\t\ti = gethostname(buf, sizeof(buf) - 1);\n\t\tbuf[sizeof(buf) - 1] = '\\0';\n\t\tif (i == 0 && (p = strchr(buf, '.')) != NULL && p[1]) {\n\t\t\tp = strdup(p + 1);\n\t\t\tif (!p)\n\t\t\t\tgoto err;\n\t\t\t__searchdomain = malloc(sizeof(__searchdomain[0]));\n\t\t\tif (!__searchdomain) {\n\t\t\t\tfree(p);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t__searchdomain[0] = p;\n\t\t\t__searchdomains++;\n err: ;\n\t\t}\n\t}\n\tDPRINTF(\"nameservers = %d\\n\", __nameservers);\n\n sync:\n\tif (__res_sync)\n\t\t__res_sync();\n}\n#endif /* L_opennameservers */\n\n\n#ifdef L_closenameservers\n\n/* Must be called under __resolv_lock. */\nvoid __close_nameservers(void)\n{\n\tif (__nameserver != (void*) &__local_nameserver)\n\t\tfree(__nameserver);\n\t__nameserver = NULL;\n\t__nameservers = 0;\n\twhile (__searchdomains)\n\t\tfree(__searchdomain[--__searchdomains]);\n\tfree(__searchdomain);\n\t__searchdomain = NULL;\n\t/*__searchdomains = 0; - already is */\n}\n#endif /* L_closenameservers */\n\n\n#ifdef L_dnslookup\n\n/* Helpers */\nstatic int __length_question(const unsigned char *data, int maxlen)\n{\n\tconst unsigned char *start;\n\tunsigned b;\n\n\tif (!data)\n\t\treturn -1;\n\n\tstart = data;\n\twhile (1) {\n\t\tif (maxlen <= 0)\n\t\t\treturn -1;\n\t\tb = *data++;\n\t\tif (b == 0)\n\t\t\tbreak;\n\t\tif ((b & 0xc0) == 0xc0) {\n\t\t\t/* It's a \"compressed\" name. */\n\t\t\tdata++; /* skip lsb of redirected offset */\n\t\t\tmaxlen -= 2;\n\t\t\tbreak;\n\t\t}\n\t\tdata += b;\n\t\tmaxlen -= (b + 1); /* account for data++ above */\n\t}\n\t/* Up to here we were skipping encoded name */\n\n\t/* Account for QTYPE and QCLASS fields */\n\tif (maxlen < 4)\n\t\treturn -1;\n\treturn data - start + 2 + 2;\n}\n\nstatic int __decode_answer(const unsigned char *message, /* packet */\n\t\tint offset,\n\t\tint len, /* total packet len */\n\t\tstruct resolv_answer *a)\n{\n\tchar temp[256];\n\tint i;\n\n\tDPRINTF(\"decode_answer(start): off %d, len %d\\n\", offset, len);\n\ti = __decode_dotted(message, offset, len, temp, sizeof(temp));\n\tif (i < 0)\n\t\treturn i;\n\n\tmessage += offset + i;\n\tlen -= i + RRFIXEDSZ + offset;\n\tif (len < 0) {\n\t\tDPRINTF(\"decode_answer: off %d, len %d, i %d\\n\", offset, len, i);\n\t\treturn len;\n\t}\n\n/* TODO: what if strdup fails? */\n\ta->dotted = strdup(temp);\n\ta->atype = (message[0] << 8) | message[1];\n\tmessage += 2;\n\ta->aclass = (message[0] << 8) | message[1];\n\tmessage += 2;\n\ta->ttl = (message[0] << 24) |\n\t\t(message[1] << 16) | (message[2] << 8) | (message[3] << 0);\n\tmessage += 4;\n\ta->rdlength = (message[0] << 8) | message[1];\n\tmessage += 2;\n\ta->rdata = message;\n\ta->rdoffset = offset + i + RRFIXEDSZ;\n\n\tDPRINTF(\"i=%d,rdlength=%d\\n\", i, a->rdlength);\n\n\tif (len < a->rdlength)\n\t\treturn -1;\n\treturn i + RRFIXEDSZ + a->rdlength;\n}\n\n/* On entry:\n *  a.buf(len) = auxiliary buffer for IP addresses after first one\n *  a.add_count = how many additional addresses are there already\n *  outpacket = where to save ptr to raw packet? can be NULL\n * On exit:\n *  ret < 0: error, all other data is not valid\n *  ret >= 0: length of reply packet\n *  a.add_count & a.buf: updated\n *  a.rdlength: length of addresses (4 bytes for IPv4)\n *  *outpacket: updated (packet is malloced, you need to free it)\n *  a.rdata: points into *outpacket to 1st IP addr\n *      NB: don't pass outpacket == NULL if you need to use a.rdata!\n *  a.atype: type of query?\n *  a.dotted: which name we _actually_ used. May contain search domains\n *      appended. (why the filed is called \"dotted\" I have no idea)\n *      This is a malloced string. May be NULL because strdup failed.\n */\nint __dns_lookup(const char *name,\n\t\tint type,\n\t\tunsigned char **outpacket,\n\t\tstruct resolv_answer *a)\n{\n\t/* Protected by __resolv_lock: */\n\tstatic int last_ns_num = 0;\n\tstatic uint16_t last_id = 1;\n\n\tint i, j, fd, rc;\n\tint packet_len;\n\tint name_len;\n#ifdef USE_SELECT\n\tstruct timeval tv;\n\tfd_set fds;\n#else\n\tstruct pollfd fds;\n#endif\n\tstruct resolv_header h;\n\tstruct resolv_question q;\n\tstruct resolv_answer ma;\n\tbool first_answer = 1;\n\tint retries_left;\n\tunsigned char *packet = malloc(PACKETSZ);\n\tchar *lookup;\n\tint variant = -1;  /* search domain to append, -1: none */\n\tint local_ns_num = -1; /* Nth server to use */\n\tint local_id = local_id; /* for compiler */\n\tint sdomains = 0;\n\tbool ends_with_dot;\n\tbool contains_dot;\n\tsockaddr46_t sa;\n\tint num_answers;\n\n\tfd = -1;\n\tlookup = NULL;\n\tname_len = strlen(name);\n\tif ((unsigned)name_len >= MAXDNAME - MAXLEN_searchdomain - 2)\n\t\tgoto fail; /* paranoia */\n\tlookup = malloc(name_len + 1/*for '.'*/ + MAXLEN_searchdomain + 1);\n\tif (!packet || !lookup || !name[0])\n\t\tgoto fail;\n\tends_with_dot = (name[name_len - 1] == '.');\n\tcontains_dot = strchr(name, '.') != NULL;\n\t/* no strcpy! paranoia, user might change name[] under us */\n\tmemcpy(lookup, name, name_len);\n\n\tDPRINTF(\"Looking up type %d answer for '%s'\\n\", type, name);\n\tretries_left = 0; /* for compiler */\n\tdo {\n\t\tunsigned act_variant;\n\t\tint pos;\n\t\tunsigned reply_timeout;\n\n\t\tif (fd != -1) {\n\t\t\tclose(fd);\n\t\t\tfd = -1;\n\t\t}\n\n\t\t/* Mess with globals while under lock */\n\t\t/* NB: even data *pointed to* by globals may vanish\n\t\t * outside the locks. We should assume any and all\n\t\t * globals can completely change between locked\n\t\t * code regions. OTOH, this is rare, so we don't need\n\t\t * to handle it \"nicely\" (do not skip servers,\n\t\t * search domains, etc), we only need to ensure\n\t\t * we do not SEGV, use freed+overwritten data\n\t\t * or do other Really Bad Things. */\n\t\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t\t__open_nameservers();\n\t\tif (type != T_PTR) {\n\t\t\tsdomains = __searchdomains;\n\t\t}\n\t\tlookup[name_len] = '\\0';\n\t\t/* For qualified names, act_variant = MAX_UINT, 0, .., sdomains-1\n\t\t *  => Try original name first, then append search domains\n\t\t * For names without domain, act_variant = 0, 1, .., sdomains\n\t\t *  => Try search domains first, original name last */\n\t\tact_variant = contains_dot ? variant : variant + 1;\n\t\tif (act_variant < sdomains) {\n\t\t\t/* lookup is name_len + 1 + MAXLEN_searchdomain + 1 long */\n\t\t\t/* __searchdomain[] is not bigger than MAXLEN_searchdomain */\n\t\t\tlookup[name_len] = '.';\n\t\t\tstrcpy(&lookup[name_len + 1], __searchdomain[act_variant]);\n\t\t}\n\t\t/* first time? pick starting server etc */\n\t\tif (local_ns_num < 0) {\n\t\t\tlocal_id = last_id;\n/*TODO: implement /etc/resolv.conf's \"options rotate\"\n (a.k.a. RES_ROTATE bit in _res.options)\n\t\t\tlocal_ns_num = 0;\n\t\t\tif (_res.options & RES_ROTATE) */\n\t\t\t\tlocal_ns_num = last_ns_num;\n\t\t\tretries_left = __nameservers * __resolv_attempts;\n\t\t}\n\t\tif (local_ns_num >= __nameservers)\n\t\t\tlocal_ns_num = 0;\n\t\tlocal_id++;\n\t\tlocal_id &= 0xffff;\n\t\t/* write new values back while still under lock */\n\t\tlast_id = local_id;\n\t\tlast_ns_num = local_ns_num;\n\t\t/* struct copy */\n\t\t/* can't just take a pointer, __nameserver[x]\n\t\t * is not safe to use outside of locks */\n\t\tsa = __nameserver[local_ns_num];\n\t\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\n\t\tmemset(packet, 0, PACKETSZ);\n\t\tmemset(&h, 0, sizeof(h));\n\n\t\t/* encode header */\n\t\th.id = local_id;\n\t\th.qdcount = 1;\n\t\th.rd = 1;\n\t\tDPRINTF(\"encoding header\\n\", h.rd);\n\t\ti = __encode_header(&h, packet, PACKETSZ);\n\t\tif (i < 0)\n\t\t\tgoto fail;\n\n\t\t/* encode question */\n\t\tDPRINTF(\"lookup name: %s\\n\", lookup);\n\t\tq.dotted = lookup;\n\t\tq.qtype = type;\n\t\tq.qclass = C_IN; /* CLASS_IN */\n\t\tj = __encode_question(&q, packet+i, PACKETSZ-i);\n\t\tif (j < 0)\n\t\t\tgoto fail;\n\t\tpacket_len = i + j;\n\n\t\t/* send packet */\n#ifdef DEBUG\n\t\t{\n\t\t\tconst socklen_t plen = sa.sa.sa_family == AF_INET ? INET_ADDRSTRLEN : INET6_ADDRSTRLEN;\n\t\t\tchar *pbuf = malloc(plen);\n\t\t\tif (pbuf == NULL) ;/* nothing */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\telse if (sa.sa.sa_family == AF_INET6)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET6, &sa.sa6.sin6_addr, pbuf, plen);\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\telse if (sa.sa.sa_family == AF_INET)\n\t\t\t\tpbuf = (char*)inet_ntop(AF_INET, &sa.sa4.sin_addr, pbuf, plen);\n#endif\n\t\t\tDPRINTF(\"On try %d, sending query to %s, port %d\\n\",\n\t\t\t\tretries_left, pbuf, NAMESERVER_PORT);\n\t\t\tfree(pbuf);\n\t\t}\n#endif\n\t\tfd = socket(sa.sa.sa_family, SOCK_DGRAM, IPPROTO_UDP);\n\t\tif (fd < 0) /* paranoia */\n\t\t\tgoto try_next_server;\n\t\trc = connect(fd, &sa.sa, sizeof(sa));\n\t\tif (rc < 0) {\n\t\t\t/*if (errno == ENETUNREACH) { */\n\t\t\t\t/* routing error, presume not transient */\n\t\t\t\tgoto try_next_server;\n\t\t\t/*} */\n/*For example, what transient error this can be? Can't think of any */\n\t\t\t/* retry */\n\t\t\t/*continue; */\n\t\t}\n\t\tDPRINTF(\"Xmit packet len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\t/* no error check - if it fails, we time out on recv */\n\t\tsend(fd, packet, packet_len, 0);\n\n#ifdef USE_SELECT\n\t\treply_timeout = __resolv_timeout;\n wait_again:\n\t\tFD_ZERO(&fds);\n\t\tFD_SET(fd, &fds);\n\t\ttv.tv_sec = reply_timeout;\n\t\ttv.tv_usec = 0;\n\t\tif (select(fd + 1, &fds, NULL, NULL, &tv) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\treply_timeout--;\n#else /* !USE_SELECT */\n\t\treply_timeout = __resolv_timeout * 1000;\n wait_again:\n\t\tfds.fd = fd;\n\t\tfds.events = POLLIN;\n\t\tif (poll(&fds, 1, reply_timeout) <= 0) {\n\t\t\tDPRINTF(\"Timeout\\n\");\n\t\t\t/* timed out, so retry send and receive\n\t\t\t * to next nameserver */\n\t\t\tgoto try_next_server;\n\t\t}\n\t\tif (fds.revents & (POLLERR | POLLHUP | POLLNVAL)) {\n\t\t\tDPRINTF(\"Bad event\\n\");\n\t\t\tgoto try_next_server;\n\t\t}\n/*TODO: better timeout accounting?*/\n\t\treply_timeout -= 1000;\n#endif /* USE_SELECT */\n\n/* vda: a bogus response seen in real world (caused SEGV in uclibc):\n * \"ping www.google.com\" sending AAAA query and getting\n * response with one answer... with answer part missing!\n * Fixed by thorough checks for not going past the packet's end.\n */\n#ifdef DEBUG\n\t\t{\n\t\t\tstatic const char test_query[32] = \"\\0\\2\\1\\0\\0\\1\\0\\0\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tstatic const char test_respn[32] = \"\\0\\2\\201\\200\\0\\1\\0\\1\\0\\0\\0\\0\\3www\\6google\\3com\\0\\0\\34\\0\\1\";\n\t\t\tpos = memcmp(packet + 2, test_query + 2, 30);\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n\t\t\tif (pos == 0) {\n\t\t\t\tpacket_len = 32;\n\t\t\t\tmemcpy(packet + 2, test_respn + 2, 30);\n\t\t\t}\n\t\t}\n#else\n\t\tpacket_len = recv(fd, packet, PACKETSZ, MSG_DONTWAIT);\n#endif\n\n\t\tif (packet_len < HFIXEDSZ) {\n\t\t\t/* too short!\n\t\t\t * If the peer did shutdown then retry later,\n\t\t\t * try next peer on error.\n\t\t\t * it's just a bogus packet from somewhere */\n bogus_packet:\n\t\t\tif (packet_len >= 0 && reply_timeout)\n\t\t\t\tgoto wait_again;\n\t\t\tgoto try_next_server;\n\t\t}\n\t\t__decode_header(packet, &h);\n\t\tDPRINTF(\"len:%d id:%d qr:%d\\n\", packet_len, h.id, h.qr);\n\t\tif (h.id != local_id || !h.qr) {\n\t\t\t/* unsolicited */\n\t\t\tgoto bogus_packet;\n\t\t}\n\n\t\tDPRINTF(\"Got response (i think)!\\n\");\n\t\tDPRINTF(\"qrcount=%d,ancount=%d,nscount=%d,arcount=%d\\n\",\n\t\t\t\th.qdcount, h.ancount, h.nscount, h.arcount);\n\t\tDPRINTF(\"opcode=%d,aa=%d,tc=%d,rd=%d,ra=%d,rcode=%d\\n\",\n\t\t\t\th.opcode, h.aa, h.tc, h.rd, h.ra, h.rcode);\n\n\t\t/* bug 660 says we treat negative response as an error\n\t\t * and retry, which is, eh, an error. :)\n\t\t * We were incurring long delays because of this. */\n\t\tif (h.rcode == NXDOMAIN || h.rcode == SERVFAIL) {\n\t\t\t/* if possible, try next search domain */\n\t\t\tif (!ends_with_dot) {\n\t\t\t\tDPRINTF(\"variant:%d sdomains:%d\\n\", variant, sdomains);\n\t\t\t\tif (variant < sdomains - 1) {\n\t\t\t\t\t/* next search domain */\n\t\t\t\t\tvariant++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* no more search domains to try */\n\t\t\t}\n\t\t\tif (h.rcode != SERVFAIL) {\n\t\t\t\t/* dont loop, this is \"no such host\" situation */\n\t\t\t\th_errno = HOST_NOT_FOUND;\n\t\t\t\tgoto fail1;\n\t\t\t}\n\t\t}\n\t\t/* Insert other non-fatal errors here, which do not warrant\n\t\t * switching to next nameserver */\n\n\t\t/* Strange error, assuming this nameserver is feeling bad */\n\t\tif (h.rcode != 0)\n\t\t\tgoto try_next_server;\n\n\t\t/* Code below won't work correctly with h.ancount == 0, so... */\n\t\tif (h.ancount <= 0) {\n\t\t\th_errno = NO_DATA; /* [is this correct code to check for?] */\n\t\t\tgoto fail1;\n\t\t}\n\t\tpos = HFIXEDSZ;\n\t\t/*XXX TODO: check that question matches query (and qdcount==1?) */\n\t\tfor (j = 0; j < h.qdcount; j++) {\n\t\t\tDPRINTF(\"Skipping question %d at %d\\n\", j, pos);\n\t\t\ti = __length_question(packet + pos, packet_len - pos);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"Packet'question section \"\n\t\t\t\t\t\"is truncated, trying next server\\n\");\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\t\t\tDPRINTF(\"Length of question %d is %d\\n\", j, i);\n\t\t}\n\t\tDPRINTF(\"Decoding answer at pos %d\\n\", pos);\n\n\t\tfirst_answer = 1;\n\t\tnum_answers = 0;\n\t\ta->dotted = NULL;\n\t\tfor (j = 0; j < h.ancount; j++) {\n\t\t\ti = __decode_answer(packet, pos, packet_len, &ma);\n\t\t\tif (i < 0) {\n\t\t\t\tDPRINTF(\"failed decode %d\\n\", i);\n\t\t\t\t/* If the message was truncated but we have\n\t\t\t\t * decoded some answers, pretend it's OK */\n\t\t\t\tif (num_answers && h.tc)\n\t\t\t\t\tbreak;\n\t\t\t\tgoto try_next_server;\n\t\t\t}\n\t\t\tpos += i;\n\n\t\t\tif (__hnbad(ma.dotted))\n\t\t\t\tbreak;\n\t\t\t++num_answers;\n\t\t\tif (first_answer) {\n\t\t\t\tma.buf = a->buf;\n\t\t\t\tma.buflen = a->buflen;\n\t\t\t\tma.add_count = a->add_count;\n\t\t\t\tfree(a->dotted);\n\t\t\t\tmemcpy(a, &ma, sizeof(ma));\n\t\t\t\tif (a->atype != T_SIG && (NULL == a->buf || (type != T_A && type != T_AAAA)))\n\t\t\t\t\tbreak;\n\t\t\t\tif (a->atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\ta->add_count = h.ancount - j - 1;\n\t\t\t\tif ((a->rdlength + sizeof(struct in_addr*)) * a->add_count > a->buflen)\n\t\t\t\t\tbreak;\n\t\t\t\ta->add_count = 0;\n\t\t\t\tfirst_answer = 0;\n\t\t\t} else {\n\t\t\t\tfree(ma.dotted);\n\t\t\t\tif (ma.atype != type)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (a->rdlength != ma.rdlength) {\n\t\t\t\t\tfree(a->dotted);\n\t\t\t\t\tDPRINTF(\"Answer address len(%u) differs from original(%u)\\n\",\n\t\t\t\t\t\t\tma.rdlength, a->rdlength);\n\t\t\t\t\tgoto try_next_server;\n\t\t\t\t}\n\t\t\t\tmemcpy(a->buf + (a->add_count * ma.rdlength), ma.rdata, ma.rdlength);\n\t\t\t\t++a->add_count;\n\t\t\t}\n\t\t}\n\t\tif (!num_answers) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\tgoto fail1;\n\t\t}\n\n\t\t/* Success! */\n\t\tDPRINTF(\"Answer name = |%s|\\n\", a->dotted);\n\t\tDPRINTF(\"Answer type = |%d|\\n\", a->atype);\n\t\tif (fd != -1)\n\t\t\tclose(fd);\n\t\tif (outpacket)\n\t\t\t*outpacket = packet;\n\t\telse\n\t\t\tfree(packet);\n\t\tfree(lookup);\n\t\treturn packet_len;\n\n try_next_server:\n\t\t/* Try next nameserver */\n\t\tretries_left--;\n\t\tlocal_ns_num++;\n\t\tvariant = -1;\n\t} while (retries_left > 0);\n\n fail:\n\th_errno = NETDB_INTERNAL;\n fail1:\n\tif (fd != -1)\n\t\tclose(fd);\n\tfree(lookup);\n\tfree(packet);\n\treturn -1;\n}\n#endif /* L_dnslookup */\n\n\n#ifdef L_read_etc_hosts_r\n\nparser_t * __open_etc_hosts(void)\n{\n\tparser_t *parser;\n\tparser = config_open(\"/etc/hosts\");\n#ifdef FALLBACK_TO_CONFIG_RESOLVCONF\n\tif (parser == NULL)\n\t\tparser = config_open(\"/etc/config/hosts\");\n#endif\n\treturn parser;\n}\n\n#define MINTOKENS 2 /* ip address + canonical name */\n#define MAXTOKENS (MINTOKENS + MAXALIASES)\n#define HALISTOFF (sizeof(char*) * (MAXTOKENS + 1))\t/* reserve space for list terminator */\n#define INADDROFF (HALISTOFF + 2 * sizeof(char*))\n\nint __read_etc_hosts_r(\n\t\tparser_t * parser,\n\t\tconst char *name,\n\t\tint type,\n\t\tenum etc_hosts_action action,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf, size_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n\tchar **tok = NULL;\n\tstruct in_addr *h_addr0 = NULL;\n\tconst size_t aliaslen = INADDROFF +\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\t\t\t\tsizeof(struct in6_addr)\n#else\n\t\t\t\t\t\t\tsizeof(struct in_addr)\n#endif\n\t\t\t\t\t\t\t;\n\tint ret = HOST_NOT_FOUND;\n\t/* make sure pointer is aligned */\n\tint i = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\n\t*h_errnop = NETDB_INTERNAL;\n\tif (/* (ssize_t)buflen < 0 || */ buflen < aliaslen\n\t\t|| (buflen - aliaslen) < BUFSZ + 1)\n\t\treturn ERANGE;\n\tif (parser == NULL)\n\t\tparser = __open_etc_hosts();\n\tif (parser == NULL) {\n\t\t*result = NULL;\n\t\treturn errno;\n\t}\n\t/* Layout in buf:\n\t * char *alias[MAXTOKENS]  = {address, name, aliases...}\n\t * char **h_addr_list[1]   = {*in[6]_addr, NULL}\n\t * struct in[6]_addr\n\t * char line_buffer[BUFSZ+];\n\t */\n\tparser->data = buf;\n\tparser->data_len = aliaslen;\n\tparser->line_len = buflen - aliaslen;\n\t*h_errnop = HOST_NOT_FOUND;\n\t/* <ip>[[:space:]][<aliases>] */\n\twhile (config_read(parser, &tok, MAXTOKENS, MINTOKENS, \"# \\t\", PARSE_NORMAL)) {\n\t\tresult_buf->h_aliases = tok+1;\n\t\tif (action == GETHOSTENT) {\n\t\t\t/* Return whatever the next entry happens to be. */\n\t\t\t;\n\t\t} else if (action == GET_HOSTS_BYADDR) {\n\t\t\tif (strcmp(name, *tok) != 0)\n\t\t\t\tcontinue;\n\t\t} else { /* GET_HOSTS_BYNAME */\n\t\t\tint aliases = 0;\n\t\t\tchar **alias = tok + 1;\n\t\t\twhile (aliases < MAXALIASES) {\n\t\t\t\tchar *tmp = *(alias+aliases++);\n\t\t\t\tif (tmp && strcasecmp(name, tmp) == 0)\n\t\t\t\t\tgoto found;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\nfound:\n\t\tresult_buf->h_name = *(result_buf->h_aliases++);\n\t\tresult_buf->h_addr_list = (char**)(buf + HALISTOFF);\n\t\t*(result_buf->h_addr_list + 1) = '\\0';\n\t\th_addr0 = (struct in_addr*)(buf + INADDROFF);\n\t\tresult_buf->h_addr = (char*)h_addr0;\n\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV4__\n\t\telse if (type == AF_INET\n\t\t\t\t&& inet_pton(AF_INET, *tok, h_addr0) > 0) {\n\t\t\tDPRINTF(\"Found INET\\n\");\n\t\t\tresult_buf->h_addrtype = AF_INET;\n\t\t\tresult_buf->h_length = sizeof(struct in_addr);\n\t\t\t*result = result_buf;\n\t\t\tret = NETDB_SUCCESS;\n\t\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n#define in6 ((struct in6_addr *)buf)\n\t\telse if (type == AF_INET6\n\t\t\t\t&& inet_pton(AF_INET6, *tok, h_addr0) > 0) {\n\t\t\tDPRINTF(\"Found INET6\\n\");\n\t\t\tresult_buf->h_addrtype = AF_INET6;\n\t\t\tresult_buf->h_length = sizeof(struct in6_addr);\n\t\t\t*result = result_buf;\n\t\t\tret = NETDB_SUCCESS;\n\t\t}\n#endif\n\t\telse {\n\t\t\t/* continue parsing in the hope the user has multiple\n\t\t\t * host types listed in the database like so:\n\t\t\t * <ipv4 addr> host\n\t\t\t * <ipv6 addr> host\n\t\t\t * If looking for an IPv6 addr, don't bail when we got the IPv4\n\t\t\t */\n\t\t\tDPRINTF(\"Error: Found host but different address family\\n\");\n\t\t\t/* NB: gethostbyname2_r depends on this feature\n\t\t\t * to avoid looking for IPv6 addr of \"localhost\" etc */\n\t\t\tret = TRY_AGAIN;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t}\n\tif (action != GETHOSTENT)\n\t\tconfig_close(parser);\n\treturn ret;\n#undef in6\n}\n#endif /* L_read_etc_hosts_r */\n\n\n#ifdef L_get_hosts_byname_r\n\nint __get_hosts_byname_r(const char *name,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n\treturn __read_etc_hosts_r(NULL, name, type, GET_HOSTS_BYNAME,\n\t                          result_buf, buf, buflen, result, h_errnop);\n}\n#endif /* L_get_hosts_byname_r */\n\n\n#ifdef L_get_hosts_byaddr_r\n\nint __get_hosts_byaddr_r(const char *addr,\n\t\tint len,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n#ifndef __UCLIBC_HAS_IPV6__\n\tchar\tipaddr[INET_ADDRSTRLEN];\n#else\n\tchar\tipaddr[INET6_ADDRSTRLEN];\n#endif\n\n\tswitch (type) {\n#ifdef __UCLIBC_HAS_IPV4__\n\t\tcase AF_INET:\n\t\t\tif (len != sizeof(struct in_addr))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n\t\t\tif (len != sizeof(struct in6_addr))\n\t\t\t\treturn 0;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n\n\tinet_ntop(type, addr, ipaddr, sizeof(ipaddr));\n\n\treturn __read_etc_hosts_r(NULL, ipaddr, type, GET_HOSTS_BYADDR,\n\t\t\t\tresult_buf, buf, buflen, result, h_errnop);\n}\n#endif /* L_get_hosts_byaddr_r */\n\n\n#ifdef L_getnameinfo\n\nint getnameinfo(const struct sockaddr *sa,\n\t\tsocklen_t addrlen,\n\t\tchar *host,\n\t\tsocklen_t hostlen,\n\t\tchar *serv,\n\t\tsocklen_t servlen,\n\t\tunsigned flags)\n{\n\tint serrno = errno;\n\tbool ok = 0;\n\tstruct hostent *hoste = NULL;\n\tchar domain[256];\n\n\tif (flags & ~(NI_NUMERICHOST|NI_NUMERICSERV|NI_NOFQDN|NI_NAMEREQD|NI_DGRAM))\n\t\treturn EAI_BADFLAGS;\n\n\tif (sa == NULL || addrlen < sizeof(sa_family_t))\n\t\treturn EAI_FAMILY;\n\n\tif ((flags & NI_NAMEREQD) && host == NULL && serv == NULL)\n\t\treturn EAI_NONAME;\n\n\tif (sa->sa_family == AF_LOCAL) /* valid */;\n#ifdef __UCLIBC_HAS_IPV4__\n\telse if (sa->sa_family == AF_INET) {\n\t\tif (addrlen < sizeof(struct sockaddr_in))\n\t\t\treturn EAI_FAMILY;\n\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\telse if (sa->sa_family == AF_INET6) {\n\t\tif (addrlen < sizeof(struct sockaddr_in6))\n\t\t\treturn EAI_FAMILY;\n\t}\n#endif\n\telse\n\t\treturn EAI_FAMILY;\n\n\tif (host != NULL && hostlen > 0)\n\t\tswitch (sa->sa_family) {\n\t\tcase AF_INET:\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n#endif\n\t\t\tif (!(flags & NI_NUMERICHOST)) {\n\t\t\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\telse if (sa->sa_family == AF_INET6)\n\t\t\t\t\thoste = gethostbyaddr((const void *)\n\t\t\t\t\t\t&(((const struct sockaddr_in6 *) sa)->sin6_addr),\n\t\t\t\t\t\tsizeof(struct in6_addr), AF_INET6);\n#endif\n#ifdef __UCLIBC_HAS_IPV4__\n\t\t\t\telse\n\t\t\t\t\thoste = gethostbyaddr((const void *)\n\t\t\t\t\t\t&(((const struct sockaddr_in *)sa)->sin_addr),\n\t\t\t\t\t\tsizeof(struct in_addr), AF_INET);\n#endif\n\n\t\t\t\tif (hoste) {\n\t\t\t\t\tchar *c;\n\t\t\t\t\tif ((flags & NI_NOFQDN)\n\t\t\t\t\t && (getdomainname(domain, sizeof(domain)) == 0)\n\t\t\t\t\t && (c = strstr(hoste->h_name, domain)) != NULL\n\t\t\t\t\t && (c != hoste->h_name) && (*(--c) == '.')\n\t\t\t\t\t) {\n\t\t\t\t\t\tstrncpy(host, hoste->h_name,\n\t\t\t\t\t\t\tMIN(hostlen, (size_t) (c - hoste->h_name)));\n\t\t\t\t\t\thost[MIN(hostlen - 1, (size_t) (c - hoste->h_name))] = '\\0';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrncpy(host, hoste->h_name, hostlen);\n\t\t\t\t\t}\n\t\t\t\t\tok = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!ok) {\n\t\t\t\tconst char *c = NULL;\n\n\t\t\t\tif (flags & NI_NAMEREQD) {\n\t\t\t\t\terrno = serrno;\n\t\t\t\t\treturn EAI_NONAME;\n\t\t\t\t}\n\t\t\t\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\t\telse if (sa->sa_family == AF_INET6) {\n\t\t\t\t\tconst struct sockaddr_in6 *sin6p;\n\n\t\t\t\t\tsin6p = (const struct sockaddr_in6 *) sa;\n\t\t\t\t\tc = inet_ntop(AF_INET6,\n\t\t\t\t\t\t(const void *) &sin6p->sin6_addr,\n\t\t\t\t\t\thost, hostlen);\n#if 0\n\t\t\t\t\t/* Does scope id need to be supported? */\n\t\t\t\t\tuint32_t scopeid;\n\t\t\t\t\tscopeid = sin6p->sin6_scope_id;\n\t\t\t\t\tif (scopeid != 0) {\n\t\t\t\t\t\t/* Buffer is >= IFNAMSIZ+1.  */\n\t\t\t\t\t\tchar scopebuf[IFNAMSIZ + 1];\n\t\t\t\t\t\tchar *scopeptr;\n\t\t\t\t\t\tint ni_numericscope = 0;\n\t\t\t\t\t\tsize_t real_hostlen = strnlen(host, hostlen);\n\t\t\t\t\t\tsize_t scopelen = 0;\n\n\t\t\t\t\t\tscopebuf[0] = SCOPE_DELIMITER;\n\t\t\t\t\t\tscopebuf[1] = '\\0';\n\t\t\t\t\t\tscopeptr = &scopebuf[1];\n\n\t\t\t\t\t\tif (IN6_IS_ADDR_LINKLOCAL(&sin6p->sin6_addr)\n\t\t\t\t\t\t    || IN6_IS_ADDR_MC_LINKLOCAL(&sin6p->sin6_addr)) {\n\t\t\t\t\t\t\tif (if_indextoname(scopeid, scopeptr) == NULL)\n\t\t\t\t\t\t\t\t++ni_numericscope;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tscopelen = strlen(scopebuf);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t++ni_numericscope;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ni_numericscope)\n\t\t\t\t\t\t\tscopelen = 1 + snprintf(scopeptr,\n\t\t\t\t\t\t\t\t(scopebuf\n\t\t\t\t\t\t\t\t+ sizeof scopebuf\n\t\t\t\t\t\t\t\t- scopeptr),\n\t\t\t\t\t\t\t\t\"%u\", scopeid);\n\n\t\t\t\t\t\tif (real_hostlen + scopelen + 1 > hostlen)\n\t\t\t\t\t\t\treturn EAI_SYSTEM;\n\t\t\t\t\t\tmemcpy(host + real_hostlen, scopebuf, scopelen + 1);\n\t\t\t\t\t}\n#endif\n\t\t\t\t}\n#endif /* __UCLIBC_HAS_IPV6__ */\n#if defined __UCLIBC_HAS_IPV4__\n\t\t\t\telse {\n\t\t\t\t\tc = inet_ntop(AF_INET, (const void *)\n\t\t\t\t\t\t&(((const struct sockaddr_in *) sa)->sin_addr),\n\t\t\t\t\t\thost, hostlen);\n\t\t\t\t}\n#endif\n\t\t\t\tif (c == NULL) {\n\t\t\t\t\terrno = serrno;\n\t\t\t\t\treturn EAI_SYSTEM;\n\t\t\t\t}\n\t\t\t\tok = 1;\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase AF_LOCAL:\n\t\t\tif (!(flags & NI_NUMERICHOST)) {\n\t\t\t\tstruct utsname utsname;\n\n\t\t\t\tif (!uname(&utsname)) {\n\t\t\t\t\tstrncpy(host, utsname.nodename, hostlen);\n\t\t\t\t\tbreak;\n\t\t\t\t};\n\t\t\t};\n\n\t\t\tif (flags & NI_NAMEREQD) {\n\t\t\t\terrno = serrno;\n\t\t\t\treturn EAI_NONAME;\n\t\t\t}\n\n\t\t\tstrncpy(host, \"localhost\", hostlen);\n\t\t\tbreak;\n/* Already checked above\n\t\tdefault:\n\t\t\treturn EAI_FAMILY;\n*/\n\t}\n\n\tif (serv && (servlen > 0)) {\n\t\tif (sa->sa_family == AF_LOCAL) {\n\t\t\tstrncpy(serv, ((const struct sockaddr_un *) sa)->sun_path, servlen);\n\t\t} else { /* AF_INET || AF_INET6 */\n\t\t\tif (!(flags & NI_NUMERICSERV)) {\n\t\t\t\tstruct servent *s;\n\t\t\t\ts = getservbyport(((const struct sockaddr_in *) sa)->sin_port,\n\t\t\t\t      ((flags & NI_DGRAM) ? \"udp\" : \"tcp\"));\n\t\t\t\tif (s) {\n\t\t\t\t\tstrncpy(serv, s->s_name, servlen);\n\t\t\t\t\tgoto DONE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsnprintf(serv, servlen, \"%d\",\n\t\t\t\tntohs(((const struct sockaddr_in *) sa)->sin_port));\n\t\t}\n\t}\nDONE:\n\tif (host && (hostlen > 0))\n\t\thost[hostlen-1] = 0;\n\tif (serv && (servlen > 0))\n\t\tserv[servlen-1] = 0;\n\terrno = serrno;\n\treturn 0;\n}\nlibc_hidden_def(getnameinfo)\n#endif /* L_getnameinfo */\n\n\n#ifdef L_gethostbyname_r\n\n/* Bug 671 says:\n * \"uClibc resolver's gethostbyname does not return the requested name\n * as an alias, but instead returns the canonical name. glibc's\n * gethostbyname has a similar bug where it returns the requested name\n * with the search domain name appended (to make a FQDN) as an alias,\n * but not the original name itself. Both contradict POSIX, which says\n * that the name argument passed to gethostbyname must be in the alias list\"\n * This is fixed now, and we differ from glibc:\n *\n * $ ./gethostbyname_uclibc wer.google.com\n * h_name:'c13-ss-2-lb.cnet.com'\n * h_length:4\n * h_addrtype:2 AF_INET\n * alias:'wer.google.com' <===\n * addr: 0x4174efd8 '216.239.116.65'\n *\n * $ ./gethostbyname_glibc wer.google.com\n * h_name:'c13-ss-2-lb.cnet.com'\n * h_length:4\n * h_addrtype:2 AF_INET\n * alias:'wer.google.com.com' <===\n * addr:'216.239.116.65'\n *\n * When examples were run, /etc/resolv.conf contained \"search com\" line.\n */\nint gethostbyname_r(const char *name,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n\tstruct in_addr **addr_list;\n\tchar **alias;\n\tchar *alias0;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint wrong_af = 0;\n\n\t*result = NULL;\n\tif (!name)\n\t\treturn EINVAL;\n\n\t/* do /etc/hosts first */\n\t{\n\t\tint old_errno = errno;  /* save the old errno and reset errno */\n\t\t__set_errno(0);         /* to check for missing /etc/hosts. */\n\t\ti = __get_hosts_byname_r(name, AF_INET, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\t\tif (i == NETDB_SUCCESS) {\n\t\t\t__set_errno(old_errno);\n\t\t\treturn i;\n\t\t}\n\t\tswitch (*h_errnop) {\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\twrong_af = (i == TRY_AGAIN);\n\t\t\tcase NO_ADDRESS:\n\t\t\t\tbreak;\n\t\t\tcase NETDB_INTERNAL:\n\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else fall through */\n\t\t\tdefault:\n\t\t\t\treturn i;\n\t\t}\n\t\t__set_errno(old_errno);\n\t}\n\n\tDPRINTF(\"Nothing found in /etc/hosts\\n\");\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* prepare future h_aliases[0] */\n\ti = strlen(name) + 1;\n\tif ((ssize_t)buflen <= i)\n\t\treturn ERANGE;\n\tmemcpy(buf, name, i); /* paranoia: name might change */\n\talias0 = buf;\n\tbuf += i;\n\tbuflen -= i;\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[2];\n\t * struct in_addr* addr_list[NN+1];\n\t * struct in_addr* in[NN];\n\t */\n\talias = (char **)buf;\n\tbuf += sizeof(alias[0]) * 2;\n\tbuflen -= sizeof(alias[0]) * 2;\n\taddr_list = (struct in_addr **)buf;\n\t/* buflen may be < 0, must do signed compare */\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\n\t/* we store only one \"alias\" - the name itself */\n\talias[0] = alias0;\n\talias[1] = NULL;\n\n\t/* maybe it is already an address? */\n\t{\n\t\tstruct in_addr *in = (struct in_addr *)(buf + sizeof(addr_list[0]) * 2);\n\t\tif (inet_aton(name, in)) {\n\t\t\taddr_list[0] = in;\n\t\t\taddr_list[1] = NULL;\n\t\t\tresult_buf->h_name = alias0;\n\t\t\tresult_buf->h_aliases = alias;\n\t\t\tresult_buf->h_addrtype = AF_INET;\n\t\t\tresult_buf->h_length = sizeof(struct in_addr);\n\t\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t\t*result = result_buf;\n\t\t\t*h_errnop = NETDB_SUCCESS;\n\t\t\treturn NETDB_SUCCESS;\n\t\t}\n\t}\n\n\t/* what if /etc/hosts has it but it's not IPv4?\n\t * F.e. \"::1 localhost6\". We don't do DNS query for such hosts -\n\t * \"ping localhost6\" should be fast even if DNS server is down! */\n\tif (wrong_af) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\treturn TRY_AGAIN;\n\t}\n\n\t/* talk to DNS servers */\n\ta.buf = buf;\n\t/* take into account that at least one address will be there,\n\t * we'll need space for one in_addr + two addr_list[] elems */\n\ta.buflen = buflen - ((sizeof(addr_list[0]) * 2 + sizeof(struct in_addr)));\n\ta.add_count = 0;\n\tpacket_len = __dns_lookup(name, T_A, &packet, &a);\n\tif (packet_len < 0) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\tDPRINTF(\"__dns_lookup returned < 0\\n\");\n\t\treturn TRY_AGAIN;\n\t}\n\n\tif (a.atype == T_A) { /* ADDRESS */\n\t\t/* we need space for addr_list[] and one IPv4 address */\n\t\t/* + 1 accounting for 1st addr (it's in a.rdata),\n\t\t * another + 1 for NULL in last addr_list[]: */\n\t\tint need_bytes = sizeof(addr_list[0]) * (a.add_count + 1 + 1)\n\t\t\t\t/* for 1st addr (it's in a.rdata): */\n\t\t\t\t+ sizeof(struct in_addr);\n\t\t/* how many bytes will 2nd and following addresses take? */\n\t\tint ips_len = a.add_count * a.rdlength;\n\n\t\tbuflen -= (need_bytes + ips_len);\n\t\tif ((ssize_t)buflen < 0) {\n\t\t\tDPRINTF(\"buffer too small for all addresses\\n\");\n\t\t\t/* *h_errnop = NETDB_INTERNAL; - already is */\n\t\t\ti = ERANGE;\n\t\t\tgoto free_and_ret;\n\t\t}\n\n\t\t/* if there are additional addresses in buf,\n\t\t * move them forward so that they are not destroyed */\n\t\tDPRINTF(\"a.add_count:%d a.rdlength:%d a.rdata:%p\\n\", a.add_count, a.rdlength, a.rdata);\n\t\tmemmove(buf + need_bytes, buf, ips_len);\n\n\t\t/* 1st address is in a.rdata, insert it  */\n\t\tbuf += need_bytes - sizeof(struct in_addr);\n\t\tmemcpy(buf, a.rdata, sizeof(struct in_addr));\n\n\t\t/* fill addr_list[] */\n\t\tfor (i = 0; i <= a.add_count; i++) {\n\t\t\taddr_list[i] = (struct in_addr*)buf;\n\t\t\tbuf += sizeof(struct in_addr);\n\t\t}\n\t\taddr_list[i] = NULL;\n\n\t\t/* if we have enough space, we can report \"better\" name\n\t\t * (it may contain search domains attached by __dns_lookup,\n\t\t * or CNAME of the host if it is different from the name\n\t\t * we used to find it) */\n\t\tif (a.dotted && buflen > strlen(a.dotted)) {\n\t\t\tstrcpy(buf, a.dotted);\n\t\t\talias0 = buf;\n\t\t}\n\n\t\tresult_buf->h_name = alias0;\n\t\tresult_buf->h_aliases = alias;\n\t\tresult_buf->h_addrtype = AF_INET;\n\t\tresult_buf->h_length = sizeof(struct in_addr);\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\ti = NETDB_SUCCESS;\n\t\tgoto free_and_ret;\n\t}\n\n\t*h_errnop = HOST_NOT_FOUND;\n\t__set_h_errno(HOST_NOT_FOUND);\n\ti = TRY_AGAIN;\n\n free_and_ret:\n\tfree(a.dotted);\n\tfree(packet);\n\treturn i;\n}\nlibc_hidden_def(gethostbyname_r)\n#endif /* L_gethostbyname_r */\n\n\n#ifdef L_gethostbyname2_r\n\nint gethostbyname2_r(const char *name,\n\t\tint family,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf,\n\t\tsize_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n{\n#ifndef __UCLIBC_HAS_IPV6__\n\treturn family == (AF_INET)\n\t\t? gethostbyname_r(name, result_buf, buf, buflen, result, h_errnop)\n\t\t: HOST_NOT_FOUND;\n#else\n\tstruct in6_addr **addr_list;\n\tchar **alias;\n\tchar *alias0;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint wrong_af = 0;\n\n\tif (family == AF_INET)\n\t\treturn gethostbyname_r(name, result_buf, buf, buflen, result, h_errnop);\n\n\t*result = NULL;\n\tif (family != AF_INET6)\n\t\treturn EINVAL;\n\n\tif (!name)\n\t\treturn EINVAL;\n\n\t/* do /etc/hosts first */\n\t{\n\t\tint old_errno = errno;  /* save the old errno and reset errno */\n\t\t__set_errno(0);         /* to check for missing /etc/hosts. */\n\t\ti = __get_hosts_byname_r(name, AF_INET6 /*family*/, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\t\tif (i == NETDB_SUCCESS) {\n\t\t\t__set_errno(old_errno);\n\t\t\treturn i;\n\t\t}\n\t\tswitch (*h_errnop) {\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\twrong_af = (i == TRY_AGAIN);\n\t\t\tcase NO_ADDRESS:\n\t\t\t\tbreak;\n\t\t\tcase NETDB_INTERNAL:\n\t\t\t\tif (errno == ENOENT) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* else fall through */\n\t\t\tdefault:\n\t\t\t\treturn i;\n\t\t}\n\t\t__set_errno(old_errno);\n\t}\n\n\tDPRINTF(\"Nothing found in /etc/hosts\\n\");\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* prepare future h_aliases[0] */\n\ti = strlen(name) + 1;\n\tif ((ssize_t)buflen <= i)\n\t\treturn ERANGE;\n\tmemcpy(buf, name, i); /* paranoia: name might change */\n\talias0 = buf;\n\tbuf += i;\n\tbuflen -= i;\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[2];\n\t * struct in6_addr* addr_list[NN+1];\n\t * struct in6_addr* in[NN];\n\t */\n\talias = (char **)buf;\n\tbuf += sizeof(alias[0]) * 2;\n\tbuflen -= sizeof(alias[0]) * 2;\n\taddr_list = (struct in6_addr **)buf;\n\t/* buflen may be < 0, must do signed compare */\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\n\t/* we store only one \"alias\" - the name itself */\n\talias[0] = alias0;\n\talias[1] = NULL;\n\n\t/* maybe it is already an address? */\n\t{\n\t\tstruct in6_addr *in = (struct in6_addr *)(buf + sizeof(addr_list[0]) * 2);\n\t\tif (inet_pton(AF_INET6, name, in)) {\n\t\t\taddr_list[0] = in;\n\t\t\taddr_list[1] = NULL;\n\t\t\tresult_buf->h_name = alias0;\n\t\t\tresult_buf->h_aliases = alias;\n\t\t\tresult_buf->h_addrtype = AF_INET6;\n\t\t\tresult_buf->h_length = sizeof(struct in6_addr);\n\t\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t\t*result = result_buf;\n\t\t\t*h_errnop = NETDB_SUCCESS;\n\t\t\treturn NETDB_SUCCESS;\n\t\t}\n\t}\n\n\t/* what if /etc/hosts has it but it's not IPv6?\n\t * F.e. \"127.0.0.1 localhost\". We don't do DNS query for such hosts -\n\t * \"ping localhost\" should be fast even if DNS server is down! */\n\tif (wrong_af) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\treturn TRY_AGAIN;\n\t}\n\n\t/* talk to DNS servers */\n\ta.buf = buf;\n\t/* take into account that at least one address will be there,\n\t * we'll need space of one in6_addr + two addr_list[] elems */\n\ta.buflen = buflen - ((sizeof(addr_list[0]) * 2 + sizeof(struct in6_addr)));\n\ta.add_count = 0;\n\tpacket_len = __dns_lookup(name, T_AAAA, &packet, &a);\n\tif (packet_len < 0) {\n\t\t*h_errnop = HOST_NOT_FOUND;\n\t\tDPRINTF(\"__dns_lookup returned < 0\\n\");\n\t\treturn TRY_AGAIN;\n\t}\n\n\tif (a.atype == T_AAAA) { /* ADDRESS */\n\t\t/* we need space for addr_list[] and one IPv6 address */\n\t\t/* + 1 accounting for 1st addr (it's in a.rdata),\n\t\t * another + 1 for NULL in last addr_list[]: */\n\t\tint need_bytes = sizeof(addr_list[0]) * (a.add_count + 1 + 1)\n\t\t\t\t/* for 1st addr (it's in a.rdata): */\n\t\t\t\t+ sizeof(struct in6_addr);\n\t\t/* how many bytes will 2nd and following addresses take? */\n\t\tint ips_len = a.add_count * a.rdlength;\n\n\t\tbuflen -= (need_bytes + ips_len);\n\t\tif ((ssize_t)buflen < 0) {\n\t\t\tDPRINTF(\"buffer too small for all addresses\\n\");\n\t\t\t/* *h_errnop = NETDB_INTERNAL; - already is */\n\t\t\ti = ERANGE;\n\t\t\tgoto free_and_ret;\n\t\t}\n\n\t\t/* if there are additional addresses in buf,\n\t\t * move them forward so that they are not destroyed */\n\t\tDPRINTF(\"a.add_count:%d a.rdlength:%d a.rdata:%p\\n\", a.add_count, a.rdlength, a.rdata);\n\t\tmemmove(buf + need_bytes, buf, ips_len);\n\n\t\t/* 1st address is in a.rdata, insert it  */\n\t\tbuf += need_bytes - sizeof(struct in6_addr);\n\t\tmemcpy(buf, a.rdata, sizeof(struct in6_addr));\n\n\t\t/* fill addr_list[] */\n\t\tfor (i = 0; i <= a.add_count; i++) {\n\t\t\taddr_list[i] = (struct in6_addr*)buf;\n\t\t\tbuf += sizeof(struct in6_addr);\n\t\t}\n\t\taddr_list[i] = NULL;\n\n\t\t/* if we have enough space, we can report \"better\" name\n\t\t * (it may contain search domains attached by __dns_lookup,\n\t\t * or CNAME of the host if it is different from the name\n\t\t * we used to find it) */\n\t\tif (a.dotted && buflen > strlen(a.dotted)) {\n\t\t\tstrcpy(buf, a.dotted);\n\t\t\talias0 = buf;\n\t\t}\n\n\t\tresult_buf->h_name = alias0;\n\t\tresult_buf->h_aliases = alias;\n\t\tresult_buf->h_addrtype = AF_INET6;\n\t\tresult_buf->h_length = sizeof(struct in6_addr);\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\ti = NETDB_SUCCESS;\n\t\tgoto free_and_ret;\n\t}\n\n\t*h_errnop = HOST_NOT_FOUND;\n\t__set_h_errno(HOST_NOT_FOUND);\n\ti = TRY_AGAIN;\n\n free_and_ret:\n\tfree(a.dotted);\n\tfree(packet);\n\treturn i;\n#endif /* __UCLIBC_HAS_IPV6__ */\n}\nlibc_hidden_def(gethostbyname2_r)\n#endif /* L_gethostbyname2_r */\n\n\n#ifdef L_gethostbyaddr_r\n\nint gethostbyaddr_r(const void *addr, socklen_t addrlen,\n\t\tint type,\n\t\tstruct hostent *result_buf,\n\t\tchar *buf, size_t buflen,\n\t\tstruct hostent **result,\n\t\tint *h_errnop)\n\n{\n\tstruct in_addr *in;\n\tstruct in_addr **addr_list;\n\tchar **alias;\n\tunsigned char *packet;\n\tstruct resolv_answer a;\n\tint i;\n\tint packet_len;\n\tint nest = 0;\n\n\t*result = NULL;\n\tif (!addr)\n\t\treturn EINVAL;\n\n\tswitch (type) {\n#ifdef __UCLIBC_HAS_IPV4__\n\t\tcase AF_INET:\n\t\t\tif (addrlen != sizeof(struct in_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tcase AF_INET6:\n\t\t\tif (addrlen != sizeof(struct in6_addr))\n\t\t\t\treturn EINVAL;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\treturn EINVAL;\n\t}\n\n\t/* do /etc/hosts first */\n\ti = __get_hosts_byaddr_r(addr, addrlen, type, result_buf,\n\t\t\t\tbuf, buflen, result, h_errnop);\n\tif (i == 0)\n\t\treturn i;\n\tswitch (*h_errnop) {\n\t\tcase HOST_NOT_FOUND:\n\t\tcase NO_ADDRESS:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn i;\n\t}\n\n\t*h_errnop = NETDB_INTERNAL;\n\n\t/* make sure pointer is aligned */\n\ti = ALIGN_BUFFER_OFFSET(buf);\n\tbuf += i;\n\tbuflen -= i;\n\t/* Layout in buf:\n\t * char *alias[ALIAS_DIM];\n\t * struct in[6]_addr* addr_list[2];\n\t * struct in[6]_addr in;\n\t * char scratch_buffer[256+];\n\t */\n#define in6 ((struct in6_addr *)in)\n\talias = (char **)buf;\n\taddr_list = (struct in_addr**)buf;\n\tbuf += sizeof(*addr_list) * 2;\n\tbuflen -= sizeof(*addr_list) * 2;\n\tin = (struct in_addr*)buf;\n#ifndef __UCLIBC_HAS_IPV6__\n\tbuf += sizeof(*in);\n\tbuflen -= sizeof(*in);\n\tif (addrlen > sizeof(*in))\n\t\treturn ERANGE;\n#else\n\tbuf += sizeof(*in6);\n\tbuflen -= sizeof(*in6);\n\tif (addrlen > sizeof(*in6))\n\t\treturn ERANGE;\n#endif\n\tif ((ssize_t)buflen < 256)\n\t\treturn ERANGE;\n\talias[0] = buf;\n\talias[1] = NULL;\n\taddr_list[0] = in;\n\taddr_list[1] = NULL;\n\tmemcpy(in, addr, addrlen);\n\n\tif (0) /* nothing */;\n#ifdef __UCLIBC_HAS_IPV4__\n\telse IF_HAS_BOTH(if (type == AF_INET)) {\n\t\tunsigned char *tp = (unsigned char *)addr;\n\t\tsprintf(buf, \"%u.%u.%u.%u.in-addr.arpa\",\n\t\t\t\ttp[3], tp[2], tp[1], tp[0]);\n\t}\n#endif\n#ifdef __UCLIBC_HAS_IPV6__\n\telse {\n\t\tchar *dst = buf;\n\t\tunsigned char *tp = (unsigned char *)addr + addrlen - 1;\n\t\tdo {\n\t\t\tdst += sprintf(dst, \"%x.%x.\", tp[0] & 0xf, tp[0] >> 4);\n\t\t\ttp--;\n\t\t} while (tp >= (unsigned char *)addr);\n\t\tstrcpy(dst, \"ip6.arpa\");\n\t}\n#endif\n\n\tmemset(&a, '\\0', sizeof(a));\n\tfor (;;) {\n/* Hmm why we memset(a) to zeros only once? */\n\t\tpacket_len = __dns_lookup(buf, T_PTR, &packet, &a);\n\t\tif (packet_len < 0) {\n\t\t\t*h_errnop = HOST_NOT_FOUND;\n\t\t\treturn TRY_AGAIN;\n\t\t}\n\n\t\tstrncpy(buf, a.dotted, buflen);\n\t\tfree(a.dotted);\n\t\tif (a.atype != T_CNAME)\n\t\t\tbreak;\n\n\t\tDPRINTF(\"Got a CNAME in gethostbyaddr()\\n\");\n\t\tif (++nest > MAX_RECURSE) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\t/* Decode CNAME into buf, feed it to __dns_lookup() again */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tif (i < 0 || __hnbad(buf)) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (a.atype == T_PTR) {\t/* ADDRESS */\n\t\ti = __decode_dotted(packet, a.rdoffset, packet_len, buf, buflen);\n\t\tfree(packet);\n\t\tif (__hnbad(buf)) {\n\t\t\t*h_errnop = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tresult_buf->h_name = buf;\n\t\tresult_buf->h_addrtype = type;\n\t\tresult_buf->h_length = addrlen;\n\t\tresult_buf->h_addr_list = (char **) addr_list;\n\t\tresult_buf->h_aliases = alias;\n\t\t*result = result_buf;\n\t\t*h_errnop = NETDB_SUCCESS;\n\t\treturn NETDB_SUCCESS;\n\t}\n\n\tfree(packet);\n\t*h_errnop = NO_ADDRESS;\n\treturn TRY_AGAIN;\n#undef in6\n}\nlibc_hidden_def(gethostbyaddr_r)\n#endif /* L_gethostbyaddr_r */\n\n\n#ifdef L_gethostent_r\n\n__UCLIBC_MUTEX_STATIC(mylock, PTHREAD_MUTEX_INITIALIZER);\n\nstatic parser_t *hostp = NULL;\nstatic smallint host_stayopen;\n\nvoid endhostent_unlocked(void)\n{\n\tif (hostp) {\n\t\tconfig_close(hostp);\n\t\thostp = NULL;\n\t}\n\thost_stayopen = 0;\n}\nvoid endhostent(void)\n{\n\t__UCLIBC_MUTEX_LOCK(mylock);\n\tendhostent_unlocked();\n\t__UCLIBC_MUTEX_UNLOCK(mylock);\n}\n\nvoid sethostent(int stay_open)\n{\n\t__UCLIBC_MUTEX_LOCK(mylock);\n\tif (stay_open)\n\t\thost_stayopen = 1;\n\t__UCLIBC_MUTEX_UNLOCK(mylock);\n}\n\nint gethostent_r(struct hostent *result_buf, char *buf, size_t buflen,\n\tstruct hostent **result, int *h_errnop)\n{\n\tint ret;\n\n\t__UCLIBC_MUTEX_LOCK(mylock);\n\tif (hostp == NULL) {\n\t\thostp = __open_etc_hosts();\n\t\tif (hostp == NULL) {\n\t\t\t*result = NULL;\n\t\t\tret = TRY_AGAIN;\n\t\t\tgoto DONE;\n\t\t}\n\t}\n\n\tret = __read_etc_hosts_r(hostp, NULL, AF_INET, GETHOSTENT,\n\t\t   result_buf, buf, buflen, result, h_errnop);\n\tif (!host_stayopen)\n\t\tendhostent_unlocked();\nDONE:\n\t__UCLIBC_MUTEX_UNLOCK(mylock);\n\treturn ret;\n}\nlibc_hidden_def(gethostent_r)\n#endif /* L_gethostent_r */\n\n\n#ifndef __UCLIBC_HAS_IPV6__\n #define GETXX_BUFSZ \t(sizeof(struct in_addr) + sizeof(struct in_addr *) * 2 + \\\n\t\t\t/*sizeof(char *)*ALIAS_DIM */+ 384/*namebuffer*/ + 32/* margin */)\n#else\n #define GETXX_BUFSZ \t(sizeof(struct in6_addr) + sizeof(struct in6_addr *) * 2 + \\\n\t\t\t/*sizeof(char *)*ALIAS_DIM */+ 384/*namebuffer*/ + 32/* margin */)\n#endif /* __UCLIBC_HAS_IPV6__ */\n\n#define __INIT_GETXX_BUF(sz)\t\t\t\t\t\\\n\tif (buf == NULL)\t\t\t\t\t\\\n\t\tbuf = (char *)__uc_malloc((sz));\n\n#ifdef L_gethostent\n\nstruct hostent *gethostent(void)\n{\n\tstatic struct hostent hoste;\n\tstatic char *buf = NULL;\n\tstruct hostent *host = NULL;\n#ifndef __UCLIBC_HAS_IPV6__\n #define HOSTENT_BUFSZ\t(sizeof(struct in_addr) + sizeof(struct in_addr *) * 2 + \\\n\t\t\tsizeof(char *)*ALIAS_DIM + BUFSZ /*namebuffer*/ + 2 /* margin */)\n#else\n #define HOSTENT_BUFSZ\t(sizeof(struct in6_addr) + sizeof(struct in6_addr *) * 2 + \\\n\t\t\tsizeof(char *)*ALIAS_DIM + BUFSZ /*namebuffer*/ + 2 /* margin */)\n#endif /* __UCLIBC_HAS_IPV6__ */\n\n\t__INIT_GETXX_BUF(HOSTENT_BUFSZ);\n\tgethostent_r(&hoste, buf, HOSTENT_BUFSZ, &host, &h_errno);\n\treturn host;\n}\n#undef HOSTENT_BUFSZ\n#endif /* L_gethostent */\n\n\n#ifdef L_gethostbyname2\n\nstruct hostent *gethostbyname2(const char *name, int family)\n{\n\tstatic struct hostent hoste;\n\tstatic char *buf = NULL;\n\tstruct hostent *hp;\n\n\t__INIT_GETXX_BUF(GETXX_BUFSZ);\n#ifndef __UCLIBC_HAS_IPV6__\n\tif (family != AF_INET)\n\t\treturn (struct hostent*)NULL;\n\tgethostbyname_r(name, &hoste, buf, GETXX_BUFSZ, &hp, &h_errno);\n#else\n\tgethostbyname2_r(name, family, &hoste, buf, GETXX_BUFSZ, &hp, &h_errno);\n#endif /* __UCLIBC_HAS_IPV6__ */\n\n\treturn hp;\n}\nlibc_hidden_def(gethostbyname2)\n#endif /* L_gethostbyname2 */\n\n\n#ifdef L_gethostbyname\n\nstruct hostent *gethostbyname(const char *name)\n{\n\treturn gethostbyname2(name, AF_INET);\n}\nlibc_hidden_def(gethostbyname)\n#endif /* L_gethostbyname */\n\n\n#ifdef L_gethostbyaddr\n\nstruct hostent *gethostbyaddr(const void *addr, socklen_t len, int type)\n{\n\tstatic struct hostent hoste;\n\tstatic char *buf = NULL;\n\tstruct hostent *hp;\n\n\t__INIT_GETXX_BUF(GETXX_BUFSZ);\n\tgethostbyaddr_r(addr, len, type, &hoste, buf, GETXX_BUFSZ, &hp, &h_errno);\n\treturn hp;\n}\nlibc_hidden_def(gethostbyaddr)\n#endif /* L_gethostbyaddr */\n\n\n#ifdef L_res_comp\n\n/*\n * Expand compressed domain name 'comp_dn' to full domain name.\n * 'msg' is a pointer to the begining of the message,\n * 'eomorig' points to the first location after the message,\n * 'exp_dn' is a pointer to a buffer of size 'length' for the result.\n * Return size of compressed name or -1 if there was an error.\n */\nint dn_expand(const u_char *msg, const u_char *eom, const u_char *src,\n\t\t\t\tchar *dst, int dstsiz)\n{\n\tint n = ns_name_uncompress(msg, eom, src, dst, (size_t)dstsiz);\n\n\tif (n > 0 && dst[0] == '.')\n\t\tdst[0] = '\\0';\n\treturn n;\n}\nlibc_hidden_def(dn_expand)\n\n/*\n * Pack domain name 'exp_dn' in presentation form into 'comp_dn'.\n * Return the size of the compressed name or -1.\n * 'length' is the size of the array pointed to by 'comp_dn'.\n */\nint\ndn_comp(const char *src, u_char *dst, int dstsiz,\n\t\tu_char **dnptrs, u_char **lastdnptr)\n{\n\treturn ns_name_compress(src, dst, (size_t) dstsiz,\n\t\t\t(const u_char **) dnptrs,\n\t\t\t(const u_char **) lastdnptr);\n}\nlibc_hidden_def(dn_comp)\n#endif /* L_res_comp */\n\n\n#ifdef L_ns_name\n\n/* Thinking in noninternationalized USASCII (per the DNS spec),\n * is this character visible and not a space when printed ?\n */\nstatic int printable(int ch)\n{\n\treturn (ch > 0x20 && ch < 0x7f);\n}\n/* Thinking in noninternationalized USASCII (per the DNS spec),\n * is this characted special (\"in need of quoting\") ?\n */\nstatic int special(int ch)\n{\n\tswitch (ch) {\n\t\tcase 0x22: /* '\"' */\n\t\tcase 0x2E: /* '.' */\n\t\tcase 0x3B: /* ';' */\n\t\tcase 0x5C: /* '\\\\' */\n\t\t\t/* Special modifiers in zone files. */\n\t\tcase 0x40: /* '@' */\n\t\tcase 0x24: /* '$' */\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn 0;\n\t}\n}\n\n/*\n * ns_name_uncompress(msg, eom, src, dst, dstsiz)\n *      Expand compressed domain name to presentation format.\n * return:\n *      Number of bytes read out of `src', or -1 (with errno set).\n * note:\n *      Root domain returns as \".\" not \"\".\n */\nint ns_name_uncompress(const u_char *msg, const u_char *eom,\n\t\tconst u_char *src, char *dst, size_t dstsiz)\n{\n\tu_char tmp[NS_MAXCDNAME];\n\tint n;\n\n\tn = ns_name_unpack(msg, eom, src, tmp, sizeof tmp);\n\tif (n == -1)\n\t\treturn -1;\n\tif (ns_name_ntop(tmp, dst, dstsiz) == -1)\n\t\treturn -1;\n\treturn n;\n}\nlibc_hidden_def(ns_name_uncompress)\n\n/*\n * ns_name_ntop(src, dst, dstsiz)\n *      Convert an encoded domain name to printable ascii as per RFC1035.\n * return:\n *      Number of bytes written to buffer, or -1 (with errno set)\n * notes:\n *      The root is returned as \".\"\n *      All other domains are returned in non absolute form\n */\nint ns_name_ntop(const u_char *src, char *dst, size_t dstsiz)\n{\n\tconst u_char *cp;\n\tchar *dn, *eom;\n\tu_char c;\n\tu_int n;\n\n\tcp = src;\n\tdn = dst;\n\teom = dst + dstsiz;\n\n\twhile ((n = *cp++) != 0) {\n\t\tif ((n & NS_CMPRSFLGS) != 0) {\n\t\t\t/* Some kind of compression pointer. */\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\tif (dn != dst) {\n\t\t\tif (dn >= eom) {\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t*dn++ = '.';\n\t\t}\n\t\tif (dn + n >= eom) {\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\tfor (; n > 0; n--) {\n\t\t\tc = *cp++;\n\t\t\tif (special(c)) {\n\t\t\t\tif (dn + 1 >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = '\\\\';\n\t\t\t\t*dn++ = (char)c;\n\t\t\t} else if (!printable(c)) {\n\t\t\t\tif (dn + 3 >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = '\\\\';\n\t\t\t\t*dn++ = \"0123456789\"[c / 100];\n\t\t\t\tc = c % 100;\n\t\t\t\t*dn++ = \"0123456789\"[c / 10];\n\t\t\t\t*dn++ = \"0123456789\"[c % 10];\n\t\t\t} else {\n\t\t\t\tif (dn >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\t*dn++ = (char)c;\n\t\t\t}\n\t\t}\n\t}\n\tif (dn == dst) {\n\t\tif (dn >= eom) {\n\t\t\t__set_errno(EMSGSIZE);\n\t\t\treturn -1;\n\t\t}\n\t\t*dn++ = '.';\n\t}\n\tif (dn >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t*dn++ = '\\0';\n\treturn (dn - dst);\n}\nlibc_hidden_def(ns_name_ntop)\n\nstatic int encode_bitstring(const char **bp, const char *end,\n\t\t\t\t\t\t\tunsigned char **labelp,\n\t\t\t\t\t\t\tunsigned char ** dst,\n\t\t\t\t\t\t\tunsigned const char *eom)\n{\n\tint afterslash = 0;\n\tconst char *cp = *bp;\n\tunsigned char *tp;\n\tconst char *beg_blen;\n\tint value = 0, count = 0, tbcount = 0, blen = 0;\n\n\tbeg_blen = NULL;\n\n\t/* a bitstring must contain at least 2 characters */\n\tif (end - cp < 2)\n\t\treturn EINVAL;\n\n\t/* XXX: currently, only hex strings are supported */\n\tif (*cp++ != 'x')\n\t\treturn EINVAL;\n\tif (!isxdigit((unsigned char) *cp)) /*%< reject '\\[x/BLEN]' */\n\t\treturn EINVAL;\n\n\tfor (tp = *dst + 1; cp < end && tp < eom; cp++) {\n\t\tunsigned char c = *cp;\n\n\t\tswitch (c) {\n\t\tcase ']':       /*%< end of the bitstring */\n\t\t\tif (afterslash) {\n\t\t\t\tchar *end_blen;\n\t\t\t\tif (beg_blen == NULL)\n\t\t\t\t\treturn EINVAL;\n\t\t\t\tblen = (int)strtol(beg_blen, &end_blen, 10);\n\t\t\t\tif (*end_blen != ']')\n\t\t\t\t\treturn EINVAL;\n\t\t\t}\n\t\t\tif (count)\n\t\t\t\t*tp++ = ((value << 4) & 0xff);\n\t\t\tcp++;   /*%< skip ']' */\n\t\t\tgoto done;\n\t\tcase '/':\n\t\t\tafterslash = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (afterslash) {\n\t\t\t\tif (!__isdigit_char(c))\n\t\t\t\t\treturn EINVAL;\n\t\t\t\tif (beg_blen == NULL) {\n\t\t\t\t\tif (c == '0') {\n\t\t\t\t\t\t/* blen never begings with 0 */\n\t\t\t\t\t\treturn EINVAL;\n\t\t\t\t\t}\n\t\t\t\t\tbeg_blen = cp;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (!__isdigit_char(c)) {\n\t\t\t\t\tc = c | 0x20; /* lowercase */\n\t\t\t\t\tc = c - 'a';\n\t\t\t\t\tif (c > 5) /* not a-f? */\n\t\t\t\t\t\treturn EINVAL;\n\t\t\t\t\tc += 10 + '0';\n\t\t\t\t}\n\t\t\t\tvalue <<= 4;\n\t\t\t\tvalue += (c - '0');\n\t\t\t\tcount += 4;\n\t\t\t\ttbcount += 4;\n\t\t\t\tif (tbcount > 256)\n\t\t\t\t\treturn EINVAL;\n\t\t\t\tif (count == 8) {\n\t\t\t\t\t*tp++ = value;\n\t\t\t\t\tcount = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n  done:\n\tif (cp >= end || tp >= eom)\n\t\treturn EMSGSIZE;\n\n\t/*\n\t * bit length validation:\n\t * If a <length> is present, the number of digits in the <bit-data>\n\t * MUST be just sufficient to contain the number of bits specified\n\t * by the <length>. If there are insignificant bits in a final\n\t * hexadecimal or octal digit, they MUST be zero.\n\t * RFC2673, Section 3.2.\n\t */\n\tif (blen > 0) {\n\t\tint traillen;\n\n\t\tif (((blen + 3) & ~3) != tbcount)\n\t\t\treturn EINVAL;\n\t\ttraillen = tbcount - blen; /*%< between 0 and 3 */\n\t\tif (((value << (8 - traillen)) & 0xff) != 0)\n\t\t\treturn EINVAL;\n\t}\n\telse\n\t\tblen = tbcount;\n\tif (blen == 256)\n\t\tblen = 0;\n\n\t/* encode the type and the significant bit fields */\n\t**labelp = DNS_LABELTYPE_BITSTRING;\n\t**dst = blen;\n\n\t*bp = cp;\n\t*dst = tp;\n\n\treturn 0;\n}\n\nint ns_name_pton(const char *src, u_char *dst, size_t dstsiz)\n{\n\tstatic const char digits[] = \"0123456789\";\n\tu_char *label, *bp, *eom;\n\tint c, n, escaped, e = 0;\n\tchar *cp;\n\n\tescaped = 0;\n\tbp = dst;\n\teom = dst + dstsiz;\n\tlabel = bp++;\n\n\twhile ((c = *src++) != 0) {\n\t\tif (escaped) {\n\t\t\tif (c == '[') { /*%< start a bit string label */\n\t\t\t\tcp = strchr(src, ']');\n\t\t\t\tif (cp == NULL) {\n\t\t\t\t\terrno = EINVAL; /*%< ??? */\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\te = encode_bitstring(&src, cp + 2,\n\t\t\t\t\t\t\t &label, &bp, eom);\n\t\t\t\tif (e != 0) {\n\t\t\t\t\terrno = e;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tescaped = 0;\n\t\t\t\tlabel = bp++;\n\t\t\t\tc = *src++;\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tgoto done;\n\t\t\t\tif (c != '.') {\n\t\t\t\t\terrno = EINVAL;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcp = strchr(digits, c);\n\t\t\tif (cp != NULL) {\n\t\t\t\tn = (cp - digits) * 100;\n\t\t\t\tc = *src++;\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tcp = strchr(digits, c);\n\t\t\t\tif (cp == NULL)\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tn += (cp - digits) * 10;\n\t\t\t\tc = *src++;\n\t\t\t\tif (c == '\\0')\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tcp = strchr(digits, c);\n\t\t\t\tif (cp == NULL)\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tn += (cp - digits);\n\t\t\t\tif (n > 255)\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\tc = n;\n\t\t\t}\n\t\t\tescaped = 0;\n\t\t} else if (c == '\\\\') {\n\t\t\tescaped = 1;\n\t\t\tcontinue;\n\t\t} else if (c == '.') {\n\t\t\tc = (bp - label - 1);\n\t\t\tif ((c & NS_CMPRSFLGS) != 0) {  /*%< Label too big. */\n\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t}\n\t\t\tif (label >= eom) {\n\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t}\n\t\t\t*label = c;\n\t\t\t/* Fully qualified ? */\n\t\t\tif (*src == '\\0') {\n\t\t\t\tif (c != 0) {\n\t\t\t\t\tif (bp >= eom) {\n\t\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\t\t}\n\t\t\t\t\t*bp++ = '\\0';\n\t\t\t\t}\n\t\t\t\tif ((bp - dst) > MAXCDNAME) {\n\t\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t\t}\n\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (c == 0 || *src == '.') {\n\t\t\t\tgoto ret_EMSGSIZE;\n\t\t\t}\n\t\t\tlabel = bp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (bp >= eom) {\n\t\t\tgoto ret_EMSGSIZE;\n\t\t}\n\t\t*bp++ = (u_char)c;\n\t}\n\tc = (bp - label - 1);\n\tif ((c & NS_CMPRSFLGS) != 0) {\t  /*%< Label too big. */\n\t\tgoto ret_EMSGSIZE;\n\t}\n done:\n\tif (label >= eom) {\n\t\tgoto ret_EMSGSIZE;\n\t}\n\t*label = c;\n\tif (c != 0) {\n\t\tif (bp >= eom) {\n\t\t\tgoto ret_EMSGSIZE;\n\t\t}\n\t\t*bp++ = 0;\n\t}\n\tif ((bp - dst) > MAXCDNAME) {   /*%< src too big */\n\t\tgoto ret_EMSGSIZE;\n\t}\n\n\treturn 0;\n\n ret_EMSGSIZE:\n\terrno = EMSGSIZE;\n\treturn -1;\n}\nlibc_hidden_def(ns_name_pton)\n\n/*\n * __hnbad(dotted)\n *\tCheck whether a name is valid enough for DNS. The rules, as\n *\tlaid down by glibc, are:\n *\t- printable input string\n *\t- converts to label notation\n *\t- each label only contains [0-9a-zA-Z_-], up to 63 octets\n *\t- first label doesn\u2019t begin with \u2018-\u2019\n *\tThis both is weaker than Unix hostnames (e.g. it allows\n *\tunderscores and leading/trailing hyphen-minus) and stronger\n *\tthan general (e.g. a leading \u201c*.\u201d is valid sometimes), take care.\n * return:\n *\t0 if the name is ok\n */\nint __hnbad(const char *dotted)\n{\n\tunsigned char c, n, *cp;\n\tunsigned char buf[NS_MAXCDNAME];\n\n\tcp = (unsigned char *)dotted;\n\twhile ((c = *cp++))\n\t\tif (c < 0x21 || c > 0x7E)\n\t\t\treturn (1);\n\tif (ns_name_pton(dotted, buf, sizeof(buf)) < 0)\n\t\treturn (2);\n\tif (buf[0] > 0 && buf[1] == '-')\n\t\treturn (3);\n\tcp = buf;\n\twhile ((n = *cp++)) {\n\t\tif (n > 63)\n\t\t\treturn (4);\n\t\twhile (n--) {\n\t\t\tc = *cp++;\n\t\t\tif (c < '-' ||\n\t\t\t    (c > '-' && c < '0') ||\n\t\t\t    (c > '9' && c < 'A') ||\n\t\t\t    (c > 'Z' && c < '_') ||\n\t\t\t    (c > '_' && c < 'a') ||\n\t\t\t    c > 'z')\n\t\t\t\treturn (5);\n\t\t}\n\t}\n\treturn (0);\n}\n\n/*\n * ns_name_unpack(msg, eom, src, dst, dstsiz)\n *      Unpack a domain name from a message, source may be compressed.\n * return:\n *      -1 if it fails, or consumed octets if it succeeds.\n */\nint ns_name_unpack(const u_char *msg, const u_char *eom, const u_char *src,\n               u_char *dst, size_t dstsiz)\n{\n\tconst u_char *srcp, *dstlim;\n\tu_char *dstp;\n\tint n, len, checked;\n\n\tlen = -1;\n\tchecked = 0;\n\tdstp = dst;\n\tsrcp = src;\n\tdstlim = dst + dstsiz;\n\tif (srcp < msg || srcp >= eom) {\n\t\t__set_errno(EMSGSIZE);\n\t\treturn -1;\n\t}\n\t/* Fetch next label in domain name. */\n\twhile ((n = *srcp++) != 0) {\n\t\t/* Check for indirection. */\n\t\tswitch (n & NS_CMPRSFLGS) {\n\t\t\tcase 0:\n\t\t\t\t/* Limit checks. */\n\t\t\t\tif (dstp + n + 1 >= dstlim || srcp + n >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += n + 1;\n\t\t\t\t*dstp++ = n;\n\t\t\t\tmemcpy(dstp, srcp, n);\n\t\t\t\tdstp += n;\n\t\t\t\tsrcp += n;\n\t\t\t\tbreak;\n\n\t\t\tcase NS_CMPRSFLGS:\n\t\t\t\tif (srcp >= eom) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tif (len < 0)\n\t\t\t\t\tlen = srcp - src + 1;\n\t\t\t\tsrcp = msg + (((n & 0x3f) << 8) | (*srcp & 0xff));\n\t\t\t\tif (srcp < msg || srcp >= eom) {  /* Out of range. */\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tchecked += 2;\n\t\t\t\t/*\n\t\t\t\t * Check for loops in the compressed name;\n\t\t\t\t * if we've looked at the whole message,\n\t\t\t\t * there must be a loop.\n\t\t\t\t */\n\t\t\t\tif (checked >= eom - msg) {\n\t\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\t__set_errno(EMSGSIZE);\n\t\t\t\treturn -1;                    /* flag error */\n\t\t}\n\t}\n\t*dstp = '\\0';\n\tif (len < 0)\n\t\tlen = srcp - src;\n\treturn len;\n}\nlibc_hidden_def(ns_name_unpack)\n\nstatic int labellen(const unsigned char *lp)\n{\n\tunsigned bitlen;\n\tunsigned char l = *lp;\n\n\tif ((l & NS_CMPRSFLGS) == NS_CMPRSFLGS) {\n\t\t/* should be avoided by the caller */\n\t\treturn -1;\n\t}\n\n\tif ((l & NS_CMPRSFLGS) == NS_TYPE_ELT) {\n\t\tif (l == DNS_LABELTYPE_BITSTRING) {\n\t\t\tbitlen = lp[1];\n\t\t\tif (bitlen == 0)\n\t\t\t\tbitlen = 256;\n\t\t\treturn ((bitlen + 7 ) / 8 + 1);\n\t\t}\n\n\t\treturn -1;    /*%< unknwon ELT */\n\t}\n\n\treturn l;\n}\n\nstatic int mklower(int ch)\n{\n\tif (ch >= 0x41 && ch <= 0x5A)\n\t\treturn (ch + 0x20);\n\n\treturn ch;\n}\n\nstatic int dn_find(const unsigned char *domain,\n\t\t\t\t   const unsigned char *msg,\n\t\t\t\t   const unsigned char * const *dnptrs,\n\t\t\t\t   const unsigned char * const *lastdnptr)\n{\n\tconst unsigned char *dn, *cp, *sp;\n\tconst unsigned char * const *cpp;\n\tu_int n;\n\n\tfor (cpp = dnptrs; cpp < lastdnptr; cpp++) {\n\t\tsp = *cpp;\n\t\t/*\n\t\t * terminate search on:\n\t\t * root label\n\t\t * compression pointer\n\t\t * unusable offset\n\t\t */\n\t\twhile (*sp != 0 && (*sp & NS_CMPRSFLGS) == 0 &&\n\t\t\t\t(sp - msg) < 0x4000) {\n\t\t\tdn = domain;\n\t\t\tcp = sp;\n\n\t\t\twhile ((n = *cp++) != 0) {\n\t\t\t\t/*\n\t\t\t\t * check for indirection\n\t\t\t\t */\n\t\t\t\tswitch (n & NS_CMPRSFLGS) {\n\t\t\t\tcase 0:\t /*%< normal case, n == len */\n\t\t\t\t\tn = labellen(cp - 1); /*%< XXX */\n\t\t\t\t\tif (n != *dn++)\n\t\t\t\t\t\tgoto next;\n\n\t\t\t\t\tfor (; n > 0; n--)\n\t\t\t\t\t\tif (mklower(*dn++) !=\n\t\t\t\t\t\t    mklower(*cp++))\n\t\t\t\t\t\t\tgoto next;\n\t\t\t\t\t/* Is next root for both ? */\n\t\t\t\t\tif (*dn == '\\0' && *cp == '\\0')\n\t\t\t\t\t\treturn (sp - msg);\n\t\t\t\t\tif (*dn)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tgoto next;\n\t\t\t\tcase NS_CMPRSFLGS:      /*%< indirection */\n\t\t\t\t\tcp = msg + (((n & 0x3f) << 8) | *cp);\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t/*%< illegal type */\n\t\t\t\t\terrno = EMSGSIZE;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\nnext:\n\t\t\tsp += *sp + 1;\n\t\t}\n\t}\n\n\terrno = ENOENT;\n\treturn -1;\n}\n\nint ns_name_pack(const unsigned char *src,\n\t\t\t\t unsigned char *dst, int dstsiz,\n\t\t\t\t const unsigned char **dnptrs,\n\t\t\t\t const unsigned char **lastdnptr)\n{\n\tunsigned char *dstp;\n\tconst unsigned char **cpp, **lpp, *eob, *msg;\n\tconst unsigned char *srcp;\n\tint n, l, first = 1;\n\n\tsrcp = src;\n\tdstp = dst;\n\teob = dstp + dstsiz;\n\tlpp = cpp = NULL;\n\n\tif (dnptrs != NULL) {\n\t\tmsg = *dnptrs++;\n\t\tif (msg != NULL) {\n\t\t\tfor (cpp = dnptrs; *cpp != NULL; cpp++)\n\t\t\t\tcontinue;\n\n\t\t\tlpp = cpp;      /*%< end of list to search */\n\t\t}\n\t} else {\n\t\tmsg = NULL;\n\t}\n\n\t/* make sure the domain we are about to add is legal */\n\tl = 0;\n\tdo {\n\t\tint l0;\n\n\t\tn = *srcp;\n\t\tif ((n & NS_CMPRSFLGS) == NS_CMPRSFLGS) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tl0 = labellen(srcp);\n\t\tif (l0 < 0) {\n\t\t\terrno = EINVAL;\n\t\t\treturn -1;\n\t\t}\n\n\t\tl += l0 + 1;\n\t\tif (l > MAXCDNAME) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tsrcp += l0 + 1;\n\t} while (n != 0);\n\n\t/* from here on we need to reset compression pointer array on error */\n\tsrcp = src;\n\n\tdo {\n\t\t/* Look to see if we can use pointers. */\n\t\tn = *srcp;\n\n\t\tif (n != 0 && msg != NULL) {\n\t\t\tl = dn_find(srcp, msg, (const unsigned char * const *) dnptrs,\n\t\t\t\t\t\t(const unsigned char * const *) lpp);\n\t\t\tif (l >= 0) {\n\t\t\t\tif (dstp + 1 >= eob) {\n\t\t\t\t\tgoto cleanup;\n\t\t\t\t}\n\n\t\t\t\t*dstp++ = ((u_int32_t)l >> 8) | NS_CMPRSFLGS;\n\t\t\t\t*dstp++ = l % 256;\n\t\t\t\treturn (dstp - dst);\n\t\t\t}\n\n\t\t\t/* Not found, save it. */\n\t\t\tif (lastdnptr != NULL && cpp < lastdnptr - 1 &&\n\t\t\t\t(dstp - msg) < 0x4000 && first) {\n\t\t\t\t*cpp++ = dstp;\n\t\t\t\t*cpp = NULL;\n\t\t\t\tfirst = 0;\n\t\t\t}\n\t\t}\n\n\t\t/* copy label to buffer */\n\t\tif ((n & NS_CMPRSFLGS) == NS_CMPRSFLGS) {\n\t\t\t/* Should not happen. */\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tn = labellen(srcp);\n\t\tif (dstp + 1 + n >= eob) {\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tmemcpy(dstp, srcp, (size_t)(n + 1));\n\t\tsrcp += n + 1;\n\t\tdstp += n + 1;\n\t} while (n != 0);\n\n\tif (dstp > eob) {\ncleanup:\n\t\tif (msg != NULL)\n\t\t\t*lpp = NULL;\n\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t}\n\n\treturn dstp - dst;\n}\nlibc_hidden_def(ns_name_pack)\n\nint ns_name_compress(const char *src,\n\t\t\t\t\t unsigned char *dst, size_t dstsiz,\n\t\t\t\t\t const unsigned char **dnptrs,\n\t\t\t\t\t const unsigned char **lastdnptr)\n{\n\tunsigned char tmp[NS_MAXCDNAME];\n\n\tif (ns_name_pton(src, tmp, sizeof(tmp)) == -1)\n\t\treturn -1;\n\n\treturn ns_name_pack(tmp, dst, dstsiz, dnptrs, lastdnptr);\n}\nlibc_hidden_def(ns_name_compress)\n\nint ns_name_skip(const unsigned char **ptrptr,\n\t\t\t\t const unsigned char *eom)\n{\n\tconst unsigned char *cp;\n\tu_int n;\n\tint l;\n\n\tcp = *ptrptr;\n\twhile (cp < eom && (n = *cp++) != 0) {\n\t\t/* Check for indirection. */\n\t\tswitch (n & NS_CMPRSFLGS) {\n\t\tcase 0:\t\t /*%< normal case, n == len */\n\t\t\tcp += n;\n\t\t\tcontinue;\n\t\tcase NS_TYPE_ELT: /*%< EDNS0 extended label */\n\t\t\tl = labellen(cp - 1);\n\t\t\tif (l < 0) {\n\t\t\t\terrno = EMSGSIZE; /*%< XXX */\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tcp += l;\n\t\t\tcontinue;\n\t\tcase NS_CMPRSFLGS:      /*%< indirection */\n\t\t\tcp++;\n\t\t\tbreak;\n\t\tdefault:\t\t/*%< illegal type */\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\tif (cp > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\t*ptrptr = cp;\n\n\treturn 0;\n}\nlibc_hidden_def(ns_name_skip)\n\nint dn_skipname(const unsigned char *ptr, const unsigned char *eom)\n{\n\tconst unsigned char *saveptr = ptr;\n\n\tif (ns_name_skip(&ptr, eom) == -1)\n\t\treturn -1;\n\n\treturn ptr - saveptr;\n}\nlibc_hidden_def(dn_skipname)\n#endif /* L_ns_name */\n\n\n#ifdef L_res_init\n\n/* Will be called under __resolv_lock. */\nstatic void res_sync_func(void)\n{\n\tstruct __res_state *rp = &(_res);\n\tint n;\n\n\t/* If we didn't get malloc failure earlier... */\n\tif (__nameserver != (void*) &__local_nameserver) {\n\t\t/* TODO:\n\t\t * if (__nameservers < rp->nscount) - try to grow __nameserver[]?\n\t\t */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tif (__nameservers > rp->_u._ext.nscount)\n\t\t\t__nameservers = rp->_u._ext.nscount;\n\t\tn = __nameservers;\n\t\twhile (--n >= 0)\n\t\t\t__nameserver[n].sa6 = *rp->_u._ext.nsaddrs[n]; /* struct copy */\n#else /* IPv4 only */\n\t\tif (__nameservers > rp->nscount)\n\t\t\t__nameservers = rp->nscount;\n\t\tn = __nameservers;\n\t\twhile (--n >= 0)\n\t\t\t__nameserver[n].sa4 = rp->nsaddr_list[n]; /* struct copy */\n#endif\n\t}\n\t__resolv_timeout = rp->retrans ? : RES_TIMEOUT;\n\t__resolv_attempts = rp->retry ? : RES_DFLRETRY;\n\t/* Extend and comment what program is known\n\t * to use which _res.XXX member(s).\n\n\t   __resolv_opts = rp->options;\n\t   ...\n\t */\n}\n\n/* has to be called under __resolv_lock */\nstatic int\n__res_vinit(res_state rp, int preinit)\n{\n\tint i, n, options, retrans, retry, ndots;\n#ifdef __UCLIBC_HAS_IPV6__\n\tint m = 0;\n#endif\n\n\t__close_nameservers();\n\t__open_nameservers();\n\n\tif (preinit) {\n\t\toptions = rp->options;\n\t\tretrans = rp->retrans;\n\t\tretry = rp->retry;\n\t\tndots = rp->ndots;\n\t}\n\n\tmemset(rp, 0, sizeof(*rp));\n\n\tif (!preinit) {\n\t\trp->options = RES_DEFAULT;\n\t\trp->retrans = RES_TIMEOUT;\n\t\trp->retry = RES_DFLRETRY;\n\t\trp->ndots = 1;\n\t} else {\n\t\trp->options = options;\n\t\trp->retrans = retrans;\n\t\trp->retry = retry;\n\t\trp->ndots = ndots;\n\t}\n\n#ifdef __UCLIBC_HAS_COMPAT_RES_STATE__\n\t/* Was: \"rp->id = random();\" but:\n\t * - random() pulls in largish static buffers\n\t * - isn't actually random unless, say, srandom(time(NULL)) was called\n\t * - is not used by uclibc anyway :)\n\t */\n\t/* rp->id = 0; - memset did it */\n#endif\n#ifdef __UCLIBC_HAS_EXTRA_COMPAT_RES_STATE__\n\trp->_vcsock = -1;\n#endif\n\n\tn = __searchdomains;\n\tif (n > ARRAY_SIZE(rp->dnsrch))\n\t\tn = ARRAY_SIZE(rp->dnsrch);\n\tfor (i = 0; i < n; i++)\n\t\trp->dnsrch[i] = __searchdomain[i];\n\n\t/* copy nameservers' addresses */\n\ti = 0;\n#ifdef __UCLIBC_HAS_IPV4__\n\tn = 0;\n\twhile (n < ARRAY_SIZE(rp->nsaddr_list) && i < __nameservers) {\n\t\tif (__nameserver[i].sa.sa_family == AF_INET) {\n\t\t\trp->nsaddr_list[n] = __nameserver[i].sa4; /* struct copy */\n#ifdef __UCLIBC_HAS_IPV6__\n\t\t\tif (m < ARRAY_SIZE(rp->_u._ext.nsaddrs)) {\n\t\t\t\trp->_u._ext.nsaddrs[m] = (void*) &rp->nsaddr_list[n];\n\t\t\t\tm++;\n\t\t\t}\n#endif\n\t\t\tn++;\n\t\t}\n#ifdef __UCLIBC_HAS_IPV6__\n\t\tif (__nameserver[i].sa.sa_family == AF_INET6\n\t\t && m < ARRAY_SIZE(rp->_u._ext.nsaddrs)\n\t\t) {\n\t\t\tstruct sockaddr_in6 *sa6 = malloc(sizeof(*sa6));\n\t\t\tif (sa6) {\n\t\t\t\t*sa6 = __nameserver[i].sa6; /* struct copy */\n\t\t\t\trp->_u._ext.nsaddrs[m] = sa6;\n\t\t\t\tm++;\n\t\t\t}\n\t\t}\n#endif\n\t\ti++;\n\t}\n\trp->nscount = n;\n#ifdef __UCLIBC_HAS_IPV6__\n\trp->_u._ext.nscount = m;\n#endif\n\n#else /* IPv6 only */\n\twhile (m < ARRAY_SIZE(rp->_u._ext.nsaddrs) && i < __nameservers) {\n\t\tstruct sockaddr_in6 *sa6 = malloc(sizeof(*sa6));\n\t\tif (sa6) {\n\t\t\t*sa6 = __nameserver[i].sa6; /* struct copy */\n\t\t\trp->_u._ext.nsaddrs[m] = sa6;\n\t\t\tm++;\n\t\t}\n\t\ti++;\n\t}\n\trp->_u._ext.nscount = m;\n#endif\n\n\trp->options |= RES_INIT;\n\n\treturn 0;\n}\n\nstatic unsigned int\nres_randomid(void)\n{\n\treturn 0xffff & getpid();\n}\n\n/* Our res_init never fails (always returns 0) */\nint\nres_init(void)\n{\n\t/*\n\t * These three fields used to be statically initialized.  This made\n\t * it hard to use this code in a shared library.  It is necessary,\n\t * now that we're doing dynamic initialization here, that we preserve\n\t * the old semantics: if an application modifies one of these three\n\t * fields of _res before res_init() is called, res_init() will not\n\t * alter them.  Of course, if an application is setting them to\n\t * _zero_ before calling res_init(), hoping to override what used\n\t * to be the static default, we can't detect it and unexpected results\n\t * will follow.  Zero for any of these fields would make no sense,\n\t * so one can safely assume that the applications were already getting\n\t * unexpected results.\n\t *\n\t * _res.options is tricky since some apps were known to diddle the bits\n\t * before res_init() was first called. We can't replicate that semantic\n\t * with dynamic initialization (they may have turned bits off that are\n\t * set in RES_DEFAULT).  Our solution is to declare such applications\n\t * \"broken\".  They could fool us by setting RES_INIT but none do (yet).\n\t */\n\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\n\tif (!_res.retrans)\n\t\t_res.retrans = RES_TIMEOUT;\n\tif (!_res.retry)\n\t\t_res.retry = 4;\n\tif (!(_res.options & RES_INIT))\n\t\t_res.options = RES_DEFAULT;\n\n\t/*\n\t * This one used to initialize implicitly to zero, so unless the app\n\t * has set it to something in particular, we can randomize it now.\n\t */\n\tif (!_res.id)\n\t\t_res.id = res_randomid();\n\n\t__res_sync = NULL;\n\t__res_vinit(&_res, 1);\n\t__res_sync = res_sync_func;\n\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\n\treturn 0;\n}\nlibc_hidden_def(res_init)\n\nstatic void\n__res_iclose(res_state statp)\n{\n\tstruct __res_state * rp = statp;\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\tif (rp == NULL)\n\t\trp = __res_state();\n\t__close_nameservers();\n\t__res_sync = NULL;\n#ifdef __UCLIBC_HAS_IPV6__\n\t{\n\t\tchar *p1 = (char*) &(rp->nsaddr_list[0]);\n\t\tunsigned int m = 0;\n\t\t/* free nsaddrs[m] if they do not point to nsaddr_list[x] */\n\t\twhile (m < ARRAY_SIZE(rp->_u._ext.nsaddrs)) {\n\t\t\tchar *p2 = (char*)(rp->_u._ext.nsaddrs[m++]);\n\t\t\tif (p2 < p1 || (p2 - p1) > (signed)sizeof(rp->nsaddr_list))\n\t\t\t\tfree(p2);\n\t\t}\n\t}\n#endif\n\tmemset(rp, 0, sizeof(struct __res_state));\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n}\n\n/*\n * This routine is for closing the socket if a virtual circuit is used and\n * the program wants to close it.  This provides support for endhostent()\n * which expects to close the socket.\n *\n * This routine is not expected to be user visible.\n */\n\nvoid\nres_nclose(res_state statp)\n{\n\t__res_iclose(statp);\n}\n\n#ifdef __UCLIBC_HAS_BSD_RES_CLOSE__\nvoid res_close(void)\n{\n\t__res_iclose(NULL);\n}\n#endif\n\n#ifdef __UCLIBC_HAS_BSD_B64_NTOP_B64_PTON__\n#define Assert(Cond) if (!(Cond)) abort()\n\nstatic const char Base64[] =\n\t\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nstatic const char Pad64 = '=';\n\n/* (From RFC1521 and draft-ietf-dnssec-secext-03.txt)\n   The following encoding technique is taken from RFC 1521 by Borenstein\n   and Freed.  It is reproduced here in a slightly edited form for\n   convenience.\n\n   A 65-character subset of US-ASCII is used, enabling 6 bits to be\n   represented per printable character. (The extra 65th character, \"=\",\n   is used to signify a special processing function.)\n\n   The encoding process represents 24-bit groups of input bits as output\n   strings of 4 encoded characters. Proceeding from left to right, a\n   24-bit input group is formed by concatenating 3 8-bit input groups.\n   These 24 bits are then treated as 4 concatenated 6-bit groups, each\n   of which is translated into a single digit in the base64 alphabet.\n\n   Each 6-bit group is used as an index into an array of 64 printable\n   characters. The character referenced by the index is placed in the\n   output string.\n\n                         Table 1: The Base64 Alphabet\n\n      Value Encoding  Value Encoding  Value Encoding  Value Encoding\n          0 A            17 R            34 i            51 z\n          1 B            18 S            35 j            52 0\n          2 C            19 T            36 k            53 1\n          3 D            20 U            37 l            54 2\n          4 E            21 V            38 m            55 3\n          5 F            22 W            39 n            56 4\n          6 G            23 X            40 o            57 5\n          7 H            24 Y            41 p            58 6\n          8 I            25 Z            42 q            59 7\n          9 J            26 a            43 r            60 8\n         10 K            27 b            44 s            61 9\n         11 L            28 c            45 t            62 +\n         12 M            29 d            46 u            63 /\n         13 N            30 e            47 v\n         14 O            31 f            48 w         (pad) =\n         15 P            32 g            49 x\n         16 Q            33 h            50 y\n\n   Special processing is performed if fewer than 24 bits are available\n   at the end of the data being encoded.  A full encoding quantum is\n   always completed at the end of a quantity.  When fewer than 24 input\n   bits are available in an input group, zero bits are added (on the\n   right) to form an integral number of 6-bit groups.  Padding at the\n   end of the data is performed using the '=' character.\n\n   Since all base64 input is an integral number of octets, only the\n         -------------------------------------------------\n   following cases can arise:\n\n       (1) the final quantum of encoding input is an integral\n           multiple of 24 bits; here, the final unit of encoded\n\t   output will be an integral multiple of 4 characters\n\t   with no \"=\" padding,\n       (2) the final quantum of encoding input is exactly 8 bits;\n           here, the final unit of encoded output will be two\n\t   characters followed by two \"=\" padding characters, or\n       (3) the final quantum of encoding input is exactly 16 bits;\n           here, the final unit of encoded output will be three\n\t   characters followed by one \"=\" padding character.\n   */\n\nint\nb64_ntop(u_char const *src, size_t srclength, char *target, size_t targsize) {\n\tsize_t datalength = 0;\n\tu_char input[3];\n\tu_char output[4];\n\tsize_t i;\n\n\twhile (2 < srclength) {\n\t\tinput[0] = *src++;\n\t\tinput[1] = *src++;\n\t\tinput[2] = *src++;\n\t\tsrclength -= 3;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\toutput[3] = input[2] & 0x3f;\n\t\tAssert(output[0] < 64);\n\t\tAssert(output[1] < 64);\n\t\tAssert(output[2] < 64);\n\t\tAssert(output[3] < 64);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Base64[output[3]];\n\t}\n\n\t/* Now we worry about padding. */\n\tif (0 != srclength) {\n\t\t/* Get what's left. */\n\t\tinput[0] = input[1] = input[2] = '\\0';\n\t\tfor (i = 0; i < srclength; i++)\n\t\t\tinput[i] = *src++;\n\n\t\toutput[0] = input[0] >> 2;\n\t\toutput[1] = ((input[0] & 0x03) << 4) + (input[1] >> 4);\n\t\toutput[2] = ((input[1] & 0x0f) << 2) + (input[2] >> 6);\n\t\tAssert(output[0] < 64);\n\t\tAssert(output[1] < 64);\n\t\tAssert(output[2] < 64);\n\n\t\tif (datalength + 4 > targsize)\n\t\t\treturn (-1);\n\t\ttarget[datalength++] = Base64[output[0]];\n\t\ttarget[datalength++] = Base64[output[1]];\n\t\tif (srclength == 1)\n\t\t\ttarget[datalength++] = Pad64;\n\t\telse\n\t\t\ttarget[datalength++] = Base64[output[2]];\n\t\ttarget[datalength++] = Pad64;\n\t}\n\tif (datalength >= targsize)\n\t\treturn (-1);\n\ttarget[datalength] = '\\0';\t/* Returned value doesn't count \\0. */\n\treturn (datalength);\n}\n/* libc_hidden_def (b64_ntop) */\n\n/* skips all whitespace anywhere.\n   converts characters, four at a time, starting at (or after)\n   src from base - 64 numbers into three 8 bit bytes in the target area.\n   it returns the number of data bytes stored at the target, or -1 on error.\n */\n\nint\nb64_pton (char const *src, u_char *target, size_t targsize)\n{\n\tint tarindex, state, ch;\n\tchar *pos;\n\n\tstate = 0;\n\ttarindex = 0;\n\n\twhile ((ch = *src++) != '\\0') {\n\t\tif (isspace(ch))\t/* Skip whitespace anywhere. */\n\t\t\tcontinue;\n\n\t\tif (ch == Pad64)\n\t\t\tbreak;\n\n\t\tpos = strchr(Base64, ch);\n\t\tif (pos == 0) \t\t/* A non-base64 character. */\n\t\t\treturn (-1);\n\n\t\tswitch (state) {\n\t\tcase 0:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] = (pos - Base64) << 2;\n\t\t\t}\n\t\t\tstate = 1;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 4;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x0f)\n\t\t\t\t\t\t\t<< 4 ;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 2;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex + 1 >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex]   |=  (pos - Base64) >> 2;\n\t\t\t\ttarget[tarindex+1]  = ((pos - Base64) & 0x03)\n\t\t\t\t\t\t\t<< 6;\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 3;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (target) {\n\t\t\t\tif ((size_t)tarindex >= targsize)\n\t\t\t\t\treturn (-1);\n\t\t\t\ttarget[tarindex] |= (pos - Base64);\n\t\t\t}\n\t\t\ttarindex++;\n\t\t\tstate = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tabort();\n\t\t}\n\t}\n\n\t/*\n\t * We are done decoding Base-64 chars.  Let's see if we ended\n\t * on a byte boundary, and/or with erroneous trailing characters.\n\t */\n\n\tif (ch == Pad64) {\t\t/* We got a pad char. */\n\t\tch = *src++;\t\t/* Skip it, get next. */\n\t\tswitch (state) {\n\t\tcase 0:\t\t/* Invalid = in first position */\n\t\tcase 1:\t\t/* Invalid = in second position */\n\t\t\treturn (-1);\n\n\t\tcase 2:\t\t/* Valid, means one byte of info */\n\t\t\t/* Skip any number of spaces. */\n\t\t\tfor ((void)NULL; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\tbreak;\n\t\t\t/* Make sure there is another trailing = sign. */\n\t\t\tif (ch != Pad64)\n\t\t\t\treturn (-1);\n\t\t\tch = *src++;\t\t/* Skip the = */\n\t\t\t/* Fall through to \"single trailing =\" case. */\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase 3:\t\t/* Valid, means two bytes of info */\n\t\t\t/*\n\t\t\t * We know this char is an =.  Is there anything but\n\t\t\t * whitespace after it?\n\t\t\t */\n\t\t\tfor ((void)NULL; ch != '\\0'; ch = *src++)\n\t\t\t\tif (!isspace(ch))\n\t\t\t\t\treturn (-1);\n\n\t\t\t/*\n\t\t\t * Now make sure for cases 2 and 3 that the \"extra\"\n\t\t\t * bits that slopped past the last full byte were\n\t\t\t * zeros.  If we don't check them, they become a\n\t\t\t * subliminal channel.\n\t\t\t */\n\t\t\tif (target && target[tarindex] != 0)\n\t\t\t\treturn (-1);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * We ended by seeing the end of the string.  Make sure we\n\t\t * have no partial bytes lying around.\n\t\t */\n\t\tif (state != 0)\n\t\t\treturn (-1);\n\t}\n\n\treturn (tarindex);\n}\n#endif\n\n/* This needs to be after the use of _res in res_init, above.  */\n#undef _res\n\n#ifndef __UCLIBC_HAS_THREADS__\n/* The resolver state for use by single-threaded programs.\n   This differs from plain `struct __res_state _res;' in that it doesn't\n   create a common definition, but a plain symbol that resides in .bss,\n   which can have an alias.  */\nstruct __res_state _res __attribute__((section (\".bss\")));\nstruct __res_state *__resp = &_res;\n#else /* __UCLIBC_HAS_THREADS__ */\nstruct __res_state _res __attribute__((section (\".bss\"))) attribute_hidden;\n\n# if defined __UCLIBC_HAS_TLS__\n#  undef __resp\n__thread struct __res_state *__resp = &_res;\nextern __thread struct __res_state *__libc_resp\n       __attribute__ ((alias (\"__resp\"))) attribute_hidden attribute_tls_model_ie;\n# else\n#  undef __resp\nstruct __res_state *__resp = &_res;\n# endif\n#endif /* !__UCLIBC_HAS_THREADS__ */\n\n/*\n * Set up default settings.  If the configuration file exist, the values\n * there will have precedence.  Otherwise, the server address is set to\n * INADDR_ANY and the default domain name comes from the gethostname().\n *\n * An interrim version of this code (BIND 4.9, pre-4.4BSD) used 127.0.0.1\n * rather than INADDR_ANY (\"0.0.0.0\") as the default name server address\n * since it was noted that INADDR_ANY actually meant ``the first interface\n * you \"ifconfig\"'d at boot time'' and if this was a SLIP or PPP interface,\n * it had to be \"up\" in order for you to reach your own name server.  It\n * was later decided that since the recommended practice is to always\n * install local static routes through 127.0.0.1 for all your network\n * interfaces, that we could solve this problem without a code change.\n *\n * The configuration file should always be used, since it is the only way\n * to specify a default domain.  If you are running a server on your local\n * machine, you should say \"nameserver 0.0.0.0\" or \"nameserver 127.0.0.1\"\n * in the configuration file.\n *\n * Return 0 if completes successfully, -1 on error\n */\nint\nres_ninit(res_state statp)\n{\n\tint ret;\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\tret = __res_vinit(statp, 0);\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\treturn ret;\n}\n\n#endif /* L_res_init */\n\n#ifdef L_res_state\n# if defined __UCLIBC_HAS_TLS__\nstruct __res_state *\n__res_state (void)\n{\n       return __resp;\n}\n# else\n#  undef _res\nextern struct __res_state _res;\n\n/* When threaded, _res may be a per-thread variable.  */\nstruct __res_state *\nweak_const_function\n__res_state (void)\n{\n       return &_res;\n}\n# endif\n\n#endif /* L_res_state */\n\n\n#ifdef L_res_query\n\nint res_query(const char *dname, int class, int type,\n              unsigned char *answer, int anslen)\n{\n\tint i;\n\tunsigned char *packet = NULL;\n\tstruct resolv_answer a;\n\n\tif (!dname || class != 1 /* CLASS_IN */) {\n\t\th_errno = NO_RECOVERY;\n\t\treturn -1;\n\t}\n\n\tmemset(&a, '\\0', sizeof(a));\n\ti = __dns_lookup(dname, type, &packet, &a);\n\n\tif (i < 0) {\n\t\tif (!h_errno) /* TODO: can this ever happen? */\n\t\t\th_errno = TRY_AGAIN;\n\t\treturn -1;\n\t}\n\n\tfree(a.dotted);\n\n\tif (i > anslen)\n\t\ti = anslen;\n\tmemcpy(answer, packet, i);\n\n\tfree(packet);\n\treturn i;\n}\nlibc_hidden_def(res_query)\n\n/*\n * Formulate a normal query, send, and retrieve answer in supplied buffer.\n * Return the size of the response on success, -1 on error.\n * If enabled, implement search rules until answer or unrecoverable failure\n * is detected.  Error code, if any, is left in h_errno.\n */\n#define __TRAILING_DOT\t(1<<0)\n#define __GOT_NODATA\t(1<<1)\n#define __GOT_SERVFAIL\t(1<<2)\n#define __TRIED_AS_IS\t(1<<3)\nint res_search(const char *name, int class, int type, u_char *answer,\n\t\tint anslen)\n{\n\tconst char *cp;\n\tchar **domain;\n\tHEADER *hp = (HEADER *)(void *)answer;\n\tunsigned dots;\n\tunsigned state;\n\tint ret, saved_herrno;\n\tuint32_t _res_options;\n\tunsigned _res_ndots;\n\tchar **_res_dnsrch;\n\n\tif (!name || !answer) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn -1;\n\t}\n\n again:\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t_res_options = _res.options;\n\t_res_ndots = _res.ndots;\n\t_res_dnsrch = _res.dnsrch;\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\tif (!(_res_options & RES_INIT)) {\n\t\tres_init(); /* our res_init never fails */\n\t\tgoto again;\n\t}\n\n\tstate = 0;\n\terrno = 0;\n\th_errno = HOST_NOT_FOUND;\t/* default, if we never query */\n\tdots = 0;\n\tfor (cp = name; *cp; cp++)\n\t\tdots += (*cp == '.');\n\n\tif (cp > name && *--cp == '.')\n\t\tstate |= __TRAILING_DOT;\n\n\t/*\n\t * If there are dots in the name already, let's just give it a try\n\t * 'as is'.  The threshold can be set with the \"ndots\" option.\n\t */\n\tsaved_herrno = -1;\n\tif (dots >= _res_ndots) {\n\t\tret = res_querydomain(name, NULL, class, type, answer, anslen);\n\t\tif (ret > 0)\n\t\t\treturn ret;\n\t\tsaved_herrno = h_errno;\n\t\tstate |= __TRIED_AS_IS;\n\t}\n\n\t/*\n\t * We do at least one level of search if\n\t *\t- there is no dot and RES_DEFNAME is set, or\n\t *\t- there is at least one dot, there is no trailing dot,\n\t *\t  and RES_DNSRCH is set.\n\t */\n\tif ((!dots && (_res_options & RES_DEFNAMES))\n\t || (dots && !(state & __TRAILING_DOT) && (_res_options & RES_DNSRCH))\n\t) {\n\t\tbool done = 0;\n\n\t\tfor (domain = _res_dnsrch; *domain && !done; domain++) {\n\n\t\t\tret = res_querydomain(name, *domain, class, type,\n\t\t\t\t\t\t\t\t  answer, anslen);\n\t\t\tif (ret > 0)\n\t\t\t\treturn ret;\n\n\t\t\t/*\n\t\t\t * If no server present, give up.\n\t\t\t * If name isn't found in this domain,\n\t\t\t * keep trying higher domains in the search list\n\t\t\t * (if that's enabled).\n\t\t\t * On a NO_DATA error, keep trying, otherwise\n\t\t\t * a wildcard entry of another type could keep us\n\t\t\t * from finding this entry higher in the domain.\n\t\t\t * If we get some other error (negative answer or\n\t\t\t * server failure), then stop searching up,\n\t\t\t * but try the input name below in case it's\n\t\t\t * fully-qualified.\n\t\t\t */\n\t\t\tif (errno == ECONNREFUSED) {\n\t\t\t\th_errno = TRY_AGAIN;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tswitch (h_errno) {\n\t\t\t\tcase NO_DATA:\n\t\t\t\t\tstate |= __GOT_NODATA;\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\t\t/* keep trying */\n\t\t\t\t\tbreak;\n\t\t\t\tcase TRY_AGAIN:\n\t\t\t\t\tif (hp->rcode == SERVFAIL) {\n\t\t\t\t\t\t/* try next search element, if any */\n\t\t\t\t\t\tstate |= __GOT_SERVFAIL;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t/* FALLTHROUGH */\n\t\t\t\tdefault:\n\t\t\t\t\t/* anything else implies that we're done */\n\t\t\t\t\tdone = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * if we got here for some reason other than DNSRCH,\n\t\t\t * we only wanted one iteration of the loop, so stop.\n\t\t\t */\n\t\t\tif (!(_res_options & RES_DNSRCH))\n\t\t\t\tdone = 1;\n\t\t}\n\t}\n\n\t/*\n\t * if we have not already tried the name \"as is\", do that now.\n\t * note that we do this regardless of how many dots were in the\n\t * name or whether it ends with a dot.\n\t */\n\tif (!(state & __TRIED_AS_IS)) {\n\t\tret = res_querydomain(name, NULL, class, type, answer, anslen);\n\t\tif (ret > 0)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * if we got here, we didn't satisfy the search.\n\t * if we did an initial full query, return that query's h_errno\n\t * (note that we wouldn't be here if that query had succeeded).\n\t * else if we ever got a nodata, send that back as the reason.\n\t * else send back meaningless h_errno, that being the one from\n\t * the last DNSRCH we did.\n\t */\n\tif (saved_herrno != -1)\n\t\th_errno = saved_herrno;\n\telse if (state & __GOT_NODATA)\n\t\th_errno = NO_DATA;\n\telse if (state & __GOT_SERVFAIL)\n\t\th_errno = TRY_AGAIN;\n\treturn -1;\n}\n#undef __TRAILING_DOT\n#undef __GOT_NODATA\n#undef __GOT_SERVFAIL\n#undef __TRIED_AS_IS\n/*\n * Perform a call on res_query on the concatenation of name and domain,\n * removing a trailing dot from name if domain is NULL.\n */\nint res_querydomain(const char *name, const char *domain, int class, int type,\n\t\t\tu_char *answer, int anslen)\n{\n\tchar nbuf[MAXDNAME];\n\tconst char *longname = nbuf;\n\tsize_t n, d;\n#ifdef DEBUG\n\tuint32_t _res_options;\n#endif\n\n\tif (!name || !answer) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn -1;\n\t}\n\n#ifdef DEBUG\n again:\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t_res_options = _res.options;\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\tif (!(_res_options & RES_INIT)) {\n\t\tres_init(); /* our res_init never fails */\n\t\tgoto again;\n\t}\n\tif (_res_options & RES_DEBUG)\n\t\tprintf(\";; res_querydomain(%s, %s, %d, %d)\\n\",\n\t\t\t   name, (domain ? domain : \"<Nil>\"), class, type);\n#endif\n\tif (domain == NULL) {\n\t\t/*\n\t\t * Check for trailing '.';\n\t\t * copy without '.' if present.\n\t\t */\n\t\tn = strlen(name);\n\t\tif (n + 1 > sizeof(nbuf)) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tif (n > 0 && name[--n] == '.') {\n\t\t\tstrncpy(nbuf, name, n);\n\t\t\tnbuf[n] = '\\0';\n\t\t} else\n\t\t\tlongname = name;\n\t} else {\n\t\tn = strlen(name);\n\t\td = strlen(domain);\n\t\tif (n + 1 + d + 1 > sizeof(nbuf)) {\n\t\t\th_errno = NO_RECOVERY;\n\t\t\treturn -1;\n\t\t}\n\t\tsnprintf(nbuf, sizeof(nbuf), \"%s.%s\", name, domain);\n\t}\n\treturn res_query(longname, class, type, answer, anslen);\n}\nlibc_hidden_def(res_querydomain)\n#endif /* L_res_query */\n\n#ifdef L_ns_netint\nunsigned int ns_get16(const unsigned char *src)\n{\n\tunsigned int dst;\n\tNS_GET16(dst, src);\n\treturn dst;\n}\n\nunsigned long ns_get32(const unsigned char *src)\n{\n\tunsigned long dst;\n\tNS_GET32(dst, src);\n\treturn dst;\n}\n\nvoid ns_put16(unsigned int src, unsigned char *dst)\n{\n\tNS_PUT16(src, dst);\n}\n\nvoid ns_put32(unsigned long src, unsigned char *dst)\n{\n\tNS_PUT32(src, dst);\n}\n#endif /* L_ns_netint */\n\n#ifdef L_ns_parse\n/* These need to be in the same order as the nres.h:ns_flag enum. */\nstruct _ns_flagdata { unsigned short mask, shift; };\nstatic const struct _ns_flagdata _ns_flagdata[16] = {\n\t{ 0x8000, 15 },         /*%< qr. */\n\t{ 0x7800, 11 },         /*%< opcode. */\n\t{ 0x0400, 10 },         /*%< aa. */\n\t{ 0x0200, 9 },          /*%< tc. */\n\t{ 0x0100, 8 },          /*%< rd. */\n\t{ 0x0080, 7 },          /*%< ra. */\n\t{ 0x0040, 6 },          /*%< z. */\n\t{ 0x0020, 5 },          /*%< ad. */\n\t{ 0x0010, 4 },          /*%< cd. */\n\t{ 0x000f, 0 },          /*%< rcode. */\n\t{ 0x0000, 0 },          /*%< expansion (1/6). */\n\t{ 0x0000, 0 },          /*%< expansion (2/6). */\n\t{ 0x0000, 0 },          /*%< expansion (3/6). */\n\t{ 0x0000, 0 },          /*%< expansion (4/6). */\n\t{ 0x0000, 0 },          /*%< expansion (5/6). */\n\t{ 0x0000, 0 },          /*%< expansion (6/6). */\n};\n\nstatic void setsection(ns_msg *msg, ns_sect sect)\n{\n\tmsg->_sect = sect;\n\tif (sect == ns_s_max) {\n\t\tmsg->_rrnum = -1;\n\t\tmsg->_ptr = NULL;\n\t} else {\n\t\tmsg->_rrnum = 0;\n\t\tmsg->_ptr = msg->_sections[(int)sect];\n\t}\n}\n\nint ns_skiprr(const unsigned char *ptr,\n\t\t\t  const unsigned char *eom,\n\t\t\t  ns_sect section, int count)\n{\n\tconst u_char *optr = ptr;\n\n\tfor (; count > 0; count--) {\n\t\tint b, rdlength;\n\n\t\tb = dn_skipname(ptr, eom);\n\t\tif (b < 0) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tptr += b/*Name*/ + NS_INT16SZ/*Type*/ + NS_INT16SZ/*Class*/;\n\t\tif (section != ns_s_qd) {\n\t\t\tif (ptr + NS_INT32SZ + NS_INT16SZ > eom) {\n\t\t\t\terrno = EMSGSIZE;\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tptr += NS_INT32SZ/*TTL*/;\n\t\t\tNS_GET16(rdlength, ptr);\n\t\t\tptr += rdlength/*RData*/;\n\t\t}\n\t}\n\n\tif (ptr > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\treturn ptr - optr;\n}\nlibc_hidden_def(ns_skiprr)\n\nint\nns_initparse(const unsigned char *msg, int msglen, ns_msg *handle)\n{\n\tconst u_char *eom = msg + msglen;\n\tint i;\n\n\thandle->_msg = msg;\n\thandle->_eom = eom;\n\tif (msg + NS_INT16SZ > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\tNS_GET16(handle->_id, msg);\n\tif (msg + NS_INT16SZ > eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\tNS_GET16(handle->_flags, msg);\n\tfor (i = 0; i < ns_s_max; i++) {\n\t\tif (msg + NS_INT16SZ > eom) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\n\t\tNS_GET16(handle->_counts[i], msg);\n\t}\n\tfor (i = 0; i < ns_s_max; i++)\n\t\tif (handle->_counts[i] == 0)\n\t\t\thandle->_sections[i] = NULL;\n\t\telse {\n\t\t\tint b = ns_skiprr(msg, eom, (ns_sect)i,\n\t\t\t\t\t  handle->_counts[i]);\n\n\t\t\tif (b < 0)\n\t\t\t\treturn -1;\n\t\t\thandle->_sections[i] = msg;\n\t\t\tmsg += b;\n\t\t}\n\n\tif (msg != eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\n\tsetsection(handle, ns_s_max);\n\treturn 0;\n}\n\nint\nns_parserr(ns_msg *handle, ns_sect section, int rrnum, ns_rr *rr)\n{\n\tint b;\n\tint tmp;\n\n\t/* Make section right. */\n\ttmp = section;\n\tif (tmp < 0 || section >= ns_s_max) {\n\t\terrno = ENODEV;\n\t\treturn -1;\n\t}\n\n\tif (section != handle->_sect)\n\t\tsetsection(handle, section);\n\n\t/* Make rrnum right. */\n\tif (rrnum == -1)\n\t\trrnum = handle->_rrnum;\n\tif (rrnum < 0 || rrnum >= handle->_counts[(int)section]) {\n\t\terrno = ENODEV;\n\t\treturn -1;\n\t}\n\tif (rrnum < handle->_rrnum)\n\t\tsetsection(handle, section);\n\tif (rrnum > handle->_rrnum) {\n\t\tb = ns_skiprr(handle->_ptr, handle->_eom, section,\n\t\t\t      rrnum - handle->_rrnum);\n\n\t\tif (b < 0)\n\t\t\treturn -1;\n\t\thandle->_ptr += b;\n\t\thandle->_rrnum = rrnum;\n\t}\n\n\t/* Do the parse. */\n\tb = dn_expand(handle->_msg, handle->_eom,\n\t\t      handle->_ptr, rr->name, NS_MAXDNAME);\n\tif (b < 0)\n\t\treturn -1;\n\thandle->_ptr += b;\n\tif (handle->_ptr + NS_INT16SZ + NS_INT16SZ > handle->_eom) {\n\t\terrno = EMSGSIZE;\n\t\treturn -1;\n\t}\n\tNS_GET16(rr->type, handle->_ptr);\n\tNS_GET16(rr->rr_class, handle->_ptr);\n\tif (section == ns_s_qd) {\n\t\trr->ttl = 0;\n\t\trr->rdlength = 0;\n\t\trr->rdata = NULL;\n\t} else {\n\t\tif (handle->_ptr + NS_INT32SZ + NS_INT16SZ > handle->_eom) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\t\tNS_GET32(rr->ttl, handle->_ptr);\n\t\tNS_GET16(rr->rdlength, handle->_ptr);\n\t\tif (handle->_ptr + rr->rdlength > handle->_eom) {\n\t\t\terrno = EMSGSIZE;\n\t\t\treturn -1;\n\t\t}\n\t\trr->rdata = handle->_ptr;\n\t\thandle->_ptr += rr->rdlength;\n\t}\n\tif (++handle->_rrnum > handle->_counts[(int)section])\n\t\tsetsection(handle, (ns_sect)((int)section + 1));\n\n\treturn 0;\n}\n\nint ns_msg_getflag(ns_msg handle, int flag)\n{\n\treturn ((handle)._flags & _ns_flagdata[flag].mask) >> _ns_flagdata[flag].shift;\n}\n#endif /* L_ns_parse */\n\n#ifdef L_res_data\nint res_mkquery(int op, const char *dname, int class, int type,\n\t\t\t\tconst unsigned char *data, int datalen,\n\t\t\t\tconst unsigned char *newrr_in,\n\t\t\t\tunsigned char *buf, int buflen)\n{\n\tHEADER *hp;\n\tunsigned char *cp, *ep;\n\tunsigned char *dnptrs[20], **dpp, **lastdnptr;\n\tuint32_t _res_options;\n\tint n;\n\n\tif (!buf || buflen < HFIXEDSZ) {\n\t\th_errno = NETDB_INTERNAL;\n\t\treturn -1;\n\t}\n\n again:\n\t__UCLIBC_MUTEX_LOCK(__resolv_lock);\n\t_res_options = _res.options;\n\t__UCLIBC_MUTEX_UNLOCK(__resolv_lock);\n\tif (!(_res_options & RES_INIT)) {\n\t\tres_init(); /* our res_init never fails */\n\t\tgoto again;\n\t}\n\n#ifdef DEBUG\n\tif (_res_options & RES_DEBUG)\n\t\tprintf(\";; res_mkquery(%d, %s, %d, %d)\\n\",\n\t\t\t   op, dname && *dname ? dname : \"<null>\", class, type);\n#endif\n\n\tmemset(buf, 0, HFIXEDSZ);\n\thp = (HEADER *) buf;\n\thp->id = getpid() & 0xffff;\n\thp->opcode = op;\n\thp->rd = (_res_options & RES_RECURSE) != 0U;\n\thp->rcode = NOERROR;\n\n\tcp = buf + HFIXEDSZ;\n\tep = buf + buflen;\n\tdpp = dnptrs;\n\t*dpp++ = buf;\n\t*dpp++ = NULL;\n\tlastdnptr = dnptrs + sizeof dnptrs / sizeof dnptrs[0];\n\n\t/*\n\t * perform opcode specific processing\n\t */\n\tswitch (op) {\n\tcase QUERY:\n\tcase NS_NOTIFY_OP:\n\t\tif (ep - cp < QFIXEDSZ)\n\t\t\treturn -1;\n\n\t\tn = dn_comp(dname, cp, ep - cp - QFIXEDSZ, dnptrs, lastdnptr);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\n\t\tcp += n;\n\t\tNS_PUT16(type, cp);\n\t\tNS_PUT16(class, cp);\n\t\thp->qdcount = htons(1);\n\n\t\tif (op == QUERY || data == NULL)\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Make an additional record for completion domain.\n\t\t */\n\t\tif ((ep - cp) < RRFIXEDSZ)\n\t\t\treturn -1;\n\n\t\tn = dn_comp((const char *)data, cp, ep - cp - RRFIXEDSZ,\n\t\t\t\t\t dnptrs, lastdnptr);\n\t\tif (n < 0)\n\t\t\treturn -1;\n\n\t\tcp += n;\n\t\tNS_PUT16(T_NULL, cp);\n\t\tNS_PUT16(class, cp);\n\t\tNS_PUT32(0, cp);\n\t\tNS_PUT16(0, cp);\n\t\thp->arcount = htons(1);\n\n\t\tbreak;\n\n\tcase IQUERY:\n\t\t/*\n\t\t * Initialize answer section\n\t\t */\n\t\tif (ep - cp < 1 + RRFIXEDSZ + datalen)\n\t\t\treturn -1;\n\n\t\t*cp++ = '\\0';   /*%< no domain name */\n\t\tNS_PUT16(type, cp);\n\t\tNS_PUT16(class, cp);\n\t\tNS_PUT32(0, cp);\n\t\tNS_PUT16(datalen, cp);\n\n\t\tif (datalen) {\n\t\t\tmemcpy(cp, data, (size_t)datalen);\n\t\t\tcp += datalen;\n\t\t}\n\n\t\thp->ancount = htons(1);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -1;\n\t}\n\n\treturn cp - buf;\n}\n#endif /* L_res_data */\n\n/* Unimplemented: */\n/* res_send */\n"], "filenames": ["libc/inet/resolv.c"], "buggy_code_start_loc": [411], "buggy_code_end_loc": [2933], "fixing_code_start_loc": [412], "fixing_code_end_loc": [2994], "type": "CWE-79", "message": "In uClibc and uClibc-ng before 1.0.39, incorrect handling of special characters in domain names returned by DNS servers via gethostbyname, getaddrinfo, gethostbyaddr, and getnameinfo can lead to output of wrong hostnames (leading to domain hijacking) or injection into applications (leading to remote code execution, XSS, applications crashes, etc.). In other words, a validation step, which is expected in any stub resolver, does not occur.", "other": {"cve": {"id": "CVE-2021-43523", "sourceIdentifier": "cve@mitre.org", "published": "2021-11-10T15:15:12.213", "lastModified": "2021-11-15T14:19:43.070", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In uClibc and uClibc-ng before 1.0.39, incorrect handling of special characters in domain names returned by DNS servers via gethostbyname, getaddrinfo, gethostbyaddr, and getnameinfo can lead to output of wrong hostnames (leading to domain hijacking) or injection into applications (leading to remote code execution, XSS, applications crashes, etc.). In other words, a validation step, which is expected in any stub resolver, does not occur."}, {"lang": "es", "value": "En uClibc y uClibc-ng versiones anteriores a 1.0.39, el manejo incorrecto de los caracteres especiales en los nombres de dominio devueltos por los servidores DNS por medio de gethostbyname, getaddrinfo, gethostbyaddr y getnameinfo puede conllevar a una salida de nombres de host err\u00f3neos (conllevando al secuestro de dominios) o una inyecci\u00f3n en aplicaciones (conllevando a una ejecuci\u00f3n de c\u00f3digo remota, un ataque de tipo XSS, bloqueo de aplicaciones, etc.). En otras palabras, un paso de comprobaci\u00f3n, que se espera en cualquier stub resolver, no ocurre"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.6, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.8, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uclibc:uclibc:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.33.2", "matchCriteriaId": "2309BB0E-81D2-44E6-9BCE-7BFF25B9F77C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:uclibc-ng_project:uclibc-ng:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.0.39", "matchCriteriaId": "7096026C-F63C-4DE0-98E8-D931CC610D8A"}]}]}], "references": [{"url": "https://github.com/wbx-github/uclibc-ng/commit/0f822af0445e5348ce7b7bd8ce1204244f31d174", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://uclibc-ng.org/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2021/11/09/1", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wbx-github/uclibc-ng/commit/0f822af0445e5348ce7b7bd8ce1204244f31d174"}}