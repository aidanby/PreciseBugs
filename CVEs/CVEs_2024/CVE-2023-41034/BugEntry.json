{"buggy_code": ["/*******************************************************************************\n * Copyright (c) 2013-2015 Sierra Wireless and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n *\n * Contributors:\n *     Sierra Wireless - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.leshan.core.model;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.leshan.core.LwM2m.LwM2mVersion;\nimport org.eclipse.leshan.core.model.ResourceModel.Operations;\nimport org.eclipse.leshan.core.model.ResourceModel.Type;\nimport org.eclipse.leshan.core.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * A parser for Object DDF files.\n */\npublic class DDFFileParser {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DDFFileParser.class);\n\n    private final DocumentBuilderFactory factory;\n    private final DDFFileValidatorFactory ddfValidatorFactory;\n    private final DDFFileValidator ddfValidator;\n\n    public DDFFileParser() {\n        this(null, null);\n    }\n\n    /**\n     * Build a DDFFileParser with a given {@link DDFFileValidator}.\n     *\n     * @param ddfValidator a {@link DDFFileValidator} or {@code null} if no validation required.\n     * @since 1.1\n     */\n    public DDFFileParser(DDFFileValidator ddfValidator) {\n        this(ddfValidator, null);\n    }\n\n    /**\n     * Build a DDFFileParser with a given {@link DDFFileValidatorFactory}.\n     *\n     * @param ddfFileValidatorFactory a {@link DDFFileValidatorFactory} or {@code null} if no validation required.\n     */\n    public DDFFileParser(DDFFileValidatorFactory ddfFileValidatorFactory) {\n        this(null, ddfFileValidatorFactory);\n    }\n\n    private DDFFileParser(DDFFileValidator ddfValidator, DDFFileValidatorFactory ddfFileValidatorFactory) {\n        factory = DocumentBuilderFactory.newInstance();\n        factory.setNamespaceAware(true);\n        this.ddfValidator = ddfValidator;\n        this.ddfValidatorFactory = ddfFileValidatorFactory;\n    }\n\n    /**\n     * Parse a DDF file.\n     *\n     * @throws InvalidDDFFileException if DDF file is not a valid.\n     * @throws IOException see {@link FileInputStream#FileInputStream(File)} or\n     *         {@link DocumentBuilder#parse(InputStream)}\n     */\n    public List<ObjectModel> parse(File ddfFile) throws InvalidDDFFileException, IOException {\n        try (InputStream input = new FileInputStream(ddfFile)) {\n            return parse(input, ddfFile.getName());\n        }\n    }\n\n    /**\n     * Parse a DDF file from an inputstream.\n     *\n     * @throws InvalidDDFFileException if DDF file is not a valid.\n     * @throws IOException see {@link FileInputStream#FileInputStream(File)} or\n     *         {@link DocumentBuilder#parse(InputStream)}\n     */\n    public List<ObjectModel> parse(InputStream inputStream, String streamName)\n            throws InvalidDDFFileException, IOException {\n        streamName = streamName == null ? \"\" : streamName;\n\n        LOG.debug(\"Parsing DDF file {}\", streamName);\n\n        try {\n            // Parse XML file\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(inputStream);\n\n            // Get DDF file validator\n            LwM2mVersion lwm2mVersion;\n            DDFFileValidator ddfFileValidator;\n            if (ddfValidatorFactory != null) {\n                lwm2mVersion = ddfValidatorFactory.extractLWM2MVersion(document, streamName);\n                ddfFileValidator = ddfValidatorFactory.create(lwm2mVersion);\n            } else {\n                lwm2mVersion = null;\n                ddfFileValidator = ddfValidator;\n            }\n\n            // Validate XML against Schema\n            boolean validateDdf = ddfFileValidator != null;\n            if (validateDdf) {\n                ddfFileValidator.validate(document);\n            }\n\n            // Build list of ObjectModel\n            ArrayList<ObjectModel> objects = new ArrayList<>();\n            NodeList nodeList = document.getDocumentElement().getElementsByTagName(\"Object\");\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                objects.add(parseObject(nodeList.item(i), streamName, lwm2mVersion, validateDdf));\n            }\n            return objects;\n        } catch (InvalidDDFFileException | SAXException e) {\n            throw new InvalidDDFFileException(e, \"Invalid DDF file %s\", streamName);\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(\"Unable to create Document Builder\", e);\n        }\n    }\n\n    private ObjectModel parseObject(Node object, String streamName, LwM2mVersion schemaVersion, boolean validate)\n            throws InvalidDDFFileException {\n\n        Node objectType = object.getAttributes().getNamedItem(\"ObjectType\");\n        if (validate && (objectType == null || !\"MODefinition\".equals(objectType.getTextContent()))) {\n            throw new InvalidDDFFileException(\n                    \"Object element in %s MUST have a ObjectType attribute equals to 'MODefinition'.\", streamName);\n        }\n\n        Integer id = null;\n        String name = null;\n        String description = null;\n        String version = ObjectModel.DEFAULT_VERSION;\n        Boolean multiple = null;\n        Boolean mandatory = null;\n        Map<Integer, ResourceModel> resources = new LinkedHashMap<>();\n        String urn = null;\n        String description2 = null;\n        String lwm2mVersion = LwM2mVersion.getDefault().toString();\n\n        for (int i = 0; i < object.getChildNodes().getLength(); i++) {\n            Node field = object.getChildNodes().item(i);\n            if (field.getNodeType() != Node.ELEMENT_NODE)\n                continue;\n\n            switch (field.getNodeName()) {\n            case \"ObjectID\":\n                id = Integer.valueOf(field.getTextContent());\n                break;\n            case \"Name\":\n                name = field.getTextContent();\n                break;\n            case \"Description1\":\n                description = field.getTextContent();\n                break;\n            case \"ObjectVersion\":\n                if (!StringUtils.isEmpty(field.getTextContent())) {\n                    version = field.getTextContent();\n                }\n                break;\n            case \"MultipleInstances\":\n                if (\"Multiple\".equals(field.getTextContent())) {\n                    multiple = true;\n                } else if (\"Single\".equals(field.getTextContent())) {\n                    multiple = false;\n                }\n                break;\n            case \"Mandatory\":\n                if (\"Mandatory\".equals(field.getTextContent())) {\n                    mandatory = true;\n                } else if (\"Optional\".equals(field.getTextContent())) {\n                    mandatory = false;\n                }\n                break;\n            case \"Resources\":\n                for (int j = 0; j < field.getChildNodes().getLength(); j++) {\n                    Node item = field.getChildNodes().item(j);\n                    if (item.getNodeType() != Node.ELEMENT_NODE)\n                        continue;\n\n                    if (item.getNodeName().equals(\"Item\")) {\n                        ResourceModel resource = this.parseResource(item, streamName);\n                        if (validate && resources.containsKey(resource.id)) {\n                            throw new InvalidDDFFileException(\n                                    \"Object %s in %s contains at least 2 resources with same id %s.\",\n                                    id != null ? id : \"\", streamName, resource.id);\n                        } else {\n                            resources.put(resource.id, resource);\n                        }\n                    }\n                }\n                break;\n            case \"ObjectURN\":\n                urn = field.getTextContent();\n                break;\n            case \"LWM2MVersion\":\n                if (!StringUtils.isEmpty(field.getTextContent())) {\n                    lwm2mVersion = field.getTextContent();\n                    if (schemaVersion != null && !schemaVersion.toString().equals(lwm2mVersion)) {\n                        throw new InvalidDDFFileException(\n                                \"LWM2MVersion is not consistent with xml schema(xsi:noNamespaceSchemaLocation) in %s : %s  expected but was %s.\",\n                                streamName, schemaVersion, lwm2mVersion);\n                    }\n                }\n                break;\n            case \"Description2\":\n                description2 = field.getTextContent();\n                break;\n            default:\n                break;\n            }\n        }\n\n        return new ObjectModel(id, name, description, version, multiple, mandatory, resources.values(), urn,\n                lwm2mVersion, description2);\n\n    }\n\n    private ResourceModel parseResource(Node item, String streamName) throws DOMException, InvalidDDFFileException {\n\n        Integer id = Integer.valueOf(item.getAttributes().getNamedItem(\"ID\").getTextContent());\n        String name = null;\n        Operations operations = null;\n        Boolean multiple = false;\n        Boolean mandatory = false;\n        Type type = null;\n        String rangeEnumeration = null;\n        String units = null;\n        String description = null;\n\n        for (int i = 0; i < item.getChildNodes().getLength(); i++) {\n            Node field = item.getChildNodes().item(i);\n            if (field.getNodeType() != Node.ELEMENT_NODE)\n                continue;\n\n            switch (field.getNodeName()) {\n            case \"Name\":\n                name = field.getTextContent();\n                break;\n            case \"Operations\":\n                String strOp = field.getTextContent();\n                if (strOp != null && !strOp.isEmpty()) {\n                    operations = Operations.valueOf(strOp);\n                } else {\n                    operations = Operations.NONE;\n                }\n                break;\n            case \"MultipleInstances\":\n                if (\"Multiple\".equals(field.getTextContent())) {\n                    multiple = true;\n                } else if (\"Single\".equals(field.getTextContent())) {\n                    multiple = false;\n                }\n                break;\n            case \"Mandatory\":\n                if (\"Mandatory\".equals(field.getTextContent())) {\n                    mandatory = true;\n                } else if (\"Optional\".equals(field.getTextContent())) {\n                    mandatory = false;\n                }\n                break;\n            case \"Type\":\n                switch (field.getTextContent()) {\n                case \"String\":\n                    type = Type.STRING;\n                    break;\n                case \"Integer\":\n                    type = Type.INTEGER;\n                    break;\n                case \"Float\":\n                    type = Type.FLOAT;\n                    break;\n                case \"Boolean\":\n                    type = Type.BOOLEAN;\n                    break;\n                case \"Opaque\":\n                    type = Type.OPAQUE;\n                    break;\n                case \"Time\":\n                    type = Type.TIME;\n                    break;\n                case \"Objlnk\":\n                    type = Type.OBJLNK;\n                    break;\n                case \"Unsigned Integer\":\n                    type = Type.UNSIGNED_INTEGER;\n                    break;\n                case \"Corelnk\":\n                    type = Type.CORELINK;\n                    break;\n                case \"\":\n                    type = Type.NONE;\n                    break;\n                default:\n                    break;\n                }\n                break;\n            case \"RangeEnumeration\":\n                rangeEnumeration = field.getTextContent();\n                break;\n            case \"Units\":\n                units = field.getTextContent();\n                break;\n            case \"Description\":\n                description = field.getTextContent();\n                break;\n            default:\n                break;\n            }\n        }\n        return new ResourceModel(id, name, operations, multiple, mandatory, type, rangeEnumeration, units, description);\n    }\n}\n", "/*******************************************************************************\n * Copyright (c) 2020 Sierra Wireless and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n *\n * Contributors:\n *     Sierra Wireless - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.leshan.core.model;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\n\nimport org.eclipse.leshan.core.LwM2m.LwM2mVersion;\nimport org.eclipse.leshan.core.util.Validate;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\n\n/**\n * A DDF File Validator.\n * <p>\n * Validate a DDF File against the embedded LWM2M schema.\n * <p>\n * Support LWM2M version 1.0 and 1.1.\n */\n\npublic class DefaultDDFFileValidator implements DDFFileValidator {\n    private static String LWM2M_V1_0_SCHEMA_PATH = \"/schemas/LWM2M.xsd\";\n    private static String LWM2M_V1_1_SCHEMA_PATH = \"/schemas/LWM2M-v1_1.xsd\";\n\n    private final String schema;\n\n    /**\n     * Create a {@link DDFFileValidator} using the LWM2M v1.1 schema.\n     */\n    public DefaultDDFFileValidator() {\n        this(LwM2mVersion.V1_1);\n    }\n\n    /**\n     * Create a {@link DDFFileValidator} using schema corresponding to LWM2M {@link LwM2mVersion}.\n     */\n    public DefaultDDFFileValidator(LwM2mVersion version) {\n        Validate.notNull(version, \"version must not be null\");\n        if (LwM2mVersion.V1_0.equals(version)) {\n            schema = LWM2M_V1_0_SCHEMA_PATH;\n        } else if (LwM2mVersion.V1_1.equals(version)) {\n            schema = LWM2M_V1_1_SCHEMA_PATH;\n        } else {\n            throw new IllegalStateException(String.format(\"Unsupported version %s\", version));\n        }\n    }\n\n    @Override\n    public void validate(Node xmlToValidate) throws InvalidDDFFileException {\n        try {\n            validate(new DOMSource(xmlToValidate));\n        } catch (SAXException | IOException e) {\n            throw new InvalidDDFFileException(e);\n        }\n    }\n\n    /**\n     * Validate a XML {@link Source} against the embedded LWM2M Schema.\n     *\n     * @param xmlToValidate an XML source to validate\n     * @throws SAXException see {@link Validator#validate(Source)}\n     * @throws IOException see {@link Validator#validate(Source)}\n     */\n    public void validate(Source xmlToValidate) throws SAXException, IOException {\n        Validator validator = getEmbeddedLwM2mSchema().newValidator();\n        validator.validate(xmlToValidate);\n    }\n\n    /**\n     * Get the Embedded the LWM2M.xsd Schema.\n     *\n     * @throws SAXException see {@link SchemaFactory#newSchema(Source)}\n     */\n    protected Schema getEmbeddedLwM2mSchema() throws SAXException {\n        InputStream inputStream = DDFFileValidator.class.getResourceAsStream(schema);\n        Source source = new StreamSource(inputStream);\n        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        return schemaFactory.newSchema(source);\n    }\n}\n"], "fixing_code": ["/*******************************************************************************\n * Copyright (c) 2013-2015 Sierra Wireless and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n *\n * Contributors:\n *     Sierra Wireless - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.leshan.core.model;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\n\nimport org.eclipse.leshan.core.LwM2m.LwM2mVersion;\nimport org.eclipse.leshan.core.model.ResourceModel.Operations;\nimport org.eclipse.leshan.core.model.ResourceModel.Type;\nimport org.eclipse.leshan.core.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.w3c.dom.DOMException;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.SAXException;\n\n/**\n * A parser for Object DDF files.\n */\npublic class DDFFileParser {\n\n    private static final Logger LOG = LoggerFactory.getLogger(DDFFileParser.class);\n\n    private final DocumentBuilderFactory factory;\n    private final DDFFileValidatorFactory ddfValidatorFactory;\n    private final DDFFileValidator ddfValidator;\n\n    public DDFFileParser() {\n        this(null, null);\n    }\n\n    /**\n     * Build a DDFFileParser with a given {@link DDFFileValidator}.\n     *\n     * @param ddfValidator a {@link DDFFileValidator} or {@code null} if no validation required.\n     * @since 1.1\n     */\n    public DDFFileParser(DDFFileValidator ddfValidator) {\n        this(ddfValidator, null);\n    }\n\n    /**\n     * Build a DDFFileParser with a given {@link DDFFileValidatorFactory}.\n     *\n     * @param ddfFileValidatorFactory a {@link DDFFileValidatorFactory} or {@code null} if no validation required.\n     */\n    public DDFFileParser(DDFFileValidatorFactory ddfFileValidatorFactory) {\n        this(null, ddfFileValidatorFactory);\n    }\n\n    private DDFFileParser(DDFFileValidator ddfValidator, DDFFileValidatorFactory ddfFileValidatorFactory) {\n        this.factory = createDocumentBuilderFactory();\n        this.ddfValidator = ddfValidator;\n        this.ddfValidatorFactory = ddfFileValidatorFactory;\n    }\n\n    protected DocumentBuilderFactory createDocumentBuilderFactory() {\n        DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n        try {\n            // Create Safe DocumentBuilderFactory (not vulnerable to XXE Attacks)\n            // -----------------------------------------------------------------\n            // There is several recommendation from different source we try to apply all, even if some are maybe\n            // redundant.\n\n            // from :\n            // https://semgrep.dev/docs/cheat-sheets/java-xxe/\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n            // from :\n            // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#jaxp-documentbuilderfactory-saxparserfactory-and-dom4j\n            factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true); // Disable DTDs\n            factory.setXIncludeAware(false); // Disable XML Inclusions\n\n            // from :\n            // https://community.veracode.com/s/article/Java-Remediation-Guidance-for-XXE\n            factory.setExpandEntityReferences(false); // disable expand entity reference nodes\n\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(\"Unable to create DocumentBuilderFactory\", e);\n        }\n        factory.setNamespaceAware(true);\n        return factory;\n    }\n\n    /**\n     * Parse a DDF file.\n     *\n     * @throws InvalidDDFFileException if DDF file is not a valid.\n     * @throws IOException see {@link FileInputStream#FileInputStream(File)} or\n     *         {@link DocumentBuilder#parse(InputStream)}\n     */\n    public List<ObjectModel> parse(File ddfFile) throws InvalidDDFFileException, IOException {\n        try (InputStream input = new FileInputStream(ddfFile)) {\n            return parse(input, ddfFile.getName());\n        }\n    }\n\n    /**\n     * Parse a DDF file from an inputstream.\n     *\n     * @throws InvalidDDFFileException if DDF file is not a valid.\n     * @throws IOException see {@link FileInputStream#FileInputStream(File)} or\n     *         {@link DocumentBuilder#parse(InputStream)}\n     */\n    public List<ObjectModel> parse(InputStream inputStream, String streamName)\n            throws InvalidDDFFileException, IOException {\n        streamName = streamName == null ? \"\" : streamName;\n\n        LOG.debug(\"Parsing DDF file {}\", streamName);\n\n        try {\n            // Parse XML file\n            DocumentBuilder builder = factory.newDocumentBuilder();\n            Document document = builder.parse(inputStream);\n\n            // Get DDF file validator\n            LwM2mVersion lwm2mVersion;\n            DDFFileValidator ddfFileValidator;\n            if (ddfValidatorFactory != null) {\n                lwm2mVersion = ddfValidatorFactory.extractLWM2MVersion(document, streamName);\n                ddfFileValidator = ddfValidatorFactory.create(lwm2mVersion);\n            } else {\n                lwm2mVersion = null;\n                ddfFileValidator = ddfValidator;\n            }\n\n            // Validate XML against Schema\n            boolean validateDdf = ddfFileValidator != null;\n            if (validateDdf) {\n                ddfFileValidator.validate(document);\n            }\n\n            // Build list of ObjectModel\n            ArrayList<ObjectModel> objects = new ArrayList<>();\n            NodeList nodeList = document.getDocumentElement().getElementsByTagName(\"Object\");\n            for (int i = 0; i < nodeList.getLength(); i++) {\n                objects.add(parseObject(nodeList.item(i), streamName, lwm2mVersion, validateDdf));\n            }\n            return objects;\n        } catch (InvalidDDFFileException | SAXException e) {\n            throw new InvalidDDFFileException(e, \"Invalid DDF file %s\", streamName);\n        } catch (ParserConfigurationException e) {\n            throw new IllegalStateException(\"Unable to create Document Builder\", e);\n        }\n    }\n\n    private ObjectModel parseObject(Node object, String streamName, LwM2mVersion schemaVersion, boolean validate)\n            throws InvalidDDFFileException {\n\n        Node objectType = object.getAttributes().getNamedItem(\"ObjectType\");\n        if (validate && (objectType == null || !\"MODefinition\".equals(objectType.getTextContent()))) {\n            throw new InvalidDDFFileException(\n                    \"Object element in %s MUST have a ObjectType attribute equals to 'MODefinition'.\", streamName);\n        }\n\n        Integer id = null;\n        String name = null;\n        String description = null;\n        String version = ObjectModel.DEFAULT_VERSION;\n        Boolean multiple = null;\n        Boolean mandatory = null;\n        Map<Integer, ResourceModel> resources = new LinkedHashMap<>();\n        String urn = null;\n        String description2 = null;\n        String lwm2mVersion = LwM2mVersion.getDefault().toString();\n\n        for (int i = 0; i < object.getChildNodes().getLength(); i++) {\n            Node field = object.getChildNodes().item(i);\n            if (field.getNodeType() != Node.ELEMENT_NODE)\n                continue;\n\n            switch (field.getNodeName()) {\n            case \"ObjectID\":\n                id = Integer.valueOf(field.getTextContent());\n                break;\n            case \"Name\":\n                name = field.getTextContent();\n                break;\n            case \"Description1\":\n                description = field.getTextContent();\n                break;\n            case \"ObjectVersion\":\n                if (!StringUtils.isEmpty(field.getTextContent())) {\n                    version = field.getTextContent();\n                }\n                break;\n            case \"MultipleInstances\":\n                if (\"Multiple\".equals(field.getTextContent())) {\n                    multiple = true;\n                } else if (\"Single\".equals(field.getTextContent())) {\n                    multiple = false;\n                }\n                break;\n            case \"Mandatory\":\n                if (\"Mandatory\".equals(field.getTextContent())) {\n                    mandatory = true;\n                } else if (\"Optional\".equals(field.getTextContent())) {\n                    mandatory = false;\n                }\n                break;\n            case \"Resources\":\n                for (int j = 0; j < field.getChildNodes().getLength(); j++) {\n                    Node item = field.getChildNodes().item(j);\n                    if (item.getNodeType() != Node.ELEMENT_NODE)\n                        continue;\n\n                    if (item.getNodeName().equals(\"Item\")) {\n                        ResourceModel resource = this.parseResource(item, streamName);\n                        if (validate && resources.containsKey(resource.id)) {\n                            throw new InvalidDDFFileException(\n                                    \"Object %s in %s contains at least 2 resources with same id %s.\",\n                                    id != null ? id : \"\", streamName, resource.id);\n                        } else {\n                            resources.put(resource.id, resource);\n                        }\n                    }\n                }\n                break;\n            case \"ObjectURN\":\n                urn = field.getTextContent();\n                break;\n            case \"LWM2MVersion\":\n                if (!StringUtils.isEmpty(field.getTextContent())) {\n                    lwm2mVersion = field.getTextContent();\n                    if (schemaVersion != null && !schemaVersion.toString().equals(lwm2mVersion)) {\n                        throw new InvalidDDFFileException(\n                                \"LWM2MVersion is not consistent with xml schema(xsi:noNamespaceSchemaLocation) in %s : %s  expected but was %s.\",\n                                streamName, schemaVersion, lwm2mVersion);\n                    }\n                }\n                break;\n            case \"Description2\":\n                description2 = field.getTextContent();\n                break;\n            default:\n                break;\n            }\n        }\n\n        return new ObjectModel(id, name, description, version, multiple, mandatory, resources.values(), urn,\n                lwm2mVersion, description2);\n\n    }\n\n    private ResourceModel parseResource(Node item, String streamName) throws DOMException, InvalidDDFFileException {\n\n        Integer id = Integer.valueOf(item.getAttributes().getNamedItem(\"ID\").getTextContent());\n        String name = null;\n        Operations operations = null;\n        Boolean multiple = false;\n        Boolean mandatory = false;\n        Type type = null;\n        String rangeEnumeration = null;\n        String units = null;\n        String description = null;\n\n        for (int i = 0; i < item.getChildNodes().getLength(); i++) {\n            Node field = item.getChildNodes().item(i);\n            if (field.getNodeType() != Node.ELEMENT_NODE)\n                continue;\n\n            switch (field.getNodeName()) {\n            case \"Name\":\n                name = field.getTextContent();\n                break;\n            case \"Operations\":\n                String strOp = field.getTextContent();\n                if (strOp != null && !strOp.isEmpty()) {\n                    operations = Operations.valueOf(strOp);\n                } else {\n                    operations = Operations.NONE;\n                }\n                break;\n            case \"MultipleInstances\":\n                if (\"Multiple\".equals(field.getTextContent())) {\n                    multiple = true;\n                } else if (\"Single\".equals(field.getTextContent())) {\n                    multiple = false;\n                }\n                break;\n            case \"Mandatory\":\n                if (\"Mandatory\".equals(field.getTextContent())) {\n                    mandatory = true;\n                } else if (\"Optional\".equals(field.getTextContent())) {\n                    mandatory = false;\n                }\n                break;\n            case \"Type\":\n                switch (field.getTextContent()) {\n                case \"String\":\n                    type = Type.STRING;\n                    break;\n                case \"Integer\":\n                    type = Type.INTEGER;\n                    break;\n                case \"Float\":\n                    type = Type.FLOAT;\n                    break;\n                case \"Boolean\":\n                    type = Type.BOOLEAN;\n                    break;\n                case \"Opaque\":\n                    type = Type.OPAQUE;\n                    break;\n                case \"Time\":\n                    type = Type.TIME;\n                    break;\n                case \"Objlnk\":\n                    type = Type.OBJLNK;\n                    break;\n                case \"Unsigned Integer\":\n                    type = Type.UNSIGNED_INTEGER;\n                    break;\n                case \"Corelnk\":\n                    type = Type.CORELINK;\n                    break;\n                case \"\":\n                    type = Type.NONE;\n                    break;\n                default:\n                    break;\n                }\n                break;\n            case \"RangeEnumeration\":\n                rangeEnumeration = field.getTextContent();\n                break;\n            case \"Units\":\n                units = field.getTextContent();\n                break;\n            case \"Description\":\n                description = field.getTextContent();\n                break;\n            default:\n                break;\n            }\n        }\n        return new ResourceModel(id, name, operations, multiple, mandatory, type, rangeEnumeration, units, description);\n    }\n}\n", "/*******************************************************************************\n * Copyright (c) 2020 Sierra Wireless and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v2.0\n * and Eclipse Distribution License v1.0 which accompany this distribution.\n *\n * The Eclipse Public License is available at\n *    http://www.eclipse.org/legal/epl-v20.html\n * and the Eclipse Distribution License is available at\n *    http://www.eclipse.org/org/documents/edl-v10.html.\n *\n * Contributors:\n *     Sierra Wireless - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.leshan.core.model;\n\nimport java.io.IOException;\nimport java.io.InputStream;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.transform.Source;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.Schema;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\n\nimport org.eclipse.leshan.core.LwM2m.LwM2mVersion;\nimport org.eclipse.leshan.core.util.Validate;\nimport org.w3c.dom.Node;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXNotRecognizedException;\nimport org.xml.sax.SAXNotSupportedException;\n\n/**\n * A DDF File Validator.\n * <p>\n * Validate a DDF File against the embedded LWM2M schema.\n * <p>\n * Support LWM2M version 1.0 and 1.1.\n */\n\npublic class DefaultDDFFileValidator implements DDFFileValidator {\n    private static String LWM2M_V1_0_SCHEMA_PATH = \"/schemas/LWM2M.xsd\";\n    private static String LWM2M_V1_1_SCHEMA_PATH = \"/schemas/LWM2M-v1_1.xsd\";\n\n    private final String schema;\n\n    /**\n     * Create a {@link DDFFileValidator} using the LWM2M v1.1 schema.\n     */\n    public DefaultDDFFileValidator() {\n        this(LwM2mVersion.V1_1);\n    }\n\n    /**\n     * Create a {@link DDFFileValidator} using schema corresponding to LWM2M {@link LwM2mVersion}.\n     */\n    public DefaultDDFFileValidator(LwM2mVersion version) {\n        Validate.notNull(version, \"version must not be null\");\n        if (LwM2mVersion.V1_0.equals(version)) {\n            schema = LWM2M_V1_0_SCHEMA_PATH;\n        } else if (LwM2mVersion.V1_1.equals(version)) {\n            schema = LWM2M_V1_1_SCHEMA_PATH;\n        } else {\n            throw new IllegalStateException(String.format(\"Unsupported version %s\", version));\n        }\n    }\n\n    @Override\n    public void validate(Node xmlToValidate) throws InvalidDDFFileException {\n        try {\n            validate(new DOMSource(xmlToValidate));\n        } catch (SAXException | IOException e) {\n            throw new InvalidDDFFileException(e);\n        }\n    }\n\n    /**\n     * Validate a XML {@link Source} against the embedded LWM2M Schema.\n     *\n     * @param xmlToValidate an XML source to validate\n     * @throws SAXException see {@link Validator#validate(Source)}\n     * @throws IOException see {@link Validator#validate(Source)}\n     */\n    public void validate(Source xmlToValidate) throws SAXException, IOException {\n        Validator validator = getEmbeddedLwM2mSchema().newValidator();\n        validator.validate(xmlToValidate);\n    }\n\n    /**\n     * Get the Embedded the LWM2M.xsd Schema.\n     *\n     * @throws SAXException see {@link SchemaFactory#newSchema(Source)}\n     */\n    protected Schema getEmbeddedLwM2mSchema() throws SAXException {\n        InputStream inputStream = DDFFileValidator.class.getResourceAsStream(schema);\n        Source source = new StreamSource(inputStream);\n        SchemaFactory schemaFactory = createSchemaFactory();\n        return schemaFactory.newSchema(source);\n    }\n\n    protected SchemaFactory createSchemaFactory() {\n        SchemaFactory factory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n        try {\n            // Create Safe SchemaFactory (not vulnerable to XXE Attacks)\n            // --------------------------------------------------------\n            // There is several recommendation from different source we try to apply all, even if some are maybe\n            // redundant.\n\n            // from :\n            // https://semgrep.dev/docs/cheat-sheets/java-xxe/\n            factory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);\n\n            // from :\n            // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#schemafactory\n            factory.setProperty(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            factory.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n\n        } catch (SAXNotRecognizedException | SAXNotSupportedException e) {\n            throw new IllegalStateException(\"Unable to create SchemaFactory\", e);\n        }\n        return factory;\n    }\n}\n"], "filenames": ["leshan-core/src/main/java/org/eclipse/leshan/core/model/DDFFileParser.java", "leshan-core/src/main/java/org/eclipse/leshan/core/model/DefaultDDFFileValidator.java"], "buggy_code_start_loc": [26, 32], "buggy_code_end_loc": [81, 100], "fixing_code_start_loc": [27, 33], "fixing_code_end_loc": [110, 126], "type": "CWE-611", "message": "Eclipse Leshan is a device management server and client Java implementation. In affected versions DDFFileParser` and `DefaultDDFFileValidator` (and so `ObjectLoader`) are vulnerable to `XXE Attacks`. A DDF file is a LWM2M format used to store LWM2M object description. Leshan users are impacted only if they parse untrusted DDF files (e.g. if they let external users provide their own model), in that case they MUST upgrade to fixed version. If you parse only trusted DDF file and validate only with trusted xml schema, upgrading is not mandatory.  This issue has been fixed in versions 1.5.0 and 2.0.0-M13. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-41034", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-31T18:15:09.020", "lastModified": "2023-09-06T19:02:03.790", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Eclipse Leshan is a device management server and client Java implementation. In affected versions DDFFileParser` and `DefaultDDFFileValidator` (and so `ObjectLoader`) are vulnerable to `XXE Attacks`. A DDF file is a LWM2M format used to store LWM2M object description. Leshan users are impacted only if they parse untrusted DDF files (e.g. if they let external users provide their own model), in that case they MUST upgrade to fixed version. If you parse only trusted DDF file and validate only with trusted xml schema, upgrading is not mandatory.  This issue has been fixed in versions 1.5.0 and 2.0.0-M13. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 4.2}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-611"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.5.0", "matchCriteriaId": "0BAB8220-65D9-49C4-A405-E467D18DA48B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone1:*:*:*:*:*:*", "matchCriteriaId": "A9CD995F-4DDF-4E8A-BCF9-B70128AC91A0"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone10:*:*:*:*:*:*", "matchCriteriaId": "966926A3-EF5B-4478-A78E-37D664221ECB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone11:*:*:*:*:*:*", "matchCriteriaId": "C22BE585-DC78-4483-B7CF-C9315873C913"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone12:*:*:*:*:*:*", "matchCriteriaId": "92268218-018E-4924-A2CF-2D2DB4D36F11"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone2:*:*:*:*:*:*", "matchCriteriaId": "A4055FDA-E535-4675-B6D3-812D7A3E9C1B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone3:*:*:*:*:*:*", "matchCriteriaId": "A700BAD9-5289-49DB-9B9E-E7710522086E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone4:*:*:*:*:*:*", "matchCriteriaId": "7CE7B0A5-CF9B-469F-9DB6-4CCEB0F36269"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone5:*:*:*:*:*:*", "matchCriteriaId": "E7E15E8A-B316-4CD5-9330-14F6A7E2C69C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone6:*:*:*:*:*:*", "matchCriteriaId": "FFD798EF-A5BD-4E21-ABA4-F3AD00E9E7C7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone7:*:*:*:*:*:*", "matchCriteriaId": "93448A3D-67AB-474C-AEFA-ABBD7DD7B9E1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone8:*:*:*:*:*:*", "matchCriteriaId": "B52ECC69-1524-4581-88AE-4CE7DC47DC33"}, {"vulnerable": true, "criteria": "cpe:2.3:a:eclipse:leshan:2.0.0:milestone9:*:*:*:*:*:*", "matchCriteriaId": "2254C713-BE7F-40D7-BDF3-901C03406FA7"}]}]}], "references": [{"url": "https://github.com/eclipse-leshan/leshan/commit/29577d2879ba8e7674c3b216a7f01193fc7ae013", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/eclipse-leshan/leshan/commit/4d3e63ac271a817f81fba3e3229c519af7a3049c", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/eclipse-leshan/leshan/security/advisories/GHSA-wc9j-gc65-3cm7", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}, {"url": "https://github.com/eclipse-leshan/leshan/wiki/Adding-new-objects#the-lwm2m-model", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing", "source": "security-advisories@github.com", "tags": ["Not Applicable"]}]}, "github_commit_url": "https://github.com/eclipse-leshan/leshan/commit/29577d2879ba8e7674c3b216a7f01193fc7ae013"}}