{"buggy_code": ["/*\n  Copyright (c) 2012, Nils Schneider <nils@nilsschneider.net>\n  Copyright (c) 2016, Matthias Schiffer <mschiffer@universe-factory.net>\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n       this list of conditions and the following disclaimer.\n    2. Redistributions in binary form must reproduce the above copyright notice,\n       this list of conditions and the following disclaimer in the documentation\n       and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <ecdsautil/ecdsa.h>\n#include <ecdsautil/sha256.h>\n\n#include <string.h>\n\n\nbool ecdsa_is_valid_pubkey(const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t work;\n\n  if (ecc_25519_is_identity(pubkey))\n    return false;\n\n  // q * pubkey should be identity element\n  ecc_25519_scalarmult(&work, &ecc_25519_gf_order, pubkey);\n  return ecc_25519_is_identity(&work);\n}\n\n\n// Generate k according to RFC6979 (Deterministic DSA/ECDSA)\nstatic void generate_k_prepare(uint8_t V[32], uint8_t K[32], const uint8_t x[32], const uint8_t m[32]) {\n  memset(V, 0x01, 32); // b.\n  memset(K, 0x00, 32); // c.\n\n  {\n    uint8_t input[32+1+32+32];\n    memcpy(input, V, 32);\n    input[32] = 0x00;\n    memcpy(input+32+1, x, 32);\n    memcpy(input+32+1+32, m, 32);\n    ecdsa_sha256_hmac(K, K, input, sizeof(input)); // d.\n  }\n\n  ecdsa_sha256_hmac(V, K, V, 32); // e.\n\n  {\n    uint8_t input[32+1+32+32];\n    memcpy(input, V, 32);\n    input[32] = 0x01;\n    memcpy(input+32+1, x, 32);\n    memcpy(input+32+1+32, m, 32);\n    ecdsa_sha256_hmac(K, K, input, sizeof(input)); // f.\n  }\n\n  ecdsa_sha256_hmac(V, K, V, 32); // g.\n}\n\nstatic void generate_k(uint8_t k[32], uint8_t V[32], uint8_t K[32]) {\n  // h.\n  // Note that T = V, as qlen = hlen\n  ecdsa_sha256_hmac(V, K, V, 32);\n  memcpy(k, V, 32);\n\n  // The following steps are preparation for the next iteration (in case the generated k is invalid)\n  {\n    uint8_t input[32+1];\n    memcpy(input, V, 32);\n    input[32] = 0x00;\n    ecdsa_sha256_hmac(K, K, input, sizeof(input));\n  }\n  ecdsa_sha256_hmac(V, K, V, 32);\n}\n\nvoid ecdsa_sign_legacy(ecdsa_signature_t *signature, const ecc_int256_t *hash, const ecc_int256_t *secret) {\n  ecc_int256_t hash_r, k, krecip, tmp;\n  ecc_25519_work_t kG;\n  uint8_t V[32], K[32];\n\n  // Reduce hash (instead of clearing 3 bits)\n  ecc_25519_gf_reduce(&hash_r, hash);\n\n  // Generate k\n  generate_k_prepare(V, K, secret->p, hash_r.p);\n\nregenerate:\n  generate_k(k.p, V, K);\n  ecc_25519_gf_sanitize_secret(&k, &k);\n\n  // calculate k^(-1)\n  ecc_25519_gf_recip(&krecip, &k);\n\n  // calculate kG = k * base point\n  ecc_25519_scalarmult_base(&kG, &k);\n\n  // store x coordinate of kG in r\n  ecc_25519_store_xy_legacy(&tmp, NULL, &kG);\n  ecc_25519_gf_reduce(&signature->r, &tmp);\n\n  if (ecc_25519_gf_is_zero(&signature->r))\n    goto regenerate;\n\n  // tmp = r * secret\n  ecc_25519_gf_mult(&tmp, &signature->r, secret);\n\n  // s = hash + tmp = hash + r * secret\n  ecc_25519_gf_add(&signature->s, &hash_r, &tmp);\n\n  // tmp = krecip * s = k^(-1) * s\n  ecc_25519_gf_mult(&tmp, &krecip, &signature->s);\n\n  // mod n (order of G)\n  ecc_25519_gf_reduce(&signature->s, &tmp);\n\n  if (ecc_25519_gf_is_zero(&signature->s))\n    goto regenerate;\n}\n\n\nvoid ecdsa_verify_prepare_legacy(ecdsa_verify_context_t *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {\n  ecc_int256_t w, u1, tmp;\n\n  ctx->r = signature->r;\n\n  ecc_25519_gf_recip(&w, &signature->s);\n  ecc_25519_gf_reduce(&tmp, hash);\n  ecc_25519_gf_mult(&u1, &tmp, &w);\n  ecc_25519_gf_mult(&ctx->u2, &ctx->r, &w);\n  ecc_25519_scalarmult_base(&ctx->s1, &u1);\n}\n\n\nbool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t s2, work;\n  ecc_int256_t w, tmp;\n\n  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);\n  ecc_25519_add(&work, &ctx->s1, &s2);\n  ecc_25519_store_xy_legacy(&w, NULL, &work);\n  ecc_25519_gf_sub(&tmp, &ctx->r, &w);\n\n  return ecc_25519_gf_is_zero(&tmp);\n}\n\n\nsize_t ecdsa_verify_list_legacy(const ecdsa_verify_context_t *ctxs, size_t n_ctxs, const ecc_25519_work_t *pubkeys, size_t n_pubkeys) {\n  size_t ret = 0, i, j;\n\n  bool used[n_pubkeys];\n  memset(used, 0, sizeof(used));\n\n  for (i = 0; i < n_ctxs; i++) {\n    for (j = 0; j < n_pubkeys; j++) {\n      if (used[j])\n        continue;\n\n      if (ecdsa_verify_legacy(&ctxs[i], &pubkeys[j])) {\n        ret++;\n        used[j] = true;\n        break;\n      }\n    }\n  }\n\n  return ret;\n}\n"], "fixing_code": ["/*\n  Copyright (c) 2012, Nils Schneider <nils@nilsschneider.net>\n  Copyright (c) 2016, Matthias Schiffer <mschiffer@universe-factory.net>\n  All rights reserved.\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    1. Redistributions of source code must retain the above copyright notice,\n       this list of conditions and the following disclaimer.\n    2. Redistributions in binary form must reproduce the above copyright notice,\n       this list of conditions and the following disclaimer in the documentation\n       and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE\n  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\n#include <ecdsautil/ecdsa.h>\n#include <ecdsautil/sha256.h>\n\n#include <string.h>\n\n\nbool ecdsa_is_valid_pubkey(const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t work;\n\n  if (ecc_25519_is_identity(pubkey))\n    return false;\n\n  // q * pubkey should be identity element\n  ecc_25519_scalarmult(&work, &ecc_25519_gf_order, pubkey);\n  return ecc_25519_is_identity(&work);\n}\n\n\n// Generate k according to RFC6979 (Deterministic DSA/ECDSA)\nstatic void generate_k_prepare(uint8_t V[32], uint8_t K[32], const uint8_t x[32], const uint8_t m[32]) {\n  memset(V, 0x01, 32); // b.\n  memset(K, 0x00, 32); // c.\n\n  {\n    uint8_t input[32+1+32+32];\n    memcpy(input, V, 32);\n    input[32] = 0x00;\n    memcpy(input+32+1, x, 32);\n    memcpy(input+32+1+32, m, 32);\n    ecdsa_sha256_hmac(K, K, input, sizeof(input)); // d.\n  }\n\n  ecdsa_sha256_hmac(V, K, V, 32); // e.\n\n  {\n    uint8_t input[32+1+32+32];\n    memcpy(input, V, 32);\n    input[32] = 0x01;\n    memcpy(input+32+1, x, 32);\n    memcpy(input+32+1+32, m, 32);\n    ecdsa_sha256_hmac(K, K, input, sizeof(input)); // f.\n  }\n\n  ecdsa_sha256_hmac(V, K, V, 32); // g.\n}\n\nstatic void generate_k(uint8_t k[32], uint8_t V[32], uint8_t K[32]) {\n  // h.\n  // Note that T = V, as qlen = hlen\n  ecdsa_sha256_hmac(V, K, V, 32);\n  memcpy(k, V, 32);\n\n  // The following steps are preparation for the next iteration (in case the generated k is invalid)\n  {\n    uint8_t input[32+1];\n    memcpy(input, V, 32);\n    input[32] = 0x00;\n    ecdsa_sha256_hmac(K, K, input, sizeof(input));\n  }\n  ecdsa_sha256_hmac(V, K, V, 32);\n}\n\nvoid ecdsa_sign_legacy(ecdsa_signature_t *signature, const ecc_int256_t *hash, const ecc_int256_t *secret) {\n  ecc_int256_t hash_r, k, krecip, tmp;\n  ecc_25519_work_t kG;\n  uint8_t V[32], K[32];\n\n  // Reduce hash (instead of clearing 3 bits)\n  ecc_25519_gf_reduce(&hash_r, hash);\n\n  // Generate k\n  generate_k_prepare(V, K, secret->p, hash_r.p);\n\nregenerate:\n  generate_k(k.p, V, K);\n  ecc_25519_gf_sanitize_secret(&k, &k);\n\n  // calculate k^(-1)\n  ecc_25519_gf_recip(&krecip, &k);\n\n  // calculate kG = k * base point\n  ecc_25519_scalarmult_base(&kG, &k);\n\n  // store x coordinate of kG in r\n  ecc_25519_store_xy_legacy(&tmp, NULL, &kG);\n  ecc_25519_gf_reduce(&signature->r, &tmp);\n\n  if (ecc_25519_gf_is_zero(&signature->r))\n    goto regenerate;\n\n  // tmp = r * secret\n  ecc_25519_gf_mult(&tmp, &signature->r, secret);\n\n  // s = hash + tmp = hash + r * secret\n  ecc_25519_gf_add(&signature->s, &hash_r, &tmp);\n\n  // tmp = krecip * s = k^(-1) * s\n  ecc_25519_gf_mult(&tmp, &krecip, &signature->s);\n\n  // mod n (order of G)\n  ecc_25519_gf_reduce(&signature->s, &tmp);\n\n  if (ecc_25519_gf_is_zero(&signature->s))\n    goto regenerate;\n}\n\n\nvoid ecdsa_verify_prepare_legacy(ecdsa_verify_context_t *ctx, const ecc_int256_t *hash, const ecdsa_signature_t *signature) {\n  ecc_int256_t w, u1, tmp;\n\n  if (ecc_25519_gf_is_zero(&signature->s) || ecc_25519_gf_is_zero(&signature->r)) {\n    // Signature is invalid, mark by setting ctx->r to an invalid value\n    memset(&ctx->r, 0, sizeof(ctx->r));\n    return;\n  }\n\n  ctx->r = signature->r;\n\n  ecc_25519_gf_recip(&w, &signature->s);\n  ecc_25519_gf_reduce(&tmp, hash);\n  ecc_25519_gf_mult(&u1, &tmp, &w);\n  ecc_25519_gf_mult(&ctx->u2, &ctx->r, &w);\n  ecc_25519_scalarmult_base(&ctx->s1, &u1);\n}\n\n\nbool ecdsa_verify_legacy(const ecdsa_verify_context_t *ctx, const ecc_25519_work_t *pubkey) {\n  ecc_25519_work_t s2, work;\n  ecc_int256_t w, tmp;\n\n  // Signature was detected as invalid in prepare step\n  if (ecc_25519_gf_is_zero(&ctx->r))\n    return false;\n\n  ecc_25519_scalarmult(&s2, &ctx->u2, pubkey);\n  ecc_25519_add(&work, &ctx->s1, &s2);\n  ecc_25519_store_xy_legacy(&w, NULL, &work);\n  ecc_25519_gf_sub(&tmp, &ctx->r, &w);\n\n  return ecc_25519_gf_is_zero(&tmp);\n}\n\n\nsize_t ecdsa_verify_list_legacy(const ecdsa_verify_context_t *ctxs, size_t n_ctxs, const ecc_25519_work_t *pubkeys, size_t n_pubkeys) {\n  size_t ret = 0, i, j;\n\n  bool used[n_pubkeys];\n  memset(used, 0, sizeof(used));\n\n  for (i = 0; i < n_ctxs; i++) {\n    for (j = 0; j < n_pubkeys; j++) {\n      if (used[j])\n        continue;\n\n      if (ecdsa_verify_legacy(&ctxs[i], &pubkeys[j])) {\n        ret++;\n        used[j] = true;\n        break;\n      }\n    }\n  }\n\n  return ret;\n}\n"], "filenames": ["src/lib/ecdsa.c"], "buggy_code_start_loc": [137], "buggy_code_end_loc": [150], "fixing_code_start_loc": [138], "fixing_code_end_loc": [161], "type": "CWE-347", "message": "ecdsautils is a tiny collection of programs used for ECDSA (keygen, sign, verify). `ecdsa_verify_[prepare_]legacy()` does not check whether the signature values `r` and `s` are non-zero. A signature consisting only of zeroes is always considered valid, making it trivial to forge signatures. Requiring multiple signatures from different public keys does not mitigate the issue: `ecdsa_verify_list_legacy()` will accept an arbitrary number of such forged signatures. Both the `ecdsautil verify` CLI command and the libecdsautil library are affected. The issue has been fixed in ecdsautils 0.4.1. All older versions of ecdsautils (including versions before the split into a library and a CLI utility) are vulnerable.", "other": {"cve": {"id": "CVE-2022-24884", "sourceIdentifier": "security-advisories@github.com", "published": "2022-05-06T00:15:07.697", "lastModified": "2022-05-16T18:08:22.160", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ecdsautils is a tiny collection of programs used for ECDSA (keygen, sign, verify). `ecdsa_verify_[prepare_]legacy()` does not check whether the signature values `r` and `s` are non-zero. A signature consisting only of zeroes is always considered valid, making it trivial to forge signatures. Requiring multiple signatures from different public keys does not mitigate the issue: `ecdsa_verify_list_legacy()` will accept an arbitrary number of such forged signatures. Both the `ecdsautil verify` CLI command and the libecdsautil library are affected. The issue has been fixed in ecdsautils 0.4.1. All older versions of ecdsautils (including versions before the split into a library and a CLI utility) are vulnerable."}, {"lang": "es", "value": "ecdsautils es una peque\u00f1a colecci\u00f3n de programas usados para ECDSA (keygen, sign, verify). \"ecdsa_verify_[prepare_]legacy()\" no comprueba si los valores de la firma \"r\" y \"s\" son distintos de cero. Una firma formada s\u00f3lo por ceros se considera siempre v\u00e1lida, lo que hace trivial la falsificaci\u00f3n de firmas. Requerir m\u00faltiples firmas de diferentes claves p\u00fablicas no mitiga el problema: \"ecdsa_verify_list_legacy()\" aceptar\u00e1 un n\u00famero arbitrario de tales firmas falsificadas. Tanto el comando CLI \"ecdsautil verify\" como la biblioteca libecdsautil est\u00e1n afectados. El problema ha sido corregido en ecdsautils versi\u00f3n 0.4.1. Todas las versiones anteriores de ecdsautils (incluidas las versiones anteriores a la divisi\u00f3n en una biblioteca y una utilidad CLI) son vulnerables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.8}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-347"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-347"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ecdsautils_project:ecdsautils:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.4.1", "matchCriteriaId": "8D963CA2-36A3-4C3E-BD58-912239608DA8"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://github.com/freifunk-gluon/ecdsautils/commit/1d4b091abdf15ad7b2312535b5b95ad70f6dbd08", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/freifunk-gluon/ecdsautils/commit/39b6d0a77414fd41614953a0e185c4eefa2f88ad", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/freifunk-gluon/ecdsautils/security/advisories/GHSA-qhcg-9ffp-78pw", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/05/msg00007.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4AKQH5WCBMJA3ODCSNERY6HVX4BX3ITG/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/G2JT57AAFIEL7JDO2ZBV25JKYME5NU54/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/L7UBR3M4U3LA46BHXYSH7EN5GDG44GK7/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5132", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/freifunk-gluon/ecdsautils/commit/1d4b091abdf15ad7b2312535b5b95ad70f6dbd08"}}