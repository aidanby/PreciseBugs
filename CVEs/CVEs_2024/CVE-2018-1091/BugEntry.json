{"buggy_code": ["/*\n *  PowerPC version\n *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)\n *\n *  Derived from \"arch/m68k/kernel/ptrace.c\"\n *  Copyright (C) 1994 by Hamish Macdonald\n *  Taken from linux/kernel/ptrace.c and modified for M680x0.\n *  linux/kernel/ptrace.c is by Ross Biro 1/23/92, edited by Linus Torvalds\n *\n * Modified by Cort Dougan (cort@hq.fsmlabs.com)\n * and Paul Mackerras (paulus@samba.org).\n *\n * This file is subject to the terms and conditions of the GNU General\n * Public License.  See the file README.legal in the main directory of\n * this archive for more details.\n */\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/regset.h>\n#include <linux/tracehook.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/security.h>\n#include <linux/signal.h>\n#include <linux/seccomp.h>\n#include <linux/audit.h>\n#include <trace/syscall.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/perf_event.h>\n#include <linux/context_tracking.h>\n\n#include <linux/uaccess.h>\n#include <asm/page.h>\n#include <asm/pgtable.h>\n#include <asm/switch_to.h>\n#include <asm/tm.h>\n#include <asm/asm-prototypes.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/syscalls.h>\n\n/*\n * The parameter save area on the stack is used to store arguments being passed\n * to callee function and is located at fixed offset from stack pointer.\n */\n#ifdef CONFIG_PPC32\n#define PARAMETER_SAVE_AREA_OFFSET\t24  /* bytes */\n#else /* CONFIG_PPC32 */\n#define PARAMETER_SAVE_AREA_OFFSET\t48  /* bytes */\n#endif\n\nstruct pt_regs_offset {\n\tconst char *name;\n\tint offset;\n};\n\n#define STR(s)\t#s\t\t\t/* convert to string */\n#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}\n#define GPR_OFFSET_NAME(num)\t\\\n\t{.name = STR(r##num), .offset = offsetof(struct pt_regs, gpr[num])}, \\\n\t{.name = STR(gpr##num), .offset = offsetof(struct pt_regs, gpr[num])}\n#define REG_OFFSET_END {.name = NULL, .offset = 0}\n\n#define TVSO(f)\t(offsetof(struct thread_vr_state, f))\n#define TFSO(f)\t(offsetof(struct thread_fp_state, f))\n#define TSO(f)\t(offsetof(struct thread_struct, f))\n\nstatic const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\nstatic void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif (tsk != current)\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}\n#else\nstatic inline void flush_tmregs_to_thread(struct task_struct *tsk) { }\n#endif\n\n/**\n * regs_query_register_offset() - query register offset from its name\n * @name:\tthe name of a register\n *\n * regs_query_register_offset() returns the offset of a register in struct\n * pt_regs from its name. If the name is invalid, this returns -EINVAL;\n */\nint regs_query_register_offset(const char *name)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (!strcmp(roff->name, name))\n\t\t\treturn roff->offset;\n\treturn -EINVAL;\n}\n\n/**\n * regs_query_register_name() - query register name from its offset\n * @offset:\tthe offset of a register in struct pt_regs.\n *\n * regs_query_register_name() returns the name of a register from its\n * offset in struct pt_regs. If the @offset is invalid, this returns NULL;\n */\nconst char *regs_query_register_name(unsigned int offset)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (roff->offset == offset)\n\t\t\treturn roff->name;\n\treturn NULL;\n}\n\n/*\n * does not yet catch signals sent when the child dies.\n * in exit.c or in signal.c.\n */\n\n/*\n * Set of msr bits that gdb can change on behalf of a process.\n */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n#define MSR_DEBUGCHANGE\t0\n#else\n#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)\n#endif\n\n/*\n * Max register writeable via put_reg\n */\n#ifdef CONFIG_PPC32\n#define PT_MAX_PUT_REG\tPT_MQ\n#else\n#define PT_MAX_PUT_REG\tPT_CCR\n#endif\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\nstatic unsigned long get_user_ckpt_msr(struct task_struct *task)\n{\n\treturn task->thread.ckpt_regs.msr | task->thread.fpexc_mode;\n}\n\nstatic int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}\n\nstatic int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.ckpt_regs.trap = trap & 0xfff0;\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PPC64\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\t*data = task->thread.dscr;\n\treturn 0;\n}\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\ttask->thread.dscr = dscr;\n\ttask->thread.dscr_inherit = 1;\n\treturn 0;\n}\n#else\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}\n#endif\n\n/*\n * We prevent mucking around with the reserved area of trap\n * which are used internally by the kernel.\n */\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}\n\n/*\n * Get contents of register REGNO in task TASK.\n */\nint ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n/*\n * Write contents of register REGNO in task TASK.\n */\nint ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic int gpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint i, ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  target->thread.regs,\n\t\t\t\t  0, offsetof(struct pt_regs, msr));\n\tif (!ret) {\n\t\tunsigned long msr = get_user_msr(target);\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,\n\t\t\t\t\t  offsetof(struct pt_regs, msr),\n\t\t\t\t\t  offsetof(struct pt_regs, msr) +\n\t\t\t\t\t  sizeof(msr));\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.regs->orig_gpr3,\n\t\t\t\t\t  offsetof(struct pt_regs, orig_gpr3),\n\t\t\t\t\t  sizeof(struct pt_regs));\n\tif (!ret)\n\t\tret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t       sizeof(struct pt_regs), -1);\n\n\treturn ret;\n}\n\nstatic int gpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t target->thread.regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.regs->orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last checkpointed\n * value of all FPR registers for the current transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n * };\n */\nstatic int fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32]));\n\n\tflush_fp_to_thread(target);\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fp_state, 0, -1);\n#endif\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last checkpointed\n * value of all FPR registers for the current transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n * };\n *\n */\nstatic int fpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_FPR(i) = buf[i];\n\ttarget->thread.fp_state.fpscr = buf[32];\n\treturn 0;\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32]));\n\n\tflush_fp_to_thread(target);\n\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.fp_state, 0, -1);\n#endif\n}\n\n#ifdef CONFIG_ALTIVEC\n/*\n * Get/set all the altivec registers vr0..vr31, vscr, vrsave, in one go.\n * The transfer totals 34 quadword.  Quadwords 0-31 contain the\n * corresponding vector registers.  Quadword 32 contains the vscr as the\n * last word (offset 12) within that quadword.  Quadword 33 contains the\n * vrsave as the first word (offset 0) within the quadword.\n *\n * This definition of the VMX state is compatible with the current PPC32\n * ptrace interface.  This allows signal handling and ptrace to use the\n * same structures.  This also simplifies the implementation of a bi-arch\n * (combined (32- and 64-bit) gdb.\n */\n\nstatic int vr_active(struct task_struct *target,\n\t\t     const struct user_regset *regset)\n{\n\tflush_altivec_to_thread(target);\n\treturn target->thread.used_vr ? regset->n : 0;\n}\n\n/*\n * Regardless of transactions, 'vr_state' holds the current running\n * value of all the VMX registers and 'ckvr_state' holds the last\n * checkpointed value of all the VMX registers for the current\n * transaction to fall back on in case it aborts.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n * };\n */\nstatic int vr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.vr_state, 0,\n\t\t\t\t  33 * sizeof(vector128));\n\tif (!ret) {\n\t\t/*\n\t\t * Copy out only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\n\t\tvrsave.word = target->thread.vrsave;\n\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t  33 * sizeof(vector128), -1);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Regardless of transactions, 'vr_state' holds the current running\n * value of all the VMX registers and 'ckvr_state' holds the last\n * checkpointed value of all the VMX registers for the current\n * transaction to fall back on in case it aborts.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n * };\n */\nstatic int vr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.vr_state, 0,\n\t\t\t\t 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the first word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\n\t\tvrsave.word = target->thread.vrsave;\n\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.vrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}\n#endif /* CONFIG_ALTIVEC */\n\n#ifdef CONFIG_VSX\n/*\n * Currently to set and and get all the vsx state, you need to call\n * the fp and VMX calls as well.  This only get/sets the lower 32\n * 128bit VSX registers.\n */\n\nstatic int vsr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last\n * checkpointed value of all FPR registers for the current\n * transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tvsx[32];\n * };\n */\nstatic int vsr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last\n * checkpointed value of all FPR registers for the current\n * transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tvsx[32];\n * };\n */\nstatic int vsr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret,i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\n/*\n * For get_evrregs/set_evrregs functions 'data' has the following layout:\n *\n * struct {\n *   u32 evr[32];\n *   u64 acc;\n *   u32 spefscr;\n * }\n */\n\nstatic int evr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_spe_to_thread(target);\n\treturn target->thread.used_spe ? regset->n : 0;\n}\n\nstatic int evr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.evr,\n\t\t\t\t  0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.acc,\n\t\t\t\t\t  sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}\n\nstatic int evr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.evr,\n\t\t\t\t 0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.acc,\n\t\t\t\t\t sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}\n#endif /* CONFIG_SPE */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n/**\n * tm_cgpr_active - get active number of registers in CGPR\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in transaction checkpointed GPR category.\n */\nstatic int tm_cgpr_active(struct task_struct *target,\n\t\t\t  const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}\n\n/**\n * tm_cgpr_get - get CGPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets transaction checkpointed GPR registers.\n *\n * When the transaction is active, 'ckpt_regs' holds all the checkpointed\n * GPR register values for the current transaction to fall back on if it\n * aborts in between. This function gets those checkpointed GPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tstruct pt_regs ckpt_regs;\n * };\n */\nstatic int tm_cgpr_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.ckpt_regs,\n\t\t\t\t  0, offsetof(struct pt_regs, msr));\n\tif (!ret) {\n\t\tunsigned long msr = get_user_ckpt_msr(target);\n\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,\n\t\t\t\t\t  offsetof(struct pt_regs, msr),\n\t\t\t\t\t  offsetof(struct pt_regs, msr) +\n\t\t\t\t\t  sizeof(msr));\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.ckpt_regs.orig_gpr3,\n\t\t\t\t\t  offsetof(struct pt_regs, orig_gpr3),\n\t\t\t\t\t  sizeof(struct pt_regs));\n\tif (!ret)\n\t\tret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t       sizeof(struct pt_regs), -1);\n\n\treturn ret;\n}\n\n/*\n * tm_cgpr_set - set the CGPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed GPR registers.\n *\n * When the transaction is active, 'ckpt_regs' holds the checkpointed\n * GPR register values for the current transaction to fall back on if it\n * aborts in between. This function sets those checkpointed GPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tstruct pt_regs ckpt_regs;\n * };\n */\nstatic int tm_cgpr_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.ckpt_regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.ckpt_regs.orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}\n\n/**\n * tm_cfpr_active - get active number of registers in CFPR\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in transaction checkpointed FPR category.\n */\nstatic int tm_cfpr_active(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}\n\n/**\n * tm_cfpr_get - get CFPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets in transaction checkpointed FPR registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * values for the current transaction to fall back on if it aborts\n * in between. This function gets those checkpointed FPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n *};\n */\nstatic int tm_cfpr_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n}\n\n/**\n * tm_cfpr_set - set CFPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed FPR registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * FPR register values for the current transaction to fall back on\n * if it aborts in between. This function sets these checkpointed\n * FPR registers. The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n *};\n */\nstatic int tm_cfpr_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_CKFPR(i) = buf[i];\n\ttarget->thread.ckfp_state.fpscr = buf[32];\n\treturn 0;\n}\n\n/**\n * tm_cvmx_active - get active number of registers in CVMX\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in checkpointed VMX category.\n */\nstatic int tm_cvmx_active(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}\n\n/**\n * tm_cvmx_get - get CMVX registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets in transaction checkpointed VMX registers.\n *\n * When the transaction is active 'ckvr_state' and 'ckvrsave' hold\n * the checkpointed values for the current transaction to fall\n * back on if it aborts in between. The userspace interface buffer\n * layout is as follows.\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n *};\n */\nstatic int tm_cvmx_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t&target->thread.ckvr_state, 0,\n\t\t\t\t\t33 * sizeof(vector128));\n\tif (!ret) {\n\t\t/*\n\t\t * Copy out only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.ckvrsave;\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t\t33 * sizeof(vector128), -1);\n\t}\n\n\treturn ret;\n}\n\n/**\n * tm_cvmx_set - set CMVX registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed VMX registers.\n *\n * When the transaction is active 'ckvr_state' and 'ckvrsave' hold\n * the checkpointed values for the current transaction to fall\n * back on if it aborts in between. The userspace interface buffer\n * layout is as follows.\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n *};\n */\nstatic int tm_cvmx_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t&target->thread.ckvr_state, 0,\n\t\t\t\t\t33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.ckvrsave;\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t\t33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.ckvrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}\n\n/**\n * tm_cvsx_active - get active number of registers in CVSX\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in transaction checkpointed VSX category.\n */\nstatic int tm_cvsx_active(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}\n\n/**\n * tm_cvsx_get - get CVSX registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets in transaction checkpointed VSX registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * values for the current transaction to fall back on if it aborts\n * in between. This function gets those checkpointed VSX registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tvsx[32];\n *};\n */\nstatic int tm_cvsx_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}\n\n/**\n * tm_cvsx_set - set CFPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed VSX registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * VSX register values for the current transaction to fall back on\n * if it aborts in between. This function sets these checkpointed\n * FPR registers. The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tvsx[32];\n *};\n */\nstatic int tm_cvsx_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}\n\n/**\n * tm_spr_active - get active number of registers in TM SPR\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks the active number of available\n * regisers in the transactional memory SPR category.\n */\nstatic int tm_spr_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}\n\n/**\n * tm_spr_get - get the TM related SPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets transactional memory related SPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct {\n *\tu64\t\ttm_tfhar;\n *\tu64\t\ttm_texasr;\n *\tu64\t\ttm_tfiar;\n * };\n */\nstatic int tm_spr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfhar, 0, sizeof(u64));\n\n\t/* TEXASR register */\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_texasr, sizeof(u64),\n\t\t\t\t2 * sizeof(u64));\n\n\t/* TFIAR register */\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfiar,\n\t\t\t\t2 * sizeof(u64), 3 * sizeof(u64));\n\treturn ret;\n}\n\n/**\n * tm_spr_set - set the TM related SPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets transactional memory related SPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct {\n *\tu64\t\ttm_tfhar;\n *\tu64\t\ttm_texasr;\n *\tu64\t\ttm_tfiar;\n * };\n */\nstatic int tm_spr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfhar, 0, sizeof(u64));\n\n\t/* TEXASR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_texasr, sizeof(u64),\n\t\t\t\t2 * sizeof(u64));\n\n\t/* TFIAR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfiar,\n\t\t\t\t 2 * sizeof(u64), 3 * sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_tar_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\nstatic int tm_tar_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tar, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_tar_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tar, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_ppr_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\n\nstatic int tm_ppr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_ppr, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_ppr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_ppr, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_dscr_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\nstatic int tm_dscr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_dscr, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_dscr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_dscr, 0, sizeof(u64));\n\treturn ret;\n}\n#endif\t/* CONFIG_PPC_TRANSACTIONAL_MEM */\n\n#ifdef CONFIG_PPC64\nstatic int ppr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.ppr, 0, sizeof(u64));\n}\n\nstatic int ppr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.ppr, 0, sizeof(u64));\n}\n\nstatic int dscr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.dscr, 0, sizeof(u64));\n}\nstatic int dscr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.dscr, 0, sizeof(u64));\n}\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\nstatic int tar_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.tar, 0, sizeof(u64));\n}\nstatic int tar_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.tar, 0, sizeof(u64));\n}\n\nstatic int ebb_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\nstatic int ebb_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (!target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.ebbrr, 0, 3 * sizeof(unsigned long));\n}\n\nstatic int ebb_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.ebbrr, 0, sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.ebbhr, sizeof(unsigned long),\n\t\t\t2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.bescr,\n\t\t\t2 * sizeof(unsigned long), 3 * sizeof(unsigned long));\n\n\treturn ret;\n}\nstatic int pmu_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}\n\nstatic int pmu_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.siar, 0,\n\t\t\t5 * sizeof(unsigned long));\n}\n\nstatic int pmu_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.siar, 0,\n\t\t\tsizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.sdar, sizeof(unsigned long),\n\t\t\t2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.sier, 2 * sizeof(unsigned long),\n\t\t\t3 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.mmcr2, 3 * sizeof(unsigned long),\n\t\t\t4 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.mmcr0, 4 * sizeof(unsigned long),\n\t\t\t5 * sizeof(unsigned long));\n\treturn ret;\n}\n#endif\n/*\n * These are our native regset flavors.\n */\nenum powerpc_regset {\n\tREGSET_GPR,\n\tREGSET_FPR,\n#ifdef CONFIG_ALTIVEC\n\tREGSET_VMX,\n#endif\n#ifdef CONFIG_VSX\n\tREGSET_VSX,\n#endif\n#ifdef CONFIG_SPE\n\tREGSET_SPE,\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tREGSET_TM_CGPR,\t\t/* TM checkpointed GPR registers */\n\tREGSET_TM_CFPR,\t\t/* TM checkpointed FPR registers */\n\tREGSET_TM_CVMX,\t\t/* TM checkpointed VMX registers */\n\tREGSET_TM_CVSX,\t\t/* TM checkpointed VSX registers */\n\tREGSET_TM_SPR,\t\t/* TM specific SPR registers */\n\tREGSET_TM_CTAR,\t\t/* TM checkpointed TAR register */\n\tREGSET_TM_CPPR,\t\t/* TM checkpointed PPR register */\n\tREGSET_TM_CDSCR,\t/* TM checkpointed DSCR register */\n#endif\n#ifdef CONFIG_PPC64\n\tREGSET_PPR,\t\t/* PPR register */\n\tREGSET_DSCR,\t\t/* DSCR register */\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\tREGSET_TAR,\t\t/* TAR register */\n\tREGSET_EBB,\t\t/* EBB registers */\n\tREGSET_PMR,\t\t/* Performance Monitor Registers */\n#endif\n};\n\nstatic const struct user_regset native_regsets[] = {\n\t[REGSET_GPR] = {\n\t\t.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,\n\t\t.size = sizeof(long), .align = sizeof(long),\n\t\t.get = gpr_get, .set = gpr_set\n\t},\n\t[REGSET_FPR] = {\n\t\t.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.get = fpr_get, .set = fpr_set\n\t},\n#ifdef CONFIG_ALTIVEC\n\t[REGSET_VMX] = {\n\t\t.core_note_type = NT_PPC_VMX, .n = 34,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = vr_active, .get = vr_get, .set = vr_set\n\t},\n#endif\n#ifdef CONFIG_VSX\n\t[REGSET_VSX] = {\n\t\t.core_note_type = NT_PPC_VSX, .n = 32,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = vsr_active, .get = vsr_get, .set = vsr_set\n\t},\n#endif\n#ifdef CONFIG_SPE\n\t[REGSET_SPE] = {\n\t\t.core_note_type = NT_PPC_SPE, .n = 35,\n\t\t.size = sizeof(u32), .align = sizeof(u32),\n\t\t.active = evr_active, .get = evr_get, .set = evr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t[REGSET_TM_CGPR] = {\n\t\t.core_note_type = NT_PPC_TM_CGPR, .n = ELF_NGREG,\n\t\t.size = sizeof(long), .align = sizeof(long),\n\t\t.active = tm_cgpr_active, .get = tm_cgpr_get, .set = tm_cgpr_set\n\t},\n\t[REGSET_TM_CFPR] = {\n\t\t.core_note_type = NT_PPC_TM_CFPR, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cfpr_active, .get = tm_cfpr_get, .set = tm_cfpr_set\n\t},\n\t[REGSET_TM_CVMX] = {\n\t\t.core_note_type = NT_PPC_TM_CVMX, .n = ELF_NVMX,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = tm_cvmx_active, .get = tm_cvmx_get, .set = tm_cvmx_set\n\t},\n\t[REGSET_TM_CVSX] = {\n\t\t.core_note_type = NT_PPC_TM_CVSX, .n = ELF_NVSX,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cvsx_active, .get = tm_cvsx_get, .set = tm_cvsx_set\n\t},\n\t[REGSET_TM_SPR] = {\n\t\t.core_note_type = NT_PPC_TM_SPR, .n = ELF_NTMSPRREG,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_spr_active, .get = tm_spr_get, .set = tm_spr_set\n\t},\n\t[REGSET_TM_CTAR] = {\n\t\t.core_note_type = NT_PPC_TM_CTAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_tar_active, .get = tm_tar_get, .set = tm_tar_set\n\t},\n\t[REGSET_TM_CPPR] = {\n\t\t.core_note_type = NT_PPC_TM_CPPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_ppr_active, .get = tm_ppr_get, .set = tm_ppr_set\n\t},\n\t[REGSET_TM_CDSCR] = {\n\t\t.core_note_type = NT_PPC_TM_CDSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_dscr_active, .get = tm_dscr_get, .set = tm_dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC64\n\t[REGSET_PPR] = {\n\t\t.core_note_type = NT_PPC_PPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = ppr_get, .set = ppr_set\n\t},\n\t[REGSET_DSCR] = {\n\t\t.core_note_type = NT_PPC_DSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = dscr_get, .set = dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\t[REGSET_TAR] = {\n\t\t.core_note_type = NT_PPC_TAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = tar_get, .set = tar_set\n\t},\n\t[REGSET_EBB] = {\n\t\t.core_note_type = NT_PPC_EBB, .n = ELF_NEBB,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = ebb_active, .get = ebb_get, .set = ebb_set\n\t},\n\t[REGSET_PMR] = {\n\t\t.core_note_type = NT_PPC_PMU, .n = ELF_NPMU,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = pmu_active, .get = pmu_get, .set = pmu_set\n\t},\n#endif\n};\n\nstatic const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};\n\n#ifdef CONFIG_PPC64\n#include <linux/compat.h>\n\nstatic int gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t\t    void *kbuf, void __user *ubuf,\n\t\t\t    unsigned long *regs)\n{\n\tcompat_ulong_t *k = kbuf;\n\tcompat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\treg = get_user_msr(target);\n\t\tif (kbuf)\n\t\t\t*k++ = reg;\n\t\telse if (__put_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\tPT_REGS_COUNT * sizeof(reg), -1);\n}\n\nstatic int gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\nstatic int tm_cgpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     void *kbuf, void __user *ubuf)\n{\n\treturn gpr32_get_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.ckpt_regs.gpr[0]);\n}\n\nstatic int tm_cgpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.ckpt_regs.gpr[0]);\n}\n#endif /* CONFIG_PPC_TRANSACTIONAL_MEM */\n\nstatic int gpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     void *kbuf, void __user *ubuf)\n{\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/*\n\t\t * We have a partial register set.\n\t\t * Fill 14-31 with bogus values.\n\t\t */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\treturn gpr32_get_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.regs->gpr[0]);\n}\n\nstatic int gpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.regs->gpr[0]);\n}\n\n/*\n * These are the regset flavors matching the CONFIG_PPC32 native set.\n */\nstatic const struct user_regset compat_regsets[] = {\n\t[REGSET_GPR] = {\n\t\t.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,\n\t\t.size = sizeof(compat_long_t), .align = sizeof(compat_long_t),\n\t\t.get = gpr32_get, .set = gpr32_set\n\t},\n\t[REGSET_FPR] = {\n\t\t.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.get = fpr_get, .set = fpr_set\n\t},\n#ifdef CONFIG_ALTIVEC\n\t[REGSET_VMX] = {\n\t\t.core_note_type = NT_PPC_VMX, .n = 34,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = vr_active, .get = vr_get, .set = vr_set\n\t},\n#endif\n#ifdef CONFIG_SPE\n\t[REGSET_SPE] = {\n\t\t.core_note_type = NT_PPC_SPE, .n = 35,\n\t\t.size = sizeof(u32), .align = sizeof(u32),\n\t\t.active = evr_active, .get = evr_get, .set = evr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t[REGSET_TM_CGPR] = {\n\t\t.core_note_type = NT_PPC_TM_CGPR, .n = ELF_NGREG,\n\t\t.size = sizeof(long), .align = sizeof(long),\n\t\t.active = tm_cgpr_active,\n\t\t.get = tm_cgpr32_get, .set = tm_cgpr32_set\n\t},\n\t[REGSET_TM_CFPR] = {\n\t\t.core_note_type = NT_PPC_TM_CFPR, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cfpr_active, .get = tm_cfpr_get, .set = tm_cfpr_set\n\t},\n\t[REGSET_TM_CVMX] = {\n\t\t.core_note_type = NT_PPC_TM_CVMX, .n = ELF_NVMX,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = tm_cvmx_active, .get = tm_cvmx_get, .set = tm_cvmx_set\n\t},\n\t[REGSET_TM_CVSX] = {\n\t\t.core_note_type = NT_PPC_TM_CVSX, .n = ELF_NVSX,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cvsx_active, .get = tm_cvsx_get, .set = tm_cvsx_set\n\t},\n\t[REGSET_TM_SPR] = {\n\t\t.core_note_type = NT_PPC_TM_SPR, .n = ELF_NTMSPRREG,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_spr_active, .get = tm_spr_get, .set = tm_spr_set\n\t},\n\t[REGSET_TM_CTAR] = {\n\t\t.core_note_type = NT_PPC_TM_CTAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_tar_active, .get = tm_tar_get, .set = tm_tar_set\n\t},\n\t[REGSET_TM_CPPR] = {\n\t\t.core_note_type = NT_PPC_TM_CPPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_ppr_active, .get = tm_ppr_get, .set = tm_ppr_set\n\t},\n\t[REGSET_TM_CDSCR] = {\n\t\t.core_note_type = NT_PPC_TM_CDSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_dscr_active, .get = tm_dscr_get, .set = tm_dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC64\n\t[REGSET_PPR] = {\n\t\t.core_note_type = NT_PPC_PPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = ppr_get, .set = ppr_set\n\t},\n\t[REGSET_DSCR] = {\n\t\t.core_note_type = NT_PPC_DSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = dscr_get, .set = dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\t[REGSET_TAR] = {\n\t\t.core_note_type = NT_PPC_TAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = tar_get, .set = tar_set\n\t},\n\t[REGSET_EBB] = {\n\t\t.core_note_type = NT_PPC_EBB, .n = ELF_NEBB,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = ebb_active, .get = ebb_get, .set = ebb_set\n\t},\n#endif\n};\n\nstatic const struct user_regset_view user_ppc_compat_view = {\n\t.name = \"ppc\", .e_machine = EM_PPC, .ei_osabi = ELF_OSABI,\n\t.regsets = compat_regsets, .n = ARRAY_SIZE(compat_regsets)\n};\n#endif\t/* CONFIG_PPC64 */\n\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_PPC64\n\tif (test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n#endif\n\treturn &user_ppc_native_view;\n}\n\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}\n\nvoid user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\ttask->thread.debug.dbcr0 = DBCR0_IDM | DBCR0_BT;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_SE;\n\t\tregs->msr |= MSR_BE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\nvoid ptrace_triggered(struct perf_event *bp,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\nstatic int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,\n\t\t\t       unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &(task->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint hw_brk;\n#endif\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = 8;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif ((!data) || !(hw_brk.type & HW_BRK_TYPE_RDWR)) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk = hw_brk;\n#else /* CONFIG_PPC_ADV_DEBUG_REGS */\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0\n\t   register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0\n\t   accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R|DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\treturn 0;\n}\n\n/*\n * Called by kernel/ptrace.c when detaching..\n *\n * Make sure single step bits etc are not set.\n */\nvoid ptrace_disable(struct task_struct *child)\n{\n\t/* make sure the single step bit is not set. */\n\tuser_disable_single_step(child);\n}\n\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\nstatic long set_instruction_bp(struct task_struct *child,\n\t\t\t      struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif ((!slot1_in_use) && (!slot2_in_use)) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || (slot3_in_use == slot4_in_use)) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}\n\nstatic int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int set_dac(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint byte_enable =\n\t\t(bp_info->condition_mode >> PPC_BREAKPOINT_CONDITION_BE_SHIFT)\n\t\t& 0xf;\n\tint condition_mode =\n\t\tbp_info->condition_mode & PPC_BREAKPOINT_CONDITION_MODE;\n\tint slot;\n\n\tif (byte_enable && (condition_mode == 0))\n\t\treturn -EINVAL;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0) {\n\t\tslot = 1;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1W;\n\t\tchild->thread.debug.dac1 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc1 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC1BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC1M_SHIFT));\n\t\t}\n#endif\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t} else if (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t/* Both dac1 and dac2 are part of a range */\n\t\treturn -ENOSPC;\n#endif\n\t} else if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0) {\n\t\tslot = 2;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2W;\n\t\tchild->thread.debug.dac2 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc2 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC2BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC2M_SHIFT));\n\t\t}\n#endif\n\t} else\n\t\treturn -ENOSPC;\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot + 4;\n}\n\nstatic int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\nstatic int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}\n#endif /* CONFIG_PPC_ADV_DEBUG_DAC_RANGE */\n\nstatic long ppc_set_hwdebug(struct task_struct *child,\n\t\t     struct ppc_hw_breakpoint *bp_info)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint brk;\n#endif\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif ((bp_info->trigger_type == 0) ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif ((bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE) ||\n\t\t    (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE))\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = bp_info->addr & ~7UL;\n\tbrk.type = HW_BRK_TYPE_TRANSLATE;\n\tbrk.len = 8;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t/*\n\t * Check if the request is for 'range' breakpoints. We can\n\t * support it if range < 8 bytes.\n\t */\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\tbp = thread->ptrace_bps[0];\n\tif (bp)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr & ~HW_BREAKPOINT_ALIGN;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, child);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\tif (child->thread.hw_brk.address)\n\t\treturn -ENOSPC;\n\n\tchild->thread.hw_brk = brk;\n\n\treturn 1;\n#endif /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n}\n\nstatic long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n#else\n\tif (data != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[0] = NULL;\n\t} else\n\t\tret = -ENOENT;\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (child->thread.hw_brk.address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk.address = 0;\n\tchild->thread.hw_brk.type = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n#endif\n}\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\n\tswitch (request) {\n\t/* read the word at location addr in the USER area. */\n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long index, tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, (int) index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&tmp, &child->thread.TS_FPR(fpidx),\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\ttmp = child->thread.fp_state.fpscr;\n\t\t}\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&child->thread.TS_FPR(fpidx), &data,\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\tchild->thread.fp_state.fpscr = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_GETHWDBGINFO: {\n\t\tstruct ppc_debug_info dbginfo;\n\n\t\tdbginfo.version = 1;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tdbginfo.num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\t\tdbginfo.num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\t\tdbginfo.num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\t\tdbginfo.data_bp_alignment = 4;\n\t\tdbginfo.sizeof_condition = 4;\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_INSN_BP_MASK;\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tdbginfo.features |=\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_MASK;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_REGS */\n\t\tdbginfo.num_instruction_bps = 0;\n\t\tdbginfo.num_data_bps = 1;\n\t\tdbginfo.num_condition_regs = 0;\n#ifdef CONFIG_PPC64\n\t\tdbginfo.data_bp_alignment = 8;\n#else\n\t\tdbginfo.data_bp_alignment = 4;\n#endif\n\t\tdbginfo.sizeof_condition = 0;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_DATA_BP_RANGE;\n\t\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\t\tdbginfo.features |= PPC_DEBUG_FEATURE_DATA_BP_DAWR;\n#else\n\t\tdbginfo.features = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\n\t\tif (!access_ok(VERIFY_WRITE, datavp,\n\t\t\t       sizeof(struct ppc_debug_info)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_to_user(datavp, &dbginfo,\n\t\t\t\t     sizeof(struct ppc_debug_info)) ?\n\t\t      -EFAULT : 0;\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_SETHWDEBUG: {\n\t\tstruct ppc_hw_breakpoint bp_info;\n\n\t\tif (!access_ok(VERIFY_READ, datavp,\n\t\t\t       sizeof(struct ppc_hw_breakpoint)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_from_user(&bp_info, datavp,\n\t\t\t\t       sizeof(struct ppc_hw_breakpoint)) ?\n\t\t      -EFAULT : 0;\n\t\tif (!ret)\n\t\t\tret = ppc_set_hwdebug(child, &bp_info);\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_DELHWDEBUG: {\n\t\tret = ppc_del_hwdebug(child, data);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG: {\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tunsigned long dabr_fake;\n#endif\n\t\tret = -EINVAL;\n\t\t/* We only support one DABR and no IABRS at the moment */\n\t\tif (addr > 0)\n\t\t\tbreak;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tret = put_user(child->thread.debug.dac1, datalp);\n#else\n\t\tdabr_fake = ((child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |\n\t\t\t     (child->thread.hw_brk.type & HW_BRK_TYPE_DABR));\n\t\tret = put_user(dabr_fake, datalp);\n#endif\n\t\tbreak;\n\t}\n\n\tcase PTRACE_SET_DEBUGREG:\n\t\tret = ptrace_set_debugreg(child, addr, data);\n\t\tbreak;\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_GETREGS64:\n#endif\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_GPR,\n\t\t\t\t\t   0, sizeof(struct pt_regs),\n\t\t\t\t\t   datavp);\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_SETREGS64:\n#endif\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_GPR,\n\t\t\t\t\t     0, sizeof(struct pt_regs),\n\t\t\t\t\t     datavp);\n\n\tcase PTRACE_GETFPREGS: /* Get the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_FPR,\n\t\t\t\t\t   0, sizeof(elf_fpregset_t),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETFPREGS: /* Set the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_FPR,\n\t\t\t\t\t     0, sizeof(elf_fpregset_t),\n\t\t\t\t\t     datavp);\n\n#ifdef CONFIG_ALTIVEC\n\tcase PTRACE_GETVRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VMX,\n\t\t\t\t\t   0, (33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32)),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VMX,\n\t\t\t\t\t     0, (33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32)),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_VSX\n\tcase PTRACE_GETVSRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VSX,\n\t\t\t\t\t   0, 32 * sizeof(double),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVSRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VSX,\n\t\t\t\t\t     0, 32 * sizeof(double),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_SPE\n\tcase PTRACE_GETEVRREGS:\n\t\t/* Get the child spe register state. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETEVRREGS:\n\t\t/* Set the child spe register state. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t     datavp);\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_SECCOMP\nstatic int do_seccomp(struct pt_regs *regs)\n{\n\tif (!test_thread_flag(TIF_SECCOMP))\n\t\treturn 0;\n\n\t/*\n\t * The ABI we present to seccomp tracers is that r3 contains\n\t * the syscall return value and orig_gpr3 contains the first\n\t * syscall parameter. This is different to the ptrace ABI where\n\t * both r3 and orig_gpr3 contain the first syscall parameter.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\n\t/*\n\t * We use the __ version here because we have already checked\n\t * TIF_SECCOMP. If this fails, there is nothing left to do, we\n\t * have already loaded -ENOSYS into r3, or seccomp has put\n\t * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).\n\t */\n\tif (__secure_computing(NULL))\n\t\treturn -1;\n\n\t/*\n\t * The syscall was allowed by seccomp, restore the register\n\t * state to what audit expects.\n\t * Note that we use orig_gpr3, which means a seccomp tracer can\n\t * modify the first syscall parameter (in orig_gpr3) and also\n\t * allow the syscall to proceed.\n\t */\n\tregs->gpr[3] = regs->orig_gpr3;\n\n\treturn 0;\n}\n#else\nstatic inline int do_seccomp(struct pt_regs *regs) { return 0; }\n#endif /* CONFIG_SECCOMP */\n\n/**\n * do_syscall_trace_enter() - Do syscall tracing on kernel entry.\n * @regs: the pt_regs of the task to trace (current)\n *\n * Performs various types of tracing on syscall entry. This includes seccomp,\n * ptrace, syscall tracepoints and audit.\n *\n * The pt_regs are potentially visible to userspace via ptrace, so their\n * contents is ABI.\n *\n * One or more of the tracers may modify the contents of pt_regs, in particular\n * to modify arguments or even the syscall number itself.\n *\n * It's also possible that a tracer can choose to reject the system call. In\n * that case this function will return an illegal syscall number, and will put\n * an appropriate return value in regs->r3.\n *\n * Return: the (possibly changed) syscall number.\n */\nlong do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tuser_exit();\n\n\t/*\n\t * The tracer may decide to abort the syscall, if so tracehook\n\t * will return !0. Note that the tracer may also just change\n\t * regs->gpr[0] to an invalid syscall number, that is handled\n\t * below on the exit path.\n\t */\n\tif (test_thread_flag(TIF_SYSCALL_TRACE) &&\n\t    tracehook_report_syscall_entry(regs))\n\t\tgoto skip;\n\n\t/* Run seccomp after ptrace; allow it to set gpr[3]. */\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\t/* Avoid trace and audit when syscall is invalid. */\n\tif (regs->gpr[0] >= NR_syscalls)\n\t\tgoto skip;\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n#ifdef CONFIG_PPC64\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n#endif\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n\nskip:\n\t/*\n\t * If we are aborting explicitly, or if the syscall number is\n\t * now invalid, set the return value to -ENOSYS.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\treturn -1;\n}\n\nvoid do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}\n"], "fixing_code": ["/*\n *  PowerPC version\n *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)\n *\n *  Derived from \"arch/m68k/kernel/ptrace.c\"\n *  Copyright (C) 1994 by Hamish Macdonald\n *  Taken from linux/kernel/ptrace.c and modified for M680x0.\n *  linux/kernel/ptrace.c is by Ross Biro 1/23/92, edited by Linus Torvalds\n *\n * Modified by Cort Dougan (cort@hq.fsmlabs.com)\n * and Paul Mackerras (paulus@samba.org).\n *\n * This file is subject to the terms and conditions of the GNU General\n * Public License.  See the file README.legal in the main directory of\n * this archive for more details.\n */\n\n#include <linux/kernel.h>\n#include <linux/sched.h>\n#include <linux/mm.h>\n#include <linux/smp.h>\n#include <linux/errno.h>\n#include <linux/ptrace.h>\n#include <linux/regset.h>\n#include <linux/tracehook.h>\n#include <linux/elf.h>\n#include <linux/user.h>\n#include <linux/security.h>\n#include <linux/signal.h>\n#include <linux/seccomp.h>\n#include <linux/audit.h>\n#include <trace/syscall.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/perf_event.h>\n#include <linux/context_tracking.h>\n\n#include <linux/uaccess.h>\n#include <asm/page.h>\n#include <asm/pgtable.h>\n#include <asm/switch_to.h>\n#include <asm/tm.h>\n#include <asm/asm-prototypes.h>\n\n#define CREATE_TRACE_POINTS\n#include <trace/events/syscalls.h>\n\n/*\n * The parameter save area on the stack is used to store arguments being passed\n * to callee function and is located at fixed offset from stack pointer.\n */\n#ifdef CONFIG_PPC32\n#define PARAMETER_SAVE_AREA_OFFSET\t24  /* bytes */\n#else /* CONFIG_PPC32 */\n#define PARAMETER_SAVE_AREA_OFFSET\t48  /* bytes */\n#endif\n\nstruct pt_regs_offset {\n\tconst char *name;\n\tint offset;\n};\n\n#define STR(s)\t#s\t\t\t/* convert to string */\n#define REG_OFFSET_NAME(r) {.name = #r, .offset = offsetof(struct pt_regs, r)}\n#define GPR_OFFSET_NAME(num)\t\\\n\t{.name = STR(r##num), .offset = offsetof(struct pt_regs, gpr[num])}, \\\n\t{.name = STR(gpr##num), .offset = offsetof(struct pt_regs, gpr[num])}\n#define REG_OFFSET_END {.name = NULL, .offset = 0}\n\n#define TVSO(f)\t(offsetof(struct thread_vr_state, f))\n#define TFSO(f)\t(offsetof(struct thread_fp_state, f))\n#define TSO(f)\t(offsetof(struct thread_struct, f))\n\nstatic const struct pt_regs_offset regoffset_table[] = {\n\tGPR_OFFSET_NAME(0),\n\tGPR_OFFSET_NAME(1),\n\tGPR_OFFSET_NAME(2),\n\tGPR_OFFSET_NAME(3),\n\tGPR_OFFSET_NAME(4),\n\tGPR_OFFSET_NAME(5),\n\tGPR_OFFSET_NAME(6),\n\tGPR_OFFSET_NAME(7),\n\tGPR_OFFSET_NAME(8),\n\tGPR_OFFSET_NAME(9),\n\tGPR_OFFSET_NAME(10),\n\tGPR_OFFSET_NAME(11),\n\tGPR_OFFSET_NAME(12),\n\tGPR_OFFSET_NAME(13),\n\tGPR_OFFSET_NAME(14),\n\tGPR_OFFSET_NAME(15),\n\tGPR_OFFSET_NAME(16),\n\tGPR_OFFSET_NAME(17),\n\tGPR_OFFSET_NAME(18),\n\tGPR_OFFSET_NAME(19),\n\tGPR_OFFSET_NAME(20),\n\tGPR_OFFSET_NAME(21),\n\tGPR_OFFSET_NAME(22),\n\tGPR_OFFSET_NAME(23),\n\tGPR_OFFSET_NAME(24),\n\tGPR_OFFSET_NAME(25),\n\tGPR_OFFSET_NAME(26),\n\tGPR_OFFSET_NAME(27),\n\tGPR_OFFSET_NAME(28),\n\tGPR_OFFSET_NAME(29),\n\tGPR_OFFSET_NAME(30),\n\tGPR_OFFSET_NAME(31),\n\tREG_OFFSET_NAME(nip),\n\tREG_OFFSET_NAME(msr),\n\tREG_OFFSET_NAME(ctr),\n\tREG_OFFSET_NAME(link),\n\tREG_OFFSET_NAME(xer),\n\tREG_OFFSET_NAME(ccr),\n#ifdef CONFIG_PPC64\n\tREG_OFFSET_NAME(softe),\n#else\n\tREG_OFFSET_NAME(mq),\n#endif\n\tREG_OFFSET_NAME(trap),\n\tREG_OFFSET_NAME(dar),\n\tREG_OFFSET_NAME(dsisr),\n\tREG_OFFSET_END,\n};\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\nstatic void flush_tmregs_to_thread(struct task_struct *tsk)\n{\n\t/*\n\t * If task is not current, it will have been flushed already to\n\t * it's thread_struct during __switch_to().\n\t *\n\t * A reclaim flushes ALL the state or if not in TM save TM SPRs\n\t * in the appropriate thread structures from live.\n\t */\n\n\tif ((!cpu_has_feature(CPU_FTR_TM)) || (tsk != current))\n\t\treturn;\n\n\tif (MSR_TM_SUSPENDED(mfmsr())) {\n\t\ttm_reclaim_current(TM_CAUSE_SIGNAL);\n\t} else {\n\t\ttm_enable();\n\t\ttm_save_sprs(&(tsk->thread));\n\t}\n}\n#else\nstatic inline void flush_tmregs_to_thread(struct task_struct *tsk) { }\n#endif\n\n/**\n * regs_query_register_offset() - query register offset from its name\n * @name:\tthe name of a register\n *\n * regs_query_register_offset() returns the offset of a register in struct\n * pt_regs from its name. If the name is invalid, this returns -EINVAL;\n */\nint regs_query_register_offset(const char *name)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (!strcmp(roff->name, name))\n\t\t\treturn roff->offset;\n\treturn -EINVAL;\n}\n\n/**\n * regs_query_register_name() - query register name from its offset\n * @offset:\tthe offset of a register in struct pt_regs.\n *\n * regs_query_register_name() returns the name of a register from its\n * offset in struct pt_regs. If the @offset is invalid, this returns NULL;\n */\nconst char *regs_query_register_name(unsigned int offset)\n{\n\tconst struct pt_regs_offset *roff;\n\tfor (roff = regoffset_table; roff->name != NULL; roff++)\n\t\tif (roff->offset == offset)\n\t\t\treturn roff->name;\n\treturn NULL;\n}\n\n/*\n * does not yet catch signals sent when the child dies.\n * in exit.c or in signal.c.\n */\n\n/*\n * Set of msr bits that gdb can change on behalf of a process.\n */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n#define MSR_DEBUGCHANGE\t0\n#else\n#define MSR_DEBUGCHANGE\t(MSR_SE | MSR_BE)\n#endif\n\n/*\n * Max register writeable via put_reg\n */\n#ifdef CONFIG_PPC32\n#define PT_MAX_PUT_REG\tPT_MQ\n#else\n#define PT_MAX_PUT_REG\tPT_CCR\n#endif\n\nstatic unsigned long get_user_msr(struct task_struct *task)\n{\n\treturn task->thread.regs->msr | task->thread.fpexc_mode;\n}\n\nstatic int set_user_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.regs->msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.regs->msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\nstatic unsigned long get_user_ckpt_msr(struct task_struct *task)\n{\n\treturn task->thread.ckpt_regs.msr | task->thread.fpexc_mode;\n}\n\nstatic int set_user_ckpt_msr(struct task_struct *task, unsigned long msr)\n{\n\ttask->thread.ckpt_regs.msr &= ~MSR_DEBUGCHANGE;\n\ttask->thread.ckpt_regs.msr |= msr & MSR_DEBUGCHANGE;\n\treturn 0;\n}\n\nstatic int set_user_ckpt_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.ckpt_regs.trap = trap & 0xfff0;\n\treturn 0;\n}\n#endif\n\n#ifdef CONFIG_PPC64\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\t*data = task->thread.dscr;\n\treturn 0;\n}\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\ttask->thread.dscr = dscr;\n\ttask->thread.dscr_inherit = 1;\n\treturn 0;\n}\n#else\nstatic int get_user_dscr(struct task_struct *task, unsigned long *data)\n{\n\treturn -EIO;\n}\n\nstatic int set_user_dscr(struct task_struct *task, unsigned long dscr)\n{\n\treturn -EIO;\n}\n#endif\n\n/*\n * We prevent mucking around with the reserved area of trap\n * which are used internally by the kernel.\n */\nstatic int set_user_trap(struct task_struct *task, unsigned long trap)\n{\n\ttask->thread.regs->trap = trap & 0xfff0;\n\treturn 0;\n}\n\n/*\n * Get contents of register REGNO in task TASK.\n */\nint ptrace_get_reg(struct task_struct *task, int regno, unsigned long *data)\n{\n\tif ((task->thread.regs == NULL) || !data)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR) {\n\t\t*data = get_user_msr(task);\n\t\treturn 0;\n\t}\n\n\tif (regno == PT_DSCR)\n\t\treturn get_user_dscr(task, data);\n\n\tif (regno < (sizeof(struct pt_regs) / sizeof(unsigned long))) {\n\t\t*data = ((unsigned long *)task->thread.regs)[regno];\n\t\treturn 0;\n\t}\n\n\treturn -EIO;\n}\n\n/*\n * Write contents of register REGNO in task TASK.\n */\nint ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)\n{\n\tif (task->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (regno == PT_MSR)\n\t\treturn set_user_msr(task, data);\n\tif (regno == PT_TRAP)\n\t\treturn set_user_trap(task, data);\n\tif (regno == PT_DSCR)\n\t\treturn set_user_dscr(task, data);\n\n\tif (regno <= PT_MAX_PUT_REG) {\n\t\t((unsigned long *)task->thread.regs)[regno] = data;\n\t\treturn 0;\n\t}\n\treturn -EIO;\n}\n\nstatic int gpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint i, ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/* We have a partial register set.  Fill 14-31 with bogus values */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  target->thread.regs,\n\t\t\t\t  0, offsetof(struct pt_regs, msr));\n\tif (!ret) {\n\t\tunsigned long msr = get_user_msr(target);\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,\n\t\t\t\t\t  offsetof(struct pt_regs, msr),\n\t\t\t\t\t  offsetof(struct pt_regs, msr) +\n\t\t\t\t\t  sizeof(msr));\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.regs->orig_gpr3,\n\t\t\t\t\t  offsetof(struct pt_regs, orig_gpr3),\n\t\t\t\t\t  sizeof(struct pt_regs));\n\tif (!ret)\n\t\tret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t       sizeof(struct pt_regs), -1);\n\n\treturn ret;\n}\n\nstatic int gpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t target->thread.regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.regs->orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last checkpointed\n * value of all FPR registers for the current transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n * };\n */\nstatic int fpr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32]));\n\n\tflush_fp_to_thread(target);\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.fp_state, 0, -1);\n#endif\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last checkpointed\n * value of all FPR registers for the current transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n * };\n *\n */\nstatic int fpr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n#ifdef CONFIG_VSX\n\tu64 buf[33];\n\tint i;\n\n\tflush_fp_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_FPR(i);\n\tbuf[32] = target->thread.fp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_FPR(i) = buf[i];\n\ttarget->thread.fp_state.fpscr = buf[32];\n\treturn 0;\n#else\n\tBUILD_BUG_ON(offsetof(struct thread_fp_state, fpscr) !=\n\t\t     offsetof(struct thread_fp_state, fpr[32]));\n\n\tflush_fp_to_thread(target);\n\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.fp_state, 0, -1);\n#endif\n}\n\n#ifdef CONFIG_ALTIVEC\n/*\n * Get/set all the altivec registers vr0..vr31, vscr, vrsave, in one go.\n * The transfer totals 34 quadword.  Quadwords 0-31 contain the\n * corresponding vector registers.  Quadword 32 contains the vscr as the\n * last word (offset 12) within that quadword.  Quadword 33 contains the\n * vrsave as the first word (offset 0) within the quadword.\n *\n * This definition of the VMX state is compatible with the current PPC32\n * ptrace interface.  This allows signal handling and ptrace to use the\n * same structures.  This also simplifies the implementation of a bi-arch\n * (combined (32- and 64-bit) gdb.\n */\n\nstatic int vr_active(struct task_struct *target,\n\t\t     const struct user_regset *regset)\n{\n\tflush_altivec_to_thread(target);\n\treturn target->thread.used_vr ? regset->n : 0;\n}\n\n/*\n * Regardless of transactions, 'vr_state' holds the current running\n * value of all the VMX registers and 'ckvr_state' holds the last\n * checkpointed value of all the VMX registers for the current\n * transaction to fall back on in case it aborts.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n * };\n */\nstatic int vr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.vr_state, 0,\n\t\t\t\t  33 * sizeof(vector128));\n\tif (!ret) {\n\t\t/*\n\t\t * Copy out only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\n\t\tvrsave.word = target->thread.vrsave;\n\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t  33 * sizeof(vector128), -1);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Regardless of transactions, 'vr_state' holds the current running\n * value of all the VMX registers and 'ckvr_state' holds the last\n * checkpointed value of all the VMX registers for the current\n * transaction to fall back on in case it aborts.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n * };\n */\nstatic int vr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t  unsigned int pos, unsigned int count,\n\t\t  const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_altivec_to_thread(target);\n\n\tBUILD_BUG_ON(offsetof(struct thread_vr_state, vscr) !=\n\t\t     offsetof(struct thread_vr_state, vr[32]));\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.vr_state, 0,\n\t\t\t\t 33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the first word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\n\t\tvrsave.word = target->thread.vrsave;\n\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t 33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.vrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}\n#endif /* CONFIG_ALTIVEC */\n\n#ifdef CONFIG_VSX\n/*\n * Currently to set and and get all the vsx state, you need to call\n * the fp and VMX calls as well.  This only get/sets the lower 32\n * 128bit VSX registers.\n */\n\nstatic int vsr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last\n * checkpointed value of all FPR registers for the current\n * transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tvsx[32];\n * };\n */\nstatic int vsr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}\n\n/*\n * Regardless of transactions, 'fp_state' holds the current running\n * value of all FPR registers and 'ckfp_state' holds the last\n * checkpointed value of all FPR registers for the current\n * transaction.\n *\n * Userspace interface buffer layout:\n *\n * struct data {\n *\tu64\tvsx[32];\n * };\n */\nstatic int vsr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret,i;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.fp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}\n#endif /* CONFIG_VSX */\n\n#ifdef CONFIG_SPE\n\n/*\n * For get_evrregs/set_evrregs functions 'data' has the following layout:\n *\n * struct {\n *   u32 evr[32];\n *   u64 acc;\n *   u32 spefscr;\n * }\n */\n\nstatic int evr_active(struct task_struct *target,\n\t\t      const struct user_regset *regset)\n{\n\tflush_spe_to_thread(target);\n\treturn target->thread.used_spe ? regset->n : 0;\n}\n\nstatic int evr_get(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.evr,\n\t\t\t\t  0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.acc,\n\t\t\t\t\t  sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}\n\nstatic int evr_set(struct task_struct *target, const struct user_regset *regset,\n\t\t   unsigned int pos, unsigned int count,\n\t\t   const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tflush_spe_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.evr,\n\t\t\t\t 0, sizeof(target->thread.evr));\n\n\tBUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=\n\t\t     offsetof(struct thread_struct, spefscr));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.acc,\n\t\t\t\t\t sizeof(target->thread.evr), -1);\n\n\treturn ret;\n}\n#endif /* CONFIG_SPE */\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n/**\n * tm_cgpr_active - get active number of registers in CGPR\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in transaction checkpointed GPR category.\n */\nstatic int tm_cgpr_active(struct task_struct *target,\n\t\t\t  const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}\n\n/**\n * tm_cgpr_get - get CGPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets transaction checkpointed GPR registers.\n *\n * When the transaction is active, 'ckpt_regs' holds all the checkpointed\n * GPR register values for the current transaction to fall back on if it\n * aborts in between. This function gets those checkpointed GPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tstruct pt_regs ckpt_regs;\n * };\n */\nstatic int tm_cgpr_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.ckpt_regs,\n\t\t\t\t  0, offsetof(struct pt_regs, msr));\n\tif (!ret) {\n\t\tunsigned long msr = get_user_ckpt_msr(target);\n\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,\n\t\t\t\t\t  offsetof(struct pt_regs, msr),\n\t\t\t\t\t  offsetof(struct pt_regs, msr) +\n\t\t\t\t\t  sizeof(msr));\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t  &target->thread.ckpt_regs.orig_gpr3,\n\t\t\t\t\t  offsetof(struct pt_regs, orig_gpr3),\n\t\t\t\t\t  sizeof(struct pt_regs));\n\tif (!ret)\n\t\tret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t       sizeof(struct pt_regs), -1);\n\n\treturn ret;\n}\n\n/*\n * tm_cgpr_set - set the CGPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed GPR registers.\n *\n * When the transaction is active, 'ckpt_regs' holds the checkpointed\n * GPR register values for the current transaction to fall back on if it\n * aborts in between. This function sets those checkpointed GPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tstruct pt_regs ckpt_regs;\n * };\n */\nstatic int tm_cgpr_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tunsigned long reg;\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t &target->thread.ckpt_regs,\n\t\t\t\t 0, PT_MSR * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_MSR * sizeof(reg),\n\t\t\t\t\t (PT_MSR + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_msr(target, reg);\n\t}\n\n\tBUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=\n\t\t     offsetof(struct pt_regs, msr) + sizeof(long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t &target->thread.ckpt_regs.orig_gpr3,\n\t\t\t\t\t PT_ORIG_R3 * sizeof(reg),\n\t\t\t\t\t (PT_MAX_PUT_REG + 1) * sizeof(reg));\n\n\tif (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_MAX_PUT_REG + 1) * sizeof(reg),\n\t\t\tPT_TRAP * sizeof(reg));\n\n\tif (!ret && count > 0) {\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,\n\t\t\t\t\t PT_TRAP * sizeof(reg),\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg));\n\t\tif (!ret)\n\t\t\tret = set_user_ckpt_trap(target, reg);\n\t}\n\n\tif (!ret)\n\t\tret = user_regset_copyin_ignore(\n\t\t\t&pos, &count, &kbuf, &ubuf,\n\t\t\t(PT_TRAP + 1) * sizeof(reg), -1);\n\n\treturn ret;\n}\n\n/**\n * tm_cfpr_active - get active number of registers in CFPR\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in transaction checkpointed FPR category.\n */\nstatic int tm_cfpr_active(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}\n\n/**\n * tm_cfpr_get - get CFPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets in transaction checkpointed FPR registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * values for the current transaction to fall back on if it aborts\n * in between. This function gets those checkpointed FPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n *};\n */\nstatic int tm_cfpr_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* copy to local buffer then write that out */\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n}\n\n/**\n * tm_cfpr_set - set CFPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed FPR registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * FPR register values for the current transaction to fall back on\n * if it aborts in between. This function sets these checkpointed\n * FPR registers. The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tfpr[32];\n *\tu64\tfpscr;\n *};\n */\nstatic int tm_cfpr_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[33];\n\tint i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tfor (i = 0; i < 32; i++)\n\t\tbuf[i] = target->thread.TS_CKFPR(i);\n\tbuf[32] = target->thread.ckfp_state.fpscr;\n\n\t/* copy to local buffer then write that out */\n\ti = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);\n\tif (i)\n\t\treturn i;\n\tfor (i = 0; i < 32 ; i++)\n\t\ttarget->thread.TS_CKFPR(i) = buf[i];\n\ttarget->thread.ckfp_state.fpscr = buf[32];\n\treturn 0;\n}\n\n/**\n * tm_cvmx_active - get active number of registers in CVMX\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in checkpointed VMX category.\n */\nstatic int tm_cvmx_active(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\treturn regset->n;\n}\n\n/**\n * tm_cvmx_get - get CMVX registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets in transaction checkpointed VMX registers.\n *\n * When the transaction is active 'ckvr_state' and 'ckvrsave' hold\n * the checkpointed values for the current transaction to fall\n * back on if it aborts in between. The userspace interface buffer\n * layout is as follows.\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n *};\n */\nstatic int tm_cvmx_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t&target->thread.ckvr_state, 0,\n\t\t\t\t\t33 * sizeof(vector128));\n\tif (!ret) {\n\t\t/*\n\t\t * Copy out only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.ckvrsave;\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t\t33 * sizeof(vector128), -1);\n\t}\n\n\treturn ret;\n}\n\n/**\n * tm_cvmx_set - set CMVX registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed VMX registers.\n *\n * When the transaction is active 'ckvr_state' and 'ckvrsave' hold\n * the checkpointed values for the current transaction to fall\n * back on if it aborts in between. The userspace interface buffer\n * layout is as follows.\n *\n * struct data {\n *\tvector128\tvr[32];\n *\tvector128\tvscr;\n *\tvector128\tvrsave;\n *};\n */\nstatic int tm_cvmx_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tBUILD_BUG_ON(TVSO(vscr) != TVSO(vr[32]));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t&target->thread.ckvr_state, 0,\n\t\t\t\t\t33 * sizeof(vector128));\n\tif (!ret && count > 0) {\n\t\t/*\n\t\t * We use only the low-order word of vrsave.\n\t\t */\n\t\tunion {\n\t\t\telf_vrreg_t reg;\n\t\t\tu32 word;\n\t\t} vrsave;\n\t\tmemset(&vrsave, 0, sizeof(vrsave));\n\t\tvrsave.word = target->thread.ckvrsave;\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,\n\t\t\t\t\t\t33 * sizeof(vector128), -1);\n\t\tif (!ret)\n\t\t\ttarget->thread.ckvrsave = vrsave.word;\n\t}\n\n\treturn ret;\n}\n\n/**\n * tm_cvsx_active - get active number of registers in CVSX\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks for the active number of available\n * regisers in transaction checkpointed VSX category.\n */\nstatic int tm_cvsx_active(struct task_struct *target,\n\t\t\t\tconst struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn 0;\n\n\tflush_vsx_to_thread(target);\n\treturn target->thread.used_vsr ? regset->n : 0;\n}\n\n/**\n * tm_cvsx_get - get CVSX registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets in transaction checkpointed VSX registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * values for the current transaction to fall back on if it aborts\n * in between. This function gets those checkpointed VSX registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tvsx[32];\n *};\n */\nstatic int tm_cvsx_get(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tvoid *kbuf, void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  buf, 0, 32 * sizeof(double));\n\n\treturn ret;\n}\n\n/**\n * tm_cvsx_set - set CFPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets in transaction checkpointed VSX registers.\n *\n * When the transaction is active 'ckfp_state' holds the checkpointed\n * VSX register values for the current transaction to fall back on\n * if it aborts in between. This function sets these checkpointed\n * FPR registers. The userspace interface buffer layout is as follows.\n *\n * struct data {\n *\tu64\tvsx[32];\n *};\n */\nstatic int tm_cvsx_set(struct task_struct *target,\n\t\t\tconst struct user_regset *regset,\n\t\t\tunsigned int pos, unsigned int count,\n\t\t\tconst void *kbuf, const void __user *ubuf)\n{\n\tu64 buf[32];\n\tint ret, i;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\t/* Flush the state */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\tflush_vsx_to_thread(target);\n\n\tfor (i = 0; i < 32 ; i++)\n\t\tbuf[i] = target->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET];\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t buf, 0, 32 * sizeof(double));\n\tif (!ret)\n\t\tfor (i = 0; i < 32 ; i++)\n\t\t\ttarget->thread.ckfp_state.fpr[i][TS_VSRLOWOFFSET] = buf[i];\n\n\treturn ret;\n}\n\n/**\n * tm_spr_active - get active number of registers in TM SPR\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n *\n * This function checks the active number of available\n * regisers in the transactional memory SPR category.\n */\nstatic int tm_spr_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}\n\n/**\n * tm_spr_get - get the TM related SPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy from.\n * @ubuf:\tUser buffer to copy into.\n *\n * This function gets transactional memory related SPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct {\n *\tu64\t\ttm_tfhar;\n *\tu64\t\ttm_texasr;\n *\tu64\t\ttm_tfiar;\n * };\n */\nstatic int tm_spr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfhar, 0, sizeof(u64));\n\n\t/* TEXASR register */\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_texasr, sizeof(u64),\n\t\t\t\t2 * sizeof(u64));\n\n\t/* TFIAR register */\n\tif (!ret)\n\t\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfiar,\n\t\t\t\t2 * sizeof(u64), 3 * sizeof(u64));\n\treturn ret;\n}\n\n/**\n * tm_spr_set - set the TM related SPR registers\n * @target:\tThe target task.\n * @regset:\tThe user regset structure.\n * @pos:\tThe buffer position.\n * @count:\tNumber of bytes to copy.\n * @kbuf:\tKernel buffer to copy into.\n * @ubuf:\tUser buffer to copy from.\n *\n * This function sets transactional memory related SPR registers.\n * The userspace interface buffer layout is as follows.\n *\n * struct {\n *\tu64\t\ttm_tfhar;\n *\tu64\t\ttm_texasr;\n *\tu64\t\ttm_tfiar;\n * };\n */\nstatic int tm_spr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(tm_tfhar) + sizeof(u64) != TSO(tm_texasr));\n\tBUILD_BUG_ON(TSO(tm_texasr) + sizeof(u64) != TSO(tm_tfiar));\n\tBUILD_BUG_ON(TSO(tm_tfiar) + sizeof(u64) != TSO(ckpt_regs));\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\t/* Flush the states */\n\tflush_tmregs_to_thread(target);\n\tflush_fp_to_thread(target);\n\tflush_altivec_to_thread(target);\n\n\t/* TFHAR register */\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfhar, 0, sizeof(u64));\n\n\t/* TEXASR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_texasr, sizeof(u64),\n\t\t\t\t2 * sizeof(u64));\n\n\t/* TFIAR register */\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tfiar,\n\t\t\t\t 2 * sizeof(u64), 3 * sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_tar_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\nstatic int tm_tar_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tar, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_tar_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_tar, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_ppr_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\n\nstatic int tm_ppr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_ppr, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_ppr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_ppr, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_dscr_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\nstatic int tm_dscr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_dscr, 0, sizeof(u64));\n\treturn ret;\n}\n\nstatic int tm_dscr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret;\n\n\tif (!cpu_has_feature(CPU_FTR_TM))\n\t\treturn -ENODEV;\n\n\tif (!MSR_TM_ACTIVE(target->thread.regs->msr))\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t&target->thread.tm_dscr, 0, sizeof(u64));\n\treturn ret;\n}\n#endif\t/* CONFIG_PPC_TRANSACTIONAL_MEM */\n\n#ifdef CONFIG_PPC64\nstatic int ppr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.ppr, 0, sizeof(u64));\n}\n\nstatic int ppr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.ppr, 0, sizeof(u64));\n}\n\nstatic int dscr_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.dscr, 0, sizeof(u64));\n}\nstatic int dscr_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.dscr, 0, sizeof(u64));\n}\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\nstatic int tar_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t   &target->thread.tar, 0, sizeof(u64));\n}\nstatic int tar_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\treturn user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t  &target->thread.tar, 0, sizeof(u64));\n}\n\nstatic int ebb_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn regset->n;\n\n\treturn 0;\n}\n\nstatic int ebb_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (!target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.ebbrr, 0, 3 * sizeof(unsigned long));\n}\n\nstatic int ebb_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(ebbrr) + sizeof(unsigned long) != TSO(ebbhr));\n\tBUILD_BUG_ON(TSO(ebbhr) + sizeof(unsigned long) != TSO(bescr));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tif (target->thread.used_ebb)\n\t\treturn -ENODATA;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.ebbrr, 0, sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.ebbhr, sizeof(unsigned long),\n\t\t\t2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.bescr,\n\t\t\t2 * sizeof(unsigned long), 3 * sizeof(unsigned long));\n\n\treturn ret;\n}\nstatic int pmu_active(struct task_struct *target,\n\t\t\t const struct user_regset *regset)\n{\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn regset->n;\n}\n\nstatic int pmu_get(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      void *kbuf, void __user *ubuf)\n{\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\treturn user_regset_copyout(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.siar, 0,\n\t\t\t5 * sizeof(unsigned long));\n}\n\nstatic int pmu_set(struct task_struct *target,\n\t\t      const struct user_regset *regset,\n\t\t      unsigned int pos, unsigned int count,\n\t\t      const void *kbuf, const void __user *ubuf)\n{\n\tint ret = 0;\n\n\t/* Build tests */\n\tBUILD_BUG_ON(TSO(siar) + sizeof(unsigned long) != TSO(sdar));\n\tBUILD_BUG_ON(TSO(sdar) + sizeof(unsigned long) != TSO(sier));\n\tBUILD_BUG_ON(TSO(sier) + sizeof(unsigned long) != TSO(mmcr2));\n\tBUILD_BUG_ON(TSO(mmcr2) + sizeof(unsigned long) != TSO(mmcr0));\n\n\tif (!cpu_has_feature(CPU_FTR_ARCH_207S))\n\t\treturn -ENODEV;\n\n\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.siar, 0,\n\t\t\tsizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.sdar, sizeof(unsigned long),\n\t\t\t2 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.sier, 2 * sizeof(unsigned long),\n\t\t\t3 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.mmcr2, 3 * sizeof(unsigned long),\n\t\t\t4 * sizeof(unsigned long));\n\n\tif (!ret)\n\t\tret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,\n\t\t\t&target->thread.mmcr0, 4 * sizeof(unsigned long),\n\t\t\t5 * sizeof(unsigned long));\n\treturn ret;\n}\n#endif\n/*\n * These are our native regset flavors.\n */\nenum powerpc_regset {\n\tREGSET_GPR,\n\tREGSET_FPR,\n#ifdef CONFIG_ALTIVEC\n\tREGSET_VMX,\n#endif\n#ifdef CONFIG_VSX\n\tREGSET_VSX,\n#endif\n#ifdef CONFIG_SPE\n\tREGSET_SPE,\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\tREGSET_TM_CGPR,\t\t/* TM checkpointed GPR registers */\n\tREGSET_TM_CFPR,\t\t/* TM checkpointed FPR registers */\n\tREGSET_TM_CVMX,\t\t/* TM checkpointed VMX registers */\n\tREGSET_TM_CVSX,\t\t/* TM checkpointed VSX registers */\n\tREGSET_TM_SPR,\t\t/* TM specific SPR registers */\n\tREGSET_TM_CTAR,\t\t/* TM checkpointed TAR register */\n\tREGSET_TM_CPPR,\t\t/* TM checkpointed PPR register */\n\tREGSET_TM_CDSCR,\t/* TM checkpointed DSCR register */\n#endif\n#ifdef CONFIG_PPC64\n\tREGSET_PPR,\t\t/* PPR register */\n\tREGSET_DSCR,\t\t/* DSCR register */\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\tREGSET_TAR,\t\t/* TAR register */\n\tREGSET_EBB,\t\t/* EBB registers */\n\tREGSET_PMR,\t\t/* Performance Monitor Registers */\n#endif\n};\n\nstatic const struct user_regset native_regsets[] = {\n\t[REGSET_GPR] = {\n\t\t.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,\n\t\t.size = sizeof(long), .align = sizeof(long),\n\t\t.get = gpr_get, .set = gpr_set\n\t},\n\t[REGSET_FPR] = {\n\t\t.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.get = fpr_get, .set = fpr_set\n\t},\n#ifdef CONFIG_ALTIVEC\n\t[REGSET_VMX] = {\n\t\t.core_note_type = NT_PPC_VMX, .n = 34,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = vr_active, .get = vr_get, .set = vr_set\n\t},\n#endif\n#ifdef CONFIG_VSX\n\t[REGSET_VSX] = {\n\t\t.core_note_type = NT_PPC_VSX, .n = 32,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = vsr_active, .get = vsr_get, .set = vsr_set\n\t},\n#endif\n#ifdef CONFIG_SPE\n\t[REGSET_SPE] = {\n\t\t.core_note_type = NT_PPC_SPE, .n = 35,\n\t\t.size = sizeof(u32), .align = sizeof(u32),\n\t\t.active = evr_active, .get = evr_get, .set = evr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t[REGSET_TM_CGPR] = {\n\t\t.core_note_type = NT_PPC_TM_CGPR, .n = ELF_NGREG,\n\t\t.size = sizeof(long), .align = sizeof(long),\n\t\t.active = tm_cgpr_active, .get = tm_cgpr_get, .set = tm_cgpr_set\n\t},\n\t[REGSET_TM_CFPR] = {\n\t\t.core_note_type = NT_PPC_TM_CFPR, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cfpr_active, .get = tm_cfpr_get, .set = tm_cfpr_set\n\t},\n\t[REGSET_TM_CVMX] = {\n\t\t.core_note_type = NT_PPC_TM_CVMX, .n = ELF_NVMX,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = tm_cvmx_active, .get = tm_cvmx_get, .set = tm_cvmx_set\n\t},\n\t[REGSET_TM_CVSX] = {\n\t\t.core_note_type = NT_PPC_TM_CVSX, .n = ELF_NVSX,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cvsx_active, .get = tm_cvsx_get, .set = tm_cvsx_set\n\t},\n\t[REGSET_TM_SPR] = {\n\t\t.core_note_type = NT_PPC_TM_SPR, .n = ELF_NTMSPRREG,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_spr_active, .get = tm_spr_get, .set = tm_spr_set\n\t},\n\t[REGSET_TM_CTAR] = {\n\t\t.core_note_type = NT_PPC_TM_CTAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_tar_active, .get = tm_tar_get, .set = tm_tar_set\n\t},\n\t[REGSET_TM_CPPR] = {\n\t\t.core_note_type = NT_PPC_TM_CPPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_ppr_active, .get = tm_ppr_get, .set = tm_ppr_set\n\t},\n\t[REGSET_TM_CDSCR] = {\n\t\t.core_note_type = NT_PPC_TM_CDSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_dscr_active, .get = tm_dscr_get, .set = tm_dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC64\n\t[REGSET_PPR] = {\n\t\t.core_note_type = NT_PPC_PPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = ppr_get, .set = ppr_set\n\t},\n\t[REGSET_DSCR] = {\n\t\t.core_note_type = NT_PPC_DSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = dscr_get, .set = dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\t[REGSET_TAR] = {\n\t\t.core_note_type = NT_PPC_TAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = tar_get, .set = tar_set\n\t},\n\t[REGSET_EBB] = {\n\t\t.core_note_type = NT_PPC_EBB, .n = ELF_NEBB,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = ebb_active, .get = ebb_get, .set = ebb_set\n\t},\n\t[REGSET_PMR] = {\n\t\t.core_note_type = NT_PPC_PMU, .n = ELF_NPMU,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = pmu_active, .get = pmu_get, .set = pmu_set\n\t},\n#endif\n};\n\nstatic const struct user_regset_view user_ppc_native_view = {\n\t.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,\n\t.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)\n};\n\n#ifdef CONFIG_PPC64\n#include <linux/compat.h>\n\nstatic int gpr32_get_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t\t    void *kbuf, void __user *ubuf,\n\t\t\t    unsigned long *regs)\n{\n\tcompat_ulong_t *k = kbuf;\n\tcompat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\treg = get_user_msr(target);\n\t\tif (kbuf)\n\t\t\t*k++ = reg;\n\t\telse if (__put_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\t*k++ = regs[pos++];\n\telse\n\t\tfor (; count > 0 && pos < PT_REGS_COUNT; --count)\n\t\t\tif (__put_user((compat_ulong_t) regs[pos++], u++))\n\t\t\t\treturn -EFAULT;\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\tPT_REGS_COUNT * sizeof(reg), -1);\n}\n\nstatic int gpr32_set_common(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf,\n\t\t     unsigned long *regs)\n{\n\tconst compat_ulong_t *k = kbuf;\n\tconst compat_ulong_t __user *u = ubuf;\n\tcompat_ulong_t reg;\n\n\tpos /= sizeof(reg);\n\tcount /= sizeof(reg);\n\n\tif (kbuf)\n\t\tfor (; count > 0 && pos < PT_MSR; --count)\n\t\t\tregs[pos++] = *k++;\n\telse\n\t\tfor (; count > 0 && pos < PT_MSR; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\n\n\tif (count > 0 && pos == PT_MSR) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_msr(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tif (kbuf) {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count)\n\t\t\tregs[pos++] = *k++;\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\t++k;\n\t} else {\n\t\tfor (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t\t\tregs[pos++] = reg;\n\t\t}\n\t\tfor (; count > 0 && pos < PT_TRAP; --count, ++pos)\n\t\t\tif (__get_user(reg, u++))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (count > 0 && pos == PT_TRAP) {\n\t\tif (kbuf)\n\t\t\treg = *k++;\n\t\telse if (__get_user(reg, u++))\n\t\t\treturn -EFAULT;\n\t\tset_user_trap(target, reg);\n\t\t++pos;\n\t\t--count;\n\t}\n\n\tkbuf = k;\n\tubuf = u;\n\tpos *= sizeof(reg);\n\tcount *= sizeof(reg);\n\treturn user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,\n\t\t\t\t\t (PT_TRAP + 1) * sizeof(reg), -1);\n}\n\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\nstatic int tm_cgpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     void *kbuf, void __user *ubuf)\n{\n\treturn gpr32_get_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.ckpt_regs.gpr[0]);\n}\n\nstatic int tm_cgpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.ckpt_regs.gpr[0]);\n}\n#endif /* CONFIG_PPC_TRANSACTIONAL_MEM */\n\nstatic int gpr32_get(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     void *kbuf, void __user *ubuf)\n{\n\tint i;\n\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tif (!FULL_REGS(target->thread.regs)) {\n\t\t/*\n\t\t * We have a partial register set.\n\t\t * Fill 14-31 with bogus values.\n\t\t */\n\t\tfor (i = 14; i < 32; i++)\n\t\t\ttarget->thread.regs->gpr[i] = NV_REG_POISON;\n\t}\n\treturn gpr32_get_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.regs->gpr[0]);\n}\n\nstatic int gpr32_set(struct task_struct *target,\n\t\t     const struct user_regset *regset,\n\t\t     unsigned int pos, unsigned int count,\n\t\t     const void *kbuf, const void __user *ubuf)\n{\n\tif (target->thread.regs == NULL)\n\t\treturn -EIO;\n\n\tCHECK_FULL_REGS(target->thread.regs);\n\treturn gpr32_set_common(target, regset, pos, count, kbuf, ubuf,\n\t\t\t&target->thread.regs->gpr[0]);\n}\n\n/*\n * These are the regset flavors matching the CONFIG_PPC32 native set.\n */\nstatic const struct user_regset compat_regsets[] = {\n\t[REGSET_GPR] = {\n\t\t.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,\n\t\t.size = sizeof(compat_long_t), .align = sizeof(compat_long_t),\n\t\t.get = gpr32_get, .set = gpr32_set\n\t},\n\t[REGSET_FPR] = {\n\t\t.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.get = fpr_get, .set = fpr_set\n\t},\n#ifdef CONFIG_ALTIVEC\n\t[REGSET_VMX] = {\n\t\t.core_note_type = NT_PPC_VMX, .n = 34,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = vr_active, .get = vr_get, .set = vr_set\n\t},\n#endif\n#ifdef CONFIG_SPE\n\t[REGSET_SPE] = {\n\t\t.core_note_type = NT_PPC_SPE, .n = 35,\n\t\t.size = sizeof(u32), .align = sizeof(u32),\n\t\t.active = evr_active, .get = evr_get, .set = evr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_TRANSACTIONAL_MEM\n\t[REGSET_TM_CGPR] = {\n\t\t.core_note_type = NT_PPC_TM_CGPR, .n = ELF_NGREG,\n\t\t.size = sizeof(long), .align = sizeof(long),\n\t\t.active = tm_cgpr_active,\n\t\t.get = tm_cgpr32_get, .set = tm_cgpr32_set\n\t},\n\t[REGSET_TM_CFPR] = {\n\t\t.core_note_type = NT_PPC_TM_CFPR, .n = ELF_NFPREG,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cfpr_active, .get = tm_cfpr_get, .set = tm_cfpr_set\n\t},\n\t[REGSET_TM_CVMX] = {\n\t\t.core_note_type = NT_PPC_TM_CVMX, .n = ELF_NVMX,\n\t\t.size = sizeof(vector128), .align = sizeof(vector128),\n\t\t.active = tm_cvmx_active, .get = tm_cvmx_get, .set = tm_cvmx_set\n\t},\n\t[REGSET_TM_CVSX] = {\n\t\t.core_note_type = NT_PPC_TM_CVSX, .n = ELF_NVSX,\n\t\t.size = sizeof(double), .align = sizeof(double),\n\t\t.active = tm_cvsx_active, .get = tm_cvsx_get, .set = tm_cvsx_set\n\t},\n\t[REGSET_TM_SPR] = {\n\t\t.core_note_type = NT_PPC_TM_SPR, .n = ELF_NTMSPRREG,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_spr_active, .get = tm_spr_get, .set = tm_spr_set\n\t},\n\t[REGSET_TM_CTAR] = {\n\t\t.core_note_type = NT_PPC_TM_CTAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_tar_active, .get = tm_tar_get, .set = tm_tar_set\n\t},\n\t[REGSET_TM_CPPR] = {\n\t\t.core_note_type = NT_PPC_TM_CPPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_ppr_active, .get = tm_ppr_get, .set = tm_ppr_set\n\t},\n\t[REGSET_TM_CDSCR] = {\n\t\t.core_note_type = NT_PPC_TM_CDSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = tm_dscr_active, .get = tm_dscr_get, .set = tm_dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC64\n\t[REGSET_PPR] = {\n\t\t.core_note_type = NT_PPC_PPR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = ppr_get, .set = ppr_set\n\t},\n\t[REGSET_DSCR] = {\n\t\t.core_note_type = NT_PPC_DSCR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = dscr_get, .set = dscr_set\n\t},\n#endif\n#ifdef CONFIG_PPC_BOOK3S_64\n\t[REGSET_TAR] = {\n\t\t.core_note_type = NT_PPC_TAR, .n = 1,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.get = tar_get, .set = tar_set\n\t},\n\t[REGSET_EBB] = {\n\t\t.core_note_type = NT_PPC_EBB, .n = ELF_NEBB,\n\t\t.size = sizeof(u64), .align = sizeof(u64),\n\t\t.active = ebb_active, .get = ebb_get, .set = ebb_set\n\t},\n#endif\n};\n\nstatic const struct user_regset_view user_ppc_compat_view = {\n\t.name = \"ppc\", .e_machine = EM_PPC, .ei_osabi = ELF_OSABI,\n\t.regsets = compat_regsets, .n = ARRAY_SIZE(compat_regsets)\n};\n#endif\t/* CONFIG_PPC64 */\n\nconst struct user_regset_view *task_user_regset_view(struct task_struct *task)\n{\n#ifdef CONFIG_PPC64\n\tif (test_tsk_thread_flag(task, TIF_32BIT))\n\t\treturn &user_ppc_compat_view;\n#endif\n\treturn &user_ppc_native_view;\n}\n\n\nvoid user_enable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_BT;\n\t\ttask->thread.debug.dbcr0 |= DBCR0_IDM | DBCR0_IC;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_BE;\n\t\tregs->msr |= MSR_SE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}\n\nvoid user_enable_block_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IC;\n\t\ttask->thread.debug.dbcr0 = DBCR0_IDM | DBCR0_BT;\n\t\tregs->msr |= MSR_DE;\n#else\n\t\tregs->msr &= ~MSR_SE;\n\t\tregs->msr |= MSR_BE;\n#endif\n\t}\n\tset_tsk_thread_flag(task, TIF_SINGLESTEP);\n}\n\nvoid user_disable_single_step(struct task_struct *task)\n{\n\tstruct pt_regs *regs = task->thread.regs;\n\n\tif (regs != NULL) {\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\t/*\n\t\t * The logic to disable single stepping should be as\n\t\t * simple as turning off the Instruction Complete flag.\n\t\t * And, after doing so, if all debug flags are off, turn\n\t\t * off DBCR0(IDM) and MSR(DE) .... Torez\n\t\t */\n\t\ttask->thread.debug.dbcr0 &= ~(DBCR0_IC|DBCR0_BT);\n\t\t/*\n\t\t * Test to see if any of the DBCR_ACTIVE_EVENTS bits are set.\n\t\t */\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\t/*\n\t\t\t * All debug events were off.....\n\t\t\t */\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tregs->msr &= ~MSR_DE;\n\t\t}\n#else\n\t\tregs->msr &= ~(MSR_SE | MSR_BE);\n#endif\n\t}\n\tclear_tsk_thread_flag(task, TIF_SINGLESTEP);\n}\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\nvoid ptrace_triggered(struct perf_event *bp,\n\t\t      struct perf_sample_data *data, struct pt_regs *regs)\n{\n\tstruct perf_event_attr attr;\n\n\t/*\n\t * Disable the breakpoint request here since ptrace has defined a\n\t * one-shot behaviour for breakpoint exceptions in PPC64.\n\t * The SIGTRAP signal is generated automatically for us in do_dabr().\n\t * We don't have to do anything about that here\n\t */\n\tattr = bp->attr;\n\tattr.disabled = true;\n\tmodify_user_hw_breakpoint(bp, &attr);\n}\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\nstatic int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,\n\t\t\t       unsigned long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret;\n\tstruct thread_struct *thread = &(task->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint hw_brk;\n#endif\n\n\t/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).\n\t *  For embedded processors we support one DAC and no IAC's at the\n\t *  moment.\n\t */\n\tif (addr > 0)\n\t\treturn -EINVAL;\n\n\t/* The bottom 3 bits in dabr are flags */\n\tif ((data & ~0x7UL) >= TASK_SIZE)\n\t\treturn -EIO;\n\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.\n\t *  It was assumed, on previous implementations, that 3 bits were\n\t *  passed together with the data address, fitting the design of the\n\t *  DABR register, as follows:\n\t *\n\t *  bit 0: Read flag\n\t *  bit 1: Write flag\n\t *  bit 2: Breakpoint translation\n\t *\n\t *  Thus, we use them here as so.\n\t */\n\n\t/* Ensure breakpoint translation bit is set */\n\tif (data && !(data & HW_BRK_TYPE_TRANSLATE))\n\t\treturn -EIO;\n\thw_brk.address = data & (~HW_BRK_TYPE_DABR);\n\thw_brk.type = (data & HW_BRK_TYPE_DABR) | HW_BRK_TYPE_PRIV_ALL;\n\thw_brk.len = 8;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif ((!data) || !(hw_brk.type & HW_BRK_TYPE_RDWR)) {\n\t\tif (bp) {\n\t\t\tunregister_hw_breakpoint(bp);\n\t\t\tthread->ptrace_bps[0] = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\tif (bp) {\n\t\tattr = bp->attr;\n\t\tattr.bp_addr = hw_brk.address;\n\t\tarch_bp_generic_fields(hw_brk.type, &attr.bp_type);\n\n\t\t/* Enable breakpoint */\n\t\tattr.disabled = false;\n\n\t\tret =  modify_user_hw_breakpoint(bp, &attr);\n\t\tif (ret) {\n\t\t\treturn ret;\n\t\t}\n\t\tthread->ptrace_bps[0] = bp;\n\t\tthread->hw_brk = hw_brk;\n\t\treturn 0;\n\t}\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = hw_brk.address;\n\tarch_bp_generic_fields(hw_brk.type,\n\t\t\t       &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, task);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\ttask->thread.hw_brk = hw_brk;\n#else /* CONFIG_PPC_ADV_DEBUG_REGS */\n\t/* As described above, it was assumed 3 bits were passed with the data\n\t *  address, but we will assume only the mode bits will be passed\n\t *  as to not cause alignment restrictions for DAC-based processors.\n\t */\n\n\t/* DAC's hold the whole address without any mode flags */\n\ttask->thread.debug.dac1 = data & ~0x3UL;\n\n\tif (task->thread.debug.dac1 == 0) {\n\t\tdbcr_dac(task) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n\t\tif (!DBCR_ACTIVE_EVENTS(task->thread.debug.dbcr0,\n\t\t\t\t\ttask->thread.debug.dbcr1)) {\n\t\t\ttask->thread.regs->msr &= ~MSR_DE;\n\t\t\ttask->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Read or Write bits must be set */\n\n\tif (!(data & 0x3UL))\n\t\treturn -EINVAL;\n\n\t/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0\n\t   register */\n\ttask->thread.debug.dbcr0 |= DBCR0_IDM;\n\n\t/* Check for write and read flags and set DBCR0\n\t   accordingly */\n\tdbcr_dac(task) &= ~(DBCR_DAC1R|DBCR_DAC1W);\n\tif (data & 0x1UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1R;\n\tif (data & 0x2UL)\n\t\tdbcr_dac(task) |= DBCR_DAC1W;\n\ttask->thread.regs->msr |= MSR_DE;\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\treturn 0;\n}\n\n/*\n * Called by kernel/ptrace.c when detaching..\n *\n * Make sure single step bits etc are not set.\n */\nvoid ptrace_disable(struct task_struct *child)\n{\n\t/* make sure the single step bit is not set. */\n\tuser_disable_single_step(child);\n}\n\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\nstatic long set_instruction_bp(struct task_struct *child,\n\t\t\t      struct ppc_hw_breakpoint *bp_info)\n{\n\tint slot;\n\tint slot1_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC1) != 0);\n\tint slot2_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC2) != 0);\n\tint slot3_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC3) != 0);\n\tint slot4_in_use = ((child->thread.debug.dbcr0 & DBCR0_IAC4) != 0);\n\n\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\tslot2_in_use = 1;\n\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\tslot4_in_use = 1;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT) {\n\n\t\t/* Make sure range is valid. */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\n\t\t/* We need a pair of IAC regsisters */\n\t\tif ((!slot1_in_use) && (!slot2_in_use)) {\n\t\t\tslot = 1;\n\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC12I;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if ((!slot3_in_use) && (!slot4_in_use)) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr2;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t\tif (bp_info->addr_mode ==\n\t\t\t\t\tPPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34X;\n\t\t\telse\n\t\t\t\tdbcr_iac_range(child) |= DBCR_IAC34I;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t} else {\n\t\t/* We only need one.  If possible leave a pair free in\n\t\t * case a range is needed later\n\t\t */\n\t\tif (!slot1_in_use) {\n\t\t\t/*\n\t\t\t * Don't use iac1 if iac1-iac2 are free and either\n\t\t\t * iac3 or iac4 (but not both) are free\n\t\t\t */\n\t\t\tif (slot2_in_use || (slot3_in_use == slot4_in_use)) {\n\t\t\t\tslot = 1;\n\t\t\t\tchild->thread.debug.iac1 = bp_info->addr;\n\t\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC1;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!slot2_in_use) {\n\t\t\tslot = 2;\n\t\t\tchild->thread.debug.iac2 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC2;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\t\t} else if (!slot3_in_use) {\n\t\t\tslot = 3;\n\t\t\tchild->thread.debug.iac3 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC3;\n\t\t} else if (!slot4_in_use) {\n\t\t\tslot = 4;\n\t\t\tchild->thread.debug.iac4 = bp_info->addr;\n\t\t\tchild->thread.debug.dbcr0 |= DBCR0_IAC4;\n#endif\n\t\t} else\n\t\t\treturn -ENOSPC;\n\t}\nout:\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot;\n}\n\nstatic int del_instruction_bp(struct task_struct *child, int slot)\n{\n\tswitch (slot) {\n\tcase 1:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC1) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE) {\n\t\t\t/* address range - clear slots 1 & 2 */\n\t\t\tchild->thread.debug.iac2 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC12MODE;\n\t\t}\n\t\tchild->thread.debug.iac1 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC1;\n\t\tbreak;\n\tcase 2:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC2) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC12MODE)\n\t\t\t/* used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac2 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC2;\n\t\tbreak;\n#if CONFIG_PPC_ADV_DEBUG_IACS > 2\n\tcase 3:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC3) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE) {\n\t\t\t/* address range - clear slots 3 & 4 */\n\t\t\tchild->thread.debug.iac4 = 0;\n\t\t\tdbcr_iac_range(child) &= ~DBCR_IAC34MODE;\n\t\t}\n\t\tchild->thread.debug.iac3 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC3;\n\t\tbreak;\n\tcase 4:\n\t\tif ((child->thread.debug.dbcr0 & DBCR0_IAC4) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tif (dbcr_iac_range(child) & DBCR_IAC34MODE)\n\t\t\t/* Used in a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.iac4 = 0;\n\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IAC4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\treturn 0;\n}\n\nstatic int set_dac(struct task_struct *child, struct ppc_hw_breakpoint *bp_info)\n{\n\tint byte_enable =\n\t\t(bp_info->condition_mode >> PPC_BREAKPOINT_CONDITION_BE_SHIFT)\n\t\t& 0xf;\n\tint condition_mode =\n\t\tbp_info->condition_mode & PPC_BREAKPOINT_CONDITION_MODE;\n\tint slot;\n\n\tif (byte_enable && (condition_mode == 0))\n\t\treturn -EINVAL;\n\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0) {\n\t\tslot = 1;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC1W;\n\t\tchild->thread.debug.dac1 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc1 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC1BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC1M_SHIFT));\n\t\t}\n#endif\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t} else if (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t/* Both dac1 and dac2 are part of a range */\n\t\treturn -ENOSPC;\n#endif\n\t} else if ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0) {\n\t\tslot = 2;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2R;\n\t\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\t\tdbcr_dac(child) |= DBCR_DAC2W;\n\t\tchild->thread.debug.dac2 = (unsigned long)bp_info->addr;\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tif (byte_enable) {\n\t\t\tchild->thread.debug.dvc2 =\n\t\t\t\t(unsigned long)bp_info->condition_value;\n\t\t\tchild->thread.debug.dbcr2 |=\n\t\t\t\t((byte_enable << DBCR2_DVC2BE_SHIFT) |\n\t\t\t\t (condition_mode << DBCR2_DVC2M_SHIFT));\n\t\t}\n#endif\n\t} else\n\t\treturn -ENOSPC;\n\tchild->thread.debug.dbcr0 |= DBCR0_IDM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn slot + 4;\n}\n\nstatic int del_dac(struct task_struct *child, int slot)\n{\n\tif (slot == 1) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC1R | DBCR_DAC1W)) == 0)\n\t\t\treturn -ENOENT;\n\n\t\tchild->thread.debug.dac1 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC1R | DBCR_DAC1W);\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE) {\n\t\t\tchild->thread.debug.dac2 = 0;\n\t\t\tchild->thread.debug.dbcr2 &= ~DBCR2_DAC12MODE;\n\t\t}\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC1M | DBCR2_DVC1BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc1 = 0;\n#endif\n\t} else if (slot == 2) {\n\t\tif ((dbcr_dac(child) & (DBCR_DAC2R | DBCR_DAC2W)) == 0)\n\t\t\treturn -ENOENT;\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tif (child->thread.debug.dbcr2 & DBCR2_DAC12MODE)\n\t\t\t/* Part of a range */\n\t\t\treturn -EINVAL;\n\t\tchild->thread.debug.dbcr2 &= ~(DBCR2_DVC2M | DBCR2_DVC2BE);\n#endif\n#if CONFIG_PPC_ADV_DEBUG_DVCS > 0\n\t\tchild->thread.debug.dvc2 = 0;\n#endif\n\t\tchild->thread.debug.dac2 = 0;\n\t\tdbcr_dac(child) &= ~(DBCR_DAC2R | DBCR_DAC2W);\n\t} else\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\nstatic int set_dac_range(struct task_struct *child,\n\t\t\t struct ppc_hw_breakpoint *bp_info)\n{\n\tint mode = bp_info->addr_mode & PPC_BREAKPOINT_MODE_MASK;\n\n\t/* We don't allow range watchpoints to be used with DVC */\n\tif (bp_info->condition_mode)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Best effort to verify the address range.  The user/supervisor bits\n\t * prevent trapping in kernel space, but let's fail on an obvious bad\n\t * range.  The simple test on the mask is not fool-proof, and any\n\t * exclusive range will spill over into kernel space.\n\t */\n\tif (bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\tif (mode == PPC_BREAKPOINT_MODE_MASK) {\n\t\t/*\n\t\t * dac2 is a bitmask.  Don't allow a mask that makes a\n\t\t * kernel space address from a valid dac1 value\n\t\t */\n\t\tif (~((unsigned long)bp_info->addr2) >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t} else {\n\t\t/*\n\t\t * For range breakpoints, addr2 must also be a valid address\n\t\t */\n\t\tif (bp_info->addr2 >= TASK_SIZE)\n\t\t\treturn -EIO;\n\t}\n\n\tif (child->thread.debug.dbcr0 &\n\t    (DBCR0_DAC1R | DBCR0_DAC1W | DBCR0_DAC2R | DBCR0_DAC2W))\n\t\treturn -ENOSPC;\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1R | DBCR0_IDM);\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tchild->thread.debug.dbcr0 |= (DBCR0_DAC1W | DBCR0_IDM);\n\tchild->thread.debug.dac1 = bp_info->addr;\n\tchild->thread.debug.dac2 = bp_info->addr2;\n\tif (mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12M;\n\telse if (mode == PPC_BREAKPOINT_MODE_RANGE_EXCLUSIVE)\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MX;\n\telse\t/* PPC_BREAKPOINT_MODE_MASK */\n\t\tchild->thread.debug.dbcr2  |= DBCR2_DAC12MM;\n\tchild->thread.regs->msr |= MSR_DE;\n\n\treturn 5;\n}\n#endif /* CONFIG_PPC_ADV_DEBUG_DAC_RANGE */\n\nstatic long ppc_set_hwdebug(struct task_struct *child,\n\t\t     struct ppc_hw_breakpoint *bp_info)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint len = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n\tstruct perf_event_attr attr;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\tstruct arch_hw_breakpoint brk;\n#endif\n\n\tif (bp_info->version != 1)\n\t\treturn -ENOTSUPP;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t/*\n\t * Check for invalid flags and combinations\n\t */\n\tif ((bp_info->trigger_type == 0) ||\n\t    (bp_info->trigger_type & ~(PPC_BREAKPOINT_TRIGGER_EXECUTE |\n\t\t\t\t       PPC_BREAKPOINT_TRIGGER_RW)) ||\n\t    (bp_info->addr_mode & ~PPC_BREAKPOINT_MODE_MASK) ||\n\t    (bp_info->condition_mode &\n\t     ~(PPC_BREAKPOINT_CONDITION_MODE |\n\t       PPC_BREAKPOINT_CONDITION_BE_ALL)))\n\t\treturn -EINVAL;\n#if CONFIG_PPC_ADV_DEBUG_DVCS == 0\n\tif (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n#endif\n\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_EXECUTE) {\n\t\tif ((bp_info->trigger_type != PPC_BREAKPOINT_TRIGGER_EXECUTE) ||\n\t\t    (bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE))\n\t\t\treturn -EINVAL;\n\t\treturn set_instruction_bp(child, bp_info);\n\t}\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn set_dac(child, bp_info);\n\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\treturn set_dac_range(child, bp_info);\n#else\n\treturn -EINVAL;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n\t/*\n\t * We only support one data breakpoint\n\t */\n\tif ((bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_RW) == 0 ||\n\t    (bp_info->trigger_type & ~PPC_BREAKPOINT_TRIGGER_RW) != 0 ||\n\t    bp_info->condition_mode != PPC_BREAKPOINT_CONDITION_NONE)\n\t\treturn -EINVAL;\n\n\tif ((unsigned long)bp_info->addr >= TASK_SIZE)\n\t\treturn -EIO;\n\n\tbrk.address = bp_info->addr & ~7UL;\n\tbrk.type = HW_BRK_TYPE_TRANSLATE;\n\tbrk.len = 8;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_READ)\n\t\tbrk.type |= HW_BRK_TYPE_READ;\n\tif (bp_info->trigger_type & PPC_BREAKPOINT_TRIGGER_WRITE)\n\t\tbrk.type |= HW_BRK_TYPE_WRITE;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t/*\n\t * Check if the request is for 'range' breakpoints. We can\n\t * support it if range < 8 bytes.\n\t */\n\tif (bp_info->addr_mode == PPC_BREAKPOINT_MODE_RANGE_INCLUSIVE)\n\t\tlen = bp_info->addr2 - bp_info->addr;\n\telse if (bp_info->addr_mode == PPC_BREAKPOINT_MODE_EXACT)\n\t\tlen = 1;\n\telse\n\t\treturn -EINVAL;\n\tbp = thread->ptrace_bps[0];\n\tif (bp)\n\t\treturn -ENOSPC;\n\n\t/* Create a new breakpoint request if one doesn't exist already */\n\thw_breakpoint_init(&attr);\n\tattr.bp_addr = (unsigned long)bp_info->addr & ~HW_BREAKPOINT_ALIGN;\n\tattr.bp_len = len;\n\tarch_bp_generic_fields(brk.type, &attr.bp_type);\n\n\tthread->ptrace_bps[0] = bp = register_user_hw_breakpoint(&attr,\n\t\t\t\t\t       ptrace_triggered, NULL, child);\n\tif (IS_ERR(bp)) {\n\t\tthread->ptrace_bps[0] = NULL;\n\t\treturn PTR_ERR(bp);\n\t}\n\n\treturn 1;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\tif (bp_info->addr_mode != PPC_BREAKPOINT_MODE_EXACT)\n\t\treturn -EINVAL;\n\n\tif (child->thread.hw_brk.address)\n\t\treturn -ENOSPC;\n\n\tchild->thread.hw_brk = brk;\n\n\treturn 1;\n#endif /* !CONFIG_PPC_ADV_DEBUG_DVCS */\n}\n\nstatic long ppc_del_hwdebug(struct task_struct *child, long data)\n{\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tint ret = 0;\n\tstruct thread_struct *thread = &(child->thread);\n\tstruct perf_event *bp;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\tint rc;\n\n\tif (data <= 4)\n\t\trc = del_instruction_bp(child, (int)data);\n\telse\n\t\trc = del_dac(child, (int)data - 4);\n\n\tif (!rc) {\n\t\tif (!DBCR_ACTIVE_EVENTS(child->thread.debug.dbcr0,\n\t\t\t\t\tchild->thread.debug.dbcr1)) {\n\t\t\tchild->thread.debug.dbcr0 &= ~DBCR0_IDM;\n\t\t\tchild->thread.regs->msr &= ~MSR_DE;\n\t\t}\n\t}\n\treturn rc;\n#else\n\tif (data != 1)\n\t\treturn -EINVAL;\n\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\tbp = thread->ptrace_bps[0];\n\tif (bp) {\n\t\tunregister_hw_breakpoint(bp);\n\t\tthread->ptrace_bps[0] = NULL;\n\t} else\n\t\tret = -ENOENT;\n\treturn ret;\n#else /* CONFIG_HAVE_HW_BREAKPOINT */\n\tif (child->thread.hw_brk.address == 0)\n\t\treturn -ENOENT;\n\n\tchild->thread.hw_brk.address = 0;\n\tchild->thread.hw_brk.type = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n\n\treturn 0;\n#endif\n}\n\nlong arch_ptrace(struct task_struct *child, long request,\n\t\t unsigned long addr, unsigned long data)\n{\n\tint ret = -EPERM;\n\tvoid __user *datavp = (void __user *) data;\n\tunsigned long __user *datalp = datavp;\n\n\tswitch (request) {\n\t/* read the word at location addr in the USER area. */\n\tcase PTRACE_PEEKUSR: {\n\t\tunsigned long index, tmp;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_get_reg(child, (int) index, &tmp);\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&tmp, &child->thread.TS_FPR(fpidx),\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\ttmp = child->thread.fp_state.fpscr;\n\t\t}\n\t\tret = put_user(tmp, datalp);\n\t\tbreak;\n\t}\n\n\t/* write the word at location addr in the USER area */\n\tcase PTRACE_POKEUSR: {\n\t\tunsigned long index;\n\n\t\tret = -EIO;\n\t\t/* convert to index and check */\n#ifdef CONFIG_PPC32\n\t\tindex = addr >> 2;\n\t\tif ((addr & 3) || (index > PT_FPSCR)\n\t\t    || (child->thread.regs == NULL))\n#else\n\t\tindex = addr >> 3;\n\t\tif ((addr & 7) || (index > PT_FPSCR))\n#endif\n\t\t\tbreak;\n\n\t\tCHECK_FULL_REGS(child->thread.regs);\n\t\tif (index < PT_FPR0) {\n\t\t\tret = ptrace_put_reg(child, index, data);\n\t\t} else {\n\t\t\tunsigned int fpidx = index - PT_FPR0;\n\n\t\t\tflush_fp_to_thread(child);\n\t\t\tif (fpidx < (PT_FPSCR - PT_FPR0))\n\t\t\t\tmemcpy(&child->thread.TS_FPR(fpidx), &data,\n\t\t\t\t       sizeof(long));\n\t\t\telse\n\t\t\t\tchild->thread.fp_state.fpscr = data;\n\t\t\tret = 0;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_GETHWDBGINFO: {\n\t\tstruct ppc_debug_info dbginfo;\n\n\t\tdbginfo.version = 1;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tdbginfo.num_instruction_bps = CONFIG_PPC_ADV_DEBUG_IACS;\n\t\tdbginfo.num_data_bps = CONFIG_PPC_ADV_DEBUG_DACS;\n\t\tdbginfo.num_condition_regs = CONFIG_PPC_ADV_DEBUG_DVCS;\n\t\tdbginfo.data_bp_alignment = 4;\n\t\tdbginfo.sizeof_condition = 4;\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_INSN_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_INSN_BP_MASK;\n#ifdef CONFIG_PPC_ADV_DEBUG_DAC_RANGE\n\t\tdbginfo.features |=\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_RANGE |\n\t\t\t\t   PPC_DEBUG_FEATURE_DATA_BP_MASK;\n#endif\n#else /* !CONFIG_PPC_ADV_DEBUG_REGS */\n\t\tdbginfo.num_instruction_bps = 0;\n\t\tdbginfo.num_data_bps = 1;\n\t\tdbginfo.num_condition_regs = 0;\n#ifdef CONFIG_PPC64\n\t\tdbginfo.data_bp_alignment = 8;\n#else\n\t\tdbginfo.data_bp_alignment = 4;\n#endif\n\t\tdbginfo.sizeof_condition = 0;\n#ifdef CONFIG_HAVE_HW_BREAKPOINT\n\t\tdbginfo.features = PPC_DEBUG_FEATURE_DATA_BP_RANGE;\n\t\tif (cpu_has_feature(CPU_FTR_DAWR))\n\t\t\tdbginfo.features |= PPC_DEBUG_FEATURE_DATA_BP_DAWR;\n#else\n\t\tdbginfo.features = 0;\n#endif /* CONFIG_HAVE_HW_BREAKPOINT */\n#endif /* CONFIG_PPC_ADV_DEBUG_REGS */\n\n\t\tif (!access_ok(VERIFY_WRITE, datavp,\n\t\t\t       sizeof(struct ppc_debug_info)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_to_user(datavp, &dbginfo,\n\t\t\t\t     sizeof(struct ppc_debug_info)) ?\n\t\t      -EFAULT : 0;\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_SETHWDEBUG: {\n\t\tstruct ppc_hw_breakpoint bp_info;\n\n\t\tif (!access_ok(VERIFY_READ, datavp,\n\t\t\t       sizeof(struct ppc_hw_breakpoint)))\n\t\t\treturn -EFAULT;\n\t\tret = __copy_from_user(&bp_info, datavp,\n\t\t\t\t       sizeof(struct ppc_hw_breakpoint)) ?\n\t\t      -EFAULT : 0;\n\t\tif (!ret)\n\t\t\tret = ppc_set_hwdebug(child, &bp_info);\n\t\tbreak;\n\t}\n\n\tcase PPC_PTRACE_DELHWDEBUG: {\n\t\tret = ppc_del_hwdebug(child, data);\n\t\tbreak;\n\t}\n\n\tcase PTRACE_GET_DEBUGREG: {\n#ifndef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tunsigned long dabr_fake;\n#endif\n\t\tret = -EINVAL;\n\t\t/* We only support one DABR and no IABRS at the moment */\n\t\tif (addr > 0)\n\t\t\tbreak;\n#ifdef CONFIG_PPC_ADV_DEBUG_REGS\n\t\tret = put_user(child->thread.debug.dac1, datalp);\n#else\n\t\tdabr_fake = ((child->thread.hw_brk.address & (~HW_BRK_TYPE_DABR)) |\n\t\t\t     (child->thread.hw_brk.type & HW_BRK_TYPE_DABR));\n\t\tret = put_user(dabr_fake, datalp);\n#endif\n\t\tbreak;\n\t}\n\n\tcase PTRACE_SET_DEBUGREG:\n\t\tret = ptrace_set_debugreg(child, addr, data);\n\t\tbreak;\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_GETREGS64:\n#endif\n\tcase PTRACE_GETREGS:\t/* Get all pt_regs from the child. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_GPR,\n\t\t\t\t\t   0, sizeof(struct pt_regs),\n\t\t\t\t\t   datavp);\n\n#ifdef CONFIG_PPC64\n\tcase PTRACE_SETREGS64:\n#endif\n\tcase PTRACE_SETREGS:\t/* Set all gp regs in the child. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_GPR,\n\t\t\t\t\t     0, sizeof(struct pt_regs),\n\t\t\t\t\t     datavp);\n\n\tcase PTRACE_GETFPREGS: /* Get the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_FPR,\n\t\t\t\t\t   0, sizeof(elf_fpregset_t),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETFPREGS: /* Set the child FPU state (FPR0...31 + FPSCR) */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_FPR,\n\t\t\t\t\t     0, sizeof(elf_fpregset_t),\n\t\t\t\t\t     datavp);\n\n#ifdef CONFIG_ALTIVEC\n\tcase PTRACE_GETVRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VMX,\n\t\t\t\t\t   0, (33 * sizeof(vector128) +\n\t\t\t\t\t       sizeof(u32)),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VMX,\n\t\t\t\t\t     0, (33 * sizeof(vector128) +\n\t\t\t\t\t\t sizeof(u32)),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_VSX\n\tcase PTRACE_GETVSRREGS:\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_VSX,\n\t\t\t\t\t   0, 32 * sizeof(double),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETVSRREGS:\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_VSX,\n\t\t\t\t\t     0, 32 * sizeof(double),\n\t\t\t\t\t     datavp);\n#endif\n#ifdef CONFIG_SPE\n\tcase PTRACE_GETEVRREGS:\n\t\t/* Get the child spe register state. */\n\t\treturn copy_regset_to_user(child, &user_ppc_native_view,\n\t\t\t\t\t   REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t   datavp);\n\n\tcase PTRACE_SETEVRREGS:\n\t\t/* Set the child spe register state. */\n\t\treturn copy_regset_from_user(child, &user_ppc_native_view,\n\t\t\t\t\t     REGSET_SPE, 0, 35 * sizeof(u32),\n\t\t\t\t\t     datavp);\n#endif\n\n\tdefault:\n\t\tret = ptrace_request(child, request, addr, data);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n#ifdef CONFIG_SECCOMP\nstatic int do_seccomp(struct pt_regs *regs)\n{\n\tif (!test_thread_flag(TIF_SECCOMP))\n\t\treturn 0;\n\n\t/*\n\t * The ABI we present to seccomp tracers is that r3 contains\n\t * the syscall return value and orig_gpr3 contains the first\n\t * syscall parameter. This is different to the ptrace ABI where\n\t * both r3 and orig_gpr3 contain the first syscall parameter.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\n\t/*\n\t * We use the __ version here because we have already checked\n\t * TIF_SECCOMP. If this fails, there is nothing left to do, we\n\t * have already loaded -ENOSYS into r3, or seccomp has put\n\t * something else in r3 (via SECCOMP_RET_ERRNO/TRACE).\n\t */\n\tif (__secure_computing(NULL))\n\t\treturn -1;\n\n\t/*\n\t * The syscall was allowed by seccomp, restore the register\n\t * state to what audit expects.\n\t * Note that we use orig_gpr3, which means a seccomp tracer can\n\t * modify the first syscall parameter (in orig_gpr3) and also\n\t * allow the syscall to proceed.\n\t */\n\tregs->gpr[3] = regs->orig_gpr3;\n\n\treturn 0;\n}\n#else\nstatic inline int do_seccomp(struct pt_regs *regs) { return 0; }\n#endif /* CONFIG_SECCOMP */\n\n/**\n * do_syscall_trace_enter() - Do syscall tracing on kernel entry.\n * @regs: the pt_regs of the task to trace (current)\n *\n * Performs various types of tracing on syscall entry. This includes seccomp,\n * ptrace, syscall tracepoints and audit.\n *\n * The pt_regs are potentially visible to userspace via ptrace, so their\n * contents is ABI.\n *\n * One or more of the tracers may modify the contents of pt_regs, in particular\n * to modify arguments or even the syscall number itself.\n *\n * It's also possible that a tracer can choose to reject the system call. In\n * that case this function will return an illegal syscall number, and will put\n * an appropriate return value in regs->r3.\n *\n * Return: the (possibly changed) syscall number.\n */\nlong do_syscall_trace_enter(struct pt_regs *regs)\n{\n\tuser_exit();\n\n\t/*\n\t * The tracer may decide to abort the syscall, if so tracehook\n\t * will return !0. Note that the tracer may also just change\n\t * regs->gpr[0] to an invalid syscall number, that is handled\n\t * below on the exit path.\n\t */\n\tif (test_thread_flag(TIF_SYSCALL_TRACE) &&\n\t    tracehook_report_syscall_entry(regs))\n\t\tgoto skip;\n\n\t/* Run seccomp after ptrace; allow it to set gpr[3]. */\n\tif (do_seccomp(regs))\n\t\treturn -1;\n\n\t/* Avoid trace and audit when syscall is invalid. */\n\tif (regs->gpr[0] >= NR_syscalls)\n\t\tgoto skip;\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_enter(regs, regs->gpr[0]);\n\n#ifdef CONFIG_PPC64\n\tif (!is_32bit_task())\n\t\taudit_syscall_entry(regs->gpr[0], regs->gpr[3], regs->gpr[4],\n\t\t\t\t    regs->gpr[5], regs->gpr[6]);\n\telse\n#endif\n\t\taudit_syscall_entry(regs->gpr[0],\n\t\t\t\t    regs->gpr[3] & 0xffffffff,\n\t\t\t\t    regs->gpr[4] & 0xffffffff,\n\t\t\t\t    regs->gpr[5] & 0xffffffff,\n\t\t\t\t    regs->gpr[6] & 0xffffffff);\n\n\t/* Return the possibly modified but valid syscall number */\n\treturn regs->gpr[0];\n\nskip:\n\t/*\n\t * If we are aborting explicitly, or if the syscall number is\n\t * now invalid, set the return value to -ENOSYS.\n\t */\n\tregs->gpr[3] = -ENOSYS;\n\treturn -1;\n}\n\nvoid do_syscall_trace_leave(struct pt_regs *regs)\n{\n\tint step;\n\n\taudit_syscall_exit(regs);\n\n\tif (unlikely(test_thread_flag(TIF_SYSCALL_TRACEPOINT)))\n\t\ttrace_sys_exit(regs, regs->result);\n\n\tstep = test_thread_flag(TIF_SINGLESTEP);\n\tif (step || test_thread_flag(TIF_SYSCALL_TRACE))\n\t\ttracehook_report_syscall_exit(regs, step);\n\n\tuser_enter();\n}\n"], "filenames": ["arch/powerpc/kernel/ptrace.c"], "buggy_code_start_loc": [134], "buggy_code_end_loc": [135], "fixing_code_start_loc": [134], "fixing_code_end_loc": [135], "type": "CWE-119", "message": "In the flush_tmregs_to_thread function in arch/powerpc/kernel/ptrace.c in the Linux kernel before 4.13.5, a guest kernel crash can be triggered from unprivileged userspace during a core dump on a POWER host due to a missing processor feature check and an erroneous use of transactional memory (TM) instructions in the core dump path, leading to a denial of service.", "other": {"cve": {"id": "CVE-2018-1091", "sourceIdentifier": "secalert@redhat.com", "published": "2018-03-27T21:29:00.720", "lastModified": "2018-05-10T01:29:05.627", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In the flush_tmregs_to_thread function in arch/powerpc/kernel/ptrace.c in the Linux kernel before 4.13.5, a guest kernel crash can be triggered from unprivileged userspace during a core dump on a POWER host due to a missing processor feature check and an erroneous use of transactional memory (TM) instructions in the core dump path, leading to a denial of service."}, {"lang": "es", "value": "En la funci\u00f3n flush_tmregs_to_thread en arch/powerpc/kernel/ptrace.c en el kernel de Linux, en versiones anteriores a la 4.13.5, se puede desencadenar un cierre inesperado del kernel invitado desde un espacio de usuario sin privilegios durante un volcado de memoria en un host POWER. Esto se debe a la falta de verificaci\u00f3n de la funcionalidad del procesador y un uso err\u00f3neo de las instrucciones de la memoria transaccional (TM) en la ruta de volcado de memoria, lo que da lugar a una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-391"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.13.4", "matchCriteriaId": "928AB8DD-8573-4425-803D-1B164491BF77"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=c1fa0768a8713b135848f78fd43ffc208d8ded70", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "http://openwall.com/lists/oss-security/2018/03/27/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2018:1318", "source": "secalert@redhat.com"}, {"url": "https://access.redhat.com/security/cve/cve-2018-1091", "source": "secalert@redhat.com", "tags": ["Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1558149", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/c1fa0768a8713b135848f78fd43ffc208d8ded70", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://marc.info/?l=linuxppc-embedded&m=150535531910494&w=2", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.13.5", "source": "secalert@redhat.com", "tags": ["Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/c1fa0768a8713b135848f78fd43ffc208d8ded70"}}