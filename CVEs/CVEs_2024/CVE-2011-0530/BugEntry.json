{"buggy_code": ["/*\n * Network Block Device - server\n *\n * Copyright 1996-1998 Pavel Machek, distribute under GPL\n *  <pavel@atrey.karlin.mff.cuni.cz>\n * Copyright 2001-2004 Wouter Verhelst <wouter@debian.org>\n * Copyright 2002 Anton Altaparmakov <aia21@cam.ac.uk>\n *\n * Version 1.0 - hopefully 64-bit-clean\n * Version 1.1 - merging enhancements from Josh Parsons, <josh@coombs.anu.edu.au>\n * Version 1.2 - autodetect size of block devices, thanx to Peter T. Breuer\" <ptb@it.uc3m.es>\n * Version 1.5 - can compile on Unix systems that don't have 64 bit integer\n *\ttype, or don't have 64 bit file offsets by defining FS_32BIT\n *\tin compile options for nbd-server *only*. This can be done\n *\twith make FSCHOICE=-DFS_32BIT nbd-server. (I don't have the\n *\toriginal autoconf input file, or I would make it a configure\n *\toption.) Ken Yap <ken@nlc.net.au>.\n * Version 1.6 - fix autodetection of block device size and really make 64 bit\n * \tclean on 32 bit machines. Anton Altaparmakov <aia21@cam.ac.uk>\n * Version 2.0 - Version synchronised with client\n * Version 2.1 - Reap zombie client processes when they exit. Removed\n * \t(uncommented) the _IO magic, it's no longer necessary. Wouter\n * \tVerhelst <wouter@debian.org>\n * Version 2.2 - Auto switch to read-only mode (usefull for floppies).\n * Version 2.3 - Fixed code so that Large File Support works. This\n *\tremoves the FS_32BIT compile-time directive; define\n *\t_FILE_OFFSET_BITS=64 and _LARGEFILE_SOURCE if you used to be\n *\tusing FS_32BIT. This will allow you to use files >2GB instead of\n *\thaving to use the -m option. Wouter Verhelst <wouter@debian.org>\n * Version 2.4 - Added code to keep track of children, so that we can\n * \tproperly kill them from initscripts. Add a call to daemon(),\n * \tso that processes don't think they have to wait for us, which is\n * \tinteresting for initscripts as well. Wouter Verhelst\n * \t<wouter@debian.org>\n * Version 2.5 - Bugfix release: forgot to reset child_arraysize to\n *      zero after fork()ing, resulting in nbd-server going berserk\n *      when it receives a signal with at least one child open. Wouter\n *      Verhelst <wouter@debian.org>\n * 10/10/2003 - Added socket option SO_KEEPALIVE (sf.net bug 819235);\n * \trectified type of mainloop::size_host (sf.net bugs 814435 and\n * \t817385); close the PID file after writing to it, so that the\n * \tdaemon can actually be found. Wouter Verhelst\n * \t<wouter@debian.org>\n * 10/10/2003 - Size of the data \"size_host\" was wrong and so was not\n *  \tcorrectly put in network endianness. Many types were corrected\n *  \t(size_t and off_t instead of int).  <vspaceg@sourceforge.net>\n * Version 2.6 - Some code cleanup.\n * Version 2.7 - Better build system.\n * 11/02/2004 - Doxygenified the source, modularized it a bit. Needs a \n * \tlot more work, but this is a start. Wouter Verhelst\n * \t<wouter@debian.org>\n * 16/03/2010 - Add IPv6 support.\n *\tKitt Tientanopajai <kitt@kitty.in.th>\n *\tNeutron Soutmun <neo.neutron@gmail.com>\n *\tSuriya Soutmun <darksolar@gmail.com>\n */\n\n/* Includes LFS defines, which defines behaviours of some of the following\n * headers, so must come before those */\n#include \"lfs.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/select.h>\t\t/* select */\n#include <sys/wait.h>\t\t/* wait */\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n#include <sys/param.h>\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\t\t/* For BLKGETSIZE */\n#endif\n#include <signal.h>\t\t/* sigaction */\n#include <errno.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <arpa/inet.h>\n#include <strings.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <grp.h>\n\n#include <glib.h>\n\n/* used in cliserv.h, so must come first */\n#define MY_NAME \"nbd_server\"\n#include \"cliserv.h\"\n\n#ifdef WITH_SDP\n#include <sdp_inet.h>\n#endif\n\n/** Default position of the config file */\n#ifndef SYSCONFDIR\n#define SYSCONFDIR \"/etc\"\n#endif\n#define CFILE SYSCONFDIR \"/nbd-server/config\"\n\n/** Where our config file actually is */\ngchar* config_file_pos;\n\n/** What user we're running as */\ngchar* runuser=NULL;\n/** What group we're running as */\ngchar* rungroup=NULL;\n/** whether to export using the old negotiation protocol (port-based) */\ngboolean do_oldstyle=FALSE;\n\n/** Logging macros, now nothing goes to syslog unless you say ISSERVER */\n#ifdef ISSERVER\n#define msg2(a,b) syslog(a,b)\n#define msg3(a,b,c) syslog(a,b,c)\n#define msg4(a,b,c,d) syslog(a,b,c,d)\n#else\n#define msg2(a,b) g_message(b)\n#define msg3(a,b,c) g_message(b,c)\n#define msg4(a,b,c,d) g_message(b,c,d)\n#endif\n\n/* Debugging macros */\n//#define DODBG\n#ifdef DODBG\n#define DEBUG( a ) printf( a )\n#define DEBUG2( a,b ) printf( a,b )\n#define DEBUG3( a,b,c ) printf( a,b,c )\n#define DEBUG4( a,b,c,d ) printf( a,b,c,d )\n#else\n#define DEBUG( a )\n#define DEBUG2( a,b ) \n#define DEBUG3( a,b,c ) \n#define DEBUG4( a,b,c,d ) \n#endif\n#ifndef PACKAGE_VERSION\n#define PACKAGE_VERSION \"\"\n#endif\n/**\n * The highest value a variable of type off_t can reach. This is a signed\n * integer, so set all bits except for the leftmost one.\n **/\n#define OFFT_MAX ~((off_t)1<<(sizeof(off_t)*8-1))\n#define LINELEN 256\t  /**< Size of static buffer used to read the\n\t\t\t       authorization file (yuck) */\n#define BUFSIZE (1024*1024) /**< Size of buffer that can hold requests */\n#define DIFFPAGESIZE 4096 /**< diff file uses those chunks */\n#define F_READONLY 1      /**< flag to tell us a file is readonly */\n#define F_MULTIFILE 2\t  /**< flag to tell us a file is exported using -m */\n#define F_COPYONWRITE 4\t  /**< flag to tell us a file is exported using\n\t\t\t    copyonwrite */\n#define F_AUTOREADONLY 8  /**< flag to tell us a file is set to autoreadonly */\n#define F_SPARSE 16\t  /**< flag to tell us copyronwrite should use a sparse file */\n#define F_SDP 32\t  /**< flag to tell us the export should be done using the Socket Direct Protocol for RDMA */\n#define F_SYNC 64\t  /**< Whether to fsync() after a write */\nGHashTable *children;\nchar pidfname[256]; /**< name of our PID file */\nchar pidftemplate[256]; /**< template to be used for the filename of the PID file */\nchar default_authname[] = SYSCONFDIR \"/nbd-server/allow\"; /**< default name of allow file */\n\nint modernsock=0;\t  /**< Socket for the modern handler. Not used\n\t\t\t       if a client was only specified on the\n\t\t\t       command line; only port used if\n\t\t\t       oldstyle is set to false (and then the\n\t\t\t       command-line client isn't used, gna gna) */\nchar* modern_listen;\t  /**< listenaddr value for modernsock */\n\n/**\n * Types of virtuatlization\n **/\ntypedef enum {\n\tVIRT_NONE=0,\t/**< No virtualization */\n\tVIRT_IPLIT,\t/**< Literal IP address as part of the filename */\n\tVIRT_IPHASH,\t/**< Replacing all dots in an ip address by a / before\n\t\t\t     doing the same as in IPLIT */\n\tVIRT_CIDR,\t/**< Every subnet in its own directory */\n} VIRT_STYLE;\n\n/**\n * Variables associated with a server.\n **/\ntypedef struct {\n\tgchar* exportname;    /**< (unprocessed) filename of the file we're exporting */\n\toff_t expected_size; /**< size of the exported file as it was told to\n\t\t\t       us through configuration */\n\tgchar* listenaddr;   /**< The IP address we're listening on */\n\tunsigned int port;   /**< port we're exporting this file at */\n\tchar* authname;      /**< filename of the authorization file */\n\tint flags;           /**< flags associated with this exported file */\n\tint socket;\t     /**< The socket of this server. */\n\tint socket_family;   /**< family of the socket */\n\tVIRT_STYLE virtstyle;/**< The style of virtualization, if any */\n\tuint8_t cidrlen;     /**< The length of the mask when we use\n\t\t\t\t  CIDR-style virtualization */\n\tgchar* prerun;\t     /**< command to be ran after connecting a client,\n\t\t\t\t  but before starting to serve */\n\tgchar* postrun;\t     /**< command that will be ran after the client\n\t\t\t\t  disconnects */\n\tgchar* servename;    /**< name of the export as selected by nbd-client */\n\tint max_connections; /**< maximum number of opened connections */\n} SERVER;\n\n/**\n * Variables associated with a client socket.\n **/\ntypedef struct {\n\tint fhandle;      /**< file descriptor */\n\toff_t startoff;   /**< starting offset of this file */\n} FILE_INFO;\n\ntypedef struct {\n\toff_t exportsize;    /**< size of the file we're exporting */\n\tchar *clientname;    /**< peer */\n\tchar *exportname;    /**< (processed) filename of the file we're exporting */\n\tGArray *export;    /**< array of FILE_INFO of exported files;\n\t\t\t       array size is always 1 unless we're\n\t\t\t       doing the multiple file option */\n\tint net;\t     /**< The actual client socket */\n\tSERVER *server;\t     /**< The server this client is getting data from */\n\tchar* difffilename;  /**< filename of the copy-on-write file, if any */\n\tint difffile;\t     /**< filedescriptor of copyonwrite file. @todo\n\t\t\t       shouldn't this be an array too? (cfr export) Or\n\t\t\t       make -m and -c mutually exclusive */\n\tu32 difffilelen;     /**< number of pages in difffile */\n\tu32 *difmap;\t     /**< see comment on the global difmap for this one */\n\tgboolean modern;     /**< client was negotiated using modern negotiation protocol */\n} CLIENT;\n\n/**\n * Type of configuration file values\n **/\ntypedef enum {\n\tPARAM_INT,\t\t/**< This parameter is an integer */\n\tPARAM_STRING,\t\t/**< This parameter is a string */\n\tPARAM_BOOL,\t\t/**< This parameter is a boolean */\n} PARAM_TYPE;\n\n/**\n * Configuration file values\n **/\ntypedef struct {\n\tgchar *paramname;\t/**< Name of the parameter, as it appears in\n\t\t\t\t  the config file */\n\tgboolean required;\t/**< Whether this is a required (as opposed to\n\t\t\t\t  optional) parameter */\n\tPARAM_TYPE ptype;\t/**< Type of the parameter. */\n\tgpointer target;\t/**< Pointer to where the data of this\n\t\t\t\t  parameter should be written. If ptype is\n\t\t\t\t  PARAM_BOOL, the data is or'ed rather than\n\t\t\t\t  overwritten. */\n\tgint flagval;\t\t/**< Flag mask for this parameter in case ptype\n\t\t\t\t  is PARAM_BOOL. */\n} PARAM;\n\n/**\n * Check whether a client is allowed to connect. Works with an authorization\n * file which contains one line per machine, no wildcards.\n *\n * @param opts The client who's trying to connect.\n * @return 0 - authorization refused, 1 - OK\n **/\nint authorized_client(CLIENT *opts) {\n\tconst char *ERRMSG=\"Invalid entry '%s' in authfile '%s', so, refusing all connections.\";\n\tFILE *f ;\n\tchar line[LINELEN]; \n\tchar *tmp;\n\tstruct in_addr addr;\n\tstruct in_addr client;\n\tstruct in_addr cltemp;\n\tint len;\n\n\tif ((f=fopen(opts->server->authname,\"r\"))==NULL) {\n\t\tmsg4(LOG_INFO,\"Can't open authorization file %s (%s).\",\n\t\t     opts->server->authname,strerror(errno)) ;\n\t\treturn 1 ; \n\t}\n  \n  \tinet_aton(opts->clientname, &client);\n\twhile (fgets(line,LINELEN,f)!=NULL) {\n\t\tif((tmp=index(line, '/'))) {\n\t\t\tif(strlen(line)<=tmp-line) {\n\t\t\t\tmsg4(LOG_CRIT, ERRMSG, line, opts->server->authname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*(tmp++)=0;\n\t\t\tif(!inet_aton(line,&addr)) {\n\t\t\t\tmsg4(LOG_CRIT, ERRMSG, line, opts->server->authname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlen=strtol(tmp, NULL, 0);\n\t\t\taddr.s_addr>>=32-len;\n\t\t\taddr.s_addr<<=32-len;\n\t\t\tmemcpy(&cltemp,&client,sizeof(client));\n\t\t\tcltemp.s_addr>>=32-len;\n\t\t\tcltemp.s_addr<<=32-len;\n\t\t\tif(addr.s_addr == cltemp.s_addr) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (strncmp(line,opts->clientname,strlen(opts->clientname))==0) {\n\t\t\tfclose(f);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}\n\n/**\n * Read data from a file descriptor into a buffer\n *\n * @param f a file descriptor\n * @param buf a buffer\n * @param len the number of bytes to be read\n **/\ninline void readit(int f, void *buf, size_t len) {\n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"*\");\n\t\tif ((res = read(f, buf, len)) <= 0) {\n\t\t\tif(errno != EAGAIN) {\n\t\t\t\terr(\"Read failed: %m\");\n\t\t\t}\n\t\t} else {\n\t\t\tlen -= res;\n\t\t\tbuf += res;\n\t\t}\n\t}\n}\n\n/**\n * Write data from a buffer into a filedescriptor\n *\n * @param f a file descriptor\n * @param buf a buffer containing data\n * @param len the number of bytes to be written\n **/\ninline void writeit(int f, void *buf, size_t len) {\n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"+\");\n\t\tif ((res = write(f, buf, len)) <= 0)\n\t\t\terr(\"Send failed: %m\");\n\t\tlen -= res;\n\t\tbuf += res;\n\t}\n}\n\n/**\n * Print out a message about how to use nbd-server. Split out to a separate\n * function so that we can call it from multiple places\n */\nvoid usage() {\n\tprintf(\"This is nbd-server version \" VERSION \"\\n\");\n\tprintf(\"Usage: [ip:|ip6@]port file_to_export [size][kKmM] [-l authorize_file] [-r] [-m] [-c] [-C configuration file] [-p PID file name] [-o section name] [-M max connections]\\n\"\n\t       \"\\t-r|--read-only\\t\\tread only\\n\"\n\t       \"\\t-m|--multi-file\\t\\tmultiple file\\n\"\n\t       \"\\t-c|--copy-on-write\\tcopy on write\\n\"\n\t       \"\\t-C|--config-file\\tspecify an alternate configuration file\\n\"\n\t       \"\\t-l|--authorize-file\\tfile with list of hosts that are allowed to\\n\\t\\t\\t\\tconnect.\\n\"\n\t       \"\\t-p|--pid-file\\t\\tspecify a filename to write our PID to\\n\"\n\t       \"\\t-o|--output-config\\toutput a config file section for what you\\n\\t\\t\\t\\tspecified on the command line, with the\\n\\t\\t\\t\\tspecified section name\\n\"\n\t       \"\\t-M|--max-connections\\tspecify the maximum number of opened connections\\n\\n\"\n\t       \"\\tif port is set to 0, stdin is used (for running from inetd)\\n\"\n\t       \"\\tif file_to_export contains '%%s', it is substituted with the IP\\n\"\n\t       \"\\t\\taddress of the machine trying to connect\\n\" \n\t       \"\\tif ip is set, it contains the local IP address on which we're listening.\\n\\tif not, the server will listen on all local IP addresses\\n\");\n\tprintf(\"Using configuration file %s\\n\", CFILE);\n}\n\n/* Dumps a config file section of the given SERVER*, and exits. */\nvoid dump_section(SERVER* serve, gchar* section_header) {\n\tprintf(\"[%s]\\n\", section_header);\n\tprintf(\"\\texportname = %s\\n\", serve->exportname);\n\tprintf(\"\\tlistenaddr = %s\\n\", serve->listenaddr);\n\tprintf(\"\\tport = %d\\n\", serve->port);\n\tif(serve->flags & F_READONLY) {\n\t\tprintf(\"\\treadonly = true\\n\");\n\t}\n\tif(serve->flags & F_MULTIFILE) {\n\t\tprintf(\"\\tmultifile = true\\n\");\n\t}\n\tif(serve->flags & F_COPYONWRITE) {\n\t\tprintf(\"\\tcopyonwrite = true\\n\");\n\t}\n\tif(serve->expected_size) {\n\t\tprintf(\"\\tfilesize = %lld\\n\", (long long int)serve->expected_size);\n\t}\n\tif(serve->authname) {\n\t\tprintf(\"\\tauthfile = %s\\n\", serve->authname);\n\t}\n\texit(EXIT_SUCCESS);\n}\n\n/**\n * Parse the command line.\n *\n * @param argc the argc argument to main()\n * @param argv the argv argument to main()\n **/\nSERVER* cmdline(int argc, char *argv[]) {\n\tint i=0;\n\tint nonspecial=0;\n\tint c;\n\tstruct option long_options[] = {\n\t\t{\"read-only\", no_argument, NULL, 'r'},\n\t\t{\"multi-file\", no_argument, NULL, 'm'},\n\t\t{\"copy-on-write\", no_argument, NULL, 'c'},\n\t\t{\"authorize-file\", required_argument, NULL, 'l'},\n\t\t{\"config-file\", required_argument, NULL, 'C'},\n\t\t{\"pid-file\", required_argument, NULL, 'p'},\n\t\t{\"output-config\", required_argument, NULL, 'o'},\n\t\t{\"max-connection\", required_argument, NULL, 'M'},\n\t\t{0,0,0,0}\n\t};\n\tSERVER *serve;\n\toff_t es;\n\tsize_t last;\n\tchar suffix;\n\tgboolean do_output=FALSE;\n\tgchar* section_header=\"\";\n\tgchar** addr_port;\n\n\tif(argc==1) {\n\t\treturn NULL;\n\t}\n\tserve=g_new0(SERVER, 1);\n\tserve->authname = g_strdup(default_authname);\n\tserve->virtstyle=VIRT_IPLIT;\n\twhile((c=getopt_long(argc, argv, \"-C:cl:mo:rp:M:\", long_options, &i))>=0) {\n\t\tswitch (c) {\n\t\tcase 1:\n\t\t\t/* non-option argument */\n\t\t\tswitch(nonspecial++) {\n\t\t\tcase 0:\n\t\t\t\tif(strchr(optarg, ':') == strrchr(optarg, ':')) {\n\t\t\t\t\taddr_port=g_strsplit(optarg, \":\", 2);\n\n\t\t\t\t\t/* Check for \"@\" - maybe user using this separator\n\t\t\t\t\t\t for IPv4 address */\n\t\t\t\t\tif(!addr_port[1]) {\n\t\t\t\t\t\tg_strfreev(addr_port);\n\t\t\t\t\t\taddr_port=g_strsplit(optarg, \"@\", 2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddr_port=g_strsplit(optarg, \"@\", 2);\n\t\t\t\t}\n\n\t\t\t\tif(addr_port[1]) {\n\t\t\t\t\tserve->port=strtol(addr_port[1], NULL, 0);\n\t\t\t\t\tserve->listenaddr=g_strdup(addr_port[0]);\n\t\t\t\t} else {\n\t\t\t\t\tserve->listenaddr=NULL;\n\t\t\t\t\tserve->port=strtol(addr_port[0], NULL, 0);\n\t\t\t\t}\n\t\t\t\tg_strfreev(addr_port);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tserve->exportname = g_strdup(optarg);\n\t\t\t\tif(serve->exportname[0] != '/') {\n\t\t\t\t\tfprintf(stderr, \"E: The to be exported file needs to be an absolute filename!\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlast=strlen(optarg)-1;\n\t\t\t\tsuffix=optarg[last];\n\t\t\t\tif (suffix == 'k' || suffix == 'K' ||\n\t\t\t\t    suffix == 'm' || suffix == 'M')\n\t\t\t\t\toptarg[last] = '\\0';\n\t\t\t\tes = (off_t)atoll(optarg);\n\t\t\t\tswitch (suffix) {\n\t\t\t\t\tcase 'm':\n\t\t\t\t\tcase 'M':  es <<= 10;\n\t\t\t\t\tcase 'k':\n\t\t\t\t\tcase 'K':  es <<= 10;\n\t\t\t\t\tdefault :  break;\n\t\t\t\t}\n\t\t\t\tserve->expected_size = es;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tserve->flags |= F_READONLY;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tserve->flags |= F_MULTIFILE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdo_output = TRUE;\n\t\t\tsection_header = g_strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tstrncpy(pidftemplate, optarg, 256);\n\t\t\tbreak;\n\t\tcase 'c': \n\t\t\tserve->flags |=F_COPYONWRITE;\n\t\t        break;\n\t\tcase 'C':\n\t\t\tg_free(config_file_pos);\n\t\t\tconfig_file_pos=g_strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tg_free(serve->authname);\n\t\t\tserve->authname=g_strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tserve->max_connections = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* What's left: the port to export, the name of the to be exported\n\t * file, and, optionally, the size of the file, in that order. */\n\tif(nonspecial<2) {\n\t\tg_free(serve);\n\t\tserve=NULL;\n\t} else {\n\t\tdo_oldstyle = TRUE;\n\t}\n\tif(do_output) {\n\t\tif(!serve) {\n\t\t\tg_critical(\"Need a complete configuration on the command line to output a config file section!\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tdump_section(serve, section_header);\n\t}\n\treturn serve;\n}\n\n/**\n * Error codes for config file parsing\n **/\ntypedef enum {\n\tCFILE_NOTFOUND,\t\t/**< The configuration file is not found */\n\tCFILE_MISSING_GENERIC,\t/**< The (required) group \"generic\" is missing */\n\tCFILE_KEY_MISSING,\t/**< A (required) key is missing */\n\tCFILE_VALUE_INVALID,\t/**< A value is syntactically invalid */\n\tCFILE_VALUE_UNSUPPORTED,/**< A value is not supported in this build */\n\tCFILE_PROGERR,\t\t/**< Programmer error */\n\tCFILE_NO_EXPORTS,\t/**< A config file was specified that does not\n\t\t\t\t     define any exports */\n\tCFILE_INCORRECT_PORT,\t/**< The reserved port was specified for an\n\t\t\t\t     old-style export. */\n} CFILE_ERRORS;\n\n/**\n * Remove a SERVER from memory. Used from the hash table\n **/\nvoid remove_server(gpointer s) {\n\tSERVER *server;\n\n\tserver=(SERVER*)s;\n\tg_free(server->exportname);\n\tif(server->authname)\n\t\tg_free(server->authname);\n\tif(server->listenaddr)\n\t\tg_free(server->listenaddr);\n\tif(server->prerun)\n\t\tg_free(server->prerun);\n\tif(server->postrun)\n\t\tg_free(server->postrun);\n\tg_free(server);\n}\n\n/**\n * duplicate server\n * @param s the old server we want to duplicate\n * @return new duplicated server\n **/\nSERVER* dup_serve(SERVER *s) {\n\tSERVER *serve = NULL;\n\n\tserve=g_new0(SERVER, 1);\n\tif(serve == NULL)\n\t\treturn NULL;\n\n\tif(s->exportname)\n\t\tserve->exportname = g_strdup(s->exportname);\n\n\tserve->expected_size = s->expected_size;\n\n\tif(s->listenaddr)\n\t\tserve->listenaddr = g_strdup(s->listenaddr);\n\n\tserve->port = s->port;\n\n\tif(s->authname)\n\t\tserve->authname = strdup(s->authname);\n\n\tserve->flags = s->flags;\n\tserve->socket = serve->socket;\n\tserve->socket_family = serve->socket_family;\n\tserve->cidrlen = s->cidrlen;\n\n\tif(s->prerun)\n\t\tserve->prerun = g_strdup(s->prerun);\n\n\tif(s->postrun)\n\t\tserve->postrun = g_strdup(s->postrun);\n\t\n\tif(s->servename)\n\t\tserve->servename = g_strdup(s->servename);\n\n\tserve->max_connections = s->max_connections;\n\n\treturn serve;\n}\n\n/**\n * append new server to array\n * @param s server\n * @param a server array\n * @return 0 success, -1 error\n */\nint append_serve(SERVER *s, GArray *a) {\n\tSERVER *ns = NULL;\n\tstruct addrinfo hints;\n\tstruct addrinfo *ai = NULL;\n\tstruct addrinfo *rp = NULL;\n\tchar   host[NI_MAXHOST];\n\tgchar  *port = NULL;\n\tint e;\n\tint ret;\n\n\tif(!s) {\n\t\terr(\"Invalid parsing server\");\n\t\treturn -1;\n\t}\n\n\tport = g_strdup_printf(\"%d\", s->port);\n\n\tmemset(&hints,'\\0',sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_ADDRCONFIG | AI_PASSIVE;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\te = getaddrinfo(s->listenaddr, port, &hints, &ai);\n\n\tif (port)\n\t\tg_free(port);\n\n\tif(e == 0) {\n\t\tfor (rp = ai; rp != NULL; rp = rp->ai_next) {\n\t\t\te = getnameinfo(rp->ai_addr, rp->ai_addrlen, host, sizeof(host), NULL, 0, NI_NUMERICHOST);\n\n\t\t\tif (e != 0) { // error\n\t\t\t\tfprintf(stderr, \"getnameinfo: %s\\n\", gai_strerror(e));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// duplicate server and set listenaddr to resolved IP address\n\t\t\tns = dup_serve (s);\n\t\t\tif (ns) {\n\t\t\t\tns->listenaddr = g_strdup(host);\n\t\t\t\tns->socket_family = rp->ai_family;\n\t\t\t\tg_array_append_val(a, *ns);\n\t\t\t\tfree(ns);\n\t\t\t\tns = NULL;\n\t\t\t}\n\t\t}\n\n\t\tret = 0;\n\t} else {\n\t\tfprintf(stderr, \"getaddrinfo failed on listen host/address: %s (%s)\\n\", s->listenaddr ? s->listenaddr : \"any\", gai_strerror(e));\n\t\tret = -1;\n\t}\n\n\tif (ai)\n\t\tfreeaddrinfo(ai);\n\n\treturn ret;\n}\n\n/**\n * Parse the config file.\n *\n * @param f the name of the config file\n * @param e a GError. @see CFILE_ERRORS for what error values this function can\n * \treturn.\n * @return a Array of SERVER* pointers, If the config file is empty or does not\n *\texist, returns an empty GHashTable; if the config file contains an\n *\terror, returns NULL, and e is set appropriately\n **/\nGArray* parse_cfile(gchar* f, GError** e) {\n\tconst char* DEFAULT_ERROR = \"Could not parse %s in group %s: %s\";\n\tconst char* MISSING_REQUIRED_ERROR = \"Could not find required value %s in group %s: %s\";\n\tSERVER s;\n\tgchar *virtstyle=NULL;\n\tPARAM lp[] = {\n\t\t{ \"exportname\", TRUE,\tPARAM_STRING, \tNULL, 0 },\n\t\t{ \"port\", \tTRUE,\tPARAM_INT, \tNULL, 0 },\n\t\t{ \"authfile\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"filesize\",\tFALSE,\tPARAM_INT,\tNULL, 0 },\n\t\t{ \"virtstyle\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"prerun\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"postrun\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"readonly\",\tFALSE,\tPARAM_BOOL,\tNULL, F_READONLY },\n\t\t{ \"multifile\",\tFALSE,\tPARAM_BOOL,\tNULL, F_MULTIFILE },\n\t\t{ \"copyonwrite\", FALSE,\tPARAM_BOOL,\tNULL, F_COPYONWRITE },\n\t\t{ \"sparse_cow\",\tFALSE,\tPARAM_BOOL,\tNULL, F_SPARSE },\n\t\t{ \"sdp\",\tFALSE,\tPARAM_BOOL,\tNULL, F_SDP },\n\t\t{ \"sync\",\tFALSE,  PARAM_BOOL,\tNULL, F_SYNC },\n\t\t{ \"listenaddr\", FALSE,  PARAM_STRING,   NULL, 0 },\n\t\t{ \"maxconnections\", FALSE, PARAM_INT,\tNULL, 0 },\n\t};\n\tconst int lp_size=sizeof(lp)/sizeof(PARAM);\n\tPARAM gp[] = {\n\t\t{ \"user\",\tFALSE, PARAM_STRING,\t&runuser,\t0 },\n\t\t{ \"group\",\tFALSE, PARAM_STRING,\t&rungroup,\t0 },\n\t\t{ \"oldstyle\",\tFALSE, PARAM_BOOL,\t&do_oldstyle,\t1 },\n\t\t{ \"listenaddr\", FALSE, PARAM_STRING,\t&modern_listen, 0 },\n\t};\n\tPARAM* p=gp;\n\tint p_size=sizeof(gp)/sizeof(PARAM);\n\tGKeyFile *cfile;\n\tGError *err = NULL;\n\tconst char *err_msg=NULL;\n\tGQuark errdomain;\n\tGArray *retval=NULL;\n\tgchar **groups;\n\tgboolean value;\n\tgchar* startgroup;\n\tgint i;\n\tgint j;\n\n\terrdomain = g_quark_from_string(\"parse_cfile\");\n\tcfile = g_key_file_new();\n\tretval = g_array_new(FALSE, TRUE, sizeof(SERVER));\n\tif(!g_key_file_load_from_file(cfile, f, G_KEY_FILE_KEEP_COMMENTS |\n\t\t\tG_KEY_FILE_KEEP_TRANSLATIONS, &err)) {\n\t\tg_set_error(e, errdomain, CFILE_NOTFOUND, \"Could not open config file %s.\", f);\n\t\tg_key_file_free(cfile);\n\t\treturn retval;\n\t}\n\tstartgroup = g_key_file_get_start_group(cfile);\n\tif(!startgroup || strcmp(startgroup, \"generic\")) {\n\t\tg_set_error(e, errdomain, CFILE_MISSING_GENERIC, \"Config file does not contain the [generic] group!\");\n\t\tg_key_file_free(cfile);\n\t\treturn NULL;\n\t}\n\tgroups = g_key_file_get_groups(cfile, NULL);\n\tfor(i=0;groups[i];i++) {\n\t\tmemset(&s, '\\0', sizeof(SERVER));\n\t\tlp[0].target=&(s.exportname);\n\t\tlp[1].target=&(s.port);\n\t\tlp[2].target=&(s.authname);\n\t\tlp[3].target=&(s.expected_size);\n\t\tlp[4].target=&(virtstyle);\n\t\tlp[5].target=&(s.prerun);\n\t\tlp[6].target=&(s.postrun);\n\t\tlp[7].target=lp[8].target=lp[9].target=\n\t\t\t\tlp[10].target=lp[11].target=\n\t\t\t\tlp[12].target=&(s.flags);\n\t\tlp[13].target=&(s.listenaddr);\n\t\tlp[14].target=&(s.max_connections);\n\n\t\t/* After the [generic] group, start parsing exports */\n\t\tif(i==1) {\n\t\t\tp=lp;\n\t\t\tp_size=lp_size;\n\t\t} \n\t\tfor(j=0;j<p_size;j++) {\n\t\t\tg_assert(p[j].target != NULL);\n\t\t\tg_assert(p[j].ptype==PARAM_INT||p[j].ptype==PARAM_STRING||p[j].ptype==PARAM_BOOL);\n\t\t\tswitch(p[j].ptype) {\n\t\t\t\tcase PARAM_INT:\n\t\t\t\t\t*((gint*)p[j].target) =\n\t\t\t\t\t\tg_key_file_get_integer(cfile,\n\t\t\t\t\t\t\t\tgroups[i],\n\t\t\t\t\t\t\t\tp[j].paramname,\n\t\t\t\t\t\t\t\t&err);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_STRING:\n\t\t\t\t\t*((gchar**)p[j].target) =\n\t\t\t\t\t\tg_key_file_get_string(cfile,\n\t\t\t\t\t\t\t\tgroups[i],\n\t\t\t\t\t\t\t\tp[j].paramname,\n\t\t\t\t\t\t\t\t&err);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_BOOL:\n\t\t\t\t\tvalue = g_key_file_get_boolean(cfile,\n\t\t\t\t\t\t\tgroups[i],\n\t\t\t\t\t\t\tp[j].paramname, &err);\n\t\t\t\t\tif(!err) {\n\t\t\t\t\t\tif(value) {\n\t\t\t\t\t\t\t*((gint*)p[j].target) |= p[j].flagval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*((gint*)p[j].target) &= ~(p[j].flagval);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!strcmp(p[j].paramname, \"port\") && !strcmp(p[j].target, NBD_DEFAULT_PORT)) {\n\t\t\t\tg_set_error(e, errdomain, CFILE_INCORRECT_PORT, \"Config file specifies default port for oldstyle export\");\n\t\t\t\tg_key_file_free(cfile);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif(err) {\n\t\t\t\tif(err->code == G_KEY_FILE_ERROR_KEY_NOT_FOUND) {\n\t\t\t\t\tif(!p[j].required) {\n\t\t\t\t\t\t/* Ignore not-found error for optional values */\n\t\t\t\t\t\tg_clear_error(&err);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr_msg = MISSING_REQUIRED_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terr_msg = DEFAULT_ERROR;\n\t\t\t\t}\n\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, err_msg, p[j].paramname, groups[i], err->message);\n\t\t\t\tg_array_free(retval, TRUE);\n\t\t\t\tg_error_free(err);\n\t\t\t\tg_key_file_free(cfile);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tif(virtstyle) {\n\t\t\tif(!strncmp(virtstyle, \"none\", 4)) {\n\t\t\t\ts.virtstyle=VIRT_NONE;\n\t\t\t} else if(!strncmp(virtstyle, \"ipliteral\", 9)) {\n\t\t\t\ts.virtstyle=VIRT_IPLIT;\n\t\t\t} else if(!strncmp(virtstyle, \"iphash\", 6)) {\n\t\t\t\ts.virtstyle=VIRT_IPHASH;\n\t\t\t} else if(!strncmp(virtstyle, \"cidrhash\", 8)) {\n\t\t\t\ts.virtstyle=VIRT_CIDR;\n\t\t\t\tif(strlen(virtstyle)<10) {\n\t\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, \"Invalid value %s for parameter virtstyle in group %s: missing length\", virtstyle, groups[i]);\n\t\t\t\t\tg_array_free(retval, TRUE);\n\t\t\t\t\tg_key_file_free(cfile);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ts.cidrlen=strtol(virtstyle+8, NULL, 0);\n\t\t\t} else {\n\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, \"Invalid value %s for parameter virtstyle in group %s\", virtstyle, groups[i]);\n\t\t\t\tg_array_free(retval, TRUE);\n\t\t\t\tg_key_file_free(cfile);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif(s.port && !do_oldstyle) {\n\t\t\t\tg_warning(\"A port was specified, but oldstyle exports were not requested. This may not do what you expect.\");\n\t\t\t\tg_warning(\"Please read 'man 5 nbd-server' and search for oldstyle for more info\");\n\t\t\t}\n\t\t} else {\n\t\t\ts.virtstyle=VIRT_IPLIT;\n\t\t}\n\t\t/* Don't need to free this, it's not our string */\n\t\tvirtstyle=NULL;\n\t\t/* Don't append values for the [generic] group */\n\t\tif(i>0) {\n\t\t\ts.socket_family = AF_UNSPEC;\n\t\t\ts.servename = groups[i];\n\n\t\t\tappend_serve(&s, retval);\n\t\t} else {\n\t\t\tif(!do_oldstyle) {\n\t\t\t\tlp[1].required = 0;\n\t\t\t}\n\t\t}\n#ifndef WITH_SDP\n\t\tif(s.flags & F_SDP) {\n\t\t\tg_set_error(e, errdomain, CFILE_VALUE_UNSUPPORTED, \"This nbd-server was built without support for SDP, yet group %s uses it\", groups[i]);\n\t\t\tg_array_free(retval, TRUE);\n\t\t\tg_key_file_free(cfile);\n\t\t\treturn NULL;\n\t\t}\n#endif\n\t}\n\tif(i==1) {\n\t\tg_set_error(e, errdomain, CFILE_NO_EXPORTS, \"The config file does not specify any exports\");\n\t}\n\tg_key_file_free(cfile);\n\treturn retval;\n}\n\n/**\n * Signal handler for SIGCHLD\n * @param s the signal we're handling (must be SIGCHLD, or something\n * is severely wrong)\n **/\nvoid sigchld_handler(int s) {\n        int status;\n\tint* i;\n\tpid_t pid;\n\n\twhile((pid=waitpid(-1, &status, WNOHANG)) > 0) {\n\t\tif(WIFEXITED(status)) {\n\t\t\tmsg3(LOG_INFO, \"Child exited with %d\", WEXITSTATUS(status));\n\t\t}\n\t\ti=g_hash_table_lookup(children, &pid);\n\t\tif(!i) {\n\t\t\tmsg3(LOG_INFO, \"SIGCHLD received for an unknown child with PID %ld\", (long)pid);\n\t\t} else {\n\t\t\tDEBUG2(\"Removing %d from the list of children\", pid);\n\t\t\tg_hash_table_remove(children, &pid);\n\t\t}\n\t}\n}\n\n/**\n * Kill a child. Called from sigterm_handler::g_hash_table_foreach.\n *\n * @param key the key\n * @param value the value corresponding to the above key\n * @param user_data a pointer which we always set to 1, so that we know what\n * will happen next.\n **/\nvoid killchild(gpointer key, gpointer value, gpointer user_data) {\n\tpid_t *pid=value;\n\tint *parent=user_data;\n\n\tkill(*pid, SIGTERM);\n\t*parent=1;\n}\n\n/**\n * Handle SIGTERM and dispatch it to our children\n * @param s the signal we're handling (must be SIGTERM, or something\n * is severely wrong).\n **/\nvoid sigterm_handler(int s) {\n\tint parent=0;\n\n\tg_hash_table_foreach(children, killchild, &parent);\n\n\tif(parent) {\n\t\tunlink(pidfname);\n\t}\n\n\texit(EXIT_SUCCESS);\n}\n\n/**\n * Detect the size of a file.\n *\n * @param fhandle An open filedescriptor\n * @return the size of the file, or OFFT_MAX if detection was\n * impossible.\n **/\noff_t size_autodetect(int fhandle) {\n\toff_t es;\n\tu64 bytes;\n\tstruct stat stat_buf;\n\tint error;\n\n#ifdef HAVE_SYS_MOUNT_H\n#ifdef HAVE_SYS_IOCTL_H\n#ifdef BLKGETSIZE64\n\tDEBUG(\"looking for export size with ioctl BLKGETSIZE64\\n\");\n\tif (!ioctl(fhandle, BLKGETSIZE64, &bytes) && bytes) {\n\t\treturn (off_t)bytes;\n\t}\n#endif /* BLKGETSIZE64 */\n#endif /* HAVE_SYS_IOCTL_H */\n#endif /* HAVE_SYS_MOUNT_H */\n\n\tDEBUG(\"looking for fhandle size with fstat\\n\");\n\tstat_buf.st_size = 0;\n\terror = fstat(fhandle, &stat_buf);\n\tif (!error) {\n\t\tif(stat_buf.st_size > 0)\n\t\t\treturn (off_t)stat_buf.st_size;\n        } else {\n                err(\"fstat failed: %m\");\n        }\n\n\tDEBUG(\"looking for fhandle size with lseek SEEK_END\\n\");\n\tes = lseek(fhandle, (off_t)0, SEEK_END);\n\tif (es > ((off_t)0)) {\n\t\treturn es;\n        } else {\n                DEBUG2(\"lseek failed: %d\", errno==EBADF?1:(errno==ESPIPE?2:(errno==EINVAL?3:4)));\n        }\n\n\terr(\"Could not find size of exported block device: %m\");\n\treturn OFFT_MAX;\n}\n\n/**\n * Get the file handle and offset, given an export offset.\n *\n * @param export An array of export files\n * @param a The offset to get corresponding file/offset for\n * @param fhandle [out] File descriptor\n * @param foffset [out] Offset into fhandle\n * @param maxbytes [out] Tells how many bytes can be read/written\n * from fhandle starting at foffset (0 if there is no limit)\n * @return 0 on success, -1 on failure\n **/\nint get_filepos(GArray* export, off_t a, int* fhandle, off_t* foffset, size_t* maxbytes ) {\n\t/* Negative offset not allowed */\n\tif(a < 0)\n\t\treturn -1;\n\n\t/* Binary search for last file with starting offset <= a */\n\tFILE_INFO fi;\n\tint start = 0;\n\tint end = export->len - 1;\n\twhile( start <= end ) {\n\t\tint mid = (start + end) / 2;\n\t\tfi = g_array_index(export, FILE_INFO, mid);\n\t\tif( fi.startoff < a ) {\n\t\t\tstart = mid + 1;\n\t\t} else if( fi.startoff > a ) {\n\t\t\tend = mid - 1;\n\t\t} else {\n\t\t\tstart = end = mid;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* end should never go negative, since first startoff is 0 and a >= 0 */\n\tg_assert(end >= 0);\n\n\tfi = g_array_index(export, FILE_INFO, end);\n\t*fhandle = fi.fhandle;\n\t*foffset = a - fi.startoff;\n\t*maxbytes = 0;\n\tif( end+1 < export->len ) {\n\t\tFILE_INFO fi_next = g_array_index(export, FILE_INFO, end+1);\n\t\t*maxbytes = fi_next.startoff - a;\n\t}\n\n\treturn 0;\n}\n\n/**\n * seek to a position in a file, with error handling.\n * @param handle a filedescriptor\n * @param a position to seek to\n * @todo get rid of this; lastpoint is a global variable right now, but it\n * shouldn't be. If we pass it on as a parameter, that makes things a *lot*\n * easier.\n **/\nvoid myseek(int handle,off_t a) {\n\tif (lseek(handle, a, SEEK_SET) < 0) {\n\t\terr(\"Can not seek locally!\\n\");\n\t}\n}\n\n/**\n * Write an amount of bytes at a given offset to the right file. This\n * abstracts the write-side of the multiple file option.\n *\n * @param a The offset where the write should start\n * @param buf The buffer to write from\n * @param len The length of buf\n * @param client The client we're serving for\n * @return The number of bytes actually written, or -1 in case of an error\n **/\nssize_t rawexpwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n\tint fhandle;\n\toff_t foffset;\n\tsize_t maxbytes;\n\tssize_t retval;\n\n\tif(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))\n\t\treturn -1;\n\tif(maxbytes && len > maxbytes)\n\t\tlen = maxbytes;\n\n\tDEBUG4(\"(WRITE to fd %d offset %llu len %u), \", fhandle, foffset, len);\n\n\tmyseek(fhandle, foffset);\n\tretval = write(fhandle, buf, len);\n\tif(client->server->flags & F_SYNC) {\n\t\tfsync(fhandle);\n\t}\n\treturn retval;\n}\n\n/**\n * Call rawexpwrite repeatedly until all data has been written.\n * @return 0 on success, nonzero on failure\n **/\nint rawexpwrite_fully(off_t a, char *buf, size_t len, CLIENT *client) {\n\tssize_t ret=0;\n\n\twhile(len > 0 && (ret=rawexpwrite(a, buf, len, client)) > 0 ) {\n\t\ta += ret;\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret < 0 || len != 0);\n}\n\n/**\n * Read an amount of bytes at a given offset from the right file. This\n * abstracts the read-side of the multiple files option.\n *\n * @param a The offset where the read should start\n * @param buf A buffer to read into\n * @param len The size of buf\n * @param client The client we're serving for\n * @return The number of bytes actually read, or -1 in case of an\n * error.\n **/\nssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {\n\tint fhandle;\n\toff_t foffset;\n\tsize_t maxbytes;\n\n\tif(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))\n\t\treturn -1;\n\tif(maxbytes && len > maxbytes)\n\t\tlen = maxbytes;\n\n\tDEBUG4(\"(READ from fd %d offset %llu len %u), \", fhandle, foffset, len);\n\n\tmyseek(fhandle, foffset);\n\treturn read(fhandle, buf, len);\n}\n\n/**\n * Call rawexpread repeatedly until all data has been read.\n * @return 0 on success, nonzero on failure\n **/\nint rawexpread_fully(off_t a, char *buf, size_t len, CLIENT *client) {\n\tssize_t ret=0;\n\n\twhile(len > 0 && (ret=rawexpread(a, buf, len, client)) > 0 ) {\n\t\ta += ret;\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret < 0 || len != 0);\n}\n\n/**\n * Read an amount of bytes at a given offset from the right file. This\n * abstracts the read-side of the copyonwrite stuff, and calls\n * rawexpread() with the right parameters to do the actual work.\n * @param a The offset where the read should start\n * @param buf A buffer to read into\n * @param len The size of buf\n * @param client The client we're going to read for\n * @return 0 on success, nonzero on failure\n **/\nint expread(off_t a, char *buf, size_t len, CLIENT *client) {\n\toff_t rdlen, offset;\n\toff_t mapcnt, mapl, maph, pagestart;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn(rawexpread_fully(a, buf, len, client));\n\tDEBUG3(\"Asked to read %d bytes at %llu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE; maph=(a+len-1)/DIFFPAGESIZE;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE;\n\t\toffset=a-pagestart;\n\t\trdlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %llu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\tmyseek(client->difffile, client->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (read(client->difffile, buf, rdlen) != rdlen) return -1;\n\t\t} else { /* the block is not there */\n\t\t\tDEBUG2(\"Page %llu is not here, we read the original one\\n\",\n\t\t\t       (unsigned long long)mapcnt);\n\t\t\tif(rawexpread_fully(a, buf, rdlen, client)) return -1;\n\t\t}\n\t\tlen-=rdlen; a+=rdlen; buf+=rdlen;\n\t}\n\treturn 0;\n}\n\n/**\n * Write an amount of bytes at a given offset to the right file. This\n * abstracts the write-side of the copyonwrite option, and calls\n * rawexpwrite() with the right parameters to do the actual work.\n *\n * @param a The offset where the write should start\n * @param buf The buffer to write from\n * @param len The length of buf\n * @param client The client we're going to write for.\n * @return 0 on success, nonzero on failure\n **/\nint expwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n\tchar pagebuf[DIFFPAGESIZE];\n\toff_t mapcnt,mapl,maph;\n\toff_t wrlen,rdlen; \n\toff_t pagestart;\n\toff_t offset;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn(rawexpwrite_fully(a, buf, len, client)); \n\tDEBUG3(\"Asked to write %d bytes at %llu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE ; maph=(a+len-1)/DIFFPAGESIZE ;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE ;\n\t\toffset=a-pagestart ;\n\t\twrlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %llu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt])) ;\n\t\t\tmyseek(client->difffile,\n\t\t\t\t\tclient->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (write(client->difffile, buf, wrlen) != wrlen) return -1 ;\n\t\t} else { /* the block is not there */\n\t\t\tmyseek(client->difffile,client->difffilelen*DIFFPAGESIZE) ;\n\t\t\tclient->difmap[mapcnt]=(client->server->flags&F_SPARSE)?mapcnt:client->difffilelen++;\n\t\t\tDEBUG3(\"Page %llu is not here, we put it at %lu\\n\",\n\t\t\t       (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\trdlen=DIFFPAGESIZE ;\n\t\t\tif (rawexpread_fully(pagestart, pagebuf, rdlen, client))\n\t\t\t\treturn -1;\n\t\t\tmemcpy(pagebuf+offset,buf,wrlen) ;\n\t\t\tif (write(client->difffile, pagebuf, DIFFPAGESIZE) !=\n\t\t\t\t\tDIFFPAGESIZE)\n\t\t\t\treturn -1;\n\t\t}\t\t\t\t\t\t    \n\t\tlen-=wrlen ; a+=wrlen ; buf+=wrlen ;\n\t}\n\treturn 0;\n}\n\n/**\n * Do the initial negotiation.\n *\n * @param client The client we're negotiating with.\n **/\nCLIENT* negotiate(int net, CLIENT *client, GArray* servers) {\n\tchar zeros[128];\n\tuint64_t size_host;\n\tuint32_t flags = NBD_FLAG_HAS_FLAGS;\n\tuint16_t smallflags = 0;\n\tuint64_t magic;\n\n\tmemset(zeros, '\\0', sizeof(zeros));\n\tif(!client || !client->modern) {\n\t\t/* common */\n\t\tif (write(net, INIT_PASSWD, 8) < 0) {\n\t\t\terr_nonfatal(\"Negotiation failed: %m\");\n\t\t\tif(client)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif(!client || client->modern) {\n\t\t\t/* modern */\n\t\t\tmagic = htonll(opts_magic);\n\t\t} else {\n\t\t\t/* oldstyle */\n\t\t\tmagic = htonll(cliserv_magic);\n\t\t}\n\t\tif (write(net, &magic, sizeof(magic)) < 0) {\n\t\t\terr_nonfatal(\"Negotiation failed: %m\");\n\t\t\tif(client)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\tif(!client) {\n\t\t/* modern */\n\t\tuint32_t reserved;\n\t\tuint32_t opt;\n\t\tuint32_t namelen;\n\t\tchar* name;\n\t\tint i;\n\n\t\tif(!servers)\n\t\t\terr(\"programmer error\");\n\t\tif (write(net, &smallflags, sizeof(uint16_t)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tif (read(net, &reserved, sizeof(reserved)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tif (read(net, &magic, sizeof(magic)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tmagic = ntohll(magic);\n\t\tif(magic != opts_magic) {\n\t\t\tclose(net);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (read(net, &opt, sizeof(opt)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\topt = ntohl(opt);\n\t\tif(opt != NBD_OPT_EXPORT_NAME) {\n\t\t\tclose(net);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (read(net, &namelen, sizeof(namelen)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tnamelen = ntohl(namelen);\n\t\tname = malloc(namelen+1);\n\t\tname[namelen]=0;\n\t\tif (read(net, name, namelen) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tfor(i=0; i<servers->len; i++) {\n\t\t\tSERVER* serve = &(g_array_index(servers, SERVER, i));\n\t\t\tif(!strcmp(serve->servename, name)) {\n\t\t\t\tCLIENT* client = g_new0(CLIENT, 1);\n\t\t\t\tclient->server = serve;\n\t\t\t\tclient->exportsize = OFFT_MAX;\n\t\t\t\tclient->net = net;\n\t\t\t\tclient->modern = TRUE;\n\t\t\t\treturn client;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\t/* common */\n\tsize_host = htonll((u64)(client->exportsize));\n\tif (write(net, &size_host, 8) < 0)\n\t\terr(\"Negotiation failed: %m\");\n\tif (client->server->flags & F_READONLY)\n\t\tflags |= NBD_FLAG_READ_ONLY;\n\tif (!client->modern) {\n\t\t/* oldstyle */\n\t\tflags = htonl(flags);\n\t\tif (write(client->net, &flags, 4) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t} else {\n\t\t/* modern */\n\t\tsmallflags = (uint16_t)(flags & ~((uint16_t)0));\n\t\tsmallflags = htons(smallflags);\n\t\tif (write(client->net, &smallflags, sizeof(smallflags)) < 0) {\n\t\t\terr(\"Negotiation failed: %m\");\n\t\t}\n\t}\n\t/* common */\n\tif (write(client->net, zeros, 124) < 0)\n\t\terr(\"Negotiation failed: %m\");\n\treturn NULL;\n}\n\n/** sending macro. */\n#define SEND(net,reply) writeit( net, &reply, sizeof( reply ));\n/** error macro. */\n#define ERROR(client,reply,errcode) { reply.error = htonl(errcode); SEND(client->net,reply); reply.error = 0; }\n/**\n * Serve a file to a single client.\n *\n * @todo This beast needs to be split up in many tiny little manageable\n * pieces. Preferably with a chainsaw.\n *\n * @param client The client we're going to serve to.\n * @return when the client disconnects\n **/\nint mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE + sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n\n/**\n * Set up client export array, which is an array of FILE_INFO.\n * Also, split a single exportfile into multiple ones, if that was asked.\n * @param client information on the client which we want to setup export for\n **/\nvoid setupexport(CLIENT* client) {\n\tint i;\n\toff_t laststartoff = 0, lastsize = 0;\n\tint multifile = (client->server->flags & F_MULTIFILE);\n\n\tclient->export = g_array_new(TRUE, TRUE, sizeof(FILE_INFO));\n\n\t/* If multi-file, open as many files as we can.\n\t * If not, open exactly one file.\n\t * Calculate file sizes as we go to get total size. */\n\tfor(i=0; ; i++) {\n\t\tFILE_INFO fi;\n\t\tgchar *tmpname;\n\t\tgchar* error_string;\n\t\tmode_t mode = (client->server->flags & F_READONLY) ? O_RDONLY : O_RDWR;\n\n\t\tif(multifile) {\n\t\t\ttmpname=g_strdup_printf(\"%s.%d\", client->exportname, i);\n\t\t} else {\n\t\t\ttmpname=g_strdup(client->exportname);\n\t\t}\n\t\tDEBUG2( \"Opening %s\\n\", tmpname );\n\t\tfi.fhandle = open(tmpname, mode);\n\t\tif(fi.fhandle == -1 && mode == O_RDWR) {\n\t\t\t/* Try again because maybe media was read-only */\n\t\t\tfi.fhandle = open(tmpname, O_RDONLY);\n\t\t\tif(fi.fhandle != -1) {\n\t\t\t\t/* Opening the base file in copyonwrite mode is\n\t\t\t\t * okay */\n\t\t\t\tif(!(client->server->flags & F_COPYONWRITE)) {\n\t\t\t\t\tclient->server->flags |= F_AUTOREADONLY;\n\t\t\t\t\tclient->server->flags |= F_READONLY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(fi.fhandle == -1) {\n\t\t\tif(multifile && i>0)\n\t\t\t\tbreak;\n\t\t\terror_string=g_strdup_printf(\n\t\t\t\t\"Could not open exported file %s: %%m\",\n\t\t\t\ttmpname);\n\t\t\terr(error_string);\n\t\t}\n\t\tfi.startoff = laststartoff + lastsize;\n\t\tg_array_append_val(client->export, fi);\n\t\tg_free(tmpname);\n\n\t\t/* Starting offset and size of this file will be used to\n\t\t * calculate starting offset of next file */\n\t\tlaststartoff = fi.startoff;\n\t\tlastsize = size_autodetect(fi.fhandle);\n\n\t\tif(!multifile)\n\t\t\tbreak;\n\t}\n\n\t/* Set export size to total calculated size */\n\tclient->exportsize = laststartoff + lastsize;\n\n\t/* Export size may be overridden */\n\tif(client->server->expected_size) {\n\t\t/* desired size must be <= total calculated size */\n\t\tif(client->server->expected_size > client->exportsize) {\n\t\t\terr(\"Size of exported file is too big\\n\");\n\t\t}\n\n\t\tclient->exportsize = client->server->expected_size;\n\t}\n\n\tmsg3(LOG_INFO, \"Size of exported file/device is %llu\", (unsigned long long)client->exportsize);\n\tif(multifile) {\n\t\tmsg3(LOG_INFO, \"Total number of files: %d\", i);\n\t}\n}\n\nint copyonwrite_prepare(CLIENT* client) {\n\toff_t i;\n\tif ((client->difffilename = malloc(1024))==NULL)\n\t\terr(\"Failed to allocate string for diff file name\");\n\tsnprintf(client->difffilename, 1024, \"%s-%s-%d.diff\",client->exportname,client->clientname,\n\t\t(int)getpid()) ;\n\tclient->difffilename[1023]='\\0';\n\tmsg3(LOG_INFO,\"About to create map and diff file %s\",client->difffilename) ;\n\tclient->difffile=open(client->difffilename,O_RDWR | O_CREAT | O_TRUNC,0600) ;\n\tif (client->difffile<0) err(\"Could not create diff file (%m)\") ;\n\tif ((client->difmap=calloc(client->exportsize/DIFFPAGESIZE,sizeof(u32)))==NULL)\n\t\terr(\"Could not allocate memory\") ;\n\tfor (i=0;i<client->exportsize/DIFFPAGESIZE;i++) client->difmap[i]=(u32)-1 ;\n\n\treturn 0;\n}\n\n/**\n * Run a command. This is used for the ``prerun'' and ``postrun'' config file\n * options\n *\n * @param command the command to be ran. Read from the config file\n * @param file the file name we're about to export\n **/\nint do_run(gchar* command, gchar* file) {\n\tgchar* cmd;\n\tint retval=0;\n\n\tif(command && *command) {\n\t\tcmd = g_strdup_printf(command, file);\n\t\tretval=system(cmd);\n\t\tg_free(cmd);\n\t}\n\treturn retval;\n}\n\n/**\n * Serve a connection. \n *\n * @todo allow for multithreading, perhaps use libevent. Not just yet, though;\n * follow the road map.\n *\n * @param client a connected client\n **/\nvoid serveconnection(CLIENT *client) {\n\tif(do_run(client->server->prerun, client->exportname)) {\n\t\texit(EXIT_FAILURE);\n\t}\n\tsetupexport(client);\n\n\tif (client->server->flags & F_COPYONWRITE) {\n\t\tcopyonwrite_prepare(client);\n\t}\n\n\tsetmysockopt(client->net);\n\n\tmainloop(client);\n\tdo_run(client->server->postrun, client->exportname);\n}\n\n/**\n * Find the name of the file we have to serve. This will use g_strdup_printf\n * to put the IP address of the client inside a filename containing\n * \"%s\" (in the form as specified by the \"virtstyle\" option). That name\n * is then written to client->exportname.\n *\n * @param net A socket connected to an nbd client\n * @param client information about the client. The IP address in human-readable\n * format will be written to a new char* buffer, the address of which will be\n * stored in client->clientname.\n **/\nvoid set_peername(int net, CLIENT *client) {\n\tstruct sockaddr_storage addrin;\n\tstruct sockaddr_storage netaddr;\n\tstruct sockaddr_in  *netaddr4 = NULL;\n\tstruct sockaddr_in6 *netaddr6 = NULL;\n\tsize_t addrinlen = sizeof( addrin );\n\tstruct addrinfo hints;\n\tstruct addrinfo *ai = NULL;\n\tchar peername[NI_MAXHOST];\n\tchar netname[NI_MAXHOST];\n\tchar *tmp = NULL;\n\tint i;\n\tint e;\n\tint shift;\n\n\tif (getpeername(net, (struct sockaddr *) &addrin, (socklen_t *)&addrinlen) < 0)\n\t\terr(\"getsockname failed: %m\");\n\n\tgetnameinfo((struct sockaddr *)&addrin, (socklen_t)addrinlen,\n\t\tpeername, sizeof (peername), NULL, 0, NI_NUMERICHOST);\n\n\tmemset(&hints, '\\0', sizeof (hints));\n\thints.ai_flags = AI_ADDRCONFIG;\n\te = getaddrinfo(peername, NULL, &hints, &ai);\n\n\tif(e != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed: %s\\n\", gai_strerror(e));\n\t\tfreeaddrinfo(ai);\n\t\treturn;\n\t}\n\n\tswitch(client->server->virtstyle) {\n\t\tcase VIRT_NONE:\n\t\t\tclient->exportname=g_strdup(client->server->exportname);\n\t\t\tbreak;\n\t\tcase VIRT_IPHASH:\n\t\t\tfor(i=0;i<strlen(peername);i++) {\n\t\t\t\tif(peername[i]=='.') {\n\t\t\t\t\tpeername[i]='/';\n\t\t\t\t}\n\t\t\t}\n\t\tcase VIRT_IPLIT:\n\t\t\tclient->exportname=g_strdup_printf(client->server->exportname, peername);\n\t\t\tbreak;\n\t\tcase VIRT_CIDR:\n\t\t\tmemcpy(&netaddr, &addrin, addrinlen);\n\t\t\tif(ai->ai_family == AF_INET) {\n\t\t\t\tnetaddr4 = (struct sockaddr_in *)&netaddr;\n\t\t\t\t(netaddr4->sin_addr).s_addr>>=32-(client->server->cidrlen);\n\t\t\t\t(netaddr4->sin_addr).s_addr<<=32-(client->server->cidrlen);\n\n\t\t\t\tgetnameinfo((struct sockaddr *) netaddr4, (socklen_t) addrinlen,\n\t\t\t\t\t\t\tnetname, sizeof (netname), NULL, 0, NI_NUMERICHOST);\n\t\t\t\ttmp=g_strdup_printf(\"%s/%s\", netname, peername);\n\t\t\t}else if(ai->ai_family == AF_INET6) {\n\t\t\t\tnetaddr6 = (struct sockaddr_in6 *)&netaddr;\n\n\t\t\t\tshift = 128-(client->server->cidrlen);\n\t\t\t\ti = 3;\n\t\t\t\twhile(shift >= 32) {\n\t\t\t\t\t((netaddr6->sin6_addr).s6_addr32[i])=0;\n\t\t\t\t\tshift-=32;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t(netaddr6->sin6_addr).s6_addr32[i]>>=shift;\n\t\t\t\t(netaddr6->sin6_addr).s6_addr32[i]<<=shift;\n\n\t\t\t\tgetnameinfo((struct sockaddr *)netaddr6, (socklen_t)addrinlen,\n\t\t\t\t\t    netname, sizeof(netname), NULL, 0, NI_NUMERICHOST);\n\t\t\t\ttmp=g_strdup_printf(\"%s/%s\", netname, peername);\n\t\t\t}\n\n\t\t\tif(tmp != NULL)\n\t\t\t  client->exportname=g_strdup_printf(client->server->exportname, tmp);\n\n\t\t\tbreak;\n\t}\n\n\tfreeaddrinfo(ai);\n\tmsg4(LOG_INFO, \"connect from %s, assigned file is %s\", \n\t     peername, client->exportname);\n\tclient->clientname=g_strdup(peername);\n}\n\n/**\n * Destroy a pid_t*\n * @param data a pointer to pid_t which should be freed\n **/\nvoid destroy_pid_t(gpointer data) {\n\tg_free(data);\n}\n\n/**\n * Loop through the available servers, and serve them. Never returns.\n **/\nint serveloop(GArray* servers) {\n\tstruct sockaddr_storage addrin;\n\tsocklen_t addrinlen=sizeof(addrin);\n\tint i;\n\tint max;\n\tint sock;\n\tfd_set mset;\n\tfd_set rset;\n\n\t/* \n\t * Set up the master fd_set. The set of descriptors we need\n\t * to select() for never changes anyway and it buys us a *lot*\n\t * of time to only build this once. However, if we ever choose\n\t * to not fork() for clients anymore, we may have to revisit\n\t * this.\n\t */\n\tmax=0;\n\tFD_ZERO(&mset);\n\tfor(i=0;i<servers->len;i++) {\n\t\tif((sock=(g_array_index(servers, SERVER, i)).socket)) {\n\t\t\tFD_SET(sock, &mset);\n\t\t\tmax=sock>max?sock:max;\n\t\t}\n\t}\n\tif(modernsock) {\n\t\tFD_SET(modernsock, &mset);\n\t\tmax=modernsock>max?modernsock:max;\n\t}\n\tfor(;;) {\n\t\tCLIENT *client = NULL;\n\t\tpid_t *pid;\n\n\t\tmemcpy(&rset, &mset, sizeof(fd_set));\n\t\tif(select(max+1, &rset, NULL, NULL, NULL)>0) {\n\t\t\tint net = 0;\n\t\t\tSERVER* serve;\n\n\t\t\tDEBUG(\"accept, \");\n\t\t\tif(FD_ISSET(modernsock, &rset)) {\n\t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0)\n\t\t\t\t\terr(\"accept: %m\");\n\t\t\t\tclient = negotiate(net, NULL, servers);\n\t\t\t\tif(!client) {\n\t\t\t\t\terr_nonfatal(\"negotiation failed\");\n\t\t\t\t\tclose(net);\n\t\t\t\t\tnet=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<servers->len && !net;i++) {\n\t\t\t\tserve=&(g_array_index(servers, SERVER, i));\n\t\t\t\tif(FD_ISSET(serve->socket, &rset)) {\n\t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0)\n\t\t\t\t\t\terr(\"accept: %m\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(net) {\n\t\t\t\tint sock_flags;\n\n\t\t\t\tif(serve->max_connections > 0 &&\n\t\t\t\t   g_hash_table_size(children) >= serve->max_connections) {\n\t\t\t\t\tmsg2(LOG_INFO, \"Max connections reached\");\n\t\t\t\t\tclose(net);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif((sock_flags = fcntl(net, F_GETFL, 0))==-1) {\n\t\t\t\t\terr(\"fcntl F_GETFL\");\n\t\t\t\t}\n\t\t\t\tif(fcntl(net, F_SETFL, sock_flags &~O_NONBLOCK)==-1) {\n\t\t\t\t\terr(\"fcntl F_SETFL ~O_NONBLOCK\");\n\t\t\t\t}\n\t\t\t\tif(!client) {\n\t\t\t\t\tclient = g_new0(CLIENT, 1);\n\t\t\t\t\tclient->server=serve;\n\t\t\t\t\tclient->exportsize=OFFT_MAX;\n\t\t\t\t\tclient->net=net;\n\t\t\t\t}\n\t\t\t\tset_peername(net, client);\n\t\t\t\tif (!authorized_client(client)) {\n\t\t\t\t\tmsg2(LOG_INFO,\"Unauthorized client\") ;\n\t\t\t\t\tclose(net);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmsg2(LOG_INFO,\"Authorized client\") ;\n\t\t\t\tpid=g_malloc(sizeof(pid_t));\n#ifndef NOFORK\n\t\t\t\tif ((*pid=fork())<0) {\n\t\t\t\t\tmsg3(LOG_INFO,\"Could not fork (%s)\",strerror(errno)) ;\n\t\t\t\t\tclose(net);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*pid>0) { /* parent */\n\t\t\t\t\tclose(net);\n\t\t\t\t\tg_hash_table_insert(children, pid, pid);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* child */\n\t\t\t\tg_hash_table_destroy(children);\n\t\t\t\tfor(i=0;i<servers->len;i++) {\n\t\t\t\t\tserve=&g_array_index(servers, SERVER, i);\n\t\t\t\t\tclose(serve->socket);\n\t\t\t\t}\n\t\t\t\t/* FALSE does not free the\n\t\t\t\tactual data. This is required,\n\t\t\t\tbecause the client has a\n\t\t\t\tdirect reference into that\n\t\t\t\tdata, and otherwise we get a\n\t\t\t\tsegfault... */\n\t\t\t\tg_array_free(servers, FALSE);\n#endif // NOFORK\n\t\t\t\tmsg2(LOG_INFO,\"Starting to serve\");\n\t\t\t\tserveconnection(client);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dosockopts(int socket) {\n#ifndef sun\n\tint yes=1;\n#else\n\tchar yes='1';\n#endif /* sun */\n\tint sock_flags;\n\n\t/* lose the pesky \"Address already in use\" error message */\n\tif (setsockopt(socket,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {\n\t        err(\"setsockopt SO_REUSEADDR\");\n\t}\n\tif (setsockopt(socket,SOL_SOCKET,SO_KEEPALIVE,&yes,sizeof(int)) == -1) {\n\t\terr(\"setsockopt SO_KEEPALIVE\");\n\t}\n\n\t/* make the listening socket non-blocking */\n\tif ((sock_flags = fcntl(socket, F_GETFL, 0)) == -1) {\n\t\terr(\"fcntl F_GETFL\");\n\t}\n\tif (fcntl(socket, F_SETFL, sock_flags | O_NONBLOCK) == -1) {\n\t\terr(\"fcntl F_SETFL O_NONBLOCK\");\n\t}\n}\n\n/**\n * Connect a server's socket.\n *\n * @param serve the server we want to connect.\n **/\nint setup_serve(SERVER *serve) {\n\tstruct addrinfo hints;\n\tstruct addrinfo *ai = NULL;\n\tgchar *port = NULL;\n\tint e;\n\n\tif(!do_oldstyle) {\n\t\treturn serve->servename ? 1 : 0;\n\t}\n\tmemset(&hints,'\\0',sizeof(hints));\n\thints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = serve->socket_family;\n\n\tport = g_strdup_printf (\"%d\", serve->port);\n\tif (port == NULL)\n\t\treturn 0;\n\n\te = getaddrinfo(serve->listenaddr,port,&hints,&ai);\n\n\tg_free(port);\n\n\tif(e != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed: %s\\n\", gai_strerror(e));\n\t\tserve->socket = -1;\n\t\tfreeaddrinfo(ai);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(serve->socket_family == AF_UNSPEC)\n\t\tserve->socket_family = ai->ai_family;\n\n#ifdef WITH_SDP\n\tif ((serve->flags) && F_SDP) {\n\t\tif (ai->ai_family == AF_INET)\n\t\t\tai->ai_family = AF_INET_SDP;\n\t\telse (ai->ai_family == AF_INET6)\n\t\t\tai->ai_family = AF_INET6_SDP;\n\t}\n#endif\n\tif ((serve->socket = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) < 0)\n\t\terr(\"socket: %m\");\n\n\tdosockopts(serve->socket);\n\n\tDEBUG(\"Waiting for connections... bind, \");\n\te = bind(serve->socket, ai->ai_addr, ai->ai_addrlen);\n\tif (e != 0 && errno != EADDRINUSE)\n\t\terr(\"bind: %m\");\n\tDEBUG(\"listen, \");\n\tif (listen(serve->socket, 1) < 0)\n\t\terr(\"listen: %m\");\n\n\tfreeaddrinfo (ai);\n\tif(serve->servename) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nvoid open_modern(void) {\n\tstruct addrinfo hints;\n\tstruct addrinfo* ai = NULL;\n\tstruct sock_flags;\n\tint e;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_protocol = IPPROTO_TCP;\n\te = getaddrinfo(modern_listen, NBD_DEFAULT_PORT, &hints, &ai);\n\tif(e != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed: %s\\n\", gai_strerror(e));\n\t\texit(EXIT_FAILURE);\n\t}\n\tif((modernsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol))<0) {\n\t\terr(\"socket: %m\");\n\t}\n\n\tdosockopts(modernsock);\n\n\tif(bind(modernsock, ai->ai_addr, ai->ai_addrlen)) {\n\t\terr(\"bind: %m\");\n\t}\n\tif(listen(modernsock, 10) <0) {\n\t\terr(\"listen: %m\");\n\t}\n\n\tfreeaddrinfo(ai);\n}\n\n/**\n * Connect our servers.\n **/\nvoid setup_servers(GArray* servers) {\n\tint i;\n\tstruct sigaction sa;\n\tint want_modern=0;\n\n\tfor(i=0;i<servers->len;i++) {\n\t\twant_modern |= setup_serve(&(g_array_index(servers, SERVER, i)));\n\t}\n\tif(want_modern) {\n\t\topen_modern();\n\t}\n\tchildren=g_hash_table_new_full(g_int_hash, g_int_equal, NULL, destroy_pid_t);\n\n\tsa.sa_handler = sigchld_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tif(sigaction(SIGCHLD, &sa, NULL) == -1)\n\t\terr(\"sigaction: %m\");\n\tsa.sa_handler = sigterm_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tif(sigaction(SIGTERM, &sa, NULL) == -1)\n\t\terr(\"sigaction: %m\");\n}\n\n/**\n * Go daemon (unless we specified at compile time that we didn't want this)\n * @param serve the first server of our configuration. If its port is zero,\n * \tthen do not daemonize, because we're doing inetd then. This parameter\n * \tis only used to create a PID file of the form\n * \t/var/run/nbd-server.&lt;port&gt;.pid; it's not modified in any way.\n **/\n#if !defined(NODAEMON) && !defined(NOFORK)\nvoid daemonize(SERVER* serve) {\n\tFILE*pidf;\n\n\tif(serve && !(serve->port)) {\n\t\treturn;\n\t}\n\tif(daemon(0,0)<0) {\n\t\terr(\"daemon\");\n\t}\n\tif(!*pidftemplate) {\n\t\tif(serve) {\n\t\t\tstrncpy(pidftemplate, \"/var/run/nbd-server.%d.pid\", 255);\n\t\t} else {\n\t\t\tstrncpy(pidftemplate, \"/var/run/nbd-server.pid\", 255);\n\t\t}\n\t}\n\tsnprintf(pidfname, 255, pidftemplate, serve ? serve->port : 0);\n\tpidf=fopen(pidfname, \"w\");\n\tif(pidf) {\n\t\tfprintf(pidf,\"%d\\n\", (int)getpid());\n\t\tfclose(pidf);\n\t} else {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Not fatal; continuing\");\n\t}\n}\n#else\n#define daemonize(serve)\n#endif /* !defined(NODAEMON) && !defined(NOFORK) */\n\n/*\n * Everything beyond this point (in the file) is run in non-daemon mode.\n * The stuff above daemonize() isn't.\n */\n\nvoid serve_err(SERVER* serve, const char* msg) G_GNUC_NORETURN;\n\nvoid serve_err(SERVER* serve, const char* msg) {\n\tg_message(\"Export of %s on port %d failed:\", serve->exportname,\n\t\t\tserve->port);\n\terr(msg);\n}\n\n/**\n * Set up user-ID and/or group-ID\n **/\nvoid dousers(void) {\n\tstruct passwd *pw;\n\tstruct group *gr;\n\tgchar* str;\n\tif(rungroup) {\n\t\tgr=getgrnam(rungroup);\n\t\tif(!gr) {\n\t\t\tstr = g_strdup_printf(\"Invalid group name: %s\", rungroup);\n\t\t\terr(str);\n\t\t}\n\t\tif(setgid(gr->gr_gid)<0) {\n\t\t\terr(\"Could not set GID: %m\"); \n\t\t}\n\t}\n\tif(runuser) {\n\t\tpw=getpwnam(runuser);\n\t\tif(!pw) {\n\t\t\tstr = g_strdup_printf(\"Invalid user name: %s\", runuser);\n\t\t\terr(str);\n\t\t}\n\t\tif(setuid(pw->pw_uid)<0) {\n\t\t\terr(\"Could not set UID: %m\");\n\t\t}\n\t}\n}\n\n#ifndef ISSERVER\nvoid glib_message_syslog_redirect(const gchar *log_domain,\n                                  GLogLevelFlags log_level,\n                                  const gchar *message,\n                                  gpointer user_data)\n{\n    int level=LOG_DEBUG;\n    \n    switch( log_level )\n    {\n      case G_LOG_FLAG_FATAL:\n      case G_LOG_LEVEL_CRITICAL:\n      case G_LOG_LEVEL_ERROR:    \n        level=LOG_ERR; \n        break;\n      case G_LOG_LEVEL_WARNING:\n        level=LOG_WARNING;\n        break;\n      case G_LOG_LEVEL_MESSAGE:\n      case G_LOG_LEVEL_INFO:\n        level=LOG_INFO;\n        break;\n      case G_LOG_LEVEL_DEBUG:\n        level=LOG_DEBUG;\n      default:\n        level=LOG_ERR;\n    }\n    syslog(level, \"%s\", message);\n}\n#endif\n\n/**\n * Main entry point...\n **/\nint main(int argc, char *argv[]) {\n\tSERVER *serve;\n\tGArray *servers;\n\tGError *err=NULL;\n\n\tif (sizeof( struct nbd_request )!=28) {\n\t\tfprintf(stderr,\"Bad size of structure. Alignment problems?\\n\");\n\t\texit(EXIT_FAILURE) ;\n\t}\n\n\tmemset(pidftemplate, '\\0', 256);\n\n\tlogging();\n\tconfig_file_pos = g_strdup(CFILE);\n\tserve=cmdline(argc, argv);\n\tservers = parse_cfile(config_file_pos, &err);\n\t\n\tif(serve) {\n\t\tserve->socket_family = AF_UNSPEC;\n\n\t\tappend_serve(serve, servers);\n     \n\t\tif (!(serve->port)) {\n\t\t\tCLIENT *client;\n#ifndef ISSERVER\n\t\t\t/* You really should define ISSERVER if you're going to use\n\t\t\t * inetd mode, but if you don't, closing stdout and stderr\n\t\t\t * (which inetd had connected to the client socket) will let it\n\t\t\t * work. */\n\t\t\tclose(1);\n\t\t\tclose(2);\n\t\t\topen(\"/dev/null\", O_WRONLY);\n\t\t\topen(\"/dev/null\", O_WRONLY);\n\t\t\tg_log_set_default_handler( glib_message_syslog_redirect, NULL );\n#endif\n\t\t\tclient=g_malloc(sizeof(CLIENT));\n\t\t\tclient->server=serve;\n\t\t\tclient->net=0;\n\t\t\tclient->exportsize=OFFT_MAX;\n\t\t\tset_peername(0,client);\n\t\t\tserveconnection(client);\n\t\t\treturn 0;\n\t\t}\n\t}\n    \n\tif(!servers || !servers->len) {\n\t\tif(err && !(err->domain == g_quark_from_string(\"parse_cfile\")\n\t\t\t\t&& err->code == CFILE_NOTFOUND)) {\n\t\t\tg_warning(\"Could not parse config file: %s\", \n\t\t\t\t\terr ? err->message : \"Unknown error\");\n\t\t}\n\t}\n\tif(serve) {\n\t\tg_warning(\"Specifying an export on the command line is deprecated.\");\n\t\tg_warning(\"Please use a configuration file instead.\");\n\t}\n\n\tif((!serve) && (!servers||!servers->len)) {\n\t\tg_message(\"No configured exports; quitting.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tdaemonize(serve);\n\tsetup_servers(servers);\n\tdousers();\n\tserveloop(servers);\n\treturn 0 ;\n}\n"], "fixing_code": ["/*\n * Network Block Device - server\n *\n * Copyright 1996-1998 Pavel Machek, distribute under GPL\n *  <pavel@atrey.karlin.mff.cuni.cz>\n * Copyright 2001-2004 Wouter Verhelst <wouter@debian.org>\n * Copyright 2002 Anton Altaparmakov <aia21@cam.ac.uk>\n *\n * Version 1.0 - hopefully 64-bit-clean\n * Version 1.1 - merging enhancements from Josh Parsons, <josh@coombs.anu.edu.au>\n * Version 1.2 - autodetect size of block devices, thanx to Peter T. Breuer\" <ptb@it.uc3m.es>\n * Version 1.5 - can compile on Unix systems that don't have 64 bit integer\n *\ttype, or don't have 64 bit file offsets by defining FS_32BIT\n *\tin compile options for nbd-server *only*. This can be done\n *\twith make FSCHOICE=-DFS_32BIT nbd-server. (I don't have the\n *\toriginal autoconf input file, or I would make it a configure\n *\toption.) Ken Yap <ken@nlc.net.au>.\n * Version 1.6 - fix autodetection of block device size and really make 64 bit\n * \tclean on 32 bit machines. Anton Altaparmakov <aia21@cam.ac.uk>\n * Version 2.0 - Version synchronised with client\n * Version 2.1 - Reap zombie client processes when they exit. Removed\n * \t(uncommented) the _IO magic, it's no longer necessary. Wouter\n * \tVerhelst <wouter@debian.org>\n * Version 2.2 - Auto switch to read-only mode (usefull for floppies).\n * Version 2.3 - Fixed code so that Large File Support works. This\n *\tremoves the FS_32BIT compile-time directive; define\n *\t_FILE_OFFSET_BITS=64 and _LARGEFILE_SOURCE if you used to be\n *\tusing FS_32BIT. This will allow you to use files >2GB instead of\n *\thaving to use the -m option. Wouter Verhelst <wouter@debian.org>\n * Version 2.4 - Added code to keep track of children, so that we can\n * \tproperly kill them from initscripts. Add a call to daemon(),\n * \tso that processes don't think they have to wait for us, which is\n * \tinteresting for initscripts as well. Wouter Verhelst\n * \t<wouter@debian.org>\n * Version 2.5 - Bugfix release: forgot to reset child_arraysize to\n *      zero after fork()ing, resulting in nbd-server going berserk\n *      when it receives a signal with at least one child open. Wouter\n *      Verhelst <wouter@debian.org>\n * 10/10/2003 - Added socket option SO_KEEPALIVE (sf.net bug 819235);\n * \trectified type of mainloop::size_host (sf.net bugs 814435 and\n * \t817385); close the PID file after writing to it, so that the\n * \tdaemon can actually be found. Wouter Verhelst\n * \t<wouter@debian.org>\n * 10/10/2003 - Size of the data \"size_host\" was wrong and so was not\n *  \tcorrectly put in network endianness. Many types were corrected\n *  \t(size_t and off_t instead of int).  <vspaceg@sourceforge.net>\n * Version 2.6 - Some code cleanup.\n * Version 2.7 - Better build system.\n * 11/02/2004 - Doxygenified the source, modularized it a bit. Needs a \n * \tlot more work, but this is a start. Wouter Verhelst\n * \t<wouter@debian.org>\n * 16/03/2010 - Add IPv6 support.\n *\tKitt Tientanopajai <kitt@kitty.in.th>\n *\tNeutron Soutmun <neo.neutron@gmail.com>\n *\tSuriya Soutmun <darksolar@gmail.com>\n */\n\n/* Includes LFS defines, which defines behaviours of some of the following\n * headers, so must come before those */\n#include \"lfs.h\"\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/select.h>\t\t/* select */\n#include <sys/wait.h>\t\t/* wait */\n#ifdef HAVE_SYS_IOCTL_H\n#include <sys/ioctl.h>\n#endif\n#include <sys/param.h>\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\t\t/* For BLKGETSIZE */\n#endif\n#include <signal.h>\t\t/* sigaction */\n#include <errno.h>\n#include <netinet/tcp.h>\n#include <netinet/in.h>\n#include <netdb.h>\n#include <syslog.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <arpa/inet.h>\n#include <strings.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <pwd.h>\n#include <grp.h>\n\n#include <glib.h>\n\n/* used in cliserv.h, so must come first */\n#define MY_NAME \"nbd_server\"\n#include \"cliserv.h\"\n\n#ifdef WITH_SDP\n#include <sdp_inet.h>\n#endif\n\n/** Default position of the config file */\n#ifndef SYSCONFDIR\n#define SYSCONFDIR \"/etc\"\n#endif\n#define CFILE SYSCONFDIR \"/nbd-server/config\"\n\n/** Where our config file actually is */\ngchar* config_file_pos;\n\n/** What user we're running as */\ngchar* runuser=NULL;\n/** What group we're running as */\ngchar* rungroup=NULL;\n/** whether to export using the old negotiation protocol (port-based) */\ngboolean do_oldstyle=FALSE;\n\n/** Logging macros, now nothing goes to syslog unless you say ISSERVER */\n#ifdef ISSERVER\n#define msg2(a,b) syslog(a,b)\n#define msg3(a,b,c) syslog(a,b,c)\n#define msg4(a,b,c,d) syslog(a,b,c,d)\n#else\n#define msg2(a,b) g_message(b)\n#define msg3(a,b,c) g_message(b,c)\n#define msg4(a,b,c,d) g_message(b,c,d)\n#endif\n\n/* Debugging macros */\n//#define DODBG\n#ifdef DODBG\n#define DEBUG( a ) printf( a )\n#define DEBUG2( a,b ) printf( a,b )\n#define DEBUG3( a,b,c ) printf( a,b,c )\n#define DEBUG4( a,b,c,d ) printf( a,b,c,d )\n#else\n#define DEBUG( a )\n#define DEBUG2( a,b ) \n#define DEBUG3( a,b,c ) \n#define DEBUG4( a,b,c,d ) \n#endif\n#ifndef PACKAGE_VERSION\n#define PACKAGE_VERSION \"\"\n#endif\n/**\n * The highest value a variable of type off_t can reach. This is a signed\n * integer, so set all bits except for the leftmost one.\n **/\n#define OFFT_MAX ~((off_t)1<<(sizeof(off_t)*8-1))\n#define LINELEN 256\t  /**< Size of static buffer used to read the\n\t\t\t       authorization file (yuck) */\n#define BUFSIZE ((1024*1024)+sizeof(struct nbd_reply)) /**< Size of buffer that can hold requests */\n#define DIFFPAGESIZE 4096 /**< diff file uses those chunks */\n#define F_READONLY 1      /**< flag to tell us a file is readonly */\n#define F_MULTIFILE 2\t  /**< flag to tell us a file is exported using -m */\n#define F_COPYONWRITE 4\t  /**< flag to tell us a file is exported using\n\t\t\t    copyonwrite */\n#define F_AUTOREADONLY 8  /**< flag to tell us a file is set to autoreadonly */\n#define F_SPARSE 16\t  /**< flag to tell us copyronwrite should use a sparse file */\n#define F_SDP 32\t  /**< flag to tell us the export should be done using the Socket Direct Protocol for RDMA */\n#define F_SYNC 64\t  /**< Whether to fsync() after a write */\nGHashTable *children;\nchar pidfname[256]; /**< name of our PID file */\nchar pidftemplate[256]; /**< template to be used for the filename of the PID file */\nchar default_authname[] = SYSCONFDIR \"/nbd-server/allow\"; /**< default name of allow file */\n\nint modernsock=0;\t  /**< Socket for the modern handler. Not used\n\t\t\t       if a client was only specified on the\n\t\t\t       command line; only port used if\n\t\t\t       oldstyle is set to false (and then the\n\t\t\t       command-line client isn't used, gna gna) */\nchar* modern_listen;\t  /**< listenaddr value for modernsock */\n\n/**\n * Types of virtuatlization\n **/\ntypedef enum {\n\tVIRT_NONE=0,\t/**< No virtualization */\n\tVIRT_IPLIT,\t/**< Literal IP address as part of the filename */\n\tVIRT_IPHASH,\t/**< Replacing all dots in an ip address by a / before\n\t\t\t     doing the same as in IPLIT */\n\tVIRT_CIDR,\t/**< Every subnet in its own directory */\n} VIRT_STYLE;\n\n/**\n * Variables associated with a server.\n **/\ntypedef struct {\n\tgchar* exportname;    /**< (unprocessed) filename of the file we're exporting */\n\toff_t expected_size; /**< size of the exported file as it was told to\n\t\t\t       us through configuration */\n\tgchar* listenaddr;   /**< The IP address we're listening on */\n\tunsigned int port;   /**< port we're exporting this file at */\n\tchar* authname;      /**< filename of the authorization file */\n\tint flags;           /**< flags associated with this exported file */\n\tint socket;\t     /**< The socket of this server. */\n\tint socket_family;   /**< family of the socket */\n\tVIRT_STYLE virtstyle;/**< The style of virtualization, if any */\n\tuint8_t cidrlen;     /**< The length of the mask when we use\n\t\t\t\t  CIDR-style virtualization */\n\tgchar* prerun;\t     /**< command to be ran after connecting a client,\n\t\t\t\t  but before starting to serve */\n\tgchar* postrun;\t     /**< command that will be ran after the client\n\t\t\t\t  disconnects */\n\tgchar* servename;    /**< name of the export as selected by nbd-client */\n\tint max_connections; /**< maximum number of opened connections */\n} SERVER;\n\n/**\n * Variables associated with a client socket.\n **/\ntypedef struct {\n\tint fhandle;      /**< file descriptor */\n\toff_t startoff;   /**< starting offset of this file */\n} FILE_INFO;\n\ntypedef struct {\n\toff_t exportsize;    /**< size of the file we're exporting */\n\tchar *clientname;    /**< peer */\n\tchar *exportname;    /**< (processed) filename of the file we're exporting */\n\tGArray *export;    /**< array of FILE_INFO of exported files;\n\t\t\t       array size is always 1 unless we're\n\t\t\t       doing the multiple file option */\n\tint net;\t     /**< The actual client socket */\n\tSERVER *server;\t     /**< The server this client is getting data from */\n\tchar* difffilename;  /**< filename of the copy-on-write file, if any */\n\tint difffile;\t     /**< filedescriptor of copyonwrite file. @todo\n\t\t\t       shouldn't this be an array too? (cfr export) Or\n\t\t\t       make -m and -c mutually exclusive */\n\tu32 difffilelen;     /**< number of pages in difffile */\n\tu32 *difmap;\t     /**< see comment on the global difmap for this one */\n\tgboolean modern;     /**< client was negotiated using modern negotiation protocol */\n} CLIENT;\n\n/**\n * Type of configuration file values\n **/\ntypedef enum {\n\tPARAM_INT,\t\t/**< This parameter is an integer */\n\tPARAM_STRING,\t\t/**< This parameter is a string */\n\tPARAM_BOOL,\t\t/**< This parameter is a boolean */\n} PARAM_TYPE;\n\n/**\n * Configuration file values\n **/\ntypedef struct {\n\tgchar *paramname;\t/**< Name of the parameter, as it appears in\n\t\t\t\t  the config file */\n\tgboolean required;\t/**< Whether this is a required (as opposed to\n\t\t\t\t  optional) parameter */\n\tPARAM_TYPE ptype;\t/**< Type of the parameter. */\n\tgpointer target;\t/**< Pointer to where the data of this\n\t\t\t\t  parameter should be written. If ptype is\n\t\t\t\t  PARAM_BOOL, the data is or'ed rather than\n\t\t\t\t  overwritten. */\n\tgint flagval;\t\t/**< Flag mask for this parameter in case ptype\n\t\t\t\t  is PARAM_BOOL. */\n} PARAM;\n\n/**\n * Check whether a client is allowed to connect. Works with an authorization\n * file which contains one line per machine, no wildcards.\n *\n * @param opts The client who's trying to connect.\n * @return 0 - authorization refused, 1 - OK\n **/\nint authorized_client(CLIENT *opts) {\n\tconst char *ERRMSG=\"Invalid entry '%s' in authfile '%s', so, refusing all connections.\";\n\tFILE *f ;\n\tchar line[LINELEN]; \n\tchar *tmp;\n\tstruct in_addr addr;\n\tstruct in_addr client;\n\tstruct in_addr cltemp;\n\tint len;\n\n\tif ((f=fopen(opts->server->authname,\"r\"))==NULL) {\n\t\tmsg4(LOG_INFO,\"Can't open authorization file %s (%s).\",\n\t\t     opts->server->authname,strerror(errno)) ;\n\t\treturn 1 ; \n\t}\n  \n  \tinet_aton(opts->clientname, &client);\n\twhile (fgets(line,LINELEN,f)!=NULL) {\n\t\tif((tmp=index(line, '/'))) {\n\t\t\tif(strlen(line)<=tmp-line) {\n\t\t\t\tmsg4(LOG_CRIT, ERRMSG, line, opts->server->authname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t*(tmp++)=0;\n\t\t\tif(!inet_aton(line,&addr)) {\n\t\t\t\tmsg4(LOG_CRIT, ERRMSG, line, opts->server->authname);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tlen=strtol(tmp, NULL, 0);\n\t\t\taddr.s_addr>>=32-len;\n\t\t\taddr.s_addr<<=32-len;\n\t\t\tmemcpy(&cltemp,&client,sizeof(client));\n\t\t\tcltemp.s_addr>>=32-len;\n\t\t\tcltemp.s_addr<<=32-len;\n\t\t\tif(addr.s_addr == cltemp.s_addr) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (strncmp(line,opts->clientname,strlen(opts->clientname))==0) {\n\t\t\tfclose(f);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tfclose(f);\n\treturn 0;\n}\n\n/**\n * Read data from a file descriptor into a buffer\n *\n * @param f a file descriptor\n * @param buf a buffer\n * @param len the number of bytes to be read\n **/\ninline void readit(int f, void *buf, size_t len) {\n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"*\");\n\t\tif ((res = read(f, buf, len)) <= 0) {\n\t\t\tif(errno != EAGAIN) {\n\t\t\t\terr(\"Read failed: %m\");\n\t\t\t}\n\t\t} else {\n\t\t\tlen -= res;\n\t\t\tbuf += res;\n\t\t}\n\t}\n}\n\n/**\n * Write data from a buffer into a filedescriptor\n *\n * @param f a file descriptor\n * @param buf a buffer containing data\n * @param len the number of bytes to be written\n **/\ninline void writeit(int f, void *buf, size_t len) {\n\tssize_t res;\n\twhile (len > 0) {\n\t\tDEBUG(\"+\");\n\t\tif ((res = write(f, buf, len)) <= 0)\n\t\t\terr(\"Send failed: %m\");\n\t\tlen -= res;\n\t\tbuf += res;\n\t}\n}\n\n/**\n * Print out a message about how to use nbd-server. Split out to a separate\n * function so that we can call it from multiple places\n */\nvoid usage() {\n\tprintf(\"This is nbd-server version \" VERSION \"\\n\");\n\tprintf(\"Usage: [ip:|ip6@]port file_to_export [size][kKmM] [-l authorize_file] [-r] [-m] [-c] [-C configuration file] [-p PID file name] [-o section name] [-M max connections]\\n\"\n\t       \"\\t-r|--read-only\\t\\tread only\\n\"\n\t       \"\\t-m|--multi-file\\t\\tmultiple file\\n\"\n\t       \"\\t-c|--copy-on-write\\tcopy on write\\n\"\n\t       \"\\t-C|--config-file\\tspecify an alternate configuration file\\n\"\n\t       \"\\t-l|--authorize-file\\tfile with list of hosts that are allowed to\\n\\t\\t\\t\\tconnect.\\n\"\n\t       \"\\t-p|--pid-file\\t\\tspecify a filename to write our PID to\\n\"\n\t       \"\\t-o|--output-config\\toutput a config file section for what you\\n\\t\\t\\t\\tspecified on the command line, with the\\n\\t\\t\\t\\tspecified section name\\n\"\n\t       \"\\t-M|--max-connections\\tspecify the maximum number of opened connections\\n\\n\"\n\t       \"\\tif port is set to 0, stdin is used (for running from inetd)\\n\"\n\t       \"\\tif file_to_export contains '%%s', it is substituted with the IP\\n\"\n\t       \"\\t\\taddress of the machine trying to connect\\n\" \n\t       \"\\tif ip is set, it contains the local IP address on which we're listening.\\n\\tif not, the server will listen on all local IP addresses\\n\");\n\tprintf(\"Using configuration file %s\\n\", CFILE);\n}\n\n/* Dumps a config file section of the given SERVER*, and exits. */\nvoid dump_section(SERVER* serve, gchar* section_header) {\n\tprintf(\"[%s]\\n\", section_header);\n\tprintf(\"\\texportname = %s\\n\", serve->exportname);\n\tprintf(\"\\tlistenaddr = %s\\n\", serve->listenaddr);\n\tprintf(\"\\tport = %d\\n\", serve->port);\n\tif(serve->flags & F_READONLY) {\n\t\tprintf(\"\\treadonly = true\\n\");\n\t}\n\tif(serve->flags & F_MULTIFILE) {\n\t\tprintf(\"\\tmultifile = true\\n\");\n\t}\n\tif(serve->flags & F_COPYONWRITE) {\n\t\tprintf(\"\\tcopyonwrite = true\\n\");\n\t}\n\tif(serve->expected_size) {\n\t\tprintf(\"\\tfilesize = %lld\\n\", (long long int)serve->expected_size);\n\t}\n\tif(serve->authname) {\n\t\tprintf(\"\\tauthfile = %s\\n\", serve->authname);\n\t}\n\texit(EXIT_SUCCESS);\n}\n\n/**\n * Parse the command line.\n *\n * @param argc the argc argument to main()\n * @param argv the argv argument to main()\n **/\nSERVER* cmdline(int argc, char *argv[]) {\n\tint i=0;\n\tint nonspecial=0;\n\tint c;\n\tstruct option long_options[] = {\n\t\t{\"read-only\", no_argument, NULL, 'r'},\n\t\t{\"multi-file\", no_argument, NULL, 'm'},\n\t\t{\"copy-on-write\", no_argument, NULL, 'c'},\n\t\t{\"authorize-file\", required_argument, NULL, 'l'},\n\t\t{\"config-file\", required_argument, NULL, 'C'},\n\t\t{\"pid-file\", required_argument, NULL, 'p'},\n\t\t{\"output-config\", required_argument, NULL, 'o'},\n\t\t{\"max-connection\", required_argument, NULL, 'M'},\n\t\t{0,0,0,0}\n\t};\n\tSERVER *serve;\n\toff_t es;\n\tsize_t last;\n\tchar suffix;\n\tgboolean do_output=FALSE;\n\tgchar* section_header=\"\";\n\tgchar** addr_port;\n\n\tif(argc==1) {\n\t\treturn NULL;\n\t}\n\tserve=g_new0(SERVER, 1);\n\tserve->authname = g_strdup(default_authname);\n\tserve->virtstyle=VIRT_IPLIT;\n\twhile((c=getopt_long(argc, argv, \"-C:cl:mo:rp:M:\", long_options, &i))>=0) {\n\t\tswitch (c) {\n\t\tcase 1:\n\t\t\t/* non-option argument */\n\t\t\tswitch(nonspecial++) {\n\t\t\tcase 0:\n\t\t\t\tif(strchr(optarg, ':') == strrchr(optarg, ':')) {\n\t\t\t\t\taddr_port=g_strsplit(optarg, \":\", 2);\n\n\t\t\t\t\t/* Check for \"@\" - maybe user using this separator\n\t\t\t\t\t\t for IPv4 address */\n\t\t\t\t\tif(!addr_port[1]) {\n\t\t\t\t\t\tg_strfreev(addr_port);\n\t\t\t\t\t\taddr_port=g_strsplit(optarg, \"@\", 2);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\taddr_port=g_strsplit(optarg, \"@\", 2);\n\t\t\t\t}\n\n\t\t\t\tif(addr_port[1]) {\n\t\t\t\t\tserve->port=strtol(addr_port[1], NULL, 0);\n\t\t\t\t\tserve->listenaddr=g_strdup(addr_port[0]);\n\t\t\t\t} else {\n\t\t\t\t\tserve->listenaddr=NULL;\n\t\t\t\t\tserve->port=strtol(addr_port[0], NULL, 0);\n\t\t\t\t}\n\t\t\t\tg_strfreev(addr_port);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tserve->exportname = g_strdup(optarg);\n\t\t\t\tif(serve->exportname[0] != '/') {\n\t\t\t\t\tfprintf(stderr, \"E: The to be exported file needs to be an absolute filename!\\n\");\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\tlast=strlen(optarg)-1;\n\t\t\t\tsuffix=optarg[last];\n\t\t\t\tif (suffix == 'k' || suffix == 'K' ||\n\t\t\t\t    suffix == 'm' || suffix == 'M')\n\t\t\t\t\toptarg[last] = '\\0';\n\t\t\t\tes = (off_t)atoll(optarg);\n\t\t\t\tswitch (suffix) {\n\t\t\t\t\tcase 'm':\n\t\t\t\t\tcase 'M':  es <<= 10;\n\t\t\t\t\tcase 'k':\n\t\t\t\t\tcase 'K':  es <<= 10;\n\t\t\t\t\tdefault :  break;\n\t\t\t\t}\n\t\t\t\tserve->expected_size = es;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tserve->flags |= F_READONLY;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tserve->flags |= F_MULTIFILE;\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tdo_output = TRUE;\n\t\t\tsection_header = g_strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\tstrncpy(pidftemplate, optarg, 256);\n\t\t\tbreak;\n\t\tcase 'c': \n\t\t\tserve->flags |=F_COPYONWRITE;\n\t\t        break;\n\t\tcase 'C':\n\t\t\tg_free(config_file_pos);\n\t\t\tconfig_file_pos=g_strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\tg_free(serve->authname);\n\t\t\tserve->authname=g_strdup(optarg);\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tserve->max_connections = strtol(optarg, NULL, 0);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\texit(EXIT_FAILURE);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* What's left: the port to export, the name of the to be exported\n\t * file, and, optionally, the size of the file, in that order. */\n\tif(nonspecial<2) {\n\t\tg_free(serve);\n\t\tserve=NULL;\n\t} else {\n\t\tdo_oldstyle = TRUE;\n\t}\n\tif(do_output) {\n\t\tif(!serve) {\n\t\t\tg_critical(\"Need a complete configuration on the command line to output a config file section!\");\n\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tdump_section(serve, section_header);\n\t}\n\treturn serve;\n}\n\n/**\n * Error codes for config file parsing\n **/\ntypedef enum {\n\tCFILE_NOTFOUND,\t\t/**< The configuration file is not found */\n\tCFILE_MISSING_GENERIC,\t/**< The (required) group \"generic\" is missing */\n\tCFILE_KEY_MISSING,\t/**< A (required) key is missing */\n\tCFILE_VALUE_INVALID,\t/**< A value is syntactically invalid */\n\tCFILE_VALUE_UNSUPPORTED,/**< A value is not supported in this build */\n\tCFILE_PROGERR,\t\t/**< Programmer error */\n\tCFILE_NO_EXPORTS,\t/**< A config file was specified that does not\n\t\t\t\t     define any exports */\n\tCFILE_INCORRECT_PORT,\t/**< The reserved port was specified for an\n\t\t\t\t     old-style export. */\n} CFILE_ERRORS;\n\n/**\n * Remove a SERVER from memory. Used from the hash table\n **/\nvoid remove_server(gpointer s) {\n\tSERVER *server;\n\n\tserver=(SERVER*)s;\n\tg_free(server->exportname);\n\tif(server->authname)\n\t\tg_free(server->authname);\n\tif(server->listenaddr)\n\t\tg_free(server->listenaddr);\n\tif(server->prerun)\n\t\tg_free(server->prerun);\n\tif(server->postrun)\n\t\tg_free(server->postrun);\n\tg_free(server);\n}\n\n/**\n * duplicate server\n * @param s the old server we want to duplicate\n * @return new duplicated server\n **/\nSERVER* dup_serve(SERVER *s) {\n\tSERVER *serve = NULL;\n\n\tserve=g_new0(SERVER, 1);\n\tif(serve == NULL)\n\t\treturn NULL;\n\n\tif(s->exportname)\n\t\tserve->exportname = g_strdup(s->exportname);\n\n\tserve->expected_size = s->expected_size;\n\n\tif(s->listenaddr)\n\t\tserve->listenaddr = g_strdup(s->listenaddr);\n\n\tserve->port = s->port;\n\n\tif(s->authname)\n\t\tserve->authname = strdup(s->authname);\n\n\tserve->flags = s->flags;\n\tserve->socket = serve->socket;\n\tserve->socket_family = serve->socket_family;\n\tserve->cidrlen = s->cidrlen;\n\n\tif(s->prerun)\n\t\tserve->prerun = g_strdup(s->prerun);\n\n\tif(s->postrun)\n\t\tserve->postrun = g_strdup(s->postrun);\n\t\n\tif(s->servename)\n\t\tserve->servename = g_strdup(s->servename);\n\n\tserve->max_connections = s->max_connections;\n\n\treturn serve;\n}\n\n/**\n * append new server to array\n * @param s server\n * @param a server array\n * @return 0 success, -1 error\n */\nint append_serve(SERVER *s, GArray *a) {\n\tSERVER *ns = NULL;\n\tstruct addrinfo hints;\n\tstruct addrinfo *ai = NULL;\n\tstruct addrinfo *rp = NULL;\n\tchar   host[NI_MAXHOST];\n\tgchar  *port = NULL;\n\tint e;\n\tint ret;\n\n\tif(!s) {\n\t\terr(\"Invalid parsing server\");\n\t\treturn -1;\n\t}\n\n\tport = g_strdup_printf(\"%d\", s->port);\n\n\tmemset(&hints,'\\0',sizeof(hints));\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_ADDRCONFIG | AI_PASSIVE;\n\thints.ai_protocol = IPPROTO_TCP;\n\n\te = getaddrinfo(s->listenaddr, port, &hints, &ai);\n\n\tif (port)\n\t\tg_free(port);\n\n\tif(e == 0) {\n\t\tfor (rp = ai; rp != NULL; rp = rp->ai_next) {\n\t\t\te = getnameinfo(rp->ai_addr, rp->ai_addrlen, host, sizeof(host), NULL, 0, NI_NUMERICHOST);\n\n\t\t\tif (e != 0) { // error\n\t\t\t\tfprintf(stderr, \"getnameinfo: %s\\n\", gai_strerror(e));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// duplicate server and set listenaddr to resolved IP address\n\t\t\tns = dup_serve (s);\n\t\t\tif (ns) {\n\t\t\t\tns->listenaddr = g_strdup(host);\n\t\t\t\tns->socket_family = rp->ai_family;\n\t\t\t\tg_array_append_val(a, *ns);\n\t\t\t\tfree(ns);\n\t\t\t\tns = NULL;\n\t\t\t}\n\t\t}\n\n\t\tret = 0;\n\t} else {\n\t\tfprintf(stderr, \"getaddrinfo failed on listen host/address: %s (%s)\\n\", s->listenaddr ? s->listenaddr : \"any\", gai_strerror(e));\n\t\tret = -1;\n\t}\n\n\tif (ai)\n\t\tfreeaddrinfo(ai);\n\n\treturn ret;\n}\n\n/**\n * Parse the config file.\n *\n * @param f the name of the config file\n * @param e a GError. @see CFILE_ERRORS for what error values this function can\n * \treturn.\n * @return a Array of SERVER* pointers, If the config file is empty or does not\n *\texist, returns an empty GHashTable; if the config file contains an\n *\terror, returns NULL, and e is set appropriately\n **/\nGArray* parse_cfile(gchar* f, GError** e) {\n\tconst char* DEFAULT_ERROR = \"Could not parse %s in group %s: %s\";\n\tconst char* MISSING_REQUIRED_ERROR = \"Could not find required value %s in group %s: %s\";\n\tSERVER s;\n\tgchar *virtstyle=NULL;\n\tPARAM lp[] = {\n\t\t{ \"exportname\", TRUE,\tPARAM_STRING, \tNULL, 0 },\n\t\t{ \"port\", \tTRUE,\tPARAM_INT, \tNULL, 0 },\n\t\t{ \"authfile\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"filesize\",\tFALSE,\tPARAM_INT,\tNULL, 0 },\n\t\t{ \"virtstyle\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"prerun\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"postrun\",\tFALSE,\tPARAM_STRING,\tNULL, 0 },\n\t\t{ \"readonly\",\tFALSE,\tPARAM_BOOL,\tNULL, F_READONLY },\n\t\t{ \"multifile\",\tFALSE,\tPARAM_BOOL,\tNULL, F_MULTIFILE },\n\t\t{ \"copyonwrite\", FALSE,\tPARAM_BOOL,\tNULL, F_COPYONWRITE },\n\t\t{ \"sparse_cow\",\tFALSE,\tPARAM_BOOL,\tNULL, F_SPARSE },\n\t\t{ \"sdp\",\tFALSE,\tPARAM_BOOL,\tNULL, F_SDP },\n\t\t{ \"sync\",\tFALSE,  PARAM_BOOL,\tNULL, F_SYNC },\n\t\t{ \"listenaddr\", FALSE,  PARAM_STRING,   NULL, 0 },\n\t\t{ \"maxconnections\", FALSE, PARAM_INT,\tNULL, 0 },\n\t};\n\tconst int lp_size=sizeof(lp)/sizeof(PARAM);\n\tPARAM gp[] = {\n\t\t{ \"user\",\tFALSE, PARAM_STRING,\t&runuser,\t0 },\n\t\t{ \"group\",\tFALSE, PARAM_STRING,\t&rungroup,\t0 },\n\t\t{ \"oldstyle\",\tFALSE, PARAM_BOOL,\t&do_oldstyle,\t1 },\n\t\t{ \"listenaddr\", FALSE, PARAM_STRING,\t&modern_listen, 0 },\n\t};\n\tPARAM* p=gp;\n\tint p_size=sizeof(gp)/sizeof(PARAM);\n\tGKeyFile *cfile;\n\tGError *err = NULL;\n\tconst char *err_msg=NULL;\n\tGQuark errdomain;\n\tGArray *retval=NULL;\n\tgchar **groups;\n\tgboolean value;\n\tgchar* startgroup;\n\tgint i;\n\tgint j;\n\n\terrdomain = g_quark_from_string(\"parse_cfile\");\n\tcfile = g_key_file_new();\n\tretval = g_array_new(FALSE, TRUE, sizeof(SERVER));\n\tif(!g_key_file_load_from_file(cfile, f, G_KEY_FILE_KEEP_COMMENTS |\n\t\t\tG_KEY_FILE_KEEP_TRANSLATIONS, &err)) {\n\t\tg_set_error(e, errdomain, CFILE_NOTFOUND, \"Could not open config file %s.\", f);\n\t\tg_key_file_free(cfile);\n\t\treturn retval;\n\t}\n\tstartgroup = g_key_file_get_start_group(cfile);\n\tif(!startgroup || strcmp(startgroup, \"generic\")) {\n\t\tg_set_error(e, errdomain, CFILE_MISSING_GENERIC, \"Config file does not contain the [generic] group!\");\n\t\tg_key_file_free(cfile);\n\t\treturn NULL;\n\t}\n\tgroups = g_key_file_get_groups(cfile, NULL);\n\tfor(i=0;groups[i];i++) {\n\t\tmemset(&s, '\\0', sizeof(SERVER));\n\t\tlp[0].target=&(s.exportname);\n\t\tlp[1].target=&(s.port);\n\t\tlp[2].target=&(s.authname);\n\t\tlp[3].target=&(s.expected_size);\n\t\tlp[4].target=&(virtstyle);\n\t\tlp[5].target=&(s.prerun);\n\t\tlp[6].target=&(s.postrun);\n\t\tlp[7].target=lp[8].target=lp[9].target=\n\t\t\t\tlp[10].target=lp[11].target=\n\t\t\t\tlp[12].target=&(s.flags);\n\t\tlp[13].target=&(s.listenaddr);\n\t\tlp[14].target=&(s.max_connections);\n\n\t\t/* After the [generic] group, start parsing exports */\n\t\tif(i==1) {\n\t\t\tp=lp;\n\t\t\tp_size=lp_size;\n\t\t} \n\t\tfor(j=0;j<p_size;j++) {\n\t\t\tg_assert(p[j].target != NULL);\n\t\t\tg_assert(p[j].ptype==PARAM_INT||p[j].ptype==PARAM_STRING||p[j].ptype==PARAM_BOOL);\n\t\t\tswitch(p[j].ptype) {\n\t\t\t\tcase PARAM_INT:\n\t\t\t\t\t*((gint*)p[j].target) =\n\t\t\t\t\t\tg_key_file_get_integer(cfile,\n\t\t\t\t\t\t\t\tgroups[i],\n\t\t\t\t\t\t\t\tp[j].paramname,\n\t\t\t\t\t\t\t\t&err);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_STRING:\n\t\t\t\t\t*((gchar**)p[j].target) =\n\t\t\t\t\t\tg_key_file_get_string(cfile,\n\t\t\t\t\t\t\t\tgroups[i],\n\t\t\t\t\t\t\t\tp[j].paramname,\n\t\t\t\t\t\t\t\t&err);\n\t\t\t\t\tbreak;\n\t\t\t\tcase PARAM_BOOL:\n\t\t\t\t\tvalue = g_key_file_get_boolean(cfile,\n\t\t\t\t\t\t\tgroups[i],\n\t\t\t\t\t\t\tp[j].paramname, &err);\n\t\t\t\t\tif(!err) {\n\t\t\t\t\t\tif(value) {\n\t\t\t\t\t\t\t*((gint*)p[j].target) |= p[j].flagval;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t*((gint*)p[j].target) &= ~(p[j].flagval);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(!strcmp(p[j].paramname, \"port\") && !strcmp(p[j].target, NBD_DEFAULT_PORT)) {\n\t\t\t\tg_set_error(e, errdomain, CFILE_INCORRECT_PORT, \"Config file specifies default port for oldstyle export\");\n\t\t\t\tg_key_file_free(cfile);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif(err) {\n\t\t\t\tif(err->code == G_KEY_FILE_ERROR_KEY_NOT_FOUND) {\n\t\t\t\t\tif(!p[j].required) {\n\t\t\t\t\t\t/* Ignore not-found error for optional values */\n\t\t\t\t\t\tg_clear_error(&err);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else {\n\t\t\t\t\t\terr_msg = MISSING_REQUIRED_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\terr_msg = DEFAULT_ERROR;\n\t\t\t\t}\n\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, err_msg, p[j].paramname, groups[i], err->message);\n\t\t\t\tg_array_free(retval, TRUE);\n\t\t\t\tg_error_free(err);\n\t\t\t\tg_key_file_free(cfile);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tif(virtstyle) {\n\t\t\tif(!strncmp(virtstyle, \"none\", 4)) {\n\t\t\t\ts.virtstyle=VIRT_NONE;\n\t\t\t} else if(!strncmp(virtstyle, \"ipliteral\", 9)) {\n\t\t\t\ts.virtstyle=VIRT_IPLIT;\n\t\t\t} else if(!strncmp(virtstyle, \"iphash\", 6)) {\n\t\t\t\ts.virtstyle=VIRT_IPHASH;\n\t\t\t} else if(!strncmp(virtstyle, \"cidrhash\", 8)) {\n\t\t\t\ts.virtstyle=VIRT_CIDR;\n\t\t\t\tif(strlen(virtstyle)<10) {\n\t\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, \"Invalid value %s for parameter virtstyle in group %s: missing length\", virtstyle, groups[i]);\n\t\t\t\t\tg_array_free(retval, TRUE);\n\t\t\t\t\tg_key_file_free(cfile);\n\t\t\t\t\treturn NULL;\n\t\t\t\t}\n\t\t\t\ts.cidrlen=strtol(virtstyle+8, NULL, 0);\n\t\t\t} else {\n\t\t\t\tg_set_error(e, errdomain, CFILE_VALUE_INVALID, \"Invalid value %s for parameter virtstyle in group %s\", virtstyle, groups[i]);\n\t\t\t\tg_array_free(retval, TRUE);\n\t\t\t\tg_key_file_free(cfile);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif(s.port && !do_oldstyle) {\n\t\t\t\tg_warning(\"A port was specified, but oldstyle exports were not requested. This may not do what you expect.\");\n\t\t\t\tg_warning(\"Please read 'man 5 nbd-server' and search for oldstyle for more info\");\n\t\t\t}\n\t\t} else {\n\t\t\ts.virtstyle=VIRT_IPLIT;\n\t\t}\n\t\t/* Don't need to free this, it's not our string */\n\t\tvirtstyle=NULL;\n\t\t/* Don't append values for the [generic] group */\n\t\tif(i>0) {\n\t\t\ts.socket_family = AF_UNSPEC;\n\t\t\ts.servename = groups[i];\n\n\t\t\tappend_serve(&s, retval);\n\t\t} else {\n\t\t\tif(!do_oldstyle) {\n\t\t\t\tlp[1].required = 0;\n\t\t\t}\n\t\t}\n#ifndef WITH_SDP\n\t\tif(s.flags & F_SDP) {\n\t\t\tg_set_error(e, errdomain, CFILE_VALUE_UNSUPPORTED, \"This nbd-server was built without support for SDP, yet group %s uses it\", groups[i]);\n\t\t\tg_array_free(retval, TRUE);\n\t\t\tg_key_file_free(cfile);\n\t\t\treturn NULL;\n\t\t}\n#endif\n\t}\n\tif(i==1) {\n\t\tg_set_error(e, errdomain, CFILE_NO_EXPORTS, \"The config file does not specify any exports\");\n\t}\n\tg_key_file_free(cfile);\n\treturn retval;\n}\n\n/**\n * Signal handler for SIGCHLD\n * @param s the signal we're handling (must be SIGCHLD, or something\n * is severely wrong)\n **/\nvoid sigchld_handler(int s) {\n        int status;\n\tint* i;\n\tpid_t pid;\n\n\twhile((pid=waitpid(-1, &status, WNOHANG)) > 0) {\n\t\tif(WIFEXITED(status)) {\n\t\t\tmsg3(LOG_INFO, \"Child exited with %d\", WEXITSTATUS(status));\n\t\t}\n\t\ti=g_hash_table_lookup(children, &pid);\n\t\tif(!i) {\n\t\t\tmsg3(LOG_INFO, \"SIGCHLD received for an unknown child with PID %ld\", (long)pid);\n\t\t} else {\n\t\t\tDEBUG2(\"Removing %d from the list of children\", pid);\n\t\t\tg_hash_table_remove(children, &pid);\n\t\t}\n\t}\n}\n\n/**\n * Kill a child. Called from sigterm_handler::g_hash_table_foreach.\n *\n * @param key the key\n * @param value the value corresponding to the above key\n * @param user_data a pointer which we always set to 1, so that we know what\n * will happen next.\n **/\nvoid killchild(gpointer key, gpointer value, gpointer user_data) {\n\tpid_t *pid=value;\n\tint *parent=user_data;\n\n\tkill(*pid, SIGTERM);\n\t*parent=1;\n}\n\n/**\n * Handle SIGTERM and dispatch it to our children\n * @param s the signal we're handling (must be SIGTERM, or something\n * is severely wrong).\n **/\nvoid sigterm_handler(int s) {\n\tint parent=0;\n\n\tg_hash_table_foreach(children, killchild, &parent);\n\n\tif(parent) {\n\t\tunlink(pidfname);\n\t}\n\n\texit(EXIT_SUCCESS);\n}\n\n/**\n * Detect the size of a file.\n *\n * @param fhandle An open filedescriptor\n * @return the size of the file, or OFFT_MAX if detection was\n * impossible.\n **/\noff_t size_autodetect(int fhandle) {\n\toff_t es;\n\tu64 bytes;\n\tstruct stat stat_buf;\n\tint error;\n\n#ifdef HAVE_SYS_MOUNT_H\n#ifdef HAVE_SYS_IOCTL_H\n#ifdef BLKGETSIZE64\n\tDEBUG(\"looking for export size with ioctl BLKGETSIZE64\\n\");\n\tif (!ioctl(fhandle, BLKGETSIZE64, &bytes) && bytes) {\n\t\treturn (off_t)bytes;\n\t}\n#endif /* BLKGETSIZE64 */\n#endif /* HAVE_SYS_IOCTL_H */\n#endif /* HAVE_SYS_MOUNT_H */\n\n\tDEBUG(\"looking for fhandle size with fstat\\n\");\n\tstat_buf.st_size = 0;\n\terror = fstat(fhandle, &stat_buf);\n\tif (!error) {\n\t\tif(stat_buf.st_size > 0)\n\t\t\treturn (off_t)stat_buf.st_size;\n        } else {\n                err(\"fstat failed: %m\");\n        }\n\n\tDEBUG(\"looking for fhandle size with lseek SEEK_END\\n\");\n\tes = lseek(fhandle, (off_t)0, SEEK_END);\n\tif (es > ((off_t)0)) {\n\t\treturn es;\n        } else {\n                DEBUG2(\"lseek failed: %d\", errno==EBADF?1:(errno==ESPIPE?2:(errno==EINVAL?3:4)));\n        }\n\n\terr(\"Could not find size of exported block device: %m\");\n\treturn OFFT_MAX;\n}\n\n/**\n * Get the file handle and offset, given an export offset.\n *\n * @param export An array of export files\n * @param a The offset to get corresponding file/offset for\n * @param fhandle [out] File descriptor\n * @param foffset [out] Offset into fhandle\n * @param maxbytes [out] Tells how many bytes can be read/written\n * from fhandle starting at foffset (0 if there is no limit)\n * @return 0 on success, -1 on failure\n **/\nint get_filepos(GArray* export, off_t a, int* fhandle, off_t* foffset, size_t* maxbytes ) {\n\t/* Negative offset not allowed */\n\tif(a < 0)\n\t\treturn -1;\n\n\t/* Binary search for last file with starting offset <= a */\n\tFILE_INFO fi;\n\tint start = 0;\n\tint end = export->len - 1;\n\twhile( start <= end ) {\n\t\tint mid = (start + end) / 2;\n\t\tfi = g_array_index(export, FILE_INFO, mid);\n\t\tif( fi.startoff < a ) {\n\t\t\tstart = mid + 1;\n\t\t} else if( fi.startoff > a ) {\n\t\t\tend = mid - 1;\n\t\t} else {\n\t\t\tstart = end = mid;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* end should never go negative, since first startoff is 0 and a >= 0 */\n\tg_assert(end >= 0);\n\n\tfi = g_array_index(export, FILE_INFO, end);\n\t*fhandle = fi.fhandle;\n\t*foffset = a - fi.startoff;\n\t*maxbytes = 0;\n\tif( end+1 < export->len ) {\n\t\tFILE_INFO fi_next = g_array_index(export, FILE_INFO, end+1);\n\t\t*maxbytes = fi_next.startoff - a;\n\t}\n\n\treturn 0;\n}\n\n/**\n * seek to a position in a file, with error handling.\n * @param handle a filedescriptor\n * @param a position to seek to\n * @todo get rid of this; lastpoint is a global variable right now, but it\n * shouldn't be. If we pass it on as a parameter, that makes things a *lot*\n * easier.\n **/\nvoid myseek(int handle,off_t a) {\n\tif (lseek(handle, a, SEEK_SET) < 0) {\n\t\terr(\"Can not seek locally!\\n\");\n\t}\n}\n\n/**\n * Write an amount of bytes at a given offset to the right file. This\n * abstracts the write-side of the multiple file option.\n *\n * @param a The offset where the write should start\n * @param buf The buffer to write from\n * @param len The length of buf\n * @param client The client we're serving for\n * @return The number of bytes actually written, or -1 in case of an error\n **/\nssize_t rawexpwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n\tint fhandle;\n\toff_t foffset;\n\tsize_t maxbytes;\n\tssize_t retval;\n\n\tif(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))\n\t\treturn -1;\n\tif(maxbytes && len > maxbytes)\n\t\tlen = maxbytes;\n\n\tDEBUG4(\"(WRITE to fd %d offset %llu len %u), \", fhandle, foffset, len);\n\n\tmyseek(fhandle, foffset);\n\tretval = write(fhandle, buf, len);\n\tif(client->server->flags & F_SYNC) {\n\t\tfsync(fhandle);\n\t}\n\treturn retval;\n}\n\n/**\n * Call rawexpwrite repeatedly until all data has been written.\n * @return 0 on success, nonzero on failure\n **/\nint rawexpwrite_fully(off_t a, char *buf, size_t len, CLIENT *client) {\n\tssize_t ret=0;\n\n\twhile(len > 0 && (ret=rawexpwrite(a, buf, len, client)) > 0 ) {\n\t\ta += ret;\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret < 0 || len != 0);\n}\n\n/**\n * Read an amount of bytes at a given offset from the right file. This\n * abstracts the read-side of the multiple files option.\n *\n * @param a The offset where the read should start\n * @param buf A buffer to read into\n * @param len The size of buf\n * @param client The client we're serving for\n * @return The number of bytes actually read, or -1 in case of an\n * error.\n **/\nssize_t rawexpread(off_t a, char *buf, size_t len, CLIENT *client) {\n\tint fhandle;\n\toff_t foffset;\n\tsize_t maxbytes;\n\n\tif(get_filepos(client->export, a, &fhandle, &foffset, &maxbytes))\n\t\treturn -1;\n\tif(maxbytes && len > maxbytes)\n\t\tlen = maxbytes;\n\n\tDEBUG4(\"(READ from fd %d offset %llu len %u), \", fhandle, foffset, len);\n\n\tmyseek(fhandle, foffset);\n\treturn read(fhandle, buf, len);\n}\n\n/**\n * Call rawexpread repeatedly until all data has been read.\n * @return 0 on success, nonzero on failure\n **/\nint rawexpread_fully(off_t a, char *buf, size_t len, CLIENT *client) {\n\tssize_t ret=0;\n\n\twhile(len > 0 && (ret=rawexpread(a, buf, len, client)) > 0 ) {\n\t\ta += ret;\n\t\tbuf += ret;\n\t\tlen -= ret;\n\t}\n\treturn (ret < 0 || len != 0);\n}\n\n/**\n * Read an amount of bytes at a given offset from the right file. This\n * abstracts the read-side of the copyonwrite stuff, and calls\n * rawexpread() with the right parameters to do the actual work.\n * @param a The offset where the read should start\n * @param buf A buffer to read into\n * @param len The size of buf\n * @param client The client we're going to read for\n * @return 0 on success, nonzero on failure\n **/\nint expread(off_t a, char *buf, size_t len, CLIENT *client) {\n\toff_t rdlen, offset;\n\toff_t mapcnt, mapl, maph, pagestart;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn(rawexpread_fully(a, buf, len, client));\n\tDEBUG3(\"Asked to read %d bytes at %llu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE; maph=(a+len-1)/DIFFPAGESIZE;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE;\n\t\toffset=a-pagestart;\n\t\trdlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %llu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\tmyseek(client->difffile, client->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (read(client->difffile, buf, rdlen) != rdlen) return -1;\n\t\t} else { /* the block is not there */\n\t\t\tDEBUG2(\"Page %llu is not here, we read the original one\\n\",\n\t\t\t       (unsigned long long)mapcnt);\n\t\t\tif(rawexpread_fully(a, buf, rdlen, client)) return -1;\n\t\t}\n\t\tlen-=rdlen; a+=rdlen; buf+=rdlen;\n\t}\n\treturn 0;\n}\n\n/**\n * Write an amount of bytes at a given offset to the right file. This\n * abstracts the write-side of the copyonwrite option, and calls\n * rawexpwrite() with the right parameters to do the actual work.\n *\n * @param a The offset where the write should start\n * @param buf The buffer to write from\n * @param len The length of buf\n * @param client The client we're going to write for.\n * @return 0 on success, nonzero on failure\n **/\nint expwrite(off_t a, char *buf, size_t len, CLIENT *client) {\n\tchar pagebuf[DIFFPAGESIZE];\n\toff_t mapcnt,mapl,maph;\n\toff_t wrlen,rdlen; \n\toff_t pagestart;\n\toff_t offset;\n\n\tif (!(client->server->flags & F_COPYONWRITE))\n\t\treturn(rawexpwrite_fully(a, buf, len, client)); \n\tDEBUG3(\"Asked to write %d bytes at %llu.\\n\", len, (unsigned long long)a);\n\n\tmapl=a/DIFFPAGESIZE ; maph=(a+len-1)/DIFFPAGESIZE ;\n\n\tfor (mapcnt=mapl;mapcnt<=maph;mapcnt++) {\n\t\tpagestart=mapcnt*DIFFPAGESIZE ;\n\t\toffset=a-pagestart ;\n\t\twrlen=(0<DIFFPAGESIZE-offset && len<(size_t)(DIFFPAGESIZE-offset)) ?\n\t\t\tlen : (size_t)DIFFPAGESIZE-offset;\n\n\t\tif (client->difmap[mapcnt]!=(u32)(-1)) { /* the block is already there */\n\t\t\tDEBUG3(\"Page %llu is at %lu\\n\", (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt])) ;\n\t\t\tmyseek(client->difffile,\n\t\t\t\t\tclient->difmap[mapcnt]*DIFFPAGESIZE+offset);\n\t\t\tif (write(client->difffile, buf, wrlen) != wrlen) return -1 ;\n\t\t} else { /* the block is not there */\n\t\t\tmyseek(client->difffile,client->difffilelen*DIFFPAGESIZE) ;\n\t\t\tclient->difmap[mapcnt]=(client->server->flags&F_SPARSE)?mapcnt:client->difffilelen++;\n\t\t\tDEBUG3(\"Page %llu is not here, we put it at %lu\\n\",\n\t\t\t       (unsigned long long)mapcnt,\n\t\t\t       (unsigned long)(client->difmap[mapcnt]));\n\t\t\trdlen=DIFFPAGESIZE ;\n\t\t\tif (rawexpread_fully(pagestart, pagebuf, rdlen, client))\n\t\t\t\treturn -1;\n\t\t\tmemcpy(pagebuf+offset,buf,wrlen) ;\n\t\t\tif (write(client->difffile, pagebuf, DIFFPAGESIZE) !=\n\t\t\t\t\tDIFFPAGESIZE)\n\t\t\t\treturn -1;\n\t\t}\t\t\t\t\t\t    \n\t\tlen-=wrlen ; a+=wrlen ; buf+=wrlen ;\n\t}\n\treturn 0;\n}\n\n/**\n * Do the initial negotiation.\n *\n * @param client The client we're negotiating with.\n **/\nCLIENT* negotiate(int net, CLIENT *client, GArray* servers) {\n\tchar zeros[128];\n\tuint64_t size_host;\n\tuint32_t flags = NBD_FLAG_HAS_FLAGS;\n\tuint16_t smallflags = 0;\n\tuint64_t magic;\n\n\tmemset(zeros, '\\0', sizeof(zeros));\n\tif(!client || !client->modern) {\n\t\t/* common */\n\t\tif (write(net, INIT_PASSWD, 8) < 0) {\n\t\t\terr_nonfatal(\"Negotiation failed: %m\");\n\t\t\tif(client)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t\tif(!client || client->modern) {\n\t\t\t/* modern */\n\t\t\tmagic = htonll(opts_magic);\n\t\t} else {\n\t\t\t/* oldstyle */\n\t\t\tmagic = htonll(cliserv_magic);\n\t\t}\n\t\tif (write(net, &magic, sizeof(magic)) < 0) {\n\t\t\terr_nonfatal(\"Negotiation failed: %m\");\n\t\t\tif(client)\n\t\t\t\texit(EXIT_FAILURE);\n\t\t}\n\t}\n\tif(!client) {\n\t\t/* modern */\n\t\tuint32_t reserved;\n\t\tuint32_t opt;\n\t\tuint32_t namelen;\n\t\tchar* name;\n\t\tint i;\n\n\t\tif(!servers)\n\t\t\terr(\"programmer error\");\n\t\tif (write(net, &smallflags, sizeof(uint16_t)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tif (read(net, &reserved, sizeof(reserved)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tif (read(net, &magic, sizeof(magic)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tmagic = ntohll(magic);\n\t\tif(magic != opts_magic) {\n\t\t\tclose(net);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (read(net, &opt, sizeof(opt)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\topt = ntohl(opt);\n\t\tif(opt != NBD_OPT_EXPORT_NAME) {\n\t\t\tclose(net);\n\t\t\treturn NULL;\n\t\t}\n\t\tif (read(net, &namelen, sizeof(namelen)) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tnamelen = ntohl(namelen);\n\t\tname = malloc(namelen+1);\n\t\tname[namelen]=0;\n\t\tif (read(net, name, namelen) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t\tfor(i=0; i<servers->len; i++) {\n\t\t\tSERVER* serve = &(g_array_index(servers, SERVER, i));\n\t\t\tif(!strcmp(serve->servename, name)) {\n\t\t\t\tCLIENT* client = g_new0(CLIENT, 1);\n\t\t\t\tclient->server = serve;\n\t\t\t\tclient->exportsize = OFFT_MAX;\n\t\t\t\tclient->net = net;\n\t\t\t\tclient->modern = TRUE;\n\t\t\t\treturn client;\n\t\t\t}\n\t\t}\n\t\treturn NULL;\n\t}\n\t/* common */\n\tsize_host = htonll((u64)(client->exportsize));\n\tif (write(net, &size_host, 8) < 0)\n\t\terr(\"Negotiation failed: %m\");\n\tif (client->server->flags & F_READONLY)\n\t\tflags |= NBD_FLAG_READ_ONLY;\n\tif (!client->modern) {\n\t\t/* oldstyle */\n\t\tflags = htonl(flags);\n\t\tif (write(client->net, &flags, 4) < 0)\n\t\t\terr(\"Negotiation failed: %m\");\n\t} else {\n\t\t/* modern */\n\t\tsmallflags = (uint16_t)(flags & ~((uint16_t)0));\n\t\tsmallflags = htons(smallflags);\n\t\tif (write(client->net, &smallflags, sizeof(smallflags)) < 0) {\n\t\t\terr(\"Negotiation failed: %m\");\n\t\t}\n\t}\n\t/* common */\n\tif (write(client->net, zeros, 124) < 0)\n\t\terr(\"Negotiation failed: %m\");\n\treturn NULL;\n}\n\n/** sending macro. */\n#define SEND(net,reply) writeit( net, &reply, sizeof( reply ));\n/** error macro. */\n#define ERROR(client,reply,errcode) { reply.error = htonl(errcode); SEND(client->net,reply); reply.error = 0; }\n/**\n * Serve a file to a single client.\n *\n * @todo This beast needs to be split up in many tiny little manageable\n * pieces. Preferably with a chainsaw.\n *\n * @param client The client we're going to serve to.\n * @return when the client disconnects\n **/\nint mainloop(CLIENT *client) {\n\tstruct nbd_request request;\n\tstruct nbd_reply reply;\n\tgboolean go_on=TRUE;\n#ifdef DODBG\n\tint i = 0;\n#endif\n\tnegotiate(client->net, client, NULL);\n\tDEBUG(\"Entering request loop!\\n\");\n\treply.magic = htonl(NBD_REPLY_MAGIC);\n\treply.error = 0;\n\twhile (go_on) {\n\t\tchar buf[BUFSIZE];\n\t\tsize_t len;\n#ifdef DODBG\n\t\ti++;\n\t\tprintf(\"%d: \", i);\n#endif\n\t\treadit(client->net, &request, sizeof(request));\n\t\trequest.from = ntohll(request.from);\n\t\trequest.type = ntohl(request.type);\n\n\t\tif (request.type==NBD_CMD_DISC) {\n\t\t\tmsg2(LOG_INFO, \"Disconnect request received.\");\n                \tif (client->server->flags & F_COPYONWRITE) { \n\t\t\t\tif (client->difmap) g_free(client->difmap) ;\n                \t\tclose(client->difffile);\n\t\t\t\tunlink(client->difffilename);\n\t\t\t\tfree(client->difffilename);\n\t\t\t}\n\t\t\tgo_on=FALSE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlen = ntohl(request.len);\n\n\t\tif (request.magic != htonl(NBD_REQUEST_MAGIC))\n\t\t\terr(\"Not enough magic.\");\n\t\tif (len > BUFSIZE - sizeof(struct nbd_reply))\n\t\t\terr(\"Request too big!\");\n#ifdef DODBG\n\t\tprintf(\"%s from %llu (%llu) len %d, \", request.type ? \"WRITE\" :\n\t\t\t\t\"READ\", (unsigned long long)request.from,\n\t\t\t\t(unsigned long long)request.from / 512, len);\n#endif\n\t\tmemcpy(reply.handle, request.handle, sizeof(reply.handle));\n\t\tif ((request.from + len) > (OFFT_MAX)) {\n\t\t\tDEBUG(\"[Number too large!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (((ssize_t)((off_t)request.from + len) > client->exportsize)) {\n\t\t\tDEBUG(\"[RANGE!]\");\n\t\t\tERROR(client, reply, EINVAL);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (request.type==NBD_CMD_WRITE) {\n\t\t\tDEBUG(\"wr: net->buf, \");\n\t\t\treadit(client->net, buf, len);\n\t\t\tDEBUG(\"buf->exp, \");\n\t\t\tif ((client->server->flags & F_READONLY) ||\n\t\t\t    (client->server->flags & F_AUTOREADONLY)) {\n\t\t\t\tDEBUG(\"[WRITE to READONLY!]\");\n\t\t\t\tERROR(client, reply, EPERM);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (expwrite(request.from, buf, len, client)) {\n\t\t\t\tDEBUG(\"Write failed: %m\" );\n\t\t\t\tERROR(client, reply, errno);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSEND(client->net, reply);\n\t\t\tDEBUG(\"OK!\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\t/* READ */\n\n\t\tDEBUG(\"exp->buf, \");\n\t\tif (expread(request.from, buf + sizeof(struct nbd_reply), len, client)) {\n\t\t\tDEBUG(\"Read failed: %m\");\n\t\t\tERROR(client, reply, errno);\n\t\t\tcontinue;\n\t\t}\n\n\t\tDEBUG(\"buf->net, \");\n\t\tmemcpy(buf, &reply, sizeof(struct nbd_reply));\n\t\twriteit(client->net, buf, len + sizeof(struct nbd_reply));\n\t\tDEBUG(\"OK!\\n\");\n\t}\n\treturn 0;\n}\n\n/**\n * Set up client export array, which is an array of FILE_INFO.\n * Also, split a single exportfile into multiple ones, if that was asked.\n * @param client information on the client which we want to setup export for\n **/\nvoid setupexport(CLIENT* client) {\n\tint i;\n\toff_t laststartoff = 0, lastsize = 0;\n\tint multifile = (client->server->flags & F_MULTIFILE);\n\n\tclient->export = g_array_new(TRUE, TRUE, sizeof(FILE_INFO));\n\n\t/* If multi-file, open as many files as we can.\n\t * If not, open exactly one file.\n\t * Calculate file sizes as we go to get total size. */\n\tfor(i=0; ; i++) {\n\t\tFILE_INFO fi;\n\t\tgchar *tmpname;\n\t\tgchar* error_string;\n\t\tmode_t mode = (client->server->flags & F_READONLY) ? O_RDONLY : O_RDWR;\n\n\t\tif(multifile) {\n\t\t\ttmpname=g_strdup_printf(\"%s.%d\", client->exportname, i);\n\t\t} else {\n\t\t\ttmpname=g_strdup(client->exportname);\n\t\t}\n\t\tDEBUG2( \"Opening %s\\n\", tmpname );\n\t\tfi.fhandle = open(tmpname, mode);\n\t\tif(fi.fhandle == -1 && mode == O_RDWR) {\n\t\t\t/* Try again because maybe media was read-only */\n\t\t\tfi.fhandle = open(tmpname, O_RDONLY);\n\t\t\tif(fi.fhandle != -1) {\n\t\t\t\t/* Opening the base file in copyonwrite mode is\n\t\t\t\t * okay */\n\t\t\t\tif(!(client->server->flags & F_COPYONWRITE)) {\n\t\t\t\t\tclient->server->flags |= F_AUTOREADONLY;\n\t\t\t\t\tclient->server->flags |= F_READONLY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(fi.fhandle == -1) {\n\t\t\tif(multifile && i>0)\n\t\t\t\tbreak;\n\t\t\terror_string=g_strdup_printf(\n\t\t\t\t\"Could not open exported file %s: %%m\",\n\t\t\t\ttmpname);\n\t\t\terr(error_string);\n\t\t}\n\t\tfi.startoff = laststartoff + lastsize;\n\t\tg_array_append_val(client->export, fi);\n\t\tg_free(tmpname);\n\n\t\t/* Starting offset and size of this file will be used to\n\t\t * calculate starting offset of next file */\n\t\tlaststartoff = fi.startoff;\n\t\tlastsize = size_autodetect(fi.fhandle);\n\n\t\tif(!multifile)\n\t\t\tbreak;\n\t}\n\n\t/* Set export size to total calculated size */\n\tclient->exportsize = laststartoff + lastsize;\n\n\t/* Export size may be overridden */\n\tif(client->server->expected_size) {\n\t\t/* desired size must be <= total calculated size */\n\t\tif(client->server->expected_size > client->exportsize) {\n\t\t\terr(\"Size of exported file is too big\\n\");\n\t\t}\n\n\t\tclient->exportsize = client->server->expected_size;\n\t}\n\n\tmsg3(LOG_INFO, \"Size of exported file/device is %llu\", (unsigned long long)client->exportsize);\n\tif(multifile) {\n\t\tmsg3(LOG_INFO, \"Total number of files: %d\", i);\n\t}\n}\n\nint copyonwrite_prepare(CLIENT* client) {\n\toff_t i;\n\tif ((client->difffilename = malloc(1024))==NULL)\n\t\terr(\"Failed to allocate string for diff file name\");\n\tsnprintf(client->difffilename, 1024, \"%s-%s-%d.diff\",client->exportname,client->clientname,\n\t\t(int)getpid()) ;\n\tclient->difffilename[1023]='\\0';\n\tmsg3(LOG_INFO,\"About to create map and diff file %s\",client->difffilename) ;\n\tclient->difffile=open(client->difffilename,O_RDWR | O_CREAT | O_TRUNC,0600) ;\n\tif (client->difffile<0) err(\"Could not create diff file (%m)\") ;\n\tif ((client->difmap=calloc(client->exportsize/DIFFPAGESIZE,sizeof(u32)))==NULL)\n\t\terr(\"Could not allocate memory\") ;\n\tfor (i=0;i<client->exportsize/DIFFPAGESIZE;i++) client->difmap[i]=(u32)-1 ;\n\n\treturn 0;\n}\n\n/**\n * Run a command. This is used for the ``prerun'' and ``postrun'' config file\n * options\n *\n * @param command the command to be ran. Read from the config file\n * @param file the file name we're about to export\n **/\nint do_run(gchar* command, gchar* file) {\n\tgchar* cmd;\n\tint retval=0;\n\n\tif(command && *command) {\n\t\tcmd = g_strdup_printf(command, file);\n\t\tretval=system(cmd);\n\t\tg_free(cmd);\n\t}\n\treturn retval;\n}\n\n/**\n * Serve a connection. \n *\n * @todo allow for multithreading, perhaps use libevent. Not just yet, though;\n * follow the road map.\n *\n * @param client a connected client\n **/\nvoid serveconnection(CLIENT *client) {\n\tif(do_run(client->server->prerun, client->exportname)) {\n\t\texit(EXIT_FAILURE);\n\t}\n\tsetupexport(client);\n\n\tif (client->server->flags & F_COPYONWRITE) {\n\t\tcopyonwrite_prepare(client);\n\t}\n\n\tsetmysockopt(client->net);\n\n\tmainloop(client);\n\tdo_run(client->server->postrun, client->exportname);\n}\n\n/**\n * Find the name of the file we have to serve. This will use g_strdup_printf\n * to put the IP address of the client inside a filename containing\n * \"%s\" (in the form as specified by the \"virtstyle\" option). That name\n * is then written to client->exportname.\n *\n * @param net A socket connected to an nbd client\n * @param client information about the client. The IP address in human-readable\n * format will be written to a new char* buffer, the address of which will be\n * stored in client->clientname.\n **/\nvoid set_peername(int net, CLIENT *client) {\n\tstruct sockaddr_storage addrin;\n\tstruct sockaddr_storage netaddr;\n\tstruct sockaddr_in  *netaddr4 = NULL;\n\tstruct sockaddr_in6 *netaddr6 = NULL;\n\tsize_t addrinlen = sizeof( addrin );\n\tstruct addrinfo hints;\n\tstruct addrinfo *ai = NULL;\n\tchar peername[NI_MAXHOST];\n\tchar netname[NI_MAXHOST];\n\tchar *tmp = NULL;\n\tint i;\n\tint e;\n\tint shift;\n\n\tif (getpeername(net, (struct sockaddr *) &addrin, (socklen_t *)&addrinlen) < 0)\n\t\terr(\"getsockname failed: %m\");\n\n\tgetnameinfo((struct sockaddr *)&addrin, (socklen_t)addrinlen,\n\t\tpeername, sizeof (peername), NULL, 0, NI_NUMERICHOST);\n\n\tmemset(&hints, '\\0', sizeof (hints));\n\thints.ai_flags = AI_ADDRCONFIG;\n\te = getaddrinfo(peername, NULL, &hints, &ai);\n\n\tif(e != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed: %s\\n\", gai_strerror(e));\n\t\tfreeaddrinfo(ai);\n\t\treturn;\n\t}\n\n\tswitch(client->server->virtstyle) {\n\t\tcase VIRT_NONE:\n\t\t\tclient->exportname=g_strdup(client->server->exportname);\n\t\t\tbreak;\n\t\tcase VIRT_IPHASH:\n\t\t\tfor(i=0;i<strlen(peername);i++) {\n\t\t\t\tif(peername[i]=='.') {\n\t\t\t\t\tpeername[i]='/';\n\t\t\t\t}\n\t\t\t}\n\t\tcase VIRT_IPLIT:\n\t\t\tclient->exportname=g_strdup_printf(client->server->exportname, peername);\n\t\t\tbreak;\n\t\tcase VIRT_CIDR:\n\t\t\tmemcpy(&netaddr, &addrin, addrinlen);\n\t\t\tif(ai->ai_family == AF_INET) {\n\t\t\t\tnetaddr4 = (struct sockaddr_in *)&netaddr;\n\t\t\t\t(netaddr4->sin_addr).s_addr>>=32-(client->server->cidrlen);\n\t\t\t\t(netaddr4->sin_addr).s_addr<<=32-(client->server->cidrlen);\n\n\t\t\t\tgetnameinfo((struct sockaddr *) netaddr4, (socklen_t) addrinlen,\n\t\t\t\t\t\t\tnetname, sizeof (netname), NULL, 0, NI_NUMERICHOST);\n\t\t\t\ttmp=g_strdup_printf(\"%s/%s\", netname, peername);\n\t\t\t}else if(ai->ai_family == AF_INET6) {\n\t\t\t\tnetaddr6 = (struct sockaddr_in6 *)&netaddr;\n\n\t\t\t\tshift = 128-(client->server->cidrlen);\n\t\t\t\ti = 3;\n\t\t\t\twhile(shift >= 32) {\n\t\t\t\t\t((netaddr6->sin6_addr).s6_addr32[i])=0;\n\t\t\t\t\tshift-=32;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t\t(netaddr6->sin6_addr).s6_addr32[i]>>=shift;\n\t\t\t\t(netaddr6->sin6_addr).s6_addr32[i]<<=shift;\n\n\t\t\t\tgetnameinfo((struct sockaddr *)netaddr6, (socklen_t)addrinlen,\n\t\t\t\t\t    netname, sizeof(netname), NULL, 0, NI_NUMERICHOST);\n\t\t\t\ttmp=g_strdup_printf(\"%s/%s\", netname, peername);\n\t\t\t}\n\n\t\t\tif(tmp != NULL)\n\t\t\t  client->exportname=g_strdup_printf(client->server->exportname, tmp);\n\n\t\t\tbreak;\n\t}\n\n\tfreeaddrinfo(ai);\n\tmsg4(LOG_INFO, \"connect from %s, assigned file is %s\", \n\t     peername, client->exportname);\n\tclient->clientname=g_strdup(peername);\n}\n\n/**\n * Destroy a pid_t*\n * @param data a pointer to pid_t which should be freed\n **/\nvoid destroy_pid_t(gpointer data) {\n\tg_free(data);\n}\n\n/**\n * Loop through the available servers, and serve them. Never returns.\n **/\nint serveloop(GArray* servers) {\n\tstruct sockaddr_storage addrin;\n\tsocklen_t addrinlen=sizeof(addrin);\n\tint i;\n\tint max;\n\tint sock;\n\tfd_set mset;\n\tfd_set rset;\n\n\t/* \n\t * Set up the master fd_set. The set of descriptors we need\n\t * to select() for never changes anyway and it buys us a *lot*\n\t * of time to only build this once. However, if we ever choose\n\t * to not fork() for clients anymore, we may have to revisit\n\t * this.\n\t */\n\tmax=0;\n\tFD_ZERO(&mset);\n\tfor(i=0;i<servers->len;i++) {\n\t\tif((sock=(g_array_index(servers, SERVER, i)).socket)) {\n\t\t\tFD_SET(sock, &mset);\n\t\t\tmax=sock>max?sock:max;\n\t\t}\n\t}\n\tif(modernsock) {\n\t\tFD_SET(modernsock, &mset);\n\t\tmax=modernsock>max?modernsock:max;\n\t}\n\tfor(;;) {\n\t\tCLIENT *client = NULL;\n\t\tpid_t *pid;\n\n\t\tmemcpy(&rset, &mset, sizeof(fd_set));\n\t\tif(select(max+1, &rset, NULL, NULL, NULL)>0) {\n\t\t\tint net = 0;\n\t\t\tSERVER* serve;\n\n\t\t\tDEBUG(\"accept, \");\n\t\t\tif(FD_ISSET(modernsock, &rset)) {\n\t\t\t\tif((net=accept(modernsock, (struct sockaddr *) &addrin, &addrinlen)) < 0)\n\t\t\t\t\terr(\"accept: %m\");\n\t\t\t\tclient = negotiate(net, NULL, servers);\n\t\t\t\tif(!client) {\n\t\t\t\t\terr_nonfatal(\"negotiation failed\");\n\t\t\t\t\tclose(net);\n\t\t\t\t\tnet=0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(i=0;i<servers->len && !net;i++) {\n\t\t\t\tserve=&(g_array_index(servers, SERVER, i));\n\t\t\t\tif(FD_ISSET(serve->socket, &rset)) {\n\t\t\t\t\tif ((net=accept(serve->socket, (struct sockaddr *) &addrin, &addrinlen)) < 0)\n\t\t\t\t\t\terr(\"accept: %m\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(net) {\n\t\t\t\tint sock_flags;\n\n\t\t\t\tif(serve->max_connections > 0 &&\n\t\t\t\t   g_hash_table_size(children) >= serve->max_connections) {\n\t\t\t\t\tmsg2(LOG_INFO, \"Max connections reached\");\n\t\t\t\t\tclose(net);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif((sock_flags = fcntl(net, F_GETFL, 0))==-1) {\n\t\t\t\t\terr(\"fcntl F_GETFL\");\n\t\t\t\t}\n\t\t\t\tif(fcntl(net, F_SETFL, sock_flags &~O_NONBLOCK)==-1) {\n\t\t\t\t\terr(\"fcntl F_SETFL ~O_NONBLOCK\");\n\t\t\t\t}\n\t\t\t\tif(!client) {\n\t\t\t\t\tclient = g_new0(CLIENT, 1);\n\t\t\t\t\tclient->server=serve;\n\t\t\t\t\tclient->exportsize=OFFT_MAX;\n\t\t\t\t\tclient->net=net;\n\t\t\t\t}\n\t\t\t\tset_peername(net, client);\n\t\t\t\tif (!authorized_client(client)) {\n\t\t\t\t\tmsg2(LOG_INFO,\"Unauthorized client\") ;\n\t\t\t\t\tclose(net);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmsg2(LOG_INFO,\"Authorized client\") ;\n\t\t\t\tpid=g_malloc(sizeof(pid_t));\n#ifndef NOFORK\n\t\t\t\tif ((*pid=fork())<0) {\n\t\t\t\t\tmsg3(LOG_INFO,\"Could not fork (%s)\",strerror(errno)) ;\n\t\t\t\t\tclose(net);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*pid>0) { /* parent */\n\t\t\t\t\tclose(net);\n\t\t\t\t\tg_hash_table_insert(children, pid, pid);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t/* child */\n\t\t\t\tg_hash_table_destroy(children);\n\t\t\t\tfor(i=0;i<servers->len;i++) {\n\t\t\t\t\tserve=&g_array_index(servers, SERVER, i);\n\t\t\t\t\tclose(serve->socket);\n\t\t\t\t}\n\t\t\t\t/* FALSE does not free the\n\t\t\t\tactual data. This is required,\n\t\t\t\tbecause the client has a\n\t\t\t\tdirect reference into that\n\t\t\t\tdata, and otherwise we get a\n\t\t\t\tsegfault... */\n\t\t\t\tg_array_free(servers, FALSE);\n#endif // NOFORK\n\t\t\t\tmsg2(LOG_INFO,\"Starting to serve\");\n\t\t\t\tserveconnection(client);\n\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid dosockopts(int socket) {\n#ifndef sun\n\tint yes=1;\n#else\n\tchar yes='1';\n#endif /* sun */\n\tint sock_flags;\n\n\t/* lose the pesky \"Address already in use\" error message */\n\tif (setsockopt(socket,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(int)) == -1) {\n\t        err(\"setsockopt SO_REUSEADDR\");\n\t}\n\tif (setsockopt(socket,SOL_SOCKET,SO_KEEPALIVE,&yes,sizeof(int)) == -1) {\n\t\terr(\"setsockopt SO_KEEPALIVE\");\n\t}\n\n\t/* make the listening socket non-blocking */\n\tif ((sock_flags = fcntl(socket, F_GETFL, 0)) == -1) {\n\t\terr(\"fcntl F_GETFL\");\n\t}\n\tif (fcntl(socket, F_SETFL, sock_flags | O_NONBLOCK) == -1) {\n\t\terr(\"fcntl F_SETFL O_NONBLOCK\");\n\t}\n}\n\n/**\n * Connect a server's socket.\n *\n * @param serve the server we want to connect.\n **/\nint setup_serve(SERVER *serve) {\n\tstruct addrinfo hints;\n\tstruct addrinfo *ai = NULL;\n\tgchar *port = NULL;\n\tint e;\n\n\tif(!do_oldstyle) {\n\t\treturn serve->servename ? 1 : 0;\n\t}\n\tmemset(&hints,'\\0',sizeof(hints));\n\thints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG | AI_NUMERICSERV;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = serve->socket_family;\n\n\tport = g_strdup_printf (\"%d\", serve->port);\n\tif (port == NULL)\n\t\treturn 0;\n\n\te = getaddrinfo(serve->listenaddr,port,&hints,&ai);\n\n\tg_free(port);\n\n\tif(e != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed: %s\\n\", gai_strerror(e));\n\t\tserve->socket = -1;\n\t\tfreeaddrinfo(ai);\n\t\texit(EXIT_FAILURE);\n\t}\n\n\tif(serve->socket_family == AF_UNSPEC)\n\t\tserve->socket_family = ai->ai_family;\n\n#ifdef WITH_SDP\n\tif ((serve->flags) && F_SDP) {\n\t\tif (ai->ai_family == AF_INET)\n\t\t\tai->ai_family = AF_INET_SDP;\n\t\telse (ai->ai_family == AF_INET6)\n\t\t\tai->ai_family = AF_INET6_SDP;\n\t}\n#endif\n\tif ((serve->socket = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol)) < 0)\n\t\terr(\"socket: %m\");\n\n\tdosockopts(serve->socket);\n\n\tDEBUG(\"Waiting for connections... bind, \");\n\te = bind(serve->socket, ai->ai_addr, ai->ai_addrlen);\n\tif (e != 0 && errno != EADDRINUSE)\n\t\terr(\"bind: %m\");\n\tDEBUG(\"listen, \");\n\tif (listen(serve->socket, 1) < 0)\n\t\terr(\"listen: %m\");\n\n\tfreeaddrinfo (ai);\n\tif(serve->servename) {\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\nvoid open_modern(void) {\n\tstruct addrinfo hints;\n\tstruct addrinfo* ai = NULL;\n\tstruct sock_flags;\n\tint e;\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_family = AF_UNSPEC;\n\thints.ai_protocol = IPPROTO_TCP;\n\te = getaddrinfo(modern_listen, NBD_DEFAULT_PORT, &hints, &ai);\n\tif(e != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed: %s\\n\", gai_strerror(e));\n\t\texit(EXIT_FAILURE);\n\t}\n\tif((modernsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol))<0) {\n\t\terr(\"socket: %m\");\n\t}\n\n\tdosockopts(modernsock);\n\n\tif(bind(modernsock, ai->ai_addr, ai->ai_addrlen)) {\n\t\terr(\"bind: %m\");\n\t}\n\tif(listen(modernsock, 10) <0) {\n\t\terr(\"listen: %m\");\n\t}\n\n\tfreeaddrinfo(ai);\n}\n\n/**\n * Connect our servers.\n **/\nvoid setup_servers(GArray* servers) {\n\tint i;\n\tstruct sigaction sa;\n\tint want_modern=0;\n\n\tfor(i=0;i<servers->len;i++) {\n\t\twant_modern |= setup_serve(&(g_array_index(servers, SERVER, i)));\n\t}\n\tif(want_modern) {\n\t\topen_modern();\n\t}\n\tchildren=g_hash_table_new_full(g_int_hash, g_int_equal, NULL, destroy_pid_t);\n\n\tsa.sa_handler = sigchld_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tif(sigaction(SIGCHLD, &sa, NULL) == -1)\n\t\terr(\"sigaction: %m\");\n\tsa.sa_handler = sigterm_handler;\n\tsigemptyset(&sa.sa_mask);\n\tsa.sa_flags = SA_RESTART;\n\tif(sigaction(SIGTERM, &sa, NULL) == -1)\n\t\terr(\"sigaction: %m\");\n}\n\n/**\n * Go daemon (unless we specified at compile time that we didn't want this)\n * @param serve the first server of our configuration. If its port is zero,\n * \tthen do not daemonize, because we're doing inetd then. This parameter\n * \tis only used to create a PID file of the form\n * \t/var/run/nbd-server.&lt;port&gt;.pid; it's not modified in any way.\n **/\n#if !defined(NODAEMON) && !defined(NOFORK)\nvoid daemonize(SERVER* serve) {\n\tFILE*pidf;\n\n\tif(serve && !(serve->port)) {\n\t\treturn;\n\t}\n\tif(daemon(0,0)<0) {\n\t\terr(\"daemon\");\n\t}\n\tif(!*pidftemplate) {\n\t\tif(serve) {\n\t\t\tstrncpy(pidftemplate, \"/var/run/nbd-server.%d.pid\", 255);\n\t\t} else {\n\t\t\tstrncpy(pidftemplate, \"/var/run/nbd-server.pid\", 255);\n\t\t}\n\t}\n\tsnprintf(pidfname, 255, pidftemplate, serve ? serve->port : 0);\n\tpidf=fopen(pidfname, \"w\");\n\tif(pidf) {\n\t\tfprintf(pidf,\"%d\\n\", (int)getpid());\n\t\tfclose(pidf);\n\t} else {\n\t\tperror(\"fopen\");\n\t\tfprintf(stderr, \"Not fatal; continuing\");\n\t}\n}\n#else\n#define daemonize(serve)\n#endif /* !defined(NODAEMON) && !defined(NOFORK) */\n\n/*\n * Everything beyond this point (in the file) is run in non-daemon mode.\n * The stuff above daemonize() isn't.\n */\n\nvoid serve_err(SERVER* serve, const char* msg) G_GNUC_NORETURN;\n\nvoid serve_err(SERVER* serve, const char* msg) {\n\tg_message(\"Export of %s on port %d failed:\", serve->exportname,\n\t\t\tserve->port);\n\terr(msg);\n}\n\n/**\n * Set up user-ID and/or group-ID\n **/\nvoid dousers(void) {\n\tstruct passwd *pw;\n\tstruct group *gr;\n\tgchar* str;\n\tif(rungroup) {\n\t\tgr=getgrnam(rungroup);\n\t\tif(!gr) {\n\t\t\tstr = g_strdup_printf(\"Invalid group name: %s\", rungroup);\n\t\t\terr(str);\n\t\t}\n\t\tif(setgid(gr->gr_gid)<0) {\n\t\t\terr(\"Could not set GID: %m\"); \n\t\t}\n\t}\n\tif(runuser) {\n\t\tpw=getpwnam(runuser);\n\t\tif(!pw) {\n\t\t\tstr = g_strdup_printf(\"Invalid user name: %s\", runuser);\n\t\t\terr(str);\n\t\t}\n\t\tif(setuid(pw->pw_uid)<0) {\n\t\t\terr(\"Could not set UID: %m\");\n\t\t}\n\t}\n}\n\n#ifndef ISSERVER\nvoid glib_message_syslog_redirect(const gchar *log_domain,\n                                  GLogLevelFlags log_level,\n                                  const gchar *message,\n                                  gpointer user_data)\n{\n    int level=LOG_DEBUG;\n    \n    switch( log_level )\n    {\n      case G_LOG_FLAG_FATAL:\n      case G_LOG_LEVEL_CRITICAL:\n      case G_LOG_LEVEL_ERROR:    \n        level=LOG_ERR; \n        break;\n      case G_LOG_LEVEL_WARNING:\n        level=LOG_WARNING;\n        break;\n      case G_LOG_LEVEL_MESSAGE:\n      case G_LOG_LEVEL_INFO:\n        level=LOG_INFO;\n        break;\n      case G_LOG_LEVEL_DEBUG:\n        level=LOG_DEBUG;\n      default:\n        level=LOG_ERR;\n    }\n    syslog(level, \"%s\", message);\n}\n#endif\n\n/**\n * Main entry point...\n **/\nint main(int argc, char *argv[]) {\n\tSERVER *serve;\n\tGArray *servers;\n\tGError *err=NULL;\n\n\tif (sizeof( struct nbd_request )!=28) {\n\t\tfprintf(stderr,\"Bad size of structure. Alignment problems?\\n\");\n\t\texit(EXIT_FAILURE) ;\n\t}\n\n\tmemset(pidftemplate, '\\0', 256);\n\n\tlogging();\n\tconfig_file_pos = g_strdup(CFILE);\n\tserve=cmdline(argc, argv);\n\tservers = parse_cfile(config_file_pos, &err);\n\t\n\tif(serve) {\n\t\tserve->socket_family = AF_UNSPEC;\n\n\t\tappend_serve(serve, servers);\n     \n\t\tif (!(serve->port)) {\n\t\t\tCLIENT *client;\n#ifndef ISSERVER\n\t\t\t/* You really should define ISSERVER if you're going to use\n\t\t\t * inetd mode, but if you don't, closing stdout and stderr\n\t\t\t * (which inetd had connected to the client socket) will let it\n\t\t\t * work. */\n\t\t\tclose(1);\n\t\t\tclose(2);\n\t\t\topen(\"/dev/null\", O_WRONLY);\n\t\t\topen(\"/dev/null\", O_WRONLY);\n\t\t\tg_log_set_default_handler( glib_message_syslog_redirect, NULL );\n#endif\n\t\t\tclient=g_malloc(sizeof(CLIENT));\n\t\t\tclient->server=serve;\n\t\t\tclient->net=0;\n\t\t\tclient->exportsize=OFFT_MAX;\n\t\t\tset_peername(0,client);\n\t\t\tserveconnection(client);\n\t\t\treturn 0;\n\t\t}\n\t}\n    \n\tif(!servers || !servers->len) {\n\t\tif(err && !(err->domain == g_quark_from_string(\"parse_cfile\")\n\t\t\t\t&& err->code == CFILE_NOTFOUND)) {\n\t\t\tg_warning(\"Could not parse config file: %s\", \n\t\t\t\t\terr ? err->message : \"Unknown error\");\n\t\t}\n\t}\n\tif(serve) {\n\t\tg_warning(\"Specifying an export on the command line is deprecated.\");\n\t\tg_warning(\"Please use a configuration file instead.\");\n\t}\n\n\tif((!serve) && (!servers||!servers->len)) {\n\t\tg_message(\"No configured exports; quitting.\");\n\t\texit(EXIT_FAILURE);\n\t}\n\tdaemonize(serve);\n\tsetup_servers(servers);\n\tdousers();\n\tserveloop(servers);\n\treturn 0 ;\n}\n"], "filenames": ["nbd-server.c"], "buggy_code_start_loc": [153], "buggy_code_end_loc": [1393], "fixing_code_start_loc": [153], "fixing_code_end_loc": [1393], "type": "CWE-119", "message": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression.", "other": {"cve": {"id": "CVE-2011-0530", "sourceIdentifier": "secalert@redhat.com", "published": "2011-02-22T19:00:00.940", "lastModified": "2017-08-17T01:33:36.323", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Buffer overflow in the mainloop function in nbd-server.c in the server in Network Block Device (nbd) before 2.9.20 might allow remote attackers to execute arbitrary code via a long request.  NOTE: this issue exists because of a CVE-2005-3534 regression."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer en la funci\u00f3n mainloop en NBD-server.c en Network Block Device (nbd) antes de v2.9.20 podr\u00eda permitir a atacantes remotos ejecutar c\u00f3digo de su elecci\u00f3n a trav\u00e9s de una solicitud extensa. NOTA: este problema existe debido a una regresi\u00f3n CVE-2005-3534."}], "metrics": {"cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.9.19", "matchCriteriaId": "344B1EE6-E6C8-4554-9796-92EB76E36803"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "7FB56984-E060-4C2C-9B41-D46F75C6C40D"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "17AA20F1-CEE5-4768-837F-845B25A7F8EC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "C4C82F9D-3BEE-482D-8F83-1237EA6BA02A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "24E3411A-8602-4F5B-A9F1-7137D8F94971"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "DBF449CE-4E34-44AD-862D-B2BAD7C791A1"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.5:*:*:*:*:*:*:*", "matchCriteriaId": "6DB987D9-1A61-4817-AD2A-D3CCD9D65FE5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.6:*:*:*:*:*:*:*", "matchCriteriaId": "08C9410A-65DF-4095-85AF-D3AED4B8DBEA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.7:*:*:*:*:*:*:*", "matchCriteriaId": "D6E18B35-771D-4F90-B255-66799D1F4B05"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.8:*:*:*:*:*:*:*", "matchCriteriaId": "0EAC7C30-4702-42EF-B5B8-657C562C4AAD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.9:*:*:*:*:*:*:*", "matchCriteriaId": "391B2B7C-D466-4C40-A2FB-8BB405BAF79A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.10:*:*:*:*:*:*:*", "matchCriteriaId": "9AC011DE-6DA8-45C5-8DEE-65C9634AE61A"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.11:*:*:*:*:*:*:*", "matchCriteriaId": "C074B157-E482-43D5-B23C-6447667AA862"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.12:*:*:*:*:*:*:*", "matchCriteriaId": "14D7CAD7-11EF-45E4-9B5C-C0CB509DD5FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.13:*:*:*:*:*:*:*", "matchCriteriaId": "0E019AE8-04B6-4A3C-8D0D-CD5F8A6CC538"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.14:*:*:*:*:*:*:*", "matchCriteriaId": "3AB8A80B-07DC-4B7C-BD79-6CC5838703AD"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.15:*:*:*:*:*:*:*", "matchCriteriaId": "7A805944-8202-45DA-B60D-1A4748381934"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.16:*:*:*:*:*:*:*", "matchCriteriaId": "D7FBADED-4469-4695-A930-F359359FCA1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.17:*:*:*:*:*:*:*", "matchCriteriaId": "540E491B-7BDA-41A2-80AE-1BBC334083BC"}, {"vulnerable": true, "criteria": "cpe:2.3:a:wouter_verhelst:nbd:2.9.18:*:*:*:*:*:*:*", "matchCriteriaId": "096FF02B-91BF-4412-B9C5-A72F790BA87C"}]}]}], "references": [{"url": "http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=611187", "source": "secalert@redhat.com"}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-February/054071.html", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.fedoraproject.org/pipermail/package-announce/2011-February/054083.html", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2011-04/msg00000.html", "source": "secalert@redhat.com"}, {"url": "http://openwall.com/lists/oss-security/2011/01/28/3", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://openwall.com/lists/oss-security/2011/01/31/7", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "http://security.gentoo.org/glsa/glsa-201206-35.xml", "source": "secalert@redhat.com"}, {"url": "http://www.debian.org/security/2011/dsa-2183", "source": "secalert@redhat.com"}, {"url": "http://www.securityfocus.com/bid/46572", "source": "secalert@redhat.com"}, {"url": "http://www.vupen.com/english/advisories/2011/0403", "source": "secalert@redhat.com", "tags": ["Vendor Advisory"]}, {"url": "http://www.vupen.com/english/advisories/2011/0582", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=673562", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://exchange.xforce.ibmcloud.com/vulnerabilities/65720", "source": "secalert@redhat.com"}, {"url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8", "source": "secalert@redhat.com", "tags": ["Patch"]}, {"url": "https://hermes.opensuse.org/messages/8086846", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/yoe/nbd/commit/3ef52043861ab16352d49af89e048ba6339d6df8"}}