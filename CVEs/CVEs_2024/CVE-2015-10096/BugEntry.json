{"buggy_code": ["module TwitterBot\n  module Plugin\n    class TwitterAnnouncer\n      TWITTER_NAME_REGEXP = '^[a-zA-Z_0-9]{1,15}$'\n      include Cinch::Plugin\n\n      def initialize(*args)\n        super\n\n        raise 'Invalid plugin configuration for twitter. Missing API data' unless check_config?\n\n        tw = @bot.config.twitter\n        @twitter = Twitter::REST::Client.new do |config|\n          config.consumer_key = tw['consumer_key']\n          config.consumer_secret = tw['consumer_secret']\n          config.access_token = tw['access_token']\n          config.access_token_secret = tw['access_token_secret']\n        end\n\n        @format = Format(:bold, '%{account}') + ': \"%{tweet}\" ' + Format(:italic, '(%{time})') + ' at %{uri}'\n        @timer = Timer(tw['timer'] || 300, method: :check_tweets)\n        @history = []\n        @enabled = []\n\n        @bot.config.twitmap.each do |chan, _account|\n          @enabled << chan.downcase\n        end\n\n        # Cache tweets that have already happened. Avoid broadcasting them to the channel each reboot.\n        check_tweets(true)\n      end\n\n      match Regexp.new('tw(?:eet)?check ([a-zA-Z]+)$'), method: :announce\n      def announce(m, option)\n        option.downcase!\n\n        if !m.channel.opped?(m.user) && option != 'status'\n          m.user.notice('You are not authorized to use this command!')\n          return\n        end\n\n        case option\n          when 'on'\n            enable(m, true)\n          when 'off'\n            enable(m, false)\n          when 'status'\n            status = announcing?(m.channel.name) ? 'Announcing new tweets.' : 'Not announcing.'\n\n            accounts_str = ''\n            @bot.config.twitmap.each do |chan, accounts|\n              next if chan != m.channel.name.downcase\n\n              accounts.each do |account|\n                accounts_str += \"#{account}, \"\n              end\n            end\n            accounts_str.sub!(/, $/, '')\n            accounts_str = 'None!' unless accounts_str\n\n            m.reply(\"Status for #{m.channel.name}: #{status}\")\n            m.reply(\"Checking for the following Twitter Accounts: #{accounts_str}\")\n          else\n            m.reply(\"Option [#{option}] not understood. Options: on, off, status\")\n        end\n      end\n\n      match Regexp.new('tw(?:eet)?list ([a-zA-Z]+)(?: ([^ ]+))?$'), method: :twlist\n      def twlist(m, option, param)\n        return m.user.notice('You are not authorized to use this command!') unless m.channel.opped?(m.user)\n        option.downcase!\n        param = (param.nil? ? '' : param.downcase)\n        chan = m.channel.name.downcase\n\n        if !param.empty? && !valid_twitter_account?(param)\n          return m.reply(\"The Account [#{param}] is not a valid Twitter account.\")\n        end\n        param = 'help' if param.empty?\n\n        case option\n          when 'add'\n            if @bot.config.twitmap[chan].include?(param)\n              m.reply(\"I am already watching for activity from #{param}!\")\n            else\n              @bot.config.twitmap[chan] << param\n              m.reply(\"The Account [#{param}] is now being watched for activity. until I am restarted.\")\n            end\n          when 'del', 'delete'\n            if @bot.config.twitmap[chan].include?(param)\n              @bot.config.twitmap[chan].delete(param)\n              m.reply(\"The Account [#{param}] is no longer being watched for activity. until I am restarted.\")\n            else\n              m.reply(\"I am not watching #{param} for activity!\")\n            end\n          when 'help'\n            m.reply('Options: add <account>, del <account>')\n          else\n            m.reply(\"Option [#{option}] not understood. Options: add <account>, del <account>\")\n        end\n      end\n\n      match Regexp.new('tw(?:eet)? ([^ ]+)(?: (\\d))?'), method: :check_tweet\n      def check_tweet(m, account, amount = 1)\n        amount = 1 if amount < 1 && amount > 3\n        tweets = get_tweets(account, amount)\n\n        return m.reply(\"Sorry, but #{account} has no public tweets.\") unless tweets\n\n        tweets.each do |tweet|\n          next unless tweet\n\n          m.reply(fmt_tweet(tweet))\n        end\n      end\n\n      def check_tweets(dry_run = false)\n        all_tweets = []\n        history = []\n\n        @bot.config.twitter_accounts.each do |account|\n          all_tweets << get_tweets(account)\n        end\n\n        all_tweets.each do |tweets|\n          if !tweets || tweets.count == 0\n            warn 'Tweets are empty, skipping batch.'\n            next\n          end\n\n          @bot.config.twitmap.each do |chan, accounts|\n            next unless @enabled.include?(chan)\n\n            tweets.each do |tweet|\n              accounts.each do |account|\n                next unless tweet[:account].downcase == account.downcase\n\n                history << chan.to_s + tweet[:id].to_s\n                next if announced?(chan, tweet[:id])\n\n                Channel(chan).send(fmt_tweet(tweet)) unless dry_run\n              end\n            end\n          end\n        end\n\n        @history = history\n      end\n\n      def get_tweets(account, amount = 3)\n        tweets = []\n\n        begin\n          @twitter.user_timeline(account, count: amount).each do |tweet|\n            name = tweet.user.screen_name\n\n            tweets << { account: name, tweet: tweet.text, time: tweet.created_at, uri: tweet.uri.to_s, id: tweet.id }\n          end\n        rescue StandardError => e\n          warn \"Unable to retrieve Tweet information for #{account}: #{e}\"\n          tweets = nil\n        end\n\n        tweets\n      end\n\n      def enable(m, option)\n        chan = m.channel.name.downcase\n\n        if option\n          if announcing?(chan)\n            m.reply('I am already announcing to this channel!')\n          else\n            @enabled << chan\n            m.reply(\"I am now announcing to #{m.channel.name}, until I am restarted, or this option is toggled off.\")\n          end\n        else\n          if announcing?(chan)\n            @enabled.delete(chan)\n            m.reply(\"No longer announcing to #{m.channel.name}, until I am restarted, or this option is toggled back on.\")\n          else\n            m.reply('I am already not announcing to this channel!')\n          end\n        end\n      end\n\n      def fmt_tweet(tweetinfo)\n        account = fmt_account(tweetinfo[:account])\n        tweet = tweetinfo[:tweet]\n        time = fmt_time(tweetinfo[:time])\n        uri = tweetinfo[:uri]\n\n        @format % { account: account, tweet: tweet, time: time, uri: uri }\n      end\n\n      def fmt_account(s)\n        s = '@' + s unless s.start_with?('@')\n\n        s\n      end\n\n      def fmt_time(s)\n        now = Time.now.to_i\n        t = Time.at(s)\n        since = now - t.to_i\n\n        if since <= 3540 && since >= 0\n          if since > 60\n            since = (since / 60).round\n            time_str = 'minute'\n          else\n            time_str = 'second'\n          end\n\n          time_str += 's' if since != 1\n          return \"#{since} #{time_str} ago\"\n        end\n\n        t.to_datetime.strftime('%Y-%m-%d %H:%M:%S%Z')\n      end\n\n      def announced?(channel, id)\n        @history.include?(channel.to_s + id.to_s)\n      end\n\n      def announcing?(channel)\n        @enabled.include?(channel.downcase)\n      end\n\n      def check_config?\n        twconf = @bot.config.twitter\n\n        keys = %w(consumer_key consumer_secret access_token access_token_secret)\n        keys.each do |k|\n          return false if !twconf.key?(k) ||\n                          (twconf.key?(k) && twconf[k].to_s.empty?) ||\n                          twconf[k].start_with?('Your_')\n        end\n\n        true\n      end\n\n      def valid_twitter_account?(account)\n        account[0] = '' if account.start_with?('@')\n\n        /#{TWITTER_NAME_REGEXP}/.match(account) != nil\n      end\n    end\n  end\nend\n", "module TwitterBot\n  VERSION_MAJOR = 1\n  VERSION_MINOR = 1\n  VERSION_BUILD = 0\n  VERSION_APPEND = ''\n\n  VERSION = \"#{VERSION_MAJOR}.#{VERSION_MINOR}.#{VERSION_BUILD}#{VERSION_APPEND}\".freeze\nend\n"], "fixing_code": ["module TwitterBot\n  module Plugin\n    class TwitterAnnouncer\n      TWITTER_NAME_REGEXP = '^[a-zA-Z_0-9]{1,15}$'\n      include Cinch::Plugin\n\n      def initialize(*args)\n        super\n\n        raise 'Invalid plugin configuration for twitter. Missing API data' unless check_config?\n\n        tw = @bot.config.twitter\n        @twitter = Twitter::REST::Client.new do |config|\n          config.consumer_key = tw['consumer_key']\n          config.consumer_secret = tw['consumer_secret']\n          config.access_token = tw['access_token']\n          config.access_token_secret = tw['access_token_secret']\n        end\n\n        @format = Format(:bold, '%{account}') + ': \"%{tweet}\" ' + Format(:italic, '(%{time})') + ' at %{uri}'\n        @timer = Timer(tw['timer'] || 300, method: :check_tweets)\n        @history = []\n        @enabled = []\n\n        @bot.config.twitmap.each do |chan, _account|\n          @enabled << chan.downcase\n        end\n\n        # Cache tweets that have already happened. Avoid broadcasting them to the channel each reboot.\n        check_tweets(true)\n      end\n\n      match Regexp.new('tw(?:eet)?check ([a-zA-Z]+)$'), method: :announce\n      def announce(m, option)\n        option.downcase!\n\n        if !m.channel.opped?(m.user) && option != 'status'\n          m.user.notice('You are not authorized to use this command!')\n          return\n        end\n\n        case option\n          when 'on'\n            enable(m, true)\n          when 'off'\n            enable(m, false)\n          when 'status'\n            status = announcing?(m.channel.name) ? 'Announcing new tweets.' : 'Not announcing.'\n\n            accounts_str = ''\n            @bot.config.twitmap.each do |chan, accounts|\n              next if chan != m.channel.name.downcase\n\n              accounts.each do |account|\n                accounts_str += \"#{account}, \"\n              end\n            end\n            accounts_str.sub!(/, $/, '')\n            accounts_str = 'None!' unless accounts_str\n\n            m.reply(\"Status for #{m.channel.name}: #{status}\")\n            m.reply(\"Checking for the following Twitter Accounts: #{accounts_str}\")\n          else\n            m.reply(\"Option [#{option}] not understood. Options: on, off, status\")\n        end\n      end\n\n      match Regexp.new('tw(?:eet)?list ([a-zA-Z]+)(?: ([^ ]+))?$'), method: :twlist\n      def twlist(m, option, param)\n        return m.user.notice('You are not authorized to use this command!') unless m.channel.opped?(m.user)\n        option.downcase!\n        param = (param.nil? ? '' : param.downcase)\n        chan = m.channel.name.downcase\n\n        if !param.empty? && !valid_twitter_account?(param)\n          return m.reply(\"The Account [#{param}] is not a valid Twitter account.\")\n        end\n        param = 'help' if param.empty?\n\n        case option\n          when 'add'\n            if @bot.config.twitmap[chan].include?(param)\n              m.reply(\"I am already watching for activity from #{param}!\")\n            else\n              @bot.config.twitmap[chan] << param\n              m.reply(\"The Account [#{param}] is now being watched for activity. until I am restarted.\")\n            end\n          when 'del', 'delete'\n            if @bot.config.twitmap[chan].include?(param)\n              @bot.config.twitmap[chan].delete(param)\n              m.reply(\"The Account [#{param}] is no longer being watched for activity. until I am restarted.\")\n            else\n              m.reply(\"I am not watching #{param} for activity!\")\n            end\n          when 'help'\n            m.reply('Options: add <account>, del <account>')\n          else\n            m.reply(\"Option [#{option}] not understood. Options: add <account>, del <account>\")\n        end\n      end\n\n      match Regexp.new('tw(?:eet)? ([^ ]+)(?: (\\d))?'), method: :check_tweet\n      def check_tweet(m, account, amount = 1)\n        amount = 1 if amount < 1 && amount > 3\n        tweets = get_tweets(account, amount)\n\n        return m.reply(\"Sorry, but #{account} has no public tweets.\") unless tweets\n\n        tweets.each do |tweet|\n          next unless tweet\n\n          m.reply(fmt_tweet(tweet))\n        end\n      end\n\n      def check_tweets(dry_run = false)\n        all_tweets = []\n        history = []\n\n        @bot.config.twitter_accounts.each do |account|\n          all_tweets << get_tweets(account)\n        end\n\n        all_tweets.each do |tweets|\n          if !tweets || tweets.count == 0\n            warn 'Tweets are empty, skipping batch.'\n            next\n          end\n\n          @bot.config.twitmap.each do |chan, accounts|\n            next unless @enabled.include?(chan)\n\n            tweets.each do |tweet|\n              accounts.each do |account|\n                next unless tweet[:account].downcase == account.downcase\n\n                history << chan.to_s + tweet[:id].to_s\n                next if announced?(chan, tweet[:id])\n\n                Channel(chan).send(fmt_tweet(tweet)) unless dry_run\n              end\n            end\n          end\n        end\n\n        @history = history\n      end\n\n      def get_tweets(account, amount = 3)\n        tweets = []\n\n        begin\n          @twitter.user_timeline(account, count: amount).each do |tweet|\n            name = tweet.user.screen_name\n            twtext = tweet.text.gsub(\"\\r?\\n\", '.  ')\n\n            tweets << { account: name, tweet: twtext, time: tweet.created_at, uri: tweet.uri.to_s, id: tweet.id }\n          end\n        rescue StandardError => e\n          warn \"Unable to retrieve Tweet information for #{account}: #{e}\"\n          tweets = nil\n        end\n\n        tweets\n      end\n\n      def enable(m, option)\n        chan = m.channel.name.downcase\n\n        if option\n          if announcing?(chan)\n            m.reply('I am already announcing to this channel!')\n          else\n            @enabled << chan\n            m.reply(\"I am now announcing to #{m.channel.name}, until I am restarted, or this option is toggled off.\")\n          end\n        else\n          if announcing?(chan)\n            @enabled.delete(chan)\n            m.reply(\"No longer announcing to #{m.channel.name}, until I am restarted, or this option is toggled back on.\")\n          else\n            m.reply('I am already not announcing to this channel!')\n          end\n        end\n      end\n\n      def fmt_tweet(tweetinfo)\n        account = fmt_account(tweetinfo[:account])\n        tweet = tweetinfo[:tweet]\n        time = fmt_time(tweetinfo[:time])\n        uri = tweetinfo[:uri]\n\n        @format % { account: account, tweet: tweet, time: time, uri: uri }\n      end\n\n      def fmt_account(s)\n        s = '@' + s unless s.start_with?('@')\n\n        s\n      end\n\n      def fmt_time(s)\n        now = Time.now.to_i\n        t = Time.at(s)\n        since = now - t.to_i\n\n        if since <= 3540 && since >= 0\n          if since > 60\n            since = (since / 60).round\n            time_str = 'minute'\n          else\n            time_str = 'second'\n          end\n\n          time_str += 's' if since != 1\n          return \"#{since} #{time_str} ago\"\n        end\n\n        t.to_datetime.strftime('%Y-%m-%d %H:%M:%S%Z')\n      end\n\n      def announced?(channel, id)\n        @history.include?(channel.to_s + id.to_s)\n      end\n\n      def announcing?(channel)\n        @enabled.include?(channel.downcase)\n      end\n\n      def check_config?\n        twconf = @bot.config.twitter\n\n        keys = %w(consumer_key consumer_secret access_token access_token_secret)\n        keys.each do |k|\n          return false if !twconf.key?(k) ||\n                          (twconf.key?(k) && twconf[k].to_s.empty?) ||\n                          twconf[k].start_with?('Your_')\n        end\n\n        true\n      end\n\n      def valid_twitter_account?(account)\n        account[0] = '' if account.start_with?('@')\n\n        /#{TWITTER_NAME_REGEXP}/.match(account) != nil\n      end\n    end\n  end\nend\n", "module TwitterBot\n  VERSION_MAJOR = 1\n  VERSION_MINOR = 1\n  VERSION_BUILD = 1\n  VERSION_APPEND = ''\n\n  VERSION = \"#{VERSION_MAJOR}.#{VERSION_MINOR}.#{VERSION_BUILD}#{VERSION_APPEND}\".freeze\nend\n"], "filenames": ["lib/twitterbot/plugins/twitter_announcer.rb", "lib/twitterbot/version.rb"], "buggy_code_start_loc": [155, 4], "buggy_code_end_loc": [157, 5], "fixing_code_start_loc": [155, 4], "fixing_code_end_loc": [158, 5], "type": "CWE-77", "message": "A vulnerability, which was classified as critical, was found in Zarthus IRC Twitter Announcer Bot up to 1.1.0. This affects the function get_tweets of the file lib/twitterbot/plugins/twitter_announcer.rb. The manipulation of the argument tweet leads to command injection. It is possible to initiate the attack remotely. Upgrading to version 1.1.1 is able to address this issue. The name of the patch is 6b1941b7fc2c70e1f40981b43c84a2c20cc12bd3. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-223383.", "other": {"cve": {"id": "CVE-2015-10096", "sourceIdentifier": "cna@vuldb.com", "published": "2023-03-20T05:15:11.163", "lastModified": "2023-03-24T19:08:05.763", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as critical, was found in Zarthus IRC Twitter Announcer Bot up to 1.1.0. This affects the function get_tweets of the file lib/twitterbot/plugins/twitter_announcer.rb. The manipulation of the argument tweet leads to command injection. It is possible to initiate the attack remotely. Upgrading to version 1.1.1 is able to address this issue. The name of the patch is 6b1941b7fc2c70e1f40981b43c84a2c20cc12bd3. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-223383."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.0, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:H/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.6}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:irc_twitter_announcer_bot_project:irc_twitter_announcer_bot:1.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "64605A96-6694-47FF-A093-B529AF607E4C"}]}]}], "references": [{"url": "https://github.com/Zarthus/irc-twitter-bot/commit/6b1941b7fc2c70e1f40981b43c84a2c20cc12bd3", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/Zarthus/irc-twitter-bot/releases/tag/v1.1.1", "source": "cna@vuldb.com", "tags": ["Release Notes"]}, {"url": "https://vuldb.com/?ctiid.223383", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.223383", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Zarthus/irc-twitter-bot/commit/6b1941b7fc2c70e1f40981b43c84a2c20cc12bd3"}}