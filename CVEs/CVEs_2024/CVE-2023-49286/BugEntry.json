{"buggy_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 54    Interprocess Communication */\n\n#include \"squid.h\"\n#include \"comm/Connection.h\"\n#include \"fd.h\"\n#include \"fde.h\"\n#include \"globals.h\"\n#include \"ip/Address.h\"\n#include \"ipc/Kid.h\"\n#include \"rfc1738.h\"\n#include \"SquidConfig.h\"\n#include \"SquidIpc.h\"\n#include \"tools.h\"\n\n#include <chrono>\n#include <thread>\n\nstatic const char *hello_string = \"hi there\\n\";\n#ifndef HELLO_BUF_SZ\n#define HELLO_BUF_SZ 32\n#endif\nstatic char hello_buf[HELLO_BUF_SZ];\n\nstatic int\nipcCloseAllFD(int prfd, int pwfd, int crfd, int cwfd)\n{\n    if (prfd >= 0)\n        comm_close(prfd);\n\n    if (prfd != pwfd)\n        if (pwfd >= 0)\n            comm_close(pwfd);\n\n    if (crfd >= 0)\n        comm_close(crfd);\n\n    if (crfd != cwfd)\n        if (cwfd >= 0)\n            comm_close(cwfd);\n\n    return -1;\n}\n\nstatic void\nPutEnvironment()\n{\n#if HAVE_PUTENV\n    char *env_str;\n    int tmp_s;\n    env_str = (char *)xcalloc((tmp_s = strlen(Debug::debugOptions) + 32), 1);\n    snprintf(env_str, tmp_s, \"SQUID_DEBUG=%s\", Debug::debugOptions);\n    putenv(env_str);\n#endif\n}\n\npid_t\nipcCreate(int type, const char *prog, const char *const args[], const char *name, Ip::Address &local_addr, int *rfd, int *wfd, void **hIpc)\n{\n    pid_t pid;\n    Ip::Address ChS;\n    Ip::Address PaS;\n    struct addrinfo *AI = nullptr;\n    int crfd = -1;\n    int prfd = -1;\n    int cwfd = -1;\n    int pwfd = -1;\n    int fd;\n    int t1, t2, t3;\n    int x;\n    int xerrno;\n\n#if USE_POLL && _SQUID_OSF_\n    assert(type != IPC_FIFO);\n#endif\n\n    if (rfd)\n        *rfd = -1;\n\n    if (wfd)\n        *wfd = -1;\n\n    if (hIpc)\n        *hIpc = nullptr;\n\n// NP: no wrapping around d and c usage since we *want* code expansion\n#define IPC_CHECK_FAIL(f,d,c) \\\n    if ((f) < 0) { \\\n        debugs(54, DBG_CRITICAL, \"ERROR: Failed to create helper \" d \" FD: \" << c); \\\n        return ipcCloseAllFD(prfd, pwfd, crfd, cwfd); \\\n    } else void(0)\n\n    if (type == IPC_TCP_SOCKET) {\n        crfd = cwfd = comm_open_listener(SOCK_STREAM,\n                                         0,\n                                         local_addr,\n                                         COMM_NOCLOEXEC,\n                                         name);\n        prfd = pwfd = comm_open(SOCK_STREAM,\n                                0,          /* protocol */\n                                local_addr,\n                                0,          /* blocking */\n                                name);\n        IPC_CHECK_FAIL(crfd, \"child read\", \"TCP \" << local_addr);\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"TCP \" << local_addr);\n    } else if (type == IPC_UDP_SOCKET) {\n        crfd = cwfd = comm_open(SOCK_DGRAM,\n                                0,\n                                local_addr,\n                                COMM_NOCLOEXEC,\n                                name);\n        prfd = pwfd = comm_open(SOCK_DGRAM,\n                                0,\n                                local_addr,\n                                0,\n                                name);\n        IPC_CHECK_FAIL(crfd, \"child read\", \"UDP\" << local_addr);\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"UDP\" << local_addr);\n    } else if (type == IPC_FIFO) {\n        int p2c[2];\n        int c2p[2];\n\n        if (pipe(p2c) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: pipe: \" << xstrerr(xerrno));\n            return -1; // maybe ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n        fd_open(prfd = p2c[0], FD_PIPE, \"IPC FIFO Parent Read\");\n        fd_open(cwfd = p2c[1], FD_PIPE, \"IPC FIFO Child Write\");\n\n        if (pipe(c2p) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: pipe: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n        fd_open(crfd = c2p[0], FD_PIPE, \"IPC FIFO Child Read\");\n        fd_open(pwfd = c2p[1], FD_PIPE, \"IPC FIFO Parent Write\");\n\n        IPC_CHECK_FAIL(crfd, \"child read\", \"FIFO pipe\");\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"FIFO pipe\");\n\n#if HAVE_SOCKETPAIR && defined(AF_UNIX)\n\n    } else if (type == IPC_UNIX_STREAM) {\n        int fds[2];\n        int buflen = 32768;\n\n        if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: socketpair: \" << xstrerr(xerrno));\n            return -1;\n        }\n\n        errno = 0;\n        if (setsockopt(fds[0], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1)  {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        if (setsockopt(fds[0], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        if (setsockopt(fds[1], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        if (setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        fd_open(prfd = pwfd = fds[0], FD_PIPE, \"IPC UNIX STREAM Parent\");\n        fd_open(crfd = cwfd = fds[1], FD_PIPE, \"IPC UNIX STREAM Parent\");\n        IPC_CHECK_FAIL(crfd, \"child read\", \"UDS socket\");\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"UDS socket\");\n\n    } else if (type == IPC_UNIX_DGRAM) {\n        int fds[2];\n\n        if (socketpair(AF_UNIX, SOCK_DGRAM, 0, fds) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: socketpair: \" << xstrerr(xerrno));\n            return -1;\n        }\n\n        fd_open(prfd = pwfd = fds[0], FD_PIPE, \"IPC UNIX DGRAM Parent\");\n        fd_open(crfd = cwfd = fds[1], FD_PIPE, \"IPC UNIX DGRAM Parent\");\n\n        IPC_CHECK_FAIL(crfd, \"child read\", \"UDS datagram\");\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"UDS datagram\");\n#endif\n\n    } else {\n        assert(IPC_NONE);\n    }\n\n    debugs(54, 3, \"ipcCreate: prfd FD \" << prfd);\n    debugs(54, 3, \"ipcCreate: pwfd FD \" << pwfd);\n    debugs(54, 3, \"ipcCreate: crfd FD \" << crfd);\n    debugs(54, 3, \"ipcCreate: cwfd FD \" << cwfd);\n\n    if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {\n        Ip::Address::InitAddr(AI);\n\n        if (getsockname(pwfd, AI->ai_addr, &AI->ai_addrlen) < 0) {\n            xerrno = errno;\n            Ip::Address::FreeAddr(AI);\n            debugs(54, DBG_CRITICAL, \"ipcCreate: getsockname: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        PaS = *AI;\n\n        debugs(54, 3, \"ipcCreate: FD \" << pwfd << \" sockaddr \" << PaS);\n\n        Ip::Address::FreeAddr(AI);\n\n        Ip::Address::InitAddr(AI);\n\n        if (getsockname(crfd, AI->ai_addr, &AI->ai_addrlen) < 0) {\n            xerrno = errno;\n            Ip::Address::FreeAddr(AI);\n            debugs(54, DBG_CRITICAL, \"ipcCreate: getsockname: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        ChS = *AI;\n\n        Ip::Address::FreeAddr(AI);\n\n        debugs(54, 3, \"ipcCreate: FD \" << crfd << \" sockaddr \" << ChS );\n\n    }\n\n    if (type == IPC_TCP_SOCKET) {\n        if (listen(crfd, 1) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ipcCreate: listen FD \" << crfd << \": \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        debugs(54, 3, \"ipcCreate: FD \" << crfd << \" listening...\");\n    }\n\n    /* flush or else we get dup data if unbuffered_logs is set */\n    logsFlush();\n\n    if ((pid = fork()) < 0) {\n        xerrno = errno;\n        debugs(54, DBG_IMPORTANT, \"ipcCreate: fork: \" << xstrerr(xerrno));\n        return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n    }\n\n    if (pid > 0) {      /* parent */\n        /* close shared socket with child */\n        comm_close(crfd);\n\n        if (cwfd != crfd)\n            comm_close(cwfd);\n\n        cwfd = crfd = -1;\n\n        if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {\n            if (comm_connect_addr(pwfd, ChS) == Comm::COMM_ERROR)\n                return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        if (type == IPC_UDP_SOCKET)\n            x = comm_udp_recv(prfd, hello_buf, sizeof(hello_buf)-1, 0);\n        else\n            x = read(prfd, hello_buf, sizeof(hello_buf)-1);\n        xerrno = errno;\n        if (x >= 0)\n            hello_buf[x] = '\\0';\n\n        if (x < 0) {\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: PARENT: hello read test failed\");\n            debugs(54, DBG_CRITICAL, \"--> read: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        } else if (strcmp(hello_buf, hello_string)) {\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: PARENT: hello read test failed\");\n            debugs(54, DBG_CRITICAL, \"--> read returned \" << x);\n            debugs(54, DBG_CRITICAL, \"--> got '\" << rfc1738_escape(hello_buf) << \"'\");\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        commUnsetFdTimeout(prfd);\n        commSetNonBlocking(prfd);\n        commSetNonBlocking(pwfd);\n\n        if (rfd)\n            *rfd = prfd;\n\n        if (wfd)\n            *wfd = pwfd;\n\n        fd_table[prfd].flags.ipc = 1;\n\n        fd_table[pwfd].flags.ipc = 1;\n\n        if (Config.sleep_after_fork)\n            std::this_thread::sleep_for(std::chrono::microseconds(Config.sleep_after_fork));\n\n        return pid;\n    }\n\n    /* child */\n    TheProcessKind = pkHelper;\n    no_suid();          /* give up extra privileges */\n\n    /* close shared socket with parent */\n    close(prfd);\n\n    if (pwfd != prfd)\n        close(pwfd);\n\n    pwfd = prfd = -1;\n\n    if (type == IPC_TCP_SOCKET) {\n        debugs(54, 3, \"ipcCreate: calling accept on FD \" << crfd);\n\n        if ((fd = accept(crfd, nullptr, nullptr)) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: FD \" << crfd << \" accept: \" << xstrerr(xerrno));\n            _exit(1);\n        }\n\n        debugs(54, 3, \"ipcCreate: CHILD accepted new FD \" << fd);\n        close(crfd);\n        cwfd = crfd = fd;\n    } else if (type == IPC_UDP_SOCKET) {\n        if (comm_connect_addr(crfd, PaS) == Comm::COMM_ERROR)\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n    }\n\n    if (type == IPC_UDP_SOCKET) {\n        x = comm_udp_send(cwfd, hello_string, strlen(hello_string) + 1, 0);\n\n        if (x < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"sendto FD \" << cwfd << \": \" << xstrerr(xerrno));\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: CHILD: hello write test failed\");\n            _exit(1);\n        }\n    } else {\n        if (write(cwfd, hello_string, strlen(hello_string) + 1) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"write FD \" << cwfd << \": \" << xstrerr(xerrno));\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: CHILD: hello write test failed\");\n            _exit(1);\n        }\n    }\n\n    PutEnvironment();\n    /*\n     * This double-dup stuff avoids problems when one of\n     *  crfd, cwfd, or debug_log are in the rage 0-2.\n     */\n\n    do {\n        /* First make sure 0-2 is occupied by something. Gets cleaned up later */\n        x = dup(crfd);\n        assert(x > -1);\n    } while (x < 3 && x > -1);\n\n    close(x);\n\n    t1 = dup(crfd);\n\n    t2 = dup(cwfd);\n\n    t3 = dup(fileno(debug_log));\n\n    assert(t1 > 2 && t2 > 2 && t3 > 2);\n\n    close(crfd);\n\n    close(cwfd);\n\n    close(fileno(debug_log));\n\n    dup2(t1, 0);\n\n    dup2(t2, 1);\n\n    dup2(t3, 2);\n\n    close(t1);\n\n    close(t2);\n\n    close(t3);\n\n    /* Make sure all other filedescriptors are closed */\n    for (x = 3; x < SQUID_MAXFD; ++x)\n        close(x);\n\n#if HAVE_SETSID\n    if (opt_no_daemon)\n        setsid();\n#endif\n\n    execvp(prog, (char *const *) args);\n    xerrno = errno;\n\n    ResyncDebugLog(fdopen(2, \"a+\"));\n\n    debugs(54, DBG_CRITICAL, \"ipcCreate: \" << prog << \": \" << xstrerr(xerrno));\n\n    _exit(1);\n\n    return 0;\n}\n\n"], "fixing_code": ["/*\n * Copyright (C) 1996-2023 The Squid Software Foundation and contributors\n *\n * Squid software is distributed under GPLv2+ license and includes\n * contributions from numerous individuals and organizations.\n * Please see the COPYING and CONTRIBUTORS files for details.\n */\n\n/* DEBUG: section 54    Interprocess Communication */\n\n#include \"squid.h\"\n#include \"comm/Connection.h\"\n#include \"fd.h\"\n#include \"fde.h\"\n#include \"globals.h\"\n#include \"ip/Address.h\"\n#include \"ipc/Kid.h\"\n#include \"rfc1738.h\"\n#include \"SquidConfig.h\"\n#include \"SquidIpc.h\"\n#include \"tools.h\"\n\n#include <chrono>\n#include <thread>\n#include <cstdlib>\n\n#if HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\nstatic const char *hello_string = \"hi there\\n\";\n#ifndef HELLO_BUF_SZ\n#define HELLO_BUF_SZ 32\n#endif\nstatic char hello_buf[HELLO_BUF_SZ];\n\nstatic int\nipcCloseAllFD(int prfd, int pwfd, int crfd, int cwfd)\n{\n    if (prfd >= 0)\n        comm_close(prfd);\n\n    if (prfd != pwfd)\n        if (pwfd >= 0)\n            comm_close(pwfd);\n\n    if (crfd >= 0)\n        comm_close(crfd);\n\n    if (crfd != cwfd)\n        if (cwfd >= 0)\n            comm_close(cwfd);\n\n    return -1;\n}\n\nstatic void\nPutEnvironment()\n{\n#if HAVE_PUTENV\n    char *env_str;\n    int tmp_s;\n    env_str = (char *)xcalloc((tmp_s = strlen(Debug::debugOptions) + 32), 1);\n    snprintf(env_str, tmp_s, \"SQUID_DEBUG=%s\", Debug::debugOptions);\n    putenv(env_str);\n#endif\n}\n\npid_t\nipcCreate(int type, const char *prog, const char *const args[], const char *name, Ip::Address &local_addr, int *rfd, int *wfd, void **hIpc)\n{\n    pid_t pid;\n    Ip::Address ChS;\n    Ip::Address PaS;\n    struct addrinfo *AI = nullptr;\n    int crfd = -1;\n    int prfd = -1;\n    int cwfd = -1;\n    int pwfd = -1;\n    int fd;\n    int t1, t2, t3;\n    int x;\n    int xerrno;\n\n#if USE_POLL && _SQUID_OSF_\n    assert(type != IPC_FIFO);\n#endif\n\n    if (rfd)\n        *rfd = -1;\n\n    if (wfd)\n        *wfd = -1;\n\n    if (hIpc)\n        *hIpc = nullptr;\n\n// NP: no wrapping around d and c usage since we *want* code expansion\n#define IPC_CHECK_FAIL(f,d,c) \\\n    if ((f) < 0) { \\\n        debugs(54, DBG_CRITICAL, \"ERROR: Failed to create helper \" d \" FD: \" << c); \\\n        return ipcCloseAllFD(prfd, pwfd, crfd, cwfd); \\\n    } else void(0)\n\n    if (type == IPC_TCP_SOCKET) {\n        crfd = cwfd = comm_open_listener(SOCK_STREAM,\n                                         0,\n                                         local_addr,\n                                         COMM_NOCLOEXEC,\n                                         name);\n        prfd = pwfd = comm_open(SOCK_STREAM,\n                                0,          /* protocol */\n                                local_addr,\n                                0,          /* blocking */\n                                name);\n        IPC_CHECK_FAIL(crfd, \"child read\", \"TCP \" << local_addr);\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"TCP \" << local_addr);\n    } else if (type == IPC_UDP_SOCKET) {\n        crfd = cwfd = comm_open(SOCK_DGRAM,\n                                0,\n                                local_addr,\n                                COMM_NOCLOEXEC,\n                                name);\n        prfd = pwfd = comm_open(SOCK_DGRAM,\n                                0,\n                                local_addr,\n                                0,\n                                name);\n        IPC_CHECK_FAIL(crfd, \"child read\", \"UDP\" << local_addr);\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"UDP\" << local_addr);\n    } else if (type == IPC_FIFO) {\n        int p2c[2];\n        int c2p[2];\n\n        if (pipe(p2c) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: pipe: \" << xstrerr(xerrno));\n            return -1; // maybe ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n        fd_open(prfd = p2c[0], FD_PIPE, \"IPC FIFO Parent Read\");\n        fd_open(cwfd = p2c[1], FD_PIPE, \"IPC FIFO Child Write\");\n\n        if (pipe(c2p) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: pipe: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n        fd_open(crfd = c2p[0], FD_PIPE, \"IPC FIFO Child Read\");\n        fd_open(pwfd = c2p[1], FD_PIPE, \"IPC FIFO Parent Write\");\n\n        IPC_CHECK_FAIL(crfd, \"child read\", \"FIFO pipe\");\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"FIFO pipe\");\n\n#if HAVE_SOCKETPAIR && defined(AF_UNIX)\n\n    } else if (type == IPC_UNIX_STREAM) {\n        int fds[2];\n        int buflen = 32768;\n\n        if (socketpair(AF_UNIX, SOCK_STREAM, 0, fds) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: socketpair: \" << xstrerr(xerrno));\n            return -1;\n        }\n\n        errno = 0;\n        if (setsockopt(fds[0], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1)  {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        if (setsockopt(fds[0], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        if (setsockopt(fds[1], SOL_SOCKET, SO_SNDBUF, (void *) &buflen, sizeof(buflen)) == -1) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        if (setsockopt(fds[1], SOL_SOCKET, SO_RCVBUF, (void *) &buflen, sizeof(buflen)) == -1) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ERROR: setsockopt failed: \" << xstrerr(xerrno));\n            errno = 0;\n        }\n        fd_open(prfd = pwfd = fds[0], FD_PIPE, \"IPC UNIX STREAM Parent\");\n        fd_open(crfd = cwfd = fds[1], FD_PIPE, \"IPC UNIX STREAM Parent\");\n        IPC_CHECK_FAIL(crfd, \"child read\", \"UDS socket\");\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"UDS socket\");\n\n    } else if (type == IPC_UNIX_DGRAM) {\n        int fds[2];\n\n        if (socketpair(AF_UNIX, SOCK_DGRAM, 0, fds) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: socketpair: \" << xstrerr(xerrno));\n            return -1;\n        }\n\n        fd_open(prfd = pwfd = fds[0], FD_PIPE, \"IPC UNIX DGRAM Parent\");\n        fd_open(crfd = cwfd = fds[1], FD_PIPE, \"IPC UNIX DGRAM Parent\");\n\n        IPC_CHECK_FAIL(crfd, \"child read\", \"UDS datagram\");\n        IPC_CHECK_FAIL(prfd, \"parent read\", \"UDS datagram\");\n#endif\n\n    } else {\n        assert(IPC_NONE);\n    }\n\n    debugs(54, 3, \"ipcCreate: prfd FD \" << prfd);\n    debugs(54, 3, \"ipcCreate: pwfd FD \" << pwfd);\n    debugs(54, 3, \"ipcCreate: crfd FD \" << crfd);\n    debugs(54, 3, \"ipcCreate: cwfd FD \" << cwfd);\n\n    if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {\n        Ip::Address::InitAddr(AI);\n\n        if (getsockname(pwfd, AI->ai_addr, &AI->ai_addrlen) < 0) {\n            xerrno = errno;\n            Ip::Address::FreeAddr(AI);\n            debugs(54, DBG_CRITICAL, \"ipcCreate: getsockname: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        PaS = *AI;\n\n        debugs(54, 3, \"ipcCreate: FD \" << pwfd << \" sockaddr \" << PaS);\n\n        Ip::Address::FreeAddr(AI);\n\n        Ip::Address::InitAddr(AI);\n\n        if (getsockname(crfd, AI->ai_addr, &AI->ai_addrlen) < 0) {\n            xerrno = errno;\n            Ip::Address::FreeAddr(AI);\n            debugs(54, DBG_CRITICAL, \"ipcCreate: getsockname: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        ChS = *AI;\n\n        Ip::Address::FreeAddr(AI);\n\n        debugs(54, 3, \"ipcCreate: FD \" << crfd << \" sockaddr \" << ChS );\n\n    }\n\n    if (type == IPC_TCP_SOCKET) {\n        if (listen(crfd, 1) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_IMPORTANT, \"ipcCreate: listen FD \" << crfd << \": \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        debugs(54, 3, \"ipcCreate: FD \" << crfd << \" listening...\");\n    }\n\n    /* flush or else we get dup data if unbuffered_logs is set */\n    logsFlush();\n\n    if ((pid = fork()) < 0) {\n        xerrno = errno;\n        debugs(54, DBG_IMPORTANT, \"ipcCreate: fork: \" << xstrerr(xerrno));\n        return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n    }\n\n    if (pid > 0) {      /* parent */\n        /* close shared socket with child */\n        comm_close(crfd);\n\n        if (cwfd != crfd)\n            comm_close(cwfd);\n\n        cwfd = crfd = -1;\n\n        if (type == IPC_TCP_SOCKET || type == IPC_UDP_SOCKET) {\n            if (comm_connect_addr(pwfd, ChS) == Comm::COMM_ERROR)\n                return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        if (type == IPC_UDP_SOCKET)\n            x = comm_udp_recv(prfd, hello_buf, sizeof(hello_buf)-1, 0);\n        else\n            x = read(prfd, hello_buf, sizeof(hello_buf)-1);\n        xerrno = errno;\n        if (x >= 0)\n            hello_buf[x] = '\\0';\n\n        if (x < 0) {\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: PARENT: hello read test failed\");\n            debugs(54, DBG_CRITICAL, \"--> read: \" << xstrerr(xerrno));\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        } else if (strcmp(hello_buf, hello_string)) {\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: PARENT: hello read test failed\");\n            debugs(54, DBG_CRITICAL, \"--> read returned \" << x);\n            debugs(54, DBG_CRITICAL, \"--> got '\" << rfc1738_escape(hello_buf) << \"'\");\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n        }\n\n        commUnsetFdTimeout(prfd);\n        commSetNonBlocking(prfd);\n        commSetNonBlocking(pwfd);\n\n        if (rfd)\n            *rfd = prfd;\n\n        if (wfd)\n            *wfd = pwfd;\n\n        fd_table[prfd].flags.ipc = 1;\n\n        fd_table[pwfd].flags.ipc = 1;\n\n        if (Config.sleep_after_fork)\n            std::this_thread::sleep_for(std::chrono::microseconds(Config.sleep_after_fork));\n\n        return pid;\n    }\n\n    /* child */\n    TheProcessKind = pkHelper;\n    no_suid();          /* give up extra privileges */\n\n    /* close shared socket with parent */\n    close(prfd);\n\n    if (pwfd != prfd)\n        close(pwfd);\n\n    pwfd = prfd = -1;\n\n    if (type == IPC_TCP_SOCKET) {\n        debugs(54, 3, \"ipcCreate: calling accept on FD \" << crfd);\n\n        if ((fd = accept(crfd, nullptr, nullptr)) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"ipcCreate: FD \" << crfd << \" accept: \" << xstrerr(xerrno));\n            _exit(1);\n        }\n\n        debugs(54, 3, \"ipcCreate: CHILD accepted new FD \" << fd);\n        close(crfd);\n        cwfd = crfd = fd;\n    } else if (type == IPC_UDP_SOCKET) {\n        if (comm_connect_addr(crfd, PaS) == Comm::COMM_ERROR)\n            return ipcCloseAllFD(prfd, pwfd, crfd, cwfd);\n    }\n\n    if (type == IPC_UDP_SOCKET) {\n        x = comm_udp_send(cwfd, hello_string, strlen(hello_string) + 1, 0);\n\n        if (x < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"sendto FD \" << cwfd << \": \" << xstrerr(xerrno));\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: CHILD: hello write test failed\");\n            _exit(1);\n        }\n    } else {\n        if (write(cwfd, hello_string, strlen(hello_string) + 1) < 0) {\n            xerrno = errno;\n            debugs(54, DBG_CRITICAL, \"write FD \" << cwfd << \": \" << xstrerr(xerrno));\n            debugs(54, DBG_CRITICAL, \"ERROR: ipcCreate: CHILD: hello write test failed\");\n            _exit(1);\n        }\n    }\n\n    PutEnvironment();\n\n    // A dup(2) wrapper that reports and exits the process on errors. The\n    // exiting logic is only suitable for this child process context.\n    const auto dupOrExit = [prog,name](const int oldFd) {\n        const auto newFd = dup(oldFd);\n        if (newFd < 0) {\n            const auto savedErrno = errno;\n            debugs(54, DBG_CRITICAL, \"ERROR: Helper process initialization failure: \" << name <<\n                   Debug::Extra << \"helper (CHILD) PID: \" << getpid() <<\n                   Debug::Extra << \"helper program name: \" << prog <<\n                   Debug::Extra << \"dup(2) system call error for FD \" << oldFd << \": \" << xstrerr(savedErrno));\n            _exit(EXIT_FAILURE);\n        }\n        return newFd;\n    };\n\n    /*\n     * This double-dup stuff avoids problems when one of\n     *  crfd, cwfd, or debug_log are in the rage 0-2.\n     */\n\n    do {\n        /* First make sure 0-2 is occupied by something. Gets cleaned up later */\n        x = dupOrExit(crfd);\n    } while (x < 3);\n\n    close(x);\n\n    t1 = dupOrExit(crfd);\n\n    t2 = dupOrExit(cwfd);\n\n    t3 = dupOrExit(fileno(debug_log));\n\n    assert(t1 > 2 && t2 > 2 && t3 > 2);\n\n    close(crfd);\n\n    close(cwfd);\n\n    close(fileno(debug_log));\n\n    dup2(t1, 0);\n\n    dup2(t2, 1);\n\n    dup2(t3, 2);\n\n    close(t1);\n\n    close(t2);\n\n    close(t3);\n\n    /* Make sure all other filedescriptors are closed */\n    for (x = 3; x < SQUID_MAXFD; ++x)\n        close(x);\n\n#if HAVE_SETSID\n    if (opt_no_daemon)\n        setsid();\n#endif\n\n    execvp(prog, (char *const *) args);\n    xerrno = errno;\n\n    ResyncDebugLog(fdopen(2, \"a+\"));\n\n    debugs(54, DBG_CRITICAL, \"ipcCreate: \" << prog << \": \" << xstrerr(xerrno));\n\n    _exit(1);\n\n    return 0;\n}\n\n"], "filenames": ["src/ipc.cc"], "buggy_code_start_loc": [24], "buggy_code_end_loc": [383], "fixing_code_start_loc": [25], "fixing_code_end_loc": [403], "type": "CWE-617", "message": "Squid is a caching proxy for the Web supporting HTTP, HTTPS, FTP, and more. Due to an Incorrect Check of Function Return Value bug Squid is vulnerable to a Denial of Service attack against its Helper process management. This bug is fixed by Squid version 6.5. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-49286", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-04T23:15:27.243", "lastModified": "2024-01-19T16:15:09.793", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Squid is a caching proxy for the Web supporting HTTP, HTTPS, FTP, and more. Due to an Incorrect Check of Function Return Value bug Squid is vulnerable to a Denial of Service attack against its Helper process management. This bug is fixed by Squid version 6.5. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Squid es un proxy de almacenamiento en cach\u00e9 para la Web que admite HTTP, HTTPS, FTP y m\u00e1s. Debido a un error de verificaci\u00f3n incorrecta del valor de retorno de la funci\u00f3n, Squid es vulnerable a un ataque de denegaci\u00f3n de servicio contra su gesti\u00f3n de procesos auxiliares. Este error se solucion\u00f3 con la versi\u00f3n 6.5 de Squid. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.6, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 4.0}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}, {"lang": "en", "value": "CWE-754"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-253"}, {"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squid-cache:squid:*:*:*:*:*:*:*:*", "versionEndIncluding": "6.4", "matchCriteriaId": "64A6EFAB-804C-4B6B-B609-2F5A797EACB0"}]}]}], "references": [{"url": "http://www.squid-cache.org/Versions/v6/SQUID-2023_8.patch", "source": "security-advisories@github.com", "tags": ["Broken Link"]}, {"url": "https://github.com/squid-cache/squid/commit/6014c6648a2a54a4ecb7f952ea1163e0798f9264", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/squid-cache/squid/security/advisories/GHSA-xggx-9329-3c27", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2024/01/msg00003.html", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/A5QASTMCUSUEW3UOMKHZJB3FTONWSRXS/", "source": "security-advisories@github.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/MEV66D3PAAY6K7TWDT3WZBLCPLASFJDC/", "source": "security-advisories@github.com"}, {"url": "https://security.netapp.com/advisory/ntap-20240119-0004/", "source": "security-advisories@github.com"}]}, "github_commit_url": "https://github.com/squid-cache/squid/commit/6014c6648a2a54a4ecb7f952ea1163e0798f9264"}}