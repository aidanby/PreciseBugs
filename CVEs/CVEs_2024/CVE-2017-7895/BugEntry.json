{"buggy_code": ["/*\n * XDR support for nfsd/protocol version 3.\n *\n * Copyright (C) 1995, 1996, 1997 Olaf Kirch <okir@monad.swb.de>\n *\n * 2003-08-09 Jamie Lokier: Use htonl() for nanoseconds, not htons()!\n */\n\n#include <linux/namei.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include \"xdr3.h\"\n#include \"auth.h\"\n#include \"netns.h\"\n#include \"vfs.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_XDR\n\n\n/*\n * Mapping of S_IF* types to NFS file types\n */\nstatic u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};\n\n/*\n * XDR functions for basic NFS types\n */\nstatic __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}\n\nstatic __be32 *\ndecode_time3(__be32 *p, struct timespec *time)\n{\n\ttime->tv_sec = ntohl(*p++);\n\ttime->tv_nsec = ntohl(*p++);\n\treturn p;\n}\n\nstatic __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size;\n\tfh_init(fhp, NFS3_FHSIZE);\n\tsize = ntohl(*p++);\n\tif (size > NFS3_FHSIZE)\n\t\treturn NULL;\n\n\tmemcpy(&fhp->fh_handle.fh_base, p, size);\n\tfhp->fh_handle.fh_size = size;\n\treturn p + XDR_QUADLEN(size);\n}\n\n/* Helper function for NFSv3 ACL code */\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}\n\n/*\n * Decode a file name and make sure that the path contains\n * no slashes or null bytes.\n */\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}\n\nstatic __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)\n{\n\tu64 f;\n\tswitch(fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\tp = xdr_encode_hyper(p, (u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u64*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u64*)fhp->fh_export->ex_uuid)[1];\n\t\tp = xdr_encode_hyper(p, f);\n\t\tbreak;\n\t}\n\treturn p;\n}\n\nstatic __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}\n\nstatic __be32 *\nencode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\t/* Attributes to follow */\n\t*p++ = xdr_one;\n\treturn encode_fattr3(rqstp, p, fhp, &fhp->fh_post_attr);\n}\n\n/*\n * Encode post-operation attributes.\n * The inode may be NULL if the call failed because of a stale file\n * handle. In this case, no attributes are returned.\n */\nstatic __be32 *\nencode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry *dentry = fhp->fh_dentry;\n\tif (dentry && d_really_is_positive(dentry)) {\n\t        __be32 err;\n\t\tstruct kstat stat;\n\n\t\terr = fh_getattr(fhp, &stat);\n\t\tif (!err) {\n\t\t\t*p++ = xdr_one;\t\t/* attributes follow */\n\t\t\tlease_get_mtime(d_inode(dentry), &stat.mtime);\n\t\t\treturn encode_fattr3(rqstp, p, fhp, &stat);\n\t\t}\n\t}\n\t*p++ = xdr_zero;\n\treturn p;\n}\n\n/* Helper for NFSv3 ACLs */\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}\n\n/*\n * Enocde weak cache consistency data\n */\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}\n\n/*\n * Fill in the post_op attr for the wcc data\n */\nvoid fill_post_wcc(struct svc_fh *fhp)\n{\n\t__be32 err;\n\n\tif (fhp->fh_post_saved)\n\t\tprintk(\"nfsd: inode locked twice during operation.\\n\");\n\n\terr = fh_getattr(fhp, &fhp->fh_post_attr);\n\tfhp->fh_post_change = d_inode(fhp->fh_dentry)->i_version;\n\tif (err) {\n\t\tfhp->fh_post_saved = false;\n\t\t/* Grab the ctime anyway - set_change_info might use it */\n\t\tfhp->fh_post_attr.ctime = d_inode(fhp->fh_dentry)->i_ctime;\n\t} else\n\t\tfhp->fh_post_saved = true;\n}\n\n/*\n * XDR decode functions\n */\nint\nnfs3svc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\tif ((args->check_guard = ntohl(*p++)) != 0) { \n\t\tstruct timespec time; \n\t\tp = decode_time3(p, &time);\n\t\targs->guardtime = time.tv_sec;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\tlen = min(args->count, max_blocksize);\n\n\t/* set up the kvec */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}\n\nint\nnfs3svc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\tswitch (args->createmode = ntohl(*p++)) {\n\tcase NFS3_CREATE_UNCHECKED:\n\tcase NFS3_CREATE_GUARDED:\n\t\tp = decode_sattr3(p, &args->attrs);\n\t\tbreak;\n\tcase NFS3_CREATE_EXCLUSIVE:\n\t\targs->verf = p;\n\t\tp += 2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\nint\nnfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh)) ||\n\t    !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\nnfs3svc_decode_mknodargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_mknodargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\targs->ftype = ntohl(*p++);\n\n\tif (args->ftype == NF3BLK  || args->ftype == NF3CHR\n\t || args->ftype == NF3SOCK || args->ftype == NF3FIFO)\n\t\tp = decode_sattr3(p, &args->attrs);\n\n\tif (args->ftype == NF3BLK || args->ftype == NF3CHR) {\n\t\targs->major = ntohl(*p++);\n\t\targs->minor = ntohl(*p++);\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf   = p; p += 2;\n\targs->dircount = ~0;\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tint len;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf     = p; p += 2;\n\targs->dircount = ntohl(*p++);\n\targs->count    = ntohl(*p++);\n\n\tlen = args->count = min(args->count, max_blocksize);\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\t\tif (!args->buffer)\n\t\t\targs->buffer = page_address(p);\n\t\tlen -= PAGE_SIZE;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_commitargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\n/*\n * XDR encode functions\n */\n/*\n * There must be an encoding function for void results so svc_process\n * will work properly.\n */\nint\nnfs3svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* GETATTR */\nint\nnfs3svc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tif (resp->status == 0) {\n\t\tlease_get_mtime(d_inode(resp->fh.fh_dentry),\n\t\t\t\t&resp->stat.mtime);\n\t\tp = encode_fattr3(rqstp, p, &resp->fh, &resp->stat);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* SETATTR, REMOVE, RMDIR */\nint\nnfs3svc_encode_wccstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* LOOKUP */\nint\nnfs3svc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_post_op_attr(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* ACCESS */\nint\nnfs3svc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0)\n\t\t*p++ = htonl(resp->access);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* READLINK */\nint\nnfs3svc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->len);\n\t\txdr_ressize_check(rqstp, p);\n\t\trqstp->rq_res.page_len = resp->len;\n\t\tif (resp->len & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* READ */\nint\nnfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->eof);\n\t\t*p++ = htonl(resp->count);\t/* xdr opaque count */\n\t\txdr_ressize_check(rqstp, p);\n\t\t/* now update rqstp->rq_res to reflect data as well */\n\t\trqstp->rq_res.page_len = resp->count;\n\t\tif (resp->count & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count & 3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* WRITE */\nint\nnfs3svc_encode_writeres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->committed);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* CREATE, MKDIR, SYMLINK, MKNOD */\nint\nnfs3svc_encode_createres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\t*p++ = xdr_one;\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_wcc_data(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* RENAME */\nint\nnfs3svc_encode_renameres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameres *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->ffh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* LINK */\nint\nnfs3svc_encode_linkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* READDIR */\nint\nnfs3svc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\n\tif (resp->status == 0) {\n\t\t/* stupid readdir cookie */\n\t\tmemcpy(p, resp->verf, 8); p += 2;\n\t\txdr_ressize_check(rqstp, p);\n\t\tif (rqstp->rq_res.head[0].iov_len + (2<<2) > PAGE_SIZE)\n\t\t\treturn 1; /*No room for trailer */\n\t\trqstp->rq_res.page_len = (resp->count) << 2;\n\n\t\t/* add the 'tail' to the end of the 'head' page - page 0. */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p++ = 0;\t\t/* no more entries */\n\t\t*p++ = htonl(resp->common.err == nfserr_eof);\n\t\trqstp->rq_res.tail[0].iov_len = 2<<2;\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}\n\nstatic __be32 *\nencode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,\n\t     int namlen, u64 ino)\n{\n\t*p++ = xdr_one;\t\t\t\t /* mark entry present */\n\tp    = xdr_encode_hyper(p, ino);\t /* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\n\tcd->offset = p;\t\t\t\t/* remember pointer */\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */\n\n\treturn p;\n}\n\nstatic __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}\n\nstatic __be32 *encode_entryplus_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name, int namlen, u64 ino)\n{\n\tstruct svc_fh\t*fh = &cd->scratch;\n\t__be32 err;\n\n\tfh_init(fh, NFS3_FHSIZE);\n\terr = compose_entry_fh(cd, fh, name, namlen, ino);\n\tif (err) {\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\tgoto out;\n\t}\n\tp = encode_post_op_attr(cd->rqstp, p, fh);\n\t*p++ = xdr_one;\t\t\t/* yes, a file handle follows */\n\tp = encode_fh(p, fh);\nout:\n\tfh_put(fh);\n\treturn p;\n}\n\n/*\n * Encode a directory entry. This one works for both normal readdir\n * and readdirplus.\n * The normal readdir reply requires 2 (fileid) + 1 (stringlen)\n * + string + 2 (cookie) + 1 (next) words, i.e. 6 + strlen.\n * \n * The readdirplus baggage is 1+21 words for post_op_attr, plus the\n * file handle.\n */\n\n#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)\n#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))\nstatic int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}\n\nint\nnfs3svc_encode_entry(void *cd, const char *name,\n\t\t     int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 0);\n}\n\nint\nnfs3svc_encode_entry_plus(void *cd, const char *name,\n\t\t\t  int namlen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 1);\n}\n\n/* FSSTAT */\nint\nnfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsstatres *resp)\n{\n\tstruct kstatfs\t*s = &resp->stats;\n\tu64\t\tbs = s->f_bsize;\n\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\tp = xdr_encode_hyper(p, bs * s->f_blocks);\t/* total bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bfree);\t/* free bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bavail);\t/* user available bytes */\n\t\tp = xdr_encode_hyper(p, s->f_files);\t/* total inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* free inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* user available inodes */\n\t\t*p++ = htonl(resp->invarsec);\t/* mean unchanged time */\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* FSINFO */\nint\nnfs3svc_encode_fsinfores(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsinfores *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->f_rtmax);\n\t\t*p++ = htonl(resp->f_rtpref);\n\t\t*p++ = htonl(resp->f_rtmult);\n\t\t*p++ = htonl(resp->f_wtmax);\n\t\t*p++ = htonl(resp->f_wtpref);\n\t\t*p++ = htonl(resp->f_wtmult);\n\t\t*p++ = htonl(resp->f_dtpref);\n\t\tp = xdr_encode_hyper(p, resp->f_maxfilesize);\n\t\t*p++ = xdr_one;\n\t\t*p++ = xdr_zero;\n\t\t*p++ = htonl(resp->f_properties);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* PATHCONF */\nint\nnfs3svc_encode_pathconfres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_pathconfres *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->p_link_max);\n\t\t*p++ = htonl(resp->p_name_max);\n\t\t*p++ = htonl(resp->p_no_trunc);\n\t\t*p++ = htonl(resp->p_chown_restricted);\n\t\t*p++ = htonl(resp->p_case_insensitive);\n\t\t*p++ = htonl(resp->p_case_preserving);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* COMMIT */\nint\nnfs3svc_encode_commitres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\t/* Write verifier */\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/*\n * XDR release functions\n */\nint\nnfs3svc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}\n\nint\nnfs3svc_release_fhandle2(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fhandle_pair *resp)\n{\n\tfh_put(&resp->fh1);\n\tfh_put(&resp->fh2);\n\treturn 1;\n}\n", "/*\n * XDR support for nfsd\n *\n * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>\n */\n\n#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"auth.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_XDR\n\n/*\n * Mapping of S_IF* types to NFS file types\n */\nstatic u32\tnfs_ftypes[] = {\n\tNFNON,  NFCHR,  NFCHR, NFBAD,\n\tNFDIR,  NFBAD,  NFBLK, NFBAD,\n\tNFREG,  NFBAD,  NFLNK, NFBAD,\n\tNFSOCK, NFBAD,  NFLNK, NFBAD,\n};\n\n\n/*\n * XDR functions for basic NFS types\n */\nstatic __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tfh_init(fhp, NFS_FHSIZE);\n\tmemcpy(&fhp->fh_handle.fh_base, p, NFS_FHSIZE);\n\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\n\t/* FIXME: Look up export pointer here and verify\n\t * Sun Secure RPC if requested */\n\treturn p + (NFS_FHSIZE >> 2);\n}\n\n/* Helper function for NFSv2 ACL code */\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tmemcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);\n\treturn p + (NFS_FHSIZE>> 2);\n}\n\n/*\n * Decode a file name and make sure that the path contains\n * no slashes or null bytes.\n */\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}\n\nstatic __be32 *\ndecode_pathname(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXPATHLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}\n\nstatic __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}\n\nstatic __be32 *\nencode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t     struct kstat *stat)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tint type;\n\tstruct timespec time;\n\tu32 f;\n\n\ttype = (stat->mode & S_IFMT);\n\n\t*p++ = htonl(nfs_ftypes[type >> 12]);\n\t*p++ = htonl((u32) stat->mode);\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\n\tif (S_ISLNK(type) && stat->size > NFS_MAXPATHLEN) {\n\t\t*p++ = htonl(NFS_MAXPATHLEN);\n\t} else {\n\t\t*p++ = htonl((u32) stat->size);\n\t}\n\t*p++ = htonl((u32) stat->blksize);\n\tif (S_ISCHR(type) || S_ISBLK(type))\n\t\t*p++ = htonl(new_encode_dev(stat->rdev));\n\telse\n\t\t*p++ = htonl(0xffffffff);\n\t*p++ = htonl((u32) stat->blocks);\n\tswitch (fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\t*p++ = htonl(new_encode_dev(stat->dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\t*p++ = htonl((u32) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u32*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[1];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[2];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[3];\n\t\t*p++ = htonl(f);\n\t\tbreak;\n\t}\n\t*p++ = htonl((u32) stat->ino);\n\t*p++ = htonl((u32) stat->atime.tv_sec);\n\t*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);\n\tlease_get_mtime(d_inode(dentry), &time); \n\t*p++ = htonl((u32) time.tv_sec);\n\t*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0); \n\t*p++ = htonl((u32) stat->ctime.tv_sec);\n\t*p++ = htonl(stat->ctime.tv_nsec ? stat->ctime.tv_nsec / 1000 : 0);\n\n\treturn p;\n}\n\n/* Helper function for NFSv2 ACL code */\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}\n\n/*\n * XDR decode functions\n */\nint\nnfssvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\targs->offset    = ntohl(*p++);\n\tlen = args->count     = ntohl(*p++);\n\tp++; /* totalcount - unused */\n\n\tlen = min_t(unsigned int, len, NFSSVC_MAXBLKSIZE_V2);\n\n\t/* set up somewhere to store response.\n\t * We take pages, put them on reslist and include in iovec\n\t */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}\n\nint\nnfssvc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_createargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->fh))\n\t    || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_symlinkargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->ffh))\n\t    || !(p = decode_filename(p, &args->fname, &args->flen))\n\t    || !(p = decode_pathname(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->cookie = ntohl(*p++);\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\n/*\n * XDR encode functions\n */\nint\nnfssvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_attrstat *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropres *resp)\n{\n\tp = encode_fh(p, &resp->fh);\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readlinkres *resp)\n{\n\t*p++ = htonl(resp->len);\n\txdr_ressize_check(rqstp, p);\n\trqstp->rq_res.page_len = resp->len;\n\tif (resp->len & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t}\n\treturn 1;\n}\n\nint\nnfssvc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readres *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->count);\n\txdr_ressize_check(rqstp, p);\n\n\t/* now update rqstp->rq_res to reflect data as well */\n\trqstp->rq_res.page_len = resp->count;\n\tif (resp->count & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count&3);\n\t}\n\treturn 1;\n}\n\nint\nnfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirres *resp)\n{\n\txdr_ressize_check(rqstp, p);\n\tp = resp->buffer;\n\t*p++ = 0;\t\t\t/* no more entries */\n\t*p++ = htonl((resp->common.err == nfserr_eof));\n\trqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;\n\n\treturn 1;\n}\n\nint\nnfssvc_encode_statfsres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_statfsres *resp)\n{\n\tstruct kstatfs\t*stat = &resp->stats;\n\n\t*p++ = htonl(NFSSVC_MAXBLKSIZE_V2);\t/* max transfer size */\n\t*p++ = htonl(stat->f_bsize);\n\t*p++ = htonl(stat->f_blocks);\n\t*p++ = htonl(stat->f_bfree);\n\t*p++ = htonl(stat->f_bavail);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_entry(void *ccdv, const char *name,\n\t\t    int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd_readdirres *cd = container_of(ccd, struct nfsd_readdirres, common);\n\t__be32\t*p = cd->buffer;\n\tint\tbuflen, slen;\n\n\t/*\n\tdprintk(\"nfsd: entry(%.*s off %ld ino %ld)\\n\",\n\t\t\tnamlen, name, offset, ino);\n\t */\n\n\tif (offset > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\tif (cd->offset)\n\t\t*cd->offset = htonl(offset);\n\n\t/* truncate filename */\n\tnamlen = min(namlen, NFS2_MAXNAMLEN);\n\tslen = XDR_QUADLEN(namlen);\n\n\tif ((buflen = cd->buflen - slen - 4) < 0) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\tif (ino > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\t*p++ = xdr_one;\t\t\t\t/* mark entry present */\n\t*p++ = htonl((u32) ino);\t\t/* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\tcd->offset = p;\t\t\t/* remember pointer */\n\t*p++ = htonl(~0U);\t\t/* offset of next entry */\n\n\tcd->buflen = buflen;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n}\n\n/*\n * XDR release functions\n */\nint\nnfssvc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_fhandle *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}\n"], "fixing_code": ["/*\n * XDR support for nfsd/protocol version 3.\n *\n * Copyright (C) 1995, 1996, 1997 Olaf Kirch <okir@monad.swb.de>\n *\n * 2003-08-09 Jamie Lokier: Use htonl() for nanoseconds, not htons()!\n */\n\n#include <linux/namei.h>\n#include <linux/sunrpc/svc_xprt.h>\n#include \"xdr3.h\"\n#include \"auth.h\"\n#include \"netns.h\"\n#include \"vfs.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_XDR\n\n\n/*\n * Mapping of S_IF* types to NFS file types\n */\nstatic u32\tnfs3_ftypes[] = {\n\tNF3NON,  NF3FIFO, NF3CHR, NF3BAD,\n\tNF3DIR,  NF3BAD,  NF3BLK, NF3BAD,\n\tNF3REG,  NF3BAD,  NF3LNK, NF3BAD,\n\tNF3SOCK, NF3BAD,  NF3LNK, NF3BAD,\n};\n\n/*\n * XDR functions for basic NFS types\n */\nstatic __be32 *\nencode_time3(__be32 *p, struct timespec *time)\n{\n\t*p++ = htonl((u32) time->tv_sec); *p++ = htonl(time->tv_nsec);\n\treturn p;\n}\n\nstatic __be32 *\ndecode_time3(__be32 *p, struct timespec *time)\n{\n\ttime->tv_sec = ntohl(*p++);\n\ttime->tv_nsec = ntohl(*p++);\n\treturn p;\n}\n\nstatic __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size;\n\tfh_init(fhp, NFS3_FHSIZE);\n\tsize = ntohl(*p++);\n\tif (size > NFS3_FHSIZE)\n\t\treturn NULL;\n\n\tmemcpy(&fhp->fh_handle.fh_base, p, size);\n\tfhp->fh_handle.fh_size = size;\n\treturn p + XDR_QUADLEN(size);\n}\n\n/* Helper function for NFSv3 ACL code */\n__be32 *nfs3svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tunsigned int size = fhp->fh_handle.fh_size;\n\t*p++ = htonl(size);\n\tif (size) p[XDR_QUADLEN(size)-1]=0;\n\tmemcpy(p, &fhp->fh_handle.fh_base, size);\n\treturn p + XDR_QUADLEN(size);\n}\n\n/*\n * Decode a file name and make sure that the path contains\n * no slashes or null bytes.\n */\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS3_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}\n\nstatic __be32 *\ndecode_sattr3(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp;\n\n\tiap->ia_valid = 0;\n\n\tif (*p++) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = ntohl(*p++);\n\t}\n\tif (*p++) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, ntohl(*p++));\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif (*p++) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, ntohl(*p++));\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif (*p++) {\n\t\tu64\tnewsize;\n\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tp = xdr_decode_hyper(p, &newsize);\n\t\tiap->ia_size = min_t(u64, newsize, NFS_OFFSET_MAX);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_ATIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = ntohl(*p++);\n\t\tiap->ia_atime.tv_nsec = ntohl(*p++);\n\t}\n\tif ((tmp = ntohl(*p++)) == 1) {\t/* set to server time */\n\t\tiap->ia_valid |= ATTR_MTIME;\n\t} else if (tmp == 2) {\t\t/* set to client time */\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = ntohl(*p++);\n\t\tiap->ia_mtime.tv_nsec = ntohl(*p++);\n\t}\n\treturn p;\n}\n\nstatic __be32 *encode_fsid(__be32 *p, struct svc_fh *fhp)\n{\n\tu64 f;\n\tswitch(fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\tp = xdr_encode_hyper(p, (u64)huge_encode_dev\n\t\t\t\t     (fhp->fh_dentry->d_sb->s_dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u64*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u64*)fhp->fh_export->ex_uuid)[1];\n\t\tp = xdr_encode_hyper(p, f);\n\t\tbreak;\n\t}\n\treturn p;\n}\n\nstatic __be32 *\nencode_fattr3(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t      struct kstat *stat)\n{\n\t*p++ = htonl(nfs3_ftypes[(stat->mode & S_IFMT) >> 12]);\n\t*p++ = htonl((u32) (stat->mode & S_IALLUGO));\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\tif (S_ISLNK(stat->mode) && stat->size > NFS3_MAXPATHLEN) {\n\t\tp = xdr_encode_hyper(p, (u64) NFS3_MAXPATHLEN);\n\t} else {\n\t\tp = xdr_encode_hyper(p, (u64) stat->size);\n\t}\n\tp = xdr_encode_hyper(p, ((u64)stat->blocks) << 9);\n\t*p++ = htonl((u32) MAJOR(stat->rdev));\n\t*p++ = htonl((u32) MINOR(stat->rdev));\n\tp = encode_fsid(p, fhp);\n\tp = xdr_encode_hyper(p, stat->ino);\n\tp = encode_time3(p, &stat->atime);\n\tp = encode_time3(p, &stat->mtime);\n\tp = encode_time3(p, &stat->ctime);\n\n\treturn p;\n}\n\nstatic __be32 *\nencode_saved_post_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\t/* Attributes to follow */\n\t*p++ = xdr_one;\n\treturn encode_fattr3(rqstp, p, fhp, &fhp->fh_post_attr);\n}\n\n/*\n * Encode post-operation attributes.\n * The inode may be NULL if the call failed because of a stale file\n * handle. In this case, no attributes are returned.\n */\nstatic __be32 *\nencode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry *dentry = fhp->fh_dentry;\n\tif (dentry && d_really_is_positive(dentry)) {\n\t        __be32 err;\n\t\tstruct kstat stat;\n\n\t\terr = fh_getattr(fhp, &stat);\n\t\tif (!err) {\n\t\t\t*p++ = xdr_one;\t\t/* attributes follow */\n\t\t\tlease_get_mtime(d_inode(dentry), &stat.mtime);\n\t\t\treturn encode_fattr3(rqstp, p, fhp, &stat);\n\t\t}\n\t}\n\t*p++ = xdr_zero;\n\treturn p;\n}\n\n/* Helper for NFSv3 ACLs */\n__be32 *\nnfs3svc_encode_post_op_attr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}\n\n/*\n * Enocde weak cache consistency data\n */\nstatic __be32 *\nencode_wcc_data(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\n\tif (dentry && d_really_is_positive(dentry) && fhp->fh_post_saved) {\n\t\tif (fhp->fh_pre_saved) {\n\t\t\t*p++ = xdr_one;\n\t\t\tp = xdr_encode_hyper(p, (u64) fhp->fh_pre_size);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_mtime);\n\t\t\tp = encode_time3(p, &fhp->fh_pre_ctime);\n\t\t} else {\n\t\t\t*p++ = xdr_zero;\n\t\t}\n\t\treturn encode_saved_post_attr(rqstp, p, fhp);\n\t}\n\t/* no pre- or post-attrs */\n\t*p++ = xdr_zero;\n\treturn encode_post_op_attr(rqstp, p, fhp);\n}\n\n/*\n * Fill in the post_op attr for the wcc data\n */\nvoid fill_post_wcc(struct svc_fh *fhp)\n{\n\t__be32 err;\n\n\tif (fhp->fh_post_saved)\n\t\tprintk(\"nfsd: inode locked twice during operation.\\n\");\n\n\terr = fh_getattr(fhp, &fhp->fh_post_attr);\n\tfhp->fh_post_change = d_inode(fhp->fh_dentry)->i_version;\n\tif (err) {\n\t\tfhp->fh_post_saved = false;\n\t\t/* Grab the ctime anyway - set_change_info might use it */\n\t\tfhp->fh_post_attr.ctime = d_inode(fhp->fh_dentry)->i_ctime;\n\t} else\n\t\tfhp->fh_post_saved = true;\n}\n\n/*\n * XDR decode functions\n */\nint\nnfs3svc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\tif ((args->check_guard = ntohl(*p++)) != 0) { \n\t\tstruct timespec time; \n\t\tp = decode_time3(p, &time);\n\t\targs->guardtime = time.tv_sec;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_accessargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->access = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\tlen = min(args->count, max_blocksize);\n\n\t/* set up the kvec */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeargs *args)\n{\n\tunsigned int len, v, hdr, dlen;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tstruct kvec *tail = rqstp->rq_arg.tail;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\n\targs->count = ntohl(*p++);\n\targs->stable = ntohl(*p++);\n\tlen = args->len = ntohl(*p++);\n\tif ((void *)p > head->iov_base + head->iov_len)\n\t\treturn 0;\n\t/*\n\t * The count must equal the amount of data passed.\n\t */\n\tif (args->count != args->len)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len + tail->iov_len - hdr;\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\tif (args->count > max_blocksize) {\n\t\targs->count = max_blocksize;\n\t\tlen = args->len = max_blocksize;\n\t}\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}\n\nint\nnfs3svc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\tswitch (args->createmode = ntohl(*p++)) {\n\tcase NFS3_CREATE_UNCHECKED:\n\tcase NFS3_CREATE_GUARDED:\n\t\tp = decode_sattr3(p, &args->attrs);\n\t\tbreak;\n\tcase NFS3_CREATE_EXCLUSIVE:\n\t\targs->verf = p;\n\t\tp += 2;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\nint\nnfs3svc_decode_mkdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_createargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh)) ||\n\t    !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_symlinkargs *args)\n{\n\tunsigned int len, avail;\n\tchar *old, *new;\n\tstruct kvec *vec;\n\n\tif (!(p = decode_fh(p, &args->ffh)) ||\n\t    !(p = decode_filename(p, &args->fname, &args->flen))\n\t\t)\n\t\treturn 0;\n\tp = decode_sattr3(p, &args->attrs);\n\n\t/* now decode the pathname, which might be larger than the first page.\n\t * As we have to check for nul's anyway, we copy it into a new page\n\t * This page appears in the rq_res.pages list, but as pages_len is always\n\t * 0, it won't get in the way\n\t */\n\tlen = ntohl(*p++);\n\tif (len == 0 || len > NFS3_MAXPATHLEN || len >= PAGE_SIZE)\n\t\treturn 0;\n\targs->tname = new = page_address(*(rqstp->rq_next_page++));\n\targs->tlen = len;\n\t/* first copy and check from the first page */\n\told = (char*)p;\n\tvec = &rqstp->rq_arg.head[0];\n\tif ((void *)old > vec->iov_base + vec->iov_len)\n\t\treturn 0;\n\tavail = vec->iov_len - (old - (char*)vec->iov_base);\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t/* now copy next page if there is one */\n\tif (len && !avail && rqstp->rq_arg.page_len) {\n\t\tavail = min_t(unsigned int, rqstp->rq_arg.page_len, PAGE_SIZE);\n\t\told = page_address(rqstp->rq_arg.pages[0]);\n\t}\n\twhile (len && avail && *old) {\n\t\t*new++ = *old++;\n\t\tlen--;\n\t\tavail--;\n\t}\n\t*new = '\\0';\n\tif (len)\n\t\treturn 0;\n\n\treturn 1;\n}\n\nint\nnfs3svc_decode_mknodargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_mknodargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\targs->ftype = ntohl(*p++);\n\n\tif (args->ftype == NF3BLK  || args->ftype == NF3CHR\n\t || args->ftype == NF3SOCK || args->ftype == NF3FIFO)\n\t\tp = decode_sattr3(p, &args->attrs);\n\n\tif (args->ftype == NF3BLK || args->ftype == NF3CHR) {\n\t\targs->major = ntohl(*p++);\n\t\targs->minor = ntohl(*p++);\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf   = p; p += 2;\n\targs->dircount = ~0;\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_readdirplusargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirargs *args)\n{\n\tint len;\n\tu32 max_blocksize = svc_max_payload(rqstp);\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->cookie);\n\targs->verf     = p; p += 2;\n\targs->dircount = ntohl(*p++);\n\targs->count    = ntohl(*p++);\n\n\tlen = args->count = min(args->count, max_blocksize);\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\t\tif (!args->buffer)\n\t\t\targs->buffer = page_address(p);\n\t\tlen -= PAGE_SIZE;\n\t}\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfs3svc_decode_commitargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = xdr_decode_hyper(p, &args->offset);\n\targs->count = ntohl(*p++);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\n/*\n * XDR encode functions\n */\n/*\n * There must be an encoding function for void results so svc_process\n * will work properly.\n */\nint\nnfs3svc_encode_voidres(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* GETATTR */\nint\nnfs3svc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tif (resp->status == 0) {\n\t\tlease_get_mtime(d_inode(resp->fh.fh_dentry),\n\t\t\t\t&resp->stat.mtime);\n\t\tp = encode_fattr3(rqstp, p, &resp->fh, &resp->stat);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* SETATTR, REMOVE, RMDIR */\nint\nnfs3svc_encode_wccstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* LOOKUP */\nint\nnfs3svc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_post_op_attr(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* ACCESS */\nint\nnfs3svc_encode_accessres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_accessres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0)\n\t\t*p++ = htonl(resp->access);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* READLINK */\nint\nnfs3svc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readlinkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->len);\n\t\txdr_ressize_check(rqstp, p);\n\t\trqstp->rq_res.page_len = resp->len;\n\t\tif (resp->len & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* READ */\nint\nnfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->eof);\n\t\t*p++ = htonl(resp->count);\t/* xdr opaque count */\n\t\txdr_ressize_check(rqstp, p);\n\t\t/* now update rqstp->rq_res to reflect data as well */\n\t\trqstp->rq_res.page_len = resp->count;\n\t\tif (resp->count & 3) {\n\t\t\t/* need to pad the tail */\n\t\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t\t*p = 0;\n\t\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count & 3);\n\t\t}\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* WRITE */\nint\nnfs3svc_encode_writeres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_writeres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->count);\n\t\t*p++ = htonl(resp->committed);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* CREATE, MKDIR, SYMLINK, MKNOD */\nint\nnfs3svc_encode_createres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_diropres *resp)\n{\n\tif (resp->status == 0) {\n\t\t*p++ = xdr_one;\n\t\tp = encode_fh(p, &resp->fh);\n\t\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\t}\n\tp = encode_wcc_data(rqstp, p, &resp->dirfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* RENAME */\nint\nnfs3svc_encode_renameres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_renameres *resp)\n{\n\tp = encode_wcc_data(rqstp, p, &resp->ffh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* LINK */\nint\nnfs3svc_encode_linkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_linkres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\tp = encode_wcc_data(rqstp, p, &resp->tfh);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* READDIR */\nint\nnfs3svc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_readdirres *resp)\n{\n\tp = encode_post_op_attr(rqstp, p, &resp->fh);\n\n\tif (resp->status == 0) {\n\t\t/* stupid readdir cookie */\n\t\tmemcpy(p, resp->verf, 8); p += 2;\n\t\txdr_ressize_check(rqstp, p);\n\t\tif (rqstp->rq_res.head[0].iov_len + (2<<2) > PAGE_SIZE)\n\t\t\treturn 1; /*No room for trailer */\n\t\trqstp->rq_res.page_len = (resp->count) << 2;\n\n\t\t/* add the 'tail' to the end of the 'head' page - page 0. */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p++ = 0;\t\t/* no more entries */\n\t\t*p++ = htonl(resp->common.err == nfserr_eof);\n\t\trqstp->rq_res.tail[0].iov_len = 2<<2;\n\t\treturn 1;\n\t} else\n\t\treturn xdr_ressize_check(rqstp, p);\n}\n\nstatic __be32 *\nencode_entry_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name,\n\t     int namlen, u64 ino)\n{\n\t*p++ = xdr_one;\t\t\t\t /* mark entry present */\n\tp    = xdr_encode_hyper(p, ino);\t /* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\n\tcd->offset = p;\t\t\t\t/* remember pointer */\n\tp = xdr_encode_hyper(p, NFS_OFFSET_MAX);/* offset of next entry */\n\n\treturn p;\n}\n\nstatic __be32\ncompose_entry_fh(struct nfsd3_readdirres *cd, struct svc_fh *fhp,\n\t\t const char *name, int namlen, u64 ino)\n{\n\tstruct svc_export\t*exp;\n\tstruct dentry\t\t*dparent, *dchild;\n\t__be32 rv = nfserr_noent;\n\n\tdparent = cd->fh.fh_dentry;\n\texp  = cd->fh.fh_export;\n\n\tif (isdotent(name, namlen)) {\n\t\tif (namlen == 2) {\n\t\t\tdchild = dget_parent(dparent);\n\t\t\t/* filesystem root - cannot return filehandle for \"..\" */\n\t\t\tif (dchild == dparent)\n\t\t\t\tgoto out;\n\t\t} else\n\t\t\tdchild = dget(dparent);\n\t} else\n\t\tdchild = lookup_one_len_unlocked(name, dparent, namlen);\n\tif (IS_ERR(dchild))\n\t\treturn rv;\n\tif (d_mountpoint(dchild))\n\t\tgoto out;\n\tif (d_really_is_negative(dchild))\n\t\tgoto out;\n\tif (dchild->d_inode->i_ino != ino)\n\t\tgoto out;\n\trv = fh_compose(fhp, exp, dchild, &cd->fh);\nout:\n\tdput(dchild);\n\treturn rv;\n}\n\nstatic __be32 *encode_entryplus_baggage(struct nfsd3_readdirres *cd, __be32 *p, const char *name, int namlen, u64 ino)\n{\n\tstruct svc_fh\t*fh = &cd->scratch;\n\t__be32 err;\n\n\tfh_init(fh, NFS3_FHSIZE);\n\terr = compose_entry_fh(cd, fh, name, namlen, ino);\n\tif (err) {\n\t\t*p++ = 0;\n\t\t*p++ = 0;\n\t\tgoto out;\n\t}\n\tp = encode_post_op_attr(cd->rqstp, p, fh);\n\t*p++ = xdr_one;\t\t\t/* yes, a file handle follows */\n\tp = encode_fh(p, fh);\nout:\n\tfh_put(fh);\n\treturn p;\n}\n\n/*\n * Encode a directory entry. This one works for both normal readdir\n * and readdirplus.\n * The normal readdir reply requires 2 (fileid) + 1 (stringlen)\n * + string + 2 (cookie) + 1 (next) words, i.e. 6 + strlen.\n * \n * The readdirplus baggage is 1+21 words for post_op_attr, plus the\n * file handle.\n */\n\n#define NFS3_ENTRY_BAGGAGE\t(2 + 1 + 2 + 1)\n#define NFS3_ENTRYPLUS_BAGGAGE\t(1 + 21 + 1 + (NFS3_FHSIZE >> 2))\nstatic int\nencode_entry(struct readdir_cd *ccd, const char *name, int namlen,\n\t     loff_t offset, u64 ino, unsigned int d_type, int plus)\n{\n\tstruct nfsd3_readdirres *cd = container_of(ccd, struct nfsd3_readdirres,\n\t\t       \t\t\t\t\tcommon);\n\t__be32\t\t*p = cd->buffer;\n\tcaddr_t\t\tcurr_page_addr = NULL;\n\tstruct page **\tpage;\n\tint\t\tslen;\t\t/* string (name) length */\n\tint\t\telen;\t\t/* estimated entry length in words */\n\tint\t\tnum_entry_words = 0;\t/* actual number of words */\n\n\tif (cd->offset) {\n\t\tu64 offset64 = offset;\n\n\t\tif (unlikely(cd->offset1)) {\n\t\t\t/* we ended up with offset on a page boundary */\n\t\t\t*cd->offset = htonl(offset64 >> 32);\n\t\t\t*cd->offset1 = htonl(offset64 & 0xffffffff);\n\t\t\tcd->offset1 = NULL;\n\t\t} else {\n\t\t\txdr_encode_hyper(cd->offset, offset64);\n\t\t}\n\t}\n\n\t/*\n\tdprintk(\"encode_entry(%.*s @%ld%s)\\n\",\n\t\tnamlen, name, (long) offset, plus? \" plus\" : \"\");\n\t */\n\n\t/* truncate filename if too long */\n\tnamlen = min(namlen, NFS3_MAXNAMLEN);\n\n\tslen = XDR_QUADLEN(namlen);\n\telen = slen + NFS3_ENTRY_BAGGAGE\n\t\t+ (plus? NFS3_ENTRYPLUS_BAGGAGE : 0);\n\n\tif (cd->buflen < elen) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\t/* determine which page in rq_respages[] we are currently filling */\n\tfor (page = cd->rqstp->rq_respages + 1;\n\t\t\t\tpage < cd->rqstp->rq_next_page; page++) {\n\t\tcurr_page_addr = page_address(*page);\n\n\t\tif (((caddr_t)cd->buffer >= curr_page_addr) &&\n\t\t    ((caddr_t)cd->buffer <  curr_page_addr + PAGE_SIZE))\n\t\t\tbreak;\n\t}\n\n\tif ((caddr_t)(cd->buffer + elen) < (curr_page_addr + PAGE_SIZE)) {\n\t\t/* encode entry in current page */\n\n\t\tp = encode_entry_baggage(cd, p, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp = encode_entryplus_baggage(cd, p, name, namlen, ino);\n\t\tnum_entry_words = p - cd->buffer;\n\t} else if (*(page+1) != NULL) {\n\t\t/* temporarily encode entry into next page, then move back to\n\t\t * current and next page in rq_respages[] */\n\t\t__be32 *p1, *tmp;\n\t\tint len1, len2;\n\n\t\t/* grab next page for temporary storage of entry */\n\t\tp1 = tmp = page_address(*(page+1));\n\n\t\tp1 = encode_entry_baggage(cd, p1, name, namlen, ino);\n\n\t\tif (plus)\n\t\t\tp1 = encode_entryplus_baggage(cd, p1, name, namlen, ino);\n\n\t\t/* determine entry word length and lengths to go in pages */\n\t\tnum_entry_words = p1 - tmp;\n\t\tlen1 = curr_page_addr + PAGE_SIZE - (caddr_t)cd->buffer;\n\t\tif ((num_entry_words << 2) < len1) {\n\t\t\t/* the actual number of words in the entry is less\n\t\t\t * than elen and can still fit in the current page\n\t\t\t */\n\t\t\tmemmove(p, tmp, num_entry_words << 2);\n\t\t\tp += num_entry_words;\n\n\t\t\t/* update offset */\n\t\t\tcd->offset = cd->buffer + (cd->offset - tmp);\n\t\t} else {\n\t\t\tunsigned int offset_r = (cd->offset - tmp) << 2;\n\n\t\t\t/* update pointer to offset location.\n\t\t\t * This is a 64bit quantity, so we need to\n\t\t\t * deal with 3 cases:\n\t\t\t *  -\tentirely in first page\n\t\t\t *  -\tentirely in second page\n\t\t\t *  -\t4 bytes in each page\n\t\t\t */\n\t\t\tif (offset_r + 8 <= len1) {\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t} else if (offset_r >= len1) {\n\t\t\t\tcd->offset -= len1 >> 2;\n\t\t\t} else {\n\t\t\t\t/* sitting on the fence */\n\t\t\t\tBUG_ON(offset_r != len1 - 4);\n\t\t\t\tcd->offset = p + (cd->offset - tmp);\n\t\t\t\tcd->offset1 = tmp;\n\t\t\t}\n\n\t\t\tlen2 = (num_entry_words << 2) - len1;\n\n\t\t\t/* move from temp page to current and next pages */\n\t\t\tmemmove(p, tmp, len1);\n\t\t\tmemmove(tmp, (caddr_t)tmp+len1, len2);\n\n\t\t\tp = tmp + (len2 >> 2);\n\t\t}\n\t}\n\telse {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\n\tcd->buflen -= num_entry_words;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n\n}\n\nint\nnfs3svc_encode_entry(void *cd, const char *name,\n\t\t     int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 0);\n}\n\nint\nnfs3svc_encode_entry_plus(void *cd, const char *name,\n\t\t\t  int namlen, loff_t offset, u64 ino,\n\t\t\t  unsigned int d_type)\n{\n\treturn encode_entry(cd, name, namlen, offset, ino, d_type, 1);\n}\n\n/* FSSTAT */\nint\nnfs3svc_encode_fsstatres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsstatres *resp)\n{\n\tstruct kstatfs\t*s = &resp->stats;\n\tu64\t\tbs = s->f_bsize;\n\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\tp = xdr_encode_hyper(p, bs * s->f_blocks);\t/* total bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bfree);\t/* free bytes */\n\t\tp = xdr_encode_hyper(p, bs * s->f_bavail);\t/* user available bytes */\n\t\tp = xdr_encode_hyper(p, s->f_files);\t/* total inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* free inodes */\n\t\tp = xdr_encode_hyper(p, s->f_ffree);\t/* user available inodes */\n\t\t*p++ = htonl(resp->invarsec);\t/* mean unchanged time */\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* FSINFO */\nint\nnfs3svc_encode_fsinfores(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fsinfores *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->f_rtmax);\n\t\t*p++ = htonl(resp->f_rtpref);\n\t\t*p++ = htonl(resp->f_rtmult);\n\t\t*p++ = htonl(resp->f_wtmax);\n\t\t*p++ = htonl(resp->f_wtpref);\n\t\t*p++ = htonl(resp->f_wtmult);\n\t\t*p++ = htonl(resp->f_dtpref);\n\t\tp = xdr_encode_hyper(p, resp->f_maxfilesize);\n\t\t*p++ = xdr_one;\n\t\t*p++ = xdr_zero;\n\t\t*p++ = htonl(resp->f_properties);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* PATHCONF */\nint\nnfs3svc_encode_pathconfres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_pathconfres *resp)\n{\n\t*p++ = xdr_zero;\t/* no post_op_attr */\n\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(resp->p_link_max);\n\t\t*p++ = htonl(resp->p_name_max);\n\t\t*p++ = htonl(resp->p_no_trunc);\n\t\t*p++ = htonl(resp->p_chown_restricted);\n\t\t*p++ = htonl(resp->p_case_insensitive);\n\t\t*p++ = htonl(resp->p_case_preserving);\n\t}\n\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/* COMMIT */\nint\nnfs3svc_encode_commitres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_commitres *resp)\n{\n\tstruct nfsd_net *nn = net_generic(SVC_NET(rqstp), nfsd_net_id);\n\n\tp = encode_wcc_data(rqstp, p, &resp->fh);\n\t/* Write verifier */\n\tif (resp->status == 0) {\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_sec);\n\t\t*p++ = htonl(nn->nfssvc_boot.tv_usec);\n\t}\n\treturn xdr_ressize_check(rqstp, p);\n}\n\n/*\n * XDR release functions\n */\nint\nnfs3svc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_attrstat *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}\n\nint\nnfs3svc_release_fhandle2(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd3_fhandle_pair *resp)\n{\n\tfh_put(&resp->fh1);\n\tfh_put(&resp->fh2);\n\treturn 1;\n}\n", "/*\n * XDR support for nfsd\n *\n * Copyright (C) 1995, 1996 Olaf Kirch <okir@monad.swb.de>\n */\n\n#include \"vfs.h\"\n#include \"xdr.h\"\n#include \"auth.h\"\n\n#define NFSDDBG_FACILITY\t\tNFSDDBG_XDR\n\n/*\n * Mapping of S_IF* types to NFS file types\n */\nstatic u32\tnfs_ftypes[] = {\n\tNFNON,  NFCHR,  NFCHR, NFBAD,\n\tNFDIR,  NFBAD,  NFBLK, NFBAD,\n\tNFREG,  NFBAD,  NFLNK, NFBAD,\n\tNFSOCK, NFBAD,  NFLNK, NFBAD,\n};\n\n\n/*\n * XDR functions for basic NFS types\n */\nstatic __be32 *\ndecode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tfh_init(fhp, NFS_FHSIZE);\n\tmemcpy(&fhp->fh_handle.fh_base, p, NFS_FHSIZE);\n\tfhp->fh_handle.fh_size = NFS_FHSIZE;\n\n\t/* FIXME: Look up export pointer here and verify\n\t * Sun Secure RPC if requested */\n\treturn p + (NFS_FHSIZE >> 2);\n}\n\n/* Helper function for NFSv2 ACL code */\n__be32 *nfs2svc_decode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\treturn decode_fh(p, fhp);\n}\n\nstatic __be32 *\nencode_fh(__be32 *p, struct svc_fh *fhp)\n{\n\tmemcpy(p, &fhp->fh_handle.fh_base, NFS_FHSIZE);\n\treturn p + (NFS_FHSIZE>> 2);\n}\n\n/*\n * Decode a file name and make sure that the path contains\n * no slashes or null bytes.\n */\nstatic __be32 *\ndecode_filename(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXNAMLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0' || *name == '/')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}\n\nstatic __be32 *\ndecode_pathname(__be32 *p, char **namp, unsigned int *lenp)\n{\n\tchar\t\t*name;\n\tunsigned int\ti;\n\n\tif ((p = xdr_decode_string_inplace(p, namp, lenp, NFS_MAXPATHLEN)) != NULL) {\n\t\tfor (i = 0, name = *namp; i < *lenp; i++, name++) {\n\t\t\tif (*name == '\\0')\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn p;\n}\n\nstatic __be32 *\ndecode_sattr(__be32 *p, struct iattr *iap)\n{\n\tu32\ttmp, tmp1;\n\n\tiap->ia_valid = 0;\n\n\t/* Sun client bug compatibility check: some sun clients seem to\n\t * put 0xffff in the mode field when they mean 0xffffffff.\n\t * Quoting the 4.4BSD nfs server code: Nah nah nah nah na nah.\n\t */\n\tif ((tmp = ntohl(*p++)) != (u32)-1 && tmp != 0xffff) {\n\t\tiap->ia_valid |= ATTR_MODE;\n\t\tiap->ia_mode = tmp;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_uid = make_kuid(&init_user_ns, tmp);\n\t\tif (uid_valid(iap->ia_uid))\n\t\t\tiap->ia_valid |= ATTR_UID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_gid = make_kgid(&init_user_ns, tmp);\n\t\tif (gid_valid(iap->ia_gid))\n\t\t\tiap->ia_valid |= ATTR_GID;\n\t}\n\tif ((tmp = ntohl(*p++)) != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_SIZE;\n\t\tiap->ia_size = tmp;\n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_ATIME | ATTR_ATIME_SET;\n\t\tiap->ia_atime.tv_sec = tmp;\n\t\tiap->ia_atime.tv_nsec = tmp1 * 1000; \n\t}\n\ttmp  = ntohl(*p++); tmp1 = ntohl(*p++);\n\tif (tmp != (u32)-1 && tmp1 != (u32)-1) {\n\t\tiap->ia_valid |= ATTR_MTIME | ATTR_MTIME_SET;\n\t\tiap->ia_mtime.tv_sec = tmp;\n\t\tiap->ia_mtime.tv_nsec = tmp1 * 1000; \n\t\t/*\n\t\t * Passing the invalid value useconds=1000000 for mtime\n\t\t * is a Sun convention for \"set both mtime and atime to\n\t\t * current server time\".  It's needed to make permissions\n\t\t * checks for the \"touch\" program across v2 mounts to\n\t\t * Solaris and Irix boxes work correctly. See description of\n\t\t * sattr in section 6.1 of \"NFS Illustrated\" by\n\t\t * Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5\n\t\t */\n\t\tif (tmp1 == 1000000)\n\t\t\tiap->ia_valid &= ~(ATTR_ATIME_SET|ATTR_MTIME_SET);\n\t}\n\treturn p;\n}\n\nstatic __be32 *\nencode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp,\n\t     struct kstat *stat)\n{\n\tstruct dentry\t*dentry = fhp->fh_dentry;\n\tint type;\n\tstruct timespec time;\n\tu32 f;\n\n\ttype = (stat->mode & S_IFMT);\n\n\t*p++ = htonl(nfs_ftypes[type >> 12]);\n\t*p++ = htonl((u32) stat->mode);\n\t*p++ = htonl((u32) stat->nlink);\n\t*p++ = htonl((u32) from_kuid(&init_user_ns, stat->uid));\n\t*p++ = htonl((u32) from_kgid(&init_user_ns, stat->gid));\n\n\tif (S_ISLNK(type) && stat->size > NFS_MAXPATHLEN) {\n\t\t*p++ = htonl(NFS_MAXPATHLEN);\n\t} else {\n\t\t*p++ = htonl((u32) stat->size);\n\t}\n\t*p++ = htonl((u32) stat->blksize);\n\tif (S_ISCHR(type) || S_ISBLK(type))\n\t\t*p++ = htonl(new_encode_dev(stat->rdev));\n\telse\n\t\t*p++ = htonl(0xffffffff);\n\t*p++ = htonl((u32) stat->blocks);\n\tswitch (fsid_source(fhp)) {\n\tdefault:\n\tcase FSIDSOURCE_DEV:\n\t\t*p++ = htonl(new_encode_dev(stat->dev));\n\t\tbreak;\n\tcase FSIDSOURCE_FSID:\n\t\t*p++ = htonl((u32) fhp->fh_export->ex_fsid);\n\t\tbreak;\n\tcase FSIDSOURCE_UUID:\n\t\tf = ((u32*)fhp->fh_export->ex_uuid)[0];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[1];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[2];\n\t\tf ^= ((u32*)fhp->fh_export->ex_uuid)[3];\n\t\t*p++ = htonl(f);\n\t\tbreak;\n\t}\n\t*p++ = htonl((u32) stat->ino);\n\t*p++ = htonl((u32) stat->atime.tv_sec);\n\t*p++ = htonl(stat->atime.tv_nsec ? stat->atime.tv_nsec / 1000 : 0);\n\tlease_get_mtime(d_inode(dentry), &time); \n\t*p++ = htonl((u32) time.tv_sec);\n\t*p++ = htonl(time.tv_nsec ? time.tv_nsec / 1000 : 0); \n\t*p++ = htonl((u32) stat->ctime.tv_sec);\n\t*p++ = htonl(stat->ctime.tv_nsec ? stat->ctime.tv_nsec / 1000 : 0);\n\n\treturn p;\n}\n\n/* Helper function for NFSv2 ACL code */\n__be32 *nfs2svc_encode_fattr(struct svc_rqst *rqstp, __be32 *p, struct svc_fh *fhp, struct kstat *stat)\n{\n\treturn encode_fattr(rqstp, p, fhp, stat);\n}\n\n/*\n * XDR decode functions\n */\nint\nnfssvc_decode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_fhandle(struct svc_rqst *rqstp, __be32 *p, struct nfsd_fhandle *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_sattrargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_sattrargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_diropargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropargs *args)\n{\n\tif (!(p = decode_fh(p, &args->fh))\n\t || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_readargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readargs *args)\n{\n\tunsigned int len;\n\tint v;\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\targs->offset    = ntohl(*p++);\n\tlen = args->count     = ntohl(*p++);\n\tp++; /* totalcount - unused */\n\n\tlen = min_t(unsigned int, len, NFSSVC_MAXBLKSIZE_V2);\n\n\t/* set up somewhere to store response.\n\t * We take pages, put them on reslist and include in iovec\n\t */\n\tv=0;\n\twhile (len > 0) {\n\t\tstruct page *p = *(rqstp->rq_next_page++);\n\n\t\trqstp->rq_vec[v].iov_base = page_address(p);\n\t\trqstp->rq_vec[v].iov_len = min_t(unsigned int, len, PAGE_SIZE);\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t}\n\targs->vlen = v;\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_writeargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_writeargs *args)\n{\n\tunsigned int len, hdr, dlen;\n\tstruct kvec *head = rqstp->rq_arg.head;\n\tint v;\n\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\n\tp++;\t\t\t\t/* beginoffset */\n\targs->offset = ntohl(*p++);\t/* offset */\n\tp++;\t\t\t\t/* totalcount */\n\tlen = args->len = ntohl(*p++);\n\t/*\n\t * The protocol specifies a maximum of 8192 bytes.\n\t */\n\tif (len > NFSSVC_MAXBLKSIZE_V2)\n\t\treturn 0;\n\n\t/*\n\t * Check to make sure that we got the right number of\n\t * bytes.\n\t */\n\thdr = (void*)p - head->iov_base;\n\tif (hdr > head->iov_len)\n\t\treturn 0;\n\tdlen = head->iov_len + rqstp->rq_arg.page_len - hdr;\n\n\t/*\n\t * Round the length of the data which was specified up to\n\t * the next multiple of XDR units and then compare that\n\t * against the length which was actually received.\n\t * Note that when RPCSEC/GSS (for example) is used, the\n\t * data buffer can be padded so dlen might be larger\n\t * than required.  It must never be smaller.\n\t */\n\tif (dlen < XDR_QUADLEN(len)*4)\n\t\treturn 0;\n\n\trqstp->rq_vec[0].iov_base = (void*)p;\n\trqstp->rq_vec[0].iov_len = head->iov_len - hdr;\n\tv = 0;\n\twhile (len > rqstp->rq_vec[v].iov_len) {\n\t\tlen -= rqstp->rq_vec[v].iov_len;\n\t\tv++;\n\t\trqstp->rq_vec[v].iov_base = page_address(rqstp->rq_pages[v]);\n\t\trqstp->rq_vec[v].iov_len = PAGE_SIZE;\n\t}\n\trqstp->rq_vec[v].iov_len = len;\n\targs->vlen = v + 1;\n\treturn 1;\n}\n\nint\nnfssvc_decode_createargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_createargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->fh))\n\t    || !(p = decode_filename(p, &args->name, &args->len)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_renameargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_renameargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_filename(p, &args->fname, &args->flen))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_readlinkargs(struct svc_rqst *rqstp, __be32 *p, struct nfsd_readlinkargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_linkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_linkargs *args)\n{\n\tif (!(p = decode_fh(p, &args->ffh))\n\t || !(p = decode_fh(p, &args->tfh))\n\t || !(p = decode_filename(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_symlinkargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_symlinkargs *args)\n{\n\tif (   !(p = decode_fh(p, &args->ffh))\n\t    || !(p = decode_filename(p, &args->fname, &args->flen))\n\t    || !(p = decode_pathname(p, &args->tname, &args->tlen)))\n\t\treturn 0;\n\tp = decode_sattr(p, &args->attrs);\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\nint\nnfssvc_decode_readdirargs(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirargs *args)\n{\n\tp = decode_fh(p, &args->fh);\n\tif (!p)\n\t\treturn 0;\n\targs->cookie = ntohl(*p++);\n\targs->count  = ntohl(*p++);\n\targs->count  = min_t(u32, args->count, PAGE_SIZE);\n\targs->buffer = page_address(*(rqstp->rq_next_page++));\n\n\treturn xdr_argsize_check(rqstp, p);\n}\n\n/*\n * XDR encode functions\n */\nint\nnfssvc_encode_void(struct svc_rqst *rqstp, __be32 *p, void *dummy)\n{\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_attrstat(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_attrstat *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_diropres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_diropres *resp)\n{\n\tp = encode_fh(p, &resp->fh);\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_readlinkres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readlinkres *resp)\n{\n\t*p++ = htonl(resp->len);\n\txdr_ressize_check(rqstp, p);\n\trqstp->rq_res.page_len = resp->len;\n\tif (resp->len & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->len&3);\n\t}\n\treturn 1;\n}\n\nint\nnfssvc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readres *resp)\n{\n\tp = encode_fattr(rqstp, p, &resp->fh, &resp->stat);\n\t*p++ = htonl(resp->count);\n\txdr_ressize_check(rqstp, p);\n\n\t/* now update rqstp->rq_res to reflect data as well */\n\trqstp->rq_res.page_len = resp->count;\n\tif (resp->count & 3) {\n\t\t/* need to pad the tail */\n\t\trqstp->rq_res.tail[0].iov_base = p;\n\t\t*p = 0;\n\t\trqstp->rq_res.tail[0].iov_len = 4 - (resp->count&3);\n\t}\n\treturn 1;\n}\n\nint\nnfssvc_encode_readdirres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_readdirres *resp)\n{\n\txdr_ressize_check(rqstp, p);\n\tp = resp->buffer;\n\t*p++ = 0;\t\t\t/* no more entries */\n\t*p++ = htonl((resp->common.err == nfserr_eof));\n\trqstp->rq_res.page_len = (((unsigned long)p-1) & ~PAGE_MASK)+1;\n\n\treturn 1;\n}\n\nint\nnfssvc_encode_statfsres(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_statfsres *resp)\n{\n\tstruct kstatfs\t*stat = &resp->stats;\n\n\t*p++ = htonl(NFSSVC_MAXBLKSIZE_V2);\t/* max transfer size */\n\t*p++ = htonl(stat->f_bsize);\n\t*p++ = htonl(stat->f_blocks);\n\t*p++ = htonl(stat->f_bfree);\n\t*p++ = htonl(stat->f_bavail);\n\treturn xdr_ressize_check(rqstp, p);\n}\n\nint\nnfssvc_encode_entry(void *ccdv, const char *name,\n\t\t    int namlen, loff_t offset, u64 ino, unsigned int d_type)\n{\n\tstruct readdir_cd *ccd = ccdv;\n\tstruct nfsd_readdirres *cd = container_of(ccd, struct nfsd_readdirres, common);\n\t__be32\t*p = cd->buffer;\n\tint\tbuflen, slen;\n\n\t/*\n\tdprintk(\"nfsd: entry(%.*s off %ld ino %ld)\\n\",\n\t\t\tnamlen, name, offset, ino);\n\t */\n\n\tif (offset > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\tif (cd->offset)\n\t\t*cd->offset = htonl(offset);\n\n\t/* truncate filename */\n\tnamlen = min(namlen, NFS2_MAXNAMLEN);\n\tslen = XDR_QUADLEN(namlen);\n\n\tif ((buflen = cd->buflen - slen - 4) < 0) {\n\t\tcd->common.err = nfserr_toosmall;\n\t\treturn -EINVAL;\n\t}\n\tif (ino > ~((u32) 0)) {\n\t\tcd->common.err = nfserr_fbig;\n\t\treturn -EINVAL;\n\t}\n\t*p++ = xdr_one;\t\t\t\t/* mark entry present */\n\t*p++ = htonl((u32) ino);\t\t/* file id */\n\tp    = xdr_encode_array(p, name, namlen);/* name length & name */\n\tcd->offset = p;\t\t\t/* remember pointer */\n\t*p++ = htonl(~0U);\t\t/* offset of next entry */\n\n\tcd->buflen = buflen;\n\tcd->buffer = p;\n\tcd->common.err = nfs_ok;\n\treturn 0;\n}\n\n/*\n * XDR release functions\n */\nint\nnfssvc_release_fhandle(struct svc_rqst *rqstp, __be32 *p,\n\t\t\t\t\tstruct nfsd_fhandle *resp)\n{\n\tfh_put(&resp->fh);\n\treturn 1;\n}\n"], "filenames": ["fs/nfsd/nfs3xdr.c", "fs/nfsd/nfsxdr.c"], "buggy_code_start_loc": [371, 304], "buggy_code_end_loc": [474, 304], "fixing_code_start_loc": [372, 305], "fixing_code_end_loc": [479, 307], "type": "CWE-119", "message": "The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c.", "other": {"cve": {"id": "CVE-2017-7895", "sourceIdentifier": "cve@mitre.org", "published": "2017-04-28T10:59:00.160", "lastModified": "2023-01-19T16:13:02.183", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The NFSv2 and NFSv3 server implementations in the Linux kernel through 4.10.13 lack certain checks for the end of a buffer, which allows remote attackers to trigger pointer-arithmetic errors or possibly have unspecified other impact via crafted requests, related to fs/nfsd/nfs3xdr.c and fs/nfsd/nfsxdr.c."}, {"lang": "es", "value": "Las implementaciones de los servidores NFSv2 y NFSv3 en versiones del kernel de Linux 4.10.13 y anteriores, no realizan ciertas comprobaciones de la parte final de un b\u00fafer lo que permitir\u00eda a atacantes remotos desencadenar errores de aritm\u00e9tica de punteros o provocar otro impacto inespec\u00edfico a trav\u00e9s de peticiones especialmente dise\u00f1adas. Relacionado con fs/nfsd/nfs3xdr.c y fs/nfsd/nfsxdr.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 10.0}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 10.0, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.2.89", "matchCriteriaId": "9A5C1F01-214B-4477-A3A1-F6DF10181D3C"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.3", "versionEndExcluding": "3.16.44", "matchCriteriaId": "8C1901E2-6C4D-488B-A7CE-F7E14A38418F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.17.0", "versionEndExcluding": "4.1.40", "matchCriteriaId": "CBDB1D3B-CDD5-48F2-83E3-33F072B455B3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.2", "versionEndExcluding": "4.4.67", "matchCriteriaId": "168D3A9F-B199-4E02-B791-291B29317EF8"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.5.0", "versionEndExcluding": "4.9.26", "matchCriteriaId": "8244943C-198B-43B2-B79C-C832E4572949"}, {"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.10", "versionEndExcluding": "4.10.14", "matchCriteriaId": "90895EF1-9DC7-4E47-A937-405661F7A44B"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.debian.org/security/2017/dsa-3886", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98085", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1615", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1616", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1647", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1715", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1723", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1766", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:1798", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2412", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2428", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2429", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2472", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://access.redhat.com/errata/RHSA-2017:2732", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=13bf9fbff0e5e099e2b6f003a0ab8ae145436309", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/13bf9fbff0e5e099e2b6f003a0ab8ae145436309"}}