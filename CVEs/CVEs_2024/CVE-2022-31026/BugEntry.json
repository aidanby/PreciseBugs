{"buggy_code": ["PATH\n  remote: .\n  specs:\n    trilogy (2.1.0)\n\nGEM\n  remote: https://rubygems.org/\n  specs:\n    benchmark-ips (2.7.2)\n    minitest (5.11.3)\n    mysql2 (0.5.2)\n    rake (13.0.1)\n    rake-compiler (1.0.7)\n      rake\n\nPLATFORMS\n  ruby\n\nDEPENDENCIES\n  benchmark-ips\n  minitest (~> 5.5)\n  mysql2\n  rake-compiler (~> 1.0)\n  trilogy!\n", "class Trilogy\n  VERSION = \"2.1.0\"\nend\n", "#include <openssl/evp.h>\n\n#include \"trilogy/builder.h\"\n#include \"trilogy/error.h\"\n#include \"trilogy/packet_parser.h\"\n#include \"trilogy/protocol.h\"\n#include \"trilogy/reader.h\"\n\n#define TRILOGY_CMD_QUIT 0x01\n#define TRILOGY_CMD_CHANGE_DB 0x02\n#define TRILOGY_CMD_QUERY 0x03\n#define TRILOGY_CMD_PING 0x0e\n\n#define SCRAMBLE_LEN 20\n\nstatic size_t min(size_t a, size_t b)\n{\n    if (a < b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n#define CHECKED(expr)                                                                                                  \\\n    if ((rc = (expr)) < 0) {                                                                                           \\\n        goto fail;                                                                                                     \\\n    }\n\nint trilogy_parse_ok_packet(const uint8_t *buff, size_t len, uint32_t capabilities, trilogy_ok_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->affected_rows));\n\n    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->last_insert_id));\n\n    out_packet->status_flags = 0;\n    out_packet->warning_count = 0;\n    out_packet->txn_status_flags = 0;\n    out_packet->session_status = NULL;\n    out_packet->session_status_len = 0;\n    out_packet->session_state_changes = NULL;\n    out_packet->session_state_changes_len = 0;\n    out_packet->info = NULL;\n    out_packet->info_len = 0;\n    out_packet->last_gtid_len = 0;\n\n    if (capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41) {\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->status_flags));\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->warning_count));\n    } else if (capabilities & TRILOGY_CAPABILITIES_TRANSACTIONS) {\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->txn_status_flags));\n    }\n\n    if (capabilities & TRILOGY_CAPABILITIES_SESSION_TRACK && !trilogy_reader_eof(&reader)) {\n        CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->session_status_len,\n                                                 (const void **)&out_packet->session_status));\n\n        if (out_packet->status_flags & TRILOGY_SERVER_STATUS_SESSION_STATE_CHANGED) {\n            CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->session_state_changes_len,\n                                                     (const void **)&out_packet->session_state_changes));\n\n            TRILOGY_SESSION_TRACK_TYPE_t type = 0;\n            const char *state_info = NULL;\n            size_t state_info_len = 0;\n\n            trilogy_reader_t state_reader = TRILOGY_READER((const uint8_t *)out_packet->session_state_changes,\n                                                           out_packet->session_state_changes_len);\n\n            while (!trilogy_reader_eof(&state_reader)) {\n                CHECKED(trilogy_reader_get_uint8(&state_reader, (uint8_t *)&type));\n                CHECKED(trilogy_reader_get_lenenc_buffer(&state_reader, &state_info_len, (const void **)&state_info));\n\n                switch (type) {\n                case TRILOGY_SESSION_TRACK_GTIDS: {\n                    trilogy_reader_t gtid_reader = TRILOGY_READER((const uint8_t *)state_info, state_info_len);\n                    // There's a type with value TRILOGY_SESSION_TRACK_GTIDS tag\n                    // at the beginning here we can ignore since we already had\n                    // the type one level higher as well.\n                    CHECKED(trilogy_reader_get_uint8(&gtid_reader, NULL));\n                    CHECKED(trilogy_reader_get_lenenc_buffer(&gtid_reader, &out_packet->last_gtid_len,\n                                                             (const void **)&out_packet->last_gtid));\n                    if (out_packet->last_gtid_len > TRILOGY_MAX_LAST_GTID_LEN) {\n                        return TRILOGY_PROTOCOL_VIOLATION;\n                    }\n                    break;\n                }\n                default:\n                    break;\n                }\n            }\n        }\n    } else {\n        CHECKED(trilogy_reader_get_eof_buffer(&reader, &out_packet->info_len, (const void **)&out_packet->info));\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_eof_packet(const uint8_t *buff, size_t len, uint32_t capabilities, trilogy_eof_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    if (capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41) {\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->warning_count));\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->status_flags));\n    } else {\n        out_packet->status_flags = 0;\n        out_packet->warning_count = 0;\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_err_packet(const uint8_t *buff, size_t len, uint32_t capabilities, trilogy_err_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->error_code));\n\n    if (capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41) {\n        CHECKED(trilogy_reader_get_uint8(&reader, out_packet->sql_state_marker));\n        CHECKED(trilogy_reader_copy_buffer(&reader, 5, out_packet->sql_state));\n    } else {\n        memset(out_packet->sql_state_marker, 0, sizeof out_packet->sql_state_marker);\n        memset(out_packet->sql_state, 0, sizeof out_packet->sql_state);\n    }\n\n    CHECKED(trilogy_reader_get_eof_buffer(&reader, &out_packet->error_message_len,\n                                          (const void **)&out_packet->error_message));\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_auth_switch_request_packet(const uint8_t *buff, size_t len, uint32_t capabilities,\n                                             trilogy_auth_switch_request_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    if (capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH) {\n        const char *auth_plugin;\n        size_t auth_plugin_len;\n\n        CHECKED(trilogy_reader_get_string(&reader, &auth_plugin, &auth_plugin_len));\n        if (auth_plugin_len > sizeof(out_packet->auth_plugin) - 1) {\n            return TRILOGY_AUTH_PLUGIN_TOO_LONG;\n        }\n        memcpy(out_packet->auth_plugin, auth_plugin, auth_plugin_len + 1);\n\n        const char *auth_data;\n        size_t auth_data_len;\n        CHECKED(trilogy_reader_get_eof_buffer(&reader, &auth_data_len, (const void **)&auth_data));\n        if (auth_data_len > 21) {\n            auth_data_len = 21;\n        }\n        memcpy(out_packet->scramble, auth_data, auth_data_len);\n    } else {\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_handshake_packet(const uint8_t *buff, size_t len, trilogy_handshake_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    CHECKED(trilogy_reader_get_uint8(&reader, &out_packet->proto_version));\n    if (out_packet->proto_version != 0xa) {\n        // incompatible protocol version\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    const char *server_version;\n    size_t server_version_len;\n\n    CHECKED(trilogy_reader_get_string(&reader, &server_version, &server_version_len));\n    server_version_len = min(server_version_len, sizeof(out_packet->server_version) - 1);\n    memcpy(out_packet->server_version, server_version, server_version_len);\n    out_packet->server_version[server_version_len] = '\\0';\n\n    CHECKED(trilogy_reader_get_uint32(&reader, &out_packet->conn_id));\n\n    CHECKED(trilogy_reader_copy_buffer(&reader, 8, out_packet->scramble));\n\n    // this should be a NULL filler\n    uint8_t filler = 0;\n    CHECKED(trilogy_reader_get_uint8(&reader, &filler));\n    if (filler != '\\0') {\n        // corrupt handshake packet\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    // lower two bytes of capabilities flags\n    uint16_t caps_part = 0;\n    CHECKED(trilogy_reader_get_uint16(&reader, &caps_part));\n    out_packet->capabilities = caps_part;\n\n    if (!(out_packet->capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41)) {\n        // incompatible protocol version\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    uint8_t server_charset;\n    CHECKED(trilogy_reader_get_uint8(&reader, &server_charset));\n\n    out_packet->server_charset = server_charset;\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->server_status));\n\n    // upper 16 bits of capabilities flags\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &caps_part));\n    out_packet->capabilities |= ((uint32_t)caps_part << 16);\n\n    uint8_t auth_data_len = 0;\n    CHECKED(trilogy_reader_get_uint8(&reader, &auth_data_len));\n    if (!(out_packet->capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH)) {\n        // this should be a NULL filler\n        if (auth_data_len != '\\0') {\n            // corrupt handshake packet\n            return TRILOGY_PROTOCOL_VIOLATION;\n        }\n    }\n\n    // This space is reserved. It should be all NULL bytes but some tools or\n    // future versions of MySQL-compatible clients may use it. This library\n    // opts to skip the validation as some servers don't respect the protocol.\n    //\n    static const uint8_t null_filler[10] = {0};\n\n    const void *str;\n    CHECKED(trilogy_reader_get_buffer(&reader, 10, &str));\n\n    if (memcmp(str, null_filler, 10) != 0) {\n        // corrupt handshake packet\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    if (out_packet->capabilities & TRILOGY_CAPABILITIES_SECURE_CONNECTION && auth_data_len > 8) {\n        uint8_t remaining_auth_data_len = auth_data_len - 8;\n\n        if (remaining_auth_data_len > 13) {\n            remaining_auth_data_len = 13;\n        }\n\n        CHECKED(trilogy_reader_copy_buffer(&reader, remaining_auth_data_len, out_packet->scramble + 8));\n    } else {\n        // only support 4.1 protocol or newer with secure connection\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    if (out_packet->capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH) {\n        const char *auth_plugin;\n        size_t auth_plugin_len;\n\n        CHECKED(trilogy_reader_get_string(&reader, &auth_plugin, &auth_plugin_len));\n        if (auth_plugin_len > sizeof(out_packet->auth_plugin) - 1) {\n            return TRILOGY_AUTH_PLUGIN_TOO_LONG;\n        }\n\n        memcpy(out_packet->auth_plugin, auth_plugin, auth_plugin_len + 1);\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_result_packet(const uint8_t *buff, size_t len, trilogy_result_packet_t *out_packet)\n{\n    int rc = 0;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->column_count));\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_row_packet(const uint8_t *buff, size_t len, uint64_t column_count, trilogy_value_t *out_values)\n{\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    for (uint64_t i = 0; i < column_count; i++) {\n        void *data = NULL;\n        size_t data_len = 0;\n\n        int rc = trilogy_reader_get_lenenc_buffer(&reader, &data_len, (const void **)&data);\n\n        switch (rc) {\n        case TRILOGY_OK:\n            out_values[i].is_null = false;\n            out_values[i].data = data;\n            out_values[i].data_len = data_len;\n            break;\n\n        case TRILOGY_NULL_VALUE:\n            out_values[i].is_null = true;\n            out_values[i].data_len = 0;\n            break;\n\n        default:\n            return rc;\n        }\n    }\n\n    return trilogy_reader_finish(&reader);\n}\n\nint trilogy_parse_column_packet(const uint8_t *buff, size_t len, bool field_list, trilogy_column_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->catalog_len, (const void **)&out_packet->catalog));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->schema_len, (const void **)&out_packet->schema));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->table_len, (const void **)&out_packet->table));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->original_table_len,\n                                             (const void **)&out_packet->original_table));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->name_len, (const void **)&out_packet->name));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->original_name_len,\n                                             (const void **)&out_packet->original_name));\n\n    // skip length of fixed length field until we have something to use it for\n    CHECKED(trilogy_reader_get_lenenc(&reader, NULL));\n\n    uint16_t charset;\n    CHECKED(trilogy_reader_get_uint16(&reader, &charset));\n\n    out_packet->charset = charset;\n\n    CHECKED(trilogy_reader_get_uint32(&reader, &out_packet->len));\n\n    uint8_t type;\n    CHECKED(trilogy_reader_get_uint8(&reader, &type));\n    out_packet->type = type;\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->flags));\n\n    CHECKED(trilogy_reader_get_uint8(&reader, &out_packet->decimals));\n\n    // skip NULL filler\n    CHECKED(trilogy_reader_get_uint16(&reader, NULL));\n\n    out_packet->default_value_len = 0;\n\n    if (field_list) {\n        CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->default_value_len,\n                                                 (const void **)&out_packet->default_value));\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nstatic void trilogy_pack_scramble_native_hash(const char *scramble, const char *password, size_t password_len,\n                                              uint8_t *buffer, unsigned int *buffer_len)\n{\n    EVP_MD_CTX *ctx;\n    const EVP_MD *alg;\n    unsigned int hash_size_tmp1;\n    unsigned int hash_size_tmp2;\n    unsigned int x;\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    ctx = EVP_MD_CTX_new();\n#else\n    ctx = EVP_MD_CTX_create();\n    EVP_MD_CTX_init(ctx);\n#endif\n    alg = EVP_sha1();\n    hash_size_tmp1 = 0;\n    hash_size_tmp2 = 0;\n    uint8_t hash_tmp1[EVP_MAX_MD_SIZE];\n    uint8_t hash_tmp2[EVP_MAX_MD_SIZE];\n\n    /* First hash the password. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, (unsigned char *)(password), password_len);\n    EVP_DigestFinal_ex(ctx, hash_tmp1, &hash_size_tmp1);\n\n    /* Second, hash the password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, hash_tmp1, (size_t)hash_size_tmp1);\n    EVP_DigestFinal_ex(ctx, hash_tmp2, &hash_size_tmp2);\n\n    /* Third, hash the scramble and the double password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, (unsigned char *)scramble, SCRAMBLE_LEN);\n    EVP_DigestUpdate(ctx, hash_tmp2, (size_t)hash_size_tmp2);\n    EVP_DigestFinal_ex(ctx, buffer, buffer_len);\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    EVP_MD_CTX_free(ctx);\n#else\n    EVP_MD_CTX_destroy(ctx);\n#endif\n\n    /* Fourth, xor the last hash against the first password hash. */\n    for (x = 0; x < *buffer_len; x++) {\n        buffer[x] = buffer[x] ^ hash_tmp1[x];\n    }\n}\n\nstatic void trilogy_pack_scramble_sha2_hash(const char *scramble, const char *password, size_t password_len,\n                                            uint8_t *buffer, unsigned int *buffer_len)\n{\n    EVP_MD_CTX *ctx;\n    const EVP_MD *alg;\n    unsigned int hash_size_tmp1;\n    unsigned int hash_size_tmp2;\n    unsigned int x;\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    ctx = EVP_MD_CTX_new();\n#else\n    ctx = EVP_MD_CTX_create();\n    EVP_MD_CTX_init(ctx);\n#endif\n    alg = EVP_sha256();\n    hash_size_tmp1 = 0;\n    hash_size_tmp2 = 0;\n    uint8_t hash_tmp1[EVP_MAX_MD_SIZE];\n    uint8_t hash_tmp2[EVP_MAX_MD_SIZE];\n\n    /* First hash the password. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, (unsigned char *)(password), password_len);\n    EVP_DigestFinal_ex(ctx, hash_tmp1, &hash_size_tmp1);\n\n    /* Second, hash the password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, hash_tmp1, (size_t)hash_size_tmp1);\n    EVP_DigestFinal_ex(ctx, hash_tmp2, &hash_size_tmp2);\n\n    /* Third, hash the scramble and the double password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, hash_tmp2, (size_t)hash_size_tmp2);\n    EVP_DigestUpdate(ctx, (unsigned char *)scramble, SCRAMBLE_LEN);\n    EVP_DigestFinal_ex(ctx, buffer, buffer_len);\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    EVP_MD_CTX_free(ctx);\n#else\n    EVP_MD_CTX_destroy(ctx);\n#endif\n\n    /* Fourth, xor the first and last hash. */\n    for (x = 0; x < *buffer_len; x++) {\n        buffer[x] = hash_tmp1[x] ^ buffer[x];\n    }\n}\n\nint trilogy_build_auth_packet(trilogy_builder_t *builder, const char *user, const char *pass, size_t pass_len,\n                              const char *database, const char *auth_plugin, const char *scramble,\n                              TRILOGY_CAPABILITIES_t flags)\n{\n    int rc = TRILOGY_OK;\n\n    const char *default_auth_plugin = \"mysql_native_password\";\n\n    uint32_t capabilities = flags;\n    // Add the default set of capabilities for this client\n    capabilities |= TRILOGY_CAPABILITIES_CLIENT;\n\n    uint32_t max_packet_len = TRILOGY_MAX_PACKET_LEN;\n\n    uint8_t client_encoding = TRILOGY_CHARSET_UTF8_GENERAL_CI;\n\n    unsigned int auth_response_len = 0;\n    uint8_t auth_response[EVP_MAX_MD_SIZE];\n\n    if (database) {\n        capabilities |= TRILOGY_CAPABILITIES_CONNECT_WITH_DB;\n    }\n\n    CHECKED(trilogy_builder_write_uint32(builder, capabilities));\n\n    CHECKED(trilogy_builder_write_uint32(builder, max_packet_len));\n\n    CHECKED(trilogy_builder_write_uint8(builder, client_encoding));\n\n    static const char zeroes[23] = {0};\n    CHECKED(trilogy_builder_write_buffer(builder, zeroes, 23));\n\n    if (user) {\n        CHECKED(trilogy_builder_write_string(builder, user));\n    } else {\n        CHECKED(trilogy_builder_write_string(builder, \"root\"));\n    }\n\n    if (pass_len > 0) {\n        // Fallback to te default unless we have SHA2 requested\n        if (!strcmp(\"caching_sha2_password\", auth_plugin)) {\n            trilogy_pack_scramble_sha2_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n        } else {\n            trilogy_pack_scramble_native_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n            auth_plugin = default_auth_plugin;\n        }\n    }\n\n    // auth data len\n    CHECKED(trilogy_builder_write_uint8(builder, (uint8_t)auth_response_len));\n\n    if (auth_response_len > 0) {\n        CHECKED(trilogy_builder_write_buffer(builder, auth_response, auth_response_len));\n    }\n\n    if (database) {\n        CHECKED(trilogy_builder_write_string(builder, database));\n    }\n\n    if (capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH) {\n        CHECKED(trilogy_builder_write_string(builder, auth_plugin));\n    }\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_auth_switch_response_packet(trilogy_builder_t *builder, const char *pass, size_t pass_len,\n                                              const char *auth_plugin, const char *scramble)\n{\n    int rc = TRILOGY_OK;\n    unsigned int auth_response_len = 0;\n    uint8_t auth_response[EVP_MAX_MD_SIZE];\n\n    if (!strcmp(\"caching_sha2_password\", auth_plugin)) {\n        trilogy_pack_scramble_sha2_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n    } else {\n        trilogy_pack_scramble_native_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n    }\n\n    CHECKED(trilogy_builder_write_buffer(builder, auth_response, auth_response_len));\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\nfail:\n    return rc;\n}\n\nint trilogy_build_ping_packet(trilogy_builder_t *builder)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_PING));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_query_packet(trilogy_builder_t *builder, const char *sql, size_t sql_len)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_QUERY));\n\n    CHECKED(trilogy_builder_write_buffer(builder, sql, sql_len));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_change_db_packet(trilogy_builder_t *builder, const char *name, size_t name_len)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_CHANGE_DB));\n\n    CHECKED(trilogy_builder_write_buffer(builder, name, name_len));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_quit_packet(trilogy_builder_t *builder)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_QUIT));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_ssl_request_packet(trilogy_builder_t *builder, TRILOGY_CAPABILITIES_t flags)\n{\n    static const char zeroes[23] = {0};\n\n    const uint32_t max_packet_len = TRILOGY_MAX_PACKET_LEN;\n    const uint8_t client_encoding = TRILOGY_CHARSET_UTF8_GENERAL_CI;\n    const uint32_t capabilities = flags | TRILOGY_CAPABILITIES_CLIENT | TRILOGY_CAPABILITIES_SSL;\n\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint32(builder, capabilities));\n    CHECKED(trilogy_builder_write_uint32(builder, max_packet_len));\n    CHECKED(trilogy_builder_write_uint8(builder, client_encoding));\n    CHECKED(trilogy_builder_write_buffer(builder, zeroes, 23));\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\n#undef CHECKED\n"], "fixing_code": ["PATH\n  remote: .\n  specs:\n    trilogy (2.1.1)\n\nGEM\n  remote: https://rubygems.org/\n  specs:\n    benchmark-ips (2.7.2)\n    minitest (5.11.3)\n    mysql2 (0.5.2)\n    rake (13.0.1)\n    rake-compiler (1.0.7)\n      rake\n\nPLATFORMS\n  ruby\n\nDEPENDENCIES\n  benchmark-ips\n  minitest (~> 5.5)\n  mysql2\n  rake-compiler (~> 1.0)\n  trilogy!\n", "class Trilogy\n  VERSION = \"2.1.1\"\nend\n", "#include <openssl/evp.h>\n\n#include \"trilogy/builder.h\"\n#include \"trilogy/error.h\"\n#include \"trilogy/packet_parser.h\"\n#include \"trilogy/protocol.h\"\n#include \"trilogy/reader.h\"\n\n#define TRILOGY_CMD_QUIT 0x01\n#define TRILOGY_CMD_CHANGE_DB 0x02\n#define TRILOGY_CMD_QUERY 0x03\n#define TRILOGY_CMD_PING 0x0e\n\n#define SCRAMBLE_LEN 20\n\nstatic size_t min(size_t a, size_t b)\n{\n    if (a < b) {\n        return a;\n    } else {\n        return b;\n    }\n}\n\n#define CHECKED(expr)                                                                                                  \\\n    if ((rc = (expr)) < 0) {                                                                                           \\\n        goto fail;                                                                                                     \\\n    }\n\nint trilogy_parse_ok_packet(const uint8_t *buff, size_t len, uint32_t capabilities, trilogy_ok_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->affected_rows));\n\n    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->last_insert_id));\n\n    out_packet->status_flags = 0;\n    out_packet->warning_count = 0;\n    out_packet->txn_status_flags = 0;\n    out_packet->session_status = NULL;\n    out_packet->session_status_len = 0;\n    out_packet->session_state_changes = NULL;\n    out_packet->session_state_changes_len = 0;\n    out_packet->info = NULL;\n    out_packet->info_len = 0;\n    out_packet->last_gtid_len = 0;\n\n    if (capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41) {\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->status_flags));\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->warning_count));\n    } else if (capabilities & TRILOGY_CAPABILITIES_TRANSACTIONS) {\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->txn_status_flags));\n    }\n\n    if (capabilities & TRILOGY_CAPABILITIES_SESSION_TRACK && !trilogy_reader_eof(&reader)) {\n        CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->session_status_len,\n                                                 (const void **)&out_packet->session_status));\n\n        if (out_packet->status_flags & TRILOGY_SERVER_STATUS_SESSION_STATE_CHANGED) {\n            CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->session_state_changes_len,\n                                                     (const void **)&out_packet->session_state_changes));\n\n            TRILOGY_SESSION_TRACK_TYPE_t type = 0;\n            const char *state_info = NULL;\n            size_t state_info_len = 0;\n\n            trilogy_reader_t state_reader = TRILOGY_READER((const uint8_t *)out_packet->session_state_changes,\n                                                           out_packet->session_state_changes_len);\n\n            while (!trilogy_reader_eof(&state_reader)) {\n                CHECKED(trilogy_reader_get_uint8(&state_reader, (uint8_t *)&type));\n                CHECKED(trilogy_reader_get_lenenc_buffer(&state_reader, &state_info_len, (const void **)&state_info));\n\n                switch (type) {\n                case TRILOGY_SESSION_TRACK_GTIDS: {\n                    trilogy_reader_t gtid_reader = TRILOGY_READER((const uint8_t *)state_info, state_info_len);\n                    // There's a type with value TRILOGY_SESSION_TRACK_GTIDS tag\n                    // at the beginning here we can ignore since we already had\n                    // the type one level higher as well.\n                    CHECKED(trilogy_reader_get_uint8(&gtid_reader, NULL));\n                    CHECKED(trilogy_reader_get_lenenc_buffer(&gtid_reader, &out_packet->last_gtid_len,\n                                                             (const void **)&out_packet->last_gtid));\n                    if (out_packet->last_gtid_len > TRILOGY_MAX_LAST_GTID_LEN) {\n                        return TRILOGY_PROTOCOL_VIOLATION;\n                    }\n                    break;\n                }\n                default:\n                    break;\n                }\n            }\n        }\n    } else {\n        CHECKED(trilogy_reader_get_eof_buffer(&reader, &out_packet->info_len, (const void **)&out_packet->info));\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_eof_packet(const uint8_t *buff, size_t len, uint32_t capabilities, trilogy_eof_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    if (capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41) {\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->warning_count));\n        CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->status_flags));\n    } else {\n        out_packet->status_flags = 0;\n        out_packet->warning_count = 0;\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_err_packet(const uint8_t *buff, size_t len, uint32_t capabilities, trilogy_err_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->error_code));\n\n    if (capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41) {\n        CHECKED(trilogy_reader_get_uint8(&reader, out_packet->sql_state_marker));\n        CHECKED(trilogy_reader_copy_buffer(&reader, 5, out_packet->sql_state));\n    } else {\n        memset(out_packet->sql_state_marker, 0, sizeof out_packet->sql_state_marker);\n        memset(out_packet->sql_state, 0, sizeof out_packet->sql_state);\n    }\n\n    CHECKED(trilogy_reader_get_eof_buffer(&reader, &out_packet->error_message_len,\n                                          (const void **)&out_packet->error_message));\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_auth_switch_request_packet(const uint8_t *buff, size_t len, uint32_t capabilities,\n                                             trilogy_auth_switch_request_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    // skip packet type\n    CHECKED(trilogy_reader_get_uint8(&reader, NULL));\n\n    if (capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH) {\n        const char *auth_plugin;\n        size_t auth_plugin_len;\n\n        CHECKED(trilogy_reader_get_string(&reader, &auth_plugin, &auth_plugin_len));\n        if (auth_plugin_len > sizeof(out_packet->auth_plugin) - 1) {\n            return TRILOGY_AUTH_PLUGIN_TOO_LONG;\n        }\n        memcpy(out_packet->auth_plugin, auth_plugin, auth_plugin_len + 1);\n\n        const char *auth_data;\n        size_t auth_data_len;\n        CHECKED(trilogy_reader_get_eof_buffer(&reader, &auth_data_len, (const void **)&auth_data));\n        if (auth_data_len > 21) {\n            auth_data_len = 21;\n        }\n        memcpy(out_packet->scramble, auth_data, auth_data_len);\n    } else {\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_handshake_packet(const uint8_t *buff, size_t len, trilogy_handshake_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    CHECKED(trilogy_reader_get_uint8(&reader, &out_packet->proto_version));\n    if (out_packet->proto_version != 0xa) {\n        // incompatible protocol version\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    const char *server_version;\n    size_t server_version_len;\n\n    CHECKED(trilogy_reader_get_string(&reader, &server_version, &server_version_len));\n    server_version_len = min(server_version_len, sizeof(out_packet->server_version) - 1);\n    memcpy(out_packet->server_version, server_version, server_version_len);\n    out_packet->server_version[server_version_len] = '\\0';\n\n    CHECKED(trilogy_reader_get_uint32(&reader, &out_packet->conn_id));\n\n    CHECKED(trilogy_reader_copy_buffer(&reader, 8, out_packet->scramble));\n\n    // this should be a NULL filler\n    uint8_t filler = 0;\n    CHECKED(trilogy_reader_get_uint8(&reader, &filler));\n    if (filler != '\\0') {\n        // corrupt handshake packet\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    // lower two bytes of capabilities flags\n    uint16_t caps_part = 0;\n    CHECKED(trilogy_reader_get_uint16(&reader, &caps_part));\n    out_packet->capabilities = caps_part;\n\n    if (!(out_packet->capabilities & TRILOGY_CAPABILITIES_PROTOCOL_41)) {\n        // incompatible protocol version\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    uint8_t server_charset;\n    CHECKED(trilogy_reader_get_uint8(&reader, &server_charset));\n\n    out_packet->server_charset = server_charset;\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->server_status));\n\n    // upper 16 bits of capabilities flags\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &caps_part));\n    out_packet->capabilities |= ((uint32_t)caps_part << 16);\n\n    uint8_t auth_data_len = 0;\n    CHECKED(trilogy_reader_get_uint8(&reader, &auth_data_len));\n    if (!(out_packet->capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH)) {\n        // this should be a NULL filler\n        if (auth_data_len != '\\0') {\n            // corrupt handshake packet\n            return TRILOGY_PROTOCOL_VIOLATION;\n        }\n    }\n\n    // This space is reserved. It should be all NULL bytes but some tools or\n    // future versions of MySQL-compatible clients may use it. This library\n    // opts to skip the validation as some servers don't respect the protocol.\n    //\n    static const uint8_t null_filler[10] = {0};\n\n    const void *str;\n    CHECKED(trilogy_reader_get_buffer(&reader, 10, &str));\n\n    if (memcmp(str, null_filler, 10) != 0) {\n        // corrupt handshake packet\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    if (out_packet->capabilities & TRILOGY_CAPABILITIES_SECURE_CONNECTION && auth_data_len > 8) {\n        uint8_t remaining_auth_data_len = auth_data_len - 8;\n\n        // The auth plugins we support all provide exactly 21 bytes of\n        // auth_data. Reject any other values for auth_data_len.\n        if (SCRAMBLE_LEN + 1 != auth_data_len) {\n            return TRILOGY_PROTOCOL_VIOLATION;\n        }\n\n        CHECKED(trilogy_reader_copy_buffer(&reader, remaining_auth_data_len, out_packet->scramble + 8));\n    } else {\n        // only support 4.1 protocol or newer with secure connection\n        return TRILOGY_PROTOCOL_VIOLATION;\n    }\n\n    if (out_packet->capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH) {\n        const char *auth_plugin;\n        size_t auth_plugin_len;\n\n        CHECKED(trilogy_reader_get_string(&reader, &auth_plugin, &auth_plugin_len));\n        if (auth_plugin_len > sizeof(out_packet->auth_plugin) - 1) {\n            return TRILOGY_AUTH_PLUGIN_TOO_LONG;\n        }\n\n        memcpy(out_packet->auth_plugin, auth_plugin, auth_plugin_len + 1);\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_result_packet(const uint8_t *buff, size_t len, trilogy_result_packet_t *out_packet)\n{\n    int rc = 0;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    CHECKED(trilogy_reader_get_lenenc(&reader, &out_packet->column_count));\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nint trilogy_parse_row_packet(const uint8_t *buff, size_t len, uint64_t column_count, trilogy_value_t *out_values)\n{\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    for (uint64_t i = 0; i < column_count; i++) {\n        void *data = NULL;\n        size_t data_len = 0;\n\n        int rc = trilogy_reader_get_lenenc_buffer(&reader, &data_len, (const void **)&data);\n\n        switch (rc) {\n        case TRILOGY_OK:\n            out_values[i].is_null = false;\n            out_values[i].data = data;\n            out_values[i].data_len = data_len;\n            break;\n\n        case TRILOGY_NULL_VALUE:\n            out_values[i].is_null = true;\n            out_values[i].data_len = 0;\n            break;\n\n        default:\n            return rc;\n        }\n    }\n\n    return trilogy_reader_finish(&reader);\n}\n\nint trilogy_parse_column_packet(const uint8_t *buff, size_t len, bool field_list, trilogy_column_packet_t *out_packet)\n{\n    int rc;\n\n    trilogy_reader_t reader = TRILOGY_READER(buff, len);\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->catalog_len, (const void **)&out_packet->catalog));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->schema_len, (const void **)&out_packet->schema));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->table_len, (const void **)&out_packet->table));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->original_table_len,\n                                             (const void **)&out_packet->original_table));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->name_len, (const void **)&out_packet->name));\n\n    CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->original_name_len,\n                                             (const void **)&out_packet->original_name));\n\n    // skip length of fixed length field until we have something to use it for\n    CHECKED(trilogy_reader_get_lenenc(&reader, NULL));\n\n    uint16_t charset;\n    CHECKED(trilogy_reader_get_uint16(&reader, &charset));\n\n    out_packet->charset = charset;\n\n    CHECKED(trilogy_reader_get_uint32(&reader, &out_packet->len));\n\n    uint8_t type;\n    CHECKED(trilogy_reader_get_uint8(&reader, &type));\n    out_packet->type = type;\n\n    CHECKED(trilogy_reader_get_uint16(&reader, &out_packet->flags));\n\n    CHECKED(trilogy_reader_get_uint8(&reader, &out_packet->decimals));\n\n    // skip NULL filler\n    CHECKED(trilogy_reader_get_uint16(&reader, NULL));\n\n    out_packet->default_value_len = 0;\n\n    if (field_list) {\n        CHECKED(trilogy_reader_get_lenenc_buffer(&reader, &out_packet->default_value_len,\n                                                 (const void **)&out_packet->default_value));\n    }\n\n    return trilogy_reader_finish(&reader);\n\nfail:\n    return rc;\n}\n\nstatic void trilogy_pack_scramble_native_hash(const char *scramble, const char *password, size_t password_len,\n                                              uint8_t *buffer, unsigned int *buffer_len)\n{\n    EVP_MD_CTX *ctx;\n    const EVP_MD *alg;\n    unsigned int hash_size_tmp1;\n    unsigned int hash_size_tmp2;\n    unsigned int x;\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    ctx = EVP_MD_CTX_new();\n#else\n    ctx = EVP_MD_CTX_create();\n    EVP_MD_CTX_init(ctx);\n#endif\n    alg = EVP_sha1();\n    hash_size_tmp1 = 0;\n    hash_size_tmp2 = 0;\n    uint8_t hash_tmp1[EVP_MAX_MD_SIZE];\n    uint8_t hash_tmp2[EVP_MAX_MD_SIZE];\n\n    /* First hash the password. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, (unsigned char *)(password), password_len);\n    EVP_DigestFinal_ex(ctx, hash_tmp1, &hash_size_tmp1);\n\n    /* Second, hash the password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, hash_tmp1, (size_t)hash_size_tmp1);\n    EVP_DigestFinal_ex(ctx, hash_tmp2, &hash_size_tmp2);\n\n    /* Third, hash the scramble and the double password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, (unsigned char *)scramble, SCRAMBLE_LEN);\n    EVP_DigestUpdate(ctx, hash_tmp2, (size_t)hash_size_tmp2);\n    EVP_DigestFinal_ex(ctx, buffer, buffer_len);\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    EVP_MD_CTX_free(ctx);\n#else\n    EVP_MD_CTX_destroy(ctx);\n#endif\n\n    /* Fourth, xor the last hash against the first password hash. */\n    for (x = 0; x < *buffer_len; x++) {\n        buffer[x] = buffer[x] ^ hash_tmp1[x];\n    }\n}\n\nstatic void trilogy_pack_scramble_sha2_hash(const char *scramble, const char *password, size_t password_len,\n                                            uint8_t *buffer, unsigned int *buffer_len)\n{\n    EVP_MD_CTX *ctx;\n    const EVP_MD *alg;\n    unsigned int hash_size_tmp1;\n    unsigned int hash_size_tmp2;\n    unsigned int x;\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    ctx = EVP_MD_CTX_new();\n#else\n    ctx = EVP_MD_CTX_create();\n    EVP_MD_CTX_init(ctx);\n#endif\n    alg = EVP_sha256();\n    hash_size_tmp1 = 0;\n    hash_size_tmp2 = 0;\n    uint8_t hash_tmp1[EVP_MAX_MD_SIZE];\n    uint8_t hash_tmp2[EVP_MAX_MD_SIZE];\n\n    /* First hash the password. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, (unsigned char *)(password), password_len);\n    EVP_DigestFinal_ex(ctx, hash_tmp1, &hash_size_tmp1);\n\n    /* Second, hash the password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, hash_tmp1, (size_t)hash_size_tmp1);\n    EVP_DigestFinal_ex(ctx, hash_tmp2, &hash_size_tmp2);\n\n    /* Third, hash the scramble and the double password hash. */\n    EVP_DigestInit_ex(ctx, alg, NULL);\n    EVP_DigestUpdate(ctx, hash_tmp2, (size_t)hash_size_tmp2);\n    EVP_DigestUpdate(ctx, (unsigned char *)scramble, SCRAMBLE_LEN);\n    EVP_DigestFinal_ex(ctx, buffer, buffer_len);\n\n#if OPENSSL_VERSION_NUMBER >= 0x1010000fL\n    EVP_MD_CTX_free(ctx);\n#else\n    EVP_MD_CTX_destroy(ctx);\n#endif\n\n    /* Fourth, xor the first and last hash. */\n    for (x = 0; x < *buffer_len; x++) {\n        buffer[x] = hash_tmp1[x] ^ buffer[x];\n    }\n}\n\nint trilogy_build_auth_packet(trilogy_builder_t *builder, const char *user, const char *pass, size_t pass_len,\n                              const char *database, const char *auth_plugin, const char *scramble,\n                              TRILOGY_CAPABILITIES_t flags)\n{\n    int rc = TRILOGY_OK;\n\n    const char *default_auth_plugin = \"mysql_native_password\";\n\n    uint32_t capabilities = flags;\n    // Add the default set of capabilities for this client\n    capabilities |= TRILOGY_CAPABILITIES_CLIENT;\n\n    uint32_t max_packet_len = TRILOGY_MAX_PACKET_LEN;\n\n    uint8_t client_encoding = TRILOGY_CHARSET_UTF8_GENERAL_CI;\n\n    unsigned int auth_response_len = 0;\n    uint8_t auth_response[EVP_MAX_MD_SIZE];\n\n    if (database) {\n        capabilities |= TRILOGY_CAPABILITIES_CONNECT_WITH_DB;\n    }\n\n    CHECKED(trilogy_builder_write_uint32(builder, capabilities));\n\n    CHECKED(trilogy_builder_write_uint32(builder, max_packet_len));\n\n    CHECKED(trilogy_builder_write_uint8(builder, client_encoding));\n\n    static const char zeroes[23] = {0};\n    CHECKED(trilogy_builder_write_buffer(builder, zeroes, 23));\n\n    if (user) {\n        CHECKED(trilogy_builder_write_string(builder, user));\n    } else {\n        CHECKED(trilogy_builder_write_string(builder, \"root\"));\n    }\n\n    if (pass_len > 0) {\n        // Fallback to te default unless we have SHA2 requested\n        if (!strcmp(\"caching_sha2_password\", auth_plugin)) {\n            trilogy_pack_scramble_sha2_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n        } else {\n            trilogy_pack_scramble_native_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n            auth_plugin = default_auth_plugin;\n        }\n    }\n\n    // auth data len\n    CHECKED(trilogy_builder_write_uint8(builder, (uint8_t)auth_response_len));\n\n    if (auth_response_len > 0) {\n        CHECKED(trilogy_builder_write_buffer(builder, auth_response, auth_response_len));\n    }\n\n    if (database) {\n        CHECKED(trilogy_builder_write_string(builder, database));\n    }\n\n    if (capabilities & TRILOGY_CAPABILITIES_PLUGIN_AUTH) {\n        CHECKED(trilogy_builder_write_string(builder, auth_plugin));\n    }\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_auth_switch_response_packet(trilogy_builder_t *builder, const char *pass, size_t pass_len,\n                                              const char *auth_plugin, const char *scramble)\n{\n    int rc = TRILOGY_OK;\n    unsigned int auth_response_len = 0;\n    uint8_t auth_response[EVP_MAX_MD_SIZE];\n\n    if (!strcmp(\"caching_sha2_password\", auth_plugin)) {\n        trilogy_pack_scramble_sha2_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n    } else {\n        trilogy_pack_scramble_native_hash(scramble, pass, pass_len, auth_response, &auth_response_len);\n    }\n\n    CHECKED(trilogy_builder_write_buffer(builder, auth_response, auth_response_len));\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\nfail:\n    return rc;\n}\n\nint trilogy_build_ping_packet(trilogy_builder_t *builder)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_PING));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_query_packet(trilogy_builder_t *builder, const char *sql, size_t sql_len)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_QUERY));\n\n    CHECKED(trilogy_builder_write_buffer(builder, sql, sql_len));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_change_db_packet(trilogy_builder_t *builder, const char *name, size_t name_len)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_CHANGE_DB));\n\n    CHECKED(trilogy_builder_write_buffer(builder, name, name_len));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_quit_packet(trilogy_builder_t *builder)\n{\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint8(builder, TRILOGY_CMD_QUIT));\n\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\nint trilogy_build_ssl_request_packet(trilogy_builder_t *builder, TRILOGY_CAPABILITIES_t flags)\n{\n    static const char zeroes[23] = {0};\n\n    const uint32_t max_packet_len = TRILOGY_MAX_PACKET_LEN;\n    const uint8_t client_encoding = TRILOGY_CHARSET_UTF8_GENERAL_CI;\n    const uint32_t capabilities = flags | TRILOGY_CAPABILITIES_CLIENT | TRILOGY_CAPABILITIES_SSL;\n\n    int rc = TRILOGY_OK;\n\n    CHECKED(trilogy_builder_write_uint32(builder, capabilities));\n    CHECKED(trilogy_builder_write_uint32(builder, max_packet_len));\n    CHECKED(trilogy_builder_write_uint8(builder, client_encoding));\n    CHECKED(trilogy_builder_write_buffer(builder, zeroes, 23));\n    trilogy_builder_finalize(builder);\n\n    return TRILOGY_OK;\n\nfail:\n    return rc;\n}\n\n#undef CHECKED\n"], "filenames": ["contrib/ruby/Gemfile.lock", "contrib/ruby/lib/trilogy/version.rb", "src/protocol.c"], "buggy_code_start_loc": [4, 2, 278], "buggy_code_end_loc": [5, 3, 280], "fixing_code_start_loc": [4, 2, 278], "fixing_code_end_loc": [5, 3, 282], "type": "CWE-908", "message": "Trilogy is a client library for MySQL. When authenticating, a malicious server could return a specially crafted authentication packet, causing the client to read and return up to 12 bytes of data from an uninitialized variable in stack memory. Users of the trilogy gem should upgrade to version 2.1.1 This issue can be avoided by only connecting to trusted servers.", "other": {"cve": {"id": "CVE-2022-31026", "sourceIdentifier": "security-advisories@github.com", "published": "2022-06-09T13:15:08.457", "lastModified": "2022-06-15T18:26:27.897", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Trilogy is a client library for MySQL. When authenticating, a malicious server could return a specially crafted authentication packet, causing the client to read and return up to 12 bytes of data from an uninitialized variable in stack memory. Users of the trilogy gem should upgrade to version 2.1.1 This issue can be avoided by only connecting to trusted servers."}, {"lang": "es", "value": "Trilogy es una biblioteca cliente para MySQL. Cuando es autenticado, un servidor malicioso podr\u00eda devolver un paquete de autenticaci\u00f3n especialmente dise\u00f1ado, causando que el cliente lea y devuelva hasta 12 bytes de datos de una variable no inicializada en la memoria de la pila. Los usuarios de la gema trilog\u00eda deber\u00edan actualizar a versi\u00f3n 2.1.1. Este problema puede evitarse conect\u00e1ndose \u00fanicamente a servidores confiables"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-908"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:trilogy_project:trilogy:*:*:*:*:*:ruby:*:*", "versionEndExcluding": "2.1.1", "matchCriteriaId": "9DBD25C5-280A-4303-8AEA-1389C45EB652"}]}]}], "references": [{"url": "https://github.com/github/trilogy/commit/6bed62789eaf119902b0fe247d2a91d56c31a962", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/github/trilogy/security/advisories/GHSA-5g4r-2qhx-vqfm", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/github/trilogy/commit/6bed62789eaf119902b0fe247d2a91d56c31a962"}}