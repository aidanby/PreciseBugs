{"buggy_code": ["/*\n *  Copyright (C) 2011-2012 Christian Beier <dontmind@freeshell.org>\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * sockets.c - functions to deal with sockets.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#ifdef __linux__\n/* Setting this on other systems hides definitions such as INADDR_LOOPBACK.\n * The check should be for __GLIBC__ in fact. */\n# define _POSIX_SOURCE\n#endif\n#endif\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <rfb/rfbclient.h>\n#include \"sockets.h\"\n#include \"tls.h\"\n#include \"sasl.h\"\n\nvoid PrintInHex(char *buf, int len);\n\nrfbBool errorMessageOnReadFailure = TRUE;\n\n/*\n * ReadFromRFBServer is called whenever we want to read some data from the RFB\n * server.  It is non-trivial for two reasons:\n *\n * 1. For efficiency it performs some intelligent buffering, avoiding invoking\n *    the read() system call too often.  For small chunks of data, it simply\n *    copies the data out of an internal buffer.  For large amounts of data it\n *    reads directly into the buffer provided by the caller.\n *\n * 2. Whenever read() would block, it invokes the Xt event dispatching\n *    mechanism to process X events.  In fact, this is the only place these\n *    events are processed, as there is no XtAppMainLoop in the program.\n */\n\nrfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tunsigned int nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, 100000);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { unsigned int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}\n\n\n/*\n * Write an exact number of bytes, and don't return until you've sent them.\n */\n\nrfbBool\nWriteToRFBServer(rfbClient* client, const char *buf, unsigned int n)\n{\n  fd_set fds;\n  int i = 0;\n  int j;\n  const char *obuf = buf;\n#ifdef LIBVNCSERVER_HAVE_SASL\n  const char *output;\n  unsigned int outputlen;\n  int err;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  if (client->serverPort==-1)\n    return TRUE; /* vncrec playing */\n\n  if (client->tlsSession) {\n    /* WriteToTLS() will guarantee either everything is written, or error/eof returns */\n    i = WriteToTLS(client, buf, n);\n    if (i <= 0) return FALSE;\n\n    return TRUE;\n  }\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslconn) {\n    err = sasl_encode(client->saslconn,\n                      buf, n,\n                      &output, &outputlen);\n    if (err != SASL_OK) {\n      rfbClientLog(\"Failed to encode SASL data %s\",\n                   sasl_errstring(err, NULL, NULL));\n      return FALSE;\n    }\n    obuf = output;\n    n = outputlen;\n  }\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  while (i < n) {\n    j = write(client->sock, obuf + i, (n - i));\n    if (j <= 0) {\n      if (j < 0) {\n#ifdef WIN32\n\t errno=WSAGetLastError();\n#endif\n\tif (errno == EWOULDBLOCK ||\n#ifdef LIBVNCSERVER_ENOENT_WORKAROUND\n\t\terrno == ENOENT ||\n#endif\n\t\terrno == EAGAIN) {\n\t  FD_ZERO(&fds);\n\t  FD_SET(client->sock,&fds);\n\n\t  if (select(client->sock+1, NULL, &fds, NULL, NULL) <= 0) {\n\t    rfbClientErr(\"select\\n\");\n\t    return FALSE;\n\t  }\n\t  j = 0;\n\t} else {\n\t  rfbClientErr(\"write\\n\");\n\t  return FALSE;\n\t}\n      } else {\n\trfbClientLog(\"write failed\\n\");\n\treturn FALSE;\n      }\n    }\n    i += j;\n  }\n  return TRUE;\n}\n\n\nstatic rfbBool WaitForConnected(int socket, unsigned int secs)\n{\n  fd_set writefds;\n  fd_set exceptfds;\n  struct timeval timeout;\n\n  timeout.tv_sec=secs;\n  timeout.tv_usec=0;\n\n  FD_ZERO(&writefds);\n  FD_SET(socket, &writefds);\n  FD_ZERO(&exceptfds);\n  FD_SET(socket, &exceptfds);\n  if (select(socket+1, NULL, &writefds, &exceptfds, &timeout)==1) {\n#ifdef WIN32\n    if (FD_ISSET(socket, &exceptfds))\n      return FALSE;\n#else\n    int so_error;\n    socklen_t len = sizeof so_error;\n    getsockopt(socket, SOL_SOCKET, SO_ERROR, &so_error, &len);\n    if (so_error!=0)\n      return FALSE;\n#endif\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nrfbSocket\nConnectClientToTcpAddr(unsigned int host, int port)\n{\n  rfbSocket sock = ConnectClientToTcpAddrWithTimeout(host, port, DEFAULT_CONNECT_TIMEOUT);\n  /* put socket back into blocking mode for compatibility reasons */\n  if (sock != RFB_INVALID_SOCKET) {\n    SetBlocking(sock);\n  }\n  return sock;\n}\n\nrfbSocket\nConnectClientToTcpAddrWithTimeout(unsigned int host, int port, unsigned int timeout)\n{\n  rfbSocket sock;\n  struct sockaddr_in addr;\n  int one = 1;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = host;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientErr(\"ConnectToTcpAddr: socket (%s)\\n\",strerror(errno));\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (!SetNonBlocking(sock))\n    return FALSE;\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    if (!((errno == EWOULDBLOCK || errno == EINPROGRESS) && WaitForConnected(sock, timeout))) {\n      rfbClientErr(\"ConnectToTcpAddr: connect\\n\");\n      rfbCloseSocket(sock);\n      return RFB_INVALID_SOCKET;\n    }\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\nrfbSocket\nConnectClientToTcpAddr6(const char *hostname, int port)\n{\n  rfbSocket sock = ConnectClientToTcpAddr6WithTimeout(hostname, port, DEFAULT_CONNECT_TIMEOUT);\n  /* put socket back into blocking mode for compatibility reasons */\n  if (sock != RFB_INVALID_SOCKET) {\n    SetBlocking(sock);\n  }\n  return sock;\n}\n\nrfbSocket\nConnectClientToTcpAddr6WithTimeout(const char *hostname, int port, unsigned int timeout)\n{\n#ifdef LIBVNCSERVER_IPv6\n  rfbSocket sock;\n  int n;\n  struct addrinfo hints, *res, *ressave;\n  char port_s[10];\n  int one = 1;\n\n  snprintf(port_s, 10, \"%d\", port);\n  memset(&hints, 0, sizeof(struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  if ((n = getaddrinfo(strcmp(hostname,\"\") == 0 ? \"localhost\": hostname, port_s, &hints, &res)))\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: getaddrinfo (%s)\\n\", gai_strerror(n));\n    return RFB_INVALID_SOCKET;\n  }\n\n  ressave = res;\n  sock = RFB_INVALID_SOCKET;\n  while (res)\n  {\n    sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n    if (sock != RFB_INVALID_SOCKET)\n    {\n      if (SetNonBlocking(sock)) {\n        if (connect(sock, res->ai_addr, res->ai_addrlen) == 0) {\n          break;\n        } else {\n#ifdef WIN32\n          errno=WSAGetLastError();\n#endif\n          if ((errno == EWOULDBLOCK || errno == EINPROGRESS) && WaitForConnected(sock, timeout))\n            break;\n          rfbCloseSocket(sock);\n          sock = RFB_INVALID_SOCKET;\n        }\n      } else {\n        rfbCloseSocket(sock);\n        sock = RFB_INVALID_SOCKET;\n      }\n    }\n    res = res->ai_next;\n  }\n  freeaddrinfo(ressave);\n\n  if (sock == RFB_INVALID_SOCKET)\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: connect\\n\");\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n\n#else\n\n  rfbClientErr(\"ConnectClientToTcpAddr6: IPv6 disabled\\n\");\n  return RFB_INVALID_SOCKET;\n\n#endif\n}\n\nrfbSocket\nConnectClientToUnixSock(const char *sockFile)\n{\n  rfbSocket sock = ConnectClientToUnixSockWithTimeout(sockFile, DEFAULT_CONNECT_TIMEOUT);\n  /* put socket back into blocking mode for compatibility reasons */\n  if (sock != RFB_INVALID_SOCKET) {\n    SetBlocking(sock);\n  }\n  return sock;\n}\n\nrfbSocket\nConnectClientToUnixSockWithTimeout(const char *sockFile, unsigned int timeout)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return RFB_INVALID_SOCKET;\n#else\n  rfbSocket sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 > sizeof(addr.sun_path)) {\n      rfbClientErr(\"ConnectToUnixSock: socket file name too long\\n\");\n      return RFB_INVALID_SOCKET;\n  }\n  strcpy(addr.sun_path, sockFile);\n\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (!SetNonBlocking(sock))\n    return RFB_INVALID_SOCKET;\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0 &&\n      !(errno == EINPROGRESS && WaitForConnected(sock, timeout))) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n#endif\n}\n\n\n\n/*\n * FindFreeTcpPort tries to find unused TCP port in the range\n * (TUNNEL_PORT_OFFSET, TUNNEL_PORT_OFFSET + 99]. Returns 0 on failure.\n */\n\nint\nFindFreeTcpPort(void)\n{\n  rfbSocket sock;\n  int port;\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\": FindFreeTcpPort: socket\\n\");\n    return 0;\n  }\n\n  for (port = TUNNEL_PORT_OFFSET + 99; port > TUNNEL_PORT_OFFSET; port--) {\n    addr.sin_port = htons((unsigned short)port);\n    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0) {\n      rfbCloseSocket(sock);\n      return port;\n    }\n  }\n\n  rfbCloseSocket(sock);\n  return 0;\n}\n\n\n/*\n * ListenAtTcpPort starts listening at the given TCP port.\n */\n\nrfbSocket\nListenAtTcpPort(int port)\n{\n  return ListenAtTcpPortAndAddress(port, NULL);\n}\n\n\n\n/*\n * ListenAtTcpPortAndAddress starts listening at the given TCP port on\n * the given IP address\n */\n\nrfbSocket\nListenAtTcpPortAndAddress(int port, const char *address)\n{\n  rfbSocket sock = RFB_INVALID_SOCKET;\n  int one = 1;\n#ifndef LIBVNCSERVER_IPv6\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  if (address) {\n    addr.sin_addr.s_addr = inet_addr(address);\n  } else {\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n  }\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\"ListenAtTcpPort: socket\\n\");\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t (const char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: bind\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n#else\n  int rv;\n  struct addrinfo hints, *servinfo, *p;\n  char port_str[8];\n\n  snprintf(port_str, 8, \"%d\", port);\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE; /* fill in wildcard address if address == NULL */\n\n  if ((rv = getaddrinfo(address, port_str, &hints, &servinfo)) != 0) {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in getaddrinfo: %s\\n\", gai_strerror(rv));\n    return RFB_INVALID_SOCKET;\n  }\n\n  /* loop through all the results and bind to the first we can */\n  for(p = servinfo; p != NULL; p = p->ai_next) {\n    if ((sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == RFB_INVALID_SOCKET) {\n      continue;\n    }\n\n#ifdef IPV6_V6ONLY\n    /* we have separate IPv4 and IPv6 sockets since some OS's do not support dual binding */\n    if (p->ai_family == AF_INET6 && setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt IPV6_V6ONLY: %s\\n\", strerror(errno));\n      rfbCloseSocket(sock);\n      freeaddrinfo(servinfo);\n      return RFB_INVALID_SOCKET;\n    }\n#endif\n\n    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt SO_REUSEADDR: %s\\n\", strerror(errno));\n      rfbCloseSocket(sock);\n      freeaddrinfo(servinfo);\n      return RFB_INVALID_SOCKET;\n    }\n\n    if (bind(sock, p->ai_addr, p->ai_addrlen) < 0) {\n      rfbCloseSocket(sock);\n      continue;\n    }\n\n    break;\n  }\n\n  if (p == NULL)  {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in bind: %s\\n\", strerror(errno));\n    return RFB_INVALID_SOCKET;\n  }\n\n  /* all done with this structure now */\n  freeaddrinfo(servinfo);\n#endif\n\n  if (listen(sock, 5) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: listen\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\n\n/*\n * AcceptTcpConnection accepts a TCP connection.\n */\n\nrfbSocket\nAcceptTcpConnection(rfbSocket listenSock)\n{\n  rfbSocket sock;\n  struct sockaddr_in addr;\n  socklen_t addrlen = sizeof(addr);\n  int one = 1;\n\n  sock = accept(listenSock, (struct sockaddr *) &addr, &addrlen);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\"AcceptTcpConnection: accept\\n\");\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"AcceptTcpConnection: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\n\n/*\n * SetNonBlocking sets a socket into non-blocking mode.\n */\n\nrfbBool\nSetNonBlocking(rfbSocket sock)\n{\n#ifdef WIN32\n  unsigned long block=1;\n  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {\n    errno=WSAGetLastError();\n#else\n  int flags = fcntl(sock, F_GETFL);\n  if(flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {\n#endif\n    rfbClientErr(\"Setting socket to non-blocking failed: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n  return TRUE;\n}\n\n\nrfbBool SetBlocking(rfbSocket sock)\n{\n#ifdef WIN32\n  unsigned long block=0;\n  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {\n    errno=WSAGetLastError();\n#else\n  int flags = fcntl(sock, F_GETFL);\n  if(flags < 0 || fcntl(sock, F_SETFL, flags & ~O_NONBLOCK) < 0) {\n#endif\n    rfbClientErr(\"Setting socket to blocking failed: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n  return TRUE;\n}\n\n\n/*\n * SetDSCP sets a socket's IP QoS parameters aka Differentiated Services Code Point field\n */\n\nrfbBool\nSetDSCP(rfbSocket sock, int dscp)\n{\n#ifdef WIN32\n  rfbClientErr(\"Setting of QoS IP DSCP not implemented for Windows\\n\");\n  return TRUE;\n#else\n  int level, cmd;\n  struct sockaddr addr;\n  socklen_t addrlen = sizeof(addr);\n\n  if(getsockname(sock, &addr, &addrlen) != 0) {\n    rfbClientErr(\"Setting socket QoS failed while getting socket address: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n\n  switch(addr.sa_family)\n    {\n#if defined LIBVNCSERVER_IPv6 && defined IPV6_TCLASS\n    case AF_INET6:\n      level = IPPROTO_IPV6;\n      cmd = IPV6_TCLASS;\n      break;\n#endif\n    case AF_INET:\n      level = IPPROTO_IP;\n      cmd = IP_TOS;\n      break;\n    default:\n      rfbClientErr(\"Setting socket QoS failed: Not bound to IP address\");\n      return FALSE;\n    }\n\n  if(setsockopt(sock, level, cmd, (void*)&dscp, sizeof(dscp)) != 0) {\n    rfbClientErr(\"Setting socket QoS failed: %s\\n\", strerror(errno));\n    return FALSE;\n  }\n\n  return TRUE;\n#endif\n}\n\n\n\n/*\n * StringToIPAddr - convert a host string to an IP address.\n */\n\nrfbBool\nStringToIPAddr(const char *str, unsigned int *addr)\n{\n  struct hostent *hp;\n\n  if (strcmp(str,\"\") == 0) {\n    *addr = htonl(INADDR_LOOPBACK); /* local */\n    return TRUE;\n  }\n\n  *addr = inet_addr(str);\n\n  if (*addr != -1)\n    return TRUE;\n\n  hp = gethostbyname(str);\n\n  if (hp) {\n    *addr = *(unsigned int *)hp->h_addr;\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n/*\n * Test if the other end of a socket is on the same machine.\n */\n\nrfbBool\nSameMachine(rfbSocket sock)\n{\n  struct sockaddr_in peeraddr, myaddr;\n  socklen_t addrlen = sizeof(struct sockaddr_in);\n\n  getpeername(sock, (struct sockaddr *)&peeraddr, &addrlen);\n  getsockname(sock, (struct sockaddr *)&myaddr, &addrlen);\n\n  return (peeraddr.sin_addr.s_addr == myaddr.sin_addr.s_addr);\n}\n\n\n/*\n * Print out the contents of a packet for debugging.\n */\n\nvoid\nPrintInHex(char *buf, int len)\n{\n  int i, j;\n  char c, str[17];\n\n  str[16] = 0;\n\n  rfbClientLog(\"ReadExact: \");\n\n  for (i = 0; i < len; i++)\n    {\n      if ((i % 16 == 0) && (i != 0)) {\n\trfbClientLog(\"           \");\n      }\n      c = buf[i];\n      str[i % 16] = (((c > 31) && (c < 127)) ? c : '.');\n      rfbClientLog(\"%02x \",(unsigned char)c);\n      if ((i % 4) == 3)\n\trfbClientLog(\" \");\n      if ((i % 16) == 15)\n\t{\n\t  rfbClientLog(\"%s\\n\",str);\n\t}\n    }\n  if ((i % 16) != 0)\n    {\n      for (j = i % 16; j < 16; j++)\n\t{\n\t  rfbClientLog(\"   \");\n\t  if ((j % 4) == 3) rfbClientLog(\" \");\n\t}\n      str[i % 16] = 0;\n      rfbClientLog(\"%s\\n\",str);\n    }\n\n  fflush(stderr);\n}\n\nint WaitForMessage(rfbClient* client,unsigned int usecs)\n{\n  fd_set fds;\n  struct timeval timeout;\n  int num;\n\n  if (client->serverPort==-1)\n    /* playing back vncrec file */\n    return 1;\n  \n  timeout.tv_sec=(usecs/1000000);\n  timeout.tv_usec=(usecs%1000000);\n\n  FD_ZERO(&fds);\n  FD_SET(client->sock,&fds);\n\n  num=select(client->sock+1, &fds, NULL, NULL, &timeout);\n  if(num<0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientLog(\"Waiting for message failed: %d (%s)\\n\",errno,strerror(errno));\n  }\n\n  return num;\n}\n\n\n", "/*\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * vncviewer.c - the Xt-based VNC viewer.\n */\n\n#ifdef WIN32\n#include <winsock2.h>\n#endif\n\n#ifdef _MSC_VER\n#define strdup _strdup /* Prevent POSIX deprecation warnings */\n#endif\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <rfb/rfbclient.h>\n#include \"tls.h\"\n\nstatic void Dummy(rfbClient* client) {\n}\nstatic rfbBool DummyPoint(rfbClient* client, int x, int y) {\n  return TRUE;\n}\nstatic void DummyRect(rfbClient* client, int x, int y, int w, int h) {\n}\n\n#ifdef WIN32\nstatic char* NoPassword(rfbClient* client) {\n  return strdup(\"\");\n}\n#else\n#include <stdio.h>\n#include <termios.h>\n#endif\n\nstatic char* ReadPassword(rfbClient* client) {\n\tint i;\n\tchar* p=calloc(1,9);\n#ifndef WIN32\n\tstruct termios save,noecho;\n\tif(tcgetattr(fileno(stdin),&save)!=0) return p;\n\tnoecho=save; noecho.c_lflag &= ~ECHO;\n\tif(tcsetattr(fileno(stdin),TCSAFLUSH,&noecho)!=0) return p;\n#endif\n\tfprintf(stderr,\"Password: \");\n\ti=0;\n\twhile(1) {\n\t\tint c=fgetc(stdin);\n\t\tif(c=='\\n')\n\t\t\tbreak;\n\t\tif(i<8) {\n\t\t\tp[i]=c;\n\t\t\ti++;\n\t\t\tp[i]=0;\n\t\t}\n\t}\n#ifndef WIN32\n\ttcsetattr(fileno(stdin),TCSAFLUSH,&save);\n#endif\n\treturn p;\n}\nstatic rfbBool MallocFrameBuffer(rfbClient* client) {\n  uint64_t allocSize;\n\n  if(client->frameBuffer)\n    free(client->frameBuffer);\n\n  /* SECURITY: promote 'width' into uint64_t so that the multiplication does not overflow\n     'width' and 'height' are 16-bit integers per RFB protocol design\n     SIZE_MAX is the maximum value that can fit into size_t\n  */\n  allocSize = (uint64_t)client->width * client->height * client->format.bitsPerPixel/8;\n\n  if (allocSize >= SIZE_MAX) {\n    rfbClientErr(\"CRITICAL: cannot allocate frameBuffer, requested size is too large\\n\");\n    return FALSE;\n  }\n\n  client->frameBuffer=malloc( (size_t)allocSize );\n\n  if (client->frameBuffer == NULL)\n    rfbClientErr(\"CRITICAL: frameBuffer allocation failed, requested size too large or not enough memory?\\n\");\n\n  return client->frameBuffer?TRUE:FALSE;\n}\n\n/* messages */\n\nstatic rfbBool CheckRect(rfbClient* client, int x, int y, int w, int h) {\n  return x + w <= client->width && y + h <= client->height;\n}\n\nstatic void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void CopyRectangle(rfbClient* client, const uint8_t* buffer, int x, int y, int w, int h) {\n  int j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define COPY_RECT(BPP) \\\n  { \\\n    int rs = w * BPP / 8, rs2 = client->width * BPP / 8; \\\n    for (j = ((x * (BPP / 8)) + (y * rs2)); j < (y + h) * rs2; j += rs2) { \\\n      memcpy(client->frameBuffer + j, buffer, rs); \\\n      buffer += rs; \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT(8);  break;\n  case 16: COPY_RECT(16); break;\n  case 32: COPY_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\n/* TODO: test */\nstatic void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, src_x, src_y, w, h)) {\n    rfbClientLog(\"Source rect out of bounds: %dx%d at (%d, %d)\\n\", src_x, src_y, w, h);\n    return;\n  }\n\n  if (!CheckRect(client, dest_x, dest_y, w, h)) {\n    rfbClientLog(\"Dest rect out of bounds: %dx%d at (%d, %d)\\n\", dest_x, dest_y, w, h);\n    return;\n  }\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void initAppData(AppData* data) {\n\tdata->shareDesktop=TRUE;\n\tdata->viewOnly=FALSE;\n\tdata->encodingsString=\"tight zrle ultra copyrect hextile zlib corre rre raw\";\n\tdata->useBGR233=FALSE;\n\tdata->nColours=0;\n\tdata->forceOwnCmap=FALSE;\n\tdata->forceTrueColour=FALSE;\n\tdata->requestedDepth=0;\n\tdata->compressLevel=3;\n\tdata->qualityLevel=5;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\tdata->enableJPEG=TRUE;\n#else\n\tdata->enableJPEG=FALSE;\n#endif\n\tdata->useRemoteCursor=FALSE;\n}\n\nrfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}\n\nstatic rfbBool rfbInitConnection(rfbClient* client)\n{\n  /* Unless we accepted an incoming connection, make a TCP connection to the\n     given VNC server */\n\n  if (!client->listenSpecified) {\n    if (!client->serverHost)\n      return FALSE;\n    if (client->destHost) {\n      if (!ConnectToRFBRepeater(client,client->serverHost,client->serverPort,client->destHost,client->destPort))\n        return FALSE;\n    } else {\n      if (!ConnectToRFBServer(client,client->serverHost,client->serverPort))\n        return FALSE;\n    }\n  }\n\n  /* Initialise the VNC connection, including reading the password */\n\n  if (!InitialiseRFBConnection(client))\n    return FALSE;\n\n  client->width=client->si.framebufferWidth;\n  client->height=client->si.framebufferHeight;\n  if (!client->MallocFrameBuffer(client))\n    return FALSE;\n\n  if (!SetFormatAndEncodings(client))\n    return FALSE;\n\n  if (client->updateRect.x < 0) {\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n  }\n\n  if (client->appData.scaleSetting>1)\n  {\n      if (!SendScaleSetting(client, client->appData.scaleSetting))\n          return FALSE;\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x / client->appData.scaleSetting,\n\t\t\t      client->updateRect.y / client->appData.scaleSetting,\n\t\t\t      client->updateRect.w / client->appData.scaleSetting,\n\t\t\t      client->updateRect.h / client->appData.scaleSetting,\n\t\t\t      FALSE))\n\t      return FALSE;\n  }\n  else\n  {\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x, client->updateRect.y,\n\t\t\t      client->updateRect.w, client->updateRect.h,\n\t\t\t      FALSE))\n      return FALSE;\n  }\n\n  return TRUE;\n}\n\nrfbBool rfbInitClient(rfbClient* client,int* argc,char** argv) {\n  int i,j;\n\n  if(argv && argc && *argc) {\n    if(client->programName==0)\n      client->programName=argv[0];\n\n    for (i = 1; i < *argc; i++) {\n      j = i;\n      if (strcmp(argv[i], \"-listen\") == 0) {\n\tlistenForIncomingConnections(client);\n\tbreak;\n      } else if (strcmp(argv[i], \"-listennofork\") == 0) {\n\tlistenForIncomingConnectionsNoFork(client, -1);\n\tbreak;\n      } else if (strcmp(argv[i], \"-play\") == 0) {\n\tclient->serverPort = -1;\n\tj++;\n      } else if (i+1<*argc && strcmp(argv[i], \"-encodings\") == 0) {\n\tclient->appData.encodingsString = argv[i+1];\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-compress\") == 0) {\n\tclient->appData.compressLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-quality\") == 0) {\n\tclient->appData.qualityLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-scale\") == 0) {\n        client->appData.scaleSetting = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-qosdscp\") == 0) {\n        client->QoS_DSCP = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-repeaterdest\") == 0) {\n\tchar* colon=strchr(argv[i+1],':');\n\n\tif(client->destHost)\n\t  free(client->destHost);\n        client->destPort = 5900;\n\n\tclient->destHost = strdup(argv[i+1]);\n\tif(colon) {\n\t  client->destHost[(int)(colon-argv[i+1])] = '\\0';\n\t  client->destPort = atoi(colon+1);\n\t}\n        j+=2;\n      } else {\n\tchar* colon=strrchr(argv[i],':');\n\n\tif(client->serverHost)\n\t  free(client->serverHost);\n\n\tif(colon) {\n\t  client->serverHost = strdup(argv[i]);\n\t  client->serverHost[(int)(colon-argv[i])] = '\\0';\n\t  client->serverPort = atoi(colon+1);\n\t} else {\n\t  client->serverHost = strdup(argv[i]);\n\t}\n\tif(client->serverPort >= 0 && client->serverPort < 5900)\n\t  client->serverPort += 5900;\n      }\n      /* purge arguments */\n      if (j>i) {\n\t*argc-=j-i;\n\tmemmove(argv+i,argv+j,(*argc-i)*sizeof(char*));\n\ti--;\n      }\n    }\n  }\n\n  if(!rfbInitConnection(client)) {\n    rfbClientCleanup(client);\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\nvoid rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  int i;\n\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n#endif\n\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n\n  FreeTLS(client);\n\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n\n  free(client);\n}\n", "#ifndef RFBCLIENT_H\n#define RFBCLIENT_H\n\n/**\n * @defgroup libvncclient_api LibVNCClient API Reference\n * @{\n */\n\n/*\n *  Copyright (C) 2017 D. R. Commander.  All Rights Reserved.\n *  Copyright (C) 2000, 2001 Const Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/**\n * @file rfbclient.h\n */\n\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN /* Prevent loading any Winsock 1.x headers from windows.h */\n#ifdef _MSC_VER\n#pragma warning(disable:4996)\n#endif\n#endif\n\n#if defined(ANDROID) || defined(LIBVNCSERVER_HAVE_ANDROID)\n#include <arpa/inet.h>\n#include <sys/select.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#if LIBVNCSERVER_HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <rfb/rfbproto.h>\n#include <rfb/keysym.h>\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n#include <sasl/sasl.h>\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#define rfbClientSwap16IfLE(s) \\\n    (*(char *)&client->endianTest ? ((((s) & 0xff) << 8) | (((s) >> 8) & 0xff)) : (s))\n\n#define rfbClientSwap32IfLE(l) \\\n    (*(char *)&client->endianTest ? ((((l) >> 24) & 0x000000ff) | \\\n\t\t\t     (((l) & 0x00ff0000) >> 8)  | \\\n\t\t\t     (((l) & 0x0000ff00) << 8)  | \\\n\t\t\t     (((l) & 0x000000ff) << 24))  : (l))\n\n#define rfbClientSwap64IfLE(l) \\\n    (*(char *)&client->endianTest ? ((((l) >> 56 ) & 0x00000000000000ffULL) | \\\n\t\t\t     (((l) & 0x00ff000000000000ULL) >> 40)  | \\\n\t\t\t     (((l) & 0x0000ff0000000000ULL) >> 24)  | \\\n\t\t\t     (((l) & 0x000000ff00000000ULL) >> 8)  | \\\n\t\t\t     (((l) & 0x00000000ff000000ULL) << 8)  | \\\n\t\t\t     (((l) & 0x0000000000ff0000ULL) << 24)  | \\\n\t\t\t     (((l) & 0x000000000000ff00ULL) << 40)  | \\\n\t\t\t     (((l) & 0x00000000000000ffULL) << 56))  : (l))\n\n#define FLASH_PORT_OFFSET 5400\n#define LISTEN_PORT_OFFSET 5500\n#define TUNNEL_PORT_OFFSET 5500\n#define SERVER_PORT_OFFSET 5900\n\n#define DEFAULT_CONNECT_TIMEOUT 60\n\n#define DEFAULT_SSH_CMD \"/usr/bin/ssh\"\n#define DEFAULT_TUNNEL_CMD  \\\n  (DEFAULT_SSH_CMD \" -f -L %L:localhost:%R %H sleep 20\")\n#define DEFAULT_VIA_CMD     \\\n  (DEFAULT_SSH_CMD \" -f -L %L:%H:%R %G sleep 20\")\n\n#if(defined __cplusplus)\nextern \"C\"\n{\n#endif\n\n/** vncrec */\n\ntypedef struct {\n  FILE* file;\n  struct timeval tv;\n  rfbBool readTimestamp;\n  rfbBool doNotSleep;\n} rfbVNCRec;\n\n/** client data */\n\ntypedef struct rfbClientData {\n\tvoid* tag;\n\tvoid* data;\n\tstruct rfbClientData* next;\n} rfbClientData;\n\n/** app data (belongs into rfbClient?) */\n\ntypedef struct {\n  rfbBool shareDesktop;\n  rfbBool viewOnly;\n\n  const char* encodingsString;\n\n  rfbBool useBGR233;\n  int nColours;\n  rfbBool forceOwnCmap;\n  rfbBool forceTrueColour;\n  int requestedDepth;\n\n  int compressLevel;\n  int qualityLevel;\n  rfbBool enableJPEG;\n  rfbBool useRemoteCursor;\n  rfbBool palmVNC;  /**< use palmvnc specific SetScale (vs ultravnc) */\n  int scaleSetting; /**< 0 means no scale set, else 1/scaleSetting */\n} AppData;\n\n/** For GetCredentialProc callback function to return */\ntypedef union _rfbCredential\n{\n  /** X509 (VeNCrypt) */\n  struct\n  {\n    char *x509CACertFile;\n    char *x509CACrlFile;\n    char *x509ClientCertFile;\n    char *x509ClientKeyFile;\n    uint8_t x509CrlVerifyMode; /* Only required for OpenSSL - see meanings below */\n  } x509Credential;\n  /** Plain (VeNCrypt), MSLogon (UltraVNC) */\n  struct\n  {\n    char *username;\n    char *password;\n  } userCredential;\n} rfbCredential;\n\n#define rfbCredentialTypeX509 1\n#define rfbCredentialTypeUser 2\n\n/* When using OpenSSL, CRLs can be included in both the x509CACrlFile and appended\n   to the x509CACertFile as is common with OpenSSL.  When rfbX509CrlVerifyAll is\n   specified the CRL list must include CRLs for all certificates in the chain */\n#define rfbX509CrlVerifyNone   0    /* No CRL checking is performed */\n#define rfbX509CrlVerifyClient 1    /* Only the leaf server certificate is checked */\n#define rfbX509CrlVerifyAll    2    /* All certificates in the server chain are checked */\n\nstruct _rfbClient;\n\n/**\n * Handles a text chat message. If your application should accept text messages\n * from the server, define a function with this prototype and set\n * client->HandleTextChat to a pointer to that function subsequent to your\n * rfbGetClient() call.\n * @param client The client which called the text chat handler\n * @param value  text length if text != NULL, or one of rfbTextChatOpen,\n * rfbTextChatClose, rfbTextChatFinished if text == NULL\n * @param text The text message from the server\n */\ntypedef void (*HandleTextChatProc)(struct _rfbClient* client, int value, char *text);\n/**\n * Handles XVP server messages. If your application sends XVP messages to the\n * server, you'll want to handle the server's XVP_FAIL and XVP_INIT responses.\n * Define a function with this prototype and set client->HandleXvpMsg to a\n * pointer to that function subsequent to your rfbGetClient() call.\n * @param client The client which called the XVP message handler\n * @param version The highest XVP extension version that the server supports\n * @param opcode The opcode. 0 is XVP_FAIL, 1 is XVP_INIT\n */\ntypedef void (*HandleXvpMsgProc)(struct _rfbClient* client, uint8_t version, uint8_t opcode);\ntypedef void (*HandleKeyboardLedStateProc)(struct _rfbClient* client, int value, int pad);\ntypedef rfbBool (*HandleCursorPosProc)(struct _rfbClient* client, int x, int y);\ntypedef void (*SoftCursorLockAreaProc)(struct _rfbClient* client, int x, int y, int w, int h);\ntypedef void (*SoftCursorUnlockScreenProc)(struct _rfbClient* client);\n/**\n   Callback indicating that a rectangular area of the client's framebuffer was updated.\n   As a server will usually send several rects per rfbFramebufferUpdate message, this\n   callback is usually called multiple times per rfbFramebufferUpdate message.\n   @param client The client whose framebuffer was (partially) updated\n   @param x The x-coordinate of the upper left corner of the updated rectangle\n   @param y The y-coordinate of the upper left corner of the updated rectangle\n   @param w The width of the updated rectangle\n   @param h The heigth of the updated rectangle\n */\ntypedef void (*GotFrameBufferUpdateProc)(struct _rfbClient* client, int x, int y, int w, int h);\n/**\n   Callback indicating that a client has completely processed an rfbFramebufferUpdate\n   message sent by a server.\n   This is called exactly once per each handled rfbFramebufferUpdate message.\n   @param client The client which finished processing an rfbFramebufferUpdate\n */\ntypedef void (*FinishedFrameBufferUpdateProc)(struct _rfbClient* client);\ntypedef char* (*GetPasswordProc)(struct _rfbClient* client);\ntypedef rfbCredential* (*GetCredentialProc)(struct _rfbClient* client, int credentialType);\ntypedef rfbBool (*MallocFrameBufferProc)(struct _rfbClient* client);\ntypedef void (*GotXCutTextProc)(struct _rfbClient* client, const char *text, int textlen);\ntypedef void (*BellProc)(struct _rfbClient* client);\n/**\n    Called when a cursor shape update was received from the server. The decoded cursor shape\n    will be in client->rcSource. It's up to the application to do something with this, e.g. draw\n    into a viewer's window. If you want the server to draw the cursor into the framebuffer, be\n    careful not to announce remote cursor support, i.e. not include rfbEncodingXCursor or\n    rfbEncodingRichCursor in SetFormatAndEncodings().\n*/\ntypedef void (*GotCursorShapeProc)(struct _rfbClient* client, int xhot, int yhot, int width, int height, int bytesPerPixel);\ntypedef void (*GotCopyRectProc)(struct _rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y);\ntypedef void (*GotFillRectProc)(struct _rfbClient* client, int x, int y, int w, int h, uint32_t colour);\ntypedef void (*GotBitmapProc)(struct _rfbClient* client, const uint8_t* buffer, int x, int y, int w, int h);\ntypedef rfbBool (*GotJpegProc)(struct _rfbClient* client, const uint8_t* buffer, int length, int x, int y, int w, int h);\ntypedef rfbBool (*LockWriteToTLSProc)(struct _rfbClient* client);\ntypedef rfbBool (*UnlockWriteToTLSProc)(struct _rfbClient* client);\n\n#ifdef LIBVNCSERVER_HAVE_SASL\ntypedef char* (*GetUserProc)(struct _rfbClient* client);\ntypedef char* (*GetSASLMechanismProc)(struct _rfbClient* client, char* mechlist);\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\ntypedef struct _rfbClient {\n\tuint8_t* frameBuffer;\n\tint width, height;\n\n\tint endianTest;\n\n\tAppData appData;\n\n\tconst char* programName;\n\tchar* serverHost;\n\tint serverPort; /**< if -1, then use file recorded by vncrec */\n\trfbBool listenSpecified;\n\tint listenPort, flashPort;\n\n\tstruct {\n\t\tint x, y, w, h;\n\t} updateRect;\n\n\t/** Note that the CoRRE encoding uses this buffer and assumes it is big enough\n\t   to hold 255 * 255 * 32 bits -> 260100 bytes.  640*480 = 307200 bytes.\n\t   Hextile also assumes it is big enough to hold 16 * 16 * 32 bits.\n\t   Tight encoding assumes BUFFER_SIZE is at least 16384 bytes. */\n\n#define RFB_BUFFER_SIZE (640*480)\n\tchar buffer[RFB_BUFFER_SIZE];\n\n\t/* rfbproto.c */\n\n\trfbSocket sock;\n\trfbBool canUseCoRRE;\n\trfbBool canUseHextile;\n\tchar *desktopName;\n\trfbPixelFormat format;\n\trfbServerInitMsg si;\n\n\t/* sockets.c */\n#define RFB_BUF_SIZE 8192\n\tchar buf[RFB_BUF_SIZE];\n\tchar *bufoutptr;\n\tunsigned int buffered;\n\n\t/* The zlib encoding requires expansion/decompression/deflation of the\n\t   compressed data in the \"buffer\" above into another, result buffer.\n\t   However, the size of the result buffer can be determined precisely\n\t   based on the bitsPerPixel, height and width of the rectangle.  We\n\t   allocate this buffer one time to be the full size of the buffer. */\n\n\t/* Ultra Encoding uses this buffer too */\n\t\n\tint ultra_buffer_size;\n\tchar *ultra_buffer;\n\n\tint raw_buffer_size;\n\tchar *raw_buffer;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\tz_stream decompStream;\n\trfbBool decompStreamInited;\n#endif\n\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t/*\n\t * Variables for the ``tight'' encoding implementation.\n\t */\n\n\t/** Separate buffer for compressed data. */\n#define ZLIB_BUFFER_SIZE 30000\n\tchar zlib_buffer[ZLIB_BUFFER_SIZE];\n\n\t/* Four independent compression streams for zlib library. */\n\tz_stream zlibStream[4];\n\trfbBool zlibStreamActive[4];\n\n\t/* Filter stuff. Should be initialized by filter initialization code. */\n\trfbBool cutZeros;\n\tint rectWidth, rectColors;\n\tchar tightPalette[256*4];\n\tuint8_t tightPrevRow[2048*3*sizeof(uint16_t)];\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state (obsolete-- do not use). */\n\trfbBool jpegError;\n\n\tstruct jpeg_source_mgr* jpegSrcManager;\n\tvoid* jpegBufferPtr;\n\tsize_t jpegBufferLen;\n\n#endif\n#endif\n\n\n\t/* cursor.c */\n\t/** Holds cursor shape data when received from server. */\n\tuint8_t *rcSource, *rcMask;\n\n\t/** private data pointer */\n\trfbClientData* clientData;\n\n\trfbVNCRec* vncRec;\n\n\t/* Keyboard State support (is 'Caps Lock' set on the remote display???) */\n\tint KeyboardLedStateEnabled;\n\tint CurrentKeyboardLedState;\n\n\tint canHandleNewFBSize;\n\n\t/* hooks */\n\tHandleTextChatProc         HandleTextChat;\n\tHandleKeyboardLedStateProc HandleKeyboardLedState;\n\tHandleCursorPosProc HandleCursorPos;\n\tSoftCursorLockAreaProc SoftCursorLockArea;\n\tSoftCursorUnlockScreenProc SoftCursorUnlockScreen;\n\tGotFrameBufferUpdateProc GotFrameBufferUpdate;\n\t/** the pointer returned by GetPassword will be freed after use! */\n\tGetPasswordProc GetPassword;\n\tMallocFrameBufferProc MallocFrameBuffer;\n\tGotXCutTextProc GotXCutText;\n\tBellProc Bell;\n\n\tGotCursorShapeProc GotCursorShape;\n\tGotCopyRectProc GotCopyRect;\n\n\t/** Which messages are supported by the server\n\t * This is a *guess* for most servers.\n\t * (If we can even detect the type of server)\n\t *\n\t * If the server supports the \"rfbEncodingSupportedMessages\"\n\t * then this will be updated when the encoding is received to\n\t * accurately reflect the servers capabilities.\n\t */\n\trfbSupportedMessages supportedMessages;\n\n\t/** negotiated protocol version */\n\tint major, minor;\n\n\t/** The selected security types */\n\tuint32_t authScheme, subAuthScheme;\n\n\t/** The TLS session for Anonymous TLS and VeNCrypt */\n\tvoid* tlsSession;\n\n\t/** To support security types that requires user input (except VNC password\n\t * authentication), for example VeNCrypt and MSLogon, this callback function\n\t * must be set before the authentication. Otherwise, it implicates that the\n\t * caller application does not support it and related security types should\n\t * be bypassed.\n\t */\n\tGetCredentialProc GetCredential;\n\n\t/** The 0-terminated security types supported by the client.\n\t * Set by function SetClientAuthSchemes() */\n\tuint32_t *clientAuthSchemes;\n\n\t/** When the server is a repeater, this specifies the final destination */\n\tchar *destHost;\n\tint destPort;\n\n        /** the QoS IP DSCP for this client */\n        int QoS_DSCP;\n\n        /** hook to handle xvp server messages */\n\tHandleXvpMsgProc           HandleXvpMsg;\n\n\t/* listen.c */\n        rfbSocket listenSock;\n\n\tFinishedFrameBufferUpdateProc FinishedFrameBufferUpdate;\n\n\tchar *listenAddress;\n        /* IPv6 listen socket, address and port*/\n        rfbSocket listen6Sock;\n        char* listen6Address;\n        int listen6Port;\n\n        /* Output Window ID. When set, client application enables libvncclient to perform direct rendering in its window */\n        unsigned long outputWindow;\n\n\t/** Hooks for optional protection WriteToTLS() by mutex */\n\tLockWriteToTLSProc LockWriteToTLS;\n\tUnlockWriteToTLSProc UnlockWriteToTLS;\n\n        /** Hooks for custom rendering\n         *\n         * VNC rendering boils down to 3 activities:\n         * - GotCopyRect: copy an area of the framebuffer\n         * - GotFillRect: fill an area of the framebuffer with a solid color\n         * - GotBitmap: copy the bitmap in the buffer into the framebuffer\n         * The client application should either set all three of these or none!\n         */\n        GotFillRectProc GotFillRect;\n        GotBitmapProc GotBitmap;\n        /** Hook for custom JPEG decoding and rendering */\n        GotJpegProc GotJpeg;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n        sasl_conn_t *saslconn;\n        const char *saslDecoded;\n        unsigned int saslDecodedLength;\n        unsigned int saslDecodedOffset;\n        sasl_secret_t *saslSecret;\n\n        /* Callback to allow the client to choose a preferred mechanism. The string returned will\n           be freed once no longer required. */\n        GetSASLMechanismProc GetSASLMechanism;\n        GetUserProc GetUser;\n\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state. */\n\tvoid *tjhnd;\n\n#endif\n#endif\n\t/* timeout in seconds for select() after connect() */\n\tunsigned int connectTimeout;\n} rfbClient;\n\n/* cursor.c */\n/**\n * Handles XCursor and RichCursor shape updates from the server.\n * We emulate cursor operating on the frame buffer (that is\n * why we call it \"software cursor\"). This decodes the received cursor\n * shape and hands it over to GotCursorShapeProc, if set.\n */\nextern rfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc);\n\n/* listen.c */\n\nextern void listenForIncomingConnections(rfbClient* viewer);\nextern int listenForIncomingConnectionsNoFork(rfbClient* viewer, int usec_timeout);\n\n/* rfbproto.c */\n\nextern rfbBool rfbEnableClientLogging;\ntypedef void (*rfbClientLogProc)(const char *format, ...);\nextern rfbClientLogProc rfbClientLog,rfbClientErr;\nextern rfbBool ConnectToRFBServer(rfbClient* client,const char *hostname, int port);\nextern rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort);\nextern void SetClientAuthSchemes(rfbClient* client,const uint32_t *authSchemes, int size);\nextern rfbBool InitialiseRFBConnection(rfbClient* client);\n/**\n * Sends format and encoding parameters to the server. Your application can\n * modify the 'client' data structure directly. However some changes to this\n * structure must be communicated back to the server. For instance, if you\n * change the encoding to hextile, the server needs to know that it should send\n * framebuffer updates in hextile format. Likewise if you change the pixel\n * format of the framebuffer, the server must be notified about this as well.\n * Call this function to propagate your changes of the local 'client' structure\n * over to the server.\n * @li Encoding type\n * @li RFB protocol extensions announced via pseudo-encodings\n * @li Framebuffer pixel format (like RGB vs ARGB)\n * @li Remote cursor support\n * @param client The client in which the format or encodings have been changed\n * @return true if the format or encodings were sent to the server successfully,\n * false otherwise\n */\nextern rfbBool SetFormatAndEncodings(rfbClient* client);\nextern rfbBool SendIncrementalFramebufferUpdateRequest(rfbClient* client);\n/**\n * Sends a framebuffer update request to the server. A VNC client may request an\n * update from the server at any time. You can also specify which portions of\n * the screen you want updated. This can be handy if a pointer is at certain\n * location and the user pressed a mouse button, for instance. Then you can\n * immediately request an update of the region around the pointer from the\n * server.\n * @note The coordinate system is a left-handed Cartesian coordinate system with\n * the Z axis (unused) pointing out of the screen. Alternately you can think of\n * it as a right-handed Cartesian coordinate system with the Z axis pointing\n * into the screen. The origin is at the upper left corner of the framebuffer.\n * @param client The client through which to send the request\n * @param x The horizontal position of the update request rectangle\n * @param y The vertical position of the update request rectangle\n * @param w The width of the update request rectangle\n * @param h The height of the update request rectangle\n * @param incremental false: server sends rectangle even if nothing changed.\n * true: server only sends changed parts of rectangle.\n * @return true if the update request was sent successfully, false otherwise\n */\nextern rfbBool SendFramebufferUpdateRequest(rfbClient* client,\n\t\t\t\t\t int x, int y, int w, int h,\n\t\t\t\t\t rfbBool incremental);\nextern rfbBool SendScaleSetting(rfbClient* client,int scaleSetting);\n/**\n * Sends a pointer event to the server. A pointer event includes a cursor\n * location and a button mask. The button mask indicates which buttons on the\n * pointing device are pressed. Each button is represented by a bit in the\n * button mask. A 1 indicates the button is pressed while a 0 indicates that it\n * is not pressed. You may use these pre-defined button masks by ORing them\n * together: rfbButton1Mask, rfbButton2Mask, rfbButton3Mask, rfbButton4Mask\n * rfbButton5Mask\n * @note  The cursor location is relative to the client's framebuffer, not the\n * client's screen itself.\n * @note The coordinate system is a left-handed Cartesian coordinate system with\n * the Z axis (unused) pointing out of the screen. Alternately you can think of\n * it as a right-handed Cartesian coordinate system with the Z axis pointing\n * into the screen. The origin is at the upper left corner of the screen.\n * @param client The client through which to send the pointer event\n * @param x the horizontal location of the cursor\n * @param y the vertical location of the cursor\n * @param buttonMask the button mask indicating which buttons are pressed\n * @return true if the pointer event was sent successfully, false otherwise\n */\nextern rfbBool SendPointerEvent(rfbClient* client,int x, int y, int buttonMask);\n/**\n * Sends a key event to the server. If your application is not merely a VNC\n * viewer (i.e. it controls the server), you'll want to send the keys that the\n * user presses to the server. Use this function to do that.\n * @param client The client through which to send the key event\n * @param key An rfbKeySym defined in rfb/keysym.h\n * @param down true if this was a key down event, false otherwise\n * @return true if the key event was send successfully, false otherwise\n */\nextern rfbBool SendKeyEvent(rfbClient* client,uint32_t key, rfbBool down);\n/**\n * Places a string on the server's clipboard. Use this function if you want to\n * be able to copy and paste between the server and your application. For\n * instance, when your application is notified that the user copied some text\n * onto the clipboard, you would call this function to synchronize the server's\n * clipboard with your local clipboard.\n * @param client The client structure through which to send the client cut text\n * message\n * @param str The string to send (doesn't need to be NULL terminated)\n * @param len The length of the string\n * @return true if the client cut message was sent successfully, false otherwise\n */\nextern rfbBool SendClientCutText(rfbClient* client,char *str, int len);\n/**\n * Handles messages from the RFB server. You must call this function\n * intermittently so LibVNCClient can parse messages from the server. For\n * example, if your app has a draw loop, you could place a call to this\n * function within that draw loop.\n * @note You must call WaitForMessage() before you call this function.\n * @param client The client which will handle the RFB server messages\n * @return true if the client was able to handle the RFB server messages, false\n * otherwise\n */\nextern rfbBool HandleRFBServerMessage(rfbClient* client);\n\n/**\n * Sends a text chat message to the server.\n * @param client The client through which to send the message\n * @param text The text to send\n * @return true if the text was sent successfully, false otherwise\n */\nextern rfbBool TextChatSend(rfbClient* client, char *text);\n/**\n * Opens a text chat window on the server.\n * @param client The client through which to send the message\n * @return true if the window was opened successfully, false otherwise\n */\nextern rfbBool TextChatOpen(rfbClient* client);\n/**\n * Closes the text chat window on the server.\n * @param client The client through which to send the message\n * @return true if the window was closed successfully, false otherwise\n */\nextern rfbBool TextChatClose(rfbClient* client);\nextern rfbBool TextChatFinish(rfbClient* client);\nextern rfbBool PermitServerInput(rfbClient* client, int enabled);\nextern rfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code);\n\nextern void PrintPixelFormat(rfbPixelFormat *format);\n\nextern rfbBool SupportsClient2Server(rfbClient* client, int messageType);\nextern rfbBool SupportsServer2Client(rfbClient* client, int messageType);\n\n/* client data */\n\n/**\n * Associates a client data tag with the given pointer. LibVNCClient has\n * several events to which you can associate your own handlers. These handlers\n * have the client structure as one of their parameters. Sometimes, you may want\n * to make data from elsewhere in your application available to these handlers\n * without using a global variable. To do this, you call\n * rfbClientSetClientData() and associate the data with a tag. Then, your\n * handler can call rfbClientGetClientData() and get the a pointer to the data\n * associated with that tag.\n * @param client The client in which to set the client data\n * @param tag A unique tag which identifies the data\n * @param data A pointer to the data to associate with the tag\n */\nvoid rfbClientSetClientData(rfbClient* client, void* tag, void* data);\n/**\n * Returns a pointer to the client data associated with the given tag. See the\n * the documentation for rfbClientSetClientData() for a discussion of how you\n * can use client data.\n * @param client The client from which to get the client data\n * @param tag The tag which identifies the client data\n * @return a pointer to the client data\n */\nvoid* rfbClientGetClientData(rfbClient* client, void* tag);\n\n/* protocol extensions */\n\ntypedef struct _rfbClientProtocolExtension {\n\tint* encodings;\n\t/** returns TRUE if the encoding was handled */\n\trfbBool (*handleEncoding)(rfbClient* cl,\n\t\trfbFramebufferUpdateRectHeader* rect);\n\t/** returns TRUE if it handled the message */\n\trfbBool (*handleMessage)(rfbClient* cl,\n\t\t rfbServerToClientMsg* message);\n\tstruct _rfbClientProtocolExtension* next;\n\tuint32_t const* securityTypes;\n\t/** returns TRUE if it handled the authentication */\n\trfbBool (*handleAuthentication)(rfbClient* cl, uint32_t authScheme);\n} rfbClientProtocolExtension;\n\nvoid rfbClientRegisterExtension(rfbClientProtocolExtension* e);\n\n/* sockets.c */\n\nextern rfbBool errorMessageOnReadFailure;\n\nextern rfbBool ReadFromRFBServer(rfbClient* client, char *out, unsigned int n);\nextern rfbBool WriteToRFBServer(rfbClient* client, const char *buf, unsigned int n);\nextern int FindFreeTcpPort(void);\nextern rfbSocket ListenAtTcpPort(int port);\nextern rfbSocket ListenAtTcpPortAndAddress(int port, const char *address);\n/**\n   Tries to connect to an IPv4 host.\n   @param host Binary IPv4 address\n   @param port Port\n   @return A blocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddr(unsigned int host, int port);\n/**\n   Tries to connect to an IPv4 or IPv6 host.\n   @param hostname A hostname or IP address\n   @param port Port\n   @return A blocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddr6(const char *hostname, int port);\n/**\n   Tries to connect to a Unix socket.\n   @param sockFile Path of the socket file\n   @return A blocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToUnixSock(const char *sockFile);\n/**\n   Tries to connect to an IPv4 host using the given timeout value.\n   @param host Binary IPv4 address\n   @param port Port\n   @param timeout The time in seconds to wait for a connection\n   @return A nonblocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddrWithTimeout(unsigned int host, int port, unsigned int timeout);\n/**\n   Tries to connect to an IPv4 or IPv6 host using the given timeout value.\n   @param hostname A hostname or IP address\n   @param port Port\n   @param timeout The time in seconds to wait for a connection\n   @return A nonblocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddr6WithTimeout(const char *hostname, int port, unsigned int timeout);\n/**\n   Tries to connect to a Unix socket using the given timeout value.\n   @param sockFile Path of the socket file\n   @param timeout The time in seconds to wait for a connection\n   @return A nonblocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToUnixSockWithTimeout(const char *sockFile, unsigned int timeout);\nextern rfbSocket AcceptTcpConnection(rfbSocket listenSock);\nextern rfbBool SetNonBlocking(rfbSocket sock);\nextern rfbBool SetBlocking(rfbSocket sock);\nextern rfbBool SetDSCP(rfbSocket sock, int dscp);\n\nextern rfbBool StringToIPAddr(const char *str, unsigned int *addr);\nextern rfbBool SameMachine(rfbSocket sock);\n/**\n * Waits for an RFB message to arrive from the server. Before handling a message\n * with HandleRFBServerMessage(), you must wait for your client to receive one.\n * This function blocks until a message is received. You may specify a timeout\n * in microseconds. Once this number of microseconds have elapsed, the function\n * will return.\n * @param client The client to cause to wait until a message is received\n * @param usecs The timeout in microseconds\n * @return the return value of the underlying select() call\n */\nextern int WaitForMessage(rfbClient* client,unsigned int usecs);\n\n/* vncviewer.c */\n/**\n * Allocates and returns a pointer to an rfbClient structure. This will probably\n * be the first LibVNCClient function your client code calls. Most libVNCClient\n * functions operate on an rfbClient structure, and this function allocates\n * memory for that structure. When you're done with the rfbClient structure\n * pointer this function returns, you should free the memory rfbGetClient()\n * allocated by calling rfbClientCleanup().\n *\n * A pixel is one dot on the screen. The number of bytes in a pixel will depend\n * on the number of samples in that pixel and the number of bits in each sample.\n * A sample represents one of the primary colors in a color model. The RGB\n * color model uses red, green, and blue samples respectively. Suppose you\n * wanted to use 16-bit RGB color: You would have three samples per pixel (one\n * for each primary color), five bits per sample (the quotient of 16 RGB bits\n * divided by three samples), and two bytes per pixel (the smallest multiple of\n * eight bits in which the 16-bit pixel will fit). If you wanted 32-bit RGB\n * color, you would have three samples per pixel again, eight bits per sample\n * (since that's how 32-bit color is defined), and four bytes per pixel (the\n * smallest multiple of eight bits in which the 32-bit pixel will fit.\n * @param bitsPerSample The number of bits in a sample\n * @param samplesPerPixel The number of samples in a pixel\n * @param bytesPerPixel The number of bytes in a pixel\n * @return a pointer to the allocated rfbClient structure\n */\nrfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,int bytesPerPixel);\n/**\n * Initializes the client. The format is {PROGRAM_NAME, [OPTIONS]..., HOST}. This\n * function does not initialize the program name if the rfbClient's program\n * name is set already. The options are as follows:\n * <table>\n * <tr><th>Option</th><th>Description</th></tr>\n * <tr><td>-listen</td><td>Listen for incoming connections.</td></tr>\n * <tr><td>-listennofork</td><td>Listen for incoming connections without forking.\n * </td></tr>\n * <tr><td>-play</td><td>Set this client to replay a previously recorded session.</td></tr>\n * <tr><td>-encodings</td><td>Set the encodings to use. The next item in the\n * argv array is the encodings string, consisting of comma separated encodings like 'tight,ultra,raw'.</td></tr>\n * <tr><td>-compress</td><td>Set the compression level. The next item in the\n * argv array is the compression level as an integer. Ranges from 0 (lowest) to 9 (highest).\n * </td></tr>\n * <tr><td>-scale</td><td>Set the scaling level. The next item in the\n * argv array is the scaling level as an integer. The screen will be scaled down by this factor.</td></tr>\n * <tr><td>-qosdscp</td><td>Set the Quality of Service Differentiated Services\n * Code Point (QoS DSCP). The next item in the argv array is the code point as\n * an integer.</td></tr>\n * <tr><td>-repeaterdest</td><td>Set a VNC repeater address. The next item in the argv array is\n * the repeater's address as a string.</td></tr>\n * </table>\n *\n * The host may include a port number (delimited by a ':').\n * @param client The client to initialize\n * @param argc The number of arguments to the initializer\n * @param argv The arguments to the initializer as an array of NULL terminated\n * strings\n * @return true if the client was initialized successfully, false otherwise.\n */\nrfbBool rfbInitClient(rfbClient* client,int* argc,char** argv);\n/**\n * Cleans up the client structure and releases the memory allocated for it. You\n * should call this when you're done with the rfbClient structure that you\n * allocated with rfbGetClient().\n * @note rfbClientCleanup() does not touch client->frameBuffer.\n * @param client The client to clean up\n */\nvoid rfbClientCleanup(rfbClient* client);\n\n#if(defined __cplusplus)\n}\n#endif\n\n/**\n * @}\n */\n\n/**\n @page libvncclient_doc LibVNCClient Documentation\n @section example_code Example Code\n See SDLvncviewer.c for a rather complete client example.\n*/\n\n#endif\n"], "fixing_code": ["/*\n *  Copyright (C) 2011-2012 Christian Beier <dontmind@freeshell.org>\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * sockets.c - functions to deal with sockets.\n */\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#ifdef __linux__\n/* Setting this on other systems hides definitions such as INADDR_LOOPBACK.\n * The check should be for __GLIBC__ in fact. */\n# define _POSIX_SOURCE\n#endif\n#endif\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <assert.h>\n#include <rfb/rfbclient.h>\n#include \"sockets.h\"\n#include \"tls.h\"\n#include \"sasl.h\"\n\nvoid PrintInHex(char *buf, int len);\n\nrfbBool errorMessageOnReadFailure = TRUE;\n\n/*\n * ReadFromRFBServer is called whenever we want to read some data from the RFB\n * server.  It is non-trivial for two reasons:\n *\n * 1. For efficiency it performs some intelligent buffering, avoiding invoking\n *    the read() system call too often.  For small chunks of data, it simply\n *    copies the data out of an internal buffer.  For large amounts of data it\n *    reads directly into the buffer provided by the caller.\n *\n * 2. Whenever read() would block, it invokes the Xt event dispatching\n *    mechanism to process X events.  In fact, this is the only place these\n *    events are processed, as there is no XtAppMainLoop in the program.\n */\n\nrfbBool\nReadFromRFBServer(rfbClient* client, char *out, unsigned int n)\n{\n  const int USECS_WAIT_PER_RETRY = 100000;\n  int retries = 0;\n#undef DEBUG_READ_EXACT\n#ifdef DEBUG_READ_EXACT\n\tchar* oout=out;\n\tunsigned int nn=n;\n\trfbClientLog(\"ReadFromRFBServer %d bytes\\n\",n);\n#endif\n\n  /* Handle attempts to write to NULL out buffer that might occur\n     when an outside malloc() fails. For instance, memcpy() to NULL\n     results in undefined behaviour and probably memory corruption.*/\n  if(!out)\n    return FALSE;\n\n  if (client->serverPort==-1) {\n    /* vncrec playing */\n    rfbVNCRec* rec = client->vncRec;\n    struct timeval tv;\n\n    if (rec->readTimestamp) {\n      rec->readTimestamp = FALSE;\n      if (!fread(&tv,sizeof(struct timeval),1,rec->file))\n        return FALSE;\n\n      tv.tv_sec = rfbClientSwap32IfLE (tv.tv_sec);\n      tv.tv_usec = rfbClientSwap32IfLE (tv.tv_usec);\n\n      if (rec->tv.tv_sec!=0 && !rec->doNotSleep) {\n        struct timeval diff;\n        diff.tv_sec = tv.tv_sec - rec->tv.tv_sec;\n        diff.tv_usec = tv.tv_usec - rec->tv.tv_usec;\n        if(diff.tv_usec<0) {\n\t  diff.tv_sec--;\n\t  diff.tv_usec+=1000000;\n        }\n#ifndef WIN32\n        sleep (diff.tv_sec);\n        usleep (diff.tv_usec);\n#else\n\tSleep (diff.tv_sec * 1000 + diff.tv_usec/1000);\n#endif\n      }\n\n      rec->tv=tv;\n    }\n    \n    return (fread(out,1,n,rec->file) != n ? FALSE : TRUE);\n  }\n  \n  if (n <= client->buffered) {\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n#ifdef DEBUG_READ_EXACT\n    goto hexdump;\n#endif\n    return TRUE;\n  }\n\n  memcpy(out, client->bufoutptr, client->buffered);\n\n  out += client->buffered;\n  n -= client->buffered;\n\n  client->bufoutptr = client->buf;\n  client->buffered = 0;\n\n  if (n <= RFB_BUF_SIZE) {\n\n    while (client->buffered < n) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n      else {\n#endif /* LIBVNCSERVER_HAVE_SASL */\n        i = read(client->sock, client->buf + client->buffered, RFB_BUF_SIZE - client->buffered);\n#ifdef WIN32\n\tif (i < 0) errno=WSAGetLastError();\n#endif\n#ifdef LIBVNCSERVER_HAVE_SASL\n      }\n#endif\n  \n      if (i <= 0) {\n\tif (i < 0) {\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t      rfbClientLog(\"Connection timed out\\n\");\n\t      return FALSE;\n\t    }\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%d: %s)\\n\",errno,strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      client->buffered += i;\n    }\n\n    memcpy(out, client->bufoutptr, n);\n    client->bufoutptr += n;\n    client->buffered -= n;\n\n  } else {\n\n    while (n > 0) {\n      int i;\n      if (client->tlsSession)\n        i = ReadFromTLS(client, out, n);\n      else\n#ifdef LIBVNCSERVER_HAVE_SASL\n      if (client->saslconn)\n        i = ReadFromSASL(client, out, n);\n      else\n#endif\n        i = read(client->sock, out, n);\n\n      if (i <= 0) {\n\tif (i < 0) {\n#ifdef WIN32\n\t  errno=WSAGetLastError();\n#endif\n\t  if (errno == EWOULDBLOCK || errno == EAGAIN) {\n\t    if (client->readTimeout > 0 &&\n\t\t++retries > (client->readTimeout * 1000 * 1000 / USECS_WAIT_PER_RETRY))\n\t    {\n\t\trfbClientLog(\"Connection timed out\\n\");\n\t\treturn FALSE;\n\t    }\n\t    /* TODO:\n\t       ProcessXtEvents();\n\t    */\n\t    WaitForMessage(client, USECS_WAIT_PER_RETRY);\n\t    i = 0;\n\t  } else {\n\t    rfbClientErr(\"read (%s)\\n\",strerror(errno));\n\t    return FALSE;\n\t  }\n\t} else {\n\t  if (errorMessageOnReadFailure) {\n\t    rfbClientLog(\"VNC server closed connection\\n\");\n\t  }\n\t  return FALSE;\n\t}\n      }\n      out += i;\n      n -= i;\n    }\n  }\n\n#ifdef DEBUG_READ_EXACT\nhexdump:\n  { unsigned int ii;\n    for(ii=0;ii<nn;ii++)\n      fprintf(stderr,\"%02x \",(unsigned char)oout[ii]);\n    fprintf(stderr,\"\\n\");\n  }\n#endif\n\n  return TRUE;\n}\n\n\n/*\n * Write an exact number of bytes, and don't return until you've sent them.\n */\n\nrfbBool\nWriteToRFBServer(rfbClient* client, const char *buf, unsigned int n)\n{\n  fd_set fds;\n  int i = 0;\n  int j;\n  const char *obuf = buf;\n#ifdef LIBVNCSERVER_HAVE_SASL\n  const char *output;\n  unsigned int outputlen;\n  int err;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  if (client->serverPort==-1)\n    return TRUE; /* vncrec playing */\n\n  if (client->tlsSession) {\n    /* WriteToTLS() will guarantee either everything is written, or error/eof returns */\n    i = WriteToTLS(client, buf, n);\n    if (i <= 0) return FALSE;\n\n    return TRUE;\n  }\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslconn) {\n    err = sasl_encode(client->saslconn,\n                      buf, n,\n                      &output, &outputlen);\n    if (err != SASL_OK) {\n      rfbClientLog(\"Failed to encode SASL data %s\",\n                   sasl_errstring(err, NULL, NULL));\n      return FALSE;\n    }\n    obuf = output;\n    n = outputlen;\n  }\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  while (i < n) {\n    j = write(client->sock, obuf + i, (n - i));\n    if (j <= 0) {\n      if (j < 0) {\n#ifdef WIN32\n\t errno=WSAGetLastError();\n#endif\n\tif (errno == EWOULDBLOCK ||\n#ifdef LIBVNCSERVER_ENOENT_WORKAROUND\n\t\terrno == ENOENT ||\n#endif\n\t\terrno == EAGAIN) {\n\t  FD_ZERO(&fds);\n\t  FD_SET(client->sock,&fds);\n\n\t  if (select(client->sock+1, NULL, &fds, NULL, NULL) <= 0) {\n\t    rfbClientErr(\"select\\n\");\n\t    return FALSE;\n\t  }\n\t  j = 0;\n\t} else {\n\t  rfbClientErr(\"write\\n\");\n\t  return FALSE;\n\t}\n      } else {\n\trfbClientLog(\"write failed\\n\");\n\treturn FALSE;\n      }\n    }\n    i += j;\n  }\n  return TRUE;\n}\n\n\nstatic rfbBool WaitForConnected(int socket, unsigned int secs)\n{\n  fd_set writefds;\n  fd_set exceptfds;\n  struct timeval timeout;\n\n  timeout.tv_sec=secs;\n  timeout.tv_usec=0;\n\n  FD_ZERO(&writefds);\n  FD_SET(socket, &writefds);\n  FD_ZERO(&exceptfds);\n  FD_SET(socket, &exceptfds);\n  if (select(socket+1, NULL, &writefds, &exceptfds, &timeout)==1) {\n#ifdef WIN32\n    if (FD_ISSET(socket, &exceptfds))\n      return FALSE;\n#else\n    int so_error;\n    socklen_t len = sizeof so_error;\n    getsockopt(socket, SOL_SOCKET, SO_ERROR, &so_error, &len);\n    if (so_error!=0)\n      return FALSE;\n#endif\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nrfbSocket\nConnectClientToTcpAddr(unsigned int host, int port)\n{\n  rfbSocket sock = ConnectClientToTcpAddrWithTimeout(host, port, DEFAULT_CONNECT_TIMEOUT);\n  /* put socket back into blocking mode for compatibility reasons */\n  if (sock != RFB_INVALID_SOCKET) {\n    SetBlocking(sock);\n  }\n  return sock;\n}\n\nrfbSocket\nConnectClientToTcpAddrWithTimeout(unsigned int host, int port, unsigned int timeout)\n{\n  rfbSocket sock;\n  struct sockaddr_in addr;\n  int one = 1;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  addr.sin_addr.s_addr = host;\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientErr(\"ConnectToTcpAddr: socket (%s)\\n\",strerror(errno));\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (!SetNonBlocking(sock))\n    return FALSE;\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    if (!((errno == EWOULDBLOCK || errno == EINPROGRESS) && WaitForConnected(sock, timeout))) {\n      rfbClientErr(\"ConnectToTcpAddr: connect\\n\");\n      rfbCloseSocket(sock);\n      return RFB_INVALID_SOCKET;\n    }\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\nrfbSocket\nConnectClientToTcpAddr6(const char *hostname, int port)\n{\n  rfbSocket sock = ConnectClientToTcpAddr6WithTimeout(hostname, port, DEFAULT_CONNECT_TIMEOUT);\n  /* put socket back into blocking mode for compatibility reasons */\n  if (sock != RFB_INVALID_SOCKET) {\n    SetBlocking(sock);\n  }\n  return sock;\n}\n\nrfbSocket\nConnectClientToTcpAddr6WithTimeout(const char *hostname, int port, unsigned int timeout)\n{\n#ifdef LIBVNCSERVER_IPv6\n  rfbSocket sock;\n  int n;\n  struct addrinfo hints, *res, *ressave;\n  char port_s[10];\n  int one = 1;\n\n  snprintf(port_s, 10, \"%d\", port);\n  memset(&hints, 0, sizeof(struct addrinfo));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  if ((n = getaddrinfo(strcmp(hostname,\"\") == 0 ? \"localhost\": hostname, port_s, &hints, &res)))\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: getaddrinfo (%s)\\n\", gai_strerror(n));\n    return RFB_INVALID_SOCKET;\n  }\n\n  ressave = res;\n  sock = RFB_INVALID_SOCKET;\n  while (res)\n  {\n    sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n    if (sock != RFB_INVALID_SOCKET)\n    {\n      if (SetNonBlocking(sock)) {\n        if (connect(sock, res->ai_addr, res->ai_addrlen) == 0) {\n          break;\n        } else {\n#ifdef WIN32\n          errno=WSAGetLastError();\n#endif\n          if ((errno == EWOULDBLOCK || errno == EINPROGRESS) && WaitForConnected(sock, timeout))\n            break;\n          rfbCloseSocket(sock);\n          sock = RFB_INVALID_SOCKET;\n        }\n      } else {\n        rfbCloseSocket(sock);\n        sock = RFB_INVALID_SOCKET;\n      }\n    }\n    res = res->ai_next;\n  }\n  freeaddrinfo(ressave);\n\n  if (sock == RFB_INVALID_SOCKET)\n  {\n    rfbClientErr(\"ConnectClientToTcpAddr6: connect\\n\");\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ConnectToTcpAddr: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n\n#else\n\n  rfbClientErr(\"ConnectClientToTcpAddr6: IPv6 disabled\\n\");\n  return RFB_INVALID_SOCKET;\n\n#endif\n}\n\nrfbSocket\nConnectClientToUnixSock(const char *sockFile)\n{\n  rfbSocket sock = ConnectClientToUnixSockWithTimeout(sockFile, DEFAULT_CONNECT_TIMEOUT);\n  /* put socket back into blocking mode for compatibility reasons */\n  if (sock != RFB_INVALID_SOCKET) {\n    SetBlocking(sock);\n  }\n  return sock;\n}\n\nrfbSocket\nConnectClientToUnixSockWithTimeout(const char *sockFile, unsigned int timeout)\n{\n#ifdef WIN32\n  rfbClientErr(\"Windows doesn't support UNIX sockets\\n\");\n  return RFB_INVALID_SOCKET;\n#else\n  rfbSocket sock;\n  struct sockaddr_un addr;\n  addr.sun_family = AF_UNIX;\n  if(strlen(sockFile) + 1 > sizeof(addr.sun_path)) {\n      rfbClientErr(\"ConnectToUnixSock: socket file name too long\\n\");\n      return RFB_INVALID_SOCKET;\n  }\n  strcpy(addr.sun_path, sockFile);\n\n  sock = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\"ConnectToUnixSock: socket (%s)\\n\",strerror(errno));\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (!SetNonBlocking(sock))\n    return RFB_INVALID_SOCKET;\n\n  if (connect(sock, (struct sockaddr *)&addr, sizeof(addr.sun_family) + strlen(addr.sun_path)) < 0 &&\n      !(errno == EINPROGRESS && WaitForConnected(sock, timeout))) {\n    rfbClientErr(\"ConnectToUnixSock: connect\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n#endif\n}\n\n\n\n/*\n * FindFreeTcpPort tries to find unused TCP port in the range\n * (TUNNEL_PORT_OFFSET, TUNNEL_PORT_OFFSET + 99]. Returns 0 on failure.\n */\n\nint\nFindFreeTcpPort(void)\n{\n  rfbSocket sock;\n  int port;\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_addr.s_addr = htonl(INADDR_ANY);\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\": FindFreeTcpPort: socket\\n\");\n    return 0;\n  }\n\n  for (port = TUNNEL_PORT_OFFSET + 99; port > TUNNEL_PORT_OFFSET; port--) {\n    addr.sin_port = htons((unsigned short)port);\n    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == 0) {\n      rfbCloseSocket(sock);\n      return port;\n    }\n  }\n\n  rfbCloseSocket(sock);\n  return 0;\n}\n\n\n/*\n * ListenAtTcpPort starts listening at the given TCP port.\n */\n\nrfbSocket\nListenAtTcpPort(int port)\n{\n  return ListenAtTcpPortAndAddress(port, NULL);\n}\n\n\n\n/*\n * ListenAtTcpPortAndAddress starts listening at the given TCP port on\n * the given IP address\n */\n\nrfbSocket\nListenAtTcpPortAndAddress(int port, const char *address)\n{\n  rfbSocket sock = RFB_INVALID_SOCKET;\n  int one = 1;\n#ifndef LIBVNCSERVER_IPv6\n  struct sockaddr_in addr;\n\n  addr.sin_family = AF_INET;\n  addr.sin_port = htons(port);\n  if (address) {\n    addr.sin_addr.s_addr = inet_addr(address);\n  } else {\n    addr.sin_addr.s_addr = htonl(INADDR_ANY);\n  }\n\n  sock = socket(AF_INET, SOCK_STREAM, 0);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\"ListenAtTcpPort: socket\\n\");\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,\n\t\t (const char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: bind\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n#else\n  int rv;\n  struct addrinfo hints, *servinfo, *p;\n  char port_str[8];\n\n  snprintf(port_str, 8, \"%d\", port);\n\n  memset(&hints, 0, sizeof(hints));\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE; /* fill in wildcard address if address == NULL */\n\n  if ((rv = getaddrinfo(address, port_str, &hints, &servinfo)) != 0) {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in getaddrinfo: %s\\n\", gai_strerror(rv));\n    return RFB_INVALID_SOCKET;\n  }\n\n  /* loop through all the results and bind to the first we can */\n  for(p = servinfo; p != NULL; p = p->ai_next) {\n    if ((sock = socket(p->ai_family, p->ai_socktype, p->ai_protocol)) == RFB_INVALID_SOCKET) {\n      continue;\n    }\n\n#ifdef IPV6_V6ONLY\n    /* we have separate IPv4 and IPv6 sockets since some OS's do not support dual binding */\n    if (p->ai_family == AF_INET6 && setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt IPV6_V6ONLY: %s\\n\", strerror(errno));\n      rfbCloseSocket(sock);\n      freeaddrinfo(servinfo);\n      return RFB_INVALID_SOCKET;\n    }\n#endif\n\n    if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *)&one, sizeof(one)) < 0) {\n      rfbClientErr(\"ListenAtTcpPortAndAddress: error in setsockopt SO_REUSEADDR: %s\\n\", strerror(errno));\n      rfbCloseSocket(sock);\n      freeaddrinfo(servinfo);\n      return RFB_INVALID_SOCKET;\n    }\n\n    if (bind(sock, p->ai_addr, p->ai_addrlen) < 0) {\n      rfbCloseSocket(sock);\n      continue;\n    }\n\n    break;\n  }\n\n  if (p == NULL)  {\n    rfbClientErr(\"ListenAtTcpPortAndAddress: error in bind: %s\\n\", strerror(errno));\n    return RFB_INVALID_SOCKET;\n  }\n\n  /* all done with this structure now */\n  freeaddrinfo(servinfo);\n#endif\n\n  if (listen(sock, 5) < 0) {\n    rfbClientErr(\"ListenAtTcpPort: listen\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\n\n/*\n * AcceptTcpConnection accepts a TCP connection.\n */\n\nrfbSocket\nAcceptTcpConnection(rfbSocket listenSock)\n{\n  rfbSocket sock;\n  struct sockaddr_in addr;\n  socklen_t addrlen = sizeof(addr);\n  int one = 1;\n\n  sock = accept(listenSock, (struct sockaddr *) &addr, &addrlen);\n  if (sock == RFB_INVALID_SOCKET) {\n    rfbClientErr(\"AcceptTcpConnection: accept\\n\");\n    return RFB_INVALID_SOCKET;\n  }\n\n  if (setsockopt(sock, IPPROTO_TCP, TCP_NODELAY,\n\t\t (char *)&one, sizeof(one)) < 0) {\n    rfbClientErr(\"AcceptTcpConnection: setsockopt\\n\");\n    rfbCloseSocket(sock);\n    return RFB_INVALID_SOCKET;\n  }\n\n  return sock;\n}\n\n\n/*\n * SetNonBlocking sets a socket into non-blocking mode.\n */\n\nrfbBool\nSetNonBlocking(rfbSocket sock)\n{\n#ifdef WIN32\n  unsigned long block=1;\n  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {\n    errno=WSAGetLastError();\n#else\n  int flags = fcntl(sock, F_GETFL);\n  if(flags < 0 || fcntl(sock, F_SETFL, flags | O_NONBLOCK) < 0) {\n#endif\n    rfbClientErr(\"Setting socket to non-blocking failed: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n  return TRUE;\n}\n\n\nrfbBool SetBlocking(rfbSocket sock)\n{\n#ifdef WIN32\n  unsigned long block=0;\n  if(ioctlsocket(sock, FIONBIO, &block) == SOCKET_ERROR) {\n    errno=WSAGetLastError();\n#else\n  int flags = fcntl(sock, F_GETFL);\n  if(flags < 0 || fcntl(sock, F_SETFL, flags & ~O_NONBLOCK) < 0) {\n#endif\n    rfbClientErr(\"Setting socket to blocking failed: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n  return TRUE;\n}\n\n\n/*\n * SetDSCP sets a socket's IP QoS parameters aka Differentiated Services Code Point field\n */\n\nrfbBool\nSetDSCP(rfbSocket sock, int dscp)\n{\n#ifdef WIN32\n  rfbClientErr(\"Setting of QoS IP DSCP not implemented for Windows\\n\");\n  return TRUE;\n#else\n  int level, cmd;\n  struct sockaddr addr;\n  socklen_t addrlen = sizeof(addr);\n\n  if(getsockname(sock, &addr, &addrlen) != 0) {\n    rfbClientErr(\"Setting socket QoS failed while getting socket address: %s\\n\",strerror(errno));\n    return FALSE;\n  }\n\n  switch(addr.sa_family)\n    {\n#if defined LIBVNCSERVER_IPv6 && defined IPV6_TCLASS\n    case AF_INET6:\n      level = IPPROTO_IPV6;\n      cmd = IPV6_TCLASS;\n      break;\n#endif\n    case AF_INET:\n      level = IPPROTO_IP;\n      cmd = IP_TOS;\n      break;\n    default:\n      rfbClientErr(\"Setting socket QoS failed: Not bound to IP address\");\n      return FALSE;\n    }\n\n  if(setsockopt(sock, level, cmd, (void*)&dscp, sizeof(dscp)) != 0) {\n    rfbClientErr(\"Setting socket QoS failed: %s\\n\", strerror(errno));\n    return FALSE;\n  }\n\n  return TRUE;\n#endif\n}\n\n\n\n/*\n * StringToIPAddr - convert a host string to an IP address.\n */\n\nrfbBool\nStringToIPAddr(const char *str, unsigned int *addr)\n{\n  struct hostent *hp;\n\n  if (strcmp(str,\"\") == 0) {\n    *addr = htonl(INADDR_LOOPBACK); /* local */\n    return TRUE;\n  }\n\n  *addr = inet_addr(str);\n\n  if (*addr != -1)\n    return TRUE;\n\n  hp = gethostbyname(str);\n\n  if (hp) {\n    *addr = *(unsigned int *)hp->h_addr;\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\n/*\n * Test if the other end of a socket is on the same machine.\n */\n\nrfbBool\nSameMachine(rfbSocket sock)\n{\n  struct sockaddr_in peeraddr, myaddr;\n  socklen_t addrlen = sizeof(struct sockaddr_in);\n\n  getpeername(sock, (struct sockaddr *)&peeraddr, &addrlen);\n  getsockname(sock, (struct sockaddr *)&myaddr, &addrlen);\n\n  return (peeraddr.sin_addr.s_addr == myaddr.sin_addr.s_addr);\n}\n\n\n/*\n * Print out the contents of a packet for debugging.\n */\n\nvoid\nPrintInHex(char *buf, int len)\n{\n  int i, j;\n  char c, str[17];\n\n  str[16] = 0;\n\n  rfbClientLog(\"ReadExact: \");\n\n  for (i = 0; i < len; i++)\n    {\n      if ((i % 16 == 0) && (i != 0)) {\n\trfbClientLog(\"           \");\n      }\n      c = buf[i];\n      str[i % 16] = (((c > 31) && (c < 127)) ? c : '.');\n      rfbClientLog(\"%02x \",(unsigned char)c);\n      if ((i % 4) == 3)\n\trfbClientLog(\" \");\n      if ((i % 16) == 15)\n\t{\n\t  rfbClientLog(\"%s\\n\",str);\n\t}\n    }\n  if ((i % 16) != 0)\n    {\n      for (j = i % 16; j < 16; j++)\n\t{\n\t  rfbClientLog(\"   \");\n\t  if ((j % 4) == 3) rfbClientLog(\" \");\n\t}\n      str[i % 16] = 0;\n      rfbClientLog(\"%s\\n\",str);\n    }\n\n  fflush(stderr);\n}\n\nint WaitForMessage(rfbClient* client,unsigned int usecs)\n{\n  fd_set fds;\n  struct timeval timeout;\n  int num;\n\n  if (client->serverPort==-1)\n    /* playing back vncrec file */\n    return 1;\n  \n  timeout.tv_sec=(usecs/1000000);\n  timeout.tv_usec=(usecs%1000000);\n\n  FD_ZERO(&fds);\n  FD_SET(client->sock,&fds);\n\n  num=select(client->sock+1, &fds, NULL, NULL, &timeout);\n  if(num<0) {\n#ifdef WIN32\n    errno=WSAGetLastError();\n#endif\n    rfbClientLog(\"Waiting for message failed: %d (%s)\\n\",errno,strerror(errno));\n  }\n\n  return num;\n}\n\n\n", "/*\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/*\n * vncviewer.c - the Xt-based VNC viewer.\n */\n\n#ifdef WIN32\n#include <winsock2.h>\n#endif\n\n#ifdef _MSC_VER\n#define strdup _strdup /* Prevent POSIX deprecation warnings */\n#endif\n\n#ifdef __STRICT_ANSI__\n#define _BSD_SOURCE\n#define _POSIX_SOURCE\n#endif\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <rfb/rfbclient.h>\n#include \"tls.h\"\n\nstatic void Dummy(rfbClient* client) {\n}\nstatic rfbBool DummyPoint(rfbClient* client, int x, int y) {\n  return TRUE;\n}\nstatic void DummyRect(rfbClient* client, int x, int y, int w, int h) {\n}\n\n#ifdef WIN32\nstatic char* NoPassword(rfbClient* client) {\n  return strdup(\"\");\n}\n#else\n#include <stdio.h>\n#include <termios.h>\n#endif\n\nstatic char* ReadPassword(rfbClient* client) {\n\tint i;\n\tchar* p=calloc(1,9);\n#ifndef WIN32\n\tstruct termios save,noecho;\n\tif(tcgetattr(fileno(stdin),&save)!=0) return p;\n\tnoecho=save; noecho.c_lflag &= ~ECHO;\n\tif(tcsetattr(fileno(stdin),TCSAFLUSH,&noecho)!=0) return p;\n#endif\n\tfprintf(stderr,\"Password: \");\n\ti=0;\n\twhile(1) {\n\t\tint c=fgetc(stdin);\n\t\tif(c=='\\n')\n\t\t\tbreak;\n\t\tif(i<8) {\n\t\t\tp[i]=c;\n\t\t\ti++;\n\t\t\tp[i]=0;\n\t\t}\n\t}\n#ifndef WIN32\n\ttcsetattr(fileno(stdin),TCSAFLUSH,&save);\n#endif\n\treturn p;\n}\nstatic rfbBool MallocFrameBuffer(rfbClient* client) {\n  uint64_t allocSize;\n\n  if(client->frameBuffer)\n    free(client->frameBuffer);\n\n  /* SECURITY: promote 'width' into uint64_t so that the multiplication does not overflow\n     'width' and 'height' are 16-bit integers per RFB protocol design\n     SIZE_MAX is the maximum value that can fit into size_t\n  */\n  allocSize = (uint64_t)client->width * client->height * client->format.bitsPerPixel/8;\n\n  if (allocSize >= SIZE_MAX) {\n    rfbClientErr(\"CRITICAL: cannot allocate frameBuffer, requested size is too large\\n\");\n    return FALSE;\n  }\n\n  client->frameBuffer=malloc( (size_t)allocSize );\n\n  if (client->frameBuffer == NULL)\n    rfbClientErr(\"CRITICAL: frameBuffer allocation failed, requested size too large or not enough memory?\\n\");\n\n  return client->frameBuffer?TRUE:FALSE;\n}\n\n/* messages */\n\nstatic rfbBool CheckRect(rfbClient* client, int x, int y, int w, int h) {\n  return x + w <= client->width && y + h <= client->height;\n}\n\nstatic void FillRectangle(rfbClient* client, int x, int y, int w, int h, uint32_t colour) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define FILL_RECT(BPP) \\\n    for(j=y*client->width;j<(y+h)*client->width;j+=client->width) \\\n      for(i=x;i<x+w;i++) \\\n\t((uint##BPP##_t*)client->frameBuffer)[j+i]=colour;\n\n  switch(client->format.bitsPerPixel) {\n  case  8: FILL_RECT(8);  break;\n  case 16: FILL_RECT(16); break;\n  case 32: FILL_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void CopyRectangle(rfbClient* client, const uint8_t* buffer, int x, int y, int w, int h) {\n  int j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, x, y, w, h)) {\n    rfbClientLog(\"Rect out of bounds: %dx%d at (%d, %d)\\n\", x, y, w, h);\n    return;\n  }\n\n#define COPY_RECT(BPP) \\\n  { \\\n    int rs = w * BPP / 8, rs2 = client->width * BPP / 8; \\\n    for (j = ((x * (BPP / 8)) + (y * rs2)); j < (y + h) * rs2; j += rs2) { \\\n      memcpy(client->frameBuffer + j, buffer, rs); \\\n      buffer += rs; \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT(8);  break;\n  case 16: COPY_RECT(16); break;\n  case 32: COPY_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\n/* TODO: test */\nstatic void CopyRectangleFromRectangle(rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y) {\n  int i,j;\n\n  if (client->frameBuffer == NULL) {\n      return;\n  }\n\n  if (!CheckRect(client, src_x, src_y, w, h)) {\n    rfbClientLog(\"Source rect out of bounds: %dx%d at (%d, %d)\\n\", src_x, src_y, w, h);\n    return;\n  }\n\n  if (!CheckRect(client, dest_x, dest_y, w, h)) {\n    rfbClientLog(\"Dest rect out of bounds: %dx%d at (%d, %d)\\n\", dest_x, dest_y, w, h);\n    return;\n  }\n\n#define COPY_RECT_FROM_RECT(BPP) \\\n  { \\\n    uint##BPP##_t* _buffer=((uint##BPP##_t*)client->frameBuffer)+(src_y-dest_y)*client->width+src_x-dest_x; \\\n    if (dest_y < src_y) { \\\n      for(j = dest_y*client->width; j < (dest_y+h)*client->width; j += client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } else { \\\n      for(j = (dest_y+h-1)*client->width; j >= dest_y*client->width; j-=client->width) { \\\n        if (dest_x < src_x) { \\\n          for(i = dest_x; i < dest_x+w; i++) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } else { \\\n          for(i = dest_x+w-1; i >= dest_x; i--) { \\\n            ((uint##BPP##_t*)client->frameBuffer)[j+i]=_buffer[j+i]; \\\n          } \\\n        } \\\n      } \\\n    } \\\n  }\n\n  switch(client->format.bitsPerPixel) {\n  case  8: COPY_RECT_FROM_RECT(8);  break;\n  case 16: COPY_RECT_FROM_RECT(16); break;\n  case 32: COPY_RECT_FROM_RECT(32); break;\n  default:\n    rfbClientLog(\"Unsupported bitsPerPixel: %d\\n\",client->format.bitsPerPixel);\n  }\n}\n\nstatic void initAppData(AppData* data) {\n\tdata->shareDesktop=TRUE;\n\tdata->viewOnly=FALSE;\n\tdata->encodingsString=\"tight zrle ultra copyrect hextile zlib corre rre raw\";\n\tdata->useBGR233=FALSE;\n\tdata->nColours=0;\n\tdata->forceOwnCmap=FALSE;\n\tdata->forceTrueColour=FALSE;\n\tdata->requestedDepth=0;\n\tdata->compressLevel=3;\n\tdata->qualityLevel=5;\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\tdata->enableJPEG=TRUE;\n#else\n\tdata->enableJPEG=FALSE;\n#endif\n\tdata->useRemoteCursor=FALSE;\n}\n\nrfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,\n\t\t\tint bytesPerPixel) {\n#ifdef WIN32\n    WSADATA unused;\n#endif\n  rfbClient* client=(rfbClient*)calloc(sizeof(rfbClient),1);\n  if(!client) {\n    rfbClientErr(\"Couldn't allocate client structure!\\n\");\n    return NULL;\n  }\n#ifdef WIN32\n  if((errno = WSAStartup(MAKEWORD(2,0), &unused)) != 0) {\n      rfbClientErr(\"Could not init Windows Sockets: %s\\n\", strerror(errno));\n      return NULL;\n  }\n#endif\n  initAppData(&client->appData);\n  client->endianTest = 1;\n  client->programName=\"\";\n  client->serverHost=strdup(\"\");\n  client->serverPort=5900;\n\n  client->destHost = NULL;\n  client->destPort = 5900;\n  \n  client->connectTimeout = DEFAULT_CONNECT_TIMEOUT;\n  client->readTimeout = DEFAULT_READ_TIMEOUT;\n\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n\n  /* default: use complete frame buffer */ \n  client->updateRect.x = -1;\n \n  client->frameBuffer = NULL;\n  client->outputWindow = 0;\n \n  client->format.bitsPerPixel = bytesPerPixel*8;\n  client->format.depth = bitsPerSample*samplesPerPixel;\n  client->appData.requestedDepth=client->format.depth;\n  client->format.bigEndian = *(char *)&client->endianTest?FALSE:TRUE;\n  client->format.trueColour = 1;\n\n  if (client->format.bitsPerPixel == 8) {\n    client->format.redMax = 7;\n    client->format.greenMax = 7;\n    client->format.blueMax = 3;\n    client->format.redShift = 0;\n    client->format.greenShift = 3;\n    client->format.blueShift = 6;\n  } else {\n    client->format.redMax = (1 << bitsPerSample) - 1;\n    client->format.greenMax = (1 << bitsPerSample) - 1;\n    client->format.blueMax = (1 << bitsPerSample) - 1;\n    if(!client->format.bigEndian) {\n      client->format.redShift = 0;\n      client->format.greenShift = bitsPerSample;\n      client->format.blueShift = bitsPerSample * 2;\n    } else {\n      if(client->format.bitsPerPixel==8*3) {\n\tclient->format.redShift = bitsPerSample*2;\n\tclient->format.greenShift = bitsPerSample*1;\n\tclient->format.blueShift = 0;\n      } else {\n\tclient->format.redShift = bitsPerSample*3;\n\tclient->format.greenShift = bitsPerSample*2;\n\tclient->format.blueShift = bitsPerSample;\n      }\n    }\n  }\n\n  client->bufoutptr=client->buf;\n  client->buffered=0;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n  client->raw_buffer_size = -1;\n  client->decompStreamInited = FALSE;\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  memset(client->zlibStreamActive,0,sizeof(rfbBool)*4);\n#endif\n#endif\n\n  client->HandleCursorPos = DummyPoint;\n  client->SoftCursorLockArea = DummyRect;\n  client->SoftCursorUnlockScreen = Dummy;\n  client->GotFrameBufferUpdate = DummyRect;\n  client->GotCopyRect = CopyRectangleFromRectangle;\n  client->GotFillRect = FillRectangle;\n  client->GotBitmap = CopyRectangle;\n  client->FinishedFrameBufferUpdate = NULL;\n  client->GetPassword = ReadPassword;\n  client->MallocFrameBuffer = MallocFrameBuffer;\n  client->Bell = Dummy;\n  client->CurrentKeyboardLedState = 0;\n  client->HandleKeyboardLedState = (HandleKeyboardLedStateProc)DummyPoint;\n  client->QoS_DSCP = 0;\n\n  client->authScheme = 0;\n  client->subAuthScheme = 0;\n  client->GetCredential = NULL;\n  client->tlsSession = NULL;\n  client->LockWriteToTLS = NULL;\n  client->UnlockWriteToTLS = NULL;\n  client->sock = RFB_INVALID_SOCKET;\n  client->listenSock = RFB_INVALID_SOCKET;\n  client->listenAddress = NULL;\n  client->listen6Sock = RFB_INVALID_SOCKET;\n  client->listen6Address = NULL;\n  client->clientAuthSchemes = NULL;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  client->GetSASLMechanism = NULL;\n  client->GetUser = NULL;\n  client->saslSecret = NULL;\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n  return client;\n}\n\nstatic rfbBool rfbInitConnection(rfbClient* client)\n{\n  /* Unless we accepted an incoming connection, make a TCP connection to the\n     given VNC server */\n\n  if (!client->listenSpecified) {\n    if (!client->serverHost)\n      return FALSE;\n    if (client->destHost) {\n      if (!ConnectToRFBRepeater(client,client->serverHost,client->serverPort,client->destHost,client->destPort))\n        return FALSE;\n    } else {\n      if (!ConnectToRFBServer(client,client->serverHost,client->serverPort))\n        return FALSE;\n    }\n  }\n\n  /* Initialise the VNC connection, including reading the password */\n\n  if (!InitialiseRFBConnection(client))\n    return FALSE;\n\n  client->width=client->si.framebufferWidth;\n  client->height=client->si.framebufferHeight;\n  if (!client->MallocFrameBuffer(client))\n    return FALSE;\n\n  if (!SetFormatAndEncodings(client))\n    return FALSE;\n\n  if (client->updateRect.x < 0) {\n    client->updateRect.x = client->updateRect.y = 0;\n    client->updateRect.w = client->width;\n    client->updateRect.h = client->height;\n  }\n\n  if (client->appData.scaleSetting>1)\n  {\n      if (!SendScaleSetting(client, client->appData.scaleSetting))\n          return FALSE;\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x / client->appData.scaleSetting,\n\t\t\t      client->updateRect.y / client->appData.scaleSetting,\n\t\t\t      client->updateRect.w / client->appData.scaleSetting,\n\t\t\t      client->updateRect.h / client->appData.scaleSetting,\n\t\t\t      FALSE))\n\t      return FALSE;\n  }\n  else\n  {\n      if (!SendFramebufferUpdateRequest(client,\n\t\t\t      client->updateRect.x, client->updateRect.y,\n\t\t\t      client->updateRect.w, client->updateRect.h,\n\t\t\t      FALSE))\n      return FALSE;\n  }\n\n  return TRUE;\n}\n\nrfbBool rfbInitClient(rfbClient* client,int* argc,char** argv) {\n  int i,j;\n\n  if(argv && argc && *argc) {\n    if(client->programName==0)\n      client->programName=argv[0];\n\n    for (i = 1; i < *argc; i++) {\n      j = i;\n      if (strcmp(argv[i], \"-listen\") == 0) {\n\tlistenForIncomingConnections(client);\n\tbreak;\n      } else if (strcmp(argv[i], \"-listennofork\") == 0) {\n\tlistenForIncomingConnectionsNoFork(client, -1);\n\tbreak;\n      } else if (strcmp(argv[i], \"-play\") == 0) {\n\tclient->serverPort = -1;\n\tj++;\n      } else if (i+1<*argc && strcmp(argv[i], \"-encodings\") == 0) {\n\tclient->appData.encodingsString = argv[i+1];\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-compress\") == 0) {\n\tclient->appData.compressLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-quality\") == 0) {\n\tclient->appData.qualityLevel = atoi(argv[i+1]);\n\tj+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-scale\") == 0) {\n        client->appData.scaleSetting = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-qosdscp\") == 0) {\n        client->QoS_DSCP = atoi(argv[i+1]);\n        j+=2;\n      } else if (i+1<*argc && strcmp(argv[i], \"-repeaterdest\") == 0) {\n\tchar* colon=strchr(argv[i+1],':');\n\n\tif(client->destHost)\n\t  free(client->destHost);\n        client->destPort = 5900;\n\n\tclient->destHost = strdup(argv[i+1]);\n\tif(colon) {\n\t  client->destHost[(int)(colon-argv[i+1])] = '\\0';\n\t  client->destPort = atoi(colon+1);\n\t}\n        j+=2;\n      } else {\n\tchar* colon=strrchr(argv[i],':');\n\n\tif(client->serverHost)\n\t  free(client->serverHost);\n\n\tif(colon) {\n\t  client->serverHost = strdup(argv[i]);\n\t  client->serverHost[(int)(colon-argv[i])] = '\\0';\n\t  client->serverPort = atoi(colon+1);\n\t} else {\n\t  client->serverHost = strdup(argv[i]);\n\t}\n\tif(client->serverPort >= 0 && client->serverPort < 5900)\n\t  client->serverPort += 5900;\n      }\n      /* purge arguments */\n      if (j>i) {\n\t*argc-=j-i;\n\tmemmove(argv+i,argv+j,(*argc-i)*sizeof(char*));\n\ti--;\n      }\n    }\n  }\n\n  if(!rfbInitConnection(client)) {\n    rfbClientCleanup(client);\n    return FALSE;\n  }\n\n  return TRUE;\n}\n\nvoid rfbClientCleanup(rfbClient* client) {\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n  int i;\n\n  for ( i = 0; i < 4; i++ ) {\n    if (client->zlibStreamActive[i] == TRUE ) {\n      if (inflateEnd (&client->zlibStream[i]) != Z_OK &&\n\t  client->zlibStream[i].msg != NULL)\n\trfbClientLog(\"inflateEnd: %s\\n\", client->zlibStream[i].msg);\n    }\n  }\n\n  if ( client->decompStreamInited == TRUE ) {\n    if (inflateEnd (&client->decompStream) != Z_OK &&\n\tclient->decompStream.msg != NULL)\n      rfbClientLog(\"inflateEnd: %s\\n\", client->decompStream.msg );\n  }\n#endif\n#endif\n\n  if (client->ultra_buffer)\n    free(client->ultra_buffer);\n\n  if (client->raw_buffer)\n    free(client->raw_buffer);\n\n  FreeTLS(client);\n\n  while (client->clientData) {\n    rfbClientData* next = client->clientData->next;\n    free(client->clientData);\n    client->clientData = next;\n  }\n\n  if (client->sock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->sock);\n  if (client->listenSock != RFB_INVALID_SOCKET)\n    rfbCloseSocket(client->listenSock);\n  free(client->desktopName);\n  free(client->serverHost);\n  if (client->destHost)\n    free(client->destHost);\n  if (client->clientAuthSchemes)\n    free(client->clientAuthSchemes);\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n  if (client->saslSecret)\n    free(client->saslSecret);\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef WIN32\n  if(WSACleanup() != 0) {\n      errno=WSAGetLastError();\n      rfbClientErr(\"Could not terminate Windows Sockets: %s\\n\", strerror(errno));\n  }\n#endif\n\n  free(client);\n}\n", "#ifndef RFBCLIENT_H\n#define RFBCLIENT_H\n\n/**\n * @defgroup libvncclient_api LibVNCClient API Reference\n * @{\n */\n\n/*\n *  Copyright (C) 2017 D. R. Commander.  All Rights Reserved.\n *  Copyright (C) 2000, 2001 Const Kaplinsky.  All Rights Reserved.\n *  Copyright (C) 2000 Tridia Corporation.  All Rights Reserved.\n *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n/**\n * @file rfbclient.h\n */\n\n#ifdef WIN32\n#define WIN32_LEAN_AND_MEAN /* Prevent loading any Winsock 1.x headers from windows.h */\n#ifdef _MSC_VER\n#pragma warning(disable:4996)\n#endif\n#endif\n\n#if defined(ANDROID) || defined(LIBVNCSERVER_HAVE_ANDROID)\n#include <arpa/inet.h>\n#include <sys/select.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#if LIBVNCSERVER_HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#if LIBVNCSERVER_HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#include <rfb/rfbproto.h>\n#include <rfb/keysym.h>\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n#include <sasl/sasl.h>\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#define rfbClientSwap16IfLE(s) \\\n    (*(char *)&client->endianTest ? ((((s) & 0xff) << 8) | (((s) >> 8) & 0xff)) : (s))\n\n#define rfbClientSwap32IfLE(l) \\\n    (*(char *)&client->endianTest ? ((((l) >> 24) & 0x000000ff) | \\\n\t\t\t     (((l) & 0x00ff0000) >> 8)  | \\\n\t\t\t     (((l) & 0x0000ff00) << 8)  | \\\n\t\t\t     (((l) & 0x000000ff) << 24))  : (l))\n\n#define rfbClientSwap64IfLE(l) \\\n    (*(char *)&client->endianTest ? ((((l) >> 56 ) & 0x00000000000000ffULL) | \\\n\t\t\t     (((l) & 0x00ff000000000000ULL) >> 40)  | \\\n\t\t\t     (((l) & 0x0000ff0000000000ULL) >> 24)  | \\\n\t\t\t     (((l) & 0x000000ff00000000ULL) >> 8)  | \\\n\t\t\t     (((l) & 0x00000000ff000000ULL) << 8)  | \\\n\t\t\t     (((l) & 0x0000000000ff0000ULL) << 24)  | \\\n\t\t\t     (((l) & 0x000000000000ff00ULL) << 40)  | \\\n\t\t\t     (((l) & 0x00000000000000ffULL) << 56))  : (l))\n\n#define FLASH_PORT_OFFSET 5400\n#define LISTEN_PORT_OFFSET 5500\n#define TUNNEL_PORT_OFFSET 5500\n#define SERVER_PORT_OFFSET 5900\n\n#define DEFAULT_CONNECT_TIMEOUT 60\n#define DEFAULT_READ_TIMEOUT 0\n\n#define DEFAULT_SSH_CMD \"/usr/bin/ssh\"\n#define DEFAULT_TUNNEL_CMD  \\\n  (DEFAULT_SSH_CMD \" -f -L %L:localhost:%R %H sleep 20\")\n#define DEFAULT_VIA_CMD     \\\n  (DEFAULT_SSH_CMD \" -f -L %L:%H:%R %G sleep 20\")\n\n#if(defined __cplusplus)\nextern \"C\"\n{\n#endif\n\n/** vncrec */\n\ntypedef struct {\n  FILE* file;\n  struct timeval tv;\n  rfbBool readTimestamp;\n  rfbBool doNotSleep;\n} rfbVNCRec;\n\n/** client data */\n\ntypedef struct rfbClientData {\n\tvoid* tag;\n\tvoid* data;\n\tstruct rfbClientData* next;\n} rfbClientData;\n\n/** app data (belongs into rfbClient?) */\n\ntypedef struct {\n  rfbBool shareDesktop;\n  rfbBool viewOnly;\n\n  const char* encodingsString;\n\n  rfbBool useBGR233;\n  int nColours;\n  rfbBool forceOwnCmap;\n  rfbBool forceTrueColour;\n  int requestedDepth;\n\n  int compressLevel;\n  int qualityLevel;\n  rfbBool enableJPEG;\n  rfbBool useRemoteCursor;\n  rfbBool palmVNC;  /**< use palmvnc specific SetScale (vs ultravnc) */\n  int scaleSetting; /**< 0 means no scale set, else 1/scaleSetting */\n} AppData;\n\n/** For GetCredentialProc callback function to return */\ntypedef union _rfbCredential\n{\n  /** X509 (VeNCrypt) */\n  struct\n  {\n    char *x509CACertFile;\n    char *x509CACrlFile;\n    char *x509ClientCertFile;\n    char *x509ClientKeyFile;\n    uint8_t x509CrlVerifyMode; /* Only required for OpenSSL - see meanings below */\n  } x509Credential;\n  /** Plain (VeNCrypt), MSLogon (UltraVNC) */\n  struct\n  {\n    char *username;\n    char *password;\n  } userCredential;\n} rfbCredential;\n\n#define rfbCredentialTypeX509 1\n#define rfbCredentialTypeUser 2\n\n/* When using OpenSSL, CRLs can be included in both the x509CACrlFile and appended\n   to the x509CACertFile as is common with OpenSSL.  When rfbX509CrlVerifyAll is\n   specified the CRL list must include CRLs for all certificates in the chain */\n#define rfbX509CrlVerifyNone   0    /* No CRL checking is performed */\n#define rfbX509CrlVerifyClient 1    /* Only the leaf server certificate is checked */\n#define rfbX509CrlVerifyAll    2    /* All certificates in the server chain are checked */\n\nstruct _rfbClient;\n\n/**\n * Handles a text chat message. If your application should accept text messages\n * from the server, define a function with this prototype and set\n * client->HandleTextChat to a pointer to that function subsequent to your\n * rfbGetClient() call.\n * @param client The client which called the text chat handler\n * @param value  text length if text != NULL, or one of rfbTextChatOpen,\n * rfbTextChatClose, rfbTextChatFinished if text == NULL\n * @param text The text message from the server\n */\ntypedef void (*HandleTextChatProc)(struct _rfbClient* client, int value, char *text);\n/**\n * Handles XVP server messages. If your application sends XVP messages to the\n * server, you'll want to handle the server's XVP_FAIL and XVP_INIT responses.\n * Define a function with this prototype and set client->HandleXvpMsg to a\n * pointer to that function subsequent to your rfbGetClient() call.\n * @param client The client which called the XVP message handler\n * @param version The highest XVP extension version that the server supports\n * @param opcode The opcode. 0 is XVP_FAIL, 1 is XVP_INIT\n */\ntypedef void (*HandleXvpMsgProc)(struct _rfbClient* client, uint8_t version, uint8_t opcode);\ntypedef void (*HandleKeyboardLedStateProc)(struct _rfbClient* client, int value, int pad);\ntypedef rfbBool (*HandleCursorPosProc)(struct _rfbClient* client, int x, int y);\ntypedef void (*SoftCursorLockAreaProc)(struct _rfbClient* client, int x, int y, int w, int h);\ntypedef void (*SoftCursorUnlockScreenProc)(struct _rfbClient* client);\n/**\n   Callback indicating that a rectangular area of the client's framebuffer was updated.\n   As a server will usually send several rects per rfbFramebufferUpdate message, this\n   callback is usually called multiple times per rfbFramebufferUpdate message.\n   @param client The client whose framebuffer was (partially) updated\n   @param x The x-coordinate of the upper left corner of the updated rectangle\n   @param y The y-coordinate of the upper left corner of the updated rectangle\n   @param w The width of the updated rectangle\n   @param h The heigth of the updated rectangle\n */\ntypedef void (*GotFrameBufferUpdateProc)(struct _rfbClient* client, int x, int y, int w, int h);\n/**\n   Callback indicating that a client has completely processed an rfbFramebufferUpdate\n   message sent by a server.\n   This is called exactly once per each handled rfbFramebufferUpdate message.\n   @param client The client which finished processing an rfbFramebufferUpdate\n */\ntypedef void (*FinishedFrameBufferUpdateProc)(struct _rfbClient* client);\ntypedef char* (*GetPasswordProc)(struct _rfbClient* client);\ntypedef rfbCredential* (*GetCredentialProc)(struct _rfbClient* client, int credentialType);\ntypedef rfbBool (*MallocFrameBufferProc)(struct _rfbClient* client);\ntypedef void (*GotXCutTextProc)(struct _rfbClient* client, const char *text, int textlen);\ntypedef void (*BellProc)(struct _rfbClient* client);\n/**\n    Called when a cursor shape update was received from the server. The decoded cursor shape\n    will be in client->rcSource. It's up to the application to do something with this, e.g. draw\n    into a viewer's window. If you want the server to draw the cursor into the framebuffer, be\n    careful not to announce remote cursor support, i.e. not include rfbEncodingXCursor or\n    rfbEncodingRichCursor in SetFormatAndEncodings().\n*/\ntypedef void (*GotCursorShapeProc)(struct _rfbClient* client, int xhot, int yhot, int width, int height, int bytesPerPixel);\ntypedef void (*GotCopyRectProc)(struct _rfbClient* client, int src_x, int src_y, int w, int h, int dest_x, int dest_y);\ntypedef void (*GotFillRectProc)(struct _rfbClient* client, int x, int y, int w, int h, uint32_t colour);\ntypedef void (*GotBitmapProc)(struct _rfbClient* client, const uint8_t* buffer, int x, int y, int w, int h);\ntypedef rfbBool (*GotJpegProc)(struct _rfbClient* client, const uint8_t* buffer, int length, int x, int y, int w, int h);\ntypedef rfbBool (*LockWriteToTLSProc)(struct _rfbClient* client);\ntypedef rfbBool (*UnlockWriteToTLSProc)(struct _rfbClient* client);\n\n#ifdef LIBVNCSERVER_HAVE_SASL\ntypedef char* (*GetUserProc)(struct _rfbClient* client);\ntypedef char* (*GetSASLMechanismProc)(struct _rfbClient* client, char* mechlist);\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\ntypedef struct _rfbClient {\n\tuint8_t* frameBuffer;\n\tint width, height;\n\n\tint endianTest;\n\n\tAppData appData;\n\n\tconst char* programName;\n\tchar* serverHost;\n\tint serverPort; /**< if -1, then use file recorded by vncrec */\n\trfbBool listenSpecified;\n\tint listenPort, flashPort;\n\n\tstruct {\n\t\tint x, y, w, h;\n\t} updateRect;\n\n\t/** Note that the CoRRE encoding uses this buffer and assumes it is big enough\n\t   to hold 255 * 255 * 32 bits -> 260100 bytes.  640*480 = 307200 bytes.\n\t   Hextile also assumes it is big enough to hold 16 * 16 * 32 bits.\n\t   Tight encoding assumes BUFFER_SIZE is at least 16384 bytes. */\n\n#define RFB_BUFFER_SIZE (640*480)\n\tchar buffer[RFB_BUFFER_SIZE];\n\n\t/* rfbproto.c */\n\n\trfbSocket sock;\n\trfbBool canUseCoRRE;\n\trfbBool canUseHextile;\n\tchar *desktopName;\n\trfbPixelFormat format;\n\trfbServerInitMsg si;\n\n\t/* sockets.c */\n#define RFB_BUF_SIZE 8192\n\tchar buf[RFB_BUF_SIZE];\n\tchar *bufoutptr;\n\tunsigned int buffered;\n\n\t/* The zlib encoding requires expansion/decompression/deflation of the\n\t   compressed data in the \"buffer\" above into another, result buffer.\n\t   However, the size of the result buffer can be determined precisely\n\t   based on the bitsPerPixel, height and width of the rectangle.  We\n\t   allocate this buffer one time to be the full size of the buffer. */\n\n\t/* Ultra Encoding uses this buffer too */\n\t\n\tint ultra_buffer_size;\n\tchar *ultra_buffer;\n\n\tint raw_buffer_size;\n\tchar *raw_buffer;\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\tz_stream decompStream;\n\trfbBool decompStreamInited;\n#endif\n\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n\t/*\n\t * Variables for the ``tight'' encoding implementation.\n\t */\n\n\t/** Separate buffer for compressed data. */\n#define ZLIB_BUFFER_SIZE 30000\n\tchar zlib_buffer[ZLIB_BUFFER_SIZE];\n\n\t/* Four independent compression streams for zlib library. */\n\tz_stream zlibStream[4];\n\trfbBool zlibStreamActive[4];\n\n\t/* Filter stuff. Should be initialized by filter initialization code. */\n\trfbBool cutZeros;\n\tint rectWidth, rectColors;\n\tchar tightPalette[256*4];\n\tuint8_t tightPrevRow[2048*3*sizeof(uint16_t)];\n\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state (obsolete-- do not use). */\n\trfbBool jpegError;\n\n\tstruct jpeg_source_mgr* jpegSrcManager;\n\tvoid* jpegBufferPtr;\n\tsize_t jpegBufferLen;\n\n#endif\n#endif\n\n\n\t/* cursor.c */\n\t/** Holds cursor shape data when received from server. */\n\tuint8_t *rcSource, *rcMask;\n\n\t/** private data pointer */\n\trfbClientData* clientData;\n\n\trfbVNCRec* vncRec;\n\n\t/* Keyboard State support (is 'Caps Lock' set on the remote display???) */\n\tint KeyboardLedStateEnabled;\n\tint CurrentKeyboardLedState;\n\n\tint canHandleNewFBSize;\n\n\t/* hooks */\n\tHandleTextChatProc         HandleTextChat;\n\tHandleKeyboardLedStateProc HandleKeyboardLedState;\n\tHandleCursorPosProc HandleCursorPos;\n\tSoftCursorLockAreaProc SoftCursorLockArea;\n\tSoftCursorUnlockScreenProc SoftCursorUnlockScreen;\n\tGotFrameBufferUpdateProc GotFrameBufferUpdate;\n\t/** the pointer returned by GetPassword will be freed after use! */\n\tGetPasswordProc GetPassword;\n\tMallocFrameBufferProc MallocFrameBuffer;\n\tGotXCutTextProc GotXCutText;\n\tBellProc Bell;\n\n\tGotCursorShapeProc GotCursorShape;\n\tGotCopyRectProc GotCopyRect;\n\n\t/** Which messages are supported by the server\n\t * This is a *guess* for most servers.\n\t * (If we can even detect the type of server)\n\t *\n\t * If the server supports the \"rfbEncodingSupportedMessages\"\n\t * then this will be updated when the encoding is received to\n\t * accurately reflect the servers capabilities.\n\t */\n\trfbSupportedMessages supportedMessages;\n\n\t/** negotiated protocol version */\n\tint major, minor;\n\n\t/** The selected security types */\n\tuint32_t authScheme, subAuthScheme;\n\n\t/** The TLS session for Anonymous TLS and VeNCrypt */\n\tvoid* tlsSession;\n\n\t/** To support security types that requires user input (except VNC password\n\t * authentication), for example VeNCrypt and MSLogon, this callback function\n\t * must be set before the authentication. Otherwise, it implicates that the\n\t * caller application does not support it and related security types should\n\t * be bypassed.\n\t */\n\tGetCredentialProc GetCredential;\n\n\t/** The 0-terminated security types supported by the client.\n\t * Set by function SetClientAuthSchemes() */\n\tuint32_t *clientAuthSchemes;\n\n\t/** When the server is a repeater, this specifies the final destination */\n\tchar *destHost;\n\tint destPort;\n\n        /** the QoS IP DSCP for this client */\n        int QoS_DSCP;\n\n        /** hook to handle xvp server messages */\n\tHandleXvpMsgProc           HandleXvpMsg;\n\n\t/* listen.c */\n        rfbSocket listenSock;\n\n\tFinishedFrameBufferUpdateProc FinishedFrameBufferUpdate;\n\n\tchar *listenAddress;\n        /* IPv6 listen socket, address and port*/\n        rfbSocket listen6Sock;\n        char* listen6Address;\n        int listen6Port;\n\n        /* Output Window ID. When set, client application enables libvncclient to perform direct rendering in its window */\n        unsigned long outputWindow;\n\n\t/** Hooks for optional protection WriteToTLS() by mutex */\n\tLockWriteToTLSProc LockWriteToTLS;\n\tUnlockWriteToTLSProc UnlockWriteToTLS;\n\n        /** Hooks for custom rendering\n         *\n         * VNC rendering boils down to 3 activities:\n         * - GotCopyRect: copy an area of the framebuffer\n         * - GotFillRect: fill an area of the framebuffer with a solid color\n         * - GotBitmap: copy the bitmap in the buffer into the framebuffer\n         * The client application should either set all three of these or none!\n         */\n        GotFillRectProc GotFillRect;\n        GotBitmapProc GotBitmap;\n        /** Hook for custom JPEG decoding and rendering */\n        GotJpegProc GotJpeg;\n\n#ifdef LIBVNCSERVER_HAVE_SASL\n        sasl_conn_t *saslconn;\n        const char *saslDecoded;\n        unsigned int saslDecodedLength;\n        unsigned int saslDecodedOffset;\n        sasl_secret_t *saslSecret;\n\n        /* Callback to allow the client to choose a preferred mechanism. The string returned will\n           be freed once no longer required. */\n        GetSASLMechanismProc GetSASLMechanism;\n        GetUserProc GetUser;\n\n#endif /* LIBVNCSERVER_HAVE_SASL */\n\n#ifdef LIBVNCSERVER_HAVE_LIBZ\n#ifdef LIBVNCSERVER_HAVE_LIBJPEG\n\t/** JPEG decoder state. */\n\tvoid *tjhnd;\n\n#endif\n#endif\n\t/* timeout in seconds for select() after connect() */\n\tunsigned int connectTimeout;\n\t/* timeout in seconds when reading from half-open connections in\n\t * ReadFromRFBServer() - keep at 0 to disable timeout detection and handling */\n\tunsigned int readTimeout;\n} rfbClient;\n\n/* cursor.c */\n/**\n * Handles XCursor and RichCursor shape updates from the server.\n * We emulate cursor operating on the frame buffer (that is\n * why we call it \"software cursor\"). This decodes the received cursor\n * shape and hands it over to GotCursorShapeProc, if set.\n */\nextern rfbBool HandleCursorShape(rfbClient* client,int xhot, int yhot, int width, int height, uint32_t enc);\n\n/* listen.c */\n\nextern void listenForIncomingConnections(rfbClient* viewer);\nextern int listenForIncomingConnectionsNoFork(rfbClient* viewer, int usec_timeout);\n\n/* rfbproto.c */\n\nextern rfbBool rfbEnableClientLogging;\ntypedef void (*rfbClientLogProc)(const char *format, ...);\nextern rfbClientLogProc rfbClientLog,rfbClientErr;\nextern rfbBool ConnectToRFBServer(rfbClient* client,const char *hostname, int port);\nextern rfbBool ConnectToRFBRepeater(rfbClient* client,const char *repeaterHost, int repeaterPort, const char *destHost, int destPort);\nextern void SetClientAuthSchemes(rfbClient* client,const uint32_t *authSchemes, int size);\nextern rfbBool InitialiseRFBConnection(rfbClient* client);\n/**\n * Sends format and encoding parameters to the server. Your application can\n * modify the 'client' data structure directly. However some changes to this\n * structure must be communicated back to the server. For instance, if you\n * change the encoding to hextile, the server needs to know that it should send\n * framebuffer updates in hextile format. Likewise if you change the pixel\n * format of the framebuffer, the server must be notified about this as well.\n * Call this function to propagate your changes of the local 'client' structure\n * over to the server.\n * @li Encoding type\n * @li RFB protocol extensions announced via pseudo-encodings\n * @li Framebuffer pixel format (like RGB vs ARGB)\n * @li Remote cursor support\n * @param client The client in which the format or encodings have been changed\n * @return true if the format or encodings were sent to the server successfully,\n * false otherwise\n */\nextern rfbBool SetFormatAndEncodings(rfbClient* client);\nextern rfbBool SendIncrementalFramebufferUpdateRequest(rfbClient* client);\n/**\n * Sends a framebuffer update request to the server. A VNC client may request an\n * update from the server at any time. You can also specify which portions of\n * the screen you want updated. This can be handy if a pointer is at certain\n * location and the user pressed a mouse button, for instance. Then you can\n * immediately request an update of the region around the pointer from the\n * server.\n * @note The coordinate system is a left-handed Cartesian coordinate system with\n * the Z axis (unused) pointing out of the screen. Alternately you can think of\n * it as a right-handed Cartesian coordinate system with the Z axis pointing\n * into the screen. The origin is at the upper left corner of the framebuffer.\n * @param client The client through which to send the request\n * @param x The horizontal position of the update request rectangle\n * @param y The vertical position of the update request rectangle\n * @param w The width of the update request rectangle\n * @param h The height of the update request rectangle\n * @param incremental false: server sends rectangle even if nothing changed.\n * true: server only sends changed parts of rectangle.\n * @return true if the update request was sent successfully, false otherwise\n */\nextern rfbBool SendFramebufferUpdateRequest(rfbClient* client,\n\t\t\t\t\t int x, int y, int w, int h,\n\t\t\t\t\t rfbBool incremental);\nextern rfbBool SendScaleSetting(rfbClient* client,int scaleSetting);\n/**\n * Sends a pointer event to the server. A pointer event includes a cursor\n * location and a button mask. The button mask indicates which buttons on the\n * pointing device are pressed. Each button is represented by a bit in the\n * button mask. A 1 indicates the button is pressed while a 0 indicates that it\n * is not pressed. You may use these pre-defined button masks by ORing them\n * together: rfbButton1Mask, rfbButton2Mask, rfbButton3Mask, rfbButton4Mask\n * rfbButton5Mask\n * @note  The cursor location is relative to the client's framebuffer, not the\n * client's screen itself.\n * @note The coordinate system is a left-handed Cartesian coordinate system with\n * the Z axis (unused) pointing out of the screen. Alternately you can think of\n * it as a right-handed Cartesian coordinate system with the Z axis pointing\n * into the screen. The origin is at the upper left corner of the screen.\n * @param client The client through which to send the pointer event\n * @param x the horizontal location of the cursor\n * @param y the vertical location of the cursor\n * @param buttonMask the button mask indicating which buttons are pressed\n * @return true if the pointer event was sent successfully, false otherwise\n */\nextern rfbBool SendPointerEvent(rfbClient* client,int x, int y, int buttonMask);\n/**\n * Sends a key event to the server. If your application is not merely a VNC\n * viewer (i.e. it controls the server), you'll want to send the keys that the\n * user presses to the server. Use this function to do that.\n * @param client The client through which to send the key event\n * @param key An rfbKeySym defined in rfb/keysym.h\n * @param down true if this was a key down event, false otherwise\n * @return true if the key event was send successfully, false otherwise\n */\nextern rfbBool SendKeyEvent(rfbClient* client,uint32_t key, rfbBool down);\n/**\n * Places a string on the server's clipboard. Use this function if you want to\n * be able to copy and paste between the server and your application. For\n * instance, when your application is notified that the user copied some text\n * onto the clipboard, you would call this function to synchronize the server's\n * clipboard with your local clipboard.\n * @param client The client structure through which to send the client cut text\n * message\n * @param str The string to send (doesn't need to be NULL terminated)\n * @param len The length of the string\n * @return true if the client cut message was sent successfully, false otherwise\n */\nextern rfbBool SendClientCutText(rfbClient* client,char *str, int len);\n/**\n * Handles messages from the RFB server. You must call this function\n * intermittently so LibVNCClient can parse messages from the server. For\n * example, if your app has a draw loop, you could place a call to this\n * function within that draw loop.\n * @note You must call WaitForMessage() before you call this function.\n * @param client The client which will handle the RFB server messages\n * @return true if the client was able to handle the RFB server messages, false\n * otherwise\n */\nextern rfbBool HandleRFBServerMessage(rfbClient* client);\n\n/**\n * Sends a text chat message to the server.\n * @param client The client through which to send the message\n * @param text The text to send\n * @return true if the text was sent successfully, false otherwise\n */\nextern rfbBool TextChatSend(rfbClient* client, char *text);\n/**\n * Opens a text chat window on the server.\n * @param client The client through which to send the message\n * @return true if the window was opened successfully, false otherwise\n */\nextern rfbBool TextChatOpen(rfbClient* client);\n/**\n * Closes the text chat window on the server.\n * @param client The client through which to send the message\n * @return true if the window was closed successfully, false otherwise\n */\nextern rfbBool TextChatClose(rfbClient* client);\nextern rfbBool TextChatFinish(rfbClient* client);\nextern rfbBool PermitServerInput(rfbClient* client, int enabled);\nextern rfbBool SendXvpMsg(rfbClient* client, uint8_t version, uint8_t code);\n\nextern void PrintPixelFormat(rfbPixelFormat *format);\n\nextern rfbBool SupportsClient2Server(rfbClient* client, int messageType);\nextern rfbBool SupportsServer2Client(rfbClient* client, int messageType);\n\n/* client data */\n\n/**\n * Associates a client data tag with the given pointer. LibVNCClient has\n * several events to which you can associate your own handlers. These handlers\n * have the client structure as one of their parameters. Sometimes, you may want\n * to make data from elsewhere in your application available to these handlers\n * without using a global variable. To do this, you call\n * rfbClientSetClientData() and associate the data with a tag. Then, your\n * handler can call rfbClientGetClientData() and get the a pointer to the data\n * associated with that tag.\n * @param client The client in which to set the client data\n * @param tag A unique tag which identifies the data\n * @param data A pointer to the data to associate with the tag\n */\nvoid rfbClientSetClientData(rfbClient* client, void* tag, void* data);\n/**\n * Returns a pointer to the client data associated with the given tag. See the\n * the documentation for rfbClientSetClientData() for a discussion of how you\n * can use client data.\n * @param client The client from which to get the client data\n * @param tag The tag which identifies the client data\n * @return a pointer to the client data\n */\nvoid* rfbClientGetClientData(rfbClient* client, void* tag);\n\n/* protocol extensions */\n\ntypedef struct _rfbClientProtocolExtension {\n\tint* encodings;\n\t/** returns TRUE if the encoding was handled */\n\trfbBool (*handleEncoding)(rfbClient* cl,\n\t\trfbFramebufferUpdateRectHeader* rect);\n\t/** returns TRUE if it handled the message */\n\trfbBool (*handleMessage)(rfbClient* cl,\n\t\t rfbServerToClientMsg* message);\n\tstruct _rfbClientProtocolExtension* next;\n\tuint32_t const* securityTypes;\n\t/** returns TRUE if it handled the authentication */\n\trfbBool (*handleAuthentication)(rfbClient* cl, uint32_t authScheme);\n} rfbClientProtocolExtension;\n\nvoid rfbClientRegisterExtension(rfbClientProtocolExtension* e);\n\n/* sockets.c */\n\nextern rfbBool errorMessageOnReadFailure;\n\nextern rfbBool ReadFromRFBServer(rfbClient* client, char *out, unsigned int n);\nextern rfbBool WriteToRFBServer(rfbClient* client, const char *buf, unsigned int n);\nextern int FindFreeTcpPort(void);\nextern rfbSocket ListenAtTcpPort(int port);\nextern rfbSocket ListenAtTcpPortAndAddress(int port, const char *address);\n/**\n   Tries to connect to an IPv4 host.\n   @param host Binary IPv4 address\n   @param port Port\n   @return A blocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddr(unsigned int host, int port);\n/**\n   Tries to connect to an IPv4 or IPv6 host.\n   @param hostname A hostname or IP address\n   @param port Port\n   @return A blocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddr6(const char *hostname, int port);\n/**\n   Tries to connect to a Unix socket.\n   @param sockFile Path of the socket file\n   @return A blocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToUnixSock(const char *sockFile);\n/**\n   Tries to connect to an IPv4 host using the given timeout value.\n   @param host Binary IPv4 address\n   @param port Port\n   @param timeout The time in seconds to wait for a connection\n   @return A nonblocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddrWithTimeout(unsigned int host, int port, unsigned int timeout);\n/**\n   Tries to connect to an IPv4 or IPv6 host using the given timeout value.\n   @param hostname A hostname or IP address\n   @param port Port\n   @param timeout The time in seconds to wait for a connection\n   @return A nonblocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToTcpAddr6WithTimeout(const char *hostname, int port, unsigned int timeout);\n/**\n   Tries to connect to a Unix socket using the given timeout value.\n   @param sockFile Path of the socket file\n   @param timeout The time in seconds to wait for a connection\n   @return A nonblocking socket or RFB_INVALID_SOCKET if the connection failed\n*/\nextern rfbSocket ConnectClientToUnixSockWithTimeout(const char *sockFile, unsigned int timeout);\nextern rfbSocket AcceptTcpConnection(rfbSocket listenSock);\nextern rfbBool SetNonBlocking(rfbSocket sock);\nextern rfbBool SetBlocking(rfbSocket sock);\nextern rfbBool SetDSCP(rfbSocket sock, int dscp);\n\nextern rfbBool StringToIPAddr(const char *str, unsigned int *addr);\nextern rfbBool SameMachine(rfbSocket sock);\n/**\n * Waits for an RFB message to arrive from the server. Before handling a message\n * with HandleRFBServerMessage(), you must wait for your client to receive one.\n * This function blocks until a message is received. You may specify a timeout\n * in microseconds. Once this number of microseconds have elapsed, the function\n * will return.\n * @param client The client to cause to wait until a message is received\n * @param usecs The timeout in microseconds\n * @return the return value of the underlying select() call\n */\nextern int WaitForMessage(rfbClient* client,unsigned int usecs);\n\n/* vncviewer.c */\n/**\n * Allocates and returns a pointer to an rfbClient structure. This will probably\n * be the first LibVNCClient function your client code calls. Most libVNCClient\n * functions operate on an rfbClient structure, and this function allocates\n * memory for that structure. When you're done with the rfbClient structure\n * pointer this function returns, you should free the memory rfbGetClient()\n * allocated by calling rfbClientCleanup().\n *\n * A pixel is one dot on the screen. The number of bytes in a pixel will depend\n * on the number of samples in that pixel and the number of bits in each sample.\n * A sample represents one of the primary colors in a color model. The RGB\n * color model uses red, green, and blue samples respectively. Suppose you\n * wanted to use 16-bit RGB color: You would have three samples per pixel (one\n * for each primary color), five bits per sample (the quotient of 16 RGB bits\n * divided by three samples), and two bytes per pixel (the smallest multiple of\n * eight bits in which the 16-bit pixel will fit). If you wanted 32-bit RGB\n * color, you would have three samples per pixel again, eight bits per sample\n * (since that's how 32-bit color is defined), and four bytes per pixel (the\n * smallest multiple of eight bits in which the 32-bit pixel will fit.\n * @param bitsPerSample The number of bits in a sample\n * @param samplesPerPixel The number of samples in a pixel\n * @param bytesPerPixel The number of bytes in a pixel\n * @return a pointer to the allocated rfbClient structure\n */\nrfbClient* rfbGetClient(int bitsPerSample,int samplesPerPixel,int bytesPerPixel);\n/**\n * Initializes the client. The format is {PROGRAM_NAME, [OPTIONS]..., HOST}. This\n * function does not initialize the program name if the rfbClient's program\n * name is set already. The options are as follows:\n * <table>\n * <tr><th>Option</th><th>Description</th></tr>\n * <tr><td>-listen</td><td>Listen for incoming connections.</td></tr>\n * <tr><td>-listennofork</td><td>Listen for incoming connections without forking.\n * </td></tr>\n * <tr><td>-play</td><td>Set this client to replay a previously recorded session.</td></tr>\n * <tr><td>-encodings</td><td>Set the encodings to use. The next item in the\n * argv array is the encodings string, consisting of comma separated encodings like 'tight,ultra,raw'.</td></tr>\n * <tr><td>-compress</td><td>Set the compression level. The next item in the\n * argv array is the compression level as an integer. Ranges from 0 (lowest) to 9 (highest).\n * </td></tr>\n * <tr><td>-scale</td><td>Set the scaling level. The next item in the\n * argv array is the scaling level as an integer. The screen will be scaled down by this factor.</td></tr>\n * <tr><td>-qosdscp</td><td>Set the Quality of Service Differentiated Services\n * Code Point (QoS DSCP). The next item in the argv array is the code point as\n * an integer.</td></tr>\n * <tr><td>-repeaterdest</td><td>Set a VNC repeater address. The next item in the argv array is\n * the repeater's address as a string.</td></tr>\n * </table>\n *\n * The host may include a port number (delimited by a ':').\n * @param client The client to initialize\n * @param argc The number of arguments to the initializer\n * @param argv The arguments to the initializer as an array of NULL terminated\n * strings\n * @return true if the client was initialized successfully, false otherwise.\n */\nrfbBool rfbInitClient(rfbClient* client,int* argc,char** argv);\n/**\n * Cleans up the client structure and releases the memory allocated for it. You\n * should call this when you're done with the rfbClient structure that you\n * allocated with rfbGetClient().\n * @note rfbClientCleanup() does not touch client->frameBuffer.\n * @param client The client to clean up\n */\nvoid rfbClientCleanup(rfbClient* client);\n\n#if(defined __cplusplus)\n}\n#endif\n\n/**\n * @}\n */\n\n/**\n @page libvncclient_doc LibVNCClient Documentation\n @section example_code Example Code\n See SDLvncviewer.c for a rather complete client example.\n*/\n\n#endif\n"], "filenames": ["libvncclient/sockets.c", "libvncclient/vncviewer.c", "rfb/rfbclient.h"], "buggy_code_start_loc": [64, 274, 87], "buggy_code_end_loc": [201, 274, 456], "fixing_code_start_loc": [65, 275, 88], "fixing_code_end_loc": [215, 276, 461], "type": "CWE-835", "message": "An issue was discovered in LibVNCServer before 0.9.13. An improperly closed TCP connection causes an infinite loop in libvncclient/sockets.c.", "other": {"cve": {"id": "CVE-2020-14398", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:11.837", "lastModified": "2022-03-10T15:13:52.663", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LibVNCServer before 0.9.13. An improperly closed TCP connection causes an infinite loop in libvncclient/sockets.c."}, {"lang": "es", "value": "Se detect\u00f3 un problema en LibVNCServer versiones anteriores a 0.9.13. Una conexi\u00f3n TCP cerrada inapropiadamente causa un bucle infinito en la biblioteca libvncclient/sockets.c"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-835"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvnc_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.12", "matchCriteriaId": "A03A7282-D445-4E26-98A0-6A1597838D35"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.2:*:*:*:*:*:*:*", "matchCriteriaId": "B009C22E-30A4-4288-BCF6-C3E81DEAF45A"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00033.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00055.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2020-07/msg00066.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/57433015f856cc12753378254ce4f1c78f5d9c7b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/57433015f856cc12753378254ce4f1c78f5d9c7b"}}