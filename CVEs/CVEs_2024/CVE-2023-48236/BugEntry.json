{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * misc1.c: functions that didn't seem to fit elsewhere\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#if defined(__HAIKU__)\n# include <storage/FindDirectory.h>\n#endif\n\n#if defined(MSWIN)\n# include <lm.h>\n#endif\n\n#define URL_SLASH\t1\t\t// path_is_url() has found \"://\"\n#define URL_BACKSLASH\t2\t\t// path_is_url() has found \":\\\\\"\n\n// All user names (for ~user completion as done by shell).\nstatic garray_T\tga_users;\n\n/*\n * get_leader_len() returns the length in bytes of the prefix of the given\n * string which introduces a comment.  If this string is not a comment then\n * 0 is returned.\n * When \"flags\" is not NULL, it is set to point to the flags of the recognized\n * comment leader.\n * \"backward\" must be true for the \"O\" command.\n * If \"include_space\" is set, include trailing whitespace while calculating the\n * length.\n */\n    int\nget_leader_len(\n    char_u\t*line,\n    char_u\t**flags,\n    int\t\tbackward,\n    int\t\tinclude_space)\n{\n    int\t\ti, j;\n    int\t\tresult;\n    int\t\tgot_com = FALSE;\n    int\t\tfound_one;\n    char_u\tpart_buf[COM_MAX_LEN];\t// buffer for one option part\n    char_u\t*string;\t\t// pointer to comment string\n    char_u\t*list;\n    int\t\tmiddle_match_len = 0;\n    char_u\t*prev_list;\n    char_u\t*saved_flags = NULL;\n\n    result = i = 0;\n    while (VIM_ISWHITE(line[i]))    // leading white space is ignored\n\t++i;\n\n    /*\n     * Repeat to match several nested comment strings.\n     */\n    while (line[i] != NUL)\n    {\n\t/*\n\t * scan through the 'comments' option for a match\n\t */\n\tfound_one = FALSE;\n\tfor (list = curbuf->b_p_com; *list; )\n\t{\n\t    // Get one option part into part_buf[].  Advance \"list\" to next\n\t    // one.  Put \"string\" at start of string.\n\t    if (!got_com && flags != NULL)\n\t\t*flags = list;\t    // remember where flags started\n\t    prev_list = list;\n\t    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, \",\");\n\t    string = vim_strchr(part_buf, ':');\n\t    if (string == NULL)\t    // missing ':', ignore this part\n\t\tcontinue;\n\t    *string++ = NUL;\t    // isolate flags from string\n\n\t    // If we found a middle match previously, use that match when this\n\t    // is not a middle or end.\n\t    if (middle_match_len != 0\n\t\t    && vim_strchr(part_buf, COM_MIDDLE) == NULL\n\t\t    && vim_strchr(part_buf, COM_END) == NULL)\n\t\tbreak;\n\n\t    // When we already found a nested comment, only accept further\n\t    // nested comments.\n\t    if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)\n\t\tcontinue;\n\n\t    // When 'O' flag present and using \"O\" command skip this one.\n\t    if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)\n\t\tcontinue;\n\n\t    // Line contents and string must match.\n\t    // When string starts with white space, must have some white space\n\t    // (but the amount does not need to match, there might be a mix of\n\t    // TABs and spaces).\n\t    if (VIM_ISWHITE(string[0]))\n\t    {\n\t\tif (i == 0 || !VIM_ISWHITE(line[i - 1]))\n\t\t    continue;  // missing white space\n\t\twhile (VIM_ISWHITE(string[0]))\n\t\t    ++string;\n\t    }\n\t    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)\n\t\t;\n\t    if (string[j] != NUL)\n\t\tcontinue;  // string doesn't match\n\n\t    // When 'b' flag used, there must be white space or an\n\t    // end-of-line after the string in the line.\n\t    if (vim_strchr(part_buf, COM_BLANK) != NULL\n\t\t\t   && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)\n\t\tcontinue;\n\n\t    // We have found a match, stop searching unless this is a middle\n\t    // comment. The middle comment can be a substring of the end\n\t    // comment in which case it's better to return the length of the\n\t    // end comment and its flags.  Thus we keep searching with middle\n\t    // and end matches and use an end match if it matches better.\n\t    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)\n\t    {\n\t\tif (middle_match_len == 0)\n\t\t{\n\t\t    middle_match_len = j;\n\t\t    saved_flags = prev_list;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (middle_match_len != 0 && j > middle_match_len)\n\t\t// Use this match instead of the middle match, since it's a\n\t\t// longer thus better match.\n\t\tmiddle_match_len = 0;\n\n\t    if (middle_match_len == 0)\n\t\ti += j;\n\t    found_one = TRUE;\n\t    break;\n\t}\n\n\tif (middle_match_len != 0)\n\t{\n\t    // Use the previously found middle match after failing to find a\n\t    // match with an end.\n\t    if (!got_com && flags != NULL)\n\t\t*flags = saved_flags;\n\t    i += middle_match_len;\n\t    found_one = TRUE;\n\t}\n\n\t// No match found, stop scanning.\n\tif (!found_one)\n\t    break;\n\n\tresult = i;\n\n\t// Include any trailing white space.\n\twhile (VIM_ISWHITE(line[i]))\n\t    ++i;\n\n\tif (include_space)\n\t    result = i;\n\n\t// If this comment doesn't nest, stop here.\n\tgot_com = TRUE;\n\tif (vim_strchr(part_buf, COM_NEST) == NULL)\n\t    break;\n    }\n    return result;\n}\n\n/*\n * Return the offset at which the last comment in line starts. If there is no\n * comment in the whole line, -1 is returned.\n *\n * When \"flags\" is not null, it is set to point to the flags describing the\n * recognized comment leader.\n */\n    int\nget_last_leader_offset(char_u *line, char_u **flags)\n{\n    int\t\tresult = -1;\n    int\t\ti, j;\n    int\t\tlower_check_bound = 0;\n    char_u\t*string;\n    char_u\t*com_leader;\n    char_u\t*com_flags;\n    char_u\t*list;\n    int\t\tfound_one;\n    char_u\tpart_buf[COM_MAX_LEN];\t// buffer for one option part\n\n    /*\n     * Repeat to match several nested comment strings.\n     */\n    i = (int)STRLEN(line);\n    while (--i >= lower_check_bound)\n    {\n\t/*\n\t * scan through the 'comments' option for a match\n\t */\n\tfound_one = FALSE;\n\tfor (list = curbuf->b_p_com; *list; )\n\t{\n\t    char_u *flags_save = list;\n\n\t    /*\n\t     * Get one option part into part_buf[].  Advance list to next one.\n\t     * put string at start of string.\n\t     */\n\t    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, \",\");\n\t    string = vim_strchr(part_buf, ':');\n\t    if (string == NULL)\t// If everything is fine, this cannot actually\n\t\t\t\t// happen.\n\t\tcontinue;\n\t    *string++ = NUL;\t// Isolate flags from string.\n\t    com_leader = string;\n\n\t    /*\n\t     * Line contents and string must match.\n\t     * When string starts with white space, must have some white space\n\t     * (but the amount does not need to match, there might be a mix of\n\t     * TABs and spaces).\n\t     */\n\t    if (VIM_ISWHITE(string[0]))\n\t    {\n\t\tif (i == 0 || !VIM_ISWHITE(line[i - 1]))\n\t\t    continue;\n\t\twhile (VIM_ISWHITE(*string))\n\t\t    ++string;\n\t    }\n\t    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)\n\t\t/* do nothing */;\n\t    if (string[j] != NUL)\n\t\tcontinue;\n\n\t    /*\n\t     * When 'b' flag used, there must be white space or an\n\t     * end-of-line after the string in the line.\n\t     */\n\t    if (vim_strchr(part_buf, COM_BLANK) != NULL\n\t\t    && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)\n\t\tcontinue;\n\n\t    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)\n\t    {\n\t\t// For a middlepart comment, only consider it to match if\n\t\t// everything before the current position in the line is\n\t\t// whitespace.  Otherwise we would think we are inside a\n\t\t// comment if the middle part appears somewhere in the middle\n\t\t// of the line.  E.g. for C the \"*\" appears often.\n\t\tfor (j = 0; VIM_ISWHITE(line[j]) && j <= i; j++)\n\t\t    ;\n\t\tif (j < i)\n\t\t    continue;\n\t    }\n\n\t    /*\n\t     * We have found a match, stop searching.\n\t     */\n\t    found_one = TRUE;\n\n\t    if (flags)\n\t\t*flags = flags_save;\n\t    com_flags = flags_save;\n\n\t    break;\n\t}\n\n\tif (found_one)\n\t{\n\t    char_u  part_buf2[COM_MAX_LEN];\t// buffer for one option part\n\t    int     len1, len2, off;\n\n\t    result = i;\n\t    /*\n\t     * If this comment nests, continue searching.\n\t     */\n\t    if (vim_strchr(part_buf, COM_NEST) != NULL)\n\t\tcontinue;\n\n\t    lower_check_bound = i;\n\n\t    // Let's verify whether the comment leader found is a substring\n\t    // of other comment leaders. If it is, let's adjust the\n\t    // lower_check_bound so that we make sure that we have determined\n\t    // the comment leader correctly.\n\n\t    while (VIM_ISWHITE(*com_leader))\n\t\t++com_leader;\n\t    len1 = (int)STRLEN(com_leader);\n\n\t    for (list = curbuf->b_p_com; *list; )\n\t    {\n\t\tchar_u *flags_save = list;\n\n\t\t(void)copy_option_part(&list, part_buf2, COM_MAX_LEN, \",\");\n\t\tif (flags_save == com_flags)\n\t\t    continue;\n\t\tstring = vim_strchr(part_buf2, ':');\n\t\t++string;\n\t\twhile (VIM_ISWHITE(*string))\n\t\t    ++string;\n\t\tlen2 = (int)STRLEN(string);\n\t\tif (len2 == 0)\n\t\t    continue;\n\n\t\t// Now we have to verify whether string ends with a substring\n\t\t// beginning the com_leader.\n\t\tfor (off = (len2 > i ? i : len2); off > 0 && off + len1 > len2;)\n\t\t{\n\t\t    --off;\n\t\t    if (!STRNCMP(string + off, com_leader, len2 - off))\n\t\t    {\n\t\t\tif (i - off < lower_check_bound)\n\t\t\t    lower_check_bound = i - off;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\n/*\n * Return the number of window lines occupied by buffer line \"lnum\".\n * Includes any filler lines.\n */\n    int\nplines(linenr_T lnum)\n{\n    return plines_win(curwin, lnum, TRUE);\n}\n\n    int\nplines_win(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    int\t\tlimit_winheight)\t// when TRUE limit to window height\n{\n#if defined(FEAT_DIFF) || defined(PROTO)\n    // Check for filler lines above this buffer line.  When folded the result\n    // is one line anyway.\n    return plines_win_nofill(wp, lnum, limit_winheight)\n\t\t\t\t\t\t   + diff_check_fill(wp, lnum);\n}\n\n/*\n * Return the number of window lines occupied by buffer line \"lnum\".\n * Does not include filler lines.\n */\n    int\nplines_nofill(linenr_T lnum)\n{\n    return plines_win_nofill(curwin, lnum, TRUE);\n}\n\n    int\nplines_win_nofill(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    int\t\tlimit_winheight)\t// when TRUE limit to window height\n{\n#endif\n    int\t\tlines;\n\n    if (wp->w_width == 0)\n\treturn 1;\n\n#ifdef FEAT_FOLDING\n    // Folded lines are handled just like an empty line.\n    // NOTE: Caller must handle lines that are MAYBE folded.\n    if (lineFolded(wp, lnum) == TRUE)\n\treturn 1;\n#endif\n\n    if (!wp->w_p_wrap)\n\tlines = 1\n#ifdef FEAT_PROP_POPUP\n\t    // add a line for each \"above\" and \"below\" aligned text property\n\t    + prop_count_above_below(wp->w_buffer, lnum)\n#endif\n\t;\n    else\n\tlines = plines_win_nofold(wp, lnum);\n\n    if (limit_winheight && lines > wp->w_height)\n\treturn wp->w_height;\n    return lines;\n}\n\n/*\n * Return number of window lines physical line \"lnum\" will occupy in window\n * \"wp\".  Does not care about folding, 'wrap' or 'diff'.\n */\n    int\nplines_win_nofold(win_T *wp, linenr_T lnum)\n{\n    char_u\t*s;\n    long\tcol;\n    int\t\twidth;\n    chartabsize_T cts;\n\n    s = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    init_chartabsize_arg(&cts, wp, lnum, 0, s, s);\n    if (*s == NUL\n#ifdef FEAT_PROP_POPUP\n\t    && !cts.cts_has_prop_with_text\n#endif\n\t    )\n\treturn 1; // be quick for an empty line\n    win_linetabsize_cts(&cts, (colnr_T)MAXCOL);\n    clear_chartabsize_arg(&cts);\n    col = (int)cts.cts_vcol;\n\n    // If list mode is on, then the '$' at the end of the line may take up one\n    // extra column.\n    if (wp->w_p_list && wp->w_lcs_chars.eol != NUL)\n\tcol += 1;\n\n    /*\n     * Add column offset for 'number', 'relativenumber' and 'foldcolumn'.\n     */\n    width = wp->w_width - win_col_off(wp);\n    if (width <= 0)\n\treturn 32000;\n    if (col <= width)\n\treturn 1;\n    col -= width;\n    width += win_col_off2(wp);\n    return (col + (width - 1)) / width + 1;\n}\n\n/*\n * Like plines_win(), but only reports the number of physical screen lines\n * used from the start of the line to the given column number.\n */\n    int\nplines_win_col(win_T *wp, linenr_T lnum, long column)\n{\n    long\tcol;\n    int\t\tlines = 0;\n    int\t\twidth;\n    char_u\t*line;\n    chartabsize_T cts;\n\n#ifdef FEAT_DIFF\n    // Check for filler lines above this buffer line.  When folded the result\n    // is one line anyway.\n    lines = diff_check_fill(wp, lnum);\n#endif\n\n    if (!wp->w_p_wrap)\n\treturn lines + 1;\n\n    if (wp->w_width == 0)\n\treturn lines + 1;\n\n    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n    init_chartabsize_arg(&cts, wp, lnum, 0, line, line);\n    while (*cts.cts_ptr != NUL && --column >= 0)\n    {\n\tcts.cts_vcol += win_lbr_chartabsize(&cts, NULL);\n\tMB_PTR_ADV(cts.cts_ptr);\n    }\n\n    /*\n     * If *cts.cts_ptr is a TAB, and the TAB is not displayed as ^I, and we're\n     * not in MODE_INSERT state, then col must be adjusted so that it\n     * represents the last screen position of the TAB.  This only fixes an\n     * error when the TAB wraps from one screen line to the next (when\n     * 'columns' is not a multiple of 'ts') -- webb.\n     */\n    col = cts.cts_vcol;\n    if (*cts.cts_ptr == TAB && (State & MODE_NORMAL)\n\t\t\t\t    && (!wp->w_p_list || wp->w_lcs_chars.tab1))\n\tcol += win_lbr_chartabsize(&cts, NULL) - 1;\n    clear_chartabsize_arg(&cts);\n\n    /*\n     * Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.\n     */\n    width = wp->w_width - win_col_off(wp);\n    if (width <= 0)\n\treturn 9999;\n\n    lines += 1;\n    if (col > width)\n\tlines += (col - width) / (width + win_col_off2(wp)) + 1;\n    return lines;\n}\n\n    int\nplines_m_win(win_T *wp, linenr_T first, linenr_T last, int limit_winheight)\n{\n    int\t\tcount = 0;\n\n    while (first <= last)\n    {\n#ifdef FEAT_FOLDING\n\tint\tx;\n\n\t// Check if there are any really folded lines, but also included lines\n\t// that are maybe folded.\n\tx = foldedCount(wp, first, NULL);\n\tif (x > 0)\n\t{\n\t    ++count;\t    // count 1 for \"+-- folded\" line\n\t    first += x;\n\t}\n\telse\n#endif\n\t{\n#ifdef FEAT_DIFF\n\t    if (first == wp->w_topline)\n\t\tcount += plines_win_nofill(wp, first, limit_winheight)\n\t\t\t\t\t\t\t       + wp->w_topfill;\n\t    else\n#endif\n\t\tcount += plines_win(wp, first, limit_winheight);\n\t    ++first;\n\t}\n    }\n    return (count);\n}\n\n    int\ngchar_pos(pos_T *pos)\n{\n    char_u\t*ptr;\n\n    // When searching columns is sometimes put at the end of a line.\n    if (pos->col == MAXCOL)\n\treturn NUL;\n    ptr = ml_get_pos(pos);\n    if (has_mbyte)\n\treturn (*mb_ptr2char)(ptr);\n    return (int)*ptr;\n}\n\n    int\ngchar_cursor(void)\n{\n    if (has_mbyte)\n\treturn (*mb_ptr2char)(ml_get_cursor());\n    return (int)*ml_get_cursor();\n}\n\n/*\n * Write a character at the current cursor position.\n * It is directly written into the block.\n */\n    void\npchar_cursor(int c)\n{\n    *(ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE)\n\t\t\t\t\t\t  + curwin->w_cursor.col) = c;\n}\n\n/*\n * Skip to next part of an option argument: Skip space and comma.\n */\n    char_u *\nskip_to_option_part(char_u *p)\n{\n    if (*p == ',')\n\t++p;\n    while (*p == ' ')\n\t++p;\n    return p;\n}\n\n/*\n * check_status: called when the status bars for the buffer 'buf'\n *\t\t need to be updated\n */\n    void\ncheck_status(buf_T *buf)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf && wp->w_status_height)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    set_must_redraw(UPD_VALID);\n\t}\n}\n\n/*\n * Ask for a reply from the user, a 'y' or a 'n', with prompt \"str\" (which\n * should have been translated already).\n * No other characters are accepted, the message is repeated until a valid\n * reply is entered or CTRL-C is hit.\n * If direct is TRUE, don't use vgetc() but ui_inchar(), don't get characters\n * from any buffers but directly from the user.\n *\n * return the 'y' or 'n'\n */\n    int\nask_yesno(char_u *str, int direct)\n{\n    int\t    r = ' ';\n    int\t    save_State = State;\n\n    if (exiting)\t\t// put terminal in raw mode for this question\n\tsettmode(TMODE_RAW);\n    ++no_wait_return;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    State = MODE_CONFIRM;\t// mouse behaves like with :confirm\n    setmouse();\t\t\t// disables mouse for xterm\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping here, but recognize keys\n\n    while (r != 'y' && r != 'n')\n    {\n\t// same highlighting as for wait_return()\n\tsmsg_attr(HL_ATTR(HLF_R), \"%s (y/n)?\", str);\n\tif (direct)\n\t    r = get_keystroke();\n\telse\n\t    r = plain_vgetc();\n\tif (r == Ctrl_C || r == ESC)\n\t    r = 'n';\n\tmsg_putchar(r);\t    // show what you typed\n\tout_flush();\n    }\n    --no_wait_return;\n    State = save_State;\n    setmouse();\n    --no_mapping;\n    --allow_keys;\n\n    return r;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Returns the current mode as a string in \"buf[MODE_MAX_LENGTH]\", NUL\n * terminated.\n * The first character represents the major mode, the following ones the minor\n * ones.\n */\n    void\nget_mode(char_u *buf)\n{\n    int\t\ti = 0;\n\n    if (time_for_testing == 93784)\n    {\n\t// Testing the two-character code.\n\tbuf[i++] = 'x';\n\tbuf[i++] = '!';\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_use_loop())\n    {\n\tif (State & MODE_CMDLINE)\n\t    buf[i++] = 'c';\n\tbuf[i++] = 't';\n    }\n#endif\n    else if (VIsual_active)\n    {\n\tif (VIsual_select)\n\t    buf[i++] = VIsual_mode + 's' - 'v';\n\telse\n\t{\n\t    buf[i++] = VIsual_mode;\n\t    if (restart_VIsual_select)\n\t\tbuf[i++] = 's';\n\t}\n    }\n    else if (State == MODE_HITRETURN || State == MODE_ASKMORE\n\t\t\t\t\t\t      || State == MODE_SETWSIZE\n\t\t|| State == MODE_CONFIRM)\n    {\n\tbuf[i++] = 'r';\n\tif (State == MODE_ASKMORE)\n\t    buf[i++] = 'm';\n\telse if (State == MODE_CONFIRM)\n\t    buf[i++] = '?';\n    }\n    else if (State == MODE_EXTERNCMD)\n\tbuf[i++] = '!';\n    else if (State & MODE_INSERT)\n    {\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    buf[i++] = 'R';\n\t    buf[i++] = 'v';\n\t}\n\telse\n\t{\n\t    if (State & REPLACE_FLAG)\n\t\tbuf[i++] = 'R';\n\t    else\n\t\tbuf[i++] = 'i';\n\t}\n\n\tif (ins_compl_active())\n\t    buf[i++] = 'c';\n\telse if (ctrl_x_mode_not_defined_yet())\n\t    buf[i++] = 'x';\n    }\n    else if ((State & MODE_CMDLINE) || exmode_active)\n    {\n\tbuf[i++] = 'c';\n\tif (exmode_active == EXMODE_VIM)\n\t    buf[i++] = 'v';\n\telse if (exmode_active == EXMODE_NORMAL)\n\t    buf[i++] = 'e';\n    }\n    else\n    {\n\tbuf[i++] = 'n';\n\tif (finish_op)\n\t{\n\t    buf[i++] = 'o';\n\t    // to be able to detect force-linewise/blockwise/characterwise\n\t    // operations\n\t    buf[i++] = motion_force;\n\t}\n\telse if (restart_edit == 'I' || restart_edit == 'R'\n\t\t\t\t\t\t\t|| restart_edit == 'V')\n\t{\n\t    buf[i++] = 'i';\n\t    buf[i++] = restart_edit;\n\t}\n#ifdef FEAT_TERMINAL\n\telse if (term_in_normal_mode())\n\t    buf[i++] = 't';\n#endif\n    }\n\n    buf[i] = NUL;\n}\n\n/*\n * \"mode()\" function\n */\n    void\nf_mode(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[MODE_MAX_LENGTH];\n\n    if (in_vim9script() && check_for_opt_bool_arg(argvars, 0) == FAIL)\n\treturn;\n\n    get_mode(buf);\n\n    // Clear out the minor mode when the argument is not a non-zero number or\n    // non-empty string.\n    if (!non_zero_arg(&argvars[0]))\n\tbuf[1] = NUL;\n\n    rettv->vval.v_string = vim_strsave(buf);\n    rettv->v_type = VAR_STRING;\n}\n\n    static void\nmay_add_state_char(garray_T *gap, char_u *include, int c)\n{\n    if (include == NULL || vim_strchr(include, c) != NULL)\n\tga_append(gap, c);\n}\n\n/*\n * \"state()\" function\n */\n    void\nf_state(typval_T *argvars, typval_T *rettv)\n{\n    garray_T\tga;\n    char_u\t*include = NULL;\n    int\t\ti;\n\n    if (in_vim9script() && check_for_opt_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    ga_init2(&ga, 1, 20);\n    if (argvars[0].v_type != VAR_UNKNOWN)\n\tinclude = tv_get_string(&argvars[0]);\n\n    if (!(stuff_empty() && typebuf.tb_len == 0 && scriptin[curscript] == NULL))\n\tmay_add_state_char(&ga, include, 'm');\n    if (op_pending())\n\tmay_add_state_char(&ga, include, 'o');\n    if (autocmd_busy)\n\tmay_add_state_char(&ga, include, 'x');\n    if (ins_compl_active())\n\tmay_add_state_char(&ga, include, 'a');\n\n# ifdef FEAT_JOB_CHANNEL\n    if (channel_in_blocking_wait())\n\tmay_add_state_char(&ga, include, 'w');\n# endif\n    if (!get_was_safe_state())\n\tmay_add_state_char(&ga, include, 'S');\n    for (i = 0; i < get_callback_depth() && i < 3; ++i)\n\tmay_add_state_char(&ga, include, 'c');\n    if (msg_scrolled > 0)\n\tmay_add_state_char(&ga, include, 's');\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = ga.ga_data;\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Get a key stroke directly from the user.\n * Ignores mouse clicks and scrollbar events, except a click for the left\n * button (used at the more prompt).\n * Doesn't use vgetc(), because it syncs undo and eats mapped characters.\n * Disadvantage: typeahead is ignored.\n * Translates the interrupt character for unix to ESC.\n */\n    int\nget_keystroke(void)\n{\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 150;\n    int\t\tmaxlen;\n    int\t\tlen = 0;\n    int\t\tn;\n    int\t\tsave_mapped_ctrl_c = mapped_ctrl_c;\n    int\t\twaited = 0;\n\n    mapped_ctrl_c = FALSE;\t// mappings are not used here\n    for (;;)\n    {\n\tcursor_on();\n\tout_flush();\n\n\t// Leave some room for check_termcode() to insert a key code into (max\n\t// 5 chars plus NUL).  And fix_input_buffer() can triple the number of\n\t// bytes.\n\tmaxlen = (buflen - 6 - len) / 3;\n\tif (buf == NULL)\n\t    buf = alloc(buflen);\n\telse if (maxlen < 10)\n\t{\n\t    char_u  *t_buf = buf;\n\n\t    // Need some more space. This might happen when receiving a long\n\t    // escape sequence.\n\t    buflen += 100;\n\t    buf = vim_realloc(buf, buflen);\n\t    if (buf == NULL)\n\t\tvim_free(t_buf);\n\t    maxlen = (buflen - 6 - len) / 3;\n\t}\n\tif (buf == NULL)\n\t{\n\t    do_outofmem_msg((long_u)buflen);\n\t    return ESC;  // panic!\n\t}\n\n\t// First time: blocking wait.  Second time: wait up to 100ms for a\n\t// terminal code to complete.\n\tn = ui_inchar(buf + len, maxlen, len == 0 ? -1L : 100L, 0);\n\tif (n > 0)\n\t{\n\t    // Replace zero and CSI by a special key code.\n\t    n = fix_input_buffer(buf + len, n);\n\t    len += n;\n\t    waited = 0;\n\t}\n\telse if (len > 0)\n\t    ++waited;\t    // keep track of the waiting time\n\n\t// Incomplete termcode and not timed out yet: get more characters\n\tif ((n = check_termcode(1, buf, buflen, &len)) < 0\n\t       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))\n\t    continue;\n\n\tif (n == KEYLEN_REMOVED)  // key code removed\n\t{\n\t    if (must_redraw != 0 && !need_wait_return && (State\n\t\t\t& (MODE_CMDLINE | MODE_HITRETURN | MODE_ASKMORE)) == 0)\n\t    {\n\t\t// Redrawing was postponed, do it now.\n\t\tupdate_screen(0);\n\t\tsetcursor(); // put cursor back where it belongs\n\t    }\n\t    continue;\n\t}\n\tif (n > 0)\t\t// found a termcode: adjust length\n\t    len = n;\n\tif (len == 0)\t\t// nothing typed yet\n\t    continue;\n\n\t// Handle modifier and/or special key code.\n\tn = buf[0];\n\tif (n == K_SPECIAL)\n\t{\n\t    n = TO_SPECIAL(buf[1], buf[2]);\n\t    if (buf[1] == KS_MODIFIER\n\t\t    || n == K_IGNORE\n\t\t    || (is_mouse_key(n) && n != K_LEFTMOUSE)\n#ifdef FEAT_GUI\n\t\t    || n == K_VER_SCROLLBAR\n\t\t    || n == K_HOR_SCROLLBAR\n#endif\n\t       )\n\t    {\n\t\tif (buf[1] == KS_MODIFIER)\n\t\t    mod_mask = buf[2];\n\t\tlen -= 3;\n\t\tif (len > 0)\n\t\t    mch_memmove(buf, buf + 3, (size_t)len);\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\tif (has_mbyte)\n\t{\n\t    if (MB_BYTE2LEN(n) > len)\n\t\tcontinue;\t// more bytes to get\n\t    buf[len >= buflen ? buflen - 1 : len] = NUL;\n\t    n = (*mb_ptr2char)(buf);\n\t}\n#ifdef UNIX\n\tif (n == intr_char)\n\t    n = ESC;\n#endif\n\tbreak;\n    }\n    vim_free(buf);\n\n    mapped_ctrl_c = save_mapped_ctrl_c;\n    return n;\n}\n\n/*\n * Get a number from the user.\n * When \"mouse_used\" is not NULL allow using the mouse.\n */\n    int\nget_number(\n    int\t    colon,\t\t\t// allow colon to abort\n    int\t    *mouse_used)\n{\n    int\tn = 0;\n    int\tc;\n    int typed = 0;\n\n    if (mouse_used != NULL)\n\t*mouse_used = FALSE;\n\n    // When not printing messages, the user won't know what to type, return a\n    // zero (as if CR was hit).\n    if (msg_silent != 0)\n\treturn 0;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping here, but recognize keys\n    for (;;)\n    {\n\twindgoto(msg_row, msg_col);\n\tc = safe_vgetc();\n\tif (VIM_ISDIGIT(c))\n\t{\n\t    n = n * 10 + c - '0';\n\t    msg_putchar(c);\n\t    ++typed;\n\t}\n\telse if (c == K_DEL || c == K_KDEL || c == K_BS || c == Ctrl_H)\n\t{\n\t    if (typed > 0)\n\t    {\n\t\tmsg_puts(\"\\b \\b\");\n\t\t--typed;\n\t    }\n\t    n /= 10;\n\t}\n\telse if (mouse_used != NULL && c == K_LEFTMOUSE)\n\t{\n\t    *mouse_used = TRUE;\n\t    n = mouse_row + 1;\n\t    break;\n\t}\n\telse if (n == 0 && c == ':' && colon)\n\t{\n\t    stuffcharReadbuff(':');\n\t    if (!exmode_active)\n\t\tcmdline_row = msg_row;\n\t    skip_redraw = TRUE;\t    // skip redraw once\n\t    do_redraw = FALSE;\n\t    break;\n\t}\n\telse if (c == Ctrl_C || c == ESC || c == 'q')\n\t{\n\t    n = 0;\n\t    break;\n\t}\n\telse if (c == CAR || c == NL )\n\t    break;\n    }\n    --no_mapping;\n    --allow_keys;\n    return n;\n}\n\n/*\n * Ask the user to enter a number.\n * When \"mouse_used\" is not NULL allow using the mouse and in that case return\n * the line number.\n */\n    int\nprompt_for_number(int *mouse_used)\n{\n    int\t\ti;\n    int\t\tsave_cmdline_row;\n    int\t\tsave_State;\n\n    // When using \":silent\" assume that <CR> was entered.\n    if (mouse_used != NULL)\n\tmsg_puts(_(\"Type number and <Enter> or click with the mouse (q or empty cancels): \"));\n    else\n\tmsg_puts(_(\"Type number and <Enter> (q or empty cancels): \"));\n\n    // Set the state such that text can be selected/copied/pasted and we still\n    // get mouse events. redraw_after_callback() will not redraw if cmdline_row\n    // is zero.\n    save_cmdline_row = cmdline_row;\n    cmdline_row = 0;\n    save_State = State;\n    State = MODE_CMDLINE;\n    // May show different mouse shape.\n    setmouse();\n\n    i = get_number(TRUE, mouse_used);\n    if (KeyTyped)\n    {\n\t// don't call wait_return() now\n\tif (msg_row > 0)\n\t    cmdline_row = msg_row - 1;\n\tneed_wait_return = FALSE;\n\tmsg_didany = FALSE;\n\tmsg_didout = FALSE;\n    }\n    else\n\tcmdline_row = save_cmdline_row;\n    State = save_State;\n    // May need to restore mouse shape.\n    setmouse();\n\n    return i;\n}\n\n    void\nmsgmore(long n)\n{\n    long pn;\n\n    if (global_busy\t    // no messages now, wait until global is finished\n\t    || !messaging())  // 'lazyredraw' set, don't do messages now\n\treturn;\n\n    // We don't want to overwrite another important message, but do overwrite\n    // a previous \"more lines\" or \"fewer lines\" message, so that \"5dd\" and\n    // then \"put\" reports the last action.\n    if (keep_msg != NULL && !keep_msg_more)\n\treturn;\n\n    if (n > 0)\n\tpn = n;\n    else\n\tpn = -n;\n\n    if (pn > p_report)\n    {\n\tif (n > 0)\n\t    vim_snprintf(msg_buf, MSG_BUF_LEN,\n\t\t    NGETTEXT(\"%ld more line\", \"%ld more lines\", pn), pn);\n\telse\n\t    vim_snprintf(msg_buf, MSG_BUF_LEN,\n\t\t    NGETTEXT(\"%ld line less\", \"%ld fewer lines\", pn), pn);\n\tif (got_int)\n\t    vim_strcat((char_u *)msg_buf, (char_u *)_(\" (Interrupted)\"),\n\t\t\t\t\t\t\t\t  MSG_BUF_LEN);\n\tif (msg(msg_buf))\n\t{\n\t    set_keep_msg((char_u *)msg_buf, 0);\n\t    keep_msg_more = TRUE;\n\t}\n    }\n}\n\n/*\n * flush map and typeahead buffers and give a warning for an error\n */\n    void\nbeep_flush(void)\n{\n    if (emsg_silent == 0)\n    {\n\tflush_buffers(FLUSH_MINIMAL);\n\tvim_beep(BO_ERROR);\n    }\n}\n\n/*\n * Give a warning for an error. \"val\" is one of the BO_ values, e.g., BO_OPER.\n */\n    void\nvim_beep(unsigned val)\n{\n#ifdef FEAT_EVAL\n    called_vim_beep = TRUE;\n#endif\n\n    if (emsg_silent != 0 || in_assert_fails)\n\treturn;\n\n    if (!((bo_flags & val) || (bo_flags & BO_ALL)))\n    {\n#ifdef ELAPSED_FUNC\n\tstatic int\t\tdid_init = FALSE;\n\tstatic elapsed_T\tstart_tv;\n\n\t// Only beep once per half a second, otherwise a sequence of beeps\n\t// would freeze Vim.\n\tif (!did_init || ELAPSED_FUNC(start_tv) > 500)\n\t{\n\t    did_init = TRUE;\n\t    ELAPSED_INIT(start_tv);\n#endif\n\t    if (p_vb\n#ifdef FEAT_GUI\n\t\t    // While the GUI is starting up the termcap is set for\n\t\t    // the GUI but the output still goes to a terminal.\n\t\t    && !(gui.in_use && gui.starting)\n#endif\n\t       )\n\t    {\n\t\tout_str_cf(T_VB);\n#ifdef FEAT_VTP\n\t\t// No restore color information, refresh the screen.\n\t\tif (has_vtp_working() != 0\n# ifdef FEAT_TERMGUICOLORS\n\t\t\t&& (p_tgc || (!p_tgc && t_colors >= 256))\n# endif\n\t\t   )\n\t\t{\n\t\t    redraw_later(UPD_CLEAR);\n\t\t    update_screen(0);\n\t\t    redrawcmd();\n\t\t}\n#endif\n\t    }\n\t    else\n\t\tout_char(BELL);\n#ifdef ELAPSED_FUNC\n\t}\n#endif\n    }\n\n    // When 'debug' contains \"beep\" produce a message.  If we are sourcing\n    // a script or executing a function give the user a hint where the beep\n    // comes from.\n    if (vim_strchr(p_debug, 'e') != NULL)\n    {\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_attr(_(\"Beep!\"), HL_ATTR(HLF_W));\n    }\n}\n\n/*\n * To get the \"real\" home directory:\n * - get value of $HOME\n * For Unix:\n *  - go to that directory\n *  - do mch_dirname() to get the real name of that directory.\n *  This also works with mounts and links.\n *  Don't do this for MS-DOS, it will change the \"current dir\" for a drive.\n * For Windows:\n *  This code is duplicated in init_homedir() in dosinst.c.  Keep in sync!\n */\n    void\ninit_homedir(void)\n{\n    char_u  *var;\n\n    // In case we are called a second time (when 'encoding' changes).\n    VIM_CLEAR(homedir);\n\n#ifdef VMS\n    var = mch_getenv((char_u *)\"SYS$LOGIN\");\n#else\n    var = mch_getenv((char_u *)\"HOME\");\n#endif\n\n#ifdef MSWIN\n    /*\n     * Typically, $HOME is not defined on Windows, unless the user has\n     * specifically defined it for Vim's sake.  However, on Windows NT\n     * platforms, $HOMEDRIVE and $HOMEPATH are automatically defined for\n     * each user.  Try constructing $HOME from these.\n     */\n    if (var == NULL || *var == NUL)\n    {\n\tchar_u *homedrive, *homepath;\n\n\thomedrive = mch_getenv((char_u *)\"HOMEDRIVE\");\n\thomepath = mch_getenv((char_u *)\"HOMEPATH\");\n\tif (homepath == NULL || *homepath == NUL)\n\t    homepath = (char_u *)\"\\\\\";\n\tif (homedrive != NULL\n\t\t\t   && STRLEN(homedrive) + STRLEN(homepath) < MAXPATHL)\n\t{\n\t    sprintf((char *)NameBuff, \"%s%s\", homedrive, homepath);\n\t    if (NameBuff[0] != NUL)\n\t\tvar = NameBuff;\n\t}\n    }\n\n    if (var == NULL)\n\tvar = mch_getenv((char_u *)\"USERPROFILE\");\n\n    /*\n     * Weird but true: $HOME may contain an indirect reference to another\n     * variable, esp. \"%USERPROFILE%\".  Happens when $USERPROFILE isn't set\n     * when $HOME is being set.\n     */\n    if (var != NULL && *var == '%')\n    {\n\tchar_u\t*p;\n\tchar_u\t*exp;\n\n\tp = vim_strchr(var + 1, '%');\n\tif (p != NULL)\n\t{\n\t    vim_strncpy(NameBuff, var + 1, p - (var + 1));\n\t    exp = mch_getenv(NameBuff);\n\t    if (exp != NULL && *exp != NUL\n\t\t\t\t\t&& STRLEN(exp) + STRLEN(p) < MAXPATHL)\n\t    {\n\t\tvim_snprintf((char *)NameBuff, MAXPATHL, \"%s%s\", exp, p + 1);\n\t\tvar = NameBuff;\n\t    }\n\t}\n    }\n\n    if (var != NULL && *var == NUL)\t// empty is same as not set\n\tvar = NULL;\n\n    if (enc_utf8 && var != NULL)\n    {\n\tint\tlen;\n\tchar_u  *pp = NULL;\n\n\t// Convert from active codepage to UTF-8.  Other conversions are\n\t// not done, because they would fail for non-ASCII characters.\n\tacp_to_enc(var, (int)STRLEN(var), &pp, &len);\n\tif (pp != NULL)\n\t{\n\t    homedir = pp;\n\t    return;\n\t}\n    }\n\n    /*\n     * Default home dir is C:/\n     * Best assumption we can make in such a situation.\n     */\n    if (var == NULL)\n\tvar = (char_u *)\"C:/\";\n#endif\n\n    if (var != NULL)\n    {\n#ifdef UNIX\n\t/*\n\t * Change to the directory and get the actual path.  This resolves\n\t * links.  Don't do it when we can't return.\n\t */\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK\n\t\t\t\t\t  && mch_chdir((char *)NameBuff) == 0)\n\t{\n\t    if (!mch_chdir((char *)var) && mch_dirname(IObuff, IOSIZE) == OK)\n\t\tvar = IObuff;\n\t    if (mch_chdir((char *)NameBuff) != 0)\n\t\temsg(_(e_cannot_go_back_to_previous_directory));\n\t}\n#endif\n\thomedir = vim_strsave(var);\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_homedir(void)\n{\n    vim_free(homedir);\n}\n\n    void\nfree_users(void)\n{\n    ga_clear_strings(&ga_users);\n}\n#endif\n\n#if defined(MSWIN) || defined(PROTO)\n/*\n * Initialize $VIM and $VIMRUNTIME when 'enc' is updated.\n */\n    void\ninit_vimdir(void)\n{\n    int\t    mustfree;\n    char_u  *p;\n\n    mch_get_exe_name();\n\n    mustfree = FALSE;\n    didset_vim = FALSE;\n    p = vim_getenv((char_u *)\"VIM\", &mustfree);\n    if (mustfree)\n\tvim_free(p);\n\n    mustfree = FALSE;\n    didset_vimruntime = FALSE;\n    p = vim_getenv((char_u *)\"VIMRUNTIME\", &mustfree);\n    if (mustfree)\n\tvim_free(p);\n}\n#endif\n\n/*\n * Call expand_env() and store the result in an allocated string.\n * This is not very memory efficient, this expects the result to be freed\n * again soon.\n */\n    char_u *\nexpand_env_save(char_u *src)\n{\n    return expand_env_save_opt(src, FALSE);\n}\n\n/*\n * Idem, but when \"one\" is TRUE handle the string as one file name, only\n * expand \"~\" at the start.\n */\n    char_u *\nexpand_env_save_opt(char_u *src, int one)\n{\n    char_u\t*p;\n\n    p = alloc(MAXPATHL);\n    if (p != NULL)\n\texpand_env_esc(src, p, MAXPATHL, FALSE, one, NULL);\n    return p;\n}\n\n/*\n * Expand environment variable with path name.\n * \"~/\" is also expanded, using $HOME.\tFor Unix \"~user/\" is expanded.\n * Skips over \"\\ \", \"\\~\" and \"\\$\" (not for Win32 though).\n * If anything fails no expansion is done and dst equals src.\n */\n    void\nexpand_env(\n    char_u\t*src,\t\t// input string e.g. \"$HOME/vim.hlp\"\n    char_u\t*dst,\t\t// where to put the result\n    int\t\tdstlen)\t\t// maximum length of the result\n{\n    expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);\n}\n\n    void\nexpand_env_esc(\n    char_u\t*srcp,\t\t// input string e.g. \"$HOME/vim.hlp\"\n    char_u\t*dst,\t\t// where to put the result\n    int\t\tdstlen,\t\t// maximum length of the result\n    int\t\tesc,\t\t// escape spaces in expanded variables\n    int\t\tone,\t\t// \"srcp\" is one file name\n    char_u\t*startstr)\t// start again after this (can be NULL)\n{\n    char_u\t*src;\n    char_u\t*tail;\n    int\t\tc;\n    char_u\t*var;\n    int\t\tcopy_char;\n    int\t\tmustfree;\t// var was allocated, need to free it later\n    int\t\tat_start = TRUE; // at start of a name\n    int\t\tstartstr_len = 0;\n#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)\n    char_u\t*save_dst = dst;\n#endif\n\n    if (startstr != NULL)\n\tstartstr_len = (int)STRLEN(startstr);\n\n    src = skipwhite(srcp);\n    --dstlen;\t\t    // leave one char space for \"\\,\"\n    while (*src && dstlen > 0)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`.\n\tif (src[0] == '`' && src[1] == '=')\n\t{\n\t    size_t len;\n\n\t    var = src;\n\t    src += 2;\n\t    (void)skip_expr(&src, NULL);\n\t    if (*src == '`')\n\t\t++src;\n\t    len = src - var;\n\t    if (len > (size_t)dstlen)\n\t\tlen = dstlen;\n\t    vim_strncpy(dst, var, len);\n\t    dst += len;\n\t    dstlen -= (int)len;\n\t    continue;\n\t}\n#endif\n\tcopy_char = TRUE;\n\tif ((*src == '$'\n#ifdef VMS\n\t\t    && at_start\n#endif\n\t   )\n#if defined(MSWIN)\n\t\t|| *src == '%'\n#endif\n\t\t|| (*src == '~' && at_start))\n\t{\n\t    mustfree = FALSE;\n\n\t    /*\n\t     * The variable name is copied into dst temporarily, because it may\n\t     * be a string in read-only memory and a NUL needs to be appended.\n\t     */\n\t    if (*src != '~')\t\t\t\t// environment var\n\t    {\n\t\ttail = src + 1;\n\t\tvar = dst;\n\t\tc = dstlen - 1;\n\n#ifdef UNIX\n\t\t// Unix has ${var-name} type environment vars\n\t\tif (*tail == '{' && !vim_isIDc('{'))\n\t\t{\n\t\t    tail++;\t// ignore '{'\n\t\t    while (c-- > 0 && *tail && *tail != '}')\n\t\t\t*var++ = *tail++;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    while (c-- > 0 && *tail != NUL && ((vim_isIDc(*tail))\n#if defined(MSWIN)\n\t\t\t    || (*src == '%' && *tail != '%')\n#endif\n\t\t\t    ))\n\t\t\t*var++ = *tail++;\n\t\t}\n\n#if defined(MSWIN) || defined(UNIX)\n# ifdef UNIX\n\t\tif (src[1] == '{' && *tail != '}')\n# else\n\t\tif (*src == '%' && *tail != '%')\n# endif\n\t\t    var = NULL;\n\t\telse\n\t\t{\n# ifdef UNIX\n\t\t    if (src[1] == '{')\n# else\n\t\t    if (*src == '%')\n#endif\n\t\t\t++tail;\n#endif\n\t\t    *var = NUL;\n\t\t    var = vim_getenv(dst, &mustfree);\n#if defined(MSWIN) || defined(UNIX)\n\t\t}\n#endif\n\t    }\n\t\t\t\t\t\t\t// home directory\n\t    else if (  src[1] == NUL\n\t\t    || vim_ispathsep(src[1])\n\t\t    || vim_strchr((char_u *)\" ,\\t\\n\", src[1]) != NULL)\n\t    {\n\t\tvar = homedir;\n\t\ttail = src + 1;\n\t    }\n\t    else\t\t\t\t\t// user directory\n\t    {\n#if defined(UNIX) || (defined(VMS) && defined(USER_HOME))\n\t\t/*\n\t\t * Copy ~user to dst[], so we can put a NUL after it.\n\t\t */\n\t\ttail = src;\n\t\tvar = dst;\n\t\tc = dstlen - 1;\n\t\twhile (\t   c-- > 0\n\t\t\t&& *tail\n\t\t\t&& vim_isfilec(*tail)\n\t\t\t&& !vim_ispathsep(*tail))\n\t\t    *var++ = *tail++;\n\t\t*var = NUL;\n# ifdef UNIX\n\t\t/*\n\t\t * If the system supports getpwnam(), use it.\n\t\t * Otherwise, or if getpwnam() fails, the shell is used to\n\t\t * expand ~user.  This is slower and may fail if the shell\n\t\t * does not support ~user (old versions of /bin/sh).\n\t\t */\n#  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)\n\t\t{\n\t\t    // Note: memory allocated by getpwnam() is never freed.\n\t\t    // Calling endpwent() apparently doesn't help.\n\t\t    struct passwd *pw = (*dst == NUL)\n\t\t\t\t\t? NULL : getpwnam((char *)dst + 1);\n\n\t\t    var = (pw == NULL) ? NULL : (char_u *)pw->pw_dir;\n\t\t}\n\t\tif (var == NULL)\n#  endif\n\t\t{\n\t\t    expand_T\txpc;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    var = ExpandOne(&xpc, dst, NULL,\n\t\t\t\tWILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);\n\t\t    mustfree = TRUE;\n\t\t}\n\n# else\t// !UNIX, thus VMS\n\t\t/*\n\t\t * USER_HOME is a comma-separated list of\n\t\t * directories to search for the user account in.\n\t\t */\n\t\t{\n\t\t    char_u\ttest[MAXPATHL], paths[MAXPATHL];\n\t\t    char_u\t*path, *next_path, *ptr;\n\t\t    stat_T\tst;\n\n\t\t    STRCPY(paths, USER_HOME);\n\t\t    next_path = paths;\n\t\t    while (*next_path)\n\t\t    {\n\t\t\tfor (path = next_path; *next_path && *next_path != ',';\n\t\t\t\tnext_path++);\n\t\t\tif (*next_path)\n\t\t\t    *next_path++ = NUL;\n\t\t\tSTRCPY(test, path);\n\t\t\tSTRCAT(test, \"/\");\n\t\t\tSTRCAT(test, dst + 1);\n\t\t\tif (mch_stat(test, &st) == 0)\n\t\t\t{\n\t\t\t    var = alloc(STRLEN(test) + 1);\n\t\t\t    STRCPY(var, test);\n\t\t\t    mustfree = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n# endif // UNIX\n#else\n\t\t// cannot expand user's home directory, so don't try\n\t\tvar = NULL;\n\t\ttail = (char_u *)\"\";\t// for gcc\n#endif // UNIX || VMS\n\t    }\n\n#ifdef BACKSLASH_IN_FILENAME\n\t    // If 'shellslash' is set change backslashes to forward slashes.\n\t    // Can't use slash_adjust(), p_ssl may be set temporarily.\n\t    if (p_ssl && var != NULL && vim_strchr(var, '\\\\') != NULL)\n\t    {\n\t\tchar_u\t*p = vim_strsave(var);\n\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (mustfree)\n\t\t\tvim_free(var);\n\t\t    var = p;\n\t\t    mustfree = TRUE;\n\t\t    forward_slash(var);\n\t\t}\n\t    }\n#endif\n\n\t    // If \"var\" contains white space, escape it with a backslash.\n\t    // Required for \":e ~/tt\" when $HOME includes a space.\n\t    if (esc && var != NULL && vim_strpbrk(var, (char_u *)\" \\t\") != NULL)\n\t    {\n\t\tchar_u\t*p = vim_strsave_escaped(var, (char_u *)\" \\t\");\n\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (mustfree)\n\t\t\tvim_free(var);\n\t\t    var = p;\n\t\t    mustfree = TRUE;\n\t\t}\n\t    }\n\n\t    if (var != NULL && *var != NUL\n\t\t    && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen))\n\t    {\n\t\tSTRCPY(dst, var);\n\t\tdstlen -= (int)STRLEN(var);\n\t\tc = (int)STRLEN(var);\n\t\t// if var[] ends in a path separator and tail[] starts\n\t\t// with it, skip a character\n\t\tif (after_pathsep(dst, dst + c)\n#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)\n\t\t\t&& (dst == save_dst || dst[-1] != ':')\n#endif\n\t\t\t&& vim_ispathsep(*tail))\n\t\t    ++tail;\n\t\tdst += c;\n\t\tsrc = tail;\n\t\tcopy_char = FALSE;\n\t    }\n\t    if (mustfree)\n\t\tvim_free(var);\n\t}\n\n\tif (copy_char)\t    // copy at least one char\n\t{\n\t    /*\n\t     * Recognize the start of a new name, for '~'.\n\t     * Don't do this when \"one\" is TRUE, to avoid expanding \"~\" in\n\t     * \":edit foo ~ foo\".\n\t     */\n\t    at_start = FALSE;\n\t    if (src[0] == '\\\\' && src[1] != NUL)\n\t    {\n\t\t*dst++ = *src++;\n\t\t--dstlen;\n\t    }\n\t    else if ((src[0] == ' ' || src[0] == ',') && !one)\n\t\tat_start = TRUE;\n\t    if (dstlen > 0)\n\t    {\n\t\t*dst++ = *src++;\n\t\t--dstlen;\n\n\t\tif (startstr != NULL && src - startstr_len >= srcp\n\t\t\t&& STRNCMP(src - startstr_len, startstr,\n\t\t\t\t\t\t\t    startstr_len) == 0)\n\t\t    at_start = TRUE;\n\t    }\n\t}\n\n    }\n    *dst = NUL;\n}\n\n/*\n * If the string between \"p\" and \"pend\" ends in \"name/\", return \"pend\" minus\n * the length of \"name/\".  Otherwise return \"pend\".\n */\n    static char_u *\nremove_tail(char_u *p, char_u *pend, char_u *name)\n{\n    int\t\tlen = (int)STRLEN(name) + 1;\n    char_u\t*newend = pend - len;\n\n    if (newend >= p\n\t    && fnamencmp(newend, name, len - 1) == 0\n\t    && (newend == p || after_pathsep(p, newend)))\n\treturn newend;\n    return pend;\n}\n\n/*\n * Check if the directory \"vimdir/<version>\" or \"vimdir/runtime\" exists.\n * Return NULL if not, return its name in allocated memory otherwise.\n */\n    static char_u *\nvim_version_dir(char_u *vimdir)\n{\n    char_u\t*p;\n\n    if (vimdir == NULL || *vimdir == NUL)\n\treturn NULL;\n    p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, TRUE);\n    if (p != NULL && mch_isdir(p))\n\treturn p;\n    vim_free(p);\n    p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, TRUE);\n    if (p != NULL && mch_isdir(p))\n    {\n\tchar_u *fname = concat_fnames(p, (char_u *)\"defaults.vim\", TRUE);\n\n\t// Check that \"defaults.vim\" exists in this directory, to avoid picking\n\t// up a stray \"runtime\" directory, it would make many tests fail in\n\t// mysterious ways.\n\tif (fname != NULL)\n\t{\n\t    int exists = file_is_readable(fname);\n\n\t    vim_free(fname);\n\t    if (exists)\n\t\treturn p;\n\t}\n    }\n    vim_free(p);\n    return NULL;\n}\n\n/*\n * Vim's version of getenv().\n * Special handling of $HOME, $VIM and $VIMRUNTIME.\n * Also does ACP to 'enc' conversion for Win32.\n * \"mustfree\" is set to TRUE when the returned string is allocated.  It must be\n * initialized to FALSE by the caller.\n */\n    char_u *\nvim_getenv(char_u *name, int *mustfree)\n{\n    char_u\t*p = NULL;\n    char_u\t*pend;\n    int\t\tvimruntime;\n#ifdef MSWIN\n    WCHAR\t*wn, *wp;\n\n    // use \"C:/\" when $HOME is not set\n    if (STRCMP(name, \"HOME\") == 0)\n\treturn homedir;\n\n    // Use Wide function\n    wn = enc_to_utf16(name, NULL);\n    if (wn == NULL)\n\treturn NULL;\n\n    wp = _wgetenv(wn);\n    vim_free(wn);\n\n    if (wp != NULL && *wp == NUL)   // empty is the same as not set\n\twp = NULL;\n\n    if (wp != NULL)\n    {\n\tp = utf16_to_enc(wp, NULL);\n\tif (p == NULL)\n\t    return NULL;\n\n\t*mustfree = TRUE;\n\treturn p;\n    }\n#else\n    p = mch_getenv(name);\n    if (p != NULL && *p == NUL)\t    // empty is the same as not set\n\tp = NULL;\n\n    if (p != NULL)\n\treturn p;\n\n# ifdef __HAIKU__\n    // special handling for user settings directory...\n    if (STRCMP(name, \"BE_USER_SETTINGS\") == 0)\n    {\n\tstatic char userSettingsPath[MAXPATHL];\n\n\tif (find_directory(B_USER_SETTINGS_DIRECTORY, 0, false,\n\t\t\t\t\t   userSettingsPath, MAXPATHL) == B_OK)\n\t    return (char_u *)userSettingsPath;\n\telse\n\t    return NULL;\n    }\n# endif\n#endif\n\n    // handling $VIMRUNTIME and $VIM is below, bail out if it's another name.\n    vimruntime = (STRCMP(name, \"VIMRUNTIME\") == 0);\n    if (!vimruntime && STRCMP(name, \"VIM\") != 0)\n\treturn NULL;\n\n    /*\n     * When expanding $VIMRUNTIME fails, try using $VIM/vim<version> or $VIM.\n     * Don't do this when default_vimruntime_dir is non-empty.\n     */\n    if (vimruntime\n#ifdef HAVE_PATHDEF\n\t    && *default_vimruntime_dir == NUL\n#endif\n       )\n    {\n#ifdef MSWIN\n\t// Use Wide function\n\twp = _wgetenv(L\"VIM\");\n\tif (wp != NULL && *wp == NUL)\t    // empty is the same as not set\n\t    wp = NULL;\n\tif (wp != NULL)\n\t{\n\t    char_u *q = utf16_to_enc(wp, NULL);\n\t    if (q != NULL)\n\t    {\n\t\tp = vim_version_dir(q);\n\t\t*mustfree = TRUE;\n\t\tif (p == NULL)\n\t\t    p = q;\n\t    }\n\t}\n#else\n\tp = mch_getenv((char_u *)\"VIM\");\n\tif (p != NULL && *p == NUL)\t    // empty is the same as not set\n\t    p = NULL;\n\tif (p != NULL)\n\t{\n\t    p = vim_version_dir(p);\n\t    if (p != NULL)\n\t\t*mustfree = TRUE;\n\t    else\n\t\tp = mch_getenv((char_u *)\"VIM\");\n\t}\n#endif\n    }\n\n    /*\n     * When expanding $VIM or $VIMRUNTIME fails, try using:\n     * - the directory name from 'helpfile' (unless it contains '$')\n     * - the executable name from argv[0]\n     */\n    if (p == NULL)\n    {\n\tif (p_hf != NULL && vim_strchr(p_hf, '$') == NULL)\n\t    p = p_hf;\n#ifdef USE_EXE_NAME\n\t/*\n\t * Use the name of the executable, obtained from argv[0].\n\t */\n\telse\n\t    p = exe_name;\n#endif\n\tif (p != NULL)\n\t{\n\t    // remove the file name\n\t    pend = gettail(p);\n\n\t    // remove \"doc/\" from 'helpfile', if present\n\t    if (p == p_hf)\n\t\tpend = remove_tail(p, pend, (char_u *)\"doc\");\n\n#ifdef USE_EXE_NAME\n# ifdef MACOS_X\n\t    // remove \"MacOS\" from exe_name and add \"Resources/vim\"\n\t    if (p == exe_name)\n\t    {\n\t\tchar_u\t*pend1;\n\t\tchar_u\t*pnew;\n\n\t\tpend1 = remove_tail(p, pend, (char_u *)\"MacOS\");\n\t\tif (pend1 != pend)\n\t\t{\n\t\t    pnew = alloc(pend1 - p + 15);\n\t\t    if (pnew != NULL)\n\t\t    {\n\t\t\tSTRNCPY(pnew, p, (pend1 - p));\n\t\t\tSTRCPY(pnew + (pend1 - p), \"Resources/vim\");\n\t\t\tp = pnew;\n\t\t\tpend = p + STRLEN(p);\n\t\t    }\n\t\t}\n\t    }\n# endif\n\t    // remove \"src/\" from exe_name, if present\n\t    if (p == exe_name)\n\t\tpend = remove_tail(p, pend, (char_u *)\"src\");\n#endif\n\n\t    // for $VIM, remove \"runtime/\" or \"vim54/\", if present\n\t    if (!vimruntime)\n\t    {\n\t\tpend = remove_tail(p, pend, (char_u *)RUNTIME_DIRNAME);\n\t\tpend = remove_tail(p, pend, (char_u *)VIM_VERSION_NODOT);\n\t    }\n\n\t    // remove trailing path separator\n\t    if (pend > p && after_pathsep(p, pend))\n\t\t--pend;\n\n#ifdef MACOS_X\n\t    if (p == exe_name || p == p_hf)\n#endif\n\t\t// check that the result is a directory name\n\t\tp = vim_strnsave(p, pend - p);\n\n\t    if (p != NULL && !mch_isdir(p))\n\t\tVIM_CLEAR(p);\n\t    else\n\t    {\n#ifdef USE_EXE_NAME\n\t\t// may add \"/vim54\" or \"/runtime\" if it exists\n\t\tif (vimruntime && (pend = vim_version_dir(p)) != NULL)\n\t\t{\n\t\t    vim_free(p);\n\t\t    p = pend;\n\t\t}\n#endif\n\t\t*mustfree = TRUE;\n\t    }\n\t}\n    }\n\n#ifdef HAVE_PATHDEF\n    // When there is a pathdef.c file we can use default_vim_dir and\n    // default_vimruntime_dir\n    if (p == NULL)\n    {\n\t// Only use default_vimruntime_dir when it is not empty\n\tif (vimruntime && *default_vimruntime_dir != NUL)\n\t{\n\t    p = default_vimruntime_dir;\n\t    *mustfree = FALSE;\n\t}\n\telse if (*default_vim_dir != NUL)\n\t{\n\t    if (vimruntime && (p = vim_version_dir(default_vim_dir)) != NULL)\n\t\t*mustfree = TRUE;\n\t    else\n\t    {\n\t\tp = default_vim_dir;\n\t\t*mustfree = FALSE;\n\t    }\n\t}\n    }\n#endif\n\n    /*\n     * Set the environment variable, so that the new value can be found fast\n     * next time, and others can also use it (e.g. Perl).\n     */\n    if (p != NULL)\n    {\n\tif (vimruntime)\n\t{\n\t    vim_setenv((char_u *)\"VIMRUNTIME\", p);\n\t    didset_vimruntime = TRUE;\n\t}\n\telse\n\t{\n\t    vim_setenv((char_u *)\"VIM\", p);\n\t    didset_vim = TRUE;\n\t}\n    }\n    return p;\n}\n\n    void\nvim_unsetenv(char_u *var)\n{\n#ifdef HAVE_UNSETENV\n    unsetenv((char *)var);\n#else\n    vim_setenv(var, (char_u *)\"\");\n#endif\n}\n\n/*\n * Removes environment variable \"name\" and take care of side effects.\n */\n    void\nvim_unsetenv_ext(char_u *var)\n{\n    vim_unsetenv(var);\n\n    // \"homedir\" is not cleared, keep using the old value until $HOME is set.\n    if (STRICMP(var, \"VIM\") == 0)\n\tdidset_vim = FALSE;\n    else if (STRICMP(var, \"VIMRUNTIME\") == 0)\n\tdidset_vimruntime = FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Set environment variable \"name\" and take care of side effects.\n */\n    void\nvim_setenv_ext(char_u *name, char_u *val)\n{\n    vim_setenv(name, val);\n    if (STRICMP(name, \"HOME\") == 0)\n\tinit_homedir();\n    else if (didset_vim && STRICMP(name, \"VIM\") == 0)\n\tdidset_vim = FALSE;\n    else if (didset_vimruntime && STRICMP(name, \"VIMRUNTIME\") == 0)\n\tdidset_vimruntime = FALSE;\n}\n#endif\n\n/*\n * Our portable version of setenv.\n */\n    void\nvim_setenv(char_u *name, char_u *val)\n{\n#ifdef HAVE_SETENV\n    mch_setenv((char *)name, (char *)val, 1);\n#else\n    char_u\t*envbuf;\n\n    /*\n     * Putenv does not copy the string, it has to remain\n     * valid.  The allocated memory will never be freed.\n     */\n    envbuf = alloc(STRLEN(name) + STRLEN(val) + 2);\n    if (envbuf != NULL)\n    {\n\tsprintf((char *)envbuf, \"%s=%s\", name, val);\n\tputenv((char *)envbuf);\n    }\n#endif\n#ifdef FEAT_GETTEXT\n    /*\n     * When setting $VIMRUNTIME adjust the directory to find message\n     * translations to $VIMRUNTIME/lang.\n     */\n    if (*val != NUL && STRICMP(name, \"VIMRUNTIME\") == 0)\n    {\n\tchar_u\t*buf = concat_str(val, (char_u *)\"/lang\");\n\n\tif (buf != NULL)\n\t{\n\t    bindtextdomain(VIMPACKAGE, (char *)buf);\n\t    vim_free(buf);\n\t}\n    }\n#endif\n}\n\n/*\n * Function given to ExpandGeneric() to obtain an environment variable name.\n */\n    char_u *\nget_env_name(\n    expand_T\t*xp UNUSED,\n    int\t\tidx)\n{\n#if defined(AMIGA)\n    // No environ[] on the Amiga.\n    return NULL;\n#else\n# ifndef __WIN32__\n    // Borland C++ 5.2 has this in a header file.\n    extern char\t\t**environ;\n# endif\n    char_u\t\t*str;\n    int\t\t\tn;\n\n    str = (char_u *)environ[idx];\n    if (str == NULL)\n\treturn NULL;\n\n    for (n = 0; n < EXPAND_BUF_LEN - 1; ++n)\n    {\n\tif (str[n] == '=' || str[n] == NUL)\n\t    break;\n\txp->xp_buf[n] = str[n];\n    }\n    xp->xp_buf[n] = NUL;\n    return xp->xp_buf;\n#endif\n}\n\n/*\n * Add a user name to the list of users in ga_users.\n * Do nothing if user name is NULL or empty.\n */\n    static void\nadd_user(char_u *user, int need_copy)\n{\n    char_u\t*user_copy = (user != NULL && need_copy)\n\t\t\t\t\t\t    ? vim_strsave(user) : user;\n\n    if (user_copy == NULL || *user_copy == NUL || ga_grow(&ga_users, 1) == FAIL)\n    {\n\tif (need_copy)\n\t    vim_free(user);\n\treturn;\n    }\n    ((char_u **)(ga_users.ga_data))[ga_users.ga_len++] = user_copy;\n}\n\n/*\n * Find all user names for user completion.\n * Done only once and then cached.\n */\n    static void\ninit_users(void)\n{\n    static int\tlazy_init_done = FALSE;\n\n    if (lazy_init_done)\n\treturn;\n\n    lazy_init_done = TRUE;\n    ga_init2(&ga_users, sizeof(char_u *), 20);\n\n# if defined(HAVE_GETPWENT) && defined(HAVE_PWD_H)\n    {\n\tstruct passwd*\tpw;\n\n\tsetpwent();\n\twhile ((pw = getpwent()) != NULL)\n\t    add_user((char_u *)pw->pw_name, TRUE);\n\tendpwent();\n    }\n# elif defined(MSWIN)\n    {\n\tDWORD\t\tnusers = 0, ntotal = 0, i;\n\tPUSER_INFO_0\tuinfo;\n\n\tif (NetUserEnum(NULL, 0, 0, (LPBYTE *) &uinfo, MAX_PREFERRED_LENGTH,\n\t\t\t\t       &nusers, &ntotal, NULL) == NERR_Success)\n\t{\n\t    for (i = 0; i < nusers; i++)\n\t\tadd_user(utf16_to_enc(uinfo[i].usri0_name, NULL), FALSE);\n\n\t    NetApiBufferFree(uinfo);\n\t}\n    }\n# endif\n# if defined(HAVE_GETPWNAM)\n    {\n\tchar_u\t*user_env = mch_getenv((char_u *)\"USER\");\n\n\t// The $USER environment variable may be a valid remote user name (NIS,\n\t// LDAP) not already listed by getpwent(), as getpwent() only lists\n\t// local user names.  If $USER is not already listed, check whether it\n\t// is a valid remote user name using getpwnam() and if it is, add it to\n\t// the list of user names.\n\n\tif (user_env != NULL && *user_env != NUL)\n\t{\n\t    int\ti;\n\n\t    for (i = 0; i < ga_users.ga_len; i++)\n\t    {\n\t\tchar_u\t*local_user = ((char_u **)ga_users.ga_data)[i];\n\n\t\tif (STRCMP(local_user, user_env) == 0)\n\t\t    break;\n\t    }\n\n\t    if (i == ga_users.ga_len)\n\t    {\n\t\tstruct passwd\t*pw = getpwnam((char *)user_env);\n\n\t\tif (pw != NULL)\n\t\t    add_user((char_u *)pw->pw_name, TRUE);\n\t    }\n\t}\n    }\n# endif\n}\n\n/*\n * Function given to ExpandGeneric() to obtain an user names.\n */\n    char_u*\nget_users(expand_T *xp UNUSED, int idx)\n{\n    init_users();\n    if (idx < ga_users.ga_len)\n\treturn ((char_u **)ga_users.ga_data)[idx];\n    return NULL;\n}\n\n/*\n * Check whether name matches a user name. Return:\n * 0 if name does not match any user name.\n * 1 if name partially matches the beginning of a user name.\n * 2 is name fully matches a user name.\n */\n    int\nmatch_user(char_u *name)\n{\n    int i;\n    int n = (int)STRLEN(name);\n    int result = 0;\n\n    init_users();\n    for (i = 0; i < ga_users.ga_len; i++)\n    {\n\tif (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)\n\t    return 2; // full match\n\tif (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)\n\t    result = 1; // partial match\n    }\n    return result;\n}\n\n    static void\nprepare_to_exit(void)\n{\n#if defined(SIGHUP) && defined(SIG_IGN)\n    // Ignore SIGHUP, because a dropped connection causes a read error, which\n    // makes Vim exit and then handling SIGHUP causes various reentrance\n    // problems.\n    mch_signal(SIGHUP, SIG_IGN);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui.dying = TRUE;\n\tout_trash();\t// trash any pending output\n    }\n    else\n#endif\n    {\n\twindgoto((int)Rows - 1, 0);\n\n\t/*\n\t * Switch terminal mode back now, so messages end up on the \"normal\"\n\t * screen (if there are two screens).\n\t */\n\tsettmode(TMODE_COOK);\n\tstoptermcap();\n\tout_flush();\n    }\n}\n\n/*\n * Preserve files and exit.\n * When called IObuff must contain a message.\n * NOTE: This may be called from deathtrap() in a signal handler, avoid unsafe\n * functions, such as allocating memory.\n */\n    void\npreserve_exit(void)\n{\n    buf_T\t*buf;\n\n    prepare_to_exit();\n\n    // Setting this will prevent free() calls.  That avoids calling free()\n    // recursively when free() was invoked with a bad pointer.\n    really_exiting = TRUE;\n\n    out_str(IObuff);\n    screen_start();\t\t    // don't know where cursor is now\n    out_flush();\n\n    ml_close_notmod();\t\t    // close all not-modified buffers\n\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)\n\t{\n\t    OUT_STR(\"Vim: preserving files...\\r\\n\");\n\t    screen_start();\t    // don't know where cursor is now\n\t    out_flush();\n\t    ml_sync_all(FALSE, FALSE);\t// preserve all swap files\n\t    break;\n\t}\n    }\n\n    ml_close_all(FALSE);\t    // close all memfiles, without deleting\n\n    OUT_STR(\"Vim: Finished.\\r\\n\");\n\n    getout(1);\n}\n\n/*\n * Check for CTRL-C pressed, but only once in a while.\n * Should be used instead of ui_breakcheck() for functions that check for\n * each line in the file.  Calling ui_breakcheck() each time takes too much\n * time, because it can be a system call.\n */\n\n#ifndef BREAKCHECK_SKIP\n# define BREAKCHECK_SKIP 1000\n#endif\n\nstatic int\tbreakcheck_count = 0;\n\n    void\nline_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n\n/*\n * Like line_breakcheck() but check 10 times less often.\n */\n    void\nfast_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP * 10)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n\n# if defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Like line_breakcheck() but check 100 times less often.\n */\n    void\nveryfast_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP * 100)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n#endif\n\n#if defined(VIM_BACKTICK) || defined(FEAT_EVAL) \\\n\t|| (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \\\n\t|| defined(PROTO)\n\n#ifndef SEEK_SET\n# define SEEK_SET 0\n#endif\n#ifndef SEEK_END\n# define SEEK_END 2\n#endif\n\n/*\n * Get the stdout of an external command.\n * If \"ret_len\" is NULL replace NUL characters with NL.  When \"ret_len\" is not\n * NULL store the length there.\n * Returns an allocated string, or NULL for error.\n */\n    char_u *\nget_cmd_output(\n    char_u\t*cmd,\n    char_u\t*infile,\t// optional input file name\n    int\t\tflags,\t\t// can be SHELL_SILENT\n    int\t\t*ret_len)\n{\n    char_u\t*tempname;\n    char_u\t*command;\n    char_u\t*buffer = NULL;\n    int\t\tlen;\n    int\t\ti = 0;\n    FILE\t*fd;\n\n    if (check_restricted() || check_secure())\n\treturn NULL;\n\n    // get a name for the temp file\n    if ((tempname = vim_tempname('o', FALSE)) == NULL)\n    {\n\temsg(_(e_cant_get_temp_file_name));\n\treturn NULL;\n    }\n\n    // Add the redirection stuff\n    command = make_filter_cmd(cmd, infile, tempname);\n    if (command == NULL)\n\tgoto done;\n\n    /*\n     * Call the shell to execute the command (errors are ignored).\n     * Don't check timestamps here.\n     */\n    ++no_check_timestamps;\n    call_shell(command, SHELL_DOOUT | SHELL_EXPAND | flags);\n    --no_check_timestamps;\n\n    vim_free(command);\n\n    /*\n     * read the names from the file into memory\n     */\n# ifdef VMS\n    // created temporary file is not always readable as binary\n    fd = mch_fopen((char *)tempname, \"r\");\n# else\n    fd = mch_fopen((char *)tempname, READBIN);\n# endif\n\n    // Not being able to seek means we can't read the file.\n    if (fd == NULL\n\t    || fseek(fd, 0L, SEEK_END) == -1\n\t    || (len = ftell(fd)) == -1\t\t// get size of temp file\n\t    || fseek(fd, 0L, SEEK_SET) == -1)\t// back to the start\n    {\n\tsemsg(_(e_cannot_read_from_str_2), tempname);\n\tif (fd != NULL)\n\t    fclose(fd);\n\tgoto done;\n    }\n\n    buffer = alloc(len + 1);\n    if (buffer != NULL)\n\ti = (int)fread((char *)buffer, (size_t)1, (size_t)len, fd);\n    fclose(fd);\n    mch_remove(tempname);\n    if (buffer == NULL)\n\tgoto done;\n#ifdef VMS\n    len = i;\t// VMS doesn't give us what we asked for...\n#endif\n    if (i != len)\n    {\n\tsemsg(_(e_cant_read_file_str), tempname);\n\tVIM_CLEAR(buffer);\n    }\n    else if (ret_len == NULL)\n    {\n\t// Change NUL into SOH, otherwise the string is truncated.\n\tfor (i = 0; i < len; ++i)\n\t    if (buffer[i] == NUL)\n\t\tbuffer[i] = 1;\n\n\tbuffer[len] = NUL;\t// make sure the buffer is terminated\n    }\n    else\n\t*ret_len = len;\n\ndone:\n    vim_free(tempname);\n    return buffer;\n}\n\n# if defined(FEAT_EVAL) || defined(PROTO)\n\n    static void\nget_cmd_output_as_rettv(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tretlist)\n{\n    char_u\t*res = NULL;\n    char_u\t*p;\n    char_u\t*infile = NULL;\n    int\t\terr = FALSE;\n    FILE\t*fd;\n    list_T\t*list = NULL;\n    int\t\tflags = SHELL_SILENT;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (check_restricted() || check_secure())\n\tgoto errret;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_or_number_or_list_arg(argvars, 1)\n\t\t\t\t\t\t\t\t      == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\t/*\n\t * Write the text to a temp file, to be used for input of the shell\n\t * command.\n\t */\n\tif ((infile = vim_tempname('i', TRUE)) == NULL)\n\t{\n\t    emsg(_(e_cant_get_temp_file_name));\n\t    goto errret;\n\t}\n\n\tfd = mch_fopen((char *)infile, WRITEBIN);\n\tif (fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), infile);\n\t    goto errret;\n\t}\n\tif (argvars[1].v_type == VAR_NUMBER)\n\t{\n\t    linenr_T\tlnum;\n\t    buf_T\t*buf;\n\n\t    buf = buflist_findnr(argvars[1].vval.v_number);\n\t    if (buf == NULL)\n\t    {\n\t\tsemsg(_(e_buffer_nr_does_not_exist), argvars[1].vval.v_number);\n\t\tfclose(fd);\n\t\tgoto errret;\n\t    }\n\n\t    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; lnum++)\n\t    {\n\t\tfor (p = ml_get_buf(buf, lnum, FALSE); *p != NUL; ++p)\n\t\t    if (putc(*p == '\\n' ? NUL : *p, fd) == EOF)\n\t\t    {\n\t\t\terr = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\tif (putc(NL, fd) == EOF)\n\t\t{\n\t\t    err = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    if (write_list(fd, argvars[1].vval.v_list, TRUE) == FAIL)\n\t\terr = TRUE;\n\t}\n\telse\n\t{\n\t    size_t\tlen;\n\t    char_u\tbuf[NUMBUFLEN];\n\n\t    p = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (p == NULL)\n\t    {\n\t\tfclose(fd);\n\t\tgoto errret;\t\t// type error; errmsg already given\n\t    }\n\t    len = STRLEN(p);\n\t    if (len > 0 && fwrite(p, len, 1, fd) != 1)\n\t\terr = TRUE;\n\t}\n\tif (fclose(fd) != 0)\n\t    err = TRUE;\n\tif (err)\n\t{\n\t    emsg(_(e_error_writing_temp_file));\n\t    goto errret;\n\t}\n    }\n\n    // Omit SHELL_COOKED when invoked with \":silent\".  Avoids that the shell\n    // echoes typeahead, that messes up the display.\n    if (!msg_silent)\n\tflags += SHELL_COOKED;\n\n    if (retlist)\n    {\n\tint\t\tlen;\n\tlistitem_T\t*li;\n\tchar_u\t\t*s = NULL;\n\tchar_u\t\t*start;\n\tchar_u\t\t*end;\n\tint\t\ti;\n\n\tres = get_cmd_output(tv_get_string(&argvars[0]), infile, flags, &len);\n\tif (res == NULL)\n\t    goto errret;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    goto errret;\n\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    start = res + i;\n\t    while (i < len && res[i] != NL)\n\t\t++i;\n\t    end = res + i;\n\n\t    s = alloc(end - start + 1);\n\t    if (s == NULL)\n\t\tgoto errret;\n\n\t    for (p = s; start < end; ++p, ++start)\n\t\t*p = *start == NUL ? NL : *start;\n\t    *p = NUL;\n\n\t    li = listitem_alloc();\n\t    if (li == NULL)\n\t    {\n\t\tvim_free(s);\n\t\tgoto errret;\n\t    }\n\t    li->li_tv.v_type = VAR_STRING;\n\t    li->li_tv.v_lock = 0;\n\t    li->li_tv.vval.v_string = s;\n\t    list_append(list, li);\n\t}\n\n\trettv_list_set(rettv, list);\n\tlist = NULL;\n    }\n    else\n    {\n\tres = get_cmd_output(tv_get_string(&argvars[0]), infile, flags, NULL);\n#ifdef USE_CRNL\n\t// translate <CR><NL> into <NL>\n\tif (res != NULL)\n\t{\n\t    char_u\t*s, *d;\n\n\t    d = res;\n\t    for (s = res; *s; ++s)\n\t    {\n\t\tif (s[0] == CAR && s[1] == NL)\n\t\t    ++s;\n\t\t*d++ = *s;\n\t    }\n\t    *d = NUL;\n\t}\n#endif\n\trettv->vval.v_string = res;\n\tres = NULL;\n    }\n\nerrret:\n    if (infile != NULL)\n    {\n\tmch_remove(infile);\n\tvim_free(infile);\n    }\n    if (res != NULL)\n\tvim_free(res);\n    if (list != NULL)\n\tlist_free(list);\n}\n\n/*\n * \"system()\" function\n */\n    void\nf_system(typval_T *argvars, typval_T *rettv)\n{\n    get_cmd_output_as_rettv(argvars, rettv, FALSE);\n}\n\n/*\n * \"systemlist()\" function\n */\n    void\nf_systemlist(typval_T *argvars, typval_T *rettv)\n{\n    get_cmd_output_as_rettv(argvars, rettv, TRUE);\n}\n# endif // FEAT_EVAL\n\n#endif\n\n/*\n * Return TRUE when need to go to Insert mode because of 'insertmode'.\n * Don't do this when still processing a command or a mapping.\n * Don't do this when inside a \":normal\" command.\n */\n    int\ngoto_im(void)\n{\n    return (p_im && stuff_empty() && typebuf_typed());\n}\n\n/*\n * Returns the isolated name of the shell in allocated memory:\n * - Skip beyond any path.  E.g., \"/usr/bin/csh -f\" -> \"csh -f\".\n * - Remove any argument.  E.g., \"csh -f\" -> \"csh\".\n * But don't allow a space in the path, so that this works:\n *   \"/usr/bin/csh --rcfile ~/.cshrc\"\n * But don't do that for Windows, it's common to have a space in the path.\n * Returns NULL when out of memory.\n */\n    char_u *\nget_isolated_shell_name(void)\n{\n    char_u *p;\n\n#ifdef MSWIN\n    p = gettail(p_sh);\n    p = vim_strnsave(p, skiptowhite(p) - p);\n#else\n    p = skiptowhite(p_sh);\n    if (*p == NUL)\n    {\n\t// No white space, use the tail.\n\tp = vim_strsave(gettail(p_sh));\n    }\n    else\n    {\n\tchar_u  *p1, *p2;\n\n\t// Find the last path separator before the space.\n\tp1 = p_sh;\n\tfor (p2 = p_sh; p2 < p; MB_PTR_ADV(p2))\n\t    if (vim_ispathsep(*p2))\n\t\tp1 = p2 + 1;\n\tp = vim_strnsave(p1, p - p1);\n    }\n#endif\n    return p;\n}\n\n/*\n * Check if the \"://\" of a URL is at the pointer, return URL_SLASH.\n * Also check for \":\\\\\", which MS Internet Explorer accepts, return\n * URL_BACKSLASH.\n */\n    int\npath_is_url(char_u *p)\n{\n    if (STRNCMP(p, \"://\", (size_t)3) == 0)\n\treturn URL_SLASH;\n    else if (STRNCMP(p, \":\\\\\\\\\", (size_t)3) == 0)\n\treturn URL_BACKSLASH;\n    return 0;\n}\n\n/*\n * Check if \"fname\" starts with \"name://\" or \"name:\\\\\".\n * Return URL_SLASH for \"name://\", URL_BACKSLASH for \"name:\\\\\".\n * Return zero otherwise.\n */\n    int\npath_with_url(char_u *fname)\n{\n    char_u *p;\n\n    // We accept alphabetic characters and a dash in scheme part.\n    // RFC 3986 allows for more, but it increases the risk of matching\n    // non-URL text.\n\n    // first character must be alpha\n    if (!ASCII_ISALPHA(*fname))\n\treturn 0;\n\n    // check body: alpha or dash\n    for (p = fname + 1; (ASCII_ISALPHA(*p) || (*p == '-')); ++p)\n\t;\n\n    // check last char is not a dash\n    if (p[-1] == '-')\n\treturn 0;\n\n    // \"://\" or \":\\\\\" must follow\n    return path_is_url(p);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the dictionary of v:event.\n * Save and clear the value in case it already has items.\n */\n    dict_T *\nget_v_event(save_v_event_T *sve)\n{\n    dict_T\t*v_event = get_vim_var_dict(VV_EVENT);\n\n    if (v_event->dv_hashtab.ht_used > 0)\n    {\n\t// recursive use of v:event, save, make empty and restore later\n\tsve->sve_did_save = TRUE;\n\tsve->sve_hashtab = v_event->dv_hashtab;\n\thash_init(&v_event->dv_hashtab);\n    }\n    else\n\tsve->sve_did_save = FALSE;\n    return v_event;\n}\n\n    void\nrestore_v_event(dict_T *v_event, save_v_event_T *sve)\n{\n    dict_free_contents(v_event);\n    if (sve->sve_did_save)\n\tv_event->dv_hashtab = sve->sve_hashtab;\n    else\n\thash_init(&v_event->dv_hashtab);\n}\n#endif\n\n/*\n * Fires a ModeChanged autocmd event if appropriate.\n */\n    void\nmay_trigger_modechanged(void)\n{\n#ifdef FEAT_EVAL\n    dict_T\t    *v_event;\n    save_v_event_T  save_v_event;\n    char_u\t    curr_mode[MODE_MAX_LENGTH];\n    char_u\t    pattern_buf[2 * MODE_MAX_LENGTH];\n\n    // Skip this when got_int is set, the autocommand will not be executed.\n    // Better trigger it next time.\n    if (!has_modechanged() || got_int)\n\treturn;\n\n    get_mode(curr_mode);\n    if (STRCMP(curr_mode, last_mode) == 0)\n\treturn;\n\n    v_event = get_v_event(&save_v_event);\n    (void)dict_add_string(v_event, \"new_mode\", curr_mode);\n    (void)dict_add_string(v_event, \"old_mode\", last_mode);\n    dict_set_items_ro(v_event);\n\n    // concatenate modes in format \"old_mode:new_mode\"\n    vim_snprintf((char *)pattern_buf, sizeof(pattern_buf), \"%s:%s\", last_mode,\n\t    curr_mode);\n\n    apply_autocmds(EVENT_MODECHANGED, pattern_buf, NULL, FALSE, curbuf);\n    STRCPY(last_mode, curr_mode);\n\n    restore_v_event(v_event, &save_v_event);\n#endif\n}\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\n  \" set 'encoding' to clear the word list\n  set encoding=utf-8\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\nfunc Test_z_equal_on_single_character()\n  \" this was decrementing the index below zero\n  new\n  norm a0\\\u0118\n  norm zW\n  norm \u0016z=\n\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_camelcase()\n  set spell spelloptions=camel\n  let words = [\n      \\ 'UPPER',\n      \\ 'lower',\n      \\ 'mixedCase',\n      \\ 'HTML',\n      \\ 'XMLHttpRequest',\n      \\ 'foo123bar',\n      \\ '12345678',\n      \\ 'HELLO123world',\n      \\]\n\n  for word in words\n    call assert_equal(['', ''],  spellbadword(word))\n  endfor\n\n  set spell& spelloptions&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E937:')\n\n  \" clean up\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spell_file_missing_bwipe()\n  \" this was using a window that was wiped out in a SpellFileMissing autocmd\n  set spelllang=xy\n  au SpellFileMissing * n0\n  set spell\n  au SpellFileMissing * bw\n  snext somefile\n\n  au! SpellFileMissing\n  bwipe!\n  set nospell spelllang=en\nendfunc\n\nfunc Test_spelldump()\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n  set spell spelllang=en\n  spellrare! emacs\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    spelldump\n\n    \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n    call assert_equal('/regions=usaucagbnz', getline(1))\n    call assert_notequal(0, search('^theater/1$'))    \" US English only.\n    call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n    call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n    call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n\n  set spell\n\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    redraw\n    spelldump!\n\n    \" :spelldump! includes the number of times a word was found while updating\n    \" the screen.\n    \" Common word count starts at 10, regular word count starts at 0.\n    call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n    call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n    call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n    call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellrepall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\nfunc Test_spell_dump_word_length()\n  \" this was running over MAXWLEN\n  new\n  noremap 0 0a0zW0000000\n  sil! norm \u00160z=0\u0018\u000b\n  sil norm 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n  sil! norm \u00160z=0\u0018\u000b\n\n  bwipe!\n  nunmap 0\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellsuggest_timeout()\n  set spellsuggest=timeout:30\n  set spellsuggest=timeout:-123\n  set spellsuggest=timeout:999999\n  call assert_fails('set spellsuggest=timeout', 'E474:')\n  call assert_fails('set spellsuggest=timeout:x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:-x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:--9', 'E474:')\nendfunc\n\nfunc Test_spellsuggest_visual_end_of_line()\n  let enc_save = &encoding\n  set encoding=iso8859\n\n  \" This was reading beyond the end of the line.\n  norm R00000000000\n  sil norm \u00160\n  sil! norm \u0016i00000)\n  sil! norm \u0016i00000)\n  call feedkeys(\"\\<CR>\")\n  norm z=\n\n  let &encoding = enc_save\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\", 'D')\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\", 'D')\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  bwipe!\n  set spellfile=\n  set spl&\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_spellsuggest_too_deep()\n  \" This was incrementing \"depth\" over MAXWLEN.\n  new\n  norm \u0016s000G00\u00fd000000000000\n  sil norm ..vzG................vvzG0     v z=\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_invalid()\n  \" This was adding a word with a 0x02 byte, which causes havoc.\n  enew\n  norm o0\n  sil! norm rzzWs00\u0002/\n  2\n  sil! norm VzGprzzW\n  sil! norm z=\n\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_slash()\n  \" This caused E1280.\n  new\n  norm afoo /\n  1\n  norm zG\n\n  bwipe!\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call test_override('alloc_lines', 1)\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell', 'D')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_screendump_spellcap()\n  CheckScreendump\n\n  let lines =<< trim END\n       call test_override('alloc_lines', 1)\n       call setline(1, [\n             \\ \"   This line has a sepll error. and missing caps and trailing spaces.   \",\n             \\ \"another missing cap here.\",\n             \\ \"\",\n             \\ \"and here.\",\n             \\ \"    \",\n             \\ \"and here.\"\n             \\ ])\n       set spell spelllang=en\n  END\n  call writefile(lines, 'XtestSpellCap', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellCap', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_2', {})\n\n  \" After adding word missing Cap in next line is updated\n  call term_sendkeys(buf, \"3GANot\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_3', {})\n\n  \" Deleting a full stop removes missing Cap in next line\n  call term_sendkeys(buf, \"5Gdd\\<C-L>k$x\")\n  call VerifyScreenDump(buf, 'Test_spell_4', {})\n\n  \" Undo also updates the next line (go to command line to remove message)\n  call term_sendkeys(buf, \"u:\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_5', {})\n\n  \" Folding an empty line does not remove Cap in next line\n  call term_sendkeys(buf, \"uzfk:\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_6', {})\n\n  \" Folding the end of a sentence does not remove Cap in next line\n  \" and editing a line does not remove Cap in current line\n  call term_sendkeys(buf, \"Jzfkk$x\")\n  call VerifyScreenDump(buf, 'Test_spell_7', {})\n\n  \" Cap is correctly applied in the first row of a window\n  call term_sendkeys(buf, \"\\<C-E>\\<C-L>\")\n  call VerifyScreenDump(buf, 'Test_spell_8', {})\n\n  \" Adding an empty line does not remove Cap in \"mod_bot\" area\n  call term_sendkeys(buf, \"zbO\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_9', {})\n\n  \" Multiple empty lines does not remove Cap in the line after\n  call term_sendkeys(buf, \"O\\<Esc>\\<C-L>\")\n  call VerifyScreenDump(buf, 'Test_spell_10', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_compatible()\n  CheckScreendump\n\n  let lines =<< trim END\n       call test_override('alloc_lines', 1)\n       call setline(1, [\n             \\ \"test \"->repeat(20),\n             \\ \"\",\n             \\ \"end\",\n             \\ ])\n       set spell cpo+=$\n  END\n  call writefile(lines, 'XtestSpellComp', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellComp', {'rows': 8})\n\n  call term_sendkeys(buf, \"51|C\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_1', {})\n\n  call term_sendkeys(buf, \"x\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_2', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * misc1.c: functions that didn't seem to fit elsewhere\n */\n\n#include \"vim.h\"\n#include \"version.h\"\n\n#if defined(__HAIKU__)\n# include <storage/FindDirectory.h>\n#endif\n\n#if defined(MSWIN)\n# include <lm.h>\n#endif\n\n#define URL_SLASH\t1\t\t// path_is_url() has found \"://\"\n#define URL_BACKSLASH\t2\t\t// path_is_url() has found \":\\\\\"\n\n// All user names (for ~user completion as done by shell).\nstatic garray_T\tga_users;\n\n/*\n * get_leader_len() returns the length in bytes of the prefix of the given\n * string which introduces a comment.  If this string is not a comment then\n * 0 is returned.\n * When \"flags\" is not NULL, it is set to point to the flags of the recognized\n * comment leader.\n * \"backward\" must be true for the \"O\" command.\n * If \"include_space\" is set, include trailing whitespace while calculating the\n * length.\n */\n    int\nget_leader_len(\n    char_u\t*line,\n    char_u\t**flags,\n    int\t\tbackward,\n    int\t\tinclude_space)\n{\n    int\t\ti, j;\n    int\t\tresult;\n    int\t\tgot_com = FALSE;\n    int\t\tfound_one;\n    char_u\tpart_buf[COM_MAX_LEN];\t// buffer for one option part\n    char_u\t*string;\t\t// pointer to comment string\n    char_u\t*list;\n    int\t\tmiddle_match_len = 0;\n    char_u\t*prev_list;\n    char_u\t*saved_flags = NULL;\n\n    result = i = 0;\n    while (VIM_ISWHITE(line[i]))    // leading white space is ignored\n\t++i;\n\n    /*\n     * Repeat to match several nested comment strings.\n     */\n    while (line[i] != NUL)\n    {\n\t/*\n\t * scan through the 'comments' option for a match\n\t */\n\tfound_one = FALSE;\n\tfor (list = curbuf->b_p_com; *list; )\n\t{\n\t    // Get one option part into part_buf[].  Advance \"list\" to next\n\t    // one.  Put \"string\" at start of string.\n\t    if (!got_com && flags != NULL)\n\t\t*flags = list;\t    // remember where flags started\n\t    prev_list = list;\n\t    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, \",\");\n\t    string = vim_strchr(part_buf, ':');\n\t    if (string == NULL)\t    // missing ':', ignore this part\n\t\tcontinue;\n\t    *string++ = NUL;\t    // isolate flags from string\n\n\t    // If we found a middle match previously, use that match when this\n\t    // is not a middle or end.\n\t    if (middle_match_len != 0\n\t\t    && vim_strchr(part_buf, COM_MIDDLE) == NULL\n\t\t    && vim_strchr(part_buf, COM_END) == NULL)\n\t\tbreak;\n\n\t    // When we already found a nested comment, only accept further\n\t    // nested comments.\n\t    if (got_com && vim_strchr(part_buf, COM_NEST) == NULL)\n\t\tcontinue;\n\n\t    // When 'O' flag present and using \"O\" command skip this one.\n\t    if (backward && vim_strchr(part_buf, COM_NOBACK) != NULL)\n\t\tcontinue;\n\n\t    // Line contents and string must match.\n\t    // When string starts with white space, must have some white space\n\t    // (but the amount does not need to match, there might be a mix of\n\t    // TABs and spaces).\n\t    if (VIM_ISWHITE(string[0]))\n\t    {\n\t\tif (i == 0 || !VIM_ISWHITE(line[i - 1]))\n\t\t    continue;  // missing white space\n\t\twhile (VIM_ISWHITE(string[0]))\n\t\t    ++string;\n\t    }\n\t    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)\n\t\t;\n\t    if (string[j] != NUL)\n\t\tcontinue;  // string doesn't match\n\n\t    // When 'b' flag used, there must be white space or an\n\t    // end-of-line after the string in the line.\n\t    if (vim_strchr(part_buf, COM_BLANK) != NULL\n\t\t\t   && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)\n\t\tcontinue;\n\n\t    // We have found a match, stop searching unless this is a middle\n\t    // comment. The middle comment can be a substring of the end\n\t    // comment in which case it's better to return the length of the\n\t    // end comment and its flags.  Thus we keep searching with middle\n\t    // and end matches and use an end match if it matches better.\n\t    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)\n\t    {\n\t\tif (middle_match_len == 0)\n\t\t{\n\t\t    middle_match_len = j;\n\t\t    saved_flags = prev_list;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (middle_match_len != 0 && j > middle_match_len)\n\t\t// Use this match instead of the middle match, since it's a\n\t\t// longer thus better match.\n\t\tmiddle_match_len = 0;\n\n\t    if (middle_match_len == 0)\n\t\ti += j;\n\t    found_one = TRUE;\n\t    break;\n\t}\n\n\tif (middle_match_len != 0)\n\t{\n\t    // Use the previously found middle match after failing to find a\n\t    // match with an end.\n\t    if (!got_com && flags != NULL)\n\t\t*flags = saved_flags;\n\t    i += middle_match_len;\n\t    found_one = TRUE;\n\t}\n\n\t// No match found, stop scanning.\n\tif (!found_one)\n\t    break;\n\n\tresult = i;\n\n\t// Include any trailing white space.\n\twhile (VIM_ISWHITE(line[i]))\n\t    ++i;\n\n\tif (include_space)\n\t    result = i;\n\n\t// If this comment doesn't nest, stop here.\n\tgot_com = TRUE;\n\tif (vim_strchr(part_buf, COM_NEST) == NULL)\n\t    break;\n    }\n    return result;\n}\n\n/*\n * Return the offset at which the last comment in line starts. If there is no\n * comment in the whole line, -1 is returned.\n *\n * When \"flags\" is not null, it is set to point to the flags describing the\n * recognized comment leader.\n */\n    int\nget_last_leader_offset(char_u *line, char_u **flags)\n{\n    int\t\tresult = -1;\n    int\t\ti, j;\n    int\t\tlower_check_bound = 0;\n    char_u\t*string;\n    char_u\t*com_leader;\n    char_u\t*com_flags;\n    char_u\t*list;\n    int\t\tfound_one;\n    char_u\tpart_buf[COM_MAX_LEN];\t// buffer for one option part\n\n    /*\n     * Repeat to match several nested comment strings.\n     */\n    i = (int)STRLEN(line);\n    while (--i >= lower_check_bound)\n    {\n\t/*\n\t * scan through the 'comments' option for a match\n\t */\n\tfound_one = FALSE;\n\tfor (list = curbuf->b_p_com; *list; )\n\t{\n\t    char_u *flags_save = list;\n\n\t    /*\n\t     * Get one option part into part_buf[].  Advance list to next one.\n\t     * put string at start of string.\n\t     */\n\t    (void)copy_option_part(&list, part_buf, COM_MAX_LEN, \",\");\n\t    string = vim_strchr(part_buf, ':');\n\t    if (string == NULL)\t// If everything is fine, this cannot actually\n\t\t\t\t// happen.\n\t\tcontinue;\n\t    *string++ = NUL;\t// Isolate flags from string.\n\t    com_leader = string;\n\n\t    /*\n\t     * Line contents and string must match.\n\t     * When string starts with white space, must have some white space\n\t     * (but the amount does not need to match, there might be a mix of\n\t     * TABs and spaces).\n\t     */\n\t    if (VIM_ISWHITE(string[0]))\n\t    {\n\t\tif (i == 0 || !VIM_ISWHITE(line[i - 1]))\n\t\t    continue;\n\t\twhile (VIM_ISWHITE(*string))\n\t\t    ++string;\n\t    }\n\t    for (j = 0; string[j] != NUL && string[j] == line[i + j]; ++j)\n\t\t/* do nothing */;\n\t    if (string[j] != NUL)\n\t\tcontinue;\n\n\t    /*\n\t     * When 'b' flag used, there must be white space or an\n\t     * end-of-line after the string in the line.\n\t     */\n\t    if (vim_strchr(part_buf, COM_BLANK) != NULL\n\t\t    && !VIM_ISWHITE(line[i + j]) && line[i + j] != NUL)\n\t\tcontinue;\n\n\t    if (vim_strchr(part_buf, COM_MIDDLE) != NULL)\n\t    {\n\t\t// For a middlepart comment, only consider it to match if\n\t\t// everything before the current position in the line is\n\t\t// whitespace.  Otherwise we would think we are inside a\n\t\t// comment if the middle part appears somewhere in the middle\n\t\t// of the line.  E.g. for C the \"*\" appears often.\n\t\tfor (j = 0; VIM_ISWHITE(line[j]) && j <= i; j++)\n\t\t    ;\n\t\tif (j < i)\n\t\t    continue;\n\t    }\n\n\t    /*\n\t     * We have found a match, stop searching.\n\t     */\n\t    found_one = TRUE;\n\n\t    if (flags)\n\t\t*flags = flags_save;\n\t    com_flags = flags_save;\n\n\t    break;\n\t}\n\n\tif (found_one)\n\t{\n\t    char_u  part_buf2[COM_MAX_LEN];\t// buffer for one option part\n\t    int     len1, len2, off;\n\n\t    result = i;\n\t    /*\n\t     * If this comment nests, continue searching.\n\t     */\n\t    if (vim_strchr(part_buf, COM_NEST) != NULL)\n\t\tcontinue;\n\n\t    lower_check_bound = i;\n\n\t    // Let's verify whether the comment leader found is a substring\n\t    // of other comment leaders. If it is, let's adjust the\n\t    // lower_check_bound so that we make sure that we have determined\n\t    // the comment leader correctly.\n\n\t    while (VIM_ISWHITE(*com_leader))\n\t\t++com_leader;\n\t    len1 = (int)STRLEN(com_leader);\n\n\t    for (list = curbuf->b_p_com; *list; )\n\t    {\n\t\tchar_u *flags_save = list;\n\n\t\t(void)copy_option_part(&list, part_buf2, COM_MAX_LEN, \",\");\n\t\tif (flags_save == com_flags)\n\t\t    continue;\n\t\tstring = vim_strchr(part_buf2, ':');\n\t\t++string;\n\t\twhile (VIM_ISWHITE(*string))\n\t\t    ++string;\n\t\tlen2 = (int)STRLEN(string);\n\t\tif (len2 == 0)\n\t\t    continue;\n\n\t\t// Now we have to verify whether string ends with a substring\n\t\t// beginning the com_leader.\n\t\tfor (off = (len2 > i ? i : len2); off > 0 && off + len1 > len2;)\n\t\t{\n\t\t    --off;\n\t\t    if (!STRNCMP(string + off, com_leader, len2 - off))\n\t\t    {\n\t\t\tif (i - off < lower_check_bound)\n\t\t\t    lower_check_bound = i - off;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    return result;\n}\n\n/*\n * Return the number of window lines occupied by buffer line \"lnum\".\n * Includes any filler lines.\n */\n    int\nplines(linenr_T lnum)\n{\n    return plines_win(curwin, lnum, TRUE);\n}\n\n    int\nplines_win(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    int\t\tlimit_winheight)\t// when TRUE limit to window height\n{\n#if defined(FEAT_DIFF) || defined(PROTO)\n    // Check for filler lines above this buffer line.  When folded the result\n    // is one line anyway.\n    return plines_win_nofill(wp, lnum, limit_winheight)\n\t\t\t\t\t\t   + diff_check_fill(wp, lnum);\n}\n\n/*\n * Return the number of window lines occupied by buffer line \"lnum\".\n * Does not include filler lines.\n */\n    int\nplines_nofill(linenr_T lnum)\n{\n    return plines_win_nofill(curwin, lnum, TRUE);\n}\n\n    int\nplines_win_nofill(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    int\t\tlimit_winheight)\t// when TRUE limit to window height\n{\n#endif\n    int\t\tlines;\n\n    if (wp->w_width == 0)\n\treturn 1;\n\n#ifdef FEAT_FOLDING\n    // Folded lines are handled just like an empty line.\n    // NOTE: Caller must handle lines that are MAYBE folded.\n    if (lineFolded(wp, lnum) == TRUE)\n\treturn 1;\n#endif\n\n    if (!wp->w_p_wrap)\n\tlines = 1\n#ifdef FEAT_PROP_POPUP\n\t    // add a line for each \"above\" and \"below\" aligned text property\n\t    + prop_count_above_below(wp->w_buffer, lnum)\n#endif\n\t;\n    else\n\tlines = plines_win_nofold(wp, lnum);\n\n    if (limit_winheight && lines > wp->w_height)\n\treturn wp->w_height;\n    return lines;\n}\n\n/*\n * Return number of window lines physical line \"lnum\" will occupy in window\n * \"wp\".  Does not care about folding, 'wrap' or 'diff'.\n */\n    int\nplines_win_nofold(win_T *wp, linenr_T lnum)\n{\n    char_u\t*s;\n    long\tcol;\n    int\t\twidth;\n    chartabsize_T cts;\n\n    s = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    init_chartabsize_arg(&cts, wp, lnum, 0, s, s);\n    if (*s == NUL\n#ifdef FEAT_PROP_POPUP\n\t    && !cts.cts_has_prop_with_text\n#endif\n\t    )\n\treturn 1; // be quick for an empty line\n    win_linetabsize_cts(&cts, (colnr_T)MAXCOL);\n    clear_chartabsize_arg(&cts);\n    col = (int)cts.cts_vcol;\n\n    // If list mode is on, then the '$' at the end of the line may take up one\n    // extra column.\n    if (wp->w_p_list && wp->w_lcs_chars.eol != NUL)\n\tcol += 1;\n\n    /*\n     * Add column offset for 'number', 'relativenumber' and 'foldcolumn'.\n     */\n    width = wp->w_width - win_col_off(wp);\n    if (width <= 0)\n\treturn 32000;\n    if (col <= width)\n\treturn 1;\n    col -= width;\n    width += win_col_off2(wp);\n    return (col + (width - 1)) / width + 1;\n}\n\n/*\n * Like plines_win(), but only reports the number of physical screen lines\n * used from the start of the line to the given column number.\n */\n    int\nplines_win_col(win_T *wp, linenr_T lnum, long column)\n{\n    long\tcol;\n    int\t\tlines = 0;\n    int\t\twidth;\n    char_u\t*line;\n    chartabsize_T cts;\n\n#ifdef FEAT_DIFF\n    // Check for filler lines above this buffer line.  When folded the result\n    // is one line anyway.\n    lines = diff_check_fill(wp, lnum);\n#endif\n\n    if (!wp->w_p_wrap)\n\treturn lines + 1;\n\n    if (wp->w_width == 0)\n\treturn lines + 1;\n\n    line = ml_get_buf(wp->w_buffer, lnum, FALSE);\n\n    init_chartabsize_arg(&cts, wp, lnum, 0, line, line);\n    while (*cts.cts_ptr != NUL && --column >= 0)\n    {\n\tcts.cts_vcol += win_lbr_chartabsize(&cts, NULL);\n\tMB_PTR_ADV(cts.cts_ptr);\n    }\n\n    /*\n     * If *cts.cts_ptr is a TAB, and the TAB is not displayed as ^I, and we're\n     * not in MODE_INSERT state, then col must be adjusted so that it\n     * represents the last screen position of the TAB.  This only fixes an\n     * error when the TAB wraps from one screen line to the next (when\n     * 'columns' is not a multiple of 'ts') -- webb.\n     */\n    col = cts.cts_vcol;\n    if (*cts.cts_ptr == TAB && (State & MODE_NORMAL)\n\t\t\t\t    && (!wp->w_p_list || wp->w_lcs_chars.tab1))\n\tcol += win_lbr_chartabsize(&cts, NULL) - 1;\n    clear_chartabsize_arg(&cts);\n\n    /*\n     * Add column offset for 'number', 'relativenumber', 'foldcolumn', etc.\n     */\n    width = wp->w_width - win_col_off(wp);\n    if (width <= 0)\n\treturn 9999;\n\n    lines += 1;\n    if (col > width)\n\tlines += (col - width) / (width + win_col_off2(wp)) + 1;\n    return lines;\n}\n\n    int\nplines_m_win(win_T *wp, linenr_T first, linenr_T last, int limit_winheight)\n{\n    int\t\tcount = 0;\n\n    while (first <= last)\n    {\n#ifdef FEAT_FOLDING\n\tint\tx;\n\n\t// Check if there are any really folded lines, but also included lines\n\t// that are maybe folded.\n\tx = foldedCount(wp, first, NULL);\n\tif (x > 0)\n\t{\n\t    ++count;\t    // count 1 for \"+-- folded\" line\n\t    first += x;\n\t}\n\telse\n#endif\n\t{\n#ifdef FEAT_DIFF\n\t    if (first == wp->w_topline)\n\t\tcount += plines_win_nofill(wp, first, limit_winheight)\n\t\t\t\t\t\t\t       + wp->w_topfill;\n\t    else\n#endif\n\t\tcount += plines_win(wp, first, limit_winheight);\n\t    ++first;\n\t}\n    }\n    return (count);\n}\n\n    int\ngchar_pos(pos_T *pos)\n{\n    char_u\t*ptr;\n\n    // When searching columns is sometimes put at the end of a line.\n    if (pos->col == MAXCOL)\n\treturn NUL;\n    ptr = ml_get_pos(pos);\n    if (has_mbyte)\n\treturn (*mb_ptr2char)(ptr);\n    return (int)*ptr;\n}\n\n    int\ngchar_cursor(void)\n{\n    if (has_mbyte)\n\treturn (*mb_ptr2char)(ml_get_cursor());\n    return (int)*ml_get_cursor();\n}\n\n/*\n * Write a character at the current cursor position.\n * It is directly written into the block.\n */\n    void\npchar_cursor(int c)\n{\n    *(ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE)\n\t\t\t\t\t\t  + curwin->w_cursor.col) = c;\n}\n\n/*\n * Skip to next part of an option argument: Skip space and comma.\n */\n    char_u *\nskip_to_option_part(char_u *p)\n{\n    if (*p == ',')\n\t++p;\n    while (*p == ' ')\n\t++p;\n    return p;\n}\n\n/*\n * check_status: called when the status bars for the buffer 'buf'\n *\t\t need to be updated\n */\n    void\ncheck_status(buf_T *buf)\n{\n    win_T\t*wp;\n\n    FOR_ALL_WINDOWS(wp)\n\tif (wp->w_buffer == buf && wp->w_status_height)\n\t{\n\t    wp->w_redr_status = TRUE;\n\t    set_must_redraw(UPD_VALID);\n\t}\n}\n\n/*\n * Ask for a reply from the user, a 'y' or a 'n', with prompt \"str\" (which\n * should have been translated already).\n * No other characters are accepted, the message is repeated until a valid\n * reply is entered or CTRL-C is hit.\n * If direct is TRUE, don't use vgetc() but ui_inchar(), don't get characters\n * from any buffers but directly from the user.\n *\n * return the 'y' or 'n'\n */\n    int\nask_yesno(char_u *str, int direct)\n{\n    int\t    r = ' ';\n    int\t    save_State = State;\n\n    if (exiting)\t\t// put terminal in raw mode for this question\n\tsettmode(TMODE_RAW);\n    ++no_wait_return;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    State = MODE_CONFIRM;\t// mouse behaves like with :confirm\n    setmouse();\t\t\t// disables mouse for xterm\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping here, but recognize keys\n\n    while (r != 'y' && r != 'n')\n    {\n\t// same highlighting as for wait_return()\n\tsmsg_attr(HL_ATTR(HLF_R), \"%s (y/n)?\", str);\n\tif (direct)\n\t    r = get_keystroke();\n\telse\n\t    r = plain_vgetc();\n\tif (r == Ctrl_C || r == ESC)\n\t    r = 'n';\n\tmsg_putchar(r);\t    // show what you typed\n\tout_flush();\n    }\n    --no_wait_return;\n    State = save_State;\n    setmouse();\n    --no_mapping;\n    --allow_keys;\n\n    return r;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n\n/*\n * Returns the current mode as a string in \"buf[MODE_MAX_LENGTH]\", NUL\n * terminated.\n * The first character represents the major mode, the following ones the minor\n * ones.\n */\n    void\nget_mode(char_u *buf)\n{\n    int\t\ti = 0;\n\n    if (time_for_testing == 93784)\n    {\n\t// Testing the two-character code.\n\tbuf[i++] = 'x';\n\tbuf[i++] = '!';\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_use_loop())\n    {\n\tif (State & MODE_CMDLINE)\n\t    buf[i++] = 'c';\n\tbuf[i++] = 't';\n    }\n#endif\n    else if (VIsual_active)\n    {\n\tif (VIsual_select)\n\t    buf[i++] = VIsual_mode + 's' - 'v';\n\telse\n\t{\n\t    buf[i++] = VIsual_mode;\n\t    if (restart_VIsual_select)\n\t\tbuf[i++] = 's';\n\t}\n    }\n    else if (State == MODE_HITRETURN || State == MODE_ASKMORE\n\t\t\t\t\t\t      || State == MODE_SETWSIZE\n\t\t|| State == MODE_CONFIRM)\n    {\n\tbuf[i++] = 'r';\n\tif (State == MODE_ASKMORE)\n\t    buf[i++] = 'm';\n\telse if (State == MODE_CONFIRM)\n\t    buf[i++] = '?';\n    }\n    else if (State == MODE_EXTERNCMD)\n\tbuf[i++] = '!';\n    else if (State & MODE_INSERT)\n    {\n\tif (State & VREPLACE_FLAG)\n\t{\n\t    buf[i++] = 'R';\n\t    buf[i++] = 'v';\n\t}\n\telse\n\t{\n\t    if (State & REPLACE_FLAG)\n\t\tbuf[i++] = 'R';\n\t    else\n\t\tbuf[i++] = 'i';\n\t}\n\n\tif (ins_compl_active())\n\t    buf[i++] = 'c';\n\telse if (ctrl_x_mode_not_defined_yet())\n\t    buf[i++] = 'x';\n    }\n    else if ((State & MODE_CMDLINE) || exmode_active)\n    {\n\tbuf[i++] = 'c';\n\tif (exmode_active == EXMODE_VIM)\n\t    buf[i++] = 'v';\n\telse if (exmode_active == EXMODE_NORMAL)\n\t    buf[i++] = 'e';\n    }\n    else\n    {\n\tbuf[i++] = 'n';\n\tif (finish_op)\n\t{\n\t    buf[i++] = 'o';\n\t    // to be able to detect force-linewise/blockwise/characterwise\n\t    // operations\n\t    buf[i++] = motion_force;\n\t}\n\telse if (restart_edit == 'I' || restart_edit == 'R'\n\t\t\t\t\t\t\t|| restart_edit == 'V')\n\t{\n\t    buf[i++] = 'i';\n\t    buf[i++] = restart_edit;\n\t}\n#ifdef FEAT_TERMINAL\n\telse if (term_in_normal_mode())\n\t    buf[i++] = 't';\n#endif\n    }\n\n    buf[i] = NUL;\n}\n\n/*\n * \"mode()\" function\n */\n    void\nf_mode(typval_T *argvars, typval_T *rettv)\n{\n    char_u\tbuf[MODE_MAX_LENGTH];\n\n    if (in_vim9script() && check_for_opt_bool_arg(argvars, 0) == FAIL)\n\treturn;\n\n    get_mode(buf);\n\n    // Clear out the minor mode when the argument is not a non-zero number or\n    // non-empty string.\n    if (!non_zero_arg(&argvars[0]))\n\tbuf[1] = NUL;\n\n    rettv->vval.v_string = vim_strsave(buf);\n    rettv->v_type = VAR_STRING;\n}\n\n    static void\nmay_add_state_char(garray_T *gap, char_u *include, int c)\n{\n    if (include == NULL || vim_strchr(include, c) != NULL)\n\tga_append(gap, c);\n}\n\n/*\n * \"state()\" function\n */\n    void\nf_state(typval_T *argvars, typval_T *rettv)\n{\n    garray_T\tga;\n    char_u\t*include = NULL;\n    int\t\ti;\n\n    if (in_vim9script() && check_for_opt_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    ga_init2(&ga, 1, 20);\n    if (argvars[0].v_type != VAR_UNKNOWN)\n\tinclude = tv_get_string(&argvars[0]);\n\n    if (!(stuff_empty() && typebuf.tb_len == 0 && scriptin[curscript] == NULL))\n\tmay_add_state_char(&ga, include, 'm');\n    if (op_pending())\n\tmay_add_state_char(&ga, include, 'o');\n    if (autocmd_busy)\n\tmay_add_state_char(&ga, include, 'x');\n    if (ins_compl_active())\n\tmay_add_state_char(&ga, include, 'a');\n\n# ifdef FEAT_JOB_CHANNEL\n    if (channel_in_blocking_wait())\n\tmay_add_state_char(&ga, include, 'w');\n# endif\n    if (!get_was_safe_state())\n\tmay_add_state_char(&ga, include, 'S');\n    for (i = 0; i < get_callback_depth() && i < 3; ++i)\n\tmay_add_state_char(&ga, include, 'c');\n    if (msg_scrolled > 0)\n\tmay_add_state_char(&ga, include, 's');\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = ga.ga_data;\n}\n\n#endif // FEAT_EVAL\n\n/*\n * Get a key stroke directly from the user.\n * Ignores mouse clicks and scrollbar events, except a click for the left\n * button (used at the more prompt).\n * Doesn't use vgetc(), because it syncs undo and eats mapped characters.\n * Disadvantage: typeahead is ignored.\n * Translates the interrupt character for unix to ESC.\n */\n    int\nget_keystroke(void)\n{\n    char_u\t*buf = NULL;\n    int\t\tbuflen = 150;\n    int\t\tmaxlen;\n    int\t\tlen = 0;\n    int\t\tn;\n    int\t\tsave_mapped_ctrl_c = mapped_ctrl_c;\n    int\t\twaited = 0;\n\n    mapped_ctrl_c = FALSE;\t// mappings are not used here\n    for (;;)\n    {\n\tcursor_on();\n\tout_flush();\n\n\t// Leave some room for check_termcode() to insert a key code into (max\n\t// 5 chars plus NUL).  And fix_input_buffer() can triple the number of\n\t// bytes.\n\tmaxlen = (buflen - 6 - len) / 3;\n\tif (buf == NULL)\n\t    buf = alloc(buflen);\n\telse if (maxlen < 10)\n\t{\n\t    char_u  *t_buf = buf;\n\n\t    // Need some more space. This might happen when receiving a long\n\t    // escape sequence.\n\t    buflen += 100;\n\t    buf = vim_realloc(buf, buflen);\n\t    if (buf == NULL)\n\t\tvim_free(t_buf);\n\t    maxlen = (buflen - 6 - len) / 3;\n\t}\n\tif (buf == NULL)\n\t{\n\t    do_outofmem_msg((long_u)buflen);\n\t    return ESC;  // panic!\n\t}\n\n\t// First time: blocking wait.  Second time: wait up to 100ms for a\n\t// terminal code to complete.\n\tn = ui_inchar(buf + len, maxlen, len == 0 ? -1L : 100L, 0);\n\tif (n > 0)\n\t{\n\t    // Replace zero and CSI by a special key code.\n\t    n = fix_input_buffer(buf + len, n);\n\t    len += n;\n\t    waited = 0;\n\t}\n\telse if (len > 0)\n\t    ++waited;\t    // keep track of the waiting time\n\n\t// Incomplete termcode and not timed out yet: get more characters\n\tif ((n = check_termcode(1, buf, buflen, &len)) < 0\n\t       && (!p_ttimeout || waited * 100L < (p_ttm < 0 ? p_tm : p_ttm)))\n\t    continue;\n\n\tif (n == KEYLEN_REMOVED)  // key code removed\n\t{\n\t    if (must_redraw != 0 && !need_wait_return && (State\n\t\t\t& (MODE_CMDLINE | MODE_HITRETURN | MODE_ASKMORE)) == 0)\n\t    {\n\t\t// Redrawing was postponed, do it now.\n\t\tupdate_screen(0);\n\t\tsetcursor(); // put cursor back where it belongs\n\t    }\n\t    continue;\n\t}\n\tif (n > 0)\t\t// found a termcode: adjust length\n\t    len = n;\n\tif (len == 0)\t\t// nothing typed yet\n\t    continue;\n\n\t// Handle modifier and/or special key code.\n\tn = buf[0];\n\tif (n == K_SPECIAL)\n\t{\n\t    n = TO_SPECIAL(buf[1], buf[2]);\n\t    if (buf[1] == KS_MODIFIER\n\t\t    || n == K_IGNORE\n\t\t    || (is_mouse_key(n) && n != K_LEFTMOUSE)\n#ifdef FEAT_GUI\n\t\t    || n == K_VER_SCROLLBAR\n\t\t    || n == K_HOR_SCROLLBAR\n#endif\n\t       )\n\t    {\n\t\tif (buf[1] == KS_MODIFIER)\n\t\t    mod_mask = buf[2];\n\t\tlen -= 3;\n\t\tif (len > 0)\n\t\t    mch_memmove(buf, buf + 3, (size_t)len);\n\t\tcontinue;\n\t    }\n\t    break;\n\t}\n\tif (has_mbyte)\n\t{\n\t    if (MB_BYTE2LEN(n) > len)\n\t\tcontinue;\t// more bytes to get\n\t    buf[len >= buflen ? buflen - 1 : len] = NUL;\n\t    n = (*mb_ptr2char)(buf);\n\t}\n#ifdef UNIX\n\tif (n == intr_char)\n\t    n = ESC;\n#endif\n\tbreak;\n    }\n    vim_free(buf);\n\n    mapped_ctrl_c = save_mapped_ctrl_c;\n    return n;\n}\n\n/*\n * Get a number from the user.\n * When \"mouse_used\" is not NULL allow using the mouse.\n */\n    int\nget_number(\n    int\t    colon,\t\t\t// allow colon to abort\n    int\t    *mouse_used)\n{\n    int\tn = 0;\n    int\tc;\n    int typed = 0;\n\n    if (mouse_used != NULL)\n\t*mouse_used = FALSE;\n\n    // When not printing messages, the user won't know what to type, return a\n    // zero (as if CR was hit).\n    if (msg_silent != 0)\n\treturn 0;\n\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n    ++no_mapping;\n    ++allow_keys;\t\t// no mapping here, but recognize keys\n    for (;;)\n    {\n\twindgoto(msg_row, msg_col);\n\tc = safe_vgetc();\n\tif (VIM_ISDIGIT(c))\n\t{\n\t    if (n > INT_MAX / 10)\n\t\treturn 0;\n\t    n = n * 10 + c - '0';\n\t    msg_putchar(c);\n\t    ++typed;\n\t}\n\telse if (c == K_DEL || c == K_KDEL || c == K_BS || c == Ctrl_H)\n\t{\n\t    if (typed > 0)\n\t    {\n\t\tmsg_puts(\"\\b \\b\");\n\t\t--typed;\n\t    }\n\t    n /= 10;\n\t}\n\telse if (mouse_used != NULL && c == K_LEFTMOUSE)\n\t{\n\t    *mouse_used = TRUE;\n\t    n = mouse_row + 1;\n\t    break;\n\t}\n\telse if (n == 0 && c == ':' && colon)\n\t{\n\t    stuffcharReadbuff(':');\n\t    if (!exmode_active)\n\t\tcmdline_row = msg_row;\n\t    skip_redraw = TRUE;\t    // skip redraw once\n\t    do_redraw = FALSE;\n\t    break;\n\t}\n\telse if (c == Ctrl_C || c == ESC || c == 'q')\n\t{\n\t    n = 0;\n\t    break;\n\t}\n\telse if (c == CAR || c == NL )\n\t    break;\n    }\n    --no_mapping;\n    --allow_keys;\n    return n;\n}\n\n/*\n * Ask the user to enter a number.\n * When \"mouse_used\" is not NULL allow using the mouse and in that case return\n * the line number.\n */\n    int\nprompt_for_number(int *mouse_used)\n{\n    int\t\ti;\n    int\t\tsave_cmdline_row;\n    int\t\tsave_State;\n\n    // When using \":silent\" assume that <CR> was entered.\n    if (mouse_used != NULL)\n\tmsg_puts(_(\"Type number and <Enter> or click with the mouse (q or empty cancels): \"));\n    else\n\tmsg_puts(_(\"Type number and <Enter> (q or empty cancels): \"));\n\n    // Set the state such that text can be selected/copied/pasted and we still\n    // get mouse events. redraw_after_callback() will not redraw if cmdline_row\n    // is zero.\n    save_cmdline_row = cmdline_row;\n    cmdline_row = 0;\n    save_State = State;\n    State = MODE_CMDLINE;\n    // May show different mouse shape.\n    setmouse();\n\n    i = get_number(TRUE, mouse_used);\n    if (KeyTyped)\n    {\n\t// don't call wait_return() now\n\tif (msg_row > 0)\n\t    cmdline_row = msg_row - 1;\n\tneed_wait_return = FALSE;\n\tmsg_didany = FALSE;\n\tmsg_didout = FALSE;\n    }\n    else\n\tcmdline_row = save_cmdline_row;\n    State = save_State;\n    // May need to restore mouse shape.\n    setmouse();\n\n    return i;\n}\n\n    void\nmsgmore(long n)\n{\n    long pn;\n\n    if (global_busy\t    // no messages now, wait until global is finished\n\t    || !messaging())  // 'lazyredraw' set, don't do messages now\n\treturn;\n\n    // We don't want to overwrite another important message, but do overwrite\n    // a previous \"more lines\" or \"fewer lines\" message, so that \"5dd\" and\n    // then \"put\" reports the last action.\n    if (keep_msg != NULL && !keep_msg_more)\n\treturn;\n\n    if (n > 0)\n\tpn = n;\n    else\n\tpn = -n;\n\n    if (pn > p_report)\n    {\n\tif (n > 0)\n\t    vim_snprintf(msg_buf, MSG_BUF_LEN,\n\t\t    NGETTEXT(\"%ld more line\", \"%ld more lines\", pn), pn);\n\telse\n\t    vim_snprintf(msg_buf, MSG_BUF_LEN,\n\t\t    NGETTEXT(\"%ld line less\", \"%ld fewer lines\", pn), pn);\n\tif (got_int)\n\t    vim_strcat((char_u *)msg_buf, (char_u *)_(\" (Interrupted)\"),\n\t\t\t\t\t\t\t\t  MSG_BUF_LEN);\n\tif (msg(msg_buf))\n\t{\n\t    set_keep_msg((char_u *)msg_buf, 0);\n\t    keep_msg_more = TRUE;\n\t}\n    }\n}\n\n/*\n * flush map and typeahead buffers and give a warning for an error\n */\n    void\nbeep_flush(void)\n{\n    if (emsg_silent == 0)\n    {\n\tflush_buffers(FLUSH_MINIMAL);\n\tvim_beep(BO_ERROR);\n    }\n}\n\n/*\n * Give a warning for an error. \"val\" is one of the BO_ values, e.g., BO_OPER.\n */\n    void\nvim_beep(unsigned val)\n{\n#ifdef FEAT_EVAL\n    called_vim_beep = TRUE;\n#endif\n\n    if (emsg_silent != 0 || in_assert_fails)\n\treturn;\n\n    if (!((bo_flags & val) || (bo_flags & BO_ALL)))\n    {\n#ifdef ELAPSED_FUNC\n\tstatic int\t\tdid_init = FALSE;\n\tstatic elapsed_T\tstart_tv;\n\n\t// Only beep once per half a second, otherwise a sequence of beeps\n\t// would freeze Vim.\n\tif (!did_init || ELAPSED_FUNC(start_tv) > 500)\n\t{\n\t    did_init = TRUE;\n\t    ELAPSED_INIT(start_tv);\n#endif\n\t    if (p_vb\n#ifdef FEAT_GUI\n\t\t    // While the GUI is starting up the termcap is set for\n\t\t    // the GUI but the output still goes to a terminal.\n\t\t    && !(gui.in_use && gui.starting)\n#endif\n\t       )\n\t    {\n\t\tout_str_cf(T_VB);\n#ifdef FEAT_VTP\n\t\t// No restore color information, refresh the screen.\n\t\tif (has_vtp_working() != 0\n# ifdef FEAT_TERMGUICOLORS\n\t\t\t&& (p_tgc || (!p_tgc && t_colors >= 256))\n# endif\n\t\t   )\n\t\t{\n\t\t    redraw_later(UPD_CLEAR);\n\t\t    update_screen(0);\n\t\t    redrawcmd();\n\t\t}\n#endif\n\t    }\n\t    else\n\t\tout_char(BELL);\n#ifdef ELAPSED_FUNC\n\t}\n#endif\n    }\n\n    // When 'debug' contains \"beep\" produce a message.  If we are sourcing\n    // a script or executing a function give the user a hint where the beep\n    // comes from.\n    if (vim_strchr(p_debug, 'e') != NULL)\n    {\n\tmsg_source(HL_ATTR(HLF_W));\n\tmsg_attr(_(\"Beep!\"), HL_ATTR(HLF_W));\n    }\n}\n\n/*\n * To get the \"real\" home directory:\n * - get value of $HOME\n * For Unix:\n *  - go to that directory\n *  - do mch_dirname() to get the real name of that directory.\n *  This also works with mounts and links.\n *  Don't do this for MS-DOS, it will change the \"current dir\" for a drive.\n * For Windows:\n *  This code is duplicated in init_homedir() in dosinst.c.  Keep in sync!\n */\n    void\ninit_homedir(void)\n{\n    char_u  *var;\n\n    // In case we are called a second time (when 'encoding' changes).\n    VIM_CLEAR(homedir);\n\n#ifdef VMS\n    var = mch_getenv((char_u *)\"SYS$LOGIN\");\n#else\n    var = mch_getenv((char_u *)\"HOME\");\n#endif\n\n#ifdef MSWIN\n    /*\n     * Typically, $HOME is not defined on Windows, unless the user has\n     * specifically defined it for Vim's sake.  However, on Windows NT\n     * platforms, $HOMEDRIVE and $HOMEPATH are automatically defined for\n     * each user.  Try constructing $HOME from these.\n     */\n    if (var == NULL || *var == NUL)\n    {\n\tchar_u *homedrive, *homepath;\n\n\thomedrive = mch_getenv((char_u *)\"HOMEDRIVE\");\n\thomepath = mch_getenv((char_u *)\"HOMEPATH\");\n\tif (homepath == NULL || *homepath == NUL)\n\t    homepath = (char_u *)\"\\\\\";\n\tif (homedrive != NULL\n\t\t\t   && STRLEN(homedrive) + STRLEN(homepath) < MAXPATHL)\n\t{\n\t    sprintf((char *)NameBuff, \"%s%s\", homedrive, homepath);\n\t    if (NameBuff[0] != NUL)\n\t\tvar = NameBuff;\n\t}\n    }\n\n    if (var == NULL)\n\tvar = mch_getenv((char_u *)\"USERPROFILE\");\n\n    /*\n     * Weird but true: $HOME may contain an indirect reference to another\n     * variable, esp. \"%USERPROFILE%\".  Happens when $USERPROFILE isn't set\n     * when $HOME is being set.\n     */\n    if (var != NULL && *var == '%')\n    {\n\tchar_u\t*p;\n\tchar_u\t*exp;\n\n\tp = vim_strchr(var + 1, '%');\n\tif (p != NULL)\n\t{\n\t    vim_strncpy(NameBuff, var + 1, p - (var + 1));\n\t    exp = mch_getenv(NameBuff);\n\t    if (exp != NULL && *exp != NUL\n\t\t\t\t\t&& STRLEN(exp) + STRLEN(p) < MAXPATHL)\n\t    {\n\t\tvim_snprintf((char *)NameBuff, MAXPATHL, \"%s%s\", exp, p + 1);\n\t\tvar = NameBuff;\n\t    }\n\t}\n    }\n\n    if (var != NULL && *var == NUL)\t// empty is same as not set\n\tvar = NULL;\n\n    if (enc_utf8 && var != NULL)\n    {\n\tint\tlen;\n\tchar_u  *pp = NULL;\n\n\t// Convert from active codepage to UTF-8.  Other conversions are\n\t// not done, because they would fail for non-ASCII characters.\n\tacp_to_enc(var, (int)STRLEN(var), &pp, &len);\n\tif (pp != NULL)\n\t{\n\t    homedir = pp;\n\t    return;\n\t}\n    }\n\n    /*\n     * Default home dir is C:/\n     * Best assumption we can make in such a situation.\n     */\n    if (var == NULL)\n\tvar = (char_u *)\"C:/\";\n#endif\n\n    if (var != NULL)\n    {\n#ifdef UNIX\n\t/*\n\t * Change to the directory and get the actual path.  This resolves\n\t * links.  Don't do it when we can't return.\n\t */\n\tif (mch_dirname(NameBuff, MAXPATHL) == OK\n\t\t\t\t\t  && mch_chdir((char *)NameBuff) == 0)\n\t{\n\t    if (!mch_chdir((char *)var) && mch_dirname(IObuff, IOSIZE) == OK)\n\t\tvar = IObuff;\n\t    if (mch_chdir((char *)NameBuff) != 0)\n\t\temsg(_(e_cannot_go_back_to_previous_directory));\n\t}\n#endif\n\thomedir = vim_strsave(var);\n    }\n}\n\n#if defined(EXITFREE) || defined(PROTO)\n    void\nfree_homedir(void)\n{\n    vim_free(homedir);\n}\n\n    void\nfree_users(void)\n{\n    ga_clear_strings(&ga_users);\n}\n#endif\n\n#if defined(MSWIN) || defined(PROTO)\n/*\n * Initialize $VIM and $VIMRUNTIME when 'enc' is updated.\n */\n    void\ninit_vimdir(void)\n{\n    int\t    mustfree;\n    char_u  *p;\n\n    mch_get_exe_name();\n\n    mustfree = FALSE;\n    didset_vim = FALSE;\n    p = vim_getenv((char_u *)\"VIM\", &mustfree);\n    if (mustfree)\n\tvim_free(p);\n\n    mustfree = FALSE;\n    didset_vimruntime = FALSE;\n    p = vim_getenv((char_u *)\"VIMRUNTIME\", &mustfree);\n    if (mustfree)\n\tvim_free(p);\n}\n#endif\n\n/*\n * Call expand_env() and store the result in an allocated string.\n * This is not very memory efficient, this expects the result to be freed\n * again soon.\n */\n    char_u *\nexpand_env_save(char_u *src)\n{\n    return expand_env_save_opt(src, FALSE);\n}\n\n/*\n * Idem, but when \"one\" is TRUE handle the string as one file name, only\n * expand \"~\" at the start.\n */\n    char_u *\nexpand_env_save_opt(char_u *src, int one)\n{\n    char_u\t*p;\n\n    p = alloc(MAXPATHL);\n    if (p != NULL)\n\texpand_env_esc(src, p, MAXPATHL, FALSE, one, NULL);\n    return p;\n}\n\n/*\n * Expand environment variable with path name.\n * \"~/\" is also expanded, using $HOME.\tFor Unix \"~user/\" is expanded.\n * Skips over \"\\ \", \"\\~\" and \"\\$\" (not for Win32 though).\n * If anything fails no expansion is done and dst equals src.\n */\n    void\nexpand_env(\n    char_u\t*src,\t\t// input string e.g. \"$HOME/vim.hlp\"\n    char_u\t*dst,\t\t// where to put the result\n    int\t\tdstlen)\t\t// maximum length of the result\n{\n    expand_env_esc(src, dst, dstlen, FALSE, FALSE, NULL);\n}\n\n    void\nexpand_env_esc(\n    char_u\t*srcp,\t\t// input string e.g. \"$HOME/vim.hlp\"\n    char_u\t*dst,\t\t// where to put the result\n    int\t\tdstlen,\t\t// maximum length of the result\n    int\t\tesc,\t\t// escape spaces in expanded variables\n    int\t\tone,\t\t// \"srcp\" is one file name\n    char_u\t*startstr)\t// start again after this (can be NULL)\n{\n    char_u\t*src;\n    char_u\t*tail;\n    int\t\tc;\n    char_u\t*var;\n    int\t\tcopy_char;\n    int\t\tmustfree;\t// var was allocated, need to free it later\n    int\t\tat_start = TRUE; // at start of a name\n    int\t\tstartstr_len = 0;\n#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)\n    char_u\t*save_dst = dst;\n#endif\n\n    if (startstr != NULL)\n\tstartstr_len = (int)STRLEN(startstr);\n\n    src = skipwhite(srcp);\n    --dstlen;\t\t    // leave one char space for \"\\,\"\n    while (*src && dstlen > 0)\n    {\n#ifdef FEAT_EVAL\n\t// Skip over `=expr`.\n\tif (src[0] == '`' && src[1] == '=')\n\t{\n\t    size_t len;\n\n\t    var = src;\n\t    src += 2;\n\t    (void)skip_expr(&src, NULL);\n\t    if (*src == '`')\n\t\t++src;\n\t    len = src - var;\n\t    if (len > (size_t)dstlen)\n\t\tlen = dstlen;\n\t    vim_strncpy(dst, var, len);\n\t    dst += len;\n\t    dstlen -= (int)len;\n\t    continue;\n\t}\n#endif\n\tcopy_char = TRUE;\n\tif ((*src == '$'\n#ifdef VMS\n\t\t    && at_start\n#endif\n\t   )\n#if defined(MSWIN)\n\t\t|| *src == '%'\n#endif\n\t\t|| (*src == '~' && at_start))\n\t{\n\t    mustfree = FALSE;\n\n\t    /*\n\t     * The variable name is copied into dst temporarily, because it may\n\t     * be a string in read-only memory and a NUL needs to be appended.\n\t     */\n\t    if (*src != '~')\t\t\t\t// environment var\n\t    {\n\t\ttail = src + 1;\n\t\tvar = dst;\n\t\tc = dstlen - 1;\n\n#ifdef UNIX\n\t\t// Unix has ${var-name} type environment vars\n\t\tif (*tail == '{' && !vim_isIDc('{'))\n\t\t{\n\t\t    tail++;\t// ignore '{'\n\t\t    while (c-- > 0 && *tail && *tail != '}')\n\t\t\t*var++ = *tail++;\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    while (c-- > 0 && *tail != NUL && ((vim_isIDc(*tail))\n#if defined(MSWIN)\n\t\t\t    || (*src == '%' && *tail != '%')\n#endif\n\t\t\t    ))\n\t\t\t*var++ = *tail++;\n\t\t}\n\n#if defined(MSWIN) || defined(UNIX)\n# ifdef UNIX\n\t\tif (src[1] == '{' && *tail != '}')\n# else\n\t\tif (*src == '%' && *tail != '%')\n# endif\n\t\t    var = NULL;\n\t\telse\n\t\t{\n# ifdef UNIX\n\t\t    if (src[1] == '{')\n# else\n\t\t    if (*src == '%')\n#endif\n\t\t\t++tail;\n#endif\n\t\t    *var = NUL;\n\t\t    var = vim_getenv(dst, &mustfree);\n#if defined(MSWIN) || defined(UNIX)\n\t\t}\n#endif\n\t    }\n\t\t\t\t\t\t\t// home directory\n\t    else if (  src[1] == NUL\n\t\t    || vim_ispathsep(src[1])\n\t\t    || vim_strchr((char_u *)\" ,\\t\\n\", src[1]) != NULL)\n\t    {\n\t\tvar = homedir;\n\t\ttail = src + 1;\n\t    }\n\t    else\t\t\t\t\t// user directory\n\t    {\n#if defined(UNIX) || (defined(VMS) && defined(USER_HOME))\n\t\t/*\n\t\t * Copy ~user to dst[], so we can put a NUL after it.\n\t\t */\n\t\ttail = src;\n\t\tvar = dst;\n\t\tc = dstlen - 1;\n\t\twhile (\t   c-- > 0\n\t\t\t&& *tail\n\t\t\t&& vim_isfilec(*tail)\n\t\t\t&& !vim_ispathsep(*tail))\n\t\t    *var++ = *tail++;\n\t\t*var = NUL;\n# ifdef UNIX\n\t\t/*\n\t\t * If the system supports getpwnam(), use it.\n\t\t * Otherwise, or if getpwnam() fails, the shell is used to\n\t\t * expand ~user.  This is slower and may fail if the shell\n\t\t * does not support ~user (old versions of /bin/sh).\n\t\t */\n#  if defined(HAVE_GETPWNAM) && defined(HAVE_PWD_H)\n\t\t{\n\t\t    // Note: memory allocated by getpwnam() is never freed.\n\t\t    // Calling endpwent() apparently doesn't help.\n\t\t    struct passwd *pw = (*dst == NUL)\n\t\t\t\t\t? NULL : getpwnam((char *)dst + 1);\n\n\t\t    var = (pw == NULL) ? NULL : (char_u *)pw->pw_dir;\n\t\t}\n\t\tif (var == NULL)\n#  endif\n\t\t{\n\t\t    expand_T\txpc;\n\n\t\t    ExpandInit(&xpc);\n\t\t    xpc.xp_context = EXPAND_FILES;\n\t\t    var = ExpandOne(&xpc, dst, NULL,\n\t\t\t\tWILD_ADD_SLASH|WILD_SILENT, WILD_EXPAND_FREE);\n\t\t    mustfree = TRUE;\n\t\t}\n\n# else\t// !UNIX, thus VMS\n\t\t/*\n\t\t * USER_HOME is a comma-separated list of\n\t\t * directories to search for the user account in.\n\t\t */\n\t\t{\n\t\t    char_u\ttest[MAXPATHL], paths[MAXPATHL];\n\t\t    char_u\t*path, *next_path, *ptr;\n\t\t    stat_T\tst;\n\n\t\t    STRCPY(paths, USER_HOME);\n\t\t    next_path = paths;\n\t\t    while (*next_path)\n\t\t    {\n\t\t\tfor (path = next_path; *next_path && *next_path != ',';\n\t\t\t\tnext_path++);\n\t\t\tif (*next_path)\n\t\t\t    *next_path++ = NUL;\n\t\t\tSTRCPY(test, path);\n\t\t\tSTRCAT(test, \"/\");\n\t\t\tSTRCAT(test, dst + 1);\n\t\t\tif (mch_stat(test, &st) == 0)\n\t\t\t{\n\t\t\t    var = alloc(STRLEN(test) + 1);\n\t\t\t    STRCPY(var, test);\n\t\t\t    mustfree = TRUE;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n# endif // UNIX\n#else\n\t\t// cannot expand user's home directory, so don't try\n\t\tvar = NULL;\n\t\ttail = (char_u *)\"\";\t// for gcc\n#endif // UNIX || VMS\n\t    }\n\n#ifdef BACKSLASH_IN_FILENAME\n\t    // If 'shellslash' is set change backslashes to forward slashes.\n\t    // Can't use slash_adjust(), p_ssl may be set temporarily.\n\t    if (p_ssl && var != NULL && vim_strchr(var, '\\\\') != NULL)\n\t    {\n\t\tchar_u\t*p = vim_strsave(var);\n\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (mustfree)\n\t\t\tvim_free(var);\n\t\t    var = p;\n\t\t    mustfree = TRUE;\n\t\t    forward_slash(var);\n\t\t}\n\t    }\n#endif\n\n\t    // If \"var\" contains white space, escape it with a backslash.\n\t    // Required for \":e ~/tt\" when $HOME includes a space.\n\t    if (esc && var != NULL && vim_strpbrk(var, (char_u *)\" \\t\") != NULL)\n\t    {\n\t\tchar_u\t*p = vim_strsave_escaped(var, (char_u *)\" \\t\");\n\n\t\tif (p != NULL)\n\t\t{\n\t\t    if (mustfree)\n\t\t\tvim_free(var);\n\t\t    var = p;\n\t\t    mustfree = TRUE;\n\t\t}\n\t    }\n\n\t    if (var != NULL && *var != NUL\n\t\t    && (STRLEN(var) + STRLEN(tail) + 1 < (unsigned)dstlen))\n\t    {\n\t\tSTRCPY(dst, var);\n\t\tdstlen -= (int)STRLEN(var);\n\t\tc = (int)STRLEN(var);\n\t\t// if var[] ends in a path separator and tail[] starts\n\t\t// with it, skip a character\n\t\tif (after_pathsep(dst, dst + c)\n#if defined(BACKSLASH_IN_FILENAME) || defined(AMIGA)\n\t\t\t&& (dst == save_dst || dst[-1] != ':')\n#endif\n\t\t\t&& vim_ispathsep(*tail))\n\t\t    ++tail;\n\t\tdst += c;\n\t\tsrc = tail;\n\t\tcopy_char = FALSE;\n\t    }\n\t    if (mustfree)\n\t\tvim_free(var);\n\t}\n\n\tif (copy_char)\t    // copy at least one char\n\t{\n\t    /*\n\t     * Recognize the start of a new name, for '~'.\n\t     * Don't do this when \"one\" is TRUE, to avoid expanding \"~\" in\n\t     * \":edit foo ~ foo\".\n\t     */\n\t    at_start = FALSE;\n\t    if (src[0] == '\\\\' && src[1] != NUL)\n\t    {\n\t\t*dst++ = *src++;\n\t\t--dstlen;\n\t    }\n\t    else if ((src[0] == ' ' || src[0] == ',') && !one)\n\t\tat_start = TRUE;\n\t    if (dstlen > 0)\n\t    {\n\t\t*dst++ = *src++;\n\t\t--dstlen;\n\n\t\tif (startstr != NULL && src - startstr_len >= srcp\n\t\t\t&& STRNCMP(src - startstr_len, startstr,\n\t\t\t\t\t\t\t    startstr_len) == 0)\n\t\t    at_start = TRUE;\n\t    }\n\t}\n\n    }\n    *dst = NUL;\n}\n\n/*\n * If the string between \"p\" and \"pend\" ends in \"name/\", return \"pend\" minus\n * the length of \"name/\".  Otherwise return \"pend\".\n */\n    static char_u *\nremove_tail(char_u *p, char_u *pend, char_u *name)\n{\n    int\t\tlen = (int)STRLEN(name) + 1;\n    char_u\t*newend = pend - len;\n\n    if (newend >= p\n\t    && fnamencmp(newend, name, len - 1) == 0\n\t    && (newend == p || after_pathsep(p, newend)))\n\treturn newend;\n    return pend;\n}\n\n/*\n * Check if the directory \"vimdir/<version>\" or \"vimdir/runtime\" exists.\n * Return NULL if not, return its name in allocated memory otherwise.\n */\n    static char_u *\nvim_version_dir(char_u *vimdir)\n{\n    char_u\t*p;\n\n    if (vimdir == NULL || *vimdir == NUL)\n\treturn NULL;\n    p = concat_fnames(vimdir, (char_u *)VIM_VERSION_NODOT, TRUE);\n    if (p != NULL && mch_isdir(p))\n\treturn p;\n    vim_free(p);\n    p = concat_fnames(vimdir, (char_u *)RUNTIME_DIRNAME, TRUE);\n    if (p != NULL && mch_isdir(p))\n    {\n\tchar_u *fname = concat_fnames(p, (char_u *)\"defaults.vim\", TRUE);\n\n\t// Check that \"defaults.vim\" exists in this directory, to avoid picking\n\t// up a stray \"runtime\" directory, it would make many tests fail in\n\t// mysterious ways.\n\tif (fname != NULL)\n\t{\n\t    int exists = file_is_readable(fname);\n\n\t    vim_free(fname);\n\t    if (exists)\n\t\treturn p;\n\t}\n    }\n    vim_free(p);\n    return NULL;\n}\n\n/*\n * Vim's version of getenv().\n * Special handling of $HOME, $VIM and $VIMRUNTIME.\n * Also does ACP to 'enc' conversion for Win32.\n * \"mustfree\" is set to TRUE when the returned string is allocated.  It must be\n * initialized to FALSE by the caller.\n */\n    char_u *\nvim_getenv(char_u *name, int *mustfree)\n{\n    char_u\t*p = NULL;\n    char_u\t*pend;\n    int\t\tvimruntime;\n#ifdef MSWIN\n    WCHAR\t*wn, *wp;\n\n    // use \"C:/\" when $HOME is not set\n    if (STRCMP(name, \"HOME\") == 0)\n\treturn homedir;\n\n    // Use Wide function\n    wn = enc_to_utf16(name, NULL);\n    if (wn == NULL)\n\treturn NULL;\n\n    wp = _wgetenv(wn);\n    vim_free(wn);\n\n    if (wp != NULL && *wp == NUL)   // empty is the same as not set\n\twp = NULL;\n\n    if (wp != NULL)\n    {\n\tp = utf16_to_enc(wp, NULL);\n\tif (p == NULL)\n\t    return NULL;\n\n\t*mustfree = TRUE;\n\treturn p;\n    }\n#else\n    p = mch_getenv(name);\n    if (p != NULL && *p == NUL)\t    // empty is the same as not set\n\tp = NULL;\n\n    if (p != NULL)\n\treturn p;\n\n# ifdef __HAIKU__\n    // special handling for user settings directory...\n    if (STRCMP(name, \"BE_USER_SETTINGS\") == 0)\n    {\n\tstatic char userSettingsPath[MAXPATHL];\n\n\tif (find_directory(B_USER_SETTINGS_DIRECTORY, 0, false,\n\t\t\t\t\t   userSettingsPath, MAXPATHL) == B_OK)\n\t    return (char_u *)userSettingsPath;\n\telse\n\t    return NULL;\n    }\n# endif\n#endif\n\n    // handling $VIMRUNTIME and $VIM is below, bail out if it's another name.\n    vimruntime = (STRCMP(name, \"VIMRUNTIME\") == 0);\n    if (!vimruntime && STRCMP(name, \"VIM\") != 0)\n\treturn NULL;\n\n    /*\n     * When expanding $VIMRUNTIME fails, try using $VIM/vim<version> or $VIM.\n     * Don't do this when default_vimruntime_dir is non-empty.\n     */\n    if (vimruntime\n#ifdef HAVE_PATHDEF\n\t    && *default_vimruntime_dir == NUL\n#endif\n       )\n    {\n#ifdef MSWIN\n\t// Use Wide function\n\twp = _wgetenv(L\"VIM\");\n\tif (wp != NULL && *wp == NUL)\t    // empty is the same as not set\n\t    wp = NULL;\n\tif (wp != NULL)\n\t{\n\t    char_u *q = utf16_to_enc(wp, NULL);\n\t    if (q != NULL)\n\t    {\n\t\tp = vim_version_dir(q);\n\t\t*mustfree = TRUE;\n\t\tif (p == NULL)\n\t\t    p = q;\n\t    }\n\t}\n#else\n\tp = mch_getenv((char_u *)\"VIM\");\n\tif (p != NULL && *p == NUL)\t    // empty is the same as not set\n\t    p = NULL;\n\tif (p != NULL)\n\t{\n\t    p = vim_version_dir(p);\n\t    if (p != NULL)\n\t\t*mustfree = TRUE;\n\t    else\n\t\tp = mch_getenv((char_u *)\"VIM\");\n\t}\n#endif\n    }\n\n    /*\n     * When expanding $VIM or $VIMRUNTIME fails, try using:\n     * - the directory name from 'helpfile' (unless it contains '$')\n     * - the executable name from argv[0]\n     */\n    if (p == NULL)\n    {\n\tif (p_hf != NULL && vim_strchr(p_hf, '$') == NULL)\n\t    p = p_hf;\n#ifdef USE_EXE_NAME\n\t/*\n\t * Use the name of the executable, obtained from argv[0].\n\t */\n\telse\n\t    p = exe_name;\n#endif\n\tif (p != NULL)\n\t{\n\t    // remove the file name\n\t    pend = gettail(p);\n\n\t    // remove \"doc/\" from 'helpfile', if present\n\t    if (p == p_hf)\n\t\tpend = remove_tail(p, pend, (char_u *)\"doc\");\n\n#ifdef USE_EXE_NAME\n# ifdef MACOS_X\n\t    // remove \"MacOS\" from exe_name and add \"Resources/vim\"\n\t    if (p == exe_name)\n\t    {\n\t\tchar_u\t*pend1;\n\t\tchar_u\t*pnew;\n\n\t\tpend1 = remove_tail(p, pend, (char_u *)\"MacOS\");\n\t\tif (pend1 != pend)\n\t\t{\n\t\t    pnew = alloc(pend1 - p + 15);\n\t\t    if (pnew != NULL)\n\t\t    {\n\t\t\tSTRNCPY(pnew, p, (pend1 - p));\n\t\t\tSTRCPY(pnew + (pend1 - p), \"Resources/vim\");\n\t\t\tp = pnew;\n\t\t\tpend = p + STRLEN(p);\n\t\t    }\n\t\t}\n\t    }\n# endif\n\t    // remove \"src/\" from exe_name, if present\n\t    if (p == exe_name)\n\t\tpend = remove_tail(p, pend, (char_u *)\"src\");\n#endif\n\n\t    // for $VIM, remove \"runtime/\" or \"vim54/\", if present\n\t    if (!vimruntime)\n\t    {\n\t\tpend = remove_tail(p, pend, (char_u *)RUNTIME_DIRNAME);\n\t\tpend = remove_tail(p, pend, (char_u *)VIM_VERSION_NODOT);\n\t    }\n\n\t    // remove trailing path separator\n\t    if (pend > p && after_pathsep(p, pend))\n\t\t--pend;\n\n#ifdef MACOS_X\n\t    if (p == exe_name || p == p_hf)\n#endif\n\t\t// check that the result is a directory name\n\t\tp = vim_strnsave(p, pend - p);\n\n\t    if (p != NULL && !mch_isdir(p))\n\t\tVIM_CLEAR(p);\n\t    else\n\t    {\n#ifdef USE_EXE_NAME\n\t\t// may add \"/vim54\" or \"/runtime\" if it exists\n\t\tif (vimruntime && (pend = vim_version_dir(p)) != NULL)\n\t\t{\n\t\t    vim_free(p);\n\t\t    p = pend;\n\t\t}\n#endif\n\t\t*mustfree = TRUE;\n\t    }\n\t}\n    }\n\n#ifdef HAVE_PATHDEF\n    // When there is a pathdef.c file we can use default_vim_dir and\n    // default_vimruntime_dir\n    if (p == NULL)\n    {\n\t// Only use default_vimruntime_dir when it is not empty\n\tif (vimruntime && *default_vimruntime_dir != NUL)\n\t{\n\t    p = default_vimruntime_dir;\n\t    *mustfree = FALSE;\n\t}\n\telse if (*default_vim_dir != NUL)\n\t{\n\t    if (vimruntime && (p = vim_version_dir(default_vim_dir)) != NULL)\n\t\t*mustfree = TRUE;\n\t    else\n\t    {\n\t\tp = default_vim_dir;\n\t\t*mustfree = FALSE;\n\t    }\n\t}\n    }\n#endif\n\n    /*\n     * Set the environment variable, so that the new value can be found fast\n     * next time, and others can also use it (e.g. Perl).\n     */\n    if (p != NULL)\n    {\n\tif (vimruntime)\n\t{\n\t    vim_setenv((char_u *)\"VIMRUNTIME\", p);\n\t    didset_vimruntime = TRUE;\n\t}\n\telse\n\t{\n\t    vim_setenv((char_u *)\"VIM\", p);\n\t    didset_vim = TRUE;\n\t}\n    }\n    return p;\n}\n\n    void\nvim_unsetenv(char_u *var)\n{\n#ifdef HAVE_UNSETENV\n    unsetenv((char *)var);\n#else\n    vim_setenv(var, (char_u *)\"\");\n#endif\n}\n\n/*\n * Removes environment variable \"name\" and take care of side effects.\n */\n    void\nvim_unsetenv_ext(char_u *var)\n{\n    vim_unsetenv(var);\n\n    // \"homedir\" is not cleared, keep using the old value until $HOME is set.\n    if (STRICMP(var, \"VIM\") == 0)\n\tdidset_vim = FALSE;\n    else if (STRICMP(var, \"VIMRUNTIME\") == 0)\n\tdidset_vimruntime = FALSE;\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Set environment variable \"name\" and take care of side effects.\n */\n    void\nvim_setenv_ext(char_u *name, char_u *val)\n{\n    vim_setenv(name, val);\n    if (STRICMP(name, \"HOME\") == 0)\n\tinit_homedir();\n    else if (didset_vim && STRICMP(name, \"VIM\") == 0)\n\tdidset_vim = FALSE;\n    else if (didset_vimruntime && STRICMP(name, \"VIMRUNTIME\") == 0)\n\tdidset_vimruntime = FALSE;\n}\n#endif\n\n/*\n * Our portable version of setenv.\n */\n    void\nvim_setenv(char_u *name, char_u *val)\n{\n#ifdef HAVE_SETENV\n    mch_setenv((char *)name, (char *)val, 1);\n#else\n    char_u\t*envbuf;\n\n    /*\n     * Putenv does not copy the string, it has to remain\n     * valid.  The allocated memory will never be freed.\n     */\n    envbuf = alloc(STRLEN(name) + STRLEN(val) + 2);\n    if (envbuf != NULL)\n    {\n\tsprintf((char *)envbuf, \"%s=%s\", name, val);\n\tputenv((char *)envbuf);\n    }\n#endif\n#ifdef FEAT_GETTEXT\n    /*\n     * When setting $VIMRUNTIME adjust the directory to find message\n     * translations to $VIMRUNTIME/lang.\n     */\n    if (*val != NUL && STRICMP(name, \"VIMRUNTIME\") == 0)\n    {\n\tchar_u\t*buf = concat_str(val, (char_u *)\"/lang\");\n\n\tif (buf != NULL)\n\t{\n\t    bindtextdomain(VIMPACKAGE, (char *)buf);\n\t    vim_free(buf);\n\t}\n    }\n#endif\n}\n\n/*\n * Function given to ExpandGeneric() to obtain an environment variable name.\n */\n    char_u *\nget_env_name(\n    expand_T\t*xp UNUSED,\n    int\t\tidx)\n{\n#if defined(AMIGA)\n    // No environ[] on the Amiga.\n    return NULL;\n#else\n# ifndef __WIN32__\n    // Borland C++ 5.2 has this in a header file.\n    extern char\t\t**environ;\n# endif\n    char_u\t\t*str;\n    int\t\t\tn;\n\n    str = (char_u *)environ[idx];\n    if (str == NULL)\n\treturn NULL;\n\n    for (n = 0; n < EXPAND_BUF_LEN - 1; ++n)\n    {\n\tif (str[n] == '=' || str[n] == NUL)\n\t    break;\n\txp->xp_buf[n] = str[n];\n    }\n    xp->xp_buf[n] = NUL;\n    return xp->xp_buf;\n#endif\n}\n\n/*\n * Add a user name to the list of users in ga_users.\n * Do nothing if user name is NULL or empty.\n */\n    static void\nadd_user(char_u *user, int need_copy)\n{\n    char_u\t*user_copy = (user != NULL && need_copy)\n\t\t\t\t\t\t    ? vim_strsave(user) : user;\n\n    if (user_copy == NULL || *user_copy == NUL || ga_grow(&ga_users, 1) == FAIL)\n    {\n\tif (need_copy)\n\t    vim_free(user);\n\treturn;\n    }\n    ((char_u **)(ga_users.ga_data))[ga_users.ga_len++] = user_copy;\n}\n\n/*\n * Find all user names for user completion.\n * Done only once and then cached.\n */\n    static void\ninit_users(void)\n{\n    static int\tlazy_init_done = FALSE;\n\n    if (lazy_init_done)\n\treturn;\n\n    lazy_init_done = TRUE;\n    ga_init2(&ga_users, sizeof(char_u *), 20);\n\n# if defined(HAVE_GETPWENT) && defined(HAVE_PWD_H)\n    {\n\tstruct passwd*\tpw;\n\n\tsetpwent();\n\twhile ((pw = getpwent()) != NULL)\n\t    add_user((char_u *)pw->pw_name, TRUE);\n\tendpwent();\n    }\n# elif defined(MSWIN)\n    {\n\tDWORD\t\tnusers = 0, ntotal = 0, i;\n\tPUSER_INFO_0\tuinfo;\n\n\tif (NetUserEnum(NULL, 0, 0, (LPBYTE *) &uinfo, MAX_PREFERRED_LENGTH,\n\t\t\t\t       &nusers, &ntotal, NULL) == NERR_Success)\n\t{\n\t    for (i = 0; i < nusers; i++)\n\t\tadd_user(utf16_to_enc(uinfo[i].usri0_name, NULL), FALSE);\n\n\t    NetApiBufferFree(uinfo);\n\t}\n    }\n# endif\n# if defined(HAVE_GETPWNAM)\n    {\n\tchar_u\t*user_env = mch_getenv((char_u *)\"USER\");\n\n\t// The $USER environment variable may be a valid remote user name (NIS,\n\t// LDAP) not already listed by getpwent(), as getpwent() only lists\n\t// local user names.  If $USER is not already listed, check whether it\n\t// is a valid remote user name using getpwnam() and if it is, add it to\n\t// the list of user names.\n\n\tif (user_env != NULL && *user_env != NUL)\n\t{\n\t    int\ti;\n\n\t    for (i = 0; i < ga_users.ga_len; i++)\n\t    {\n\t\tchar_u\t*local_user = ((char_u **)ga_users.ga_data)[i];\n\n\t\tif (STRCMP(local_user, user_env) == 0)\n\t\t    break;\n\t    }\n\n\t    if (i == ga_users.ga_len)\n\t    {\n\t\tstruct passwd\t*pw = getpwnam((char *)user_env);\n\n\t\tif (pw != NULL)\n\t\t    add_user((char_u *)pw->pw_name, TRUE);\n\t    }\n\t}\n    }\n# endif\n}\n\n/*\n * Function given to ExpandGeneric() to obtain an user names.\n */\n    char_u*\nget_users(expand_T *xp UNUSED, int idx)\n{\n    init_users();\n    if (idx < ga_users.ga_len)\n\treturn ((char_u **)ga_users.ga_data)[idx];\n    return NULL;\n}\n\n/*\n * Check whether name matches a user name. Return:\n * 0 if name does not match any user name.\n * 1 if name partially matches the beginning of a user name.\n * 2 is name fully matches a user name.\n */\n    int\nmatch_user(char_u *name)\n{\n    int i;\n    int n = (int)STRLEN(name);\n    int result = 0;\n\n    init_users();\n    for (i = 0; i < ga_users.ga_len; i++)\n    {\n\tif (STRCMP(((char_u **)ga_users.ga_data)[i], name) == 0)\n\t    return 2; // full match\n\tif (STRNCMP(((char_u **)ga_users.ga_data)[i], name, n) == 0)\n\t    result = 1; // partial match\n    }\n    return result;\n}\n\n    static void\nprepare_to_exit(void)\n{\n#if defined(SIGHUP) && defined(SIG_IGN)\n    // Ignore SIGHUP, because a dropped connection causes a read error, which\n    // makes Vim exit and then handling SIGHUP causes various reentrance\n    // problems.\n    mch_signal(SIGHUP, SIG_IGN);\n#endif\n\n#ifdef FEAT_GUI\n    if (gui.in_use)\n    {\n\tgui.dying = TRUE;\n\tout_trash();\t// trash any pending output\n    }\n    else\n#endif\n    {\n\twindgoto((int)Rows - 1, 0);\n\n\t/*\n\t * Switch terminal mode back now, so messages end up on the \"normal\"\n\t * screen (if there are two screens).\n\t */\n\tsettmode(TMODE_COOK);\n\tstoptermcap();\n\tout_flush();\n    }\n}\n\n/*\n * Preserve files and exit.\n * When called IObuff must contain a message.\n * NOTE: This may be called from deathtrap() in a signal handler, avoid unsafe\n * functions, such as allocating memory.\n */\n    void\npreserve_exit(void)\n{\n    buf_T\t*buf;\n\n    prepare_to_exit();\n\n    // Setting this will prevent free() calls.  That avoids calling free()\n    // recursively when free() was invoked with a bad pointer.\n    really_exiting = TRUE;\n\n    out_str(IObuff);\n    screen_start();\t\t    // don't know where cursor is now\n    out_flush();\n\n    ml_close_notmod();\t\t    // close all not-modified buffers\n\n    FOR_ALL_BUFFERS(buf)\n    {\n\tif (buf->b_ml.ml_mfp != NULL && buf->b_ml.ml_mfp->mf_fname != NULL)\n\t{\n\t    OUT_STR(\"Vim: preserving files...\\r\\n\");\n\t    screen_start();\t    // don't know where cursor is now\n\t    out_flush();\n\t    ml_sync_all(FALSE, FALSE);\t// preserve all swap files\n\t    break;\n\t}\n    }\n\n    ml_close_all(FALSE);\t    // close all memfiles, without deleting\n\n    OUT_STR(\"Vim: Finished.\\r\\n\");\n\n    getout(1);\n}\n\n/*\n * Check for CTRL-C pressed, but only once in a while.\n * Should be used instead of ui_breakcheck() for functions that check for\n * each line in the file.  Calling ui_breakcheck() each time takes too much\n * time, because it can be a system call.\n */\n\n#ifndef BREAKCHECK_SKIP\n# define BREAKCHECK_SKIP 1000\n#endif\n\nstatic int\tbreakcheck_count = 0;\n\n    void\nline_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n\n/*\n * Like line_breakcheck() but check 10 times less often.\n */\n    void\nfast_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP * 10)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n\n# if defined(FEAT_SPELL) || defined(PROTO)\n/*\n * Like line_breakcheck() but check 100 times less often.\n */\n    void\nveryfast_breakcheck(void)\n{\n    if (++breakcheck_count >= BREAKCHECK_SKIP * 100)\n    {\n\tbreakcheck_count = 0;\n\tui_breakcheck();\n    }\n}\n#endif\n\n#if defined(VIM_BACKTICK) || defined(FEAT_EVAL) \\\n\t|| (defined(HAVE_LOCALE_H) || defined(X_LOCALE)) \\\n\t|| defined(PROTO)\n\n#ifndef SEEK_SET\n# define SEEK_SET 0\n#endif\n#ifndef SEEK_END\n# define SEEK_END 2\n#endif\n\n/*\n * Get the stdout of an external command.\n * If \"ret_len\" is NULL replace NUL characters with NL.  When \"ret_len\" is not\n * NULL store the length there.\n * Returns an allocated string, or NULL for error.\n */\n    char_u *\nget_cmd_output(\n    char_u\t*cmd,\n    char_u\t*infile,\t// optional input file name\n    int\t\tflags,\t\t// can be SHELL_SILENT\n    int\t\t*ret_len)\n{\n    char_u\t*tempname;\n    char_u\t*command;\n    char_u\t*buffer = NULL;\n    int\t\tlen;\n    int\t\ti = 0;\n    FILE\t*fd;\n\n    if (check_restricted() || check_secure())\n\treturn NULL;\n\n    // get a name for the temp file\n    if ((tempname = vim_tempname('o', FALSE)) == NULL)\n    {\n\temsg(_(e_cant_get_temp_file_name));\n\treturn NULL;\n    }\n\n    // Add the redirection stuff\n    command = make_filter_cmd(cmd, infile, tempname);\n    if (command == NULL)\n\tgoto done;\n\n    /*\n     * Call the shell to execute the command (errors are ignored).\n     * Don't check timestamps here.\n     */\n    ++no_check_timestamps;\n    call_shell(command, SHELL_DOOUT | SHELL_EXPAND | flags);\n    --no_check_timestamps;\n\n    vim_free(command);\n\n    /*\n     * read the names from the file into memory\n     */\n# ifdef VMS\n    // created temporary file is not always readable as binary\n    fd = mch_fopen((char *)tempname, \"r\");\n# else\n    fd = mch_fopen((char *)tempname, READBIN);\n# endif\n\n    // Not being able to seek means we can't read the file.\n    if (fd == NULL\n\t    || fseek(fd, 0L, SEEK_END) == -1\n\t    || (len = ftell(fd)) == -1\t\t// get size of temp file\n\t    || fseek(fd, 0L, SEEK_SET) == -1)\t// back to the start\n    {\n\tsemsg(_(e_cannot_read_from_str_2), tempname);\n\tif (fd != NULL)\n\t    fclose(fd);\n\tgoto done;\n    }\n\n    buffer = alloc(len + 1);\n    if (buffer != NULL)\n\ti = (int)fread((char *)buffer, (size_t)1, (size_t)len, fd);\n    fclose(fd);\n    mch_remove(tempname);\n    if (buffer == NULL)\n\tgoto done;\n#ifdef VMS\n    len = i;\t// VMS doesn't give us what we asked for...\n#endif\n    if (i != len)\n    {\n\tsemsg(_(e_cant_read_file_str), tempname);\n\tVIM_CLEAR(buffer);\n    }\n    else if (ret_len == NULL)\n    {\n\t// Change NUL into SOH, otherwise the string is truncated.\n\tfor (i = 0; i < len; ++i)\n\t    if (buffer[i] == NUL)\n\t\tbuffer[i] = 1;\n\n\tbuffer[len] = NUL;\t// make sure the buffer is terminated\n    }\n    else\n\t*ret_len = len;\n\ndone:\n    vim_free(tempname);\n    return buffer;\n}\n\n# if defined(FEAT_EVAL) || defined(PROTO)\n\n    static void\nget_cmd_output_as_rettv(\n    typval_T\t*argvars,\n    typval_T\t*rettv,\n    int\t\tretlist)\n{\n    char_u\t*res = NULL;\n    char_u\t*p;\n    char_u\t*infile = NULL;\n    int\t\terr = FALSE;\n    FILE\t*fd;\n    list_T\t*list = NULL;\n    int\t\tflags = SHELL_SILENT;\n\n    rettv->v_type = VAR_STRING;\n    rettv->vval.v_string = NULL;\n    if (check_restricted() || check_secure())\n\tgoto errret;\n\n    if (in_vim9script()\n\t    && (check_for_string_arg(argvars, 0) == FAIL\n\t\t|| check_for_opt_string_or_number_or_list_arg(argvars, 1)\n\t\t\t\t\t\t\t\t      == FAIL))\n\treturn;\n\n    if (argvars[1].v_type != VAR_UNKNOWN)\n    {\n\t/*\n\t * Write the text to a temp file, to be used for input of the shell\n\t * command.\n\t */\n\tif ((infile = vim_tempname('i', TRUE)) == NULL)\n\t{\n\t    emsg(_(e_cant_get_temp_file_name));\n\t    goto errret;\n\t}\n\n\tfd = mch_fopen((char *)infile, WRITEBIN);\n\tif (fd == NULL)\n\t{\n\t    semsg(_(e_cant_open_file_str), infile);\n\t    goto errret;\n\t}\n\tif (argvars[1].v_type == VAR_NUMBER)\n\t{\n\t    linenr_T\tlnum;\n\t    buf_T\t*buf;\n\n\t    buf = buflist_findnr(argvars[1].vval.v_number);\n\t    if (buf == NULL)\n\t    {\n\t\tsemsg(_(e_buffer_nr_does_not_exist), argvars[1].vval.v_number);\n\t\tfclose(fd);\n\t\tgoto errret;\n\t    }\n\n\t    for (lnum = 1; lnum <= buf->b_ml.ml_line_count; lnum++)\n\t    {\n\t\tfor (p = ml_get_buf(buf, lnum, FALSE); *p != NUL; ++p)\n\t\t    if (putc(*p == '\\n' ? NUL : *p, fd) == EOF)\n\t\t    {\n\t\t\terr = TRUE;\n\t\t\tbreak;\n\t\t    }\n\t\tif (putc(NL, fd) == EOF)\n\t\t{\n\t\t    err = TRUE;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\telse if (argvars[1].v_type == VAR_LIST)\n\t{\n\t    if (write_list(fd, argvars[1].vval.v_list, TRUE) == FAIL)\n\t\terr = TRUE;\n\t}\n\telse\n\t{\n\t    size_t\tlen;\n\t    char_u\tbuf[NUMBUFLEN];\n\n\t    p = tv_get_string_buf_chk(&argvars[1], buf);\n\t    if (p == NULL)\n\t    {\n\t\tfclose(fd);\n\t\tgoto errret;\t\t// type error; errmsg already given\n\t    }\n\t    len = STRLEN(p);\n\t    if (len > 0 && fwrite(p, len, 1, fd) != 1)\n\t\terr = TRUE;\n\t}\n\tif (fclose(fd) != 0)\n\t    err = TRUE;\n\tif (err)\n\t{\n\t    emsg(_(e_error_writing_temp_file));\n\t    goto errret;\n\t}\n    }\n\n    // Omit SHELL_COOKED when invoked with \":silent\".  Avoids that the shell\n    // echoes typeahead, that messes up the display.\n    if (!msg_silent)\n\tflags += SHELL_COOKED;\n\n    if (retlist)\n    {\n\tint\t\tlen;\n\tlistitem_T\t*li;\n\tchar_u\t\t*s = NULL;\n\tchar_u\t\t*start;\n\tchar_u\t\t*end;\n\tint\t\ti;\n\n\tres = get_cmd_output(tv_get_string(&argvars[0]), infile, flags, &len);\n\tif (res == NULL)\n\t    goto errret;\n\n\tlist = list_alloc();\n\tif (list == NULL)\n\t    goto errret;\n\n\tfor (i = 0; i < len; ++i)\n\t{\n\t    start = res + i;\n\t    while (i < len && res[i] != NL)\n\t\t++i;\n\t    end = res + i;\n\n\t    s = alloc(end - start + 1);\n\t    if (s == NULL)\n\t\tgoto errret;\n\n\t    for (p = s; start < end; ++p, ++start)\n\t\t*p = *start == NUL ? NL : *start;\n\t    *p = NUL;\n\n\t    li = listitem_alloc();\n\t    if (li == NULL)\n\t    {\n\t\tvim_free(s);\n\t\tgoto errret;\n\t    }\n\t    li->li_tv.v_type = VAR_STRING;\n\t    li->li_tv.v_lock = 0;\n\t    li->li_tv.vval.v_string = s;\n\t    list_append(list, li);\n\t}\n\n\trettv_list_set(rettv, list);\n\tlist = NULL;\n    }\n    else\n    {\n\tres = get_cmd_output(tv_get_string(&argvars[0]), infile, flags, NULL);\n#ifdef USE_CRNL\n\t// translate <CR><NL> into <NL>\n\tif (res != NULL)\n\t{\n\t    char_u\t*s, *d;\n\n\t    d = res;\n\t    for (s = res; *s; ++s)\n\t    {\n\t\tif (s[0] == CAR && s[1] == NL)\n\t\t    ++s;\n\t\t*d++ = *s;\n\t    }\n\t    *d = NUL;\n\t}\n#endif\n\trettv->vval.v_string = res;\n\tres = NULL;\n    }\n\nerrret:\n    if (infile != NULL)\n    {\n\tmch_remove(infile);\n\tvim_free(infile);\n    }\n    if (res != NULL)\n\tvim_free(res);\n    if (list != NULL)\n\tlist_free(list);\n}\n\n/*\n * \"system()\" function\n */\n    void\nf_system(typval_T *argvars, typval_T *rettv)\n{\n    get_cmd_output_as_rettv(argvars, rettv, FALSE);\n}\n\n/*\n * \"systemlist()\" function\n */\n    void\nf_systemlist(typval_T *argvars, typval_T *rettv)\n{\n    get_cmd_output_as_rettv(argvars, rettv, TRUE);\n}\n# endif // FEAT_EVAL\n\n#endif\n\n/*\n * Return TRUE when need to go to Insert mode because of 'insertmode'.\n * Don't do this when still processing a command or a mapping.\n * Don't do this when inside a \":normal\" command.\n */\n    int\ngoto_im(void)\n{\n    return (p_im && stuff_empty() && typebuf_typed());\n}\n\n/*\n * Returns the isolated name of the shell in allocated memory:\n * - Skip beyond any path.  E.g., \"/usr/bin/csh -f\" -> \"csh -f\".\n * - Remove any argument.  E.g., \"csh -f\" -> \"csh\".\n * But don't allow a space in the path, so that this works:\n *   \"/usr/bin/csh --rcfile ~/.cshrc\"\n * But don't do that for Windows, it's common to have a space in the path.\n * Returns NULL when out of memory.\n */\n    char_u *\nget_isolated_shell_name(void)\n{\n    char_u *p;\n\n#ifdef MSWIN\n    p = gettail(p_sh);\n    p = vim_strnsave(p, skiptowhite(p) - p);\n#else\n    p = skiptowhite(p_sh);\n    if (*p == NUL)\n    {\n\t// No white space, use the tail.\n\tp = vim_strsave(gettail(p_sh));\n    }\n    else\n    {\n\tchar_u  *p1, *p2;\n\n\t// Find the last path separator before the space.\n\tp1 = p_sh;\n\tfor (p2 = p_sh; p2 < p; MB_PTR_ADV(p2))\n\t    if (vim_ispathsep(*p2))\n\t\tp1 = p2 + 1;\n\tp = vim_strnsave(p1, p - p1);\n    }\n#endif\n    return p;\n}\n\n/*\n * Check if the \"://\" of a URL is at the pointer, return URL_SLASH.\n * Also check for \":\\\\\", which MS Internet Explorer accepts, return\n * URL_BACKSLASH.\n */\n    int\npath_is_url(char_u *p)\n{\n    if (STRNCMP(p, \"://\", (size_t)3) == 0)\n\treturn URL_SLASH;\n    else if (STRNCMP(p, \":\\\\\\\\\", (size_t)3) == 0)\n\treturn URL_BACKSLASH;\n    return 0;\n}\n\n/*\n * Check if \"fname\" starts with \"name://\" or \"name:\\\\\".\n * Return URL_SLASH for \"name://\", URL_BACKSLASH for \"name:\\\\\".\n * Return zero otherwise.\n */\n    int\npath_with_url(char_u *fname)\n{\n    char_u *p;\n\n    // We accept alphabetic characters and a dash in scheme part.\n    // RFC 3986 allows for more, but it increases the risk of matching\n    // non-URL text.\n\n    // first character must be alpha\n    if (!ASCII_ISALPHA(*fname))\n\treturn 0;\n\n    // check body: alpha or dash\n    for (p = fname + 1; (ASCII_ISALPHA(*p) || (*p == '-')); ++p)\n\t;\n\n    // check last char is not a dash\n    if (p[-1] == '-')\n\treturn 0;\n\n    // \"://\" or \":\\\\\" must follow\n    return path_is_url(p);\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return the dictionary of v:event.\n * Save and clear the value in case it already has items.\n */\n    dict_T *\nget_v_event(save_v_event_T *sve)\n{\n    dict_T\t*v_event = get_vim_var_dict(VV_EVENT);\n\n    if (v_event->dv_hashtab.ht_used > 0)\n    {\n\t// recursive use of v:event, save, make empty and restore later\n\tsve->sve_did_save = TRUE;\n\tsve->sve_hashtab = v_event->dv_hashtab;\n\thash_init(&v_event->dv_hashtab);\n    }\n    else\n\tsve->sve_did_save = FALSE;\n    return v_event;\n}\n\n    void\nrestore_v_event(dict_T *v_event, save_v_event_T *sve)\n{\n    dict_free_contents(v_event);\n    if (sve->sve_did_save)\n\tv_event->dv_hashtab = sve->sve_hashtab;\n    else\n\thash_init(&v_event->dv_hashtab);\n}\n#endif\n\n/*\n * Fires a ModeChanged autocmd event if appropriate.\n */\n    void\nmay_trigger_modechanged(void)\n{\n#ifdef FEAT_EVAL\n    dict_T\t    *v_event;\n    save_v_event_T  save_v_event;\n    char_u\t    curr_mode[MODE_MAX_LENGTH];\n    char_u\t    pattern_buf[2 * MODE_MAX_LENGTH];\n\n    // Skip this when got_int is set, the autocommand will not be executed.\n    // Better trigger it next time.\n    if (!has_modechanged() || got_int)\n\treturn;\n\n    get_mode(curr_mode);\n    if (STRCMP(curr_mode, last_mode) == 0)\n\treturn;\n\n    v_event = get_v_event(&save_v_event);\n    (void)dict_add_string(v_event, \"new_mode\", curr_mode);\n    (void)dict_add_string(v_event, \"old_mode\", last_mode);\n    dict_set_items_ro(v_event);\n\n    // concatenate modes in format \"old_mode:new_mode\"\n    vim_snprintf((char *)pattern_buf, sizeof(pattern_buf), \"%s:%s\", last_mode,\n\t    curr_mode);\n\n    apply_autocmds(EVENT_MODECHANGED, pattern_buf, NULL, FALSE, curbuf);\n    STRCPY(last_mode, curr_mode);\n\n    restore_v_event(v_event, &save_v_event);\n#endif\n}\n", "\" Test spell checking\n\" Note: this file uses latin1 encoding, but is used with utf-8 encoding.\n\nsource check.vim\nCheckFeature spell\n\nsource screendump.vim\n\nfunc TearDown()\n  set nospell\n  call delete('Xtest.aff')\n  call delete('Xtest.dic')\n  call delete('Xtest.latin1.add')\n  call delete('Xtest.latin1.add.spl')\n  call delete('Xtest.latin1.spl')\n  call delete('Xtest.latin1.sug')\n  \" set 'encoding' to clear the word list\n  set encoding=utf-8\nendfunc\n\nfunc Test_wrap_search()\n  new\n  call setline(1, ['The', '', 'A plong line with two zpelling mistakes', '', 'End'])\n  set spell wrapscan\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  normal ]s\n  call assert_equal('zpelling', expand('<cword>'))\n  normal ]s\n  call assert_equal('plong', expand('<cword>'))\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_curswant()\n  new\n  call setline(1, ['Another plong line', 'abcdefghijklmnopq'])\n  set spell wrapscan\n  normal 0]s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[s\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 0]S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n  normal 0[S\n  call assert_equal('plong', expand('<cword>'))\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  normal 1G0\n  call assert_equal('plong', spellbadword()[0])\n  normal j\n  call assert_equal(9, getcurpos()[2])\n\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_z_equal_on_invalid_utf8_word()\n  split\n  set spell\n  call setline(1, \"\\xff\")\n  norm z=\n  set nospell\n  bwipe!\nendfunc\n\nfunc Test_z_equal_on_single_character()\n  \" this was decrementing the index below zero\n  new\n  norm a0\\\u0118\n  norm zW\n  norm \u0016z=\n\n  bwipe!\nendfunc\n\n\" Test spellbadword() with argument\nfunc Test_spellbadword()\n  set spell\n\n  call assert_equal(['bycycle', 'bad'],  spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], 'A sentence. another sentence'->spellbadword())\n\n  call assert_equal(['TheCamelWord', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=camel\n  call assert_equal(['asdf', 'bad'], 'TheCamelWord asdf'->spellbadword())\n  set spelloptions=\n\n  set spelllang=en\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_us\n  call assert_equal(['centre', 'local'], spellbadword('centre'))\n  call assert_equal(['', ''],            spellbadword('center'))\n  set spelllang=en_gb\n  call assert_equal(['', ''],            spellbadword('centre'))\n  call assert_equal(['center', 'local'], spellbadword('center'))\n\n  \" Create a small word list to test that spellbadword('...')\n  \" can return ['...', 'rare'].\n  e Xwords\n  insert\nfoo\nfoobar/?\n.\n   w!\n   mkspell! Xwords.spl Xwords\n   set spelllang=Xwords.spl\n   call assert_equal(['foobar', 'rare'], spellbadword('foo foobar'))\n\n  \" Typo should be detected even without the 'spell' option.\n  set spelllang=en_gb nospell\n  call assert_equal(['', ''], spellbadword('centre'))\n  call assert_equal(['bycycle', 'bad'], spellbadword('My bycycle.'))\n  call assert_equal(['another', 'caps'], spellbadword('A sentence. another sentence'))\n\n  set spelllang=\n  call assert_fails(\"call spellbadword('maxch')\", 'E756:')\n  call assert_fails(\"spelldump\", 'E756:')\n\n  call delete('Xwords.spl')\n  call delete('Xwords')\n  set spelllang&\n  set spell&\nendfunc\n\nfunc Test_spell_camelcase()\n  set spell spelloptions=camel\n  let words = [\n      \\ 'UPPER',\n      \\ 'lower',\n      \\ 'mixedCase',\n      \\ 'HTML',\n      \\ 'XMLHttpRequest',\n      \\ 'foo123bar',\n      \\ '12345678',\n      \\ 'HELLO123world',\n      \\]\n\n  for word in words\n    call assert_equal(['', ''],  spellbadword(word))\n  endfor\n\n  set spell& spelloptions&\nendfunc\n\nfunc Test_spell_file_missing()\n  let s:spell_file_missing = 0\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * let s:spell_file_missing += 1\n  augroup END\n\n  set spell spelllang=ab_cd\n  let messages = GetMessages()\n  call assert_equal('Warning: Cannot find word list \"ab.utf-8.spl\" or \"ab.ascii.spl\"', messages[-1])\n  call assert_equal(1, s:spell_file_missing)\n\n  new XTestSpellFileMissing\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing * bwipe\n  augroup END\n  call assert_fails('set spell spelllang=ab_cd', 'E937:')\n\n  \" clean up\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  unlet s:spell_file_missing\n  set spell& spelllang&\n  %bwipe!\nendfunc\n\nfunc Test_spell_file_missing_bwipe()\n  \" this was using a window that was wiped out in a SpellFileMissing autocmd\n  set spelllang=xy\n  au SpellFileMissing * n0\n  set spell\n  au SpellFileMissing * bw\n  snext somefile\n\n  au! SpellFileMissing\n  bwipe!\n  set nospell spelllang=en\nendfunc\n\nfunc Test_spelldump()\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n  set spell spelllang=en\n  spellrare! emacs\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    spelldump\n\n    \" Check assumption about region: 1: us, 2: au, 3: ca, 4: gb, 5: nz.\n    call assert_equal('/regions=usaucagbnz', getline(1))\n    call assert_notequal(0, search('^theater/1$'))    \" US English only.\n    call assert_notequal(0, search('^theatre/2345$')) \" AU, CA, GB or NZ English.\n\n    call assert_notequal(0, search('^emacs/?$'))      \" ? for a rare word.\n    call assert_notequal(0, search('^the the/!$'))    \" ! for a wrong word.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  bwipe\n  set spell&\nendfunc\n\nfunc Test_spelldump_bang()\n  new\n  call setline(1, 'This is a sample sentence.')\n  redraw\n\n  \" In case the spell file is not found avoid getting the download dialog, we\n  \" would get stuck at the prompt.\n  let g:en_not_found = 0\n  augroup TestSpellFileMissing\n    au! SpellFileMissing * let g:en_not_found = 1\n  augroup END\n\n  set spell\n\n  if g:en_not_found\n    call assert_report(\"Could not find English spell file\")\n  else\n    redraw\n    spelldump!\n\n    \" :spelldump! includes the number of times a word was found while updating\n    \" the screen.\n    \" Common word count starts at 10, regular word count starts at 0.\n    call assert_notequal(0, search(\"^is\\t11$\"))    \" common word found once.\n    call assert_notequal(0, search(\"^the\\t10$\"))   \" common word never found.\n    call assert_notequal(0, search(\"^sample\\t1$\")) \" regular word found once.\n    call assert_equal(0, search(\"^screen\\t\"))      \" regular word never found.\n  endif\n\n  \" clean up\n  unlet g:en_not_found\n  augroup TestSpellFileMissing\n    autocmd! SpellFileMissing\n  augroup END\n  augroup! TestSpellFileMissing\n  %bwipe!\n  set spell&\nendfunc\n\nfunc Test_spelllang_inv_region()\n  set spell spelllang=en_xx\n  let messages = GetMessages()\n  call assert_equal('Warning: region xx not supported', messages[-1])\n  set spell& spelllang&\nendfunc\n\nfunc Test_compl_with_CTRL_X_CTRL_K_using_spell()\n  \" When spell checking is enabled and 'dictionary' is empty,\n  \" CTRL-X CTRL-K in insert mode completes using the spelling dictionary.\n  new\n  set spell spelllang=en dictionary=\n\n  set ignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set noignorecase\n  call feedkeys(\"Senglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['englis'], getline(1, '$'))\n  call feedkeys(\"SEnglis\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['English'], getline(1, '$'))\n\n  set spelllang=en_us\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theater'], getline(1, '$'))\n  set spelllang=en_gb\n  call feedkeys(\"Stheat\\<c-x>\\<c-k>\\<esc>\", 'tnx')\n  call assert_equal(['theatre'], getline(1, '$'))\n\n  bwipe!\n  set spell& spelllang& dictionary& ignorecase&\nendfunc\n\nfunc Test_spellrepall()\n  new\n  set spell\n  call assert_fails('spellrepall', 'E752:')\n  call setline(1, ['A speling mistake. The same speling mistake.',\n        \\                'Another speling mistake.'])\n  call feedkeys(']s1z=', 'tx')\n  call assert_equal('A spelling mistake. The same speling mistake.', getline(1))\n  call assert_equal('Another speling mistake.', getline(2))\n  spellrepall\n  call assert_equal('A spelling mistake. The same spelling mistake.', getline(1))\n  call assert_equal('Another spelling mistake.', getline(2))\n  call assert_fails('spellrepall', 'E753:')\n  set spell&\n  bwipe!\nendfunc\n\nfunc Test_spell_dump_word_length()\n  \" this was running over MAXWLEN\n  new\n  noremap 0 0a0zW0000000\n  sil! norm \u00160z=0\u0018\u000b\n  sil norm 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n  sil! norm \u00160z=0\u0018\u000b\n\n  bwipe!\n  nunmap 0\nendfunc\n\n\" Test spellsuggest({word} [, {max} [, {capital}]])\nfunc Test_spellsuggest()\n  \" Verify suggestions are given even when spell checking is not enabled.\n  set nospell\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  set spell\n\n  \" With 1 argument.\n  call assert_equal(['march', 'March'], spellsuggest('marrch')[0:1])\n\n  \" With 2 arguments.\n  call assert_equal(['march', 'March'], spellsuggest('marrch', 2))\n\n  \" With 3 arguments.\n  call assert_equal(['march'], spellsuggest('marrch', 1, 0))\n  call assert_equal(['March'], spellsuggest('marrch', 1, 1))\n\n  \" Test with digits and hyphen.\n  call assert_equal('Carbon-14', spellsuggest('Carbon-15')[0])\n\n  \" Comment taken from spellsuggest.c explains the following test cases:\n  \"\n  \" If there are more UPPER than lower case letters suggest an\n  \" ALLCAP word.  Otherwise, if the first letter is UPPER then\n  \" suggest ONECAP.  Exception: \"ALl\" most likely should be \"All\",\n  \" require three upper case letters.\n  call assert_equal(['THIRD', 'third'], spellsuggest('thIRD', 2))\n  call assert_equal(['third', 'THIRD'], spellsuggest('tHIrd', 2))\n  call assert_equal(['Third'], spellsuggest('THird', 1))\n  call assert_equal(['All'],      spellsuggest('ALl', 1))\n\n  \" Special suggestion for repeated 'the the'.\n  call assert_inrange(0, 2, index(spellsuggest('the the',   3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('the   the', 3), 'the'))\n  call assert_inrange(0, 2, index(spellsuggest('The the',   3), 'The'))\n\n  call assert_fails(\"call spellsuggest('maxch', [])\", 'E745:')\n  call assert_fails(\"call spellsuggest('maxch', 2, [])\", 'E745:')\n\n  set spelllang=\n  call assert_fails(\"call spellsuggest('maxch')\", 'E756:')\n  set spelllang&\n\n  set spell&\nendfunc\n\n\" Test 'spellsuggest' option with methods fast, best and double.\nfunc Test_spellsuggest_option_methods()\n  set spell\n\n  for e in ['latin1', 'utf-8']\n    exe 'set encoding=' .. e\n\n    set spellsuggest=fast\n    call assert_equal(['Stick', 'Stitch'], spellsuggest('Stich', 2), e)\n\n    \" With best or double option, \"Stitch\" should become the top suggestion\n    \" because of better phonetic matching.\n    set spellsuggest=best\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n\n    set spellsuggest=double\n    call assert_equal(['Stitch', 'Stick'], spellsuggest('Stich', 2), e)\n  endfor\n\n  set spell& spellsuggest& encoding&\nendfunc\n\n\" Test 'spellsuggest' option with value file:{filename}\nfunc Test_spellsuggest_option_file()\n  set spell spellsuggest=file:Xspellsuggest\n  call writefile(['emacs/vim',\n        \\         'theribal/terrible',\n        \\         'teribal/terrrible',\n        \\         'terribal'],\n        \\         'Xspellsuggest')\n\n  call assert_equal(['vim'],      spellsuggest('emacs', 2))\n  call assert_equal(['terrible'], spellsuggest('theribal',2))\n\n  \" If the suggestion is misspelled (*terrrible* with 3 r),\n  \" it should not be proposed.\n  \" The entry for \"terribal\" should be ignored because of missing slash.\n  call assert_equal([], spellsuggest('teribal', 2))\n  call assert_equal([], spellsuggest('terribal', 2))\n\n  set spell spellsuggest=best,file:Xspellsuggest\n  call assert_equal(['vim', 'Emacs'],       spellsuggest('emacs', 2))\n  call assert_equal(['terrible', 'tribal'], spellsuggest('theribal', 2))\n  call assert_equal(['tribal'],             spellsuggest('teribal', 1))\n  call assert_equal(['tribal'],             spellsuggest('terribal', 1))\n\n  call delete('Xspellsuggest')\n  call assert_fails(\"call spellsuggest('vim')\", \"E484: Can't open file Xspellsuggest\")\n\n  set spellsuggest& spell&\nendfunc\n\n\" Test 'spellsuggest' option with value {number}\n\" to limit the number of suggestions\nfunc Test_spellsuggest_option_number()\n  set spell spellsuggest=2,best\n  new\n\n  \" We limited the number of suggestions to 2, so selecting\n  \" the 1st and 2nd suggestion should correct the word, but\n  \" selecting a 3rd suggestion should do nothing.\n  call setline(1, 'A baord')\n  norm $1z=\n  call assert_equal('A board', getline(1))\n\n  call setline(1, 'A baord')\n  norm $2z=\n  call assert_equal('A bard', getline(1))\n\n  call setline(1, 'A baord')\n  norm $3z=\n  call assert_equal('A baord', getline(1))\n\n  let a = execute('norm $z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"board\\\"\\n\"\n  \\ .. \" 2 \\\"bard\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell spellsuggest=0\n  call assert_equal(\"\\nSorry, no suggestions\", execute('norm $z='))\n\n  \" Unlike z=, function spellsuggest(...) should not be affected by the\n  \" max number of suggestions (2) set by the 'spellsuggest' option.\n  call assert_equal(['board', 'bard', 'broad'], spellsuggest('baord', 3))\n\n  set spellsuggest& spell&\n  bwipe!\nendfunc\n\n\" Test 'spellsuggest' option with value expr:{expr}\nfunc Test_spellsuggest_option_expr()\n  \" A silly 'spellsuggest' function which makes suggestions all uppercase\n  \" and makes the score of each suggestion the length of the suggested word.\n  \" So shorter suggestions are preferred.\n  func MySuggest()\n    let spellsuggest_save = &spellsuggest\n    set spellsuggest=3,best\n    let result = map(spellsuggest(v:val, 3), \"[toupper(v:val), len(v:val)]\")\n    let &spellsuggest = spellsuggest_save\n    return result\n  endfunc\n\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal(['BARD', 'BOARD', 'BROAD'], spellsuggest('baord', 3))\n\n  new\n  call setline(1, 'baord')\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  \" With verbose, z= should show the score i.e. word length with\n  \" our SpellSuggest() function.\n  set verbose=1\n  let a = execute('norm z=')\n  call assert_equal(\n  \\    \"\\n\"\n  \\ .. \"Change \\\"baord\\\" to:\\n\"\n  \\ .. \" 1 \\\"BARD\\\"                      (4 - 0)\\n\"\n  \\ .. \" 2 \\\"BOARD\\\"                     (5 - 0)\\n\"\n  \\ .. \" 3 \\\"BROAD\\\"                     (5 - 0)\\n\"\n  \\ .. \"Type number and <Enter> or click with the mouse (q or empty cancels): \", a)\n\n  set spell& spellsuggest& verbose&\n  bwipe!\nendfunc\n\n\" Test for 'spellsuggest' expr errors\nfunc Test_spellsuggest_expr_errors()\n  \" 'spellsuggest'\n  func MySuggest()\n    return range(3)\n  endfunc\n  set spell spellsuggest=expr:MySuggest()\n  call assert_equal([], spellsuggest('baord', 3))\n\n  \" Test for 'spellsuggest' expression returning a non-list value\n  func! MySuggest2()\n    return 'good'\n  endfunc\n  set spellsuggest=expr:MySuggest2()\n  call assert_equal([], spellsuggest('baord'))\n\n  \" Test for 'spellsuggest' expression returning a list with dict values\n  func! MySuggest3()\n    return [[{}, {}]]\n  endfunc\n  set spellsuggest=expr:MySuggest3()\n  call assert_fails(\"call spellsuggest('baord')\", 'E731:')\n\n  set nospell spellsuggest&\n  delfunc MySuggest\n  delfunc MySuggest2\n  delfunc MySuggest3\nendfunc\n\nfunc Test_spellsuggest_timeout()\n  set spellsuggest=timeout:30\n  set spellsuggest=timeout:-123\n  set spellsuggest=timeout:999999\n  call assert_fails('set spellsuggest=timeout', 'E474:')\n  call assert_fails('set spellsuggest=timeout:x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:-x', 'E474:')\n  call assert_fails('set spellsuggest=timeout:--9', 'E474:')\nendfunc\n\nfunc Test_spellsuggest_visual_end_of_line()\n  let enc_save = &encoding\n  set encoding=iso8859\n\n  \" This was reading beyond the end of the line.\n  norm R00000000000\n  sil norm \u00160\n  sil! norm \u0016i00000)\n  sil! norm \u0016i00000)\n  call feedkeys(\"\\<CR>\")\n  norm z=\n\n  let &encoding = enc_save\nendfunc\n\nfunc Test_spellinfo()\n  new\n  let runtime = substitute($VIMRUNTIME, '\\\\', '/', 'g')\n\n  set enc=latin1 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set enc=cp1250 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.ascii.spl\\n$\", execute('spellinfo'))\n\n  set enc=utf-8 spell spelllang=en\n  call assert_match(\"^\\nfile: \" .. runtime .. \"/spell/en.utf-8.spl\\n$\", execute('spellinfo'))\n\n  set enc=latin1 spell spelllang=en_us,en_nz\n  call assert_match(\"^\\n\" .\n                 \\  \"file: \" .. runtime .. \"/spell/en.latin1.spl\\n\" .\n                 \\  \"file: \" .. runtime.. \"/spell/en.latin1.spl\\n$\", execute('spellinfo'))\n\n  set spell spelllang=\n  call assert_fails('spellinfo', 'E756:')\n\n  set nospell spelllang=en\n  call assert_fails('spellinfo', 'E756:')\n\n  call assert_fails('set spelllang=foo/bar', 'E474:')\n  call assert_fails('set spelllang=foo\\ bar', 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\nbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo\\\\\\rbar\", 'E474:')\n  call assert_fails(\"set spelllang=foo+bar\", 'E474:')\n\n  set enc& spell& spelllang&\n  bwipe\nendfunc\n\nfunc Test_zz_basic()\n  call LoadAffAndDic(g:test_data_aff1, g:test_data_dic1)\n  call RunGoodBad(\"wrong OK puts. Test the end\",\n        \\ \"bad: inputs comment ok Ok. test d\\xE9\\xF4l end the\",\n        \\[\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"input\", \"OK\", \"output\", \"outputs\", \"outtest\", \"put\", \"puts\",\n        \\  \"test\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\[\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\", \"outtest\", \"the end\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\ ]\n        \\ )\n\n  call assert_equal(\"gebletegek\", soundfold('goobledygoook'))\n  call assert_equal(\"kepereneven\", 'k\u00f3op\u00ebr\u02d9n\u00f4ven'->soundfold())\n  call assert_equal(\"everles gesvets etele\", soundfold('oeverloos gezwets edale'))\nendfunc\n\n\" Postponed prefixes\nfunc Test_zz_prefixes()\n  call LoadAffAndDic(g:test_data_aff2, g:test_data_dic1)\n  call RunGoodBad(\"puts\",\n        \\ \"bad: inputs comment ok Ok end the. test d\\xE9\\xF4l\",\n        \\ [\"Comment\", \"deol\", \"d\\xE9\\xF4r\", \"OK\", \"put\", \"input\", \"output\", \"puts\", \"outputs\", \"test\", \"outtest\", \"testen\", \"testn\", \"the end\", \"uk\", \"wrong\"],\n        \\ [\n        \\   [\"bad\", [\"put\", \"uk\", \"OK\"]],\n        \\   [\"inputs\", [\"input\", \"puts\", \"outputs\"]],\n        \\   [\"comment\", [\"Comment\"]],\n        \\   [\"ok\", [\"OK\", \"uk\", \"put\"]],\n        \\   [\"Ok\", [\"OK\", \"Uk\", \"Put\"]],\n        \\   [\"end\", [\"put\", \"uk\", \"deol\"]],\n        \\   [\"the\", [\"put\", \"uk\", \"test\"]],\n        \\   [\"test\", [\"Test\", \"testn\", \"testen\"]],\n        \\   [\"d\\xE9\\xF4l\", [\"deol\", \"d\\xE9\\xF4r\", \"test\"]],\n        \\ ])\nendfunc\n\n\"Compound words\nfunc Test_zz_compound()\n  call LoadAffAndDic(g:test_data_aff3, g:test_data_dic3)\n  call RunGoodBad(\"foo m\\xEF foobar foofoobar barfoo barbarfoo\",\n        \\ \"bad: bar la foom\\xEF barm\\xEF m\\xEFfoo m\\xEFbar m\\xEFm\\xEF lala m\\xEFla lam\\xEF foola labar\",\n        \\ [\"foo\", \"m\\xEF\"],\n        \\ [\n        \\   [\"bad\", [\"foo\", \"m\\xEF\"]],\n        \\   [\"bar\", [\"barfoo\", \"foobar\", \"foo\"]],\n        \\   [\"la\", [\"m\\xEF\", \"foo\"]],\n        \\   [\"foom\\xEF\", [\"foo m\\xEF\", \"foo\", \"foofoo\"]],\n        \\   [\"barm\\xEF\", [\"barfoo\", \"m\\xEF\", \"barbar\"]],\n        \\   [\"m\\xEFfoo\", [\"m\\xEF foo\", \"foo\", \"foofoo\"]],\n        \\   [\"m\\xEFbar\", [\"foobar\", \"barbar\", \"m\\xEF\"]],\n        \\   [\"m\\xEFm\\xEF\", [\"m\\xEF m\\xEF\", \"m\\xEF\"]],\n        \\   [\"lala\", []],\n        \\   [\"m\\xEFla\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"lam\\xEF\", [\"m\\xEF\", \"m\\xEF m\\xEF\"]],\n        \\   [\"foola\", [\"foo\", \"foobar\", \"foofoo\"]],\n        \\   [\"labar\", [\"barbar\", \"foobar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff4, g:test_data_dic4)\n  call RunGoodBad(\"word util bork prebork start end wordutil wordutils pro-ok bork borkbork borkborkbork borkborkborkbork borkborkborkborkbork tomato tomatotomato startend startword startwordword startwordend startwordwordend startwordwordwordend prebork preborkbork preborkborkbork nouword\",\n        \\ \"bad: wordutilize pro borkborkborkborkborkbork tomatotomatotomato endstart endend startstart wordend wordstart preborkprebork  preborkpreborkbork startwordwordwordwordend borkpreborkpreborkbork utilsbork  startnouword\",\n        \\ [\"bork\", \"prebork\", \"end\", \"pro-ok\", \"start\", \"tomato\", \"util\", \"utilize\", \"utils\", \"word\", \"nouword\"],\n        \\ [\n        \\   [\"bad\", [\"end\", \"bork\", \"word\"]],\n        \\   [\"wordutilize\", [\"word utilize\", \"wordutils\", \"wordutil\"]],\n        \\   [\"pro\", [\"bork\", \"word\", \"end\"]],\n        \\   [\"borkborkborkborkborkbork\", [\"bork borkborkborkborkbork\", \"borkbork borkborkborkbork\", \"borkborkbork borkborkbork\"]],\n        \\   [\"tomatotomatotomato\", [\"tomato tomatotomato\", \"tomatotomato tomato\", \"tomato tomato tomato\"]],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"endend\", [\"end end\", \"end\"]],\n        \\   [\"startstart\", [\"start start\"]],\n        \\   [\"wordend\", [\"word end\", \"word\", \"wordword\"]],\n        \\   [\"wordstart\", [\"word start\", \"bork start\"]],\n        \\   [\"preborkprebork\", [\"prebork prebork\", \"preborkbork\", \"preborkborkbork\"]],\n        \\   [\"preborkpreborkbork\", [\"prebork preborkbork\", \"preborkborkbork\", \"preborkborkborkbork\"]],\n        \\   [\"startwordwordwordwordend\", [\"startwordwordwordword end\", \"startwordwordwordword\", \"start wordwordwordword end\"]],\n        \\   [\"borkpreborkpreborkbork\", [\"bork preborkpreborkbork\", \"bork prebork preborkbork\", \"bork preborkprebork bork\"]],\n        \\   [\"utilsbork\", [\"utilbork\", \"utils bork\", \"util bork\"]],\n        \\   [\"startnouword\", [\"start nouword\", \"startword\", \"startborkword\"]],\n        \\ ])\n\nendfunc\n\n\"Test affix flags with two characters\nfunc Test_zz_affix()\n  call LoadAffAndDic(g:test_data_aff5, g:test_data_dic5)\n  call RunGoodBad(\"fooa1 fooa\\xE9 bar prebar barbork prebarbork  startprebar start end startend  startmiddleend nouend\",\n        \\ \"bad: foo fooa2 prabar probarbirk middle startmiddle middleend endstart startprobar startnouend\",\n        \\ [\"bar\", \"barbork\", \"end\", \"fooa1\", \"fooa\\xE9\", \"nouend\", \"prebar\", \"prebarbork\", \"start\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"fooa1\"]],\n        \\   [\"foo\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"fooa2\", [\"fooa1\", \"fooa\\xE9\", \"bar\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"bar bar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"startmiddle\", [\"startmiddleend\", \"startmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endstart\", [\"end start\", \"start\"]],\n        \\   [\"startprobar\", [\"startprebar\", \"start prebar\", \"startbar\"]],\n        \\   [\"startnouend\", [\"start nouend\", \"startend\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff6, g:test_data_dic6)\n  call RunGoodBad(\"meea1 meea\\xE9 bar prebar barbork prebarbork  leadprebar lead end leadend  leadmiddleend\",\n        \\  \"bad: mee meea2 prabar probarbirk middle leadmiddle middleend endlead leadprobar\",\n        \\ [\"bar\", \"barbork\", \"end\", \"lead\", \"meea1\", \"meea\\xE9\", \"prebar\", \"prebarbork\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"end\", \"lead\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarbirk\", [\"prebarbork\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddleend\", \"leadmiddlebar\"]],\n        \\   [\"middleend\", []],\n        \\   [\"endlead\", [\"end lead\", \"lead\", \"end end\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\n\n  call LoadAffAndDic(g:test_data_aff7, g:test_data_dic7)\n  call RunGoodBad(\"meea1 meezero meea\\xE9 bar prebar barmeat prebarmeat  leadprebar lead tail leadtail  leadmiddletail\",\n        \\ \"bad: mee meea2 prabar probarmaat middle leadmiddle middletail taillead leadprobar\",\n        \\ [\"bar\", \"barmeat\", \"lead\", \"meea1\", \"meea\\xE9\", \"meezero\", \"prebar\", \"prebarmeat\", \"tail\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"lead\", \"tail\"]],\n        \\   [\"mee\", [\"meea1\", \"meea\\xE9\", \"bar\"]],\n        \\   [\"meea2\", [\"meea1\", \"meea\\xE9\", \"lead\"]],\n        \\   [\"prabar\", [\"prebar\", \"bar\", \"leadbar\"]],\n        \\   [\"probarmaat\", [\"prebarmeat\"]],\n        \\   [\"middle\", []],\n        \\   [\"leadmiddle\", [\"leadmiddlebar\"]],\n        \\   [\"middletail\", []],\n        \\   [\"taillead\", [\"tail lead\", \"tail\"]],\n        \\   [\"leadprobar\", [\"leadprebar\", \"lead prebar\", \"leadbar\"]],\n        \\ ])\nendfunc\n\nfunc Test_zz_NOSLITSUGS()\n  call LoadAffAndDic(g:test_data_aff8, g:test_data_dic8)\n  call RunGoodBad(\"foo bar faabar\", \"bad: foobar barfoo\",\n        \\ [\"bar\", \"faabar\", \"foo\"],\n        \\ [\n        \\   [\"bad\", [\"bar\", \"foo\"]],\n        \\   [\"foobar\", [\"faabar\", \"foo bar\", \"bar\"]],\n        \\   [\"barfoo\", [\"bar foo\", \"bar\", \"foo\"]],\n        \\ ])\nendfunc\n\n\" Numbers\nfunc Test_zz_Numbers()\n  call LoadAffAndDic(g:test_data_aff9, g:test_data_dic9)\n  call RunGoodBad(\"0b1011 0777 1234 0x01ff\", \"\",\n        \\ [\"bar\", \"foo\"],\n        \\ [\n        \\ ])\nendfunc\n\n\" Affix flags\nfunc Test_zz_affix_flags()\n  call LoadAffAndDic(g:test_data_aff10, g:test_data_dic10)\n  call RunGoodBad(\"drink drinkable drinkables drinktable drinkabletable\",\n\t\\ \"bad: drinks drinkstable drinkablestable\",\n        \\ [\"drink\", \"drinkable\", \"drinkables\", \"table\"],\n        \\ [['bad', []],\n\t\\ ['drinks', ['drink']],\n\t\\ ['drinkstable', ['drinktable', 'drinkable', 'drink table']],\n        \\ ['drinkablestable', ['drinkabletable', 'drinkables table', 'drinkable table']],\n\t\\ ])\nendfunc\n\nfunction FirstSpellWord()\n  call feedkeys(\"/^start:\\n\", 'tx')\n  normal ]smm\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\nfunction SecondSpellWord()\n  normal `m]s\n  let [str, a] = spellbadword()\n  return str\nendfunc\n\n\"Test with SAL instead of SOFO items; test automatic reloading\nfunc Test_zz_sal_and_addition()\n  set enc=latin1\n  set spellfile=\n  call writefile(g:test_data_dic1, \"Xtest.dic\", 'D')\n  call writefile(g:test_data_aff_sal, \"Xtest.aff\", 'D')\n  mkspell! Xtest Xtest\n  set spl=Xtest.latin1.spl spell\n  call assert_equal('kbltykk', soundfold('goobledygoook'))\n  call assert_equal('kprnfn', soundfold('k\u00f3op\u00ebr\u02d9n\u00f4ven'))\n  call assert_equal('*fls kswts tl', soundfold('oeverloos gezwets edale'))\n\n  \"also use an addition file\n  call writefile([\"/regions=usgbnz\", \"elequint/2\", \"elekwint/3\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n\n  bwipe!\n  call setline(1, [\"start: elequint test elekwint test elekwent asdf\"])\n\n  set spellfile=Xtest.latin1.add\n  call assert_equal(\"elekwent\", FirstSpellWord())\n\n  set spl=Xtest_us.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  set spl=Xtest_gb.latin1.spl\n  call assert_equal(\"elekwint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_nz.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwent\", SecondSpellWord())\n\n  set spl=Xtest_ca.latin1.spl\n  call assert_equal(\"elequint\", FirstSpellWord())\n  call assert_equal(\"elekwint\", SecondSpellWord())\n\n  bwipe!\n  set spellfile=\n  set spl&\nendfunc\n\nfunc Test_spellfile_value()\n  set spellfile=Xdir/Xtest.latin1.add\n  set spellfile=Xdir/Xtest.utf-8.add,Xtest_other.add\nendfunc\n\nfunc Test_region_error()\n  messages clear\n  call writefile([\"/regions=usgbnz\", \"elequint/0\"], \"Xtest.latin1.add\", 'D')\n  mkspell! Xtest.latin1.add.spl Xtest.latin1.add\n  call assert_match('Invalid region nr in Xtest.latin1.add line 2: 0', execute('messages'))\n  call delete('Xtest.latin1.add.spl')\nendfunc\n\n\" Check using z= in new buffer (crash fixed by patch 7.4a.028).\nfunc Test_zeq_crash()\n  new\n  set maxmem=512 spell\n  call feedkeys('iasd\u001bz=:\\\"', 'tx')\n\n  bwipe!\nendfunc\n\n\" Check that z= works even when 'nospell' is set.  This test uses one of the\n\" tests in Test_spellsuggest_option_number() just to verify that z= basically\n\" works and that \"E756: Spell checking is not enabled\" is not generated.\nfunc Test_zeq_nospell()\n  new\n  set nospell spellsuggest=1,best\n  call setline(1, 'A baord')\n  try\n    norm $1z=\n    call assert_equal('A board', getline(1))\n  catch\n    call assert_report(\"Caught exception: \" . v:exception)\n  endtry\n  set spell& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check that \"E756: Spell checking is not possible\" is reported when z= is\n\" executed and 'spelllang' is empty.\nfunc Test_zeq_no_spelllang()\n  new\n  set spelllang= spellsuggest=1,best\n  call setline(1, 'A baord')\n  call assert_fails('normal $1z=', 'E756:')\n  set spelllang& spellsuggest&\n  bwipe!\nendfunc\n\n\" Check handling a word longer than MAXWLEN.\nfunc Test_spell_long_word()\n  set enc=utf-8\n  new\n  call setline(1, \"d\\xCC\\xB4\\xCC\\xBD\\xCD\\x88\\xCD\\x94a\\xCC\\xB5\\xCD\\x84\\xCD\\x84\\xCC\\xA8\\xCD\\x9Cr\\xCC\\xB5\\xCC\\x8E\\xCD\\x85\\xCD\\x85k\\xCC\\xB6\\xCC\\x89\\xCC\\x9D \\xCC\\xB6\\xCC\\x83\\xCC\\x8F\\xCC\\xA4\\xCD\\x8Ef\\xCC\\xB7\\xCC\\x81\\xCC\\x80\\xCC\\xA9\\xCC\\xB0\\xCC\\xAC\\xCC\\xA2\\xCD\\x95\\xCD\\x87\\xCD\\x8D\\xCC\\x9E\\xCD\\x99\\xCC\\xAD\\xCC\\xAB\\xCC\\x97\\xCC\\xBBo\\xCC\\xB6\\xCC\\x84\\xCC\\x95\\xCC\\x8C\\xCC\\x8B\\xCD\\x9B\\xCD\\x9C\\xCC\\xAFr\\xCC\\xB7\\xCC\\x94\\xCD\\x83\\xCD\\x97\\xCC\\x8C\\xCC\\x82\\xCD\\x82\\xCD\\x80\\xCD\\x91\\xCC\\x80\\xCC\\xBE\\xCC\\x82\\xCC\\x8F\\xCC\\xA3\\xCD\\x85\\xCC\\xAE\\xCD\\x8D\\xCD\\x99\\xCC\\xBC\\xCC\\xAB\\xCC\\xA7\\xCD\\x88c\\xCC\\xB7\\xCD\\x83\\xCC\\x84\\xCD\\x92\\xCC\\x86\\xCC\\x83\\xCC\\x88\\xCC\\x92\\xCC\\x94\\xCC\\xBE\\xCC\\x9D\\xCC\\xAF\\xCC\\x98\\xCC\\x9D\\xCC\\xBB\\xCD\\x8E\\xCC\\xBB\\xCC\\xB3\\xCC\\xA3\\xCD\\x8E\\xCD\\x99\\xCC\\xA5\\xCC\\xAD\\xCC\\x99\\xCC\\xB9\\xCC\\xAE\\xCC\\xA5\\xCC\\x9E\\xCD\\x88\\xCC\\xAE\\xCC\\x9E\\xCC\\xA9\\xCC\\x97\\xCC\\xBC\\xCC\\x99\\xCC\\xA5\\xCD\\x87\\xCC\\x97\\xCD\\x8E\\xCD\\x94\\xCC\\x99\\xCC\\x9D\\xCC\\x96\\xCD\\x94\\xCC\\xAB\\xCC\\xA7\\xCC\\xA5\\xCC\\x98\\xCC\\xBB\\xCC\\xAF\\xCC\\xABe\\xCC\\xB7\\xCC\\x8E\\xCC\\x82\\xCD\\x86\\xCD\\x9B\\xCC\\x94\\xCD\\x83\\xCC\\x85\\xCD\\x8A\\xCD\\x8C\\xCC\\x8B\\xCD\\x92\\xCD\\x91\\xCC\\x8F\\xCC\\x81\\xCD\\x95\\xCC\\xA2\\xCC\\xB9\\xCC\\xB2\\xCD\\x9C\\xCC\\xB1\\xCC\\xA6\\xCC\\xB3\\xCC\\xAF\\xCC\\xAE\\xCC\\x9C\\xCD\\x99s\\xCC\\xB8\\xCC\\x8C\\xCC\\x8E\\xCC\\x87\\xCD\\x81\\xCD\\x82\\xCC\\x86\\xCD\\x8C\\xCD\\x8C\\xCC\\x8B\\xCC\\x84\\xCC\\x8C\\xCD\\x84\\xCD\\x9B\\xCD\\x86\\xCC\\x93\\xCD\\x90\\xCC\\x85\\xCC\\x94\\xCD\\x98\\xCD\\x84\\xCD\\x92\\xCD\\x8B\\xCC\\x90\\xCC\\x83\\xCC\\x8F\\xCD\\x84\\xCD\\x81\\xCD\\x9B\\xCC\\x90\\xCD\\x81\\xCC\\x8F\\xCC\\xBD\\xCC\\x88\\xCC\\xBF\\xCC\\x88\\xCC\\x84\\xCC\\x8E\\xCD\\x99\\xCD\\x94\\xCC\\x99\\xCD\\x99\\xCC\\xB0\\xCC\\xA8\\xCC\\xA3\\xCC\\xA8\\xCC\\x96\\xCC\\x99\\xCC\\xAE\\xCC\\xBC\\xCC\\x99\\xCD\\x9A\\xCC\\xB2\\xCC\\xB1\\xCC\\x9F\\xCC\\xBB\\xCC\\xA6\\xCD\\x85\\xCC\\xAA\\xCD\\x89\\xCC\\x9D\\xCC\\x99\\xCD\\x96\\xCC\\xB1\\xCC\\xB1\\xCC\\x99\\xCC\\xA6\\xCC\\xA5\\xCD\\x95\\xCC\\xB2\\xCC\\xA0\\xCD\\x99 within\")\n  set spell spelllang=en\n  redraw\n  redraw!\n  bwipe!\n  set nospell\nendfunc\n\nfunc Test_spellsuggest_too_deep()\n  \" This was incrementing \"depth\" over MAXWLEN.\n  new\n  norm \u0016s000G00\u00fd000000000000\n  sil norm ..vzG................vvzG0     v z=\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_invalid()\n  \" This was adding a word with a 0x02 byte, which causes havoc.\n  enew\n  norm o0\n  sil! norm rzzWs00\u0002/\n  2\n  sil! norm VzGprzzW\n  sil! norm z=\n\n  bwipe!\nendfunc\n\nfunc Test_spell_good_word_slash()\n  \" This caused E1280.\n  new\n  norm afoo /\n  1\n  norm zG\n\n  bwipe!\nendfunc\n\nfunc LoadAffAndDic(aff_contents, dic_contents)\n  set enc=latin1\n  set spellfile=\n  call writefile(a:aff_contents, \"Xtest.aff\")\n  call writefile(a:dic_contents, \"Xtest.dic\")\n  \" Generate a .spl file from a .dic and .aff file.\n  mkspell! Xtest Xtest\n  \" use that spell file\n  set spl=Xtest.latin1.spl spell\nendfunc\n\nfunc ListWords()\n  spelldump\n  %yank\n  quit\n  return split(@\", \"\\n\")\nendfunc\n\nfunc TestGoodBadBase()\n  exe '1;/^good:'\n  normal 0f:]s\n  let prevbad = ''\n  let result = []\n  while 1\n    let [bad, a] = spellbadword()\n    if bad == '' || bad == prevbad || bad == 'badend'\n      break\n    endif\n    let prevbad = bad\n    let lst = bad->spellsuggest(3)\n    normal mm\n\n    call add(result, [bad, lst])\n    normal `m]s\n  endwhile\n  return result\nendfunc\n\nfunc RunGoodBad(good, bad, expected_words, expected_bad_words)\n  bwipe!\n  call setline(1, [\"good: \", a:good,  a:bad, \" badend \"])\n  let words = ListWords()\n  call assert_equal(a:expected_words, words[1:-1])\n  let bad_words = TestGoodBadBase()\n  call assert_equal(a:expected_bad_words, bad_words)\n  bwipe!\nendfunc\n\nfunc Test_spell_screendump()\n  CheckScreendump\n\n  let lines =<< trim END\n       call test_override('alloc_lines', 1)\n       call setline(1, [\n             \\ \"This is some text without any spell errors.  Everything\",\n             \\ \"should just be black, nothing wrong here.\",\n             \\ \"\",\n             \\ \"This line has a sepll error. and missing caps.\",\n             \\ \"And and this is the the duplication.\",\n             \\ \"with missing caps here.\",\n             \\ ])\n       set spell spelllang=en_nz\n  END\n  call writefile(lines, 'XtestSpell', 'D')\n  let buf = RunVimInTerminal('-S XtestSpell', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_1', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_screendump_spellcap()\n  CheckScreendump\n\n  let lines =<< trim END\n       call test_override('alloc_lines', 1)\n       call setline(1, [\n             \\ \"   This line has a sepll error. and missing caps and trailing spaces.   \",\n             \\ \"another missing cap here.\",\n             \\ \"\",\n             \\ \"and here.\",\n             \\ \"    \",\n             \\ \"and here.\"\n             \\ ])\n       set spell spelllang=en\n  END\n  call writefile(lines, 'XtestSpellCap', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellCap', {'rows': 8})\n  call VerifyScreenDump(buf, 'Test_spell_2', {})\n\n  \" After adding word missing Cap in next line is updated\n  call term_sendkeys(buf, \"3GANot\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_3', {})\n\n  \" Deleting a full stop removes missing Cap in next line\n  call term_sendkeys(buf, \"5Gdd\\<C-L>k$x\")\n  call VerifyScreenDump(buf, 'Test_spell_4', {})\n\n  \" Undo also updates the next line (go to command line to remove message)\n  call term_sendkeys(buf, \"u:\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_5', {})\n\n  \" Folding an empty line does not remove Cap in next line\n  call term_sendkeys(buf, \"uzfk:\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_6', {})\n\n  \" Folding the end of a sentence does not remove Cap in next line\n  \" and editing a line does not remove Cap in current line\n  call term_sendkeys(buf, \"Jzfkk$x\")\n  call VerifyScreenDump(buf, 'Test_spell_7', {})\n\n  \" Cap is correctly applied in the first row of a window\n  call term_sendkeys(buf, \"\\<C-E>\\<C-L>\")\n  call VerifyScreenDump(buf, 'Test_spell_8', {})\n\n  \" Adding an empty line does not remove Cap in \"mod_bot\" area\n  call term_sendkeys(buf, \"zbO\\<Esc>\")\n  call VerifyScreenDump(buf, 'Test_spell_9', {})\n\n  \" Multiple empty lines does not remove Cap in the line after\n  call term_sendkeys(buf, \"O\\<Esc>\\<C-L>\")\n  call VerifyScreenDump(buf, 'Test_spell_10', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_spell_compatible()\n  CheckScreendump\n\n  let lines =<< trim END\n       call test_override('alloc_lines', 1)\n       call setline(1, [\n             \\ \"test \"->repeat(20),\n             \\ \"\",\n             \\ \"end\",\n             \\ ])\n       set spell cpo+=$\n  END\n  call writefile(lines, 'XtestSpellComp', 'D')\n  let buf = RunVimInTerminal('-S XtestSpellComp', {'rows': 8})\n\n  call term_sendkeys(buf, \"51|C\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_1', {})\n\n  call term_sendkeys(buf, \"x\")\n  call VerifyScreenDump(buf, 'Test_spell_compatible_2', {})\n\n  \" clean up\n  call StopVimInTerminal(buf)\nendfunc\n\nfunc Test_z_equal_with_large_count()\n  split\n  set spell\n  call setline(1, \"ff\")\n  norm 0z=337203685477580\n  set nospell\n  bwipe!\nendfunc\n\nlet g:test_data_aff1 = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"SOFOFROM abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xBF\",\n      \\\"SOFOTO   ebctefghejklnnepkrstevvkesebctefghejklnnepkrstevvkeseeeeeeeceeeeeeeedneeeeeeeeeeepseeeeeeeeceeeeeeeedneeeeeeeeeeep?\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_dic1 = [\n      \\\"123456\",\n      \\\"test/NO\",\n      \\\"# comment\",\n      \\\"wrong\",\n      \\\"Comment\",\n      \\\"OK\",\n      \\\"uk\",\n      \\\"put/ISO\",\n      \\\"the end\",\n      \\\"deol\",\n      \\\"d\\xE9\\xF4r\",\n      \\ ]\nlet g:test_data_aff2 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out [a-z]\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\ ]\nlet g:test_data_aff3 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDRULE m*\",\n      \\\"NEEDCOMPOUND x\",\n      \\ ]\nlet g:test_data_dic3 = [\n      \\\"1234\",\n      \\\"foo/m\",\n      \\\"bar/mx\",\n      \\\"m\\xEF/m\",\n      \\\"la/mx\",\n      \\ ]\nlet g:test_data_aff4 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"COMPOUNDRULE m+\",\n      \\\"COMPOUNDRULE sm*e\",\n      \\\"COMPOUNDRULE sm+\",\n      \\\"COMPOUNDMIN 3\",\n      \\\"COMPOUNDWORDMAX 3\",\n      \\\"COMPOUNDFORBIDFLAG t\",\n      \\\"\",\n      \\\"COMPOUNDSYLMAX 5\",\n      \\\"SYLLABLE a\\xE1e\\xE9i\\xEDo\\xF3\\xF6\\xF5u\\xFA\\xFC\\xFBy/aa/au/ea/ee/ei/ie/oa/oe/oo/ou/uu/ui\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"NEEDAFFIX x\",\n      \\\"\",\n      \\\"PFXPOSTPONE\",\n      \\\"\",\n      \\\"MIDWORD '-\",\n      \\\"\",\n      \\\"SFX q N 1\",\n      \\\"SFX q   0    -ok .\",\n      \\\"\",\n      \\\"SFX a Y 2\",\n      \\\"SFX a 0 s .\",\n      \\\"SFX a 0 ize/t .\",\n      \\\"\",\n      \\\"PFX p N 1\",\n      \\\"PFX p 0 pre .\",\n      \\\"\",\n      \\\"PFX P N 1\",\n      \\\"PFX P 0 nou .\",\n      \\ ]\nlet g:test_data_dic4 = [\n      \\\"1234\",\n      \\\"word/mP\",\n      \\\"util/am\",\n      \\\"pro/xq\",\n      \\\"tomato/m\",\n      \\\"bork/mp\",\n      \\\"start/s\",\n      \\\"end/e\",\n      \\ ]\nlet g:test_data_aff5 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG long\",\n      \\\"\",\n      \\\"NEEDAFFIX !!\",\n      \\\"\",\n      \\\"COMPOUNDRULE ssmm*ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND xx\",\n      \\\"COMPOUNDPERMITFLAG pp\",\n      \\\"\",\n      \\\"SFX 13 Y 1\",\n      \\\"SFX 13 0 bork .\",\n      \\\"\",\n      \\\"SFX a1 Y 1\",\n      \\\"SFX a1 0 a1 .\",\n      \\\"\",\n      \\\"SFX a\\xE9 Y 1\",\n      \\\"SFX a\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX zz Y 1\",\n      \\\"PFX zz 0 pre/pp .\",\n      \\\"\",\n      \\\"PFX yy Y 1\",\n      \\\"PFX yy 0 nou .\",\n      \\ ]\nlet g:test_data_dic5 = [\n      \\\"1234\",\n      \\\"foo/a1a\\xE9!!\",\n      \\\"bar/zz13ee\",\n      \\\"start/ss\",\n      \\\"end/eeyy\",\n      \\\"middle/mmxx\",\n      \\ ]\nlet g:test_data_aff6 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG caplong\",\n      \\\"\",\n      \\\"NEEDAFFIX A!\",\n      \\\"\",\n      \\\"COMPOUNDRULE sMm*Ee\",\n      \\\"\",\n      \\\"NEEDCOMPOUND Xx\",\n      \\\"\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX N3 Y 1\",\n      \\\"SFX N3 0 bork .\",\n      \\\"\",\n      \\\"SFX A1 Y 1\",\n      \\\"SFX A1 0 a1 .\",\n      \\\"\",\n      \\\"SFX A\\xE9 Y 1\",\n      \\\"SFX A\\xE9 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX Zz Y 1\",\n      \\\"PFX Zz 0 pre/p .\",\n      \\ ]\nlet g:test_data_dic6 = [\n      \\\"1234\",\n      \\\"mee/A1A\\xE9A!\",\n      \\\"bar/ZzN3Ee\",\n      \\\"lead/s\",\n      \\\"end/Ee\",\n      \\\"middle/MmXx\",\n      \\ ]\nlet g:test_data_aff7 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"FLAG num\",\n      \\\"\",\n      \\\"NEEDAFFIX 9999\",\n      \\\"\",\n      \\\"COMPOUNDRULE 2,77*123\",\n      \\\"\",\n      \\\"NEEDCOMPOUND 1\",\n      \\\"COMPOUNDPERMITFLAG 432\",\n      \\\"\",\n      \\\"SFX 61003 Y 1\",\n      \\\"SFX 61003 0 meat .\",\n      \\\"\",\n      \\\"SFX 0 Y 1\",\n      \\\"SFX 0 0 zero .\",\n      \\\"\",\n      \\\"SFX 391 Y 1\",\n      \\\"SFX 391 0 a1 .\",\n      \\\"\",\n      \\\"SFX 111 Y 1\",\n      \\\"SFX 111 0 a\\xE9 .\",\n      \\\"\",\n      \\\"PFX 17 Y 1\",\n      \\\"PFX 17 0 pre/432 .\",\n      \\ ]\nlet g:test_data_dic7 = [\n      \\\"1234\",\n      \\\"mee/0,391,111,9999\",\n      \\\"bar/17,61003,123\",\n      \\\"lead/2\",\n      \\\"tail/123\",\n      \\\"middle/77,1\",\n      \\ ]\nlet g:test_data_aff8 = [\n      \\\"SET ISO8859-1\",\n      \\\"\",\n      \\\"NOSPLITSUGS\",\n      \\ ]\nlet g:test_data_dic8 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\\"faabar\",\n      \\ ]\nlet g:test_data_aff9 = [\n      \\ ]\nlet g:test_data_dic9 = [\n      \\\"1234\",\n      \\\"foo\",\n      \\\"bar\",\n      \\ ]\nlet g:test_data_aff10 = [\n      \\\"COMPOUNDRULE se\",\n      \\\"COMPOUNDPERMITFLAG p\",\n      \\\"\",\n      \\\"SFX A Y 1\",\n      \\\"SFX A 0 able/Mp .\",\n      \\\"\",\n      \\\"SFX M Y 1\",\n      \\\"SFX M 0 s .\",\n      \\ ]\nlet g:test_data_dic10 = [\n      \\\"1234\",\n      \\\"drink/As\",\n      \\\"table/e\",\n      \\ ]\nlet g:test_data_aff_sal = [\n      \\\"SET ISO8859-1\",\n      \\\"TRY esianrtolcdugmphbyfvkwjkqxz-\\xEB\\xE9\\xE8\\xEA\\xEF\\xEE\\xE4\\xE0\\xE2\\xF6\\xFC\\xFB'ESIANRTOLCDUGMPHBYFVKWJKQXZ\",\n      \\\"\",\n      \\\"FOL  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"LOW  \\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\\xE6\\xE7\\xE8\\xE9\\xEA\\xEB\\xEC\\xED\\xEE\\xEF\\xF0\\xF1\\xF2\\xF3\\xF4\\xF5\\xF6\\xF8\\xF9\\xFA\\xFB\\xFC\\xFD\\xFE\\xDF\\xFF\",\n      \\\"UPP  \\xC0\\xC1\\xC2\\xC3\\xC4\\xC5\\xC6\\xC7\\xC8\\xC9\\xCA\\xCB\\xCC\\xCD\\xCE\\xCF\\xD0\\xD1\\xD2\\xD3\\xD4\\xD5\\xD6\\xD8\\xD9\\xDA\\xDB\\xDC\\xDD\\xDE\\xDF\\xFF\",\n      \\\"\",\n      \\\"MIDWORD\\t'-\",\n      \\\"\",\n      \\\"KEP =\",\n      \\\"RAR ?\",\n      \\\"BAD !\",\n      \\\"\",\n      \\\"PFX I N 1\",\n      \\\"PFX I 0 in .\",\n      \\\"\",\n      \\\"PFX O Y 1\",\n      \\\"PFX O 0 out .\",\n      \\\"\",\n      \\\"SFX S Y 2\",\n      \\\"SFX S 0 s [^s]\",\n      \\\"SFX S 0 es s\",\n      \\\"\",\n      \\\"SFX N N 3\",\n      \\\"SFX N 0 en [^n]\",\n      \\\"SFX N 0 nen n\",\n      \\\"SFX N 0 n .\",\n      \\\"\",\n      \\\"REP 3\",\n      \\\"REP g ch\",\n      \\\"REP ch g\",\n      \\\"REP svp s.v.p.\",\n      \\\"\",\n      \\\"MAP 9\",\n      \\\"MAP a\\xE0\\xE1\\xE2\\xE3\\xE4\\xE5\",\n      \\\"MAP e\\xE8\\xE9\\xEA\\xEB\",\n      \\\"MAP i\\xEC\\xED\\xEE\\xEF\",\n      \\\"MAP o\\xF2\\xF3\\xF4\\xF5\\xF6\",\n      \\\"MAP u\\xF9\\xFA\\xFB\\xFC\",\n      \\\"MAP n\\xF1\",\n      \\\"MAP c\\xE7\",\n      \\\"MAP y\\xFF\\xFD\",\n      \\\"MAP s\\xDF\",\n      \\\"\",\n      \\\"SAL AH(AEIOUY)-^         *H\",\n      \\\"SAL AR(AEIOUY)-^         *R\",\n      \\\"SAL A(HR)^               *\",\n      \\\"SAL A^                   *\",\n      \\\"SAL AH(AEIOUY)-          H\",\n      \\\"SAL AR(AEIOUY)-          R\",\n      \\\"SAL A(HR)                _\",\n      \\\"SAL \\xC0^                   *\",\n      \\\"SAL \\xC5^                   *\",\n      \\\"SAL BB-                  _\",\n      \\\"SAL B                    B\",\n      \\\"SAL CQ-                  _\",\n      \\\"SAL CIA                  X\",\n      \\\"SAL CH                   X\",\n      \\\"SAL C(EIY)-              S\",\n      \\\"SAL CK                   K\",\n      \\\"SAL COUGH^               KF\",\n      \\\"SAL CC<                  C\",\n      \\\"SAL C                    K\",\n      \\\"SAL DG(EIY)              K\",\n      \\\"SAL DD-                  _\",\n      \\\"SAL D                    T\",\n      \\\"SAL \\xC9<                   E\",\n      \\\"SAL EH(AEIOUY)-^         *H\",\n      \\\"SAL ER(AEIOUY)-^         *R\",\n      \\\"SAL E(HR)^               *\",\n      \\\"SAL ENOUGH^$             *NF\",\n      \\\"SAL E^                   *\",\n      \\\"SAL EH(AEIOUY)-          H\",\n      \\\"SAL ER(AEIOUY)-          R\",\n      \\\"SAL E(HR)                _\",\n      \\\"SAL FF-                  _\",\n      \\\"SAL F                    F\",\n      \\\"SAL GN^                  N\",\n      \\\"SAL GN$                  N\",\n      \\\"SAL GNS$                 NS\",\n      \\\"SAL GNED$                N\",\n      \\\"SAL GH(AEIOUY)-          K\",\n      \\\"SAL GH                   _\",\n      \\\"SAL GG9                  K\",\n      \\\"SAL G                    K\",\n      \\\"SAL H                    H\",\n      \\\"SAL IH(AEIOUY)-^         *H\",\n      \\\"SAL IR(AEIOUY)-^         *R\",\n      \\\"SAL I(HR)^               *\",\n      \\\"SAL I^                   *\",\n      \\\"SAL ING6                 N\",\n      \\\"SAL IH(AEIOUY)-          H\",\n      \\\"SAL IR(AEIOUY)-          R\",\n      \\\"SAL I(HR)                _\",\n      \\\"SAL J                    K\",\n      \\\"SAL KN^                  N\",\n      \\\"SAL KK-                  _\",\n      \\\"SAL K                    K\",\n      \\\"SAL LAUGH^               LF\",\n      \\\"SAL LL-                  _\",\n      \\\"SAL L                    L\",\n      \\\"SAL MB$                  M\",\n      \\\"SAL MM                   M\",\n      \\\"SAL M                    M\",\n      \\\"SAL NN-                  _\",\n      \\\"SAL N                    N\",\n      \\\"SAL OH(AEIOUY)-^         *H\",\n      \\\"SAL OR(AEIOUY)-^         *R\",\n      \\\"SAL O(HR)^               *\",\n      \\\"SAL O^                   *\",\n      \\\"SAL OH(AEIOUY)-          H\",\n      \\\"SAL OR(AEIOUY)-          R\",\n      \\\"SAL O(HR)                _\",\n      \\\"SAL PH                   F\",\n      \\\"SAL PN^                  N\",\n      \\\"SAL PP-                  _\",\n      \\\"SAL P                    P\",\n      \\\"SAL Q                    K\",\n      \\\"SAL RH^                  R\",\n      \\\"SAL ROUGH^               RF\",\n      \\\"SAL RR-                  _\",\n      \\\"SAL R                    R\",\n      \\\"SAL SCH(EOU)-            SK\",\n      \\\"SAL SC(IEY)-             S\",\n      \\\"SAL SH                   X\",\n      \\\"SAL SI(AO)-              X\",\n      \\\"SAL SS-                  _\",\n      \\\"SAL S                    S\",\n      \\\"SAL TI(AO)-              X\",\n      \\\"SAL TH                   @\",\n      \\\"SAL TCH--                _\",\n      \\\"SAL TOUGH^               TF\",\n      \\\"SAL TT-                  _\",\n      \\\"SAL T                    T\",\n      \\\"SAL UH(AEIOUY)-^         *H\",\n      \\\"SAL UR(AEIOUY)-^         *R\",\n      \\\"SAL U(HR)^               *\",\n      \\\"SAL U^                   *\",\n      \\\"SAL UH(AEIOUY)-          H\",\n      \\\"SAL UR(AEIOUY)-          R\",\n      \\\"SAL U(HR)                _\",\n      \\\"SAL V^                   W\",\n      \\\"SAL V                    F\",\n      \\\"SAL WR^                  R\",\n      \\\"SAL WH^                  W\",\n      \\\"SAL W(AEIOU)-            W\",\n      \\\"SAL X^                   S\",\n      \\\"SAL X                    KS\",\n      \\\"SAL Y(AEIOU)-            Y\",\n      \\\"SAL ZZ-                  _\",\n      \\\"SAL Z                    S\",\n      \\ ]\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 8.2 and 9.0 can be found with \":help version9\".\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion != NULL)\n\treturn;\n\n#ifdef BUILD_DATE\n    char *date_time = BUILD_DATE;\n#else\n    char *date_time = __DATE__ \" \" __TIME__;\n#endif\n    char *msg = _(\"%s (%s, compiled %s)\");\n    size_t len = strlen(msg)\n\t+ strlen(VIM_VERSION_LONG_ONLY)\n\t+ strlen(VIM_VERSION_DATE_ONLY)\n\t+ strlen(date_time);\n\n    longVersion = alloc(len);\n    if (longVersion == NULL)\n\tlongVersion = VIM_VERSION_LONG;\n    else\n\tvim_snprintf(longVersion, len, msg,\n\t\tVIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n\t\"++builtin_terms\",\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n\t\"+cindent\",\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n\t\"+cmdline_info\",\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n\t\"-ebcdic\",\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n\t\"+file_in_path\",\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n\t\"+float\",\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n\t\"-footer\",\n\t// only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n\t\"+jumplist\",\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n\t\"+lispindent\",\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n#  ifdef DYNAMIC_GPM\n\t\"+mouse_gpm/dyn\",\n#  else\n\t\"+mouse_gpm\",\n#  endif\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n\t\"+path_extra\",\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n#  ifdef DYNAMIC_PYTHON3_STABLE_ABI\n\t\"+python3/dyn-stable\",\n#  else\n\t\"+python3/dyn\",\n#  endif\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n\t\"+smartindent\",\n#ifdef FEAT_SODIUM\n# ifdef DYNAMIC_SODIUM\n\t\"+sodium/dyn\",\n# else\n\t\"+sodium\",\n# endif\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n\t\"+tag_binary\",\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n\t\"+textobjects\",\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n\t\"+title\",\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+vim9script\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n\t\"+wildignore\",\n\t\"+wildmenu\",\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n# ifdef FEAT_XATTR\n\t\"+xattr\",\n# else\n\t\"-xattr\",\n# endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#if defined(MSWIN)\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#elif defined(HAVE_XPM)\n\t\"+xpm\",\n#else\n\t\"-xpm\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# if defined(USE_XSMP_INTERACT)\n\t\"+xsmp_interact\",\n# elif defined(USE_XSMP)\n\t\"+xsmp\",\n# else\n\t\"-xsmp\",\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    for (;;)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (l == h)\n\t    break;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + ((item_count % ncol) ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#if defined(FEAT_HUGE)\n    msg_puts(_(\"\\nHuge version \"));\n#elif defined(FEAT_NORMAL)\n    msg_puts(_(\"\\nNormal version \"));\n#else\n    msg_puts(_(\"\\nTiny version \"));\n#endif\n#if !defined(FEAT_GUI)\n    msg_puts(_(\"without GUI.\"));\n#elif defined(FEAT_GUI_GTK)\n# if defined(USE_GTK3)\n    msg_puts(_(\"with GTK3 GUI.\"));\n# elif defined(FEAT_GUI_GNOME)\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n# else\n     msg_puts(_(\"with GTK2 GUI.\"));\n# endif\n#elif defined(FEAT_GUI_MOTIF)\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#elif defined(FEAT_GUI_HAIKU)\n    msg_puts(_(\"with Haiku GUI.\"));\n#elif defined(FEAT_GUI_PHOTON)\n    msg_puts(_(\"with Photon GUI.\"));\n#elif defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version9<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/misc1.c", "src/testdir/test_spell.vim", "src/version.c"], "buggy_code_start_loc": [977, 1079, 706], "buggy_code_end_loc": [977, 1079, 706], "fixing_code_start_loc": [978, 1080, 707], "fixing_code_end_loc": [980, 1089, 709], "type": "CWE-190", "message": "Vim is an open source command line text editor. When using the z= command, the user may overflow the count with values larger\nthan MAX_INT. Impact is low, user interaction is required and a crash may not even happen in all situations. This vulnerability has been addressed in commit `73b2d379` which has been included in release version 9.0.2111. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-48236", "sourceIdentifier": "security-advisories@github.com", "published": "2023-11-16T23:15:09.567", "lastModified": "2024-01-25T21:38:21.563", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Vim is an open source command line text editor. When using the z= command, the user may overflow the count with values larger\nthan MAX_INT. Impact is low, user interaction is required and a crash may not even happen in all situations. This vulnerability has been addressed in commit `73b2d379` which has been included in release version 9.0.2111. Users are advised to upgrade. There are no known workarounds for this vulnerability."}, {"lang": "es", "value": "Vim es un editor de texto de l\u00ednea de comandos de c\u00f3digo abierto. Al utilizar el comando z=, el usuario puede desbordar el recuento con valores mayores que MAX_INT. El impacto es bajo, se requiere la interacci\u00f3n del usuario y es posible que ni siquiera ocurra una falla en todas las situaciones. Esta vulnerabilidad se solucion\u00f3 en el commit `73b2d379` que se incluy\u00f3 en la versi\u00f3n 9.0.2111. Se recomienda a los usuarios que actualicen. No se conocen workarounds para esta vulnerabilidad."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:R/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 2.8, "baseSeverity": "LOW"}, "exploitabilityScore": 1.3, "impactScore": 1.4}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "9.0.2111", "matchCriteriaId": "BE20F802-64E3-4126-948E-599241BD7066"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/11/16/1", "source": "security-advisories@github.com", "tags": ["Mailing List"]}, {"url": "https://github.com/vim/vim/commit/73b2d3790cad5694fc0ed0db2926e4220c48d968", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/vim/vim/security/advisories/GHSA-pr4c-932v-8hx5", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/4UJAK2W5S7G75ETDAEM3BDUCVSXCEGRD/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3VQF7CL3V6FGSEW37WNDFBRRILR65AK/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/VNRNYLWXZOGTYWE5HMFNQ5FVE3HBUHF6/", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20231227-0002/", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/73b2d3790cad5694fc0ed0db2926e4220c48d968"}}