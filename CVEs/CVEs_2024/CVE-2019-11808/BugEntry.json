{"buggy_code": ["/*\n * Copyright 2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ratpack.session;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.RemovalListener;\nimport com.google.inject.*;\nimport com.google.inject.name.Names;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.util.AsciiString;\nimport ratpack.func.Action;\nimport ratpack.guice.BindingsSpec;\nimport ratpack.guice.ConfigurableModule;\nimport ratpack.guice.RequestScoped;\nimport ratpack.http.Request;\nimport ratpack.http.Response;\nimport ratpack.session.internal.*;\nimport ratpack.util.Types;\n\nimport javax.inject.Named;\nimport java.io.Serializable;\nimport java.util.function.Consumer;\n\n/**\n * Provides support for HTTP sessions.\n * <p>\n * This module provides the general session API (see {@link Session}), and a default {@link SessionStore} implementation that stores session data in local memory.\n *\n * <h3>The session store</h3>\n * <p>\n * It is expected that most applications will provide alternative bindings for the {@link SessionStore} type, overriding the default.\n * This allows arbitrary stores to be used to persist session data.\n * <p>\n * The default, in memory, implementation stores the data in a {@link Cache}{@code <}{@link AsciiString}, {@link ByteBuf}{@code >}.\n * This cache instance is provided by this module and defaults to storing a maximum of 1000 entries, discarding least recently used.\n * The {@link #memoryStore} methods are provided to conveniently construct alternative cache configurations, if necessary.\n * <h3>Serialization</h3>\n * <p>\n * Objects must be serialized to be stored in the session.\n * The get/set methods {@link SessionData} allow supplying a {@link SessionSerializer} to be used for the specific value.\n * For variants of the get/set methods where a serializer is not provided, the implementation of {@link SessionSerializer} bound with Guice will be used.\n * The default implementation provided by this module uses Java's in built serialization mechanism.\n * Users of this module may choose to override this binding with an alternative serialization strategy.\n * <p>\n * However, other Ratpack extensions may require session storage any rely on Java serialization.\n * For this reason, there is also always a {@link JavaSessionSerializer} implementation available that is guaranteed to be able to serialize any {@link Serializable}\n * object (that conforms to the {@link Serializable} contract.\n * Users of this module may also choose to override this binding with another implementation (e.g. one based on <a href=\"https://github.com/EsotericSoftware/kryo\">Kryo</a>),\n * but this implementation must be able to serialize any object implementing {@link Serializable}.\n *\n * It is also often desirable to provide alternative implementations for {@link SessionSerializer} and {@link JavaSessionSerializer}.\n * The default binding for both types is an implementation that uses out-of-the-box Java serialization (which is neither fast nor efficient).\n *\n * <h3>Example usage</h3>\n * <pre class=\"java\">{@code\n * import ratpack.guice.Guice;\n * import ratpack.path.PathTokens;\n * import ratpack.session.Session;\n * import ratpack.session.SessionModule;\n * import ratpack.test.embed.EmbeddedApp;\n *\n * import static org.junit.Assert.assertEquals;\n *\n * public class Example {\n *   public static void main(String... args) throws Exception {\n *     EmbeddedApp.of(a -> a\n *         .registry(Guice.registry(b -> b\n *             .module(SessionModule.class)\n *         ))\n *         .handlers(c -> c\n *             .get(\"set/:name/:value\", ctx ->\n *                 ctx.get(Session.class).getData().then(sessionData -> {\n *                   PathTokens pathTokens = ctx.getPathTokens();\n *                   sessionData.set(pathTokens.get(\"name\"), pathTokens.get(\"value\"));\n *                   ctx.render(\"ok\");\n *                 })\n *             )\n *             .get(\"get/:name\", ctx -> {\n *               ctx.get(Session.class).getData()\n *                 .map(d -> d.require(ctx.getPathTokens().get(\"name\")))\n *                 .then(ctx::render);\n *             })\n *         )\n *     ).test(httpClient -> {\n *       assertEquals(\"ok\", httpClient.getText(\"set/foo/bar\"));\n *       assertEquals(\"bar\", httpClient.getText(\"get/foo\"));\n *\n *       assertEquals(\"ok\", httpClient.getText(\"set/foo/baz\"));\n *       assertEquals(\"baz\", httpClient.getText(\"get/foo\"));\n *     });\n *   }\n * }\n * }</pre>\n */\npublic class SessionModule extends ConfigurableModule<SessionCookieConfig> {\n\n  /**\n   * The name of the binding for the {@link Cache} implementation that backs the in memory session store.\n   *\n   * @see #memoryStore(Consumer)\n   */\n  public static final String LOCAL_MEMORY_SESSION_CACHE_BINDING_NAME = \"localMemorySessionCache\";\n\n  /**\n   * The key of the binding for the {@link Cache} implementation that backs the in memory session store.\n   *\n   * @see #memoryStore(Consumer)\n   */\n  public static final Key<Cache<AsciiString, ByteBuf>> LOCAL_MEMORY_SESSION_CACHE_BINDING_KEY = Key.get(\n    new TypeLiteral<Cache<AsciiString, ByteBuf>>() {},\n    Names.named(LOCAL_MEMORY_SESSION_CACHE_BINDING_NAME)\n  );\n\n  /**\n   * A builder for an alternative cache for the default in memory store.\n   * <p>\n   * This method is intended to be used with the {@link BindingsSpec#binder(Action)} method.\n   * <pre class=\"java\">{@code\n   * import ratpack.guice.Guice;\n   * import ratpack.session.SessionModule;\n   *\n   * public class Example {\n   *   public static void main(String... args) {\n   *     Guice.registry(b -> b\n   *         .binder(SessionModule.memoryStore(c -> c.maximumSize(100)))\n   *     );\n   *   }\n   * }\n   * }</pre>\n   *\n   * @param config the cache configuration\n   * @return an action that binds the cache\n   * @see #memoryStore(Binder, Consumer)\n   */\n  public static Action<Binder> memoryStore(Consumer<? super CacheBuilder<AsciiString, ByteBuf>> config) {\n    return b -> memoryStore(b, config);\n  }\n\n  /**\n   * A builder for an alternative cache for the default in memory store.\n   * <p>\n   * This method can be used from within a custom {@link Module}.\n   * <pre class=\"java\">{@code\n   * import com.google.inject.AbstractModule;\n   * import ratpack.session.SessionModule;\n   *\n   * public class CustomSessionModule extends AbstractModule {\n   *   protected void configure() {\n   *     SessionModule.memoryStore(binder(), c -> c.maximumSize(100));\n   *   }\n   * }\n   * }</pre>\n   * }<p>\n   * This method binds the built cache with the {@link #LOCAL_MEMORY_SESSION_CACHE_BINDING_KEY} key.\n   * It also implicitly registers a {@link RemovalListener}, that releases the byte buffers as they are discarded.\n   *\n   * @param binder the guice binder\n   * @param config the cache configuration\n   */\n  public static void memoryStore(Binder binder, Consumer<? super CacheBuilder<AsciiString, ByteBuf>> config) {\n    binder.bind(LOCAL_MEMORY_SESSION_CACHE_BINDING_KEY).toProvider(() -> {\n      CacheBuilder<AsciiString, ByteBuf> cacheBuilder = Types.cast(CacheBuilder.newBuilder());\n      cacheBuilder.removalListener(n -> n.getValue().release());\n      config.accept(cacheBuilder);\n      return cacheBuilder.build();\n    }).in(Scopes.SINGLETON);\n  }\n\n  @Override\n  protected void configure() {\n    memoryStore(binder(), s -> s.maximumSize(1000));\n  }\n\n  @Provides\n  @Singleton\n  SessionStore sessionStoreAdapter(@Named(LOCAL_MEMORY_SESSION_CACHE_BINDING_NAME) Cache<AsciiString, ByteBuf> cache) {\n    return new LocalMemorySessionStore(cache);\n  }\n\n  @Provides\n  SessionIdGenerator sessionIdGenerator() {\n    return new DefaultSessionIdGenerator();\n  }\n\n  @Provides\n  @RequestScoped\n  SessionId sessionId(Request request, Response response, SessionIdGenerator idGenerator, SessionCookieConfig cookieConfig) {\n    return new CookieBasedSessionId(request, response, idGenerator, cookieConfig);\n  }\n\n  @Provides\n  SessionSerializer sessionValueSerializer(JavaSessionSerializer sessionSerializer) {\n    return sessionSerializer;\n  }\n\n  @Provides\n  JavaSessionSerializer javaSessionSerializer() {\n    return new JavaBuiltinSessionSerializer();\n  }\n\n  @Provides\n  @RequestScoped\n  Session sessionAdapter(SessionId sessionId, SessionStore store, Response response, ByteBufAllocator bufferAllocator, SessionSerializer defaultSerializer, JavaSessionSerializer javaSerializer) {\n    return new DefaultSession(sessionId, bufferAllocator, store, response, defaultSerializer, javaSerializer);\n  }\n\n}\n", "/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ratpack.session.internal;\n\nimport io.netty.util.AsciiString;\nimport ratpack.session.SessionIdGenerator;\n\nimport java.util.UUID;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class DefaultSessionIdGenerator implements SessionIdGenerator {\n\n  public AsciiString generateSessionId() {\n    ThreadLocalRandom random = ThreadLocalRandom.current();\n    UUID uuid = new UUID(random.nextLong(), random.nextLong());\n    return AsciiString.of(uuid.toString());\n  }\n\n}\n"], "fixing_code": ["/*\n * Copyright 2015 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ratpack.session;\n\nimport com.google.common.cache.Cache;\nimport com.google.common.cache.CacheBuilder;\nimport com.google.common.cache.RemovalListener;\nimport com.google.inject.*;\nimport com.google.inject.name.Names;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.buffer.ByteBufAllocator;\nimport io.netty.util.AsciiString;\nimport ratpack.func.Action;\nimport ratpack.guice.BindingsSpec;\nimport ratpack.guice.ConfigurableModule;\nimport ratpack.guice.RequestScoped;\nimport ratpack.http.Request;\nimport ratpack.http.Response;\nimport ratpack.session.internal.*;\nimport ratpack.util.Types;\n\nimport javax.inject.Named;\nimport java.io.Serializable;\nimport java.util.function.Consumer;\n\n/**\n * Provides support for HTTP sessions.\n * <p>\n * This module provides the general session API (see {@link Session}), and a default {@link SessionStore} implementation that stores session data in local memory.\n *\n * <h3>The session store</h3>\n * <p>\n * It is expected that most applications will provide alternative bindings for the {@link SessionStore} type, overriding the default.\n * This allows arbitrary stores to be used to persist session data.\n * <p>\n * The default, in memory, implementation stores the data in a {@link Cache}{@code <}{@link AsciiString}, {@link ByteBuf}{@code >}.\n * This cache instance is provided by this module and defaults to storing a maximum of 1000 entries, discarding least recently used.\n * The {@link #memoryStore} methods are provided to conveniently construct alternative cache configurations, if necessary.\n * <h3>Serialization</h3>\n * <p>\n * Objects must be serialized to be stored in the session.\n * The get/set methods {@link SessionData} allow supplying a {@link SessionSerializer} to be used for the specific value.\n * For variants of the get/set methods where a serializer is not provided, the implementation of {@link SessionSerializer} bound with Guice will be used.\n * The default implementation provided by this module uses Java's in built serialization mechanism.\n * Users of this module may choose to override this binding with an alternative serialization strategy.\n * <p>\n * However, other Ratpack extensions may require session storage any rely on Java serialization.\n * For this reason, there is also always a {@link JavaSessionSerializer} implementation available that is guaranteed to be able to serialize any {@link Serializable}\n * object (that conforms to the {@link Serializable} contract.\n * Users of this module may also choose to override this binding with another implementation (e.g. one based on <a href=\"https://github.com/EsotericSoftware/kryo\">Kryo</a>),\n * but this implementation must be able to serialize any object implementing {@link Serializable}.\n *\n * It is also often desirable to provide alternative implementations for {@link SessionSerializer} and {@link JavaSessionSerializer}.\n * The default binding for both types is an implementation that uses out-of-the-box Java serialization (which is neither fast nor efficient).\n *\n * <h3>Example usage</h3>\n * <pre class=\"java\">{@code\n * import ratpack.guice.Guice;\n * import ratpack.path.PathTokens;\n * import ratpack.session.Session;\n * import ratpack.session.SessionModule;\n * import ratpack.test.embed.EmbeddedApp;\n *\n * import static org.junit.Assert.assertEquals;\n *\n * public class Example {\n *   public static void main(String... args) throws Exception {\n *     EmbeddedApp.of(a -> a\n *         .registry(Guice.registry(b -> b\n *             .module(SessionModule.class)\n *         ))\n *         .handlers(c -> c\n *             .get(\"set/:name/:value\", ctx ->\n *                 ctx.get(Session.class).getData().then(sessionData -> {\n *                   PathTokens pathTokens = ctx.getPathTokens();\n *                   sessionData.set(pathTokens.get(\"name\"), pathTokens.get(\"value\"));\n *                   ctx.render(\"ok\");\n *                 })\n *             )\n *             .get(\"get/:name\", ctx -> {\n *               ctx.get(Session.class).getData()\n *                 .map(d -> d.require(ctx.getPathTokens().get(\"name\")))\n *                 .then(ctx::render);\n *             })\n *         )\n *     ).test(httpClient -> {\n *       assertEquals(\"ok\", httpClient.getText(\"set/foo/bar\"));\n *       assertEquals(\"bar\", httpClient.getText(\"get/foo\"));\n *\n *       assertEquals(\"ok\", httpClient.getText(\"set/foo/baz\"));\n *       assertEquals(\"baz\", httpClient.getText(\"get/foo\"));\n *     });\n *   }\n * }\n * }</pre>\n */\npublic class SessionModule extends ConfigurableModule<SessionCookieConfig> {\n\n  /**\n   * The name of the binding for the {@link Cache} implementation that backs the in memory session store.\n   *\n   * @see #memoryStore(Consumer)\n   */\n  public static final String LOCAL_MEMORY_SESSION_CACHE_BINDING_NAME = \"localMemorySessionCache\";\n\n  /**\n   * The key of the binding for the {@link Cache} implementation that backs the in memory session store.\n   *\n   * @see #memoryStore(Consumer)\n   */\n  public static final Key<Cache<AsciiString, ByteBuf>> LOCAL_MEMORY_SESSION_CACHE_BINDING_KEY = Key.get(\n    new TypeLiteral<Cache<AsciiString, ByteBuf>>() {},\n    Names.named(LOCAL_MEMORY_SESSION_CACHE_BINDING_NAME)\n  );\n\n  /**\n   * A builder for an alternative cache for the default in memory store.\n   * <p>\n   * This method is intended to be used with the {@link BindingsSpec#binder(Action)} method.\n   * <pre class=\"java\">{@code\n   * import ratpack.guice.Guice;\n   * import ratpack.session.SessionModule;\n   *\n   * public class Example {\n   *   public static void main(String... args) {\n   *     Guice.registry(b -> b\n   *         .binder(SessionModule.memoryStore(c -> c.maximumSize(100)))\n   *     );\n   *   }\n   * }\n   * }</pre>\n   *\n   * @param config the cache configuration\n   * @return an action that binds the cache\n   * @see #memoryStore(Binder, Consumer)\n   */\n  public static Action<Binder> memoryStore(Consumer<? super CacheBuilder<AsciiString, ByteBuf>> config) {\n    return b -> memoryStore(b, config);\n  }\n\n  /**\n   * A builder for an alternative cache for the default in memory store.\n   * <p>\n   * This method can be used from within a custom {@link Module}.\n   * <pre class=\"java\">{@code\n   * import com.google.inject.AbstractModule;\n   * import ratpack.session.SessionModule;\n   *\n   * public class CustomSessionModule extends AbstractModule {\n   *   protected void configure() {\n   *     SessionModule.memoryStore(binder(), c -> c.maximumSize(100));\n   *   }\n   * }\n   * }</pre>\n   * }<p>\n   * This method binds the built cache with the {@link #LOCAL_MEMORY_SESSION_CACHE_BINDING_KEY} key.\n   * It also implicitly registers a {@link RemovalListener}, that releases the byte buffers as they are discarded.\n   *\n   * @param binder the guice binder\n   * @param config the cache configuration\n   */\n  public static void memoryStore(Binder binder, Consumer<? super CacheBuilder<AsciiString, ByteBuf>> config) {\n    binder.bind(LOCAL_MEMORY_SESSION_CACHE_BINDING_KEY).toProvider(() -> {\n      CacheBuilder<AsciiString, ByteBuf> cacheBuilder = Types.cast(CacheBuilder.newBuilder());\n      cacheBuilder.removalListener(n -> n.getValue().release());\n      config.accept(cacheBuilder);\n      return cacheBuilder.build();\n    }).in(Scopes.SINGLETON);\n  }\n\n  @Override\n  protected void configure() {\n    memoryStore(binder(), s -> s.maximumSize(1000));\n  }\n\n  @Provides\n  @Singleton\n  SessionStore sessionStoreAdapter(@Named(LOCAL_MEMORY_SESSION_CACHE_BINDING_NAME) Cache<AsciiString, ByteBuf> cache) {\n    return new LocalMemorySessionStore(cache);\n  }\n\n  @Provides\n  @Singleton\n  SessionIdGenerator sessionIdGenerator() {\n    return new DefaultSessionIdGenerator();\n  }\n\n  @Provides\n  @RequestScoped\n  SessionId sessionId(Request request, Response response, SessionIdGenerator idGenerator, SessionCookieConfig cookieConfig) {\n    return new CookieBasedSessionId(request, response, idGenerator, cookieConfig);\n  }\n\n  @Provides\n  SessionSerializer sessionValueSerializer(JavaSessionSerializer sessionSerializer) {\n    return sessionSerializer;\n  }\n\n  @Provides\n  JavaSessionSerializer javaSessionSerializer() {\n    return new JavaBuiltinSessionSerializer();\n  }\n\n  @Provides\n  @RequestScoped\n  Session sessionAdapter(SessionId sessionId, SessionStore store, Response response, ByteBufAllocator bufferAllocator, SessionSerializer defaultSerializer, JavaSessionSerializer javaSerializer) {\n    return new DefaultSession(sessionId, bufferAllocator, store, response, defaultSerializer, javaSerializer);\n  }\n\n}\n", "/*\n * Copyright 2013 the original author or authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage ratpack.session.internal;\n\nimport com.google.inject.Singleton;\nimport io.netty.util.AsciiString;\nimport ratpack.session.SessionIdGenerator;\n\nimport java.util.UUID;\n\n@Singleton\npublic class DefaultSessionIdGenerator implements SessionIdGenerator {\n\n  public AsciiString generateSessionId() {\n    return AsciiString.cached(UUID.randomUUID().toString());\n  }\n\n}\n"], "filenames": ["ratpack-session/src/main/java/ratpack/session/SessionModule.java", "ratpack-session/src/main/java/ratpack/session/internal/DefaultSessionIdGenerator.java"], "buggy_code_start_loc": [196, 18], "buggy_code_end_loc": [196, 31], "fixing_code_start_loc": [197, 19], "fixing_code_end_loc": [198, 30], "type": "CWE-338", "message": "Ratpack versions before 1.6.1 generate a session ID using a cryptographically weak PRNG in the JDK's ThreadLocalRandom. This means that if an attacker can determine a small window for the server start time and obtain a session ID value, they can theoretically determine the sequence of session IDs.", "other": {"cve": {"id": "CVE-2019-11808", "sourceIdentifier": "cve@mitre.org", "published": "2019-05-07T07:29:05.167", "lastModified": "2019-05-08T16:14:44.343", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Ratpack versions before 1.6.1 generate a session ID using a cryptographically weak PRNG in the JDK's ThreadLocalRandom. This means that if an attacker can determine a small window for the server start time and obtain a session ID value, they can theoretically determine the sequence of session IDs."}, {"lang": "es", "value": "Las versiones de Ratpack anteriores a la 1.6.1 generan un ID de sesi\u00f3n utilizando un PRNG criptogr\u00e1ficamente d\u00e9bil en ThreadLocalRandom del JDK. Esto significa que si un atacante puede determinar una peque\u00f1a ventana para la hora de inicio del servidor y obtener un valor de ID de sesi\u00f3n, te\u00f3ricamente puede determinar la secuencia de ID de sesi\u00f3n."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.7, "baseSeverity": "LOW"}, "exploitabilityScore": 2.2, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-338"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ratpack_project:ratpack:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.6.1", "matchCriteriaId": "1FB3DD33-AEA0-48E6-9600-2B857CB25D61"}]}]}], "references": [{"url": "https://github.com/ratpack/ratpack/commit/f2b63eb82dd71194319fd3945f5edf29b8f3a42d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ratpack/ratpack/issues/1448", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ratpack/ratpack/releases/tag/v1.6.1", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ratpack/ratpack/commit/f2b63eb82dd71194319fd3945f5edf29b8f3a42d"}}