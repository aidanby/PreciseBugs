{"buggy_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/pixfmt.h\"\n\n#include \"cbs.h\"\n#include \"cbs_internal.h\"\n#include \"cbs_av1.h\"\n#include \"internal.h\"\n\n\nstatic int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t value;\n    int position, zeroes, i, j;\n    char bits[65];\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = i = 0;\n    while (1) {\n        if (get_bits_left(gbc) < zeroes + 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            break;\n        } else {\n            bits[i++] = '0';\n            ++zeroes;\n        }\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        value = get_bits_long(gbc, zeroes);\n\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (value >> (zeroes - j - 1) & 1) ? '1' : '0';\n\n        value += (1 << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_uvlc(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                              const char *name, uint32_t value,\n                              uint32_t range_min, uint32_t range_max)\n{\n    uint32_t v;\n    int position, zeroes;\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    if (value == 0) {\n        zeroes = 0;\n        put_bits(pbc, 1, 1);\n    } else {\n        zeroes = av_log2(value + 1);\n        v = value - (1 << zeroes) + 1;\n        put_bits(pbc, zeroes + 1, 1);\n        put_bits(pbc, zeroes, v);\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j;\n        i = 0;\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = '0';\n        bits[i++] = '1';\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (v >> (zeroes - j - 1) & 1) ? '1' : '0';\n        bits[i++] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_read_leb128(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                               const char *name, uint64_t *write_to)\n{\n    uint64_t value;\n    int position, err, i;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    value = 0;\n    for (i = 0; i < 8; i++) {\n        int subscript[2] = { 1, i };\n        uint32_t byte;\n        err = ff_cbs_read_unsigned(ctx, gbc, 8, \"leb128_byte[i]\", subscript,\n                                   &byte, 0x00, 0xff);\n        if (err < 0)\n            return err;\n\n        value |= (uint64_t)(byte & 0x7f) << (i * 7);\n        if (!(byte & 0x80))\n            break;\n    }\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL, \"\", value);\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_leb128(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                                const char *name, uint64_t value)\n{\n    int position, err, len, i;\n    uint8_t byte;\n\n    len = (av_log2(value) + 7) / 7;\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    for (i = 0; i < len; i++) {\n        int subscript[2] = { 1, i };\n\n        byte = value >> (7 * i) & 0x7f;\n        if (i < len - 1)\n            byte |= 0x80;\n\n        err = ff_cbs_write_unsigned(ctx, pbc, 8, \"leb128_byte[i]\", subscript,\n                                    byte, 0x00, 0xff);\n        if (err < 0)\n            return err;\n    }\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL, \"\", value);\n\n    return 0;\n}\n\nstatic int cbs_av1_read_su(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                           int width, const char *name,\n                           const int *subscripts, int32_t *write_to)\n{\n    int position;\n    int32_t value;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    if (get_bits_left(gbc) < width) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid signed value at \"\n               \"%s: bitstream ended.\\n\", name);\n        return AVERROR_INVALIDDATA;\n    }\n\n    value = get_sbits(gbc, width);\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < width; i++)\n            bits[i] = value & (1 << (width - i - 1)) ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, bits, value);\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_su(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                            int width, const char *name,\n                            const int *subscripts, int32_t value)\n{\n    if (put_bits_left(pbc) < width)\n        return AVERROR(ENOSPC);\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < width; i++)\n            bits[i] = value & (1 << (width - i - 1)) ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),\n                                    name, subscripts, bits, value);\n    }\n\n    put_sbits(pbc, width, value);\n\n    return 0;\n}\n\nstatic int cbs_av1_read_ns(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                           uint32_t n, const char *name,\n                           const int *subscripts, uint32_t *write_to)\n{\n    uint32_t w, m, v, extra_bit, value;\n    int position;\n\n    av_assert0(n > 0);\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    w = av_log2(n) + 1;\n    m = (1 << w) - n;\n\n    if (get_bits_left(gbc) < w) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid non-symmetric value at \"\n               \"%s: bitstream ended.\\n\", name);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (w - 1 > 0)\n        v = get_bits(gbc, w - 1);\n    else\n        v = 0;\n\n    if (v < m) {\n        value = v;\n    } else {\n        extra_bit = get_bits1(gbc);\n        value = (v << 1) - m + extra_bit;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < w - 1; i++)\n            bits[i] = (v >> i & 1) ? '1' : '0';\n        if (v >= m)\n            bits[i++] = extra_bit ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, bits, value);\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_ns(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                            uint32_t n, const char *name,\n                            const int *subscripts, uint32_t value)\n{\n    uint32_t w, m, v, extra_bit;\n    int position;\n\n    if (value > n) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [0,%\"PRIu32\"].\\n\",\n               name, value, n);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    w = av_log2(n) + 1;\n    m = (1 << w) - n;\n\n    if (put_bits_left(pbc) < w)\n        return AVERROR(ENOSPC);\n\n    if (value < m) {\n        v = value;\n        put_bits(pbc, w - 1, v);\n    } else {\n        v = m + ((value - m) >> 1);\n        extra_bit = (value - m) & 1;\n        put_bits(pbc, w - 1, v);\n        put_bits(pbc, 1, extra_bit);\n    }\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < w - 1; i++)\n            bits[i] = (v >> i & 1) ? '1' : '0';\n        if (value >= m)\n            bits[i++] = extra_bit ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, bits, value);\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_read_increment(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                                  uint32_t range_min, uint32_t range_max,\n                                  const char *name, uint32_t *write_to)\n{\n    uint32_t value;\n    int position, i;\n    char bits[33];\n\n    av_assert0(range_min <= range_max && range_max - range_min < sizeof(bits) - 1);\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    for (i = 0, value = range_min; value < range_max;) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid increment value at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            ++value;\n        } else {\n            bits[i++] = '0';\n            break;\n        }\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, NULL, bits, value);\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_increment(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                                   uint32_t range_min, uint32_t range_max,\n                                   const char *name, uint32_t value)\n{\n    int len;\n\n    av_assert0(range_min <= range_max && range_max - range_min < 32);\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (value == range_max)\n        len = range_max - range_min;\n    else\n        len = value - range_min + 1;\n    if (put_bits_left(pbc) < len)\n        return AVERROR(ENOSPC);\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < len; i++) {\n            if (range_min + i == value)\n                bits[i] = '0';\n            else\n                bits[i] = '1';\n        }\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),\n                                    name, NULL, bits, value);\n    }\n\n    if (len > 0)\n        put_bits(pbc, len, (1 << len) - 1 - (value != range_max));\n\n    return 0;\n}\n\nstatic int cbs_av1_read_subexp(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                               uint32_t range_max, const char *name,\n                               const int *subscripts, uint32_t *write_to)\n{\n    uint32_t value;\n    int position, err;\n    uint32_t max_len, len, range_offset, range_bits;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    av_assert0(range_max > 0);\n    max_len = av_log2(range_max - 1) - 3;\n\n    err = cbs_av1_read_increment(ctx, gbc, 0, max_len,\n                                 \"subexp_more_bits\", &len);\n    if (err < 0)\n        return err;\n\n    if (len) {\n        range_bits   = 2 + len;\n        range_offset = 1 << range_bits;\n    } else {\n        range_bits   = 3;\n        range_offset = 0;\n    }\n\n    if (len < max_len) {\n        err = ff_cbs_read_unsigned(ctx, gbc, range_bits,\n                                   \"subexp_bits\", NULL, &value,\n                                   0, MAX_UINT_BITS(range_bits));\n        if (err < 0)\n            return err;\n\n    } else {\n        err = cbs_av1_read_ns(ctx, gbc, range_max - range_offset,\n                              \"subexp_final_bits\", NULL, &value);\n        if (err < 0)\n            return err;\n    }\n    value += range_offset;\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, \"\", value);\n\n    *write_to = value;\n    return err;\n}\n\nstatic int cbs_av1_write_subexp(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                                uint32_t range_max, const char *name,\n                                const int *subscripts, uint32_t value)\n{\n    int position, err;\n    uint32_t max_len, len, range_offset, range_bits;\n\n    if (value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [0,%\"PRIu32\"].\\n\",\n               name, value, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    av_assert0(range_max > 0);\n    max_len = av_log2(range_max - 1) - 3;\n\n    if (value < 8) {\n        range_bits   = 3;\n        range_offset = 0;\n        len = 0;\n    } else {\n        range_bits = av_log2(value);\n        len = range_bits - 2;\n        if (len > max_len) {\n            // The top bin is combined with the one below it.\n            av_assert0(len == max_len + 1);\n            --range_bits;\n            len = max_len;\n        }\n        range_offset = 1 << range_bits;\n    }\n\n    err = cbs_av1_write_increment(ctx, pbc, 0, max_len,\n                                  \"subexp_more_bits\", len);\n    if (err < 0)\n        return err;\n\n    if (len < max_len) {\n        err = ff_cbs_write_unsigned(ctx, pbc, range_bits,\n                                    \"subexp_bits\", NULL,\n                                    value - range_offset,\n                                    0, MAX_UINT_BITS(range_bits));\n        if (err < 0)\n            return err;\n\n    } else {\n        err = cbs_av1_write_ns(ctx, pbc, range_max - range_offset,\n                               \"subexp_final_bits\", NULL,\n                               value - range_offset);\n        if (err < 0)\n            return err;\n    }\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, \"\", value);\n\n    return err;\n}\n\n\nstatic int cbs_av1_tile_log2(int blksize, int target)\n{\n    int k;\n    for (k = 0; (blksize << k) < target; k++);\n    return k;\n}\n\nstatic int cbs_av1_get_relative_dist(const AV1RawSequenceHeader *seq,\n                                     unsigned int a, unsigned int b)\n{\n    unsigned int diff, m;\n    if (!seq->enable_order_hint)\n        return 0;\n    diff = a - b;\n    m = 1 << seq->order_hint_bits_minus_1;\n    diff = (diff & (m - 1)) - (diff & m);\n    return diff;\n}\n\n\n#define HEADER(name) do { \\\n        ff_cbs_trace_header(ctx, name); \\\n    } while (0)\n\n#define CHECK(call) do { \\\n        err = (call); \\\n        if (err < 0) \\\n            return err; \\\n    } while (0)\n\n#define FUNC_NAME(rw, codec, name) cbs_ ## codec ## _ ## rw ## _ ## name\n#define FUNC_AV1(rw, name) FUNC_NAME(rw, av1, name)\n#define FUNC(name) FUNC_AV1(READWRITE, name)\n\n#define SUBSCRIPTS(subs, ...) (subs > 0 ? ((int[subs + 1]){ subs, __VA_ARGS__ }) : NULL)\n\n#define fb(width, name) \\\n        xf(width, name, current->name, 0, MAX_UINT_BITS(width), 0)\n#define fc(width, name, range_min, range_max) \\\n        xf(width, name, current->name, range_min, range_max, 0)\n#define flag(name) fb(1, name)\n#define su(width, name) \\\n        xsu(width, name, current->name, 0)\n\n#define fbs(width, name, subs, ...) \\\n        xf(width, name, current->name, 0, MAX_UINT_BITS(width), subs, __VA_ARGS__)\n#define fcs(width, name, range_min, range_max, subs, ...) \\\n        xf(width, name, current->name, range_min, range_max, subs, __VA_ARGS__)\n#define flags(name, subs, ...) \\\n        xf(1, name, current->name, 0, 1, subs, __VA_ARGS__)\n#define sus(width, name, subs, ...) \\\n        xsu(width, name, current->name, subs, __VA_ARGS__)\n\n#define fixed(width, name, value) do { \\\n        av_unused uint32_t fixed_value = value; \\\n        xf(width, name, fixed_value, value, value, 0); \\\n    } while (0)\n\n\n#define READ\n#define READWRITE read\n#define RWContext GetBitContext\n\n#define xf(width, name, var, range_min, range_max, subs, ...) do { \\\n        uint32_t value = range_min; \\\n        CHECK(ff_cbs_read_unsigned(ctx, rw, width, #name, \\\n                                   SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                   &value, range_min, range_max)); \\\n        var = value; \\\n    } while (0)\n\n#define xsu(width, name, var, subs, ...) do { \\\n        int32_t value = 0; \\\n        CHECK(cbs_av1_read_su(ctx, rw, width, #name, \\\n                              SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\\n        var = value; \\\n    } while (0)\n\n#define uvlc(name, range_min, range_max) do { \\\n        uint32_t value = range_min; \\\n        CHECK(cbs_av1_read_uvlc(ctx, rw, #name, \\\n                                &value, range_min, range_max)); \\\n        current->name = value; \\\n    } while (0)\n\n#define ns(max_value, name, subs, ...) do { \\\n        uint32_t value = 0; \\\n        CHECK(cbs_av1_read_ns(ctx, rw, max_value, #name, \\\n                              SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define increment(name, min, max) do { \\\n        uint32_t value = 0; \\\n        CHECK(cbs_av1_read_increment(ctx, rw, min, max, #name, &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define subexp(name, max, subs, ...) do { \\\n        uint32_t value = 0; \\\n        CHECK(cbs_av1_read_subexp(ctx, rw, max, #name, \\\n                                  SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define delta_q(name) do { \\\n        uint8_t delta_coded; \\\n        int8_t delta_q; \\\n        xf(1, name.delta_coded, delta_coded, 0, 1, 0); \\\n        if (delta_coded) \\\n            xsu(1 + 6, name.delta_q, delta_q, 0); \\\n        else \\\n            delta_q = 0; \\\n        current->name = delta_q; \\\n    } while (0)\n\n#define leb128(name) do { \\\n        uint64_t value = 0; \\\n        CHECK(cbs_av1_read_leb128(ctx, rw, #name, &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define infer(name, value) do { \\\n        current->name = value; \\\n    } while (0)\n\n#define byte_alignment(rw) (get_bits_count(rw) % 8)\n\n#include \"cbs_av1_syntax_template.c\"\n\n#undef READ\n#undef READWRITE\n#undef RWContext\n#undef xf\n#undef xsu\n#undef uvlc\n#undef leb128\n#undef ns\n#undef increment\n#undef subexp\n#undef delta_q\n#undef leb128\n#undef infer\n#undef byte_alignment\n\n\n#define WRITE\n#define READWRITE write\n#define RWContext PutBitContext\n\n#define xf(width, name, var, range_min, range_max, subs, ...) do { \\\n        CHECK(ff_cbs_write_unsigned(ctx, rw, width, #name, \\\n                                    SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                    var, range_min, range_max)); \\\n    } while (0)\n\n#define xsu(width, name, var, subs, ...) do { \\\n        CHECK(cbs_av1_write_su(ctx, rw, width, #name, \\\n                               SUBSCRIPTS(subs, __VA_ARGS__), var)); \\\n    } while (0)\n\n#define uvlc(name, range_min, range_max) do { \\\n        CHECK(cbs_av1_write_uvlc(ctx, rw, #name, current->name, \\\n                                 range_min, range_max)); \\\n    } while (0)\n\n#define ns(max_value, name, subs, ...) do { \\\n        CHECK(cbs_av1_write_ns(ctx, rw, max_value, #name, \\\n                               SUBSCRIPTS(subs, __VA_ARGS__), \\\n                               current->name)); \\\n    } while (0)\n\n#define increment(name, min, max) do { \\\n        CHECK(cbs_av1_write_increment(ctx, rw, min, max, #name, \\\n                                      current->name)); \\\n    } while (0)\n\n#define subexp(name, max, subs, ...) do { \\\n        CHECK(cbs_av1_write_subexp(ctx, rw, max, #name, \\\n                                   SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                   current->name)); \\\n    } while (0)\n\n#define delta_q(name) do { \\\n        xf(1, name.delta_coded, current->name != 0, 0, 1, 0); \\\n        if (current->name) \\\n            xsu(1 + 6, name.delta_q, current->name, 0); \\\n    } while (0)\n\n#define leb128(name) do { \\\n        CHECK(cbs_av1_write_leb128(ctx, rw, #name, current->name)); \\\n    } while (0)\n\n#define infer(name, value) do { \\\n        if (current->name != (value)) { \\\n            av_log(ctx->log_ctx, AV_LOG_WARNING, \"Warning: \" \\\n                   \"%s does not match inferred value: \" \\\n                   \"%\"PRId64\", but should be %\"PRId64\".\\n\", \\\n                   #name, (int64_t)current->name, (int64_t)(value)); \\\n        } \\\n    } while (0)\n\n#define byte_alignment(rw) (put_bits_count(rw) % 8)\n\n#include \"cbs_av1_syntax_template.c\"\n\n#undef READ\n#undef READWRITE\n#undef RWContext\n#undef xf\n#undef xsu\n#undef uvlc\n#undef leb128\n#undef ns\n#undef increment\n#undef subexp\n#undef delta_q\n#undef infer\n#undef byte_alignment\n\n\nstatic int cbs_av1_split_fragment(CodedBitstreamContext *ctx,\n                                  CodedBitstreamFragment *frag,\n                                  int header)\n{\n    GetBitContext gbc;\n    uint8_t *data;\n    size_t size;\n    uint64_t obu_length;\n    int pos, err, trace;\n\n    // Don't include this parsing in trace output.\n    trace = ctx->trace_enable;\n    ctx->trace_enable = 0;\n\n    data = frag->data;\n    size = frag->data_size;\n\n    if (INT_MAX / 8 < size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid fragment: \"\n               \"too large (%\"SIZE_SPECIFIER\" bytes).\\n\", size);\n        err = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    while (size > 0) {\n        AV1RawOBUHeader header;\n        uint64_t obu_size;\n\n        init_get_bits(&gbc, data, 8 * size);\n\n        err = cbs_av1_read_obu_header(ctx, &gbc, &header);\n        if (err < 0)\n            goto fail;\n\n        if (get_bits_left(&gbc) < 8) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU: fragment \"\n                   \"too short (%\"SIZE_SPECIFIER\" bytes).\\n\", size);\n            err = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        if (header.obu_has_size_field) {\n            err = cbs_av1_read_leb128(ctx, &gbc, \"obu_size\", &obu_size);\n            if (err < 0)\n                goto fail;\n        } else\n            obu_size = size - 1 - header.obu_extension_flag;\n\n        pos = get_bits_count(&gbc);\n        av_assert0(pos % 8 == 0 && pos / 8 <= size);\n\n        obu_length = pos / 8 + obu_size;\n\n        if (size < obu_length) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU length: \"\n                   \"%\"PRIu64\", but only %\"SIZE_SPECIFIER\" bytes remaining in fragment.\\n\",\n                   obu_length, size);\n            err = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, -1, header.obu_type,\n                                      data, obu_length, frag->data_ref);\n        if (err < 0)\n            goto fail;\n\n        data += obu_length;\n        size -= obu_length;\n    }\n\n    err = 0;\nfail:\n    ctx->trace_enable = trace;\n    return err;\n}\n\nstatic void cbs_av1_free_tile_data(AV1RawTileData *td)\n{\n    av_buffer_unref(&td->data_ref);\n}\n\nstatic void cbs_av1_free_metadata(AV1RawMetadata *md)\n{\n    switch (md->metadata_type) {\n    case AV1_METADATA_TYPE_ITUT_T35:\n        av_buffer_unref(&md->metadata.itut_t35.payload_ref);\n        break;\n    }\n}\n\nstatic void cbs_av1_free_obu(void *unit, uint8_t *content)\n{\n    AV1RawOBU *obu = (AV1RawOBU*)content;\n\n    switch (obu->header.obu_type) {\n    case AV1_OBU_TILE_GROUP:\n        cbs_av1_free_tile_data(&obu->obu.tile_group.tile_data);\n        break;\n    case AV1_OBU_FRAME:\n        cbs_av1_free_tile_data(&obu->obu.frame.tile_group.tile_data);\n        break;\n    case AV1_OBU_TILE_LIST:\n        cbs_av1_free_tile_data(&obu->obu.tile_list.tile_data);\n        break;\n    case AV1_OBU_METADATA:\n        cbs_av1_free_metadata(&obu->obu.metadata);\n        break;\n    }\n\n    av_freep(&obu);\n}\n\nstatic int cbs_av1_ref_tile_data(CodedBitstreamContext *ctx,\n                                 CodedBitstreamUnit *unit,\n                                 GetBitContext *gbc,\n                                 AV1RawTileData *td)\n{\n    int pos;\n\n    pos = get_bits_count(gbc);\n    if (pos >= 8 * unit->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Bitstream ended before \"\n               \"any data in tile group (%d bits read).\\n\", pos);\n        return AVERROR_INVALIDDATA;\n    }\n    // Must be byte-aligned at this point.\n    av_assert0(pos % 8 == 0);\n\n    td->data_ref = av_buffer_ref(unit->data_ref);\n    if (!td->data_ref)\n        return AVERROR(ENOMEM);\n\n    td->data      = unit->data      + pos / 8;\n    td->data_size = unit->data_size - pos / 8;\n\n    return 0;\n}\n\nstatic int cbs_av1_read_unit(CodedBitstreamContext *ctx,\n                             CodedBitstreamUnit *unit)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n    AV1RawOBU *obu;\n    GetBitContext gbc;\n    int err, start_pos, end_pos;\n\n    err = ff_cbs_alloc_unit_content(ctx, unit, sizeof(*obu),\n                                    &cbs_av1_free_obu);\n    if (err < 0)\n        return err;\n    obu = unit->content;\n\n    err = init_get_bits(&gbc, unit->data, 8 * unit->data_size);\n    if (err < 0)\n        return err;\n\n    err = cbs_av1_read_obu_header(ctx, &gbc, &obu->header);\n    if (err < 0)\n        return err;\n    av_assert0(obu->header.obu_type == unit->type);\n\n    if (obu->header.obu_has_size_field) {\n        uint64_t obu_size;\n        err = cbs_av1_read_leb128(ctx, &gbc, \"obu_size\", &obu_size);\n        if (err < 0)\n            return err;\n        obu->obu_size = obu_size;\n    } else {\n        if (unit->data_size < 1 + obu->header.obu_extension_flag) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU length: \"\n                   \"unit too short (%\"SIZE_SPECIFIER\").\\n\", unit->data_size);\n            return AVERROR_INVALIDDATA;\n        }\n        obu->obu_size = unit->data_size - 1 - obu->header.obu_extension_flag;\n    }\n\n    start_pos = get_bits_count(&gbc);\n\n    if (obu->header.obu_extension_flag) {\n        priv->temporal_id = obu->header.temporal_id;\n        priv->spatial_id  = obu->header.temporal_id;\n\n        if (obu->header.obu_type != AV1_OBU_SEQUENCE_HEADER &&\n            obu->header.obu_type != AV1_OBU_TEMPORAL_DELIMITER &&\n            priv->operating_point_idc) {\n            int in_temporal_layer =\n                (priv->operating_point_idc >>  priv->temporal_id    ) & 1;\n            int in_spatial_layer  =\n                (priv->operating_point_idc >> (priv->spatial_id + 8)) & 1;\n            if (!in_temporal_layer || !in_spatial_layer) {\n                // Decoding will drop this OBU at this operating point.\n            }\n        }\n    } else {\n        priv->temporal_id = 0;\n        priv->spatial_id  = 0;\n    }\n\n    switch (obu->header.obu_type) {\n    case AV1_OBU_SEQUENCE_HEADER:\n        {\n            err = cbs_av1_read_sequence_header_obu(ctx, &gbc,\n                                                   &obu->obu.sequence_header);\n            if (err < 0)\n                return err;\n\n            av_buffer_unref(&priv->sequence_header_ref);\n            priv->sequence_header = NULL;\n\n            priv->sequence_header_ref = av_buffer_ref(unit->content_ref);\n            if (!priv->sequence_header_ref)\n                return AVERROR(ENOMEM);\n            priv->sequence_header = &obu->obu.sequence_header;\n        }\n        break;\n    case AV1_OBU_TEMPORAL_DELIMITER:\n        {\n            err = cbs_av1_read_temporal_delimiter_obu(ctx, &gbc);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_FRAME_HEADER:\n    case AV1_OBU_REDUNDANT_FRAME_HEADER:\n        {\n            err = cbs_av1_read_frame_header_obu(ctx, &gbc,\n                                                &obu->obu.frame_header,\n                                                obu->header.obu_type ==\n                                                AV1_OBU_REDUNDANT_FRAME_HEADER,\n                                                unit->data_ref);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_TILE_GROUP:\n        {\n            err = cbs_av1_read_tile_group_obu(ctx, &gbc,\n                                              &obu->obu.tile_group);\n            if (err < 0)\n                return err;\n\n            err = cbs_av1_ref_tile_data(ctx, unit, &gbc,\n                                        &obu->obu.tile_group.tile_data);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_FRAME:\n        {\n            err = cbs_av1_read_frame_obu(ctx, &gbc, &obu->obu.frame,\n                                         unit->data_ref);\n            if (err < 0)\n                return err;\n\n            err = cbs_av1_ref_tile_data(ctx, unit, &gbc,\n                                        &obu->obu.frame.tile_group.tile_data);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_TILE_LIST:\n        {\n            err = cbs_av1_read_tile_list_obu(ctx, &gbc,\n                                             &obu->obu.tile_list);\n            if (err < 0)\n                return err;\n\n            err = cbs_av1_ref_tile_data(ctx, unit, &gbc,\n                                        &obu->obu.tile_list.tile_data);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_METADATA:\n        {\n            err = cbs_av1_read_metadata_obu(ctx, &gbc, &obu->obu.metadata);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_PADDING:\n    default:\n        return AVERROR(ENOSYS);\n    }\n\n    end_pos = get_bits_count(&gbc);\n    av_assert0(end_pos <= unit->data_size * 8);\n\n    if (obu->obu_size > 0 &&\n        obu->header.obu_type != AV1_OBU_TILE_GROUP &&\n        obu->header.obu_type != AV1_OBU_FRAME) {\n        err = cbs_av1_read_trailing_bits(ctx, &gbc,\n                                         obu->obu_size * 8 + start_pos - end_pos);\n        if (err < 0)\n            return err;\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_write_obu(CodedBitstreamContext *ctx,\n                             CodedBitstreamUnit *unit,\n                             PutBitContext *pbc)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n    AV1RawOBU *obu = unit->content;\n    PutBitContext pbc_tmp;\n    AV1RawTileData *td;\n    size_t header_size;\n    int err, start_pos, end_pos, data_pos;\n\n    // OBUs in the normal bitstream format must contain a size field\n    // in every OBU (in annex B it is optional, but we don't support\n    // writing that).\n    obu->header.obu_has_size_field = 1;\n\n    err = cbs_av1_write_obu_header(ctx, pbc, &obu->header);\n    if (err < 0)\n        return err;\n\n    if (obu->header.obu_has_size_field) {\n        pbc_tmp = *pbc;\n        // Add space for the size field to fill later.\n        put_bits32(pbc, 0);\n        put_bits32(pbc, 0);\n    }\n\n    td = NULL;\n    start_pos = put_bits_count(pbc);\n\n    switch (obu->header.obu_type) {\n    case AV1_OBU_SEQUENCE_HEADER:\n        {\n            err = cbs_av1_write_sequence_header_obu(ctx, pbc,\n                                                    &obu->obu.sequence_header);\n            if (err < 0)\n                return err;\n\n            av_buffer_unref(&priv->sequence_header_ref);\n            priv->sequence_header = NULL;\n\n            priv->sequence_header_ref = av_buffer_ref(unit->content_ref);\n            if (!priv->sequence_header_ref)\n                return AVERROR(ENOMEM);\n            priv->sequence_header = &obu->obu.sequence_header;\n        }\n        break;\n    case AV1_OBU_TEMPORAL_DELIMITER:\n        {\n            err = cbs_av1_write_temporal_delimiter_obu(ctx, pbc);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_FRAME_HEADER:\n    case AV1_OBU_REDUNDANT_FRAME_HEADER:\n        {\n            err = cbs_av1_write_frame_header_obu(ctx, pbc,\n                                                 &obu->obu.frame_header,\n                                                 obu->header.obu_type ==\n                                                 AV1_OBU_REDUNDANT_FRAME_HEADER,\n                                                 NULL);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_TILE_GROUP:\n        {\n            err = cbs_av1_write_tile_group_obu(ctx, pbc,\n                                               &obu->obu.tile_group);\n            if (err < 0)\n                return err;\n\n            td = &obu->obu.tile_group.tile_data;\n        }\n        break;\n    case AV1_OBU_FRAME:\n        {\n            err = cbs_av1_write_frame_obu(ctx, pbc, &obu->obu.frame, NULL);\n            if (err < 0)\n                return err;\n\n            td = &obu->obu.frame.tile_group.tile_data;\n        }\n        break;\n    case AV1_OBU_TILE_LIST:\n        {\n            err = cbs_av1_write_tile_list_obu(ctx, pbc, &obu->obu.tile_list);\n            if (err < 0)\n                return err;\n\n            td = &obu->obu.tile_list.tile_data;\n        }\n        break;\n    case AV1_OBU_METADATA:\n        {\n            err = cbs_av1_write_metadata_obu(ctx, pbc, &obu->obu.metadata);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_PADDING:\n    default:\n        return AVERROR(ENOSYS);\n    }\n\n    end_pos = put_bits_count(pbc);\n    header_size = (end_pos - start_pos + 7) / 8;\n    if (td) {\n        obu->obu_size = header_size + td->data_size;\n    } else if (header_size > 0) {\n        // Add trailing bits and recalculate.\n        err = cbs_av1_write_trailing_bits(ctx, pbc, 8 - end_pos % 8);\n        if (err < 0)\n            return err;\n        end_pos = put_bits_count(pbc);\n        obu->obu_size = header_size = (end_pos - start_pos + 7) / 8;\n    } else {\n        // Empty OBU.\n        obu->obu_size = 0;\n    }\n\n    end_pos = put_bits_count(pbc);\n    // Must now be byte-aligned.\n    av_assert0(end_pos % 8 == 0);\n    flush_put_bits(pbc);\n    start_pos /= 8;\n    end_pos   /= 8;\n\n    *pbc = pbc_tmp;\n    err = cbs_av1_write_leb128(ctx, pbc, \"obu_size\", obu->obu_size);\n    if (err < 0)\n        return err;\n\n    data_pos = put_bits_count(pbc) / 8;\n    flush_put_bits(pbc);\n    av_assert0(data_pos <= start_pos);\n\n    if (8 * obu->obu_size > put_bits_left(pbc))\n        return AVERROR(ENOSPC);\n\n    if (obu->obu_size > 0) {\n        memmove(priv->write_buffer + data_pos,\n                priv->write_buffer + start_pos, header_size);\n        skip_put_bytes(pbc, header_size);\n\n        if (td) {\n            memcpy(priv->write_buffer + data_pos + header_size,\n                   td->data, td->data_size);\n            skip_put_bytes(pbc, td->data_size);\n        }\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_write_unit(CodedBitstreamContext *ctx,\n                              CodedBitstreamUnit *unit)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n    PutBitContext pbc;\n    int err;\n\n    if (!priv->write_buffer) {\n        // Initial write buffer size is 1MB.\n        priv->write_buffer_size = 1024 * 1024;\n\n    reallocate_and_try_again:\n        err = av_reallocp(&priv->write_buffer, priv->write_buffer_size);\n        if (err < 0) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Unable to allocate a \"\n                   \"sufficiently large write buffer (last attempt \"\n                   \"%\"SIZE_SPECIFIER\" bytes).\\n\", priv->write_buffer_size);\n            return err;\n        }\n    }\n\n    init_put_bits(&pbc, priv->write_buffer, priv->write_buffer_size);\n\n    err = cbs_av1_write_obu(ctx, unit, &pbc);\n    if (err == AVERROR(ENOSPC)) {\n        // Overflow.\n        priv->write_buffer_size *= 2;\n        goto reallocate_and_try_again;\n    }\n    if (err < 0)\n        return err;\n\n    // Overflow but we didn't notice.\n    av_assert0(put_bits_count(&pbc) <= 8 * priv->write_buffer_size);\n\n    // OBU data must be byte-aligned.\n    av_assert0(put_bits_count(&pbc) % 8 == 0);\n\n    unit->data_size = put_bits_count(&pbc) / 8;\n    flush_put_bits(&pbc);\n\n    err = ff_cbs_alloc_unit_data(ctx, unit, unit->data_size);\n    if (err < 0)\n        return err;\n\n    memcpy(unit->data, priv->write_buffer, unit->data_size);\n\n    return 0;\n}\n\nstatic int cbs_av1_assemble_fragment(CodedBitstreamContext *ctx,\n                                     CodedBitstreamFragment *frag)\n{\n    size_t size, pos;\n    int i;\n\n    size = 0;\n    for (i = 0; i < frag->nb_units; i++)\n        size += frag->units[i].data_size;\n\n    frag->data_ref = av_buffer_alloc(size + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!frag->data_ref)\n        return AVERROR(ENOMEM);\n    frag->data = frag->data_ref->data;\n    memset(frag->data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n    pos = 0;\n    for (i = 0; i < frag->nb_units; i++) {\n        memcpy(frag->data + pos, frag->units[i].data,\n               frag->units[i].data_size);\n        pos += frag->units[i].data_size;\n    }\n    av_assert0(pos == size);\n    frag->data_size = size;\n\n    return 0;\n}\n\nstatic void cbs_av1_close(CodedBitstreamContext *ctx)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n\n    av_buffer_unref(&priv->sequence_header_ref);\n    av_buffer_unref(&priv->frame_header_ref);\n\n    av_freep(&priv->write_buffer);\n}\n\nconst CodedBitstreamType ff_cbs_type_av1 = {\n    .codec_id          = AV_CODEC_ID_AV1,\n\n    .priv_data_size    = sizeof(CodedBitstreamAV1Context),\n\n    .split_fragment    = &cbs_av1_split_fragment,\n    .read_unit         = &cbs_av1_read_unit,\n    .write_unit        = &cbs_av1_write_unit,\n    .assemble_fragment = &cbs_av1_assemble_fragment,\n\n    .close             = &cbs_av1_close,\n};\n"], "fixing_code": ["/*\n * This file is part of FFmpeg.\n *\n * FFmpeg is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * FFmpeg is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with FFmpeg; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\n */\n\n#include \"libavutil/avassert.h\"\n#include \"libavutil/pixfmt.h\"\n\n#include \"cbs.h\"\n#include \"cbs_internal.h\"\n#include \"cbs_av1.h\"\n#include \"internal.h\"\n\n\nstatic int cbs_av1_read_uvlc(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                             const char *name, uint32_t *write_to,\n                             uint32_t range_min, uint32_t range_max)\n{\n    uint32_t zeroes, bits_value, value;\n    int position;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    zeroes = 0;\n    while (1) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        if (get_bits1(gbc))\n            break;\n        ++zeroes;\n    }\n\n    if (zeroes >= 32) {\n        value = MAX_UINT_BITS(32);\n    } else {\n        if (get_bits_left(gbc) < zeroes) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid uvlc code at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n\n        bits_value = get_bits_long(gbc, zeroes);\n        value = bits_value + (UINT32_C(1) << zeroes) - 1;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j, k;\n\n        if (zeroes >= 32) {\n            while (zeroes > 32) {\n                k = FFMIN(zeroes - 32, 32);\n                for (i = 0; i < k; i++)\n                    bits[i] = '0';\n                bits[i] = 0;\n                ff_cbs_trace_syntax_element(ctx, position, name,\n                                            NULL, bits, 0);\n                zeroes -= k;\n                position += k;\n            }\n        }\n\n        for (i = 0; i < zeroes; i++)\n            bits[i] = '0';\n        bits[i++] = '1';\n\n        if (zeroes < 32) {\n            for (j = 0; j < zeroes; j++)\n                bits[i++] = (bits_value >> (zeroes - j - 1) & 1) ? '1' : '0';\n        }\n\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name,\n                                    NULL, bits, value);\n    }\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_uvlc(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                              const char *name, uint32_t value,\n                              uint32_t range_min, uint32_t range_max)\n{\n    uint32_t v;\n    int position, zeroes;\n\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    if (value == 0) {\n        zeroes = 0;\n        put_bits(pbc, 1, 1);\n    } else {\n        zeroes = av_log2(value + 1);\n        v = value - (1 << zeroes) + 1;\n        put_bits(pbc, zeroes + 1, 1);\n        put_bits(pbc, zeroes, v);\n    }\n\n    if (ctx->trace_enable) {\n        char bits[65];\n        int i, j;\n        i = 0;\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = '0';\n        bits[i++] = '1';\n        for (j = 0; j < zeroes; j++)\n            bits[i++] = (v >> (zeroes - j - 1) & 1) ? '1' : '0';\n        bits[i++] = 0;\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL,\n                                    bits, value);\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_read_leb128(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                               const char *name, uint64_t *write_to)\n{\n    uint64_t value;\n    int position, err, i;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    value = 0;\n    for (i = 0; i < 8; i++) {\n        int subscript[2] = { 1, i };\n        uint32_t byte;\n        err = ff_cbs_read_unsigned(ctx, gbc, 8, \"leb128_byte[i]\", subscript,\n                                   &byte, 0x00, 0xff);\n        if (err < 0)\n            return err;\n\n        value |= (uint64_t)(byte & 0x7f) << (i * 7);\n        if (!(byte & 0x80))\n            break;\n    }\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL, \"\", value);\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_leb128(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                                const char *name, uint64_t value)\n{\n    int position, err, len, i;\n    uint8_t byte;\n\n    len = (av_log2(value) + 7) / 7;\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    for (i = 0; i < len; i++) {\n        int subscript[2] = { 1, i };\n\n        byte = value >> (7 * i) & 0x7f;\n        if (i < len - 1)\n            byte |= 0x80;\n\n        err = ff_cbs_write_unsigned(ctx, pbc, 8, \"leb128_byte[i]\", subscript,\n                                    byte, 0x00, 0xff);\n        if (err < 0)\n            return err;\n    }\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position, name, NULL, \"\", value);\n\n    return 0;\n}\n\nstatic int cbs_av1_read_su(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                           int width, const char *name,\n                           const int *subscripts, int32_t *write_to)\n{\n    int position;\n    int32_t value;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    if (get_bits_left(gbc) < width) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid signed value at \"\n               \"%s: bitstream ended.\\n\", name);\n        return AVERROR_INVALIDDATA;\n    }\n\n    value = get_sbits(gbc, width);\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < width; i++)\n            bits[i] = value & (1 << (width - i - 1)) ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, bits, value);\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_su(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                            int width, const char *name,\n                            const int *subscripts, int32_t value)\n{\n    if (put_bits_left(pbc) < width)\n        return AVERROR(ENOSPC);\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < width; i++)\n            bits[i] = value & (1 << (width - i - 1)) ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),\n                                    name, subscripts, bits, value);\n    }\n\n    put_sbits(pbc, width, value);\n\n    return 0;\n}\n\nstatic int cbs_av1_read_ns(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                           uint32_t n, const char *name,\n                           const int *subscripts, uint32_t *write_to)\n{\n    uint32_t w, m, v, extra_bit, value;\n    int position;\n\n    av_assert0(n > 0);\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    w = av_log2(n) + 1;\n    m = (1 << w) - n;\n\n    if (get_bits_left(gbc) < w) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid non-symmetric value at \"\n               \"%s: bitstream ended.\\n\", name);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (w - 1 > 0)\n        v = get_bits(gbc, w - 1);\n    else\n        v = 0;\n\n    if (v < m) {\n        value = v;\n    } else {\n        extra_bit = get_bits1(gbc);\n        value = (v << 1) - m + extra_bit;\n    }\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < w - 1; i++)\n            bits[i] = (v >> i & 1) ? '1' : '0';\n        if (v >= m)\n            bits[i++] = extra_bit ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, bits, value);\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_ns(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                            uint32_t n, const char *name,\n                            const int *subscripts, uint32_t value)\n{\n    uint32_t w, m, v, extra_bit;\n    int position;\n\n    if (value > n) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [0,%\"PRIu32\"].\\n\",\n               name, value, n);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    w = av_log2(n) + 1;\n    m = (1 << w) - n;\n\n    if (put_bits_left(pbc) < w)\n        return AVERROR(ENOSPC);\n\n    if (value < m) {\n        v = value;\n        put_bits(pbc, w - 1, v);\n    } else {\n        v = m + ((value - m) >> 1);\n        extra_bit = (value - m) & 1;\n        put_bits(pbc, w - 1, v);\n        put_bits(pbc, 1, extra_bit);\n    }\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < w - 1; i++)\n            bits[i] = (v >> i & 1) ? '1' : '0';\n        if (value >= m)\n            bits[i++] = extra_bit ? '1' : '0';\n        bits[i] = 0;\n\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, bits, value);\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_read_increment(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                                  uint32_t range_min, uint32_t range_max,\n                                  const char *name, uint32_t *write_to)\n{\n    uint32_t value;\n    int position, i;\n    char bits[33];\n\n    av_assert0(range_min <= range_max && range_max - range_min < sizeof(bits) - 1);\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    for (i = 0, value = range_min; value < range_max;) {\n        if (get_bits_left(gbc) < 1) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid increment value at \"\n                   \"%s: bitstream ended.\\n\", name);\n            return AVERROR_INVALIDDATA;\n        }\n        if (get_bits1(gbc)) {\n            bits[i++] = '1';\n            ++value;\n        } else {\n            bits[i++] = '0';\n            break;\n        }\n    }\n\n    if (ctx->trace_enable) {\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, NULL, bits, value);\n    }\n\n    *write_to = value;\n    return 0;\n}\n\nstatic int cbs_av1_write_increment(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                                   uint32_t range_min, uint32_t range_max,\n                                   const char *name, uint32_t value)\n{\n    int len;\n\n    av_assert0(range_min <= range_max && range_max - range_min < 32);\n    if (value < range_min || value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [%\"PRIu32\",%\"PRIu32\"].\\n\",\n               name, value, range_min, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (value == range_max)\n        len = range_max - range_min;\n    else\n        len = value - range_min + 1;\n    if (put_bits_left(pbc) < len)\n        return AVERROR(ENOSPC);\n\n    if (ctx->trace_enable) {\n        char bits[33];\n        int i;\n        for (i = 0; i < len; i++) {\n            if (range_min + i == value)\n                bits[i] = '0';\n            else\n                bits[i] = '1';\n        }\n        bits[i] = 0;\n        ff_cbs_trace_syntax_element(ctx, put_bits_count(pbc),\n                                    name, NULL, bits, value);\n    }\n\n    if (len > 0)\n        put_bits(pbc, len, (1 << len) - 1 - (value != range_max));\n\n    return 0;\n}\n\nstatic int cbs_av1_read_subexp(CodedBitstreamContext *ctx, GetBitContext *gbc,\n                               uint32_t range_max, const char *name,\n                               const int *subscripts, uint32_t *write_to)\n{\n    uint32_t value;\n    int position, err;\n    uint32_t max_len, len, range_offset, range_bits;\n\n    if (ctx->trace_enable)\n        position = get_bits_count(gbc);\n\n    av_assert0(range_max > 0);\n    max_len = av_log2(range_max - 1) - 3;\n\n    err = cbs_av1_read_increment(ctx, gbc, 0, max_len,\n                                 \"subexp_more_bits\", &len);\n    if (err < 0)\n        return err;\n\n    if (len) {\n        range_bits   = 2 + len;\n        range_offset = 1 << range_bits;\n    } else {\n        range_bits   = 3;\n        range_offset = 0;\n    }\n\n    if (len < max_len) {\n        err = ff_cbs_read_unsigned(ctx, gbc, range_bits,\n                                   \"subexp_bits\", NULL, &value,\n                                   0, MAX_UINT_BITS(range_bits));\n        if (err < 0)\n            return err;\n\n    } else {\n        err = cbs_av1_read_ns(ctx, gbc, range_max - range_offset,\n                              \"subexp_final_bits\", NULL, &value);\n        if (err < 0)\n            return err;\n    }\n    value += range_offset;\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, \"\", value);\n\n    *write_to = value;\n    return err;\n}\n\nstatic int cbs_av1_write_subexp(CodedBitstreamContext *ctx, PutBitContext *pbc,\n                                uint32_t range_max, const char *name,\n                                const int *subscripts, uint32_t value)\n{\n    int position, err;\n    uint32_t max_len, len, range_offset, range_bits;\n\n    if (value > range_max) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"%s out of range: \"\n               \"%\"PRIu32\", but must be in [0,%\"PRIu32\"].\\n\",\n               name, value, range_max);\n        return AVERROR_INVALIDDATA;\n    }\n\n    if (ctx->trace_enable)\n        position = put_bits_count(pbc);\n\n    av_assert0(range_max > 0);\n    max_len = av_log2(range_max - 1) - 3;\n\n    if (value < 8) {\n        range_bits   = 3;\n        range_offset = 0;\n        len = 0;\n    } else {\n        range_bits = av_log2(value);\n        len = range_bits - 2;\n        if (len > max_len) {\n            // The top bin is combined with the one below it.\n            av_assert0(len == max_len + 1);\n            --range_bits;\n            len = max_len;\n        }\n        range_offset = 1 << range_bits;\n    }\n\n    err = cbs_av1_write_increment(ctx, pbc, 0, max_len,\n                                  \"subexp_more_bits\", len);\n    if (err < 0)\n        return err;\n\n    if (len < max_len) {\n        err = ff_cbs_write_unsigned(ctx, pbc, range_bits,\n                                    \"subexp_bits\", NULL,\n                                    value - range_offset,\n                                    0, MAX_UINT_BITS(range_bits));\n        if (err < 0)\n            return err;\n\n    } else {\n        err = cbs_av1_write_ns(ctx, pbc, range_max - range_offset,\n                               \"subexp_final_bits\", NULL,\n                               value - range_offset);\n        if (err < 0)\n            return err;\n    }\n\n    if (ctx->trace_enable)\n        ff_cbs_trace_syntax_element(ctx, position,\n                                    name, subscripts, \"\", value);\n\n    return err;\n}\n\n\nstatic int cbs_av1_tile_log2(int blksize, int target)\n{\n    int k;\n    for (k = 0; (blksize << k) < target; k++);\n    return k;\n}\n\nstatic int cbs_av1_get_relative_dist(const AV1RawSequenceHeader *seq,\n                                     unsigned int a, unsigned int b)\n{\n    unsigned int diff, m;\n    if (!seq->enable_order_hint)\n        return 0;\n    diff = a - b;\n    m = 1 << seq->order_hint_bits_minus_1;\n    diff = (diff & (m - 1)) - (diff & m);\n    return diff;\n}\n\n\n#define HEADER(name) do { \\\n        ff_cbs_trace_header(ctx, name); \\\n    } while (0)\n\n#define CHECK(call) do { \\\n        err = (call); \\\n        if (err < 0) \\\n            return err; \\\n    } while (0)\n\n#define FUNC_NAME(rw, codec, name) cbs_ ## codec ## _ ## rw ## _ ## name\n#define FUNC_AV1(rw, name) FUNC_NAME(rw, av1, name)\n#define FUNC(name) FUNC_AV1(READWRITE, name)\n\n#define SUBSCRIPTS(subs, ...) (subs > 0 ? ((int[subs + 1]){ subs, __VA_ARGS__ }) : NULL)\n\n#define fb(width, name) \\\n        xf(width, name, current->name, 0, MAX_UINT_BITS(width), 0)\n#define fc(width, name, range_min, range_max) \\\n        xf(width, name, current->name, range_min, range_max, 0)\n#define flag(name) fb(1, name)\n#define su(width, name) \\\n        xsu(width, name, current->name, 0)\n\n#define fbs(width, name, subs, ...) \\\n        xf(width, name, current->name, 0, MAX_UINT_BITS(width), subs, __VA_ARGS__)\n#define fcs(width, name, range_min, range_max, subs, ...) \\\n        xf(width, name, current->name, range_min, range_max, subs, __VA_ARGS__)\n#define flags(name, subs, ...) \\\n        xf(1, name, current->name, 0, 1, subs, __VA_ARGS__)\n#define sus(width, name, subs, ...) \\\n        xsu(width, name, current->name, subs, __VA_ARGS__)\n\n#define fixed(width, name, value) do { \\\n        av_unused uint32_t fixed_value = value; \\\n        xf(width, name, fixed_value, value, value, 0); \\\n    } while (0)\n\n\n#define READ\n#define READWRITE read\n#define RWContext GetBitContext\n\n#define xf(width, name, var, range_min, range_max, subs, ...) do { \\\n        uint32_t value = range_min; \\\n        CHECK(ff_cbs_read_unsigned(ctx, rw, width, #name, \\\n                                   SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                   &value, range_min, range_max)); \\\n        var = value; \\\n    } while (0)\n\n#define xsu(width, name, var, subs, ...) do { \\\n        int32_t value = 0; \\\n        CHECK(cbs_av1_read_su(ctx, rw, width, #name, \\\n                              SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\\n        var = value; \\\n    } while (0)\n\n#define uvlc(name, range_min, range_max) do { \\\n        uint32_t value = range_min; \\\n        CHECK(cbs_av1_read_uvlc(ctx, rw, #name, \\\n                                &value, range_min, range_max)); \\\n        current->name = value; \\\n    } while (0)\n\n#define ns(max_value, name, subs, ...) do { \\\n        uint32_t value = 0; \\\n        CHECK(cbs_av1_read_ns(ctx, rw, max_value, #name, \\\n                              SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define increment(name, min, max) do { \\\n        uint32_t value = 0; \\\n        CHECK(cbs_av1_read_increment(ctx, rw, min, max, #name, &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define subexp(name, max, subs, ...) do { \\\n        uint32_t value = 0; \\\n        CHECK(cbs_av1_read_subexp(ctx, rw, max, #name, \\\n                                  SUBSCRIPTS(subs, __VA_ARGS__), &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define delta_q(name) do { \\\n        uint8_t delta_coded; \\\n        int8_t delta_q; \\\n        xf(1, name.delta_coded, delta_coded, 0, 1, 0); \\\n        if (delta_coded) \\\n            xsu(1 + 6, name.delta_q, delta_q, 0); \\\n        else \\\n            delta_q = 0; \\\n        current->name = delta_q; \\\n    } while (0)\n\n#define leb128(name) do { \\\n        uint64_t value = 0; \\\n        CHECK(cbs_av1_read_leb128(ctx, rw, #name, &value)); \\\n        current->name = value; \\\n    } while (0)\n\n#define infer(name, value) do { \\\n        current->name = value; \\\n    } while (0)\n\n#define byte_alignment(rw) (get_bits_count(rw) % 8)\n\n#include \"cbs_av1_syntax_template.c\"\n\n#undef READ\n#undef READWRITE\n#undef RWContext\n#undef xf\n#undef xsu\n#undef uvlc\n#undef leb128\n#undef ns\n#undef increment\n#undef subexp\n#undef delta_q\n#undef leb128\n#undef infer\n#undef byte_alignment\n\n\n#define WRITE\n#define READWRITE write\n#define RWContext PutBitContext\n\n#define xf(width, name, var, range_min, range_max, subs, ...) do { \\\n        CHECK(ff_cbs_write_unsigned(ctx, rw, width, #name, \\\n                                    SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                    var, range_min, range_max)); \\\n    } while (0)\n\n#define xsu(width, name, var, subs, ...) do { \\\n        CHECK(cbs_av1_write_su(ctx, rw, width, #name, \\\n                               SUBSCRIPTS(subs, __VA_ARGS__), var)); \\\n    } while (0)\n\n#define uvlc(name, range_min, range_max) do { \\\n        CHECK(cbs_av1_write_uvlc(ctx, rw, #name, current->name, \\\n                                 range_min, range_max)); \\\n    } while (0)\n\n#define ns(max_value, name, subs, ...) do { \\\n        CHECK(cbs_av1_write_ns(ctx, rw, max_value, #name, \\\n                               SUBSCRIPTS(subs, __VA_ARGS__), \\\n                               current->name)); \\\n    } while (0)\n\n#define increment(name, min, max) do { \\\n        CHECK(cbs_av1_write_increment(ctx, rw, min, max, #name, \\\n                                      current->name)); \\\n    } while (0)\n\n#define subexp(name, max, subs, ...) do { \\\n        CHECK(cbs_av1_write_subexp(ctx, rw, max, #name, \\\n                                   SUBSCRIPTS(subs, __VA_ARGS__), \\\n                                   current->name)); \\\n    } while (0)\n\n#define delta_q(name) do { \\\n        xf(1, name.delta_coded, current->name != 0, 0, 1, 0); \\\n        if (current->name) \\\n            xsu(1 + 6, name.delta_q, current->name, 0); \\\n    } while (0)\n\n#define leb128(name) do { \\\n        CHECK(cbs_av1_write_leb128(ctx, rw, #name, current->name)); \\\n    } while (0)\n\n#define infer(name, value) do { \\\n        if (current->name != (value)) { \\\n            av_log(ctx->log_ctx, AV_LOG_WARNING, \"Warning: \" \\\n                   \"%s does not match inferred value: \" \\\n                   \"%\"PRId64\", but should be %\"PRId64\".\\n\", \\\n                   #name, (int64_t)current->name, (int64_t)(value)); \\\n        } \\\n    } while (0)\n\n#define byte_alignment(rw) (put_bits_count(rw) % 8)\n\n#include \"cbs_av1_syntax_template.c\"\n\n#undef READ\n#undef READWRITE\n#undef RWContext\n#undef xf\n#undef xsu\n#undef uvlc\n#undef leb128\n#undef ns\n#undef increment\n#undef subexp\n#undef delta_q\n#undef infer\n#undef byte_alignment\n\n\nstatic int cbs_av1_split_fragment(CodedBitstreamContext *ctx,\n                                  CodedBitstreamFragment *frag,\n                                  int header)\n{\n    GetBitContext gbc;\n    uint8_t *data;\n    size_t size;\n    uint64_t obu_length;\n    int pos, err, trace;\n\n    // Don't include this parsing in trace output.\n    trace = ctx->trace_enable;\n    ctx->trace_enable = 0;\n\n    data = frag->data;\n    size = frag->data_size;\n\n    if (INT_MAX / 8 < size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid fragment: \"\n               \"too large (%\"SIZE_SPECIFIER\" bytes).\\n\", size);\n        err = AVERROR_INVALIDDATA;\n        goto fail;\n    }\n\n    while (size > 0) {\n        AV1RawOBUHeader header;\n        uint64_t obu_size;\n\n        init_get_bits(&gbc, data, 8 * size);\n\n        err = cbs_av1_read_obu_header(ctx, &gbc, &header);\n        if (err < 0)\n            goto fail;\n\n        if (get_bits_left(&gbc) < 8) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU: fragment \"\n                   \"too short (%\"SIZE_SPECIFIER\" bytes).\\n\", size);\n            err = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        if (header.obu_has_size_field) {\n            err = cbs_av1_read_leb128(ctx, &gbc, \"obu_size\", &obu_size);\n            if (err < 0)\n                goto fail;\n        } else\n            obu_size = size - 1 - header.obu_extension_flag;\n\n        pos = get_bits_count(&gbc);\n        av_assert0(pos % 8 == 0 && pos / 8 <= size);\n\n        obu_length = pos / 8 + obu_size;\n\n        if (size < obu_length) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU length: \"\n                   \"%\"PRIu64\", but only %\"SIZE_SPECIFIER\" bytes remaining in fragment.\\n\",\n                   obu_length, size);\n            err = AVERROR_INVALIDDATA;\n            goto fail;\n        }\n\n        err = ff_cbs_insert_unit_data(ctx, frag, -1, header.obu_type,\n                                      data, obu_length, frag->data_ref);\n        if (err < 0)\n            goto fail;\n\n        data += obu_length;\n        size -= obu_length;\n    }\n\n    err = 0;\nfail:\n    ctx->trace_enable = trace;\n    return err;\n}\n\nstatic void cbs_av1_free_tile_data(AV1RawTileData *td)\n{\n    av_buffer_unref(&td->data_ref);\n}\n\nstatic void cbs_av1_free_metadata(AV1RawMetadata *md)\n{\n    switch (md->metadata_type) {\n    case AV1_METADATA_TYPE_ITUT_T35:\n        av_buffer_unref(&md->metadata.itut_t35.payload_ref);\n        break;\n    }\n}\n\nstatic void cbs_av1_free_obu(void *unit, uint8_t *content)\n{\n    AV1RawOBU *obu = (AV1RawOBU*)content;\n\n    switch (obu->header.obu_type) {\n    case AV1_OBU_TILE_GROUP:\n        cbs_av1_free_tile_data(&obu->obu.tile_group.tile_data);\n        break;\n    case AV1_OBU_FRAME:\n        cbs_av1_free_tile_data(&obu->obu.frame.tile_group.tile_data);\n        break;\n    case AV1_OBU_TILE_LIST:\n        cbs_av1_free_tile_data(&obu->obu.tile_list.tile_data);\n        break;\n    case AV1_OBU_METADATA:\n        cbs_av1_free_metadata(&obu->obu.metadata);\n        break;\n    }\n\n    av_freep(&obu);\n}\n\nstatic int cbs_av1_ref_tile_data(CodedBitstreamContext *ctx,\n                                 CodedBitstreamUnit *unit,\n                                 GetBitContext *gbc,\n                                 AV1RawTileData *td)\n{\n    int pos;\n\n    pos = get_bits_count(gbc);\n    if (pos >= 8 * unit->data_size) {\n        av_log(ctx->log_ctx, AV_LOG_ERROR, \"Bitstream ended before \"\n               \"any data in tile group (%d bits read).\\n\", pos);\n        return AVERROR_INVALIDDATA;\n    }\n    // Must be byte-aligned at this point.\n    av_assert0(pos % 8 == 0);\n\n    td->data_ref = av_buffer_ref(unit->data_ref);\n    if (!td->data_ref)\n        return AVERROR(ENOMEM);\n\n    td->data      = unit->data      + pos / 8;\n    td->data_size = unit->data_size - pos / 8;\n\n    return 0;\n}\n\nstatic int cbs_av1_read_unit(CodedBitstreamContext *ctx,\n                             CodedBitstreamUnit *unit)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n    AV1RawOBU *obu;\n    GetBitContext gbc;\n    int err, start_pos, end_pos;\n\n    err = ff_cbs_alloc_unit_content(ctx, unit, sizeof(*obu),\n                                    &cbs_av1_free_obu);\n    if (err < 0)\n        return err;\n    obu = unit->content;\n\n    err = init_get_bits(&gbc, unit->data, 8 * unit->data_size);\n    if (err < 0)\n        return err;\n\n    err = cbs_av1_read_obu_header(ctx, &gbc, &obu->header);\n    if (err < 0)\n        return err;\n    av_assert0(obu->header.obu_type == unit->type);\n\n    if (obu->header.obu_has_size_field) {\n        uint64_t obu_size;\n        err = cbs_av1_read_leb128(ctx, &gbc, \"obu_size\", &obu_size);\n        if (err < 0)\n            return err;\n        obu->obu_size = obu_size;\n    } else {\n        if (unit->data_size < 1 + obu->header.obu_extension_flag) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Invalid OBU length: \"\n                   \"unit too short (%\"SIZE_SPECIFIER\").\\n\", unit->data_size);\n            return AVERROR_INVALIDDATA;\n        }\n        obu->obu_size = unit->data_size - 1 - obu->header.obu_extension_flag;\n    }\n\n    start_pos = get_bits_count(&gbc);\n\n    if (obu->header.obu_extension_flag) {\n        priv->temporal_id = obu->header.temporal_id;\n        priv->spatial_id  = obu->header.temporal_id;\n\n        if (obu->header.obu_type != AV1_OBU_SEQUENCE_HEADER &&\n            obu->header.obu_type != AV1_OBU_TEMPORAL_DELIMITER &&\n            priv->operating_point_idc) {\n            int in_temporal_layer =\n                (priv->operating_point_idc >>  priv->temporal_id    ) & 1;\n            int in_spatial_layer  =\n                (priv->operating_point_idc >> (priv->spatial_id + 8)) & 1;\n            if (!in_temporal_layer || !in_spatial_layer) {\n                // Decoding will drop this OBU at this operating point.\n            }\n        }\n    } else {\n        priv->temporal_id = 0;\n        priv->spatial_id  = 0;\n    }\n\n    switch (obu->header.obu_type) {\n    case AV1_OBU_SEQUENCE_HEADER:\n        {\n            err = cbs_av1_read_sequence_header_obu(ctx, &gbc,\n                                                   &obu->obu.sequence_header);\n            if (err < 0)\n                return err;\n\n            av_buffer_unref(&priv->sequence_header_ref);\n            priv->sequence_header = NULL;\n\n            priv->sequence_header_ref = av_buffer_ref(unit->content_ref);\n            if (!priv->sequence_header_ref)\n                return AVERROR(ENOMEM);\n            priv->sequence_header = &obu->obu.sequence_header;\n        }\n        break;\n    case AV1_OBU_TEMPORAL_DELIMITER:\n        {\n            err = cbs_av1_read_temporal_delimiter_obu(ctx, &gbc);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_FRAME_HEADER:\n    case AV1_OBU_REDUNDANT_FRAME_HEADER:\n        {\n            err = cbs_av1_read_frame_header_obu(ctx, &gbc,\n                                                &obu->obu.frame_header,\n                                                obu->header.obu_type ==\n                                                AV1_OBU_REDUNDANT_FRAME_HEADER,\n                                                unit->data_ref);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_TILE_GROUP:\n        {\n            err = cbs_av1_read_tile_group_obu(ctx, &gbc,\n                                              &obu->obu.tile_group);\n            if (err < 0)\n                return err;\n\n            err = cbs_av1_ref_tile_data(ctx, unit, &gbc,\n                                        &obu->obu.tile_group.tile_data);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_FRAME:\n        {\n            err = cbs_av1_read_frame_obu(ctx, &gbc, &obu->obu.frame,\n                                         unit->data_ref);\n            if (err < 0)\n                return err;\n\n            err = cbs_av1_ref_tile_data(ctx, unit, &gbc,\n                                        &obu->obu.frame.tile_group.tile_data);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_TILE_LIST:\n        {\n            err = cbs_av1_read_tile_list_obu(ctx, &gbc,\n                                             &obu->obu.tile_list);\n            if (err < 0)\n                return err;\n\n            err = cbs_av1_ref_tile_data(ctx, unit, &gbc,\n                                        &obu->obu.tile_list.tile_data);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_METADATA:\n        {\n            err = cbs_av1_read_metadata_obu(ctx, &gbc, &obu->obu.metadata);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_PADDING:\n    default:\n        return AVERROR(ENOSYS);\n    }\n\n    end_pos = get_bits_count(&gbc);\n    av_assert0(end_pos <= unit->data_size * 8);\n\n    if (obu->obu_size > 0 &&\n        obu->header.obu_type != AV1_OBU_TILE_GROUP &&\n        obu->header.obu_type != AV1_OBU_FRAME) {\n        err = cbs_av1_read_trailing_bits(ctx, &gbc,\n                                         obu->obu_size * 8 + start_pos - end_pos);\n        if (err < 0)\n            return err;\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_write_obu(CodedBitstreamContext *ctx,\n                             CodedBitstreamUnit *unit,\n                             PutBitContext *pbc)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n    AV1RawOBU *obu = unit->content;\n    PutBitContext pbc_tmp;\n    AV1RawTileData *td;\n    size_t header_size;\n    int err, start_pos, end_pos, data_pos;\n\n    // OBUs in the normal bitstream format must contain a size field\n    // in every OBU (in annex B it is optional, but we don't support\n    // writing that).\n    obu->header.obu_has_size_field = 1;\n\n    err = cbs_av1_write_obu_header(ctx, pbc, &obu->header);\n    if (err < 0)\n        return err;\n\n    if (obu->header.obu_has_size_field) {\n        pbc_tmp = *pbc;\n        // Add space for the size field to fill later.\n        put_bits32(pbc, 0);\n        put_bits32(pbc, 0);\n    }\n\n    td = NULL;\n    start_pos = put_bits_count(pbc);\n\n    switch (obu->header.obu_type) {\n    case AV1_OBU_SEQUENCE_HEADER:\n        {\n            err = cbs_av1_write_sequence_header_obu(ctx, pbc,\n                                                    &obu->obu.sequence_header);\n            if (err < 0)\n                return err;\n\n            av_buffer_unref(&priv->sequence_header_ref);\n            priv->sequence_header = NULL;\n\n            priv->sequence_header_ref = av_buffer_ref(unit->content_ref);\n            if (!priv->sequence_header_ref)\n                return AVERROR(ENOMEM);\n            priv->sequence_header = &obu->obu.sequence_header;\n        }\n        break;\n    case AV1_OBU_TEMPORAL_DELIMITER:\n        {\n            err = cbs_av1_write_temporal_delimiter_obu(ctx, pbc);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_FRAME_HEADER:\n    case AV1_OBU_REDUNDANT_FRAME_HEADER:\n        {\n            err = cbs_av1_write_frame_header_obu(ctx, pbc,\n                                                 &obu->obu.frame_header,\n                                                 obu->header.obu_type ==\n                                                 AV1_OBU_REDUNDANT_FRAME_HEADER,\n                                                 NULL);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_TILE_GROUP:\n        {\n            err = cbs_av1_write_tile_group_obu(ctx, pbc,\n                                               &obu->obu.tile_group);\n            if (err < 0)\n                return err;\n\n            td = &obu->obu.tile_group.tile_data;\n        }\n        break;\n    case AV1_OBU_FRAME:\n        {\n            err = cbs_av1_write_frame_obu(ctx, pbc, &obu->obu.frame, NULL);\n            if (err < 0)\n                return err;\n\n            td = &obu->obu.frame.tile_group.tile_data;\n        }\n        break;\n    case AV1_OBU_TILE_LIST:\n        {\n            err = cbs_av1_write_tile_list_obu(ctx, pbc, &obu->obu.tile_list);\n            if (err < 0)\n                return err;\n\n            td = &obu->obu.tile_list.tile_data;\n        }\n        break;\n    case AV1_OBU_METADATA:\n        {\n            err = cbs_av1_write_metadata_obu(ctx, pbc, &obu->obu.metadata);\n            if (err < 0)\n                return err;\n        }\n        break;\n    case AV1_OBU_PADDING:\n    default:\n        return AVERROR(ENOSYS);\n    }\n\n    end_pos = put_bits_count(pbc);\n    header_size = (end_pos - start_pos + 7) / 8;\n    if (td) {\n        obu->obu_size = header_size + td->data_size;\n    } else if (header_size > 0) {\n        // Add trailing bits and recalculate.\n        err = cbs_av1_write_trailing_bits(ctx, pbc, 8 - end_pos % 8);\n        if (err < 0)\n            return err;\n        end_pos = put_bits_count(pbc);\n        obu->obu_size = header_size = (end_pos - start_pos + 7) / 8;\n    } else {\n        // Empty OBU.\n        obu->obu_size = 0;\n    }\n\n    end_pos = put_bits_count(pbc);\n    // Must now be byte-aligned.\n    av_assert0(end_pos % 8 == 0);\n    flush_put_bits(pbc);\n    start_pos /= 8;\n    end_pos   /= 8;\n\n    *pbc = pbc_tmp;\n    err = cbs_av1_write_leb128(ctx, pbc, \"obu_size\", obu->obu_size);\n    if (err < 0)\n        return err;\n\n    data_pos = put_bits_count(pbc) / 8;\n    flush_put_bits(pbc);\n    av_assert0(data_pos <= start_pos);\n\n    if (8 * obu->obu_size > put_bits_left(pbc))\n        return AVERROR(ENOSPC);\n\n    if (obu->obu_size > 0) {\n        memmove(priv->write_buffer + data_pos,\n                priv->write_buffer + start_pos, header_size);\n        skip_put_bytes(pbc, header_size);\n\n        if (td) {\n            memcpy(priv->write_buffer + data_pos + header_size,\n                   td->data, td->data_size);\n            skip_put_bytes(pbc, td->data_size);\n        }\n    }\n\n    return 0;\n}\n\nstatic int cbs_av1_write_unit(CodedBitstreamContext *ctx,\n                              CodedBitstreamUnit *unit)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n    PutBitContext pbc;\n    int err;\n\n    if (!priv->write_buffer) {\n        // Initial write buffer size is 1MB.\n        priv->write_buffer_size = 1024 * 1024;\n\n    reallocate_and_try_again:\n        err = av_reallocp(&priv->write_buffer, priv->write_buffer_size);\n        if (err < 0) {\n            av_log(ctx->log_ctx, AV_LOG_ERROR, \"Unable to allocate a \"\n                   \"sufficiently large write buffer (last attempt \"\n                   \"%\"SIZE_SPECIFIER\" bytes).\\n\", priv->write_buffer_size);\n            return err;\n        }\n    }\n\n    init_put_bits(&pbc, priv->write_buffer, priv->write_buffer_size);\n\n    err = cbs_av1_write_obu(ctx, unit, &pbc);\n    if (err == AVERROR(ENOSPC)) {\n        // Overflow.\n        priv->write_buffer_size *= 2;\n        goto reallocate_and_try_again;\n    }\n    if (err < 0)\n        return err;\n\n    // Overflow but we didn't notice.\n    av_assert0(put_bits_count(&pbc) <= 8 * priv->write_buffer_size);\n\n    // OBU data must be byte-aligned.\n    av_assert0(put_bits_count(&pbc) % 8 == 0);\n\n    unit->data_size = put_bits_count(&pbc) / 8;\n    flush_put_bits(&pbc);\n\n    err = ff_cbs_alloc_unit_data(ctx, unit, unit->data_size);\n    if (err < 0)\n        return err;\n\n    memcpy(unit->data, priv->write_buffer, unit->data_size);\n\n    return 0;\n}\n\nstatic int cbs_av1_assemble_fragment(CodedBitstreamContext *ctx,\n                                     CodedBitstreamFragment *frag)\n{\n    size_t size, pos;\n    int i;\n\n    size = 0;\n    for (i = 0; i < frag->nb_units; i++)\n        size += frag->units[i].data_size;\n\n    frag->data_ref = av_buffer_alloc(size + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!frag->data_ref)\n        return AVERROR(ENOMEM);\n    frag->data = frag->data_ref->data;\n    memset(frag->data + size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n    pos = 0;\n    for (i = 0; i < frag->nb_units; i++) {\n        memcpy(frag->data + pos, frag->units[i].data,\n               frag->units[i].data_size);\n        pos += frag->units[i].data_size;\n    }\n    av_assert0(pos == size);\n    frag->data_size = size;\n\n    return 0;\n}\n\nstatic void cbs_av1_close(CodedBitstreamContext *ctx)\n{\n    CodedBitstreamAV1Context *priv = ctx->priv_data;\n\n    av_buffer_unref(&priv->sequence_header_ref);\n    av_buffer_unref(&priv->frame_header_ref);\n\n    av_freep(&priv->write_buffer);\n}\n\nconst CodedBitstreamType ff_cbs_type_av1 = {\n    .codec_id          = AV_CODEC_ID_AV1,\n\n    .priv_data_size    = sizeof(CodedBitstreamAV1Context),\n\n    .split_fragment    = &cbs_av1_split_fragment,\n    .read_unit         = &cbs_av1_read_unit,\n    .write_unit        = &cbs_av1_write_unit,\n    .assemble_fragment = &cbs_av1_assemble_fragment,\n\n    .close             = &cbs_av1_close,\n};\n"], "filenames": ["libavcodec/cbs_av1.c"], "buggy_code_start_loc": [32], "buggy_code_end_loc": [71], "fixing_code_start_loc": [32], "fixing_code_end_loc": [93], "type": "CWE-129", "message": "FFMPEG version 4.1 contains a CWE-129: Improper Validation of Array Index vulnerability in libavcodec/cbs_av1.c that can result in Denial of service. This attack appears to be exploitable via specially crafted AV1 file has to be provided as input. This vulnerability appears to have been fixed in after commit b97a4b658814b2de8b9f2a3bce491c002d34de31.", "other": {"cve": {"id": "CVE-2019-1000016", "sourceIdentifier": "cve@mitre.org", "published": "2019-02-04T21:29:01.283", "lastModified": "2019-02-06T17:00:29.340", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FFMPEG version 4.1 contains a CWE-129: Improper Validation of Array Index vulnerability in libavcodec/cbs_av1.c that can result in Denial of service. This attack appears to be exploitable via specially crafted AV1 file has to be provided as input. This vulnerability appears to have been fixed in after commit b97a4b658814b2de8b9f2a3bce491c002d34de31."}, {"lang": "es", "value": "FFMPEG 4.1 contiene una vulnerabilidad CWE-129: validaci\u00f3n incorrecta del \u00edndice de arrays en libavcodec/cbs_av1.c que puede resultar en una denegaci\u00f3n de servicio (DoS). Este ataque parece ser explotable mediante un archivo AV1 especialmente manipulado, que debe proporcionarse como entrada. La vulnerabilidad parece haber sido solucionada tras el commit con ID b97a4b658814b2de8b9f2a3bce491c002d34de31."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-129"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ffmpeg:ffmpeg:4.1:*:*:*:*:*:*:*", "matchCriteriaId": "DC791808-C7E8-4298-9FB1-C1D72C573255"}]}]}], "references": [{"url": "https://github.com/FFmpeg/FFmpeg/commit/b97a4b658814b2de8b9f2a3bce491c002d34de31#diff-cd7e24986650014d67f484f3ffceef3f", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/FFmpeg/FFmpeg/commit/b97a4b658814b2de8b9f2a3bce491c002d34de31#diff-cd7e24986650014d67f484f3ffceef3f"}}