{"buggy_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * findfile.c: Search for files in directories listed in 'path'\n */\n\n#include \"vim.h\"\n\n/*\n * File searching functions for 'path', 'tags' and 'cdpath' options.\n * External visible functions:\n * vim_findfile_init()\t\tcreates/initialises the search context\n * vim_findfile_free_visited()\tfree list of visited files/dirs of search\n *\t\t\t\tcontext\n * vim_findfile()\t\tfind a file in the search context\n * vim_findfile_cleanup()\tcleanup/free search context created by\n *\t\t\t\tvim_findfile_init()\n *\n * All static functions and variables start with 'ff_'\n *\n * In general it works like this:\n * First you create yourself a search context by calling vim_findfile_init().\n * It is possible to give a search context from a previous call to\n * vim_findfile_init(), so it can be reused. After this you call vim_findfile()\n * until you are satisfied with the result or it returns NULL. On every call it\n * returns the next file which matches the conditions given to\n * vim_findfile_init(). If it doesn't find a next file it returns NULL.\n *\n * It is possible to call vim_findfile_init() again to reinitialise your search\n * with some new parameters. Don't forget to pass your old search context to\n * it, so it can reuse it and especially reuse the list of already visited\n * directories. If you want to delete the list of already visited directories\n * simply call vim_findfile_free_visited().\n *\n * When you are done call vim_findfile_cleanup() to free the search context.\n *\n * The function vim_findfile_init() has a long comment, which describes the\n * needed parameters.\n *\n *\n *\n * ATTENTION:\n * ==========\n *\tAlso we use an allocated search context here, this functions are NOT\n *\tthread-safe!!!!!\n *\n *\tTo minimize parameter passing (or because I'm to lazy), only the\n *\texternal visible functions get a search context as a parameter. This is\n *\tthen assigned to a static global, which is used throughout the local\n *\tfunctions.\n */\n\n/*\n * type for the directory search stack\n */\ntypedef struct ff_stack\n{\n    struct ff_stack\t*ffs_prev;\n\n    // the fix part (no wildcards) and the part containing the wildcards\n    // of the search path\n    char_u\t\t*ffs_fix_path;\n#ifdef FEAT_PATH_EXTRA\n    char_u\t\t*ffs_wc_path;\n#endif\n\n    // files/dirs found in the above directory, matched by the first wildcard\n    // of wc_part\n    char_u\t\t**ffs_filearray;\n    int\t\t\tffs_filearray_size;\n    char_u\t\tffs_filearray_cur;   // needed for partly handled dirs\n\n    // to store status of partly handled directories\n    // 0: we work on this directory for the first time\n    // 1: this directory was partly searched in an earlier step\n    int\t\t\tffs_stage;\n\n    // How deep are we in the directory tree?\n    // Counts backward from value of level parameter to vim_findfile_init\n    int\t\t\tffs_level;\n\n    // Did we already expand '**' to an empty string?\n    int\t\t\tffs_star_star_empty;\n} ff_stack_T;\n\n/*\n * type for already visited directories or files.\n */\ntypedef struct ff_visited\n{\n    struct ff_visited\t*ffv_next;\n\n#ifdef FEAT_PATH_EXTRA\n    // Visited directories are different if the wildcard string are\n    // different. So we have to save it.\n    char_u\t\t*ffv_wc_path;\n#endif\n    // for unix use inode etc for comparison (needed because of links), else\n    // use filename.\n#ifdef UNIX\n    int\t\t\tffv_dev_valid;\t// ffv_dev and ffv_ino were set\n    dev_t\t\tffv_dev;\t// device number\n    ino_t\t\tffv_ino;\t// inode number\n#endif\n    // The memory for this struct is allocated according to the length of\n    // ffv_fname.\n    char_u\t\tffv_fname[1];\t// actually longer\n} ff_visited_T;\n\n/*\n * We might have to manage several visited lists during a search.\n * This is especially needed for the tags option. If tags is set to:\n *      \"./++/tags,./++/TAGS,++/tags\"  (replace + with *)\n * So we have to do 3 searches:\n *   1) search from the current files directory downward for the file \"tags\"\n *   2) search from the current files directory downward for the file \"TAGS\"\n *   3) search from Vims current directory downwards for the file \"tags\"\n * As you can see, the first and the third search are for the same file, so for\n * the third search we can use the visited list of the first search. For the\n * second search we must start from a empty visited list.\n * The struct ff_visited_list_hdr is used to manage a linked list of already\n * visited lists.\n */\ntypedef struct ff_visited_list_hdr\n{\n    struct ff_visited_list_hdr\t*ffvl_next;\n\n    // the filename the attached visited list is for\n    char_u\t\t\t*ffvl_filename;\n\n    ff_visited_T\t\t*ffvl_visited_list;\n\n} ff_visited_list_hdr_T;\n\n\n/*\n * '**' can be expanded to several directory levels.\n * Set the default maximum depth.\n */\n#define FF_MAX_STAR_STAR_EXPAND ((char_u)30)\n\n/*\n * The search context:\n *   ffsc_stack_ptr:\tthe stack for the dirs to search\n *   ffsc_visited_list: the currently active visited list\n *   ffsc_dir_visited_list: the currently active visited list for search dirs\n *   ffsc_visited_lists_list: the list of all visited lists\n *   ffsc_dir_visited_lists_list: the list of all visited lists for search dirs\n *   ffsc_file_to_search:     the file to search for\n *   ffsc_start_dir:\tthe starting directory, if search path was relative\n *   ffsc_fix_path:\tthe fix part of the given path (without wildcards)\n *\t\t\tNeeded for upward search.\n *   ffsc_wc_path:\tthe part of the given path containing wildcards\n *   ffsc_level:\thow many levels of dirs to search downwards\n *   ffsc_stopdirs_v:\tarray of stop directories for upward search\n *   ffsc_find_what:\tFINDFILE_BOTH, FINDFILE_DIR or FINDFILE_FILE\n *   ffsc_tagfile:\tsearching for tags file, don't use 'suffixesadd'\n */\ntypedef struct ff_search_ctx_T\n{\n     ff_stack_T\t\t\t*ffsc_stack_ptr;\n     ff_visited_list_hdr_T\t*ffsc_visited_list;\n     ff_visited_list_hdr_T\t*ffsc_dir_visited_list;\n     ff_visited_list_hdr_T\t*ffsc_visited_lists_list;\n     ff_visited_list_hdr_T\t*ffsc_dir_visited_lists_list;\n     char_u\t\t\t*ffsc_file_to_search;\n     char_u\t\t\t*ffsc_start_dir;\n     char_u\t\t\t*ffsc_fix_path;\n#ifdef FEAT_PATH_EXTRA\n     char_u\t\t\t*ffsc_wc_path;\n     int\t\t\tffsc_level;\n     char_u\t\t\t**ffsc_stopdirs_v;\n#endif\n     int\t\t\tffsc_find_what;\n     int\t\t\tffsc_tagfile;\n} ff_search_ctx_T;\n\n// locally needed functions\n#ifdef FEAT_PATH_EXTRA\nstatic int ff_check_visited(ff_visited_T **, char_u *, char_u *);\n#else\nstatic int ff_check_visited(ff_visited_T **, char_u *);\n#endif\nstatic void vim_findfile_free_visited(void *search_ctx_arg);\nstatic void vim_findfile_free_visited_list(ff_visited_list_hdr_T **list_headp);\nstatic void ff_free_visited_list(ff_visited_T *vl);\nstatic ff_visited_list_hdr_T* ff_get_visited_list(char_u *, ff_visited_list_hdr_T **list_headp);\n\nstatic void ff_push(ff_search_ctx_T *search_ctx, ff_stack_T *stack_ptr);\nstatic ff_stack_T *ff_pop(ff_search_ctx_T *search_ctx);\nstatic void ff_clear(ff_search_ctx_T *search_ctx);\nstatic void ff_free_stack_element(ff_stack_T *stack_ptr);\n#ifdef FEAT_PATH_EXTRA\nstatic ff_stack_T *ff_create_stack_element(char_u *, char_u *, int, int);\n#else\nstatic ff_stack_T *ff_create_stack_element(char_u *, int, int);\n#endif\n#ifdef FEAT_PATH_EXTRA\nstatic int ff_path_in_stoplist(char_u *, int, char_u **);\n#endif\n\nstatic char_u e_pathtoolong[] = N_(\"E854: path too long for completion\");\n\nstatic char_u\t*ff_expand_buffer = NULL; // used for expanding filenames\n\n#if 0\n/*\n * if someone likes findfirst/findnext, here are the functions\n * NOT TESTED!!\n */\n\nstatic void *ff_fn_search_context = NULL;\n\n    char_u *\nvim_findfirst(char_u *path, char_u *filename, int level)\n{\n    ff_fn_search_context =\n\tvim_findfile_init(path, filename, NULL, level, TRUE, FALSE,\n\t\tff_fn_search_context, rel_fname);\n    if (NULL == ff_fn_search_context)\n\treturn NULL;\n    else\n\treturn vim_findnext()\n}\n\n    char_u *\nvim_findnext(void)\n{\n    char_u *ret = vim_findfile(ff_fn_search_context);\n\n    if (NULL == ret)\n    {\n\tvim_findfile_cleanup(ff_fn_search_context);\n\tff_fn_search_context = NULL;\n    }\n    return ret;\n}\n#endif\n\n/*\n * Initialization routine for vim_findfile().\n *\n * Returns the newly allocated search context or NULL if an error occurred.\n *\n * Don't forget to clean up by calling vim_findfile_cleanup() if you are done\n * with the search context.\n *\n * Find the file 'filename' in the directory 'path'.\n * The parameter 'path' may contain wildcards. If so only search 'level'\n * directories deep. The parameter 'level' is the absolute maximum and is\n * not related to restricts given to the '**' wildcard. If 'level' is 100\n * and you use '**200' vim_findfile() will stop after 100 levels.\n *\n * 'filename' cannot contain wildcards!  It is used as-is, no backslashes to\n * escape special characters.\n *\n * If 'stopdirs' is not NULL and nothing is found downward, the search is\n * restarted on the next higher directory level. This is repeated until the\n * start-directory of a search is contained in 'stopdirs'. 'stopdirs' has the\n * format \";*<dirname>*\\(;<dirname>\\)*;\\=$\".\n *\n * If the 'path' is relative, the starting dir for the search is either VIM's\n * current dir or if the path starts with \"./\" the current files dir.\n * If the 'path' is absolute, the starting dir is that part of the path before\n * the first wildcard.\n *\n * Upward search is only done on the starting dir.\n *\n * If 'free_visited' is TRUE the list of already visited files/directories is\n * cleared. Set this to FALSE if you just want to search from another\n * directory, but want to be sure that no directory from a previous search is\n * searched again. This is useful if you search for a file at different places.\n * The list of visited files/dirs can also be cleared with the function\n * vim_findfile_free_visited().\n *\n * Set the parameter 'find_what' to FINDFILE_DIR if you want to search for\n * directories only, FINDFILE_FILE for files only, FINDFILE_BOTH for both.\n *\n * A search context returned by a previous call to vim_findfile_init() can be\n * passed in the parameter \"search_ctx_arg\".  This context is reused and\n * reinitialized with the new parameters.  The list of already visited\n * directories from this context is only deleted if the parameter\n * \"free_visited\" is true.  Be aware that the passed \"search_ctx_arg\" is freed\n * if the reinitialization fails.\n *\n * If you don't have a search context from a previous call \"search_ctx_arg\"\n * must be NULL.\n *\n * This function silently ignores a few errors, vim_findfile() will have\n * limited functionality then.\n */\n    void *\nvim_findfile_init(\n    char_u\t*path,\n    char_u\t*filename,\n    char_u\t*stopdirs UNUSED,\n    int\t\tlevel,\n    int\t\tfree_visited,\n    int\t\tfind_what,\n    void\t*search_ctx_arg,\n    int\t\ttagfile,\t// expanding names of tags files\n    char_u\t*rel_fname)\t// file name to use for \".\"\n{\n#ifdef FEAT_PATH_EXTRA\n    char_u\t\t*wc_part;\n#endif\n    ff_stack_T\t\t*sptr;\n    ff_search_ctx_T\t*search_ctx;\n\n    // If a search context is given by the caller, reuse it, else allocate a\n    // new one.\n    if (search_ctx_arg != NULL)\n\tsearch_ctx = search_ctx_arg;\n    else\n    {\n\tsearch_ctx = ALLOC_CLEAR_ONE(ff_search_ctx_T);\n\tif (search_ctx == NULL)\n\t    goto error_return;\n    }\n    search_ctx->ffsc_find_what = find_what;\n    search_ctx->ffsc_tagfile = tagfile;\n\n    // clear the search context, but NOT the visited lists\n    ff_clear(search_ctx);\n\n    // clear visited list if wanted\n    if (free_visited == TRUE)\n\tvim_findfile_free_visited(search_ctx);\n    else\n    {\n\t// Reuse old visited lists. Get the visited list for the given\n\t// filename. If no list for the current filename exists, creates a new\n\t// one.\n\tsearch_ctx->ffsc_visited_list = ff_get_visited_list(filename,\n\t\t\t\t\t&search_ctx->ffsc_visited_lists_list);\n\tif (search_ctx->ffsc_visited_list == NULL)\n\t    goto error_return;\n\tsearch_ctx->ffsc_dir_visited_list = ff_get_visited_list(filename,\n\t\t\t\t    &search_ctx->ffsc_dir_visited_lists_list);\n\tif (search_ctx->ffsc_dir_visited_list == NULL)\n\t    goto error_return;\n    }\n\n    if (ff_expand_buffer == NULL)\n    {\n\tff_expand_buffer = alloc(MAXPATHL);\n\tif (ff_expand_buffer == NULL)\n\t    goto error_return;\n    }\n\n    // Store information on starting dir now if path is relative.\n    // If path is absolute, we do that later.\n    if (path[0] == '.'\n\t    && (vim_ispathsep(path[1]) || path[1] == NUL)\n\t    && (!tagfile || vim_strchr(p_cpo, CPO_DOTTAG) == NULL)\n\t    && rel_fname != NULL)\n    {\n\tint\tlen = (int)(gettail(rel_fname) - rel_fname);\n\n\tif (!vim_isAbsName(rel_fname) && len + 1 < MAXPATHL)\n\t{\n\t    // Make the start dir an absolute path name.\n\t    vim_strncpy(ff_expand_buffer, rel_fname, len);\n\t    search_ctx->ffsc_start_dir = FullName_save(ff_expand_buffer, FALSE);\n\t}\n\telse\n\t    search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);\n\tif (search_ctx->ffsc_start_dir == NULL)\n\t    goto error_return;\n\tif (*++path != NUL)\n\t    ++path;\n    }\n    else if (*path == NUL || !vim_isAbsName(path))\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\t// \"c:dir\" needs \"c:\" to be expanded, otherwise use current dir\n\tif (*path != NUL && path[1] == ':')\n\t{\n\t    char_u  drive[3];\n\n\t    drive[0] = path[0];\n\t    drive[1] = ':';\n\t    drive[2] = NUL;\n\t    if (vim_FullName(drive, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)\n\t\tgoto error_return;\n\t    path += 2;\n\t}\n\telse\n#endif\n\tif (mch_dirname(ff_expand_buffer, MAXPATHL) == FAIL)\n\t    goto error_return;\n\n\tsearch_ctx->ffsc_start_dir = vim_strsave(ff_expand_buffer);\n\tif (search_ctx->ffsc_start_dir == NULL)\n\t    goto error_return;\n\n#ifdef BACKSLASH_IN_FILENAME\n\t// A path that starts with \"/dir\" is relative to the drive, not to the\n\t// directory (but not for \"//machine/dir\").  Only use the drive name.\n\tif ((*path == '/' || *path == '\\\\')\n\t\t&& path[1] != path[0]\n\t\t&& search_ctx->ffsc_start_dir[1] == ':')\n\t    search_ctx->ffsc_start_dir[2] = NUL;\n#endif\n    }\n\n#ifdef FEAT_PATH_EXTRA\n    /*\n     * If stopdirs are given, split them into an array of pointers.\n     * If this fails (mem allocation), there is no upward search at all or a\n     * stop directory is not recognized -> continue silently.\n     * If stopdirs just contains a \";\" or is empty,\n     * search_ctx->ffsc_stopdirs_v will only contain a  NULL pointer. This\n     * is handled as unlimited upward search.  See function\n     * ff_path_in_stoplist() for details.\n     */\n    if (stopdirs != NULL)\n    {\n\tchar_u\t*walker = stopdirs;\n\tint\tdircount;\n\n\twhile (*walker == ';')\n\t    walker++;\n\n\tdircount = 1;\n\tsearch_ctx->ffsc_stopdirs_v = ALLOC_ONE(char_u *);\n\n\tif (search_ctx->ffsc_stopdirs_v != NULL)\n\t{\n\t    do\n\t    {\n\t\tchar_u\t*helper;\n\t\tvoid\t*ptr;\n\n\t\thelper = walker;\n\t\tptr = vim_realloc(search_ctx->ffsc_stopdirs_v,\n\t\t\t\t\t   (dircount + 1) * sizeof(char_u *));\n\t\tif (ptr)\n\t\t    search_ctx->ffsc_stopdirs_v = ptr;\n\t\telse\n\t\t    // ignore, keep what we have and continue\n\t\t    break;\n\t\twalker = vim_strchr(walker, ';');\n\t\tif (walker)\n\t\t{\n\t\t    search_ctx->ffsc_stopdirs_v[dircount-1] =\n\t\t\t\t\t vim_strnsave(helper, walker - helper);\n\t\t    walker++;\n\t\t}\n\t\telse\n\t\t    // this might be \"\", which means ascent till top\n\t\t    // of directory tree.\n\t\t    search_ctx->ffsc_stopdirs_v[dircount-1] =\n\t\t\t\t\t\t\t  vim_strsave(helper);\n\n\t\tdircount++;\n\n\t    } while (walker != NULL);\n\t    search_ctx->ffsc_stopdirs_v[dircount-1] = NULL;\n\t}\n    }\n#endif\n\n#ifdef FEAT_PATH_EXTRA\n    search_ctx->ffsc_level = level;\n\n    /*\n     * split into:\n     *  -fix path\n     *  -wildcard_stuff (might be NULL)\n     */\n    wc_part = vim_strchr(path, '*');\n    if (wc_part != NULL)\n    {\n\tint\tllevel;\n\tint\tlen;\n\tchar\t*errpt;\n\n\t// save the fix part of the path\n\tsearch_ctx->ffsc_fix_path = vim_strnsave(path, wc_part - path);\n\n\t/*\n\t * copy wc_path and add restricts to the '**' wildcard.\n\t * The octet after a '**' is used as a (binary) counter.\n\t * So '**3' is transposed to '**^C' ('^C' is ASCII value 3)\n\t * or '**76' is transposed to '**N'( 'N' is ASCII value 76).\n\t * For EBCDIC you get different character values.\n\t * If no restrict is given after '**' the default is used.\n\t * Due to this technique the path looks awful if you print it as a\n\t * string.\n\t */\n\tlen = 0;\n\twhile (*wc_part != NUL)\n\t{\n\t    if (len + 5 >= MAXPATHL)\n\t    {\n\t\temsg(_(e_pathtoolong));\n\t\tbreak;\n\t    }\n\t    if (STRNCMP(wc_part, \"**\", 2) == 0)\n\t    {\n\t\tff_expand_buffer[len++] = *wc_part++;\n\t\tff_expand_buffer[len++] = *wc_part++;\n\n\t\tllevel = strtol((char *)wc_part, &errpt, 10);\n\t\tif ((char_u *)errpt != wc_part && llevel > 0 && llevel < 255)\n\t\t    ff_expand_buffer[len++] = llevel;\n\t\telse if ((char_u *)errpt != wc_part && llevel == 0)\n\t\t    // restrict is 0 -> remove already added '**'\n\t\t    len -= 2;\n\t\telse\n\t\t    ff_expand_buffer[len++] = FF_MAX_STAR_STAR_EXPAND;\n\t\twc_part = (char_u *)errpt;\n\t\tif (*wc_part != NUL && !vim_ispathsep(*wc_part))\n\t\t{\n\t\t    semsg(_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"), PATHSEPSTR);\n\t\t    goto error_return;\n\t\t}\n\t    }\n\t    else\n\t\tff_expand_buffer[len++] = *wc_part++;\n\t}\n\tff_expand_buffer[len] = NUL;\n\tsearch_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);\n\n\tif (search_ctx->ffsc_wc_path == NULL)\n\t    goto error_return;\n    }\n    else\n#endif\n\tsearch_ctx->ffsc_fix_path = vim_strsave(path);\n\n    if (search_ctx->ffsc_start_dir == NULL)\n    {\n\t// store the fix part as startdir.\n\t// This is needed if the parameter path is fully qualified.\n\tsearch_ctx->ffsc_start_dir = vim_strsave(search_ctx->ffsc_fix_path);\n\tif (search_ctx->ffsc_start_dir == NULL)\n\t    goto error_return;\n\tsearch_ctx->ffsc_fix_path[0] = NUL;\n    }\n\n    // create an absolute path\n    if (STRLEN(search_ctx->ffsc_start_dir)\n\t\t\t  + STRLEN(search_ctx->ffsc_fix_path) + 3 >= MAXPATHL)\n    {\n\temsg(_(e_pathtoolong));\n\tgoto error_return;\n    }\n    STRCPY(ff_expand_buffer, search_ctx->ffsc_start_dir);\n    add_pathsep(ff_expand_buffer);\n    {\n\tint    eb_len = (int)STRLEN(ff_expand_buffer);\n\tchar_u *buf = alloc(eb_len\n\t\t\t\t+ (int)STRLEN(search_ctx->ffsc_fix_path) + 1);\n\n\tSTRCPY(buf, ff_expand_buffer);\n\tSTRCPY(buf + eb_len, search_ctx->ffsc_fix_path);\n\tif (mch_isdir(buf))\n\t{\n\t    STRCAT(ff_expand_buffer, search_ctx->ffsc_fix_path);\n\t    add_pathsep(ff_expand_buffer);\n\t}\n#ifdef FEAT_PATH_EXTRA\n\telse\n\t{\n\t    char_u *p =  gettail(search_ctx->ffsc_fix_path);\n\t    char_u *wc_path = NULL;\n\t    char_u *temp = NULL;\n\t    int    len = 0;\n\n\t    if (p > search_ctx->ffsc_fix_path)\n\t    {\n\t\t// do not add '..' to the path and start upwards searching\n\t\tlen = (int)(p - search_ctx->ffsc_fix_path) - 1;\n\t\tif ((len >= 2\n\t\t\t&& STRNCMP(search_ctx->ffsc_fix_path, \"..\", 2) == 0)\n\t\t\t&& (len == 2\n\t\t\t\t   || search_ctx->ffsc_fix_path[2] == PATHSEP))\n\t\t{\n\t\t    vim_free(buf);\n\t\t    goto error_return;\n\t\t}\n\t\tSTRNCAT(ff_expand_buffer, search_ctx->ffsc_fix_path, len);\n\t\tadd_pathsep(ff_expand_buffer);\n\t    }\n\t    else\n\t\tlen = (int)STRLEN(search_ctx->ffsc_fix_path);\n\n\t    if (search_ctx->ffsc_wc_path != NULL)\n\t    {\n\t\twc_path = vim_strsave(search_ctx->ffsc_wc_path);\n\t\ttemp = alloc(STRLEN(search_ctx->ffsc_wc_path)\n\t\t\t\t + STRLEN(search_ctx->ffsc_fix_path + len)\n\t\t\t\t + 1);\n\t\tif (temp == NULL || wc_path == NULL)\n\t\t{\n\t\t    vim_free(buf);\n\t\t    vim_free(temp);\n\t\t    vim_free(wc_path);\n\t\t    goto error_return;\n\t\t}\n\n\t\tSTRCPY(temp, search_ctx->ffsc_fix_path + len);\n\t\tSTRCAT(temp, search_ctx->ffsc_wc_path);\n\t\tvim_free(search_ctx->ffsc_wc_path);\n\t\tvim_free(wc_path);\n\t\tsearch_ctx->ffsc_wc_path = temp;\n\t    }\n\t}\n#endif\n\tvim_free(buf);\n    }\n\n    sptr = ff_create_stack_element(ff_expand_buffer,\n#ifdef FEAT_PATH_EXTRA\n\t    search_ctx->ffsc_wc_path,\n#endif\n\t    level, 0);\n\n    if (sptr == NULL)\n\tgoto error_return;\n\n    ff_push(search_ctx, sptr);\n\n    search_ctx->ffsc_file_to_search = vim_strsave(filename);\n    if (search_ctx->ffsc_file_to_search == NULL)\n\tgoto error_return;\n\n    return search_ctx;\n\nerror_return:\n    /*\n     * We clear the search context now!\n     * Even when the caller gave us a (perhaps valid) context we free it here,\n     * as we might have already destroyed it.\n     */\n    vim_findfile_cleanup(search_ctx);\n    return NULL;\n}\n\n#if defined(FEAT_PATH_EXTRA) || defined(PROTO)\n/*\n * Get the stopdir string.  Check that ';' is not escaped.\n */\n    char_u *\nvim_findfile_stopdir(char_u *buf)\n{\n    char_u\t*r_ptr = buf;\n\n    while (*r_ptr != NUL && *r_ptr != ';')\n    {\n\tif (r_ptr[0] == '\\\\' && r_ptr[1] == ';')\n\t{\n\t    // Overwrite the escape char,\n\t    // use STRLEN(r_ptr) to move the trailing '\\0'.\n\t    STRMOVE(r_ptr, r_ptr + 1);\n\t    r_ptr++;\n\t}\n\tr_ptr++;\n    }\n    if (*r_ptr == ';')\n    {\n\t*r_ptr = 0;\n\tr_ptr++;\n    }\n    else if (*r_ptr == NUL)\n\tr_ptr = NULL;\n    return r_ptr;\n}\n#endif\n\n/*\n * Clean up the given search context. Can handle a NULL pointer.\n */\n    void\nvim_findfile_cleanup(void *ctx)\n{\n    if (ctx == NULL)\n\treturn;\n\n    vim_findfile_free_visited(ctx);\n    ff_clear(ctx);\n    vim_free(ctx);\n}\n\n/*\n * Find a file in a search context.\n * The search context was created with vim_findfile_init() above.\n * Return a pointer to an allocated file name or NULL if nothing found.\n * To get all matching files call this function until you get NULL.\n *\n * If the passed search_context is NULL, NULL is returned.\n *\n * The search algorithm is depth first. To change this replace the\n * stack with a list (don't forget to leave partly searched directories on the\n * top of the list).\n */\n    char_u *\nvim_findfile(void *search_ctx_arg)\n{\n    char_u\t*file_path;\n#ifdef FEAT_PATH_EXTRA\n    char_u\t*rest_of_wildcards;\n    char_u\t*path_end = NULL;\n#endif\n    ff_stack_T\t*stackp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_PATH_EXTRA)\n    int\t\tlen;\n#endif\n    int\t\ti;\n    char_u\t*p;\n#ifdef FEAT_SEARCHPATH\n    char_u\t*suf;\n#endif\n    ff_search_ctx_T *search_ctx;\n\n    if (search_ctx_arg == NULL)\n\treturn NULL;\n\n    search_ctx = (ff_search_ctx_T *)search_ctx_arg;\n\n    /*\n     * filepath is used as buffer for various actions and as the storage to\n     * return a found filename.\n     */\n    if ((file_path = alloc(MAXPATHL)) == NULL)\n\treturn NULL;\n\n#ifdef FEAT_PATH_EXTRA\n    // store the end of the start dir -- needed for upward search\n    if (search_ctx->ffsc_start_dir != NULL)\n\tpath_end = &search_ctx->ffsc_start_dir[\n\t\t\t\t\t  STRLEN(search_ctx->ffsc_start_dir)];\n#endif\n\n#ifdef FEAT_PATH_EXTRA\n    // upward search loop\n    for (;;)\n    {\n#endif\n\t// downward search loop\n\tfor (;;)\n\t{\n\t    // check if user user wants to stop the search\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\n\t    // get directory to work on from stack\n\t    stackp = ff_pop(search_ctx);\n\t    if (stackp == NULL)\n\t\tbreak;\n\n\t    /*\n\t     * TODO: decide if we leave this test in\n\t     *\n\t     * GOOD: don't search a directory(-tree) twice.\n\t     * BAD:  - check linked list for every new directory entered.\n\t     *       - check for double files also done below\n\t     *\n\t     * Here we check if we already searched this directory.\n\t     * We already searched a directory if:\n\t     * 1) The directory is the same.\n\t     * 2) We would use the same wildcard string.\n\t     *\n\t     * Good if you have links on same directory via several ways\n\t     *  or you have selfreferences in directories (e.g. SuSE Linux 6.3:\n\t     *  /etc/rc.d/init.d is linked to /etc/rc.d -> endless loop)\n\t     *\n\t     * This check is only needed for directories we work on for the\n\t     * first time (hence stackp->ff_filearray == NULL)\n\t     */\n\t    if (stackp->ffs_filearray == NULL\n\t\t    && ff_check_visited(&search_ctx->ffsc_dir_visited_list\n\t\t\t\t\t\t\t  ->ffvl_visited_list,\n\t\t\tstackp->ffs_fix_path\n#ifdef FEAT_PATH_EXTRA\n\t\t\t, stackp->ffs_wc_path\n#endif\n\t\t\t) == FAIL)\n\t    {\n#ifdef FF_VERBOSE\n\t\tif (p_verbose >= 5)\n\t\t{\n\t\t    verbose_enter_scroll();\n\t\t    smsg(\"Already Searched: %s (%s)\",\n\t\t\t\t   stackp->ffs_fix_path, stackp->ffs_wc_path);\n\t\t    // don't overwrite this either\n\t\t    msg_puts(\"\\n\");\n\t\t    verbose_leave_scroll();\n\t\t}\n#endif\n\t\tff_free_stack_element(stackp);\n\t\tcontinue;\n\t    }\n#ifdef FF_VERBOSE\n\t    else if (p_verbose >= 5)\n\t    {\n\t\tverbose_enter_scroll();\n\t\tsmsg(\"Searching: %s (%s)\",\n\t\t\t\t   stackp->ffs_fix_path, stackp->ffs_wc_path);\n\t\t// don't overwrite this either\n\t\tmsg_puts(\"\\n\");\n\t\tverbose_leave_scroll();\n\t    }\n#endif\n\n\t    // check depth\n\t    if (stackp->ffs_level <= 0)\n\t    {\n\t\tff_free_stack_element(stackp);\n\t\tcontinue;\n\t    }\n\n\t    file_path[0] = NUL;\n\n\t    /*\n\t     * If no filearray till now expand wildcards\n\t     * The function expand_wildcards() can handle an array of paths\n\t     * and all possible expands are returned in one array. We use this\n\t     * to handle the expansion of '**' into an empty string.\n\t     */\n\t    if (stackp->ffs_filearray == NULL)\n\t    {\n\t\tchar_u *dirptrs[2];\n\n\t\t// we use filepath to build the path expand_wildcards() should\n\t\t// expand.\n\t\tdirptrs[0] = file_path;\n\t\tdirptrs[1] = NULL;\n\n\t\t// if we have a start dir copy it in\n\t\tif (!vim_isAbsName(stackp->ffs_fix_path)\n\t\t\t\t\t\t&& search_ctx->ffsc_start_dir)\n\t\t{\n\t\t    if (STRLEN(search_ctx->ffsc_start_dir) + 1 < MAXPATHL)\n\t\t    {\n\t\t\tSTRCPY(file_path, search_ctx->ffsc_start_dir);\n\t\t\tadd_pathsep(file_path);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tff_free_stack_element(stackp);\n\t\t\tgoto fail;\n\t\t    }\n\t\t}\n\n\t\t// append the fix part of the search path\n\t\tif (STRLEN(file_path) + STRLEN(stackp->ffs_fix_path) + 1\n\t\t\t\t\t\t\t\t    < MAXPATHL)\n\t\t{\n\t\t    STRCAT(file_path, stackp->ffs_fix_path);\n\t\t    add_pathsep(file_path);\n\t\t}\n\t\telse\n\t\t{\n\t\t    ff_free_stack_element(stackp);\n\t\t    goto fail;\n\t\t}\n\n#ifdef FEAT_PATH_EXTRA\n\t\trest_of_wildcards = stackp->ffs_wc_path;\n\t\tif (*rest_of_wildcards != NUL)\n\t\t{\n\t\t    len = (int)STRLEN(file_path);\n\t\t    if (STRNCMP(rest_of_wildcards, \"**\", 2) == 0)\n\t\t    {\n\t\t\t// pointer to the restrict byte\n\t\t\t// The restrict byte is not a character!\n\t\t\tp = rest_of_wildcards + 2;\n\n\t\t\tif (*p > 0)\n\t\t\t{\n\t\t\t    (*p)--;\n\t\t\t    if (len + 1 < MAXPATHL)\n\t\t\t\tfile_path[len++] = '*';\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tff_free_stack_element(stackp);\n\t\t\t\tgoto fail;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (*p == 0)\n\t\t\t{\n\t\t\t    // remove '**<numb> from wildcards\n\t\t\t    STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);\n\t\t\t}\n\t\t\telse\n\t\t\t    rest_of_wildcards += 3;\n\n\t\t\tif (stackp->ffs_star_star_empty == 0)\n\t\t\t{\n\t\t\t    // if not done before, expand '**' to empty\n\t\t\t    stackp->ffs_star_star_empty = 1;\n\t\t\t    dirptrs[1] = stackp->ffs_fix_path;\n\t\t\t}\n\t\t    }\n\n\t\t    /*\n\t\t     * Here we copy until the next path separator or the end of\n\t\t     * the path. If we stop at a path separator, there is\n\t\t     * still something else left. This is handled below by\n\t\t     * pushing every directory returned from expand_wildcards()\n\t\t     * on the stack again for further search.\n\t\t     */\n\t\t    while (*rest_of_wildcards\n\t\t\t    && !vim_ispathsep(*rest_of_wildcards))\n\t\t\tif (len + 1 < MAXPATHL)\n\t\t\t    file_path[len++] = *rest_of_wildcards++;\n\t\t\telse\n\t\t\t{\n\t\t\t    ff_free_stack_element(stackp);\n\t\t\t    goto fail;\n\t\t\t}\n\n\t\t    file_path[len] = NUL;\n\t\t    if (vim_ispathsep(*rest_of_wildcards))\n\t\t\trest_of_wildcards++;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Expand wildcards like \"*\" and \"$VAR\".\n\t\t * If the path is a URL don't try this.\n\t\t */\n\t\tif (path_with_url(dirptrs[0]))\n\t\t{\n\t\t    stackp->ffs_filearray = ALLOC_ONE(char_u *);\n\t\t    if (stackp->ffs_filearray != NULL\n\t\t\t    && (stackp->ffs_filearray[0]\n\t\t\t\t= vim_strsave(dirptrs[0])) != NULL)\n\t\t\tstackp->ffs_filearray_size = 1;\n\t\t    else\n\t\t\tstackp->ffs_filearray_size = 0;\n\t\t}\n\t\telse\n\t\t    // Add EW_NOTWILD because the expanded path may contain\n\t\t    // wildcard characters that are to be taken literally.\n\t\t    // This is a bit of a hack.\n\t\t    expand_wildcards((dirptrs[1] == NULL) ? 1 : 2, dirptrs,\n\t\t\t    &stackp->ffs_filearray_size,\n\t\t\t    &stackp->ffs_filearray,\n\t\t\t    EW_DIR|EW_ADDSLASH|EW_SILENT|EW_NOTWILD);\n\n\t\tstackp->ffs_filearray_cur = 0;\n\t\tstackp->ffs_stage = 0;\n\t    }\n#ifdef FEAT_PATH_EXTRA\n\t    else\n\t\trest_of_wildcards = &stackp->ffs_wc_path[\n\t\t\t\t\t\t STRLEN(stackp->ffs_wc_path)];\n#endif\n\n\t    if (stackp->ffs_stage == 0)\n\t    {\n\t\t// this is the first time we work on this directory\n#ifdef FEAT_PATH_EXTRA\n\t\tif (*rest_of_wildcards == NUL)\n#endif\n\t\t{\n\t\t    /*\n\t\t     * We don't have further wildcards to expand, so we have to\n\t\t     * check for the final file now.\n\t\t     */\n\t\t    for (i = stackp->ffs_filearray_cur;\n\t\t\t\t\t  i < stackp->ffs_filearray_size; ++i)\n\t\t    {\n\t\t\tif (!path_with_url(stackp->ffs_filearray[i])\n\t\t\t\t      && !mch_isdir(stackp->ffs_filearray[i]))\n\t\t\t    continue;   // not a directory\n\n\t\t\t// prepare the filename to be checked for existence\n\t\t\t// below\n\t\t\tif (STRLEN(stackp->ffs_filearray[i]) + 1\n\t\t\t\t+ STRLEN(search_ctx->ffsc_file_to_search)\n\t\t\t\t\t\t\t\t    < MAXPATHL)\n\t\t\t{\n\t\t\t    STRCPY(file_path, stackp->ffs_filearray[i]);\n\t\t\t    add_pathsep(file_path);\n\t\t\t    STRCAT(file_path, search_ctx->ffsc_file_to_search);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ff_free_stack_element(stackp);\n\t\t\t    goto fail;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try without extra suffix and then with suffixes\n\t\t\t * from 'suffixesadd'.\n\t\t\t */\n#ifdef FEAT_SEARCHPATH\n\t\t\tlen = (int)STRLEN(file_path);\n\t\t\tif (search_ctx->ffsc_tagfile)\n\t\t\t    suf = (char_u *)\"\";\n\t\t\telse\n\t\t\t    suf = curbuf->b_p_sua;\n\t\t\tfor (;;)\n#endif\n\t\t\t{\n\t\t\t    // if file exists and we didn't already find it\n\t\t\t    if ((path_with_url(file_path)\n\t\t\t\t  || (mch_getperm(file_path) >= 0\n\t\t\t\t      && (search_ctx->ffsc_find_what\n\t\t\t\t\t\t\t      == FINDFILE_BOTH\n\t\t\t\t\t  || ((search_ctx->ffsc_find_what\n\t\t\t\t\t\t\t      == FINDFILE_DIR)\n\t\t\t\t\t\t   == mch_isdir(file_path)))))\n#ifndef FF_VERBOSE\n\t\t\t\t    && (ff_check_visited(\n\t\t\t\t\t    &search_ctx->ffsc_visited_list->ffvl_visited_list,\n\t\t\t\t\t    file_path\n#ifdef FEAT_PATH_EXTRA\n\t\t\t\t\t    , (char_u *)\"\"\n#endif\n\t\t\t\t\t    ) == OK)\n#endif\n\t\t\t       )\n\t\t\t    {\n#ifdef FF_VERBOSE\n\t\t\t\tif (ff_check_visited(\n\t\t\t\t\t    &search_ctx->ffsc_visited_list->ffvl_visited_list,\n\t\t\t\t\t    file_path\n#ifdef FEAT_PATH_EXTRA\n\t\t\t\t\t    , (char_u *)\"\"\n#endif\n\t\t\t\t\t\t    ) == FAIL)\n\t\t\t\t{\n\t\t\t\t    if (p_verbose >= 5)\n\t\t\t\t    {\n\t\t\t\t\tverbose_enter_scroll();\n\t\t\t\t\tsmsg(\"Already: %s\",\n\t\t\t\t\t\t\t\t   file_path);\n\t\t\t\t\t// don't overwrite this either\n\t\t\t\t\tmsg_puts(\"\\n\");\n\t\t\t\t\tverbose_leave_scroll();\n\t\t\t\t    }\n\t\t\t\t    continue;\n\t\t\t\t}\n#endif\n\n\t\t\t\t// push dir to examine rest of subdirs later\n\t\t\t\tstackp->ffs_filearray_cur = i + 1;\n\t\t\t\tff_push(search_ctx, stackp);\n\n\t\t\t\tif (!path_with_url(file_path))\n\t\t\t\t    simplify_filename(file_path);\n\t\t\t\tif (mch_dirname(ff_expand_buffer, MAXPATHL)\n\t\t\t\t\t\t\t\t\t== OK)\n\t\t\t\t{\n\t\t\t\t    p = shorten_fname(file_path,\n\t\t\t\t\t\t\t    ff_expand_buffer);\n\t\t\t\t    if (p != NULL)\n\t\t\t\t\tSTRMOVE(file_path, p);\n\t\t\t\t}\n#ifdef FF_VERBOSE\n\t\t\t\tif (p_verbose >= 5)\n\t\t\t\t{\n\t\t\t\t    verbose_enter_scroll();\n\t\t\t\t    smsg(\"HIT: %s\", file_path);\n\t\t\t\t    // don't overwrite this either\n\t\t\t\t    msg_puts(\"\\n\");\n\t\t\t\t    verbose_leave_scroll();\n\t\t\t\t}\n#endif\n\t\t\t\treturn file_path;\n\t\t\t    }\n\n#ifdef FEAT_SEARCHPATH\n\t\t\t    // Not found or found already, try next suffix.\n\t\t\t    if (*suf == NUL)\n\t\t\t\tbreak;\n\t\t\t    copy_option_part(&suf, file_path + len,\n\t\t\t\t\t\t\t MAXPATHL - len, \",\");\n#endif\n\t\t\t}\n\t\t    }\n\t\t}\n#ifdef FEAT_PATH_EXTRA\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * still wildcards left, push the directories for further\n\t\t     * search\n\t\t     */\n\t\t    for (i = stackp->ffs_filearray_cur;\n\t\t\t\t\t  i < stackp->ffs_filearray_size; ++i)\n\t\t    {\n\t\t\tif (!mch_isdir(stackp->ffs_filearray[i]))\n\t\t\t    continue;\t// not a directory\n\n\t\t\tff_push(search_ctx,\n\t\t\t\tff_create_stack_element(\n\t\t\t\t\t\t     stackp->ffs_filearray[i],\n\t\t\t\t\t\t     rest_of_wildcards,\n\t\t\t\t\t\t     stackp->ffs_level - 1, 0));\n\t\t    }\n\t\t}\n#endif\n\t\tstackp->ffs_filearray_cur = 0;\n\t\tstackp->ffs_stage = 1;\n\t    }\n\n#ifdef FEAT_PATH_EXTRA\n\t    /*\n\t     * if wildcards contains '**' we have to descent till we reach the\n\t     * leaves of the directory tree.\n\t     */\n\t    if (STRNCMP(stackp->ffs_wc_path, \"**\", 2) == 0)\n\t    {\n\t\tfor (i = stackp->ffs_filearray_cur;\n\t\t\t\t\t  i < stackp->ffs_filearray_size; ++i)\n\t\t{\n\t\t    if (fnamecmp(stackp->ffs_filearray[i],\n\t\t\t\t\t\t   stackp->ffs_fix_path) == 0)\n\t\t\tcontinue; // don't repush same directory\n\t\t    if (!mch_isdir(stackp->ffs_filearray[i]))\n\t\t\tcontinue;   // not a directory\n\t\t    ff_push(search_ctx,\n\t\t\t    ff_create_stack_element(stackp->ffs_filearray[i],\n\t\t\t\tstackp->ffs_wc_path, stackp->ffs_level - 1, 1));\n\t\t}\n\t    }\n#endif\n\n\t    // we are done with the current directory\n\t    ff_free_stack_element(stackp);\n\n\t}\n\n#ifdef FEAT_PATH_EXTRA\n\t// If we reached this, we didn't find anything downwards.\n\t// Let's check if we should do an upward search.\n\tif (search_ctx->ffsc_start_dir\n\t\t&& search_ctx->ffsc_stopdirs_v != NULL && !got_int)\n\t{\n\t    ff_stack_T  *sptr;\n\n\t    // is the last starting directory in the stop list?\n\t    if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,\n\t\t       (int)(path_end - search_ctx->ffsc_start_dir),\n\t\t       search_ctx->ffsc_stopdirs_v) == TRUE)\n\t\tbreak;\n\n\t    // cut of last dir\n\t    while (path_end > search_ctx->ffsc_start_dir\n\t\t\t\t\t\t  && vim_ispathsep(*path_end))\n\t\tpath_end--;\n\t    while (path_end > search_ctx->ffsc_start_dir\n\t\t\t\t\t      && !vim_ispathsep(path_end[-1]))\n\t\tpath_end--;\n\t    *path_end = 0;\n\t    path_end--;\n\n\t    if (*search_ctx->ffsc_start_dir == 0)\n\t\tbreak;\n\n\t    if (STRLEN(search_ctx->ffsc_start_dir) + 1\n\t\t    + STRLEN(search_ctx->ffsc_fix_path) < MAXPATHL)\n\t    {\n\t\tSTRCPY(file_path, search_ctx->ffsc_start_dir);\n\t\tadd_pathsep(file_path);\n\t\tSTRCAT(file_path, search_ctx->ffsc_fix_path);\n\t    }\n\t    else\n\t\tgoto fail;\n\n\t    // create a new stack entry\n\t    sptr = ff_create_stack_element(file_path,\n\t\t    search_ctx->ffsc_wc_path, search_ctx->ffsc_level, 0);\n\t    if (sptr == NULL)\n\t\tbreak;\n\t    ff_push(search_ctx, sptr);\n\t}\n\telse\n\t    break;\n    }\n#endif\n\nfail:\n    vim_free(file_path);\n    return NULL;\n}\n\n/*\n * Free the list of lists of visited files and directories\n * Can handle it if the passed search_context is NULL;\n */\n    static void\nvim_findfile_free_visited(void *search_ctx_arg)\n{\n    ff_search_ctx_T *search_ctx;\n\n    if (search_ctx_arg == NULL)\n\treturn;\n\n    search_ctx = (ff_search_ctx_T *)search_ctx_arg;\n    vim_findfile_free_visited_list(&search_ctx->ffsc_visited_lists_list);\n    vim_findfile_free_visited_list(&search_ctx->ffsc_dir_visited_lists_list);\n}\n\n    static void\nvim_findfile_free_visited_list(ff_visited_list_hdr_T **list_headp)\n{\n    ff_visited_list_hdr_T *vp;\n\n    while (*list_headp != NULL)\n    {\n\tvp = (*list_headp)->ffvl_next;\n\tff_free_visited_list((*list_headp)->ffvl_visited_list);\n\n\tvim_free((*list_headp)->ffvl_filename);\n\tvim_free(*list_headp);\n\t*list_headp = vp;\n    }\n    *list_headp = NULL;\n}\n\n    static void\nff_free_visited_list(ff_visited_T *vl)\n{\n    ff_visited_T *vp;\n\n    while (vl != NULL)\n    {\n\tvp = vl->ffv_next;\n#ifdef FEAT_PATH_EXTRA\n\tvim_free(vl->ffv_wc_path);\n#endif\n\tvim_free(vl);\n\tvl = vp;\n    }\n    vl = NULL;\n}\n\n/*\n * Returns the already visited list for the given filename. If none is found it\n * allocates a new one.\n */\n    static ff_visited_list_hdr_T*\nff_get_visited_list(\n    char_u\t\t\t*filename,\n    ff_visited_list_hdr_T\t**list_headp)\n{\n    ff_visited_list_hdr_T  *retptr = NULL;\n\n    // check if a visited list for the given filename exists\n    if (*list_headp != NULL)\n    {\n\tretptr = *list_headp;\n\twhile (retptr != NULL)\n\t{\n\t    if (fnamecmp(filename, retptr->ffvl_filename) == 0)\n\t    {\n#ifdef FF_VERBOSE\n\t\tif (p_verbose >= 5)\n\t\t{\n\t\t    verbose_enter_scroll();\n\t\t    smsg(\"ff_get_visited_list: FOUND list for %s\",\n\t\t\t\t\t\t\t\t    filename);\n\t\t    // don't overwrite this either\n\t\t    msg_puts(\"\\n\");\n\t\t    verbose_leave_scroll();\n\t\t}\n#endif\n\t\treturn retptr;\n\t    }\n\t    retptr = retptr->ffvl_next;\n\t}\n    }\n\n#ifdef FF_VERBOSE\n    if (p_verbose >= 5)\n    {\n\tverbose_enter_scroll();\n\tsmsg(\"ff_get_visited_list: new list for %s\", filename);\n\t// don't overwrite this either\n\tmsg_puts(\"\\n\");\n\tverbose_leave_scroll();\n    }\n#endif\n\n    /*\n     * if we reach this we didn't find a list and we have to allocate new list\n     */\n    retptr = ALLOC_ONE(ff_visited_list_hdr_T);\n    if (retptr == NULL)\n\treturn NULL;\n\n    retptr->ffvl_visited_list = NULL;\n    retptr->ffvl_filename = vim_strsave(filename);\n    if (retptr->ffvl_filename == NULL)\n    {\n\tvim_free(retptr);\n\treturn NULL;\n    }\n    retptr->ffvl_next = *list_headp;\n    *list_headp = retptr;\n\n    return retptr;\n}\n\n#ifdef FEAT_PATH_EXTRA\n/*\n * check if two wildcard paths are equal. Returns TRUE or FALSE.\n * They are equal if:\n *  - both paths are NULL\n *  - they have the same length\n *  - char by char comparison is OK\n *  - the only differences are in the counters behind a '**', so\n *    '**\\20' is equal to '**\\24'\n */\n    static int\nff_wc_equal(char_u *s1, char_u *s2)\n{\n    int\t\ti, j;\n    int\t\tc1 = NUL;\n    int\t\tc2 = NUL;\n    int\t\tprev1 = NUL;\n    int\t\tprev2 = NUL;\n\n    if (s1 == s2)\n\treturn TRUE;\n\n    if (s1 == NULL || s2 == NULL)\n\treturn FALSE;\n\n    for (i = 0, j = 0; s1[i] != NUL && s2[j] != NUL;)\n    {\n\tc1 = PTR2CHAR(s1 + i);\n\tc2 = PTR2CHAR(s2 + j);\n\n\tif ((p_fic ? MB_TOLOWER(c1) != MB_TOLOWER(c2) : c1 != c2)\n\t\t&& (prev1 != '*' || prev2 != '*'))\n\t    return FALSE;\n\tprev2 = prev1;\n\tprev1 = c1;\n\n\ti += mb_ptr2len(s1 + i);\n\tj += mb_ptr2len(s2 + j);\n    }\n    return s1[i] == s2[j];\n}\n#endif\n\n/*\n * maintains the list of already visited files and dirs\n * returns FAIL if the given file/dir is already in the list\n * returns OK if it is newly added\n *\n * TODO: What to do on memory allocation problems?\n *\t -> return TRUE - Better the file is found several times instead of\n *\t    never.\n */\n    static int\nff_check_visited(\n    ff_visited_T\t**visited_list,\n    char_u\t\t*fname\n#ifdef FEAT_PATH_EXTRA\n    , char_u\t\t*wc_path\n#endif\n    )\n{\n    ff_visited_T\t*vp;\n#ifdef UNIX\n    stat_T\t\tst;\n    int\t\t\turl = FALSE;\n#endif\n\n    // For an URL we only compare the name, otherwise we compare the\n    // device/inode (unix) or the full path name (not Unix).\n    if (path_with_url(fname))\n    {\n\tvim_strncpy(ff_expand_buffer, fname, MAXPATHL - 1);\n#ifdef UNIX\n\turl = TRUE;\n#endif\n    }\n    else\n    {\n\tff_expand_buffer[0] = NUL;\n#ifdef UNIX\n\tif (mch_stat((char *)fname, &st) < 0)\n#else\n\tif (vim_FullName(fname, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)\n#endif\n\t    return FAIL;\n    }\n\n    // check against list of already visited files\n    for (vp = *visited_list; vp != NULL; vp = vp->ffv_next)\n    {\n\tif (\n#ifdef UNIX\n\t\t!url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev\n\t\t\t\t\t\t  && vp->ffv_ino == st.st_ino)\n\t\t     :\n#endif\n\t\tfnamecmp(vp->ffv_fname, ff_expand_buffer) == 0\n\t   )\n\t{\n#ifdef FEAT_PATH_EXTRA\n\t    // are the wildcard parts equal\n\t    if (ff_wc_equal(vp->ffv_wc_path, wc_path) == TRUE)\n#endif\n\t\t// already visited\n\t\treturn FAIL;\n\t}\n    }\n\n    /*\n     * New file/dir.  Add it to the list of visited files/dirs.\n     */\n    vp = alloc(sizeof(ff_visited_T) + STRLEN(ff_expand_buffer));\n\n    if (vp != NULL)\n    {\n#ifdef UNIX\n\tif (!url)\n\t{\n\t    vp->ffv_dev_valid = TRUE;\n\t    vp->ffv_ino = st.st_ino;\n\t    vp->ffv_dev = st.st_dev;\n\t    vp->ffv_fname[0] = NUL;\n\t}\n\telse\n\t{\n\t    vp->ffv_dev_valid = FALSE;\n#endif\n\t    STRCPY(vp->ffv_fname, ff_expand_buffer);\n#ifdef UNIX\n\t}\n#endif\n#ifdef FEAT_PATH_EXTRA\n\tif (wc_path != NULL)\n\t    vp->ffv_wc_path = vim_strsave(wc_path);\n\telse\n\t    vp->ffv_wc_path = NULL;\n#endif\n\n\tvp->ffv_next = *visited_list;\n\t*visited_list = vp;\n    }\n\n    return OK;\n}\n\n/*\n * create stack element from given path pieces\n */\n    static ff_stack_T *\nff_create_stack_element(\n    char_u\t*fix_part,\n#ifdef FEAT_PATH_EXTRA\n    char_u\t*wc_part,\n#endif\n    int\t\tlevel,\n    int\t\tstar_star_empty)\n{\n    ff_stack_T\t*new;\n\n    new = ALLOC_ONE(ff_stack_T);\n    if (new == NULL)\n\treturn NULL;\n\n    new->ffs_prev\t   = NULL;\n    new->ffs_filearray\t   = NULL;\n    new->ffs_filearray_size = 0;\n    new->ffs_filearray_cur  = 0;\n    new->ffs_stage\t   = 0;\n    new->ffs_level\t   = level;\n    new->ffs_star_star_empty = star_star_empty;\n\n    // the following saves NULL pointer checks in vim_findfile\n    if (fix_part == NULL)\n\tfix_part = (char_u *)\"\";\n    new->ffs_fix_path = vim_strsave(fix_part);\n\n#ifdef FEAT_PATH_EXTRA\n    if (wc_part == NULL)\n\twc_part  = (char_u *)\"\";\n    new->ffs_wc_path = vim_strsave(wc_part);\n#endif\n\n    if (new->ffs_fix_path == NULL\n#ifdef FEAT_PATH_EXTRA\n\t    || new->ffs_wc_path == NULL\n#endif\n\t    )\n    {\n\tff_free_stack_element(new);\n\tnew = NULL;\n    }\n\n    return new;\n}\n\n/*\n * Push a dir on the directory stack.\n */\n    static void\nff_push(ff_search_ctx_T *search_ctx, ff_stack_T *stack_ptr)\n{\n    // check for NULL pointer, not to return an error to the user, but\n    // to prevent a crash\n    if (stack_ptr != NULL)\n    {\n\tstack_ptr->ffs_prev = search_ctx->ffsc_stack_ptr;\n\tsearch_ctx->ffsc_stack_ptr = stack_ptr;\n    }\n}\n\n/*\n * Pop a dir from the directory stack.\n * Returns NULL if stack is empty.\n */\n    static ff_stack_T *\nff_pop(ff_search_ctx_T *search_ctx)\n{\n    ff_stack_T  *sptr;\n\n    sptr = search_ctx->ffsc_stack_ptr;\n    if (search_ctx->ffsc_stack_ptr != NULL)\n\tsearch_ctx->ffsc_stack_ptr = search_ctx->ffsc_stack_ptr->ffs_prev;\n\n    return sptr;\n}\n\n/*\n * free the given stack element\n */\n    static void\nff_free_stack_element(ff_stack_T *stack_ptr)\n{\n    // vim_free handles possible NULL pointers\n    vim_free(stack_ptr->ffs_fix_path);\n#ifdef FEAT_PATH_EXTRA\n    vim_free(stack_ptr->ffs_wc_path);\n#endif\n\n    if (stack_ptr->ffs_filearray != NULL)\n\tFreeWild(stack_ptr->ffs_filearray_size, stack_ptr->ffs_filearray);\n\n    vim_free(stack_ptr);\n}\n\n/*\n * Clear the search context, but NOT the visited list.\n */\n    static void\nff_clear(ff_search_ctx_T *search_ctx)\n{\n    ff_stack_T   *sptr;\n\n    // clear up stack\n    while ((sptr = ff_pop(search_ctx)) != NULL)\n\tff_free_stack_element(sptr);\n\n    vim_free(search_ctx->ffsc_file_to_search);\n    vim_free(search_ctx->ffsc_start_dir);\n    vim_free(search_ctx->ffsc_fix_path);\n#ifdef FEAT_PATH_EXTRA\n    vim_free(search_ctx->ffsc_wc_path);\n#endif\n\n#ifdef FEAT_PATH_EXTRA\n    if (search_ctx->ffsc_stopdirs_v != NULL)\n    {\n\tint  i = 0;\n\n\twhile (search_ctx->ffsc_stopdirs_v[i] != NULL)\n\t{\n\t    vim_free(search_ctx->ffsc_stopdirs_v[i]);\n\t    i++;\n\t}\n\tvim_free(search_ctx->ffsc_stopdirs_v);\n    }\n    search_ctx->ffsc_stopdirs_v = NULL;\n#endif\n\n    // reset everything\n    search_ctx->ffsc_file_to_search = NULL;\n    search_ctx->ffsc_start_dir = NULL;\n    search_ctx->ffsc_fix_path = NULL;\n#ifdef FEAT_PATH_EXTRA\n    search_ctx->ffsc_wc_path = NULL;\n    search_ctx->ffsc_level = 0;\n#endif\n}\n\n#ifdef FEAT_PATH_EXTRA\n/*\n * check if the given path is in the stopdirs\n * returns TRUE if yes else FALSE\n */\n    static int\nff_path_in_stoplist(char_u *path, int path_len, char_u **stopdirs_v)\n{\n    int\t\ti = 0;\n\n    // eat up trailing path separators, except the first\n    while (path_len > 1 && vim_ispathsep(path[path_len - 1]))\n\tpath_len--;\n\n    // if no path consider it as match\n    if (path_len == 0)\n\treturn TRUE;\n\n    for (i = 0; stopdirs_v[i] != NULL; i++)\n    {\n\tif ((int)STRLEN(stopdirs_v[i]) > path_len)\n\t{\n\t    // match for parent directory. So '/home' also matches\n\t    // '/home/rks'. Check for PATHSEP in stopdirs_v[i], else\n\t    // '/home/r' would also match '/home/rks'\n\t    if (fnamencmp(stopdirs_v[i], path, path_len) == 0\n\t\t    && vim_ispathsep(stopdirs_v[i][path_len]))\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t    if (fnamecmp(stopdirs_v[i], path) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_SEARCHPATH) || defined(PROTO)\n/*\n * Find the file name \"ptr[len]\" in the path.  Also finds directory names.\n *\n * On the first call set the parameter 'first' to TRUE to initialize\n * the search.  For repeating calls to FALSE.\n *\n * Repeating calls will return other files called 'ptr[len]' from the path.\n *\n * Only on the first call 'ptr' and 'len' are used.  For repeating calls they\n * don't need valid values.\n *\n * If nothing found on the first call the option FNAME_MESS will issue the\n * message:\n *\t    'Can't find file \"<file>\" in path'\n * On repeating calls:\n *\t    'No more file \"<file>\" found in path'\n *\n * options:\n * FNAME_MESS\t    give error message when not found\n *\n * Uses NameBuff[]!\n *\n * Returns an allocated string for the file name.  NULL for error.\n *\n */\n    char_u *\nfind_file_in_path(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    int\t\tfirst,\t\t// use count'th matching file name\n    char_u\t*rel_fname)\t// file name searching relative to\n{\n    return find_file_in_path_option(ptr, len, options, first,\n\t    *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,\n\t    FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);\n}\n\nstatic char_u\t*ff_file_to_find = NULL;\nstatic void\t*fdip_search_ctx = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_findfile(void)\n{\n    vim_free(ff_file_to_find);\n    vim_findfile_cleanup(fdip_search_ctx);\n    vim_free(ff_expand_buffer);\n}\n# endif\n\n/*\n * Find the directory name \"ptr[len]\" in the path.\n *\n * options:\n * FNAME_MESS\t    give error message when not found\n * FNAME_UNESC\t    unescape backslashes.\n *\n * Uses NameBuff[]!\n *\n * Returns an allocated string for the file name.  NULL for error.\n */\n    char_u *\nfind_directory_in_path(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    char_u\t*rel_fname)\t// file name searching relative to\n{\n    return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,\n\t\t\t\t       FINDFILE_DIR, rel_fname, (char_u *)\"\");\n}\n\n    char_u *\nfind_file_in_path_option(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    int\t\tfirst,\t\t// use count'th matching file name\n    char_u\t*path_option,\t// p_path or p_cdpath\n    int\t\tfind_what,\t// FINDFILE_FILE, _DIR or _BOTH\n    char_u\t*rel_fname,\t// file name we are looking relative to.\n    char_u\t*suffixes)\t// list of suffixes, 'suffixesadd' option\n{\n    static char_u\t*dir;\n    static int\t\tdid_findfile_init = FALSE;\n    char_u\t\tsave_char;\n    char_u\t\t*file_name = NULL;\n    char_u\t\t*buf = NULL;\n    int\t\t\trel_to_curdir;\n# ifdef AMIGA\n    struct Process\t*proc = (struct Process *)FindTask(0L);\n    APTR\t\tsave_winptr = proc->pr_WindowPtr;\n\n    // Avoid a requester here for a volume that doesn't exist.\n    proc->pr_WindowPtr = (APTR)-1L;\n# endif\n\n    if (first == TRUE)\n    {\n\t// copy file name into NameBuff, expanding environment variables\n\tsave_char = ptr[len];\n\tptr[len] = NUL;\n\texpand_env_esc(ptr, NameBuff, MAXPATHL, FALSE, TRUE, NULL);\n\tptr[len] = save_char;\n\n\tvim_free(ff_file_to_find);\n\tff_file_to_find = vim_strsave(NameBuff);\n\tif (ff_file_to_find == NULL)\t// out of memory\n\t{\n\t    file_name = NULL;\n\t    goto theend;\n\t}\n\tif (options & FNAME_UNESC)\n\t{\n\t    // Change all \"\\ \" to \" \".\n\t    for (ptr = ff_file_to_find; *ptr != NUL; ++ptr)\n\t\tif (ptr[0] == '\\\\' && ptr[1] == ' ')\n\t\t    mch_memmove(ptr, ptr + 1, STRLEN(ptr));\n\t}\n    }\n\n    rel_to_curdir = (ff_file_to_find[0] == '.'\n\t\t    && (ff_file_to_find[1] == NUL\n\t\t\t|| vim_ispathsep(ff_file_to_find[1])\n\t\t\t|| (ff_file_to_find[1] == '.'\n\t\t\t    && (ff_file_to_find[2] == NUL\n\t\t\t\t|| vim_ispathsep(ff_file_to_find[2])))));\n    if (vim_isAbsName(ff_file_to_find)\n\t    // \"..\", \"../path\", \".\" and \"./path\": don't use the path_option\n\t    || rel_to_curdir\n# if defined(MSWIN)\n\t    // handle \"\\tmp\" as absolute path\n\t    || vim_ispathsep(ff_file_to_find[0])\n\t    // handle \"c:name\" as absolute path\n\t    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')\n# endif\n# ifdef AMIGA\n\t    // handle \":tmp\" as absolute path\n\t    || ff_file_to_find[0] == ':'\n# endif\n       )\n    {\n\t/*\n\t * Absolute path, no need to use \"path_option\".\n\t * If this is not a first call, return NULL.  We already returned a\n\t * filename on the first call.\n\t */\n\tif (first == TRUE)\n\t{\n\t    int\t\tl;\n\t    int\t\trun;\n\n\t    if (path_with_url(ff_file_to_find))\n\t    {\n\t\tfile_name = vim_strsave(ff_file_to_find);\n\t\tgoto theend;\n\t    }\n\n\t    // When FNAME_REL flag given first use the directory of the file.\n\t    // Otherwise or when this fails use the current directory.\n\t    for (run = 1; run <= 2; ++run)\n\t    {\n\t\tl = (int)STRLEN(ff_file_to_find);\n\t\tif (run == 1\n\t\t\t&& rel_to_curdir\n\t\t\t&& (options & FNAME_REL)\n\t\t\t&& rel_fname != NULL\n\t\t\t&& STRLEN(rel_fname) + l < MAXPATHL)\n\t\t{\n\t\t    STRCPY(NameBuff, rel_fname);\n\t\t    STRCPY(gettail(NameBuff), ff_file_to_find);\n\t\t    l = (int)STRLEN(NameBuff);\n\t\t}\n\t\telse\n\t\t{\n\t\t    STRCPY(NameBuff, ff_file_to_find);\n\t\t    run = 2;\n\t\t}\n\n\t\t// When the file doesn't exist, try adding parts of\n\t\t// 'suffixesadd'.\n\t\tbuf = suffixes;\n\t\tfor (;;)\n\t\t{\n\t\t    if (mch_getperm(NameBuff) >= 0\n\t\t\t     && (find_what == FINDFILE_BOTH\n\t\t\t\t || ((find_what == FINDFILE_DIR)\n\t\t\t\t\t\t    == mch_isdir(NameBuff))))\n\t\t    {\n\t\t\tfile_name = vim_strsave(NameBuff);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (*buf == NUL)\n\t\t\tbreak;\n\t\t    copy_option_part(&buf, NameBuff + l, MAXPATHL - l, \",\");\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * Loop over all paths in the 'path' or 'cdpath' option.\n\t * When \"first\" is set, first setup to the start of the option.\n\t * Otherwise continue to find the next match.\n\t */\n\tif (first == TRUE)\n\t{\n\t    // vim_findfile_free_visited can handle a possible NULL pointer\n\t    vim_findfile_free_visited(fdip_search_ctx);\n\t    dir = path_option;\n\t    did_findfile_init = FALSE;\n\t}\n\n\tfor (;;)\n\t{\n\t    if (did_findfile_init)\n\t    {\n\t\tfile_name = vim_findfile(fdip_search_ctx);\n\t\tif (file_name != NULL)\n\t\t    break;\n\n\t\tdid_findfile_init = FALSE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u  *r_ptr;\n\n\t\tif (dir == NULL || *dir == NUL)\n\t\t{\n\t\t    // We searched all paths of the option, now we can\n\t\t    // free the search context.\n\t\t    vim_findfile_cleanup(fdip_search_ctx);\n\t\t    fdip_search_ctx = NULL;\n\t\t    break;\n\t\t}\n\n\t\tif ((buf = alloc(MAXPATHL)) == NULL)\n\t\t    break;\n\n\t\t// copy next path\n\t\tbuf[0] = 0;\n\t\tcopy_option_part(&dir, buf, MAXPATHL, \" ,\");\n\n# ifdef FEAT_PATH_EXTRA\n\t\t// get the stopdir string\n\t\tr_ptr = vim_findfile_stopdir(buf);\n# else\n\t\tr_ptr = NULL;\n# endif\n\t\tfdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,\n\t\t\t\t\t    r_ptr, 100, FALSE, find_what,\n\t\t\t\t\t   fdip_search_ctx, FALSE, rel_fname);\n\t\tif (fdip_search_ctx != NULL)\n\t\t    did_findfile_init = TRUE;\n\t\tvim_free(buf);\n\t    }\n\t}\n    }\n    if (file_name == NULL && (options & FNAME_MESS))\n    {\n\tif (first == TRUE)\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E345: Can't find file \\\"%s\\\" in path\"),\n\t\t\tff_file_to_find);\n\t}\n\telse\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E347: No more file \\\"%s\\\" found in path\"),\n\t\t\tff_file_to_find);\n\t}\n    }\n\ntheend:\n# ifdef AMIGA\n    proc->pr_WindowPtr = save_winptr;\n# endif\n    return file_name;\n}\n\n/*\n * Get the file name at the cursor.\n * If Visual mode is active, use the selected text if it's in one line.\n * Returns the name in allocated memory, NULL for failure.\n */\n    char_u *\ngrab_file_name(long count, linenr_T *file_lnum)\n{\n    int options = FNAME_MESS|FNAME_EXP|FNAME_REL|FNAME_UNESC;\n\n    if (VIsual_active)\n    {\n\tint\tlen;\n\tchar_u\t*ptr;\n\n\tif (get_visual_text(NULL, &ptr, &len) == FAIL)\n\t    return NULL;\n\t// Only recognize \":123\" here\n\tif (file_lnum != NULL && ptr[len] == ':' && isdigit(ptr[len + 1]))\n\t{\n\t    char_u *p = ptr + len + 1;\n\n\t    *file_lnum = getdigits(&p);\n\t}\n\treturn find_file_name_in_path(ptr, len, options,\n\t\t\t\t\t\t     count, curbuf->b_ffname);\n    }\n    return file_name_at_cursor(options | FNAME_HYP, count, file_lnum);\n}\n\n/*\n * Return the file name under or after the cursor.\n *\n * The 'path' option is searched if the file name is not absolute.\n * The string returned has been alloc'ed and should be freed by the caller.\n * NULL is returned if the file name or file is not found.\n *\n * options:\n * FNAME_MESS\t    give error messages\n * FNAME_EXP\t    expand to path\n * FNAME_HYP\t    check for hypertext link\n * FNAME_INCL\t    apply \"includeexpr\"\n */\n    char_u *\nfile_name_at_cursor(int options, long count, linenr_T *file_lnum)\n{\n    return file_name_in_line(ml_get_curline(),\n\t\t      curwin->w_cursor.col, options, count, curbuf->b_ffname,\n\t\t      file_lnum);\n}\n\n/*\n * Return the name of the file under or after ptr[col].\n * Otherwise like file_name_at_cursor().\n */\n    char_u *\nfile_name_in_line(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\toptions,\n    long\tcount,\n    char_u\t*rel_fname,\t// file we are searching relative to\n    linenr_T\t*file_lnum)\t// line number after the file name\n{\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\tin_type = TRUE;\n    int\t\tis_url = FALSE;\n\n    /*\n     * search forward for what could be the start of a file name\n     */\n    ptr = line + col;\n    while (*ptr != NUL && !vim_isfilec(*ptr))\n\tMB_PTR_ADV(ptr);\n    if (*ptr == NUL)\t\t// nothing found\n    {\n\tif (options & FNAME_MESS)\n\t    emsg(_(\"E446: No file name under cursor\"));\n\treturn NULL;\n    }\n\n    /*\n     * Search backward for first char of the file name.\n     * Go one char back to \":\" before \"//\" even when ':' is not in 'isfname'.\n     */\n    while (ptr > line)\n    {\n\tif (has_mbyte && (len = (*mb_head_off)(line, ptr - 1)) > 0)\n\t    ptr -= len + 1;\n\telse if (vim_isfilec(ptr[-1])\n\t\t|| ((options & FNAME_HYP) && path_is_url(ptr - 1)))\n\t    --ptr;\n\telse\n\t    break;\n    }\n\n    /*\n     * Search forward for the last char of the file name.\n     * Also allow \"://\" when ':' is not in 'isfname'.\n     */\n    len = 0;\n    while (vim_isfilec(ptr[len]) || (ptr[len] == '\\\\' && ptr[len + 1] == ' ')\n\t\t\t || ((options & FNAME_HYP) && path_is_url(ptr + len))\n\t\t\t || (is_url && vim_strchr((char_u *)\":?&=\", ptr[len]) != NULL))\n    {\n\t// After type:// we also include :, ?, & and = as valid characters, so that\n\t// http://google.com:8080?q=this&that=ok works.\n\tif ((ptr[len] >= 'A' && ptr[len] <= 'Z') || (ptr[len] >= 'a' && ptr[len] <= 'z'))\n\t{\n\t    if (in_type && path_is_url(ptr + len + 1))\n\t\tis_url = TRUE;\n\t}\n\telse\n\t    in_type = FALSE;\n\n\tif (ptr[len] == '\\\\')\n\t    // Skip over the \"\\\" in \"\\ \".\n\t    ++len;\n\tif (has_mbyte)\n\t    len += (*mb_ptr2len)(ptr + len);\n\telse\n\t    ++len;\n    }\n\n    /*\n     * If there is trailing punctuation, remove it.\n     * But don't remove \"..\", could be a directory name.\n     */\n    if (len > 2 && vim_strchr((char_u *)\".,:;!\", ptr[len - 1]) != NULL\n\t\t\t\t\t\t       && ptr[len - 2] != '.')\n\t--len;\n\n    if (file_lnum != NULL)\n    {\n\tchar_u *p;\n\tchar\t*line_english = \" line \";\n\tchar\t*line_transl = _(line_msg);\n\n\t// Get the number after the file name and a separator character.\n\t// Also accept \" line 999\" with and without the same translation as\n\t// used in last_set_msg().\n\tp = ptr + len;\n\tif (STRNCMP(p, line_english, STRLEN(line_english)) == 0)\n\t    p += STRLEN(line_english);\n\telse if (STRNCMP(p, line_transl, STRLEN(line_transl)) == 0)\n\t    p += STRLEN(line_transl);\n\telse\n\t    p = skipwhite(p);\n\tif (*p != NUL)\n\t{\n\t    if (!isdigit(*p))\n\t\t++p;\t\t    // skip the separator\n\t    p = skipwhite(p);\n\t    if (isdigit(*p))\n\t\t*file_lnum = (int)getdigits(&p);\n\t}\n    }\n\n    return find_file_name_in_path(ptr, len, options, count, rel_fname);\n}\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    static char_u *\neval_includeexpr(char_u *ptr, int len)\n{\n    char_u\t*res;\n\n    set_vim_var_string(VV_FNAME, ptr, len);\n    res = eval_to_string_safe(curbuf->b_p_inex,\n\t\t      was_set_insecurely((char_u *)\"includeexpr\", OPT_LOCAL));\n    set_vim_var_string(VV_FNAME, NULL, 0);\n    return res;\n}\n# endif\n\n/*\n * Return the name of the file ptr[len] in 'path'.\n * Otherwise like file_name_at_cursor().\n */\n    char_u *\nfind_file_name_in_path(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\toptions,\n    long\tcount,\n    char_u\t*rel_fname)\t// file we are searching relative to\n{\n    char_u\t*file_name;\n    int\t\tc;\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    char_u\t*tofree = NULL;\n\n    if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n    {\n\ttofree = eval_includeexpr(ptr, len);\n\tif (tofree != NULL)\n\t{\n\t    ptr = tofree;\n\t    len = (int)STRLEN(ptr);\n\t}\n    }\n# endif\n\n    if (options & FNAME_EXP)\n    {\n\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n\t/*\n\t * If the file could not be found in a normal way, try applying\n\t * 'includeexpr' (unless done already).\n\t */\n\tif (file_name == NULL\n\t\t&& !(options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n\t{\n\t    tofree = eval_includeexpr(ptr, len);\n\t    if (tofree != NULL)\n\t    {\n\t\tptr = tofree;\n\t\tlen = (int)STRLEN(ptr);\n\t\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\t    }\n\t}\n# endif\n\tif (file_name == NULL && (options & FNAME_MESS))\n\t{\n\t    c = ptr[len];\n\t    ptr[len] = NUL;\n\t    semsg(_(\"E447: Can't find file \\\"%s\\\" in path\"), ptr);\n\t    ptr[len] = c;\n\t}\n\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\twhile (file_name != NULL && --count > 0)\n\t{\n\t    vim_free(file_name);\n\t    file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);\n\t}\n    }\n    else\n\tfile_name = vim_strnsave(ptr, len);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    vim_free(tofree);\n# endif\n\n    return file_name;\n}\n\n/*\n * Return the end of the directory name, on the first path\n * separator:\n * \"/path/file\", \"/path/dir/\", \"/path//dir\", \"/file\"\n *\t ^\t       ^\t     ^\t      ^\n */\n    static char_u *\ngettail_dir(char_u *fname)\n{\n    char_u\t*dir_end = fname;\n    char_u\t*next_dir_end = fname;\n    int\t\tlook_for_sep = TRUE;\n    char_u\t*p;\n\n    for (p = fname; *p != NUL; )\n    {\n\tif (vim_ispathsep(*p))\n\t{\n\t    if (look_for_sep)\n\t    {\n\t\tnext_dir_end = p;\n\t\tlook_for_sep = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    if (!look_for_sep)\n\t\tdir_end = next_dir_end;\n\t    look_for_sep = TRUE;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return dir_end;\n}\n\n/*\n * return TRUE if 'c' is a path list separator.\n */\n    int\nvim_ispathlistsep(int c)\n{\n# ifdef UNIX\n    return (c == ':');\n# else\n    return (c == ';');\t// might not be right for every system...\n# endif\n}\n\n/*\n * Moves \"*psep\" back to the previous path separator in \"path\".\n * Returns FAIL is \"*psep\" ends up at the beginning of \"path\".\n */\n    static int\nfind_previous_pathsep(char_u *path, char_u **psep)\n{\n    // skip the current separator\n    if (*psep > path && vim_ispathsep(**psep))\n\t--*psep;\n\n    // find the previous separator\n    while (*psep > path)\n    {\n\tif (vim_ispathsep(**psep))\n\t    return OK;\n\tMB_PTR_BACK(path, *psep);\n    }\n\n    return FAIL;\n}\n\n/*\n * Returns TRUE if \"maybe_unique\" is unique wrt other_paths in \"gap\".\n * \"maybe_unique\" is the end portion of \"((char_u **)gap->ga_data)[i]\".\n */\n    static int\nis_unique(char_u *maybe_unique, garray_T *gap, int i)\n{\n    int\t    j;\n    int\t    candidate_len;\n    int\t    other_path_len;\n    char_u  **other_paths = (char_u **)gap->ga_data;\n    char_u  *rival;\n\n    for (j = 0; j < gap->ga_len; j++)\n    {\n\tif (j == i)\n\t    continue;  // don't compare it with itself\n\n\tcandidate_len = (int)STRLEN(maybe_unique);\n\tother_path_len = (int)STRLEN(other_paths[j]);\n\tif (other_path_len < candidate_len)\n\t    continue;  // it's different when it's shorter\n\n\trival = other_paths[j] + other_path_len - candidate_len;\n\tif (fnamecmp(maybe_unique, rival) == 0\n\t\t&& (rival == other_paths[j] || vim_ispathsep(*(rival - 1))))\n\t    return FALSE;  // match\n    }\n\n    return TRUE;  // no match found\n}\n\n/*\n * Split the 'path' option into an array of strings in garray_T.  Relative\n * paths are expanded to their equivalent fullpath.  This includes the \".\"\n * (relative to current buffer directory) and empty path (relative to current\n * directory) notations.\n *\n * TODO: handle upward search (;) and path limiter (**N) notations by\n * expanding each into their equivalent path(s).\n */\n    static void\nexpand_path_option(char_u *curdir, garray_T *gap)\n{\n    char_u\t*path_option = *curbuf->b_p_path == NUL\n\t\t\t\t\t\t  ? p_path : curbuf->b_p_path;\n    char_u\t*buf;\n    char_u\t*p;\n    int\t\tlen;\n\n    if ((buf = alloc(MAXPATHL)) == NULL)\n\treturn;\n\n    while (*path_option != NUL)\n    {\n\tcopy_option_part(&path_option, buf, MAXPATHL, \" ,\");\n\n\tif (buf[0] == '.' && (buf[1] == NUL || vim_ispathsep(buf[1])))\n\t{\n\t    // Relative to current buffer:\n\t    // \"/path/file\" + \".\" -> \"/path/\"\n\t    // \"/path/file\"  + \"./subdir\" -> \"/path/subdir\"\n\t    if (curbuf->b_ffname == NULL)\n\t\tcontinue;\n\t    p = gettail(curbuf->b_ffname);\n\t    len = (int)(p - curbuf->b_ffname);\n\t    if (len + (int)STRLEN(buf) >= MAXPATHL)\n\t\tcontinue;\n\t    if (buf[1] == NUL)\n\t\tbuf[len] = NUL;\n\t    else\n\t\tSTRMOVE(buf + len, buf + 2);\n\t    mch_memmove(buf, curbuf->b_ffname, len);\n\t    simplify_filename(buf);\n\t}\n\telse if (buf[0] == NUL)\n\t    // relative to current directory\n\t    STRCPY(buf, curdir);\n\telse if (path_with_url(buf))\n\t    // URL can't be used here\n\t    continue;\n\telse if (!mch_isFullName(buf))\n\t{\n\t    // Expand relative path to their full path equivalent\n\t    len = (int)STRLEN(curdir);\n\t    if (len + (int)STRLEN(buf) + 3 > MAXPATHL)\n\t\tcontinue;\n\t    STRMOVE(buf + len + 1, buf);\n\t    STRCPY(buf, curdir);\n\t    buf[len] = PATHSEP;\n\t    simplify_filename(buf);\n\t}\n\n\tif (ga_grow(gap, 1) == FAIL)\n\t    break;\n\n# if defined(MSWIN)\n\t// Avoid the path ending in a backslash, it fails when a comma is\n\t// appended.\n\tlen = (int)STRLEN(buf);\n\tif (buf[len - 1] == '\\\\')\n\t    buf[len - 1] = '/';\n# endif\n\n\tp = vim_strsave(buf);\n\tif (p == NULL)\n\t    break;\n\t((char_u **)gap->ga_data)[gap->ga_len++] = p;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Returns a pointer to the file or directory name in \"fname\" that matches the\n * longest path in \"ga\"p, or NULL if there is no match. For example:\n *\n *    path: /foo/bar/baz\n *   fname: /foo/bar/baz/quux.txt\n * returns:\t\t ^this\n */\n    static char_u *\nget_path_cutoff(char_u *fname, garray_T *gap)\n{\n    int\t    i;\n    int\t    maxlen = 0;\n    char_u  **path_part = (char_u **)gap->ga_data;\n    char_u  *cutoff = NULL;\n\n    for (i = 0; i < gap->ga_len; i++)\n    {\n\tint j = 0;\n\n\twhile ((fname[j] == path_part[i][j]\n# if defined(MSWIN)\n\t\t|| (vim_ispathsep(fname[j]) && vim_ispathsep(path_part[i][j]))\n# endif\n\t\t\t     ) && fname[j] != NUL && path_part[i][j] != NUL)\n\t    j++;\n\tif (j > maxlen)\n\t{\n\t    maxlen = j;\n\t    cutoff = &fname[j];\n\t}\n    }\n\n    // skip to the file or directory name\n    if (cutoff != NULL)\n\twhile (vim_ispathsep(*cutoff))\n\t    MB_PTR_ADV(cutoff);\n\n    return cutoff;\n}\n\n/*\n * Sorts, removes duplicates and modifies all the fullpath names in \"gap\" so\n * that they are unique with respect to each other while conserving the part\n * that matches the pattern. Beware, this is at least O(n^2) wrt \"gap->ga_len\".\n */\n    void\nuniquefy_paths(garray_T *gap, char_u *pattern)\n{\n    int\t\ti;\n    int\t\tlen;\n    char_u\t**fnames = (char_u **)gap->ga_data;\n    int\t\tsort_again = FALSE;\n    char_u\t*pat;\n    char_u      *file_pattern;\n    char_u\t*curdir;\n    regmatch_T\tregmatch;\n    garray_T\tpath_ga;\n    char_u\t**in_curdir = NULL;\n    char_u\t*short_name;\n\n    remove_duplicates(gap);\n    ga_init2(&path_ga, (int)sizeof(char_u *), 1);\n\n    /*\n     * We need to prepend a '*' at the beginning of file_pattern so that the\n     * regex matches anywhere in the path. FIXME: is this valid for all\n     * possible patterns?\n     */\n    len = (int)STRLEN(pattern);\n    file_pattern = alloc(len + 2);\n    if (file_pattern == NULL)\n\treturn;\n    file_pattern[0] = '*';\n    file_pattern[1] = NUL;\n    STRCAT(file_pattern, pattern);\n    pat = file_pat_to_reg_pat(file_pattern, NULL, NULL, TRUE);\n    vim_free(file_pattern);\n    if (pat == NULL)\n\treturn;\n\n    regmatch.rm_ic = TRUE;\t\t// always ignore case\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    vim_free(pat);\n    if (regmatch.regprog == NULL)\n\treturn;\n\n    if ((curdir = alloc(MAXPATHL)) == NULL)\n\tgoto theend;\n    mch_dirname(curdir, MAXPATHL);\n    expand_path_option(curdir, &path_ga);\n\n    in_curdir = ALLOC_CLEAR_MULT(char_u *, gap->ga_len);\n    if (in_curdir == NULL)\n\tgoto theend;\n\n    for (i = 0; i < gap->ga_len && !got_int; i++)\n    {\n\tchar_u\t    *path = fnames[i];\n\tint\t    is_in_curdir;\n\tchar_u\t    *dir_end = gettail_dir(path);\n\tchar_u\t    *pathsep_p;\n\tchar_u\t    *path_cutoff;\n\n\tlen = (int)STRLEN(path);\n\tis_in_curdir = fnamencmp(curdir, path, dir_end - path) == 0\n\t\t\t\t\t     && curdir[dir_end - path] == NUL;\n\tif (is_in_curdir)\n\t    in_curdir[i] = vim_strsave(path);\n\n\t// Shorten the filename while maintaining its uniqueness\n\tpath_cutoff = get_path_cutoff(path, &path_ga);\n\n\t// Don't assume all files can be reached without path when search\n\t// pattern starts with star star slash, so only remove path_cutoff\n\t// when possible.\n\tif (pattern[0] == '*' && pattern[1] == '*'\n\t\t&& vim_ispathsep_nocolon(pattern[2])\n\t\t&& path_cutoff != NULL\n\t\t&& vim_regexec(&regmatch, path_cutoff, (colnr_T)0)\n\t\t&& is_unique(path_cutoff, gap, i))\n\t{\n\t    sort_again = TRUE;\n\t    mch_memmove(path, path_cutoff, STRLEN(path_cutoff) + 1);\n\t}\n\telse\n\t{\n\t    // Here all files can be reached without path, so get shortest\n\t    // unique path.  We start at the end of the path.\n\t    pathsep_p = path + len - 1;\n\n\t    while (find_previous_pathsep(path, &pathsep_p))\n\t\tif (vim_regexec(&regmatch, pathsep_p + 1, (colnr_T)0)\n\t\t\t&& is_unique(pathsep_p + 1, gap, i)\n\t\t\t&& path_cutoff != NULL && pathsep_p + 1 >= path_cutoff)\n\t\t{\n\t\t    sort_again = TRUE;\n\t\t    mch_memmove(path, pathsep_p + 1, STRLEN(pathsep_p));\n\t\t    break;\n\t\t}\n\t}\n\n\tif (mch_isFullName(path))\n\t{\n\t    /*\n\t     * Last resort: shorten relative to curdir if possible.\n\t     * 'possible' means:\n\t     * 1. It is under the current directory.\n\t     * 2. The result is actually shorter than the original.\n\t     *\n\t     *\t    Before\t\t  curdir\tAfter\n\t     *\t    /foo/bar/file.txt\t  /foo/bar\t./file.txt\n\t     *\t    c:\\foo\\bar\\file.txt   c:\\foo\\bar\t.\\file.txt\n\t     *\t    /file.txt\t\t  /\t\t/file.txt\n\t     *\t    c:\\file.txt\t\t  c:\\\t\t.\\file.txt\n\t     */\n\t    short_name = shorten_fname(path, curdir);\n\t    if (short_name != NULL && short_name > path + 1\n# if defined(MSWIN)\n\t\t    // On windows,\n\t\t    //\t    shorten_fname(\"c:\\a\\a.txt\", \"c:\\a\\b\")\n\t\t    // returns \"\\a\\a.txt\", which is not really the short\n\t\t    // name, hence:\n\t\t    && !vim_ispathsep(*short_name)\n# endif\n\t\t)\n\t    {\n\t\tSTRCPY(path, \".\");\n\t\tadd_pathsep(path);\n\t\tSTRMOVE(path + STRLEN(path), short_name);\n\t    }\n\t}\n\tui_breakcheck();\n    }\n\n    // Shorten filenames in /in/current/directory/{filename}\n    for (i = 0; i < gap->ga_len && !got_int; i++)\n    {\n\tchar_u *rel_path;\n\tchar_u *path = in_curdir[i];\n\n\tif (path == NULL)\n\t    continue;\n\n\t// If the {filename} is not unique, change it to ./{filename}.\n\t// Else reduce it to {filename}\n\tshort_name = shorten_fname(path, curdir);\n\tif (short_name == NULL)\n\t    short_name = path;\n\tif (is_unique(short_name, gap, i))\n\t{\n\t    STRCPY(fnames[i], short_name);\n\t    continue;\n\t}\n\n\trel_path = alloc(STRLEN(short_name) + STRLEN(PATHSEPSTR) + 2);\n\tif (rel_path == NULL)\n\t    goto theend;\n\tSTRCPY(rel_path, \".\");\n\tadd_pathsep(rel_path);\n\tSTRCAT(rel_path, short_name);\n\n\tvim_free(fnames[i]);\n\tfnames[i] = rel_path;\n\tsort_again = TRUE;\n\tui_breakcheck();\n    }\n\ntheend:\n    vim_free(curdir);\n    if (in_curdir != NULL)\n    {\n\tfor (i = 0; i < gap->ga_len; i++)\n\t    vim_free(in_curdir[i]);\n\tvim_free(in_curdir);\n    }\n    ga_clear_strings(&path_ga);\n    vim_regfree(regmatch.regprog);\n\n    if (sort_again)\n\tremove_duplicates(gap);\n}\n\n/*\n * Calls globpath() with 'path' values for the given pattern and stores the\n * result in \"gap\".\n * Returns the total number of matches.\n */\n    int\nexpand_in_path(\n    garray_T\t*gap,\n    char_u\t*pattern,\n    int\t\tflags)\t\t// EW_* flags\n{\n    char_u\t*curdir;\n    garray_T\tpath_ga;\n    char_u\t*paths = NULL;\n    int\t\tglob_flags = 0;\n\n    if ((curdir = alloc(MAXPATHL)) == NULL)\n\treturn 0;\n    mch_dirname(curdir, MAXPATHL);\n\n    ga_init2(&path_ga, (int)sizeof(char_u *), 1);\n    expand_path_option(curdir, &path_ga);\n    vim_free(curdir);\n    if (path_ga.ga_len == 0)\n\treturn 0;\n\n    paths = ga_concat_strings(&path_ga, \",\");\n    ga_clear_strings(&path_ga);\n    if (paths == NULL)\n\treturn 0;\n\n    if (flags & EW_ICASE)\n\tglob_flags |= WILD_ICASE;\n    if (flags & EW_ADDSLASH)\n\tglob_flags |= WILD_ADD_SLASH;\n    globpath(paths, pattern, gap, glob_flags);\n    vim_free(paths);\n\n    return gap->ga_len;\n}\n\n#endif // FEAT_SEARCHPATH\n\n/*\n * Converts a file name into a canonical form. It simplifies a file name into\n * its simplest form by stripping out unneeded components, if any.  The\n * resulting file name is simplified in place and will either be the same\n * length as that supplied, or shorter.\n */\n    void\nsimplify_filename(char_u *filename)\n{\n#ifndef AMIGA\t    // Amiga doesn't have \"..\", it uses \"/\"\n    int\t\tcomponents = 0;\n    char_u\t*p, *tail, *start;\n    int\t\tstripping_disabled = FALSE;\n    int\t\trelative = TRUE;\n\n    p = filename;\n# ifdef BACKSLASH_IN_FILENAME\n    if (p[1] == ':')\t    // skip \"x:\"\n\tp += 2;\n# endif\n\n    if (vim_ispathsep(*p))\n    {\n\trelative = FALSE;\n\tdo\n\t    ++p;\n\twhile (vim_ispathsep(*p));\n    }\n    start = p;\t    // remember start after \"c:/\" or \"/\" or \"///\"\n#ifdef UNIX\n    // Posix says that \"//path\" is unchanged but \"///path\" is \"/path\".\n    if (start > filename + 2)\n    {\n\tSTRMOVE(filename + 1, p);\n\tstart = p = filename + 1;\n    }\n#endif\n\n    do\n    {\n\t// At this point \"p\" is pointing to the char following a single \"/\"\n\t// or \"p\" is at the \"start\" of the (absolute or relative) path name.\n# ifdef VMS\n\t// VMS allows device:[path] - don't strip the [ in directory\n\tif ((*p == '[' || *p == '<') && p > filename && p[-1] == ':')\n\t{\n\t    // :[ or :< composition: vms directory component\n\t    ++components;\n\t    p = getnextcomp(p + 1);\n\t}\n\t// allow remote calls as host\"user passwd\"::device:[path]\n\telse if (p[0] == ':' && p[1] == ':' && p > filename && p[-1] == '\"' )\n\t{\n\t    // \":: composition: vms host/passwd component\n\t    ++components;\n\t    p = getnextcomp(p + 2);\n\t}\n\telse\n# endif\n\t  if (vim_ispathsep(*p))\n\t    STRMOVE(p, p + 1);\t\t// remove duplicate \"/\"\n\telse if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL))\n\t{\n\t    if (p == start && relative)\n\t\tp += 1 + (p[1] != NUL);\t// keep single \".\" or leading \"./\"\n\t    else\n\t    {\n\t\t// Strip \"./\" or \".///\".  If we are at the end of the file name\n\t\t// and there is no trailing path separator, either strip \"/.\" if\n\t\t// we are after \"start\", or strip \".\" if we are at the beginning\n\t\t// of an absolute path name .\n\t\ttail = p + 1;\n\t\tif (p[1] != NUL)\n\t\t    while (vim_ispathsep(*tail))\n\t\t\tMB_PTR_ADV(tail);\n\t\telse if (p > start)\n\t\t    --p;\t\t// strip preceding path separator\n\t\tSTRMOVE(p, tail);\n\t    }\n\t}\n\telse if (p[0] == '.' && p[1] == '.' &&\n\t    (vim_ispathsep(p[2]) || p[2] == NUL))\n\t{\n\t    // Skip to after \"..\" or \"../\" or \"..///\".\n\t    tail = p + 2;\n\t    while (vim_ispathsep(*tail))\n\t\tMB_PTR_ADV(tail);\n\n\t    if (components > 0)\t\t// strip one preceding component\n\t    {\n\t\tint\t\tdo_strip = FALSE;\n\t\tchar_u\t\tsaved_char;\n\t\tstat_T\t\tst;\n\n\t\t// Don't strip for an erroneous file name.\n\t\tif (!stripping_disabled)\n\t\t{\n\t\t    // If the preceding component does not exist in the file\n\t\t    // system, we strip it.  On Unix, we don't accept a symbolic\n\t\t    // link that refers to a non-existent file.\n\t\t    saved_char = p[-1];\n\t\t    p[-1] = NUL;\n# ifdef UNIX\n\t\t    if (mch_lstat((char *)filename, &st) < 0)\n# else\n\t\t\tif (mch_stat((char *)filename, &st) < 0)\n# endif\n\t\t\t    do_strip = TRUE;\n\t\t    p[-1] = saved_char;\n\n\t\t    --p;\n\t\t    // Skip back to after previous '/'.\n\t\t    while (p > start && !after_pathsep(start, p))\n\t\t\tMB_PTR_BACK(start, p);\n\n\t\t    if (!do_strip)\n\t\t    {\n\t\t\t// If the component exists in the file system, check\n\t\t\t// that stripping it won't change the meaning of the\n\t\t\t// file name.  First get information about the\n\t\t\t// unstripped file name.  This may fail if the component\n\t\t\t// to strip is not a searchable directory (but a regular\n\t\t\t// file, for instance), since the trailing \"/..\" cannot\n\t\t\t// be applied then.  We don't strip it then since we\n\t\t\t// don't want to replace an erroneous file name by\n\t\t\t// a valid one, and we disable stripping of later\n\t\t\t// components.\n\t\t\tsaved_char = *tail;\n\t\t\t*tail = NUL;\n\t\t\tif (mch_stat((char *)filename, &st) >= 0)\n\t\t\t    do_strip = TRUE;\n\t\t\telse\n\t\t\t    stripping_disabled = TRUE;\n\t\t\t*tail = saved_char;\n# ifdef UNIX\n\t\t\tif (do_strip)\n\t\t\t{\n\t\t\t    stat_T\tnew_st;\n\n\t\t\t    // On Unix, the check for the unstripped file name\n\t\t\t    // above works also for a symbolic link pointing to\n\t\t\t    // a searchable directory.  But then the parent of\n\t\t\t    // the directory pointed to by the link must be the\n\t\t\t    // same as the stripped file name.  (The latter\n\t\t\t    // exists in the file system since it is the\n\t\t\t    // component's parent directory.)\n\t\t\t    if (p == start && relative)\n\t\t\t\t(void)mch_stat(\".\", &new_st);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tsaved_char = *p;\n\t\t\t\t*p = NUL;\n\t\t\t\t(void)mch_stat((char *)filename, &new_st);\n\t\t\t\t*p = saved_char;\n\t\t\t    }\n\n\t\t\t    if (new_st.st_ino != st.st_ino ||\n\t\t\t\tnew_st.st_dev != st.st_dev)\n\t\t\t    {\n\t\t\t\tdo_strip = FALSE;\n\t\t\t\t// We don't disable stripping of later\n\t\t\t\t// components since the unstripped path name is\n\t\t\t\t// still valid.\n\t\t\t    }\n\t\t\t}\n# endif\n\t\t    }\n\t\t}\n\n\t\tif (!do_strip)\n\t\t{\n\t\t    // Skip the \"..\" or \"../\" and reset the counter for the\n\t\t    // components that might be stripped later on.\n\t\t    p = tail;\n\t\t    components = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Strip previous component.  If the result would get empty\n\t\t    // and there is no trailing path separator, leave a single\n\t\t    // \".\" instead.  If we are at the end of the file name and\n\t\t    // there is no trailing path separator and a preceding\n\t\t    // component is left after stripping, strip its trailing\n\t\t    // path separator as well.\n\t\t    if (p == start && relative && tail[-1] == '.')\n\t\t    {\n\t\t\t*p++ = '.';\n\t\t\t*p = NUL;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (p > start && tail[-1] == '.')\n\t\t\t    --p;\n\t\t\tSTRMOVE(p, tail);\t// strip previous component\n\t\t    }\n\n\t\t    --components;\n\t\t}\n\t    }\n\t    else if (p == start && !relative)\t// leading \"/..\" or \"/../\"\n\t\tSTRMOVE(p, tail);\t\t// strip \"..\" or \"../\"\n\t    else\n\t    {\n\t\tif (p == start + 2 && p[-2] == '.')\t// leading \"./../\"\n\t\t{\n\t\t    STRMOVE(p - 2, p);\t\t\t// strip leading \"./\"\n\t\t    tail -= 2;\n\t\t}\n\t\tp = tail;\t\t// skip to char after \"..\" or \"../\"\n\t    }\n\t}\n\telse\n\t{\n\t    ++components;\t\t// simple path component\n\t    p = getnextcomp(p);\n\t}\n    } while (*p != NUL);\n#endif // !AMIGA\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"simplify()\" function\n */\n    void\nf_simplify(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    p = tv_get_string_strict(&argvars[0]);\n    rettv->vval.v_string = vim_strsave(p);\n    simplify_filename(rettv->vval.v_string);\t// simplify in place\n    rettv->v_type = VAR_STRING;\n}\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic int\tnv_compare(const void *s1, const void *s2);\nstatic void\tunshift_special(cmdarg_T *cap);\n#ifdef FEAT_CMDL_INFO\nstatic void\tdel_from_showcmd(int);\n#endif\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\n#ifdef FEAT_TEXTOBJ\nstatic void\tnv_object(cmdarg_T *cap);\n#endif\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\nstatic char *e_noident = N_(\"E349: No identifier under cursor\");\n\n/*\n * Function to be called for a Normal or Visual mode command.\n * The argument is a cmdarg_T.\n */\ntypedef void (*nv_func_T)(cmdarg_T *cap);\n\n// Values for cmd_flags.\n#define NV_NCH\t    0x01\t  // may need to get a second char\n#define NV_NCH_NOP  (0x02|NV_NCH) // get second char when no operator pending\n#define NV_NCH_ALW  (0x04|NV_NCH) // always get a second char\n#define NV_LANG\t    0x08\t// second char needs language adjustment\n\n#define NV_SS\t    0x10\t// may start selection\n#define NV_SSS\t    0x20\t// may start selection with shift modifier\n#define NV_STS\t    0x40\t// may stop selection without shift modif.\n#define NV_RL\t    0x80\t// 'rightleft' modifies command\n#define NV_KEEPREG  0x100\t// don't clear regname\n#define NV_NCW\t    0x200\t// not allowed in command-line window\n\n/*\n * Generally speaking, every Normal mode command should either clear any\n * pending operator (with *clearop*()), or set the motion type variable\n * oap->motion_type.\n *\n * When a cursor motion command is made, it is marked as being a character or\n * line oriented motion.  Then, if an operator is in effect, the operation\n * becomes character or line oriented accordingly.\n */\n\n/*\n * This table contains one entry for every Normal or Visual mode command.\n * The order doesn't matter, init_normal_cmds() will create a sorted index.\n * It is faster when all keys from zero to '~' are present.\n */\nstatic const struct nv_cmd\n{\n    int\t\tcmd_char;\t// (first) command character\n    nv_func_T   cmd_func;\t// function for this command\n    short_u\tcmd_flags;\t// NV_ flags\n    short\tcmd_arg;\t// value for ca.arg\n} nv_cmds[] =\n{\n    {NUL,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_A,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_B,\tnv_page,\tNV_STS,\t\t\tBACKWARD},\n    {Ctrl_C,\tnv_esc,\t\t0,\t\t\tTRUE},\n    {Ctrl_D,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_E,\tnv_scroll_line,\t0,\t\t\tTRUE},\n    {Ctrl_F,\tnv_page,\tNV_STS,\t\t\tFORWARD},\n    {Ctrl_G,\tnv_ctrlg,\t0,\t\t\t0},\n    {Ctrl_H,\tnv_ctrlh,\t0,\t\t\t0},\n    {Ctrl_I,\tnv_pcmark,\t0,\t\t\t0},\n    {NL,\tnv_down,\t0,\t\t\tFALSE},\n    {Ctrl_K,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_L,\tnv_clear,\t0,\t\t\t0},\n    {CAR,\tnv_down,\t0,\t\t\tTRUE},\n    {Ctrl_N,\tnv_down,\tNV_STS,\t\t\tFALSE},\n    {Ctrl_O,\tnv_ctrlo,\t0,\t\t\t0},\n    {Ctrl_P,\tnv_up,\t\tNV_STS,\t\t\tFALSE},\n    {Ctrl_Q,\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_R,\tnv_redo,\t0,\t\t\t0},\n    {Ctrl_S,\tnv_ignore,\t0,\t\t\t0},\n    {Ctrl_T,\tnv_tagpop,\tNV_NCW,\t\t\t0},\n    {Ctrl_U,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_V,\tnv_visual,\t0,\t\t\tFALSE},\n    {'V',\tnv_visual,\t0,\t\t\tFALSE},\n    {'v',\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_W,\tnv_window,\t0,\t\t\t0},\n    {Ctrl_X,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_Y,\tnv_scroll_line,\t0,\t\t\tFALSE},\n    {Ctrl_Z,\tnv_suspend,\t0,\t\t\t0},\n    {ESC,\tnv_esc,\t\t0,\t\t\tFALSE},\n    {Ctrl_BSL,\tnv_normal,\tNV_NCH_ALW,\t\t0},\n    {Ctrl_RSB,\tnv_ident,\tNV_NCW,\t\t\t0},\n    {Ctrl_HAT,\tnv_hat,\t\tNV_NCW,\t\t\t0},\n    {Ctrl__,\tnv_error,\t0,\t\t\t0},\n    {' ',\tnv_right,\t0,\t\t\t0},\n    {'!',\tnv_operator,\t0,\t\t\t0},\n    {'\"',\tnv_regname,\tNV_NCH_NOP|NV_KEEPREG,\t0},\n    {'#',\tnv_ident,\t0,\t\t\t0},\n    {'$',\tnv_dollar,\t0,\t\t\t0},\n    {'%',\tnv_percent,\t0,\t\t\t0},\n    {'&',\tnv_optrans,\t0,\t\t\t0},\n    {'\\'',\tnv_gomark,\tNV_NCH_ALW,\t\tTRUE},\n    {'(',\tnv_brace,\t0,\t\t\tBACKWARD},\n    {')',\tnv_brace,\t0,\t\t\tFORWARD},\n    {'*',\tnv_ident,\t0,\t\t\t0},\n    {'+',\tnv_down,\t0,\t\t\tTRUE},\n    {',',\tnv_csearch,\t0,\t\t\tTRUE},\n    {'-',\tnv_up,\t\t0,\t\t\tTRUE},\n    {'.',\tnv_dot,\t\tNV_KEEPREG,\t\t0},\n    {'/',\tnv_search,\t0,\t\t\tFALSE},\n    {'0',\tnv_beginline,\t0,\t\t\t0},\n    {'1',\tnv_ignore,\t0,\t\t\t0},\n    {'2',\tnv_ignore,\t0,\t\t\t0},\n    {'3',\tnv_ignore,\t0,\t\t\t0},\n    {'4',\tnv_ignore,\t0,\t\t\t0},\n    {'5',\tnv_ignore,\t0,\t\t\t0},\n    {'6',\tnv_ignore,\t0,\t\t\t0},\n    {'7',\tnv_ignore,\t0,\t\t\t0},\n    {'8',\tnv_ignore,\t0,\t\t\t0},\n    {'9',\tnv_ignore,\t0,\t\t\t0},\n    {':',\tnv_colon,\t0,\t\t\t0},\n    {';',\tnv_csearch,\t0,\t\t\tFALSE},\n    {'<',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'=',\tnv_operator,\t0,\t\t\t0},\n    {'>',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'?',\tnv_search,\t0,\t\t\tFALSE},\n    {'@',\tnv_at,\t\tNV_NCH_NOP,\t\tFALSE},\n    {'A',\tnv_edit,\t0,\t\t\t0},\n    {'B',\tnv_bck_word,\t0,\t\t\t1},\n    {'C',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'D',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'E',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'F',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'G',\tnv_goto,\t0,\t\t\tTRUE},\n    {'H',\tnv_scroll,\t0,\t\t\t0},\n    {'I',\tnv_edit,\t0,\t\t\t0},\n    {'J',\tnv_join,\t0,\t\t\t0},\n    {'K',\tnv_ident,\t0,\t\t\t0},\n    {'L',\tnv_scroll,\t0,\t\t\t0},\n    {'M',\tnv_scroll,\t0,\t\t\t0},\n    {'N',\tnv_next,\t0,\t\t\tSEARCH_REV},\n    {'O',\tnv_open,\t0,\t\t\t0},\n    {'P',\tnv_put,\t\t0,\t\t\t0},\n    {'Q',\tnv_exmode,\tNV_NCW,\t\t\t0},\n    {'R',\tnv_Replace,\t0,\t\t\tFALSE},\n    {'S',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'T',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'U',\tnv_Undo,\t0,\t\t\t0},\n    {'W',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'X',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Y',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Z',\tnv_Zet,\t\tNV_NCH_NOP|NV_NCW,\t0},\n    {'[',\tnv_brackets,\tNV_NCH_ALW,\t\tBACKWARD},\n    {'\\\\',\tnv_error,\t0,\t\t\t0},\n    {']',\tnv_brackets,\tNV_NCH_ALW,\t\tFORWARD},\n    {'^',\tnv_beginline,\t0,\t\t\tBL_WHITE | BL_FIX},\n    {'_',\tnv_lineop,\t0,\t\t\t0},\n    {'`',\tnv_gomark,\tNV_NCH_ALW,\t\tFALSE},\n    {'a',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'b',\tnv_bck_word,\t0,\t\t\t0},\n    {'c',\tnv_operator,\t0,\t\t\t0},\n    {'d',\tnv_operator,\t0,\t\t\t0},\n    {'e',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'f',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'g',\tnv_g_cmd,\tNV_NCH_ALW,\t\tFALSE},\n    {'h',\tnv_left,\tNV_RL,\t\t\t0},\n    {'i',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'j',\tnv_down,\t0,\t\t\tFALSE},\n    {'k',\tnv_up,\t\t0,\t\t\tFALSE},\n    {'l',\tnv_right,\tNV_RL,\t\t\t0},\n    {'m',\tnv_mark,\tNV_NCH_NOP,\t\t0},\n    {'n',\tnv_next,\t0,\t\t\t0},\n    {'o',\tnv_open,\t0,\t\t\t0},\n    {'p',\tnv_put,\t\t0,\t\t\t0},\n    {'q',\tnv_record,\tNV_NCH,\t\t\t0},\n    {'r',\tnv_replace,\tNV_NCH_NOP|NV_LANG,\t0},\n    {'s',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'t',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'u',\tnv_undo,\t0,\t\t\t0},\n    {'w',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'x',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'y',\tnv_operator,\t0,\t\t\t0},\n    {'z',\tnv_zet,\t\tNV_NCH_ALW,\t\t0},\n    {'{',\tnv_findpar,\t0,\t\t\tBACKWARD},\n    {'|',\tnv_pipe,\t0,\t\t\t0},\n    {'}',\tnv_findpar,\t0,\t\t\tFORWARD},\n    {'~',\tnv_tilde,\t0,\t\t\t0},\n\n    // pound sign\n    {POUND,\tnv_ident,\t0,\t\t\t0},\n    {K_MOUSEUP, nv_mousescroll,\t0,\t\t\tMSCR_UP},\n    {K_MOUSEDOWN, nv_mousescroll, 0,\t\t\tMSCR_DOWN},\n    {K_MOUSELEFT, nv_mousescroll, 0,\t\t\tMSCR_LEFT},\n    {K_MOUSERIGHT, nv_mousescroll, 0,\t\t\tMSCR_RIGHT},\n    {K_LEFTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTMOUSE_NM, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE_NM, nv_mouse, 0,\t\t\t0},\n    {K_MOUSEMOVE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLERELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X1MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X1DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X1RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X2MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X2DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X2RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_IGNORE,\tnv_ignore,\tNV_KEEPREG,\t\t0},\n    {K_NOP,\tnv_nop,\t\t0,\t\t\t0},\n    {K_INS,\tnv_edit,\t0,\t\t\t0},\n    {K_KINS,\tnv_edit,\t0,\t\t\t0},\n    {K_BS,\tnv_ctrlh,\t0,\t\t\t0},\n    {K_UP,\tnv_up,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_UP,\tnv_page,\tNV_SS,\t\t\tBACKWARD},\n    {K_DOWN,\tnv_down,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_DOWN,\tnv_page,\tNV_SS,\t\t\tFORWARD},\n    {K_LEFT,\tnv_left,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_LEFT,\tnv_bck_word,\tNV_SS|NV_RL,\t\t0},\n    {K_C_LEFT,\tnv_bck_word,\tNV_SSS|NV_RL|NV_STS,\t1},\n    {K_RIGHT,\tnv_right,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_RIGHT,\tnv_wordcmd,\tNV_SS|NV_RL,\t\tFALSE},\n    {K_C_RIGHT,\tnv_wordcmd,\tNV_SSS|NV_RL|NV_STS,\tTRUE},\n    {K_PAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_KPAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_PAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_KPAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_KEND,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_END,\tnv_end,\t\tNV_SS,\t\t\tFALSE},\n    {K_C_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tTRUE},\n    {K_HOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_KHOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_S_HOME,\tnv_home,\tNV_SS,\t\t\t0},\n    {K_C_HOME,\tnv_goto,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_DEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_KDEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_UNDO,\tnv_kundo,\t0,\t\t\t0},\n    {K_HELP,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_F1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_XF1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_SELECT,\tnv_select,\t0,\t\t\t0},\n#ifdef FEAT_GUI\n    {K_VER_SCROLLBAR, nv_ver_scrollbar, 0,\t\t0},\n    {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0,\t\t0},\n#endif\n#ifdef FEAT_GUI_TABLINE\n    {K_TABLINE, nv_tabline,\t0,\t\t\t0},\n    {K_TABMENU, nv_tabmenu,\t0,\t\t\t0},\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    {K_F21,\tnv_nbcmd,\tNV_NCH_ALW,\t\t0},\n#endif\n#ifdef FEAT_DND\n    {K_DROP,\tnv_drop,\tNV_STS,\t\t\t0},\n#endif\n    {K_CURSORHOLD, nv_cursorhold, NV_KEEPREG,\t\t0},\n    {K_PS,\tnv_edit,\t0,\t\t\t0},\n    {K_COMMAND,\tnv_colon,\t0,\t\t\t0},\n};\n\n// Number of commands in nv_cmds[].\n#define NV_CMDS_SIZE ARRAY_LENGTH(nv_cmds)\n\n// Sorted index of commands in nv_cmds[].\nstatic short nv_cmd_idx[NV_CMDS_SIZE];\n\n// The highest index for which\n// nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char]\nstatic int nv_max_linear;\n\n/*\n * Compare functions for qsort() below, that checks the command character\n * through the index in nv_cmd_idx[].\n */\n    static int\nnv_compare(const void *s1, const void *s2)\n{\n    int\t\tc1, c2;\n\n    // The commands are sorted on absolute value.\n    c1 = nv_cmds[*(const short *)s1].cmd_char;\n    c2 = nv_cmds[*(const short *)s2].cmd_char;\n    if (c1 < 0)\n\tc1 = -c1;\n    if (c2 < 0)\n\tc2 = -c2;\n    return c1 - c2;\n}\n\n/*\n * Initialize the nv_cmd_idx[] table.\n */\n    void\ninit_normal_cmds(void)\n{\n    int\t\ti;\n\n    // Fill the index table with a one to one relation.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tnv_cmd_idx[i] = i;\n\n    // Sort the commands by the command character.\n    qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);\n\n    // Find the first entry that can't be indexed by the command character.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tif (i != nv_cmds[nv_cmd_idx[i]].cmd_char)\n\t    break;\n    nv_max_linear = i - 1;\n}\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n#ifdef FEAT_CMDL_INFO\n    int\t\tneed_flushbuf;\t\t// need to call out_flush()\n#endif\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n#ifdef FEAT_EVAL\n    int\t\tset_prevcount = FALSE;\n#endif\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    /*\n     * If there is an operator pending, then the command we take this time\n     * will terminate it. Finish_op tells us to finish the operation before\n     * returning this time (unless the operation was cancelled).\n     */\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != SELECTMODE);\n\n    /*\n     * If a mapping was started in Visual or Select mode, remember the length\n     * of the mapping.  This is used below to not return to Insert mode for as\n     * long as the mapping is being executed.\n     */\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    /*\n     * In Select mode, typed text replaces the selection.\n     */\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n#ifdef FEAT_CMDL_INFO\n    need_flushbuf = add_to_showcmd(c);\n#endif\n\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t/*\n\t * Handle a count before a command and compute ca.count0.\n\t * Note that '0' is a command and not the start of a count, but it's\n\t * part of a count after other digits.\n\t */\n\twhile (    (c >= '1' && c <= '9')\n\t\t|| (ca.count0 != 0 && (c == K_DEL || c == K_KDEL || c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tca.count0 /= 10;\n#ifdef FEAT_CMDL_INFO\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n#endif\n\t    }\n\t    else\n\t\tca.count0 = ca.count0 * 10 + (c - '0');\n\t    if (ca.count0 < 0)\t    // overflow\n\t\tca.count0 = 999999999L;\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\t    if (ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t}\n\n\t/*\n\t * If we got CTRL-W there may be a/another count\n\t */\n\tif (c == Ctrl_W && !ctrl_w && oap->op_type == OP_NOP)\n\t{\n\t    ctrl_w = TRUE;\n\t    ca.opcount = ca.count0;\t// remember first count\n\t    ca.count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\toap->prev_opcount = ca.opcount;\n\toap->prev_count0 = ca.count0;\n    }\n    else if (ca.opcount != 0)\n    {\n\t/*\n\t * If we're in the middle of an operator (including after entering a\n\t * yank buffer with '\"') AND we had a count before the operator, then\n\t * that count overrides the current value of ca.count0.\n\t * What this means effectively, is that commands like \"3dw\" get turned\n\t * into \"d3w\" which makes things fall into place pretty neatly.\n\t * If you give a count before AND after the operator, they are\n\t * multiplied.\n\t */\n\tif (ca.count0)\n\t    ca.count0 *= ca.opcount;\n\telse\n\t    ca.count0 = ca.opcount;\n\tif (ca.count0 < 0)\t    // overflow\n\t    ca.count0 = 999999999L;\n    }\n\n    /*\n     * Always remember the count.  It will be set to zero (on the next call,\n     * above) when there is no pending operator.\n     * When called from main(), save the count for use by the \"count\" built-in\n     * variable.\n     */\n    ca.opcount = ca.count0;\n    ca.count1 = (ca.count0 == 0 ? 1 : ca.count0);\n\n#ifdef FEAT_EVAL\n    /*\n     * Only set v:count when called from main() and not a stuffed command.\n     * Do set it for redo.\n     */\n    if (toplevel && readbuf1_empty())\n\tset_vcount(ca.count0, ca.count1, set_prevcount);\n#endif\n\n    /*\n     * Find the command character in the table of commands.\n     * For CTRL-W we already got nchar when looking for a count.\n     */\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW))\n    {\n\t// This command is not allowed while editing a cmdline: beep.\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\tgoto normal_end;\n    }\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && curbuf_locked())\n\tgoto normal_end;\n\n    /*\n     * In Visual/Select mode, a few keys are handled in a special way.\n     */\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    /*\n     * Get an additional character if we need one.\n     */\n    if ((nv_cmds[idx].cmd_flags & NV_NCH)\n\t    && (((nv_cmds[idx].cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && oap->op_type == OP_NOP)\n\t\t|| (nv_cmds[idx].cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (ca.cmdchar == 'q'\n\t\t    && oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')\n\t\t    && (oap->op_type != OP_NOP || VIsual_active))))\n    {\n\tint\t*cp;\n\tint\trepl = FALSE;\t// get character for replace mode\n\tint\tlit = FALSE;\t// get extra character literally\n\tint\tlangmap_active = FALSE;    // using :lmap mappings\n\tint\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n\tint\tsave_smd;\t// saved value of p_smd\n#endif\n\n\t++no_mapping;\n\t++allow_keys;\t\t// no mapping for nchar, but allow key codes\n\t// Don't generate a CursorHold event here, most commands can't handle\n\t// it, e.g., nv_replace(), nv_csearch().\n\tdid_cursorhold = TRUE;\n\tif (ca.cmdchar == 'g')\n\t{\n\t    /*\n\t     * For 'g' get the next character now, so that we can check for\n\t     * \"gr\", \"g'\" and \"g`\".\n\t     */\n\t    ca.nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(ca.nchar, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(ca.nchar);\n#endif\n\t    if (ca.nchar == 'r' || ca.nchar == '\\'' || ca.nchar == '`'\n\t\t\t\t\t\t       || ca.nchar == Ctrl_BSL)\n\t    {\n\t\tcp = &ca.extra_char;\t// need to get a third character\n\t\tif (ca.nchar != 'r')\n\t\t    lit = TRUE;\t\t\t// get it literally\n\t\telse\n\t\t    repl = TRUE;\t\t// get it in replace mode\n\t    }\n\t    else\n\t\tcp = NULL;\t\t// no third character needed\n\t}\n\telse\n\t{\n\t    if (ca.cmdchar == 'r')\t\t// get it in replace mode\n\t\trepl = TRUE;\n\t    cp = &ca.nchar;\n\t}\n\tlang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n\t/*\n\t * Get a second or third character.\n\t */\n\tif (cp != NULL)\n\t{\n\t    if (repl)\n\t    {\n\t\tState = REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// show different cursor shape\n#endif\n\t    }\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t    {\n\t\t// Allow mappings defined with \":lmap\".\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\tif (repl)\n\t\t    State = LREPLACE;\n\t\telse\n\t\t    State = LANGMAP;\n\t\tlangmap_active = TRUE;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    save_smd = p_smd;\n\t    p_smd = FALSE;\t// Don't let the IM code show the mode here\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t\tim_set_active(TRUE);\n#endif\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Disable bracketed paste and modifyOtherKeys here, we won't\n\t\t// recognize the escape sequences with 'esckeys' off.\n\t\tout_str(T_BD);\n\t\tout_str(T_CTE);\n\t    }\n\n\t    *cp = plain_vgetc();\n\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Re-enable bracketed paste mode and modifyOtherKeys\n\t\tout_str(T_BE);\n\t\tout_str(T_CTI);\n\t    }\n\n\t    if (langmap_active)\n\t    {\n\t\t// Undo the decrement done above\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\tState = NORMAL_BUSY;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    if (lang)\n\t    {\n\t\tif (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\t    im_save_status(&curbuf->b_p_iminsert);\n\t\tim_set_active(FALSE);\n\t    }\n\t    p_smd = save_smd;\n#endif\n\t    State = NORMAL_BUSY;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(*cp);\n#endif\n\n\t    if (!lit)\n\t    {\n#ifdef FEAT_DIGRAPHS\n\t\t// Typing CTRL-K gets a digraph.\n\t\tif (*cp == Ctrl_K\n\t\t\t&& ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t    || cp == &ca.extra_char)\n\t\t\t&& vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t\t{\n\t\t    c = get_digraph(FALSE);\n\t\t    if (c > 0)\n\t\t    {\n\t\t\t*cp = c;\n# ifdef FEAT_CMDL_INFO\n\t\t\t// Guessing how to update showcmd here...\n\t\t\tdel_from_showcmd(3);\n\t\t\tneed_flushbuf |= add_to_showcmd(*cp);\n# endif\n\t\t    }\n\t\t}\n#endif\n\n\t\t// adjust chars > 127, except after \"tTfFr\" commands\n\t\tLANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t\t// adjust Hebrew mapped char\n\t\tif (p_hkmap && lang && KeyTyped)\n\t\t    *cp = hkmap(*cp);\n#endif\n\t    }\n\n\t    /*\n\t     * When the next character is CTRL-\\ a following CTRL-N means the\n\t     * command is aborted and we go to Normal mode.\n\t     */\n\t    if (cp == &ca.extra_char\n\t\t    && ca.nchar == Ctrl_BSL\n\t\t    && (ca.extra_char == Ctrl_N || ca.extra_char == Ctrl_G))\n\t    {\n\t\tca.cmdchar = Ctrl_BSL;\n\t\tca.nchar = ca.extra_char;\n\t\tidx = find_command(ca.cmdchar);\n\t    }\n\t    else if ((ca.nchar == 'n' || ca.nchar == 'N') && ca.cmdchar == 'g')\n\t\tca.oap->op_type = get_op_type(*cp, NUL);\n\t    else if (*cp == Ctrl_BSL)\n\t    {\n\t\tlong towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t\t// There is a busy wait here when typing \"f<C-\\>\" and then\n\t\t// something different from CTRL-N.  Can't be avoided.\n\t\twhile ((c = vpeekc()) <= 0 && towait > 0L)\n\t\t{\n\t\t    do_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\t    towait -= 50L;\n\t\t}\n\t\tif (c > 0)\n\t\t{\n\t\t    c = plain_vgetc();\n\t\t    if (c != Ctrl_N && c != Ctrl_G)\n\t\t\tvungetc(c);\n\t\t    else\n\t\t    {\n\t\t\tca.cmdchar = Ctrl_BSL;\n\t\t\tca.nchar = c;\n\t\t\tidx = find_command(ca.cmdchar);\n\t\t    }\n\t\t}\n\t    }\n\n\t    // When getting a text character and the next character is a\n\t    // multi-byte character, it could be a composing character.\n\t    // However, don't wait for it to arrive. Also, do enable mapping,\n\t    // because if it's put back with vungetc() it's too late to apply\n\t    // mapping.\n\t    --no_mapping;\n\t    while (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t\t\t && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (!utf_iscomposing(c))\n\t\t{\n\t\t    vungetc(c);\t\t// it wasn't, put it back\n\t\t    break;\n\t\t}\n\t\telse if (ca.ncharC1 == 0)\n\t\t    ca.ncharC1 = c;\n\t\telse\n\t\t    ca.ncharC2 = c;\n\t    }\n\t    ++no_mapping;\n\t}\n\t--no_mapping;\n\t--allow_keys;\n    }\n\n#ifdef FEAT_CMDL_INFO\n    /*\n     * Flush the showcmd characters onto the screen so we can see them while\n     * the command is being executed.  Only do this when the shown command was\n     * actually displayed, otherwise this will slow down a lot when executing\n     * mappings.\n     */\n    if (need_flushbuf)\n\tout_flush();\n#endif\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    /*\n     * Execute the command!\n     * Call the command function found in the commands table.\n     */\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    /*\n     * If we didn't start or finish an operator, reset oap->regname, unless we\n     * need it later.\n     */\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    /*\n     * If an operation is pending, handle it.  But not for K_IGNORE or\n     * K_MOUSEMOVE.\n     */\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    /*\n     * Wait for a moment when a message is displayed that will be overwritten\n     * by the mode message.\n     * In Visual mode and with \"^O\" in Insert mode, a short message will be\n     * overwritten by the mode message.  Wait a bit, until a key is hit.\n     * In Visual mode, it's more important to keep the Visual area updated\n     * than keeping a message (e.g. from a /pat search).\n     * Only do this if the command was typed, not from a mapping.\n     * Don't wait when emsg_silent is non-zero.\n     * Also wait a bit after an error message, e.g. for \"^O:\".\n     * Don't redraw the screen, it would remove the message.\n     */\n    if (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos.lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos.col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && oap->regname == 0\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && oap->op_type == OP_NOP)\n    {\n\tint\tsave_State = State;\n\n\t// Draw the cursor with the right shape here\n\tif (restart_edit != 0)\n\t    State = INSERT;\n\n\t// If need to redraw, and there is a \"keep_msg\", redraw before the\n\t// delay\n\tif (must_redraw && keep_msg != NULL && !emsg_on_display)\n\t{\n\t    char_u\t*kmsg;\n\n\t    kmsg = keep_msg;\n\t    keep_msg = NULL;\n\t    // Showmode() will clear keep_msg, but we want to use it anyway.\n\t    // First update w_topline.\n\t    setcursor();\n\t    update_screen(0);\n\t    // now reset it, otherwise it's put in the history again\n\t    keep_msg = kmsg;\n\n\t    kmsg = vim_strsave(keep_msg);\n\t    if (kmsg != NULL)\n\t    {\n\t\tmsg_attr((char *)kmsg, keep_msg_attr);\n\t\tvim_free(kmsg);\n\t    }\n\t}\n\tsetcursor();\n#ifdef CURSOR_SHAPE\n\tui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\tcursor_on();\n\tout_flush();\n\tif (msg_scroll || emsg_on_display)\n\t    ui_delay(1003L, TRUE);\t// wait at least one second\n\tui_delay(3003L, FALSE);\t\t// wait up to three seconds\n\tState = save_State;\n\n\tmsg_scroll = FALSE;\n\temsg_on_display = FALSE;\n    }\n\n    /*\n     * Finish up after executing a Normal mode command.\n     */\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n#ifdef FEAT_CMDL_INFO\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n#endif\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    /*\n     * May restart edit(), if we got here with CTRL-O in Insert mode (but not\n     * if still inside a mapping that started in Visual mode).\n     * May switch from Visual to Select mode after CTRL-O command.\n     */\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    /*\n     * If we are using the clipboard, then remember what was selected in case\n     * we need to paste it somewhere while we still own the selection.\n     * Only do this when the clipboard is already owned.  Don't want to grab\n     * the selection when hitting ESC.\n     */\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    /*\n     * if i == 0: try to find an identifier\n     * if i == 1: try to find any non-white text\n     */\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(\"E348: No string under cursor\"));\n\t    else\n\t\temsg(_(e_noident));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num)\n\tAppendNumberToRedobuff(num);\n\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n#ifdef FEAT_CMDL_INFO\n    else\n\tclear_showcmd();\n#endif\n}\n\n#if defined(FEAT_CMDL_INFO) || defined(PROTO)\n/*\n * Routines for displaying a partly typed command\n */\n\n#define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30\nstatic char_u\tshowcmd_buf[SHOWCMD_BUFLEN];\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len;\n\n    cursor_off();\n\n    len = (int)STRLEN(showcmd_buf);\n    if (len == 0)\n\tshowcmd_is_clear = TRUE;\n    else\n    {\n\tscreen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\tshowcmd_is_clear = FALSE;\n    }\n\n    /*\n     * clear the rest of an old message by outputting up to SHOWCMD_COLS\n     * spaces\n     */\n    screen_puts((char_u *)\"          \" + len, (int)Rows - 1, sc_col + len, 0);\n\n    setcursor();\t    // put cursor back where it belongs\n}\n#endif\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    /*\n\t     * Synchronize other windows, as necessary according to\n\t     * 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t     * when 'diff' is set.\n\t     */\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    /*\n\t     * When switching between windows, make sure that the relative\n\t     * vertical offset is valid for the new window.  The relative\n\t     * offset is invalid whenever another 'scrollbind' window has\n\t     * scrolled to a point that would force the current window to\n\t     * scroll past the beginning or end of its buffer.  When the\n\t     * resync is performed, some of the other 'scrollbind' windows may\n\t     * need to jump so that the current window's relative position is\n\t     * visible on-screen.\n\t     */\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    /*\n     * check 'scrollopt' string for vertical and horizontal scroll options\n     */\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    /*\n     * loop through the scrollbound windows and scroll accordingly\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_scb)\n\t{\n\t    /*\n\t     * do the vertical scroll\n\t     */\n\t    if (want_ver)\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (old_curwin->w_p_diff && curwin->w_p_diff)\n\t\t{\n\t\t    diff_set_topline(old_curwin, curwin);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    curwin->w_scbind_pos += topline_diff;\n\t\t    topline = curwin->w_scbind_pos;\n\t\t    if (topline > curbuf->b_ml.ml_line_count)\n\t\t\ttopline = curbuf->b_ml.ml_line_count;\n\t\t    if (topline < 1)\n\t\t\ttopline = 1;\n\n\t\t    y = topline - curwin->w_topline;\n\t\t    if (y > 0)\n\t\t\tscrollup(y, FALSE);\n\t\t    else\n\t\t\tscrolldown(-y, FALSE);\n\t\t}\n\n\t\tredraw_later(VALID);\n\t\tcursor_correct();\n\t\tcurwin->w_redr_status = TRUE;\n\t    }\n\n\t    /*\n\t     * do the horizontal scroll\n\t     */\n\t    if (want_hor && curwin->w_leftcol != tgt_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = tgt_leftcol;\n\t\tleftcol_changed();\n\t    }\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n    }\n    else\n    {\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n\t// clear any search statistics\n\tif (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\t    clear_cmdline = TRUE;\n    }\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    /*\n     * With \"gD\" go to line 1.\n     * With \"gd\" Search back for the start of the current function, then go\n     * back until a blank line.  If this fails go to line 1.\n     */\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      /*\n       * Instead of sticking at the last character of the buffer line we\n       * try to stick in the last column of the screen.\n       */\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t/*\n\t * Check for landing on a character that got split at the end of the\n\t * last line.  We want to advance a screenline, not end up in the same\n\t * screenline or move two screenlines.\n\t */\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value())\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(VALID);\n}\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n#ifdef FEAT_SPELL\n    int\t\tundo = FALSE;\n#endif\n    long        siso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar))\n    {\n\t/*\n\t * \"z123{nchar}\": edit the count before obtaining {nchar}\n\t */\n\tif (checkclearop(cap->oap))\n\t    return;\n\tn = nchar - '0';\n\tfor (;;)\n\t{\n#ifdef USE_ON_FLY_SCROLL\n\t    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t    ++no_mapping;\n\t    ++allow_keys;   // no mapping for nchar, but allow key codes\n\t    nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(nchar, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    (void)add_to_showcmd(nchar);\n#endif\n\t    if (nchar == K_DEL || nchar == K_KDEL)\n\t\tn /= 10;\n\t    else if (VIM_ISDIGIT(nchar))\n\t\tn = n * 10 + (nchar - '0');\n\t    else if (nchar == CAR)\n\t    {\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight((int)n);\n\t\tbreak;\n\t    }\n\t    else if (nchar == 'l'\n\t\t    || nchar == 'h'\n\t\t    || nchar == K_LEFT\n\t\t    || nchar == K_RIGHT)\n\t    {\n\t\tcap->count1 = n ? n * cap->count1 : cap->count1;\n\t\tgoto dozet;\n\t    }\n\t    else\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t}\n\tcap->oap->op_type = OP_NOP;\n\treturn;\n    }\n\ndozet:\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    /*\n     * For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n     * If line number given, set cursor.\n     */\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    if ((colnr_T)cap->count1 > curwin->w_leftcol)\n\t\t\tcurwin->w_leftcol = 0;\n\t\t    else\n\t\t\tcurwin->w_leftcol -= (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zL\" - scroll screen left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll screen to the left\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    // scroll the window left\n\t\t    curwin->w_leftcol += (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for nchar, but allow key codes\n\t\tnchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(nchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(nchar);\n#endif\n\t\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t\t{\n\t\t    clearopbeep(cap->oap);\n\t\t    break;\n\t\t}\n\t\tundo = TRUE;\n\t\t// FALLTHROUGH\n\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\t{\n\t\t    char_u  *ptr = NULL;\n\t\t    int\t    len;\n\n\t\t    if (checkclearop(cap->oap))\n\t\t\tbreak;\n\t\t    if (VIsual_active && get_visual_text(cap, &ptr, &len)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\treturn;\n\t\t    if (ptr == NULL)\n\t\t    {\n\t\t\tpos_T\tpos = curwin->w_cursor;\n\n\t\t\t// Find bad word under the cursor.  When 'spell' is\n\t\t\t// off this fails and find_ident_under_cursor() is\n\t\t\t// used below.\n\t\t\temsg_off++;\n\t\t\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\t\t\temsg_off--;\n\t\t\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t\t\t    ptr = ml_get_pos(&curwin->w_cursor);\n\t\t\tcurwin->w_cursor = pos;\n\t\t    }\n\n\t\t    if (ptr == NULL && (len = find_ident_under_cursor(&ptr,\n\t\t\t\t\t\t\t    FIND_IDENT)) == 0)\n\t\t\treturn;\n\t\t    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t\t\t\t\t      ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t\t\t\t\t    (nchar == 'G' || nchar == 'W')\n\t\t\t\t\t\t       ? 0 : (int)cap->count1,\n\t\t\t\t\t    undo);\n\t\t}\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_horiz_scroll(scrollbar_value, FALSE);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    /*\n     * Ignore 'Q' in Visual mode, just give a beep.\n     */\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tcmd_result = do_cmdline(NULL, is_cmdkey ? getcmdkeycmd : getexline, NULL,\n\t\t\t    cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\ttrigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\ttrigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    /*\n     * The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n     */\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_noident));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    /*\n\t     * Put cursor at start of word, makes search skip the word\n\t     * under the cursor.\n\t     * Call setpcmark() first, so \"*``\" puts the cursor back where\n\t     * it was.\n\t     */\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    if (kp_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else if (kp_ex)\n\t    {\n\t\tif (cap->count0 != 0)\n\t\t    vim_snprintf((char *)buf, buflen, \"%s %ld\",\n\t\t\t\t\t\t\t     kp, cap->count0);\n\t\telse\n\t\t    STRCPY(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t    }\n\t    else\n\t    {\n\t\t// An external command will probably use an argument starting\n\t\t// with \"-\" as an option.  To avoid trouble we skip the \"-\".\n\t\twhile (*ptr == '-' && n > 0)\n\t\t{\n\t\t    ++ptr;\n\t\t    --n;\n\t\t}\n\t\tif (n == 0)\n\t\t{\n\t\t    emsg(_(e_noident));\t // found dashes only\n\t\t    vim_free(buf);\n\t\t    return;\n\t\t}\n\n\t\t// When a count is given, turn it into a range.  Is this\n\t\t// really what we want?\n\t\tisman = (STRCMP(kp, \"man\") == 0);\n\t\tisman_s = (STRCMP(kp, \"man -s\") == 0);\n\t\tif (cap->count0 != 0 && !(isman || isman_s))\n\t\t    sprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n\t\tSTRCAT(buf, \"! \");\n\t\tif (cap->count0 == 0 && isman_s)\n\t\t    STRCAT(buf, \"man\");\n\t\telse\n\t\t    STRCAT(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t\tif (cap->count0 != 0 && (isman || isman_s))\n\t\t{\n\t\t    sprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\t\t    STRCAT(buf, \" \");\n\t\t}\n\t    }\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    /*\n     * Now grab the chars in the identifier\n     */\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    /*\n     * Execute the command.\n     */\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (has_mbyte)\n\t    // Correct the length to include the whole last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    /*\n     * In virtual edit mode, there's no such thing as \"past_line\", as lines\n     * are (theoretically) infinitely long.\n     */\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    /*\n\t     *\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t     *\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t     * CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t     */\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n#ifdef FEAT_CMDWIN\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n#ifdef FEAT_SEARCHPATH\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (text_locked())\n    {\n\tclearopbeep(cap->oap);\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n#endif\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, TRUE);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n     */\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    /*\n     * Find the occurrence(s) of the identifier or define under cursor\n     * in current and included files or jump to the first occurrence.\n     *\n     *\t\t\tsearch\t     list\t    jump\n     *\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n     * identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n     * define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n     */\n    if (vim_strchr((char_u *)\n# ifdef EBCDIC\n\t\t\"iI\\005dD\\067\",\n# else\n\t\t\"iI\\011dD\\004\",\n# endif\n\t\tcap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    /*\n     * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n     * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n     * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n     * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n     * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n     */\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n    {\n\tif (cap->nchar == '*')\n\t    cap->nchar = '/';\n\tprev_pos.lnum = 0;\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    if (cap->cmdchar == '[')\n\t\tfindc = '{';\n\t    else\n\t\tfindc = '}';\n\t    n = 9999;\n\t}\n\telse\n\t{\n\t    findc = cap->nchar;\n\t    n = cap->count1;\n\t}\n\tfor ( ; n > 0; --n)\n\t{\n\t    if ((pos = findmatchlimit(cap->oap, findc,\n\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t    {\n\t\tif (new_pos.lnum == 0)\t// nothing found\n\t\t{\n\t\t    if (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t\tclearopbeep(cap->oap);\n\t\t}\n\t\telse\n\t\t    pos = &new_pos;\t// use last one found\n\t\tbreak;\n\t    }\n\t    prev_pos = new_pos;\n\t    curwin->w_cursor = *pos;\n\t    new_pos = *pos;\n\t}\n\tcurwin->w_cursor = old_pos;\n\n\t/*\n\t * Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n\t * brought us to the match for \"[m\" and \"]M\" when inside a method.\n\t * Try finding the '{' or '}' we want to be at.\n\t * Also repeat for the given count.\n\t */\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    // norm is TRUE for \"]M\" and \"[m\"\n\t    int\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\t    n = cap->count1;\n\t    // found a match: we were inside a method\n\t    if (prev_pos.lnum != 0)\n\t    {\n\t\tpos = &prev_pos;\n\t\tcurwin->w_cursor = prev_pos;\n\t\tif (norm)\n\t\t    --n;\n\t    }\n\t    else\n\t\tpos = NULL;\n\t    while (n > 0)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t    {\n\t\t\t// if not found anything, that's an error\n\t\t\tif (pos == NULL)\n\t\t\t    clearopbeep(cap->oap);\n\t\t\tn = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    c = gchar_cursor();\n\t\t    if (c == '{' || c == '}')\n\t\t    {\n\t\t\t// Must have found end/start of class: use it.\n\t\t\t// Or found the place to be at.\n\t\t\tif ((c == findc && norm) || (n == 1 && !norm))\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t    n = 0;\n\t\t\t}\n\t\t\t// if no match found at all, we started outside of the\n\t\t\t// class and we're inside now.  Just go on.\n\t\t\telse if (new_pos.lnum == 0)\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t}\n\t\t\t// found start/end of other method: go to match\n\t\t\telse if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t    (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t  0)) == NULL)\n\t\t\t    n = 0;\n\t\t\telse\n\t\t\t    curwin->w_cursor = *pos;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--n;\n\t    }\n\t    curwin->w_cursor = old_pos;\n\t    if (pos == NULL && new_pos.lnum != 0)\n\t\tclearopbeep(cap->oap);\n\t}\n\tif (pos != NULL)\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n     */\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t/*\n\t * Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t * we also stop at '}'.\n\t */\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n     */\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    /*\n     * \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n     */\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    /*\n     * [ or ] followed by a middle mouse click: put selected text with\n     * indent adjustment.  Any other button just does as usual.\n     */\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    /*\n     * \"[z\" and \"]z\": move to start or end of open fold.\n     */\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    /*\n     * \"[c\" and \"]c\": move to next or previous diff-change.\n     */\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    /*\n     * \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n     */\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    /*\n     * Replacing with a TAB is done by edit() when it is complicated because\n     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n     * Other characters are done below to avoid problems with things like\n     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n     */\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t/*\n\t * Replace character(s) by a single newline.\n\t * Strange vi behaviour: Only one newline is inserted.\n\t * Delete the characters here.\n\t * Insert the newline with an insert command, takes care of\n\t * autoindent.\tThe insert command depends on being on the last\n\t * character of a line or not.\n\t */\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Replace the characters within one line.\n\t     */\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t/*\n\t\t * Get ptr again, because u_save and/or showmatch() will have\n\t\t * released the line.  This may also happen in ins_copychar().\n\t\t * At the same time we let know that the line will be changed.\n\t\t */\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n#ifdef FEAT_JUMPLIST\n    pos_T\t*pos;\n# ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n# endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(\"E664: changelist is empty\"));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(\"E662: At start of changelist\"));\n\t    else\n\t\temsg(_(\"E663: At end of changelist\"));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#else\n    clearopbeep(cap->oap);\n#endif\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    trigger_modechanged();\n\t}\n\tredraw_curbuf_later(INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    /*\n\t     * For V and ^V, we multiply the number of lines even if there\n\t     * was only one -- webb\n\t     */\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (stuff_empty() && typebuf_typed()\n\t\t    && (vim_strchr(p_slm, c) != NULL));\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\ttpos;\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    /*\n     * \"g^A\": dump log of used memory.\n     */\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    /*\n     * \"g^A/g^X\": sequentially increment visually selected region\n     */\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gR\": Enter virtual replace mode.\n     */\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    /*\n     * \"gv\": Reselect the previous Visual area.  If Visual already active,\n     *\t     exchange previous and current Visual area.\n     */\n    case 'v':\n\tif (checkclearop(oap))\n\t    break;\n\n\tif (\t   curbuf->b_visual.vi_start.lnum == 0\n\t\t|| curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t\t|| curbuf->b_visual.vi_end.lnum == 0)\n\t    beep_flush();\n\telse\n\t{\n\t    // set w_cursor to the start of the Visual area, tpos to the end\n\t    if (VIsual_active)\n\t    {\n\t\ti = VIsual_mode;\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = i;\n# endif\n\t\ti = curwin->w_curswant;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\tcurbuf->b_visual.vi_curswant = i;\n\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t    }\n\t    else\n\t    {\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t    }\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\n\t    // Set Visual to the start and w_cursor to the end of the Visual\n\t    // area.  Make sure they are on an existing character.\n\t    check_cursor();\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = tpos;\n\t    check_cursor();\n\t    update_topline();\n\t    /*\n\t     * When called from normal \"g\" command: start Select mode when\n\t     * 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n\t     * start Select mode.\n\t     */\n\t    if (cap->arg)\n\t\tVIsual_select = TRUE;\n\t    else\n\t\tmay_start_select('c');\n\t    setmouse();\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end are still the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t    redraw_curbuf_later(INVERTED);\n\t    showmode();\n\t}\n\tbreak;\n    /*\n     * \"gV\": Don't reselect the previous Visual area after a Select mode\n     *\t     mapping of menu.\n     */\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    /*\n     * \"gh\":  start Select mode.\n     * \"gH\":  start Select line mode.\n     * \"g^H\": start Select block mode.\n     */\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n# ifdef EBCDIC\n\t// EBCDIC: 'v'-'h' != '^v'-'^h'\n\tif (cap->nchar == Ctrl_H)\n\t    cap->cmdchar = Ctrl_V;\n\telse\n# endif\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gj\" and \"gk\" two new funny movement keys -- up and down\n     * movement based on *screen* line rather than *file* line.\n     */\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gJ\": join two lines without inserting a space.\n     */\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    /*\n     * \"g0\", \"g^\" and \"g$\": Like \"0\", \"^\" and \"$\" but for screen lines.\n     * \"gm\": middle of \"g0\" and \"g$\".\n     */\n    case '^':\n\tflag = TRUE;\n\t// FALLTHROUGH\n\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\toap->motion_type = MCHAR;\n\toap->inclusive = FALSE;\n\tif (curwin->w_p_wrap && curwin->w_width != 0)\n\t{\n\t    int\t\twidth1 = curwin->w_width - curwin_col_off();\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t    validate_virtcol();\n\t    i = 0;\n\t    if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)\n\t\ti = (curwin->w_virtcol - width1) / width2 * width2 + width1;\n\t}\n\telse\n\t    i = curwin->w_leftcol;\n\t// Go to the middle of the screen line.  When 'number' or\n\t// 'relativenumber' is on and lines are wrapping the middle can be more\n\t// to the left.\n\tif (cap->nchar == 'm')\n\t    i += (curwin->w_width - curwin_col_off()\n\t\t    + ((curwin->w_p_wrap && i > 0)\n\t\t\t? curwin_col_off2() : 0)) / 2;\n\tcoladvance((colnr_T)i);\n\tif (flag)\n\t{\n\t    do\n\t\ti = gchar_cursor();\n\t    while (VIM_ISWHITE(i) && oneright() == OK);\n\t    curwin->w_valid &= ~VALID_WCOL;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\tbreak;\n\n    case 'M':\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    if (has_mbyte)\n\t\ti = mb_string2cells(ptr, (int)STRLEN(ptr));\n\t    else\n\t\ti = (int)STRLEN(ptr);\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    case '_':\n\t// \"g_\": to the last non-blank character in the line or <count> lines\n\t// downward.\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->inclusive = TRUE;\n\tcurwin->w_curswant = MAXCOL;\n\tif (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    // In Visual mode we may end up after the line.\n\t    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t\t--curwin->w_cursor.col;\n\n\t    // Decrease the cursor column until it's on a non-blank.\n\t    while (curwin->w_cursor.col > 0\n\t\t\t\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_set_curswant = TRUE;\n\t    adjust_for_sel(cap);\n\t}\n\tbreak;\n\n    case '$':\n    case K_END:\n    case K_KEND:\n\t{\n\t    int col_off = curwin_col_off();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = TRUE;\n\t    if (curwin->w_p_wrap && curwin->w_width != 0)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\t\tif (cap->count1 == 1)\n\t\t{\n\t\t    int\t\twidth1 = curwin->w_width - col_off;\n\t\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t\t    validate_virtcol();\n\t\t    i = width1 - 1;\n\t\t    if (curwin->w_virtcol >= (colnr_T)width1)\n\t\t\ti += ((curwin->w_virtcol - width1) / width2 + 1)\n\t\t\t\t\t\t\t\t     * width2;\n\t\t    coladvance((colnr_T)i);\n\n\t\t    // Make sure we stick in this column.\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol;\n\t\t    curwin->w_set_curswant = FALSE;\n\t\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t\t    {\n\t\t\t/*\n\t\t\t * Check for landing on a character that got split at\n\t\t\t * the end of the line.  We do not want to advance to\n\t\t\t * the next screen line.\n\t\t\t */\n\t\t\tif (curwin->w_virtcol > (colnr_T)i)\n\t\t\t    --curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t\t    clearopbeep(oap);\n\t    }\n\t    else\n\t    {\n\t\tif (cap->count1 > 1)\n\t\t    // if it fails, let the cursor still move to the last char\n\t\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\t\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\t\tcoladvance((colnr_T)i);\n\n\t\t// if the character doesn't fit move one back\n\t\tif (curwin->w_cursor.col > 0\n\t\t\t\t       && (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t\t{\n\t\t    colnr_T vcol;\n\n\t\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t\t--curwin->w_cursor.col;\n\t\t}\n\n\t\t// Make sure we stick in this column.\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol;\n\t\tcurwin->w_set_curswant = FALSE;\n\t    }\n\t}\n\tbreak;\n\n    /*\n     * \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n     */\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    /*\n     * ge and gE: go back to end of word\n     */\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"g CTRL-G\": display info about cursor position\n     */\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    /*\n     * \"gi\": start Insert at the last position.\n     */\n    case 'i':\n\tif (curbuf->b_last_insert.lnum != 0)\n\t{\n\t    curwin->w_cursor = curbuf->b_last_insert;\n\t    check_cursor_lnum();\n\t    i = (int)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > (colnr_T)i)\n\t    {\n\t\tif (virtual_active())\n\t\t    curwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t\tcurwin->w_cursor.col = i;\n\t    }\n\t}\n\tcap->cmdchar = 'i';\n\tnv_edit(cap);\n\tbreak;\n\n    /*\n     * \"gI\": Start insert in column 1.\n     */\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"gf\": goto file, edit file under cursor\n     * \"]f\" and \"[f\": can also be used.\n     */\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n#endif\n\n\t// \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    /*\n     * \"gs\": Goto sleep.\n     */\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    /*\n     * \"ga\": Display the ascii value of the character under the\n     * cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n     */\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    /*\n     * \"g8\": Display the bytes used for the UTF-8 character under the\n     * cursor.\tIt is displayed in hex.\n     * \"8g8\" finds illegal byte sequence.\n     */\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    /*\n     * \"gg\": Goto the first line in file.  With a count it goes to\n     * that line number like for \"G\". -- webb\n     */\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    /*\n     *\t Two-character operators:\n     *\t \"gq\"\t    Format text\n     *\t \"gw\"\t    Format text and keep cursor position\n     *\t \"g~\"\t    Toggle the case of the text.\n     *\t \"gu\"\t    Change text to lower case.\n     *\t \"gU\"\t    Change text to upper case.\n     *   \"g?\"\t    rot13 encoding\n     *   \"g@\"\t    call 'operatorfunc'\n     */\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    /*\n     * \"gd\": Find first occurrence of pattern under the cursor in the\n     *\t current function\n     * \"gD\": idem, but in the current file.\n     */\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    /*\n     * g<*Mouse> : <C-*mouse>\n     */\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    /*\n     * \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n     */\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (text_locked())\n\t{\n\t    clearopbeep(cap->oap);\n\t    text_locked_msg();\n\t    break;\n\t}\n\n\tif (!checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n#ifdef FEAT_JUMPLIST\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n#endif\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t      0) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t/*\n\t * If \"restart_edit\" is TRUE, the last but one command is repeated\n\t * instead of the last command (inserting text). This is used for\n\t * CTRL-O <.> in insert mode.\n\t */\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo\n */\n    static void\nnv_redo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    /*\n     * Set inclusive for the \"E\" and \"e\" command.\n     */\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    /*\n     * \"cw\" and \"cW\" are a special case.\n     */\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t/*\n\t\t * Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t * changes one character, not all blanks until the start of\n\t\t * the next word.  Only do this when the 'w' flag is included\n\t\t * in 'cpoptions'.\n\t\t */\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * This is a little strange. To match what the real Vi does,\n\t\t * we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t * that we are not on a space or a TAB.  This seems impolite\n\t\t * at first, but it's really more what we mean when we say\n\t\t * 'cw'.\n\t\t * Another strangeness: When standing on the end of a word\n\t\t * \"ce\" will change until the end of the next word, but \"cw\"\n\t\t * will change only one character! This is done by setting\n\t\t * flag.\n\t\t */\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n\tVIsual_select = TRUE;\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n#endif\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0\n#ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n#endif\n\t\t&& !VIsual_active\n\t\t&& no_reason)\n\t{\n\t    if (anyBufIsChanged())\n\t\tmsg(_(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\"));\n\t    else\n\t\tmsg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t}\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n#endif\n    }\n#ifdef FEAT_CMDWIN\n    else if (cmdwin_type != 0 && ex_normal_busy)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will return ESC.  Exit the cmdline window to break the\n\t// loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n#endif\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(INVERTED);\n    }\n    else if (no_reason)\n\tvim_beep(BO_ESC);\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n#ifdef FEAT_TEXTOBJ\n\tnv_object(cap);\n#else\n\tclearopbeep(cap->oap);\n#endif\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\t// When the last char in the line was deleted then append. Detect this\n\t// by checking if the cursor moved to before the Visual area.\n\tif (*ml_get_cursor() != NUL && LT_POS(curwin->w_cursor, old_pos)\n\t\t\t\t       && LT_POS(curwin->w_cursor, old_visual))\n\t    inc_cursor();\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n#ifdef FEAT_TEXTOBJ\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n#endif\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_CMDWIN\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n#endif\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "fixing_code": ["/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n/*\n * findfile.c: Search for files in directories listed in 'path'\n */\n\n#include \"vim.h\"\n\n/*\n * File searching functions for 'path', 'tags' and 'cdpath' options.\n * External visible functions:\n * vim_findfile_init()\t\tcreates/initialises the search context\n * vim_findfile_free_visited()\tfree list of visited files/dirs of search\n *\t\t\t\tcontext\n * vim_findfile()\t\tfind a file in the search context\n * vim_findfile_cleanup()\tcleanup/free search context created by\n *\t\t\t\tvim_findfile_init()\n *\n * All static functions and variables start with 'ff_'\n *\n * In general it works like this:\n * First you create yourself a search context by calling vim_findfile_init().\n * It is possible to give a search context from a previous call to\n * vim_findfile_init(), so it can be reused. After this you call vim_findfile()\n * until you are satisfied with the result or it returns NULL. On every call it\n * returns the next file which matches the conditions given to\n * vim_findfile_init(). If it doesn't find a next file it returns NULL.\n *\n * It is possible to call vim_findfile_init() again to reinitialise your search\n * with some new parameters. Don't forget to pass your old search context to\n * it, so it can reuse it and especially reuse the list of already visited\n * directories. If you want to delete the list of already visited directories\n * simply call vim_findfile_free_visited().\n *\n * When you are done call vim_findfile_cleanup() to free the search context.\n *\n * The function vim_findfile_init() has a long comment, which describes the\n * needed parameters.\n *\n *\n *\n * ATTENTION:\n * ==========\n *\tAlso we use an allocated search context here, this functions are NOT\n *\tthread-safe!!!!!\n *\n *\tTo minimize parameter passing (or because I'm to lazy), only the\n *\texternal visible functions get a search context as a parameter. This is\n *\tthen assigned to a static global, which is used throughout the local\n *\tfunctions.\n */\n\n/*\n * type for the directory search stack\n */\ntypedef struct ff_stack\n{\n    struct ff_stack\t*ffs_prev;\n\n    // the fix part (no wildcards) and the part containing the wildcards\n    // of the search path\n    char_u\t\t*ffs_fix_path;\n#ifdef FEAT_PATH_EXTRA\n    char_u\t\t*ffs_wc_path;\n#endif\n\n    // files/dirs found in the above directory, matched by the first wildcard\n    // of wc_part\n    char_u\t\t**ffs_filearray;\n    int\t\t\tffs_filearray_size;\n    char_u\t\tffs_filearray_cur;   // needed for partly handled dirs\n\n    // to store status of partly handled directories\n    // 0: we work on this directory for the first time\n    // 1: this directory was partly searched in an earlier step\n    int\t\t\tffs_stage;\n\n    // How deep are we in the directory tree?\n    // Counts backward from value of level parameter to vim_findfile_init\n    int\t\t\tffs_level;\n\n    // Did we already expand '**' to an empty string?\n    int\t\t\tffs_star_star_empty;\n} ff_stack_T;\n\n/*\n * type for already visited directories or files.\n */\ntypedef struct ff_visited\n{\n    struct ff_visited\t*ffv_next;\n\n#ifdef FEAT_PATH_EXTRA\n    // Visited directories are different if the wildcard string are\n    // different. So we have to save it.\n    char_u\t\t*ffv_wc_path;\n#endif\n    // for unix use inode etc for comparison (needed because of links), else\n    // use filename.\n#ifdef UNIX\n    int\t\t\tffv_dev_valid;\t// ffv_dev and ffv_ino were set\n    dev_t\t\tffv_dev;\t// device number\n    ino_t\t\tffv_ino;\t// inode number\n#endif\n    // The memory for this struct is allocated according to the length of\n    // ffv_fname.\n    char_u\t\tffv_fname[1];\t// actually longer\n} ff_visited_T;\n\n/*\n * We might have to manage several visited lists during a search.\n * This is especially needed for the tags option. If tags is set to:\n *      \"./++/tags,./++/TAGS,++/tags\"  (replace + with *)\n * So we have to do 3 searches:\n *   1) search from the current files directory downward for the file \"tags\"\n *   2) search from the current files directory downward for the file \"TAGS\"\n *   3) search from Vims current directory downwards for the file \"tags\"\n * As you can see, the first and the third search are for the same file, so for\n * the third search we can use the visited list of the first search. For the\n * second search we must start from a empty visited list.\n * The struct ff_visited_list_hdr is used to manage a linked list of already\n * visited lists.\n */\ntypedef struct ff_visited_list_hdr\n{\n    struct ff_visited_list_hdr\t*ffvl_next;\n\n    // the filename the attached visited list is for\n    char_u\t\t\t*ffvl_filename;\n\n    ff_visited_T\t\t*ffvl_visited_list;\n\n} ff_visited_list_hdr_T;\n\n\n/*\n * '**' can be expanded to several directory levels.\n * Set the default maximum depth.\n */\n#define FF_MAX_STAR_STAR_EXPAND ((char_u)30)\n\n/*\n * The search context:\n *   ffsc_stack_ptr:\tthe stack for the dirs to search\n *   ffsc_visited_list: the currently active visited list\n *   ffsc_dir_visited_list: the currently active visited list for search dirs\n *   ffsc_visited_lists_list: the list of all visited lists\n *   ffsc_dir_visited_lists_list: the list of all visited lists for search dirs\n *   ffsc_file_to_search:     the file to search for\n *   ffsc_start_dir:\tthe starting directory, if search path was relative\n *   ffsc_fix_path:\tthe fix part of the given path (without wildcards)\n *\t\t\tNeeded for upward search.\n *   ffsc_wc_path:\tthe part of the given path containing wildcards\n *   ffsc_level:\thow many levels of dirs to search downwards\n *   ffsc_stopdirs_v:\tarray of stop directories for upward search\n *   ffsc_find_what:\tFINDFILE_BOTH, FINDFILE_DIR or FINDFILE_FILE\n *   ffsc_tagfile:\tsearching for tags file, don't use 'suffixesadd'\n */\ntypedef struct ff_search_ctx_T\n{\n     ff_stack_T\t\t\t*ffsc_stack_ptr;\n     ff_visited_list_hdr_T\t*ffsc_visited_list;\n     ff_visited_list_hdr_T\t*ffsc_dir_visited_list;\n     ff_visited_list_hdr_T\t*ffsc_visited_lists_list;\n     ff_visited_list_hdr_T\t*ffsc_dir_visited_lists_list;\n     char_u\t\t\t*ffsc_file_to_search;\n     char_u\t\t\t*ffsc_start_dir;\n     char_u\t\t\t*ffsc_fix_path;\n#ifdef FEAT_PATH_EXTRA\n     char_u\t\t\t*ffsc_wc_path;\n     int\t\t\tffsc_level;\n     char_u\t\t\t**ffsc_stopdirs_v;\n#endif\n     int\t\t\tffsc_find_what;\n     int\t\t\tffsc_tagfile;\n} ff_search_ctx_T;\n\n// locally needed functions\n#ifdef FEAT_PATH_EXTRA\nstatic int ff_check_visited(ff_visited_T **, char_u *, char_u *);\n#else\nstatic int ff_check_visited(ff_visited_T **, char_u *);\n#endif\nstatic void vim_findfile_free_visited(void *search_ctx_arg);\nstatic void vim_findfile_free_visited_list(ff_visited_list_hdr_T **list_headp);\nstatic void ff_free_visited_list(ff_visited_T *vl);\nstatic ff_visited_list_hdr_T* ff_get_visited_list(char_u *, ff_visited_list_hdr_T **list_headp);\n\nstatic void ff_push(ff_search_ctx_T *search_ctx, ff_stack_T *stack_ptr);\nstatic ff_stack_T *ff_pop(ff_search_ctx_T *search_ctx);\nstatic void ff_clear(ff_search_ctx_T *search_ctx);\nstatic void ff_free_stack_element(ff_stack_T *stack_ptr);\n#ifdef FEAT_PATH_EXTRA\nstatic ff_stack_T *ff_create_stack_element(char_u *, char_u *, int, int);\n#else\nstatic ff_stack_T *ff_create_stack_element(char_u *, int, int);\n#endif\n#ifdef FEAT_PATH_EXTRA\nstatic int ff_path_in_stoplist(char_u *, int, char_u **);\n#endif\n\nstatic char_u e_pathtoolong[] = N_(\"E854: path too long for completion\");\n\nstatic char_u\t*ff_expand_buffer = NULL; // used for expanding filenames\n\n#if 0\n/*\n * if someone likes findfirst/findnext, here are the functions\n * NOT TESTED!!\n */\n\nstatic void *ff_fn_search_context = NULL;\n\n    char_u *\nvim_findfirst(char_u *path, char_u *filename, int level)\n{\n    ff_fn_search_context =\n\tvim_findfile_init(path, filename, NULL, level, TRUE, FALSE,\n\t\tff_fn_search_context, rel_fname);\n    if (NULL == ff_fn_search_context)\n\treturn NULL;\n    else\n\treturn vim_findnext()\n}\n\n    char_u *\nvim_findnext(void)\n{\n    char_u *ret = vim_findfile(ff_fn_search_context);\n\n    if (NULL == ret)\n    {\n\tvim_findfile_cleanup(ff_fn_search_context);\n\tff_fn_search_context = NULL;\n    }\n    return ret;\n}\n#endif\n\n/*\n * Initialization routine for vim_findfile().\n *\n * Returns the newly allocated search context or NULL if an error occurred.\n *\n * Don't forget to clean up by calling vim_findfile_cleanup() if you are done\n * with the search context.\n *\n * Find the file 'filename' in the directory 'path'.\n * The parameter 'path' may contain wildcards. If so only search 'level'\n * directories deep. The parameter 'level' is the absolute maximum and is\n * not related to restricts given to the '**' wildcard. If 'level' is 100\n * and you use '**200' vim_findfile() will stop after 100 levels.\n *\n * 'filename' cannot contain wildcards!  It is used as-is, no backslashes to\n * escape special characters.\n *\n * If 'stopdirs' is not NULL and nothing is found downward, the search is\n * restarted on the next higher directory level. This is repeated until the\n * start-directory of a search is contained in 'stopdirs'. 'stopdirs' has the\n * format \";*<dirname>*\\(;<dirname>\\)*;\\=$\".\n *\n * If the 'path' is relative, the starting dir for the search is either VIM's\n * current dir or if the path starts with \"./\" the current files dir.\n * If the 'path' is absolute, the starting dir is that part of the path before\n * the first wildcard.\n *\n * Upward search is only done on the starting dir.\n *\n * If 'free_visited' is TRUE the list of already visited files/directories is\n * cleared. Set this to FALSE if you just want to search from another\n * directory, but want to be sure that no directory from a previous search is\n * searched again. This is useful if you search for a file at different places.\n * The list of visited files/dirs can also be cleared with the function\n * vim_findfile_free_visited().\n *\n * Set the parameter 'find_what' to FINDFILE_DIR if you want to search for\n * directories only, FINDFILE_FILE for files only, FINDFILE_BOTH for both.\n *\n * A search context returned by a previous call to vim_findfile_init() can be\n * passed in the parameter \"search_ctx_arg\".  This context is reused and\n * reinitialized with the new parameters.  The list of already visited\n * directories from this context is only deleted if the parameter\n * \"free_visited\" is true.  Be aware that the passed \"search_ctx_arg\" is freed\n * if the reinitialization fails.\n *\n * If you don't have a search context from a previous call \"search_ctx_arg\"\n * must be NULL.\n *\n * This function silently ignores a few errors, vim_findfile() will have\n * limited functionality then.\n */\n    void *\nvim_findfile_init(\n    char_u\t*path,\n    char_u\t*filename,\n    char_u\t*stopdirs UNUSED,\n    int\t\tlevel,\n    int\t\tfree_visited,\n    int\t\tfind_what,\n    void\t*search_ctx_arg,\n    int\t\ttagfile,\t// expanding names of tags files\n    char_u\t*rel_fname)\t// file name to use for \".\"\n{\n#ifdef FEAT_PATH_EXTRA\n    char_u\t\t*wc_part;\n#endif\n    ff_stack_T\t\t*sptr;\n    ff_search_ctx_T\t*search_ctx;\n\n    // If a search context is given by the caller, reuse it, else allocate a\n    // new one.\n    if (search_ctx_arg != NULL)\n\tsearch_ctx = search_ctx_arg;\n    else\n    {\n\tsearch_ctx = ALLOC_CLEAR_ONE(ff_search_ctx_T);\n\tif (search_ctx == NULL)\n\t    goto error_return;\n    }\n    search_ctx->ffsc_find_what = find_what;\n    search_ctx->ffsc_tagfile = tagfile;\n\n    // clear the search context, but NOT the visited lists\n    ff_clear(search_ctx);\n\n    // clear visited list if wanted\n    if (free_visited == TRUE)\n\tvim_findfile_free_visited(search_ctx);\n    else\n    {\n\t// Reuse old visited lists. Get the visited list for the given\n\t// filename. If no list for the current filename exists, creates a new\n\t// one.\n\tsearch_ctx->ffsc_visited_list = ff_get_visited_list(filename,\n\t\t\t\t\t&search_ctx->ffsc_visited_lists_list);\n\tif (search_ctx->ffsc_visited_list == NULL)\n\t    goto error_return;\n\tsearch_ctx->ffsc_dir_visited_list = ff_get_visited_list(filename,\n\t\t\t\t    &search_ctx->ffsc_dir_visited_lists_list);\n\tif (search_ctx->ffsc_dir_visited_list == NULL)\n\t    goto error_return;\n    }\n\n    if (ff_expand_buffer == NULL)\n    {\n\tff_expand_buffer = alloc(MAXPATHL);\n\tif (ff_expand_buffer == NULL)\n\t    goto error_return;\n    }\n\n    // Store information on starting dir now if path is relative.\n    // If path is absolute, we do that later.\n    if (path[0] == '.'\n\t    && (vim_ispathsep(path[1]) || path[1] == NUL)\n\t    && (!tagfile || vim_strchr(p_cpo, CPO_DOTTAG) == NULL)\n\t    && rel_fname != NULL)\n    {\n\tint\tlen = (int)(gettail(rel_fname) - rel_fname);\n\n\tif (!vim_isAbsName(rel_fname) && len + 1 < MAXPATHL)\n\t{\n\t    // Make the start dir an absolute path name.\n\t    vim_strncpy(ff_expand_buffer, rel_fname, len);\n\t    search_ctx->ffsc_start_dir = FullName_save(ff_expand_buffer, FALSE);\n\t}\n\telse\n\t    search_ctx->ffsc_start_dir = vim_strnsave(rel_fname, len);\n\tif (search_ctx->ffsc_start_dir == NULL)\n\t    goto error_return;\n\tif (*++path != NUL)\n\t    ++path;\n    }\n    else if (*path == NUL || !vim_isAbsName(path))\n    {\n#ifdef BACKSLASH_IN_FILENAME\n\t// \"c:dir\" needs \"c:\" to be expanded, otherwise use current dir\n\tif (*path != NUL && path[1] == ':')\n\t{\n\t    char_u  drive[3];\n\n\t    drive[0] = path[0];\n\t    drive[1] = ':';\n\t    drive[2] = NUL;\n\t    if (vim_FullName(drive, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)\n\t\tgoto error_return;\n\t    path += 2;\n\t}\n\telse\n#endif\n\tif (mch_dirname(ff_expand_buffer, MAXPATHL) == FAIL)\n\t    goto error_return;\n\n\tsearch_ctx->ffsc_start_dir = vim_strsave(ff_expand_buffer);\n\tif (search_ctx->ffsc_start_dir == NULL)\n\t    goto error_return;\n\n#ifdef BACKSLASH_IN_FILENAME\n\t// A path that starts with \"/dir\" is relative to the drive, not to the\n\t// directory (but not for \"//machine/dir\").  Only use the drive name.\n\tif ((*path == '/' || *path == '\\\\')\n\t\t&& path[1] != path[0]\n\t\t&& search_ctx->ffsc_start_dir[1] == ':')\n\t    search_ctx->ffsc_start_dir[2] = NUL;\n#endif\n    }\n\n#ifdef FEAT_PATH_EXTRA\n    /*\n     * If stopdirs are given, split them into an array of pointers.\n     * If this fails (mem allocation), there is no upward search at all or a\n     * stop directory is not recognized -> continue silently.\n     * If stopdirs just contains a \";\" or is empty,\n     * search_ctx->ffsc_stopdirs_v will only contain a  NULL pointer. This\n     * is handled as unlimited upward search.  See function\n     * ff_path_in_stoplist() for details.\n     */\n    if (stopdirs != NULL)\n    {\n\tchar_u\t*walker = stopdirs;\n\tint\tdircount;\n\n\twhile (*walker == ';')\n\t    walker++;\n\n\tdircount = 1;\n\tsearch_ctx->ffsc_stopdirs_v = ALLOC_ONE(char_u *);\n\n\tif (search_ctx->ffsc_stopdirs_v != NULL)\n\t{\n\t    do\n\t    {\n\t\tchar_u\t*helper;\n\t\tvoid\t*ptr;\n\n\t\thelper = walker;\n\t\tptr = vim_realloc(search_ctx->ffsc_stopdirs_v,\n\t\t\t\t\t   (dircount + 1) * sizeof(char_u *));\n\t\tif (ptr)\n\t\t    search_ctx->ffsc_stopdirs_v = ptr;\n\t\telse\n\t\t    // ignore, keep what we have and continue\n\t\t    break;\n\t\twalker = vim_strchr(walker, ';');\n\t\tif (walker)\n\t\t{\n\t\t    search_ctx->ffsc_stopdirs_v[dircount-1] =\n\t\t\t\t\t vim_strnsave(helper, walker - helper);\n\t\t    walker++;\n\t\t}\n\t\telse\n\t\t    // this might be \"\", which means ascent till top\n\t\t    // of directory tree.\n\t\t    search_ctx->ffsc_stopdirs_v[dircount-1] =\n\t\t\t\t\t\t\t  vim_strsave(helper);\n\n\t\tdircount++;\n\n\t    } while (walker != NULL);\n\t    search_ctx->ffsc_stopdirs_v[dircount-1] = NULL;\n\t}\n    }\n#endif\n\n#ifdef FEAT_PATH_EXTRA\n    search_ctx->ffsc_level = level;\n\n    /*\n     * split into:\n     *  -fix path\n     *  -wildcard_stuff (might be NULL)\n     */\n    wc_part = vim_strchr(path, '*');\n    if (wc_part != NULL)\n    {\n\tint\tllevel;\n\tint\tlen;\n\tchar\t*errpt;\n\n\t// save the fix part of the path\n\tsearch_ctx->ffsc_fix_path = vim_strnsave(path, wc_part - path);\n\n\t/*\n\t * copy wc_path and add restricts to the '**' wildcard.\n\t * The octet after a '**' is used as a (binary) counter.\n\t * So '**3' is transposed to '**^C' ('^C' is ASCII value 3)\n\t * or '**76' is transposed to '**N'( 'N' is ASCII value 76).\n\t * For EBCDIC you get different character values.\n\t * If no restrict is given after '**' the default is used.\n\t * Due to this technique the path looks awful if you print it as a\n\t * string.\n\t */\n\tlen = 0;\n\twhile (*wc_part != NUL)\n\t{\n\t    if (len + 5 >= MAXPATHL)\n\t    {\n\t\temsg(_(e_pathtoolong));\n\t\tbreak;\n\t    }\n\t    if (STRNCMP(wc_part, \"**\", 2) == 0)\n\t    {\n\t\tff_expand_buffer[len++] = *wc_part++;\n\t\tff_expand_buffer[len++] = *wc_part++;\n\n\t\tllevel = strtol((char *)wc_part, &errpt, 10);\n\t\tif ((char_u *)errpt != wc_part && llevel > 0 && llevel < 255)\n\t\t    ff_expand_buffer[len++] = llevel;\n\t\telse if ((char_u *)errpt != wc_part && llevel == 0)\n\t\t    // restrict is 0 -> remove already added '**'\n\t\t    len -= 2;\n\t\telse\n\t\t    ff_expand_buffer[len++] = FF_MAX_STAR_STAR_EXPAND;\n\t\twc_part = (char_u *)errpt;\n\t\tif (*wc_part != NUL && !vim_ispathsep(*wc_part))\n\t\t{\n\t\t    semsg(_(\"E343: Invalid path: '**[number]' must be at the end of the path or be followed by '%s'.\"), PATHSEPSTR);\n\t\t    goto error_return;\n\t\t}\n\t    }\n\t    else\n\t\tff_expand_buffer[len++] = *wc_part++;\n\t}\n\tff_expand_buffer[len] = NUL;\n\tsearch_ctx->ffsc_wc_path = vim_strsave(ff_expand_buffer);\n\n\tif (search_ctx->ffsc_wc_path == NULL)\n\t    goto error_return;\n    }\n    else\n#endif\n\tsearch_ctx->ffsc_fix_path = vim_strsave(path);\n\n    if (search_ctx->ffsc_start_dir == NULL)\n    {\n\t// store the fix part as startdir.\n\t// This is needed if the parameter path is fully qualified.\n\tsearch_ctx->ffsc_start_dir = vim_strsave(search_ctx->ffsc_fix_path);\n\tif (search_ctx->ffsc_start_dir == NULL)\n\t    goto error_return;\n\tsearch_ctx->ffsc_fix_path[0] = NUL;\n    }\n\n    // create an absolute path\n    if (STRLEN(search_ctx->ffsc_start_dir)\n\t\t\t  + STRLEN(search_ctx->ffsc_fix_path) + 3 >= MAXPATHL)\n    {\n\temsg(_(e_pathtoolong));\n\tgoto error_return;\n    }\n    STRCPY(ff_expand_buffer, search_ctx->ffsc_start_dir);\n    add_pathsep(ff_expand_buffer);\n    {\n\tint    eb_len = (int)STRLEN(ff_expand_buffer);\n\tchar_u *buf = alloc(eb_len\n\t\t\t\t+ (int)STRLEN(search_ctx->ffsc_fix_path) + 1);\n\n\tSTRCPY(buf, ff_expand_buffer);\n\tSTRCPY(buf + eb_len, search_ctx->ffsc_fix_path);\n\tif (mch_isdir(buf))\n\t{\n\t    STRCAT(ff_expand_buffer, search_ctx->ffsc_fix_path);\n\t    add_pathsep(ff_expand_buffer);\n\t}\n#ifdef FEAT_PATH_EXTRA\n\telse\n\t{\n\t    char_u *p =  gettail(search_ctx->ffsc_fix_path);\n\t    char_u *wc_path = NULL;\n\t    char_u *temp = NULL;\n\t    int    len = 0;\n\n\t    if (p > search_ctx->ffsc_fix_path)\n\t    {\n\t\t// do not add '..' to the path and start upwards searching\n\t\tlen = (int)(p - search_ctx->ffsc_fix_path) - 1;\n\t\tif ((len >= 2\n\t\t\t&& STRNCMP(search_ctx->ffsc_fix_path, \"..\", 2) == 0)\n\t\t\t&& (len == 2\n\t\t\t\t   || search_ctx->ffsc_fix_path[2] == PATHSEP))\n\t\t{\n\t\t    vim_free(buf);\n\t\t    goto error_return;\n\t\t}\n\t\tSTRNCAT(ff_expand_buffer, search_ctx->ffsc_fix_path, len);\n\t\tadd_pathsep(ff_expand_buffer);\n\t    }\n\t    else\n\t\tlen = (int)STRLEN(search_ctx->ffsc_fix_path);\n\n\t    if (search_ctx->ffsc_wc_path != NULL)\n\t    {\n\t\twc_path = vim_strsave(search_ctx->ffsc_wc_path);\n\t\ttemp = alloc(STRLEN(search_ctx->ffsc_wc_path)\n\t\t\t\t + STRLEN(search_ctx->ffsc_fix_path + len)\n\t\t\t\t + 1);\n\t\tif (temp == NULL || wc_path == NULL)\n\t\t{\n\t\t    vim_free(buf);\n\t\t    vim_free(temp);\n\t\t    vim_free(wc_path);\n\t\t    goto error_return;\n\t\t}\n\n\t\tSTRCPY(temp, search_ctx->ffsc_fix_path + len);\n\t\tSTRCAT(temp, search_ctx->ffsc_wc_path);\n\t\tvim_free(search_ctx->ffsc_wc_path);\n\t\tvim_free(wc_path);\n\t\tsearch_ctx->ffsc_wc_path = temp;\n\t    }\n\t}\n#endif\n\tvim_free(buf);\n    }\n\n    sptr = ff_create_stack_element(ff_expand_buffer,\n#ifdef FEAT_PATH_EXTRA\n\t    search_ctx->ffsc_wc_path,\n#endif\n\t    level, 0);\n\n    if (sptr == NULL)\n\tgoto error_return;\n\n    ff_push(search_ctx, sptr);\n\n    search_ctx->ffsc_file_to_search = vim_strsave(filename);\n    if (search_ctx->ffsc_file_to_search == NULL)\n\tgoto error_return;\n\n    return search_ctx;\n\nerror_return:\n    /*\n     * We clear the search context now!\n     * Even when the caller gave us a (perhaps valid) context we free it here,\n     * as we might have already destroyed it.\n     */\n    vim_findfile_cleanup(search_ctx);\n    return NULL;\n}\n\n#if defined(FEAT_PATH_EXTRA) || defined(PROTO)\n/*\n * Get the stopdir string.  Check that ';' is not escaped.\n */\n    char_u *\nvim_findfile_stopdir(char_u *buf)\n{\n    char_u\t*r_ptr = buf;\n\n    while (*r_ptr != NUL && *r_ptr != ';')\n    {\n\tif (r_ptr[0] == '\\\\' && r_ptr[1] == ';')\n\t{\n\t    // Overwrite the escape char,\n\t    // use STRLEN(r_ptr) to move the trailing '\\0'.\n\t    STRMOVE(r_ptr, r_ptr + 1);\n\t    r_ptr++;\n\t}\n\tr_ptr++;\n    }\n    if (*r_ptr == ';')\n    {\n\t*r_ptr = 0;\n\tr_ptr++;\n    }\n    else if (*r_ptr == NUL)\n\tr_ptr = NULL;\n    return r_ptr;\n}\n#endif\n\n/*\n * Clean up the given search context. Can handle a NULL pointer.\n */\n    void\nvim_findfile_cleanup(void *ctx)\n{\n    if (ctx == NULL)\n\treturn;\n\n    vim_findfile_free_visited(ctx);\n    ff_clear(ctx);\n    vim_free(ctx);\n}\n\n/*\n * Find a file in a search context.\n * The search context was created with vim_findfile_init() above.\n * Return a pointer to an allocated file name or NULL if nothing found.\n * To get all matching files call this function until you get NULL.\n *\n * If the passed search_context is NULL, NULL is returned.\n *\n * The search algorithm is depth first. To change this replace the\n * stack with a list (don't forget to leave partly searched directories on the\n * top of the list).\n */\n    char_u *\nvim_findfile(void *search_ctx_arg)\n{\n    char_u\t*file_path;\n#ifdef FEAT_PATH_EXTRA\n    char_u\t*rest_of_wildcards;\n    char_u\t*path_end = NULL;\n#endif\n    ff_stack_T\t*stackp;\n#if defined(FEAT_SEARCHPATH) || defined(FEAT_PATH_EXTRA)\n    int\t\tlen;\n#endif\n    int\t\ti;\n    char_u\t*p;\n#ifdef FEAT_SEARCHPATH\n    char_u\t*suf;\n#endif\n    ff_search_ctx_T *search_ctx;\n\n    if (search_ctx_arg == NULL)\n\treturn NULL;\n\n    search_ctx = (ff_search_ctx_T *)search_ctx_arg;\n\n    /*\n     * filepath is used as buffer for various actions and as the storage to\n     * return a found filename.\n     */\n    if ((file_path = alloc(MAXPATHL)) == NULL)\n\treturn NULL;\n\n#ifdef FEAT_PATH_EXTRA\n    // store the end of the start dir -- needed for upward search\n    if (search_ctx->ffsc_start_dir != NULL)\n\tpath_end = &search_ctx->ffsc_start_dir[\n\t\t\t\t\t  STRLEN(search_ctx->ffsc_start_dir)];\n#endif\n\n#ifdef FEAT_PATH_EXTRA\n    // upward search loop\n    for (;;)\n    {\n#endif\n\t// downward search loop\n\tfor (;;)\n\t{\n\t    // check if user user wants to stop the search\n\t    ui_breakcheck();\n\t    if (got_int)\n\t\tbreak;\n\n\t    // get directory to work on from stack\n\t    stackp = ff_pop(search_ctx);\n\t    if (stackp == NULL)\n\t\tbreak;\n\n\t    /*\n\t     * TODO: decide if we leave this test in\n\t     *\n\t     * GOOD: don't search a directory(-tree) twice.\n\t     * BAD:  - check linked list for every new directory entered.\n\t     *       - check for double files also done below\n\t     *\n\t     * Here we check if we already searched this directory.\n\t     * We already searched a directory if:\n\t     * 1) The directory is the same.\n\t     * 2) We would use the same wildcard string.\n\t     *\n\t     * Good if you have links on same directory via several ways\n\t     *  or you have selfreferences in directories (e.g. SuSE Linux 6.3:\n\t     *  /etc/rc.d/init.d is linked to /etc/rc.d -> endless loop)\n\t     *\n\t     * This check is only needed for directories we work on for the\n\t     * first time (hence stackp->ff_filearray == NULL)\n\t     */\n\t    if (stackp->ffs_filearray == NULL\n\t\t    && ff_check_visited(&search_ctx->ffsc_dir_visited_list\n\t\t\t\t\t\t\t  ->ffvl_visited_list,\n\t\t\tstackp->ffs_fix_path\n#ifdef FEAT_PATH_EXTRA\n\t\t\t, stackp->ffs_wc_path\n#endif\n\t\t\t) == FAIL)\n\t    {\n#ifdef FF_VERBOSE\n\t\tif (p_verbose >= 5)\n\t\t{\n\t\t    verbose_enter_scroll();\n\t\t    smsg(\"Already Searched: %s (%s)\",\n\t\t\t\t   stackp->ffs_fix_path, stackp->ffs_wc_path);\n\t\t    // don't overwrite this either\n\t\t    msg_puts(\"\\n\");\n\t\t    verbose_leave_scroll();\n\t\t}\n#endif\n\t\tff_free_stack_element(stackp);\n\t\tcontinue;\n\t    }\n#ifdef FF_VERBOSE\n\t    else if (p_verbose >= 5)\n\t    {\n\t\tverbose_enter_scroll();\n\t\tsmsg(\"Searching: %s (%s)\",\n\t\t\t\t   stackp->ffs_fix_path, stackp->ffs_wc_path);\n\t\t// don't overwrite this either\n\t\tmsg_puts(\"\\n\");\n\t\tverbose_leave_scroll();\n\t    }\n#endif\n\n\t    // check depth\n\t    if (stackp->ffs_level <= 0)\n\t    {\n\t\tff_free_stack_element(stackp);\n\t\tcontinue;\n\t    }\n\n\t    file_path[0] = NUL;\n\n\t    /*\n\t     * If no filearray till now expand wildcards\n\t     * The function expand_wildcards() can handle an array of paths\n\t     * and all possible expands are returned in one array. We use this\n\t     * to handle the expansion of '**' into an empty string.\n\t     */\n\t    if (stackp->ffs_filearray == NULL)\n\t    {\n\t\tchar_u *dirptrs[2];\n\n\t\t// we use filepath to build the path expand_wildcards() should\n\t\t// expand.\n\t\tdirptrs[0] = file_path;\n\t\tdirptrs[1] = NULL;\n\n\t\t// if we have a start dir copy it in\n\t\tif (!vim_isAbsName(stackp->ffs_fix_path)\n\t\t\t\t\t\t&& search_ctx->ffsc_start_dir)\n\t\t{\n\t\t    if (STRLEN(search_ctx->ffsc_start_dir) + 1 < MAXPATHL)\n\t\t    {\n\t\t\tSTRCPY(file_path, search_ctx->ffsc_start_dir);\n\t\t\tadd_pathsep(file_path);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tff_free_stack_element(stackp);\n\t\t\tgoto fail;\n\t\t    }\n\t\t}\n\n\t\t// append the fix part of the search path\n\t\tif (STRLEN(file_path) + STRLEN(stackp->ffs_fix_path) + 1\n\t\t\t\t\t\t\t\t    < MAXPATHL)\n\t\t{\n\t\t    STRCAT(file_path, stackp->ffs_fix_path);\n\t\t    add_pathsep(file_path);\n\t\t}\n\t\telse\n\t\t{\n\t\t    ff_free_stack_element(stackp);\n\t\t    goto fail;\n\t\t}\n\n#ifdef FEAT_PATH_EXTRA\n\t\trest_of_wildcards = stackp->ffs_wc_path;\n\t\tif (*rest_of_wildcards != NUL)\n\t\t{\n\t\t    len = (int)STRLEN(file_path);\n\t\t    if (STRNCMP(rest_of_wildcards, \"**\", 2) == 0)\n\t\t    {\n\t\t\t// pointer to the restrict byte\n\t\t\t// The restrict byte is not a character!\n\t\t\tp = rest_of_wildcards + 2;\n\n\t\t\tif (*p > 0)\n\t\t\t{\n\t\t\t    (*p)--;\n\t\t\t    if (len + 1 < MAXPATHL)\n\t\t\t\tfile_path[len++] = '*';\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tff_free_stack_element(stackp);\n\t\t\t\tgoto fail;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (*p == 0)\n\t\t\t{\n\t\t\t    // remove '**<numb> from wildcards\n\t\t\t    STRMOVE(rest_of_wildcards, rest_of_wildcards + 3);\n\t\t\t}\n\t\t\telse\n\t\t\t    rest_of_wildcards += 3;\n\n\t\t\tif (stackp->ffs_star_star_empty == 0)\n\t\t\t{\n\t\t\t    // if not done before, expand '**' to empty\n\t\t\t    stackp->ffs_star_star_empty = 1;\n\t\t\t    dirptrs[1] = stackp->ffs_fix_path;\n\t\t\t}\n\t\t    }\n\n\t\t    /*\n\t\t     * Here we copy until the next path separator or the end of\n\t\t     * the path. If we stop at a path separator, there is\n\t\t     * still something else left. This is handled below by\n\t\t     * pushing every directory returned from expand_wildcards()\n\t\t     * on the stack again for further search.\n\t\t     */\n\t\t    while (*rest_of_wildcards\n\t\t\t    && !vim_ispathsep(*rest_of_wildcards))\n\t\t\tif (len + 1 < MAXPATHL)\n\t\t\t    file_path[len++] = *rest_of_wildcards++;\n\t\t\telse\n\t\t\t{\n\t\t\t    ff_free_stack_element(stackp);\n\t\t\t    goto fail;\n\t\t\t}\n\n\t\t    file_path[len] = NUL;\n\t\t    if (vim_ispathsep(*rest_of_wildcards))\n\t\t\trest_of_wildcards++;\n\t\t}\n#endif\n\n\t\t/*\n\t\t * Expand wildcards like \"*\" and \"$VAR\".\n\t\t * If the path is a URL don't try this.\n\t\t */\n\t\tif (path_with_url(dirptrs[0]))\n\t\t{\n\t\t    stackp->ffs_filearray = ALLOC_ONE(char_u *);\n\t\t    if (stackp->ffs_filearray != NULL\n\t\t\t    && (stackp->ffs_filearray[0]\n\t\t\t\t= vim_strsave(dirptrs[0])) != NULL)\n\t\t\tstackp->ffs_filearray_size = 1;\n\t\t    else\n\t\t\tstackp->ffs_filearray_size = 0;\n\t\t}\n\t\telse\n\t\t    // Add EW_NOTWILD because the expanded path may contain\n\t\t    // wildcard characters that are to be taken literally.\n\t\t    // This is a bit of a hack.\n\t\t    expand_wildcards((dirptrs[1] == NULL) ? 1 : 2, dirptrs,\n\t\t\t    &stackp->ffs_filearray_size,\n\t\t\t    &stackp->ffs_filearray,\n\t\t\t    EW_DIR|EW_ADDSLASH|EW_SILENT|EW_NOTWILD);\n\n\t\tstackp->ffs_filearray_cur = 0;\n\t\tstackp->ffs_stage = 0;\n\t    }\n#ifdef FEAT_PATH_EXTRA\n\t    else\n\t\trest_of_wildcards = &stackp->ffs_wc_path[\n\t\t\t\t\t\t STRLEN(stackp->ffs_wc_path)];\n#endif\n\n\t    if (stackp->ffs_stage == 0)\n\t    {\n\t\t// this is the first time we work on this directory\n#ifdef FEAT_PATH_EXTRA\n\t\tif (*rest_of_wildcards == NUL)\n#endif\n\t\t{\n\t\t    /*\n\t\t     * We don't have further wildcards to expand, so we have to\n\t\t     * check for the final file now.\n\t\t     */\n\t\t    for (i = stackp->ffs_filearray_cur;\n\t\t\t\t\t  i < stackp->ffs_filearray_size; ++i)\n\t\t    {\n\t\t\tif (!path_with_url(stackp->ffs_filearray[i])\n\t\t\t\t      && !mch_isdir(stackp->ffs_filearray[i]))\n\t\t\t    continue;   // not a directory\n\n\t\t\t// prepare the filename to be checked for existence\n\t\t\t// below\n\t\t\tif (STRLEN(stackp->ffs_filearray[i]) + 1\n\t\t\t\t+ STRLEN(search_ctx->ffsc_file_to_search)\n\t\t\t\t\t\t\t\t    < MAXPATHL)\n\t\t\t{\n\t\t\t    STRCPY(file_path, stackp->ffs_filearray[i]);\n\t\t\t    add_pathsep(file_path);\n\t\t\t    STRCAT(file_path, search_ctx->ffsc_file_to_search);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    ff_free_stack_element(stackp);\n\t\t\t    goto fail;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * Try without extra suffix and then with suffixes\n\t\t\t * from 'suffixesadd'.\n\t\t\t */\n#ifdef FEAT_SEARCHPATH\n\t\t\tlen = (int)STRLEN(file_path);\n\t\t\tif (search_ctx->ffsc_tagfile)\n\t\t\t    suf = (char_u *)\"\";\n\t\t\telse\n\t\t\t    suf = curbuf->b_p_sua;\n\t\t\tfor (;;)\n#endif\n\t\t\t{\n\t\t\t    // if file exists and we didn't already find it\n\t\t\t    if ((path_with_url(file_path)\n\t\t\t\t  || (mch_getperm(file_path) >= 0\n\t\t\t\t      && (search_ctx->ffsc_find_what\n\t\t\t\t\t\t\t      == FINDFILE_BOTH\n\t\t\t\t\t  || ((search_ctx->ffsc_find_what\n\t\t\t\t\t\t\t      == FINDFILE_DIR)\n\t\t\t\t\t\t   == mch_isdir(file_path)))))\n#ifndef FF_VERBOSE\n\t\t\t\t    && (ff_check_visited(\n\t\t\t\t\t    &search_ctx->ffsc_visited_list->ffvl_visited_list,\n\t\t\t\t\t    file_path\n#ifdef FEAT_PATH_EXTRA\n\t\t\t\t\t    , (char_u *)\"\"\n#endif\n\t\t\t\t\t    ) == OK)\n#endif\n\t\t\t       )\n\t\t\t    {\n#ifdef FF_VERBOSE\n\t\t\t\tif (ff_check_visited(\n\t\t\t\t\t    &search_ctx->ffsc_visited_list->ffvl_visited_list,\n\t\t\t\t\t    file_path\n#ifdef FEAT_PATH_EXTRA\n\t\t\t\t\t    , (char_u *)\"\"\n#endif\n\t\t\t\t\t\t    ) == FAIL)\n\t\t\t\t{\n\t\t\t\t    if (p_verbose >= 5)\n\t\t\t\t    {\n\t\t\t\t\tverbose_enter_scroll();\n\t\t\t\t\tsmsg(\"Already: %s\",\n\t\t\t\t\t\t\t\t   file_path);\n\t\t\t\t\t// don't overwrite this either\n\t\t\t\t\tmsg_puts(\"\\n\");\n\t\t\t\t\tverbose_leave_scroll();\n\t\t\t\t    }\n\t\t\t\t    continue;\n\t\t\t\t}\n#endif\n\n\t\t\t\t// push dir to examine rest of subdirs later\n\t\t\t\tstackp->ffs_filearray_cur = i + 1;\n\t\t\t\tff_push(search_ctx, stackp);\n\n\t\t\t\tif (!path_with_url(file_path))\n\t\t\t\t    simplify_filename(file_path);\n\t\t\t\tif (mch_dirname(ff_expand_buffer, MAXPATHL)\n\t\t\t\t\t\t\t\t\t== OK)\n\t\t\t\t{\n\t\t\t\t    p = shorten_fname(file_path,\n\t\t\t\t\t\t\t    ff_expand_buffer);\n\t\t\t\t    if (p != NULL)\n\t\t\t\t\tSTRMOVE(file_path, p);\n\t\t\t\t}\n#ifdef FF_VERBOSE\n\t\t\t\tif (p_verbose >= 5)\n\t\t\t\t{\n\t\t\t\t    verbose_enter_scroll();\n\t\t\t\t    smsg(\"HIT: %s\", file_path);\n\t\t\t\t    // don't overwrite this either\n\t\t\t\t    msg_puts(\"\\n\");\n\t\t\t\t    verbose_leave_scroll();\n\t\t\t\t}\n#endif\n\t\t\t\treturn file_path;\n\t\t\t    }\n\n#ifdef FEAT_SEARCHPATH\n\t\t\t    // Not found or found already, try next suffix.\n\t\t\t    if (*suf == NUL)\n\t\t\t\tbreak;\n\t\t\t    copy_option_part(&suf, file_path + len,\n\t\t\t\t\t\t\t MAXPATHL - len, \",\");\n#endif\n\t\t\t}\n\t\t    }\n\t\t}\n#ifdef FEAT_PATH_EXTRA\n\t\telse\n\t\t{\n\t\t    /*\n\t\t     * still wildcards left, push the directories for further\n\t\t     * search\n\t\t     */\n\t\t    for (i = stackp->ffs_filearray_cur;\n\t\t\t\t\t  i < stackp->ffs_filearray_size; ++i)\n\t\t    {\n\t\t\tif (!mch_isdir(stackp->ffs_filearray[i]))\n\t\t\t    continue;\t// not a directory\n\n\t\t\tff_push(search_ctx,\n\t\t\t\tff_create_stack_element(\n\t\t\t\t\t\t     stackp->ffs_filearray[i],\n\t\t\t\t\t\t     rest_of_wildcards,\n\t\t\t\t\t\t     stackp->ffs_level - 1, 0));\n\t\t    }\n\t\t}\n#endif\n\t\tstackp->ffs_filearray_cur = 0;\n\t\tstackp->ffs_stage = 1;\n\t    }\n\n#ifdef FEAT_PATH_EXTRA\n\t    /*\n\t     * if wildcards contains '**' we have to descent till we reach the\n\t     * leaves of the directory tree.\n\t     */\n\t    if (STRNCMP(stackp->ffs_wc_path, \"**\", 2) == 0)\n\t    {\n\t\tfor (i = stackp->ffs_filearray_cur;\n\t\t\t\t\t  i < stackp->ffs_filearray_size; ++i)\n\t\t{\n\t\t    if (fnamecmp(stackp->ffs_filearray[i],\n\t\t\t\t\t\t   stackp->ffs_fix_path) == 0)\n\t\t\tcontinue; // don't repush same directory\n\t\t    if (!mch_isdir(stackp->ffs_filearray[i]))\n\t\t\tcontinue;   // not a directory\n\t\t    ff_push(search_ctx,\n\t\t\t    ff_create_stack_element(stackp->ffs_filearray[i],\n\t\t\t\tstackp->ffs_wc_path, stackp->ffs_level - 1, 1));\n\t\t}\n\t    }\n#endif\n\n\t    // we are done with the current directory\n\t    ff_free_stack_element(stackp);\n\n\t}\n\n#ifdef FEAT_PATH_EXTRA\n\t// If we reached this, we didn't find anything downwards.\n\t// Let's check if we should do an upward search.\n\tif (search_ctx->ffsc_start_dir\n\t\t&& search_ctx->ffsc_stopdirs_v != NULL && !got_int)\n\t{\n\t    ff_stack_T  *sptr;\n\n\t    // is the last starting directory in the stop list?\n\t    if (ff_path_in_stoplist(search_ctx->ffsc_start_dir,\n\t\t       (int)(path_end - search_ctx->ffsc_start_dir),\n\t\t       search_ctx->ffsc_stopdirs_v) == TRUE)\n\t\tbreak;\n\n\t    // cut of last dir\n\t    while (path_end > search_ctx->ffsc_start_dir\n\t\t\t\t\t\t  && vim_ispathsep(*path_end))\n\t\tpath_end--;\n\t    while (path_end > search_ctx->ffsc_start_dir\n\t\t\t\t\t      && !vim_ispathsep(path_end[-1]))\n\t\tpath_end--;\n\t    *path_end = 0;\n\t    path_end--;\n\n\t    if (*search_ctx->ffsc_start_dir == 0)\n\t\tbreak;\n\n\t    if (STRLEN(search_ctx->ffsc_start_dir) + 1\n\t\t    + STRLEN(search_ctx->ffsc_fix_path) < MAXPATHL)\n\t    {\n\t\tSTRCPY(file_path, search_ctx->ffsc_start_dir);\n\t\tadd_pathsep(file_path);\n\t\tSTRCAT(file_path, search_ctx->ffsc_fix_path);\n\t    }\n\t    else\n\t\tgoto fail;\n\n\t    // create a new stack entry\n\t    sptr = ff_create_stack_element(file_path,\n\t\t    search_ctx->ffsc_wc_path, search_ctx->ffsc_level, 0);\n\t    if (sptr == NULL)\n\t\tbreak;\n\t    ff_push(search_ctx, sptr);\n\t}\n\telse\n\t    break;\n    }\n#endif\n\nfail:\n    vim_free(file_path);\n    return NULL;\n}\n\n/*\n * Free the list of lists of visited files and directories\n * Can handle it if the passed search_context is NULL;\n */\n    static void\nvim_findfile_free_visited(void *search_ctx_arg)\n{\n    ff_search_ctx_T *search_ctx;\n\n    if (search_ctx_arg == NULL)\n\treturn;\n\n    search_ctx = (ff_search_ctx_T *)search_ctx_arg;\n    vim_findfile_free_visited_list(&search_ctx->ffsc_visited_lists_list);\n    vim_findfile_free_visited_list(&search_ctx->ffsc_dir_visited_lists_list);\n}\n\n    static void\nvim_findfile_free_visited_list(ff_visited_list_hdr_T **list_headp)\n{\n    ff_visited_list_hdr_T *vp;\n\n    while (*list_headp != NULL)\n    {\n\tvp = (*list_headp)->ffvl_next;\n\tff_free_visited_list((*list_headp)->ffvl_visited_list);\n\n\tvim_free((*list_headp)->ffvl_filename);\n\tvim_free(*list_headp);\n\t*list_headp = vp;\n    }\n    *list_headp = NULL;\n}\n\n    static void\nff_free_visited_list(ff_visited_T *vl)\n{\n    ff_visited_T *vp;\n\n    while (vl != NULL)\n    {\n\tvp = vl->ffv_next;\n#ifdef FEAT_PATH_EXTRA\n\tvim_free(vl->ffv_wc_path);\n#endif\n\tvim_free(vl);\n\tvl = vp;\n    }\n    vl = NULL;\n}\n\n/*\n * Returns the already visited list for the given filename. If none is found it\n * allocates a new one.\n */\n    static ff_visited_list_hdr_T*\nff_get_visited_list(\n    char_u\t\t\t*filename,\n    ff_visited_list_hdr_T\t**list_headp)\n{\n    ff_visited_list_hdr_T  *retptr = NULL;\n\n    // check if a visited list for the given filename exists\n    if (*list_headp != NULL)\n    {\n\tretptr = *list_headp;\n\twhile (retptr != NULL)\n\t{\n\t    if (fnamecmp(filename, retptr->ffvl_filename) == 0)\n\t    {\n#ifdef FF_VERBOSE\n\t\tif (p_verbose >= 5)\n\t\t{\n\t\t    verbose_enter_scroll();\n\t\t    smsg(\"ff_get_visited_list: FOUND list for %s\",\n\t\t\t\t\t\t\t\t    filename);\n\t\t    // don't overwrite this either\n\t\t    msg_puts(\"\\n\");\n\t\t    verbose_leave_scroll();\n\t\t}\n#endif\n\t\treturn retptr;\n\t    }\n\t    retptr = retptr->ffvl_next;\n\t}\n    }\n\n#ifdef FF_VERBOSE\n    if (p_verbose >= 5)\n    {\n\tverbose_enter_scroll();\n\tsmsg(\"ff_get_visited_list: new list for %s\", filename);\n\t// don't overwrite this either\n\tmsg_puts(\"\\n\");\n\tverbose_leave_scroll();\n    }\n#endif\n\n    /*\n     * if we reach this we didn't find a list and we have to allocate new list\n     */\n    retptr = ALLOC_ONE(ff_visited_list_hdr_T);\n    if (retptr == NULL)\n\treturn NULL;\n\n    retptr->ffvl_visited_list = NULL;\n    retptr->ffvl_filename = vim_strsave(filename);\n    if (retptr->ffvl_filename == NULL)\n    {\n\tvim_free(retptr);\n\treturn NULL;\n    }\n    retptr->ffvl_next = *list_headp;\n    *list_headp = retptr;\n\n    return retptr;\n}\n\n#ifdef FEAT_PATH_EXTRA\n/*\n * check if two wildcard paths are equal. Returns TRUE or FALSE.\n * They are equal if:\n *  - both paths are NULL\n *  - they have the same length\n *  - char by char comparison is OK\n *  - the only differences are in the counters behind a '**', so\n *    '**\\20' is equal to '**\\24'\n */\n    static int\nff_wc_equal(char_u *s1, char_u *s2)\n{\n    int\t\ti, j;\n    int\t\tc1 = NUL;\n    int\t\tc2 = NUL;\n    int\t\tprev1 = NUL;\n    int\t\tprev2 = NUL;\n\n    if (s1 == s2)\n\treturn TRUE;\n\n    if (s1 == NULL || s2 == NULL)\n\treturn FALSE;\n\n    for (i = 0, j = 0; s1[i] != NUL && s2[j] != NUL;)\n    {\n\tc1 = PTR2CHAR(s1 + i);\n\tc2 = PTR2CHAR(s2 + j);\n\n\tif ((p_fic ? MB_TOLOWER(c1) != MB_TOLOWER(c2) : c1 != c2)\n\t\t&& (prev1 != '*' || prev2 != '*'))\n\t    return FALSE;\n\tprev2 = prev1;\n\tprev1 = c1;\n\n\ti += mb_ptr2len(s1 + i);\n\tj += mb_ptr2len(s2 + j);\n    }\n    return s1[i] == s2[j];\n}\n#endif\n\n/*\n * maintains the list of already visited files and dirs\n * returns FAIL if the given file/dir is already in the list\n * returns OK if it is newly added\n *\n * TODO: What to do on memory allocation problems?\n *\t -> return TRUE - Better the file is found several times instead of\n *\t    never.\n */\n    static int\nff_check_visited(\n    ff_visited_T\t**visited_list,\n    char_u\t\t*fname\n#ifdef FEAT_PATH_EXTRA\n    , char_u\t\t*wc_path\n#endif\n    )\n{\n    ff_visited_T\t*vp;\n#ifdef UNIX\n    stat_T\t\tst;\n    int\t\t\turl = FALSE;\n#endif\n\n    // For an URL we only compare the name, otherwise we compare the\n    // device/inode (unix) or the full path name (not Unix).\n    if (path_with_url(fname))\n    {\n\tvim_strncpy(ff_expand_buffer, fname, MAXPATHL - 1);\n#ifdef UNIX\n\turl = TRUE;\n#endif\n    }\n    else\n    {\n\tff_expand_buffer[0] = NUL;\n#ifdef UNIX\n\tif (mch_stat((char *)fname, &st) < 0)\n#else\n\tif (vim_FullName(fname, ff_expand_buffer, MAXPATHL, TRUE) == FAIL)\n#endif\n\t    return FAIL;\n    }\n\n    // check against list of already visited files\n    for (vp = *visited_list; vp != NULL; vp = vp->ffv_next)\n    {\n\tif (\n#ifdef UNIX\n\t\t!url ? (vp->ffv_dev_valid && vp->ffv_dev == st.st_dev\n\t\t\t\t\t\t  && vp->ffv_ino == st.st_ino)\n\t\t     :\n#endif\n\t\tfnamecmp(vp->ffv_fname, ff_expand_buffer) == 0\n\t   )\n\t{\n#ifdef FEAT_PATH_EXTRA\n\t    // are the wildcard parts equal\n\t    if (ff_wc_equal(vp->ffv_wc_path, wc_path) == TRUE)\n#endif\n\t\t// already visited\n\t\treturn FAIL;\n\t}\n    }\n\n    /*\n     * New file/dir.  Add it to the list of visited files/dirs.\n     */\n    vp = alloc(sizeof(ff_visited_T) + STRLEN(ff_expand_buffer));\n\n    if (vp != NULL)\n    {\n#ifdef UNIX\n\tif (!url)\n\t{\n\t    vp->ffv_dev_valid = TRUE;\n\t    vp->ffv_ino = st.st_ino;\n\t    vp->ffv_dev = st.st_dev;\n\t    vp->ffv_fname[0] = NUL;\n\t}\n\telse\n\t{\n\t    vp->ffv_dev_valid = FALSE;\n#endif\n\t    STRCPY(vp->ffv_fname, ff_expand_buffer);\n#ifdef UNIX\n\t}\n#endif\n#ifdef FEAT_PATH_EXTRA\n\tif (wc_path != NULL)\n\t    vp->ffv_wc_path = vim_strsave(wc_path);\n\telse\n\t    vp->ffv_wc_path = NULL;\n#endif\n\n\tvp->ffv_next = *visited_list;\n\t*visited_list = vp;\n    }\n\n    return OK;\n}\n\n/*\n * create stack element from given path pieces\n */\n    static ff_stack_T *\nff_create_stack_element(\n    char_u\t*fix_part,\n#ifdef FEAT_PATH_EXTRA\n    char_u\t*wc_part,\n#endif\n    int\t\tlevel,\n    int\t\tstar_star_empty)\n{\n    ff_stack_T\t*new;\n\n    new = ALLOC_ONE(ff_stack_T);\n    if (new == NULL)\n\treturn NULL;\n\n    new->ffs_prev\t   = NULL;\n    new->ffs_filearray\t   = NULL;\n    new->ffs_filearray_size = 0;\n    new->ffs_filearray_cur  = 0;\n    new->ffs_stage\t   = 0;\n    new->ffs_level\t   = level;\n    new->ffs_star_star_empty = star_star_empty;\n\n    // the following saves NULL pointer checks in vim_findfile\n    if (fix_part == NULL)\n\tfix_part = (char_u *)\"\";\n    new->ffs_fix_path = vim_strsave(fix_part);\n\n#ifdef FEAT_PATH_EXTRA\n    if (wc_part == NULL)\n\twc_part  = (char_u *)\"\";\n    new->ffs_wc_path = vim_strsave(wc_part);\n#endif\n\n    if (new->ffs_fix_path == NULL\n#ifdef FEAT_PATH_EXTRA\n\t    || new->ffs_wc_path == NULL\n#endif\n\t    )\n    {\n\tff_free_stack_element(new);\n\tnew = NULL;\n    }\n\n    return new;\n}\n\n/*\n * Push a dir on the directory stack.\n */\n    static void\nff_push(ff_search_ctx_T *search_ctx, ff_stack_T *stack_ptr)\n{\n    // check for NULL pointer, not to return an error to the user, but\n    // to prevent a crash\n    if (stack_ptr != NULL)\n    {\n\tstack_ptr->ffs_prev = search_ctx->ffsc_stack_ptr;\n\tsearch_ctx->ffsc_stack_ptr = stack_ptr;\n    }\n}\n\n/*\n * Pop a dir from the directory stack.\n * Returns NULL if stack is empty.\n */\n    static ff_stack_T *\nff_pop(ff_search_ctx_T *search_ctx)\n{\n    ff_stack_T  *sptr;\n\n    sptr = search_ctx->ffsc_stack_ptr;\n    if (search_ctx->ffsc_stack_ptr != NULL)\n\tsearch_ctx->ffsc_stack_ptr = search_ctx->ffsc_stack_ptr->ffs_prev;\n\n    return sptr;\n}\n\n/*\n * free the given stack element\n */\n    static void\nff_free_stack_element(ff_stack_T *stack_ptr)\n{\n    // vim_free handles possible NULL pointers\n    vim_free(stack_ptr->ffs_fix_path);\n#ifdef FEAT_PATH_EXTRA\n    vim_free(stack_ptr->ffs_wc_path);\n#endif\n\n    if (stack_ptr->ffs_filearray != NULL)\n\tFreeWild(stack_ptr->ffs_filearray_size, stack_ptr->ffs_filearray);\n\n    vim_free(stack_ptr);\n}\n\n/*\n * Clear the search context, but NOT the visited list.\n */\n    static void\nff_clear(ff_search_ctx_T *search_ctx)\n{\n    ff_stack_T   *sptr;\n\n    // clear up stack\n    while ((sptr = ff_pop(search_ctx)) != NULL)\n\tff_free_stack_element(sptr);\n\n    vim_free(search_ctx->ffsc_file_to_search);\n    vim_free(search_ctx->ffsc_start_dir);\n    vim_free(search_ctx->ffsc_fix_path);\n#ifdef FEAT_PATH_EXTRA\n    vim_free(search_ctx->ffsc_wc_path);\n#endif\n\n#ifdef FEAT_PATH_EXTRA\n    if (search_ctx->ffsc_stopdirs_v != NULL)\n    {\n\tint  i = 0;\n\n\twhile (search_ctx->ffsc_stopdirs_v[i] != NULL)\n\t{\n\t    vim_free(search_ctx->ffsc_stopdirs_v[i]);\n\t    i++;\n\t}\n\tvim_free(search_ctx->ffsc_stopdirs_v);\n    }\n    search_ctx->ffsc_stopdirs_v = NULL;\n#endif\n\n    // reset everything\n    search_ctx->ffsc_file_to_search = NULL;\n    search_ctx->ffsc_start_dir = NULL;\n    search_ctx->ffsc_fix_path = NULL;\n#ifdef FEAT_PATH_EXTRA\n    search_ctx->ffsc_wc_path = NULL;\n    search_ctx->ffsc_level = 0;\n#endif\n}\n\n#ifdef FEAT_PATH_EXTRA\n/*\n * check if the given path is in the stopdirs\n * returns TRUE if yes else FALSE\n */\n    static int\nff_path_in_stoplist(char_u *path, int path_len, char_u **stopdirs_v)\n{\n    int\t\ti = 0;\n\n    // eat up trailing path separators, except the first\n    while (path_len > 1 && vim_ispathsep(path[path_len - 1]))\n\tpath_len--;\n\n    // if no path consider it as match\n    if (path_len == 0)\n\treturn TRUE;\n\n    for (i = 0; stopdirs_v[i] != NULL; i++)\n    {\n\tif ((int)STRLEN(stopdirs_v[i]) > path_len)\n\t{\n\t    // match for parent directory. So '/home' also matches\n\t    // '/home/rks'. Check for PATHSEP in stopdirs_v[i], else\n\t    // '/home/r' would also match '/home/rks'\n\t    if (fnamencmp(stopdirs_v[i], path, path_len) == 0\n\t\t    && vim_ispathsep(stopdirs_v[i][path_len]))\n\t\treturn TRUE;\n\t}\n\telse\n\t{\n\t    if (fnamecmp(stopdirs_v[i], path) == 0)\n\t\treturn TRUE;\n\t}\n    }\n    return FALSE;\n}\n#endif\n\n#if defined(FEAT_SEARCHPATH) || defined(PROTO)\n/*\n * Find the file name \"ptr[len]\" in the path.  Also finds directory names.\n *\n * On the first call set the parameter 'first' to TRUE to initialize\n * the search.  For repeating calls to FALSE.\n *\n * Repeating calls will return other files called 'ptr[len]' from the path.\n *\n * Only on the first call 'ptr' and 'len' are used.  For repeating calls they\n * don't need valid values.\n *\n * If nothing found on the first call the option FNAME_MESS will issue the\n * message:\n *\t    'Can't find file \"<file>\" in path'\n * On repeating calls:\n *\t    'No more file \"<file>\" found in path'\n *\n * options:\n * FNAME_MESS\t    give error message when not found\n *\n * Uses NameBuff[]!\n *\n * Returns an allocated string for the file name.  NULL for error.\n *\n */\n    char_u *\nfind_file_in_path(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    int\t\tfirst,\t\t// use count'th matching file name\n    char_u\t*rel_fname)\t// file name searching relative to\n{\n    return find_file_in_path_option(ptr, len, options, first,\n\t    *curbuf->b_p_path == NUL ? p_path : curbuf->b_p_path,\n\t    FINDFILE_BOTH, rel_fname, curbuf->b_p_sua);\n}\n\nstatic char_u\t*ff_file_to_find = NULL;\nstatic void\t*fdip_search_ctx = NULL;\n\n# if defined(EXITFREE) || defined(PROTO)\n    void\nfree_findfile(void)\n{\n    vim_free(ff_file_to_find);\n    vim_findfile_cleanup(fdip_search_ctx);\n    vim_free(ff_expand_buffer);\n}\n# endif\n\n/*\n * Find the directory name \"ptr[len]\" in the path.\n *\n * options:\n * FNAME_MESS\t    give error message when not found\n * FNAME_UNESC\t    unescape backslashes.\n *\n * Uses NameBuff[]!\n *\n * Returns an allocated string for the file name.  NULL for error.\n */\n    char_u *\nfind_directory_in_path(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    char_u\t*rel_fname)\t// file name searching relative to\n{\n    return find_file_in_path_option(ptr, len, options, TRUE, p_cdpath,\n\t\t\t\t       FINDFILE_DIR, rel_fname, (char_u *)\"\");\n}\n\n    char_u *\nfind_file_in_path_option(\n    char_u\t*ptr,\t\t// file name\n    int\t\tlen,\t\t// length of file name\n    int\t\toptions,\n    int\t\tfirst,\t\t// use count'th matching file name\n    char_u\t*path_option,\t// p_path or p_cdpath\n    int\t\tfind_what,\t// FINDFILE_FILE, _DIR or _BOTH\n    char_u\t*rel_fname,\t// file name we are looking relative to.\n    char_u\t*suffixes)\t// list of suffixes, 'suffixesadd' option\n{\n    static char_u\t*dir;\n    static int\t\tdid_findfile_init = FALSE;\n    char_u\t\tsave_char;\n    char_u\t\t*file_name = NULL;\n    char_u\t\t*buf = NULL;\n    int\t\t\trel_to_curdir;\n# ifdef AMIGA\n    struct Process\t*proc = (struct Process *)FindTask(0L);\n    APTR\t\tsave_winptr = proc->pr_WindowPtr;\n\n    // Avoid a requester here for a volume that doesn't exist.\n    proc->pr_WindowPtr = (APTR)-1L;\n# endif\n\n    if (len == 0)\n\treturn NULL;\n\n    if (first == TRUE)\n    {\n\t// copy file name into NameBuff, expanding environment variables\n\tsave_char = ptr[len];\n\tptr[len] = NUL;\n\texpand_env_esc(ptr, NameBuff, MAXPATHL, FALSE, TRUE, NULL);\n\tptr[len] = save_char;\n\n\tvim_free(ff_file_to_find);\n\tff_file_to_find = vim_strsave(NameBuff);\n\tif (ff_file_to_find == NULL)\t// out of memory\n\t{\n\t    file_name = NULL;\n\t    goto theend;\n\t}\n\tif (options & FNAME_UNESC)\n\t{\n\t    // Change all \"\\ \" to \" \".\n\t    for (ptr = ff_file_to_find; *ptr != NUL; ++ptr)\n\t\tif (ptr[0] == '\\\\' && ptr[1] == ' ')\n\t\t    mch_memmove(ptr, ptr + 1, STRLEN(ptr));\n\t}\n    }\n\n    rel_to_curdir = (ff_file_to_find[0] == '.'\n\t\t    && (ff_file_to_find[1] == NUL\n\t\t\t|| vim_ispathsep(ff_file_to_find[1])\n\t\t\t|| (ff_file_to_find[1] == '.'\n\t\t\t    && (ff_file_to_find[2] == NUL\n\t\t\t\t|| vim_ispathsep(ff_file_to_find[2])))));\n    if (vim_isAbsName(ff_file_to_find)\n\t    // \"..\", \"../path\", \".\" and \"./path\": don't use the path_option\n\t    || rel_to_curdir\n# if defined(MSWIN)\n\t    // handle \"\\tmp\" as absolute path\n\t    || vim_ispathsep(ff_file_to_find[0])\n\t    // handle \"c:name\" as absolute path\n\t    || (ff_file_to_find[0] != NUL && ff_file_to_find[1] == ':')\n# endif\n# ifdef AMIGA\n\t    // handle \":tmp\" as absolute path\n\t    || ff_file_to_find[0] == ':'\n# endif\n       )\n    {\n\t/*\n\t * Absolute path, no need to use \"path_option\".\n\t * If this is not a first call, return NULL.  We already returned a\n\t * filename on the first call.\n\t */\n\tif (first == TRUE)\n\t{\n\t    int\t\tl;\n\t    int\t\trun;\n\n\t    if (path_with_url(ff_file_to_find))\n\t    {\n\t\tfile_name = vim_strsave(ff_file_to_find);\n\t\tgoto theend;\n\t    }\n\n\t    // When FNAME_REL flag given first use the directory of the file.\n\t    // Otherwise or when this fails use the current directory.\n\t    for (run = 1; run <= 2; ++run)\n\t    {\n\t\tl = (int)STRLEN(ff_file_to_find);\n\t\tif (run == 1\n\t\t\t&& rel_to_curdir\n\t\t\t&& (options & FNAME_REL)\n\t\t\t&& rel_fname != NULL\n\t\t\t&& STRLEN(rel_fname) + l < MAXPATHL)\n\t\t{\n\t\t    STRCPY(NameBuff, rel_fname);\n\t\t    STRCPY(gettail(NameBuff), ff_file_to_find);\n\t\t    l = (int)STRLEN(NameBuff);\n\t\t}\n\t\telse\n\t\t{\n\t\t    STRCPY(NameBuff, ff_file_to_find);\n\t\t    run = 2;\n\t\t}\n\n\t\t// When the file doesn't exist, try adding parts of\n\t\t// 'suffixesadd'.\n\t\tbuf = suffixes;\n\t\tfor (;;)\n\t\t{\n\t\t    if (mch_getperm(NameBuff) >= 0\n\t\t\t     && (find_what == FINDFILE_BOTH\n\t\t\t\t || ((find_what == FINDFILE_DIR)\n\t\t\t\t\t\t    == mch_isdir(NameBuff))))\n\t\t    {\n\t\t\tfile_name = vim_strsave(NameBuff);\n\t\t\tgoto theend;\n\t\t    }\n\t\t    if (*buf == NUL)\n\t\t\tbreak;\n\t\t    copy_option_part(&buf, NameBuff + l, MAXPATHL - l, \",\");\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t/*\n\t * Loop over all paths in the 'path' or 'cdpath' option.\n\t * When \"first\" is set, first setup to the start of the option.\n\t * Otherwise continue to find the next match.\n\t */\n\tif (first == TRUE)\n\t{\n\t    // vim_findfile_free_visited can handle a possible NULL pointer\n\t    vim_findfile_free_visited(fdip_search_ctx);\n\t    dir = path_option;\n\t    did_findfile_init = FALSE;\n\t}\n\n\tfor (;;)\n\t{\n\t    if (did_findfile_init)\n\t    {\n\t\tfile_name = vim_findfile(fdip_search_ctx);\n\t\tif (file_name != NULL)\n\t\t    break;\n\n\t\tdid_findfile_init = FALSE;\n\t    }\n\t    else\n\t    {\n\t\tchar_u  *r_ptr;\n\n\t\tif (dir == NULL || *dir == NUL)\n\t\t{\n\t\t    // We searched all paths of the option, now we can\n\t\t    // free the search context.\n\t\t    vim_findfile_cleanup(fdip_search_ctx);\n\t\t    fdip_search_ctx = NULL;\n\t\t    break;\n\t\t}\n\n\t\tif ((buf = alloc(MAXPATHL)) == NULL)\n\t\t    break;\n\n\t\t// copy next path\n\t\tbuf[0] = 0;\n\t\tcopy_option_part(&dir, buf, MAXPATHL, \" ,\");\n\n# ifdef FEAT_PATH_EXTRA\n\t\t// get the stopdir string\n\t\tr_ptr = vim_findfile_stopdir(buf);\n# else\n\t\tr_ptr = NULL;\n# endif\n\t\tfdip_search_ctx = vim_findfile_init(buf, ff_file_to_find,\n\t\t\t\t\t    r_ptr, 100, FALSE, find_what,\n\t\t\t\t\t   fdip_search_ctx, FALSE, rel_fname);\n\t\tif (fdip_search_ctx != NULL)\n\t\t    did_findfile_init = TRUE;\n\t\tvim_free(buf);\n\t    }\n\t}\n    }\n    if (file_name == NULL && (options & FNAME_MESS))\n    {\n\tif (first == TRUE)\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E344: Can't find directory \\\"%s\\\" in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E345: Can't find file \\\"%s\\\" in path\"),\n\t\t\tff_file_to_find);\n\t}\n\telse\n\t{\n\t    if (find_what == FINDFILE_DIR)\n\t\tsemsg(_(\"E346: No more directory \\\"%s\\\" found in cdpath\"),\n\t\t\tff_file_to_find);\n\t    else\n\t\tsemsg(_(\"E347: No more file \\\"%s\\\" found in path\"),\n\t\t\tff_file_to_find);\n\t}\n    }\n\ntheend:\n# ifdef AMIGA\n    proc->pr_WindowPtr = save_winptr;\n# endif\n    return file_name;\n}\n\n/*\n * Get the file name at the cursor.\n * If Visual mode is active, use the selected text if it's in one line.\n * Returns the name in allocated memory, NULL for failure.\n */\n    char_u *\ngrab_file_name(long count, linenr_T *file_lnum)\n{\n    int options = FNAME_MESS|FNAME_EXP|FNAME_REL|FNAME_UNESC;\n\n    if (VIsual_active)\n    {\n\tint\tlen;\n\tchar_u\t*ptr;\n\n\tif (get_visual_text(NULL, &ptr, &len) == FAIL)\n\t    return NULL;\n\t// Only recognize \":123\" here\n\tif (file_lnum != NULL && ptr[len] == ':' && isdigit(ptr[len + 1]))\n\t{\n\t    char_u *p = ptr + len + 1;\n\n\t    *file_lnum = getdigits(&p);\n\t}\n\treturn find_file_name_in_path(ptr, len, options,\n\t\t\t\t\t\t     count, curbuf->b_ffname);\n    }\n    return file_name_at_cursor(options | FNAME_HYP, count, file_lnum);\n}\n\n/*\n * Return the file name under or after the cursor.\n *\n * The 'path' option is searched if the file name is not absolute.\n * The string returned has been alloc'ed and should be freed by the caller.\n * NULL is returned if the file name or file is not found.\n *\n * options:\n * FNAME_MESS\t    give error messages\n * FNAME_EXP\t    expand to path\n * FNAME_HYP\t    check for hypertext link\n * FNAME_INCL\t    apply \"includeexpr\"\n */\n    char_u *\nfile_name_at_cursor(int options, long count, linenr_T *file_lnum)\n{\n    return file_name_in_line(ml_get_curline(),\n\t\t      curwin->w_cursor.col, options, count, curbuf->b_ffname,\n\t\t      file_lnum);\n}\n\n/*\n * Return the name of the file under or after ptr[col].\n * Otherwise like file_name_at_cursor().\n */\n    char_u *\nfile_name_in_line(\n    char_u\t*line,\n    int\t\tcol,\n    int\t\toptions,\n    long\tcount,\n    char_u\t*rel_fname,\t// file we are searching relative to\n    linenr_T\t*file_lnum)\t// line number after the file name\n{\n    char_u\t*ptr;\n    int\t\tlen;\n    int\t\tin_type = TRUE;\n    int\t\tis_url = FALSE;\n\n    /*\n     * search forward for what could be the start of a file name\n     */\n    ptr = line + col;\n    while (*ptr != NUL && !vim_isfilec(*ptr))\n\tMB_PTR_ADV(ptr);\n    if (*ptr == NUL)\t\t// nothing found\n    {\n\tif (options & FNAME_MESS)\n\t    emsg(_(\"E446: No file name under cursor\"));\n\treturn NULL;\n    }\n\n    /*\n     * Search backward for first char of the file name.\n     * Go one char back to \":\" before \"//\" even when ':' is not in 'isfname'.\n     */\n    while (ptr > line)\n    {\n\tif (has_mbyte && (len = (*mb_head_off)(line, ptr - 1)) > 0)\n\t    ptr -= len + 1;\n\telse if (vim_isfilec(ptr[-1])\n\t\t|| ((options & FNAME_HYP) && path_is_url(ptr - 1)))\n\t    --ptr;\n\telse\n\t    break;\n    }\n\n    /*\n     * Search forward for the last char of the file name.\n     * Also allow \"://\" when ':' is not in 'isfname'.\n     */\n    len = 0;\n    while (vim_isfilec(ptr[len]) || (ptr[len] == '\\\\' && ptr[len + 1] == ' ')\n\t\t\t || ((options & FNAME_HYP) && path_is_url(ptr + len))\n\t\t\t || (is_url && vim_strchr((char_u *)\":?&=\", ptr[len]) != NULL))\n    {\n\t// After type:// we also include :, ?, & and = as valid characters, so that\n\t// http://google.com:8080?q=this&that=ok works.\n\tif ((ptr[len] >= 'A' && ptr[len] <= 'Z') || (ptr[len] >= 'a' && ptr[len] <= 'z'))\n\t{\n\t    if (in_type && path_is_url(ptr + len + 1))\n\t\tis_url = TRUE;\n\t}\n\telse\n\t    in_type = FALSE;\n\n\tif (ptr[len] == '\\\\')\n\t    // Skip over the \"\\\" in \"\\ \".\n\t    ++len;\n\tif (has_mbyte)\n\t    len += (*mb_ptr2len)(ptr + len);\n\telse\n\t    ++len;\n    }\n\n    /*\n     * If there is trailing punctuation, remove it.\n     * But don't remove \"..\", could be a directory name.\n     */\n    if (len > 2 && vim_strchr((char_u *)\".,:;!\", ptr[len - 1]) != NULL\n\t\t\t\t\t\t       && ptr[len - 2] != '.')\n\t--len;\n\n    if (file_lnum != NULL)\n    {\n\tchar_u *p;\n\tchar\t*line_english = \" line \";\n\tchar\t*line_transl = _(line_msg);\n\n\t// Get the number after the file name and a separator character.\n\t// Also accept \" line 999\" with and without the same translation as\n\t// used in last_set_msg().\n\tp = ptr + len;\n\tif (STRNCMP(p, line_english, STRLEN(line_english)) == 0)\n\t    p += STRLEN(line_english);\n\telse if (STRNCMP(p, line_transl, STRLEN(line_transl)) == 0)\n\t    p += STRLEN(line_transl);\n\telse\n\t    p = skipwhite(p);\n\tif (*p != NUL)\n\t{\n\t    if (!isdigit(*p))\n\t\t++p;\t\t    // skip the separator\n\t    p = skipwhite(p);\n\t    if (isdigit(*p))\n\t\t*file_lnum = (int)getdigits(&p);\n\t}\n    }\n\n    return find_file_name_in_path(ptr, len, options, count, rel_fname);\n}\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    static char_u *\neval_includeexpr(char_u *ptr, int len)\n{\n    char_u\t*res;\n\n    set_vim_var_string(VV_FNAME, ptr, len);\n    res = eval_to_string_safe(curbuf->b_p_inex,\n\t\t      was_set_insecurely((char_u *)\"includeexpr\", OPT_LOCAL));\n    set_vim_var_string(VV_FNAME, NULL, 0);\n    return res;\n}\n# endif\n\n/*\n * Return the name of the file ptr[len] in 'path'.\n * Otherwise like file_name_at_cursor().\n */\n    char_u *\nfind_file_name_in_path(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\toptions,\n    long\tcount,\n    char_u\t*rel_fname)\t// file we are searching relative to\n{\n    char_u\t*file_name;\n    int\t\tc;\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    char_u\t*tofree = NULL;\n# endif\n\n    if (len == 0)\n\treturn NULL;\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    if ((options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n    {\n\ttofree = eval_includeexpr(ptr, len);\n\tif (tofree != NULL)\n\t{\n\t    ptr = tofree;\n\t    len = (int)STRLEN(ptr);\n\t}\n    }\n# endif\n\n    if (options & FNAME_EXP)\n    {\n\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n\t/*\n\t * If the file could not be found in a normal way, try applying\n\t * 'includeexpr' (unless done already).\n\t */\n\tif (file_name == NULL\n\t\t&& !(options & FNAME_INCL) && *curbuf->b_p_inex != NUL)\n\t{\n\t    tofree = eval_includeexpr(ptr, len);\n\t    if (tofree != NULL)\n\t    {\n\t\tptr = tofree;\n\t\tlen = (int)STRLEN(ptr);\n\t\tfile_name = find_file_in_path(ptr, len, options & ~FNAME_MESS,\n\t\t\t\t\t\t\t     TRUE, rel_fname);\n\t    }\n\t}\n# endif\n\tif (file_name == NULL && (options & FNAME_MESS))\n\t{\n\t    c = ptr[len];\n\t    ptr[len] = NUL;\n\t    semsg(_(\"E447: Can't find file \\\"%s\\\" in path\"), ptr);\n\t    ptr[len] = c;\n\t}\n\n\t// Repeat finding the file \"count\" times.  This matters when it\n\t// appears several times in the path.\n\twhile (file_name != NULL && --count > 0)\n\t{\n\t    vim_free(file_name);\n\t    file_name = find_file_in_path(ptr, len, options, FALSE, rel_fname);\n\t}\n    }\n    else\n\tfile_name = vim_strnsave(ptr, len);\n\n# if defined(FEAT_FIND_ID) && defined(FEAT_EVAL)\n    vim_free(tofree);\n# endif\n\n    return file_name;\n}\n\n/*\n * Return the end of the directory name, on the first path\n * separator:\n * \"/path/file\", \"/path/dir/\", \"/path//dir\", \"/file\"\n *\t ^\t       ^\t     ^\t      ^\n */\n    static char_u *\ngettail_dir(char_u *fname)\n{\n    char_u\t*dir_end = fname;\n    char_u\t*next_dir_end = fname;\n    int\t\tlook_for_sep = TRUE;\n    char_u\t*p;\n\n    for (p = fname; *p != NUL; )\n    {\n\tif (vim_ispathsep(*p))\n\t{\n\t    if (look_for_sep)\n\t    {\n\t\tnext_dir_end = p;\n\t\tlook_for_sep = FALSE;\n\t    }\n\t}\n\telse\n\t{\n\t    if (!look_for_sep)\n\t\tdir_end = next_dir_end;\n\t    look_for_sep = TRUE;\n\t}\n\tMB_PTR_ADV(p);\n    }\n    return dir_end;\n}\n\n/*\n * return TRUE if 'c' is a path list separator.\n */\n    int\nvim_ispathlistsep(int c)\n{\n# ifdef UNIX\n    return (c == ':');\n# else\n    return (c == ';');\t// might not be right for every system...\n# endif\n}\n\n/*\n * Moves \"*psep\" back to the previous path separator in \"path\".\n * Returns FAIL is \"*psep\" ends up at the beginning of \"path\".\n */\n    static int\nfind_previous_pathsep(char_u *path, char_u **psep)\n{\n    // skip the current separator\n    if (*psep > path && vim_ispathsep(**psep))\n\t--*psep;\n\n    // find the previous separator\n    while (*psep > path)\n    {\n\tif (vim_ispathsep(**psep))\n\t    return OK;\n\tMB_PTR_BACK(path, *psep);\n    }\n\n    return FAIL;\n}\n\n/*\n * Returns TRUE if \"maybe_unique\" is unique wrt other_paths in \"gap\".\n * \"maybe_unique\" is the end portion of \"((char_u **)gap->ga_data)[i]\".\n */\n    static int\nis_unique(char_u *maybe_unique, garray_T *gap, int i)\n{\n    int\t    j;\n    int\t    candidate_len;\n    int\t    other_path_len;\n    char_u  **other_paths = (char_u **)gap->ga_data;\n    char_u  *rival;\n\n    for (j = 0; j < gap->ga_len; j++)\n    {\n\tif (j == i)\n\t    continue;  // don't compare it with itself\n\n\tcandidate_len = (int)STRLEN(maybe_unique);\n\tother_path_len = (int)STRLEN(other_paths[j]);\n\tif (other_path_len < candidate_len)\n\t    continue;  // it's different when it's shorter\n\n\trival = other_paths[j] + other_path_len - candidate_len;\n\tif (fnamecmp(maybe_unique, rival) == 0\n\t\t&& (rival == other_paths[j] || vim_ispathsep(*(rival - 1))))\n\t    return FALSE;  // match\n    }\n\n    return TRUE;  // no match found\n}\n\n/*\n * Split the 'path' option into an array of strings in garray_T.  Relative\n * paths are expanded to their equivalent fullpath.  This includes the \".\"\n * (relative to current buffer directory) and empty path (relative to current\n * directory) notations.\n *\n * TODO: handle upward search (;) and path limiter (**N) notations by\n * expanding each into their equivalent path(s).\n */\n    static void\nexpand_path_option(char_u *curdir, garray_T *gap)\n{\n    char_u\t*path_option = *curbuf->b_p_path == NUL\n\t\t\t\t\t\t  ? p_path : curbuf->b_p_path;\n    char_u\t*buf;\n    char_u\t*p;\n    int\t\tlen;\n\n    if ((buf = alloc(MAXPATHL)) == NULL)\n\treturn;\n\n    while (*path_option != NUL)\n    {\n\tcopy_option_part(&path_option, buf, MAXPATHL, \" ,\");\n\n\tif (buf[0] == '.' && (buf[1] == NUL || vim_ispathsep(buf[1])))\n\t{\n\t    // Relative to current buffer:\n\t    // \"/path/file\" + \".\" -> \"/path/\"\n\t    // \"/path/file\"  + \"./subdir\" -> \"/path/subdir\"\n\t    if (curbuf->b_ffname == NULL)\n\t\tcontinue;\n\t    p = gettail(curbuf->b_ffname);\n\t    len = (int)(p - curbuf->b_ffname);\n\t    if (len + (int)STRLEN(buf) >= MAXPATHL)\n\t\tcontinue;\n\t    if (buf[1] == NUL)\n\t\tbuf[len] = NUL;\n\t    else\n\t\tSTRMOVE(buf + len, buf + 2);\n\t    mch_memmove(buf, curbuf->b_ffname, len);\n\t    simplify_filename(buf);\n\t}\n\telse if (buf[0] == NUL)\n\t    // relative to current directory\n\t    STRCPY(buf, curdir);\n\telse if (path_with_url(buf))\n\t    // URL can't be used here\n\t    continue;\n\telse if (!mch_isFullName(buf))\n\t{\n\t    // Expand relative path to their full path equivalent\n\t    len = (int)STRLEN(curdir);\n\t    if (len + (int)STRLEN(buf) + 3 > MAXPATHL)\n\t\tcontinue;\n\t    STRMOVE(buf + len + 1, buf);\n\t    STRCPY(buf, curdir);\n\t    buf[len] = PATHSEP;\n\t    simplify_filename(buf);\n\t}\n\n\tif (ga_grow(gap, 1) == FAIL)\n\t    break;\n\n# if defined(MSWIN)\n\t// Avoid the path ending in a backslash, it fails when a comma is\n\t// appended.\n\tlen = (int)STRLEN(buf);\n\tif (buf[len - 1] == '\\\\')\n\t    buf[len - 1] = '/';\n# endif\n\n\tp = vim_strsave(buf);\n\tif (p == NULL)\n\t    break;\n\t((char_u **)gap->ga_data)[gap->ga_len++] = p;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Returns a pointer to the file or directory name in \"fname\" that matches the\n * longest path in \"ga\"p, or NULL if there is no match. For example:\n *\n *    path: /foo/bar/baz\n *   fname: /foo/bar/baz/quux.txt\n * returns:\t\t ^this\n */\n    static char_u *\nget_path_cutoff(char_u *fname, garray_T *gap)\n{\n    int\t    i;\n    int\t    maxlen = 0;\n    char_u  **path_part = (char_u **)gap->ga_data;\n    char_u  *cutoff = NULL;\n\n    for (i = 0; i < gap->ga_len; i++)\n    {\n\tint j = 0;\n\n\twhile ((fname[j] == path_part[i][j]\n# if defined(MSWIN)\n\t\t|| (vim_ispathsep(fname[j]) && vim_ispathsep(path_part[i][j]))\n# endif\n\t\t\t     ) && fname[j] != NUL && path_part[i][j] != NUL)\n\t    j++;\n\tif (j > maxlen)\n\t{\n\t    maxlen = j;\n\t    cutoff = &fname[j];\n\t}\n    }\n\n    // skip to the file or directory name\n    if (cutoff != NULL)\n\twhile (vim_ispathsep(*cutoff))\n\t    MB_PTR_ADV(cutoff);\n\n    return cutoff;\n}\n\n/*\n * Sorts, removes duplicates and modifies all the fullpath names in \"gap\" so\n * that they are unique with respect to each other while conserving the part\n * that matches the pattern. Beware, this is at least O(n^2) wrt \"gap->ga_len\".\n */\n    void\nuniquefy_paths(garray_T *gap, char_u *pattern)\n{\n    int\t\ti;\n    int\t\tlen;\n    char_u\t**fnames = (char_u **)gap->ga_data;\n    int\t\tsort_again = FALSE;\n    char_u\t*pat;\n    char_u      *file_pattern;\n    char_u\t*curdir;\n    regmatch_T\tregmatch;\n    garray_T\tpath_ga;\n    char_u\t**in_curdir = NULL;\n    char_u\t*short_name;\n\n    remove_duplicates(gap);\n    ga_init2(&path_ga, (int)sizeof(char_u *), 1);\n\n    /*\n     * We need to prepend a '*' at the beginning of file_pattern so that the\n     * regex matches anywhere in the path. FIXME: is this valid for all\n     * possible patterns?\n     */\n    len = (int)STRLEN(pattern);\n    file_pattern = alloc(len + 2);\n    if (file_pattern == NULL)\n\treturn;\n    file_pattern[0] = '*';\n    file_pattern[1] = NUL;\n    STRCAT(file_pattern, pattern);\n    pat = file_pat_to_reg_pat(file_pattern, NULL, NULL, TRUE);\n    vim_free(file_pattern);\n    if (pat == NULL)\n\treturn;\n\n    regmatch.rm_ic = TRUE;\t\t// always ignore case\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC + RE_STRING);\n    vim_free(pat);\n    if (regmatch.regprog == NULL)\n\treturn;\n\n    if ((curdir = alloc(MAXPATHL)) == NULL)\n\tgoto theend;\n    mch_dirname(curdir, MAXPATHL);\n    expand_path_option(curdir, &path_ga);\n\n    in_curdir = ALLOC_CLEAR_MULT(char_u *, gap->ga_len);\n    if (in_curdir == NULL)\n\tgoto theend;\n\n    for (i = 0; i < gap->ga_len && !got_int; i++)\n    {\n\tchar_u\t    *path = fnames[i];\n\tint\t    is_in_curdir;\n\tchar_u\t    *dir_end = gettail_dir(path);\n\tchar_u\t    *pathsep_p;\n\tchar_u\t    *path_cutoff;\n\n\tlen = (int)STRLEN(path);\n\tis_in_curdir = fnamencmp(curdir, path, dir_end - path) == 0\n\t\t\t\t\t     && curdir[dir_end - path] == NUL;\n\tif (is_in_curdir)\n\t    in_curdir[i] = vim_strsave(path);\n\n\t// Shorten the filename while maintaining its uniqueness\n\tpath_cutoff = get_path_cutoff(path, &path_ga);\n\n\t// Don't assume all files can be reached without path when search\n\t// pattern starts with star star slash, so only remove path_cutoff\n\t// when possible.\n\tif (pattern[0] == '*' && pattern[1] == '*'\n\t\t&& vim_ispathsep_nocolon(pattern[2])\n\t\t&& path_cutoff != NULL\n\t\t&& vim_regexec(&regmatch, path_cutoff, (colnr_T)0)\n\t\t&& is_unique(path_cutoff, gap, i))\n\t{\n\t    sort_again = TRUE;\n\t    mch_memmove(path, path_cutoff, STRLEN(path_cutoff) + 1);\n\t}\n\telse\n\t{\n\t    // Here all files can be reached without path, so get shortest\n\t    // unique path.  We start at the end of the path.\n\t    pathsep_p = path + len - 1;\n\n\t    while (find_previous_pathsep(path, &pathsep_p))\n\t\tif (vim_regexec(&regmatch, pathsep_p + 1, (colnr_T)0)\n\t\t\t&& is_unique(pathsep_p + 1, gap, i)\n\t\t\t&& path_cutoff != NULL && pathsep_p + 1 >= path_cutoff)\n\t\t{\n\t\t    sort_again = TRUE;\n\t\t    mch_memmove(path, pathsep_p + 1, STRLEN(pathsep_p));\n\t\t    break;\n\t\t}\n\t}\n\n\tif (mch_isFullName(path))\n\t{\n\t    /*\n\t     * Last resort: shorten relative to curdir if possible.\n\t     * 'possible' means:\n\t     * 1. It is under the current directory.\n\t     * 2. The result is actually shorter than the original.\n\t     *\n\t     *\t    Before\t\t  curdir\tAfter\n\t     *\t    /foo/bar/file.txt\t  /foo/bar\t./file.txt\n\t     *\t    c:\\foo\\bar\\file.txt   c:\\foo\\bar\t.\\file.txt\n\t     *\t    /file.txt\t\t  /\t\t/file.txt\n\t     *\t    c:\\file.txt\t\t  c:\\\t\t.\\file.txt\n\t     */\n\t    short_name = shorten_fname(path, curdir);\n\t    if (short_name != NULL && short_name > path + 1\n# if defined(MSWIN)\n\t\t    // On windows,\n\t\t    //\t    shorten_fname(\"c:\\a\\a.txt\", \"c:\\a\\b\")\n\t\t    // returns \"\\a\\a.txt\", which is not really the short\n\t\t    // name, hence:\n\t\t    && !vim_ispathsep(*short_name)\n# endif\n\t\t)\n\t    {\n\t\tSTRCPY(path, \".\");\n\t\tadd_pathsep(path);\n\t\tSTRMOVE(path + STRLEN(path), short_name);\n\t    }\n\t}\n\tui_breakcheck();\n    }\n\n    // Shorten filenames in /in/current/directory/{filename}\n    for (i = 0; i < gap->ga_len && !got_int; i++)\n    {\n\tchar_u *rel_path;\n\tchar_u *path = in_curdir[i];\n\n\tif (path == NULL)\n\t    continue;\n\n\t// If the {filename} is not unique, change it to ./{filename}.\n\t// Else reduce it to {filename}\n\tshort_name = shorten_fname(path, curdir);\n\tif (short_name == NULL)\n\t    short_name = path;\n\tif (is_unique(short_name, gap, i))\n\t{\n\t    STRCPY(fnames[i], short_name);\n\t    continue;\n\t}\n\n\trel_path = alloc(STRLEN(short_name) + STRLEN(PATHSEPSTR) + 2);\n\tif (rel_path == NULL)\n\t    goto theend;\n\tSTRCPY(rel_path, \".\");\n\tadd_pathsep(rel_path);\n\tSTRCAT(rel_path, short_name);\n\n\tvim_free(fnames[i]);\n\tfnames[i] = rel_path;\n\tsort_again = TRUE;\n\tui_breakcheck();\n    }\n\ntheend:\n    vim_free(curdir);\n    if (in_curdir != NULL)\n    {\n\tfor (i = 0; i < gap->ga_len; i++)\n\t    vim_free(in_curdir[i]);\n\tvim_free(in_curdir);\n    }\n    ga_clear_strings(&path_ga);\n    vim_regfree(regmatch.regprog);\n\n    if (sort_again)\n\tremove_duplicates(gap);\n}\n\n/*\n * Calls globpath() with 'path' values for the given pattern and stores the\n * result in \"gap\".\n * Returns the total number of matches.\n */\n    int\nexpand_in_path(\n    garray_T\t*gap,\n    char_u\t*pattern,\n    int\t\tflags)\t\t// EW_* flags\n{\n    char_u\t*curdir;\n    garray_T\tpath_ga;\n    char_u\t*paths = NULL;\n    int\t\tglob_flags = 0;\n\n    if ((curdir = alloc(MAXPATHL)) == NULL)\n\treturn 0;\n    mch_dirname(curdir, MAXPATHL);\n\n    ga_init2(&path_ga, (int)sizeof(char_u *), 1);\n    expand_path_option(curdir, &path_ga);\n    vim_free(curdir);\n    if (path_ga.ga_len == 0)\n\treturn 0;\n\n    paths = ga_concat_strings(&path_ga, \",\");\n    ga_clear_strings(&path_ga);\n    if (paths == NULL)\n\treturn 0;\n\n    if (flags & EW_ICASE)\n\tglob_flags |= WILD_ICASE;\n    if (flags & EW_ADDSLASH)\n\tglob_flags |= WILD_ADD_SLASH;\n    globpath(paths, pattern, gap, glob_flags);\n    vim_free(paths);\n\n    return gap->ga_len;\n}\n\n#endif // FEAT_SEARCHPATH\n\n/*\n * Converts a file name into a canonical form. It simplifies a file name into\n * its simplest form by stripping out unneeded components, if any.  The\n * resulting file name is simplified in place and will either be the same\n * length as that supplied, or shorter.\n */\n    void\nsimplify_filename(char_u *filename)\n{\n#ifndef AMIGA\t    // Amiga doesn't have \"..\", it uses \"/\"\n    int\t\tcomponents = 0;\n    char_u\t*p, *tail, *start;\n    int\t\tstripping_disabled = FALSE;\n    int\t\trelative = TRUE;\n\n    p = filename;\n# ifdef BACKSLASH_IN_FILENAME\n    if (p[1] == ':')\t    // skip \"x:\"\n\tp += 2;\n# endif\n\n    if (vim_ispathsep(*p))\n    {\n\trelative = FALSE;\n\tdo\n\t    ++p;\n\twhile (vim_ispathsep(*p));\n    }\n    start = p;\t    // remember start after \"c:/\" or \"/\" or \"///\"\n#ifdef UNIX\n    // Posix says that \"//path\" is unchanged but \"///path\" is \"/path\".\n    if (start > filename + 2)\n    {\n\tSTRMOVE(filename + 1, p);\n\tstart = p = filename + 1;\n    }\n#endif\n\n    do\n    {\n\t// At this point \"p\" is pointing to the char following a single \"/\"\n\t// or \"p\" is at the \"start\" of the (absolute or relative) path name.\n# ifdef VMS\n\t// VMS allows device:[path] - don't strip the [ in directory\n\tif ((*p == '[' || *p == '<') && p > filename && p[-1] == ':')\n\t{\n\t    // :[ or :< composition: vms directory component\n\t    ++components;\n\t    p = getnextcomp(p + 1);\n\t}\n\t// allow remote calls as host\"user passwd\"::device:[path]\n\telse if (p[0] == ':' && p[1] == ':' && p > filename && p[-1] == '\"' )\n\t{\n\t    // \":: composition: vms host/passwd component\n\t    ++components;\n\t    p = getnextcomp(p + 2);\n\t}\n\telse\n# endif\n\t  if (vim_ispathsep(*p))\n\t    STRMOVE(p, p + 1);\t\t// remove duplicate \"/\"\n\telse if (p[0] == '.' && (vim_ispathsep(p[1]) || p[1] == NUL))\n\t{\n\t    if (p == start && relative)\n\t\tp += 1 + (p[1] != NUL);\t// keep single \".\" or leading \"./\"\n\t    else\n\t    {\n\t\t// Strip \"./\" or \".///\".  If we are at the end of the file name\n\t\t// and there is no trailing path separator, either strip \"/.\" if\n\t\t// we are after \"start\", or strip \".\" if we are at the beginning\n\t\t// of an absolute path name .\n\t\ttail = p + 1;\n\t\tif (p[1] != NUL)\n\t\t    while (vim_ispathsep(*tail))\n\t\t\tMB_PTR_ADV(tail);\n\t\telse if (p > start)\n\t\t    --p;\t\t// strip preceding path separator\n\t\tSTRMOVE(p, tail);\n\t    }\n\t}\n\telse if (p[0] == '.' && p[1] == '.' &&\n\t    (vim_ispathsep(p[2]) || p[2] == NUL))\n\t{\n\t    // Skip to after \"..\" or \"../\" or \"..///\".\n\t    tail = p + 2;\n\t    while (vim_ispathsep(*tail))\n\t\tMB_PTR_ADV(tail);\n\n\t    if (components > 0)\t\t// strip one preceding component\n\t    {\n\t\tint\t\tdo_strip = FALSE;\n\t\tchar_u\t\tsaved_char;\n\t\tstat_T\t\tst;\n\n\t\t// Don't strip for an erroneous file name.\n\t\tif (!stripping_disabled)\n\t\t{\n\t\t    // If the preceding component does not exist in the file\n\t\t    // system, we strip it.  On Unix, we don't accept a symbolic\n\t\t    // link that refers to a non-existent file.\n\t\t    saved_char = p[-1];\n\t\t    p[-1] = NUL;\n# ifdef UNIX\n\t\t    if (mch_lstat((char *)filename, &st) < 0)\n# else\n\t\t\tif (mch_stat((char *)filename, &st) < 0)\n# endif\n\t\t\t    do_strip = TRUE;\n\t\t    p[-1] = saved_char;\n\n\t\t    --p;\n\t\t    // Skip back to after previous '/'.\n\t\t    while (p > start && !after_pathsep(start, p))\n\t\t\tMB_PTR_BACK(start, p);\n\n\t\t    if (!do_strip)\n\t\t    {\n\t\t\t// If the component exists in the file system, check\n\t\t\t// that stripping it won't change the meaning of the\n\t\t\t// file name.  First get information about the\n\t\t\t// unstripped file name.  This may fail if the component\n\t\t\t// to strip is not a searchable directory (but a regular\n\t\t\t// file, for instance), since the trailing \"/..\" cannot\n\t\t\t// be applied then.  We don't strip it then since we\n\t\t\t// don't want to replace an erroneous file name by\n\t\t\t// a valid one, and we disable stripping of later\n\t\t\t// components.\n\t\t\tsaved_char = *tail;\n\t\t\t*tail = NUL;\n\t\t\tif (mch_stat((char *)filename, &st) >= 0)\n\t\t\t    do_strip = TRUE;\n\t\t\telse\n\t\t\t    stripping_disabled = TRUE;\n\t\t\t*tail = saved_char;\n# ifdef UNIX\n\t\t\tif (do_strip)\n\t\t\t{\n\t\t\t    stat_T\tnew_st;\n\n\t\t\t    // On Unix, the check for the unstripped file name\n\t\t\t    // above works also for a symbolic link pointing to\n\t\t\t    // a searchable directory.  But then the parent of\n\t\t\t    // the directory pointed to by the link must be the\n\t\t\t    // same as the stripped file name.  (The latter\n\t\t\t    // exists in the file system since it is the\n\t\t\t    // component's parent directory.)\n\t\t\t    if (p == start && relative)\n\t\t\t\t(void)mch_stat(\".\", &new_st);\n\t\t\t    else\n\t\t\t    {\n\t\t\t\tsaved_char = *p;\n\t\t\t\t*p = NUL;\n\t\t\t\t(void)mch_stat((char *)filename, &new_st);\n\t\t\t\t*p = saved_char;\n\t\t\t    }\n\n\t\t\t    if (new_st.st_ino != st.st_ino ||\n\t\t\t\tnew_st.st_dev != st.st_dev)\n\t\t\t    {\n\t\t\t\tdo_strip = FALSE;\n\t\t\t\t// We don't disable stripping of later\n\t\t\t\t// components since the unstripped path name is\n\t\t\t\t// still valid.\n\t\t\t    }\n\t\t\t}\n# endif\n\t\t    }\n\t\t}\n\n\t\tif (!do_strip)\n\t\t{\n\t\t    // Skip the \"..\" or \"../\" and reset the counter for the\n\t\t    // components that might be stripped later on.\n\t\t    p = tail;\n\t\t    components = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // Strip previous component.  If the result would get empty\n\t\t    // and there is no trailing path separator, leave a single\n\t\t    // \".\" instead.  If we are at the end of the file name and\n\t\t    // there is no trailing path separator and a preceding\n\t\t    // component is left after stripping, strip its trailing\n\t\t    // path separator as well.\n\t\t    if (p == start && relative && tail[-1] == '.')\n\t\t    {\n\t\t\t*p++ = '.';\n\t\t\t*p = NUL;\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tif (p > start && tail[-1] == '.')\n\t\t\t    --p;\n\t\t\tSTRMOVE(p, tail);\t// strip previous component\n\t\t    }\n\n\t\t    --components;\n\t\t}\n\t    }\n\t    else if (p == start && !relative)\t// leading \"/..\" or \"/../\"\n\t\tSTRMOVE(p, tail);\t\t// strip \"..\" or \"../\"\n\t    else\n\t    {\n\t\tif (p == start + 2 && p[-2] == '.')\t// leading \"./../\"\n\t\t{\n\t\t    STRMOVE(p - 2, p);\t\t\t// strip leading \"./\"\n\t\t    tail -= 2;\n\t\t}\n\t\tp = tail;\t\t// skip to char after \"..\" or \"../\"\n\t    }\n\t}\n\telse\n\t{\n\t    ++components;\t\t// simple path component\n\t    p = getnextcomp(p);\n\t}\n    } while (*p != NUL);\n#endif // !AMIGA\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * \"simplify()\" function\n */\n    void\nf_simplify(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*p;\n\n    if (in_vim9script() && check_for_string_arg(argvars, 0) == FAIL)\n\treturn;\n\n    p = tv_get_string_strict(&argvars[0]);\n    rettv->vval.v_string = vim_strsave(p);\n    simplify_filename(rettv->vval.v_string);\t// simplify in place\n    rettv->v_type = VAR_STRING;\n}\n#endif // FEAT_EVAL\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n/*\n * normal.c:\tContains the main routine for processing characters in command\n *\t\tmode.  Communicates closely with the code in ops.c to handle\n *\t\tthe operators.\n */\n\n#include \"vim.h\"\n\nstatic int\tVIsual_mode_orig = NUL;\t\t// saved Visual mode\n\n#ifdef FEAT_EVAL\nstatic void\tset_vcount_ca(cmdarg_T *cap, int *set_prevcount);\n#endif\nstatic int\tnv_compare(const void *s1, const void *s2);\nstatic void\tunshift_special(cmdarg_T *cap);\n#ifdef FEAT_CMDL_INFO\nstatic void\tdel_from_showcmd(int);\n#endif\n\n/*\n * nv_*(): functions called to handle Normal and Visual mode commands.\n * n_*(): functions called to handle Normal mode commands.\n * v_*(): functions called to handle Visual mode commands.\n */\nstatic void\tnv_ignore(cmdarg_T *cap);\nstatic void\tnv_nop(cmdarg_T *cap);\nstatic void\tnv_error(cmdarg_T *cap);\nstatic void\tnv_help(cmdarg_T *cap);\nstatic void\tnv_addsub(cmdarg_T *cap);\nstatic void\tnv_page(cmdarg_T *cap);\nstatic void\tnv_zet(cmdarg_T *cap);\n#ifdef FEAT_GUI\nstatic void\tnv_ver_scrollbar(cmdarg_T *cap);\nstatic void\tnv_hor_scrollbar(cmdarg_T *cap);\n#endif\n#ifdef FEAT_GUI_TABLINE\nstatic void\tnv_tabline(cmdarg_T *cap);\nstatic void\tnv_tabmenu(cmdarg_T *cap);\n#endif\nstatic void\tnv_exmode(cmdarg_T *cap);\nstatic void\tnv_colon(cmdarg_T *cap);\nstatic void\tnv_ctrlg(cmdarg_T *cap);\nstatic void\tnv_ctrlh(cmdarg_T *cap);\nstatic void\tnv_clear(cmdarg_T *cap);\nstatic void\tnv_ctrlo(cmdarg_T *cap);\nstatic void\tnv_hat(cmdarg_T *cap);\nstatic void\tnv_Zet(cmdarg_T *cap);\nstatic void\tnv_ident(cmdarg_T *cap);\nstatic void\tnv_tagpop(cmdarg_T *cap);\nstatic void\tnv_scroll(cmdarg_T *cap);\nstatic void\tnv_right(cmdarg_T *cap);\nstatic void\tnv_left(cmdarg_T *cap);\nstatic void\tnv_up(cmdarg_T *cap);\nstatic void\tnv_down(cmdarg_T *cap);\nstatic void\tnv_end(cmdarg_T *cap);\nstatic void\tnv_dollar(cmdarg_T *cap);\nstatic void\tnv_search(cmdarg_T *cap);\nstatic void\tnv_next(cmdarg_T *cap);\nstatic int\tnormal_search(cmdarg_T *cap, int dir, char_u *pat, int opt, int *wrapped);\nstatic void\tnv_csearch(cmdarg_T *cap);\nstatic void\tnv_brackets(cmdarg_T *cap);\nstatic void\tnv_percent(cmdarg_T *cap);\nstatic void\tnv_brace(cmdarg_T *cap);\nstatic void\tnv_mark(cmdarg_T *cap);\nstatic void\tnv_findpar(cmdarg_T *cap);\nstatic void\tnv_undo(cmdarg_T *cap);\nstatic void\tnv_kundo(cmdarg_T *cap);\nstatic void\tnv_Replace(cmdarg_T *cap);\nstatic void\tnv_replace(cmdarg_T *cap);\nstatic void\tnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos);\nstatic void\tv_visop(cmdarg_T *cap);\nstatic void\tnv_subst(cmdarg_T *cap);\nstatic void\tnv_abbrev(cmdarg_T *cap);\nstatic void\tnv_optrans(cmdarg_T *cap);\nstatic void\tnv_gomark(cmdarg_T *cap);\nstatic void\tnv_pcmark(cmdarg_T *cap);\nstatic void\tnv_regname(cmdarg_T *cap);\nstatic void\tnv_visual(cmdarg_T *cap);\nstatic void\tn_start_visual_mode(int c);\nstatic void\tnv_window(cmdarg_T *cap);\nstatic void\tnv_suspend(cmdarg_T *cap);\nstatic void\tnv_g_cmd(cmdarg_T *cap);\nstatic void\tnv_dot(cmdarg_T *cap);\nstatic void\tnv_redo(cmdarg_T *cap);\nstatic void\tnv_Undo(cmdarg_T *cap);\nstatic void\tnv_tilde(cmdarg_T *cap);\nstatic void\tnv_operator(cmdarg_T *cap);\n#ifdef FEAT_EVAL\nstatic void\tset_op_var(int optype);\n#endif\nstatic void\tnv_lineop(cmdarg_T *cap);\nstatic void\tnv_home(cmdarg_T *cap);\nstatic void\tnv_pipe(cmdarg_T *cap);\nstatic void\tnv_bck_word(cmdarg_T *cap);\nstatic void\tnv_wordcmd(cmdarg_T *cap);\nstatic void\tnv_beginline(cmdarg_T *cap);\nstatic void\tadjust_cursor(oparg_T *oap);\nstatic void\tadjust_for_sel(cmdarg_T *cap);\nstatic void\tnv_select(cmdarg_T *cap);\nstatic void\tnv_goto(cmdarg_T *cap);\nstatic void\tnv_normal(cmdarg_T *cap);\nstatic void\tnv_esc(cmdarg_T *oap);\nstatic void\tnv_edit(cmdarg_T *cap);\nstatic void\tinvoke_edit(cmdarg_T *cap, int repl, int cmd, int startln);\n#ifdef FEAT_TEXTOBJ\nstatic void\tnv_object(cmdarg_T *cap);\n#endif\nstatic void\tnv_record(cmdarg_T *cap);\nstatic void\tnv_at(cmdarg_T *cap);\nstatic void\tnv_halfpage(cmdarg_T *cap);\nstatic void\tnv_join(cmdarg_T *cap);\nstatic void\tnv_put(cmdarg_T *cap);\nstatic void\tnv_put_opt(cmdarg_T *cap, int fix_indent);\nstatic void\tnv_open(cmdarg_T *cap);\n#ifdef FEAT_NETBEANS_INTG\nstatic void\tnv_nbcmd(cmdarg_T *cap);\n#endif\n#ifdef FEAT_DND\nstatic void\tnv_drop(cmdarg_T *cap);\n#endif\nstatic void\tnv_cursorhold(cmdarg_T *cap);\n\nstatic char *e_noident = N_(\"E349: No identifier under cursor\");\n\n/*\n * Function to be called for a Normal or Visual mode command.\n * The argument is a cmdarg_T.\n */\ntypedef void (*nv_func_T)(cmdarg_T *cap);\n\n// Values for cmd_flags.\n#define NV_NCH\t    0x01\t  // may need to get a second char\n#define NV_NCH_NOP  (0x02|NV_NCH) // get second char when no operator pending\n#define NV_NCH_ALW  (0x04|NV_NCH) // always get a second char\n#define NV_LANG\t    0x08\t// second char needs language adjustment\n\n#define NV_SS\t    0x10\t// may start selection\n#define NV_SSS\t    0x20\t// may start selection with shift modifier\n#define NV_STS\t    0x40\t// may stop selection without shift modif.\n#define NV_RL\t    0x80\t// 'rightleft' modifies command\n#define NV_KEEPREG  0x100\t// don't clear regname\n#define NV_NCW\t    0x200\t// not allowed in command-line window\n\n/*\n * Generally speaking, every Normal mode command should either clear any\n * pending operator (with *clearop*()), or set the motion type variable\n * oap->motion_type.\n *\n * When a cursor motion command is made, it is marked as being a character or\n * line oriented motion.  Then, if an operator is in effect, the operation\n * becomes character or line oriented accordingly.\n */\n\n/*\n * This table contains one entry for every Normal or Visual mode command.\n * The order doesn't matter, init_normal_cmds() will create a sorted index.\n * It is faster when all keys from zero to '~' are present.\n */\nstatic const struct nv_cmd\n{\n    int\t\tcmd_char;\t// (first) command character\n    nv_func_T   cmd_func;\t// function for this command\n    short_u\tcmd_flags;\t// NV_ flags\n    short\tcmd_arg;\t// value for ca.arg\n} nv_cmds[] =\n{\n    {NUL,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_A,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_B,\tnv_page,\tNV_STS,\t\t\tBACKWARD},\n    {Ctrl_C,\tnv_esc,\t\t0,\t\t\tTRUE},\n    {Ctrl_D,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_E,\tnv_scroll_line,\t0,\t\t\tTRUE},\n    {Ctrl_F,\tnv_page,\tNV_STS,\t\t\tFORWARD},\n    {Ctrl_G,\tnv_ctrlg,\t0,\t\t\t0},\n    {Ctrl_H,\tnv_ctrlh,\t0,\t\t\t0},\n    {Ctrl_I,\tnv_pcmark,\t0,\t\t\t0},\n    {NL,\tnv_down,\t0,\t\t\tFALSE},\n    {Ctrl_K,\tnv_error,\t0,\t\t\t0},\n    {Ctrl_L,\tnv_clear,\t0,\t\t\t0},\n    {CAR,\tnv_down,\t0,\t\t\tTRUE},\n    {Ctrl_N,\tnv_down,\tNV_STS,\t\t\tFALSE},\n    {Ctrl_O,\tnv_ctrlo,\t0,\t\t\t0},\n    {Ctrl_P,\tnv_up,\t\tNV_STS,\t\t\tFALSE},\n    {Ctrl_Q,\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_R,\tnv_redo,\t0,\t\t\t0},\n    {Ctrl_S,\tnv_ignore,\t0,\t\t\t0},\n    {Ctrl_T,\tnv_tagpop,\tNV_NCW,\t\t\t0},\n    {Ctrl_U,\tnv_halfpage,\t0,\t\t\t0},\n    {Ctrl_V,\tnv_visual,\t0,\t\t\tFALSE},\n    {'V',\tnv_visual,\t0,\t\t\tFALSE},\n    {'v',\tnv_visual,\t0,\t\t\tFALSE},\n    {Ctrl_W,\tnv_window,\t0,\t\t\t0},\n    {Ctrl_X,\tnv_addsub,\t0,\t\t\t0},\n    {Ctrl_Y,\tnv_scroll_line,\t0,\t\t\tFALSE},\n    {Ctrl_Z,\tnv_suspend,\t0,\t\t\t0},\n    {ESC,\tnv_esc,\t\t0,\t\t\tFALSE},\n    {Ctrl_BSL,\tnv_normal,\tNV_NCH_ALW,\t\t0},\n    {Ctrl_RSB,\tnv_ident,\tNV_NCW,\t\t\t0},\n    {Ctrl_HAT,\tnv_hat,\t\tNV_NCW,\t\t\t0},\n    {Ctrl__,\tnv_error,\t0,\t\t\t0},\n    {' ',\tnv_right,\t0,\t\t\t0},\n    {'!',\tnv_operator,\t0,\t\t\t0},\n    {'\"',\tnv_regname,\tNV_NCH_NOP|NV_KEEPREG,\t0},\n    {'#',\tnv_ident,\t0,\t\t\t0},\n    {'$',\tnv_dollar,\t0,\t\t\t0},\n    {'%',\tnv_percent,\t0,\t\t\t0},\n    {'&',\tnv_optrans,\t0,\t\t\t0},\n    {'\\'',\tnv_gomark,\tNV_NCH_ALW,\t\tTRUE},\n    {'(',\tnv_brace,\t0,\t\t\tBACKWARD},\n    {')',\tnv_brace,\t0,\t\t\tFORWARD},\n    {'*',\tnv_ident,\t0,\t\t\t0},\n    {'+',\tnv_down,\t0,\t\t\tTRUE},\n    {',',\tnv_csearch,\t0,\t\t\tTRUE},\n    {'-',\tnv_up,\t\t0,\t\t\tTRUE},\n    {'.',\tnv_dot,\t\tNV_KEEPREG,\t\t0},\n    {'/',\tnv_search,\t0,\t\t\tFALSE},\n    {'0',\tnv_beginline,\t0,\t\t\t0},\n    {'1',\tnv_ignore,\t0,\t\t\t0},\n    {'2',\tnv_ignore,\t0,\t\t\t0},\n    {'3',\tnv_ignore,\t0,\t\t\t0},\n    {'4',\tnv_ignore,\t0,\t\t\t0},\n    {'5',\tnv_ignore,\t0,\t\t\t0},\n    {'6',\tnv_ignore,\t0,\t\t\t0},\n    {'7',\tnv_ignore,\t0,\t\t\t0},\n    {'8',\tnv_ignore,\t0,\t\t\t0},\n    {'9',\tnv_ignore,\t0,\t\t\t0},\n    {':',\tnv_colon,\t0,\t\t\t0},\n    {';',\tnv_csearch,\t0,\t\t\tFALSE},\n    {'<',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'=',\tnv_operator,\t0,\t\t\t0},\n    {'>',\tnv_operator,\tNV_RL,\t\t\t0},\n    {'?',\tnv_search,\t0,\t\t\tFALSE},\n    {'@',\tnv_at,\t\tNV_NCH_NOP,\t\tFALSE},\n    {'A',\tnv_edit,\t0,\t\t\t0},\n    {'B',\tnv_bck_word,\t0,\t\t\t1},\n    {'C',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'D',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'E',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'F',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'G',\tnv_goto,\t0,\t\t\tTRUE},\n    {'H',\tnv_scroll,\t0,\t\t\t0},\n    {'I',\tnv_edit,\t0,\t\t\t0},\n    {'J',\tnv_join,\t0,\t\t\t0},\n    {'K',\tnv_ident,\t0,\t\t\t0},\n    {'L',\tnv_scroll,\t0,\t\t\t0},\n    {'M',\tnv_scroll,\t0,\t\t\t0},\n    {'N',\tnv_next,\t0,\t\t\tSEARCH_REV},\n    {'O',\tnv_open,\t0,\t\t\t0},\n    {'P',\tnv_put,\t\t0,\t\t\t0},\n    {'Q',\tnv_exmode,\tNV_NCW,\t\t\t0},\n    {'R',\tnv_Replace,\t0,\t\t\tFALSE},\n    {'S',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'T',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tBACKWARD},\n    {'U',\tnv_Undo,\t0,\t\t\t0},\n    {'W',\tnv_wordcmd,\t0,\t\t\tTRUE},\n    {'X',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Y',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'Z',\tnv_Zet,\t\tNV_NCH_NOP|NV_NCW,\t0},\n    {'[',\tnv_brackets,\tNV_NCH_ALW,\t\tBACKWARD},\n    {'\\\\',\tnv_error,\t0,\t\t\t0},\n    {']',\tnv_brackets,\tNV_NCH_ALW,\t\tFORWARD},\n    {'^',\tnv_beginline,\t0,\t\t\tBL_WHITE | BL_FIX},\n    {'_',\tnv_lineop,\t0,\t\t\t0},\n    {'`',\tnv_gomark,\tNV_NCH_ALW,\t\tFALSE},\n    {'a',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'b',\tnv_bck_word,\t0,\t\t\t0},\n    {'c',\tnv_operator,\t0,\t\t\t0},\n    {'d',\tnv_operator,\t0,\t\t\t0},\n    {'e',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'f',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'g',\tnv_g_cmd,\tNV_NCH_ALW,\t\tFALSE},\n    {'h',\tnv_left,\tNV_RL,\t\t\t0},\n    {'i',\tnv_edit,\tNV_NCH,\t\t\t0},\n    {'j',\tnv_down,\t0,\t\t\tFALSE},\n    {'k',\tnv_up,\t\t0,\t\t\tFALSE},\n    {'l',\tnv_right,\tNV_RL,\t\t\t0},\n    {'m',\tnv_mark,\tNV_NCH_NOP,\t\t0},\n    {'n',\tnv_next,\t0,\t\t\t0},\n    {'o',\tnv_open,\t0,\t\t\t0},\n    {'p',\tnv_put,\t\t0,\t\t\t0},\n    {'q',\tnv_record,\tNV_NCH,\t\t\t0},\n    {'r',\tnv_replace,\tNV_NCH_NOP|NV_LANG,\t0},\n    {'s',\tnv_subst,\tNV_KEEPREG,\t\t0},\n    {'t',\tnv_csearch,\tNV_NCH_ALW|NV_LANG,\tFORWARD},\n    {'u',\tnv_undo,\t0,\t\t\t0},\n    {'w',\tnv_wordcmd,\t0,\t\t\tFALSE},\n    {'x',\tnv_abbrev,\tNV_KEEPREG,\t\t0},\n    {'y',\tnv_operator,\t0,\t\t\t0},\n    {'z',\tnv_zet,\t\tNV_NCH_ALW,\t\t0},\n    {'{',\tnv_findpar,\t0,\t\t\tBACKWARD},\n    {'|',\tnv_pipe,\t0,\t\t\t0},\n    {'}',\tnv_findpar,\t0,\t\t\tFORWARD},\n    {'~',\tnv_tilde,\t0,\t\t\t0},\n\n    // pound sign\n    {POUND,\tnv_ident,\t0,\t\t\t0},\n    {K_MOUSEUP, nv_mousescroll,\t0,\t\t\tMSCR_UP},\n    {K_MOUSEDOWN, nv_mousescroll, 0,\t\t\tMSCR_DOWN},\n    {K_MOUSELEFT, nv_mousescroll, 0,\t\t\tMSCR_LEFT},\n    {K_MOUSERIGHT, nv_mousescroll, 0,\t\t\tMSCR_RIGHT},\n    {K_LEFTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTMOUSE_NM, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_LEFTRELEASE_NM, nv_mouse, 0,\t\t\t0},\n    {K_MOUSEMOVE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLEDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_MIDDLERELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTMOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTDRAG, nv_mouse,\t0,\t\t\t0},\n    {K_RIGHTRELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X1MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X1DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X1RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_X2MOUSE, nv_mouse,\t0,\t\t\t0},\n    {K_X2DRAG, nv_mouse,\t0,\t\t\t0},\n    {K_X2RELEASE, nv_mouse,\t0,\t\t\t0},\n    {K_IGNORE,\tnv_ignore,\tNV_KEEPREG,\t\t0},\n    {K_NOP,\tnv_nop,\t\t0,\t\t\t0},\n    {K_INS,\tnv_edit,\t0,\t\t\t0},\n    {K_KINS,\tnv_edit,\t0,\t\t\t0},\n    {K_BS,\tnv_ctrlh,\t0,\t\t\t0},\n    {K_UP,\tnv_up,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_UP,\tnv_page,\tNV_SS,\t\t\tBACKWARD},\n    {K_DOWN,\tnv_down,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_DOWN,\tnv_page,\tNV_SS,\t\t\tFORWARD},\n    {K_LEFT,\tnv_left,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_LEFT,\tnv_bck_word,\tNV_SS|NV_RL,\t\t0},\n    {K_C_LEFT,\tnv_bck_word,\tNV_SSS|NV_RL|NV_STS,\t1},\n    {K_RIGHT,\tnv_right,\tNV_SSS|NV_STS|NV_RL,\t0},\n    {K_S_RIGHT,\tnv_wordcmd,\tNV_SS|NV_RL,\t\tFALSE},\n    {K_C_RIGHT,\tnv_wordcmd,\tNV_SSS|NV_RL|NV_STS,\tTRUE},\n    {K_PAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_KPAGEUP,\tnv_page,\tNV_SSS|NV_STS,\t\tBACKWARD},\n    {K_PAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_KPAGEDOWN, nv_page,\tNV_SSS|NV_STS,\t\tFORWARD},\n    {K_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_KEND,\tnv_end,\t\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_S_END,\tnv_end,\t\tNV_SS,\t\t\tFALSE},\n    {K_C_END,\tnv_end,\t\tNV_SSS|NV_STS,\t\tTRUE},\n    {K_HOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_KHOME,\tnv_home,\tNV_SSS|NV_STS,\t\t0},\n    {K_S_HOME,\tnv_home,\tNV_SS,\t\t\t0},\n    {K_C_HOME,\tnv_goto,\tNV_SSS|NV_STS,\t\tFALSE},\n    {K_DEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_KDEL,\tnv_abbrev,\t0,\t\t\t0},\n    {K_UNDO,\tnv_kundo,\t0,\t\t\t0},\n    {K_HELP,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_F1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_XF1,\tnv_help,\tNV_NCW,\t\t\t0},\n    {K_SELECT,\tnv_select,\t0,\t\t\t0},\n#ifdef FEAT_GUI\n    {K_VER_SCROLLBAR, nv_ver_scrollbar, 0,\t\t0},\n    {K_HOR_SCROLLBAR, nv_hor_scrollbar, 0,\t\t0},\n#endif\n#ifdef FEAT_GUI_TABLINE\n    {K_TABLINE, nv_tabline,\t0,\t\t\t0},\n    {K_TABMENU, nv_tabmenu,\t0,\t\t\t0},\n#endif\n#ifdef FEAT_NETBEANS_INTG\n    {K_F21,\tnv_nbcmd,\tNV_NCH_ALW,\t\t0},\n#endif\n#ifdef FEAT_DND\n    {K_DROP,\tnv_drop,\tNV_STS,\t\t\t0},\n#endif\n    {K_CURSORHOLD, nv_cursorhold, NV_KEEPREG,\t\t0},\n    {K_PS,\tnv_edit,\t0,\t\t\t0},\n    {K_COMMAND,\tnv_colon,\t0,\t\t\t0},\n};\n\n// Number of commands in nv_cmds[].\n#define NV_CMDS_SIZE ARRAY_LENGTH(nv_cmds)\n\n// Sorted index of commands in nv_cmds[].\nstatic short nv_cmd_idx[NV_CMDS_SIZE];\n\n// The highest index for which\n// nv_cmds[idx].cmd_char == nv_cmd_idx[nv_cmds[idx].cmd_char]\nstatic int nv_max_linear;\n\n/*\n * Compare functions for qsort() below, that checks the command character\n * through the index in nv_cmd_idx[].\n */\n    static int\nnv_compare(const void *s1, const void *s2)\n{\n    int\t\tc1, c2;\n\n    // The commands are sorted on absolute value.\n    c1 = nv_cmds[*(const short *)s1].cmd_char;\n    c2 = nv_cmds[*(const short *)s2].cmd_char;\n    if (c1 < 0)\n\tc1 = -c1;\n    if (c2 < 0)\n\tc2 = -c2;\n    return c1 - c2;\n}\n\n/*\n * Initialize the nv_cmd_idx[] table.\n */\n    void\ninit_normal_cmds(void)\n{\n    int\t\ti;\n\n    // Fill the index table with a one to one relation.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tnv_cmd_idx[i] = i;\n\n    // Sort the commands by the command character.\n    qsort((void *)&nv_cmd_idx, (size_t)NV_CMDS_SIZE, sizeof(short), nv_compare);\n\n    // Find the first entry that can't be indexed by the command character.\n    for (i = 0; i < (int)NV_CMDS_SIZE; ++i)\n\tif (i != nv_cmds[nv_cmd_idx[i]].cmd_char)\n\t    break;\n    nv_max_linear = i - 1;\n}\n\n/*\n * Search for a command in the commands table.\n * Returns -1 for invalid command.\n */\n    static int\nfind_command(int cmdchar)\n{\n    int\t\ti;\n    int\t\tidx;\n    int\t\ttop, bot;\n    int\t\tc;\n\n    // A multi-byte character is never a command.\n    if (cmdchar >= 0x100)\n\treturn -1;\n\n    // We use the absolute value of the character.  Special keys have a\n    // negative value, but are sorted on their absolute value.\n    if (cmdchar < 0)\n\tcmdchar = -cmdchar;\n\n    // If the character is in the first part: The character is the index into\n    // nv_cmd_idx[].\n    if (cmdchar <= nv_max_linear)\n\treturn nv_cmd_idx[cmdchar];\n\n    // Perform a binary search.\n    bot = nv_max_linear + 1;\n    top = NV_CMDS_SIZE - 1;\n    idx = -1;\n    while (bot <= top)\n    {\n\ti = (top + bot) / 2;\n\tc = nv_cmds[nv_cmd_idx[i]].cmd_char;\n\tif (c < 0)\n\t    c = -c;\n\tif (cmdchar == c)\n\t{\n\t    idx = nv_cmd_idx[i];\n\t    break;\n\t}\n\tif (cmdchar > c)\n\t    bot = i + 1;\n\telse\n\t    top = i - 1;\n    }\n    return idx;\n}\n\n/*\n * Execute a command in Normal mode.\n */\n    void\nnormal_cmd(\n    oparg_T\t*oap,\n    int\t\ttoplevel UNUSED)\t// TRUE when called from main()\n{\n    cmdarg_T\tca;\t\t\t// command arguments\n    int\t\tc;\n    int\t\tctrl_w = FALSE;\t\t// got CTRL-W command\n    int\t\told_col = curwin->w_curswant;\n#ifdef FEAT_CMDL_INFO\n    int\t\tneed_flushbuf;\t\t// need to call out_flush()\n#endif\n    pos_T\told_pos;\t\t// cursor position before command\n    int\t\tmapped_len;\n    static int\told_mapped_len = 0;\n    int\t\tidx;\n#ifdef FEAT_EVAL\n    int\t\tset_prevcount = FALSE;\n#endif\n    int\t\tsave_did_cursorhold = did_cursorhold;\n\n    CLEAR_FIELD(ca);\t// also resets ca.retval\n    ca.oap = oap;\n\n    // Use a count remembered from before entering an operator.  After typing\n    // \"3d\" we return from normal_cmd() and come back here, the \"3\" is\n    // remembered in \"opcount\".\n    ca.opcount = opcount;\n\n    /*\n     * If there is an operator pending, then the command we take this time\n     * will terminate it. Finish_op tells us to finish the operation before\n     * returning this time (unless the operation was cancelled).\n     */\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = (oap->op_type != OP_NOP);\n#ifdef CURSOR_SHAPE\n    if (finish_op != c)\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n    trigger_modechanged();\n\n    // When not finishing an operator and no register name typed, reset the\n    // count.\n    if (!finish_op && !oap->regname)\n    {\n\tca.opcount = 0;\n#ifdef FEAT_EVAL\n\tset_prevcount = TRUE;\n#endif\n    }\n\n    // Restore counts from before receiving K_CURSORHOLD.  This means after\n    // typing \"3\", handling K_CURSORHOLD and then typing \"2\" we get \"32\", not\n    // \"3 * 2\".\n    if (oap->prev_opcount > 0 || oap->prev_count0 > 0)\n    {\n\tca.opcount = oap->prev_opcount;\n\tca.count0 = oap->prev_count0;\n\toap->prev_opcount = 0;\n\toap->prev_count0 = 0;\n    }\n\n    mapped_len = typebuf_maplen();\n\n    State = NORMAL_BUSY;\n#ifdef USE_ON_FLY_SCROLL\n    dont_scroll = FALSE;\t// allow scrolling here\n#endif\n\n#ifdef FEAT_EVAL\n    // Set v:count here, when called from main() and not a stuffed\n    // command, so that v:count can be used in an expression mapping\n    // when there is no count. Do set it for redo.\n    if (toplevel && readbuf1_empty())\n\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\n    /*\n     * Get the command character from the user.\n     */\n    c = safe_vgetc();\n    LANGMAP_ADJUST(c, get_real_state() != SELECTMODE);\n\n    /*\n     * If a mapping was started in Visual or Select mode, remember the length\n     * of the mapping.  This is used below to not return to Insert mode for as\n     * long as the mapping is being executed.\n     */\n    if (restart_edit == 0)\n\told_mapped_len = 0;\n    else if (old_mapped_len\n\t\t|| (VIsual_active && mapped_len == 0 && typebuf_maplen() > 0))\n\told_mapped_len = typebuf_maplen();\n\n    if (c == NUL)\n\tc = K_ZERO;\n\n    /*\n     * In Select mode, typed text replaces the selection.\n     */\n    if (VIsual_active\n\t    && VIsual_select\n\t    && (vim_isprintc(c) || c == NL || c == CAR || c == K_KENTER))\n    {\n\t// Fake a \"c\"hange command.  When \"restart_edit\" is set (e.g., because\n\t// 'insertmode' is set) fake a \"d\"elete command, Insert mode will\n\t// restart automatically.\n\t// Insert the typed character in the typeahead buffer, so that it can\n\t// be mapped in Insert mode.  Required for \":lmap\" to work.\n\tins_char_typebuf(vgetc_char, vgetc_mod_mask);\n\tif (restart_edit != 0)\n\t    c = 'd';\n\telse\n\t    c = 'c';\n\tmsg_nowait = TRUE;\t// don't delay going to insert mode\n\told_mapped_len = 0;\t// do go to Insert mode\n    }\n\n#ifdef FEAT_CMDL_INFO\n    need_flushbuf = add_to_showcmd(c);\n#endif\n\ngetcount:\n    if (!(VIsual_active && VIsual_select))\n    {\n\t/*\n\t * Handle a count before a command and compute ca.count0.\n\t * Note that '0' is a command and not the start of a count, but it's\n\t * part of a count after other digits.\n\t */\n\twhile (    (c >= '1' && c <= '9')\n\t\t|| (ca.count0 != 0 && (c == K_DEL || c == K_KDEL || c == '0')))\n\t{\n\t    if (c == K_DEL || c == K_KDEL)\n\t    {\n\t\tca.count0 /= 10;\n#ifdef FEAT_CMDL_INFO\n\t\tdel_from_showcmd(4);\t// delete the digit and ~@%\n#endif\n\t    }\n\t    else\n\t\tca.count0 = ca.count0 * 10 + (c - '0');\n\t    if (ca.count0 < 0)\t    // overflow\n\t\tca.count0 = 999999999L;\n#ifdef FEAT_EVAL\n\t    // Set v:count here, when called from main() and not a stuffed\n\t    // command, so that v:count can be used in an expression mapping\n\t    // right after the count. Do set it for redo.\n\t    if (toplevel && readbuf1_empty())\n\t\tset_vcount_ca(&ca, &set_prevcount);\n#endif\n\t    if (ctrl_w)\n\t    {\n\t\t++no_mapping;\n\t\t++allow_keys;\t\t// no mapping for nchar, but keys\n\t    }\n\t    ++no_zero_mapping;\t\t// don't map zero here\n\t    c = plain_vgetc();\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_zero_mapping;\n\t    if (ctrl_w)\n\t    {\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t    }\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t}\n\n\t/*\n\t * If we got CTRL-W there may be a/another count\n\t */\n\tif (c == Ctrl_W && !ctrl_w && oap->op_type == OP_NOP)\n\t{\n\t    ctrl_w = TRUE;\n\t    ca.opcount = ca.count0;\t// remember first count\n\t    ca.count0 = 0;\n\t    ++no_mapping;\n\t    ++allow_keys;\t\t// no mapping for nchar, but keys\n\t    c = plain_vgetc();\t\t// get next character\n\t    LANGMAP_ADJUST(c, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(c);\n#endif\n\t    goto getcount;\t\t// jump back\n\t}\n    }\n\n    if (c == K_CURSORHOLD)\n    {\n\t// Save the count values so that ca.opcount and ca.count0 are exactly\n\t// the same when coming back here after handling K_CURSORHOLD.\n\toap->prev_opcount = ca.opcount;\n\toap->prev_count0 = ca.count0;\n    }\n    else if (ca.opcount != 0)\n    {\n\t/*\n\t * If we're in the middle of an operator (including after entering a\n\t * yank buffer with '\"') AND we had a count before the operator, then\n\t * that count overrides the current value of ca.count0.\n\t * What this means effectively, is that commands like \"3dw\" get turned\n\t * into \"d3w\" which makes things fall into place pretty neatly.\n\t * If you give a count before AND after the operator, they are\n\t * multiplied.\n\t */\n\tif (ca.count0)\n\t    ca.count0 *= ca.opcount;\n\telse\n\t    ca.count0 = ca.opcount;\n\tif (ca.count0 < 0)\t    // overflow\n\t    ca.count0 = 999999999L;\n    }\n\n    /*\n     * Always remember the count.  It will be set to zero (on the next call,\n     * above) when there is no pending operator.\n     * When called from main(), save the count for use by the \"count\" built-in\n     * variable.\n     */\n    ca.opcount = ca.count0;\n    ca.count1 = (ca.count0 == 0 ? 1 : ca.count0);\n\n#ifdef FEAT_EVAL\n    /*\n     * Only set v:count when called from main() and not a stuffed command.\n     * Do set it for redo.\n     */\n    if (toplevel && readbuf1_empty())\n\tset_vcount(ca.count0, ca.count1, set_prevcount);\n#endif\n\n    /*\n     * Find the command character in the table of commands.\n     * For CTRL-W we already got nchar when looking for a count.\n     */\n    if (ctrl_w)\n    {\n\tca.nchar = c;\n\tca.cmdchar = Ctrl_W;\n    }\n    else\n\tca.cmdchar = c;\n    idx = find_command(ca.cmdchar);\n    if (idx < 0)\n    {\n\t// Not a known command: beep.\n\tclearopbeep(oap);\n\tgoto normal_end;\n    }\n\n    if (text_locked() && (nv_cmds[idx].cmd_flags & NV_NCW))\n    {\n\t// This command is not allowed while editing a cmdline: beep.\n\tclearopbeep(oap);\n\ttext_locked_msg();\n\tgoto normal_end;\n    }\n    if ((nv_cmds[idx].cmd_flags & NV_NCW) && curbuf_locked())\n\tgoto normal_end;\n\n    /*\n     * In Visual/Select mode, a few keys are handled in a special way.\n     */\n    if (VIsual_active)\n    {\n\t// when 'keymodel' contains \"stopsel\" may stop Select/Visual mode\n\tif (km_stopsel\n\t\t&& (nv_cmds[idx].cmd_flags & NV_STS)\n\t\t&& !(mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    end_visual_mode();\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\n\t// Keys that work different when 'keymodel' contains \"startsel\"\n\tif (km_startsel)\n\t{\n\t    if (nv_cmds[idx].cmd_flags & NV_SS)\n\t    {\n\t\tunshift_special(&ca);\n\t\tidx = find_command(ca.cmdchar);\n\t\tif (idx < 0)\n\t\t{\n\t\t    // Just in case\n\t\t    clearopbeep(oap);\n\t\t    goto normal_end;\n\t\t}\n\t    }\n\t    else if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t       && (mod_mask & MOD_MASK_SHIFT))\n\t\tmod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n#ifdef FEAT_RIGHTLEFT\n    if (curwin->w_p_rl && KeyTyped && !KeyStuffed\n\t\t\t\t\t  && (nv_cmds[idx].cmd_flags & NV_RL))\n    {\n\t// Invert horizontal movements and operations.  Only when typed by the\n\t// user directly, not when the result of a mapping or \"x\" translated\n\t// to \"dl\".\n\tswitch (ca.cmdchar)\n\t{\n\t    case 'l':\t    ca.cmdchar = 'h'; break;\n\t    case K_RIGHT:   ca.cmdchar = K_LEFT; break;\n\t    case K_S_RIGHT: ca.cmdchar = K_S_LEFT; break;\n\t    case K_C_RIGHT: ca.cmdchar = K_C_LEFT; break;\n\t    case 'h':\t    ca.cmdchar = 'l'; break;\n\t    case K_LEFT:    ca.cmdchar = K_RIGHT; break;\n\t    case K_S_LEFT:  ca.cmdchar = K_S_RIGHT; break;\n\t    case K_C_LEFT:  ca.cmdchar = K_C_RIGHT; break;\n\t    case '>':\t    ca.cmdchar = '<'; break;\n\t    case '<':\t    ca.cmdchar = '>'; break;\n\t}\n\tidx = find_command(ca.cmdchar);\n    }\n#endif\n\n    /*\n     * Get an additional character if we need one.\n     */\n    if ((nv_cmds[idx].cmd_flags & NV_NCH)\n\t    && (((nv_cmds[idx].cmd_flags & NV_NCH_NOP) == NV_NCH_NOP\n\t\t    && oap->op_type == OP_NOP)\n\t\t|| (nv_cmds[idx].cmd_flags & NV_NCH_ALW) == NV_NCH_ALW\n\t\t|| (ca.cmdchar == 'q'\n\t\t    && oap->op_type == OP_NOP\n\t\t    && reg_recording == 0\n\t\t    && reg_executing == 0)\n\t\t|| ((ca.cmdchar == 'a' || ca.cmdchar == 'i')\n\t\t    && (oap->op_type != OP_NOP || VIsual_active))))\n    {\n\tint\t*cp;\n\tint\trepl = FALSE;\t// get character for replace mode\n\tint\tlit = FALSE;\t// get extra character literally\n\tint\tlangmap_active = FALSE;    // using :lmap mappings\n\tint\tlang;\t\t// getting a text character\n#ifdef HAVE_INPUT_METHOD\n\tint\tsave_smd;\t// saved value of p_smd\n#endif\n\n\t++no_mapping;\n\t++allow_keys;\t\t// no mapping for nchar, but allow key codes\n\t// Don't generate a CursorHold event here, most commands can't handle\n\t// it, e.g., nv_replace(), nv_csearch().\n\tdid_cursorhold = TRUE;\n\tif (ca.cmdchar == 'g')\n\t{\n\t    /*\n\t     * For 'g' get the next character now, so that we can check for\n\t     * \"gr\", \"g'\" and \"g`\".\n\t     */\n\t    ca.nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(ca.nchar, TRUE);\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(ca.nchar);\n#endif\n\t    if (ca.nchar == 'r' || ca.nchar == '\\'' || ca.nchar == '`'\n\t\t\t\t\t\t       || ca.nchar == Ctrl_BSL)\n\t    {\n\t\tcp = &ca.extra_char;\t// need to get a third character\n\t\tif (ca.nchar != 'r')\n\t\t    lit = TRUE;\t\t\t// get it literally\n\t\telse\n\t\t    repl = TRUE;\t\t// get it in replace mode\n\t    }\n\t    else\n\t\tcp = NULL;\t\t// no third character needed\n\t}\n\telse\n\t{\n\t    if (ca.cmdchar == 'r')\t\t// get it in replace mode\n\t\trepl = TRUE;\n\t    cp = &ca.nchar;\n\t}\n\tlang = (repl || (nv_cmds[idx].cmd_flags & NV_LANG));\n\n\t/*\n\t * Get a second or third character.\n\t */\n\tif (cp != NULL)\n\t{\n\t    if (repl)\n\t    {\n\t\tState = REPLACE;\t// pretend Replace mode\n#ifdef CURSOR_SHAPE\n\t\tui_cursor_shape();\t// show different cursor shape\n#endif\n\t    }\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_LMAP)\n\t    {\n\t\t// Allow mappings defined with \":lmap\".\n\t\t--no_mapping;\n\t\t--allow_keys;\n\t\tif (repl)\n\t\t    State = LREPLACE;\n\t\telse\n\t\t    State = LANGMAP;\n\t\tlangmap_active = TRUE;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    save_smd = p_smd;\n\t    p_smd = FALSE;\t// Don't let the IM code show the mode here\n\t    if (lang && curbuf->b_p_iminsert == B_IMODE_IM)\n\t\tim_set_active(TRUE);\n#endif\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Disable bracketed paste and modifyOtherKeys here, we won't\n\t\t// recognize the escape sequences with 'esckeys' off.\n\t\tout_str(T_BD);\n\t\tout_str(T_CTE);\n\t    }\n\n\t    *cp = plain_vgetc();\n\n\t    if ((State & INSERT) && !p_ek)\n\t    {\n#ifdef FEAT_JOB_CHANNEL\n\t\tch_log_output = TRUE;\n#endif\n\t\t// Re-enable bracketed paste mode and modifyOtherKeys\n\t\tout_str(T_BE);\n\t\tout_str(T_CTI);\n\t    }\n\n\t    if (langmap_active)\n\t    {\n\t\t// Undo the decrement done above\n\t\t++no_mapping;\n\t\t++allow_keys;\n\t\tState = NORMAL_BUSY;\n\t    }\n#ifdef HAVE_INPUT_METHOD\n\t    if (lang)\n\t    {\n\t\tif (curbuf->b_p_iminsert != B_IMODE_LMAP)\n\t\t    im_save_status(&curbuf->b_p_iminsert);\n\t\tim_set_active(FALSE);\n\t    }\n\t    p_smd = save_smd;\n#endif\n\t    State = NORMAL_BUSY;\n#ifdef FEAT_CMDL_INFO\n\t    need_flushbuf |= add_to_showcmd(*cp);\n#endif\n\n\t    if (!lit)\n\t    {\n#ifdef FEAT_DIGRAPHS\n\t\t// Typing CTRL-K gets a digraph.\n\t\tif (*cp == Ctrl_K\n\t\t\t&& ((nv_cmds[idx].cmd_flags & NV_LANG)\n\t\t\t    || cp == &ca.extra_char)\n\t\t\t&& vim_strchr(p_cpo, CPO_DIGRAPH) == NULL)\n\t\t{\n\t\t    c = get_digraph(FALSE);\n\t\t    if (c > 0)\n\t\t    {\n\t\t\t*cp = c;\n# ifdef FEAT_CMDL_INFO\n\t\t\t// Guessing how to update showcmd here...\n\t\t\tdel_from_showcmd(3);\n\t\t\tneed_flushbuf |= add_to_showcmd(*cp);\n# endif\n\t\t    }\n\t\t}\n#endif\n\n\t\t// adjust chars > 127, except after \"tTfFr\" commands\n\t\tLANGMAP_ADJUST(*cp, !lang);\n#ifdef FEAT_RIGHTLEFT\n\t\t// adjust Hebrew mapped char\n\t\tif (p_hkmap && lang && KeyTyped)\n\t\t    *cp = hkmap(*cp);\n#endif\n\t    }\n\n\t    /*\n\t     * When the next character is CTRL-\\ a following CTRL-N means the\n\t     * command is aborted and we go to Normal mode.\n\t     */\n\t    if (cp == &ca.extra_char\n\t\t    && ca.nchar == Ctrl_BSL\n\t\t    && (ca.extra_char == Ctrl_N || ca.extra_char == Ctrl_G))\n\t    {\n\t\tca.cmdchar = Ctrl_BSL;\n\t\tca.nchar = ca.extra_char;\n\t\tidx = find_command(ca.cmdchar);\n\t    }\n\t    else if ((ca.nchar == 'n' || ca.nchar == 'N') && ca.cmdchar == 'g')\n\t\tca.oap->op_type = get_op_type(*cp, NUL);\n\t    else if (*cp == Ctrl_BSL)\n\t    {\n\t\tlong towait = (p_ttm >= 0 ? p_ttm : p_tm);\n\n\t\t// There is a busy wait here when typing \"f<C-\\>\" and then\n\t\t// something different from CTRL-N.  Can't be avoided.\n\t\twhile ((c = vpeekc()) <= 0 && towait > 0L)\n\t\t{\n\t\t    do_sleep(towait > 50L ? 50L : towait, FALSE);\n\t\t    towait -= 50L;\n\t\t}\n\t\tif (c > 0)\n\t\t{\n\t\t    c = plain_vgetc();\n\t\t    if (c != Ctrl_N && c != Ctrl_G)\n\t\t\tvungetc(c);\n\t\t    else\n\t\t    {\n\t\t\tca.cmdchar = Ctrl_BSL;\n\t\t\tca.nchar = c;\n\t\t\tidx = find_command(ca.cmdchar);\n\t\t    }\n\t\t}\n\t    }\n\n\t    // When getting a text character and the next character is a\n\t    // multi-byte character, it could be a composing character.\n\t    // However, don't wait for it to arrive. Also, do enable mapping,\n\t    // because if it's put back with vungetc() it's too late to apply\n\t    // mapping.\n\t    --no_mapping;\n\t    while (enc_utf8 && lang && (c = vpeekc()) > 0\n\t\t\t\t && (c >= 0x100 || MB_BYTE2LEN(vpeekc()) > 1))\n\t    {\n\t\tc = plain_vgetc();\n\t\tif (!utf_iscomposing(c))\n\t\t{\n\t\t    vungetc(c);\t\t// it wasn't, put it back\n\t\t    break;\n\t\t}\n\t\telse if (ca.ncharC1 == 0)\n\t\t    ca.ncharC1 = c;\n\t\telse\n\t\t    ca.ncharC2 = c;\n\t    }\n\t    ++no_mapping;\n\t}\n\t--no_mapping;\n\t--allow_keys;\n    }\n\n#ifdef FEAT_CMDL_INFO\n    /*\n     * Flush the showcmd characters onto the screen so we can see them while\n     * the command is being executed.  Only do this when the shown command was\n     * actually displayed, otherwise this will slow down a lot when executing\n     * mappings.\n     */\n    if (need_flushbuf)\n\tout_flush();\n#endif\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tif (ex_normal_busy)\n\t    did_cursorhold = save_did_cursorhold;\n\telse\n\t    did_cursorhold = FALSE;\n    }\n\n    State = NORMAL;\n\n    if (ca.nchar == ESC)\n    {\n\tclearop(oap);\n\tif (restart_edit == 0 && goto_im())\n\t    restart_edit = 'a';\n\tgoto normal_end;\n    }\n\n    if (ca.cmdchar != K_IGNORE)\n    {\n\tmsg_didout = FALSE;    // don't scroll screen up for normal command\n\tmsg_col = 0;\n    }\n\n    old_pos = curwin->w_cursor;\t\t// remember where cursor was\n\n    // When 'keymodel' contains \"startsel\" some keys start Select/Visual\n    // mode.\n    if (!VIsual_active && km_startsel)\n    {\n\tif (nv_cmds[idx].cmd_flags & NV_SS)\n\t{\n\t    start_selection();\n\t    unshift_special(&ca);\n\t    idx = find_command(ca.cmdchar);\n\t}\n\telse if ((nv_cmds[idx].cmd_flags & NV_SSS)\n\t\t\t\t\t   && (mod_mask & MOD_MASK_SHIFT))\n\t{\n\t    start_selection();\n\t    mod_mask &= ~MOD_MASK_SHIFT;\n\t}\n    }\n\n    /*\n     * Execute the command!\n     * Call the command function found in the commands table.\n     */\n    ca.arg = nv_cmds[idx].cmd_arg;\n    (nv_cmds[idx].cmd_func)(&ca);\n\n    /*\n     * If we didn't start or finish an operator, reset oap->regname, unless we\n     * need it later.\n     */\n    if (!finish_op\n\t    && !oap->op_type\n\t    && (idx < 0 || !(nv_cmds[idx].cmd_flags & NV_KEEPREG)))\n    {\n\tclearop(oap);\n#ifdef FEAT_EVAL\n\treset_reg_var();\n#endif\n    }\n\n    // Get the length of mapped chars again after typing a count, second\n    // character or \"z333<cr>\".\n    if (old_mapped_len > 0)\n\told_mapped_len = typebuf_maplen();\n\n    /*\n     * If an operation is pending, handle it.  But not for K_IGNORE or\n     * K_MOUSEMOVE.\n     */\n    if (ca.cmdchar != K_IGNORE && ca.cmdchar != K_MOUSEMOVE)\n\tdo_pending_operator(&ca, old_col, FALSE);\n\n    /*\n     * Wait for a moment when a message is displayed that will be overwritten\n     * by the mode message.\n     * In Visual mode and with \"^O\" in Insert mode, a short message will be\n     * overwritten by the mode message.  Wait a bit, until a key is hit.\n     * In Visual mode, it's more important to keep the Visual area updated\n     * than keeping a message (e.g. from a /pat search).\n     * Only do this if the command was typed, not from a mapping.\n     * Don't wait when emsg_silent is non-zero.\n     * Also wait a bit after an error message, e.g. for \"^O:\".\n     * Don't redraw the screen, it would remove the message.\n     */\n    if (       ((p_smd\n\t\t    && msg_silent == 0\n\t\t    && (restart_edit != 0\n\t\t\t|| (VIsual_active\n\t\t\t    && old_pos.lnum == curwin->w_cursor.lnum\n\t\t\t    && old_pos.col == curwin->w_cursor.col)\n\t\t       )\n\t\t    && (clear_cmdline\n\t\t\t|| redraw_cmdline)\n\t\t    && (msg_didout || (msg_didany && msg_scroll))\n\t\t    && !msg_nowait\n\t\t    && KeyTyped)\n\t\t|| (restart_edit != 0\n\t\t    && !VIsual_active\n\t\t    && (msg_scroll\n\t\t\t|| emsg_on_display)))\n\t    && oap->regname == 0\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && typebuf_typed()\n\t    && emsg_silent == 0\n\t    && !in_assert_fails\n\t    && !did_wait_return\n\t    && oap->op_type == OP_NOP)\n    {\n\tint\tsave_State = State;\n\n\t// Draw the cursor with the right shape here\n\tif (restart_edit != 0)\n\t    State = INSERT;\n\n\t// If need to redraw, and there is a \"keep_msg\", redraw before the\n\t// delay\n\tif (must_redraw && keep_msg != NULL && !emsg_on_display)\n\t{\n\t    char_u\t*kmsg;\n\n\t    kmsg = keep_msg;\n\t    keep_msg = NULL;\n\t    // Showmode() will clear keep_msg, but we want to use it anyway.\n\t    // First update w_topline.\n\t    setcursor();\n\t    update_screen(0);\n\t    // now reset it, otherwise it's put in the history again\n\t    keep_msg = kmsg;\n\n\t    kmsg = vim_strsave(keep_msg);\n\t    if (kmsg != NULL)\n\t    {\n\t\tmsg_attr((char *)kmsg, keep_msg_attr);\n\t\tvim_free(kmsg);\n\t    }\n\t}\n\tsetcursor();\n#ifdef CURSOR_SHAPE\n\tui_cursor_shape();\t\t// may show different cursor shape\n#endif\n\tcursor_on();\n\tout_flush();\n\tif (msg_scroll || emsg_on_display)\n\t    ui_delay(1003L, TRUE);\t// wait at least one second\n\tui_delay(3003L, FALSE);\t\t// wait up to three seconds\n\tState = save_State;\n\n\tmsg_scroll = FALSE;\n\temsg_on_display = FALSE;\n    }\n\n    /*\n     * Finish up after executing a Normal mode command.\n     */\nnormal_end:\n\n    msg_nowait = FALSE;\n\n#ifdef FEAT_EVAL\n    if (finish_op)\n\treset_reg_var();\n#endif\n\n    // Reset finish_op, in case it was set\n#ifdef CURSOR_SHAPE\n    c = finish_op;\n#endif\n    finish_op = FALSE;\n    trigger_modechanged();\n#ifdef CURSOR_SHAPE\n    // Redraw the cursor with another shape, if we were in Operator-pending\n    // mode or did a replace command.\n    if (c || ca.cmdchar == 'r')\n    {\n\tui_cursor_shape();\t\t// may show different cursor shape\n# ifdef FEAT_MOUSESHAPE\n\tupdate_mouseshape(-1);\n# endif\n    }\n#endif\n\n#ifdef FEAT_CMDL_INFO\n    if (oap->op_type == OP_NOP && oap->regname == 0\n\t    && ca.cmdchar != K_CURSORHOLD)\n\tclear_showcmd();\n#endif\n\n    checkpcmark();\t\t// check if we moved since setting pcmark\n    vim_free(ca.searchbuf);\n\n    if (has_mbyte)\n\tmb_adjust_cursor();\n\n    if (curwin->w_p_scb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_scrollbind(TRUE);\n    }\n\n    if (curwin->w_p_crb && toplevel)\n    {\n\tvalidate_cursor();\t// may need to update w_leftcol\n\tdo_check_cursorbind();\n    }\n\n#ifdef FEAT_TERMINAL\n    // don't go to Insert mode if a terminal has a running job\n    if (term_job_running(curbuf->b_term))\n\trestart_edit = 0;\n#endif\n\n    /*\n     * May restart edit(), if we got here with CTRL-O in Insert mode (but not\n     * if still inside a mapping that started in Visual mode).\n     * May switch from Visual to Select mode after CTRL-O command.\n     */\n    if (       oap->op_type == OP_NOP\n\t    && ((restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t\t|| restart_VIsual_select == 1)\n\t    && !(ca.retval & CA_COMMAND_BUSY)\n\t    && stuff_empty()\n\t    && oap->regname == 0)\n    {\n\tif (restart_VIsual_select == 1)\n\t{\n\t    VIsual_select = TRUE;\n\t    trigger_modechanged();\n\t    showmode();\n\t    restart_VIsual_select = 0;\n\t}\n\tif (restart_edit != 0 && !VIsual_active && old_mapped_len == 0)\n\t    (void)edit(restart_edit, FALSE, 1L);\n    }\n\n    if (restart_VIsual_select == 2)\n\trestart_VIsual_select = 1;\n\n    // Save count before an operator for next time.\n    opcount = ca.opcount;\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:count and v:count1 according to \"cap\".\n * Set v:prevcount only when \"set_prevcount\" is TRUE.\n */\n    static void\nset_vcount_ca(cmdarg_T *cap, int *set_prevcount)\n{\n    long count = cap->count0;\n\n    // multiply with cap->opcount the same way as above\n    if (cap->opcount != 0)\n\tcount = cap->opcount * (count == 0 ? 1 : count);\n    set_vcount(count, count == 0 ? 1 : count, *set_prevcount);\n    *set_prevcount = FALSE;  // only set v:prevcount once\n}\n#endif\n\n/*\n * Check if highlighting for Visual mode is possible, give a warning message\n * if not.\n */\n    void\ncheck_visual_highlight(void)\n{\n    static int\t    did_check = FALSE;\n\n    if (full_screen)\n    {\n\tif (!did_check && HL_ATTR(HLF_V) == 0)\n\t    msg(_(\"Warning: terminal cannot highlight\"));\n\tdid_check = TRUE;\n    }\n}\n\n#if defined(FEAT_CLIPBOARD) && defined(FEAT_EVAL)\n/*\n * Call yank_do_autocmd() for \"regname\".\n */\n    static void\ncall_yank_do_autocmd(int regname)\n{\n    oparg_T\toa;\n    yankreg_T\t*reg;\n\n    clear_oparg(&oa);\n    oa.regname = regname;\n    oa.op_type = OP_YANK;\n    oa.is_VIsual = TRUE;\n    reg = get_register(regname, TRUE);\n    yank_do_autocmd(&oa, reg);\n    free_register(reg);\n}\n#endif\n\n/*\n * End Visual mode.\n * This function or the next should ALWAYS be called to end Visual mode, except\n * from do_pending_operator().\n */\n    void\nend_visual_mode()\n{\n    end_visual_mode_keep_button();\n    reset_held_button();\n}\n\n    void\nend_visual_mode_keep_button()\n{\n#ifdef FEAT_CLIPBOARD\n    /*\n     * If we are using the clipboard, then remember what was selected in case\n     * we need to paste it somewhere while we still own the selection.\n     * Only do this when the clipboard is already owned.  Don't want to grab\n     * the selection when hitting ESC.\n     */\n    if (clip_star.available && clip_star.owned)\n\tclip_auto_select();\n\n# if defined(FEAT_EVAL)\n    // Emit a TextYankPost for the automatic copy of the selection into the\n    // star and/or plus register.\n    if (has_textyankpost())\n    {\n\tif (clip_isautosel_star())\n\t    call_yank_do_autocmd('*');\n\tif (clip_isautosel_plus())\n\t    call_yank_do_autocmd('+');\n    }\n# endif\n#endif\n\n    VIsual_active = FALSE;\n    setmouse();\n    mouse_dragging = 0;\n\n    // Save the current VIsual area for '< and '> marks, and \"gv\"\n    curbuf->b_visual.vi_mode = VIsual_mode;\n    curbuf->b_visual.vi_start = VIsual;\n    curbuf->b_visual.vi_end = curwin->w_cursor;\n    curbuf->b_visual.vi_curswant = curwin->w_curswant;\n#ifdef FEAT_EVAL\n    curbuf->b_visual_mode_eval = VIsual_mode;\n#endif\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    may_clear_cmdline();\n\n    adjust_cursor_eol();\n    trigger_modechanged();\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect.\n */\n    void\nreset_VIsual_and_resel(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n    }\n    VIsual_reselect = FALSE;\n}\n\n/*\n * Reset VIsual_active and VIsual_reselect if it's set.\n */\n    void\nreset_VIsual(void)\n{\n    if (VIsual_active)\n    {\n\tend_visual_mode();\n\tredraw_curbuf_later(INVERTED);\t// delete the inversion later\n\tVIsual_reselect = FALSE;\n    }\n}\n\n    void\nrestore_visual_mode(void)\n{\n    if (VIsual_mode_orig != NUL)\n    {\n\tcurbuf->b_visual.vi_mode = VIsual_mode_orig;\n\tVIsual_mode_orig = NUL;\n    }\n}\n\n/*\n * Check for a balloon-eval special item to include when searching for an\n * identifier.  When \"dir\" is BACKWARD \"ptr[-1]\" must be valid!\n * Returns TRUE if the character at \"*ptr\" should be included.\n * \"dir\" is FORWARD or BACKWARD, the direction of searching.\n * \"*colp\" is in/decremented if \"ptr[-dir]\" should also be included.\n * \"bnp\" points to a counter for square brackets.\n */\n    static int\nfind_is_eval_item(\n    char_u\t*ptr,\n    int\t\t*colp,\n    int\t\t*bnp,\n    int\t\tdir)\n{\n    // Accept everything inside [].\n    if ((*ptr == ']' && dir == BACKWARD) || (*ptr == '[' && dir == FORWARD))\n\t++*bnp;\n    if (*bnp > 0)\n    {\n\tif ((*ptr == '[' && dir == BACKWARD) || (*ptr == ']' && dir == FORWARD))\n\t    --*bnp;\n\treturn TRUE;\n    }\n\n    // skip over \"s.var\"\n    if (*ptr == '.')\n\treturn TRUE;\n\n    // two-character item: s->var\n    if (ptr[dir == BACKWARD ? 0 : 1] == '>'\n\t    && ptr[dir == BACKWARD ? -1 : 0] == '-')\n    {\n\t*colp += dir;\n\treturn TRUE;\n    }\n    return FALSE;\n}\n\n/*\n * Find the identifier under or to the right of the cursor.\n * \"find_type\" can have one of three values:\n * FIND_IDENT:   find an identifier (keyword)\n * FIND_STRING:  find any non-white text\n * FIND_IDENT + FIND_STRING: find any non-white text, identifier preferred.\n * FIND_EVAL:\t find text useful for C program debugging\n *\n * There are three steps:\n * 1. Search forward for the start of an identifier/text.  Doesn't move if\n *    already on one.\n * 2. Search backward for the start of this identifier/text.\n *    This doesn't match the real Vi but I like it a little better and it\n *    shouldn't bother anyone.\n * 3. Search forward to the end of this identifier/text.\n *    When FIND_IDENT isn't defined, we backup until a blank.\n *\n * Returns the length of the text, or zero if no text is found.\n * If text is found, a pointer to the text is put in \"*text\".  This\n * points into the current buffer line and is not always NUL terminated.\n */\n    int\nfind_ident_under_cursor(char_u **text, int find_type)\n{\n    return find_ident_at_pos(curwin, curwin->w_cursor.lnum,\n\t\t\t\tcurwin->w_cursor.col, text, NULL, find_type);\n}\n\n/*\n * Like find_ident_under_cursor(), but for any window and any position.\n * However: Uses 'iskeyword' from the current window!.\n */\n    int\nfind_ident_at_pos(\n    win_T\t*wp,\n    linenr_T\tlnum,\n    colnr_T\tstartcol,\n    char_u\t**text,\n    int\t\t*textcol,\t// column where \"text\" starts, can be NULL\n    int\t\tfind_type)\n{\n    char_u\t*ptr;\n    int\t\tcol = 0;\t// init to shut up GCC\n    int\t\ti;\n    int\t\tthis_class = 0;\n    int\t\tprev_class;\n    int\t\tprevcol;\n    int\t\tbn = 0;\t\t// bracket nesting\n\n    /*\n     * if i == 0: try to find an identifier\n     * if i == 1: try to find any non-white text\n     */\n    ptr = ml_get_buf(wp->w_buffer, lnum, FALSE);\n    for (i = (find_type & FIND_IDENT) ? 0 : 1;\ti < 2; ++i)\n    {\n\t/*\n\t * 1. skip to start of identifier/text\n\t */\n\tcol = startcol;\n\tif (has_mbyte)\n\t{\n\t    while (ptr[col] != NUL)\n\t    {\n\t\t// Stop at a ']' to evaluate \"a[x]\".\n\t\tif ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\t    break;\n\t\tthis_class = mb_get_class(ptr + col);\n\t\tif (this_class != 0 && (i == 1 || this_class != 1))\n\t\t    break;\n\t\tcol += (*mb_ptr2len)(ptr + col);\n\t    }\n\t}\n\telse\n\t    while (ptr[col] != NUL\n\t\t    && (i == 0 ? !vim_iswordc(ptr[col]) : VIM_ISWHITE(ptr[col]))\n\t\t    && (!(find_type & FIND_EVAL) || ptr[col] != ']')\n\t\t    )\n\t\t++col;\n\n\t// When starting on a ']' count it, so that we include the '['.\n\tbn = ptr[col] == ']';\n\n\t/*\n\t * 2. Back up to start of identifier/text.\n\t */\n\tif (has_mbyte)\n\t{\n\t    // Remember class of character under cursor.\n\t    if ((find_type & FIND_EVAL) && ptr[col] == ']')\n\t\tthis_class = mb_get_class((char_u *)\"a\");\n\t    else\n\t\tthis_class = mb_get_class(ptr + col);\n\t    while (col > 0 && this_class != 0)\n\t    {\n\t\tprevcol = col - 1 - (*mb_head_off)(ptr, ptr + col - 1);\n\t\tprev_class = mb_get_class(ptr + prevcol);\n\t\tif (this_class != prev_class\n\t\t\t&& (i == 0\n\t\t\t    || prev_class == 0\n\t\t\t    || (find_type & FIND_IDENT))\n\t\t\t&& (!(find_type & FIND_EVAL)\n\t\t\t    || prevcol == 0\n\t\t\t    || !find_is_eval_item(ptr + prevcol, &prevcol,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t)\n\t\t    break;\n\t\tcol = prevcol;\n\t    }\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (this_class > 2)\n\t\tthis_class = 2;\n\t    if (!(find_type & FIND_STRING) || this_class == 2)\n\t\tbreak;\n\t}\n\telse\n\t{\n\t    while (col > 0\n\t\t    && ((i == 0\n\t\t\t    ? vim_iswordc(ptr[col - 1])\n\t\t\t    : (!VIM_ISWHITE(ptr[col - 1])\n\t\t\t\t&& (!(find_type & FIND_IDENT)\n\t\t\t\t    || !vim_iswordc(ptr[col - 1]))))\n\t\t\t|| ((find_type & FIND_EVAL)\n\t\t\t    && col > 1\n\t\t\t    && find_is_eval_item(ptr + col - 1, &col,\n\t\t\t\t\t\t\t       &bn, BACKWARD))\n\t\t\t))\n\t\t--col;\n\n\t    // If we don't want just any old text, or we've found an\n\t    // identifier, stop searching.\n\t    if (!(find_type & FIND_STRING) || vim_iswordc(ptr[col]))\n\t\tbreak;\n\t}\n    }\n\n    if (ptr[col] == NUL || (i == 0\n\t\t&& (has_mbyte ? this_class != 2 : !vim_iswordc(ptr[col]))))\n    {\n\t// didn't find an identifier or text\n\tif ((find_type & FIND_NOERROR) == 0)\n\t{\n\t    if (find_type & FIND_STRING)\n\t\temsg(_(\"E348: No string under cursor\"));\n\t    else\n\t\temsg(_(e_noident));\n\t}\n\treturn 0;\n    }\n    ptr += col;\n    *text = ptr;\n    if (textcol != NULL)\n\t*textcol = col;\n\n    /*\n     * 3. Find the end if the identifier/text.\n     */\n    bn = 0;\n    startcol -= col;\n    col = 0;\n    if (has_mbyte)\n    {\n\t// Search for point of changing multibyte character class.\n\tthis_class = mb_get_class(ptr);\n\twhile (ptr[col] != NUL\n\t\t&& ((i == 0 ? mb_get_class(ptr + col) == this_class\n\t\t\t    : mb_get_class(ptr + col) != 0)\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t))\n\t    col += (*mb_ptr2len)(ptr + col);\n    }\n    else\n\twhile ((i == 0 ? vim_iswordc(ptr[col])\n\t\t       : (ptr[col] != NUL && !VIM_ISWHITE(ptr[col])))\n\t\t    || ((find_type & FIND_EVAL)\n\t\t\t&& col <= (int)startcol\n\t\t\t&& find_is_eval_item(ptr + col, &col, &bn, FORWARD))\n\t\t)\n\t    ++col;\n\n    return col;\n}\n\n/*\n * Prepare for redo of a normal command.\n */\n    static void\nprep_redo_cmd(cmdarg_T *cap)\n{\n    prep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n}\n\n/*\n * Prepare for redo of any command.\n * Note that only the last argument can be a multi-byte char.\n */\n    void\nprep_redo(\n    int\t    regname,\n    long    num,\n    int\t    cmd1,\n    int\t    cmd2,\n    int\t    cmd3,\n    int\t    cmd4,\n    int\t    cmd5)\n{\n    ResetRedobuff();\n    if (regname != 0)\t// yank from specified buffer\n    {\n\tAppendCharToRedobuff('\"');\n\tAppendCharToRedobuff(regname);\n    }\n    if (num)\n\tAppendNumberToRedobuff(num);\n\n    if (cmd1 != NUL)\n\tAppendCharToRedobuff(cmd1);\n    if (cmd2 != NUL)\n\tAppendCharToRedobuff(cmd2);\n    if (cmd3 != NUL)\n\tAppendCharToRedobuff(cmd3);\n    if (cmd4 != NUL)\n\tAppendCharToRedobuff(cmd4);\n    if (cmd5 != NUL)\n\tAppendCharToRedobuff(cmd5);\n}\n\n/*\n * check for operator active and clear it\n *\n * return TRUE if operator was active\n */\n    static int\ncheckclearop(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n/*\n * Check for operator or Visual active.  Clear active operator.\n *\n * Return TRUE if operator or Visual was active.\n */\n    static int\ncheckclearopq(oparg_T *oap)\n{\n    if (oap->op_type == OP_NOP && !VIsual_active)\n\treturn FALSE;\n    clearopbeep(oap);\n    return TRUE;\n}\n\n    void\nclearop(oparg_T *oap)\n{\n    oap->op_type = OP_NOP;\n    oap->regname = 0;\n    oap->motion_force = NUL;\n    oap->use_reg_one = FALSE;\n    motion_force = NUL;\n}\n\n    void\nclearopbeep(oparg_T *oap)\n{\n    clearop(oap);\n    beep_flush();\n}\n\n/*\n * Remove the shift modifier from a special key.\n */\n    static void\nunshift_special(cmdarg_T *cap)\n{\n    switch (cap->cmdchar)\n    {\n\tcase K_S_RIGHT:\tcap->cmdchar = K_RIGHT; break;\n\tcase K_S_LEFT:\tcap->cmdchar = K_LEFT; break;\n\tcase K_S_UP:\tcap->cmdchar = K_UP; break;\n\tcase K_S_DOWN:\tcap->cmdchar = K_DOWN; break;\n\tcase K_S_HOME:\tcap->cmdchar = K_HOME; break;\n\tcase K_S_END:\tcap->cmdchar = K_END; break;\n    }\n    cap->cmdchar = simplify_key(cap->cmdchar, &mod_mask);\n}\n\n/*\n * If the mode is currently displayed clear the command line or update the\n * command displayed.\n */\n    void\nmay_clear_cmdline(void)\n{\n    if (mode_displayed)\n\tclear_cmdline = TRUE;   // unshow visual mode later\n#ifdef FEAT_CMDL_INFO\n    else\n\tclear_showcmd();\n#endif\n}\n\n#if defined(FEAT_CMDL_INFO) || defined(PROTO)\n/*\n * Routines for displaying a partly typed command\n */\n\n#define SHOWCMD_BUFLEN SHOWCMD_COLS + 1 + 30\nstatic char_u\tshowcmd_buf[SHOWCMD_BUFLEN];\nstatic char_u\told_showcmd_buf[SHOWCMD_BUFLEN];  // For push_showcmd()\nstatic int\tshowcmd_is_clear = TRUE;\nstatic int\tshowcmd_visual = FALSE;\n\nstatic void display_showcmd(void);\n\n    void\nclear_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    if (VIsual_active && !char_avail())\n    {\n\tint\t\tcursor_bot = LT_POS(VIsual, curwin->w_cursor);\n\tlong\t\tlines;\n\tcolnr_T\t\tleftcol, rightcol;\n\tlinenr_T\ttop, bot;\n\n\t// Show the size of the Visual area.\n\tif (cursor_bot)\n\t{\n\t    top = VIsual.lnum;\n\t    bot = curwin->w_cursor.lnum;\n\t}\n\telse\n\t{\n\t    top = curwin->w_cursor.lnum;\n\t    bot = VIsual.lnum;\n\t}\n# ifdef FEAT_FOLDING\n\t// Include closed folds as a whole.\n\t(void)hasFolding(top, &top, NULL);\n\t(void)hasFolding(bot, NULL, &bot);\n# endif\n\tlines = bot - top + 1;\n\n\tif (VIsual_mode == Ctrl_V)\n\t{\n# ifdef FEAT_LINEBREAK\n\t    char_u *saved_sbr = p_sbr;\n\t    char_u *saved_w_sbr = curwin->w_p_sbr;\n\n\t    // Make 'sbr' empty for a moment to get the correct size.\n\t    p_sbr = empty_option;\n\t    curwin->w_p_sbr = empty_option;\n# endif\n\t    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);\n# ifdef FEAT_LINEBREAK\n\t    p_sbr = saved_sbr;\n\t    curwin->w_p_sbr = saved_w_sbr;\n# endif\n\t    sprintf((char *)showcmd_buf, \"%ldx%ld\", lines,\n\t\t\t\t\t      (long)(rightcol - leftcol + 1));\n\t}\n\telse if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)\n\t    sprintf((char *)showcmd_buf, \"%ld\", lines);\n\telse\n\t{\n\t    char_u  *s, *e;\n\t    int\t    l;\n\t    int\t    bytes = 0;\n\t    int\t    chars = 0;\n\n\t    if (cursor_bot)\n\t    {\n\t\ts = ml_get_pos(&VIsual);\n\t\te = ml_get_cursor();\n\t    }\n\t    else\n\t    {\n\t\ts = ml_get_cursor();\n\t\te = ml_get_pos(&VIsual);\n\t    }\n\t    while ((*p_sel != 'e') ? s <= e : s < e)\n\t    {\n\t\tl = (*mb_ptr2len)(s);\n\t\tif (l == 0)\n\t\t{\n\t\t    ++bytes;\n\t\t    ++chars;\n\t\t    break;  // end of line\n\t\t}\n\t\tbytes += l;\n\t\t++chars;\n\t\ts += l;\n\t    }\n\t    if (bytes == chars)\n\t\tsprintf((char *)showcmd_buf, \"%d\", chars);\n\t    else\n\t\tsprintf((char *)showcmd_buf, \"%d-%d\", chars, bytes);\n\t}\n\tshowcmd_buf[SHOWCMD_COLS] = NUL;\t// truncate\n\tshowcmd_visual = TRUE;\n    }\n    else\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n\n\t// Don't actually display something if there is nothing to clear.\n\tif (showcmd_is_clear)\n\t    return;\n    }\n\n    display_showcmd();\n}\n\n/*\n * Add 'c' to string of shown command chars.\n * Return TRUE if output has been written (and setcursor() has been called).\n */\n    int\nadd_to_showcmd(int c)\n{\n    char_u\t*p;\n    int\t\told_len;\n    int\t\textra_len;\n    int\t\toverflow;\n    int\t\ti;\n    static int\tignore[] =\n    {\n#ifdef FEAT_GUI\n\tK_VER_SCROLLBAR, K_HOR_SCROLLBAR,\n\tK_LEFTMOUSE_NM, K_LEFTRELEASE_NM,\n#endif\n\tK_IGNORE, K_PS,\n\tK_LEFTMOUSE, K_LEFTDRAG, K_LEFTRELEASE, K_MOUSEMOVE,\n\tK_MIDDLEMOUSE, K_MIDDLEDRAG, K_MIDDLERELEASE,\n\tK_RIGHTMOUSE, K_RIGHTDRAG, K_RIGHTRELEASE,\n\tK_MOUSEDOWN, K_MOUSEUP, K_MOUSELEFT, K_MOUSERIGHT,\n\tK_X1MOUSE, K_X1DRAG, K_X1RELEASE, K_X2MOUSE, K_X2DRAG, K_X2RELEASE,\n\tK_CURSORHOLD,\n\t0\n    };\n\n    if (!p_sc || msg_silent != 0)\n\treturn FALSE;\n\n    if (showcmd_visual)\n    {\n\tshowcmd_buf[0] = NUL;\n\tshowcmd_visual = FALSE;\n    }\n\n    // Ignore keys that are scrollbar updates and mouse clicks\n    if (IS_SPECIAL(c))\n\tfor (i = 0; ignore[i] != 0; ++i)\n\t    if (ignore[i] == c)\n\t\treturn FALSE;\n\n    p = transchar(c);\n    if (*p == ' ')\n\tSTRCPY(p, \"<20>\");\n    old_len = (int)STRLEN(showcmd_buf);\n    extra_len = (int)STRLEN(p);\n    overflow = old_len + extra_len - SHOWCMD_COLS;\n    if (overflow > 0)\n\tmch_memmove(showcmd_buf, showcmd_buf + overflow,\n\t\t\t\t\t\t      old_len - overflow + 1);\n    STRCAT(showcmd_buf, p);\n\n    if (char_avail())\n\treturn FALSE;\n\n    display_showcmd();\n\n    return TRUE;\n}\n\n    void\nadd_to_showcmd_c(int c)\n{\n    if (!add_to_showcmd(c))\n\tsetcursor();\n}\n\n/*\n * Delete 'len' characters from the end of the shown command.\n */\n    static void\ndel_from_showcmd(int len)\n{\n    int\t    old_len;\n\n    if (!p_sc)\n\treturn;\n\n    old_len = (int)STRLEN(showcmd_buf);\n    if (len > old_len)\n\tlen = old_len;\n    showcmd_buf[old_len - len] = NUL;\n\n    if (!char_avail())\n\tdisplay_showcmd();\n}\n\n/*\n * push_showcmd() and pop_showcmd() are used when waiting for the user to type\n * something and there is a partial mapping.\n */\n    void\npush_showcmd(void)\n{\n    if (p_sc)\n\tSTRCPY(old_showcmd_buf, showcmd_buf);\n}\n\n    void\npop_showcmd(void)\n{\n    if (!p_sc)\n\treturn;\n\n    STRCPY(showcmd_buf, old_showcmd_buf);\n\n    display_showcmd();\n}\n\n    static void\ndisplay_showcmd(void)\n{\n    int\t    len;\n\n    cursor_off();\n\n    len = (int)STRLEN(showcmd_buf);\n    if (len == 0)\n\tshowcmd_is_clear = TRUE;\n    else\n    {\n\tscreen_puts(showcmd_buf, (int)Rows - 1, sc_col, 0);\n\tshowcmd_is_clear = FALSE;\n    }\n\n    /*\n     * clear the rest of an old message by outputting up to SHOWCMD_COLS\n     * spaces\n     */\n    screen_puts((char_u *)\"          \" + len, (int)Rows - 1, sc_col + len, 0);\n\n    setcursor();\t    // put cursor back where it belongs\n}\n#endif\n\n/*\n * When \"check\" is FALSE, prepare for commands that scroll the window.\n * When \"check\" is TRUE, take care of scroll-binding after the window has\n * scrolled.  Called from normal_cmd() and edit().\n */\n    void\ndo_check_scrollbind(int check)\n{\n    static win_T\t*old_curwin = NULL;\n    static linenr_T\told_topline = 0;\n#ifdef FEAT_DIFF\n    static int\t\told_topfill = 0;\n#endif\n    static buf_T\t*old_buf = NULL;\n    static colnr_T\told_leftcol = 0;\n\n    if (check && curwin->w_p_scb)\n    {\n\t// If a \":syncbind\" command was just used, don't scroll, only reset\n\t// the values.\n\tif (did_syncbind)\n\t    did_syncbind = FALSE;\n\telse if (curwin == old_curwin)\n\t{\n\t    /*\n\t     * Synchronize other windows, as necessary according to\n\t     * 'scrollbind'.  Don't do this after an \":edit\" command, except\n\t     * when 'diff' is set.\n\t     */\n\t    if ((curwin->w_buffer == old_buf\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_p_diff\n#endif\n\t\t)\n\t\t&& (curwin->w_topline != old_topline\n#ifdef FEAT_DIFF\n\t\t\t|| curwin->w_topfill != old_topfill\n#endif\n\t\t\t|| curwin->w_leftcol != old_leftcol))\n\t    {\n\t\tcheck_scrollbind(curwin->w_topline - old_topline,\n\t\t\t(long)(curwin->w_leftcol - old_leftcol));\n\t    }\n\t}\n\telse if (vim_strchr(p_sbo, 'j')) // jump flag set in 'scrollopt'\n\t{\n\t    /*\n\t     * When switching between windows, make sure that the relative\n\t     * vertical offset is valid for the new window.  The relative\n\t     * offset is invalid whenever another 'scrollbind' window has\n\t     * scrolled to a point that would force the current window to\n\t     * scroll past the beginning or end of its buffer.  When the\n\t     * resync is performed, some of the other 'scrollbind' windows may\n\t     * need to jump so that the current window's relative position is\n\t     * visible on-screen.\n\t     */\n\t    check_scrollbind(curwin->w_topline - curwin->w_scbind_pos, 0L);\n\t}\n\tcurwin->w_scbind_pos = curwin->w_topline;\n    }\n\n    old_curwin = curwin;\n    old_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    old_topfill = curwin->w_topfill;\n#endif\n    old_buf = curwin->w_buffer;\n    old_leftcol = curwin->w_leftcol;\n}\n\n/*\n * Synchronize any windows that have \"scrollbind\" set, based on the\n * number of rows by which the current window has changed\n * (1998-11-02 16:21:01  R. Edward Ralston <eralston@computer.org>)\n */\n    void\ncheck_scrollbind(linenr_T topline_diff, long leftcol_diff)\n{\n    int\t\twant_ver;\n    int\t\twant_hor;\n    win_T\t*old_curwin = curwin;\n    buf_T\t*old_curbuf = curbuf;\n    int\t\told_VIsual_select = VIsual_select;\n    int\t\told_VIsual_active = VIsual_active;\n    colnr_T\ttgt_leftcol = curwin->w_leftcol;\n    long\ttopline;\n    long\ty;\n\n    /*\n     * check 'scrollopt' string for vertical and horizontal scroll options\n     */\n    want_ver = (vim_strchr(p_sbo, 'v') && topline_diff != 0);\n#ifdef FEAT_DIFF\n    want_ver |= old_curwin->w_p_diff;\n#endif\n    want_hor = (vim_strchr(p_sbo, 'h') && (leftcol_diff || topline_diff != 0));\n\n    /*\n     * loop through the scrollbound windows and scroll accordingly\n     */\n    VIsual_select = VIsual_active = 0;\n    FOR_ALL_WINDOWS(curwin)\n    {\n\tcurbuf = curwin->w_buffer;\n\t// skip original window  and windows with 'noscrollbind'\n\tif (curwin != old_curwin && curwin->w_p_scb)\n\t{\n\t    /*\n\t     * do the vertical scroll\n\t     */\n\t    if (want_ver)\n\t    {\n#ifdef FEAT_DIFF\n\t\tif (old_curwin->w_p_diff && curwin->w_p_diff)\n\t\t{\n\t\t    diff_set_topline(old_curwin, curwin);\n\t\t}\n\t\telse\n#endif\n\t\t{\n\t\t    curwin->w_scbind_pos += topline_diff;\n\t\t    topline = curwin->w_scbind_pos;\n\t\t    if (topline > curbuf->b_ml.ml_line_count)\n\t\t\ttopline = curbuf->b_ml.ml_line_count;\n\t\t    if (topline < 1)\n\t\t\ttopline = 1;\n\n\t\t    y = topline - curwin->w_topline;\n\t\t    if (y > 0)\n\t\t\tscrollup(y, FALSE);\n\t\t    else\n\t\t\tscrolldown(-y, FALSE);\n\t\t}\n\n\t\tredraw_later(VALID);\n\t\tcursor_correct();\n\t\tcurwin->w_redr_status = TRUE;\n\t    }\n\n\t    /*\n\t     * do the horizontal scroll\n\t     */\n\t    if (want_hor && curwin->w_leftcol != tgt_leftcol)\n\t    {\n\t\tcurwin->w_leftcol = tgt_leftcol;\n\t\tleftcol_changed();\n\t    }\n\t}\n    }\n\n    /*\n     * reset current-window\n     */\n    VIsual_select = old_VIsual_select;\n    VIsual_active = old_VIsual_active;\n    curwin = old_curwin;\n    curbuf = old_curbuf;\n}\n\n/*\n * Command character that's ignored.\n * Used for CTRL-Q and CTRL-S to avoid problems with terminals that use\n * xon/xoff.\n */\n    static void\nnv_ignore(cmdarg_T *cap)\n{\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n\n/*\n * Command character that doesn't do anything, but unlike nv_ignore() does\n * start edit().  Used for \"startinsert\" executed while starting up.\n */\n    static void\nnv_nop(cmdarg_T *cap UNUSED)\n{\n}\n\n/*\n * Command character doesn't exist.\n */\n    static void\nnv_error(cmdarg_T *cap)\n{\n    clearopbeep(cap->oap);\n}\n\n/*\n * <Help> and <F1> commands.\n */\n    static void\nnv_help(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tex_help(NULL);\n}\n\n/*\n * CTRL-A and CTRL-X: Add or subtract from letter or number under cursor.\n */\n    static void\nnv_addsub(cmdarg_T *cap)\n{\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n\tclearopbeep(cap->oap);\n    else\n#endif\n    if (!VIsual_active && cap->oap->op_type == OP_NOP)\n    {\n\tprep_redo_cmd(cap);\n\tcap->oap->op_type = cap->cmdchar == Ctrl_A ?  OP_NR_ADD : OP_NR_SUB;\n\top_addsub(cap->oap, cap->count1, cap->arg);\n\tcap->oap->op_type = OP_NOP;\n    }\n    else if (VIsual_active)\n\tnv_operator(cap);\n    else\n\tclearop(cap->oap);\n}\n\n/*\n * CTRL-F, CTRL-B, etc: Scroll page up or down.\n */\n    static void\nnv_page(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (mod_mask & MOD_MASK_CTRL)\n\t{\n\t    // <C-PageUp>: tab page back; <C-PageDown>: tab page forward\n\t    if (cap->arg == BACKWARD)\n\t\tgoto_tabpage(-(int)cap->count1);\n\t    else\n\t\tgoto_tabpage((int)cap->count0);\n\t}\n\telse\n\t    (void)onepage(cap->arg, cap->count1);\n    }\n}\n\n/*\n * Implementation of \"gd\" and \"gD\" command.\n */\n    static void\nnv_gd(\n    oparg_T\t*oap,\n    int\t\tnchar,\n    int\t\tthisblock)\t// 1 for \"1gd\" and \"1gD\"\n{\n    int\t\tlen;\n    char_u\t*ptr;\n\n    if ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0\n\t    || find_decl(ptr, len, nchar == 'd', thisblock, SEARCH_START)\n\t\t\t\t\t\t\t\t       == FAIL)\n    {\n\tclearopbeep(oap);\n    }\n    else\n    {\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_SEARCH) && KeyTyped && oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n\t// clear any search statistics\n\tif (messaging() && !msg_silent && !shortmess(SHM_SEARCHCOUNT))\n\t    clear_cmdline = TRUE;\n    }\n}\n\n/*\n * Return TRUE if line[offset] is not inside a C-style comment or string, FALSE\n * otherwise.\n */\n    static int\nis_ident(char_u *line, int offset)\n{\n    int\ti;\n    int\tincomment = FALSE;\n    int\tinstring = 0;\n    int\tprev = 0;\n\n    for (i = 0; i < offset && line[i] != NUL; i++)\n    {\n\tif (instring != 0)\n\t{\n\t    if (prev != '\\\\' && line[i] == instring)\n\t\tinstring = 0;\n\t}\n\telse if ((line[i] == '\"' || line[i] == '\\'') && !incomment)\n\t{\n\t    instring = line[i];\n\t}\n\telse\n\t{\n\t    if (incomment)\n\t    {\n\t\tif (prev == '*' && line[i] == '/')\n\t\t    incomment = FALSE;\n\t    }\n\t    else if (prev == '/' && line[i] == '*')\n\t    {\n\t\tincomment = TRUE;\n\t    }\n\t    else if (prev == '/' && line[i] == '/')\n\t    {\n\t\treturn FALSE;\n\t    }\n\t}\n\n\tprev = line[i];\n    }\n\n    return incomment == FALSE && instring == 0;\n}\n\n/*\n * Search for variable declaration of \"ptr[len]\".\n * When \"locally\" is TRUE in the current function (\"gd\"), otherwise in the\n * current file (\"gD\").\n * When \"thisblock\" is TRUE check the {} block scope.\n * Return FAIL when not found.\n */\n    int\nfind_decl(\n    char_u\t*ptr,\n    int\t\tlen,\n    int\t\tlocally,\n    int\t\tthisblock,\n    int\t\tflags_arg)\t// flags passed to searchit()\n{\n    char_u\t*pat;\n    pos_T\told_pos;\n    pos_T\tpar_pos;\n    pos_T\tfound_pos;\n    int\t\tt;\n    int\t\tsave_p_ws;\n    int\t\tsave_p_scs;\n    int\t\tretval = OK;\n    int\t\tincll;\n    int\t\tsearchflags = flags_arg;\n    int\t\tvalid;\n\n    if ((pat = alloc(len + 7)) == NULL)\n\treturn FAIL;\n\n    // Put \"\\V\" before the pattern to avoid that the special meaning of \".\"\n    // and \"~\" causes trouble.\n    sprintf((char *)pat, vim_iswordp(ptr) ? \"\\\\V\\\\<%.*s\\\\>\" : \"\\\\V%.*s\",\n\t\t\t\t\t\t\t\t    len, ptr);\n    old_pos = curwin->w_cursor;\n    save_p_ws = p_ws;\n    save_p_scs = p_scs;\n    p_ws = FALSE;\t// don't wrap around end of file now\n    p_scs = FALSE;\t// don't switch ignorecase off now\n\n    /*\n     * With \"gD\" go to line 1.\n     * With \"gd\" Search back for the start of the current function, then go\n     * back until a blank line.  If this fails go to line 1.\n     */\n    if (!locally || !findpar(&incll, BACKWARD, 1L, '{', FALSE))\n    {\n\tsetpcmark();\t\t\t// Set in findpar() otherwise\n\tcurwin->w_cursor.lnum = 1;\n\tpar_pos = curwin->w_cursor;\n    }\n    else\n    {\n\tpar_pos = curwin->w_cursor;\n\twhile (curwin->w_cursor.lnum > 1 && *skipwhite(ml_get_curline()) != NUL)\n\t    --curwin->w_cursor.lnum;\n    }\n    curwin->w_cursor.col = 0;\n\n    // Search forward for the identifier, ignore comment lines.\n    CLEAR_POS(&found_pos);\n    for (;;)\n    {\n\tt = searchit(curwin, curbuf, &curwin->w_cursor, NULL, FORWARD,\n\t\t\t\t\t  pat, 1L, searchflags, RE_LAST, NULL);\n\tif (curwin->w_cursor.lnum >= old_pos.lnum)\n\t    t = FAIL;\t// match after start is failure too\n\n\tif (thisblock && t != FAIL)\n\t{\n\t    pos_T\t*pos;\n\n\t    // Check that the block the match is in doesn't end before the\n\t    // position where we started the search from.\n\t    if ((pos = findmatchlimit(NULL, '}', FM_FORWARD,\n\t\t     (int)(old_pos.lnum - curwin->w_cursor.lnum + 1))) != NULL\n\t\t    && pos->lnum < old_pos.lnum)\n\t    {\n\t\t// There can't be a useful match before the end of this block.\n\t\t// Skip to the end.\n\t\tcurwin->w_cursor = *pos;\n\t\tcontinue;\n\t    }\n\t}\n\n\tif (t == FAIL)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t    {\n\t\tcurwin->w_cursor = found_pos;\n\t\tt = OK;\n\t    }\n\t    break;\n\t}\n\tif (get_leader_len(ml_get_curline(), NULL, FALSE, TRUE) > 0)\n\t{\n\t    // Ignore this line, continue at start of next line.\n\t    ++curwin->w_cursor.lnum;\n\t    curwin->w_cursor.col = 0;\n\t    continue;\n\t}\n\tvalid = is_ident(ml_get_curline(), curwin->w_cursor.col);\n\n\t// If the current position is not a valid identifier and a previous\n\t// match is present, favor that one instead.\n\tif (!valid && found_pos.lnum != 0)\n\t{\n\t    curwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// Global search: use first valid match found\n\tif (valid && !locally)\n\t    break;\n\tif (valid && curwin->w_cursor.lnum >= par_pos.lnum)\n\t{\n\t    // If we previously found a valid position, use it.\n\t    if (found_pos.lnum != 0)\n\t\tcurwin->w_cursor = found_pos;\n\t    break;\n\t}\n\n\t// For finding a local variable and the match is before the \"{\" or\n\t// inside a comment, continue searching.  For K&R style function\n\t// declarations this skips the function header without types.\n\tif (!valid)\n\t    CLEAR_POS(&found_pos);\n\telse\n\t    found_pos = curwin->w_cursor;\n\t// Remove SEARCH_START from flags to avoid getting stuck at one\n\t// position.\n\tsearchflags &= ~SEARCH_START;\n    }\n\n    if (t == FAIL)\n    {\n\tretval = FAIL;\n\tcurwin->w_cursor = old_pos;\n    }\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// \"n\" searches forward now\n\treset_search_dir();\n    }\n\n    vim_free(pat);\n    p_ws = save_p_ws;\n    p_scs = save_p_scs;\n\n    return retval;\n}\n\n/*\n * Move 'dist' lines in direction 'dir', counting lines by *screen*\n * lines rather than lines in the file.\n * 'dist' must be positive.\n *\n * Return OK if able to move cursor, FAIL otherwise.\n */\n    static int\nnv_screengo(oparg_T *oap, int dir, long dist)\n{\n    int\t\tlinelen = linetabsize(ml_get_curline());\n    int\t\tretval = OK;\n    int\t\tatend = FALSE;\n    int\t\tn;\n    int\t\tcol_off1;\t// margin offset for first screen line\n    int\t\tcol_off2;\t// margin offset for wrapped screen line\n    int\t\twidth1;\t\t// text width for first screen line\n    int\t\twidth2;\t\t// text width for wrapped screen line\n\n    oap->motion_type = MCHAR;\n    oap->inclusive = (curwin->w_curswant == MAXCOL);\n\n    col_off1 = curwin_col_off();\n    col_off2 = col_off1 - curwin_col_off2();\n    width1 = curwin->w_width - col_off1;\n    width2 = curwin->w_width - col_off2;\n    if (width2 == 0)\n\twidth2 = 1; // avoid divide by zero\n\n    if (curwin->w_width != 0)\n    {\n      /*\n       * Instead of sticking at the last character of the buffer line we\n       * try to stick in the last column of the screen.\n       */\n      if (curwin->w_curswant == MAXCOL)\n      {\n\tatend = TRUE;\n\tvalidate_virtcol();\n\tif (width1 <= 0)\n\t    curwin->w_curswant = 0;\n\telse\n\t{\n\t    curwin->w_curswant = width1 - 1;\n\t    if (curwin->w_virtcol > curwin->w_curswant)\n\t\tcurwin->w_curswant += ((curwin->w_virtcol\n\t\t\t     - curwin->w_curswant - 1) / width2 + 1) * width2;\n\t}\n      }\n      else\n      {\n\tif (linelen > width1)\n\t    n = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\telse\n\t    n = width1;\n\tif (curwin->w_curswant >= (colnr_T)n)\n\t    curwin->w_curswant = n - 1;\n      }\n\n      while (dist--)\n      {\n\tif (dir == BACKWARD)\n\t{\n\t    if ((long)curwin->w_curswant >= width1\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t       )\n\t\t// Move back within the line. This can give a negative value\n\t\t// for w_curswant if width1 < width2 (with cpoptions+=n),\n\t\t// which will get clipped to column 0.\n\t\tcurwin->w_curswant -= width2;\n\t    else\n\t    {\n\t\t// to previous line\n#ifdef FEAT_FOLDING\n\t\t// Move to the start of a closed fold.  Don't do that when\n\t\t// 'foldopen' contains \"all\": it will open in a moment.\n\t\tif (!(fdo_flags & FDO_ALL))\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n#endif\n\t\tif (curwin->w_cursor.lnum == 1)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\t--curwin->w_cursor.lnum;\n\n\t\tlinelen = linetabsize(ml_get_curline());\n\t\tif (linelen > width1)\n\t\t    curwin->w_curswant += (((linelen - width1 - 1) / width2)\n\t\t\t\t\t\t\t\t+ 1) * width2;\n\t    }\n\t}\n\telse // dir == FORWARD\n\t{\n\t    if (linelen > width1)\n\t\tn = ((linelen - width1 - 1) / width2 + 1) * width2 + width1;\n\t    else\n\t\tn = width1;\n\t    if (curwin->w_curswant + width2 < (colnr_T)n\n#ifdef FEAT_FOLDING\n\t\t    && !hasFolding(curwin->w_cursor.lnum, NULL, NULL)\n#endif\n\t\t    )\n\t\t// move forward within line\n\t\tcurwin->w_curswant += width2;\n\t    else\n\t    {\n\t\t// to next line\n#ifdef FEAT_FOLDING\n\t\t// Move to the end of a closed fold.\n\t\t(void)hasFolding(curwin->w_cursor.lnum, NULL,\n\t\t\t\t\t\t      &curwin->w_cursor.lnum);\n#endif\n\t\tif (curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t\t{\n\t\t    retval = FAIL;\n\t\t    break;\n\t\t}\n\t\tcurwin->w_cursor.lnum++;\n\t\tcurwin->w_curswant %= width2;\n\t\t// Check if the cursor has moved below the number display\n\t\t// when width1 < width2 (with cpoptions+=n). Subtract width2\n\t\t// to get a negative value for w_curswant, which will get\n\t\t// clipped to column 0.\n\t\tif (curwin->w_curswant >= width1)\n\t\t    curwin->w_curswant -= width2;\n\t\tlinelen = linetabsize(ml_get_curline());\n\t    }\n\t}\n      }\n    }\n\n    if (virtual_active() && atend)\n\tcoladvance(MAXCOL);\n    else\n\tcoladvance(curwin->w_curswant);\n\n    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n    {\n\tcolnr_T virtcol;\n\tint\tc;\n\n\t/*\n\t * Check for landing on a character that got split at the end of the\n\t * last line.  We want to advance a screenline, not end up in the same\n\t * screenline or move two screenlines.\n\t */\n\tvalidate_virtcol();\n\tvirtcol = curwin->w_virtcol;\n#if defined(FEAT_LINEBREAK)\n\tif (virtcol > (colnr_T)width1 && *get_showbreak_value(curwin) != NUL)\n\t    virtcol -= vim_strsize(get_showbreak_value(curwin));\n#endif\n\n\tc = (*mb_ptr2char)(ml_get_cursor());\n\tif (dir == FORWARD && virtcol < curwin->w_curswant\n\t\t&& (curwin->w_curswant <= (colnr_T)width1)\n\t\t&& !vim_isprintc(c) && c > 255)\n\t    oneright();\n\n\tif (virtcol > curwin->w_curswant\n\t\t&& (curwin->w_curswant < (colnr_T)width1\n\t\t    ? (curwin->w_curswant > (colnr_T)width1 / 2)\n\t\t    : ((curwin->w_curswant - width1) % width2\n\t\t\t\t\t\t      > (colnr_T)width2 / 2)))\n\t    --curwin->w_cursor.col;\n    }\n\n    if (atend)\n\tcurwin->w_curswant = MAXCOL;\t    // stick in the last column\n\n    return retval;\n}\n\n/*\n * Handle CTRL-E and CTRL-Y commands: scroll a line up or down.\n * cap->arg must be TRUE for CTRL-E.\n */\n    void\nnv_scroll_line(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n\tscroll_redraw(cap->arg, cap->count1);\n}\n\n/*\n * Scroll \"count\" lines up or down, and redraw.\n */\n    void\nscroll_redraw(int up, long count)\n{\n    linenr_T\tprev_topline = curwin->w_topline;\n#ifdef FEAT_DIFF\n    int\t\tprev_topfill = curwin->w_topfill;\n#endif\n    linenr_T\tprev_lnum = curwin->w_cursor.lnum;\n\n    if (up)\n\tscrollup(count, TRUE);\n    else\n\tscrolldown(count, TRUE);\n    if (get_scrolloff_value())\n    {\n\t// Adjust the cursor position for 'scrolloff'.  Mark w_topline as\n\t// valid, otherwise the screen jumps back at the end of the file.\n\tcursor_correct();\n\tcheck_cursor_moved(curwin);\n\tcurwin->w_valid |= VALID_TOPLINE;\n\n\t// If moved back to where we were, at least move the cursor, otherwise\n\t// we get stuck at one position.  Don't move the cursor up if the\n\t// first line of the buffer is already on the screen\n\twhile (curwin->w_topline == prev_topline\n#ifdef FEAT_DIFF\n\t\t&& curwin->w_topfill == prev_topfill\n#endif\n\t\t)\n\t{\n\t    if (up)\n\t    {\n\t\tif (curwin->w_cursor.lnum > prev_lnum\n\t\t\t|| cursor_down(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    else\n\t    {\n\t\tif (curwin->w_cursor.lnum < prev_lnum\n\t\t\t|| prev_topline == 1L\n\t\t\t|| cursor_up(1L, FALSE) == FAIL)\n\t\t    break;\n\t    }\n\t    // Mark w_topline as valid, otherwise the screen jumps back at the\n\t    // end of the file.\n\t    check_cursor_moved(curwin);\n\t    curwin->w_valid |= VALID_TOPLINE;\n\t}\n    }\n    if (curwin->w_cursor.lnum != prev_lnum)\n\tcoladvance(curwin->w_curswant);\n    redraw_later(VALID);\n}\n\n/*\n * Commands that start with \"z\".\n */\n    static void\nnv_zet(cmdarg_T *cap)\n{\n    long\tn;\n    colnr_T\tcol;\n    int\t\tnchar = cap->nchar;\n#ifdef FEAT_FOLDING\n    long\told_fdl = curwin->w_p_fdl;\n    int\t\told_fen = curwin->w_p_fen;\n#endif\n#ifdef FEAT_SPELL\n    int\t\tundo = FALSE;\n#endif\n    long        siso = get_sidescrolloff_value();\n\n    if (VIM_ISDIGIT(nchar))\n    {\n\t/*\n\t * \"z123{nchar}\": edit the count before obtaining {nchar}\n\t */\n\tif (checkclearop(cap->oap))\n\t    return;\n\tn = nchar - '0';\n\tfor (;;)\n\t{\n#ifdef USE_ON_FLY_SCROLL\n\t    dont_scroll = TRUE;\t\t// disallow scrolling here\n#endif\n\t    ++no_mapping;\n\t    ++allow_keys;   // no mapping for nchar, but allow key codes\n\t    nchar = plain_vgetc();\n\t    LANGMAP_ADJUST(nchar, TRUE);\n\t    --no_mapping;\n\t    --allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t    (void)add_to_showcmd(nchar);\n#endif\n\t    if (nchar == K_DEL || nchar == K_KDEL)\n\t\tn /= 10;\n\t    else if (VIM_ISDIGIT(nchar))\n\t\tn = n * 10 + (nchar - '0');\n\t    else if (nchar == CAR)\n\t    {\n#ifdef FEAT_GUI\n\t\tneed_mouse_correct = TRUE;\n#endif\n\t\twin_setheight((int)n);\n\t\tbreak;\n\t    }\n\t    else if (nchar == 'l'\n\t\t    || nchar == 'h'\n\t\t    || nchar == K_LEFT\n\t\t    || nchar == K_RIGHT)\n\t    {\n\t\tcap->count1 = n ? n * cap->count1 : cap->count1;\n\t\tgoto dozet;\n\t    }\n\t    else\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t}\n\tcap->oap->op_type = OP_NOP;\n\treturn;\n    }\n\ndozet:\n    if (\n#ifdef FEAT_FOLDING\n\t    // \"zf\" and \"zF\" are always an operator, \"zd\", \"zo\", \"zO\", \"zc\"\n\t    // and \"zC\" only in Visual mode.  \"zj\" and \"zk\" are motion\n\t    // commands.\n\t    cap->nchar != 'f' && cap->nchar != 'F'\n\t    && !(VIsual_active && vim_strchr((char_u *)\"dcCoO\", cap->nchar))\n\t    && cap->nchar != 'j' && cap->nchar != 'k'\n\t    &&\n#endif\n\t    checkclearop(cap->oap))\n\treturn;\n\n    /*\n     * For \"z+\", \"z<CR>\", \"zt\", \"z.\", \"zz\", \"z^\", \"z-\", \"zb\":\n     * If line number given, set cursor.\n     */\n    if ((vim_strchr((char_u *)\"+\\r\\nt.z^-b\", nchar) != NULL)\n\t    && cap->count0\n\t    && cap->count0 != curwin->w_cursor.lnum)\n    {\n\tsetpcmark();\n\tif (cap->count0 > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\telse\n\t    curwin->w_cursor.lnum = cap->count0;\n\tcheck_cursor_col();\n    }\n\n    switch (nchar)\n    {\n\t\t// \"z+\", \"z<CR>\" and \"zt\": put cursor at top of screen\n    case '+':\n\t\tif (cap->count0 == 0)\n\t\t{\n\t\t    // No count given: put cursor at the line below screen\n\t\t    validate_botline();\t// make sure w_botline is valid\n\t\t    if (curwin->w_botline > curbuf->b_ml.ml_line_count)\n\t\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\t    else\n\t\t\tcurwin->w_cursor.lnum = curwin->w_botline;\n\t\t}\n\t\t// FALLTHROUGH\n    case NL:\n    case CAR:\n    case K_KENTER:\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 't':\tscroll_cursor_top(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z.\" and \"zz\": put cursor in middle of screen\n    case '.':\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'z':\tscroll_cursor_halfway(TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"z^\", \"z-\" and \"zb\": put cursor at bottom of screen\n    case '^':\t// Strange Vi behavior: <count>z^ finds line at top of window\n\t\t// when <count> is at bottom of window, and puts that one at\n\t\t// bottom of window.\n\t\tif (cap->count0 != 0)\n\t\t{\n\t\t    scroll_cursor_bot(0, TRUE);\n\t\t    curwin->w_cursor.lnum = curwin->w_topline;\n\t\t}\n\t\telse if (curwin->w_topline == 1)\n\t\t    curwin->w_cursor.lnum = 1;\n\t\telse\n\t\t    curwin->w_cursor.lnum = curwin->w_topline - 1;\n\t\t// FALLTHROUGH\n    case '-':\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t\t// FALLTHROUGH\n\n    case 'b':\tscroll_cursor_bot(0, TRUE);\n\t\tredraw_later(VALID);\n\t\tset_fraction(curwin);\n\t\tbreak;\n\n\t\t// \"zH\" - scroll screen right half-page\n    case 'H':\n\t\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zh\" - scroll screen to the right\n    case 'h':\n    case K_LEFT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    if ((colnr_T)cap->count1 > curwin->w_leftcol)\n\t\t\tcurwin->w_leftcol = 0;\n\t\t    else\n\t\t\tcurwin->w_leftcol -= (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zL\" - scroll screen left half-page\n    case 'L':\tcap->count1 *= curwin->w_width / 2;\n\t\t// FALLTHROUGH\n\n\t\t// \"zl\" - scroll screen to the left\n    case 'l':\n    case K_RIGHT:\n\t\tif (!curwin->w_p_wrap)\n\t\t{\n\t\t    // scroll the window left\n\t\t    curwin->w_leftcol += (colnr_T)cap->count1;\n\t\t    leftcol_changed();\n\t\t}\n\t\tbreak;\n\n\t\t// \"zs\" - scroll screen, cursor at the start\n    case 's':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, &col, NULL, NULL);\n\t\t    if ((long)col > siso)\n\t\t\tcol -= siso;\n\t\t    else\n\t\t\tcol = 0;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"ze\" - scroll screen, cursor at the end\n    case 'e':\tif (!curwin->w_p_wrap)\n\t\t{\n#ifdef FEAT_FOLDING\n\t\t    if (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t\tcol = 0;\t// like the cursor is in col 0\n\t\t    else\n#endif\n\t\t    getvcol(curwin, &curwin->w_cursor, NULL, NULL, &col);\n\t\t    n = curwin->w_width - curwin_col_off();\n\t\t    if ((long)col + siso < n)\n\t\t\tcol = 0;\n\t\t    else\n\t\t\tcol = col + siso - n + 1;\n\t\t    if (curwin->w_leftcol != col)\n\t\t    {\n\t\t\tcurwin->w_leftcol = col;\n\t\t\tredraw_later(NOT_VALID);\n\t\t    }\n\t\t}\n\t\tbreak;\n\n\t\t// \"zp\", \"zP\" in block mode put without addind trailing spaces\n    case 'P':\n    case 'p':  nv_put(cap);\n\t       break;\n\t\t// \"zy\" Yank without trailing spaces\n    case 'y':  nv_operator(cap);\n\t       break;\n#ifdef FEAT_FOLDING\n\t\t// \"zF\": create fold command\n\t\t// \"zf\": create fold operator\n    case 'F':\n    case 'f':   if (foldManualAllowed(TRUE))\n\t\t{\n\t\t    cap->nchar = 'f';\n\t\t    nv_operator(cap);\n\t\t    curwin->w_p_fen = TRUE;\n\n\t\t    // \"zF\" is like \"zfzf\"\n\t\t    if (nchar == 'F' && cap->oap->op_type == OP_FOLD)\n\t\t    {\n\t\t\tnv_operator(cap);\n\t\t\tfinish_op = TRUE;\n\t\t    }\n\t\t}\n\t\telse\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n\t\t// \"zd\": delete fold at cursor\n\t\t// \"zD\": delete fold at cursor recursively\n    case 'd':\n    case 'D':\tif (foldManualAllowed(FALSE))\n\t\t{\n\t\t    if (VIsual_active)\n\t\t\tnv_operator(cap);\n\t\t    else\n\t\t\tdeleteFold(curwin->w_cursor.lnum,\n\t\t\t\t  curwin->w_cursor.lnum, nchar == 'D', FALSE);\n\t\t}\n\t\tbreak;\n\n\t\t// \"zE\": erase all folds\n    case 'E':\tif (foldmethodIsManual(curwin))\n\t\t{\n\t\t    clearFolding(curwin);\n\t\t    changed_window_setting();\n\t\t}\n\t\telse if (foldmethodIsMarker(curwin))\n\t\t    deleteFold((linenr_T)1, curbuf->b_ml.ml_line_count,\n\t\t\t\t\t\t\t\t TRUE, FALSE);\n\t\telse\n\t\t    emsg(_(\"E352: Cannot erase folds with current 'foldmethod'\"));\n\t\tbreak;\n\n\t\t// \"zn\": fold none: reset 'foldenable'\n    case 'n':\tcurwin->w_p_fen = FALSE;\n\t\tbreak;\n\n\t\t// \"zN\": fold Normal: set 'foldenable'\n    case 'N':\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zi\": invert folding: toggle 'foldenable'\n    case 'i':\tcurwin->w_p_fen = !curwin->w_p_fen;\n\t\tbreak;\n\n\t\t// \"za\": open closed fold or close open fold at cursor\n    case 'a':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\telse\n\t\t{\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zA\": open fold at cursor recursively\n    case 'A':\tif (hasFolding(curwin->w_cursor.lnum, NULL, NULL))\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\telse\n\t\t{\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\t    curwin->w_p_fen = TRUE;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zo\": open fold at cursor or Visual area\n    case 'o':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFold(curwin->w_cursor.lnum, cap->count1);\n\t\tbreak;\n\n\t\t// \"zO\": open fold recursively\n    case 'O':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    openFoldRecurse(curwin->w_cursor.lnum);\n\t\tbreak;\n\n\t\t// \"zc\": close fold at cursor or Visual area\n    case 'c':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFold(curwin->w_cursor.lnum, cap->count1);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zC\": close fold recursively\n    case 'C':\tif (VIsual_active)\n\t\t    nv_operator(cap);\n\t\telse\n\t\t    closeFoldRecurse(curwin->w_cursor.lnum);\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zv\": open folds at the cursor\n    case 'v':\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zx\": re-apply 'foldlevel' and open folds at the cursor\n    case 'x':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\tnewFoldLevel();\t\t\t// update right now\n\t\tfoldOpenCursor();\n\t\tbreak;\n\n\t\t// \"zX\": undo manual opens/closes, re-apply 'foldlevel'\n    case 'X':\tcurwin->w_p_fen = TRUE;\n\t\tcurwin->w_foldinvalid = TRUE;\t// recompute folds\n\t\told_fdl = -1;\t\t\t// force an update\n\t\tbreak;\n\n\t\t// \"zm\": fold more\n    case 'm':\tif (curwin->w_p_fdl > 0)\n\t\t{\n\t\t    curwin->w_p_fdl -= cap->count1;\n\t\t    if (curwin->w_p_fdl < 0)\n\t\t\tcurwin->w_p_fdl = 0;\n\t\t}\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zM\": close all folds\n    case 'M':\tcurwin->w_p_fdl = 0;\n\t\told_fdl = -1;\t\t// force an update\n\t\tcurwin->w_p_fen = TRUE;\n\t\tbreak;\n\n\t\t// \"zr\": reduce folding\n    case 'r':\tcurwin->w_p_fdl += cap->count1;\n\t\t{\n\t\t    int d = getDeepestNesting();\n\n\t\t    if (curwin->w_p_fdl >= d)\n\t\t\tcurwin->w_p_fdl = d;\n\t\t}\n\t\tbreak;\n\n\t\t// \"zR\": open all folds\n    case 'R':\tcurwin->w_p_fdl = getDeepestNesting();\n\t\told_fdl = -1;\t\t// force an update\n\t\tbreak;\n\n    case 'j':\t// \"zj\" move to next fold downwards\n    case 'k':\t// \"zk\" move to next fold upwards\n\t\tif (foldMoveTo(TRUE, nchar == 'j' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t  cap->count1) == FAIL)\n\t\t    clearopbeep(cap->oap);\n\t\tbreak;\n\n#endif // FEAT_FOLDING\n\n#ifdef FEAT_SPELL\n    case 'u':\t// \"zug\" and \"zuw\": undo \"zg\" and \"zw\"\n\t\t++no_mapping;\n\t\t++allow_keys;   // no mapping for nchar, but allow key codes\n\t\tnchar = plain_vgetc();\n\t\tLANGMAP_ADJUST(nchar, TRUE);\n\t\t--no_mapping;\n\t\t--allow_keys;\n#ifdef FEAT_CMDL_INFO\n\t\t(void)add_to_showcmd(nchar);\n#endif\n\t\tif (vim_strchr((char_u *)\"gGwW\", nchar) == NULL)\n\t\t{\n\t\t    clearopbeep(cap->oap);\n\t\t    break;\n\t\t}\n\t\tundo = TRUE;\n\t\t// FALLTHROUGH\n\n    case 'g':\t// \"zg\": add good word to word list\n    case 'w':\t// \"zw\": add wrong word to word list\n    case 'G':\t// \"zG\": add good word to temp word list\n    case 'W':\t// \"zW\": add wrong word to temp word list\n\t\t{\n\t\t    char_u  *ptr = NULL;\n\t\t    int\t    len;\n\n\t\t    if (checkclearop(cap->oap))\n\t\t\tbreak;\n\t\t    if (VIsual_active && get_visual_text(cap, &ptr, &len)\n\t\t\t\t\t\t\t\t      == FAIL)\n\t\t\treturn;\n\t\t    if (ptr == NULL)\n\t\t    {\n\t\t\tpos_T\tpos = curwin->w_cursor;\n\n\t\t\t// Find bad word under the cursor.  When 'spell' is\n\t\t\t// off this fails and find_ident_under_cursor() is\n\t\t\t// used below.\n\t\t\temsg_off++;\n\t\t\tlen = spell_move_to(curwin, FORWARD, TRUE, TRUE, NULL);\n\t\t\temsg_off--;\n\t\t\tif (len != 0 && curwin->w_cursor.col <= pos.col)\n\t\t\t    ptr = ml_get_pos(&curwin->w_cursor);\n\t\t\tcurwin->w_cursor = pos;\n\t\t    }\n\n\t\t    if (ptr == NULL && (len = find_ident_under_cursor(&ptr,\n\t\t\t\t\t\t\t    FIND_IDENT)) == 0)\n\t\t\treturn;\n\t\t    spell_add_word(ptr, len, nchar == 'w' || nchar == 'W'\n\t\t\t\t\t      ? SPELL_ADD_BAD : SPELL_ADD_GOOD,\n\t\t\t\t\t    (nchar == 'G' || nchar == 'W')\n\t\t\t\t\t\t       ? 0 : (int)cap->count1,\n\t\t\t\t\t    undo);\n\t\t}\n\t\tbreak;\n\n    case '=':\t// \"z=\": suggestions for a badly spelled word\n\t\tif (!checkclearop(cap->oap))\n\t\t    spell_suggest((int)cap->count0);\n\t\tbreak;\n#endif\n\n    default:\tclearopbeep(cap->oap);\n    }\n\n#ifdef FEAT_FOLDING\n    // Redraw when 'foldenable' changed\n    if (old_fen != curwin->w_p_fen)\n    {\n# ifdef FEAT_DIFF\n\twin_T\t    *wp;\n\n\tif (foldmethodIsDiff(curwin) && curwin->w_p_scb)\n\t{\n\t    // Adjust 'foldenable' in diff-synced windows.\n\t    FOR_ALL_WINDOWS(wp)\n\t    {\n\t\tif (wp != curwin && foldmethodIsDiff(wp) && wp->w_p_scb)\n\t\t{\n\t\t    wp->w_p_fen = curwin->w_p_fen;\n\t\t    changed_window_setting_win(wp);\n\t\t}\n\t    }\n\t}\n# endif\n\tchanged_window_setting();\n    }\n\n    // Redraw when 'foldlevel' changed.\n    if (old_fdl != curwin->w_p_fdl)\n\tnewFoldLevel();\n#endif\n}\n\n#ifdef FEAT_GUI\n/*\n * Vertical scrollbar movement.\n */\n    static void\nnv_ver_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_scroll();\n}\n\n/*\n * Horizontal scrollbar movement.\n */\n    static void\nnv_hor_scrollbar(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to scroll\n    gui_do_horiz_scroll(scrollbar_value, FALSE);\n}\n#endif\n\n#if defined(FEAT_GUI_TABLINE) || defined(PROTO)\n/*\n * Click in GUI tab.\n */\n    static void\nnv_tabline(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    goto_tabpage(current_tab);\n}\n\n/*\n * Selected item in tab line menu.\n */\n    static void\nnv_tabmenu(cmdarg_T *cap)\n{\n    if (cap->oap->op_type != OP_NOP)\n\tclearopbeep(cap->oap);\n\n    // Even if an operator was pending, we still want to jump tabs.\n    handle_tabmenu();\n}\n\n/*\n * Handle selecting an item of the GUI tab line menu.\n * Used in Normal and Insert mode.\n */\n    void\nhandle_tabmenu(void)\n{\n    switch (current_tabmenu)\n    {\n\tcase TABLINE_MENU_CLOSE:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"tabclose\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"tabclose %d\",\n\t\t\t\t\t\t\t\t current_tab);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_NEW:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"$tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"%dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n\n\tcase TABLINE_MENU_OPEN:\n\t    if (current_tab == 0)\n\t\tdo_cmdline_cmd((char_u *)\"browse $tabnew\");\n\t    else\n\t    {\n\t\tvim_snprintf((char *)IObuff, IOSIZE, \"browse %dtabnew\",\n\t\t\t\t\t\t\t     current_tab - 1);\n\t\tdo_cmdline_cmd(IObuff);\n\t    }\n\t    break;\n    }\n}\n#endif\n\n/*\n * \"Q\" command.\n */\n    static void\nnv_exmode(cmdarg_T *cap)\n{\n    /*\n     * Ignore 'Q' in Visual mode, just give a beep.\n     */\n    if (VIsual_active)\n\tvim_beep(BO_EX);\n    else if (!checkclearop(cap->oap))\n\tdo_exmode(FALSE);\n}\n\n/*\n * Handle a \":\" command.\n */\n    static void\nnv_colon(cmdarg_T *cap)\n{\n    int\told_p_im;\n    int\tcmd_result;\n    int\tis_cmdkey = cap->cmdchar == K_COMMAND;\n\n    if (VIsual_active && !is_cmdkey)\n\tnv_operator(cap);\n    else\n    {\n\tif (cap->oap->op_type != OP_NOP)\n\t{\n\t    // Using \":\" as a movement is characterwise exclusive.\n\t    cap->oap->motion_type = MCHAR;\n\t    cap->oap->inclusive = FALSE;\n\t}\n\telse if (cap->count0 && !is_cmdkey)\n\t{\n\t    // translate \"count:\" into \":.,.+(count - 1)\"\n\t    stuffcharReadbuff('.');\n\t    if (cap->count0 > 1)\n\t    {\n\t\tstuffReadbuff((char_u *)\",.+\");\n\t\tstuffnumReadbuff((long)cap->count0 - 1L);\n\t    }\n\t}\n\n\t// When typing, don't type below an old message\n\tif (KeyTyped)\n\t    compute_cmdrow();\n\n\told_p_im = p_im;\n\n\t// get a command line and execute it\n\tcmd_result = do_cmdline(NULL, is_cmdkey ? getcmdkeycmd : getexline, NULL,\n\t\t\t    cap->oap->op_type != OP_NOP ? DOCMD_KEEPLINE : 0);\n\n\t// If 'insertmode' changed, enter or exit Insert mode\n\tif (p_im != old_p_im)\n\t{\n\t    if (p_im)\n\t\trestart_edit = 'i';\n\t    else\n\t\trestart_edit = 0;\n\t}\n\n\tif (cmd_result == FAIL)\n\t    // The Ex command failed, do not execute the operator.\n\t    clearop(cap->oap);\n\telse if (cap->oap->op_type != OP_NOP\n\t\t&& (cap->oap->start.lnum > curbuf->b_ml.ml_line_count\n\t\t    || cap->oap->start.col >\n\t\t\t       (colnr_T)STRLEN(ml_get(cap->oap->start.lnum))\n\t\t    || did_emsg\n\t\t    ))\n\t    // The start of the operator has become invalid by the Ex command.\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle CTRL-G command.\n */\n    static void\nnv_ctrlg(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// toggle Selection/Visual mode\n    {\n\tVIsual_select = !VIsual_select;\n\ttrigger_modechanged();\n\tshowmode();\n    }\n    else if (!checkclearop(cap->oap))\n\t// print full name if count given or :cd used\n\tfileinfo((int)cap->count0, FALSE, TRUE);\n}\n\n/*\n * Handle CTRL-H <Backspace> command.\n */\n    static void\nnv_ctrlh(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tcap->cmdchar = 'x';\t// BS key behaves like 'x' in Select mode\n\tv_visop(cap);\n    }\n    else\n\tnv_left(cap);\n}\n\n/*\n * CTRL-L: clear screen and redraw.\n */\n    static void\nnv_clear(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_SYN_HL\n\t// Clear all syntax states to force resyncing.\n\tsyn_stack_free_all(curwin->w_s);\n# ifdef FEAT_RELTIME\n\t{\n\t    win_T *wp;\n\n\t    FOR_ALL_WINDOWS(wp)\n\t\twp->w_s->b_syn_slow = FALSE;\n\t}\n# endif\n#endif\n\tredraw_later(CLEAR);\n#if defined(MSWIN) && (!defined(FEAT_GUI_MSWIN) || defined(VIMDLL))\n# ifdef VIMDLL\n\tif (!gui.in_use)\n# endif\n\t    resize_console_buf();\n#endif\n    }\n}\n\n/*\n * CTRL-O: In Select mode: switch to Visual mode for one command.\n * Otherwise: Go to older pcmark.\n */\n    static void\nnv_ctrlo(cmdarg_T *cap)\n{\n    if (VIsual_active && VIsual_select)\n    {\n\tVIsual_select = FALSE;\n\ttrigger_modechanged();\n\tshowmode();\n\trestart_VIsual_select = 2;\t// restart Select mode later\n    }\n    else\n    {\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n    }\n}\n\n/*\n * CTRL-^ command, short for \":e #\".  Works even when the alternate buffer is\n * not named.\n */\n    static void\nnv_hat(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\t(void)buflist_getfile((int)cap->count0, (linenr_T)0,\n\t\t\t\t\t\tGETF_SETMARK|GETF_ALT, FALSE);\n}\n\n/*\n * \"Z\" commands.\n */\n    static void\nnv_Zet(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->nchar)\n\t{\n\t\t\t// \"ZZ\": equivalent to \":x\".\n\t    case 'Z':\tdo_cmdline_cmd((char_u *)\"x\");\n\t\t\tbreak;\n\n\t\t\t// \"ZQ\": equivalent to \":q!\" (Elvis compatible).\n\t    case 'Q':\tdo_cmdline_cmd((char_u *)\"q!\");\n\t\t\tbreak;\n\n\t    default:\tclearopbeep(cap->oap);\n\t}\n    }\n}\n\n/*\n * Call nv_ident() as if \"c1\" was used, with \"c2\" as next character.\n */\n    void\ndo_nv_ident(int c1, int c2)\n{\n    oparg_T\toa;\n    cmdarg_T\tca;\n\n    clear_oparg(&oa);\n    CLEAR_FIELD(ca);\n    ca.oap = &oa;\n    ca.cmdchar = c1;\n    ca.nchar = c2;\n    nv_ident(&ca);\n}\n\n/*\n * Handle the commands that use the word under the cursor.\n * [g] CTRL-]\t:ta to current identifier\n * [g] 'K'\trun program for current identifier\n * [g] '*'\t/ to current identifier or string\n * [g] '#'\t? to current identifier or string\n *  g  ']'\t:tselect for current identifier\n */\n    static void\nnv_ident(cmdarg_T *cap)\n{\n    char_u\t*ptr = NULL;\n    char_u\t*buf;\n    unsigned\tbuflen;\n    char_u\t*newbuf;\n    char_u\t*p;\n    char_u\t*kp;\t\t// value of 'keywordprg'\n    int\t\tkp_help;\t// 'keywordprg' is \":he\"\n    int\t\tkp_ex;\t\t// 'keywordprg' starts with \":\"\n    int\t\tn = 0;\t\t// init for GCC\n    int\t\tcmdchar;\n    int\t\tg_cmd;\t\t// \"g\" command\n    int\t\ttag_cmd = FALSE;\n    char_u\t*aux_ptr;\n    int\t\tisman;\n    int\t\tisman_s;\n\n    if (cap->cmdchar == 'g')\t// \"g*\", \"g#\", \"g]\" and \"gCTRL-]\"\n    {\n\tcmdchar = cap->nchar;\n\tg_cmd = TRUE;\n    }\n    else\n    {\n\tcmdchar = cap->cmdchar;\n\tg_cmd = FALSE;\n    }\n\n    if (cmdchar == POUND)\t// the pound sign, '#' for English keyboards\n\tcmdchar = '#';\n\n    /*\n     * The \"]\", \"CTRL-]\" and \"K\" commands accept an argument in Visual mode.\n     */\n    if (cmdchar == ']' || cmdchar == Ctrl_RSB || cmdchar == 'K')\n    {\n\tif (VIsual_active && get_visual_text(cap, &ptr, &n) == FAIL)\n\t    return;\n\tif (checkclearopq(cap->oap))\n\t    return;\n    }\n\n    if (ptr == NULL && (n = find_ident_under_cursor(&ptr,\n\t\t    (cmdchar == '*' || cmdchar == '#')\n\t\t\t\t ? FIND_IDENT|FIND_STRING : FIND_IDENT)) == 0)\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n\n    // Allocate buffer to put the command in.  Inserting backslashes can\n    // double the length of the word.  p_kp / curbuf->b_p_kp could be added\n    // and some numbers.\n    kp = (*curbuf->b_p_kp == NUL ? p_kp : curbuf->b_p_kp);\n    kp_help = (*kp == NUL || STRCMP(kp, \":he\") == 0\n\t\t\t\t\t\t || STRCMP(kp, \":help\") == 0);\n    if (kp_help && *skipwhite(ptr) == NUL)\n    {\n\temsg(_(e_noident));\t // found white space only\n\treturn;\n    }\n    kp_ex = (*kp == ':');\n    buflen = (unsigned)(n * 2 + 30 + STRLEN(kp));\n    buf = alloc(buflen);\n    if (buf == NULL)\n\treturn;\n    buf[0] = NUL;\n\n    switch (cmdchar)\n    {\n\tcase '*':\n\tcase '#':\n\t    /*\n\t     * Put cursor at start of word, makes search skip the word\n\t     * under the cursor.\n\t     * Call setpcmark() first, so \"*``\" puts the cursor back where\n\t     * it was.\n\t     */\n\t    setpcmark();\n\t    curwin->w_cursor.col = (colnr_T) (ptr - ml_get_curline());\n\n\t    if (!g_cmd && vim_iswordp(ptr))\n\t\tSTRCPY(buf, \"\\\\<\");\n\t    no_smartcase = TRUE;\t// don't use 'smartcase' now\n\t    break;\n\n\tcase 'K':\n\t    if (kp_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else if (kp_ex)\n\t    {\n\t\tif (cap->count0 != 0)\n\t\t    vim_snprintf((char *)buf, buflen, \"%s %ld\",\n\t\t\t\t\t\t\t     kp, cap->count0);\n\t\telse\n\t\t    STRCPY(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t    }\n\t    else\n\t    {\n\t\t// An external command will probably use an argument starting\n\t\t// with \"-\" as an option.  To avoid trouble we skip the \"-\".\n\t\twhile (*ptr == '-' && n > 0)\n\t\t{\n\t\t    ++ptr;\n\t\t    --n;\n\t\t}\n\t\tif (n == 0)\n\t\t{\n\t\t    emsg(_(e_noident));\t // found dashes only\n\t\t    vim_free(buf);\n\t\t    return;\n\t\t}\n\n\t\t// When a count is given, turn it into a range.  Is this\n\t\t// really what we want?\n\t\tisman = (STRCMP(kp, \"man\") == 0);\n\t\tisman_s = (STRCMP(kp, \"man -s\") == 0);\n\t\tif (cap->count0 != 0 && !(isman || isman_s))\n\t\t    sprintf((char *)buf, \".,.+%ld\", cap->count0 - 1);\n\n\t\tSTRCAT(buf, \"! \");\n\t\tif (cap->count0 == 0 && isman_s)\n\t\t    STRCAT(buf, \"man\");\n\t\telse\n\t\t    STRCAT(buf, kp);\n\t\tSTRCAT(buf, \" \");\n\t\tif (cap->count0 != 0 && (isman || isman_s))\n\t\t{\n\t\t    sprintf((char *)buf + STRLEN(buf), \"%ld\", cap->count0);\n\t\t    STRCAT(buf, \" \");\n\t\t}\n\t    }\n\t    break;\n\n\tcase ']':\n\t    tag_cmd = TRUE;\n#ifdef FEAT_CSCOPE\n\t    if (p_cst)\n\t\tSTRCPY(buf, \"cstag \");\n\t    else\n#endif\n\t\tSTRCPY(buf, \"ts \");\n\t    break;\n\n\tdefault:\n\t    tag_cmd = TRUE;\n\t    if (curbuf->b_help)\n\t\tSTRCPY(buf, \"he! \");\n\t    else\n\t    {\n\t\tif (g_cmd)\n\t\t    STRCPY(buf, \"tj \");\n\t\telse if (cap->count0 == 0)\n\t\t    STRCPY(buf, \"ta \");\n\t\telse\n\t\t    sprintf((char *)buf, \":%ldta \", cap->count0);\n\t    }\n    }\n\n    /*\n     * Now grab the chars in the identifier\n     */\n    if (cmdchar == 'K' && !kp_help)\n    {\n\tptr = vim_strnsave(ptr, n);\n\tif (kp_ex)\n\t    // Escape the argument properly for an Ex command\n\t    p = vim_strsave_fnameescape(ptr, VSE_NONE);\n\telse\n\t    // Escape the argument properly for a shell command\n\t    p = vim_strsave_shellescape(ptr, TRUE, TRUE);\n\tvim_free(ptr);\n\tif (p == NULL)\n\t{\n\t    vim_free(buf);\n\t    return;\n\t}\n\tnewbuf = vim_realloc(buf, STRLEN(buf) + STRLEN(p) + 1);\n\tif (newbuf == NULL)\n\t{\n\t    vim_free(buf);\n\t    vim_free(p);\n\t    return;\n\t}\n\tbuf = newbuf;\n\tSTRCAT(buf, p);\n\tvim_free(p);\n    }\n    else\n    {\n\tif (cmdchar == '*')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/.*~[^$\\\\\" : \"/^$\\\\\");\n\telse if (cmdchar == '#')\n\t    aux_ptr = (char_u *)(magic_isset() ? \"/?.*~[^$\\\\\" : \"/?^$\\\\\");\n\telse if (tag_cmd)\n\t{\n\t    if (curbuf->b_help)\n\t\t// \":help\" handles unescaped argument\n\t\taux_ptr = (char_u *)\"\";\n\t    else\n\t\taux_ptr = (char_u *)\"\\\\|\\\"\\n[\";\n\t}\n\telse\n\t    aux_ptr = (char_u *)\"\\\\|\\\"\\n*?[\";\n\n\tp = buf + STRLEN(buf);\n\twhile (n-- > 0)\n\t{\n\t    // put a backslash before \\ and some others\n\t    if (vim_strchr(aux_ptr, *ptr) != NULL)\n\t\t*p++ = '\\\\';\n\t    // When current byte is a part of multibyte character, copy all\n\t    // bytes of that character.\n\t    if (has_mbyte)\n\t    {\n\t\tint i;\n\t\tint len = (*mb_ptr2len)(ptr) - 1;\n\n\t\tfor (i = 0; i < len && n >= 1; ++i, --n)\n\t\t    *p++ = *ptr++;\n\t    }\n\t    *p++ = *ptr++;\n\t}\n\t*p = NUL;\n    }\n\n    /*\n     * Execute the command.\n     */\n    if (cmdchar == '*' || cmdchar == '#')\n    {\n\tif (!g_cmd && (has_mbyte\n\t\t    ? vim_iswordp(mb_prevptr(ml_get_curline(), ptr))\n\t\t    : vim_iswordc(ptr[-1])))\n\t    STRCAT(buf, \"\\\\>\");\n\n\t// put pattern in search history\n\tinit_history();\n\tadd_to_history(HIST_SEARCH, buf, TRUE, NUL);\n\n\t(void)normal_search(cap, cmdchar == '*' ? '/' : '?', buf, 0, NULL);\n    }\n    else\n    {\n\tg_tag_at_cursor = TRUE;\n\tdo_cmdline_cmd(buf);\n\tg_tag_at_cursor = FALSE;\n    }\n\n    vim_free(buf);\n}\n\n/*\n * Get visually selected text, within one line only.\n * Returns FAIL if more than one line selected.\n */\n    int\nget_visual_text(\n    cmdarg_T\t*cap,\n    char_u\t**pp,\t    // return: start of selected text\n    int\t\t*lenp)\t    // return: length of selected text\n{\n    if (VIsual_mode != 'V')\n\tunadjust_for_sel();\n    if (VIsual.lnum != curwin->w_cursor.lnum)\n    {\n\tif (cap != NULL)\n\t    clearopbeep(cap->oap);\n\treturn FAIL;\n    }\n    if (VIsual_mode == 'V')\n    {\n\t*pp = ml_get_curline();\n\t*lenp = (int)STRLEN(*pp);\n    }\n    else\n    {\n\tif (LT_POS(curwin->w_cursor, VIsual))\n\t{\n\t    *pp = ml_get_pos(&curwin->w_cursor);\n\t    *lenp = VIsual.col - curwin->w_cursor.col + 1;\n\t}\n\telse\n\t{\n\t    *pp = ml_get_pos(&VIsual);\n\t    *lenp = curwin->w_cursor.col - VIsual.col + 1;\n\t}\n\tif (**pp == NUL)\n\t    *lenp = 0;\n\tif (has_mbyte && *lenp > 0)\n\t    // Correct the length to include all bytes of the last character.\n\t    *lenp += (*mb_ptr2len)(*pp + (*lenp - 1)) - 1;\n    }\n    reset_VIsual_and_resel();\n    return OK;\n}\n\n/*\n * CTRL-T: backwards in tag stack\n */\n    static void\nnv_tagpop(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n\tdo_tag((char_u *)\"\", DT_POP, (int)cap->count1, FALSE, TRUE);\n}\n\n/*\n * Handle scrolling command 'H', 'L' and 'M'.\n */\n    static void\nnv_scroll(cmdarg_T *cap)\n{\n    int\t\tused = 0;\n    long\tn;\n#ifdef FEAT_FOLDING\n    linenr_T\tlnum;\n#endif\n    int\t\thalf;\n\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    if (cap->cmdchar == 'L')\n    {\n\tvalidate_botline();\t    // make sure curwin->w_botline is valid\n\tcurwin->w_cursor.lnum = curwin->w_botline - 1;\n\tif (cap->count1 - 1 >= curwin->w_cursor.lnum)\n\t    curwin->w_cursor.lnum = 1;\n\telse\n\t{\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tfor (n = cap->count1 - 1; n > 0\n\t\t\t    && curwin->w_cursor.lnum > curwin->w_topline; --n)\n\t\t{\n\t\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\t\t    --curwin->w_cursor.lnum;\n\t\t}\n\t    }\n\t    else\n#endif\n\t\tcurwin->w_cursor.lnum -= cap->count1 - 1;\n\t}\n    }\n    else\n    {\n\tif (cap->cmdchar == 'M')\n\t{\n#ifdef FEAT_DIFF\n\t    // Don't count filler lines above the window.\n\t    used -= diff_check_fill(curwin, curwin->w_topline)\n\t\t\t\t\t\t\t  - curwin->w_topfill;\n#endif\n\t    validate_botline();\t    // make sure w_empty_rows is valid\n\t    half = (curwin->w_height - curwin->w_empty_rows + 1) / 2;\n\t    for (n = 0; curwin->w_topline + n < curbuf->b_ml.ml_line_count; ++n)\n\t    {\n#ifdef FEAT_DIFF\n\t\t// Count half he number of filler lines to be \"below this\n\t\t// line\" and half to be \"above the next line\".\n\t\tif (n > 0 && used + diff_check_fill(curwin, curwin->w_topline\n\t\t\t\t\t\t\t     + n) / 2 >= half)\n\t\t{\n\t\t    --n;\n\t\t    break;\n\t\t}\n#endif\n\t\tused += plines(curwin->w_topline + n);\n\t\tif (used >= half)\n\t\t    break;\n#ifdef FEAT_FOLDING\n\t\tif (hasFolding(curwin->w_topline + n, NULL, &lnum))\n\t\t    n = lnum - curwin->w_topline;\n#endif\n\t    }\n\t    if (n > 0 && used > curwin->w_height)\n\t\t--n;\n\t}\n\telse // (cap->cmdchar == 'H')\n\t{\n\t    n = cap->count1 - 1;\n#ifdef FEAT_FOLDING\n\t    if (hasAnyFolding(curwin))\n\t    {\n\t\t// Count a fold for one screen line.\n\t\tlnum = curwin->w_topline;\n\t\twhile (n-- > 0 && lnum < curwin->w_botline - 1)\n\t\t{\n\t\t    (void)hasFolding(lnum, NULL, &lnum);\n\t\t    ++lnum;\n\t\t}\n\t\tn = lnum - curwin->w_topline;\n\t    }\n#endif\n\t}\n\tcurwin->w_cursor.lnum = curwin->w_topline + n;\n\tif (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    curwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n    }\n\n    // Correct for 'so', except when an operator is pending.\n    if (cap->oap->op_type == OP_NOP)\n\tcursor_correct();\n    beginline(BL_SOL | BL_FIX);\n}\n\n/*\n * Cursor right commands.\n */\n    static void\nnv_right(cmdarg_T *cap)\n{\n    long\tn;\n    int\t\tpast_line;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Right> and <S-Right> move a word or WORD right\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = TRUE;\n\tnv_wordcmd(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    past_line = (VIsual_active && *p_sel != 'o');\n\n    /*\n     * In virtual edit mode, there's no such thing as \"past_line\", as lines\n     * are (theoretically) infinitely long.\n     */\n    if (virtual_active())\n\tpast_line = 0;\n\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif ((!past_line && oneright() == FAIL)\n\t\t|| (past_line && *ml_get_cursor() == NUL)\n\t\t)\n\t{\n\t    /*\n\t     *\t  <Space> wraps to next line if 'whichwrap' has 's'.\n\t     *\t      'l' wraps to next line if 'whichwrap' has 'l'.\n\t     * CURS_RIGHT wraps to next line if 'whichwrap' has '>'.\n\t     */\n\t    if (       ((cap->cmdchar == ' '\n\t\t\t    && vim_strchr(p_ww, 's') != NULL)\n\t\t\t|| (cap->cmdchar == 'l'\n\t\t\t    && vim_strchr(p_ww, 'l') != NULL)\n\t\t\t|| (cap->cmdchar == K_RIGHT\n\t\t\t    && vim_strchr(p_ww, '>') != NULL))\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n\t\t// When deleting we also count the NL as a character.\n\t\t// Set cap->oap->inclusive when last char in the line is\n\t\t// included, move to next line after that\n\t\tif (\t   cap->oap->op_type != OP_NOP\n\t\t\t&& !cap->oap->inclusive\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t\telse\n\t\t{\n\t\t    ++curwin->w_cursor.lnum;\n\t\t    curwin->w_cursor.col = 0;\n\t\t    curwin->w_cursor.coladd = 0;\n\t\t    curwin->w_set_curswant = TRUE;\n\t\t    cap->oap->inclusive = FALSE;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    if (cap->oap->op_type == OP_NOP)\n\t    {\n\t\t// Only beep and flush if not moved at all\n\t\tif (n == cap->count1)\n\t\t    beep_flush();\n\t    }\n\t    else\n\t    {\n\t\tif (!LINEEMPTY(curwin->w_cursor.lnum))\n\t\t    cap->oap->inclusive = TRUE;\n\t    }\n\t    break;\n\t}\n\telse if (past_line)\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    if (virtual_active())\n\t\toneright();\n\t    else\n\t    {\n\t\tif (has_mbyte)\n\t\t    curwin->w_cursor.col += (*mb_ptr2len)(ml_get_cursor());\n\t\telse\n\t\t    ++curwin->w_cursor.col;\n\t    }\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor left commands.\n *\n * Returns TRUE when operator end should not be adjusted.\n */\n    static void\nnv_left(cmdarg_T *cap)\n{\n    long\tn;\n\n    if (mod_mask & (MOD_MASK_SHIFT | MOD_MASK_CTRL))\n    {\n\t// <C-Left> and <S-Left> move a word or WORD left\n\tif (mod_mask & MOD_MASK_CTRL)\n\t    cap->arg = 1;\n\tnv_bck_word(cap);\n\treturn;\n    }\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    for (n = cap->count1; n > 0; --n)\n    {\n\tif (oneleft() == FAIL)\n\t{\n\t    // <BS> and <Del> wrap to previous line if 'whichwrap' has 'b'.\n\t    //\t\t 'h' wraps to previous line if 'whichwrap' has 'h'.\n\t    //\t   CURS_LEFT wraps to previous line if 'whichwrap' has '<'.\n\t    if (       (((cap->cmdchar == K_BS\n\t\t\t\t|| cap->cmdchar == Ctrl_H)\n\t\t\t    && vim_strchr(p_ww, 'b') != NULL)\n\t\t\t|| (cap->cmdchar == 'h'\n\t\t\t    && vim_strchr(p_ww, 'h') != NULL)\n\t\t\t|| (cap->cmdchar == K_LEFT\n\t\t\t    && vim_strchr(p_ww, '<') != NULL))\n\t\t    && curwin->w_cursor.lnum > 1)\n\t    {\n\t\t--(curwin->w_cursor.lnum);\n\t\tcoladvance((colnr_T)MAXCOL);\n\t\tcurwin->w_set_curswant = TRUE;\n\n\t\t// When the NL before the first char has to be deleted we\n\t\t// put the cursor on the NUL after the previous line.\n\t\t// This is a very special case, be careful!\n\t\t// Don't adjust op_end now, otherwise it won't work.\n\t\tif (\t   (cap->oap->op_type == OP_DELETE\n\t\t\t    || cap->oap->op_type == OP_CHANGE)\n\t\t\t&& !LINEEMPTY(curwin->w_cursor.lnum))\n\t\t{\n\t\t    char_u *cp = ml_get_cursor();\n\n\t\t    if (*cp != NUL)\n\t\t    {\n\t\t\tif (has_mbyte)\n\t\t\t    curwin->w_cursor.col += (*mb_ptr2len)(cp);\n\t\t\telse\n\t\t\t    ++curwin->w_cursor.col;\n\t\t    }\n\t\t    cap->retval |= CA_NO_ADJ_OP_END;\n\t\t}\n\t\tcontinue;\n\t    }\n\t    // Only beep and flush if not moved at all\n\t    else if (cap->oap->op_type == OP_NOP && n == cap->count1)\n\t\tbeep_flush();\n\t    break;\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (n != cap->count1 && (fdo_flags & FDO_HOR) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Cursor up commands.\n * cap->arg is TRUE for \"-\": Move cursor to first non-blank.\n */\n    static void\nnv_up(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Up> is page up\n\tcap->arg = BACKWARD;\n\tnv_page(cap);\n    }\n    else\n    {\n\tcap->oap->motion_type = MLINE;\n\tif (cursor_up(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse if (cap->arg)\n\t    beginline(BL_WHITE | BL_FIX);\n    }\n}\n\n/*\n * Cursor down commands.\n * cap->arg is TRUE for CR and \"+\": Move cursor to first non-blank.\n */\n    static void\nnv_down(cmdarg_T *cap)\n{\n    if (mod_mask & MOD_MASK_SHIFT)\n    {\n\t// <S-Down> is page down\n\tcap->arg = FORWARD;\n\tnv_page(cap);\n    }\n#if defined(FEAT_QUICKFIX)\n    // Quickfix window only: view the result under the cursor.\n    else if (bt_quickfix(curbuf) && cap->cmdchar == CAR)\n\tqf_view_result(FALSE);\n#endif\n    else\n    {\n#ifdef FEAT_CMDWIN\n\t// In the cmdline window a <CR> executes the command.\n\tif (cmdwin_type != 0 && cap->cmdchar == CAR)\n\t    cmdwin_result = CAR;\n\telse\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t// In a prompt buffer a <CR> in the last line invokes the callback.\n\tif (bt_prompt(curbuf) && cap->cmdchar == CAR\n\t\t       && curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count)\n\t{\n\t    invoke_prompt_callback();\n\t    if (restart_edit == 0)\n\t\trestart_edit = 'a';\n\t}\n\telse\n#endif\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    if (cursor_down(cap->count1, cap->oap->op_type == OP_NOP) == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    else if (cap->arg)\n\t\tbeginline(BL_WHITE | BL_FIX);\n\t}\n    }\n}\n\n#ifdef FEAT_SEARCHPATH\n/*\n * Grab the file name under the cursor and edit it.\n */\n    static void\nnv_gotofile(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    linenr_T\tlnum = -1;\n\n    if (text_locked())\n    {\n\tclearopbeep(cap->oap);\n\ttext_locked_msg();\n\treturn;\n    }\n    if (curbuf_locked())\n    {\n\tclearop(cap->oap);\n\treturn;\n    }\n#ifdef FEAT_PROP_POPUP\n    if (ERROR_IF_TERM_POPUP_WINDOW)\n\treturn;\n#endif\n\n    ptr = grab_file_name(cap->count1, &lnum);\n\n    if (ptr != NULL)\n    {\n\t// do autowrite if necessary\n\tif (curbufIsChanged() && curbuf->b_nwindows <= 1 && !buf_hide(curbuf))\n\t    (void)autowrite(curbuf, FALSE);\n\tsetpcmark();\n\tif (do_ecmd(0, ptr, NULL, NULL, ECMD_LAST,\n\t\t\t\tbuf_hide(curbuf) ? ECMD_HIDE : 0, curwin) == OK\n\t\t&& cap->nchar == 'F' && lnum >= 0)\n\t{\n\t    curwin->w_cursor.lnum = lnum;\n\t    check_cursor_lnum();\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n\tvim_free(ptr);\n    }\n    else\n\tclearop(cap->oap);\n}\n#endif\n\n/*\n * <End> command: to end of current line or last line.\n */\n    static void\nnv_end(cmdarg_T *cap)\n{\n    if (cap->arg || (mod_mask & MOD_MASK_CTRL))\t// CTRL-END = goto last line\n    {\n\tcap->arg = TRUE;\n\tnv_goto(cap);\n\tcap->count1 = 1;\t\t// to end of current line\n    }\n    nv_dollar(cap);\n}\n\n/*\n * Handle the \"$\" command.\n */\n    static void\nnv_dollar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = TRUE;\n    // In virtual mode when off the edge of a line and an operator\n    // is pending (whew!) keep the cursor where it is.\n    // Otherwise, send it to the end of the line.\n    if (!virtual_active() || gchar_cursor() != NUL\n\t\t\t\t\t       || cap->oap->op_type == OP_NOP)\n\tcurwin->w_curswant = MAXCOL;\t// so we stay at the end\n    if (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Implementation of '?' and '/' commands.\n * If cap->arg is TRUE don't set PC mark.\n */\n    static void\nnv_search(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\tsave_cursor = curwin->w_cursor;\n\n    if (cap->cmdchar == '?' && cap->oap->op_type == OP_ROT13)\n    {\n\t// Translate \"g??\" to \"g?g?\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = '?';\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // When using 'incsearch' the cursor may be moved to set a different search\n    // start position.\n    cap->searchbuf = getcmdline(cap->cmdchar, cap->count1, 0, TRUE);\n\n    if (cap->searchbuf == NULL)\n    {\n\tclearop(oap);\n\treturn;\n    }\n\n    (void)normal_search(cap, cap->cmdchar, cap->searchbuf,\n\t\t\t(cap->arg || !EQUAL_POS(save_cursor, curwin->w_cursor))\n\t\t\t\t\t\t      ? 0 : SEARCH_MARK, NULL);\n}\n\n/*\n * Handle \"N\" and \"n\" commands.\n * cap->arg is SEARCH_REV for \"N\", 0 for \"n\".\n */\n    static void\nnv_next(cmdarg_T *cap)\n{\n    pos_T   old = curwin->w_cursor;\n    int\t    wrapped = FALSE;\n    int\t    i = normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, &wrapped);\n\n    if (i == 1 && !wrapped && EQUAL_POS(old, curwin->w_cursor))\n    {\n\t// Avoid getting stuck on the current cursor position, which can\n\t// happen when an offset is given and the cursor is on the last char\n\t// in the buffer: Repeat with count + 1.\n\tcap->count1 += 1;\n\t(void)normal_search(cap, 0, NULL, SEARCH_MARK | cap->arg, NULL);\n\tcap->count1 -= 1;\n    }\n}\n\n/*\n * Search for \"pat\" in direction \"dir\" ('/' or '?', 0 for repeat).\n * Uses only cap->count1 and cap->oap from \"cap\".\n * Return 0 for failure, 1 for found, 2 for found and line offset added.\n */\n    static int\nnormal_search(\n    cmdarg_T\t*cap,\n    int\t\tdir,\n    char_u\t*pat,\n    int\t\topt,\t\t// extra flags for do_search()\n    int\t\t*wrapped)\n{\n    int\t\ti;\n    searchit_arg_T sia;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n\n    CLEAR_FIELD(sia);\n    i = do_search(cap->oap, dir, dir, pat, cap->count1,\n\t\t\t    opt | SEARCH_OPT | SEARCH_ECHO | SEARCH_MSG, &sia);\n    if (wrapped != NULL)\n\t*wrapped = sia.sa_wrapped;\n    if (i == 0)\n\tclearop(cap->oap);\n    else\n    {\n\tif (i == 2)\n\t    cap->oap->motion_type = MLINE;\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n#endif\n    }\n\n    // \"/$\" will put the cursor after the end of the line, may need to\n    // correct that here\n    check_cursor();\n    return i;\n}\n\n/*\n * Character search commands.\n * cap->arg is BACKWARD for 'F' and 'T', FORWARD for 'f' and 't', TRUE for\n * ',' and FALSE for ';'.\n * cap->nchar is NUL for ',' and ';' (repeat the search)\n */\n    static void\nnv_csearch(cmdarg_T *cap)\n{\n    int\t\tt_cmd;\n\n    if (cap->cmdchar == 't' || cap->cmdchar == 'T')\n\tt_cmd = TRUE;\n    else\n\tt_cmd = FALSE;\n\n    cap->oap->motion_type = MCHAR;\n    if (IS_SPECIAL(cap->nchar) || searchc(cap, t_cmd) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_set_curswant = TRUE;\n\t// Include a Tab for \"tx\" and for \"dfx\".\n\tif (gchar_cursor() == TAB && virtual_active() && cap->arg == FORWARD\n\t\t&& (t_cmd || cap->oap->op_type != OP_NOP))\n\t{\n\t    colnr_T\tscol, ecol;\n\n\t    getvcol(curwin, &curwin->w_cursor, &scol, NULL, &ecol);\n\t    curwin->w_cursor.coladd = ecol - scol;\n\t}\n\telse\n\t    curwin->w_cursor.coladd = 0;\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"[\" and \"]\" commands.\n * cap->arg is BACKWARD for \"[\" and FORWARD for \"]\".\n */\n    static void\nnv_brackets(cmdarg_T *cap)\n{\n    pos_T\tnew_pos = {0, 0, 0};\n    pos_T\tprev_pos;\n    pos_T\t*pos = NULL;\t    // init for GCC\n    pos_T\told_pos;\t    // cursor position before command\n    int\t\tflag;\n    long\tn;\n    int\t\tfindc;\n    int\t\tc;\n\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    old_pos = curwin->w_cursor;\n    curwin->w_cursor.coladd = 0;    // TODO: don't do this for an error.\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"[f\" or \"]f\" : Edit file under the cursor (same as \"gf\")\n     */\n    if (cap->nchar == 'f')\n\tnv_gotofile(cap);\n    else\n#endif\n\n#ifdef FEAT_FIND_ID\n    /*\n     * Find the occurrence(s) of the identifier or define under cursor\n     * in current and included files or jump to the first occurrence.\n     *\n     *\t\t\tsearch\t     list\t    jump\n     *\t\t      fwd   bwd    fwd\t bwd\t fwd\tbwd\n     * identifier     \"]i\"  \"[i\"   \"]I\"  \"[I\"\t\"]^I\"  \"[^I\"\n     * define\t      \"]d\"  \"[d\"   \"]D\"  \"[D\"\t\"]^D\"  \"[^D\"\n     */\n    if (vim_strchr((char_u *)\n# ifdef EBCDIC\n\t\t\"iI\\005dD\\067\",\n# else\n\t\t\"iI\\011dD\\004\",\n# endif\n\t\tcap->nchar) != NULL)\n    {\n\tchar_u\t*ptr;\n\tint\tlen;\n\n\tif ((len = find_ident_under_cursor(&ptr, FIND_IDENT)) == 0)\n\t    clearop(cap->oap);\n\telse\n\t{\n\t    find_pattern_in_path(ptr, 0, len, TRUE,\n\t\tcap->count0 == 0 ? !isupper(cap->nchar) : FALSE,\n\t\t((cap->nchar & 0xf) == ('d' & 0xf)) ?  FIND_DEFINE : FIND_ANY,\n\t\tcap->count1,\n\t\tisupper(cap->nchar) ? ACTION_SHOW_ALL :\n\t\t\t    islower(cap->nchar) ? ACTION_SHOW : ACTION_GOTO,\n\t\tcap->cmdchar == ']' ? curwin->w_cursor.lnum + 1 : (linenr_T)1,\n\t\t(linenr_T)MAXLNUM);\n\t    curwin->w_set_curswant = TRUE;\n\t}\n    }\n    else\n#endif\n\n    /*\n     * \"[{\", \"[(\", \"]}\" or \"])\": go to Nth unclosed '{', '(', '}' or ')'\n     * \"[#\", \"]#\": go to start/end of Nth innermost #if..#endif construct.\n     * \"[/\", \"[*\", \"]/\", \"]*\": go to Nth comment start/end.\n     * \"[m\" or \"]m\" search for prev/next start of (Java) method.\n     * \"[M\" or \"]M\" search for prev/next end of (Java) method.\n     */\n    if (  (cap->cmdchar == '['\n\t\t&& vim_strchr((char_u *)\"{(*/#mM\", cap->nchar) != NULL)\n\t    || (cap->cmdchar == ']'\n\t\t&& vim_strchr((char_u *)\"})*/#mM\", cap->nchar) != NULL))\n    {\n\tif (cap->nchar == '*')\n\t    cap->nchar = '/';\n\tprev_pos.lnum = 0;\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    if (cap->cmdchar == '[')\n\t\tfindc = '{';\n\t    else\n\t\tfindc = '}';\n\t    n = 9999;\n\t}\n\telse\n\t{\n\t    findc = cap->nchar;\n\t    n = cap->count1;\n\t}\n\tfor ( ; n > 0; --n)\n\t{\n\t    if ((pos = findmatchlimit(cap->oap, findc,\n\t\t(cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD, 0)) == NULL)\n\t    {\n\t\tif (new_pos.lnum == 0)\t// nothing found\n\t\t{\n\t\t    if (cap->nchar != 'm' && cap->nchar != 'M')\n\t\t\tclearopbeep(cap->oap);\n\t\t}\n\t\telse\n\t\t    pos = &new_pos;\t// use last one found\n\t\tbreak;\n\t    }\n\t    prev_pos = new_pos;\n\t    curwin->w_cursor = *pos;\n\t    new_pos = *pos;\n\t}\n\tcurwin->w_cursor = old_pos;\n\n\t/*\n\t * Handle \"[m\", \"]m\", \"[M\" and \"[M\".  The findmatchlimit() only\n\t * brought us to the match for \"[m\" and \"]M\" when inside a method.\n\t * Try finding the '{' or '}' we want to be at.\n\t * Also repeat for the given count.\n\t */\n\tif (cap->nchar == 'm' || cap->nchar == 'M')\n\t{\n\t    // norm is TRUE for \"]M\" and \"[m\"\n\t    int\t    norm = ((findc == '{') == (cap->nchar == 'm'));\n\n\t    n = cap->count1;\n\t    // found a match: we were inside a method\n\t    if (prev_pos.lnum != 0)\n\t    {\n\t\tpos = &prev_pos;\n\t\tcurwin->w_cursor = prev_pos;\n\t\tif (norm)\n\t\t    --n;\n\t    }\n\t    else\n\t\tpos = NULL;\n\t    while (n > 0)\n\t    {\n\t\tfor (;;)\n\t\t{\n\t\t    if ((findc == '{' ? dec_cursor() : inc_cursor()) < 0)\n\t\t    {\n\t\t\t// if not found anything, that's an error\n\t\t\tif (pos == NULL)\n\t\t\t    clearopbeep(cap->oap);\n\t\t\tn = 0;\n\t\t\tbreak;\n\t\t    }\n\t\t    c = gchar_cursor();\n\t\t    if (c == '{' || c == '}')\n\t\t    {\n\t\t\t// Must have found end/start of class: use it.\n\t\t\t// Or found the place to be at.\n\t\t\tif ((c == findc && norm) || (n == 1 && !norm))\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t    n = 0;\n\t\t\t}\n\t\t\t// if no match found at all, we started outside of the\n\t\t\t// class and we're inside now.  Just go on.\n\t\t\telse if (new_pos.lnum == 0)\n\t\t\t{\n\t\t\t    new_pos = curwin->w_cursor;\n\t\t\t    pos = &new_pos;\n\t\t\t}\n\t\t\t// found start/end of other method: go to match\n\t\t\telse if ((pos = findmatchlimit(cap->oap, findc,\n\t\t\t    (cap->cmdchar == '[') ? FM_BACKWARD : FM_FORWARD,\n\t\t\t\t\t\t\t\t  0)) == NULL)\n\t\t\t    n = 0;\n\t\t\telse\n\t\t\t    curwin->w_cursor = *pos;\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t\t--n;\n\t    }\n\t    curwin->w_cursor = old_pos;\n\t    if (pos == NULL && new_pos.lnum != 0)\n\t\tclearopbeep(cap->oap);\n\t}\n\tif (pos != NULL)\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped\n\t\t\t\t\t       && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[[\", \"[]\", \"]]\" and \"][\": move to start or end of function\n     */\n    else if (cap->nchar == '[' || cap->nchar == ']')\n    {\n\tif (cap->nchar == cap->cmdchar)\t\t    // \"]]\" or \"[[\"\n\t    flag = '{';\n\telse\n\t    flag = '}';\t\t    // \"][\" or \"[]\"\n\n\tcurwin->w_set_curswant = TRUE;\n\t/*\n\t * Imitate strange Vi behaviour: When using \"]]\" with an operator\n\t * we also stop at '}'.\n\t */\n\tif (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, flag,\n\t      (cap->oap->op_type != OP_NOP\n\t\t\t\t      && cap->arg == FORWARD && flag == '{')))\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    if (cap->oap->op_type == OP_NOP)\n\t\tbeginline(BL_WHITE | BL_FIX);\n#ifdef FEAT_FOLDING\n\t    if ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t\tfoldOpenCursor();\n#endif\n\t}\n    }\n\n    /*\n     * \"[p\", \"[P\", \"]P\" and \"]p\": put with indent adjustment\n     */\n    else if (cap->nchar == 'p' || cap->nchar == 'P')\n    {\n\tnv_put_opt(cap, TRUE);\n    }\n\n    /*\n     * \"['\", \"[`\", \"]'\" and \"]`\": jump to next mark\n     */\n    else if (cap->nchar == '\\'' || cap->nchar == '`')\n    {\n\tpos = &curwin->w_cursor;\n\tfor (n = cap->count1; n > 0; --n)\n\t{\n\t    prev_pos = *pos;\n\t    pos = getnextmark(pos, cap->cmdchar == '[' ? BACKWARD : FORWARD,\n\t\t\t\t\t\t\t  cap->nchar == '\\'');\n\t    if (pos == NULL)\n\t\tbreak;\n\t}\n\tif (pos == NULL)\n\t    pos = &prev_pos;\n\tnv_cursormark(cap, cap->nchar == '\\'', pos);\n    }\n\n    /*\n     * [ or ] followed by a middle mouse click: put selected text with\n     * indent adjustment.  Any other button just does as usual.\n     */\n    else if (cap->nchar >= K_RIGHTRELEASE && cap->nchar <= K_LEFTMOUSE)\n    {\n\t(void)do_mouse(cap->oap, cap->nchar,\n\t\t       (cap->cmdchar == ']') ? FORWARD : BACKWARD,\n\t\t       cap->count1, PUT_FIXINDENT);\n    }\n\n#ifdef FEAT_FOLDING\n    /*\n     * \"[z\" and \"]z\": move to start or end of open fold.\n     */\n    else if (cap->nchar == 'z')\n    {\n\tif (foldMoveTo(FALSE, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_DIFF\n    /*\n     * \"[c\" and \"]c\": move to next or previous diff-change.\n     */\n    else if (cap->nchar == 'c')\n    {\n\tif (diff_move_to(cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t\t\t\t\t cap->count1) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n#endif\n\n#ifdef FEAT_SPELL\n    /*\n     * \"[s\", \"[S\", \"]s\" and \"]S\": move to next spell error.\n     */\n    else if (cap->nchar == 's' || cap->nchar == 'S')\n    {\n\tsetpcmark();\n\tfor (n = 0; n < cap->count1; ++n)\n\t    if (spell_move_to(curwin, cap->cmdchar == ']' ? FORWARD : BACKWARD,\n\t\t\t  cap->nchar == 's' ? TRUE : FALSE, FALSE, NULL) == 0)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\tbreak;\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP && (fdo_flags & FDO_SEARCH) && KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#endif\n\n    // Not a valid cap->nchar.\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle Normal mode \"%\" command.\n */\n    static void\nnv_percent(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n#if defined(FEAT_FOLDING)\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n#endif\n\n    cap->oap->inclusive = TRUE;\n    if (cap->count0)\t    // {cnt}% : goto {cnt} percentage in file\n    {\n\tif (cap->count0 > 100)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    cap->oap->motion_type = MLINE;\n\t    setpcmark();\n\t    // Round up, so 'normal 100%' always jumps at the line line.\n\t    // Beyond 21474836 lines, (ml_line_count * 100 + 99) would\n\t    // overflow on 32-bits, so use a formula with less accuracy\n\t    // to avoid overflows.\n\t    if (curbuf->b_ml.ml_line_count >= 21474836)\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count + 99L)\n\t\t\t\t\t\t\t / 100L * cap->count0;\n\t    else\n\t\tcurwin->w_cursor.lnum = (curbuf->b_ml.ml_line_count *\n\t\t\t\t\t\t    cap->count0 + 99L) / 100L;\n\t    if (curwin->w_cursor.lnum < 1)\n\t\tcurwin->w_cursor.lnum = 1;\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t    beginline(BL_SOL | BL_FIX);\n\t}\n    }\n    else\t\t    // \"%\" : go to matching paren\n    {\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->use_reg_one = TRUE;\n\tif ((pos = findmatch(cap->oap, NUL)) == NULL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    setpcmark();\n\t    curwin->w_cursor = *pos;\n\t    curwin->w_set_curswant = TRUE;\n\t    curwin->w_cursor.coladd = 0;\n\t    adjust_for_sel(cap);\n\t}\n    }\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && lnum != curwin->w_cursor.lnum\n\t    && (fdo_flags & FDO_PERCENT)\n\t    && KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle \"(\" and \")\" commands.\n * cap->arg is BACKWARD for \"(\" and FORWARD for \")\".\n */\n    static void\nnv_brace(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->use_reg_one = TRUE;\n    // The motion used to be inclusive for \"(\", but that is not what Vi does.\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n\n    if (findsent(cap->arg, cap->count1) == FAIL)\n\tclearopbeep(cap->oap);\n    else\n    {\n\t// Don't leave the cursor on the NUL past end of line.\n\tadjust_cursor(cap->oap);\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"m\" command: Mark a position.\n */\n    static void\nnv_mark(cmdarg_T *cap)\n{\n    if (!checkclearop(cap->oap))\n    {\n\tif (setmark(cap->nchar) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * \"{\" and \"}\" commands.\n * cmd->arg is BACKWARD for \"{\" and FORWARD for \"}\".\n */\n    static void\nnv_findpar(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    cap->oap->use_reg_one = TRUE;\n    curwin->w_set_curswant = TRUE;\n    if (!findpar(&cap->oap->inclusive, cap->arg, cap->count1, NUL, FALSE))\n\tclearopbeep(cap->oap);\n    else\n    {\n\tcurwin->w_cursor.coladd = 0;\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_BLOCK) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * \"u\" command: Undo or make lower case.\n */\n    static void\nnv_undo(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_LOWER || VIsual_active)\n    {\n\t// translate \"<Visual>u\" to \"<Visual>gu\" and \"guu\" to \"gugu\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'u';\n\tnv_operator(cap);\n    }\n    else\n\tnv_kundo(cap);\n}\n\n/*\n * <Undo> command.\n */\n    static void\nnv_kundo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf))\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tu_undo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle the \"r\" command.\n */\n    static void\nnv_replace(cmdarg_T *cap)\n{\n    char_u\t*ptr;\n    int\t\thad_ctrl_v;\n    long\tn;\n\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    // get another character\n    if (cap->nchar == Ctrl_V)\n    {\n\thad_ctrl_v = Ctrl_V;\n\tcap->nchar = get_literal(FALSE);\n\t// Don't redo a multibyte character with CTRL-V.\n\tif (cap->nchar > DEL)\n\t    had_ctrl_v = NUL;\n    }\n    else\n\thad_ctrl_v = NUL;\n\n    // Abort if the character is a special key.\n    if (IS_SPECIAL(cap->nchar))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    // Visual mode \"r\"\n    if (VIsual_active)\n    {\n\tif (got_int)\n\t    reset_VIsual();\n\tif (had_ctrl_v)\n\t{\n\t    // Use a special (negative) number to make a difference between a\n\t    // literal CR or NL and a line break.\n\t    if (cap->nchar == CAR)\n\t\tcap->nchar = REPLACE_CR_NCHAR;\n\t    else if (cap->nchar == NL)\n\t\tcap->nchar = REPLACE_NL_NCHAR;\n\t}\n\tnv_operator(cap);\n\treturn;\n    }\n\n    // Break tabs, etc.\n    if (virtual_active())\n    {\n\tif (u_save_cursor() == FAIL)\n\t    return;\n\tif (gchar_cursor() == NUL)\n\t{\n\t    // Add extra space and put the cursor on the first one.\n\t    coladvance_force((colnr_T)(getviscol() + cap->count1));\n\t    curwin->w_cursor.col -= cap->count1;\n\t}\n\telse if (gchar_cursor() == TAB)\n\t    coladvance_force(getviscol());\n    }\n\n    // Abort if not enough characters to replace.\n    ptr = ml_get_cursor();\n    if (STRLEN(ptr) < (unsigned)cap->count1\n\t    || (has_mbyte && mb_charlen(ptr) < cap->count1))\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    /*\n     * Replacing with a TAB is done by edit() when it is complicated because\n     * 'expandtab' or 'smarttab' is set.  CTRL-V TAB inserts a literal TAB.\n     * Other characters are done below to avoid problems with things like\n     * CTRL-V 048 (for edit() this would be R CTRL-V 0 ESC).\n     */\n    if (had_ctrl_v != Ctrl_V && cap->nchar == '\\t' && (curbuf->b_p_et || p_sta))\n    {\n\tstuffnumReadbuff(cap->count1);\n\tstuffcharReadbuff('R');\n\tstuffcharReadbuff('\\t');\n\tstuffcharReadbuff(ESC);\n\treturn;\n    }\n\n    // save line for undo\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    if (had_ctrl_v != Ctrl_V && (cap->nchar == '\\r' || cap->nchar == '\\n'))\n    {\n\t/*\n\t * Replace character(s) by a single newline.\n\t * Strange vi behaviour: Only one newline is inserted.\n\t * Delete the characters here.\n\t * Insert the newline with an insert command, takes care of\n\t * autoindent.\tThe insert command depends on being on the last\n\t * character of a line or not.\n\t */\n\t(void)del_chars(cap->count1, FALSE);\t// delete the characters\n\tstuffcharReadbuff('\\r');\n\tstuffcharReadbuff(ESC);\n\n\t// Give 'r' to edit(), to get the redo command right.\n\tinvoke_edit(cap, TRUE, 'r', FALSE);\n    }\n    else\n    {\n\tprep_redo(cap->oap->regname, cap->count1,\n\t\t\t\t       NUL, 'r', NUL, had_ctrl_v, cap->nchar);\n\n\tcurbuf->b_op_start = curwin->w_cursor;\n\tif (has_mbyte)\n\t{\n\t    int\t\told_State = State;\n\n\t    if (cap->ncharC1 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC1);\n\t    if (cap->ncharC2 != 0)\n\t\tAppendCharToRedobuff(cap->ncharC2);\n\n\t    // This is slow, but it handles replacing a single-byte with a\n\t    // multi-byte and the other way around.  Also handles adding\n\t    // composing characters for utf-8.\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\tState = REPLACE;\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t    int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\t\t    if (c != NUL)\n\t\t\tins_char(c);\n\t\t    else\n\t\t\t// will be decremented further down\n\t\t\t++curwin->w_cursor.col;\n\t\t}\n\t\telse\n\t\t    ins_char(cap->nchar);\n\t\tState = old_State;\n\t\tif (cap->ncharC1 != 0)\n\t\t    ins_char(cap->ncharC1);\n\t\tif (cap->ncharC2 != 0)\n\t\t    ins_char(cap->ncharC2);\n\t    }\n\t}\n\telse\n\t{\n\t    /*\n\t     * Replace the characters within one line.\n\t     */\n\t    for (n = cap->count1; n > 0; --n)\n\t    {\n\t\t/*\n\t\t * Get ptr again, because u_save and/or showmatch() will have\n\t\t * released the line.  This may also happen in ins_copychar().\n\t\t * At the same time we let know that the line will be changed.\n\t\t */\n\t\tif (cap->nchar == Ctrl_E || cap->nchar == Ctrl_Y)\n\t\t{\n\t\t  int c = ins_copychar(curwin->w_cursor.lnum\n\t\t\t\t\t   + (cap->nchar == Ctrl_Y ? -1 : 1));\n\n\t\t  ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t  if (c != NUL)\n\t\t    ptr[curwin->w_cursor.col] = c;\n\t\t}\n\t\telse\n\t\t{\n\t\t    ptr = ml_get_buf(curbuf, curwin->w_cursor.lnum, TRUE);\n\t\t    ptr[curwin->w_cursor.col] = cap->nchar;\n\t\t}\n\t\tif (p_sm && msg_silent == 0)\n\t\t    showmatch(cap->nchar);\n\t\t++curwin->w_cursor.col;\n\t    }\n#ifdef FEAT_NETBEANS_INTG\n\t    if (netbeans_active())\n\t    {\n\t\tcolnr_T  start = (colnr_T)(curwin->w_cursor.col - cap->count1);\n\n\t\tnetbeans_removed(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t\t\t   (long)cap->count1);\n\t\tnetbeans_inserted(curbuf, curwin->w_cursor.lnum, start,\n\t\t\t\t\t       &ptr[start], (int)cap->count1);\n\t    }\n#endif\n\n\t    // mark the buffer as changed and prepare for displaying\n\t    changed_bytes(curwin->w_cursor.lnum,\n\t\t\t       (colnr_T)(curwin->w_cursor.col - cap->count1));\n\t}\n\t--curwin->w_cursor.col;\t    // cursor on the last replaced char\n\t// if the character on the left of the current cursor is a multi-byte\n\t// character, move two characters left\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tcurwin->w_set_curswant = TRUE;\n\tset_last_insert(cap->nchar);\n    }\n}\n\n/*\n * 'o': Exchange start and end of Visual area.\n * 'O': same, but in block mode exchange left and right corners.\n */\n    static void\nv_swap_corners(int cmdchar)\n{\n    pos_T\told_cursor;\n    colnr_T\tleft, right;\n\n    if (cmdchar == 'O' && VIsual_mode == Ctrl_V)\n    {\n\told_cursor = curwin->w_cursor;\n\tgetvcols(curwin, &old_cursor, &VIsual, &left, &right);\n\tcurwin->w_cursor.lnum = VIsual.lnum;\n\tcoladvance(left);\n\tVIsual = curwin->w_cursor;\n\n\tcurwin->w_cursor.lnum = old_cursor.lnum;\n\tcurwin->w_curswant = right;\n\t// 'selection \"exclusive\" and cursor at right-bottom corner: move it\n\t// right one column\n\tif (old_cursor.lnum >= VIsual.lnum && *p_sel == 'e')\n\t    ++curwin->w_curswant;\n\tcoladvance(curwin->w_curswant);\n\tif (curwin->w_cursor.col == old_cursor.col\n\t\t&& (!virtual_active()\n\t\t    || curwin->w_cursor.coladd == old_cursor.coladd))\n\t{\n\t    curwin->w_cursor.lnum = VIsual.lnum;\n\t    if (old_cursor.lnum <= VIsual.lnum && *p_sel == 'e')\n\t\t++right;\n\t    coladvance(right);\n\t    VIsual = curwin->w_cursor;\n\n\t    curwin->w_cursor.lnum = old_cursor.lnum;\n\t    coladvance(left);\n\t    curwin->w_curswant = left;\n\t}\n    }\n    else\n    {\n\told_cursor = curwin->w_cursor;\n\tcurwin->w_cursor = VIsual;\n\tVIsual = old_cursor;\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * \"R\" (cap->arg is FALSE) and \"gR\" (cap->arg is TRUE).\n */\n    static void\nnv_Replace(cmdarg_T *cap)\n{\n    if (VIsual_active)\t\t// \"R\" is replace lines\n    {\n\tcap->cmdchar = 'c';\n\tcap->nchar = NUL;\n\tVIsual_mode_orig = VIsual_mode; // remember original area for gv\n\tVIsual_mode = 'V';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, FALSE, cap->arg ? 'V' : 'R', FALSE);\n\t}\n    }\n}\n\n/*\n * \"gr\".\n */\n    static void\nnv_vreplace(cmdarg_T *cap)\n{\n    if (VIsual_active)\n    {\n\tcap->cmdchar = 'r';\n\tcap->nchar = cap->extra_char;\n\tnv_replace(cap);\t// Do same as \"r\" in Visual mode for now\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tif (!curbuf->b_p_ma)\n\t    emsg(_(e_cannot_make_changes_modifiable_is_off));\n\telse\n\t{\n\t    if (cap->extra_char == Ctrl_V)\t// get another character\n\t\tcap->extra_char = get_literal(FALSE);\n\t    stuffcharReadbuff(cap->extra_char);\n\t    stuffcharReadbuff(ESC);\n\t    if (virtual_active())\n\t\tcoladvance(getviscol());\n\t    invoke_edit(cap, TRUE, 'v', FALSE);\n\t}\n    }\n}\n\n/*\n * Swap case for \"~\" command, when it does not work like an operator.\n */\n    static void\nn_swapchar(cmdarg_T *cap)\n{\n    long\tn;\n    pos_T\tstartpos;\n    int\t\tdid_change = 0;\n#ifdef FEAT_NETBEANS_INTG\n    pos_T\tpos;\n    char_u\t*ptr;\n    int\t\tcount;\n#endif\n\n    if (checkclearopq(cap->oap))\n\treturn;\n\n    if (LINEEMPTY(curwin->w_cursor.lnum) && vim_strchr(p_ww, '~') == NULL)\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n\n    prep_redo_cmd(cap);\n\n    if (u_save_cursor() == FAIL)\n\treturn;\n\n    startpos = curwin->w_cursor;\n#ifdef FEAT_NETBEANS_INTG\n    pos = startpos;\n#endif\n    for (n = cap->count1; n > 0; --n)\n    {\n\tdid_change |= swapchar(cap->oap->op_type, &curwin->w_cursor);\n\tinc_cursor();\n\tif (gchar_cursor() == NUL)\n\t{\n\t    if (vim_strchr(p_ww, '~') != NULL\n\t\t    && curwin->w_cursor.lnum < curbuf->b_ml.ml_line_count)\n\t    {\n#ifdef FEAT_NETBEANS_INTG\n\t\tif (netbeans_active())\n\t\t{\n\t\t    if (did_change)\n\t\t    {\n\t\t\tptr = ml_get(pos.lnum);\n\t\t\tcount = (int)STRLEN(ptr) - pos.col;\n\t\t\tnetbeans_removed(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t\t (long)count);\n\t\t\tnetbeans_inserted(curbuf, pos.lnum, pos.col,\n\t\t\t\t\t\t\t&ptr[pos.col], count);\n\t\t    }\n\t\t    pos.col = 0;\n\t\t    pos.lnum++;\n\t\t}\n#endif\n\t\t++curwin->w_cursor.lnum;\n\t\tcurwin->w_cursor.col = 0;\n\t\tif (n > 1)\n\t\t{\n\t\t    if (u_savesub(curwin->w_cursor.lnum) == FAIL)\n\t\t\tbreak;\n\t\t    u_clearline();\n\t\t}\n\t    }\n\t    else\n\t\tbreak;\n\t}\n    }\n#ifdef FEAT_NETBEANS_INTG\n    if (did_change && netbeans_active())\n    {\n\tptr = ml_get(pos.lnum);\n\tcount = curwin->w_cursor.col - pos.col;\n\tnetbeans_removed(curbuf, pos.lnum, pos.col, (long)count);\n\tnetbeans_inserted(curbuf, pos.lnum, pos.col, &ptr[pos.col], count);\n    }\n#endif\n\n\n    check_cursor();\n    curwin->w_set_curswant = TRUE;\n    if (did_change)\n    {\n\tchanged_lines(startpos.lnum, startpos.col, curwin->w_cursor.lnum + 1,\n\t\t\t\t\t\t\t\t\t  0L);\n\tcurbuf->b_op_start = startpos;\n\tcurbuf->b_op_end = curwin->w_cursor;\n\tif (curbuf->b_op_end.col > 0)\n\t    --curbuf->b_op_end.col;\n    }\n}\n\n/*\n * Move cursor to mark.\n */\n    static void\nnv_cursormark(cmdarg_T *cap, int flag, pos_T *pos)\n{\n    if (check_mark(pos) == FAIL)\n\tclearop(cap->oap);\n    else\n    {\n\tif (cap->cmdchar == '\\''\n\t\t|| cap->cmdchar == '`'\n\t\t|| cap->cmdchar == '['\n\t\t|| cap->cmdchar == ']')\n\t    setpcmark();\n\tcurwin->w_cursor = *pos;\n\tif (flag)\n\t    beginline(BL_WHITE | BL_FIX);\n\telse\n\t    check_cursor();\n    }\n    cap->oap->motion_type = flag ? MLINE : MCHAR;\n    if (cap->cmdchar == '`')\n\tcap->oap->use_reg_one = TRUE;\n    cap->oap->inclusive = FALSE;\t\t// ignored if not MCHAR\n    curwin->w_set_curswant = TRUE;\n}\n\n/*\n * Handle commands that are operators in Visual mode.\n */\n    static void\nv_visop(cmdarg_T *cap)\n{\n    static char_u trans[] = \"YyDdCcxdXdAAIIrr\";\n\n    // Uppercase means linewise, except in block mode, then \"D\" deletes till\n    // the end of the line, and \"C\" replaces till EOL\n    if (isupper(cap->cmdchar))\n    {\n\tif (VIsual_mode != Ctrl_V)\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\telse if (cap->cmdchar == 'C' || cap->cmdchar == 'D')\n\t    curwin->w_curswant = MAXCOL;\n    }\n    cap->cmdchar = *(vim_strchr(trans, cap->cmdchar) + 1);\n    nv_operator(cap);\n}\n\n/*\n * \"s\" and \"S\" commands.\n */\n    static void\nnv_subst(cmdarg_T *cap)\n{\n#ifdef FEAT_TERMINAL\n    // When showing output of term_dumpdiff() swap the top and bottom.\n    if (term_swap_diff() == OK)\n\treturn;\n#endif\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n    if (VIsual_active)\t// \"vs\" and \"vS\" are the same as \"vc\"\n    {\n\tif (cap->cmdchar == 'S')\n\t{\n\t    VIsual_mode_orig = VIsual_mode;\n\t    VIsual_mode = 'V';\n\t}\n\tcap->cmdchar = 'c';\n\tnv_operator(cap);\n    }\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Abbreviated commands.\n */\n    static void\nnv_abbrev(cmdarg_T *cap)\n{\n    if (cap->cmdchar == K_DEL || cap->cmdchar == K_KDEL)\n\tcap->cmdchar = 'x';\t\t// DEL key behaves like 'x'\n\n    // in Visual mode these commands are operators\n    if (VIsual_active)\n\tv_visop(cap);\n    else\n\tnv_optrans(cap);\n}\n\n/*\n * Translate a command into another command.\n */\n    static void\nnv_optrans(cmdarg_T *cap)\n{\n    static char_u *(ar[8]) = {(char_u *)\"dl\", (char_u *)\"dh\",\n\t\t\t      (char_u *)\"d$\", (char_u *)\"c$\",\n\t\t\t      (char_u *)\"cl\", (char_u *)\"cc\",\n\t\t\t      (char_u *)\"yy\", (char_u *)\":s\\r\"};\n    static char_u *str = (char_u *)\"xXDCsSY&\";\n\n    if (!checkclearopq(cap->oap))\n    {\n\t// In Vi \"2D\" doesn't delete the next line.  Can't translate it\n\t// either, because \"2.\" should also not use the count.\n\tif (cap->cmdchar == 'D' && vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t{\n\t    cap->oap->start = curwin->w_cursor;\n\t    cap->oap->op_type = OP_DELETE;\n#ifdef FEAT_EVAL\n\t    set_op_var(OP_DELETE);\n#endif\n\t    cap->count1 = 1;\n\t    nv_dollar(cap);\n\t    finish_op = TRUE;\n\t    ResetRedobuff();\n\t    AppendCharToRedobuff('D');\n\t}\n\telse\n\t{\n\t    if (cap->count0)\n\t\tstuffnumReadbuff(cap->count0);\n\t    stuffReadbuff(ar[(int)(vim_strchr(str, cap->cmdchar) - str)]);\n\t}\n    }\n    cap->opcount = 0;\n}\n\n/*\n * \"'\" and \"`\" commands.  Also for \"g'\" and \"g`\".\n * cap->arg is TRUE for \"'\" and \"g'\".\n */\n    static void\nnv_gomark(cmdarg_T *cap)\n{\n    pos_T\t*pos;\n    int\t\tc;\n#ifdef FEAT_FOLDING\n    pos_T\told_cursor = curwin->w_cursor;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n#endif\n\n    if (cap->cmdchar == 'g')\n\tc = cap->extra_char;\n    else\n\tc = cap->nchar;\n    pos = getmark(c, (cap->oap->op_type == OP_NOP));\n    if (pos == (pos_T *)-1)\t    // jumped to other file\n    {\n\tif (cap->arg)\n\t{\n\t    check_cursor_lnum();\n\t    beginline(BL_WHITE | BL_FIX);\n\t}\n\telse\n\t    check_cursor();\n    }\n    else\n\tnv_cursormark(cap, cap->arg, pos);\n\n    // May need to clear the coladd that a mark includes.\n    if (!virtual_active())\n\tcurwin->w_cursor.coladd = 0;\n    check_cursor_col();\n#ifdef FEAT_FOLDING\n    if (cap->oap->op_type == OP_NOP\n\t    && pos != NULL\n\t    && (pos == (pos_T *)-1 || !EQUAL_POS(old_cursor, *pos))\n\t    && (fdo_flags & FDO_MARK)\n\t    && old_KeyTyped)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle CTRL-O, CTRL-I, \"g;\", \"g,\" and \"CTRL-Tab\" commands.\n */\n    static void\nnv_pcmark(cmdarg_T *cap)\n{\n#ifdef FEAT_JUMPLIST\n    pos_T\t*pos;\n# ifdef FEAT_FOLDING\n    linenr_T\tlnum = curwin->w_cursor.lnum;\n    int\t\told_KeyTyped = KeyTyped;    // getting file may reset it\n# endif\n\n    if (!checkclearopq(cap->oap))\n    {\n\tif (cap->cmdchar == TAB && mod_mask == MOD_MASK_CTRL)\n\t{\n\t    if (goto_tabpage_lastused() == FAIL)\n\t\tclearopbeep(cap->oap);\n\t    return;\n\t}\n\tif (cap->cmdchar == 'g')\n\t    pos = movechangelist((int)cap->count1);\n\telse\n\t    pos = movemark((int)cap->count1);\n\tif (pos == (pos_T *)-1)\t\t// jump to other file\n\t{\n\t    curwin->w_set_curswant = TRUE;\n\t    check_cursor();\n\t}\n\telse if (pos != NULL)\t\t    // can jump\n\t    nv_cursormark(cap, FALSE, pos);\n\telse if (cap->cmdchar == 'g')\n\t{\n\t    if (curbuf->b_changelistlen == 0)\n\t\temsg(_(\"E664: changelist is empty\"));\n\t    else if (cap->count1 < 0)\n\t\temsg(_(\"E662: At start of changelist\"));\n\t    else\n\t\temsg(_(\"E663: At end of changelist\"));\n\t}\n\telse\n\t    clearopbeep(cap->oap);\n# ifdef FEAT_FOLDING\n\tif (cap->oap->op_type == OP_NOP\n\t\t&& (pos == (pos_T *)-1 || lnum != curwin->w_cursor.lnum)\n\t\t&& (fdo_flags & FDO_MARK)\n\t\t&& old_KeyTyped)\n\t    foldOpenCursor();\n# endif\n    }\n#else\n    clearopbeep(cap->oap);\n#endif\n}\n\n/*\n * Handle '\"' command.\n */\n    static void\nnv_regname(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n\tcap->nchar = get_expr_register();\n#endif\n    if (cap->nchar != NUL && valid_yank_reg(cap->nchar, FALSE))\n    {\n\tcap->oap->regname = cap->nchar;\n\tcap->opcount = cap->count0;\t// remember count before '\"'\n#ifdef FEAT_EVAL\n\tset_reg_var(cap->oap->regname);\n#endif\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * Handle \"v\", \"V\" and \"CTRL-V\" commands.\n * Also for \"gh\", \"gH\" and \"g^H\" commands: Always start Select mode, cap->arg\n * is TRUE.\n * Handle CTRL-Q just like CTRL-V.\n */\n    static void\nnv_visual(cmdarg_T *cap)\n{\n    if (cap->cmdchar == Ctrl_Q)\n\tcap->cmdchar = Ctrl_V;\n\n    // 'v', 'V' and CTRL-V can be used while an operator is pending to make it\n    // characterwise, linewise, or blockwise.\n    if (cap->oap->op_type != OP_NOP)\n    {\n\tmotion_force = cap->oap->motion_force = cap->cmdchar;\n\tfinish_op = FALSE;\t// operator doesn't finish now but later\n\treturn;\n    }\n\n    VIsual_select = cap->arg;\n    if (VIsual_active)\t    // change Visual mode\n    {\n\tif (VIsual_mode == cap->cmdchar)    // stop visual mode\n\t    end_visual_mode();\n\telse\t\t\t\t    // toggle char/block mode\n\t{\t\t\t\t    //\t   or char/line mode\n\t    VIsual_mode = cap->cmdchar;\n\t    showmode();\n\t    trigger_modechanged();\n\t}\n\tredraw_curbuf_later(INVERTED);\t    // update the inversion\n    }\n    else\t\t    // start Visual mode\n    {\n\tcheck_visual_highlight();\n\tif (cap->count0 > 0 && resel_VIsual_mode != NUL)\n\t{\n\t    // use previously selected part\n\t    VIsual = curwin->w_cursor;\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    setmouse();\n\t    if (p_smd && msg_silent == 0)\n\t\tredraw_cmdline = TRUE;\t    // show visual mode later\n\t    /*\n\t     * For V and ^V, we multiply the number of lines even if there\n\t     * was only one -- webb\n\t     */\n\t    if (resel_VIsual_mode != 'v' || resel_VIsual_line_count > 1)\n\t    {\n\t\tcurwin->w_cursor.lnum +=\n\t\t\t\t    resel_VIsual_line_count * cap->count0 - 1;\n\t\tcheck_cursor();\n\t    }\n\t    VIsual_mode = resel_VIsual_mode;\n\t    if (VIsual_mode == 'v')\n\t    {\n\t\tif (resel_VIsual_line_count <= 1)\n\t\t{\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\t}\n\t\telse\n\t\t    curwin->w_curswant = resel_VIsual_vcol;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    if (resel_VIsual_vcol == MAXCOL)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t    else if (VIsual_mode == Ctrl_V)\n\t    {\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol\n\t\t\t\t\t+ resel_VIsual_vcol * cap->count0 - 1;\n\t\tcoladvance(curwin->w_curswant);\n\t    }\n\t    else\n\t\tcurwin->w_set_curswant = TRUE;\n\t    redraw_curbuf_later(INVERTED);\t// show the inversion\n\t}\n\telse\n\t{\n\t    if (!cap->arg)\n\t\t// start Select mode when 'selectmode' contains \"cmd\"\n\t\tmay_start_select('c');\n\t    n_start_visual_mode(cap->cmdchar);\n\t    if (VIsual_mode != 'V' && *p_sel == 'e')\n\t\t++cap->count1;  // include one more char\n\t    if (cap->count0 > 0 && --cap->count1 > 0)\n\t    {\n\t\t// With a count select that many characters or lines.\n\t\tif (VIsual_mode == 'v' || VIsual_mode == Ctrl_V)\n\t\t    nv_right(cap);\n\t\telse if (VIsual_mode == 'V')\n\t\t    nv_down(cap);\n\t    }\n\t}\n    }\n}\n\n/*\n * Start selection for Shift-movement keys.\n */\n    void\nstart_selection(void)\n{\n    // if 'selectmode' contains \"key\", start Select mode\n    may_start_select('k');\n    n_start_visual_mode('v');\n}\n\n/*\n * Start Select mode, if \"c\" is in 'selectmode' and not in a mapping or menu.\n */\n    void\nmay_start_select(int c)\n{\n    VIsual_select = (stuff_empty() && typebuf_typed()\n\t\t    && (vim_strchr(p_slm, c) != NULL));\n}\n\n/*\n * Start Visual mode \"c\".\n * Should set VIsual_select before calling this.\n */\n    static void\nn_start_visual_mode(int c)\n{\n#ifdef FEAT_CONCEAL\n    int cursor_line_was_concealed = curwin->w_p_cole > 0\n\t\t\t\t\t\t&& conceal_cursor_line(curwin);\n#endif\n\n    VIsual_mode = c;\n    VIsual_active = TRUE;\n    VIsual_reselect = TRUE;\n\n    // Corner case: the 0 position in a tab may change when going into\n    // virtualedit.  Recalculate curwin->w_cursor to avoid bad highlighting.\n    if (c == Ctrl_V && (get_ve_flags() & VE_BLOCK) && gchar_cursor() == TAB)\n    {\n\tvalidate_virtcol();\n\tcoladvance(curwin->w_virtcol);\n    }\n    VIsual = curwin->w_cursor;\n\n#ifdef FEAT_FOLDING\n    foldAdjustVisual();\n#endif\n\n    trigger_modechanged();\n    setmouse();\n#ifdef FEAT_CONCEAL\n    // Check if redraw is needed after changing the state.\n    conceal_check_cursor_line(cursor_line_was_concealed);\n#endif\n\n    if (p_smd && msg_silent == 0)\n\tredraw_cmdline = TRUE;\t// show visual mode later\n#ifdef FEAT_CLIPBOARD\n    // Make sure the clipboard gets updated.  Needed because start and\n    // end may still be the same, and the selection needs to be owned\n    clip_star.vmode = NUL;\n#endif\n\n    // Only need to redraw this line, unless still need to redraw an old\n    // Visual area (when 'lazyredraw' is set).\n    if (curwin->w_redr_type < INVERTED)\n    {\n\tcurwin->w_old_cursor_lnum = curwin->w_cursor.lnum;\n\tcurwin->w_old_visual_lnum = curwin->w_cursor.lnum;\n    }\n}\n\n\n/*\n * CTRL-W: Window commands\n */\n    static void\nnv_window(cmdarg_T *cap)\n{\n    if (cap->nchar == ':')\n    {\n\t// \"CTRL-W :\" is the same as typing \":\"; useful in a terminal window\n\tcap->cmdchar = ':';\n\tcap->nchar = NUL;\n\tnv_colon(cap);\n    }\n    else if (!checkclearop(cap->oap))\n\tdo_window(cap->nchar, cap->count0, NUL); // everything is in window.c\n}\n\n/*\n * CTRL-Z: Suspend\n */\n    static void\nnv_suspend(cmdarg_T *cap)\n{\n    clearop(cap->oap);\n    if (VIsual_active)\n\tend_visual_mode();\t\t// stop Visual mode\n    do_cmdline_cmd((char_u *)\"stop\");\n}\n\n/*\n * Commands starting with \"g\".\n */\n    static void\nnv_g_cmd(cmdarg_T *cap)\n{\n    oparg_T\t*oap = cap->oap;\n    pos_T\ttpos;\n    int\t\ti;\n    int\t\tflag = FALSE;\n\n    switch (cap->nchar)\n    {\n    case Ctrl_A:\n    case Ctrl_X:\n#ifdef MEM_PROFILE\n    /*\n     * \"g^A\": dump log of used memory.\n     */\n\tif (!VIsual_active && cap->nchar == Ctrl_A)\n\t    vim_mem_profile_dump();\n\telse\n#endif\n    /*\n     * \"g^A/g^X\": sequentially increment visually selected region\n     */\n\t     if (VIsual_active)\n\t{\n\t    cap->arg = TRUE;\n\t    cap->cmdchar = cap->nchar;\n\t    cap->nchar = NUL;\n\t    nv_addsub(cap);\n\t}\n\telse\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gR\": Enter virtual replace mode.\n     */\n    case 'R':\n\tcap->arg = TRUE;\n\tnv_Replace(cap);\n\tbreak;\n\n    case 'r':\n\tnv_vreplace(cap);\n\tbreak;\n\n    case '&':\n\tdo_cmdline_cmd((char_u *)\"%s//~/&\");\n\tbreak;\n\n    /*\n     * \"gv\": Reselect the previous Visual area.  If Visual already active,\n     *\t     exchange previous and current Visual area.\n     */\n    case 'v':\n\tif (checkclearop(oap))\n\t    break;\n\n\tif (\t   curbuf->b_visual.vi_start.lnum == 0\n\t\t|| curbuf->b_visual.vi_start.lnum > curbuf->b_ml.ml_line_count\n\t\t|| curbuf->b_visual.vi_end.lnum == 0)\n\t    beep_flush();\n\telse\n\t{\n\t    // set w_cursor to the start of the Visual area, tpos to the end\n\t    if (VIsual_active)\n\t    {\n\t\ti = VIsual_mode;\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurbuf->b_visual.vi_mode = i;\n# ifdef FEAT_EVAL\n\t\tcurbuf->b_visual_mode_eval = i;\n# endif\n\t\ti = curwin->w_curswant;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\tcurbuf->b_visual.vi_curswant = i;\n\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurbuf->b_visual.vi_end = curwin->w_cursor;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t\tcurbuf->b_visual.vi_start = VIsual;\n\t    }\n\t    else\n\t    {\n\t\tVIsual_mode = curbuf->b_visual.vi_mode;\n\t\tcurwin->w_curswant = curbuf->b_visual.vi_curswant;\n\t\ttpos = curbuf->b_visual.vi_end;\n\t\tcurwin->w_cursor = curbuf->b_visual.vi_start;\n\t    }\n\n\t    VIsual_active = TRUE;\n\t    VIsual_reselect = TRUE;\n\n\t    // Set Visual to the start and w_cursor to the end of the Visual\n\t    // area.  Make sure they are on an existing character.\n\t    check_cursor();\n\t    VIsual = curwin->w_cursor;\n\t    curwin->w_cursor = tpos;\n\t    check_cursor();\n\t    update_topline();\n\t    /*\n\t     * When called from normal \"g\" command: start Select mode when\n\t     * 'selectmode' contains \"cmd\".  When called for K_SELECT, always\n\t     * start Select mode.\n\t     */\n\t    if (cap->arg)\n\t\tVIsual_select = TRUE;\n\t    else\n\t\tmay_start_select('c');\n\t    setmouse();\n#ifdef FEAT_CLIPBOARD\n\t    // Make sure the clipboard gets updated.  Needed because start and\n\t    // end are still the same, and the selection needs to be owned\n\t    clip_star.vmode = NUL;\n#endif\n\t    redraw_curbuf_later(INVERTED);\n\t    showmode();\n\t}\n\tbreak;\n    /*\n     * \"gV\": Don't reselect the previous Visual area after a Select mode\n     *\t     mapping of menu.\n     */\n    case 'V':\n\tVIsual_reselect = FALSE;\n\tbreak;\n\n    /*\n     * \"gh\":  start Select mode.\n     * \"gH\":  start Select line mode.\n     * \"g^H\": start Select block mode.\n     */\n    case K_BS:\n\tcap->nchar = Ctrl_H;\n\t// FALLTHROUGH\n    case 'h':\n    case 'H':\n    case Ctrl_H:\n# ifdef EBCDIC\n\t// EBCDIC: 'v'-'h' != '^v'-'^h'\n\tif (cap->nchar == Ctrl_H)\n\t    cap->cmdchar = Ctrl_V;\n\telse\n# endif\n\tcap->cmdchar = cap->nchar + ('v' - 'h');\n\tcap->arg = TRUE;\n\tnv_visual(cap);\n\tbreak;\n\n    // \"gn\", \"gN\" visually select next/previous search match\n    // \"gn\" selects next match\n    // \"gN\" selects previous match\n    case 'N':\n    case 'n':\n\tif (!current_search(cap->count1, cap->nchar == 'n'))\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gj\" and \"gk\" two new funny movement keys -- up and down\n     * movement based on *screen* line rather than *file* line.\n     */\n    case 'j':\n    case K_DOWN:\n\t// with 'nowrap' it works just like the normal \"j\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_down(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, FORWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case 'k':\n    case K_UP:\n\t// with 'nowrap' it works just like the normal \"k\" command.\n\tif (!curwin->w_p_wrap)\n\t{\n\t    oap->motion_type = MLINE;\n\t    i = cursor_up(cap->count1, oap->op_type == OP_NOP);\n\t}\n\telse\n\t    i = nv_screengo(oap, BACKWARD, cap->count1);\n\tif (i == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"gJ\": join two lines without inserting a space.\n     */\n    case 'J':\n\tnv_join(cap);\n\tbreak;\n\n    /*\n     * \"g0\", \"g^\" and \"g$\": Like \"0\", \"^\" and \"$\" but for screen lines.\n     * \"gm\": middle of \"g0\" and \"g$\".\n     */\n    case '^':\n\tflag = TRUE;\n\t// FALLTHROUGH\n\n    case '0':\n    case 'm':\n    case K_HOME:\n    case K_KHOME:\n\toap->motion_type = MCHAR;\n\toap->inclusive = FALSE;\n\tif (curwin->w_p_wrap && curwin->w_width != 0)\n\t{\n\t    int\t\twidth1 = curwin->w_width - curwin_col_off();\n\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t    validate_virtcol();\n\t    i = 0;\n\t    if (curwin->w_virtcol >= (colnr_T)width1 && width2 > 0)\n\t\ti = (curwin->w_virtcol - width1) / width2 * width2 + width1;\n\t}\n\telse\n\t    i = curwin->w_leftcol;\n\t// Go to the middle of the screen line.  When 'number' or\n\t// 'relativenumber' is on and lines are wrapping the middle can be more\n\t// to the left.\n\tif (cap->nchar == 'm')\n\t    i += (curwin->w_width - curwin_col_off()\n\t\t    + ((curwin->w_p_wrap && i > 0)\n\t\t\t? curwin_col_off2() : 0)) / 2;\n\tcoladvance((colnr_T)i);\n\tif (flag)\n\t{\n\t    do\n\t\ti = gchar_cursor();\n\t    while (VIM_ISWHITE(i) && oneright() == OK);\n\t    curwin->w_valid &= ~VALID_WCOL;\n\t}\n\tcurwin->w_set_curswant = TRUE;\n\tbreak;\n\n    case 'M':\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = FALSE;\n\t    if (has_mbyte)\n\t\ti = mb_string2cells(ptr, (int)STRLEN(ptr));\n\t    else\n\t\ti = (int)STRLEN(ptr);\n\t    if (cap->count0 > 0 && cap->count0 <= 100)\n\t\tcoladvance((colnr_T)(i * cap->count0 / 100));\n\t    else\n\t\tcoladvance((colnr_T)(i / 2));\n\t    curwin->w_set_curswant = TRUE;\n\t}\n\tbreak;\n\n    case '_':\n\t// \"g_\": to the last non-blank character in the line or <count> lines\n\t// downward.\n\tcap->oap->motion_type = MCHAR;\n\tcap->oap->inclusive = TRUE;\n\tcurwin->w_curswant = MAXCOL;\n\tif (cursor_down((long)(cap->count1 - 1),\n\t\t\t\t\t cap->oap->op_type == OP_NOP) == FAIL)\n\t    clearopbeep(cap->oap);\n\telse\n\t{\n\t    char_u  *ptr = ml_get_curline();\n\n\t    // In Visual mode we may end up after the line.\n\t    if (curwin->w_cursor.col > 0 && ptr[curwin->w_cursor.col] == NUL)\n\t\t--curwin->w_cursor.col;\n\n\t    // Decrease the cursor column until it's on a non-blank.\n\t    while (curwin->w_cursor.col > 0\n\t\t\t\t    && VIM_ISWHITE(ptr[curwin->w_cursor.col]))\n\t\t--curwin->w_cursor.col;\n\t    curwin->w_set_curswant = TRUE;\n\t    adjust_for_sel(cap);\n\t}\n\tbreak;\n\n    case '$':\n    case K_END:\n    case K_KEND:\n\t{\n\t    int col_off = curwin_col_off();\n\n\t    oap->motion_type = MCHAR;\n\t    oap->inclusive = TRUE;\n\t    if (curwin->w_p_wrap && curwin->w_width != 0)\n\t    {\n\t\tcurwin->w_curswant = MAXCOL;    // so we stay at the end\n\t\tif (cap->count1 == 1)\n\t\t{\n\t\t    int\t\twidth1 = curwin->w_width - col_off;\n\t\t    int\t\twidth2 = width1 + curwin_col_off2();\n\n\t\t    validate_virtcol();\n\t\t    i = width1 - 1;\n\t\t    if (curwin->w_virtcol >= (colnr_T)width1)\n\t\t\ti += ((curwin->w_virtcol - width1) / width2 + 1)\n\t\t\t\t\t\t\t\t     * width2;\n\t\t    coladvance((colnr_T)i);\n\n\t\t    // Make sure we stick in this column.\n\t\t    validate_virtcol();\n\t\t    curwin->w_curswant = curwin->w_virtcol;\n\t\t    curwin->w_set_curswant = FALSE;\n\t\t    if (curwin->w_cursor.col > 0 && curwin->w_p_wrap)\n\t\t    {\n\t\t\t/*\n\t\t\t * Check for landing on a character that got split at\n\t\t\t * the end of the line.  We do not want to advance to\n\t\t\t * the next screen line.\n\t\t\t */\n\t\t\tif (curwin->w_virtcol > (colnr_T)i)\n\t\t\t    --curwin->w_cursor.col;\n\t\t    }\n\t\t}\n\t\telse if (nv_screengo(oap, FORWARD, cap->count1 - 1) == FAIL)\n\t\t    clearopbeep(oap);\n\t    }\n\t    else\n\t    {\n\t\tif (cap->count1 > 1)\n\t\t    // if it fails, let the cursor still move to the last char\n\t\t    (void)cursor_down(cap->count1 - 1, FALSE);\n\n\t\ti = curwin->w_leftcol + curwin->w_width - col_off - 1;\n\t\tcoladvance((colnr_T)i);\n\n\t\t// if the character doesn't fit move one back\n\t\tif (curwin->w_cursor.col > 0\n\t\t\t\t       && (*mb_ptr2cells)(ml_get_cursor()) > 1)\n\t\t{\n\t\t    colnr_T vcol;\n\n\t\t    getvvcol(curwin, &curwin->w_cursor, NULL, NULL, &vcol);\n\t\t    if (vcol >= curwin->w_leftcol + curwin->w_width - col_off)\n\t\t\t--curwin->w_cursor.col;\n\t\t}\n\n\t\t// Make sure we stick in this column.\n\t\tvalidate_virtcol();\n\t\tcurwin->w_curswant = curwin->w_virtcol;\n\t\tcurwin->w_set_curswant = FALSE;\n\t    }\n\t}\n\tbreak;\n\n    /*\n     * \"g*\" and \"g#\", like \"*\" and \"#\" but without using \"\\<\" and \"\\>\"\n     */\n    case '*':\n    case '#':\n#if POUND != '#'\n    case POUND:\t\t// pound sign (sometimes equal to '#')\n#endif\n    case Ctrl_RSB:\t\t// :tag or :tselect for current identifier\n    case ']':\t\t\t// :tselect for current identifier\n\tnv_ident(cap);\n\tbreak;\n\n    /*\n     * ge and gE: go back to end of word\n     */\n    case 'e':\n    case 'E':\n\toap->motion_type = MCHAR;\n\tcurwin->w_set_curswant = TRUE;\n\toap->inclusive = TRUE;\n\tif (bckend_word(cap->count1, cap->nchar == 'E', FALSE) == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    /*\n     * \"g CTRL-G\": display info about cursor position\n     */\n    case Ctrl_G:\n\tcursor_pos_info(NULL);\n\tbreak;\n\n    /*\n     * \"gi\": start Insert at the last position.\n     */\n    case 'i':\n\tif (curbuf->b_last_insert.lnum != 0)\n\t{\n\t    curwin->w_cursor = curbuf->b_last_insert;\n\t    check_cursor_lnum();\n\t    i = (int)STRLEN(ml_get_curline());\n\t    if (curwin->w_cursor.col > (colnr_T)i)\n\t    {\n\t\tif (virtual_active())\n\t\t    curwin->w_cursor.coladd += curwin->w_cursor.col - i;\n\t\tcurwin->w_cursor.col = i;\n\t    }\n\t}\n\tcap->cmdchar = 'i';\n\tnv_edit(cap);\n\tbreak;\n\n    /*\n     * \"gI\": Start insert in column 1.\n     */\n    case 'I':\n\tbeginline(0);\n\tif (!checkclearopq(oap))\n\t    invoke_edit(cap, FALSE, 'g', FALSE);\n\tbreak;\n\n#ifdef FEAT_SEARCHPATH\n    /*\n     * \"gf\": goto file, edit file under cursor\n     * \"]f\" and \"[f\": can also be used.\n     */\n    case 'f':\n    case 'F':\n\tnv_gotofile(cap);\n\tbreak;\n#endif\n\n\t// \"g'm\" and \"g`m\": jump to mark without setting pcmark\n    case '\\'':\n\tcap->arg = TRUE;\n\t// FALLTHROUGH\n    case '`':\n\tnv_gomark(cap);\n\tbreak;\n\n    /*\n     * \"gs\": Goto sleep.\n     */\n    case 's':\n\tdo_sleep(cap->count1 * 1000L, FALSE);\n\tbreak;\n\n    /*\n     * \"ga\": Display the ascii value of the character under the\n     * cursor.\tIt is displayed in decimal, hex, and octal. -- webb\n     */\n    case 'a':\n\tdo_ascii(NULL);\n\tbreak;\n\n    /*\n     * \"g8\": Display the bytes used for the UTF-8 character under the\n     * cursor.\tIt is displayed in hex.\n     * \"8g8\" finds illegal byte sequence.\n     */\n    case '8':\n\tif (cap->count0 == 8)\n\t    utf_find_illegal();\n\telse\n\t    show_utf8();\n\tbreak;\n\n    // \"g<\": show scrollback text\n    case '<':\n\tshow_sb_text();\n\tbreak;\n\n    /*\n     * \"gg\": Goto the first line in file.  With a count it goes to\n     * that line number like for \"G\". -- webb\n     */\n    case 'g':\n\tcap->arg = FALSE;\n\tnv_goto(cap);\n\tbreak;\n\n    /*\n     *\t Two-character operators:\n     *\t \"gq\"\t    Format text\n     *\t \"gw\"\t    Format text and keep cursor position\n     *\t \"g~\"\t    Toggle the case of the text.\n     *\t \"gu\"\t    Change text to lower case.\n     *\t \"gU\"\t    Change text to upper case.\n     *   \"g?\"\t    rot13 encoding\n     *   \"g@\"\t    call 'operatorfunc'\n     */\n    case 'q':\n    case 'w':\n\toap->cursor_start = curwin->w_cursor;\n\t// FALLTHROUGH\n    case '~':\n    case 'u':\n    case 'U':\n    case '?':\n    case '@':\n\tnv_operator(cap);\n\tbreak;\n\n    /*\n     * \"gd\": Find first occurrence of pattern under the cursor in the\n     *\t current function\n     * \"gD\": idem, but in the current file.\n     */\n    case 'd':\n    case 'D':\n\tnv_gd(oap, cap->nchar, (int)cap->count0);\n\tbreak;\n\n    /*\n     * g<*Mouse> : <C-*mouse>\n     */\n    case K_MIDDLEMOUSE:\n    case K_MIDDLEDRAG:\n    case K_MIDDLERELEASE:\n    case K_LEFTMOUSE:\n    case K_LEFTDRAG:\n    case K_LEFTRELEASE:\n    case K_MOUSEMOVE:\n    case K_RIGHTMOUSE:\n    case K_RIGHTDRAG:\n    case K_RIGHTRELEASE:\n    case K_X1MOUSE:\n    case K_X1DRAG:\n    case K_X1RELEASE:\n    case K_X2MOUSE:\n    case K_X2DRAG:\n    case K_X2RELEASE:\n\tmod_mask = MOD_MASK_CTRL;\n\t(void)do_mouse(oap, cap->nchar, BACKWARD, cap->count1, 0);\n\tbreak;\n\n    case K_IGNORE:\n\tbreak;\n\n    /*\n     * \"gP\" and \"gp\": same as \"P\" and \"p\" but leave cursor just after new text\n     */\n    case 'p':\n    case 'P':\n\tnv_put(cap);\n\tbreak;\n\n#ifdef FEAT_BYTEOFF\n    // \"go\": goto byte count from start of buffer\n    case 'o':\n\tgoto_byte(cap->count0);\n\tbreak;\n#endif\n\n    // \"gQ\": improved Ex mode\n    case 'Q':\n\tif (text_locked())\n\t{\n\t    clearopbeep(cap->oap);\n\t    text_locked_msg();\n\t    break;\n\t}\n\n\tif (!checkclearopq(oap))\n\t    do_exmode(TRUE);\n\tbreak;\n\n#ifdef FEAT_JUMPLIST\n    case ',':\n\tnv_pcmark(cap);\n\tbreak;\n\n    case ';':\n\tcap->count1 = -cap->count1;\n\tnv_pcmark(cap);\n\tbreak;\n#endif\n\n    case 't':\n\tif (!checkclearop(oap))\n\t    goto_tabpage((int)cap->count0);\n\tbreak;\n    case 'T':\n\tif (!checkclearop(oap))\n\t    goto_tabpage(-(int)cap->count1);\n\tbreak;\n\n    case TAB:\n\tif (!checkclearop(oap) && goto_tabpage_lastused() == FAIL)\n\t    clearopbeep(oap);\n\tbreak;\n\n    case '+':\n    case '-': // \"g+\" and \"g-\": undo or redo along the timeline\n\tif (!checkclearopq(oap))\n\t    undo_time(cap->nchar == '-' ? -cap->count1 : cap->count1,\n\t\t\t\t\t\t\t FALSE, FALSE, FALSE);\n\tbreak;\n\n    default:\n\tclearopbeep(oap);\n\tbreak;\n    }\n}\n\n/*\n * Handle \"o\" and \"O\" commands.\n */\n    static void\nn_opencmd(cmdarg_T *cap)\n{\n#ifdef FEAT_CONCEAL\n    linenr_T\toldline = curwin->w_cursor.lnum;\n#endif\n\n    if (!checkclearopq(cap->oap))\n    {\n#ifdef FEAT_FOLDING\n\tif (cap->cmdchar == 'O')\n\t    // Open above the first line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\t&curwin->w_cursor.lnum, NULL);\n\telse\n\t    // Open below the last line of a folded sequence of lines\n\t    (void)hasFolding(curwin->w_cursor.lnum,\n\t\t\t\t\t\tNULL, &curwin->w_cursor.lnum);\n#endif\n\tif (u_save((linenr_T)(curwin->w_cursor.lnum -\n\t\t\t\t\t       (cap->cmdchar == 'O' ? 1 : 0)),\n\t\t   (linenr_T)(curwin->w_cursor.lnum +\n\t\t\t\t\t       (cap->cmdchar == 'o' ? 1 : 0))\n\t\t       ) == OK\n\t\t&& open_line(cap->cmdchar == 'O' ? BACKWARD : FORWARD,\n\t\t\t has_format_option(FO_OPEN_COMS) ? OPENLINE_DO_COM : 0,\n\t\t\t\t\t\t\t\t      0) == OK)\n\t{\n#ifdef FEAT_CONCEAL\n\t    if (curwin->w_p_cole > 0 && oldline != curwin->w_cursor.lnum)\n\t\tredrawWinline(curwin, oldline);\n#endif\n#ifdef FEAT_SYN_HL\n\t    if (curwin->w_p_cul)\n\t\t// force redraw of cursorline\n\t\tcurwin->w_valid &= ~VALID_CROW;\n#endif\n\t    // When '#' is in 'cpoptions' ignore the count.\n\t    if (vim_strchr(p_cpo, CPO_HASH) != NULL)\n\t\tcap->count1 = 1;\n\t    invoke_edit(cap, FALSE, cap->cmdchar, TRUE);\n\t}\n    }\n}\n\n/*\n * \".\" command: redo last change.\n */\n    static void\nnv_dot(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\t/*\n\t * If \"restart_edit\" is TRUE, the last but one command is repeated\n\t * instead of the last command (inserting text). This is used for\n\t * CTRL-O <.> in insert mode.\n\t */\n\tif (start_redo(cap->count0, restart_edit != 0 && !arrow_used) == FAIL)\n\t    clearopbeep(cap->oap);\n    }\n}\n\n/*\n * CTRL-R: undo undo\n */\n    static void\nnv_redo(cmdarg_T *cap)\n{\n    if (!checkclearopq(cap->oap))\n    {\n\tu_redo((int)cap->count1);\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * Handle \"U\" command.\n */\n    static void\nnv_Undo(cmdarg_T *cap)\n{\n    // In Visual mode and typing \"gUU\" triggers an operator\n    if (cap->oap->op_type == OP_UPPER || VIsual_active)\n    {\n\t// translate \"gUU\" to \"gUgU\"\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'U';\n\tnv_operator(cap);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tu_undoline();\n\tcurwin->w_set_curswant = TRUE;\n    }\n}\n\n/*\n * '~' command: If tilde is not an operator and Visual is off: swap case of a\n * single character.\n */\n    static void\nnv_tilde(cmdarg_T *cap)\n{\n    if (!p_to && !VIsual_active && cap->oap->op_type != OP_TILDE)\n    {\n#ifdef FEAT_JOB_CHANNEL\n\tif (bt_prompt(curbuf) && !prompt_curpos_editable())\n\t{\n\t    clearopbeep(cap->oap);\n\t    return;\n\t}\n#endif\n\tn_swapchar(cap);\n    }\n    else\n\tnv_operator(cap);\n}\n\n/*\n * Handle an operator command.\n * The actual work is done by do_pending_operator().\n */\n    static void\nnv_operator(cmdarg_T *cap)\n{\n    int\t    op_type;\n\n    op_type = get_op_type(cap->cmdchar, cap->nchar);\n#ifdef FEAT_JOB_CHANNEL\n    if (bt_prompt(curbuf) && op_is_change(op_type) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n\treturn;\n    }\n#endif\n\n    if (op_type == cap->oap->op_type)\t    // double operator works on lines\n\tnv_lineop(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tcap->oap->start = curwin->w_cursor;\n\tcap->oap->op_type = op_type;\n#ifdef FEAT_EVAL\n\tset_op_var(op_type);\n#endif\n    }\n}\n\n#ifdef FEAT_EVAL\n/*\n * Set v:operator to the characters for \"optype\".\n */\n    static void\nset_op_var(int optype)\n{\n    char_u\topchars[3];\n\n    if (optype == OP_NOP)\n\tset_vim_var_string(VV_OP, NULL, 0);\n    else\n    {\n\topchars[0] = get_op_char(optype);\n\topchars[1] = get_extra_op_char(optype);\n\topchars[2] = NUL;\n\tset_vim_var_string(VV_OP, opchars, -1);\n    }\n}\n#endif\n\n/*\n * Handle linewise operator \"dd\", \"yy\", etc.\n *\n * \"_\" is is a strange motion command that helps make operators more logical.\n * It is actually implemented, but not documented in the real Vi.  This motion\n * command actually refers to \"the current line\".  Commands like \"dd\" and \"yy\"\n * are really an alternate form of \"d_\" and \"y_\".  It does accept a count, so\n * \"d3_\" works to delete 3 lines.\n */\n    static void\nnv_lineop(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MLINE;\n    if (cursor_down(cap->count1 - 1L, cap->oap->op_type == OP_NOP) == FAIL)\n\tclearopbeep(cap->oap);\n    else if (  (cap->oap->op_type == OP_DELETE // only with linewise motions\n\t\t&& cap->oap->motion_force != 'v'\n\t\t&& cap->oap->motion_force != Ctrl_V)\n\t    || cap->oap->op_type == OP_LSHIFT\n\t    || cap->oap->op_type == OP_RSHIFT)\n\tbeginline(BL_SOL | BL_FIX);\n    else if (cap->oap->op_type != OP_YANK)\t// 'Y' does not move cursor\n\tbeginline(BL_WHITE | BL_FIX);\n}\n\n/*\n * <Home> command.\n */\n    static void\nnv_home(cmdarg_T *cap)\n{\n    // CTRL-HOME is like \"gg\"\n    if (mod_mask & MOD_MASK_CTRL)\n\tnv_goto(cap);\n    else\n    {\n\tcap->count0 = 1;\n\tnv_pipe(cap);\n    }\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * \"|\" command.\n */\n    static void\nnv_pipe(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(0);\n    if (cap->count0 > 0)\n    {\n\tcoladvance((colnr_T)(cap->count0 - 1));\n\tcurwin->w_curswant = (colnr_T)(cap->count0 - 1);\n    }\n    else\n\tcurwin->w_curswant = 0;\n    // keep curswant at the column where we wanted to go, not where\n    // we ended; differs if line is too short\n    curwin->w_set_curswant = FALSE;\n}\n\n/*\n * Handle back-word command \"b\" and \"B\".\n * cap->arg is 1 for \"B\"\n */\n    static void\nnv_bck_word(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    curwin->w_set_curswant = TRUE;\n    if (bck_word(cap->count1, cap->arg, FALSE) == FAIL)\n\tclearopbeep(cap->oap);\n#ifdef FEAT_FOLDING\n    else if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * Handle word motion commands \"e\", \"E\", \"w\" and \"W\".\n * cap->arg is TRUE for \"E\" and \"W\".\n */\n    static void\nnv_wordcmd(cmdarg_T *cap)\n{\n    int\t\tn;\n    int\t\tword_end;\n    int\t\tflag = FALSE;\n    pos_T\tstartpos = curwin->w_cursor;\n\n    /*\n     * Set inclusive for the \"E\" and \"e\" command.\n     */\n    if (cap->cmdchar == 'e' || cap->cmdchar == 'E')\n\tword_end = TRUE;\n    else\n\tword_end = FALSE;\n    cap->oap->inclusive = word_end;\n\n    /*\n     * \"cw\" and \"cW\" are a special case.\n     */\n    if (!word_end && cap->oap->op_type == OP_CHANGE)\n    {\n\tn = gchar_cursor();\n\tif (n != NUL)\t\t\t// not an empty line\n\t{\n\t    if (VIM_ISWHITE(n))\n\t    {\n\t\t/*\n\t\t * Reproduce a funny Vi behaviour: \"cw\" on a blank only\n\t\t * changes one character, not all blanks until the start of\n\t\t * the next word.  Only do this when the 'w' flag is included\n\t\t * in 'cpoptions'.\n\t\t */\n\t\tif (cap->count1 == 1 && vim_strchr(p_cpo, CPO_CW) != NULL)\n\t\t{\n\t\t    cap->oap->inclusive = TRUE;\n\t\t    cap->oap->motion_type = MCHAR;\n\t\t    return;\n\t\t}\n\t    }\n\t    else\n\t    {\n\t\t/*\n\t\t * This is a little strange. To match what the real Vi does,\n\t\t * we effectively map 'cw' to 'ce', and 'cW' to 'cE', provided\n\t\t * that we are not on a space or a TAB.  This seems impolite\n\t\t * at first, but it's really more what we mean when we say\n\t\t * 'cw'.\n\t\t * Another strangeness: When standing on the end of a word\n\t\t * \"ce\" will change until the end of the next word, but \"cw\"\n\t\t * will change only one character! This is done by setting\n\t\t * flag.\n\t\t */\n\t\tcap->oap->inclusive = TRUE;\n\t\tword_end = TRUE;\n\t\tflag = TRUE;\n\t    }\n\t}\n    }\n\n    cap->oap->motion_type = MCHAR;\n    curwin->w_set_curswant = TRUE;\n    if (word_end)\n\tn = end_word(cap->count1, cap->arg, flag, FALSE);\n    else\n\tn = fwd_word(cap->count1, cap->arg, cap->oap->op_type != OP_NOP);\n\n    // Don't leave the cursor on the NUL past the end of line. Unless we\n    // didn't move it forward.\n    if (LT_POS(startpos, curwin->w_cursor))\n\tadjust_cursor(cap->oap);\n\n    if (n == FAIL && cap->oap->op_type == OP_NOP)\n\tclearopbeep(cap->oap);\n    else\n    {\n\tadjust_for_sel(cap);\n#ifdef FEAT_FOLDING\n\tif ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\t    foldOpenCursor();\n#endif\n    }\n}\n\n/*\n * Used after a movement command: If the cursor ends up on the NUL after the\n * end of the line, may move it back to the last character and make the motion\n * inclusive.\n */\n    static void\nadjust_cursor(oparg_T *oap)\n{\n    // The cursor cannot remain on the NUL when:\n    // - the column is > 0\n    // - not in Visual mode or 'selection' is \"o\"\n    // - 'virtualedit' is not \"all\" and not \"onemore\".\n    if (curwin->w_cursor.col > 0 && gchar_cursor() == NUL\n\t\t&& (!VIsual_active || *p_sel == 'o')\n\t\t&& !virtual_active() && (get_ve_flags() & VE_ONEMORE) == 0)\n    {\n\t--curwin->w_cursor.col;\n\t// prevent cursor from moving on the trail byte\n\tif (has_mbyte)\n\t    mb_adjust_cursor();\n\toap->inclusive = TRUE;\n    }\n}\n\n/*\n * \"0\" and \"^\" commands.\n * cap->arg is the argument for beginline().\n */\n    static void\nnv_beginline(cmdarg_T *cap)\n{\n    cap->oap->motion_type = MCHAR;\n    cap->oap->inclusive = FALSE;\n    beginline(cap->arg);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_HOR) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n    ins_at_eol = FALSE;\t    // Don't move cursor past eol (only necessary in a\n\t\t\t    // one-character line).\n}\n\n/*\n * In exclusive Visual mode, may include the last character.\n */\n    static void\nadjust_for_sel(cmdarg_T *cap)\n{\n    if (VIsual_active && cap->oap->inclusive && *p_sel == 'e'\n\t    && gchar_cursor() != NUL && LT_POS(VIsual, curwin->w_cursor))\n    {\n\tif (has_mbyte)\n\t    inc_cursor();\n\telse\n\t    ++curwin->w_cursor.col;\n\tcap->oap->inclusive = FALSE;\n    }\n}\n\n/*\n * Exclude last character at end of Visual area for 'selection' == \"exclusive\".\n * Should check VIsual_mode before calling this.\n * Returns TRUE when backed up to the previous line.\n */\n    int\nunadjust_for_sel(void)\n{\n    pos_T\t*pp;\n\n    if (*p_sel == 'e' && !EQUAL_POS(VIsual, curwin->w_cursor))\n    {\n\tif (LT_POS(VIsual, curwin->w_cursor))\n\t    pp = &curwin->w_cursor;\n\telse\n\t    pp = &VIsual;\n\tif (pp->coladd > 0)\n\t    --pp->coladd;\n\telse\n\tif (pp->col > 0)\n\t{\n\t    --pp->col;\n\t    mb_adjustpos(curbuf, pp);\n\t}\n\telse if (pp->lnum > 1)\n\t{\n\t    --pp->lnum;\n\t    pp->col = (colnr_T)STRLEN(ml_get(pp->lnum));\n\t    return TRUE;\n\t}\n    }\n    return FALSE;\n}\n\n/*\n * SELECT key in Normal or Visual mode: end of Select mode mapping.\n */\n    static void\nnv_select(cmdarg_T *cap)\n{\n    if (VIsual_active)\n\tVIsual_select = TRUE;\n    else if (VIsual_reselect)\n    {\n\tcap->nchar = 'v';\t    // fake \"gv\" command\n\tcap->arg = TRUE;\n\tnv_g_cmd(cap);\n    }\n}\n\n\n/*\n * \"G\", \"gg\", CTRL-END, CTRL-HOME.\n * cap->arg is TRUE for \"G\".\n */\n    static void\nnv_goto(cmdarg_T *cap)\n{\n    linenr_T\tlnum;\n\n    if (cap->arg)\n\tlnum = curbuf->b_ml.ml_line_count;\n    else\n\tlnum = 1L;\n    cap->oap->motion_type = MLINE;\n    setpcmark();\n\n    // When a count is given, use it instead of the default lnum\n    if (cap->count0 != 0)\n\tlnum = cap->count0;\n    if (lnum < 1L)\n\tlnum = 1L;\n    else if (lnum > curbuf->b_ml.ml_line_count)\n\tlnum = curbuf->b_ml.ml_line_count;\n    curwin->w_cursor.lnum = lnum;\n    beginline(BL_SOL | BL_FIX);\n#ifdef FEAT_FOLDING\n    if ((fdo_flags & FDO_JUMP) && KeyTyped && cap->oap->op_type == OP_NOP)\n\tfoldOpenCursor();\n#endif\n}\n\n/*\n * CTRL-\\ in Normal mode.\n */\n    static void\nnv_normal(cmdarg_T *cap)\n{\n    if (cap->nchar == Ctrl_N || cap->nchar == Ctrl_G)\n    {\n\tclearop(cap->oap);\n\tif (restart_edit != 0 && mode_displayed)\n\t    clear_cmdline = TRUE;\t\t// unshow mode later\n\trestart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t    cmdwin_result = Ctrl_C;\n#endif\n\tif (VIsual_active)\n\t{\n\t    end_visual_mode();\t\t// stop Visual\n\t    redraw_curbuf_later(INVERTED);\n\t}\n\t// CTRL-\\ CTRL-G restarts Insert mode when 'insertmode' is set.\n\tif (cap->nchar == Ctrl_G && p_im)\n\t    restart_edit = 'a';\n    }\n    else\n\tclearopbeep(cap->oap);\n}\n\n/*\n * ESC in Normal mode: beep, but don't flush buffers.\n * Don't even beep if we are canceling a command.\n */\n    static void\nnv_esc(cmdarg_T *cap)\n{\n    int\t\tno_reason;\n\n    no_reason = (cap->oap->op_type == OP_NOP\n\t\t&& cap->opcount == 0\n\t\t&& cap->count0 == 0\n\t\t&& cap->oap->regname == 0\n\t\t&& !p_im);\n\n    if (cap->arg)\t\t// TRUE for CTRL-C\n    {\n\tif (restart_edit == 0\n#ifdef FEAT_CMDWIN\n\t\t&& cmdwin_type == 0\n#endif\n\t\t&& !VIsual_active\n\t\t&& no_reason)\n\t{\n\t    if (anyBufIsChanged())\n\t\tmsg(_(\"Type  :qa!  and press <Enter> to abandon all changes and exit Vim\"));\n\t    else\n\t\tmsg(_(\"Type  :qa  and press <Enter> to exit Vim\"));\n\t}\n\n\t// Don't reset \"restart_edit\" when 'insertmode' is set, it won't be\n\t// set again below when halfway a mapping.\n\tif (!p_im)\n\t    restart_edit = 0;\n#ifdef FEAT_CMDWIN\n\tif (cmdwin_type != 0)\n\t{\n\t    cmdwin_result = K_IGNORE;\n\t    got_int = FALSE;\t// don't stop executing autocommands et al.\n\t    return;\n\t}\n#endif\n    }\n#ifdef FEAT_CMDWIN\n    else if (cmdwin_type != 0 && ex_normal_busy)\n    {\n\t// When :normal runs out of characters while in the command line window\n\t// vgetorpeek() will return ESC.  Exit the cmdline window to break the\n\t// loop.\n\tcmdwin_result = K_IGNORE;\n\treturn;\n    }\n#endif\n\n    if (VIsual_active)\n    {\n\tend_visual_mode();\t// stop Visual\n\tcheck_cursor_col();\t// make sure cursor is not beyond EOL\n\tcurwin->w_set_curswant = TRUE;\n\tredraw_curbuf_later(INVERTED);\n    }\n    else if (no_reason)\n\tvim_beep(BO_ESC);\n    clearop(cap->oap);\n\n    // A CTRL-C is often used at the start of a menu.  When 'insertmode' is\n    // set return to Insert mode afterwards.\n    if (restart_edit == 0 && goto_im() && ex_normal_busy == 0)\n\trestart_edit = 'a';\n}\n\n/*\n * Move the cursor for the \"A\" command.\n */\n    void\nset_cursor_for_append_to_line(void)\n{\n    curwin->w_set_curswant = TRUE;\n    if (get_ve_flags() == VE_ALL)\n    {\n\tint save_State = State;\n\n\t// Pretend Insert mode here to allow the cursor on the\n\t// character past the end of the line\n\tState = INSERT;\n\tcoladvance((colnr_T)MAXCOL);\n\tState = save_State;\n    }\n    else\n\tcurwin->w_cursor.col += (colnr_T)STRLEN(ml_get_cursor());\n}\n\n/*\n * Handle \"A\", \"a\", \"I\", \"i\" and <Insert> commands.\n * Also handle K_PS, start bracketed paste.\n */\n    static void\nnv_edit(cmdarg_T *cap)\n{\n    // <Insert> is equal to \"i\"\n    if (cap->cmdchar == K_INS || cap->cmdchar == K_KINS)\n\tcap->cmdchar = 'i';\n\n    // in Visual mode \"A\" and \"I\" are an operator\n    if (VIsual_active && (cap->cmdchar == 'A' || cap->cmdchar == 'I'))\n    {\n#ifdef FEAT_TERMINAL\n\tif (term_in_normal_mode())\n\t{\n\t    end_visual_mode();\n\t    clearop(cap->oap);\n\t    term_enter_job_mode();\n\t    return;\n\t}\n#endif\n\tv_visop(cap);\n    }\n\n    // in Visual mode and after an operator \"a\" and \"i\" are for text objects\n    else if ((cap->cmdchar == 'a' || cap->cmdchar == 'i')\n\t    && (cap->oap->op_type != OP_NOP || VIsual_active))\n    {\n#ifdef FEAT_TEXTOBJ\n\tnv_object(cap);\n#else\n\tclearopbeep(cap->oap);\n#endif\n    }\n#ifdef FEAT_TERMINAL\n    else if (term_in_normal_mode())\n    {\n\tclearop(cap->oap);\n\tterm_enter_job_mode();\n\treturn;\n    }\n#endif\n    else if (!curbuf->b_p_ma && !p_im)\n    {\n\t// Only give this error when 'insertmode' is off.\n\temsg(_(e_cannot_make_changes_modifiable_is_off));\n\tclearop(cap->oap);\n\tif (cap->cmdchar == K_PS)\n\t    // drop the pasted text\n\t    bracketed_paste(PASTE_INSERT, TRUE, NULL);\n    }\n    else if (cap->cmdchar == K_PS && VIsual_active)\n    {\n\tpos_T old_pos = curwin->w_cursor;\n\tpos_T old_visual = VIsual;\n\n\t// In Visual mode the selected text is deleted.\n\tif (VIsual_mode == 'V' || curwin->w_cursor.lnum != VIsual.lnum)\n\t{\n\t    shift_delete_registers();\n\t    cap->oap->regname = '1';\n\t}\n\telse\n\t    cap->oap->regname = '-';\n\tcap->cmdchar = 'd';\n\tcap->nchar = NUL;\n\tnv_operator(cap);\n\tdo_pending_operator(cap, 0, FALSE);\n\tcap->cmdchar = K_PS;\n\n\t// When the last char in the line was deleted then append. Detect this\n\t// by checking if the cursor moved to before the Visual area.\n\tif (*ml_get_cursor() != NUL && LT_POS(curwin->w_cursor, old_pos)\n\t\t\t\t       && LT_POS(curwin->w_cursor, old_visual))\n\t    inc_cursor();\n\n\t// Insert to replace the deleted text with the pasted text.\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (!checkclearopq(cap->oap))\n    {\n\tswitch (cap->cmdchar)\n\t{\n\t    case 'A':\t// \"A\"ppend after the line\n\t\tset_cursor_for_append_to_line();\n\t\tbreak;\n\n\t    case 'I':\t// \"I\"nsert before the first non-blank\n\t\tif (vim_strchr(p_cpo, CPO_INSEND) == NULL)\n\t\t    beginline(BL_WHITE);\n\t\telse\n\t\t    beginline(BL_WHITE|BL_FIX);\n\t\tbreak;\n\n\t    case K_PS:\n\t\t// Bracketed paste works like \"a\"ppend, unless the cursor is in\n\t\t// the first column, then it inserts.\n\t\tif (curwin->w_cursor.col == 0)\n\t\t    break;\n\t\t// FALLTHROUGH\n\n\t    case 'a':\t// \"a\"ppend is like \"i\"nsert on the next character.\n\t\t// increment coladd when in virtual space, increment the\n\t\t// column otherwise, also to append after an unprintable char\n\t\tif (virtual_active()\n\t\t\t&& (curwin->w_cursor.coladd > 0\n\t\t\t    || *ml_get_cursor() == NUL\n\t\t\t    || *ml_get_cursor() == TAB))\n\t\t    curwin->w_cursor.coladd++;\n\t\telse if (*ml_get_cursor() != NUL)\n\t\t    inc_cursor();\n\t\tbreak;\n\t}\n\n\tif (curwin->w_cursor.coladd && cap->cmdchar != 'A')\n\t{\n\t    int save_State = State;\n\n\t    // Pretend Insert mode here to allow the cursor on the\n\t    // character past the end of the line\n\t    State = INSERT;\n\t    coladvance(getviscol());\n\t    State = save_State;\n\t}\n\n\tinvoke_edit(cap, FALSE, cap->cmdchar, FALSE);\n    }\n    else if (cap->cmdchar == K_PS)\n\t// drop the pasted text\n\tbracketed_paste(PASTE_INSERT, TRUE, NULL);\n}\n\n/*\n * Invoke edit() and take care of \"restart_edit\" and the return value.\n */\n    static void\ninvoke_edit(\n    cmdarg_T\t*cap,\n    int\t\trepl,\t\t// \"r\" or \"gr\" command\n    int\t\tcmd,\n    int\t\tstartln)\n{\n    int\t\trestart_edit_save = 0;\n\n    // Complicated: When the user types \"a<C-O>a\" we don't want to do Insert\n    // mode recursively.  But when doing \"a<C-O>.\" or \"a<C-O>rx\" we do allow\n    // it.\n    if (repl || !stuff_empty())\n\trestart_edit_save = restart_edit;\n    else\n\trestart_edit_save = 0;\n\n    // Always reset \"restart_edit\", this is not a restarted edit.\n    restart_edit = 0;\n\n    if (edit(cmd, startln, cap->count1))\n\tcap->retval |= CA_COMMAND_BUSY;\n\n    if (restart_edit == 0)\n\trestart_edit = restart_edit_save;\n}\n\n#ifdef FEAT_TEXTOBJ\n/*\n * \"a\" or \"i\" while an operator is pending or in Visual mode: object motion.\n */\n    static void\nnv_object(\n    cmdarg_T\t*cap)\n{\n    int\t\tflag;\n    int\t\tinclude;\n    char_u\t*mps_save;\n\n    if (cap->cmdchar == 'i')\n\tinclude = FALSE;    // \"ix\" = inner object: exclude white space\n    else\n\tinclude = TRUE;\t    // \"ax\" = an object: include white space\n\n    // Make sure (), [], {} and <> are in 'matchpairs'\n    mps_save = curbuf->b_p_mps;\n    curbuf->b_p_mps = (char_u *)\"(:),{:},[:],<:>\";\n\n    switch (cap->nchar)\n    {\n\tcase 'w': // \"aw\" = a word\n\t\tflag = current_word(cap->oap, cap->count1, include, FALSE);\n\t\tbreak;\n\tcase 'W': // \"aW\" = a WORD\n\t\tflag = current_word(cap->oap, cap->count1, include, TRUE);\n\t\tbreak;\n\tcase 'b': // \"ab\" = a braces block\n\tcase '(':\n\tcase ')':\n\t\tflag = current_block(cap->oap, cap->count1, include, '(', ')');\n\t\tbreak;\n\tcase 'B': // \"aB\" = a Brackets block\n\tcase '{':\n\tcase '}':\n\t\tflag = current_block(cap->oap, cap->count1, include, '{', '}');\n\t\tbreak;\n\tcase '[': // \"a[\" = a [] block\n\tcase ']':\n\t\tflag = current_block(cap->oap, cap->count1, include, '[', ']');\n\t\tbreak;\n\tcase '<': // \"a<\" = a <> block\n\tcase '>':\n\t\tflag = current_block(cap->oap, cap->count1, include, '<', '>');\n\t\tbreak;\n\tcase 't': // \"at\" = a tag block (xml and html)\n\t\t// Do not adjust oap->end in do_pending_operator()\n\t\t// otherwise there are different results for 'dit'\n\t\t// (note leading whitespace in last line):\n\t\t// 1) <b>      2) <b>\n\t\t//    foobar      foobar\n\t\t//    </b>            </b>\n\t\tcap->retval |= CA_NO_ADJ_OP_END;\n\t\tflag = current_tagblock(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase 'p': // \"ap\" = a paragraph\n\t\tflag = current_par(cap->oap, cap->count1, include, 'p');\n\t\tbreak;\n\tcase 's': // \"as\" = a sentence\n\t\tflag = current_sent(cap->oap, cap->count1, include);\n\t\tbreak;\n\tcase '\"': // \"a\"\" = a double quoted string\n\tcase '\\'': // \"a'\" = a single quoted string\n\tcase '`': // \"a`\" = a backtick quoted string\n\t\tflag = current_quote(cap->oap, cap->count1, include,\n\t\t\t\t\t\t\t\t  cap->nchar);\n\t\tbreak;\n#if 0\t// TODO\n\tcase 'S': // \"aS\" = a section\n\tcase 'f': // \"af\" = a filename\n\tcase 'u': // \"au\" = a URL\n#endif\n\tdefault:\n\t\tflag = FAIL;\n\t\tbreak;\n    }\n\n    curbuf->b_p_mps = mps_save;\n    if (flag == FAIL)\n\tclearopbeep(cap->oap);\n    adjust_cursor_col();\n    curwin->w_set_curswant = TRUE;\n}\n#endif\n\n/*\n * \"q\" command: Start/stop recording.\n * \"q:\", \"q/\", \"q?\": edit command-line in command-line window.\n */\n    static void\nnv_record(cmdarg_T *cap)\n{\n    if (cap->oap->op_type == OP_FORMAT)\n    {\n\t// \"gqq\" is the same as \"gqgq\": format line\n\tcap->cmdchar = 'g';\n\tcap->nchar = 'q';\n\tnv_operator(cap);\n    }\n    else if (!checkclearop(cap->oap))\n    {\n#ifdef FEAT_CMDWIN\n\tif (cap->nchar == ':' || cap->nchar == '/' || cap->nchar == '?')\n\t{\n\t    stuffcharReadbuff(cap->nchar);\n\t    stuffcharReadbuff(K_CMDWIN);\n\t}\n\telse\n#endif\n\t    // (stop) recording into a named register, unless executing a\n\t    // register\n\t    if (reg_executing == 0 && do_record(cap->nchar) == FAIL)\n\t\tclearopbeep(cap->oap);\n    }\n}\n\n/*\n * Handle the \"@r\" command.\n */\n    static void\nnv_at(cmdarg_T *cap)\n{\n    if (checkclearop(cap->oap))\n\treturn;\n#ifdef FEAT_EVAL\n    if (cap->nchar == '=')\n    {\n\tif (get_expr_register() == NUL)\n\t    return;\n    }\n#endif\n    while (cap->count1-- && !got_int)\n    {\n\tif (do_execreg(cap->nchar, FALSE, FALSE, FALSE) == FAIL)\n\t{\n\t    clearopbeep(cap->oap);\n\t    break;\n\t}\n\tline_breakcheck();\n    }\n}\n\n/*\n * Handle the CTRL-U and CTRL-D commands.\n */\n    static void\nnv_halfpage(cmdarg_T *cap)\n{\n    if ((cap->cmdchar == Ctrl_U && curwin->w_cursor.lnum == 1)\n\t    || (cap->cmdchar == Ctrl_D\n\t\t&& curwin->w_cursor.lnum == curbuf->b_ml.ml_line_count))\n\tclearopbeep(cap->oap);\n    else if (!checkclearop(cap->oap))\n\thalfpage(cap->cmdchar == Ctrl_D, cap->count0);\n}\n\n/*\n * Handle \"J\" or \"gJ\" command.\n */\n    static void\nnv_join(cmdarg_T *cap)\n{\n    if (VIsual_active)\t// join the visual lines\n\tnv_operator(cap);\n    else if (!checkclearop(cap->oap))\n    {\n\tif (cap->count0 <= 1)\n\t    cap->count0 = 2;\t    // default for join is two lines!\n\tif (curwin->w_cursor.lnum + cap->count0 - 1 >\n\t\t\t\t\t\t   curbuf->b_ml.ml_line_count)\n\t{\n\t    // can't join when on the last line\n\t    if (cap->count0 <= 2)\n\t    {\n\t\tclearopbeep(cap->oap);\n\t\treturn;\n\t    }\n\t    cap->count0 = curbuf->b_ml.ml_line_count\n\t\t\t\t\t\t  - curwin->w_cursor.lnum + 1;\n\t}\n\n\tprep_redo(cap->oap->regname, cap->count0,\n\t\t\t\t     NUL, cap->cmdchar, NUL, NUL, cap->nchar);\n\t(void)do_join(cap->count0, cap->nchar == NUL, TRUE, TRUE, TRUE);\n    }\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n */\n    static void\nnv_put(cmdarg_T *cap)\n{\n    nv_put_opt(cap, FALSE);\n}\n\n/*\n * \"P\", \"gP\", \"p\" and \"gp\" commands.\n * \"fix_indent\" is TRUE for \"[p\", \"[P\", \"]p\" and \"]P\".\n */\n    static void\nnv_put_opt(cmdarg_T *cap, int fix_indent)\n{\n    int\t\tregname = 0;\n    void\t*reg1 = NULL, *reg2 = NULL;\n    int\t\tempty = FALSE;\n    int\t\twas_visual = FALSE;\n    int\t\tdir;\n    int\t\tflags = 0;\n\n    if (cap->oap->op_type != OP_NOP)\n    {\n#ifdef FEAT_DIFF\n\t// \"dp\" is \":diffput\"\n\tif (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'p')\n\t{\n\t    clearop(cap->oap);\n\t    nv_diffgetput(TRUE, cap->opcount);\n\t}\n\telse\n#endif\n\tclearopbeep(cap->oap);\n    }\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf) && !prompt_curpos_editable())\n    {\n\tclearopbeep(cap->oap);\n    }\n#endif\n    else\n    {\n\tif (fix_indent)\n\t{\n\t    dir = (cap->cmdchar == ']' && cap->nchar == 'p')\n\t\t\t\t\t\t\t ? FORWARD : BACKWARD;\n\t    flags |= PUT_FIXINDENT;\n\t}\n\telse\n\t    dir = (cap->cmdchar == 'P'\n\t\t    || ((cap->cmdchar == 'g' || cap->cmdchar == 'z')\n\t\t\t&& cap->nchar == 'P')) ? BACKWARD : FORWARD;\n\tprep_redo_cmd(cap);\n\tif (cap->cmdchar == 'g')\n\t    flags |= PUT_CURSEND;\n\telse if (cap->cmdchar == 'z')\n\t    flags |= PUT_BLOCK_INNER;\n\n\tif (VIsual_active)\n\t{\n\t    // Putting in Visual mode: The put text replaces the selected\n\t    // text.  First delete the selected text, then put the new text.\n\t    // Need to save and restore the registers that the delete\n\t    // overwrites if the old contents is being put.\n\t    was_visual = TRUE;\n\t    regname = cap->oap->regname;\n#ifdef FEAT_CLIPBOARD\n\t    adjust_clip_reg(&regname);\n#endif\n\t   if (regname == 0 || regname == '\"'\n\t\t\t\t     || VIM_ISDIGIT(regname) || regname == '-'\n#ifdef FEAT_CLIPBOARD\n\t\t    || (clip_unnamed && (regname == '*' || regname == '+'))\n#endif\n\n\t\t    )\n\t    {\n\t\t// The delete is going to overwrite the register we want to\n\t\t// put, save it first.\n\t\treg1 = get_register(regname, TRUE);\n\t    }\n\n\t    // Now delete the selected text. Avoid messages here.\n\t    cap->cmdchar = 'd';\n\t    cap->nchar = NUL;\n\t    cap->oap->regname = NUL;\n\t    ++msg_silent;\n\t    nv_operator(cap);\n\t    do_pending_operator(cap, 0, FALSE);\n\t    empty = (curbuf->b_ml.ml_flags & ML_EMPTY);\n\t    --msg_silent;\n\n\t    // delete PUT_LINE_BACKWARD;\n\t    cap->oap->regname = regname;\n\n\t    if (reg1 != NULL)\n\t    {\n\t\t// Delete probably changed the register we want to put, save\n\t\t// it first. Then put back what was there before the delete.\n\t\treg2 = get_register(regname, FALSE);\n\t\tput_register(regname, reg1);\n\t    }\n\n\t    // When deleted a linewise Visual area, put the register as\n\t    // lines to avoid it joined with the next line.  When deletion was\n\t    // characterwise, split a line when putting lines.\n\t    if (VIsual_mode == 'V')\n\t\tflags |= PUT_LINE;\n\t    else if (VIsual_mode == 'v')\n\t\tflags |= PUT_LINE_SPLIT;\n\t    if (VIsual_mode == Ctrl_V && dir == FORWARD)\n\t\tflags |= PUT_LINE_FORWARD;\n\t    dir = BACKWARD;\n\t    if ((VIsual_mode != 'V'\n\t\t\t&& curwin->w_cursor.col < curbuf->b_op_start.col)\n\t\t    || (VIsual_mode == 'V'\n\t\t\t&& curwin->w_cursor.lnum < curbuf->b_op_start.lnum))\n\t\t// cursor is at the end of the line or end of file, put\n\t\t// forward.\n\t\tdir = FORWARD;\n\t    // May have been reset in do_put().\n\t    VIsual_active = TRUE;\n\t}\n\tdo_put(cap->oap->regname, NULL, dir, cap->count1, flags);\n\n\t// If a register was saved, put it back now.\n\tif (reg2 != NULL)\n\t    put_register(regname, reg2);\n\n\t// What to reselect with \"gv\"?  Selecting the just put text seems to\n\t// be the most useful, since the original text was removed.\n\tif (was_visual)\n\t{\n\t    curbuf->b_visual.vi_start = curbuf->b_op_start;\n\t    curbuf->b_visual.vi_end = curbuf->b_op_end;\n\t    // need to adjust cursor position\n\t    if (*p_sel == 'e')\n\t\tinc(&curbuf->b_visual.vi_end);\n\t}\n\n\t// When all lines were selected and deleted do_put() leaves an empty\n\t// line that needs to be deleted now.\n\tif (empty && *ml_get(curbuf->b_ml.ml_line_count) == NUL)\n\t{\n\t    ml_delete_flags(curbuf->b_ml.ml_line_count, ML_DEL_MESSAGE);\n\t    deleted_lines(curbuf->b_ml.ml_line_count + 1, 1);\n\n\t    // If the cursor was in that line, move it to the end of the last\n\t    // line.\n\t    if (curwin->w_cursor.lnum > curbuf->b_ml.ml_line_count)\n\t    {\n\t\tcurwin->w_cursor.lnum = curbuf->b_ml.ml_line_count;\n\t\tcoladvance((colnr_T)MAXCOL);\n\t    }\n\t}\n\tauto_format(FALSE, TRUE);\n    }\n}\n\n/*\n * \"o\" and \"O\" commands.\n */\n    static void\nnv_open(cmdarg_T *cap)\n{\n#ifdef FEAT_DIFF\n    // \"do\" is \":diffget\"\n    if (cap->oap->op_type == OP_DELETE && cap->cmdchar == 'o')\n    {\n\tclearop(cap->oap);\n\tnv_diffgetput(FALSE, cap->opcount);\n    }\n    else\n#endif\n    if (VIsual_active)  // switch start and end of visual\n\tv_swap_corners(cap->cmdchar);\n#ifdef FEAT_JOB_CHANNEL\n    else if (bt_prompt(curbuf))\n\tclearopbeep(cap->oap);\n#endif\n    else\n\tn_opencmd(cap);\n}\n\n#ifdef FEAT_NETBEANS_INTG\n    static void\nnv_nbcmd(cmdarg_T *cap)\n{\n    netbeans_keycommand(cap->nchar);\n}\n#endif\n\n#ifdef FEAT_DND\n    static void\nnv_drop(cmdarg_T *cap UNUSED)\n{\n    do_put('~', NULL, BACKWARD, 1L, PUT_CURSEND);\n}\n#endif\n\n/*\n * Trigger CursorHold event.\n * When waiting for a character for 'updatetime' K_CURSORHOLD is put in the\n * input buffer.  \"did_cursorhold\" is set to avoid retriggering.\n */\n    static void\nnv_cursorhold(cmdarg_T *cap)\n{\n    apply_autocmds(EVENT_CURSORHOLD, NULL, NULL, FALSE, curbuf);\n    did_cursorhold = TRUE;\n    cap->retval |= CA_COMMAND_BUSY;\t// don't call edit() now\n}\n", "\" Tests for various Visual modes.\n\nsource shared.vim\nsource check.vim\nsource screendump.vim\n\nfunc Test_block_shift_multibyte()\n  \" Uses double-wide character.\n  split\n  call setline(1, ['x\u30f9xxx', '\u30f9xxx'])\n  exe \"normal 1G0l\\<C-V>jl>\"\n  call assert_equal('x\t \u30f9xxx', getline(1))\n  call assert_equal('\t\u30f9xxx', getline(2))\n  q!\nendfunc\n\nfunc Test_block_shift_overflow()\n  \" This used to cause a multiplication overflow followed by a crash.\n  new\n  normal ii\n  exe \"normal \\<C-V>876543210>\"\n  q!\nendfunc\n\nfunc Test_dotregister_paste()\n  new\n  exe \"norm! ihello world\\<esc>\"\n  norm! 0ve\".p\n  call assert_equal('hello world world', getline(1))\n  q!\nendfunc\n\nfunc Test_Visual_ctrl_o()\n  new\n  call setline(1, ['one', 'two', 'three'])\n  call cursor(1,2)\n  set noshowmode\n  set tw=0\n  call feedkeys(\"\\<c-v>jjlIa\\<c-\\>\\<c-o>:set tw=88\\<cr>\\<esc>\", 'tx')\n  call assert_equal(['oane', 'tawo', 'tahree'], getline(1, 3))\n  call assert_equal(88, &tw)\n  set tw&\n  bw!\nendfu\n\nfunc Test_Visual_vapo()\n  new\n  normal oxx\n  normal vapo\n  bwipe!\nendfunc\n\nfunc Test_Visual_inner_quote()\n  new\n  normal oxX\n  normal vki'\n  bwipe!\nendfunc\n\n\" Test for Visual mode not being reset causing E315 error.\nfunc TriggerTheProblem()\n  \" At this point there is no visual selection because :call reset it.\n  \" Let's restore the selection:\n  normal gv\n  '<,'>del _\n  try\n      exe \"normal \\<Esc>\"\n  catch /^Vim\\%((\\a\\+)\\)\\=:E315/\n      echom 'Snap! E315 error!'\n      let g:msg = 'Snap! E315 error!'\n  endtry\nendfunc\n\nfunc Test_visual_mode_reset()\n  enew\n  let g:msg = \"Everything's fine.\"\n  enew\n  setl buftype=nofile\n  call append(line('$'), 'Delete this line.')\n\n  \" NOTE: this has to be done by a call to a function because executing :del\n  \" the ex-way will require the colon operator which resets the visual mode\n  \" thus preventing the problem:\n  exe \"normal! GV:call TriggerTheProblem()\\<CR>\"\n  call assert_equal(\"Everything's fine.\", g:msg)\nendfunc\n\n\" Test for visual block shift and tab characters.\nfunc Test_block_shift_tab()\n  new\n  call append(0, repeat(['one two three'], 5))\n  call cursor(1,1)\n  exe \"normal i\\<C-G>u\"\n  exe \"normal fe\\<C-V>4jR\\<Esc>ugvr1\"\n  call assert_equal('on1 two three', getline(1))\n  call assert_equal('on1 two three', getline(2))\n  call assert_equal('on1 two three', getline(5))\n\n  %d _\n  call append(0, repeat(['abcdefghijklmnopqrstuvwxyz'], 5))\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<11|D\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>   \"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Esc>4k13|\\<C-V>4j<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  %s/\\s\\+//g\n  call cursor(1,1)\n  exe \"normal \\<C-V>4jI    \\<Esc>j<<\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>\\<Tab>\\<Tab>\\<Tab>\\<Tab>\"\n  exe \"normal j7|a\\<Tab>       \\<Tab>\\<Tab>\\<Esc>4k13|\\<C-V>4j3<\"\n  call assert_equal('    abcdefghijklmnopqrstuvwxyz', getline(1))\n  call assert_equal('abcdefghij', getline(2))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(3))\n  call assert_equal(\"    abc\\<Tab>\\<Tab>defghijklmnopqrstuvwxyz\", getline(4))\n  call assert_equal(\"    abc\\<Tab>    defghijklmnopqrstuvwxyz\", getline(5))\n\n  \" Test for block shift with space characters at the beginning and with\n  \" 'noexpandtab' and 'expandtab'\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 noexpandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"\\t1\", \"\\t2\", \"\\t3\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"      1\", \"      2\", \"      3\"])\n  setlocal shiftwidth=2 expandtab\n  exe \"normal gg\\<C-V>3j>\"\n  call assert_equal([\"        1\", \"        2\", \"        3\"], getline(1, '$'))\n  setlocal shiftwidth&\n\n  bw!\nendfunc\n\n\" Tests Blockwise Visual when there are TABs before the text.\nfunc Test_blockwise_visual()\n  new\n  call append(0, ['123456',\n\t      \\ '234567',\n\t      \\ '345678',\n\t      \\ '',\n\t      \\ 'test text test tex start here',\n\t      \\ \"\\t\\tsome text\",\n\t      \\ \"\\t\\ttest text\",\n\t      \\ 'test text'])\n  call cursor(1,1)\n  exe \"normal /start here$\\<CR>\"\n  exe 'normal \"by$' . \"\\<C-V>jjlld\"\n  exe \"normal /456$\\<CR>\"\n  exe \"normal \\<C-V>jj\" . '\"bP'\n  call assert_equal(['123start here56',\n\t      \\ '234start here67',\n\t      \\ '345start here78',\n\t      \\ '',\n\t      \\ 'test text test tex rt here',\n\t      \\ \"\\t\\tsomext\",\n\t      \\ \"\\t\\ttesext\"], getline(1, 7))\n\n  bw!\nendfunc\n\n\" Test swapping corners in blockwise visual mode with o and O\nfunc Test_blockwise_visual_o_O()\n  new\n\n  exe \"norm! 10i.\\<Esc>Y4P3lj\\<C-V>4l2jr \"\n  exe \"norm! gvO\\<Esc>ra\"\n  exe \"norm! gvO\\<Esc>rb\"\n  exe \"norm! gvo\\<C-c>rc\"\n  exe \"norm! gvO\\<C-c>rd\"\n  set selection=exclusive\n  exe \"norm! gvOo\\<C-c>re\"\n  call assert_equal('...a   be.', getline(4))\n  exe \"norm! gvOO\\<C-c>rf\"\n  set selection&\n\n  call assert_equal(['..........',\n        \\            '...c   d..',\n        \\            '...     ..',\n        \\            '...a   bf.',\n        \\            '..........'], getline(1, '$'))\n\n  bw!\nendfun\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace()\n  if exists('&t_kD')\n    let save_t_kD = &t_kD\n  endif\n  if exists('&t_kb')\n    let save_t_kb = &t_kb\n  endif\n  exe \"set t_kD=\\<C-V>x7f t_kb=\\<C-V>x08\"\n  enew!\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  set ai bs=2\n  exe \"normal gR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal([' 1',\n\t      \\ ' A',\n\t      \\ ' BCDEFGHIJ',\n\t      \\ ' \tKL',\n\t      \\ '\tMNO',\n\t      \\ '\tPQR',\n\t      \\ ], getline(1, 6))\n  normal G\n  mark a\n  exe \"normal o0\\<C-D>\\nabcdefghi\\njk\\tlmn\\n    opq\\trst\\n\\<C-D>uvwxyz\\n\"\n  exe \"normal 'ajgR0\\<C-D> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\" . repeat(\"\\<BS>\", 29)\n  call assert_equal([' 1',\n\t      \\ 'abcdefghi',\n\t      \\ 'jk\tlmn',\n\t      \\ '    opq\trst',\n\t      \\ 'uvwxyz'], getline(7, 11))\n  normal G\n  exe \"normal iab\\tcdefghi\\tjkl\"\n  exe \"normal 0gRAB......CDEFGHI.J\\<Esc>o\"\n  exe \"normal iabcdefghijklmnopqrst\\<Esc>0gRAB\\tIJKLMNO\\tQR\"\n  call assert_equal(['AB......CDEFGHI.Jkl',\n\t      \\ 'AB\tIJKLMNO\tQRst'], getline(12, 13))\n\n  \" Test inserting Tab with 'noexpandtab' and 'softabstop' set to 4\n  %d\n  call setline(1, 'aaaaaaaaaaaaa')\n  set softtabstop=4\n  exe \"normal gggR\\<Tab>\\<Tab>x\"\n  call assert_equal(\"\\txaaaa\", getline(1))\n  set softtabstop&\n\n  enew!\n  set noai bs&vim\n  if exists('save_t_kD')\n    let &t_kD = save_t_kD\n  endif\n  if exists('save_t_kb')\n    let &t_kb = save_t_kb\n  endif\nendfunc\n\n\" Test Virtual replace mode.\nfunc Test_virtual_replace2()\n  enew!\n  set bs=2\n  exe \"normal a\\nabcdefghi\\njk\\tlmn\\n    opq\trst\\n\\<C-D>uvwxyz\"\n  call cursor(1,1)\n  \" Test 1: Test that del deletes the newline\n  exe \"normal gR0\\<del> 1\\nA\\nBCDEFGHIJ\\n\\tKL\\nMNO\\nPQR\"\n  call assert_equal(['0 1',\n\t      \\ 'A',\n\t      \\ 'BCDEFGHIJ',\n\t      \\ '\tKL',\n\t      \\ 'MNO',\n\t      \\ 'PQR',\n\t      \\ ], getline(1, 6))\n  \" Test 2:\n  \" a newline is not deleted, if no newline has been added in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>5\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '123h',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 3:\n  \" a newline is deleted, if a newline has been inserted before in virtual replace mode\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  exe \"norm! gR1234\\<cr>\\<cr>56\\<bs>\\<bs>\\<bs>\"\n  call assert_equal(['abcd',\n        \\ '1234',\n        \\ 'ijkl'], getline(1, '$'))\n  \" Test 4:\n  \" delete add a newline, delete it, add it again and check undo\n  %d_\n  call setline(1, ['abcd', 'efgh', 'ijkl'])\n  call cursor(2,1)\n  \" break undo sequence explicitly\n  let &ul = &ul\n  exe \"norm! gR1234\\<cr>\\<bs>\\<del>56\\<cr>\"\n  let &ul = &ul\n  call assert_equal(['abcd',\n        \\ '123456',\n        \\ ''], getline(1, '$'))\n  norm! u\n  call assert_equal(['abcd',\n        \\ 'efgh',\n        \\ 'ijkl'], getline(1, '$'))\n\n  \" Test for truncating spaces in a newly added line using 'autoindent' if\n  \" characters are not added to that line.\n  %d_\n  call setline(1, ['    app', '    bee', '    cat'])\n  setlocal autoindent\n  exe \"normal gg$gRt\\n\\nr\"\n  call assert_equal(['    apt', '', '    rat'], getline(1, '$'))\n\n  \" clean up\n  %d_\n  set bs&vim\nendfunc\n\nfunc Test_Visual_word_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence.'])\n\n  \" When start and end of visual area are identical, 'aw' or 'iw' select\n  \" the whole word.\n  norm! 1go2fcvawy\n  call assert_equal('Second ', @\")\n  norm! 1go2fcviwy\n  call assert_equal('Second', @\")\n\n  \" When start and end of visual area are not identical, 'aw' or 'iw'\n  \" extend the word in direction of the end of the visual area.\n  norm! 1go2fcvlawy\n  call assert_equal('cond ', @\")\n  norm! gv2awy\n  call assert_equal('cond sentence.', @\")\n\n  norm! 1go2fcvliwy\n  call assert_equal('cond', @\")\n  norm! gv2iwy\n  call assert_equal('cond sentence', @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1go2fcvhawy\n  call assert_equal(' Sec', @\")\n  norm! gv2awy\n  call assert_equal(' sentence. Sec', @\")\n\n  norm! 1go2fcvhiwy\n  call assert_equal('Sec', @\")\n  norm! gv2iwy\n  call assert_equal('. Sec', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_sentence_textobject()\n  new\n  call setline(1, ['First sentence. Second sentence. Third', 'sentence. Fourth sentence'])\n\n  \" When start and end of visual area are identical, 'as' or 'is' select\n  \" the whole sentence.\n  norm! 1gofdvasy\n  call assert_equal('Second sentence. ', @\")\n  norm! 1gofdvisy\n  call assert_equal('Second sentence.', @\")\n\n  \" When start and end of visual area are not identical, 'as' or 'is'\n  \" extend the sentence in direction of the end of the visual area.\n  norm! 1gofdvlasy\n  call assert_equal('d sentence. ', @\")\n  norm! gvasy\n  call assert_equal(\"d sentence. Third\\nsentence. \", @\")\n\n  norm! 1gofdvlisy\n  call assert_equal('d sentence.', @\")\n  norm! gvisy\n  call assert_equal('d sentence. ', @\")\n  norm! gvisy\n  call assert_equal(\"d sentence. Third\\nsentence.\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 1gofdvhasy\n  call assert_equal(' Second', @\")\n  norm! gvasy\n  call assert_equal(\"First sentence. Second\", @\")\n\n  norm! 1gofdvhisy\n  call assert_equal('Second', @\")\n  norm! gvisy\n  call assert_equal(' Second', @\")\n  norm! gvisy\n  call assert_equal('First sentence. Second', @\")\n\n  bwipe!\nendfunc\n\nfunc Test_Visual_paragraph_textobject()\n  new\n  let lines =<< trim [END]\n    First line.\n\n    Second line.\n    Third line.\n    Fourth line.\n    Fifth line.\n\n    Sixth line.\n  [END]\n  call setline(1, lines)\n\n  \" When start and end of visual area are identical, 'ap' or 'ip' select\n  \" the whole paragraph.\n  norm! 4ggvapy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! 4ggvipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\nFifth line.\\n\", @\")\n\n  \" When start and end of visual area are not identical, 'ap' or 'ip'\n  \" extend the sentence in direction of the end of the visual area.\n  \" FIXME: actually, it is not sufficient to have different start and\n  \" end of visual selection, the start line and end line have to differ,\n  \" which is not consistent with the documentation.\n  norm! 4ggVjapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n  norm! 4ggVjipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"Third line.\\nFourth line.\\nFifth line.\\n\\nSixth line.\\n\", @\")\n\n  \" Extend visual area in opposite direction.\n  norm! 5ggVkapy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvapy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! 5ggVkipy\n  call assert_equal(\"Second line.\\nThird line.\\nFourth line.\\n\", @\")\n  norma gvipy\n  call assert_equal(\"\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n  norm! gvipy\n  call assert_equal(\"First line.\\n\\nSecond line.\\nThird line.\\nFourth line.\\n\", @\")\n\n  bwipe!\nendfunc\n\nfunc Test_curswant_not_changed()\n  new\n  call setline(1, ['one', 'two'])\n  au InsertLeave * call getcurpos()\n  call feedkeys(\"gg0\\<C-V>jI123 \\<Esc>j\", 'xt')\n  call assert_equal([0, 2, 1, 0, 1], getcurpos())\n\n  bwipe!\n  au! InsertLeave\nendfunc\n\n\" Tests for \"vaBiB\", end could be wrong.\nfunc Test_Visual_Block()\n  new\n  a\n- Bug in \"vPPPP\" on this text:\n\t{\n\t\tcmd;\n\t\t{\n\t\t\tcmd;\\t/* <-- Start cursor here */\n\t\t\t{\n\t\t\t}\n\t\t}\n\t}\n.\n  normal gg\n  call search('Start cursor here')\n  normal vaBiBD\n  call assert_equal(['- Bug in \"vPPPP\" on this text:',\n\t      \\ \"\\t{\",\n\t      \\ \"\\t}\"], getline(1, '$'))\n\n  close!\nendfunc\n\n\" Test for 'p'ut in visual block mode\nfunc Test_visual_block_put()\n  new\n  call append(0, ['One', 'Two', 'Three'])\n  normal gg\n  yank\n  call feedkeys(\"jl\\<C-V>ljp\", 'xt')\n  call assert_equal(['One', 'T', 'Tee', 'One', ''], getline(1, '$'))\n  bw!\nendfunc\n\n\" Visual modes (v V CTRL-V) followed by an operator; count; repeating\nfunc Test_visual_mode_op()\n  new\n  call append(0, '')\n\n  call setline(1, 'apple banana cherry')\n  call cursor(1, 1)\n  normal lvld.l3vd.\n  call assert_equal('a y', getline(1))\n\n  call setline(1, ['line 1 line 1', 'line 2 line 2', 'line 3 line 3',\n        \\ 'line 4 line 4', 'line 5 line 5', 'line 6 line 6'])\n  call cursor(1, 1)\n  exe \"normal Vcnewline\\<Esc>j.j2Vd.\"\n  call assert_equal(['newline', 'newline'], getline(1, '$'))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xxxxxxxxxxxxx', 'xxxxxxxxxxxxx', 'xxxxxxxxxxxxx',\n        \\ 'xxxxxxxxxxxxx'])\n  exe \"normal \\<C-V>jlc  \\<Esc>l.l2\\<C-V>c----\\<Esc>l.\"\n  call assert_equal(['    --------x',\n        \\ '    --------x',\n        \\ 'xxxx--------x',\n        \\ 'xxxx--------x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\n\" Visual mode maps (movement and text object)\n\" Visual mode maps; count; repeating\n\"   - Simple\n\"   - With an Ex command (custom text object)\nfunc Test_visual_mode_maps()\n  new\n  call append(0, '')\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  vnoremap W /\\u/s-1<CR>\n  vnoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'KiwiRaspberryDateWatermelonPeach')\n  call cursor(1, 1)\n  exe \"normal vWcNo\\<Esc>l.fD2vd.\"\n  call assert_equal('NoNoberryach', getline(1))\n\n  call setline(1, 'JambuRambutanBananaTangerineMango')\n  call cursor(1, 1)\n  exe \"normal llviWc-\\<Esc>l.l2vdl.\"\n  call assert_equal('--ago', getline(1))\n\n  vunmap W\n  vunmap iW\n  bwipe!\n  delfunc SelectInCaps\nendfunc\n\n\" Operator-pending mode maps (movement and text object)\n\"   - Simple\n\"   - With Ex command moving the cursor\n\"   - With Ex command and Visual selection (custom text object)\nfunc Test_visual_oper_pending_mode_maps()\n  new\n  call append(0, '')\n\n  func MoveToCap()\n    call search('\\u', 'W')\n  endfunction\n\n  func SelectInCaps()\n    let [line1, col1] = searchpos('\\u', 'bcnW')\n    let [line2, col2] = searchpos('.\\u', 'nW')\n    call setpos(\"'<\", [0, line1, col1, 0])\n    call setpos(\"'>\", [0, line2, col2, 0])\n    normal! gv\n  endfunction\n\n  onoremap W /\\u/<CR>\n  onoremap <Leader>W :<C-U>call MoveToCap()<CR>\n  onoremap iW :<C-U>call SelectInCaps()<CR>\n\n  call setline(1, 'PineappleQuinceLoganberryOrangeGrapefruitKiwiZ')\n  call cursor(1, 1)\n  exe \"normal cW-\\<Esc>l.l2.l.\"\n  call assert_equal('----Z', getline(1))\n\n  call setline(1, 'JuniperDurianZ')\n  call cursor(1, 1)\n  exe \"normal g?\\WfD.\"\n  call assert_equal('WhavcreQhevnaZ', getline(1))\n\n  call setline(1, 'LemonNectarineZ')\n  call cursor(1, 1)\n  exe \"normal yiWPlciWNew\\<Esc>fr.\"\n  call assert_equal('LemonNewNewZ', getline(1))\n\n  ounmap W\n  ounmap <Leader>W\n  ounmap iW\n  bwipe!\n  delfunc MoveToCap\n  delfunc SelectInCaps\nendfunc\n\n\" Patch 7.3.879: Properly abort Operator-pending mode for \"dv:<Esc>\" etc.\nfunc Test_op_pend_mode_abort()\n  new\n  call append(0, '')\n\n  call setline(1, ['zzzz', 'zzzz'])\n  call cursor(1, 1)\n\n  exe \"normal dV:\\<CR>dv:\\<CR>\"\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  call assert_fails('exe \"normal d:\\<CR>\"', 'E21:')\n  set modifiable\n  call feedkeys(\"dv:\\<Esc>dV:\\<Esc>\", 'xt')\n  call assert_equal(['zzz'], getline(1, 2))\n  set nomodifiable\n  let v:errmsg = ''\n  call feedkeys(\"d:\\<Esc>\", 'xt')\n  call assert_true(v:errmsg !~# '^E21:')\n  set modifiable\n\n  bwipe!\nendfunc\n\nfunc Test_characterwise_visual_mode()\n  new\n\n  \" characterwise visual mode: replace last line\n  $put ='a'\n  let @\" = 'x'\n  normal v$p\n  call assert_equal('x', getline('$'))\n\n  \" characterwise visual mode: delete middle line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal G\n  normal kkv$d\n  call assert_equal(['', 'b', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete middle two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkkvj$d\n  call assert_equal(['', 'c'], getline(1, '$'))\n\n  \" characterwise visual mode: delete last line\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gv$d\n  call assert_equal(['', 'a', 'b', ''], getline(1, '$'))\n\n  \" characterwise visual mode: delete last two lines\n  call deletebufline('', 1, '$')\n  call append('$', ['a', 'b', 'c'])\n  normal Gkvj$d\n  call assert_equal(['', 'a', ''], getline(1, '$'))\n\n  \" characterwise visual mode: use a count with the visual mode from the last\n  \" line in the buffer\n  %d _\n  call setline(1, ['one', 'two', 'three', 'four'])\n  norm! vj$y\n  norm! G1vy\n  call assert_equal('four', @\")\n\n  \" characterwise visual mode: replace a single character line and the eol\n  %d _\n  call setline(1, \"a\")\n  normal v$rx\n  call assert_equal(['x'], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_visual_mode_put()\n  new\n\n  \" v_p: replace last character with line register at middle line\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$vp\n  call assert_equal(['', 'aaa', 'bb', 'aaa', '', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at middle line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal k$v$p\n  call assert_equal(['', 'aaa', 'bb', 'aaa', 'ccc'], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $vp\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  \" v_p: replace last character with line register at last line selecting\n  \" newline\n  call deletebufline('', 1, '$')\n  call append('$', ['aaa', 'bbb', 'ccc'])\n  normal G\n  -2yank\n  normal $v$p\n  call assert_equal(['', 'aaa', 'bbb', 'cc', 'aaa', ''], getline(1, '$'))\n\n  bwipe!\nendfunc\n\nfunc Test_gv_with_exclusive_selection()\n  new\n\n  \" gv with exclusive selection after an operation\n  call append('$', ['zzz ', '\u00c3\u00a4\u00c3 '])\n  set selection=exclusive\n  normal Gkv3lyjv3lpgvcxxx\n  call assert_equal(['', 'zzz ', 'xxx '], getline(1, '$'))\n\n  \" gv with exclusive selection without an operation\n  call deletebufline('', 1, '$')\n  call append('$', 'zzz ')\n  set selection=exclusive\n  exe \"normal G0v3l\\<Esc>gvcxxx\"\n  call assert_equal(['', 'xxx '], getline(1, '$'))\n\n  set selection&vim\n  bwipe!\nendfunc\n\n\" Tests for the visual block mode commands\nfunc Test_visual_block_mode()\n  new\n  call append(0, '')\n  call setline(1, repeat(['abcdefghijklm'], 5))\n  call cursor(1, 1)\n\n  \" Test shift-right of a block\n  exe \"normal jllll\\<C-V>jj>wll\\<C-V>jlll>\"\n  \" Test shift-left of a block\n  exe \"normal G$hhhh\\<C-V>kk<\"\n  \" Test block-insert\n  exe \"normal Gkl\\<C-V>kkkIxyz\"\n  \" Test block-replace\n  exe \"normal Gllll\\<C-V>kkklllrq\"\n  \" Test block-change\n  exe \"normal G$khhh\\<C-V>hhkkcmno\"\n  call assert_equal(['axyzbcdefghijklm',\n        \\ 'axyzqqqq   mno\t      ghijklm',\n        \\ 'axyzqqqqef mno        ghijklm',\n        \\ 'axyzqqqqefgmnoklm',\n        \\ 'abcdqqqqijklm'], getline(1, 5))\n\n  \" Test 'C' to change till the end of the line\n  call cursor(3, 4)\n  exe \"normal! \\<C-V>j3lCooo\"\n  call assert_equal(['axyooo', 'axyooo'], getline(3, 4))\n\n  \" Test 'D' to delete till the end of the line\n  call cursor(3, 3)\n  exe \"normal! \\<C-V>j2lD\"\n  call assert_equal(['ax', 'ax'], getline(3, 4))\n\n  \" Test block insert with a short line that ends before the block\n  %d _\n  call setline(1, [\"  one\", \"a\", \"  two\"])\n  exe \"normal gg\\<C-V>2jIx\"\n  call assert_equal([\"  xone\", \"a\", \"  xtwo\"], getline(1, '$'))\n\n  \" Test block append at EOL with '$' and without '$'\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg$\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"ax\", \"twox\"], getline(1, '$'))\n  %d _\n  call setline(1, [\"one\", \"a\", \"two\"])\n  exe \"normal gg3l\\<C-V>2jAx\"\n  call assert_equal([\"onex\", \"a  x\", \"twox\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and use $ to jump to\n  \" the end of the line.\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg$\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Test block replace with an empty line in the middle and move cursor to the\n  \" end of the line\n  %d _\n  call setline(1, ['one', '', 'two'])\n  exe \"normal gg2l\\<C-V>2jrx\"\n  call assert_equal([\"onx\", \"\", \"twx\"], getline(1, '$'))\n\n  \" Replace odd number of characters with a multibyte character\n  %d _\n  call setline(1, ['abcd', 'efgh'])\n  exe \"normal ggl\\<C-V>2ljr\\u1100\"\n  call assert_equal([\"a\\u1100 \", \"e\\u1100 \"], getline(1, '$'))\n\n  \" During visual block append, if the cursor moved outside of the selected\n  \" range, then the edit should not be applied to the block.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal 2G\\<C-V>jAx\\<Up>\"\n  call assert_equal(['aaa', 'bxbb', 'ccc'], getline(1, '$'))\n\n  \" During visual block append, if the cursor is moved before the start of the\n  \" block, then the new text should be appended there.\n  %d _\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal $\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n  \" Repeat the previous test but use 'l' to move the cursor instead of '$'\n  call setline(1, ['aaa', 'bbb', 'ccc'])\n  exe \"normal! gg2l\\<C-V>2jA\\<Left>x\"\n  call assert_equal(['aaxa', 'bbxb', 'ccxc'], getline(1, '$'))\n\n  \" Change a characterwise motion to a blockwise motion using CTRL-V\n  %d _\n  call setline(1, ['123', '456', '789'])\n  exe \"normal ld\\<C-V>j\"\n  call assert_equal(['13', '46', '789'], getline(1, '$'))\n\n  \" Test from ':help v_b_I_example'\n  %d _\n  setlocal tabstop=8 shiftwidth=4\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3jISTRING\"\n  let expected =<< trim END\n    abcdefghijklmnSTRINGopqrstuvwxyz\n    abc\t      STRING  defghijklmnopqrstuvwxyz\n    abcdef  ghi   STRING  \tjklmnopqrstuvwxyz\n    abcdefghijklmnSTRINGopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_A_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j$ASTRING\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyzSTRING\n    abc\t\tdefghijklmnopqrstuvwxyzSTRING\n    abcdef  ghi\t\tjklmnopqrstuvwxyzSTRING\n    abcdefghijklmnopqrstuvwxyzSTRING\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_<_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j3l<..\"\n  let expected =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t      defghijklmnopqrstuvwxyz\n    abcdef  ghi   jklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_>_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>3j>..\"\n  let expected =<< trim END\n    abcdefghijklmn\t\t  opqrstuvwxyz\n    abc\t\t\t    defghijklmnopqrstuvwxyz\n    abcdef  ghi\t\t\t    jklmnopqrstuvwxyz\n    abcdefghijklmn\t\t  opqrstuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  \" Test from ':help v_b_r_example'\n  %d _\n  let lines =<< trim END\n    abcdefghijklmnopqrstuvwxyz\n    abc\t\tdefghijklmnopqrstuvwxyz\n    abcdef  ghi\t\tjklmnopqrstuvwxyz\n    abcdefghijklmnopqrstuvwxyz\n  END\n  call setline(1, lines)\n  exe \"normal ggfo\\<C-V>5l3jrX\"\n  let expected =<< trim END\n    abcdefghijklmnXXXXXXuvwxyz\n    abc\t      XXXXXXhijklmnopqrstuvwxyz\n    abcdef  ghi   XXXXXX    jklmnopqrstuvwxyz\n    abcdefghijklmnXXXXXXuvwxyz\n  END\n  call assert_equal(expected, getline(1, '$'))\n\n  bwipe!\n  set tabstop& shiftwidth&\nendfunc\n\nfunc Test_visual_force_motion_feedkeys()\n    onoremap <expr> i- execute('let g:mode = mode(1)')->slice(0, 0)\n    call feedkeys('dvi-', 'x')\n    call assert_equal('nov', g:mode)\n    call feedkeys('di-', 'x')\n    call assert_equal('no', g:mode)\n    ounmap i-\nendfunc\n\n\" Test block-insert using cursor keys for movement\nfunc Test_visual_block_insert_cursor_keys()\n  new\n  call append(0, ['aaaaaa', 'bbbbbb', 'cccccc', 'dddddd'])\n  call cursor(1, 1)\n\n  exe \"norm! l\\<C-V>jjjlllI\\<Right>\\<Right>  \\<Esc>\"\n  call assert_equal(['aaa  aaa', 'bbb  bbb', 'ccc  ccc', 'ddd  ddd'],\n        \\ getline(1, 4))\n\n  call deletebufline('', 1, '$')\n  call setline(1, ['xaaa', 'bbbb', 'cccc', 'dddd'])\n  call cursor(1, 1)\n  exe \"norm! \\<C-V>jjjI<>\\<Left>p\\<Esc>\"\n  call assert_equal(['<p>xaaa', '<p>bbbb', '<p>cccc', '<p>dddd'],\n        \\ getline(1, 4))\n  bwipe!\nendfunc\n\nfunc Test_visual_block_create()\n  new\n  call append(0, '')\n  \" Test for Visual block was created with the last <C-v>$\n  call setline(1, ['A23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$Aab\\<Esc>\"\n  call assert_equal(['A23ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (1)\n  call deletebufline('', 1, '$')\n  call setline(1, ['B23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hAab\\<Esc>\"\n  call assert_equal(['B23 ab', '4567ab'], getline(1, 2))\n\n  \" Test for Visual block was created with the middle <C-v>$ (2)\n  call deletebufline('', 1, '$')\n  call setline(1, ['C23', '4567'])\n  call cursor(1, 1)\n  exe \"norm! l\\<C-V>j$hhAab\\<Esc>\"\n  call assert_equal(['C23ab', '456ab7'], getline(1, 2))\n  bwipe!\nendfunc\n\n\" Test for Visual block insert when virtualedit=all\nfunc Test_virtualedit_visual_block()\n  set ve=all\n  new\n  call append(0, [\"\\t\\tline1\", \"\\t\\tline2\", \"\\t\\tline3\"])\n  call cursor(1, 1)\n  exe \"norm! 07l\\<C-V>jjIx\\<Esc>\"\n  call assert_equal([\"       x \\tline1\",\n        \\ \"       x \\tline2\",\n        \\ \"       x \\tline3\"], getline(1, 3))\n\n  \" Test for Visual block append when virtualedit=all\n  exe \"norm! 012l\\<C-v>jjAx\\<Esc>\"\n  call assert_equal(['       x     x   line1',\n        \\ '       x     x   line2',\n        \\ '       x     x   line3'], getline(1, 3))\n  set ve=\n  bwipe!\nendfunc\n\n\" Test for changing case\nfunc Test_visual_change_case()\n  new\n  \" gUe must uppercase a whole word, also when \u00df changes to SS\n  exe \"normal Gothe youtu\u00dfeuu end\\<Esc>Ypk0wgUe\\r\"\n  \" gUfx must uppercase until x, inclusive.\n  exe \"normal O- you\u00dftu\u00dfexu -\\<Esc>0fogUfx\\r\"\n  \" VU must uppercase a whole line\n  exe \"normal YpkVU\\r\"\n  \" same, when it's the last line in the buffer\n  exe \"normal YPGi111\\<Esc>VUddP\\r\"\n  \" Uppercase two lines\n  exe \"normal Oblah di\\rdoh dut\\<Esc>VkUj\\r\"\n  \" Uppercase part of two lines\n  exe \"normal ddppi333\\<Esc>k0i222\\<Esc>fyllvjfuUk\"\n  call assert_equal(['the YOUTUSSEUU end', '- yOUSSTUSSEXu -',\n        \\ 'THE YOUTUSSEUU END', '111THE YOUTUSSEUU END', 'BLAH DI', 'DOH DUT',\n        \\ '222the yoUTUSSEUU END', '333THE YOUTU\u00dfeuu end'], getline(2, '$'))\n  bwipe!\nendfunc\n\n\" Test for Visual replace using Enter or NL\nfunc Test_visual_replace_crnl()\n  new\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\r\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\r\\n\"\n  exe \"normal G3o123456789\\e2k05l\\<C-V>2jr\\n\"\n  exe \"normal G3o98765\\e2k02l\\<C-V>2jr\\<C-V>\\n\"\n  call assert_equal(['12345', '789', '12345', '789', '12345', '789', \"98\\r65\",\n        \\ \"98\\r65\", \"98\\r65\", '12345', '789', '12345', '789', '12345', '789',\n        \\ \"98\\n65\", \"98\\n65\", \"98\\n65\"], getline(2, '$'))\n  bwipe!\nendfunc\n\nfunc Test_ve_block_curpos()\n  new\n  \" Test cursor position. When ve=block and Visual block mode and $gj\n  call append(0, ['12345', '789'])\n  call cursor(1, 3)\n  set virtualedit=block\n  exe \"norm! \\<C-V>$gj\\<Esc>\"\n  call assert_equal([0, 2, 4, 0], getpos(\"'>\"))\n  set virtualedit=\n  bwipe!\nendfunc\n\n\" Test for block_insert when replacing spaces in front of the a with tabs\nfunc Test_block_insert_replace_tabs()\n  new\n  set ts=8 sts=4 sw=4\n  call append(0, [\"#define BO_ALL\\t    0x0001\",\n        \\ \"#define BO_BS\\t    0x0002\",\n        \\ \"#define BO_CRSR\\t    0x0004\"])\n  call cursor(1, 1)\n  exe \"norm! f0\\<C-V>2jI\\<tab>\\<esc>\"\n  call assert_equal([\n        \\ \"#define BO_ALL\\t\\t0x0001\",\n        \\ \"#define BO_BS\\t    \\t0x0002\",\n        \\ \"#define BO_CRSR\\t    \\t0x0004\", ''], getline(1, '$'))\n  set ts& sts& sw&\n  bwipe!\nendfunc\n\n\" Test for * register in :\nfunc Test_star_register()\n  call assert_fails('*bfirst', 'E16:')\n  new\n  call setline(1, ['foo', 'bar', 'baz', 'qux'])\n  exe \"normal jVj\\<ESC>\"\n  *yank r\n  call assert_equal(\"bar\\nbaz\\n\", @r)\n\n  delmarks < >\n  call assert_fails('*yank', 'E20:')\n  close!\nendfunc\n\n\" Test for changing text in visual mode with 'exclusive' selection\nfunc Test_exclusive_selection()\n  new\n  call setline(1, ['one', 'two'])\n  set selection=exclusive\n  call feedkeys(\"vwcabc\", 'xt')\n  call assert_equal('abctwo', getline(1))\n  call setline(1, [\"\\tone\"])\n  set virtualedit=all\n  call feedkeys('0v2lcl', 'xt')\n  call assert_equal('l      one', getline(1))\n  set virtualedit&\n  set selection&\n  close!\nendfunc\n\n\" Test for starting linewise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_linewise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one', 'two', 'three', 'four'])\n    norm! 3Vy\n    call assert_equal(\"one\\ntwo\\nthree\\n\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for starting characterwise visual with a count.\n\" This test needs to be run without any previous visual mode. Otherwise the\n\" count will use the count from the previous visual mode.\nfunc Test_characterwise_visual_with_count()\n  let after =<< trim [CODE]\n    call setline(1, ['one two', 'three'])\n    norm! l5vy\n    call assert_equal(\"ne tw\", @\")\n    call writefile(v:errors, 'Xtestout')\n    qall!\n  [CODE]\n  if RunVim([], after, '')\n    call assert_equal([], readfile('Xtestout'))\n    call delete('Xtestout')\n  endif\nendfunc\n\n\" Test for visually selecting an inner block (iB)\nfunc Test_visual_inner_block()\n  new\n  call setline(1, ['one', '{', 'two', '{', 'three', '}', 'four', '}', 'five'])\n  call cursor(5, 1)\n  \" visually select all the lines in the block and then execute iB\n  call feedkeys(\"ViB\\<C-C>\", 'xt')\n  call assert_equal([0, 5, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 5, 6, 0], getpos(\"'>\"))\n  \" visually select two inner blocks\n  call feedkeys(\"ViBiB\\<C-C>\", 'xt')\n  call assert_equal([0, 3, 1, 0], getpos(\"'<\"))\n  call assert_equal([0, 7, 5, 0], getpos(\"'>\"))\n  \" try to select non-existing inner block\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiBiB')\n  \" try to select a unclosed inner block\n  8,9d\n  call cursor(5, 1)\n  call assert_beeps('normal ViBiB')\n  close!\nendfunc\n\nfunc Test_visual_put_in_block()\n  new\n  call setline(1, ['xxxx', 'y\u221eyy', 'zzzz'])\n  normal 1G2yl\n  exe \"normal 1G2l\\<C-V>jjlp\"\n  call assert_equal(['xxxx', 'y\u221exx', 'zzxx'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zp()\n  new\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  %d\n  \" paste using zP\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ '/subdir', \n    \\ '/longsubdir',\n    \\ '/longlongsubdir'])\n  exe \"normal! 5G\\<c-v>2j$y\"\n  norm! 1Gf;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_in_block_using_zy_and_zp()\n  new\n\n  \" Test 1) Paste using zp - after the cursor without trailing spaces\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hzp\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 2) Paste using zP - in front of the cursor without trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/subdir;text', '/path/longsubdir;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 3) Paste using p - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;hp\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 4) Paste using P - with trailing spaces\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /subdir           columntext',\n\t\t\\ 'texttext  /longsubdir       columntext',\n    \\ 'texttext  /longlongsubdir   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jezy\"\n  norm! 1G0f;P\n  call assert_equal(['/path/subdir        ;text', '/path/longsubdir    ;text', '/path/longlongsubdir;text'], getline(1, 3))\n\n  \" Test 5) Yank with spaces inside the block\n  %d\n  call setline(1, ['/path;text', '/path;text', '/path;text', '', \n    \\ 'texttext  /sub    dir/           columntext',\n    \\ 'texttext  /lon    gsubdir/       columntext',\n    \\ 'texttext  /lon    glongsubdir/   columntext'])\n  exe \"normal! 5G0f/\\<c-v>2jf/zy\"\n  norm! 1G0f;zP\n  call assert_equal(['/path/sub    dir/;text', '/path/lon    gsubdir/;text', '/path/lon    glongsubdir/;text'], getline(1, 3))\n  bwipe!\nendfunc\n\nfunc Test_visual_put_blockedit_zy_and_zp()\n  new\n\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  \"\n  \" now with blockmode editing\n  sil %d\n  :set ve=block\n  call setline(1, ['aa', 'bbbbb', 'ccc', '', 'XX', 'GGHHJ', 'RTZU'])\n  exe \"normal! gg0\\<c-v>2j$zy\"\n  norm! 5gg0zP\n  call assert_equal(['aa', 'bbbbb', 'ccc', '', 'aaXX', 'bbbbbGGHHJ', 'cccRTZU'], getline(1, 7))\n  set ve&vim\n  bw!\nendfunc\n\nfunc Test_visual_block_with_virtualedit()\n  CheckScreendump\n\n  let lines =<< trim END\n    call setline(1, ['aaaaaa', 'bbbb', 'cc'])\n    set virtualedit=block\n    normal G\n  END\n  call writefile(lines, 'XTest_block')\n\n  let buf = RunVimInTerminal('-S XTest_block', {'rows': 8, 'cols': 50})\n  call term_sendkeys(buf, \"\\<C-V>gg$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit', {})\n\n  call term_sendkeys(buf, \"\\<Esc>gg\\<C-V>G$\")\n  call VerifyScreenDump(buf, 'Test_visual_block_with_virtualedit2', {})\n\n  \" clean up\n  call term_sendkeys(buf, \"\\<Esc>\")\n  call StopVimInTerminal(buf)\n  call delete('XTest_block')\nendfunc\n\nfunc Test_visual_block_ctrl_w_f()\n  \" Emtpy block selected in new buffer should not result in an error.\n  au! BufNew foo sil norm \u0016\u0017f\n  edit foo\n\n  au! BufNew\nendfunc\n\nfunc Test_visual_reselect_with_count()\n  \" this was causing an illegal memory access\n  let lines =<< trim END\n\n\n\n      :\n      r<sfile>\n      exe \"%norm e3\\<c-v>kr\\t\"\n      :\n\n      :\n  END\n  call writefile(lines, 'XvisualReselect')\n  source XvisualReselect\n\n  bwipe!\n  call delete('XvisualReselect')\nendfunc\n\n\n\" vim: shiftwidth=2 sts=2 expandtab\n", "/* vi:set ts=8 sts=4 sw=4 noet:\n *\n * VIM - Vi IMproved\t\tby Bram Moolenaar\n *\n * Do \":help uganda\"  in Vim to read copying and usage conditions.\n * Do \":help credits\" in Vim to see a list of people who contributed.\n * See README.txt for an overview of the Vim source code.\n */\n\n#include \"vim.h\"\n\n/*\n * Vim originated from Stevie version 3.6 (Fish disk 217) by GRWalter (Fred)\n * It has been changed beyond recognition since then.\n *\n * Differences between version 7.4 and 8.x can be found with \":help version8\".\n * Differences between version 6.4 and 7.x can be found with \":help version7\".\n * Differences between version 5.8 and 6.x can be found with \":help version6\".\n * Differences between version 4.x and 5.x can be found with \":help version5\".\n * Differences between version 3.0 and 4.x can be found with \":help version4\".\n * All the remarks about older versions have been removed, they are not very\n * interesting.\n */\n\n#include \"version.h\"\n\nchar\t\t*Version = VIM_VERSION_SHORT;\nstatic char\t*mediumVersion = VIM_VERSION_MEDIUM;\n\n#if defined(HAVE_DATE_TIME) || defined(PROTO)\n# if (defined(VMS) && defined(VAXC)) || defined(PROTO)\nchar\tlongVersion[sizeof(VIM_VERSION_LONG_DATE) + sizeof(__DATE__)\n\t\t\t\t\t\t      + sizeof(__TIME__) + 3];\n\n    void\ninit_longVersion(void)\n{\n    /*\n     * Construct the long version string.  Necessary because\n     * VAX C can't concatenate strings in the preprocessor.\n     */\n    strcpy(longVersion, VIM_VERSION_LONG_DATE);\n#ifdef BUILD_DATE\n    strcat(longVersion, BUILD_DATE);\n#else\n    strcat(longVersion, __DATE__);\n    strcat(longVersion, \" \");\n    strcat(longVersion, __TIME__);\n#endif\n    strcat(longVersion, \")\");\n}\n\n# else\nchar\t*longVersion = NULL;\n\n    void\ninit_longVersion(void)\n{\n    if (longVersion == NULL)\n    {\n#ifdef BUILD_DATE\n\tchar *date_time = BUILD_DATE;\n#else\n\tchar *date_time = __DATE__ \" \" __TIME__;\n#endif\n\tchar *msg = _(\"%s (%s, compiled %s)\");\n\tsize_t len = strlen(msg)\n\t\t    + strlen(VIM_VERSION_LONG_ONLY)\n\t\t    + strlen(VIM_VERSION_DATE_ONLY)\n\t\t    + strlen(date_time);\n\n\tlongVersion = alloc(len);\n\tif (longVersion == NULL)\n\t    longVersion = VIM_VERSION_LONG;\n\telse\n\t    vim_snprintf(longVersion, len, msg,\n\t\t      VIM_VERSION_LONG_ONLY, VIM_VERSION_DATE_ONLY, date_time);\n    }\n}\n# endif\n#else\nchar\t*longVersion = VIM_VERSION_LONG;\n\n    void\ninit_longVersion(void)\n{\n    // nothing to do\n}\n#endif\n\nstatic char *(features[]) =\n{\n#ifdef HAVE_ACL\n\t\"+acl\",\n#else\n\t\"-acl\",\n#endif\n#ifdef AMIGA\t\t// only for Amiga systems\n# ifdef FEAT_ARP\n\t\"+ARP\",\n# else\n\t\"-ARP\",\n# endif\n#endif\n#ifdef FEAT_ARABIC\n\t\"+arabic\",\n#else\n\t\"-arabic\",\n#endif\n\t\"+autocmd\",\n#ifdef FEAT_AUTOCHDIR\n       \"+autochdir\",\n#else\n       \"-autochdir\",\n#endif\n#ifdef FEAT_AUTOSERVERNAME\n\t\"+autoservername\",\n#else\n\t\"-autoservername\",\n#endif\n#ifdef FEAT_BEVAL_GUI\n\t\"+balloon_eval\",\n#else\n\t\"-balloon_eval\",\n#endif\n#ifdef FEAT_BEVAL_TERM\n\t\"+balloon_eval_term\",\n#else\n\t\"-balloon_eval_term\",\n#endif\n#ifdef FEAT_BROWSE\n\t\"+browse\",\n#else\n\t\"-browse\",\n#endif\n#ifdef NO_BUILTIN_TCAPS\n\t\"-builtin_terms\",\n#endif\n#ifdef SOME_BUILTIN_TCAPS\n\t\"+builtin_terms\",\n#endif\n#ifdef ALL_BUILTIN_TCAPS\n\t\"++builtin_terms\",\n#endif\n#ifdef FEAT_BYTEOFF\n\t\"+byte_offset\",\n#else\n\t\"-byte_offset\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+channel\",\n#else\n\t\"-channel\",\n#endif\n#ifdef FEAT_CINDENT\n\t\"+cindent\",\n#else\n\t\"-cindent\",\n#endif\n#ifdef FEAT_CLIENTSERVER\n\t\"+clientserver\",\n#else\n\t\"-clientserver\",\n#endif\n#ifdef FEAT_CLIPBOARD\n\t\"+clipboard\",\n#else\n\t\"-clipboard\",\n#endif\n\t\"+cmdline_compl\",\n\t\"+cmdline_hist\",\n#ifdef FEAT_CMDL_INFO\n\t\"+cmdline_info\",\n#else\n\t\"-cmdline_info\",\n#endif\n\t\"+comments\",\n#ifdef FEAT_CONCEAL\n\t\"+conceal\",\n#else\n\t\"-conceal\",\n#endif\n#ifdef FEAT_CRYPT\n\t\"+cryptv\",\n#else\n\t\"-cryptv\",\n#endif\n#ifdef FEAT_CSCOPE\n\t\"+cscope\",\n#else\n\t\"-cscope\",\n#endif\n\t\"+cursorbind\",\n#ifdef CURSOR_SHAPE\n\t\"+cursorshape\",\n#else\n\t\"-cursorshape\",\n#endif\n#if defined(FEAT_CON_DIALOG) && defined(FEAT_GUI_DIALOG)\n\t\"+dialog_con_gui\",\n#else\n# if defined(FEAT_CON_DIALOG)\n\t\"+dialog_con\",\n# else\n#  if defined(FEAT_GUI_DIALOG)\n\t\"+dialog_gui\",\n#  else\n\t\"-dialog\",\n#  endif\n# endif\n#endif\n#ifdef FEAT_DIFF\n\t\"+diff\",\n#else\n\t\"-diff\",\n#endif\n#ifdef FEAT_DIGRAPHS\n\t\"+digraphs\",\n#else\n\t\"-digraphs\",\n#endif\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_DIRECTX\n\t\"+directx\",\n# else\n\t\"-directx\",\n# endif\n#endif\n#ifdef FEAT_DND\n\t\"+dnd\",\n#else\n\t\"-dnd\",\n#endif\n#ifdef EBCDIC\n\t\"+ebcdic\",\n#else\n\t\"-ebcdic\",\n#endif\n#ifdef FEAT_EMACS_TAGS\n\t\"+emacs_tags\",\n#else\n\t\"-emacs_tags\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+eval\",\n#else\n\t\"-eval\",\n#endif\n\t\"+ex_extra\",\n#ifdef FEAT_SEARCH_EXTRA\n\t\"+extra_search\",\n#else\n\t\"-extra_search\",\n#endif\n\t\"-farsi\",\n#ifdef FEAT_SEARCHPATH\n\t\"+file_in_path\",\n#else\n\t\"-file_in_path\",\n#endif\n#ifdef FEAT_FIND_ID\n\t\"+find_in_path\",\n#else\n\t\"-find_in_path\",\n#endif\n#ifdef FEAT_FLOAT\n\t\"+float\",\n#else\n\t\"-float\",\n#endif\n#ifdef FEAT_FOLDING\n\t\"+folding\",\n#else\n\t\"-folding\",\n#endif\n#ifdef FEAT_FOOTER\n\t\"+footer\",\n#else\n\t\"-footer\",\n#endif\n\t    // only interesting on Unix systems\n#if !defined(USE_SYSTEM) && defined(UNIX)\n\t\"+fork()\",\n#endif\n#ifdef FEAT_GETTEXT\n# ifdef DYNAMIC_GETTEXT\n\t\"+gettext/dyn\",\n# else\n\t\"+gettext\",\n# endif\n#else\n\t\"-gettext\",\n#endif\n\t\"-hangul_input\",\n#if (defined(HAVE_ICONV_H) && defined(USE_ICONV)) || defined(DYNAMIC_ICONV)\n# ifdef DYNAMIC_ICONV\n\t\"+iconv/dyn\",\n# else\n\t\"+iconv\",\n# endif\n#else\n\t\"-iconv\",\n#endif\n\t\"+insert_expand\",\n#ifdef FEAT_IPV6\n\t\"+ipv6\",\n#else\n\t\"-ipv6\",\n#endif\n#ifdef FEAT_JOB_CHANNEL\n\t\"+job\",\n#else\n\t\"-job\",\n#endif\n#ifdef FEAT_JUMPLIST\n\t\"+jumplist\",\n#else\n\t\"-jumplist\",\n#endif\n#ifdef FEAT_KEYMAP\n\t\"+keymap\",\n#else\n\t\"-keymap\",\n#endif\n#ifdef FEAT_EVAL\n\t\"+lambda\",\n#else\n\t\"-lambda\",\n#endif\n#ifdef FEAT_LANGMAP\n\t\"+langmap\",\n#else\n\t\"-langmap\",\n#endif\n#ifdef FEAT_LIBCALL\n\t\"+libcall\",\n#else\n\t\"-libcall\",\n#endif\n#ifdef FEAT_LINEBREAK\n\t\"+linebreak\",\n#else\n\t\"-linebreak\",\n#endif\n#ifdef FEAT_LISP\n\t\"+lispindent\",\n#else\n\t\"-lispindent\",\n#endif\n\t\"+listcmds\",\n\t\"+localmap\",\n#ifdef FEAT_LUA\n# ifdef DYNAMIC_LUA\n\t\"+lua/dyn\",\n# else\n\t\"+lua\",\n# endif\n#else\n\t\"-lua\",\n#endif\n#ifdef FEAT_MENU\n\t\"+menu\",\n#else\n\t\"-menu\",\n#endif\n#ifdef FEAT_SESSION\n\t\"+mksession\",\n#else\n\t\"-mksession\",\n#endif\n\t\"+modify_fname\",\n\t\"+mouse\",\n#ifdef FEAT_MOUSESHAPE\n\t\"+mouseshape\",\n#else\n\t\"-mouseshape\",\n#endif\n\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_MOUSE_DEC\n\t\"+mouse_dec\",\n# else\n\t\"-mouse_dec\",\n# endif\n# ifdef FEAT_MOUSE_GPM\n\t\"+mouse_gpm\",\n# else\n\t\"-mouse_gpm\",\n# endif\n# ifdef FEAT_MOUSE_JSB\n\t\"+mouse_jsbterm\",\n# else\n\t\"-mouse_jsbterm\",\n# endif\n# ifdef FEAT_MOUSE_NET\n\t\"+mouse_netterm\",\n# else\n\t\"-mouse_netterm\",\n# endif\n#endif\n\n#ifdef __QNX__\n# ifdef FEAT_MOUSE_PTERM\n\t\"+mouse_pterm\",\n# else\n\t\"-mouse_pterm\",\n# endif\n#endif\n\n#if defined(UNIX) || defined(VMS)\n\t\"+mouse_sgr\",\n# ifdef FEAT_SYSMOUSE\n\t\"+mouse_sysmouse\",\n# else\n\t\"-mouse_sysmouse\",\n# endif\n# ifdef FEAT_MOUSE_URXVT\n\t\"+mouse_urxvt\",\n# else\n\t\"-mouse_urxvt\",\n# endif\n\t\"+mouse_xterm\",\n#endif\n\n#ifdef FEAT_MBYTE_IME\n# ifdef DYNAMIC_IME\n\t\"+multi_byte_ime/dyn\",\n# else\n\t\"+multi_byte_ime\",\n# endif\n#else\n\t\"+multi_byte\",\n#endif\n#ifdef FEAT_MULTI_LANG\n\t\"+multi_lang\",\n#else\n\t\"-multi_lang\",\n#endif\n#ifdef FEAT_MZSCHEME\n# ifdef DYNAMIC_MZSCHEME\n\t\"+mzscheme/dyn\",\n# else\n\t\"+mzscheme\",\n# endif\n#else\n\t\"-mzscheme\",\n#endif\n#ifdef FEAT_NETBEANS_INTG\n\t\"+netbeans_intg\",\n#else\n\t\"-netbeans_intg\",\n#endif\n\t\"+num64\",\n#ifdef FEAT_GUI_MSWIN\n# ifdef FEAT_OLE\n\t\"+ole\",\n# else\n\t\"-ole\",\n# endif\n#endif\n#ifdef FEAT_EVAL\n\t\"+packages\",\n#else\n\t\"-packages\",\n#endif\n#ifdef FEAT_PATH_EXTRA\n\t\"+path_extra\",\n#else\n\t\"-path_extra\",\n#endif\n#ifdef FEAT_PERL\n# ifdef DYNAMIC_PERL\n\t\"+perl/dyn\",\n# else\n\t\"+perl\",\n# endif\n#else\n\t\"-perl\",\n#endif\n#ifdef FEAT_PERSISTENT_UNDO\n\t\"+persistent_undo\",\n#else\n\t\"-persistent_undo\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+popupwin\",\n#else\n\t\"-popupwin\",\n#endif\n#ifdef FEAT_PRINTER\n# ifdef FEAT_POSTSCRIPT\n\t\"+postscript\",\n# else\n\t\"-postscript\",\n# endif\n\t\"+printer\",\n#else\n\t\"-printer\",\n#endif\n#ifdef FEAT_PROFILE\n\t\"+profile\",\n#else\n\t\"-profile\",\n#endif\n#ifdef FEAT_PYTHON\n# ifdef DYNAMIC_PYTHON\n\t\"+python/dyn\",\n# else\n\t\"+python\",\n# endif\n#else\n\t\"-python\",\n#endif\n#ifdef FEAT_PYTHON3\n# ifdef DYNAMIC_PYTHON3\n\t\"+python3/dyn\",\n# else\n\t\"+python3\",\n# endif\n#else\n\t\"-python3\",\n#endif\n#ifdef FEAT_QUICKFIX\n\t\"+quickfix\",\n#else\n\t\"-quickfix\",\n#endif\n#ifdef FEAT_RELTIME\n\t\"+reltime\",\n#else\n\t\"-reltime\",\n#endif\n#ifdef FEAT_RIGHTLEFT\n\t\"+rightleft\",\n#else\n\t\"-rightleft\",\n#endif\n#ifdef FEAT_RUBY\n# ifdef DYNAMIC_RUBY\n\t\"+ruby/dyn\",\n# else\n\t\"+ruby\",\n# endif\n#else\n\t\"-ruby\",\n#endif\n\t\"+scrollbind\",\n#ifdef FEAT_SIGNS\n\t\"+signs\",\n#else\n\t\"-signs\",\n#endif\n#ifdef FEAT_SMARTINDENT\n\t\"+smartindent\",\n#else\n\t\"-smartindent\",\n#endif\n#ifdef FEAT_SODIUM\n\t\"+sodium\",\n#else\n\t\"-sodium\",\n#endif\n#ifdef FEAT_SOUND\n\t\"+sound\",\n#else\n\t\"-sound\",\n#endif\n#ifdef FEAT_SPELL\n\t\"+spell\",\n#else\n\t\"-spell\",\n#endif\n#ifdef STARTUPTIME\n\t\"+startuptime\",\n#else\n\t\"-startuptime\",\n#endif\n#ifdef FEAT_STL_OPT\n\t\"+statusline\",\n#else\n\t\"-statusline\",\n#endif\n\t\"-sun_workshop\",\n#ifdef FEAT_SYN_HL\n\t\"+syntax\",\n#else\n\t\"-syntax\",\n#endif\n\t    // only interesting on Unix systems\n#if defined(USE_SYSTEM) && defined(UNIX)\n\t\"+system()\",\n#endif\n#ifdef FEAT_TAG_BINS\n\t\"+tag_binary\",\n#else\n\t\"-tag_binary\",\n#endif\n\t\"-tag_old_static\",\n\t\"-tag_any_white\",\n#ifdef FEAT_TCL\n# ifdef DYNAMIC_TCL\n\t\"+tcl/dyn\",\n# else\n\t\"+tcl\",\n# endif\n#else\n\t\"-tcl\",\n#endif\n#ifdef FEAT_TERMGUICOLORS\n\t\"+termguicolors\",\n#else\n\t\"-termguicolors\",\n#endif\n#ifdef FEAT_TERMINAL\n\t\"+terminal\",\n#else\n\t\"-terminal\",\n#endif\n#if defined(UNIX)\n// only Unix can have terminfo instead of termcap\n# ifdef TERMINFO\n\t\"+terminfo\",\n# else\n\t\"-terminfo\",\n# endif\n#endif\n#ifdef FEAT_TERMRESPONSE\n\t\"+termresponse\",\n#else\n\t\"-termresponse\",\n#endif\n#ifdef FEAT_TEXTOBJ\n\t\"+textobjects\",\n#else\n\t\"-textobjects\",\n#endif\n#ifdef FEAT_PROP_POPUP\n\t\"+textprop\",\n#else\n\t\"-textprop\",\n#endif\n#if !defined(UNIX)\n// unix always includes termcap support\n# ifdef HAVE_TGETENT\n\t\"+tgetent\",\n# else\n\t\"-tgetent\",\n# endif\n#endif\n#ifdef FEAT_TIMERS\n\t\"+timers\",\n#else\n\t\"-timers\",\n#endif\n#ifdef FEAT_TITLE\n\t\"+title\",\n#else\n\t\"-title\",\n#endif\n#ifdef FEAT_TOOLBAR\n\t\"+toolbar\",\n#else\n\t\"-toolbar\",\n#endif\n\t\"+user_commands\",\n#ifdef FEAT_VARTABS\n\t\"+vartabs\",\n#else\n\t\"-vartabs\",\n#endif\n\t\"+vertsplit\",\n\t\"+virtualedit\",\n\t\"+visual\",\n\t\"+visualextra\",\n#ifdef FEAT_VIMINFO\n\t\"+viminfo\",\n#else\n\t\"-viminfo\",\n#endif\n\t\"+vreplace\",\n#ifdef MSWIN\n# ifdef FEAT_VTP\n\t\"+vtp\",\n# else\n\t\"-vtp\",\n# endif\n#endif\n#ifdef FEAT_WILDIGN\n\t\"+wildignore\",\n#else\n\t\"-wildignore\",\n#endif\n#ifdef FEAT_WILDMENU\n\t\"+wildmenu\",\n#else\n\t\"-wildmenu\",\n#endif\n\t\"+windows\",\n#ifdef FEAT_WRITEBACKUP\n\t\"+writebackup\",\n#else\n\t\"-writebackup\",\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef FEAT_X11\n\t\"+X11\",\n# else\n\t\"-X11\",\n# endif\n#endif\n#ifdef FEAT_XFONTSET\n\t\"+xfontset\",\n#else\n\t\"-xfontset\",\n#endif\n#ifdef FEAT_XIM\n\t\"+xim\",\n#else\n\t\"-xim\",\n#endif\n#ifdef MSWIN\n# ifdef FEAT_XPM_W32\n\t\"+xpm_w32\",\n# else\n\t\"-xpm_w32\",\n# endif\n#else\n# ifdef HAVE_XPM\n\t\"+xpm\",\n# else\n\t\"-xpm\",\n# endif\n#endif\n#if defined(UNIX) || defined(VMS)\n# ifdef USE_XSMP_INTERACT\n\t\"+xsmp_interact\",\n# else\n#  ifdef USE_XSMP\n\t\"+xsmp\",\n#  else\n\t\"-xsmp\",\n#  endif\n# endif\n# ifdef FEAT_XCLIPBOARD\n\t\"+xterm_clipboard\",\n# else\n\t\"-xterm_clipboard\",\n# endif\n#endif\n#ifdef FEAT_XTERM_SAVE\n\t\"+xterm_save\",\n#else\n\t\"-xterm_save\",\n#endif\n\tNULL\n};\n\nstatic int included_patches[] =\n{   /* Add new patch number below this line */\n/**/\n    3611,\n/**/\n    3610,\n/**/\n    3609,\n/**/\n    3608,\n/**/\n    3607,\n/**/\n    3606,\n/**/\n    3605,\n/**/\n    3604,\n/**/\n    3603,\n/**/\n    3602,\n/**/\n    3601,\n/**/\n    3600,\n/**/\n    3599,\n/**/\n    3598,\n/**/\n    3597,\n/**/\n    3596,\n/**/\n    3595,\n/**/\n    3594,\n/**/\n    3593,\n/**/\n    3592,\n/**/\n    3591,\n/**/\n    3590,\n/**/\n    3589,\n/**/\n    3588,\n/**/\n    3587,\n/**/\n    3586,\n/**/\n    3585,\n/**/\n    3584,\n/**/\n    3583,\n/**/\n    3582,\n/**/\n    3581,\n/**/\n    3580,\n/**/\n    3579,\n/**/\n    3578,\n/**/\n    3577,\n/**/\n    3576,\n/**/\n    3575,\n/**/\n    3574,\n/**/\n    3573,\n/**/\n    3572,\n/**/\n    3571,\n/**/\n    3570,\n/**/\n    3569,\n/**/\n    3568,\n/**/\n    3567,\n/**/\n    3566,\n/**/\n    3565,\n/**/\n    3564,\n/**/\n    3563,\n/**/\n    3562,\n/**/\n    3561,\n/**/\n    3560,\n/**/\n    3559,\n/**/\n    3558,\n/**/\n    3557,\n/**/\n    3556,\n/**/\n    3555,\n/**/\n    3554,\n/**/\n    3553,\n/**/\n    3552,\n/**/\n    3551,\n/**/\n    3550,\n/**/\n    3549,\n/**/\n    3548,\n/**/\n    3547,\n/**/\n    3546,\n/**/\n    3545,\n/**/\n    3544,\n/**/\n    3543,\n/**/\n    3542,\n/**/\n    3541,\n/**/\n    3540,\n/**/\n    3539,\n/**/\n    3538,\n/**/\n    3537,\n/**/\n    3536,\n/**/\n    3535,\n/**/\n    3534,\n/**/\n    3533,\n/**/\n    3532,\n/**/\n    3531,\n/**/\n    3530,\n/**/\n    3529,\n/**/\n    3528,\n/**/\n    3527,\n/**/\n    3526,\n/**/\n    3525,\n/**/\n    3524,\n/**/\n    3523,\n/**/\n    3522,\n/**/\n    3521,\n/**/\n    3520,\n/**/\n    3519,\n/**/\n    3518,\n/**/\n    3517,\n/**/\n    3516,\n/**/\n    3515,\n/**/\n    3514,\n/**/\n    3513,\n/**/\n    3512,\n/**/\n    3511,\n/**/\n    3510,\n/**/\n    3509,\n/**/\n    3508,\n/**/\n    3507,\n/**/\n    3506,\n/**/\n    3505,\n/**/\n    3504,\n/**/\n    3503,\n/**/\n    3502,\n/**/\n    3501,\n/**/\n    3500,\n/**/\n    3499,\n/**/\n    3498,\n/**/\n    3497,\n/**/\n    3496,\n/**/\n    3495,\n/**/\n    3494,\n/**/\n    3493,\n/**/\n    3492,\n/**/\n    3491,\n/**/\n    3490,\n/**/\n    3489,\n/**/\n    3488,\n/**/\n    3487,\n/**/\n    3486,\n/**/\n    3485,\n/**/\n    3484,\n/**/\n    3483,\n/**/\n    3482,\n/**/\n    3481,\n/**/\n    3480,\n/**/\n    3479,\n/**/\n    3478,\n/**/\n    3477,\n/**/\n    3476,\n/**/\n    3475,\n/**/\n    3474,\n/**/\n    3473,\n/**/\n    3472,\n/**/\n    3471,\n/**/\n    3470,\n/**/\n    3469,\n/**/\n    3468,\n/**/\n    3467,\n/**/\n    3466,\n/**/\n    3465,\n/**/\n    3464,\n/**/\n    3463,\n/**/\n    3462,\n/**/\n    3461,\n/**/\n    3460,\n/**/\n    3459,\n/**/\n    3458,\n/**/\n    3457,\n/**/\n    3456,\n/**/\n    3455,\n/**/\n    3454,\n/**/\n    3453,\n/**/\n    3452,\n/**/\n    3451,\n/**/\n    3450,\n/**/\n    3449,\n/**/\n    3448,\n/**/\n    3447,\n/**/\n    3446,\n/**/\n    3445,\n/**/\n    3444,\n/**/\n    3443,\n/**/\n    3442,\n/**/\n    3441,\n/**/\n    3440,\n/**/\n    3439,\n/**/\n    3438,\n/**/\n    3437,\n/**/\n    3436,\n/**/\n    3435,\n/**/\n    3434,\n/**/\n    3433,\n/**/\n    3432,\n/**/\n    3431,\n/**/\n    3430,\n/**/\n    3429,\n/**/\n    3428,\n/**/\n    3427,\n/**/\n    3426,\n/**/\n    3425,\n/**/\n    3424,\n/**/\n    3423,\n/**/\n    3422,\n/**/\n    3421,\n/**/\n    3420,\n/**/\n    3419,\n/**/\n    3418,\n/**/\n    3417,\n/**/\n    3416,\n/**/\n    3415,\n/**/\n    3414,\n/**/\n    3413,\n/**/\n    3412,\n/**/\n    3411,\n/**/\n    3410,\n/**/\n    3409,\n/**/\n    3408,\n/**/\n    3407,\n/**/\n    3406,\n/**/\n    3405,\n/**/\n    3404,\n/**/\n    3403,\n/**/\n    3402,\n/**/\n    3401,\n/**/\n    3400,\n/**/\n    3399,\n/**/\n    3398,\n/**/\n    3397,\n/**/\n    3396,\n/**/\n    3395,\n/**/\n    3394,\n/**/\n    3393,\n/**/\n    3392,\n/**/\n    3391,\n/**/\n    3390,\n/**/\n    3389,\n/**/\n    3388,\n/**/\n    3387,\n/**/\n    3386,\n/**/\n    3385,\n/**/\n    3384,\n/**/\n    3383,\n/**/\n    3382,\n/**/\n    3381,\n/**/\n    3380,\n/**/\n    3379,\n/**/\n    3378,\n/**/\n    3377,\n/**/\n    3376,\n/**/\n    3375,\n/**/\n    3374,\n/**/\n    3373,\n/**/\n    3372,\n/**/\n    3371,\n/**/\n    3370,\n/**/\n    3369,\n/**/\n    3368,\n/**/\n    3367,\n/**/\n    3366,\n/**/\n    3365,\n/**/\n    3364,\n/**/\n    3363,\n/**/\n    3362,\n/**/\n    3361,\n/**/\n    3360,\n/**/\n    3359,\n/**/\n    3358,\n/**/\n    3357,\n/**/\n    3356,\n/**/\n    3355,\n/**/\n    3354,\n/**/\n    3353,\n/**/\n    3352,\n/**/\n    3351,\n/**/\n    3350,\n/**/\n    3349,\n/**/\n    3348,\n/**/\n    3347,\n/**/\n    3346,\n/**/\n    3345,\n/**/\n    3344,\n/**/\n    3343,\n/**/\n    3342,\n/**/\n    3341,\n/**/\n    3340,\n/**/\n    3339,\n/**/\n    3338,\n/**/\n    3337,\n/**/\n    3336,\n/**/\n    3335,\n/**/\n    3334,\n/**/\n    3333,\n/**/\n    3332,\n/**/\n    3331,\n/**/\n    3330,\n/**/\n    3329,\n/**/\n    3328,\n/**/\n    3327,\n/**/\n    3326,\n/**/\n    3325,\n/**/\n    3324,\n/**/\n    3323,\n/**/\n    3322,\n/**/\n    3321,\n/**/\n    3320,\n/**/\n    3319,\n/**/\n    3318,\n/**/\n    3317,\n/**/\n    3316,\n/**/\n    3315,\n/**/\n    3314,\n/**/\n    3313,\n/**/\n    3312,\n/**/\n    3311,\n/**/\n    3310,\n/**/\n    3309,\n/**/\n    3308,\n/**/\n    3307,\n/**/\n    3306,\n/**/\n    3305,\n/**/\n    3304,\n/**/\n    3303,\n/**/\n    3302,\n/**/\n    3301,\n/**/\n    3300,\n/**/\n    3299,\n/**/\n    3298,\n/**/\n    3297,\n/**/\n    3296,\n/**/\n    3295,\n/**/\n    3294,\n/**/\n    3293,\n/**/\n    3292,\n/**/\n    3291,\n/**/\n    3290,\n/**/\n    3289,\n/**/\n    3288,\n/**/\n    3287,\n/**/\n    3286,\n/**/\n    3285,\n/**/\n    3284,\n/**/\n    3283,\n/**/\n    3282,\n/**/\n    3281,\n/**/\n    3280,\n/**/\n    3279,\n/**/\n    3278,\n/**/\n    3277,\n/**/\n    3276,\n/**/\n    3275,\n/**/\n    3274,\n/**/\n    3273,\n/**/\n    3272,\n/**/\n    3271,\n/**/\n    3270,\n/**/\n    3269,\n/**/\n    3268,\n/**/\n    3267,\n/**/\n    3266,\n/**/\n    3265,\n/**/\n    3264,\n/**/\n    3263,\n/**/\n    3262,\n/**/\n    3261,\n/**/\n    3260,\n/**/\n    3259,\n/**/\n    3258,\n/**/\n    3257,\n/**/\n    3256,\n/**/\n    3255,\n/**/\n    3254,\n/**/\n    3253,\n/**/\n    3252,\n/**/\n    3251,\n/**/\n    3250,\n/**/\n    3249,\n/**/\n    3248,\n/**/\n    3247,\n/**/\n    3246,\n/**/\n    3245,\n/**/\n    3244,\n/**/\n    3243,\n/**/\n    3242,\n/**/\n    3241,\n/**/\n    3240,\n/**/\n    3239,\n/**/\n    3238,\n/**/\n    3237,\n/**/\n    3236,\n/**/\n    3235,\n/**/\n    3234,\n/**/\n    3233,\n/**/\n    3232,\n/**/\n    3231,\n/**/\n    3230,\n/**/\n    3229,\n/**/\n    3228,\n/**/\n    3227,\n/**/\n    3226,\n/**/\n    3225,\n/**/\n    3224,\n/**/\n    3223,\n/**/\n    3222,\n/**/\n    3221,\n/**/\n    3220,\n/**/\n    3219,\n/**/\n    3218,\n/**/\n    3217,\n/**/\n    3216,\n/**/\n    3215,\n/**/\n    3214,\n/**/\n    3213,\n/**/\n    3212,\n/**/\n    3211,\n/**/\n    3210,\n/**/\n    3209,\n/**/\n    3208,\n/**/\n    3207,\n/**/\n    3206,\n/**/\n    3205,\n/**/\n    3204,\n/**/\n    3203,\n/**/\n    3202,\n/**/\n    3201,\n/**/\n    3200,\n/**/\n    3199,\n/**/\n    3198,\n/**/\n    3197,\n/**/\n    3196,\n/**/\n    3195,\n/**/\n    3194,\n/**/\n    3193,\n/**/\n    3192,\n/**/\n    3191,\n/**/\n    3190,\n/**/\n    3189,\n/**/\n    3188,\n/**/\n    3187,\n/**/\n    3186,\n/**/\n    3185,\n/**/\n    3184,\n/**/\n    3183,\n/**/\n    3182,\n/**/\n    3181,\n/**/\n    3180,\n/**/\n    3179,\n/**/\n    3178,\n/**/\n    3177,\n/**/\n    3176,\n/**/\n    3175,\n/**/\n    3174,\n/**/\n    3173,\n/**/\n    3172,\n/**/\n    3171,\n/**/\n    3170,\n/**/\n    3169,\n/**/\n    3168,\n/**/\n    3167,\n/**/\n    3166,\n/**/\n    3165,\n/**/\n    3164,\n/**/\n    3163,\n/**/\n    3162,\n/**/\n    3161,\n/**/\n    3160,\n/**/\n    3159,\n/**/\n    3158,\n/**/\n    3157,\n/**/\n    3156,\n/**/\n    3155,\n/**/\n    3154,\n/**/\n    3153,\n/**/\n    3152,\n/**/\n    3151,\n/**/\n    3150,\n/**/\n    3149,\n/**/\n    3148,\n/**/\n    3147,\n/**/\n    3146,\n/**/\n    3145,\n/**/\n    3144,\n/**/\n    3143,\n/**/\n    3142,\n/**/\n    3141,\n/**/\n    3140,\n/**/\n    3139,\n/**/\n    3138,\n/**/\n    3137,\n/**/\n    3136,\n/**/\n    3135,\n/**/\n    3134,\n/**/\n    3133,\n/**/\n    3132,\n/**/\n    3131,\n/**/\n    3130,\n/**/\n    3129,\n/**/\n    3128,\n/**/\n    3127,\n/**/\n    3126,\n/**/\n    3125,\n/**/\n    3124,\n/**/\n    3123,\n/**/\n    3122,\n/**/\n    3121,\n/**/\n    3120,\n/**/\n    3119,\n/**/\n    3118,\n/**/\n    3117,\n/**/\n    3116,\n/**/\n    3115,\n/**/\n    3114,\n/**/\n    3113,\n/**/\n    3112,\n/**/\n    3111,\n/**/\n    3110,\n/**/\n    3109,\n/**/\n    3108,\n/**/\n    3107,\n/**/\n    3106,\n/**/\n    3105,\n/**/\n    3104,\n/**/\n    3103,\n/**/\n    3102,\n/**/\n    3101,\n/**/\n    3100,\n/**/\n    3099,\n/**/\n    3098,\n/**/\n    3097,\n/**/\n    3096,\n/**/\n    3095,\n/**/\n    3094,\n/**/\n    3093,\n/**/\n    3092,\n/**/\n    3091,\n/**/\n    3090,\n/**/\n    3089,\n/**/\n    3088,\n/**/\n    3087,\n/**/\n    3086,\n/**/\n    3085,\n/**/\n    3084,\n/**/\n    3083,\n/**/\n    3082,\n/**/\n    3081,\n/**/\n    3080,\n/**/\n    3079,\n/**/\n    3078,\n/**/\n    3077,\n/**/\n    3076,\n/**/\n    3075,\n/**/\n    3074,\n/**/\n    3073,\n/**/\n    3072,\n/**/\n    3071,\n/**/\n    3070,\n/**/\n    3069,\n/**/\n    3068,\n/**/\n    3067,\n/**/\n    3066,\n/**/\n    3065,\n/**/\n    3064,\n/**/\n    3063,\n/**/\n    3062,\n/**/\n    3061,\n/**/\n    3060,\n/**/\n    3059,\n/**/\n    3058,\n/**/\n    3057,\n/**/\n    3056,\n/**/\n    3055,\n/**/\n    3054,\n/**/\n    3053,\n/**/\n    3052,\n/**/\n    3051,\n/**/\n    3050,\n/**/\n    3049,\n/**/\n    3048,\n/**/\n    3047,\n/**/\n    3046,\n/**/\n    3045,\n/**/\n    3044,\n/**/\n    3043,\n/**/\n    3042,\n/**/\n    3041,\n/**/\n    3040,\n/**/\n    3039,\n/**/\n    3038,\n/**/\n    3037,\n/**/\n    3036,\n/**/\n    3035,\n/**/\n    3034,\n/**/\n    3033,\n/**/\n    3032,\n/**/\n    3031,\n/**/\n    3030,\n/**/\n    3029,\n/**/\n    3028,\n/**/\n    3027,\n/**/\n    3026,\n/**/\n    3025,\n/**/\n    3024,\n/**/\n    3023,\n/**/\n    3022,\n/**/\n    3021,\n/**/\n    3020,\n/**/\n    3019,\n/**/\n    3018,\n/**/\n    3017,\n/**/\n    3016,\n/**/\n    3015,\n/**/\n    3014,\n/**/\n    3013,\n/**/\n    3012,\n/**/\n    3011,\n/**/\n    3010,\n/**/\n    3009,\n/**/\n    3008,\n/**/\n    3007,\n/**/\n    3006,\n/**/\n    3005,\n/**/\n    3004,\n/**/\n    3003,\n/**/\n    3002,\n/**/\n    3001,\n/**/\n    3000,\n/**/\n    2999,\n/**/\n    2998,\n/**/\n    2997,\n/**/\n    2996,\n/**/\n    2995,\n/**/\n    2994,\n/**/\n    2993,\n/**/\n    2992,\n/**/\n    2991,\n/**/\n    2990,\n/**/\n    2989,\n/**/\n    2988,\n/**/\n    2987,\n/**/\n    2986,\n/**/\n    2985,\n/**/\n    2984,\n/**/\n    2983,\n/**/\n    2982,\n/**/\n    2981,\n/**/\n    2980,\n/**/\n    2979,\n/**/\n    2978,\n/**/\n    2977,\n/**/\n    2976,\n/**/\n    2975,\n/**/\n    2974,\n/**/\n    2973,\n/**/\n    2972,\n/**/\n    2971,\n/**/\n    2970,\n/**/\n    2969,\n/**/\n    2968,\n/**/\n    2967,\n/**/\n    2966,\n/**/\n    2965,\n/**/\n    2964,\n/**/\n    2963,\n/**/\n    2962,\n/**/\n    2961,\n/**/\n    2960,\n/**/\n    2959,\n/**/\n    2958,\n/**/\n    2957,\n/**/\n    2956,\n/**/\n    2955,\n/**/\n    2954,\n/**/\n    2953,\n/**/\n    2952,\n/**/\n    2951,\n/**/\n    2950,\n/**/\n    2949,\n/**/\n    2948,\n/**/\n    2947,\n/**/\n    2946,\n/**/\n    2945,\n/**/\n    2944,\n/**/\n    2943,\n/**/\n    2942,\n/**/\n    2941,\n/**/\n    2940,\n/**/\n    2939,\n/**/\n    2938,\n/**/\n    2937,\n/**/\n    2936,\n/**/\n    2935,\n/**/\n    2934,\n/**/\n    2933,\n/**/\n    2932,\n/**/\n    2931,\n/**/\n    2930,\n/**/\n    2929,\n/**/\n    2928,\n/**/\n    2927,\n/**/\n    2926,\n/**/\n    2925,\n/**/\n    2924,\n/**/\n    2923,\n/**/\n    2922,\n/**/\n    2921,\n/**/\n    2920,\n/**/\n    2919,\n/**/\n    2918,\n/**/\n    2917,\n/**/\n    2916,\n/**/\n    2915,\n/**/\n    2914,\n/**/\n    2913,\n/**/\n    2912,\n/**/\n    2911,\n/**/\n    2910,\n/**/\n    2909,\n/**/\n    2908,\n/**/\n    2907,\n/**/\n    2906,\n/**/\n    2905,\n/**/\n    2904,\n/**/\n    2903,\n/**/\n    2902,\n/**/\n    2901,\n/**/\n    2900,\n/**/\n    2899,\n/**/\n    2898,\n/**/\n    2897,\n/**/\n    2896,\n/**/\n    2895,\n/**/\n    2894,\n/**/\n    2893,\n/**/\n    2892,\n/**/\n    2891,\n/**/\n    2890,\n/**/\n    2889,\n/**/\n    2888,\n/**/\n    2887,\n/**/\n    2886,\n/**/\n    2885,\n/**/\n    2884,\n/**/\n    2883,\n/**/\n    2882,\n/**/\n    2881,\n/**/\n    2880,\n/**/\n    2879,\n/**/\n    2878,\n/**/\n    2877,\n/**/\n    2876,\n/**/\n    2875,\n/**/\n    2874,\n/**/\n    2873,\n/**/\n    2872,\n/**/\n    2871,\n/**/\n    2870,\n/**/\n    2869,\n/**/\n    2868,\n/**/\n    2867,\n/**/\n    2866,\n/**/\n    2865,\n/**/\n    2864,\n/**/\n    2863,\n/**/\n    2862,\n/**/\n    2861,\n/**/\n    2860,\n/**/\n    2859,\n/**/\n    2858,\n/**/\n    2857,\n/**/\n    2856,\n/**/\n    2855,\n/**/\n    2854,\n/**/\n    2853,\n/**/\n    2852,\n/**/\n    2851,\n/**/\n    2850,\n/**/\n    2849,\n/**/\n    2848,\n/**/\n    2847,\n/**/\n    2846,\n/**/\n    2845,\n/**/\n    2844,\n/**/\n    2843,\n/**/\n    2842,\n/**/\n    2841,\n/**/\n    2840,\n/**/\n    2839,\n/**/\n    2838,\n/**/\n    2837,\n/**/\n    2836,\n/**/\n    2835,\n/**/\n    2834,\n/**/\n    2833,\n/**/\n    2832,\n/**/\n    2831,\n/**/\n    2830,\n/**/\n    2829,\n/**/\n    2828,\n/**/\n    2827,\n/**/\n    2826,\n/**/\n    2825,\n/**/\n    2824,\n/**/\n    2823,\n/**/\n    2822,\n/**/\n    2821,\n/**/\n    2820,\n/**/\n    2819,\n/**/\n    2818,\n/**/\n    2817,\n/**/\n    2816,\n/**/\n    2815,\n/**/\n    2814,\n/**/\n    2813,\n/**/\n    2812,\n/**/\n    2811,\n/**/\n    2810,\n/**/\n    2809,\n/**/\n    2808,\n/**/\n    2807,\n/**/\n    2806,\n/**/\n    2805,\n/**/\n    2804,\n/**/\n    2803,\n/**/\n    2802,\n/**/\n    2801,\n/**/\n    2800,\n/**/\n    2799,\n/**/\n    2798,\n/**/\n    2797,\n/**/\n    2796,\n/**/\n    2795,\n/**/\n    2794,\n/**/\n    2793,\n/**/\n    2792,\n/**/\n    2791,\n/**/\n    2790,\n/**/\n    2789,\n/**/\n    2788,\n/**/\n    2787,\n/**/\n    2786,\n/**/\n    2785,\n/**/\n    2784,\n/**/\n    2783,\n/**/\n    2782,\n/**/\n    2781,\n/**/\n    2780,\n/**/\n    2779,\n/**/\n    2778,\n/**/\n    2777,\n/**/\n    2776,\n/**/\n    2775,\n/**/\n    2774,\n/**/\n    2773,\n/**/\n    2772,\n/**/\n    2771,\n/**/\n    2770,\n/**/\n    2769,\n/**/\n    2768,\n/**/\n    2767,\n/**/\n    2766,\n/**/\n    2765,\n/**/\n    2764,\n/**/\n    2763,\n/**/\n    2762,\n/**/\n    2761,\n/**/\n    2760,\n/**/\n    2759,\n/**/\n    2758,\n/**/\n    2757,\n/**/\n    2756,\n/**/\n    2755,\n/**/\n    2754,\n/**/\n    2753,\n/**/\n    2752,\n/**/\n    2751,\n/**/\n    2750,\n/**/\n    2749,\n/**/\n    2748,\n/**/\n    2747,\n/**/\n    2746,\n/**/\n    2745,\n/**/\n    2744,\n/**/\n    2743,\n/**/\n    2742,\n/**/\n    2741,\n/**/\n    2740,\n/**/\n    2739,\n/**/\n    2738,\n/**/\n    2737,\n/**/\n    2736,\n/**/\n    2735,\n/**/\n    2734,\n/**/\n    2733,\n/**/\n    2732,\n/**/\n    2731,\n/**/\n    2730,\n/**/\n    2729,\n/**/\n    2728,\n/**/\n    2727,\n/**/\n    2726,\n/**/\n    2725,\n/**/\n    2724,\n/**/\n    2723,\n/**/\n    2722,\n/**/\n    2721,\n/**/\n    2720,\n/**/\n    2719,\n/**/\n    2718,\n/**/\n    2717,\n/**/\n    2716,\n/**/\n    2715,\n/**/\n    2714,\n/**/\n    2713,\n/**/\n    2712,\n/**/\n    2711,\n/**/\n    2710,\n/**/\n    2709,\n/**/\n    2708,\n/**/\n    2707,\n/**/\n    2706,\n/**/\n    2705,\n/**/\n    2704,\n/**/\n    2703,\n/**/\n    2702,\n/**/\n    2701,\n/**/\n    2700,\n/**/\n    2699,\n/**/\n    2698,\n/**/\n    2697,\n/**/\n    2696,\n/**/\n    2695,\n/**/\n    2694,\n/**/\n    2693,\n/**/\n    2692,\n/**/\n    2691,\n/**/\n    2690,\n/**/\n    2689,\n/**/\n    2688,\n/**/\n    2687,\n/**/\n    2686,\n/**/\n    2685,\n/**/\n    2684,\n/**/\n    2683,\n/**/\n    2682,\n/**/\n    2681,\n/**/\n    2680,\n/**/\n    2679,\n/**/\n    2678,\n/**/\n    2677,\n/**/\n    2676,\n/**/\n    2675,\n/**/\n    2674,\n/**/\n    2673,\n/**/\n    2672,\n/**/\n    2671,\n/**/\n    2670,\n/**/\n    2669,\n/**/\n    2668,\n/**/\n    2667,\n/**/\n    2666,\n/**/\n    2665,\n/**/\n    2664,\n/**/\n    2663,\n/**/\n    2662,\n/**/\n    2661,\n/**/\n    2660,\n/**/\n    2659,\n/**/\n    2658,\n/**/\n    2657,\n/**/\n    2656,\n/**/\n    2655,\n/**/\n    2654,\n/**/\n    2653,\n/**/\n    2652,\n/**/\n    2651,\n/**/\n    2650,\n/**/\n    2649,\n/**/\n    2648,\n/**/\n    2647,\n/**/\n    2646,\n/**/\n    2645,\n/**/\n    2644,\n/**/\n    2643,\n/**/\n    2642,\n/**/\n    2641,\n/**/\n    2640,\n/**/\n    2639,\n/**/\n    2638,\n/**/\n    2637,\n/**/\n    2636,\n/**/\n    2635,\n/**/\n    2634,\n/**/\n    2633,\n/**/\n    2632,\n/**/\n    2631,\n/**/\n    2630,\n/**/\n    2629,\n/**/\n    2628,\n/**/\n    2627,\n/**/\n    2626,\n/**/\n    2625,\n/**/\n    2624,\n/**/\n    2623,\n/**/\n    2622,\n/**/\n    2621,\n/**/\n    2620,\n/**/\n    2619,\n/**/\n    2618,\n/**/\n    2617,\n/**/\n    2616,\n/**/\n    2615,\n/**/\n    2614,\n/**/\n    2613,\n/**/\n    2612,\n/**/\n    2611,\n/**/\n    2610,\n/**/\n    2609,\n/**/\n    2608,\n/**/\n    2607,\n/**/\n    2606,\n/**/\n    2605,\n/**/\n    2604,\n/**/\n    2603,\n/**/\n    2602,\n/**/\n    2601,\n/**/\n    2600,\n/**/\n    2599,\n/**/\n    2598,\n/**/\n    2597,\n/**/\n    2596,\n/**/\n    2595,\n/**/\n    2594,\n/**/\n    2593,\n/**/\n    2592,\n/**/\n    2591,\n/**/\n    2590,\n/**/\n    2589,\n/**/\n    2588,\n/**/\n    2587,\n/**/\n    2586,\n/**/\n    2585,\n/**/\n    2584,\n/**/\n    2583,\n/**/\n    2582,\n/**/\n    2581,\n/**/\n    2580,\n/**/\n    2579,\n/**/\n    2578,\n/**/\n    2577,\n/**/\n    2576,\n/**/\n    2575,\n/**/\n    2574,\n/**/\n    2573,\n/**/\n    2572,\n/**/\n    2571,\n/**/\n    2570,\n/**/\n    2569,\n/**/\n    2568,\n/**/\n    2567,\n/**/\n    2566,\n/**/\n    2565,\n/**/\n    2564,\n/**/\n    2563,\n/**/\n    2562,\n/**/\n    2561,\n/**/\n    2560,\n/**/\n    2559,\n/**/\n    2558,\n/**/\n    2557,\n/**/\n    2556,\n/**/\n    2555,\n/**/\n    2554,\n/**/\n    2553,\n/**/\n    2552,\n/**/\n    2551,\n/**/\n    2550,\n/**/\n    2549,\n/**/\n    2548,\n/**/\n    2547,\n/**/\n    2546,\n/**/\n    2545,\n/**/\n    2544,\n/**/\n    2543,\n/**/\n    2542,\n/**/\n    2541,\n/**/\n    2540,\n/**/\n    2539,\n/**/\n    2538,\n/**/\n    2537,\n/**/\n    2536,\n/**/\n    2535,\n/**/\n    2534,\n/**/\n    2533,\n/**/\n    2532,\n/**/\n    2531,\n/**/\n    2530,\n/**/\n    2529,\n/**/\n    2528,\n/**/\n    2527,\n/**/\n    2526,\n/**/\n    2525,\n/**/\n    2524,\n/**/\n    2523,\n/**/\n    2522,\n/**/\n    2521,\n/**/\n    2520,\n/**/\n    2519,\n/**/\n    2518,\n/**/\n    2517,\n/**/\n    2516,\n/**/\n    2515,\n/**/\n    2514,\n/**/\n    2513,\n/**/\n    2512,\n/**/\n    2511,\n/**/\n    2510,\n/**/\n    2509,\n/**/\n    2508,\n/**/\n    2507,\n/**/\n    2506,\n/**/\n    2505,\n/**/\n    2504,\n/**/\n    2503,\n/**/\n    2502,\n/**/\n    2501,\n/**/\n    2500,\n/**/\n    2499,\n/**/\n    2498,\n/**/\n    2497,\n/**/\n    2496,\n/**/\n    2495,\n/**/\n    2494,\n/**/\n    2493,\n/**/\n    2492,\n/**/\n    2491,\n/**/\n    2490,\n/**/\n    2489,\n/**/\n    2488,\n/**/\n    2487,\n/**/\n    2486,\n/**/\n    2485,\n/**/\n    2484,\n/**/\n    2483,\n/**/\n    2482,\n/**/\n    2481,\n/**/\n    2480,\n/**/\n    2479,\n/**/\n    2478,\n/**/\n    2477,\n/**/\n    2476,\n/**/\n    2475,\n/**/\n    2474,\n/**/\n    2473,\n/**/\n    2472,\n/**/\n    2471,\n/**/\n    2470,\n/**/\n    2469,\n/**/\n    2468,\n/**/\n    2467,\n/**/\n    2466,\n/**/\n    2465,\n/**/\n    2464,\n/**/\n    2463,\n/**/\n    2462,\n/**/\n    2461,\n/**/\n    2460,\n/**/\n    2459,\n/**/\n    2458,\n/**/\n    2457,\n/**/\n    2456,\n/**/\n    2455,\n/**/\n    2454,\n/**/\n    2453,\n/**/\n    2452,\n/**/\n    2451,\n/**/\n    2450,\n/**/\n    2449,\n/**/\n    2448,\n/**/\n    2447,\n/**/\n    2446,\n/**/\n    2445,\n/**/\n    2444,\n/**/\n    2443,\n/**/\n    2442,\n/**/\n    2441,\n/**/\n    2440,\n/**/\n    2439,\n/**/\n    2438,\n/**/\n    2437,\n/**/\n    2436,\n/**/\n    2435,\n/**/\n    2434,\n/**/\n    2433,\n/**/\n    2432,\n/**/\n    2431,\n/**/\n    2430,\n/**/\n    2429,\n/**/\n    2428,\n/**/\n    2427,\n/**/\n    2426,\n/**/\n    2425,\n/**/\n    2424,\n/**/\n    2423,\n/**/\n    2422,\n/**/\n    2421,\n/**/\n    2420,\n/**/\n    2419,\n/**/\n    2418,\n/**/\n    2417,\n/**/\n    2416,\n/**/\n    2415,\n/**/\n    2414,\n/**/\n    2413,\n/**/\n    2412,\n/**/\n    2411,\n/**/\n    2410,\n/**/\n    2409,\n/**/\n    2408,\n/**/\n    2407,\n/**/\n    2406,\n/**/\n    2405,\n/**/\n    2404,\n/**/\n    2403,\n/**/\n    2402,\n/**/\n    2401,\n/**/\n    2400,\n/**/\n    2399,\n/**/\n    2398,\n/**/\n    2397,\n/**/\n    2396,\n/**/\n    2395,\n/**/\n    2394,\n/**/\n    2393,\n/**/\n    2392,\n/**/\n    2391,\n/**/\n    2390,\n/**/\n    2389,\n/**/\n    2388,\n/**/\n    2387,\n/**/\n    2386,\n/**/\n    2385,\n/**/\n    2384,\n/**/\n    2383,\n/**/\n    2382,\n/**/\n    2381,\n/**/\n    2380,\n/**/\n    2379,\n/**/\n    2378,\n/**/\n    2377,\n/**/\n    2376,\n/**/\n    2375,\n/**/\n    2374,\n/**/\n    2373,\n/**/\n    2372,\n/**/\n    2371,\n/**/\n    2370,\n/**/\n    2369,\n/**/\n    2368,\n/**/\n    2367,\n/**/\n    2366,\n/**/\n    2365,\n/**/\n    2364,\n/**/\n    2363,\n/**/\n    2362,\n/**/\n    2361,\n/**/\n    2360,\n/**/\n    2359,\n/**/\n    2358,\n/**/\n    2357,\n/**/\n    2356,\n/**/\n    2355,\n/**/\n    2354,\n/**/\n    2353,\n/**/\n    2352,\n/**/\n    2351,\n/**/\n    2350,\n/**/\n    2349,\n/**/\n    2348,\n/**/\n    2347,\n/**/\n    2346,\n/**/\n    2345,\n/**/\n    2344,\n/**/\n    2343,\n/**/\n    2342,\n/**/\n    2341,\n/**/\n    2340,\n/**/\n    2339,\n/**/\n    2338,\n/**/\n    2337,\n/**/\n    2336,\n/**/\n    2335,\n/**/\n    2334,\n/**/\n    2333,\n/**/\n    2332,\n/**/\n    2331,\n/**/\n    2330,\n/**/\n    2329,\n/**/\n    2328,\n/**/\n    2327,\n/**/\n    2326,\n/**/\n    2325,\n/**/\n    2324,\n/**/\n    2323,\n/**/\n    2322,\n/**/\n    2321,\n/**/\n    2320,\n/**/\n    2319,\n/**/\n    2318,\n/**/\n    2317,\n/**/\n    2316,\n/**/\n    2315,\n/**/\n    2314,\n/**/\n    2313,\n/**/\n    2312,\n/**/\n    2311,\n/**/\n    2310,\n/**/\n    2309,\n/**/\n    2308,\n/**/\n    2307,\n/**/\n    2306,\n/**/\n    2305,\n/**/\n    2304,\n/**/\n    2303,\n/**/\n    2302,\n/**/\n    2301,\n/**/\n    2300,\n/**/\n    2299,\n/**/\n    2298,\n/**/\n    2297,\n/**/\n    2296,\n/**/\n    2295,\n/**/\n    2294,\n/**/\n    2293,\n/**/\n    2292,\n/**/\n    2291,\n/**/\n    2290,\n/**/\n    2289,\n/**/\n    2288,\n/**/\n    2287,\n/**/\n    2286,\n/**/\n    2285,\n/**/\n    2284,\n/**/\n    2283,\n/**/\n    2282,\n/**/\n    2281,\n/**/\n    2280,\n/**/\n    2279,\n/**/\n    2278,\n/**/\n    2277,\n/**/\n    2276,\n/**/\n    2275,\n/**/\n    2274,\n/**/\n    2273,\n/**/\n    2272,\n/**/\n    2271,\n/**/\n    2270,\n/**/\n    2269,\n/**/\n    2268,\n/**/\n    2267,\n/**/\n    2266,\n/**/\n    2265,\n/**/\n    2264,\n/**/\n    2263,\n/**/\n    2262,\n/**/\n    2261,\n/**/\n    2260,\n/**/\n    2259,\n/**/\n    2258,\n/**/\n    2257,\n/**/\n    2256,\n/**/\n    2255,\n/**/\n    2254,\n/**/\n    2253,\n/**/\n    2252,\n/**/\n    2251,\n/**/\n    2250,\n/**/\n    2249,\n/**/\n    2248,\n/**/\n    2247,\n/**/\n    2246,\n/**/\n    2245,\n/**/\n    2244,\n/**/\n    2243,\n/**/\n    2242,\n/**/\n    2241,\n/**/\n    2240,\n/**/\n    2239,\n/**/\n    2238,\n/**/\n    2237,\n/**/\n    2236,\n/**/\n    2235,\n/**/\n    2234,\n/**/\n    2233,\n/**/\n    2232,\n/**/\n    2231,\n/**/\n    2230,\n/**/\n    2229,\n/**/\n    2228,\n/**/\n    2227,\n/**/\n    2226,\n/**/\n    2225,\n/**/\n    2224,\n/**/\n    2223,\n/**/\n    2222,\n/**/\n    2221,\n/**/\n    2220,\n/**/\n    2219,\n/**/\n    2218,\n/**/\n    2217,\n/**/\n    2216,\n/**/\n    2215,\n/**/\n    2214,\n/**/\n    2213,\n/**/\n    2212,\n/**/\n    2211,\n/**/\n    2210,\n/**/\n    2209,\n/**/\n    2208,\n/**/\n    2207,\n/**/\n    2206,\n/**/\n    2205,\n/**/\n    2204,\n/**/\n    2203,\n/**/\n    2202,\n/**/\n    2201,\n/**/\n    2200,\n/**/\n    2199,\n/**/\n    2198,\n/**/\n    2197,\n/**/\n    2196,\n/**/\n    2195,\n/**/\n    2194,\n/**/\n    2193,\n/**/\n    2192,\n/**/\n    2191,\n/**/\n    2190,\n/**/\n    2189,\n/**/\n    2188,\n/**/\n    2187,\n/**/\n    2186,\n/**/\n    2185,\n/**/\n    2184,\n/**/\n    2183,\n/**/\n    2182,\n/**/\n    2181,\n/**/\n    2180,\n/**/\n    2179,\n/**/\n    2178,\n/**/\n    2177,\n/**/\n    2176,\n/**/\n    2175,\n/**/\n    2174,\n/**/\n    2173,\n/**/\n    2172,\n/**/\n    2171,\n/**/\n    2170,\n/**/\n    2169,\n/**/\n    2168,\n/**/\n    2167,\n/**/\n    2166,\n/**/\n    2165,\n/**/\n    2164,\n/**/\n    2163,\n/**/\n    2162,\n/**/\n    2161,\n/**/\n    2160,\n/**/\n    2159,\n/**/\n    2158,\n/**/\n    2157,\n/**/\n    2156,\n/**/\n    2155,\n/**/\n    2154,\n/**/\n    2153,\n/**/\n    2152,\n/**/\n    2151,\n/**/\n    2150,\n/**/\n    2149,\n/**/\n    2148,\n/**/\n    2147,\n/**/\n    2146,\n/**/\n    2145,\n/**/\n    2144,\n/**/\n    2143,\n/**/\n    2142,\n/**/\n    2141,\n/**/\n    2140,\n/**/\n    2139,\n/**/\n    2138,\n/**/\n    2137,\n/**/\n    2136,\n/**/\n    2135,\n/**/\n    2134,\n/**/\n    2133,\n/**/\n    2132,\n/**/\n    2131,\n/**/\n    2130,\n/**/\n    2129,\n/**/\n    2128,\n/**/\n    2127,\n/**/\n    2126,\n/**/\n    2125,\n/**/\n    2124,\n/**/\n    2123,\n/**/\n    2122,\n/**/\n    2121,\n/**/\n    2120,\n/**/\n    2119,\n/**/\n    2118,\n/**/\n    2117,\n/**/\n    2116,\n/**/\n    2115,\n/**/\n    2114,\n/**/\n    2113,\n/**/\n    2112,\n/**/\n    2111,\n/**/\n    2110,\n/**/\n    2109,\n/**/\n    2108,\n/**/\n    2107,\n/**/\n    2106,\n/**/\n    2105,\n/**/\n    2104,\n/**/\n    2103,\n/**/\n    2102,\n/**/\n    2101,\n/**/\n    2100,\n/**/\n    2099,\n/**/\n    2098,\n/**/\n    2097,\n/**/\n    2096,\n/**/\n    2095,\n/**/\n    2094,\n/**/\n    2093,\n/**/\n    2092,\n/**/\n    2091,\n/**/\n    2090,\n/**/\n    2089,\n/**/\n    2088,\n/**/\n    2087,\n/**/\n    2086,\n/**/\n    2085,\n/**/\n    2084,\n/**/\n    2083,\n/**/\n    2082,\n/**/\n    2081,\n/**/\n    2080,\n/**/\n    2079,\n/**/\n    2078,\n/**/\n    2077,\n/**/\n    2076,\n/**/\n    2075,\n/**/\n    2074,\n/**/\n    2073,\n/**/\n    2072,\n/**/\n    2071,\n/**/\n    2070,\n/**/\n    2069,\n/**/\n    2068,\n/**/\n    2067,\n/**/\n    2066,\n/**/\n    2065,\n/**/\n    2064,\n/**/\n    2063,\n/**/\n    2062,\n/**/\n    2061,\n/**/\n    2060,\n/**/\n    2059,\n/**/\n    2058,\n/**/\n    2057,\n/**/\n    2056,\n/**/\n    2055,\n/**/\n    2054,\n/**/\n    2053,\n/**/\n    2052,\n/**/\n    2051,\n/**/\n    2050,\n/**/\n    2049,\n/**/\n    2048,\n/**/\n    2047,\n/**/\n    2046,\n/**/\n    2045,\n/**/\n    2044,\n/**/\n    2043,\n/**/\n    2042,\n/**/\n    2041,\n/**/\n    2040,\n/**/\n    2039,\n/**/\n    2038,\n/**/\n    2037,\n/**/\n    2036,\n/**/\n    2035,\n/**/\n    2034,\n/**/\n    2033,\n/**/\n    2032,\n/**/\n    2031,\n/**/\n    2030,\n/**/\n    2029,\n/**/\n    2028,\n/**/\n    2027,\n/**/\n    2026,\n/**/\n    2025,\n/**/\n    2024,\n/**/\n    2023,\n/**/\n    2022,\n/**/\n    2021,\n/**/\n    2020,\n/**/\n    2019,\n/**/\n    2018,\n/**/\n    2017,\n/**/\n    2016,\n/**/\n    2015,\n/**/\n    2014,\n/**/\n    2013,\n/**/\n    2012,\n/**/\n    2011,\n/**/\n    2010,\n/**/\n    2009,\n/**/\n    2008,\n/**/\n    2007,\n/**/\n    2006,\n/**/\n    2005,\n/**/\n    2004,\n/**/\n    2003,\n/**/\n    2002,\n/**/\n    2001,\n/**/\n    2000,\n/**/\n    1999,\n/**/\n    1998,\n/**/\n    1997,\n/**/\n    1996,\n/**/\n    1995,\n/**/\n    1994,\n/**/\n    1993,\n/**/\n    1992,\n/**/\n    1991,\n/**/\n    1990,\n/**/\n    1989,\n/**/\n    1988,\n/**/\n    1987,\n/**/\n    1986,\n/**/\n    1985,\n/**/\n    1984,\n/**/\n    1983,\n/**/\n    1982,\n/**/\n    1981,\n/**/\n    1980,\n/**/\n    1979,\n/**/\n    1978,\n/**/\n    1977,\n/**/\n    1976,\n/**/\n    1975,\n/**/\n    1974,\n/**/\n    1973,\n/**/\n    1972,\n/**/\n    1971,\n/**/\n    1970,\n/**/\n    1969,\n/**/\n    1968,\n/**/\n    1967,\n/**/\n    1966,\n/**/\n    1965,\n/**/\n    1964,\n/**/\n    1963,\n/**/\n    1962,\n/**/\n    1961,\n/**/\n    1960,\n/**/\n    1959,\n/**/\n    1958,\n/**/\n    1957,\n/**/\n    1956,\n/**/\n    1955,\n/**/\n    1954,\n/**/\n    1953,\n/**/\n    1952,\n/**/\n    1951,\n/**/\n    1950,\n/**/\n    1949,\n/**/\n    1948,\n/**/\n    1947,\n/**/\n    1946,\n/**/\n    1945,\n/**/\n    1944,\n/**/\n    1943,\n/**/\n    1942,\n/**/\n    1941,\n/**/\n    1940,\n/**/\n    1939,\n/**/\n    1938,\n/**/\n    1937,\n/**/\n    1936,\n/**/\n    1935,\n/**/\n    1934,\n/**/\n    1933,\n/**/\n    1932,\n/**/\n    1931,\n/**/\n    1930,\n/**/\n    1929,\n/**/\n    1928,\n/**/\n    1927,\n/**/\n    1926,\n/**/\n    1925,\n/**/\n    1924,\n/**/\n    1923,\n/**/\n    1922,\n/**/\n    1921,\n/**/\n    1920,\n/**/\n    1919,\n/**/\n    1918,\n/**/\n    1917,\n/**/\n    1916,\n/**/\n    1915,\n/**/\n    1914,\n/**/\n    1913,\n/**/\n    1912,\n/**/\n    1911,\n/**/\n    1910,\n/**/\n    1909,\n/**/\n    1908,\n/**/\n    1907,\n/**/\n    1906,\n/**/\n    1905,\n/**/\n    1904,\n/**/\n    1903,\n/**/\n    1902,\n/**/\n    1901,\n/**/\n    1900,\n/**/\n    1899,\n/**/\n    1898,\n/**/\n    1897,\n/**/\n    1896,\n/**/\n    1895,\n/**/\n    1894,\n/**/\n    1893,\n/**/\n    1892,\n/**/\n    1891,\n/**/\n    1890,\n/**/\n    1889,\n/**/\n    1888,\n/**/\n    1887,\n/**/\n    1886,\n/**/\n    1885,\n/**/\n    1884,\n/**/\n    1883,\n/**/\n    1882,\n/**/\n    1881,\n/**/\n    1880,\n/**/\n    1879,\n/**/\n    1878,\n/**/\n    1877,\n/**/\n    1876,\n/**/\n    1875,\n/**/\n    1874,\n/**/\n    1873,\n/**/\n    1872,\n/**/\n    1871,\n/**/\n    1870,\n/**/\n    1869,\n/**/\n    1868,\n/**/\n    1867,\n/**/\n    1866,\n/**/\n    1865,\n/**/\n    1864,\n/**/\n    1863,\n/**/\n    1862,\n/**/\n    1861,\n/**/\n    1860,\n/**/\n    1859,\n/**/\n    1858,\n/**/\n    1857,\n/**/\n    1856,\n/**/\n    1855,\n/**/\n    1854,\n/**/\n    1853,\n/**/\n    1852,\n/**/\n    1851,\n/**/\n    1850,\n/**/\n    1849,\n/**/\n    1848,\n/**/\n    1847,\n/**/\n    1846,\n/**/\n    1845,\n/**/\n    1844,\n/**/\n    1843,\n/**/\n    1842,\n/**/\n    1841,\n/**/\n    1840,\n/**/\n    1839,\n/**/\n    1838,\n/**/\n    1837,\n/**/\n    1836,\n/**/\n    1835,\n/**/\n    1834,\n/**/\n    1833,\n/**/\n    1832,\n/**/\n    1831,\n/**/\n    1830,\n/**/\n    1829,\n/**/\n    1828,\n/**/\n    1827,\n/**/\n    1826,\n/**/\n    1825,\n/**/\n    1824,\n/**/\n    1823,\n/**/\n    1822,\n/**/\n    1821,\n/**/\n    1820,\n/**/\n    1819,\n/**/\n    1818,\n/**/\n    1817,\n/**/\n    1816,\n/**/\n    1815,\n/**/\n    1814,\n/**/\n    1813,\n/**/\n    1812,\n/**/\n    1811,\n/**/\n    1810,\n/**/\n    1809,\n/**/\n    1808,\n/**/\n    1807,\n/**/\n    1806,\n/**/\n    1805,\n/**/\n    1804,\n/**/\n    1803,\n/**/\n    1802,\n/**/\n    1801,\n/**/\n    1800,\n/**/\n    1799,\n/**/\n    1798,\n/**/\n    1797,\n/**/\n    1796,\n/**/\n    1795,\n/**/\n    1794,\n/**/\n    1793,\n/**/\n    1792,\n/**/\n    1791,\n/**/\n    1790,\n/**/\n    1789,\n/**/\n    1788,\n/**/\n    1787,\n/**/\n    1786,\n/**/\n    1785,\n/**/\n    1784,\n/**/\n    1783,\n/**/\n    1782,\n/**/\n    1781,\n/**/\n    1780,\n/**/\n    1779,\n/**/\n    1778,\n/**/\n    1777,\n/**/\n    1776,\n/**/\n    1775,\n/**/\n    1774,\n/**/\n    1773,\n/**/\n    1772,\n/**/\n    1771,\n/**/\n    1770,\n/**/\n    1769,\n/**/\n    1768,\n/**/\n    1767,\n/**/\n    1766,\n/**/\n    1765,\n/**/\n    1764,\n/**/\n    1763,\n/**/\n    1762,\n/**/\n    1761,\n/**/\n    1760,\n/**/\n    1759,\n/**/\n    1758,\n/**/\n    1757,\n/**/\n    1756,\n/**/\n    1755,\n/**/\n    1754,\n/**/\n    1753,\n/**/\n    1752,\n/**/\n    1751,\n/**/\n    1750,\n/**/\n    1749,\n/**/\n    1748,\n/**/\n    1747,\n/**/\n    1746,\n/**/\n    1745,\n/**/\n    1744,\n/**/\n    1743,\n/**/\n    1742,\n/**/\n    1741,\n/**/\n    1740,\n/**/\n    1739,\n/**/\n    1738,\n/**/\n    1737,\n/**/\n    1736,\n/**/\n    1735,\n/**/\n    1734,\n/**/\n    1733,\n/**/\n    1732,\n/**/\n    1731,\n/**/\n    1730,\n/**/\n    1729,\n/**/\n    1728,\n/**/\n    1727,\n/**/\n    1726,\n/**/\n    1725,\n/**/\n    1724,\n/**/\n    1723,\n/**/\n    1722,\n/**/\n    1721,\n/**/\n    1720,\n/**/\n    1719,\n/**/\n    1718,\n/**/\n    1717,\n/**/\n    1716,\n/**/\n    1715,\n/**/\n    1714,\n/**/\n    1713,\n/**/\n    1712,\n/**/\n    1711,\n/**/\n    1710,\n/**/\n    1709,\n/**/\n    1708,\n/**/\n    1707,\n/**/\n    1706,\n/**/\n    1705,\n/**/\n    1704,\n/**/\n    1703,\n/**/\n    1702,\n/**/\n    1701,\n/**/\n    1700,\n/**/\n    1699,\n/**/\n    1698,\n/**/\n    1697,\n/**/\n    1696,\n/**/\n    1695,\n/**/\n    1694,\n/**/\n    1693,\n/**/\n    1692,\n/**/\n    1691,\n/**/\n    1690,\n/**/\n    1689,\n/**/\n    1688,\n/**/\n    1687,\n/**/\n    1686,\n/**/\n    1685,\n/**/\n    1684,\n/**/\n    1683,\n/**/\n    1682,\n/**/\n    1681,\n/**/\n    1680,\n/**/\n    1679,\n/**/\n    1678,\n/**/\n    1677,\n/**/\n    1676,\n/**/\n    1675,\n/**/\n    1674,\n/**/\n    1673,\n/**/\n    1672,\n/**/\n    1671,\n/**/\n    1670,\n/**/\n    1669,\n/**/\n    1668,\n/**/\n    1667,\n/**/\n    1666,\n/**/\n    1665,\n/**/\n    1664,\n/**/\n    1663,\n/**/\n    1662,\n/**/\n    1661,\n/**/\n    1660,\n/**/\n    1659,\n/**/\n    1658,\n/**/\n    1657,\n/**/\n    1656,\n/**/\n    1655,\n/**/\n    1654,\n/**/\n    1653,\n/**/\n    1652,\n/**/\n    1651,\n/**/\n    1650,\n/**/\n    1649,\n/**/\n    1648,\n/**/\n    1647,\n/**/\n    1646,\n/**/\n    1645,\n/**/\n    1644,\n/**/\n    1643,\n/**/\n    1642,\n/**/\n    1641,\n/**/\n    1640,\n/**/\n    1639,\n/**/\n    1638,\n/**/\n    1637,\n/**/\n    1636,\n/**/\n    1635,\n/**/\n    1634,\n/**/\n    1633,\n/**/\n    1632,\n/**/\n    1631,\n/**/\n    1630,\n/**/\n    1629,\n/**/\n    1628,\n/**/\n    1627,\n/**/\n    1626,\n/**/\n    1625,\n/**/\n    1624,\n/**/\n    1623,\n/**/\n    1622,\n/**/\n    1621,\n/**/\n    1620,\n/**/\n    1619,\n/**/\n    1618,\n/**/\n    1617,\n/**/\n    1616,\n/**/\n    1615,\n/**/\n    1614,\n/**/\n    1613,\n/**/\n    1612,\n/**/\n    1611,\n/**/\n    1610,\n/**/\n    1609,\n/**/\n    1608,\n/**/\n    1607,\n/**/\n    1606,\n/**/\n    1605,\n/**/\n    1604,\n/**/\n    1603,\n/**/\n    1602,\n/**/\n    1601,\n/**/\n    1600,\n/**/\n    1599,\n/**/\n    1598,\n/**/\n    1597,\n/**/\n    1596,\n/**/\n    1595,\n/**/\n    1594,\n/**/\n    1593,\n/**/\n    1592,\n/**/\n    1591,\n/**/\n    1590,\n/**/\n    1589,\n/**/\n    1588,\n/**/\n    1587,\n/**/\n    1586,\n/**/\n    1585,\n/**/\n    1584,\n/**/\n    1583,\n/**/\n    1582,\n/**/\n    1581,\n/**/\n    1580,\n/**/\n    1579,\n/**/\n    1578,\n/**/\n    1577,\n/**/\n    1576,\n/**/\n    1575,\n/**/\n    1574,\n/**/\n    1573,\n/**/\n    1572,\n/**/\n    1571,\n/**/\n    1570,\n/**/\n    1569,\n/**/\n    1568,\n/**/\n    1567,\n/**/\n    1566,\n/**/\n    1565,\n/**/\n    1564,\n/**/\n    1563,\n/**/\n    1562,\n/**/\n    1561,\n/**/\n    1560,\n/**/\n    1559,\n/**/\n    1558,\n/**/\n    1557,\n/**/\n    1556,\n/**/\n    1555,\n/**/\n    1554,\n/**/\n    1553,\n/**/\n    1552,\n/**/\n    1551,\n/**/\n    1550,\n/**/\n    1549,\n/**/\n    1548,\n/**/\n    1547,\n/**/\n    1546,\n/**/\n    1545,\n/**/\n    1544,\n/**/\n    1543,\n/**/\n    1542,\n/**/\n    1541,\n/**/\n    1540,\n/**/\n    1539,\n/**/\n    1538,\n/**/\n    1537,\n/**/\n    1536,\n/**/\n    1535,\n/**/\n    1534,\n/**/\n    1533,\n/**/\n    1532,\n/**/\n    1531,\n/**/\n    1530,\n/**/\n    1529,\n/**/\n    1528,\n/**/\n    1527,\n/**/\n    1526,\n/**/\n    1525,\n/**/\n    1524,\n/**/\n    1523,\n/**/\n    1522,\n/**/\n    1521,\n/**/\n    1520,\n/**/\n    1519,\n/**/\n    1518,\n/**/\n    1517,\n/**/\n    1516,\n/**/\n    1515,\n/**/\n    1514,\n/**/\n    1513,\n/**/\n    1512,\n/**/\n    1511,\n/**/\n    1510,\n/**/\n    1509,\n/**/\n    1508,\n/**/\n    1507,\n/**/\n    1506,\n/**/\n    1505,\n/**/\n    1504,\n/**/\n    1503,\n/**/\n    1502,\n/**/\n    1501,\n/**/\n    1500,\n/**/\n    1499,\n/**/\n    1498,\n/**/\n    1497,\n/**/\n    1496,\n/**/\n    1495,\n/**/\n    1494,\n/**/\n    1493,\n/**/\n    1492,\n/**/\n    1491,\n/**/\n    1490,\n/**/\n    1489,\n/**/\n    1488,\n/**/\n    1487,\n/**/\n    1486,\n/**/\n    1485,\n/**/\n    1484,\n/**/\n    1483,\n/**/\n    1482,\n/**/\n    1481,\n/**/\n    1480,\n/**/\n    1479,\n/**/\n    1478,\n/**/\n    1477,\n/**/\n    1476,\n/**/\n    1475,\n/**/\n    1474,\n/**/\n    1473,\n/**/\n    1472,\n/**/\n    1471,\n/**/\n    1470,\n/**/\n    1469,\n/**/\n    1468,\n/**/\n    1467,\n/**/\n    1466,\n/**/\n    1465,\n/**/\n    1464,\n/**/\n    1463,\n/**/\n    1462,\n/**/\n    1461,\n/**/\n    1460,\n/**/\n    1459,\n/**/\n    1458,\n/**/\n    1457,\n/**/\n    1456,\n/**/\n    1455,\n/**/\n    1454,\n/**/\n    1453,\n/**/\n    1452,\n/**/\n    1451,\n/**/\n    1450,\n/**/\n    1449,\n/**/\n    1448,\n/**/\n    1447,\n/**/\n    1446,\n/**/\n    1445,\n/**/\n    1444,\n/**/\n    1443,\n/**/\n    1442,\n/**/\n    1441,\n/**/\n    1440,\n/**/\n    1439,\n/**/\n    1438,\n/**/\n    1437,\n/**/\n    1436,\n/**/\n    1435,\n/**/\n    1434,\n/**/\n    1433,\n/**/\n    1432,\n/**/\n    1431,\n/**/\n    1430,\n/**/\n    1429,\n/**/\n    1428,\n/**/\n    1427,\n/**/\n    1426,\n/**/\n    1425,\n/**/\n    1424,\n/**/\n    1423,\n/**/\n    1422,\n/**/\n    1421,\n/**/\n    1420,\n/**/\n    1419,\n/**/\n    1418,\n/**/\n    1417,\n/**/\n    1416,\n/**/\n    1415,\n/**/\n    1414,\n/**/\n    1413,\n/**/\n    1412,\n/**/\n    1411,\n/**/\n    1410,\n/**/\n    1409,\n/**/\n    1408,\n/**/\n    1407,\n/**/\n    1406,\n/**/\n    1405,\n/**/\n    1404,\n/**/\n    1403,\n/**/\n    1402,\n/**/\n    1401,\n/**/\n    1400,\n/**/\n    1399,\n/**/\n    1398,\n/**/\n    1397,\n/**/\n    1396,\n/**/\n    1395,\n/**/\n    1394,\n/**/\n    1393,\n/**/\n    1392,\n/**/\n    1391,\n/**/\n    1390,\n/**/\n    1389,\n/**/\n    1388,\n/**/\n    1387,\n/**/\n    1386,\n/**/\n    1385,\n/**/\n    1384,\n/**/\n    1383,\n/**/\n    1382,\n/**/\n    1381,\n/**/\n    1380,\n/**/\n    1379,\n/**/\n    1378,\n/**/\n    1377,\n/**/\n    1376,\n/**/\n    1375,\n/**/\n    1374,\n/**/\n    1373,\n/**/\n    1372,\n/**/\n    1371,\n/**/\n    1370,\n/**/\n    1369,\n/**/\n    1368,\n/**/\n    1367,\n/**/\n    1366,\n/**/\n    1365,\n/**/\n    1364,\n/**/\n    1363,\n/**/\n    1362,\n/**/\n    1361,\n/**/\n    1360,\n/**/\n    1359,\n/**/\n    1358,\n/**/\n    1357,\n/**/\n    1356,\n/**/\n    1355,\n/**/\n    1354,\n/**/\n    1353,\n/**/\n    1352,\n/**/\n    1351,\n/**/\n    1350,\n/**/\n    1349,\n/**/\n    1348,\n/**/\n    1347,\n/**/\n    1346,\n/**/\n    1345,\n/**/\n    1344,\n/**/\n    1343,\n/**/\n    1342,\n/**/\n    1341,\n/**/\n    1340,\n/**/\n    1339,\n/**/\n    1338,\n/**/\n    1337,\n/**/\n    1336,\n/**/\n    1335,\n/**/\n    1334,\n/**/\n    1333,\n/**/\n    1332,\n/**/\n    1331,\n/**/\n    1330,\n/**/\n    1329,\n/**/\n    1328,\n/**/\n    1327,\n/**/\n    1326,\n/**/\n    1325,\n/**/\n    1324,\n/**/\n    1323,\n/**/\n    1322,\n/**/\n    1321,\n/**/\n    1320,\n/**/\n    1319,\n/**/\n    1318,\n/**/\n    1317,\n/**/\n    1316,\n/**/\n    1315,\n/**/\n    1314,\n/**/\n    1313,\n/**/\n    1312,\n/**/\n    1311,\n/**/\n    1310,\n/**/\n    1309,\n/**/\n    1308,\n/**/\n    1307,\n/**/\n    1306,\n/**/\n    1305,\n/**/\n    1304,\n/**/\n    1303,\n/**/\n    1302,\n/**/\n    1301,\n/**/\n    1300,\n/**/\n    1299,\n/**/\n    1298,\n/**/\n    1297,\n/**/\n    1296,\n/**/\n    1295,\n/**/\n    1294,\n/**/\n    1293,\n/**/\n    1292,\n/**/\n    1291,\n/**/\n    1290,\n/**/\n    1289,\n/**/\n    1288,\n/**/\n    1287,\n/**/\n    1286,\n/**/\n    1285,\n/**/\n    1284,\n/**/\n    1283,\n/**/\n    1282,\n/**/\n    1281,\n/**/\n    1280,\n/**/\n    1279,\n/**/\n    1278,\n/**/\n    1277,\n/**/\n    1276,\n/**/\n    1275,\n/**/\n    1274,\n/**/\n    1273,\n/**/\n    1272,\n/**/\n    1271,\n/**/\n    1270,\n/**/\n    1269,\n/**/\n    1268,\n/**/\n    1267,\n/**/\n    1266,\n/**/\n    1265,\n/**/\n    1264,\n/**/\n    1263,\n/**/\n    1262,\n/**/\n    1261,\n/**/\n    1260,\n/**/\n    1259,\n/**/\n    1258,\n/**/\n    1257,\n/**/\n    1256,\n/**/\n    1255,\n/**/\n    1254,\n/**/\n    1253,\n/**/\n    1252,\n/**/\n    1251,\n/**/\n    1250,\n/**/\n    1249,\n/**/\n    1248,\n/**/\n    1247,\n/**/\n    1246,\n/**/\n    1245,\n/**/\n    1244,\n/**/\n    1243,\n/**/\n    1242,\n/**/\n    1241,\n/**/\n    1240,\n/**/\n    1239,\n/**/\n    1238,\n/**/\n    1237,\n/**/\n    1236,\n/**/\n    1235,\n/**/\n    1234,\n/**/\n    1233,\n/**/\n    1232,\n/**/\n    1231,\n/**/\n    1230,\n/**/\n    1229,\n/**/\n    1228,\n/**/\n    1227,\n/**/\n    1226,\n/**/\n    1225,\n/**/\n    1224,\n/**/\n    1223,\n/**/\n    1222,\n/**/\n    1221,\n/**/\n    1220,\n/**/\n    1219,\n/**/\n    1218,\n/**/\n    1217,\n/**/\n    1216,\n/**/\n    1215,\n/**/\n    1214,\n/**/\n    1213,\n/**/\n    1212,\n/**/\n    1211,\n/**/\n    1210,\n/**/\n    1209,\n/**/\n    1208,\n/**/\n    1207,\n/**/\n    1206,\n/**/\n    1205,\n/**/\n    1204,\n/**/\n    1203,\n/**/\n    1202,\n/**/\n    1201,\n/**/\n    1200,\n/**/\n    1199,\n/**/\n    1198,\n/**/\n    1197,\n/**/\n    1196,\n/**/\n    1195,\n/**/\n    1194,\n/**/\n    1193,\n/**/\n    1192,\n/**/\n    1191,\n/**/\n    1190,\n/**/\n    1189,\n/**/\n    1188,\n/**/\n    1187,\n/**/\n    1186,\n/**/\n    1185,\n/**/\n    1184,\n/**/\n    1183,\n/**/\n    1182,\n/**/\n    1181,\n/**/\n    1180,\n/**/\n    1179,\n/**/\n    1178,\n/**/\n    1177,\n/**/\n    1176,\n/**/\n    1175,\n/**/\n    1174,\n/**/\n    1173,\n/**/\n    1172,\n/**/\n    1171,\n/**/\n    1170,\n/**/\n    1169,\n/**/\n    1168,\n/**/\n    1167,\n/**/\n    1166,\n/**/\n    1165,\n/**/\n    1164,\n/**/\n    1163,\n/**/\n    1162,\n/**/\n    1161,\n/**/\n    1160,\n/**/\n    1159,\n/**/\n    1158,\n/**/\n    1157,\n/**/\n    1156,\n/**/\n    1155,\n/**/\n    1154,\n/**/\n    1153,\n/**/\n    1152,\n/**/\n    1151,\n/**/\n    1150,\n/**/\n    1149,\n/**/\n    1148,\n/**/\n    1147,\n/**/\n    1146,\n/**/\n    1145,\n/**/\n    1144,\n/**/\n    1143,\n/**/\n    1142,\n/**/\n    1141,\n/**/\n    1140,\n/**/\n    1139,\n/**/\n    1138,\n/**/\n    1137,\n/**/\n    1136,\n/**/\n    1135,\n/**/\n    1134,\n/**/\n    1133,\n/**/\n    1132,\n/**/\n    1131,\n/**/\n    1130,\n/**/\n    1129,\n/**/\n    1128,\n/**/\n    1127,\n/**/\n    1126,\n/**/\n    1125,\n/**/\n    1124,\n/**/\n    1123,\n/**/\n    1122,\n/**/\n    1121,\n/**/\n    1120,\n/**/\n    1119,\n/**/\n    1118,\n/**/\n    1117,\n/**/\n    1116,\n/**/\n    1115,\n/**/\n    1114,\n/**/\n    1113,\n/**/\n    1112,\n/**/\n    1111,\n/**/\n    1110,\n/**/\n    1109,\n/**/\n    1108,\n/**/\n    1107,\n/**/\n    1106,\n/**/\n    1105,\n/**/\n    1104,\n/**/\n    1103,\n/**/\n    1102,\n/**/\n    1101,\n/**/\n    1100,\n/**/\n    1099,\n/**/\n    1098,\n/**/\n    1097,\n/**/\n    1096,\n/**/\n    1095,\n/**/\n    1094,\n/**/\n    1093,\n/**/\n    1092,\n/**/\n    1091,\n/**/\n    1090,\n/**/\n    1089,\n/**/\n    1088,\n/**/\n    1087,\n/**/\n    1086,\n/**/\n    1085,\n/**/\n    1084,\n/**/\n    1083,\n/**/\n    1082,\n/**/\n    1081,\n/**/\n    1080,\n/**/\n    1079,\n/**/\n    1078,\n/**/\n    1077,\n/**/\n    1076,\n/**/\n    1075,\n/**/\n    1074,\n/**/\n    1073,\n/**/\n    1072,\n/**/\n    1071,\n/**/\n    1070,\n/**/\n    1069,\n/**/\n    1068,\n/**/\n    1067,\n/**/\n    1066,\n/**/\n    1065,\n/**/\n    1064,\n/**/\n    1063,\n/**/\n    1062,\n/**/\n    1061,\n/**/\n    1060,\n/**/\n    1059,\n/**/\n    1058,\n/**/\n    1057,\n/**/\n    1056,\n/**/\n    1055,\n/**/\n    1054,\n/**/\n    1053,\n/**/\n    1052,\n/**/\n    1051,\n/**/\n    1050,\n/**/\n    1049,\n/**/\n    1048,\n/**/\n    1047,\n/**/\n    1046,\n/**/\n    1045,\n/**/\n    1044,\n/**/\n    1043,\n/**/\n    1042,\n/**/\n    1041,\n/**/\n    1040,\n/**/\n    1039,\n/**/\n    1038,\n/**/\n    1037,\n/**/\n    1036,\n/**/\n    1035,\n/**/\n    1034,\n/**/\n    1033,\n/**/\n    1032,\n/**/\n    1031,\n/**/\n    1030,\n/**/\n    1029,\n/**/\n    1028,\n/**/\n    1027,\n/**/\n    1026,\n/**/\n    1025,\n/**/\n    1024,\n/**/\n    1023,\n/**/\n    1022,\n/**/\n    1021,\n/**/\n    1020,\n/**/\n    1019,\n/**/\n    1018,\n/**/\n    1017,\n/**/\n    1016,\n/**/\n    1015,\n/**/\n    1014,\n/**/\n    1013,\n/**/\n    1012,\n/**/\n    1011,\n/**/\n    1010,\n/**/\n    1009,\n/**/\n    1008,\n/**/\n    1007,\n/**/\n    1006,\n/**/\n    1005,\n/**/\n    1004,\n/**/\n    1003,\n/**/\n    1002,\n/**/\n    1001,\n/**/\n    1000,\n/**/\n    999,\n/**/\n    998,\n/**/\n    997,\n/**/\n    996,\n/**/\n    995,\n/**/\n    994,\n/**/\n    993,\n/**/\n    992,\n/**/\n    991,\n/**/\n    990,\n/**/\n    989,\n/**/\n    988,\n/**/\n    987,\n/**/\n    986,\n/**/\n    985,\n/**/\n    984,\n/**/\n    983,\n/**/\n    982,\n/**/\n    981,\n/**/\n    980,\n/**/\n    979,\n/**/\n    978,\n/**/\n    977,\n/**/\n    976,\n/**/\n    975,\n/**/\n    974,\n/**/\n    973,\n/**/\n    972,\n/**/\n    971,\n/**/\n    970,\n/**/\n    969,\n/**/\n    968,\n/**/\n    967,\n/**/\n    966,\n/**/\n    965,\n/**/\n    964,\n/**/\n    963,\n/**/\n    962,\n/**/\n    961,\n/**/\n    960,\n/**/\n    959,\n/**/\n    958,\n/**/\n    957,\n/**/\n    956,\n/**/\n    955,\n/**/\n    954,\n/**/\n    953,\n/**/\n    952,\n/**/\n    951,\n/**/\n    950,\n/**/\n    949,\n/**/\n    948,\n/**/\n    947,\n/**/\n    946,\n/**/\n    945,\n/**/\n    944,\n/**/\n    943,\n/**/\n    942,\n/**/\n    941,\n/**/\n    940,\n/**/\n    939,\n/**/\n    938,\n/**/\n    937,\n/**/\n    936,\n/**/\n    935,\n/**/\n    934,\n/**/\n    933,\n/**/\n    932,\n/**/\n    931,\n/**/\n    930,\n/**/\n    929,\n/**/\n    928,\n/**/\n    927,\n/**/\n    926,\n/**/\n    925,\n/**/\n    924,\n/**/\n    923,\n/**/\n    922,\n/**/\n    921,\n/**/\n    920,\n/**/\n    919,\n/**/\n    918,\n/**/\n    917,\n/**/\n    916,\n/**/\n    915,\n/**/\n    914,\n/**/\n    913,\n/**/\n    912,\n/**/\n    911,\n/**/\n    910,\n/**/\n    909,\n/**/\n    908,\n/**/\n    907,\n/**/\n    906,\n/**/\n    905,\n/**/\n    904,\n/**/\n    903,\n/**/\n    902,\n/**/\n    901,\n/**/\n    900,\n/**/\n    899,\n/**/\n    898,\n/**/\n    897,\n/**/\n    896,\n/**/\n    895,\n/**/\n    894,\n/**/\n    893,\n/**/\n    892,\n/**/\n    891,\n/**/\n    890,\n/**/\n    889,\n/**/\n    888,\n/**/\n    887,\n/**/\n    886,\n/**/\n    885,\n/**/\n    884,\n/**/\n    883,\n/**/\n    882,\n/**/\n    881,\n/**/\n    880,\n/**/\n    879,\n/**/\n    878,\n/**/\n    877,\n/**/\n    876,\n/**/\n    875,\n/**/\n    874,\n/**/\n    873,\n/**/\n    872,\n/**/\n    871,\n/**/\n    870,\n/**/\n    869,\n/**/\n    868,\n/**/\n    867,\n/**/\n    866,\n/**/\n    865,\n/**/\n    864,\n/**/\n    863,\n/**/\n    862,\n/**/\n    861,\n/**/\n    860,\n/**/\n    859,\n/**/\n    858,\n/**/\n    857,\n/**/\n    856,\n/**/\n    855,\n/**/\n    854,\n/**/\n    853,\n/**/\n    852,\n/**/\n    851,\n/**/\n    850,\n/**/\n    849,\n/**/\n    848,\n/**/\n    847,\n/**/\n    846,\n/**/\n    845,\n/**/\n    844,\n/**/\n    843,\n/**/\n    842,\n/**/\n    841,\n/**/\n    840,\n/**/\n    839,\n/**/\n    838,\n/**/\n    837,\n/**/\n    836,\n/**/\n    835,\n/**/\n    834,\n/**/\n    833,\n/**/\n    832,\n/**/\n    831,\n/**/\n    830,\n/**/\n    829,\n/**/\n    828,\n/**/\n    827,\n/**/\n    826,\n/**/\n    825,\n/**/\n    824,\n/**/\n    823,\n/**/\n    822,\n/**/\n    821,\n/**/\n    820,\n/**/\n    819,\n/**/\n    818,\n/**/\n    817,\n/**/\n    816,\n/**/\n    815,\n/**/\n    814,\n/**/\n    813,\n/**/\n    812,\n/**/\n    811,\n/**/\n    810,\n/**/\n    809,\n/**/\n    808,\n/**/\n    807,\n/**/\n    806,\n/**/\n    805,\n/**/\n    804,\n/**/\n    803,\n/**/\n    802,\n/**/\n    801,\n/**/\n    800,\n/**/\n    799,\n/**/\n    798,\n/**/\n    797,\n/**/\n    796,\n/**/\n    795,\n/**/\n    794,\n/**/\n    793,\n/**/\n    792,\n/**/\n    791,\n/**/\n    790,\n/**/\n    789,\n/**/\n    788,\n/**/\n    787,\n/**/\n    786,\n/**/\n    785,\n/**/\n    784,\n/**/\n    783,\n/**/\n    782,\n/**/\n    781,\n/**/\n    780,\n/**/\n    779,\n/**/\n    778,\n/**/\n    777,\n/**/\n    776,\n/**/\n    775,\n/**/\n    774,\n/**/\n    773,\n/**/\n    772,\n/**/\n    771,\n/**/\n    770,\n/**/\n    769,\n/**/\n    768,\n/**/\n    767,\n/**/\n    766,\n/**/\n    765,\n/**/\n    764,\n/**/\n    763,\n/**/\n    762,\n/**/\n    761,\n/**/\n    760,\n/**/\n    759,\n/**/\n    758,\n/**/\n    757,\n/**/\n    756,\n/**/\n    755,\n/**/\n    754,\n/**/\n    753,\n/**/\n    752,\n/**/\n    751,\n/**/\n    750,\n/**/\n    749,\n/**/\n    748,\n/**/\n    747,\n/**/\n    746,\n/**/\n    745,\n/**/\n    744,\n/**/\n    743,\n/**/\n    742,\n/**/\n    741,\n/**/\n    740,\n/**/\n    739,\n/**/\n    738,\n/**/\n    737,\n/**/\n    736,\n/**/\n    735,\n/**/\n    734,\n/**/\n    733,\n/**/\n    732,\n/**/\n    731,\n/**/\n    730,\n/**/\n    729,\n/**/\n    728,\n/**/\n    727,\n/**/\n    726,\n/**/\n    725,\n/**/\n    724,\n/**/\n    723,\n/**/\n    722,\n/**/\n    721,\n/**/\n    720,\n/**/\n    719,\n/**/\n    718,\n/**/\n    717,\n/**/\n    716,\n/**/\n    715,\n/**/\n    714,\n/**/\n    713,\n/**/\n    712,\n/**/\n    711,\n/**/\n    710,\n/**/\n    709,\n/**/\n    708,\n/**/\n    707,\n/**/\n    706,\n/**/\n    705,\n/**/\n    704,\n/**/\n    703,\n/**/\n    702,\n/**/\n    701,\n/**/\n    700,\n/**/\n    699,\n/**/\n    698,\n/**/\n    697,\n/**/\n    696,\n/**/\n    695,\n/**/\n    694,\n/**/\n    693,\n/**/\n    692,\n/**/\n    691,\n/**/\n    690,\n/**/\n    689,\n/**/\n    688,\n/**/\n    687,\n/**/\n    686,\n/**/\n    685,\n/**/\n    684,\n/**/\n    683,\n/**/\n    682,\n/**/\n    681,\n/**/\n    680,\n/**/\n    679,\n/**/\n    678,\n/**/\n    677,\n/**/\n    676,\n/**/\n    675,\n/**/\n    674,\n/**/\n    673,\n/**/\n    672,\n/**/\n    671,\n/**/\n    670,\n/**/\n    669,\n/**/\n    668,\n/**/\n    667,\n/**/\n    666,\n/**/\n    665,\n/**/\n    664,\n/**/\n    663,\n/**/\n    662,\n/**/\n    661,\n/**/\n    660,\n/**/\n    659,\n/**/\n    658,\n/**/\n    657,\n/**/\n    656,\n/**/\n    655,\n/**/\n    654,\n/**/\n    653,\n/**/\n    652,\n/**/\n    651,\n/**/\n    650,\n/**/\n    649,\n/**/\n    648,\n/**/\n    647,\n/**/\n    646,\n/**/\n    645,\n/**/\n    644,\n/**/\n    643,\n/**/\n    642,\n/**/\n    641,\n/**/\n    640,\n/**/\n    639,\n/**/\n    638,\n/**/\n    637,\n/**/\n    636,\n/**/\n    635,\n/**/\n    634,\n/**/\n    633,\n/**/\n    632,\n/**/\n    631,\n/**/\n    630,\n/**/\n    629,\n/**/\n    628,\n/**/\n    627,\n/**/\n    626,\n/**/\n    625,\n/**/\n    624,\n/**/\n    623,\n/**/\n    622,\n/**/\n    621,\n/**/\n    620,\n/**/\n    619,\n/**/\n    618,\n/**/\n    617,\n/**/\n    616,\n/**/\n    615,\n/**/\n    614,\n/**/\n    613,\n/**/\n    612,\n/**/\n    611,\n/**/\n    610,\n/**/\n    609,\n/**/\n    608,\n/**/\n    607,\n/**/\n    606,\n/**/\n    605,\n/**/\n    604,\n/**/\n    603,\n/**/\n    602,\n/**/\n    601,\n/**/\n    600,\n/**/\n    599,\n/**/\n    598,\n/**/\n    597,\n/**/\n    596,\n/**/\n    595,\n/**/\n    594,\n/**/\n    593,\n/**/\n    592,\n/**/\n    591,\n/**/\n    590,\n/**/\n    589,\n/**/\n    588,\n/**/\n    587,\n/**/\n    586,\n/**/\n    585,\n/**/\n    584,\n/**/\n    583,\n/**/\n    582,\n/**/\n    581,\n/**/\n    580,\n/**/\n    579,\n/**/\n    578,\n/**/\n    577,\n/**/\n    576,\n/**/\n    575,\n/**/\n    574,\n/**/\n    573,\n/**/\n    572,\n/**/\n    571,\n/**/\n    570,\n/**/\n    569,\n/**/\n    568,\n/**/\n    567,\n/**/\n    566,\n/**/\n    565,\n/**/\n    564,\n/**/\n    563,\n/**/\n    562,\n/**/\n    561,\n/**/\n    560,\n/**/\n    559,\n/**/\n    558,\n/**/\n    557,\n/**/\n    556,\n/**/\n    555,\n/**/\n    554,\n/**/\n    553,\n/**/\n    552,\n/**/\n    551,\n/**/\n    550,\n/**/\n    549,\n/**/\n    548,\n/**/\n    547,\n/**/\n    546,\n/**/\n    545,\n/**/\n    544,\n/**/\n    543,\n/**/\n    542,\n/**/\n    541,\n/**/\n    540,\n/**/\n    539,\n/**/\n    538,\n/**/\n    537,\n/**/\n    536,\n/**/\n    535,\n/**/\n    534,\n/**/\n    533,\n/**/\n    532,\n/**/\n    531,\n/**/\n    530,\n/**/\n    529,\n/**/\n    528,\n/**/\n    527,\n/**/\n    526,\n/**/\n    525,\n/**/\n    524,\n/**/\n    523,\n/**/\n    522,\n/**/\n    521,\n/**/\n    520,\n/**/\n    519,\n/**/\n    518,\n/**/\n    517,\n/**/\n    516,\n/**/\n    515,\n/**/\n    514,\n/**/\n    513,\n/**/\n    512,\n/**/\n    511,\n/**/\n    510,\n/**/\n    509,\n/**/\n    508,\n/**/\n    507,\n/**/\n    506,\n/**/\n    505,\n/**/\n    504,\n/**/\n    503,\n/**/\n    502,\n/**/\n    501,\n/**/\n    500,\n/**/\n    499,\n/**/\n    498,\n/**/\n    497,\n/**/\n    496,\n/**/\n    495,\n/**/\n    494,\n/**/\n    493,\n/**/\n    492,\n/**/\n    491,\n/**/\n    490,\n/**/\n    489,\n/**/\n    488,\n/**/\n    487,\n/**/\n    486,\n/**/\n    485,\n/**/\n    484,\n/**/\n    483,\n/**/\n    482,\n/**/\n    481,\n/**/\n    480,\n/**/\n    479,\n/**/\n    478,\n/**/\n    477,\n/**/\n    476,\n/**/\n    475,\n/**/\n    474,\n/**/\n    473,\n/**/\n    472,\n/**/\n    471,\n/**/\n    470,\n/**/\n    469,\n/**/\n    468,\n/**/\n    467,\n/**/\n    466,\n/**/\n    465,\n/**/\n    464,\n/**/\n    463,\n/**/\n    462,\n/**/\n    461,\n/**/\n    460,\n/**/\n    459,\n/**/\n    458,\n/**/\n    457,\n/**/\n    456,\n/**/\n    455,\n/**/\n    454,\n/**/\n    453,\n/**/\n    452,\n/**/\n    451,\n/**/\n    450,\n/**/\n    449,\n/**/\n    448,\n/**/\n    447,\n/**/\n    446,\n/**/\n    445,\n/**/\n    444,\n/**/\n    443,\n/**/\n    442,\n/**/\n    441,\n/**/\n    440,\n/**/\n    439,\n/**/\n    438,\n/**/\n    437,\n/**/\n    436,\n/**/\n    435,\n/**/\n    434,\n/**/\n    433,\n/**/\n    432,\n/**/\n    431,\n/**/\n    430,\n/**/\n    429,\n/**/\n    428,\n/**/\n    427,\n/**/\n    426,\n/**/\n    425,\n/**/\n    424,\n/**/\n    423,\n/**/\n    422,\n/**/\n    421,\n/**/\n    420,\n/**/\n    419,\n/**/\n    418,\n/**/\n    417,\n/**/\n    416,\n/**/\n    415,\n/**/\n    414,\n/**/\n    413,\n/**/\n    412,\n/**/\n    411,\n/**/\n    410,\n/**/\n    409,\n/**/\n    408,\n/**/\n    407,\n/**/\n    406,\n/**/\n    405,\n/**/\n    404,\n/**/\n    403,\n/**/\n    402,\n/**/\n    401,\n/**/\n    400,\n/**/\n    399,\n/**/\n    398,\n/**/\n    397,\n/**/\n    396,\n/**/\n    395,\n/**/\n    394,\n/**/\n    393,\n/**/\n    392,\n/**/\n    391,\n/**/\n    390,\n/**/\n    389,\n/**/\n    388,\n/**/\n    387,\n/**/\n    386,\n/**/\n    385,\n/**/\n    384,\n/**/\n    383,\n/**/\n    382,\n/**/\n    381,\n/**/\n    380,\n/**/\n    379,\n/**/\n    378,\n/**/\n    377,\n/**/\n    376,\n/**/\n    375,\n/**/\n    374,\n/**/\n    373,\n/**/\n    372,\n/**/\n    371,\n/**/\n    370,\n/**/\n    369,\n/**/\n    368,\n/**/\n    367,\n/**/\n    366,\n/**/\n    365,\n/**/\n    364,\n/**/\n    363,\n/**/\n    362,\n/**/\n    361,\n/**/\n    360,\n/**/\n    359,\n/**/\n    358,\n/**/\n    357,\n/**/\n    356,\n/**/\n    355,\n/**/\n    354,\n/**/\n    353,\n/**/\n    352,\n/**/\n    351,\n/**/\n    350,\n/**/\n    349,\n/**/\n    348,\n/**/\n    347,\n/**/\n    346,\n/**/\n    345,\n/**/\n    344,\n/**/\n    343,\n/**/\n    342,\n/**/\n    341,\n/**/\n    340,\n/**/\n    339,\n/**/\n    338,\n/**/\n    337,\n/**/\n    336,\n/**/\n    335,\n/**/\n    334,\n/**/\n    333,\n/**/\n    332,\n/**/\n    331,\n/**/\n    330,\n/**/\n    329,\n/**/\n    328,\n/**/\n    327,\n/**/\n    326,\n/**/\n    325,\n/**/\n    324,\n/**/\n    323,\n/**/\n    322,\n/**/\n    321,\n/**/\n    320,\n/**/\n    319,\n/**/\n    318,\n/**/\n    317,\n/**/\n    316,\n/**/\n    315,\n/**/\n    314,\n/**/\n    313,\n/**/\n    312,\n/**/\n    311,\n/**/\n    310,\n/**/\n    309,\n/**/\n    308,\n/**/\n    307,\n/**/\n    306,\n/**/\n    305,\n/**/\n    304,\n/**/\n    303,\n/**/\n    302,\n/**/\n    301,\n/**/\n    300,\n/**/\n    299,\n/**/\n    298,\n/**/\n    297,\n/**/\n    296,\n/**/\n    295,\n/**/\n    294,\n/**/\n    293,\n/**/\n    292,\n/**/\n    291,\n/**/\n    290,\n/**/\n    289,\n/**/\n    288,\n/**/\n    287,\n/**/\n    286,\n/**/\n    285,\n/**/\n    284,\n/**/\n    283,\n/**/\n    282,\n/**/\n    281,\n/**/\n    280,\n/**/\n    279,\n/**/\n    278,\n/**/\n    277,\n/**/\n    276,\n/**/\n    275,\n/**/\n    274,\n/**/\n    273,\n/**/\n    272,\n/**/\n    271,\n/**/\n    270,\n/**/\n    269,\n/**/\n    268,\n/**/\n    267,\n/**/\n    266,\n/**/\n    265,\n/**/\n    264,\n/**/\n    263,\n/**/\n    262,\n/**/\n    261,\n/**/\n    260,\n/**/\n    259,\n/**/\n    258,\n/**/\n    257,\n/**/\n    256,\n/**/\n    255,\n/**/\n    254,\n/**/\n    253,\n/**/\n    252,\n/**/\n    251,\n/**/\n    250,\n/**/\n    249,\n/**/\n    248,\n/**/\n    247,\n/**/\n    246,\n/**/\n    245,\n/**/\n    244,\n/**/\n    243,\n/**/\n    242,\n/**/\n    241,\n/**/\n    240,\n/**/\n    239,\n/**/\n    238,\n/**/\n    237,\n/**/\n    236,\n/**/\n    235,\n/**/\n    234,\n/**/\n    233,\n/**/\n    232,\n/**/\n    231,\n/**/\n    230,\n/**/\n    229,\n/**/\n    228,\n/**/\n    227,\n/**/\n    226,\n/**/\n    225,\n/**/\n    224,\n/**/\n    223,\n/**/\n    222,\n/**/\n    221,\n/**/\n    220,\n/**/\n    219,\n/**/\n    218,\n/**/\n    217,\n/**/\n    216,\n/**/\n    215,\n/**/\n    214,\n/**/\n    213,\n/**/\n    212,\n/**/\n    211,\n/**/\n    210,\n/**/\n    209,\n/**/\n    208,\n/**/\n    207,\n/**/\n    206,\n/**/\n    205,\n/**/\n    204,\n/**/\n    203,\n/**/\n    202,\n/**/\n    201,\n/**/\n    200,\n/**/\n    199,\n/**/\n    198,\n/**/\n    197,\n/**/\n    196,\n/**/\n    195,\n/**/\n    194,\n/**/\n    193,\n/**/\n    192,\n/**/\n    191,\n/**/\n    190,\n/**/\n    189,\n/**/\n    188,\n/**/\n    187,\n/**/\n    186,\n/**/\n    185,\n/**/\n    184,\n/**/\n    183,\n/**/\n    182,\n/**/\n    181,\n/**/\n    180,\n/**/\n    179,\n/**/\n    178,\n/**/\n    177,\n/**/\n    176,\n/**/\n    175,\n/**/\n    174,\n/**/\n    173,\n/**/\n    172,\n/**/\n    171,\n/**/\n    170,\n/**/\n    169,\n/**/\n    168,\n/**/\n    167,\n/**/\n    166,\n/**/\n    165,\n/**/\n    164,\n/**/\n    163,\n/**/\n    162,\n/**/\n    161,\n/**/\n    160,\n/**/\n    159,\n/**/\n    158,\n/**/\n    157,\n/**/\n    156,\n/**/\n    155,\n/**/\n    154,\n/**/\n    153,\n/**/\n    152,\n/**/\n    151,\n/**/\n    150,\n/**/\n    149,\n/**/\n    148,\n/**/\n    147,\n/**/\n    146,\n/**/\n    145,\n/**/\n    144,\n/**/\n    143,\n/**/\n    142,\n/**/\n    141,\n/**/\n    140,\n/**/\n    139,\n/**/\n    138,\n/**/\n    137,\n/**/\n    136,\n/**/\n    135,\n/**/\n    134,\n/**/\n    133,\n/**/\n    132,\n/**/\n    131,\n/**/\n    130,\n/**/\n    129,\n/**/\n    128,\n/**/\n    127,\n/**/\n    126,\n/**/\n    125,\n/**/\n    124,\n/**/\n    123,\n/**/\n    122,\n/**/\n    121,\n/**/\n    120,\n/**/\n    119,\n/**/\n    118,\n/**/\n    117,\n/**/\n    116,\n/**/\n    115,\n/**/\n    114,\n/**/\n    113,\n/**/\n    112,\n/**/\n    111,\n/**/\n    110,\n/**/\n    109,\n/**/\n    108,\n/**/\n    107,\n/**/\n    106,\n/**/\n    105,\n/**/\n    104,\n/**/\n    103,\n/**/\n    102,\n/**/\n    101,\n/**/\n    100,\n/**/\n    99,\n/**/\n    98,\n/**/\n    97,\n/**/\n    96,\n/**/\n    95,\n/**/\n    94,\n/**/\n    93,\n/**/\n    92,\n/**/\n    91,\n/**/\n    90,\n/**/\n    89,\n/**/\n    88,\n/**/\n    87,\n/**/\n    86,\n/**/\n    85,\n/**/\n    84,\n/**/\n    83,\n/**/\n    82,\n/**/\n    81,\n/**/\n    80,\n/**/\n    79,\n/**/\n    78,\n/**/\n    77,\n/**/\n    76,\n/**/\n    75,\n/**/\n    74,\n/**/\n    73,\n/**/\n    72,\n/**/\n    71,\n/**/\n    70,\n/**/\n    69,\n/**/\n    68,\n/**/\n    67,\n/**/\n    66,\n/**/\n    65,\n/**/\n    64,\n/**/\n    63,\n/**/\n    62,\n/**/\n    61,\n/**/\n    60,\n/**/\n    59,\n/**/\n    58,\n/**/\n    57,\n/**/\n    56,\n/**/\n    55,\n/**/\n    54,\n/**/\n    53,\n/**/\n    52,\n/**/\n    51,\n/**/\n    50,\n/**/\n    49,\n/**/\n    48,\n/**/\n    47,\n/**/\n    46,\n/**/\n    45,\n/**/\n    44,\n/**/\n    43,\n/**/\n    42,\n/**/\n    41,\n/**/\n    40,\n/**/\n    39,\n/**/\n    38,\n/**/\n    37,\n/**/\n    36,\n/**/\n    35,\n/**/\n    34,\n/**/\n    33,\n/**/\n    32,\n/**/\n    31,\n/**/\n    30,\n/**/\n    29,\n/**/\n    28,\n/**/\n    27,\n/**/\n    26,\n/**/\n    25,\n/**/\n    24,\n/**/\n    23,\n/**/\n    22,\n/**/\n    21,\n/**/\n    20,\n/**/\n    19,\n/**/\n    18,\n/**/\n    17,\n/**/\n    16,\n/**/\n    15,\n/**/\n    14,\n/**/\n    13,\n/**/\n    12,\n/**/\n    11,\n/**/\n    10,\n/**/\n    9,\n/**/\n    8,\n/**/\n    7,\n/**/\n    6,\n/**/\n    5,\n/**/\n    4,\n/**/\n    3,\n/**/\n    2,\n/**/\n    1,\n/**/\n    0\n};\n\n/*\n * Place to put a short description when adding a feature with a patch.\n * Keep it short, e.g.,: \"relative numbers\", \"persistent undo\".\n * Also add a comment marker to separate the lines.\n * See the official Vim patches for the diff format: It must use a context of\n * one line only.  Create it by hand or use \"diff -C2\" and edit the patch.\n */\nstatic char *(extra_patches[]) =\n{   /* Add your patch description below this line */\n/**/\n    NULL\n};\n\n    int\nhighest_patch(void)\n{\n    // this relies on the highest patch number to be the first entry\n    return included_patches[0];\n}\n\n#if defined(FEAT_EVAL) || defined(PROTO)\n/*\n * Return TRUE if patch \"n\" has been included.\n */\n    int\nhas_patch(int n)\n{\n    int\t\th, m, l;\n\n    // Perform a binary search.\n    l = 0;\n    h = (int)ARRAY_LENGTH(included_patches) - 1;\n    while (l < h)\n    {\n\tm = (l + h) / 2;\n\tif (included_patches[m] == n)\n\t    return TRUE;\n\tif (included_patches[m] < n)\n\t    h = m;\n\telse\n\t    l = m + 1;\n    }\n    return FALSE;\n}\n#endif\n\n    void\nex_version(exarg_T *eap)\n{\n    /*\n     * Ignore a \":version 9.99\" command.\n     */\n    if (*eap->arg == NUL)\n    {\n\tmsg_putchar('\\n');\n\tlist_version();\n    }\n}\n\n/*\n * Output a string for the version message.  If it's going to wrap, output a\n * newline, unless the message is too long to fit on the screen anyway.\n * When \"wrap\" is TRUE wrap the string in [].\n */\n    static void\nversion_msg_wrap(char_u *s, int wrap)\n{\n    int\t\tlen = vim_strsize(s) + (wrap ? 2 : 0);\n\n    if (!got_int && len < (int)Columns && msg_col + len >= (int)Columns\n\t\t\t\t\t\t\t\t&& *s != '\\n')\n\tmsg_putchar('\\n');\n    if (!got_int)\n    {\n\tif (wrap)\n\t    msg_puts(\"[\");\n\tmsg_puts((char *)s);\n\tif (wrap)\n\t    msg_puts(\"]\");\n    }\n}\n\n    static void\nversion_msg(char *s)\n{\n    version_msg_wrap((char_u *)s, FALSE);\n}\n\n/*\n * List all features aligned in columns, dictionary style.\n */\n    static void\nlist_features(void)\n{\n    list_in_columns((char_u **)features, -1, -1);\n}\n\n/*\n * List string items nicely aligned in columns.\n * When \"size\" is < 0 then the last entry is marked with NULL.\n * The entry with index \"current\" is inclosed in [].\n */\n    void\nlist_in_columns(char_u **items, int size, int current)\n{\n    int\t\ti;\n    int\t\tncol;\n    int\t\tnrow;\n    int\t\tcur_row = 1;\n    int\t\titem_count = 0;\n    int\t\twidth = 0;\n#ifdef FEAT_SYN_HL\n    int\t\tuse_highlight = (items == (char_u **)features);\n#endif\n\n    // Find the length of the longest item, use that + 1 as the column\n    // width.\n    for (i = 0; size < 0 ? items[i] != NULL : i < size; ++i)\n    {\n\tint l = vim_strsize(items[i]) + (i == current ? 2 : 0);\n\n\tif (l > width)\n\t    width = l;\n\t++item_count;\n    }\n    width += 1;\n\n    if (Columns < width)\n    {\n\t// Not enough screen columns - show one per line\n\tfor (i = 0; i < item_count; ++i)\n\t{\n\t    version_msg_wrap(items[i], i == current);\n\t    if (msg_col > 0 && i < item_count - 1)\n\t\tmsg_putchar('\\n');\n\t}\n\treturn;\n    }\n\n    // The rightmost column doesn't need a separator.\n    // Sacrifice it to fit in one more column if possible.\n    ncol = (int) (Columns + 1) / width;\n    nrow = item_count / ncol + (item_count % ncol ? 1 : 0);\n\n    // \"i\" counts columns then rows.  \"idx\" counts rows then columns.\n    for (i = 0; !got_int && i < nrow * ncol; ++i)\n    {\n\tint idx = (i / ncol) + (i % ncol) * nrow;\n\n\tif (idx < item_count)\n\t{\n\t    int last_col = (i + 1) % ncol == 0;\n\n\t    if (idx == current)\n\t\tmsg_putchar('[');\n#ifdef FEAT_SYN_HL\n\t    if (use_highlight && items[idx][0] == '-')\n\t\tmsg_puts_attr((char *)items[idx], HL_ATTR(HLF_W));\n\t    else\n#endif\n\t\tmsg_puts((char *)items[idx]);\n\t    if (idx == current)\n\t\tmsg_putchar(']');\n\t    if (last_col)\n\t    {\n\t\tif (msg_col > 0 && cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t    else\n\t    {\n\t\twhile (msg_col % width)\n\t\t    msg_putchar(' ');\n\t    }\n\t}\n\telse\n\t{\n\t    // this row is out of items, thus at the end of the row\n\t    if (msg_col > 0)\n\t    {\n\t\tif (cur_row < nrow)\n\t\t    msg_putchar('\\n');\n\t\t++cur_row;\n\t    }\n\t}\n    }\n}\n\n    void\nlist_version(void)\n{\n    int\t\ti;\n    int\t\tfirst;\n    char\t*s = \"\";\n\n    /*\n     * When adding features here, don't forget to update the list of\n     * internal variables in eval.c!\n     */\n    init_longVersion();\n    msg(longVersion);\n#ifdef MSWIN\n# ifdef FEAT_GUI_MSWIN\n#  ifdef VIMDLL\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI/console version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI/console version\"));\n#   endif\n#  else\n#   ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit GUI version\"));\n#   else\n    msg_puts(_(\"\\nMS-Windows 32-bit GUI version\"));\n#   endif\n#  endif\n#  ifdef FEAT_OLE\n    msg_puts(_(\" with OLE support\"));\n#  endif\n# else\n#  ifdef _WIN64\n    msg_puts(_(\"\\nMS-Windows 64-bit console version\"));\n#  else\n    msg_puts(_(\"\\nMS-Windows 32-bit console version\"));\n#  endif\n# endif\n#endif\n#if defined(MACOS_X)\n# if defined(MACOS_X_DARWIN)\n    msg_puts(_(\"\\nmacOS version\"));\n# else\n    msg_puts(_(\"\\nmacOS version w/o darwin feat.\"));\n# endif\n# if defined(__arm64__)\n    msg_puts(\" - arm64\");\n# elif defined(__x86_64__)\n    msg_puts(\" - x86_64\");\n# endif\n#endif\n\n#ifdef VMS\n    msg_puts(_(\"\\nOpenVMS version\"));\n# ifdef HAVE_PATHDEF\n    if (*compiled_arch != NUL)\n    {\n\tmsg_puts(\" - \");\n\tmsg_puts((char *)compiled_arch);\n    }\n# endif\n\n#endif\n\n    // Print the list of patch numbers if there is at least one.\n    // Print a range when patches are consecutive: \"1-10, 12, 15-40, 42-45\"\n    if (included_patches[0] != 0)\n    {\n\tmsg_puts(_(\"\\nIncluded patches: \"));\n\tfirst = -1;\n\ti = (int)ARRAY_LENGTH(included_patches) - 1;\n\twhile (--i >= 0)\n\t{\n\t    if (first < 0)\n\t\tfirst = included_patches[i];\n\t    if (i == 0 || included_patches[i - 1] != included_patches[i] + 1)\n\t    {\n\t\tmsg_puts(s);\n\t\ts = \", \";\n\t\tmsg_outnum((long)first);\n\t\tif (first != included_patches[i])\n\t\t{\n\t\t    msg_puts(\"-\");\n\t\t    msg_outnum((long)included_patches[i]);\n\t\t}\n\t\tfirst = -1;\n\t    }\n\t}\n    }\n\n    // Print the list of extra patch descriptions if there is at least one.\n    if (extra_patches[0] != NULL)\n    {\n\tmsg_puts(_(\"\\nExtra patches: \"));\n\ts = \"\";\n\tfor (i = 0; extra_patches[i] != NULL; ++i)\n\t{\n\t    msg_puts(s);\n\t    s = \", \";\n\t    msg_puts(extra_patches[i]);\n\t}\n    }\n\n#ifdef MODIFIED_BY\n    msg_puts(\"\\n\");\n    msg_puts(_(\"Modified by \"));\n    msg_puts(MODIFIED_BY);\n#endif\n\n#ifdef HAVE_PATHDEF\n    if (*compiled_user != NUL || *compiled_sys != NUL)\n    {\n\tmsg_puts(_(\"\\nCompiled \"));\n\tif (*compiled_user != NUL)\n\t{\n\t    msg_puts(_(\"by \"));\n\t    msg_puts((char *)compiled_user);\n\t}\n\tif (*compiled_sys != NUL)\n\t{\n\t    msg_puts(\"@\");\n\t    msg_puts((char *)compiled_sys);\n\t}\n    }\n#endif\n\n#ifdef FEAT_HUGE\n    msg_puts(_(\"\\nHuge version \"));\n#else\n# ifdef FEAT_BIG\n    msg_puts(_(\"\\nBig version \"));\n# else\n#  ifdef FEAT_NORMAL\n    msg_puts(_(\"\\nNormal version \"));\n#  else\n#   ifdef FEAT_SMALL\n    msg_puts(_(\"\\nSmall version \"));\n#   else\n    msg_puts(_(\"\\nTiny version \"));\n#   endif\n#  endif\n# endif\n#endif\n#ifndef FEAT_GUI\n    msg_puts(_(\"without GUI.\"));\n#else\n# ifdef FEAT_GUI_GTK\n#  ifdef USE_GTK3\n    msg_puts(_(\"with GTK3 GUI.\"));\n#  else\n#   ifdef FEAT_GUI_GNOME\n     msg_puts(_(\"with GTK2-GNOME GUI.\"));\n#   else\n     msg_puts(_(\"with GTK2 GUI.\"));\n#   endif\n# endif\n# else\n#  ifdef FEAT_GUI_MOTIF\n    msg_puts(_(\"with X11-Motif GUI.\"));\n#  else\n#   ifdef FEAT_GUI_ATHENA\n#    ifdef FEAT_GUI_NEXTAW\n    msg_puts(_(\"with X11-neXtaw GUI.\"));\n#    else\n    msg_puts(_(\"with X11-Athena GUI.\"));\n#    endif\n#   else\n#    ifdef FEAT_GUI_HAIKU\n    msg_puts(_(\"with Haiku GUI.\"));\n#    else\n#     ifdef FEAT_GUI_PHOTON\n    msg_puts(_(\"with Photon GUI.\"));\n#     else\n#      if defined(MSWIN)\n    msg_puts(_(\"with GUI.\"));\n#      endif\n#     endif\n#    endif\n#   endif\n#  endif\n# endif\n#endif\n    version_msg(_(\"  Features included (+) or not (-):\\n\"));\n\n    list_features();\n    if (msg_col > 0)\n\tmsg_putchar('\\n');\n\n#ifdef SYS_VIMRC_FILE\n    version_msg(_(\"   system vimrc file: \\\"\"));\n    version_msg(SYS_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE\n    version_msg(_(\"     user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE2\n    version_msg(_(\" 2nd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_VIMRC_FILE3\n    version_msg(_(\" 3rd user vimrc file: \\\"\"));\n    version_msg(USR_VIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE\n    version_msg(_(\"      user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef USR_EXRC_FILE2\n    version_msg(_(\"  2nd user exrc file: \\\"\"));\n    version_msg(USR_EXRC_FILE2);\n    version_msg(\"\\\"\\n\");\n#endif\n#ifdef FEAT_GUI\n# ifdef SYS_GVIMRC_FILE\n    version_msg(_(\"  system gvimrc file: \\\"\"));\n    version_msg(SYS_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n    version_msg(_(\"    user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE);\n    version_msg(\"\\\"\\n\");\n# ifdef USR_GVIMRC_FILE2\n    version_msg(_(\"2nd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE2);\n    version_msg(\"\\\"\\n\");\n# endif\n# ifdef USR_GVIMRC_FILE3\n    version_msg(_(\"3rd user gvimrc file: \\\"\"));\n    version_msg(USR_GVIMRC_FILE3);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n    version_msg(_(\"       defaults file: \\\"\"));\n    version_msg(VIM_DEFAULTS_FILE);\n    version_msg(\"\\\"\\n\");\n#ifdef FEAT_GUI\n# ifdef SYS_MENU_FILE\n    version_msg(_(\"    system menu file: \\\"\"));\n    version_msg(SYS_MENU_FILE);\n    version_msg(\"\\\"\\n\");\n# endif\n#endif\n#ifdef HAVE_PATHDEF\n    if (*default_vim_dir != NUL)\n    {\n\tversion_msg(_(\"  fall-back for $VIM: \\\"\"));\n\tversion_msg((char *)default_vim_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    if (*default_vimruntime_dir != NUL)\n    {\n\tversion_msg(_(\" f-b for $VIMRUNTIME: \\\"\"));\n\tversion_msg((char *)default_vimruntime_dir);\n\tversion_msg(\"\\\"\\n\");\n    }\n    version_msg(_(\"Compilation: \"));\n    version_msg((char *)all_cflags);\n    version_msg(\"\\n\");\n#ifdef VMS\n    if (*compiler_version != NUL)\n    {\n\tversion_msg(_(\"Compiler: \"));\n\tversion_msg((char *)compiler_version);\n\tversion_msg(\"\\n\");\n    }\n#endif\n    version_msg(_(\"Linking: \"));\n    version_msg((char *)all_lflags);\n#endif\n#ifdef DEBUG\n    version_msg(\"\\n\");\n    version_msg(_(\"  DEBUG BUILD\"));\n#endif\n}\n\nstatic void do_intro_line(int row, char_u *mesg, int add_version, int attr);\nstatic void intro_message(int colon);\n\n/*\n * Show the intro message when not editing a file.\n */\n    void\nmaybe_intro_message(void)\n{\n    if (BUFEMPTY()\n\t    && curbuf->b_fname == NULL\n\t    && firstwin->w_next == NULL\n\t    && vim_strchr(p_shm, SHM_INTRO) == NULL)\n\tintro_message(FALSE);\n}\n\n/*\n * Give an introductory message about Vim.\n * Only used when starting Vim on an empty file, without a file name.\n * Or with the \":intro\" command (for Sven :-).\n */\n    static void\nintro_message(\n    int\t\tcolon)\t\t// TRUE for \":intro\"\n{\n    int\t\ti;\n    int\t\trow;\n    int\t\tblanklines;\n    int\t\tsponsor;\n    char\t*p;\n    static char\t*(lines[]) =\n    {\n\tN_(\"VIM - Vi IMproved\"),\n\t\"\",\n\tN_(\"version \"),\n\tN_(\"by Bram Moolenaar et al.\"),\n#ifdef MODIFIED_BY\n\t\" \",\n#endif\n\tN_(\"Vim is open source and freely distributable\"),\n\t\"\",\n\tN_(\"Help poor children in Uganda!\"),\n\tN_(\"type  :help iccf<Enter>       for information \"),\n\t\"\",\n\tN_(\"type  :q<Enter>               to exit         \"),\n\tN_(\"type  :help<Enter>  or  <F1>  for on-line help\"),\n\tN_(\"type  :help version8<Enter>   for version info\"),\n\tNULL,\n\t\"\",\n\tN_(\"Running in Vi compatible mode\"),\n\tN_(\"type  :set nocp<Enter>        for Vim defaults\"),\n\tN_(\"type  :help cp-default<Enter> for info on this\"),\n    };\n#ifdef FEAT_GUI\n    static char\t*(gui_lines[]) =\n    {\n\tNULL,\n\tNULL,\n\tNULL,\n\tNULL,\n#ifdef MODIFIED_BY\n\tNULL,\n#endif\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Help->Orphans           for information    \"),\n\tNULL,\n\tN_(\"Running modeless, typed text is inserted\"),\n\tN_(\"menu  Edit->Global Settings->Toggle Insert Mode  \"),\n\tN_(\"                              for two modes      \"),\n\tNULL,\n\tNULL,\n\tNULL,\n\tN_(\"menu  Edit->Global Settings->Toggle Vi Compatible\"),\n\tN_(\"                              for Vim defaults   \"),\n    };\n#endif\n\n    // blanklines = screen height - # message lines\n    blanklines = (int)Rows - (ARRAY_LENGTH(lines) - 1);\n    if (!p_cp)\n\tblanklines += 4;  // add 4 for not showing \"Vi compatible\" message\n\n    // Don't overwrite a statusline.  Depends on 'cmdheight'.\n    if (p_ls > 1)\n\tblanklines -= Rows - topframe->fr_height;\n    if (blanklines < 0)\n\tblanklines = 0;\n\n    // Show the sponsor and register message one out of four times, the Uganda\n    // message two out of four times.\n    sponsor = (int)time(NULL);\n    sponsor = ((sponsor & 2) == 0) - ((sponsor & 4) == 0);\n\n    // start displaying the message lines after half of the blank lines\n    row = blanklines / 2;\n    if ((row >= 2 && Columns >= 50) || colon)\n    {\n\tfor (i = 0; i < (int)ARRAY_LENGTH(lines); ++i)\n\t{\n\t    p = lines[i];\n#ifdef FEAT_GUI\n\t    if (p_im && gui.in_use && gui_lines[i] != NULL)\n\t\tp = gui_lines[i];\n#endif\n\t    if (p == NULL)\n\t    {\n\t\tif (!p_cp)\n\t\t    break;\n\t\tcontinue;\n\t    }\n\t    if (sponsor != 0)\n\t    {\n\t\tif (strstr(p, \"children\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"Sponsor Vim development!\")\n\t\t\t: N_(\"Become a registered Vim user!\");\n\t\telse if (strstr(p, \"iccf\") != NULL)\n\t\t    p = sponsor < 0\n\t\t\t? N_(\"type  :help sponsor<Enter>    for information \")\n\t\t\t: N_(\"type  :help register<Enter>   for information \");\n\t\telse if (strstr(p, \"Orphans\") != NULL)\n\t\t    p = N_(\"menu  Help->Sponsor/Register  for information    \");\n\t    }\n\t    if (*p != NUL)\n\t\tdo_intro_line(row, (char_u *)_(p), i == 2, 0);\n\t    ++row;\n\t}\n    }\n\n    // Make the wait-return message appear just below the text.\n    if (colon)\n\tmsg_row = row;\n}\n\n    static void\ndo_intro_line(\n    int\t\trow,\n    char_u\t*mesg,\n    int\t\tadd_version,\n    int\t\tattr)\n{\n    char_u\tvers[20];\n    int\t\tcol;\n    char_u\t*p;\n    int\t\tl;\n    int\t\tclen;\n#ifdef MODIFIED_BY\n# define MODBY_LEN 150\n    char_u\tmodby[MODBY_LEN];\n\n    if (*mesg == ' ')\n    {\n\tvim_strncpy(modby, (char_u *)_(\"Modified by \"), MODBY_LEN - 1);\n\tl = (int)STRLEN(modby);\n\tvim_strncpy(modby + l, (char_u *)MODIFIED_BY, MODBY_LEN - l - 1);\n\tmesg = modby;\n    }\n#endif\n\n    // Center the message horizontally.\n    col = vim_strsize(mesg);\n    if (add_version)\n    {\n\tSTRCPY(vers, mediumVersion);\n\tif (highest_patch())\n\t{\n\t    // Check for 9.9x or 9.9xx, alpha/beta version\n\t    if (isalpha((int)vers[3]))\n\t    {\n\t\tint len = (isalpha((int)vers[4])) ? 5 : 4;\n\t\tsprintf((char *)vers + len, \".%d%s\", highest_patch(),\n\t\t\t\t\t\t\t mediumVersion + len);\n\t    }\n\t    else\n\t\tsprintf((char *)vers + 3, \".%d\", highest_patch());\n\t}\n\tcol += (int)STRLEN(vers);\n    }\n    col = (Columns - col) / 2;\n    if (col < 0)\n\tcol = 0;\n\n    // Split up in parts to highlight <> items differently.\n    for (p = mesg; *p != NUL; p += l)\n    {\n\tclen = 0;\n\tfor (l = 0; p[l] != NUL\n\t\t\t && (l == 0 || (p[l] != '<' && p[l - 1] != '>')); ++l)\n\t{\n\t    if (has_mbyte)\n\t    {\n\t\tclen += ptr2cells(p + l);\n\t\tl += (*mb_ptr2len)(p + l) - 1;\n\t    }\n\t    else\n\t\tclen += byte2cells(p[l]);\n\t}\n\tscreen_puts_len(p, l, row, col, *p == '<' ? HL_ATTR(HLF_8) : attr);\n\tcol += clen;\n    }\n\n    // Add the version number to the version line.\n    if (add_version)\n\tscreen_puts(vers, row, col, 0);\n}\n\n/*\n * \":intro\": clear screen, display intro screen and wait for return.\n */\n    void\nex_intro(exarg_T *eap UNUSED)\n{\n    screenclear();\n    intro_message(TRUE);\n    wait_return(TRUE);\n}\n"], "filenames": ["src/findfile.c", "src/normal.c", "src/testdir/test_visual.vim", "src/version.c"], "buggy_code_start_loc": [1737, 3884, 1267, 759], "buggy_code_end_loc": [2122, 3886, 1267, 759], "fixing_code_start_loc": [1738, 3884, 1268, 760], "fixing_code_end_loc": [2130, 3888, 1276, 762], "type": "CWE-122", "message": "vim is vulnerable to Heap-based Buffer Overflow", "other": {"cve": {"id": "CVE-2021-3973", "sourceIdentifier": "security@huntr.dev", "published": "2021-11-19T12:15:09.260", "lastModified": "2022-08-29T18:59:10.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "vim is vulnerable to Heap-based Buffer Overflow"}, {"lang": "es", "value": "vim es vulnerable al desbordamiento del b\u00fafer en la regi\u00f3n Heap de la memoria"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:C/I:C/A:C", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "COMPLETE", "integrityImpact": "COMPLETE", "availabilityImpact": "COMPLETE", "baseScore": 9.3}, "baseSeverity": "HIGH", "exploitabilityScore": 8.6, "impactScore": 10.0, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-122"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:vim:vim:*:*:*:*:*:*:*:*", "versionEndExcluding": "8.2.3611", "matchCriteriaId": "C08F885F-1838-4E03-9BD0-03D3CE86F829"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:34:*:*:*:*:*:*:*", "matchCriteriaId": "A930E247-0B43-43CB-98FF-6CE7B8189835"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2022/01/15/1", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/vim/vim/commit/615ddd5342b50a6878a907062aa471740bd9a847", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/ce6e8609-77c6-4e17-b9fc-a2e5abed052e", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00018.html", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FNXY7T5OORA7UJIMGSJBGHFMU6UZWS6P/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/IH2LS2DXBTYOCWGAKFMBF3HTWWXPBEFL/", "source": "security@huntr.dev", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202208-32", "source": "security@huntr.dev", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/vim/vim/commit/615ddd5342b50a6878a907062aa471740bd9a847"}}