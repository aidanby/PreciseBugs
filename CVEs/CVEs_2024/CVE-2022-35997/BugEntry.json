{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Contains OP to generate sparse crosses.\n#include <assert.h>\n\n#include <limits>\n#include <string>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/platform/fingerprint.h\"\n#include \"tensorflow/core/platform/strong_hash.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\nnamespace {\n// An interface that represents a column with batches.\ntemplate <typename InternalType>\nclass ColumnInterface {\n public:\n  // Returns the number of features in the specified batch.\n  virtual int64_t FeatureCount(int64_t batch) const = 0;\n\n  // Returns the fingerprint of nth feature from the specified batch.\n  virtual InternalType Feature(int64_t batch, int64_t n,\n                               bool strong_hash) const = 0;\n\n  virtual ~ColumnInterface() {}\n};\n\n// A column that is backed by a sparse tensor.\ntemplate <typename InternalType>\nclass SparseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  SparseTensorColumn(const Tensor& values, std::vector<int64_t> feature_counts,\n                     std::vector<int64_t> feature_start_indices)\n      : values_(values),\n        feature_counts_(std::move(feature_counts)),\n        feature_start_indices_(std::move(feature_start_indices)) {\n    CHECK_EQ(feature_counts_.size(), feature_start_indices_.size());\n  }\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return feature_counts_[batch];\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~SparseTensorColumn() override {}\n\n private:\n  const Tensor& values_;\n  std::vector<int64_t> feature_counts_;\n  std::vector<int64_t> feature_start_indices_;\n};\n\n// A column that is backed by a sparse tensor.\ntemplate <typename InternalType>\nclass KeyedSparseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  KeyedSparseTensorColumn(const Tensor& values,\n                          std::vector<int64_t> feature_counts,\n                          std::vector<int64_t> feature_start_indices,\n                          std::vector<int64_t> key)\n      : values_(values),\n        feature_counts_(std::move(feature_counts)),\n        feature_start_indices_(std::move(feature_start_indices)) {\n    DCHECK_EQ(feature_counts_.size(), feature_start_indices_.size());\n    std::memcpy(key_, key.data(), sizeof(key_));\n  }\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return feature_counts_[batch];\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~KeyedSparseTensorColumn() override {}\n\n private:\n  const Tensor& values_;\n  tensorflow::uint64 key_[2];\n  std::vector<int64_t> feature_counts_;\n  std::vector<int64_t> feature_start_indices_;\n};\n\n// InternalType is int64 only when using HashCrosser.\ntemplate <>\nint64_t SparseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                             bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (DT_STRING == values_.dtype())\n    return Fingerprint64(values_.vec<tstring>().data()[start + n]);\n  return values_.vec<int64_t>().data()[start + n];\n}\n\ntemplate <>\nint64_t KeyedSparseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                                  bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (strong_hash) {\n    if (DT_STRING == values_.dtype()) {\n      return StrongKeyedHash(key_, values_.vec<tstring>()(start + n));\n    }\n    return StrongKeyedHash(\n        key_,\n        {reinterpret_cast<const char*>(&values_.vec<int64_t>()(start + n)),\n         sizeof(values_.dtype())});\n  }\n  if (DT_STRING == values_.dtype())\n    return Fingerprint64(values_.vec<tstring>()(start + n));\n  return Fingerprint64(\n      {reinterpret_cast<const char*>(&values_.vec<int64_t>()(start + n)),\n       sizeof(values_.dtype())});\n}\n\n// InternalType is string or StringPiece when using StringCrosser.\ntemplate <>\ntstring SparseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                             bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (DT_STRING == values_.dtype())\n    return values_.vec<tstring>().data()[start + n];\n  return std::to_string(values_.vec<int64_t>().data()[start + n]);\n}\n\ntemplate <>\ntstring KeyedSparseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                                  bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (DT_STRING == values_.dtype())\n    return values_.vec<tstring>().data()[start + n];\n  return std::to_string(values_.vec<int64_t>().data()[start + n]);\n}\n\ntemplate <>\nStringPiece SparseTensorColumn<StringPiece>::Feature(int64_t batch, int64_t n,\n                                                     bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  return values_.vec<tstring>().data()[start + n];\n}\n\ntemplate <>\nStringPiece KeyedSparseTensorColumn<StringPiece>::Feature(\n    int64_t batch, int64_t n, bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  return values_.vec<tstring>().data()[start + n];\n}\n\n// A column that is backed by a dense tensor.\ntemplate <typename InternalType>\nclass DenseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  explicit DenseTensorColumn(const Tensor& tensor) : tensor_(tensor) {}\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return tensor_.dim_size(1);\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~DenseTensorColumn() override {}\n\n private:\n  const Tensor& tensor_;\n};\n\n// A column that is backed by a dense tensor.\ntemplate <typename InternalType>\nclass KeyedDenseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  explicit KeyedDenseTensorColumn(const Tensor& tensor,\n                                  std::vector<int64_t> key)\n      : tensor_(tensor) {\n    std::memcpy(key_, key.data(), sizeof(key_));\n  }\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return tensor_.dim_size(1);\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~KeyedDenseTensorColumn() override {}\n\n private:\n  const Tensor& tensor_;\n  tensorflow::uint64 key_[2];\n};\n\n// InternalType is int64 only when using HashCrosser.\ntemplate <>\nint64_t DenseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                            bool strong_hash) const {\n  if (DT_STRING == tensor_.dtype())\n    return Fingerprint64(tensor_.matrix<tstring>()(batch, n));\n  return tensor_.matrix<int64_t>()(batch, n);\n}\n\ntemplate <>\nint64_t KeyedDenseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                                 bool strong_hash) const {\n  if (strong_hash) {\n    if (DT_STRING == tensor_.dtype()) {\n      return StrongKeyedHash(key_, tensor_.matrix<tstring>()(batch, n));\n    }\n    return StrongKeyedHash(\n        key_,\n        {reinterpret_cast<const char*>(tensor_.matrix<int64_t>()(batch, n)),\n         sizeof(tensor_.dtype())});\n  }\n  if (DT_STRING == tensor_.dtype())\n    return Fingerprint64(tensor_.matrix<tstring>()(batch, n));\n  return tensor_.matrix<int64_t>()(batch, n);\n}\n\n// Internal type is string or StringPiece when using StringCrosser.\ntemplate <>\ntstring DenseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                            bool strong_hash) const {\n  if (DT_STRING == tensor_.dtype()) return tensor_.matrix<tstring>()(batch, n);\n  return std::to_string(tensor_.matrix<int64_t>()(batch, n));\n}\n\ntemplate <>\ntstring KeyedDenseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                                 bool strong_hash) const {\n  if (DT_STRING == tensor_.dtype()) return tensor_.matrix<tstring>()(batch, n);\n  return std::to_string(tensor_.matrix<int64_t>()(batch, n));\n}\n\ntemplate <>\nStringPiece DenseTensorColumn<StringPiece>::Feature(int64_t batch, int64_t n,\n                                                    bool strong_hash) const {\n  return tensor_.matrix<tstring>()(batch, n);\n}\n\ntemplate <>\nStringPiece KeyedDenseTensorColumn<StringPiece>::Feature(\n    int64_t batch, int64_t n, bool strong_hash) const {\n  return tensor_.matrix<tstring>()(batch, n);\n}\n\n// Updates Output tensors with sparse crosses.\ntemplate <typename OutType>\nclass OutputUpdater {\n public:\n  OutputUpdater(const std::vector<int64_t>& output_start_indices,\n                Tensor* indices_out, Tensor* values_out)\n      : output_start_indices_(output_start_indices),\n        indices_out_(indices_out),\n        values_out_(values_out) {}\n\n  void Update(const int64_t batch_index, const int64_t cross_count,\n              const OutType& cross) const {\n    const int64_t output_index =\n        output_start_indices_[batch_index] + cross_count;\n\n    auto indices_matrix = indices_out_->matrix<int64_t>();\n    indices_matrix(output_index, 0) = batch_index;\n    indices_matrix(output_index, 1) = cross_count;\n\n    auto value_vec = values_out_->vec<OutType>();\n    value_vec(output_index) = cross;\n  }\n\n private:\n  const std::vector<int64_t>& output_start_indices_;\n  Tensor* indices_out_;\n  Tensor* values_out_;\n};\n\n// Generates the sparse crosses as concatenation of strings.\ntemplate <typename InternalType>\nclass StringCrosser {\n public:\n  StringCrosser(const std::vector<\n                    std::unique_ptr<ColumnInterface<InternalType>>>& columns,\n                const int64_t num_buckets_unused, const uint64 hash_key_unused,\n                const tstring k_feature_separator)\n      : columns_(columns), k_feature_separator_(k_feature_separator) {}\n\n  string Generate(const int64_t batch_index,\n                  const std::vector<int>& permutation,\n                  bool unused_strong_hash) const {\n    gtl::InlinedVector<InternalType, 6> cross_vec(columns_.size());\n    for (int i = 0; i < permutation.size(); i++) {\n      cross_vec[i] = columns_[i]->Feature(batch_index, permutation[i], false);\n    }\n    // TODO(zakaria): this will copy the string twice, might effect\n    // performance.\n    return absl::StrJoin(cross_vec, k_feature_separator_);\n  }\n\n private:\n  const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns_;\n  const tstring k_feature_separator_;\n};\n\n// Generates the sparse crosses as nested hash to avoid string manipulations.\nclass HashCrosser {\n public:\n  HashCrosser(\n      const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns,\n      const int64_t num_buckets, const uint64 hash_key,\n      const tstring k_feature_separator_unused)\n      : columns_(columns), num_buckets_(num_buckets), hash_key_(hash_key) {}\n\n  int64_t Generate(const int64_t batch_index,\n                   const std::vector<int>& permutation,\n                   bool unused_strong_hash) const {\n    // Do the fingerprint concatenation on uint64.\n    uint64 hashed_output = hash_key_;\n    for (size_t i = 0; i < permutation.size(); ++i) {\n      uint64 hash_i = columns_[i]->Feature(batch_index, permutation[i], false);\n      hashed_output = FingerprintCat64(hashed_output, hash_i);\n    }\n    // The return value is int64 based on the number of buckets.\n    if (num_buckets_ > 0) {\n      return hashed_output % num_buckets_;\n    } else {\n      // To prevent negative output we take modulo to max int64.\n      return hashed_output % std::numeric_limits<int64_t>::max();\n    }\n  }\n\n private:\n  const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns_;\n  const int64_t num_buckets_;\n  const uint64 hash_key_;\n};\n\n// Generates the sparse crosses as nested hash to avoid string manipulations.\nclass HashCrosserV2 {\n public:\n  HashCrosserV2(\n      const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns,\n      const int64_t num_buckets, const uint64 hash_key_unused,\n      const tstring k_feature_separator_unused)\n      : columns_(columns), num_buckets_(num_buckets) {}\n\n  int64_t Generate(const int64_t batch_index,\n                   const std::vector<int>& permutation,\n                   bool strong_hash) const {\n    // Do the fingerprint concatenation on uint64.\n    uint64 hashed_output =\n        columns_[0]->Feature(batch_index, permutation[0], strong_hash);\n    for (size_t i = 1; i < permutation.size(); ++i) {\n      uint64 hash_i =\n          columns_[i]->Feature(batch_index, permutation[i], strong_hash);\n      hashed_output = FingerprintCat64(hashed_output, hash_i);\n    }\n    // The return value is int64 based on the number of buckets.\n    if (num_buckets_ > 0) {\n      return hashed_output % num_buckets_;\n    } else {\n      // To prevent negative output we take modulo to max int64.\n      return hashed_output % std::numeric_limits<int64_t>::max();\n    }\n  }\n\n private:\n  const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns_;\n  const int64_t num_buckets_;\n};\n\n// ProductIterator generates cartesian products based on indices.\ntemplate <typename InternalType>\nclass ProductIterator {\n public:\n  explicit ProductIterator(\n      const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>&\n          columns,\n      int64_t batch_index)\n      : columns_(columns), batch_index_(batch_index) {\n    next_permutation_.resize(columns_.size(), 0);\n    // Sets has_next_ to false if any feature column has 0 features.\n    has_next_ = true;\n    for (int i = 0; i < columns_.size(); i++) {\n      if (columns_[i]->FeatureCount(batch_index_) == 0) {\n        has_next_ = false;\n        break;\n      }\n    }\n  }\n\n  std::vector<int> Next() {\n    std::vector<int> permutation(next_permutation_);\n\n    // Generates next permutation, if available.\n    bool carry = true;\n    for (int i = next_permutation_.size() - 1; i >= 0; i--) {\n      if (carry) {\n        next_permutation_[i] = next_permutation_[i] + 1;\n      }\n      if (next_permutation_[i] == columns_[i]->FeatureCount(batch_index_)) {\n        next_permutation_[i] = 0;\n      } else {\n        carry = false;\n        break;\n      }\n    }\n    has_next_ = !carry;\n    return permutation;\n  }\n\n  bool HasNext() { return has_next_; }\n\n private:\n  bool has_next_;\n  const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns_;\n  const int64_t batch_index_;\n  std::vector<int> next_permutation_;\n};\n\ntemplate <bool HASHED_OUTPUT, typename InternalType>\nstruct CrossTraits;\n\ntemplate <typename InternalType>\nstruct CrossTraits<false, InternalType> {\n  typedef StringCrosser<InternalType> Crosser;\n  typedef StringCrosser<InternalType> CrosserV2;\n  typedef OutputUpdater<tstring> Updater;\n};\n\ntemplate <>\nstruct CrossTraits<true, int64_t> {\n  typedef HashCrosser Crosser;\n  typedef HashCrosserV2 CrosserV2;\n  typedef OutputUpdater<int64_t> Updater;\n};\n}  // namespace\n\n// Calculate the batch size from either the shapes input or the dense input.\nint64_t CalculateBatchSize(const OpInputList& shapes_list_in,\n                           const OpInputList& dense_list_in) {\n  if (shapes_list_in.size() > 0) {\n    return shapes_list_in[0].vec<int64_t>()(0);\n  }\n\n  if (dense_list_in.size() > 0) {\n    return dense_list_in[0].dim_size(0);\n  }\n\n  return 0;\n}\n\n// Validates input tensors.\nStatus ValidateInput(const OpInputList& indices_list_in,\n                     const OpInputList& values_list_in,\n                     const OpInputList& shapes_list_in,\n                     const OpInputList& dense_list_in,\n                     const DataType& internal_type) {\n  const auto size = indices_list_in.size();\n  // Only perform internal_type check for SparseCrossOp.\n  // Check if the internal_type is not invalid before doing so.\n  bool check_type = internal_type != DT_INVALID;\n  // Validates indices_list_in OpInputList.\n  for (int i = 0; i < size; i++) {\n    if (check_type && indices_list_in[i].dtype() != DT_INT64) {\n      return errors::InvalidArgument(\"Input indices should be of type \",\n                                     DT_INT64, \" but received \",\n                                     indices_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input indices should be a matrix but received shape \",\n          indices_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(1) != 2) {\n      return errors::InvalidArgument(\"Expected D2 of index to be 2 got \",\n                                     indices_list_in[i].shape().dim_size(1),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates values_list_in OpInputList.\n  if (values_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input values, got \",\n                                   values_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    // Make sure to avoid the expected type to be string, but input values to be\n    // int64.\n    if (check_type && internal_type == DT_STRING &&\n        values_list_in[i].dtype() == DT_INT64) {\n      return errors::InvalidArgument(\"Input values should be of internal type \",\n                                     internal_type, \" but received \",\n                                     values_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input values should be a vector but received shape \",\n          values_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(0) !=\n        values_list_in[i].shape().dim_size(0)) {\n      return errors::InvalidArgument(\n          \"Expected size of values to be \",\n          indices_list_in[i].shape().dim_size(0), \" got \",\n          values_list_in[i].shape().dim_size(0), \" at position \", i);\n    }\n  }\n\n  // Validates shapes_list_in OpInputList\n  if (shapes_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input shapes, got \",\n                                   shapes_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {\n      return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,\n                                     \" but received \",\n                                     shapes_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input shapes should be a vector but received shape \",\n          shapes_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n\n    if (shapes_list_in[i].vec<int64_t>().size() != 2) {\n      return errors::InvalidArgument(\"shape should imply a 2D tensor, but got \",\n                                     shapes_list_in[i].shape().DebugString(),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates dense_list_in OpInputList\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    // Make sure to avoid the expected type to be string, but input values to be\n    // int64.\n    if (check_type && internal_type == DT_STRING &&\n        dense_list_in[i].dtype() == DT_INT64) {\n      return errors::InvalidArgument(\"Dense inputs should be of internal type \",\n                                     internal_type, \" but received \",\n                                     dense_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Dense inputs should be a matrix but received shape \",\n          dense_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n  }\n\n  // Validates batch sizes.  (Note: we do this after validating the input\n  // shapes, because CalculateBatchSize() depends on inputs having valid\n  // shapes).\n  const auto batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  for (int i = 0; i < size; i++) {\n    if (shapes_list_in[i].vec<int64_t>()(0) != batch_size) {\n      return errors::InvalidArgument(\n          \"Expected batch size \", batch_size, \" got \",\n          shapes_list_in[i].vec<int64_t>()(0), \" at position \", i);\n    }\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    if (dense_list_in[i].dim_size(0) != batch_size) {\n      return errors::InvalidArgument(\"Expected batch size \", batch_size,\n                                     \" got \", dense_list_in[i].dim_size(0),\n                                     \" at dense tensor \", i);\n    }\n  }\n\n  return OkStatus();\n}\n\n// Extracts data about the features and populates feature data.\nvoid ExtractFeatureData(\n    const OpInputList& indices_list_in, int64_t batch_size,\n    std::vector<std::vector<int64_t>>* feature_counts,\n    std::vector<std::vector<int64_t>>* feature_start_indices) {\n  gtl::InlinedVector<int64_t, 8> current_row(indices_list_in.size(), 0);\n  for (int b = 0; b < batch_size; b++) {\n    for (int i = 0; i < indices_list_in.size(); i++) {\n      const auto indices = indices_list_in[i].matrix<int64_t>();\n      int64_t feature_count = 0;\n      int64_t start_index = current_row[i];\n      // Loops until we reach next batch index for current feature column.\n      while (current_row[i] < indices_list_in[i].dim_size(0) &&\n             indices(current_row[i], 0) == b) {\n        feature_count++;\n        current_row[i]++;\n      }\n      (*feature_counts)[i].push_back(feature_count);\n      (*feature_start_indices)[i].push_back(start_index);\n    }\n  }\n}\n\n// Returns number of crosses for a given batch_index\ntemplate <typename InternalType>\nint64_t CrossCountByBatchIndex(\n    const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns,\n    int batch_index) {\n  int64_t cross_count = 1;\n  for (int i = 0; i < columns.size(); i++) {\n    const auto feature_count = columns[i]->FeatureCount(batch_index);\n    // If one column is missing any feature, there won't be any cross.\n    if (feature_count == 0) {\n      return 0;\n    }\n    cross_count *= feature_count;\n  }\n  return cross_count;\n}\n\n// Generate the columns given the sparse and dense inputs.\ntemplate <typename InternalType>\nstd::vector<std::unique_ptr<ColumnInterface<InternalType>>>\nGenerateColumnsFromInput(const OpInputList& indices_list_in,\n                         const OpInputList& values_list_in,\n                         const OpInputList& shapes_list_in,\n                         const OpInputList& dense_list_in) {\n  std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns;\n  const int64_t batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  const int64_t number_of_columns = shapes_list_in.size();\n\n  std::vector<std::vector<int64_t>> feature_counts(number_of_columns,\n                                                   std::vector<int64_t>());\n  std::vector<std::vector<int64_t>> feature_start_indices(\n      number_of_columns, std::vector<int64_t>());\n\n  ExtractFeatureData(indices_list_in, batch_size, &feature_counts,\n                     &feature_start_indices);\n\n  columns.reserve(values_list_in.size());\n  for (int i = 0; i < values_list_in.size(); ++i) {\n    columns.emplace_back(new SparseTensorColumn<InternalType>(\n        values_list_in[i], std::move(feature_counts[i]),\n        std::move(feature_start_indices[i])));\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    columns.emplace_back(new DenseTensorColumn<InternalType>(dense_list_in[i]));\n  }\n\n  return columns;\n}\n\n// Generate the columns given the sparse and dense inputs.\ntemplate <typename InternalType>\nstd::vector<std::unique_ptr<ColumnInterface<InternalType>>>\nGenerateKeyedColumnsFromInput(const OpInputList& indices_list_in,\n                              const OpInputList& values_list_in,\n                              const OpInputList& shapes_list_in,\n                              const OpInputList& dense_list_in,\n                              std::vector<int64_t> keys) {\n  std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns;\n  const int64_t batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  const int64_t number_of_columns = shapes_list_in.size();\n\n  std::vector<std::vector<int64_t>> feature_counts(number_of_columns,\n                                                   std::vector<int64_t>());\n  std::vector<std::vector<int64_t>> feature_start_indices(\n      number_of_columns, std::vector<int64_t>());\n\n  ExtractFeatureData(indices_list_in, batch_size, &feature_counts,\n                     &feature_start_indices);\n\n  columns.reserve(values_list_in.size());\n  for (int i = 0; i < values_list_in.size(); ++i) {\n    columns.emplace_back(new KeyedSparseTensorColumn<InternalType>(\n        values_list_in[i], std::move(feature_counts[i]),\n        std::move(feature_start_indices[i]), keys));\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    columns.emplace_back(\n        new KeyedDenseTensorColumn<InternalType>(dense_list_in[i], keys));\n  }\n\n  return columns;\n}\n\n// Allocates output tensors with proper size and sets the shape tensor of\n// the output SparseTensor.\n// It also output_start_indices which contains the start indices for each\n// input in the output SparseTensor.\ntemplate <typename InternalType>\nStatus CreateOutputTensors(\n    const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns,\n    int64_t batch_size, OpKernelContext* context, Tensor** indices_out,\n    Tensor** values_out, Tensor** shape_out,\n    std::vector<int64_t>* output_start_indices) {\n  // Calculates dimensions for output tensors.\n  int64_t cross_count_total = 0;\n  int64_t max_cross_count = 0;\n  for (int64_t b = 0; b < batch_size; b++) {\n    // For each input, sets starting indices in output SparseTensor\n    (*output_start_indices)[b] = cross_count_total;\n    const auto cross_count = CrossCountByBatchIndex(columns, b);\n    max_cross_count = std::max(max_cross_count, cross_count);\n    cross_count_total += cross_count;\n  }\n\n  // Allocates tensors.\n  TF_RETURN_IF_ERROR(context->allocate_output(\n      0, TensorShape({cross_count_total, 2}), indices_out));\n  TF_RETURN_IF_ERROR(context->allocate_output(\n      1, TensorShape({cross_count_total}), values_out));\n  TF_RETURN_IF_ERROR(context->allocate_output(2, TensorShape({2}), shape_out));\n\n  // Sets shape.\n  auto shape_vec = (*shape_out)->vec<int64_t>();\n  shape_vec(0) = batch_size;\n  shape_vec(1) = max_cross_count;\n\n  return OkStatus();\n}\n\ntemplate <bool HASHED_OUTPUT, typename InternalType>\nclass SparseCrossOp : public OpKernel {\n public:\n  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    // Read signed_hash_key_ as int64 since uint64 attributes are not\n    // supported by REGISTER_OP.\n    int64_t signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    DataType internal_type = internal_type_;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n        GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in);\n\n    const tstring k_feature_separator = \"_X_\";\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(\n        columns, num_buckets_, hash_key_, k_feature_separator);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64_t batch_size =\n        CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64_t> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Updater updater(\n        output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater](int64_t begin, int64_t end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<InternalType> product_iterator(columns, b);\n        int64_t cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }\n\n private:\n  int64_t num_buckets_;\n  uint64 hash_key_;\n  DataType internal_type_;\n};\n\nclass SparseCrossV2Op : public OpKernel {\n public:\n  explicit SparseCrossV2Op(OpKernelConstruction* context) : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    // Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    const tstring separator = sep_t->scalar<tstring>()();\n\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64_t batch_size =\n        CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64_t> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64_t begin, int64_t end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64_t cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }\n};\n\nclass SparseCrossHashedOp : public OpKernel {\n public:\n  explicit SparseCrossHashedOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    // Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64_t num_buckets = num_buckets_t->scalar<int64_t>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;\n    OP_REQUIRES_OK(context, context->input(\"salt\", &salt_t));\n    const auto salt = salt_t->flat<int64_t>();\n    std::vector<int64_t> key_{salt(0), salt(1)};\n\n    std::vector<std::unique_ptr<ColumnInterface<int64_t>>> columns =\n        GenerateKeyedColumnsFromInput<int64_t>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in,\n                                               key_);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64_t batch_size =\n        CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64_t> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    const tstring unused_sep;\n    HashCrosserV2 crosser(columns, num_buckets, 0, unused_sep);\n    OutputUpdater<int64_t> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater, strong_hash](int64_t begin,\n                                                             int64_t end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<int64_t> product_iterator(columns, b);\n        int64_t cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, strong_hash));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<tstring>(\"out_type\")\n                            .TypeConstraint<tstring>(\"internal_type\"),\n                        SparseCrossOp<false, StringPiece>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<tstring>(\"out_type\")\n                            .TypeConstraint<int64_t>(\"internal_type\"),\n                        SparseCrossOp<false, tstring>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<int64_t>(\"out_type\")\n                            .TypeConstraint<tstring>(\"internal_type\"),\n                        SparseCrossOp<true, int64>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<int64_t>(\"out_type\")\n                            .TypeConstraint<int64_t>(\"internal_type\"),\n                        SparseCrossOp<true, int64>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCrossV2\").Device(DEVICE_CPU),\n                        SparseCrossV2Op);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCrossHashed\").Device(DEVICE_CPU),\n                        SparseCrossHashedOp);\n\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for sparse_cross_op.\"\"\"\n\nimport numpy\n\nfrom tensorflow.python.client import session\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_sparse_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import test\n\n\nclass BaseSparseCrossOpTest(test.TestCase):\n\n  def _sparse_tensor(self, data, batch_size=-1):\n    \"\"\"Generates a SparseTensor.\n\n    Args:\n      data: Should be a list of list of strings or int64. Each item of the outer\n        list represents a batch. Each item of the batch is a feature of a\n        specific feature column.\n      batch_size: optional batch size, especially for cases when data has no\n        entry for some batches.\n\n    Returns:\n     A SparseTensor.\n    \"\"\"\n    indices = []\n    values = []\n    max_col_count = 0\n    for batch, batch_ix in zip(data, range(len(data))):\n      for column, column_ix in zip(batch, range(len(batch))):\n        indices.append([batch_ix, column_ix])\n        values.append(column)\n        max_col_count = max(max_col_count, column_ix + 1)\n    shape = [batch_size if batch_size != -1 else len(data), max_col_count]\n    value_type = (\n        dtypes.string\n        if not values or isinstance(values[0], str) else dtypes.int64)\n    return sparse_tensor.SparseTensor(\n        constant_op.constant(indices, dtypes.int64, [len(indices), 2]),\n        constant_op.constant(values, value_type, [len(indices)]),\n        constant_op.constant(shape, dtypes.int64))\n\n  def _assert_sparse_tensor_equals(self, sp1, sp2):\n    self.assertAllEqual(sp1.indices, sp2.indices)\n    self.assertAllEqual(sp1.values, sp2.values)\n    self.assertAllEqual(sp1.dense_shape, sp2.dense_shape)\n\n  def _assert_sparse_tensor_empty(self, sp):\n    self.assertEqual(0, sp.indices.size)\n    self.assertEqual(0, sp.values.size)\n    # TODO(zakaria): check if we can ignore the first dim of the shape.\n    self.assertEqual(0, sp.dense_shape[1])\n\n\nclass SparseCrossOpTest(test.TestCase):\n\n  @test_util.run_deprecated_v1\n  def test_simple(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1'],\n                             ['batch2-FC1-F1', 'batch2-FC1-F2']]),\n        self._sparse_tensor([['batch1-FC2-F1'],\n                             ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    ])\n    expected_out = self._sparse_tensor([['batch1-FC1-F1_X_batch1-FC2-F1'], [\n        'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n        'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_dense(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                              ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                             dtypes.string),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1', 'batch1-FC1-F2_X_batch1-FC2-F2'\n    ], [\n        'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n        'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_sparse(self):\n    \"\"\"Tests mixed type.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([[11], [333, 55555]]),\n        self._sparse_tensor([['batch1-FC2-F1'],\n                             ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    ])\n    expected_out = self._sparse_tensor([['11_X_batch1-FC2-F1'], [\n        '333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2', '55555_X_batch2-FC2-F1',\n        '55555_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_dense(self):\n    \"\"\"Tests mixed dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        constant_op.constant([[11, 333], [55555, 999999]], dtypes.int64),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor([[\n        '11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2', '333_X_batch1-FC2-F1',\n        '333_X_batch1-FC2-F2'\n    ], [\n        '55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2',\n        '999999_X_batch2-FC2-F1', '999999_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_cross_dense(self):\n    \"\"\"Tests sparse and dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1'],\n                             ['batch2-FC1-F1', 'batch2-FC1-F2']]),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor(\n        [['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2'], [\n            'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n            'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_sparse_input(self):\n    \"\"\"Tests mixed type sparse and dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([[11], [333, 5555]]),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor(\n        [['11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2'], [\n            '333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2',\n            '5555_X_batch2-FC2-F1', '5555_X_batch2-FC2-F2'\n        ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x3x3(self):\n    \"\"\"Tests 3x3x3 permutation.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(\n            [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n        self._sparse_tensor(\n            [['batch1-FC2-F1', 'batch1-FC2-F2', 'batch1-FC2-F3']]),\n        self._sparse_tensor(\n            [['batch1-FC3-F1', 'batch1-FC3-F2', 'batch1-FC3-F3']])\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F3'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(\n            [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n        self._sparse_tensor([['batch1-FC2-F1']]),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_large_batch(self):\n    \"\"\"Tests with large batch size to force multithreading.\"\"\"\n    batch_size = 5000\n    col1 = []\n    col2 = []\n    col3 = []\n    for b in range(batch_size):\n      col1.append(\n          ['batch%d-FC1-F1' % b, 'batch%d-FC1-F2' % b, 'batch%d-FC1-F3' % b])\n      col2.append(['batch%d-FC2-F1' % b])\n      col3.append(['batch%d-FC3-F1' % b, 'batch%d-FC3-F2' % b])\n\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(col1),\n        self._sparse_tensor(col2),\n        self._sparse_tensor(col3)\n    ])\n\n    col_out = []\n    for b in range(batch_size):\n      col_out.append([\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b)\n      ])\n\n    expected_out = self._sparse_tensor(col_out)\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_one_column_empty(self):\n    \"\"\"Tests when one column is empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']]),\n        self._sparse_tensor([], 1),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    ])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_empty(self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_some_columns_empty(self):\n    \"\"\"Tests when more than one columns are empty.\n\n    Cross for the corresponding batch should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']], 2),\n        self._sparse_tensor([['batch1-FC2-F1'], ['batch2-FC2-F1']], 2),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']], 2)\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]], 2)\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_all_columns_empty(self):\n    \"\"\"Tests when all columns are empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([]),\n        self._sparse_tensor([]),\n        self._sparse_tensor([])\n    ])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_empty(self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket_no_hash_key(self):\n    op = sparse_ops.sparse_cross_hashed([\n        self._sparse_tensor([['batch1-FC1-F1']]),\n        self._sparse_tensor([['batch1-FC2-F1']]),\n        self._sparse_tensor([['batch1-FC3-F1']])\n    ])\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[1971693436396284976]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[4847552627144134031]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  # TODO(sibyl-Aix6ihai): Add benchmark to compare Hashed vs Non-hashed.\n  @test_util.run_deprecated_v1\n  def test_hashed_no_hash_key(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        num_buckets=100)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[83]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_output(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        num_buckets=100,\n        hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[31]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed__has_no_collision(self):\n    \"\"\"Tests that fingerprint concatenation has no collisions.\"\"\"\n    # Although the last 10 bits of 359 and 1024+359 are identical.\n    # As a result, all the crosses shouldn't collide.\n    t1 = constant_op.constant([[359], [359 + 1024]])\n    t2 = constant_op.constant([list(range(10)), list(range(10))])\n    cross = sparse_ops.sparse_cross_hashed(\n        [t2, t1], num_buckets=1024, hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    cross_dense = sparse_ops.sparse_tensor_to_dense(cross)\n    with session.Session():\n      values = self.evaluate(cross_dense)\n      self.assertTrue(numpy.not_equal(values[0], values[1]).all())\n\n  def test_hashed_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation with hashed output.\"\"\"\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor(\n                [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n        ],\n        num_buckets=1000)\n    with self.cached_session() as sess:\n      out = self.evaluate(op)\n      self.assertEqual(6, len(out.values))\n      self.assertAllEqual([[0, i] for i in range(6)], out.indices)\n      self.assertTrue(all(x < 1000 and x >= 0 for x in out.values))\n      all_values_are_different = len(out.values) == len(set(out.values))\n      self.assertTrue(all_values_are_different)\n\n  def _assert_sparse_tensor_empty(self, sp):\n    self.assertEqual(0, sp.indices.size)\n    self.assertEqual(0, sp.values.size)\n    # TODO(zakaria): check if we can ignore the first dim of the shape.\n    self.assertEqual(0, sp.dense_shape[1])\n\n  def _assert_sparse_tensor_equals(self, sp1, sp2):\n    self.assertAllEqual(sp1.indices, sp2.indices)\n    self.assertAllEqual(sp1.values, sp2.values)\n    self.assertAllEqual(sp1.dense_shape, sp2.dense_shape)\n\n  def _sparse_tensor(self, data, batch_size=-1):\n    \"\"\"Generates a SparseTensor.\n\n    Args:\n      data: Should be a list of list of strings or int64. Each item of the outer\n          list represents a batch. Each item of the batch is a feature of a\n          specific feature column.\n      batch_size: optional batch size, especially for cases when data has no\n          entry for some batches.\n\n    Returns:\n     A SparseTensor.\n    \"\"\"\n    indices = []\n    values = []\n    max_col_count = 0\n    for batch, batch_ix in zip(data, range(len(data))):\n      for column, column_ix in zip(batch, range(len(batch))):\n        indices.append([batch_ix, column_ix])\n        values.append(column)\n        max_col_count = max(max_col_count, column_ix + 1)\n    shape = [batch_size if batch_size != -1 else len(data), max_col_count]\n    value_type = (dtypes.string if not values or isinstance(values[0], str) else\n                  dtypes.int64)\n    return sparse_tensor.SparseTensor(\n        constant_op.constant(indices, dtypes.int64, [len(indices), 2]),\n        constant_op.constant(values, value_type, [len(indices)]),\n        constant_op.constant(shape, dtypes.int64))\n\n  def test_invalid_sparse_tensors(self):\n    # Test validation of invalid SparseTensors.  The SparseTensor constructor\n    # prevents us from creating invalid SparseTensors (eps. in eager mode),\n    # so we create valid SparseTensors and then modify them to be invalid.\n\n    st1 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st1._indices = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input indices should be a matrix'):\n      self.evaluate(sparse_ops.sparse_cross([st1]))\n\n    st2 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st2._values = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input values should be a vector'):\n      self.evaluate(sparse_ops.sparse_cross([st2]))\n\n    st3 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st3._dense_shape = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input shapes should be a vector'):\n      self.evaluate(sparse_ops.sparse_cross([st3]))\n\n  def test_bad_tensor_shapes(self):\n    # All inputs must be 2D.\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected D2 of index to be 2'):\n      st = sparse_tensor.SparseTensor([[0]], [0], [10])  # 1D SparseTensor\n      self.evaluate(sparse_ops.sparse_cross([st]))\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Dense inputs should be a matrix'):\n      dt = array_ops.zeros([0])  # 1D DenseTensor.\n      self.evaluate(sparse_ops.sparse_cross([dt]))\n\n  def test_batch_size_mismatch(self):\n    st1 = sparse_tensor.SparseTensor([[0, 0]], [0], [10, 10])  # batch size 10\n    st2 = sparse_tensor.SparseTensor([[0, 0]], [0], [7, 10])  # batch size 7\n    dt = array_ops.zeros([5, 0])  # batch size 5\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected batch size'):\n      self.evaluate(sparse_ops.sparse_cross([st1, dt]))\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected batch size'):\n      self.evaluate(sparse_ops.sparse_cross([st1, st2]))\n\n\nclass SparseCrossV2OpTest(BaseSparseCrossOpTest):\n\n  @test_util.run_deprecated_v1\n  def test_sparse(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],\n                                    ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_X_batch1-FC2-F1'],\n        ['batch2-FC1-F1_X_batch2-FC2-F1',\n         'batch2-FC1-F1_X_batch2-FC2-F2',\n         'batch2-FC1-F2_X_batch2-FC2-F1',\n         'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_sep(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],\n                                    ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_Y_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_Y_batch1-FC2-F1'],\n        ['batch2-FC1-F1_Y_batch2-FC2-F1',\n         'batch2-FC1-F1_Y_batch2-FC2-F2',\n         'batch2-FC1-F2_Y_batch2-FC2-F1',\n         'batch2-FC1-F2_Y_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_dense(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                                        ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                                       dtypes.string)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2',\n         'batch1-FC1-F2_X_batch1-FC2-F1', 'batch1-FC1-F2_X_batch1-FC2-F2'\n        ],\n        ['batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n         'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_dense_sep(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                                        ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                                       dtypes.string)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_batch1-FC2-F1', 'batch1-FC1-F1_batch1-FC2-F2',\n         'batch1-FC1-F2_batch1-FC2-F1', 'batch1-FC1-F2_batch1-FC2-F2'\n        ],\n        ['batch2-FC1-F1_batch2-FC2-F1', 'batch2-FC1-F1_batch2-FC2-F2',\n         'batch2-FC1-F2_batch2-FC2-F1', 'batch2-FC1-F2_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_sparse(self):\n    \"\"\"Tests mixed type.\"\"\"\n    sp_inp_1 = self._sparse_tensor([[11], [333, 55555]])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['11_X_batch1-FC2-F1'],\n        ['333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2',\n         '55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_dense(self):\n    \"\"\"Tests mixed dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([[11, 333], [55555, 999999]],\n                                       dtypes.int64)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2',\n         '333_X_batch1-FC2-F1', '333_X_batch1-FC2-F2'\n        ],\n        ['55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2',\n         '999999_X_batch2-FC2-F1', '999999_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_cross_dense(self):\n    \"\"\"Tests sparse and dense inputs.\"\"\"\n    sp_inp = self._sparse_tensor([['batch1-FC1-F1'],\n                                  ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    dense_inp = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                      ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                     dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp.indices],\n        values=[sp_inp.values],\n        shapes=[sp_inp.dense_shape],\n        dense_inputs=[dense_inp],\n        sep='_X_')\n    expected_out = self._sparse_tensor(\n        [['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2'],\n         [\n             'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n             'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n         ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x3x3(self):\n    \"\"\"Tests 3x3x3 permutation.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor(\n        [['batch1-FC2-F1', 'batch1-FC2-F2', 'batch1-FC2-F3']])\n    sp_inp_3 = self._sparse_tensor(\n        [['batch1-FC3-F1', 'batch1-FC3-F2', 'batch1-FC3-F3']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F3'\n    ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_large_batch(self):\n    \"\"\"Tests with large batch size to force multithreading.\"\"\"\n    batch_size = 5000\n    col1 = []\n    col2 = []\n    col3 = []\n    for b in range(batch_size):\n      col1.append(\n          ['batch%d-FC1-F1' % b,\n           'batch%d-FC1-F2' % b,\n           'batch%d-FC1-F3' % b])\n      col2.append(['batch%d-FC2-F1' % b])\n      col3.append(['batch%d-FC3-F1' % b, 'batch%d-FC3-F2' % b])\n    sp_inp_1 = self._sparse_tensor(col1)\n    sp_inp_2 = self._sparse_tensor(col2)\n    sp_inp_3 = self._sparse_tensor(col3)\n\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n\n    col_out = []\n    for b in range(batch_size):\n      col_out.append([\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b)\n      ])\n\n    expected_out = self._sparse_tensor(col_out)\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_one_column_empty(self):\n    \"\"\"Tests when one column is empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([], 1)\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_empty(self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_some_columns_empty(self):\n    \"\"\"Tests when more than one columns are empty.\n\n    Cross for the corresponding batch should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']], 2)\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'], ['batch2-FC2-F1']], 2)\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']], 2)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]], 2)\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_all_columns_empty(self):\n    \"\"\"Tests when all columns are empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([])\n    sp_inp_2 = self._sparse_tensor([])\n    sp_inp_3 = self._sparse_tensor([])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_empty(self.evaluate(out))\n\n\nclass SparseCrossHashedOpTest(BaseSparseCrossOpTest):\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket_no_hash_key(self):\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=0,\n        salt=[1, 1],\n        strong_hash=False)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[9186962005966787372]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n    # salt is not being used when `strong_hash` is False.\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=0,\n        salt=[137, 173],\n        strong_hash=False)\n    out_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out_2))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_output(self):\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=100,\n        salt=[137, 173],\n        strong_hash=False)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[79]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_has_no_collision(self):\n    \"\"\"Tests that fingerprint concatenation has no collisions.\"\"\"\n    # Although the last 10 bits of 359 and 1024+359 are identical.\n    # As a result, all the crosses shouldn't collide.\n    t1 = constant_op.constant([[359], [359 + 1024]], dtype=dtypes.int64)\n    t2 = constant_op.constant(\n        [list(range(10)), list(range(10))], dtype=dtypes.int64)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[t2, t1],\n        num_buckets=1024,\n        salt=[137, 173],\n        strong_hash=False)\n    cross = sparse_tensor.SparseTensor(inds, vals, shapes)\n    cross_dense = sparse_ops.sparse_tensor_to_dense(cross)\n    with session.Session():\n      values = self.evaluate(cross_dense)\n      self.assertTrue(numpy.not_equal(values[0], values[1]).all())\n\n  def test_hashed_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation with hashed output.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=1000,\n        salt=[137, 173],\n        strong_hash=False)\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      out = self.evaluate(output)\n      self.assertEqual(6, len(out.values))\n      self.assertAllEqual([[0, i] for i in range(6)], out.indices)\n      self.assertTrue(all(x < 1000 and x >= 0 for x in out.values))\n      all_values_are_different = len(out.values) == len(set(out.values))\n      self.assertTrue(all_values_are_different)\n\n  def test_hashed_different_salt(self):\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=False,\n        num_buckets=1000,\n        salt=[137, 173])\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 1])\n    output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      out = self.evaluate(output)\n      out_2 = self.evaluate(output_2)\n      self.assertAllEqual(out.indices, out_2.indices)\n      self.assertNotAllEqual(out.values, out_2.values)\n\n  def test_sep_ignored_in_hashed_out(self):\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 173])\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 173])\n    output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      out = self.evaluate(output)\n      out_2 = self.evaluate(output_2)\n      self.assertAllEqual(out.indices, out_2.indices)\n      self.assertAllEqual(out.values, out_2.values)\n\n\nif __name__ == '__main__':\n  test.main()\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n// Contains OP to generate sparse crosses.\n#include <assert.h>\n\n#include <limits>\n#include <string>\n#include <vector>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op_def_builder.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/op_requires.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/framework/types.pb.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/lib/strings/str_util.h\"\n#include \"tensorflow/core/platform/errors.h\"\n#include \"tensorflow/core/platform/fingerprint.h\"\n#include \"tensorflow/core/platform/strong_hash.h\"\n#include \"tensorflow/core/util/work_sharder.h\"\n\nnamespace tensorflow {\n\nnamespace {\n// An interface that represents a column with batches.\ntemplate <typename InternalType>\nclass ColumnInterface {\n public:\n  // Returns the number of features in the specified batch.\n  virtual int64_t FeatureCount(int64_t batch) const = 0;\n\n  // Returns the fingerprint of nth feature from the specified batch.\n  virtual InternalType Feature(int64_t batch, int64_t n,\n                               bool strong_hash) const = 0;\n\n  virtual ~ColumnInterface() {}\n};\n\n// A column that is backed by a sparse tensor.\ntemplate <typename InternalType>\nclass SparseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  SparseTensorColumn(const Tensor& values, std::vector<int64_t> feature_counts,\n                     std::vector<int64_t> feature_start_indices)\n      : values_(values),\n        feature_counts_(std::move(feature_counts)),\n        feature_start_indices_(std::move(feature_start_indices)) {\n    CHECK_EQ(feature_counts_.size(), feature_start_indices_.size());\n  }\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return feature_counts_[batch];\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~SparseTensorColumn() override {}\n\n private:\n  const Tensor& values_;\n  std::vector<int64_t> feature_counts_;\n  std::vector<int64_t> feature_start_indices_;\n};\n\n// A column that is backed by a sparse tensor.\ntemplate <typename InternalType>\nclass KeyedSparseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  KeyedSparseTensorColumn(const Tensor& values,\n                          std::vector<int64_t> feature_counts,\n                          std::vector<int64_t> feature_start_indices,\n                          std::vector<int64_t> key)\n      : values_(values),\n        feature_counts_(std::move(feature_counts)),\n        feature_start_indices_(std::move(feature_start_indices)) {\n    DCHECK_EQ(feature_counts_.size(), feature_start_indices_.size());\n    std::memcpy(key_, key.data(), sizeof(key_));\n  }\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return feature_counts_[batch];\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~KeyedSparseTensorColumn() override {}\n\n private:\n  const Tensor& values_;\n  tensorflow::uint64 key_[2];\n  std::vector<int64_t> feature_counts_;\n  std::vector<int64_t> feature_start_indices_;\n};\n\n// InternalType is int64 only when using HashCrosser.\ntemplate <>\nint64_t SparseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                             bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (DT_STRING == values_.dtype())\n    return Fingerprint64(values_.vec<tstring>().data()[start + n]);\n  return values_.vec<int64_t>().data()[start + n];\n}\n\ntemplate <>\nint64_t KeyedSparseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                                  bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (strong_hash) {\n    if (DT_STRING == values_.dtype()) {\n      return StrongKeyedHash(key_, values_.vec<tstring>()(start + n));\n    }\n    return StrongKeyedHash(\n        key_,\n        {reinterpret_cast<const char*>(&values_.vec<int64_t>()(start + n)),\n         sizeof(values_.dtype())});\n  }\n  if (DT_STRING == values_.dtype())\n    return Fingerprint64(values_.vec<tstring>()(start + n));\n  return Fingerprint64(\n      {reinterpret_cast<const char*>(&values_.vec<int64_t>()(start + n)),\n       sizeof(values_.dtype())});\n}\n\n// InternalType is string or StringPiece when using StringCrosser.\ntemplate <>\ntstring SparseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                             bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (DT_STRING == values_.dtype())\n    return values_.vec<tstring>().data()[start + n];\n  return std::to_string(values_.vec<int64_t>().data()[start + n]);\n}\n\ntemplate <>\ntstring KeyedSparseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                                  bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  if (DT_STRING == values_.dtype())\n    return values_.vec<tstring>().data()[start + n];\n  return std::to_string(values_.vec<int64_t>().data()[start + n]);\n}\n\ntemplate <>\nStringPiece SparseTensorColumn<StringPiece>::Feature(int64_t batch, int64_t n,\n                                                     bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  return values_.vec<tstring>().data()[start + n];\n}\n\ntemplate <>\nStringPiece KeyedSparseTensorColumn<StringPiece>::Feature(\n    int64_t batch, int64_t n, bool strong_hash) const {\n  const int64_t start = feature_start_indices_[batch];\n  return values_.vec<tstring>().data()[start + n];\n}\n\n// A column that is backed by a dense tensor.\ntemplate <typename InternalType>\nclass DenseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  explicit DenseTensorColumn(const Tensor& tensor) : tensor_(tensor) {}\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return tensor_.dim_size(1);\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~DenseTensorColumn() override {}\n\n private:\n  const Tensor& tensor_;\n};\n\n// A column that is backed by a dense tensor.\ntemplate <typename InternalType>\nclass KeyedDenseTensorColumn : public ColumnInterface<InternalType> {\n public:\n  explicit KeyedDenseTensorColumn(const Tensor& tensor,\n                                  std::vector<int64_t> key)\n      : tensor_(tensor) {\n    std::memcpy(key_, key.data(), sizeof(key_));\n  }\n\n  int64_t FeatureCount(int64_t batch) const override {\n    return tensor_.dim_size(1);\n  }\n\n  InternalType Feature(int64_t batch, int64_t n,\n                       bool strong_hash) const override;\n\n  ~KeyedDenseTensorColumn() override {}\n\n private:\n  const Tensor& tensor_;\n  tensorflow::uint64 key_[2];\n};\n\n// InternalType is int64 only when using HashCrosser.\ntemplate <>\nint64_t DenseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                            bool strong_hash) const {\n  if (DT_STRING == tensor_.dtype())\n    return Fingerprint64(tensor_.matrix<tstring>()(batch, n));\n  return tensor_.matrix<int64_t>()(batch, n);\n}\n\ntemplate <>\nint64_t KeyedDenseTensorColumn<int64_t>::Feature(int64_t batch, int64_t n,\n                                                 bool strong_hash) const {\n  if (strong_hash) {\n    if (DT_STRING == tensor_.dtype()) {\n      return StrongKeyedHash(key_, tensor_.matrix<tstring>()(batch, n));\n    }\n    return StrongKeyedHash(\n        key_,\n        {reinterpret_cast<const char*>(tensor_.matrix<int64_t>()(batch, n)),\n         sizeof(tensor_.dtype())});\n  }\n  if (DT_STRING == tensor_.dtype())\n    return Fingerprint64(tensor_.matrix<tstring>()(batch, n));\n  return tensor_.matrix<int64_t>()(batch, n);\n}\n\n// Internal type is string or StringPiece when using StringCrosser.\ntemplate <>\ntstring DenseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                            bool strong_hash) const {\n  if (DT_STRING == tensor_.dtype()) return tensor_.matrix<tstring>()(batch, n);\n  return std::to_string(tensor_.matrix<int64_t>()(batch, n));\n}\n\ntemplate <>\ntstring KeyedDenseTensorColumn<tstring>::Feature(int64_t batch, int64_t n,\n                                                 bool strong_hash) const {\n  if (DT_STRING == tensor_.dtype()) return tensor_.matrix<tstring>()(batch, n);\n  return std::to_string(tensor_.matrix<int64_t>()(batch, n));\n}\n\ntemplate <>\nStringPiece DenseTensorColumn<StringPiece>::Feature(int64_t batch, int64_t n,\n                                                    bool strong_hash) const {\n  return tensor_.matrix<tstring>()(batch, n);\n}\n\ntemplate <>\nStringPiece KeyedDenseTensorColumn<StringPiece>::Feature(\n    int64_t batch, int64_t n, bool strong_hash) const {\n  return tensor_.matrix<tstring>()(batch, n);\n}\n\n// Updates Output tensors with sparse crosses.\ntemplate <typename OutType>\nclass OutputUpdater {\n public:\n  OutputUpdater(const std::vector<int64_t>& output_start_indices,\n                Tensor* indices_out, Tensor* values_out)\n      : output_start_indices_(output_start_indices),\n        indices_out_(indices_out),\n        values_out_(values_out) {}\n\n  void Update(const int64_t batch_index, const int64_t cross_count,\n              const OutType& cross) const {\n    const int64_t output_index =\n        output_start_indices_[batch_index] + cross_count;\n\n    auto indices_matrix = indices_out_->matrix<int64_t>();\n    indices_matrix(output_index, 0) = batch_index;\n    indices_matrix(output_index, 1) = cross_count;\n\n    auto value_vec = values_out_->vec<OutType>();\n    value_vec(output_index) = cross;\n  }\n\n private:\n  const std::vector<int64_t>& output_start_indices_;\n  Tensor* indices_out_;\n  Tensor* values_out_;\n};\n\n// Generates the sparse crosses as concatenation of strings.\ntemplate <typename InternalType>\nclass StringCrosser {\n public:\n  StringCrosser(const std::vector<\n                    std::unique_ptr<ColumnInterface<InternalType>>>& columns,\n                const int64_t num_buckets_unused, const uint64 hash_key_unused,\n                const tstring k_feature_separator)\n      : columns_(columns), k_feature_separator_(k_feature_separator) {}\n\n  string Generate(const int64_t batch_index,\n                  const std::vector<int>& permutation,\n                  bool unused_strong_hash) const {\n    gtl::InlinedVector<InternalType, 6> cross_vec(columns_.size());\n    for (int i = 0; i < permutation.size(); i++) {\n      cross_vec[i] = columns_[i]->Feature(batch_index, permutation[i], false);\n    }\n    // TODO(zakaria): this will copy the string twice, might effect\n    // performance.\n    return absl::StrJoin(cross_vec, k_feature_separator_);\n  }\n\n private:\n  const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns_;\n  const tstring k_feature_separator_;\n};\n\n// Generates the sparse crosses as nested hash to avoid string manipulations.\nclass HashCrosser {\n public:\n  HashCrosser(\n      const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns,\n      const int64_t num_buckets, const uint64 hash_key,\n      const tstring k_feature_separator_unused)\n      : columns_(columns), num_buckets_(num_buckets), hash_key_(hash_key) {}\n\n  int64_t Generate(const int64_t batch_index,\n                   const std::vector<int>& permutation,\n                   bool unused_strong_hash) const {\n    // Do the fingerprint concatenation on uint64.\n    uint64 hashed_output = hash_key_;\n    for (size_t i = 0; i < permutation.size(); ++i) {\n      uint64 hash_i = columns_[i]->Feature(batch_index, permutation[i], false);\n      hashed_output = FingerprintCat64(hashed_output, hash_i);\n    }\n    // The return value is int64 based on the number of buckets.\n    if (num_buckets_ > 0) {\n      return hashed_output % num_buckets_;\n    } else {\n      // To prevent negative output we take modulo to max int64.\n      return hashed_output % std::numeric_limits<int64_t>::max();\n    }\n  }\n\n private:\n  const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns_;\n  const int64_t num_buckets_;\n  const uint64 hash_key_;\n};\n\n// Generates the sparse crosses as nested hash to avoid string manipulations.\nclass HashCrosserV2 {\n public:\n  HashCrosserV2(\n      const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns,\n      const int64_t num_buckets, const uint64 hash_key_unused,\n      const tstring k_feature_separator_unused)\n      : columns_(columns), num_buckets_(num_buckets) {}\n\n  int64_t Generate(const int64_t batch_index,\n                   const std::vector<int>& permutation,\n                   bool strong_hash) const {\n    // Do the fingerprint concatenation on uint64.\n    uint64 hashed_output =\n        columns_[0]->Feature(batch_index, permutation[0], strong_hash);\n    for (size_t i = 1; i < permutation.size(); ++i) {\n      uint64 hash_i =\n          columns_[i]->Feature(batch_index, permutation[i], strong_hash);\n      hashed_output = FingerprintCat64(hashed_output, hash_i);\n    }\n    // The return value is int64 based on the number of buckets.\n    if (num_buckets_ > 0) {\n      return hashed_output % num_buckets_;\n    } else {\n      // To prevent negative output we take modulo to max int64.\n      return hashed_output % std::numeric_limits<int64_t>::max();\n    }\n  }\n\n private:\n  const std::vector<std::unique_ptr<ColumnInterface<int64_t>>>& columns_;\n  const int64_t num_buckets_;\n};\n\n// ProductIterator generates cartesian products based on indices.\ntemplate <typename InternalType>\nclass ProductIterator {\n public:\n  explicit ProductIterator(\n      const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>&\n          columns,\n      int64_t batch_index)\n      : columns_(columns), batch_index_(batch_index) {\n    next_permutation_.resize(columns_.size(), 0);\n    // Sets has_next_ to false if any feature column has 0 features.\n    has_next_ = true;\n    for (int i = 0; i < columns_.size(); i++) {\n      if (columns_[i]->FeatureCount(batch_index_) == 0) {\n        has_next_ = false;\n        break;\n      }\n    }\n  }\n\n  std::vector<int> Next() {\n    std::vector<int> permutation(next_permutation_);\n\n    // Generates next permutation, if available.\n    bool carry = true;\n    for (int i = next_permutation_.size() - 1; i >= 0; i--) {\n      if (carry) {\n        next_permutation_[i] = next_permutation_[i] + 1;\n      }\n      if (next_permutation_[i] == columns_[i]->FeatureCount(batch_index_)) {\n        next_permutation_[i] = 0;\n      } else {\n        carry = false;\n        break;\n      }\n    }\n    has_next_ = !carry;\n    return permutation;\n  }\n\n  bool HasNext() { return has_next_; }\n\n private:\n  bool has_next_;\n  const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns_;\n  const int64_t batch_index_;\n  std::vector<int> next_permutation_;\n};\n\ntemplate <bool HASHED_OUTPUT, typename InternalType>\nstruct CrossTraits;\n\ntemplate <typename InternalType>\nstruct CrossTraits<false, InternalType> {\n  typedef StringCrosser<InternalType> Crosser;\n  typedef StringCrosser<InternalType> CrosserV2;\n  typedef OutputUpdater<tstring> Updater;\n};\n\ntemplate <>\nstruct CrossTraits<true, int64_t> {\n  typedef HashCrosser Crosser;\n  typedef HashCrosserV2 CrosserV2;\n  typedef OutputUpdater<int64_t> Updater;\n};\n}  // namespace\n\n// Calculate the batch size from either the shapes input or the dense input.\nint64_t CalculateBatchSize(const OpInputList& shapes_list_in,\n                           const OpInputList& dense_list_in) {\n  if (shapes_list_in.size() > 0) {\n    return shapes_list_in[0].vec<int64_t>()(0);\n  }\n\n  if (dense_list_in.size() > 0) {\n    return dense_list_in[0].dim_size(0);\n  }\n\n  return 0;\n}\n\n// Validates input tensors.\nStatus ValidateInput(const OpInputList& indices_list_in,\n                     const OpInputList& values_list_in,\n                     const OpInputList& shapes_list_in,\n                     const OpInputList& dense_list_in,\n                     const DataType& internal_type) {\n  const auto size = indices_list_in.size();\n  // Only perform internal_type check for SparseCrossOp.\n  // Check if the internal_type is not invalid before doing so.\n  bool check_type = internal_type != DT_INVALID;\n  // Validates indices_list_in OpInputList.\n  for (int i = 0; i < size; i++) {\n    if (check_type && indices_list_in[i].dtype() != DT_INT64) {\n      return errors::InvalidArgument(\"Input indices should be of type \",\n                                     DT_INT64, \" but received \",\n                                     indices_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsMatrix(indices_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input indices should be a matrix but received shape \",\n          indices_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(1) != 2) {\n      return errors::InvalidArgument(\"Expected D2 of index to be 2 got \",\n                                     indices_list_in[i].shape().dim_size(1),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates values_list_in OpInputList.\n  if (values_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input values, got \",\n                                   values_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    // Make sure to avoid the expected type to be string, but input values to be\n    // int64.\n    if (check_type && internal_type == DT_STRING &&\n        values_list_in[i].dtype() == DT_INT64) {\n      return errors::InvalidArgument(\"Input values should be of internal type \",\n                                     internal_type, \" but received \",\n                                     values_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsVector(values_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input values should be a vector but received shape \",\n          values_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n    if (indices_list_in[i].shape().dim_size(0) !=\n        values_list_in[i].shape().dim_size(0)) {\n      return errors::InvalidArgument(\n          \"Expected size of values to be \",\n          indices_list_in[i].shape().dim_size(0), \" got \",\n          values_list_in[i].shape().dim_size(0), \" at position \", i);\n    }\n  }\n\n  // Validates shapes_list_in OpInputList\n  if (shapes_list_in.size() != size) {\n    return errors::InvalidArgument(\"Expected \", size, \" input shapes, got \",\n                                   shapes_list_in.size());\n  }\n  for (int i = 0; i < size; i++) {\n    if (check_type && shapes_list_in[i].dtype() != DT_INT64) {\n      return errors::InvalidArgument(\"Input shape should be of type \", DT_INT64,\n                                     \" but received \",\n                                     shapes_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsVector(shapes_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Input shapes should be a vector but received shape \",\n          shapes_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n\n    if (shapes_list_in[i].vec<int64_t>().size() != 2) {\n      return errors::InvalidArgument(\"shape should imply a 2D tensor, but got \",\n                                     shapes_list_in[i].shape().DebugString(),\n                                     \" at position \", i);\n    }\n  }\n\n  // Validates dense_list_in OpInputList\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    // Make sure to avoid the expected type to be string, but input values to be\n    // int64.\n    if (check_type && internal_type == DT_STRING &&\n        dense_list_in[i].dtype() == DT_INT64) {\n      return errors::InvalidArgument(\"Dense inputs should be of internal type \",\n                                     internal_type, \" but received \",\n                                     dense_list_in[i].dtype());\n    }\n    if (!TensorShapeUtils::IsMatrix(dense_list_in[i].shape())) {\n      return errors::InvalidArgument(\n          \"Dense inputs should be a matrix but received shape \",\n          dense_list_in[i].shape().DebugString(), \" at position \", i);\n    }\n  }\n\n  // Validates batch sizes.  (Note: we do this after validating the input\n  // shapes, because CalculateBatchSize() depends on inputs having valid\n  // shapes).\n  const auto batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  for (int i = 0; i < size; i++) {\n    if (shapes_list_in[i].vec<int64_t>()(0) != batch_size) {\n      return errors::InvalidArgument(\n          \"Expected batch size \", batch_size, \" got \",\n          shapes_list_in[i].vec<int64_t>()(0), \" at position \", i);\n    }\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    if (dense_list_in[i].dim_size(0) != batch_size) {\n      return errors::InvalidArgument(\"Expected batch size \", batch_size,\n                                     \" got \", dense_list_in[i].dim_size(0),\n                                     \" at dense tensor \", i);\n    }\n  }\n\n  return OkStatus();\n}\n\n// Extracts data about the features and populates feature data.\nvoid ExtractFeatureData(\n    const OpInputList& indices_list_in, int64_t batch_size,\n    std::vector<std::vector<int64_t>>* feature_counts,\n    std::vector<std::vector<int64_t>>* feature_start_indices) {\n  gtl::InlinedVector<int64_t, 8> current_row(indices_list_in.size(), 0);\n  for (int b = 0; b < batch_size; b++) {\n    for (int i = 0; i < indices_list_in.size(); i++) {\n      const auto indices = indices_list_in[i].matrix<int64_t>();\n      int64_t feature_count = 0;\n      int64_t start_index = current_row[i];\n      // Loops until we reach next batch index for current feature column.\n      while (current_row[i] < indices_list_in[i].dim_size(0) &&\n             indices(current_row[i], 0) == b) {\n        feature_count++;\n        current_row[i]++;\n      }\n      (*feature_counts)[i].push_back(feature_count);\n      (*feature_start_indices)[i].push_back(start_index);\n    }\n  }\n}\n\n// Returns number of crosses for a given batch_index\ntemplate <typename InternalType>\nint64_t CrossCountByBatchIndex(\n    const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns,\n    int batch_index) {\n  int64_t cross_count = 1;\n  for (int i = 0; i < columns.size(); i++) {\n    const auto feature_count = columns[i]->FeatureCount(batch_index);\n    // If one column is missing any feature, there won't be any cross.\n    if (feature_count == 0) {\n      return 0;\n    }\n    cross_count *= feature_count;\n  }\n  return cross_count;\n}\n\n// Generate the columns given the sparse and dense inputs.\ntemplate <typename InternalType>\nstd::vector<std::unique_ptr<ColumnInterface<InternalType>>>\nGenerateColumnsFromInput(const OpInputList& indices_list_in,\n                         const OpInputList& values_list_in,\n                         const OpInputList& shapes_list_in,\n                         const OpInputList& dense_list_in) {\n  std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns;\n  const int64_t batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  const int64_t number_of_columns = shapes_list_in.size();\n\n  std::vector<std::vector<int64_t>> feature_counts(number_of_columns,\n                                                   std::vector<int64_t>());\n  std::vector<std::vector<int64_t>> feature_start_indices(\n      number_of_columns, std::vector<int64_t>());\n\n  ExtractFeatureData(indices_list_in, batch_size, &feature_counts,\n                     &feature_start_indices);\n\n  columns.reserve(values_list_in.size());\n  for (int i = 0; i < values_list_in.size(); ++i) {\n    columns.emplace_back(new SparseTensorColumn<InternalType>(\n        values_list_in[i], std::move(feature_counts[i]),\n        std::move(feature_start_indices[i])));\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    columns.emplace_back(new DenseTensorColumn<InternalType>(dense_list_in[i]));\n  }\n\n  return columns;\n}\n\n// Generate the columns given the sparse and dense inputs.\ntemplate <typename InternalType>\nstd::vector<std::unique_ptr<ColumnInterface<InternalType>>>\nGenerateKeyedColumnsFromInput(const OpInputList& indices_list_in,\n                              const OpInputList& values_list_in,\n                              const OpInputList& shapes_list_in,\n                              const OpInputList& dense_list_in,\n                              std::vector<int64_t> keys) {\n  std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns;\n  const int64_t batch_size = CalculateBatchSize(shapes_list_in, dense_list_in);\n  const int64_t number_of_columns = shapes_list_in.size();\n\n  std::vector<std::vector<int64_t>> feature_counts(number_of_columns,\n                                                   std::vector<int64_t>());\n  std::vector<std::vector<int64_t>> feature_start_indices(\n      number_of_columns, std::vector<int64_t>());\n\n  ExtractFeatureData(indices_list_in, batch_size, &feature_counts,\n                     &feature_start_indices);\n\n  columns.reserve(values_list_in.size());\n  for (int i = 0; i < values_list_in.size(); ++i) {\n    columns.emplace_back(new KeyedSparseTensorColumn<InternalType>(\n        values_list_in[i], std::move(feature_counts[i]),\n        std::move(feature_start_indices[i]), keys));\n  }\n  for (int i = 0; i < dense_list_in.size(); ++i) {\n    columns.emplace_back(\n        new KeyedDenseTensorColumn<InternalType>(dense_list_in[i], keys));\n  }\n\n  return columns;\n}\n\n// Allocates output tensors with proper size and sets the shape tensor of\n// the output SparseTensor.\n// It also output_start_indices which contains the start indices for each\n// input in the output SparseTensor.\ntemplate <typename InternalType>\nStatus CreateOutputTensors(\n    const std::vector<std::unique_ptr<ColumnInterface<InternalType>>>& columns,\n    int64_t batch_size, OpKernelContext* context, Tensor** indices_out,\n    Tensor** values_out, Tensor** shape_out,\n    std::vector<int64_t>* output_start_indices) {\n  // Calculates dimensions for output tensors.\n  int64_t cross_count_total = 0;\n  int64_t max_cross_count = 0;\n  for (int64_t b = 0; b < batch_size; b++) {\n    // For each input, sets starting indices in output SparseTensor\n    (*output_start_indices)[b] = cross_count_total;\n    const auto cross_count = CrossCountByBatchIndex(columns, b);\n    max_cross_count = std::max(max_cross_count, cross_count);\n    cross_count_total += cross_count;\n  }\n\n  // Allocates tensors.\n  TF_RETURN_IF_ERROR(context->allocate_output(\n      0, TensorShape({cross_count_total, 2}), indices_out));\n  TF_RETURN_IF_ERROR(context->allocate_output(\n      1, TensorShape({cross_count_total}), values_out));\n  TF_RETURN_IF_ERROR(context->allocate_output(2, TensorShape({2}), shape_out));\n\n  // Sets shape.\n  auto shape_vec = (*shape_out)->vec<int64_t>();\n  shape_vec(0) = batch_size;\n  shape_vec(1) = max_cross_count;\n\n  return OkStatus();\n}\n\ntemplate <bool HASHED_OUTPUT, typename InternalType>\nclass SparseCrossOp : public OpKernel {\n public:\n  explicit SparseCrossOp(OpKernelConstruction* context) : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"num_buckets\", &num_buckets_));\n    // Read signed_hash_key_ as int64 since uint64 attributes are not\n    // supported by REGISTER_OP.\n    int64_t signed_hash_key_;\n    OP_REQUIRES_OK(context, context->GetAttr(\"hash_key\", &signed_hash_key_));\n    hash_key_ = static_cast<uint64>(signed_hash_key_);\n    OP_REQUIRES_OK(context, context->GetAttr(\"internal_type\", &internal_type_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    DataType internal_type = internal_type_;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    std::vector<std::unique_ptr<ColumnInterface<InternalType>>> columns =\n        GenerateColumnsFromInput<InternalType>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in);\n\n    const tstring k_feature_separator = \"_X_\";\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Crosser crosser(\n        columns, num_buckets_, hash_key_, k_feature_separator);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64_t batch_size =\n        CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64_t> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n\n    typename CrossTraits<HASHED_OUTPUT, InternalType>::Updater updater(\n        output_start_indices, indices_out, values_out);\n    auto do_work = [&columns, crosser, updater](int64_t begin, int64_t end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<InternalType> product_iterator(columns, b);\n        int64_t cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }\n\n private:\n  int64_t num_buckets_;\n  uint64 hash_key_;\n  DataType internal_type_;\n};\n\nclass SparseCrossV2Op : public OpKernel {\n public:\n  explicit SparseCrossV2Op(OpKernelConstruction* context) : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    // Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* sep_t;\n    OP_REQUIRES_OK(context, context->input(\"sep\", &sep_t));\n    OP_REQUIRES(context, TensorShapeUtils::IsScalar(sep_t->shape()),\n                errors::InvalidArgument(\"Input separator should be a scalar. \"\n                                        \"Received: \",\n                                        sep_t->DebugString()));\n    const tstring separator = sep_t->scalar<tstring>()();\n\n    std::vector<std::unique_ptr<ColumnInterface<tstring>>> columns =\n        GenerateColumnsFromInput<tstring>(indices_list_in, values_list_in,\n                                          shapes_list_in, dense_list_in);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64_t batch_size =\n        CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64_t> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    StringCrosser<tstring> crosser(columns, 0, 0, separator);\n    OutputUpdater<tstring> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater](int64_t begin, int64_t end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<tstring> product_iterator(columns, b);\n        int64_t cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, false));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }\n};\n\nclass SparseCrossHashedOp : public OpKernel {\n public:\n  explicit SparseCrossHashedOp(OpKernelConstruction* context)\n      : OpKernel(context) {}\n\n  void Compute(OpKernelContext* context) override {\n    OpInputList indices_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"indices\", &indices_list_in));\n    OpInputList values_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"values\", &values_list_in));\n    OpInputList shapes_list_in;\n    OP_REQUIRES_OK(context, context->input_list(\"shapes\", &shapes_list_in));\n    OpInputList dense_list_in;\n    OP_REQUIRES_OK(context,\n                   context->input_list(\"dense_inputs\", &dense_list_in));\n\n    // Set internal_type to invalid_type so that the check will be ignored.\n    DataType internal_type = DT_INVALID;\n    OP_REQUIRES_OK(\n        context, ValidateInput(indices_list_in, values_list_in, shapes_list_in,\n                               dense_list_in, internal_type));\n\n    const Tensor* num_buckets_t;\n    OP_REQUIRES_OK(context, context->input(\"num_buckets\", &num_buckets_t));\n    const int64_t num_buckets = num_buckets_t->scalar<int64_t>()();\n\n    const Tensor* strong_hash_t;\n    OP_REQUIRES_OK(context, context->input(\"strong_hash\", &strong_hash_t));\n    const bool strong_hash = strong_hash_t->scalar<bool>()();\n\n    const Tensor* salt_t;\n    OP_REQUIRES_OK(context, context->input(\"salt\", &salt_t));\n    const auto salt = salt_t->flat<int64_t>();\n    std::vector<int64_t> key_{salt(0), salt(1)};\n\n    std::vector<std::unique_ptr<ColumnInterface<int64_t>>> columns =\n        GenerateKeyedColumnsFromInput<int64_t>(indices_list_in, values_list_in,\n                                               shapes_list_in, dense_list_in,\n                                               key_);\n    Tensor* indices_out;\n    Tensor* values_out;\n    Tensor* shape_out;\n    const int64_t batch_size =\n        CalculateBatchSize(shapes_list_in, dense_list_in);\n    std::vector<int64_t> output_start_indices(batch_size);\n    OP_REQUIRES_OK(\n        context,\n        CreateOutputTensors(columns, batch_size, context, &indices_out,\n                            &values_out, &shape_out, &output_start_indices));\n    const tstring unused_sep;\n    HashCrosserV2 crosser(columns, num_buckets, 0, unused_sep);\n    OutputUpdater<int64_t> updater(output_start_indices, indices_out,\n                                   values_out);\n    auto do_work = [&columns, crosser, updater, strong_hash](int64_t begin,\n                                                             int64_t end) {\n      for (int b = begin; b < end; b++) {\n        ProductIterator<int64_t> product_iterator(columns, b);\n        int64_t cross_count = 0;\n        while (product_iterator.HasNext()) {\n          const auto permutation = product_iterator.Next();\n          updater.Update(b, cross_count,\n                         crosser.Generate(b, permutation, strong_hash));\n          cross_count++;\n        }\n      }\n    };\n\n    auto* worker_threads = context->device()->tensorflow_cpu_worker_threads();\n    // TODO(zakaria): optimize kCostPerUnit\n    const int kCostPerUnit = 5000 * indices_list_in.size();\n    Shard(worker_threads->num_threads, worker_threads->workers, batch_size,\n          kCostPerUnit, do_work);\n  }\n};\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<tstring>(\"out_type\")\n                            .TypeConstraint<tstring>(\"internal_type\"),\n                        SparseCrossOp<false, StringPiece>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<tstring>(\"out_type\")\n                            .TypeConstraint<int64_t>(\"internal_type\"),\n                        SparseCrossOp<false, tstring>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<int64_t>(\"out_type\")\n                            .TypeConstraint<tstring>(\"internal_type\"),\n                        SparseCrossOp<true, int64>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCross\")\n                            .Device(DEVICE_CPU)\n                            .TypeConstraint<int64_t>(\"out_type\")\n                            .TypeConstraint<int64_t>(\"internal_type\"),\n                        SparseCrossOp<true, int64>);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCrossV2\").Device(DEVICE_CPU),\n                        SparseCrossV2Op);\n\nREGISTER_KERNEL_BUILDER(Name(\"SparseCrossHashed\").Device(DEVICE_CPU),\n                        SparseCrossHashedOp);\n\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for sparse_cross_op.\"\"\"\n\nimport numpy\n\nfrom tensorflow.python.client import session\nfrom tensorflow.python.framework import constant_op\nfrom tensorflow.python.framework import dtypes\nfrom tensorflow.python.framework import errors\nfrom tensorflow.python.framework import sparse_tensor\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import array_ops\nfrom tensorflow.python.ops import gen_sparse_ops\nfrom tensorflow.python.ops import sparse_ops\nfrom tensorflow.python.platform import test\n\n\nclass BaseSparseCrossOpTest(test.TestCase):\n\n  def _sparse_tensor(self, data, batch_size=-1):\n    \"\"\"Generates a SparseTensor.\n\n    Args:\n      data: Should be a list of list of strings or int64. Each item of the outer\n        list represents a batch. Each item of the batch is a feature of a\n        specific feature column.\n      batch_size: optional batch size, especially for cases when data has no\n        entry for some batches.\n\n    Returns:\n     A SparseTensor.\n    \"\"\"\n    indices = []\n    values = []\n    max_col_count = 0\n    for batch, batch_ix in zip(data, range(len(data))):\n      for column, column_ix in zip(batch, range(len(batch))):\n        indices.append([batch_ix, column_ix])\n        values.append(column)\n        max_col_count = max(max_col_count, column_ix + 1)\n    shape = [batch_size if batch_size != -1 else len(data), max_col_count]\n    value_type = (\n        dtypes.string\n        if not values or isinstance(values[0], str) else dtypes.int64)\n    return sparse_tensor.SparseTensor(\n        constant_op.constant(indices, dtypes.int64, [len(indices), 2]),\n        constant_op.constant(values, value_type, [len(indices)]),\n        constant_op.constant(shape, dtypes.int64))\n\n  def _assert_sparse_tensor_equals(self, sp1, sp2):\n    self.assertAllEqual(sp1.indices, sp2.indices)\n    self.assertAllEqual(sp1.values, sp2.values)\n    self.assertAllEqual(sp1.dense_shape, sp2.dense_shape)\n\n  def _assert_sparse_tensor_empty(self, sp):\n    self.assertEqual(0, sp.indices.size)\n    self.assertEqual(0, sp.values.size)\n    # TODO(zakaria): check if we can ignore the first dim of the shape.\n    self.assertEqual(0, sp.dense_shape[1])\n\n\nclass SparseCrossOpTest(test.TestCase):\n\n  @test_util.run_deprecated_v1\n  def test_simple(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1'],\n                             ['batch2-FC1-F1', 'batch2-FC1-F2']]),\n        self._sparse_tensor([['batch1-FC2-F1'],\n                             ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    ])\n    expected_out = self._sparse_tensor([['batch1-FC1-F1_X_batch1-FC2-F1'], [\n        'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n        'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_dense(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                              ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                             dtypes.string),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1', 'batch1-FC1-F2_X_batch1-FC2-F2'\n    ], [\n        'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n        'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_sparse(self):\n    \"\"\"Tests mixed type.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([[11], [333, 55555]]),\n        self._sparse_tensor([['batch1-FC2-F1'],\n                             ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    ])\n    expected_out = self._sparse_tensor([['11_X_batch1-FC2-F1'], [\n        '333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2', '55555_X_batch2-FC2-F1',\n        '55555_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_dense(self):\n    \"\"\"Tests mixed dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        constant_op.constant([[11, 333], [55555, 999999]], dtypes.int64),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor([[\n        '11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2', '333_X_batch1-FC2-F1',\n        '333_X_batch1-FC2-F2'\n    ], [\n        '55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2',\n        '999999_X_batch2-FC2-F1', '999999_X_batch2-FC2-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_cross_dense(self):\n    \"\"\"Tests sparse and dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1'],\n                             ['batch2-FC1-F1', 'batch2-FC1-F2']]),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor(\n        [['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2'], [\n            'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n            'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_integer_sparse_input(self):\n    \"\"\"Tests mixed type sparse and dense inputs.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([[11], [333, 5555]]),\n        constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                              ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                             dtypes.string),\n    ])\n    expected_out = self._sparse_tensor(\n        [['11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2'], [\n            '333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2',\n            '5555_X_batch2-FC2-F1', '5555_X_batch2-FC2-F2'\n        ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x3x3(self):\n    \"\"\"Tests 3x3x3 permutation.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(\n            [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n        self._sparse_tensor(\n            [['batch1-FC2-F1', 'batch1-FC2-F2', 'batch1-FC2-F3']]),\n        self._sparse_tensor(\n            [['batch1-FC3-F1', 'batch1-FC3-F2', 'batch1-FC3-F3']])\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F3'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation.\"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(\n            [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n        self._sparse_tensor([['batch1-FC2-F1']]),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_large_batch(self):\n    \"\"\"Tests with large batch size to force multithreading.\"\"\"\n    batch_size = 5000\n    col1 = []\n    col2 = []\n    col3 = []\n    for b in range(batch_size):\n      col1.append(\n          ['batch%d-FC1-F1' % b, 'batch%d-FC1-F2' % b, 'batch%d-FC1-F3' % b])\n      col2.append(['batch%d-FC2-F1' % b])\n      col3.append(['batch%d-FC3-F1' % b, 'batch%d-FC3-F2' % b])\n\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor(col1),\n        self._sparse_tensor(col2),\n        self._sparse_tensor(col3)\n    ])\n\n    col_out = []\n    for b in range(batch_size):\n      col_out.append([\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b)\n      ])\n\n    expected_out = self._sparse_tensor(col_out)\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_one_column_empty(self):\n    \"\"\"Tests when one column is empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']]),\n        self._sparse_tensor([], 1),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    ])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_empty(self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_some_columns_empty(self):\n    \"\"\"Tests when more than one columns are empty.\n\n    Cross for the corresponding batch should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']], 2),\n        self._sparse_tensor([['batch1-FC2-F1'], ['batch2-FC2-F1']], 2),\n        self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']], 2)\n    ])\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]], 2)\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_all_columns_empty(self):\n    \"\"\"Tests when all columns are empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    op = sparse_ops.sparse_cross([\n        self._sparse_tensor([]),\n        self._sparse_tensor([]),\n        self._sparse_tensor([])\n    ])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_empty(self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket_no_hash_key(self):\n    op = sparse_ops.sparse_cross_hashed([\n        self._sparse_tensor([['batch1-FC1-F1']]),\n        self._sparse_tensor([['batch1-FC2-F1']]),\n        self._sparse_tensor([['batch1-FC3-F1']])\n    ])\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[1971693436396284976]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[4847552627144134031]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  # TODO(sibyl-Aix6ihai): Add benchmark to compare Hashed vs Non-hashed.\n  @test_util.run_deprecated_v1\n  def test_hashed_no_hash_key(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        num_buckets=100)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[83]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_output(self):\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor([['batch1-FC1-F1']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1']])\n        ],\n        num_buckets=100,\n        hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[31]])\n    with self.cached_session() as sess:\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(op))\n\n  @test_util.run_deprecated_v1\n  def test_hashed__has_no_collision(self):\n    \"\"\"Tests that fingerprint concatenation has no collisions.\"\"\"\n    # Although the last 10 bits of 359 and 1024+359 are identical.\n    # As a result, all the crosses shouldn't collide.\n    t1 = constant_op.constant([[359], [359 + 1024]])\n    t2 = constant_op.constant([list(range(10)), list(range(10))])\n    cross = sparse_ops.sparse_cross_hashed(\n        [t2, t1], num_buckets=1024, hash_key=sparse_ops._DEFAULT_HASH_KEY + 1)\n    cross_dense = sparse_ops.sparse_tensor_to_dense(cross)\n    with session.Session():\n      values = self.evaluate(cross_dense)\n      self.assertTrue(numpy.not_equal(values[0], values[1]).all())\n\n  def test_hashed_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation with hashed output.\"\"\"\n    op = sparse_ops.sparse_cross_hashed(\n        [\n            self._sparse_tensor(\n                [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']]),\n            self._sparse_tensor([['batch1-FC2-F1']]),\n            self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n        ],\n        num_buckets=1000)\n    with self.cached_session() as sess:\n      out = self.evaluate(op)\n      self.assertEqual(6, len(out.values))\n      self.assertAllEqual([[0, i] for i in range(6)], out.indices)\n      self.assertTrue(all(x < 1000 and x >= 0 for x in out.values))\n      all_values_are_different = len(out.values) == len(set(out.values))\n      self.assertTrue(all_values_are_different)\n\n  def _assert_sparse_tensor_empty(self, sp):\n    self.assertEqual(0, sp.indices.size)\n    self.assertEqual(0, sp.values.size)\n    # TODO(zakaria): check if we can ignore the first dim of the shape.\n    self.assertEqual(0, sp.dense_shape[1])\n\n  def _assert_sparse_tensor_equals(self, sp1, sp2):\n    self.assertAllEqual(sp1.indices, sp2.indices)\n    self.assertAllEqual(sp1.values, sp2.values)\n    self.assertAllEqual(sp1.dense_shape, sp2.dense_shape)\n\n  def _sparse_tensor(self, data, batch_size=-1):\n    \"\"\"Generates a SparseTensor.\n\n    Args:\n      data: Should be a list of list of strings or int64. Each item of the outer\n          list represents a batch. Each item of the batch is a feature of a\n          specific feature column.\n      batch_size: optional batch size, especially for cases when data has no\n          entry for some batches.\n\n    Returns:\n     A SparseTensor.\n    \"\"\"\n    indices = []\n    values = []\n    max_col_count = 0\n    for batch, batch_ix in zip(data, range(len(data))):\n      for column, column_ix in zip(batch, range(len(batch))):\n        indices.append([batch_ix, column_ix])\n        values.append(column)\n        max_col_count = max(max_col_count, column_ix + 1)\n    shape = [batch_size if batch_size != -1 else len(data), max_col_count]\n    value_type = (dtypes.string if not values or isinstance(values[0], str) else\n                  dtypes.int64)\n    return sparse_tensor.SparseTensor(\n        constant_op.constant(indices, dtypes.int64, [len(indices), 2]),\n        constant_op.constant(values, value_type, [len(indices)]),\n        constant_op.constant(shape, dtypes.int64))\n\n  def test_invalid_sparse_tensors(self):\n    # Test validation of invalid SparseTensors.  The SparseTensor constructor\n    # prevents us from creating invalid SparseTensors (eps. in eager mode),\n    # so we create valid SparseTensors and then modify them to be invalid.\n\n    st1 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st1._indices = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input indices should be a matrix'):\n      self.evaluate(sparse_ops.sparse_cross([st1]))\n\n    st2 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st2._values = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input values should be a vector'):\n      self.evaluate(sparse_ops.sparse_cross([st2]))\n\n    st3 = sparse_tensor.SparseTensor([[0, 0]], [0], [2, 2])\n    st3._dense_shape = array_ops.zeros([], dtypes.int64)\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Input shapes should be a vector'):\n      self.evaluate(sparse_ops.sparse_cross([st3]))\n\n  def test_bad_tensor_shapes(self):\n    # All inputs must be 2D.\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected D2 of index to be 2'):\n      st = sparse_tensor.SparseTensor([[0]], [0], [10])  # 1D SparseTensor\n      self.evaluate(sparse_ops.sparse_cross([st]))\n\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Dense inputs should be a matrix'):\n      dt = array_ops.zeros([0])  # 1D DenseTensor.\n      self.evaluate(sparse_ops.sparse_cross([dt]))\n\n  def test_batch_size_mismatch(self):\n    st1 = sparse_tensor.SparseTensor([[0, 0]], [0], [10, 10])  # batch size 10\n    st2 = sparse_tensor.SparseTensor([[0, 0]], [0], [7, 10])  # batch size 7\n    dt = array_ops.zeros([5, 0])  # batch size 5\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected batch size'):\n      self.evaluate(sparse_ops.sparse_cross([st1, dt]))\n    with self.assertRaisesRegex((errors.InvalidArgumentError, ValueError),\n                                'Expected batch size'):\n      self.evaluate(sparse_ops.sparse_cross([st1, st2]))\n\n\nclass SparseCrossV2OpTest(BaseSparseCrossOpTest):\n\n  @test_util.run_deprecated_v1\n  def test_sparse(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],\n                                    ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_X_batch1-FC2-F1'],\n        ['batch2-FC1-F1_X_batch2-FC2-F1',\n         'batch2-FC1-F1_X_batch2-FC2-F2',\n         'batch2-FC1-F2_X_batch2-FC2-F1',\n         'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_sep(self):\n    \"\"\"Tests a simple scenario.\"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1'],\n                                    ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_Y_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_Y_batch1-FC2-F1'],\n        ['batch2-FC1-F1_Y_batch2-FC2-F1',\n         'batch2-FC1-F1_Y_batch2-FC2-F2',\n         'batch2-FC1-F2_Y_batch2-FC2-F1',\n         'batch2-FC1-F2_Y_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_dense(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                                        ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                                       dtypes.string)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2',\n         'batch1-FC1-F2_X_batch1-FC2-F1', 'batch1-FC1-F2_X_batch1-FC2-F2'\n        ],\n        ['batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n         'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_dense_sep(self):\n    \"\"\"Tests only dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([['batch1-FC1-F1', 'batch1-FC1-F2'],\n                                        ['batch2-FC1-F1', 'batch2-FC1-F2']],\n                                       dtypes.string)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['batch1-FC1-F1_batch1-FC2-F1', 'batch1-FC1-F1_batch1-FC2-F2',\n         'batch1-FC1-F2_batch1-FC2-F1', 'batch1-FC1-F2_batch1-FC2-F2'\n        ],\n        ['batch2-FC1-F1_batch2-FC2-F1', 'batch2-FC1-F1_batch2-FC2-F2',\n         'batch2-FC1-F2_batch2-FC2-F1', 'batch2-FC1-F2_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_sparse(self):\n    \"\"\"Tests mixed type.\"\"\"\n    sp_inp_1 = self._sparse_tensor([[11], [333, 55555]])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'],\n                                    ['batch2-FC2-F1', 'batch2-FC2-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices],\n        values=[sp_inp_1.values, sp_inp_2.values],\n        shapes=[sp_inp_1.dense_shape, sp_inp_2.dense_shape],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['11_X_batch1-FC2-F1'],\n        ['333_X_batch2-FC2-F1', '333_X_batch2-FC2-F2',\n         '55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_integer_mixed_string_dense(self):\n    \"\"\"Tests mixed dense inputs.\"\"\"\n    dense_inp_1 = constant_op.constant([[11, 333], [55555, 999999]],\n                                       dtypes.int64)\n    dense_inp_2 = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                        ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                       dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[dense_inp_1, dense_inp_2],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    # pyformat: disable\n    expected_out = self._sparse_tensor([\n        ['11_X_batch1-FC2-F1', '11_X_batch1-FC2-F2',\n         '333_X_batch1-FC2-F1', '333_X_batch1-FC2-F2'\n        ],\n        ['55555_X_batch2-FC2-F1', '55555_X_batch2-FC2-F2',\n         '999999_X_batch2-FC2-F1', '999999_X_batch2-FC2-F2'\n        ]])\n    # pyformat: enable\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_sparse_cross_dense(self):\n    \"\"\"Tests sparse and dense inputs.\"\"\"\n    sp_inp = self._sparse_tensor([['batch1-FC1-F1'],\n                                  ['batch2-FC1-F1', 'batch2-FC1-F2']])\n    dense_inp = constant_op.constant([['batch1-FC2-F1', 'batch1-FC2-F2'],\n                                      ['batch2-FC2-F1', 'batch2-FC2-F2']],\n                                     dtypes.string)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp.indices],\n        values=[sp_inp.values],\n        shapes=[sp_inp.dense_shape],\n        dense_inputs=[dense_inp],\n        sep='_X_')\n    expected_out = self._sparse_tensor(\n        [['batch1-FC1-F1_X_batch1-FC2-F1', 'batch1-FC1-F1_X_batch1-FC2-F2'],\n         [\n             'batch2-FC1-F1_X_batch2-FC2-F1', 'batch2-FC1-F1_X_batch2-FC2-F2',\n             'batch2-FC1-F2_X_batch2-FC2-F1', 'batch2-FC1-F2_X_batch2-FC2-F2'\n         ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x3x3(self):\n    \"\"\"Tests 3x3x3 permutation.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor(\n        [['batch1-FC2-F1', 'batch1-FC2-F2', 'batch1-FC2-F3']])\n    sp_inp_3 = self._sparse_tensor(\n        [['batch1-FC3-F1', 'batch1-FC3-F2', 'batch1-FC3-F3']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F1_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F3_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F2_X_batch1-FC3-F3',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F3_X_batch1-FC3-F3'\n    ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_permutation_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F3_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_large_batch(self):\n    \"\"\"Tests with large batch size to force multithreading.\"\"\"\n    batch_size = 5000\n    col1 = []\n    col2 = []\n    col3 = []\n    for b in range(batch_size):\n      col1.append(\n          ['batch%d-FC1-F1' % b,\n           'batch%d-FC1-F2' % b,\n           'batch%d-FC1-F3' % b])\n      col2.append(['batch%d-FC2-F1' % b])\n      col3.append(['batch%d-FC3-F1' % b, 'batch%d-FC3-F2' % b])\n    sp_inp_1 = self._sparse_tensor(col1)\n    sp_inp_2 = self._sparse_tensor(col2)\n    sp_inp_3 = self._sparse_tensor(col3)\n\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n\n    col_out = []\n    for b in range(batch_size):\n      col_out.append([\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F1_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F2_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F1' % (b, b, b),\n          'batch%d-FC1-F3_X_batch%d-FC2-F1_X_batch%d-FC3-F2' % (b, b, b)\n      ])\n\n    expected_out = self._sparse_tensor(col_out)\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_one_column_empty(self):\n    \"\"\"Tests when one column is empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']])\n    sp_inp_2 = self._sparse_tensor([], 1)\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_empty(self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_some_columns_empty(self):\n    \"\"\"Tests when more than one columns are empty.\n\n    Cross for the corresponding batch should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1', 'batch1-FC1-F2']], 2)\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1'], ['batch2-FC2-F1']], 2)\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']], 2)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    expected_out = self._sparse_tensor([[\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F1_X_batch1-FC2-F1_X_batch1-FC3-F2',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F1',\n        'batch1-FC1-F2_X_batch1-FC2-F1_X_batch1-FC3-F2'\n    ]], 2)\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_all_columns_empty(self):\n    \"\"\"Tests when all columns are empty.\n\n    The crossed tensor should be empty.\n    \"\"\"\n    sp_inp_1 = self._sparse_tensor([])\n    sp_inp_2 = self._sparse_tensor([])\n    sp_inp_3 = self._sparse_tensor([])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_v2(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        sep='_X_')\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_empty(self.evaluate(out))\n\n  def testNonScalarInput(self):\n    with self.assertRaisesRegex(errors.InvalidArgumentError,\n                                'Input separator should be a scalar.'):\n      self.evaluate(sparse_ops.sparse_cross(\n          inputs=[],\n          name='a',\n          separator=constant_op.constant(['a', 'b'], dtype=dtypes.string)))\n\n\nclass SparseCrossHashedOpTest(BaseSparseCrossOpTest):\n\n  @test_util.run_deprecated_v1\n  def test_hashed_zero_bucket_no_hash_key(self):\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=0,\n        salt=[1, 1],\n        strong_hash=False)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[9186962005966787372]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n    # salt is not being used when `strong_hash` is False.\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=0,\n        salt=[137, 173],\n        strong_hash=False)\n    out_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out_2))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_output(self):\n    sp_inp_1 = self._sparse_tensor([['batch1-FC1-F1']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=100,\n        salt=[137, 173],\n        strong_hash=False)\n    # Check actual hashed output to prevent unintentional hashing changes.\n    expected_out = self._sparse_tensor([[79]])\n    out = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      self._assert_sparse_tensor_equals(expected_out, self.evaluate(out))\n\n  @test_util.run_deprecated_v1\n  def test_hashed_has_no_collision(self):\n    \"\"\"Tests that fingerprint concatenation has no collisions.\"\"\"\n    # Although the last 10 bits of 359 and 1024+359 are identical.\n    # As a result, all the crosses shouldn't collide.\n    t1 = constant_op.constant([[359], [359 + 1024]], dtype=dtypes.int64)\n    t2 = constant_op.constant(\n        [list(range(10)), list(range(10))], dtype=dtypes.int64)\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[],\n        values=[],\n        shapes=[],\n        dense_inputs=[t2, t1],\n        num_buckets=1024,\n        salt=[137, 173],\n        strong_hash=False)\n    cross = sparse_tensor.SparseTensor(inds, vals, shapes)\n    cross_dense = sparse_ops.sparse_tensor_to_dense(cross)\n    with session.Session():\n      values = self.evaluate(cross_dense)\n      self.assertTrue(numpy.not_equal(values[0], values[1]).all())\n\n  def test_hashed_3x1x2(self):\n    \"\"\"Tests 3x1x2 permutation with hashed output.\"\"\"\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        num_buckets=1000,\n        salt=[137, 173],\n        strong_hash=False)\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    with self.cached_session():\n      out = self.evaluate(output)\n      self.assertEqual(6, len(out.values))\n      self.assertAllEqual([[0, i] for i in range(6)], out.indices)\n      self.assertTrue(all(x < 1000 and x >= 0 for x in out.values))\n      all_values_are_different = len(out.values) == len(set(out.values))\n      self.assertTrue(all_values_are_different)\n\n  def test_hashed_different_salt(self):\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=False,\n        num_buckets=1000,\n        salt=[137, 173])\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 1])\n    output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      out = self.evaluate(output)\n      out_2 = self.evaluate(output_2)\n      self.assertAllEqual(out.indices, out_2.indices)\n      self.assertNotAllEqual(out.values, out_2.values)\n\n  def test_sep_ignored_in_hashed_out(self):\n    sp_inp_1 = self._sparse_tensor(\n        [['batch1-FC1-F1', 'batch1-FC1-F2', 'batch1-FC1-F3']])\n    sp_inp_2 = self._sparse_tensor([['batch1-FC2-F1']])\n    sp_inp_3 = self._sparse_tensor([['batch1-FC3-F1', 'batch1-FC3-F2']])\n    inds, vals, shapes = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 173])\n    output = sparse_tensor.SparseTensor(inds, vals, shapes)\n    inds_2, vals_2, shapes_2 = gen_sparse_ops.sparse_cross_hashed(\n        indices=[sp_inp_1.indices, sp_inp_2.indices, sp_inp_3.indices],\n        values=[sp_inp_1.values, sp_inp_2.values, sp_inp_3.values],\n        shapes=[\n            sp_inp_1.dense_shape, sp_inp_2.dense_shape, sp_inp_3.dense_shape\n        ],\n        dense_inputs=[],\n        strong_hash=True,\n        num_buckets=1000,\n        salt=[137, 173])\n    output_2 = sparse_tensor.SparseTensor(inds_2, vals_2, shapes_2)\n    with self.cached_session():\n      out = self.evaluate(output)\n      out_2 = self.evaluate(output_2)\n      self.assertAllEqual(out.indices, out_2.indices)\n      self.assertAllEqual(out.values, out_2.values)\n\n\nif __name__ == '__main__':\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/sparse_cross_op.cc", "tensorflow/python/kernel_tests/sparse_ops/sparse_cross_op_test.py"], "buggy_code_start_loc": [26, 875], "buggy_code_end_loc": [834, 875], "fixing_code_start_loc": [27, 876], "fixing_code_end_loc": [841, 884], "type": "CWE-617", "message": "TensorFlow is an open source platform for machine learning. If `tf.sparse.cross` receives an input `separator` that is not a scalar, it gives a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 83dcb4dbfa094e33db084e97c4d0531a559e0ebf. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue.", "other": {"cve": {"id": "CVE-2022-35997", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-16T23:15:10.467", "lastModified": "2022-09-20T14:49:39.707", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an open source platform for machine learning. If `tf.sparse.cross` receives an input `separator` that is not a scalar, it gives a `CHECK` fail that can be used to trigger a denial of service attack. We have patched the issue in GitHub commit 83dcb4dbfa094e33db084e97c4d0531a559e0ebf. The fix will be included in TensorFlow 2.10.0. We will also cherrypick this commit on TensorFlow 2.9.1, TensorFlow 2.8.1, and TensorFlow 2.7.2, as these are also affected and still in supported range. There are no known workarounds for this issue."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto para el aprendizaje autom\u00e1tico. Si \"tf.sparse.cross\" recibe un \"separador\" de entrada que no es un escalar, da un fallo \"CHECK\" que puede ser usado para desencadenar un ataque de denegaci\u00f3n de servicio. Hemos parcheado el problema en el commit 83dcb4dbfa094e33db084e97c4d0531a559e0ebf de GitHub. La correcci\u00f3n ser\u00e1 incluida en TensorFlow versi\u00f3n 2.10.0. Tambi\u00e9n seleccionaremos este compromiso en TensorFlow versi\u00f3n 2.9.1, TensorFlow versi\u00f3n 2.8.1, y TensorFlow versi\u00f3n 2.7.2, ya que estos tambi\u00e9n est\u00e1n afectados y todav\u00eda est\u00e1n en el rango admitido. No se presentan mitigaciones conocidas para este problema"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-617"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.7.2", "matchCriteriaId": "C6622D95-1C86-45C5-AB55-E6EEEA0996DF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.8.0", "versionEndExcluding": "2.8.1", "matchCriteriaId": "0F9D273D-02DC-441E-AA91-EAC8DEAA4B44"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.9.0", "versionEndExcluding": "2.9.1", "matchCriteriaId": "FE4F8A81-6CC2-4F7F-9602-C170FDD926E7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc0:*:*:*:*:*:*", "matchCriteriaId": "1DBFBCE2-0A01-4575-BE45-6775ABFB8B28"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc1:*:*:*:*:*:*", "matchCriteriaId": "89806CF9-E423-4CA6-A01A-8175C260CB24"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc2:*:*:*:*:*:*", "matchCriteriaId": "F2B80690-A257-4E16-BD27-9AE045BC56ED"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:2.10:rc3:*:*:*:*:*:*", "matchCriteriaId": "F335F9A4-5AB8-4E53-BC18-E01F7C653E5E"}]}]}], "references": [{"url": "https://github.com/tensorflow/tensorflow/commit/83dcb4dbfa094e33db084e97c4d0531a559e0ebf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-p7hr-f446-x6qf", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/83dcb4dbfa094e33db084e97c4d0531a559e0ebf"}}