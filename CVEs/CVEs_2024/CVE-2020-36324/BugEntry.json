{"buggy_code": ["import json\nimport os\nimport sqlite3\n\nfrom flask import Flask, render_template, redirect, g, request, url_for, Response\nfrom sqlalchemy import desc, func\nfrom sqlalchemy.exc import IntegrityError\nimport yaml\n\nfrom . import worker, output\nfrom .connections import Connections\nfrom .login import auth\nfrom .models.user import UserGroup\nfrom .models.query import Query\nfrom .models.queryrevision import QueryRevision\nfrom .models.queryrun import QueryRun\nfrom .models.star import Star\nfrom .redissession import RedisSessionInterface\nfrom .results import SQLiteResultReader\nfrom .user import user_blueprint, get_user, get_preferences\nfrom .utils import json_formatter\nfrom .utils import monkey as _unused  # noqa: F401\nfrom .utils.pagination import RangeBasedPagination\nfrom .health import health_blueprint\nfrom .webhelpers import templatehelpers\n\n__dir__ = os.path.dirname(__file__)\n\napp = Flask(__name__)\napp.config.update(yaml.load(open(os.path.join(__dir__, \"../default_config.yaml\"))))\ntry:\n    app.config.update(yaml.load(open(os.path.join(__dir__, \"../config.yaml\"))))\nexcept IOError:\n    # Is ok if we can't load config.yaml\n    pass\n\napp.register_blueprint(auth)\napp.register_blueprint(health_blueprint)\napp.register_blueprint(user_blueprint)\napp.register_blueprint(templatehelpers)\n\nglobal_conn = Connections(app.config)\napp.session_interface = RedisSessionInterface(global_conn.redis)\n\n\nclass QueriesRangeBasedPagination(RangeBasedPagination):\n    def get_page_link(self, page_key, limit):\n        get_params = dict(request.args)\n        get_params.update({\n            'from': page_key, 'limit': limit})\n        return url_for('query_runs_all', **dict(\n            [(key, value) for key, value in list(get_params.items())])\n        )\n\n    def order_queryset(self):\n        if self.direction == 'next':\n            self.queryset = self.queryset.order_by(desc(QueryRun.timestamp))\n        else:\n            self.queryset = self.queryset.order_by(QueryRun.timestamp)\n\n    def filter_queryset(self):\n        if self.page_key is None:\n            return\n        from_query = g.conn.session.query(Query).get(self.page_key)\n        if from_query:\n            from_qrun_id = from_query.latest_rev.latest_run.id\n            if self.direction == 'prev':\n                self.queryset = self.queryset.filter(\n                    QueryRun.id > from_qrun_id)\n            else:\n                self.queryset = self.queryset.filter(\n                    QueryRun.id < from_qrun_id)\n\n\n@app.before_request\ndef setup_context():\n    g.conn = Connections(app.config)\n\n\n@app.teardown_request\ndef kill_context(exception=None):\n    g.conn.close_all()\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"landing.html\", user=get_user())\n\n\n@app.route(\"/api/query/unstar\", methods=[\"POST\"])\ndef unstar_query():\n    if get_user() is None:\n        return \"Unauthorized access\", 403\n    query = g.conn.session.query(Query).get(request.form['query_id'])\n    if query:\n        star = g.conn.session.query(Star)\\\n            .filter(Star.query_id == request.form['query_id'])\\\n            .filter(Star.user_id == get_user().id)\\\n            .one()\n        g.conn.session.delete(star)\n        g.conn.session.commit()\n        return \"\"\n    else:\n        return \"Query not found\", 404\n\n\n@app.route(\"/api/query/star\", methods=[\"POST\"])\ndef star_query():\n    if get_user() is None:\n        return \"Unauthorized access\", 403\n    query = g.conn.session.query(Query).get(request.form['query_id'])\n    if query:\n        star = Star()\n        star.user = get_user()\n        star.query = query\n        g.conn.session.add(star)\n        try:\n            g.conn.session.commit()\n        except IntegrityError as e:\n            if e.args[0] == 1062:  # Duplicate\n                g.conn.session.rollback()\n            else:\n                raise\n        return \"\"\n    else:\n        return \"Query not found\", 404\n\n\n@app.route(\"/query/new\")\ndef new_query():\n    if get_user() is None:\n        return redirect(\"/login?next=/query/new\")\n    query = Query()\n    query.user = get_user()\n    g.conn.session.add(query)\n    g.conn.session.commit()\n    return redirect(url_for('query_show', query_id=query.id))\n\n\n@app.route(\"/fork/<int:id>\")\ndef fork_query(id):\n    if get_user() is None:\n        return redirect(\"/login?next=fork/{id}\".format(id=id))\n    query = Query()\n    query.user = get_user()\n    parent_query = g.conn.session.query(Query).filter(Query.id == id).one()\n    query.title = parent_query.title\n    query.parent_id = parent_query.id\n    query.description = parent_query.description\n    g.conn.session.add(query)\n    g.conn.session.commit()\n\n    query_rev = QueryRevision(query_id=query.id, text=parent_query.latest_rev.text)\n    query.latest_rev = query_rev\n    g.conn.session.add(query)\n    g.conn.session.add(query_rev)\n    g.conn.session.commit()\n    return redirect(url_for('query_show', query_id=query.id))\n\n\n@app.route(\"/query/<int:query_id>\")\ndef query_show(query_id):\n    query = g.conn.session.query(Query).filter(Query.id == query_id).one()\n    can_edit = get_user() is not None and get_user().id == query.user_id\n    is_starred = False\n    if get_user():\n        is_starred = g.conn.session.query(func.count(Star.id))\\\n            .filter(Star.user_id == get_user().id)\\\n            .filter(Star.query_id == query_id).scalar() == 1\n    jsvars = {\n        'query_id': query.id,\n        'can_edit': can_edit,\n        'is_starred': is_starred,\n        'published': query.published,\n        'preferences': get_preferences()\n    }\n\n    if query.latest_rev and query.latest_rev.latest_run_id:\n        jsvars['qrun_id'] = query.latest_rev.latest_run_id\n\n    return render_template(\n        \"query/view.html\",\n        user=get_user(),\n        query=query,\n        jsvars=jsvars,\n        latest_rev=query.latest_rev\n    )\n\n\n@app.route('/query/<int:query_id>/result/latest/<string:resultset_id>/<string:format>')\ndef query_output_redirect(query_id, resultset_id, format):\n    query = g.conn.session.query(Query).filter(Query.id == query_id).one()\n    qrun_id = query.latest_rev.latest_run_id\n    # FIXME: Enforce HTTPS everywhere in a nicer way!\n    resp = redirect(\n        url_for('output_result', qrun_id=qrun_id,\n                resultset_id=resultset_id, format=format,\n                _external=True, _scheme='https')\n    )\n    # CORS on the redirect\n    resp.headers.add('Access-Control-Allow-Origin', '*')\n    return resp\n\n\n@app.route('/api/query/meta', methods=['POST'])\ndef api_set_meta():\n    if get_user() is None:\n        return \"Authentication required\", 401\n\n    query = g.conn.session.query(Query).filter(Query.id == request.form['query_id']).one()\n\n    if query.user_id != get_user().id:\n        return \"Authorization denied\", 403\n\n    if 'title' in request.form:\n        query.title = request.form['title']\n    if 'published' in request.form:\n        query.published = request.form['published'] == '1'\n    if 'description' in request.form:\n        query.description = request.form['description']\n    g.conn.session.add(query)\n    g.conn.session.commit()\n    return json.dumps({'id': query.id})\n\n\n@app.route('/api/query/run', methods=['POST'])\ndef api_run_query():\n    if get_user() is None:\n        return \"Authentication required\", 401\n    text = request.form['text']\n    query = g.conn.session.query(Query).filter(Query.id == request.form['query_id']).one()\n\n    if query.user_id != get_user().id or \\\n            g.conn.session.query(UserGroup).filter(UserGroup.user_id == get_user().id) \\\n            .filter(UserGroup.group_name == 'blocked').first():\n        return \"Authorization denied\", 403\n\n    if query.latest_rev and query.latest_rev.latest_run:\n        result = worker.run_query.AsyncResult(query.latest_rev.latest_run.task_id)\n        if not result.ready():\n            result.revoke(terminate=True)\n            query.latest_rev.latest_run.status = QueryRun.STATUS_SUPERSEDED\n            g.conn.session.add(query.latest_rev.latest_run)\n            g.conn.session.commit()\n\n    query_rev = QueryRevision(query_id=query.id, text=text)\n    query.latest_rev = query_rev\n\n    # XXX (phuedx, 2014/08/08): This deviates from the pre-existing\n    # QueryRevision interface, but I'm not confident that SQLAlchemy would\n    # invalidate a cached result for a relationship if a property changed.\n    query_run = QueryRun()\n    query_run.rev = query_rev\n    query_run.status = QueryRun.STATUS_QUEUED\n\n    g.conn.session.add(query_run)\n    g.conn.session.add(query)\n    g.conn.session.commit()\n    query_rev.latest_run = query_run\n    query_run.task_id = worker.run_query.delay(query_run.id).task_id\n    g.conn.session.add(query_rev)\n    g.conn.session.add(query_run)\n    g.conn.session.commit()\n    return json.dumps({\n        'qrun_id': query_run.id\n    })\n\n\n@app.route(\"/query/runs/all\")\ndef query_runs_all():\n    queries = g.conn.session.query(Query)\\\n        .join(Query.latest_rev).join(QueryRevision.latest_run)\n    queries_filter = 'all'\n    if request.args.get('published') == 'true':\n        queries = queries.filter(Query.published)\n        queries_filter = 'published'\n    limit = int(request.args.get(\n        'limit', app.config.get('QUERY_RESULTS_PER_PAGE', 50)))\n    queries, prev_link, next_link = QueriesRangeBasedPagination(\n        queries, request.args.get('from'), limit,\n        request.path,\n        request.referrer, dict(request.args)).paginate()\n    return render_template(\n        \"query/list.html\", user=get_user(), queries=queries,\n        prev_link=prev_link, next_link=next_link,\n        queries_filter=queries_filter)\n\n\n@app.route('/run/<int:qrun_id>/status')\ndef run_status(qrun_id):\n    qrun = g.conn.session.query(QueryRun).get(qrun_id)\n    if not qrun:\n        return Response('No such query_run id', status=404)\n    return Response(json.dumps({\n        'status': qrun.status_message,\n        'extra': json.loads(qrun.extra_info or '{}'),\n        'timestamp': qrun.timestamp.strftime('%s')\n    }), mimetype='application/json', headers={'Access-Control-Allow-Origin': '*'})\n\n\n@app.route(\"/run/<int:qrun_id>/output/<int:resultset_id>/<string:format>\")\ndef output_result(qrun_id, resultset_id=0, format='json'):\n    qrun = g.conn.session.query(QueryRun).get(qrun_id)\n    if not qrun:\n        response = Response('No such query_run id', status=404)\n    else:\n        reader = SQLiteResultReader(qrun, app.config['OUTPUT_PATH_TEMPLATE'])\n        try:\n            response = output.get_formatted_response(format, qrun, reader, resultset_id)\n        except sqlite3.OperationalError as e:\n            if e.args[0].startswith('no such table'):\n                response = Response('No such resultset id', status=404)\n            else:\n                raise\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    return response\n\n\n@app.route(\"/run/<int:qrun_id>/meta\")\ndef output_run_meta(qrun_id):\n    qrun = g.conn.session.query(QueryRun).get(qrun_id)\n    if not qrun:\n        return Response('No such query run id', status=404)\n    return Response(json.dumps(\n        {\n            'run': qrun,\n            'rev': qrun.rev,\n            'query': qrun.rev.query\n        }, default=json_formatter),\n        mimetype='application/json',\n        headers={'Access-Control-Allow-Origin': '*'},\n    )\n\n\n@app.route(\"/rev/<int:rev_id>/meta\")\ndef output_rev_meta(rev_id):\n    rev = g.conn.session.query(QueryRevision).get(rev_id)\n    if not rev:\n        return Response('No such query revision id', status=404)\n    return Response(json.dumps(\n        {\n            'latest_run': rev.latest_run,\n            'rev': rev,\n            'query': rev.query\n        }, default=json_formatter),\n        mimetype='application/json',\n        headers={'Access-Control-Allow-Origin': '*'},\n    )\n\n\n@app.route(\"/query/<int:query_id>/meta\")\ndef output_query_meta(query_id):\n    query = g.conn.session.query(Query).get(query_id)\n    if not query:\n        return Response('No such query id', status=404)\n    return Response(json.dumps(\n        {\n            'latest_run': query.latest_rev.latest_run,\n            'latest_rev': query.latest_rev,\n            'query': query\n        }, default=json_formatter),\n        mimetype='application/json',\n        headers={'Access-Control-Allow-Origin': '*'},\n    )\n\n\n@app.route(\"/explain/<int:connection_id>\")\ndef output_explain(connection_id):\n    cur = g.conn.replica.cursor()\n    try:\n        cur.execute('SHOW EXPLAIN FOR %d;' % connection_id)\n    except cur.InternalError as e:\n        if e.args[0] in [1094, 1915, 1933]:\n            # 1094 = Unknown thread id\n            # 1915, 1933 = Target is not running an EXPLAINable command\n            return Response(json.dumps(\n                {\n                    'headers': ['Error'],\n                    'rows': [['Hmm... Is the SQL actually running?!']],\n                }, default=json_formatter),\n                mimetype='application/json',\n            )\n        else:\n            raise\n    else:\n        return Response(json.dumps(\n            {\n                'headers': [c[0] for c in cur.description],\n                'rows': cur.fetchall(),\n            }, default=json_formatter),\n            mimetype='application/json',\n        )\n\n\n@app.route(\"/api/preferences/get/<key>\")\ndef pref_get(key):\n    if get_user() is None:\n        return \"Authentication required\", 401\n\n    if key in get_preferences():\n        return Response(json.dumps({'key': key, 'value': get_preferences()[key]}))\n    else:\n        return Response(json.dumps({'key': key, 'error': 'novalue'}))\n\n\n@app.route(\"/api/preferences/set/<key>/<value>\")\ndef pref_set(key, value):\n    if get_user() is None:\n        return \"Authentication required\", 401\n\n    get_preferences()[key] = (None if value == 'null' else value)\n    return Response(json.dumps({'key': key, 'success': ''})), 201\n\n\nif __name__ == '__main__':\n    app.run(port=5000, host=\"0.0.0.0\")\n"], "fixing_code": ["import json\nimport os\nimport sqlite3\n\nfrom flask import Flask, render_template, redirect, g, request, url_for, Response\nfrom sqlalchemy import desc, func\nfrom sqlalchemy.exc import IntegrityError\nimport yaml\n\nfrom . import worker, output\nfrom .connections import Connections\nfrom .login import auth\nfrom .models.user import UserGroup\nfrom .models.query import Query\nfrom .models.queryrevision import QueryRevision\nfrom .models.queryrun import QueryRun\nfrom .models.star import Star\nfrom .redissession import RedisSessionInterface\nfrom .results import SQLiteResultReader\nfrom .user import user_blueprint, get_user, get_preferences\nfrom .utils import json_formatter\nfrom .utils import monkey as _unused  # noqa: F401\nfrom .utils.pagination import RangeBasedPagination\nfrom .health import health_blueprint\nfrom .webhelpers import templatehelpers\n\n__dir__ = os.path.dirname(__file__)\n\napp = Flask(__name__)\napp.config.update(yaml.load(open(os.path.join(__dir__, \"../default_config.yaml\"))))\ntry:\n    app.config.update(yaml.load(open(os.path.join(__dir__, \"../config.yaml\"))))\nexcept IOError:\n    # Is ok if we can't load config.yaml\n    pass\n\napp.register_blueprint(auth)\napp.register_blueprint(health_blueprint)\napp.register_blueprint(user_blueprint)\napp.register_blueprint(templatehelpers)\n\nglobal_conn = Connections(app.config)\napp.session_interface = RedisSessionInterface(global_conn.redis)\n\n\nclass QueriesRangeBasedPagination(RangeBasedPagination):\n    def get_page_link(self, page_key, limit):\n        get_params = dict(request.args)\n        get_params.update({\n            'from': page_key, 'limit': limit})\n        return url_for('query_runs_all', **dict(\n            [(key, value) for key, value in list(get_params.items())])\n        )\n\n    def order_queryset(self):\n        if self.direction == 'next':\n            self.queryset = self.queryset.order_by(desc(QueryRun.timestamp))\n        else:\n            self.queryset = self.queryset.order_by(QueryRun.timestamp)\n\n    def filter_queryset(self):\n        if self.page_key is None:\n            return\n        from_query = g.conn.session.query(Query).get(self.page_key)\n        if from_query:\n            from_qrun_id = from_query.latest_rev.latest_run.id\n            if self.direction == 'prev':\n                self.queryset = self.queryset.filter(\n                    QueryRun.id > from_qrun_id)\n            else:\n                self.queryset = self.queryset.filter(\n                    QueryRun.id < from_qrun_id)\n\n\n@app.before_request\ndef setup_context():\n    g.conn = Connections(app.config)\n\n\n@app.teardown_request\ndef kill_context(exception=None):\n    g.conn.close_all()\n\n\n@app.route(\"/\")\ndef index():\n    return render_template(\"landing.html\", user=get_user())\n\n\n@app.route(\"/api/query/unstar\", methods=[\"POST\"])\ndef unstar_query():\n    if get_user() is None:\n        return \"Unauthorized access\", 403\n    query = g.conn.session.query(Query).get(request.form['query_id'])\n    if query:\n        star = g.conn.session.query(Star)\\\n            .filter(Star.query_id == request.form['query_id'])\\\n            .filter(Star.user_id == get_user().id)\\\n            .one()\n        g.conn.session.delete(star)\n        g.conn.session.commit()\n        return \"\"\n    else:\n        return \"Query not found\", 404\n\n\n@app.route(\"/api/query/star\", methods=[\"POST\"])\ndef star_query():\n    if get_user() is None:\n        return \"Unauthorized access\", 403\n    query = g.conn.session.query(Query).get(request.form['query_id'])\n    if query:\n        star = Star()\n        star.user = get_user()\n        star.query = query\n        g.conn.session.add(star)\n        try:\n            g.conn.session.commit()\n        except IntegrityError as e:\n            if e.args[0] == 1062:  # Duplicate\n                g.conn.session.rollback()\n            else:\n                raise\n        return \"\"\n    else:\n        return \"Query not found\", 404\n\n\n@app.route(\"/query/new\")\ndef new_query():\n    if get_user() is None:\n        return redirect(\"/login?next=/query/new\")\n    query = Query()\n    query.user = get_user()\n    g.conn.session.add(query)\n    g.conn.session.commit()\n    return redirect(url_for('query_show', query_id=query.id))\n\n\n@app.route(\"/fork/<int:id>\")\ndef fork_query(id):\n    if get_user() is None:\n        return redirect(\"/login?next=fork/{id}\".format(id=id))\n    query = Query()\n    query.user = get_user()\n    parent_query = g.conn.session.query(Query).filter(Query.id == id).one()\n    query.title = parent_query.title\n    query.parent_id = parent_query.id\n    query.description = parent_query.description\n    g.conn.session.add(query)\n    g.conn.session.commit()\n\n    query_rev = QueryRevision(query_id=query.id, text=parent_query.latest_rev.text)\n    query.latest_rev = query_rev\n    g.conn.session.add(query)\n    g.conn.session.add(query_rev)\n    g.conn.session.commit()\n    return redirect(url_for('query_show', query_id=query.id))\n\n\n@app.route(\"/query/<int:query_id>\")\ndef query_show(query_id):\n    query = g.conn.session.query(Query).filter(Query.id == query_id).one()\n    can_edit = get_user() is not None and get_user().id == query.user_id\n    is_starred = False\n    if get_user():\n        is_starred = g.conn.session.query(func.count(Star.id))\\\n            .filter(Star.user_id == get_user().id)\\\n            .filter(Star.query_id == query_id).scalar() == 1\n    jsvars = {\n        'query_id': query.id,\n        'can_edit': can_edit,\n        'is_starred': is_starred,\n        'published': query.published,\n        'preferences': get_preferences()\n    }\n\n    if query.latest_rev and query.latest_rev.latest_run_id:\n        jsvars['qrun_id'] = query.latest_rev.latest_run_id\n\n    return render_template(\n        \"query/view.html\",\n        user=get_user(),\n        query=query,\n        jsvars=jsvars,\n        latest_rev=query.latest_rev\n    )\n\n\n@app.route('/query/<int:query_id>/result/latest/<string:resultset_id>/<string:format>')\ndef query_output_redirect(query_id, resultset_id, format):\n    query = g.conn.session.query(Query).filter(Query.id == query_id).one()\n    qrun_id = query.latest_rev.latest_run_id\n    # FIXME: Enforce HTTPS everywhere in a nicer way!\n    resp = redirect(\n        url_for('output_result', qrun_id=qrun_id,\n                resultset_id=resultset_id, format=format,\n                _external=True, _scheme='https')\n    )\n    # CORS on the redirect\n    resp.headers.add('Access-Control-Allow-Origin', '*')\n    return resp\n\n\n@app.route('/api/query/meta', methods=['POST'])\ndef api_set_meta():\n    if get_user() is None:\n        return \"Authentication required\", 401\n\n    query = g.conn.session.query(Query).filter(Query.id == request.form['query_id']).one()\n\n    if query.user_id != get_user().id:\n        return \"Authorization denied\", 403\n\n    if 'title' in request.form:\n        query.title = request.form['title']\n    if 'published' in request.form:\n        query.published = request.form['published'] == '1'\n    if 'description' in request.form:\n        query.description = request.form['description']\n    g.conn.session.add(query)\n    g.conn.session.commit()\n    return json.dumps({'id': query.id})\n\n\n@app.route('/api/query/run', methods=['POST'])\ndef api_run_query():\n    if get_user() is None:\n        return \"Authentication required\", 401\n    text = request.form['text']\n    query = g.conn.session.query(Query).filter(Query.id == request.form['query_id']).one()\n\n    if query.user_id != get_user().id or \\\n            g.conn.session.query(UserGroup).filter(UserGroup.user_id == get_user().id) \\\n            .filter(UserGroup.group_name == 'blocked').first():\n        return \"Authorization denied\", 403\n\n    if query.latest_rev and query.latest_rev.latest_run:\n        result = worker.run_query.AsyncResult(query.latest_rev.latest_run.task_id)\n        if not result.ready():\n            result.revoke(terminate=True)\n            query.latest_rev.latest_run.status = QueryRun.STATUS_SUPERSEDED\n            g.conn.session.add(query.latest_rev.latest_run)\n            g.conn.session.commit()\n\n    query_rev = QueryRevision(query_id=query.id, text=text)\n    query.latest_rev = query_rev\n\n    # XXX (phuedx, 2014/08/08): This deviates from the pre-existing\n    # QueryRevision interface, but I'm not confident that SQLAlchemy would\n    # invalidate a cached result for a relationship if a property changed.\n    query_run = QueryRun()\n    query_run.rev = query_rev\n    query_run.status = QueryRun.STATUS_QUEUED\n\n    g.conn.session.add(query_run)\n    g.conn.session.add(query)\n    g.conn.session.commit()\n    query_rev.latest_run = query_run\n    query_run.task_id = worker.run_query.delay(query_run.id).task_id\n    g.conn.session.add(query_rev)\n    g.conn.session.add(query_run)\n    g.conn.session.commit()\n    return json.dumps({\n        'qrun_id': query_run.id\n    })\n\n\n@app.route(\"/query/runs/all\")\ndef query_runs_all():\n    queries = g.conn.session.query(Query)\\\n        .join(Query.latest_rev).join(QueryRevision.latest_run)\n    queries_filter = 'all'\n    if request.args.get('published') == 'true':\n        queries = queries.filter(Query.published)\n        queries_filter = 'published'\n    limit = int(request.args.get(\n        'limit', app.config.get('QUERY_RESULTS_PER_PAGE', 50)))\n    queries, prev_link, next_link = QueriesRangeBasedPagination(\n        queries, request.args.get('from'), limit,\n        request.path,\n        request.referrer, dict(request.args)).paginate()\n    return render_template(\n        \"query/list.html\", user=get_user(), queries=queries,\n        prev_link=prev_link, next_link=next_link,\n        queries_filter=queries_filter)\n\n\n@app.route('/run/<int:qrun_id>/status')\ndef run_status(qrun_id):\n    qrun = g.conn.session.query(QueryRun).get(qrun_id)\n    if not qrun:\n        return Response('No such query_run id', status=404)\n    return Response(json.dumps({\n        'status': qrun.status_message,\n        'extra': json.loads(qrun.extra_info or '{}'),\n        'timestamp': qrun.timestamp.strftime('%s')\n    }), mimetype='application/json', headers={'Access-Control-Allow-Origin': '*'})\n\n\n@app.route(\"/run/<int:qrun_id>/output/<int:resultset_id>/<string:format>\")\ndef output_result(qrun_id, resultset_id=0, format='json'):\n    qrun = g.conn.session.query(QueryRun).get(qrun_id)\n    if not qrun:\n        response = Response('No such query_run id', status=404)\n    else:\n        reader = SQLiteResultReader(qrun, app.config['OUTPUT_PATH_TEMPLATE'])\n        try:\n            response = output.get_formatted_response(format, qrun, reader, resultset_id)\n        except sqlite3.OperationalError as e:\n            if e.args[0].startswith('no such table'):\n                response = Response('No such resultset id', status=404)\n            else:\n                raise\n    response.headers['Access-Control-Allow-Origin'] = '*'\n    return response\n\n\n@app.route(\"/run/<int:qrun_id>/meta\")\ndef output_run_meta(qrun_id):\n    qrun = g.conn.session.query(QueryRun).get(qrun_id)\n    if not qrun:\n        return Response('No such query run id', status=404)\n    return Response(json.dumps(\n        {\n            'run': qrun,\n            'rev': qrun.rev,\n            'query': qrun.rev.query\n        }, default=json_formatter),\n        mimetype='application/json',\n        headers={'Access-Control-Allow-Origin': '*'},\n    )\n\n\n@app.route(\"/rev/<int:rev_id>/meta\")\ndef output_rev_meta(rev_id):\n    rev = g.conn.session.query(QueryRevision).get(rev_id)\n    if not rev:\n        return Response('No such query revision id', status=404)\n    return Response(json.dumps(\n        {\n            'latest_run': rev.latest_run,\n            'rev': rev,\n            'query': rev.query\n        }, default=json_formatter),\n        mimetype='application/json',\n        headers={'Access-Control-Allow-Origin': '*'},\n    )\n\n\n@app.route(\"/query/<int:query_id>/meta\")\ndef output_query_meta(query_id):\n    query = g.conn.session.query(Query).get(query_id)\n    if not query:\n        return Response('No such query id', status=404)\n    return Response(json.dumps(\n        {\n            'latest_run': query.latest_rev.latest_run,\n            'latest_rev': query.latest_rev,\n            'query': query\n        }, default=json_formatter),\n        mimetype='application/json',\n        headers={'Access-Control-Allow-Origin': '*'},\n    )\n\n\n@app.route(\"/explain/<int:connection_id>\")\ndef output_explain(connection_id):\n    cur = g.conn.replica.cursor()\n    try:\n        cur.execute('SHOW EXPLAIN FOR %d;' % connection_id)\n    except cur.InternalError as e:\n        if e.args[0] in [1094, 1915, 1933]:\n            # 1094 = Unknown thread id\n            # 1915, 1933 = Target is not running an EXPLAINable command\n            return Response(json.dumps(\n                {\n                    'headers': ['Error'],\n                    'rows': [['Hmm... Is the SQL actually running?!']],\n                }, default=json_formatter),\n                mimetype='application/json',\n            )\n        else:\n            raise\n    else:\n        return Response(json.dumps(\n            {\n                'headers': [c[0] for c in cur.description],\n                'rows': cur.fetchall(),\n            }, default=json_formatter),\n            mimetype='application/json',\n        )\n\n\n@app.route(\"/api/preferences/get/<key>\")\ndef pref_get(key):\n    if get_user() is None:\n        return \"Authentication required\", 401\n\n    if key in get_preferences():\n        return Response(\n            json.dumps({'key': key, 'value': get_preferences()[key]}),\n            mimetype='application/json'\n        )\n    else:\n        return Response(\n            json.dumps({'key': key, 'error': 'novalue'}),\n            mimetype='application/json'\n        )\n\n\n@app.route(\"/api/preferences/set/<key>/<value>\")\ndef pref_set(key, value):\n    if get_user() is None:\n        return \"Authentication required\", 401\n\n    get_preferences()[key] = (None if value == 'null' else value)\n    return Response(\n        json.dumps({'key': key, 'success': ''}),\n        mimetype='application/json'\n    ), 201\n\n\nif __name__ == '__main__':\n    app.run(port=5000, host=\"0.0.0.0\")\n"], "filenames": ["quarry/web/app.py"], "buggy_code_start_loc": [401], "buggy_code_end_loc": [413], "fixing_code_start_loc": [401], "fixing_code_end_loc": [422], "type": "CWE-79", "message": "Wikimedia Quarry analytics-quarry-web before 2020-12-15 allows Reflected XSS because app.py does not explicitly set the application/json content type.", "other": {"cve": {"id": "CVE-2020-36324", "sourceIdentifier": "cve@mitre.org", "published": "2021-04-21T20:15:36.870", "lastModified": "2021-04-26T15:46:32.680", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Wikimedia Quarry analytics-quarry-web before 2020-12-15 allows Reflected XSS because app.py does not explicitly set the application/json content type."}, {"lang": "es", "value": "Wikimedia Quarry analytics-quarry-web antes del 15-12-2020, permite un ataque de tipo XSS Reflejado, porque app.py no establece expl\u00edcitamente el tipo de contenido application/json"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 6.1, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:P/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-79"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:wikimedia:analytics-quarry-web:*:*:*:*:*:*:*:*", "versionEndExcluding": "2020-12-15", "matchCriteriaId": "0EBCF64D-CF03-4EAC-B8DA-2478AF3D5652"}]}]}], "references": [{"url": "https://github.com/wikimedia/analytics-quarry-web/commit/4b7e1d6a3a52ec6cf826a971135a38b0f74785d2", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://quarry.wmflabs.org/", "source": "cve@mitre.org", "tags": ["Product", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/wikimedia/analytics-quarry-web/commit/4b7e1d6a3a52ec6cf826a971135a38b0f74785d2"}}