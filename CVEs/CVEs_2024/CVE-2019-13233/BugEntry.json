{"buggy_code": ["/*\n * Utility functions for x86 operand and address decoding\n *\n * Copyright (C) Intel Corporation 2017\n */\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n#include <linux/mmu_context.h>\n#include <asm/desc_defs.h>\n#include <asm/desc.h>\n#include <asm/inat.h>\n#include <asm/insn.h>\n#include <asm/insn-eval.h>\n#include <asm/ldt.h>\n#include <asm/vm86.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"insn: \" fmt\n\nenum reg_type {\n\tREG_TYPE_RM = 0,\n\tREG_TYPE_INDEX,\n\tREG_TYPE_BASE,\n};\n\n/**\n * is_string_insn() - Determine if instruction is a string instruction\n * @insn:\tInstruction containing the opcode to inspect\n *\n * Returns:\n *\n * true if the instruction, determined by the opcode, is any of the\n * string instructions as defined in the Intel Software Development manual.\n * False otherwise.\n */\nstatic bool is_string_insn(struct insn *insn)\n{\n\tinsn_get_opcode(insn);\n\n\t/* All string instructions have a 1-byte opcode. */\n\tif (insn->opcode.nbytes != 1)\n\t\treturn false;\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x6c ... 0x6f:\t/* INS, OUTS */\n\tcase 0xa4 ... 0xa7:\t/* MOVS, CMPS */\n\tcase 0xaa ... 0xaf:\t/* STOS, LODS, SCAS */\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/**\n * get_seg_reg_override_idx() - obtain segment register override index\n * @insn:\tValid instruction with segment override prefixes\n *\n * Inspect the instruction prefixes in @insn and find segment overrides, if any.\n *\n * Returns:\n *\n * A constant identifying the segment register to use, among CS, SS, DS,\n * ES, FS, or GS. INAT_SEG_REG_DEFAULT is returned if no segment override\n * prefixes were found.\n *\n * -EINVAL in case of error.\n */\nstatic int get_seg_reg_override_idx(struct insn *insn)\n{\n\tint idx = INAT_SEG_REG_DEFAULT;\n\tint num_overrides = 0, i;\n\n\tinsn_get_prefixes(insn);\n\n\t/* Look for any segment override prefixes. */\n\tfor (i = 0; i < insn->prefixes.nbytes; i++) {\n\t\tinsn_attr_t attr;\n\n\t\tattr = inat_get_opcode_attribute(insn->prefixes.bytes[i]);\n\t\tswitch (attr) {\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_CS):\n\t\t\tidx = INAT_SEG_REG_CS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_SS):\n\t\t\tidx = INAT_SEG_REG_SS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_DS):\n\t\t\tidx = INAT_SEG_REG_DS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_ES):\n\t\t\tidx = INAT_SEG_REG_ES;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_FS):\n\t\t\tidx = INAT_SEG_REG_FS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_GS):\n\t\t\tidx = INAT_SEG_REG_GS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\t/* No default action needed. */\n\t\t}\n\t}\n\n\t/* More than one segment override prefix leads to undefined behavior. */\n\tif (num_overrides > 1)\n\t\treturn -EINVAL;\n\n\treturn idx;\n}\n\n/**\n * check_seg_overrides() - check if segment override prefixes are allowed\n * @insn:\tValid instruction with segment override prefixes\n * @regoff:\tOperand offset, in pt_regs, for which the check is performed\n *\n * For a particular register used in register-indirect addressing, determine if\n * segment override prefixes can be used. Specifically, no overrides are allowed\n * for rDI if used with a string instruction.\n *\n * Returns:\n *\n * True if segment override prefixes can be used with the register indicated\n * in @regoff. False if otherwise.\n */\nstatic bool check_seg_overrides(struct insn *insn, int regoff)\n{\n\tif (regoff == offsetof(struct pt_regs, di) && is_string_insn(insn))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * resolve_default_seg() - resolve default segment register index for an operand\n * @insn:\tInstruction with opcode and address size. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @off:\tOperand offset, in pt_regs, for which resolution is needed\n *\n * Resolve the default segment register index associated with the instruction\n * operand register indicated by @off. Such index is resolved based on defaults\n * described in the Intel Software Development Manual.\n *\n * Returns:\n *\n * If in protected mode, a constant identifying the segment register to use,\n * among CS, SS, ES or DS. If in long mode, INAT_SEG_REG_IGNORE.\n *\n * -EINVAL in case of error.\n */\nstatic int resolve_default_seg(struct insn *insn, struct pt_regs *regs, int off)\n{\n\tif (user_64bit_mode(regs))\n\t\treturn INAT_SEG_REG_IGNORE;\n\t/*\n\t * Resolve the default segment register as described in Section 3.7.4\n\t * of the Intel Software Development Manual Vol. 1:\n\t *\n\t *  + DS for all references involving r[ABCD]X, and rSI.\n\t *  + If used in a string instruction, ES for rDI. Otherwise, DS.\n\t *  + AX, CX and DX are not valid register operands in 16-bit address\n\t *    encodings but are valid for 32-bit and 64-bit encodings.\n\t *  + -EDOM is reserved to identify for cases in which no register\n\t *    is used (i.e., displacement-only addressing). Use DS.\n\t *  + SS for rSP or rBP.\n\t *  + CS for rIP.\n\t */\n\n\tswitch (off) {\n\tcase offsetof(struct pt_regs, ax):\n\tcase offsetof(struct pt_regs, cx):\n\tcase offsetof(struct pt_regs, dx):\n\t\t/* Need insn to verify address size. */\n\t\tif (insn->addr_bytes == 2)\n\t\t\treturn -EINVAL;\n\n\t\t/* fall through */\n\n\tcase -EDOM:\n\tcase offsetof(struct pt_regs, bx):\n\tcase offsetof(struct pt_regs, si):\n\t\treturn INAT_SEG_REG_DS;\n\n\tcase offsetof(struct pt_regs, di):\n\t\tif (is_string_insn(insn))\n\t\t\treturn INAT_SEG_REG_ES;\n\t\treturn INAT_SEG_REG_DS;\n\n\tcase offsetof(struct pt_regs, bp):\n\tcase offsetof(struct pt_regs, sp):\n\t\treturn INAT_SEG_REG_SS;\n\n\tcase offsetof(struct pt_regs, ip):\n\t\treturn INAT_SEG_REG_CS;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * resolve_seg_reg() - obtain segment register index\n * @insn:\tInstruction with operands\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tOperand offset, in pt_regs, used to deterimine segment register\n *\n * Determine the segment register associated with the operands and, if\n * applicable, prefixes and the instruction pointed by @insn.\n *\n * The segment register associated to an operand used in register-indirect\n * addressing depends on:\n *\n * a) Whether running in long mode (in such a case segments are ignored, except\n * if FS or GS are used).\n *\n * b) Whether segment override prefixes can be used. Certain instructions and\n *    registers do not allow override prefixes.\n *\n * c) Whether segment overrides prefixes are found in the instruction prefixes.\n *\n * d) If there are not segment override prefixes or they cannot be used, the\n *    default segment register associated with the operand register is used.\n *\n * The function checks first if segment override prefixes can be used with the\n * operand indicated by @regoff. If allowed, obtain such overridden segment\n * register index. Lastly, if not prefixes were found or cannot be used, resolve\n * the segment register index to use based on the defaults described in the\n * Intel documentation. In long mode, all segment register indexes will be\n * ignored, except if overrides were found for FS or GS. All these operations\n * are done using helper functions.\n *\n * The operand register, @regoff, is represented as the offset from the base of\n * pt_regs.\n *\n * As stated, the main use of this function is to determine the segment register\n * index based on the instruction, its operands and prefixes. Hence, @insn\n * must be valid. However, if @regoff indicates rIP, we don't need to inspect\n * @insn at all as in this case CS is used in all cases. This case is checked\n * before proceeding further.\n *\n * Please note that this function does not return the value in the segment\n * register (i.e., the segment selector) but our defined index. The segment\n * selector needs to be obtained using get_segment_selector() and passing the\n * segment register index resolved by this function.\n *\n * Returns:\n *\n * An index identifying the segment register to use, among CS, SS, DS,\n * ES, FS, or GS. INAT_SEG_REG_IGNORE is returned if running in long mode.\n *\n * -EINVAL in case of error.\n */\nstatic int resolve_seg_reg(struct insn *insn, struct pt_regs *regs, int regoff)\n{\n\tint idx;\n\n\t/*\n\t * In the unlikely event of having to resolve the segment register\n\t * index for rIP, do it first. Segment override prefixes should not\n\t * be used. Hence, it is not necessary to inspect the instruction,\n\t * which may be invalid at this point.\n\t */\n\tif (regoff == offsetof(struct pt_regs, ip)) {\n\t\tif (user_64bit_mode(regs))\n\t\t\treturn INAT_SEG_REG_IGNORE;\n\t\telse\n\t\t\treturn INAT_SEG_REG_CS;\n\t}\n\n\tif (!insn)\n\t\treturn -EINVAL;\n\n\tif (!check_seg_overrides(insn, regoff))\n\t\treturn resolve_default_seg(insn, regs, regoff);\n\n\tidx = get_seg_reg_override_idx(insn);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tif (idx == INAT_SEG_REG_DEFAULT)\n\t\treturn resolve_default_seg(insn, regs, regoff);\n\n\t/*\n\t * In long mode, segment override prefixes are ignored, except for\n\t * overrides for FS and GS.\n\t */\n\tif (user_64bit_mode(regs)) {\n\t\tif (idx != INAT_SEG_REG_FS &&\n\t\t    idx != INAT_SEG_REG_GS)\n\t\t\tidx = INAT_SEG_REG_IGNORE;\n\t}\n\n\treturn idx;\n}\n\n/**\n * get_segment_selector() - obtain segment selector\n * @regs:\t\tRegister values as seen when entering kernel mode\n * @seg_reg_idx:\tSegment register index to use\n *\n * Obtain the segment selector from any of the CS, SS, DS, ES, FS, GS segment\n * registers. In CONFIG_X86_32, the segment is obtained from either pt_regs or\n * kernel_vm86_regs as applicable. In CONFIG_X86_64, CS and SS are obtained\n * from pt_regs. DS, ES, FS and GS are obtained by reading the actual CPU\n * registers. This done for only for completeness as in CONFIG_X86_64 segment\n * registers are ignored.\n *\n * Returns:\n *\n * Value of the segment selector, including null when running in\n * long mode.\n *\n * -EINVAL on error.\n */\nstatic short get_segment_selector(struct pt_regs *regs, int seg_reg_idx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned short sel;\n\n\tswitch (seg_reg_idx) {\n\tcase INAT_SEG_REG_IGNORE:\n\t\treturn 0;\n\tcase INAT_SEG_REG_CS:\n\t\treturn (unsigned short)(regs->cs & 0xffff);\n\tcase INAT_SEG_REG_SS:\n\t\treturn (unsigned short)(regs->ss & 0xffff);\n\tcase INAT_SEG_REG_DS:\n\t\tsavesegment(ds, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_ES:\n\t\tsavesegment(es, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_FS:\n\t\tsavesegment(fs, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_GS:\n\t\tsavesegment(gs, sel);\n\t\treturn sel;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n#else /* CONFIG_X86_32 */\n\tstruct kernel_vm86_regs *vm86regs = (struct kernel_vm86_regs *)regs;\n\n\tif (v8086_mode(regs)) {\n\t\tswitch (seg_reg_idx) {\n\t\tcase INAT_SEG_REG_CS:\n\t\t\treturn (unsigned short)(regs->cs & 0xffff);\n\t\tcase INAT_SEG_REG_SS:\n\t\t\treturn (unsigned short)(regs->ss & 0xffff);\n\t\tcase INAT_SEG_REG_DS:\n\t\t\treturn vm86regs->ds;\n\t\tcase INAT_SEG_REG_ES:\n\t\t\treturn vm86regs->es;\n\t\tcase INAT_SEG_REG_FS:\n\t\t\treturn vm86regs->fs;\n\t\tcase INAT_SEG_REG_GS:\n\t\t\treturn vm86regs->gs;\n\t\tcase INAT_SEG_REG_IGNORE:\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (seg_reg_idx) {\n\tcase INAT_SEG_REG_CS:\n\t\treturn (unsigned short)(regs->cs & 0xffff);\n\tcase INAT_SEG_REG_SS:\n\t\treturn (unsigned short)(regs->ss & 0xffff);\n\tcase INAT_SEG_REG_DS:\n\t\treturn (unsigned short)(regs->ds & 0xffff);\n\tcase INAT_SEG_REG_ES:\n\t\treturn (unsigned short)(regs->es & 0xffff);\n\tcase INAT_SEG_REG_FS:\n\t\treturn (unsigned short)(regs->fs & 0xffff);\n\tcase INAT_SEG_REG_GS:\n\t\t/*\n\t\t * GS may or may not be in regs as per CONFIG_X86_32_LAZY_GS.\n\t\t * The macro below takes care of both cases.\n\t\t */\n\t\treturn get_user_gs(regs);\n\tcase INAT_SEG_REG_IGNORE:\n\t\t/* fall through */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n#endif /* CONFIG_X86_64 */\n}\n\nstatic int get_reg_offset(struct insn *insn, struct pt_regs *regs,\n\t\t\t  enum reg_type type)\n{\n\tint regno = 0;\n\n\tstatic const int regoff[] = {\n\t\toffsetof(struct pt_regs, ax),\n\t\toffsetof(struct pt_regs, cx),\n\t\toffsetof(struct pt_regs, dx),\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, sp),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n#ifdef CONFIG_X86_64\n\t\toffsetof(struct pt_regs, r8),\n\t\toffsetof(struct pt_regs, r9),\n\t\toffsetof(struct pt_regs, r10),\n\t\toffsetof(struct pt_regs, r11),\n\t\toffsetof(struct pt_regs, r12),\n\t\toffsetof(struct pt_regs, r13),\n\t\toffsetof(struct pt_regs, r14),\n\t\toffsetof(struct pt_regs, r15),\n#endif\n\t};\n\tint nr_registers = ARRAY_SIZE(regoff);\n\t/*\n\t * Don't possibly decode a 32-bit instructions as\n\t * reading a 64-bit-only register.\n\t */\n\tif (IS_ENABLED(CONFIG_X86_64) && !insn->x86_64)\n\t\tnr_registers -= 8;\n\n\tswitch (type) {\n\tcase REG_TYPE_RM:\n\t\tregno = X86_MODRM_RM(insn->modrm.value);\n\n\t\t/*\n\t\t * ModRM.mod == 0 and ModRM.rm == 5 means a 32-bit displacement\n\t\t * follows the ModRM byte.\n\t\t */\n\t\tif (!X86_MODRM_MOD(insn->modrm.value) && regno == 5)\n\t\t\treturn -EDOM;\n\n\t\tif (X86_REX_B(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\t\tbreak;\n\n\tcase REG_TYPE_INDEX:\n\t\tregno = X86_SIB_INDEX(insn->sib.value);\n\t\tif (X86_REX_X(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\n\t\t/*\n\t\t * If ModRM.mod != 3 and SIB.index = 4 the scale*index\n\t\t * portion of the address computation is null. This is\n\t\t * true only if REX.X is 0. In such a case, the SIB index\n\t\t * is used in the address computation.\n\t\t */\n\t\tif (X86_MODRM_MOD(insn->modrm.value) != 3 && regno == 4)\n\t\t\treturn -EDOM;\n\t\tbreak;\n\n\tcase REG_TYPE_BASE:\n\t\tregno = X86_SIB_BASE(insn->sib.value);\n\t\t/*\n\t\t * If ModRM.mod is 0 and SIB.base == 5, the base of the\n\t\t * register-indirect addressing is 0. In this case, a\n\t\t * 32-bit displacement follows the SIB byte.\n\t\t */\n\t\tif (!X86_MODRM_MOD(insn->modrm.value) && regno == 5)\n\t\t\treturn -EDOM;\n\n\t\tif (X86_REX_B(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err_ratelimited(\"invalid register type: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (regno >= nr_registers) {\n\t\tWARN_ONCE(1, \"decoded an instruction with an invalid register\");\n\t\treturn -EINVAL;\n\t}\n\treturn regoff[regno];\n}\n\n/**\n * get_reg_offset_16() - Obtain offset of register indicated by instruction\n * @insn:\tInstruction containing ModRM byte\n * @regs:\tRegister values as seen when entering kernel mode\n * @offs1:\tOffset of the first operand register\n * @offs2:\tOffset of the second opeand register, if applicable\n *\n * Obtain the offset, in pt_regs, of the registers indicated by the ModRM byte\n * in @insn. This function is to be used with 16-bit address encodings. The\n * @offs1 and @offs2 will be written with the offset of the two registers\n * indicated by the instruction. In cases where any of the registers is not\n * referenced by the instruction, the value will be set to -EDOM.\n *\n * Returns:\n *\n * 0 on success, -EINVAL on error.\n */\nstatic int get_reg_offset_16(struct insn *insn, struct pt_regs *regs,\n\t\t\t     int *offs1, int *offs2)\n{\n\t/*\n\t * 16-bit addressing can use one or two registers. Specifics of\n\t * encodings are given in Table 2-1. \"16-Bit Addressing Forms with the\n\t * ModR/M Byte\" of the Intel Software Development Manual.\n\t */\n\tstatic const int regoff1[] = {\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, bx),\n\t};\n\n\tstatic const int regoff2[] = {\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\t-EDOM,\n\t\t-EDOM,\n\t\t-EDOM,\n\t\t-EDOM,\n\t};\n\n\tif (!offs1 || !offs2)\n\t\treturn -EINVAL;\n\n\t/* Operand is a register, use the generic function. */\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\t*offs1 = insn_get_modrm_rm_off(insn, regs);\n\t\t*offs2 = -EDOM;\n\t\treturn 0;\n\t}\n\n\t*offs1 = regoff1[X86_MODRM_RM(insn->modrm.value)];\n\t*offs2 = regoff2[X86_MODRM_RM(insn->modrm.value)];\n\n\t/*\n\t * If ModRM.mod is 0 and ModRM.rm is 110b, then we use displacement-\n\t * only addressing. This means that no registers are involved in\n\t * computing the effective address. Thus, ensure that the first\n\t * register offset is invalild. The second register offset is already\n\t * invalid under the aforementioned conditions.\n\t */\n\tif ((X86_MODRM_MOD(insn->modrm.value) == 0) &&\n\t    (X86_MODRM_RM(insn->modrm.value) == 6))\n\t\t*offs1 = -EDOM;\n\n\treturn 0;\n}\n\n/**\n * get_desc() - Obtain pointer to a segment descriptor\n * @sel:\tSegment selector\n *\n * Given a segment selector, obtain a pointer to the segment descriptor.\n * Both global and local descriptor tables are supported.\n *\n * Returns:\n *\n * Pointer to segment descriptor on success.\n *\n * NULL on error.\n */\nstatic struct desc_struct *get_desc(unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tstruct desc_struct *desc = NULL;\n\t\tstruct ldt_struct *ldt;\n\n\t\t/* Bits [15:3] contain the index of the desired entry. */\n\t\tsel >>= 3;\n\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries)\n\t\t\tdesc = &ldt->entries[sel];\n\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\n\t\treturn desc;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\n\t/*\n\t * Segment descriptors have a size of 8 bytes. Thus, the index is\n\t * multiplied by 8 to obtain the memory offset of the desired descriptor\n\t * from the base of the GDT. As bits [15:3] of the segment selector\n\t * contain the index, it can be regarded as multiplied by 8 already.\n\t * All that remains is to clear bits [2:0].\n\t */\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\n\tif (desc_base > gdt_desc.size)\n\t\treturn NULL;\n\n\treturn (struct desc_struct *)(gdt_desc.address + desc_base);\n}\n\n/**\n * insn_get_seg_base() - Obtain base address of segment descriptor.\n * @regs:\t\tRegister values as seen when entering kernel mode\n * @seg_reg_idx:\tIndex of the segment register pointing to seg descriptor\n *\n * Obtain the base address of the segment as indicated by the segment descriptor\n * pointed by the segment selector. The segment selector is obtained from the\n * input segment register index @seg_reg_idx.\n *\n * Returns:\n *\n * In protected mode, base address of the segment. Zero in long mode,\n * except when FS or GS are used. In virtual-8086 mode, the segment\n * selector shifted 4 bits to the right.\n *\n * -1L in case of error.\n */\nunsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t/*\n\t\t * Base is simply the segment selector shifted 4\n\t\t * bits to the right.\n\t\t */\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t/*\n\t\t * Only FS or GS will have a base address, the rest of\n\t\t * the segments' bases are forced to 0.\n\t\t */\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t/*\n\t\t\t * swapgs was called at the kernel entry point. Thus,\n\t\t\t * MSR_KERNEL_GS_BASE will have the user-space GS base.\n\t\t\t */\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t/* In protected mode the segment selector cannot be null. */\n\tif (!sel)\n\t\treturn -1L;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -1L;\n\n\treturn get_desc_base(desc);\n}\n\n/**\n * get_seg_limit() - Obtain the limit of a segment descriptor\n * @regs:\t\tRegister values as seen when entering kernel mode\n * @seg_reg_idx:\tIndex of the segment register pointing to seg descriptor\n *\n * Obtain the limit of the segment as indicated by the segment descriptor\n * pointed by the segment selector. The segment selector is obtained from the\n * input segment register index @seg_reg_idx.\n *\n * Returns:\n *\n * In protected mode, the limit of the segment descriptor in bytes.\n * In long mode and virtual-8086 mode, segment limits are not enforced. Thus,\n * limit is returned as -1L to imply a limit-less segment.\n *\n * Zero is returned on error.\n */\nstatic unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct *desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn 0;\n\n\t/*\n\t * If the granularity bit is set, the limit is given in multiples\n\t * of 4096. This also means that the 12 least significant bits are\n\t * not tested when checking the segment limits. In practice,\n\t * this means that the segment ends in (limit << 12) + 0xfff.\n\t */\n\tlimit = get_desc_limit(desc);\n\tif (desc->g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}\n\n/**\n * insn_get_code_seg_params() - Obtain code segment parameters\n * @regs:\tStructure with register values as seen when entering kernel mode\n *\n * Obtain address and operand sizes of the code segment. It is obtained from the\n * selector contained in the CS register in regs. In protected mode, the default\n * address is determined by inspecting the L and D bits of the segment\n * descriptor. In virtual-8086 mode, the default is always two bytes for both\n * address and operand sizes.\n *\n * Returns:\n *\n * An int containing ORed-in default parameters on success.\n *\n * -EINVAL on error.\n */\nint insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct *desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\t/* Address and operand size are both 16-bit. */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tdesc = get_desc(sel);\n\tif (!desc)\n\t\treturn -EINVAL;\n\n\t/*\n\t * The most significant byte of the Type field of the segment descriptor\n\t * determines whether a segment contains data or code. If this is a data\n\t * segment, return error.\n\t */\n\tif (!(desc->type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc->l << 1) | desc->d) {\n\tcase 0: /*\n\t\t * Legacy mode. CS.L=0, CS.D=0. Address and operand size are\n\t\t * both 16-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: /*\n\t\t * Legacy mode. CS.L=0, CS.D=1. Address and operand size are\n\t\t * both 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: /*\n\t\t * IA-32e 64-bit mode. CS.L=1, CS.D=0. Address size is 64-bit;\n\t\t * operand size is 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: /* Invalid setting. CS.L=1, CS.D=1 */\n\t\t/* fall through */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * insn_get_modrm_rm_off() - Obtain register in r/m part of the ModRM byte\n * @insn:\tInstruction containing the ModRM byte\n * @regs:\tRegister values as seen when entering kernel mode\n *\n * Returns:\n *\n * The register indicated by the r/m part of the ModRM byte. The\n * register is obtained as an offset from the base of pt_regs. In specific\n * cases, the returned value can be -EDOM to indicate that the particular value\n * of ModRM does not refer to a register and shall be ignored.\n */\nint insn_get_modrm_rm_off(struct insn *insn, struct pt_regs *regs)\n{\n\treturn get_reg_offset(insn, regs, REG_TYPE_RM);\n}\n\n/**\n * get_seg_base_limit() - obtain base address and limit of a segment\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tOperand offset, in pt_regs, used to resolve segment descriptor\n * @base:\tObtained segment base\n * @limit:\tObtained segment limit\n *\n * Obtain the base address and limit of the segment associated with the operand\n * @regoff and, if any or allowed, override prefixes in @insn. This function is\n * different from insn_get_seg_base() as the latter does not resolve the segment\n * associated with the instruction operand. If a limit is not needed (e.g.,\n * when running in long mode), @limit can be NULL.\n *\n * Returns:\n *\n * 0 on success. @base and @limit will contain the base address and of the\n * resolved segment, respectively.\n *\n * -EINVAL on error.\n */\nstatic int get_seg_base_limit(struct insn *insn, struct pt_regs *regs,\n\t\t\t      int regoff, unsigned long *base,\n\t\t\t      unsigned long *limit)\n{\n\tint seg_reg_idx;\n\n\tif (!base)\n\t\treturn -EINVAL;\n\n\tseg_reg_idx = resolve_seg_reg(insn, regs, regoff);\n\tif (seg_reg_idx < 0)\n\t\treturn seg_reg_idx;\n\n\t*base = insn_get_seg_base(regs, seg_reg_idx);\n\tif (*base == -1L)\n\t\treturn -EINVAL;\n\n\tif (!limit)\n\t\treturn 0;\n\n\t*limit = get_seg_limit(regs, seg_reg_idx);\n\tif (!(*limit))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_reg() - Obtain effective address from register operand\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, with the effective address\n * @eff_addr:\tObtained effective address\n *\n * Obtain the effective address stored in the register operand as indicated by\n * the ModRM byte. This function is to be used only with register addressing\n * (i.e.,  ModRM.mod is 3). The effective address is saved in @eff_addr. The\n * register operand, as an offset from the base of pt_regs, is saved in @regoff;\n * such offset can then be used to resolve the segment associated with the\n * operand. This function can be used with any of the supported address sizes\n * in x86.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the effective address stored in the\n * operand indicated by ModRM. @regoff will have such operand as an offset from\n * the base of pt_regs.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_reg(struct insn *insn, struct pt_regs *regs,\n\t\t\t    int *regoff, long *eff_addr)\n{\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) != 3)\n\t\treturn -EINVAL;\n\n\t*regoff = get_reg_offset(insn, regs, REG_TYPE_RM);\n\tif (*regoff < 0)\n\t\treturn -EINVAL;\n\n\t/* Ignore bytes that are outside the address size. */\n\tif (insn->addr_bytes == 2)\n\t\t*eff_addr = regs_get_register(regs, *regoff) & 0xffff;\n\telse if (insn->addr_bytes == 4)\n\t\t*eff_addr = regs_get_register(regs, *regoff) & 0xffffffff;\n\telse /* 64-bit address */\n\t\t*eff_addr = regs_get_register(regs, *regoff);\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_modrm() - Obtain referenced effective address via ModRM\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, associated with segment\n * @eff_addr:\tObtained effective address\n *\n * Obtain the effective address referenced by the ModRM byte of @insn. After\n * identifying the registers involved in the register-indirect memory reference,\n * its value is obtained from the operands in @regs. The computed address is\n * stored @eff_addr. Also, the register operand that indicates the associated\n * segment is stored in @regoff, this parameter can later be used to determine\n * such segment.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the referenced effective address. @regoff\n * will have a register, as an offset from the base of pt_regs, that can be used\n * to resolve the associated segment.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_modrm(struct insn *insn, struct pt_regs *regs,\n\t\t\t      int *regoff, long *eff_addr)\n{\n\tlong tmp;\n\n\tif (insn->addr_bytes != 8 && insn->addr_bytes != 4)\n\t\treturn -EINVAL;\n\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\t*regoff = get_reg_offset(insn, regs, REG_TYPE_RM);\n\n\t/*\n\t * -EDOM means that we must ignore the address_offset. In such a case,\n\t * in 64-bit mode the effective address relative to the rIP of the\n\t * following instruction.\n\t */\n\tif (*regoff == -EDOM) {\n\t\tif (user_64bit_mode(regs))\n\t\t\ttmp = regs->ip + insn->length;\n\t\telse\n\t\t\ttmp = 0;\n\t} else if (*regoff < 0) {\n\t\treturn -EINVAL;\n\t} else {\n\t\ttmp = regs_get_register(regs, *regoff);\n\t}\n\n\tif (insn->addr_bytes == 4) {\n\t\tint addr32 = (int)(tmp & 0xffffffff) + insn->displacement.value;\n\n\t\t*eff_addr = addr32 & 0xffffffff;\n\t} else {\n\t\t*eff_addr = tmp + insn->displacement.value;\n\t}\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_modrm_16() - Obtain referenced effective address via ModRM\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, associated with segment\n * @eff_addr:\tObtained effective address\n *\n * Obtain the 16-bit effective address referenced by the ModRM byte of @insn.\n * After identifying the registers involved in the register-indirect memory\n * reference, its value is obtained from the operands in @regs. The computed\n * address is stored @eff_addr. Also, the register operand that indicates\n * the associated segment is stored in @regoff, this parameter can later be used\n * to determine such segment.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the referenced effective address. @regoff\n * will have a register, as an offset from the base of pt_regs, that can be used\n * to resolve the associated segment.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_modrm_16(struct insn *insn, struct pt_regs *regs,\n\t\t\t\t int *regoff, short *eff_addr)\n{\n\tint addr_offset1, addr_offset2, ret;\n\tshort addr1 = 0, addr2 = 0, displacement;\n\n\tif (insn->addr_bytes != 2)\n\t\treturn -EINVAL;\n\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\tret = get_reg_offset_16(insn, regs, &addr_offset1, &addr_offset2);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't fail on invalid offset values. They might be invalid because\n\t * they cannot be used for this particular value of ModRM. Instead, use\n\t * them in the computation only if they contain a valid value.\n\t */\n\tif (addr_offset1 != -EDOM)\n\t\taddr1 = regs_get_register(regs, addr_offset1) & 0xffff;\n\n\tif (addr_offset2 != -EDOM)\n\t\taddr2 = regs_get_register(regs, addr_offset2) & 0xffff;\n\n\tdisplacement = insn->displacement.value & 0xffff;\n\t*eff_addr = addr1 + addr2 + displacement;\n\n\t/*\n\t * The first operand register could indicate to use of either SS or DS\n\t * registers to obtain the segment selector.  The second operand\n\t * register can only indicate the use of DS. Thus, the first operand\n\t * will be used to obtain the segment selector.\n\t */\n\t*regoff = addr_offset1;\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_sib() - Obtain referenced effective address via SIB\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, associated with segment\n * @eff_addr:\tObtained effective address\n *\n * Obtain the effective address referenced by the SIB byte of @insn. After\n * identifying the registers involved in the indexed, register-indirect memory\n * reference, its value is obtained from the operands in @regs. The computed\n * address is stored @eff_addr. Also, the register operand that indicates the\n * associated segment is stored in @regoff, this parameter can later be used to\n * determine such segment.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the referenced effective address.\n * @base_offset will have a register, as an offset from the base of pt_regs,\n * that can be used to resolve the associated segment.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_sib(struct insn *insn, struct pt_regs *regs,\n\t\t\t    int *base_offset, long *eff_addr)\n{\n\tlong base, indx;\n\tint indx_offset;\n\n\tif (insn->addr_bytes != 8 && insn->addr_bytes != 4)\n\t\treturn -EINVAL;\n\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\tinsn_get_sib(insn);\n\n\tif (!insn->sib.nbytes)\n\t\treturn -EINVAL;\n\n\t*base_offset = get_reg_offset(insn, regs, REG_TYPE_BASE);\n\tindx_offset = get_reg_offset(insn, regs, REG_TYPE_INDEX);\n\n\t/*\n\t * Negative values in the base and index offset means an error when\n\t * decoding the SIB byte. Except -EDOM, which means that the registers\n\t * should not be used in the address computation.\n\t */\n\tif (*base_offset == -EDOM)\n\t\tbase = 0;\n\telse if (*base_offset < 0)\n\t\treturn -EINVAL;\n\telse\n\t\tbase = regs_get_register(regs, *base_offset);\n\n\tif (indx_offset == -EDOM)\n\t\tindx = 0;\n\telse if (indx_offset < 0)\n\t\treturn -EINVAL;\n\telse\n\t\tindx = regs_get_register(regs, indx_offset);\n\n\tif (insn->addr_bytes == 4) {\n\t\tint addr32, base32, idx32;\n\n\t\tbase32 = base & 0xffffffff;\n\t\tidx32 = indx & 0xffffffff;\n\n\t\taddr32 = base32 + idx32 * (1 << X86_SIB_SCALE(insn->sib.value));\n\t\taddr32 += insn->displacement.value;\n\n\t\t*eff_addr = addr32 & 0xffffffff;\n\t} else {\n\t\t*eff_addr = base + indx * (1 << X86_SIB_SCALE(insn->sib.value));\n\t\t*eff_addr += insn->displacement.value;\n\t}\n\n\treturn 0;\n}\n\n/**\n * get_addr_ref_16() - Obtain the 16-bit address referred by instruction\n * @insn:\tInstruction containing ModRM byte and displacement\n * @regs:\tRegister values as seen when entering kernel mode\n *\n * This function is to be used with 16-bit address encodings. Obtain the memory\n * address referred by the instruction's ModRM and displacement bytes. Also, the\n * segment used as base is determined by either any segment override prefixes in\n * @insn or the default segment of the registers involved in the address\n * computation. In protected mode, segment limits are enforced.\n *\n * Returns:\n *\n * Linear address referenced by the instruction operands on success.\n *\n * -1L on error.\n */\nstatic void __user *get_addr_ref_16(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base, seg_limit;\n\tint ret, regoff;\n\tshort eff_addr;\n\tlong tmp;\n\n\tinsn_get_modrm(insn);\n\tinsn_get_displacement(insn);\n\n\tif (insn->addr_bytes != 2)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\teff_addr = tmp;\n\t} else {\n\t\tret = get_eff_addr_modrm_16(insn, regs, &regoff, &eff_addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, &seg_limit);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Before computing the linear address, make sure the effective address\n\t * is within the limits of the segment. In virtual-8086 mode, segment\n\t * limits are not enforced. In such a case, the segment limit is -1L to\n\t * reflect this fact.\n\t */\n\tif ((unsigned long)(eff_addr & 0xffff) > seg_limit)\n\t\tgoto out;\n\n\tlinear_addr = (unsigned long)(eff_addr & 0xffff) + seg_base;\n\n\t/* Limit linear address to 20 bits */\n\tif (v8086_mode(regs))\n\t\tlinear_addr &= 0xfffff;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n\n/**\n * get_addr_ref_32() - Obtain a 32-bit linear address\n * @insn:\tInstruction with ModRM, SIB bytes and displacement\n * @regs:\tRegister values as seen when entering kernel mode\n *\n * This function is to be used with 32-bit address encodings to obtain the\n * linear memory address referred by the instruction's ModRM, SIB,\n * displacement bytes and segment base address, as applicable. If in protected\n * mode, segment limits are enforced.\n *\n * Returns:\n *\n * Linear address referenced by instruction and registers on success.\n *\n * -1L on error.\n */\nstatic void __user *get_addr_ref_32(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base, seg_limit;\n\tint eff_addr, regoff;\n\tlong tmp;\n\tint ret;\n\n\tif (insn->addr_bytes != 4)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\teff_addr = tmp;\n\n\t} else {\n\t\tif (insn->sib.nbytes) {\n\t\t\tret = get_eff_addr_sib(insn, regs, &regoff, &tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\teff_addr = tmp;\n\t\t} else {\n\t\t\tret = get_eff_addr_modrm(insn, regs, &regoff, &tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\teff_addr = tmp;\n\t\t}\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, &seg_limit);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * In protected mode, before computing the linear address, make sure\n\t * the effective address is within the limits of the segment.\n\t * 32-bit addresses can be used in long and virtual-8086 modes if an\n\t * address override prefix is used. In such cases, segment limits are\n\t * not enforced. When in virtual-8086 mode, the segment limit is -1L\n\t * to reflect this situation.\n\t *\n\t * After computed, the effective address is treated as an unsigned\n\t * quantity.\n\t */\n\tif (!user_64bit_mode(regs) && ((unsigned int)eff_addr > seg_limit))\n\t\tgoto out;\n\n\t/*\n\t * Even though 32-bit address encodings are allowed in virtual-8086\n\t * mode, the address range is still limited to [0x-0xffff].\n\t */\n\tif (v8086_mode(regs) && (eff_addr & ~0xffff))\n\t\tgoto out;\n\n\t/*\n\t * Data type long could be 64 bits in size. Ensure that our 32-bit\n\t * effective address is not sign-extended when computing the linear\n\t * address.\n\t */\n\tlinear_addr = (unsigned long)(eff_addr & 0xffffffff) + seg_base;\n\n\t/* Limit linear address to 20 bits */\n\tif (v8086_mode(regs))\n\t\tlinear_addr &= 0xfffff;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n\n/**\n * get_addr_ref_64() - Obtain a 64-bit linear address\n * @insn:\tInstruction struct with ModRM and SIB bytes and displacement\n * @regs:\tStructure with register values as seen when entering kernel mode\n *\n * This function is to be used with 64-bit address encodings to obtain the\n * linear memory address referred by the instruction's ModRM, SIB,\n * displacement bytes and segment base address, as applicable.\n *\n * Returns:\n *\n * Linear address referenced by instruction and registers on success.\n *\n * -1L on error.\n */\n#ifndef CONFIG_X86_64\nstatic void __user *get_addr_ref_64(struct insn *insn, struct pt_regs *regs)\n{\n\treturn (void __user *)-1L;\n}\n#else\nstatic void __user *get_addr_ref_64(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base;\n\tint regoff, ret;\n\tlong eff_addr;\n\n\tif (insn->addr_bytes != 8)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &eff_addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t} else {\n\t\tif (insn->sib.nbytes) {\n\t\t\tret = get_eff_addr_sib(insn, regs, &regoff, &eff_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tret = get_eff_addr_modrm(insn, regs, &regoff, &eff_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tlinear_addr = (unsigned long)eff_addr + seg_base;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n#endif /* CONFIG_X86_64 */\n\n/**\n * insn_get_addr_ref() - Obtain the linear address referred by instruction\n * @insn:\tInstruction structure containing ModRM byte and displacement\n * @regs:\tStructure with register values as seen when entering kernel mode\n *\n * Obtain the linear address referred by the instruction's ModRM, SIB and\n * displacement bytes, and segment base, as applicable. In protected mode,\n * segment limits are enforced.\n *\n * Returns:\n *\n * Linear address referenced by instruction and registers on success.\n *\n * -1L on error.\n */\nvoid __user *insn_get_addr_ref(struct insn *insn, struct pt_regs *regs)\n{\n\tif (!insn || !regs)\n\t\treturn (void __user *)-1L;\n\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\treturn get_addr_ref_16(insn, regs);\n\tcase 4:\n\t\treturn get_addr_ref_32(insn, regs);\n\tcase 8:\n\t\treturn get_addr_ref_64(insn, regs);\n\tdefault:\n\t\treturn (void __user *)-1L;\n\t}\n}\n"], "fixing_code": ["/*\n * Utility functions for x86 operand and address decoding\n *\n * Copyright (C) Intel Corporation 2017\n */\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/ratelimit.h>\n#include <linux/mmu_context.h>\n#include <asm/desc_defs.h>\n#include <asm/desc.h>\n#include <asm/inat.h>\n#include <asm/insn.h>\n#include <asm/insn-eval.h>\n#include <asm/ldt.h>\n#include <asm/vm86.h>\n\n#undef pr_fmt\n#define pr_fmt(fmt) \"insn: \" fmt\n\nenum reg_type {\n\tREG_TYPE_RM = 0,\n\tREG_TYPE_INDEX,\n\tREG_TYPE_BASE,\n};\n\n/**\n * is_string_insn() - Determine if instruction is a string instruction\n * @insn:\tInstruction containing the opcode to inspect\n *\n * Returns:\n *\n * true if the instruction, determined by the opcode, is any of the\n * string instructions as defined in the Intel Software Development manual.\n * False otherwise.\n */\nstatic bool is_string_insn(struct insn *insn)\n{\n\tinsn_get_opcode(insn);\n\n\t/* All string instructions have a 1-byte opcode. */\n\tif (insn->opcode.nbytes != 1)\n\t\treturn false;\n\n\tswitch (insn->opcode.bytes[0]) {\n\tcase 0x6c ... 0x6f:\t/* INS, OUTS */\n\tcase 0xa4 ... 0xa7:\t/* MOVS, CMPS */\n\tcase 0xaa ... 0xaf:\t/* STOS, LODS, SCAS */\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}\n\n/**\n * get_seg_reg_override_idx() - obtain segment register override index\n * @insn:\tValid instruction with segment override prefixes\n *\n * Inspect the instruction prefixes in @insn and find segment overrides, if any.\n *\n * Returns:\n *\n * A constant identifying the segment register to use, among CS, SS, DS,\n * ES, FS, or GS. INAT_SEG_REG_DEFAULT is returned if no segment override\n * prefixes were found.\n *\n * -EINVAL in case of error.\n */\nstatic int get_seg_reg_override_idx(struct insn *insn)\n{\n\tint idx = INAT_SEG_REG_DEFAULT;\n\tint num_overrides = 0, i;\n\n\tinsn_get_prefixes(insn);\n\n\t/* Look for any segment override prefixes. */\n\tfor (i = 0; i < insn->prefixes.nbytes; i++) {\n\t\tinsn_attr_t attr;\n\n\t\tattr = inat_get_opcode_attribute(insn->prefixes.bytes[i]);\n\t\tswitch (attr) {\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_CS):\n\t\t\tidx = INAT_SEG_REG_CS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_SS):\n\t\t\tidx = INAT_SEG_REG_SS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_DS):\n\t\t\tidx = INAT_SEG_REG_DS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_ES):\n\t\t\tidx = INAT_SEG_REG_ES;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_FS):\n\t\t\tidx = INAT_SEG_REG_FS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\tcase INAT_MAKE_PREFIX(INAT_PFX_GS):\n\t\t\tidx = INAT_SEG_REG_GS;\n\t\t\tnum_overrides++;\n\t\t\tbreak;\n\t\t/* No default action needed. */\n\t\t}\n\t}\n\n\t/* More than one segment override prefix leads to undefined behavior. */\n\tif (num_overrides > 1)\n\t\treturn -EINVAL;\n\n\treturn idx;\n}\n\n/**\n * check_seg_overrides() - check if segment override prefixes are allowed\n * @insn:\tValid instruction with segment override prefixes\n * @regoff:\tOperand offset, in pt_regs, for which the check is performed\n *\n * For a particular register used in register-indirect addressing, determine if\n * segment override prefixes can be used. Specifically, no overrides are allowed\n * for rDI if used with a string instruction.\n *\n * Returns:\n *\n * True if segment override prefixes can be used with the register indicated\n * in @regoff. False if otherwise.\n */\nstatic bool check_seg_overrides(struct insn *insn, int regoff)\n{\n\tif (regoff == offsetof(struct pt_regs, di) && is_string_insn(insn))\n\t\treturn false;\n\n\treturn true;\n}\n\n/**\n * resolve_default_seg() - resolve default segment register index for an operand\n * @insn:\tInstruction with opcode and address size. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @off:\tOperand offset, in pt_regs, for which resolution is needed\n *\n * Resolve the default segment register index associated with the instruction\n * operand register indicated by @off. Such index is resolved based on defaults\n * described in the Intel Software Development Manual.\n *\n * Returns:\n *\n * If in protected mode, a constant identifying the segment register to use,\n * among CS, SS, ES or DS. If in long mode, INAT_SEG_REG_IGNORE.\n *\n * -EINVAL in case of error.\n */\nstatic int resolve_default_seg(struct insn *insn, struct pt_regs *regs, int off)\n{\n\tif (user_64bit_mode(regs))\n\t\treturn INAT_SEG_REG_IGNORE;\n\t/*\n\t * Resolve the default segment register as described in Section 3.7.4\n\t * of the Intel Software Development Manual Vol. 1:\n\t *\n\t *  + DS for all references involving r[ABCD]X, and rSI.\n\t *  + If used in a string instruction, ES for rDI. Otherwise, DS.\n\t *  + AX, CX and DX are not valid register operands in 16-bit address\n\t *    encodings but are valid for 32-bit and 64-bit encodings.\n\t *  + -EDOM is reserved to identify for cases in which no register\n\t *    is used (i.e., displacement-only addressing). Use DS.\n\t *  + SS for rSP or rBP.\n\t *  + CS for rIP.\n\t */\n\n\tswitch (off) {\n\tcase offsetof(struct pt_regs, ax):\n\tcase offsetof(struct pt_regs, cx):\n\tcase offsetof(struct pt_regs, dx):\n\t\t/* Need insn to verify address size. */\n\t\tif (insn->addr_bytes == 2)\n\t\t\treturn -EINVAL;\n\n\t\t/* fall through */\n\n\tcase -EDOM:\n\tcase offsetof(struct pt_regs, bx):\n\tcase offsetof(struct pt_regs, si):\n\t\treturn INAT_SEG_REG_DS;\n\n\tcase offsetof(struct pt_regs, di):\n\t\tif (is_string_insn(insn))\n\t\t\treturn INAT_SEG_REG_ES;\n\t\treturn INAT_SEG_REG_DS;\n\n\tcase offsetof(struct pt_regs, bp):\n\tcase offsetof(struct pt_regs, sp):\n\t\treturn INAT_SEG_REG_SS;\n\n\tcase offsetof(struct pt_regs, ip):\n\t\treturn INAT_SEG_REG_CS;\n\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * resolve_seg_reg() - obtain segment register index\n * @insn:\tInstruction with operands\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tOperand offset, in pt_regs, used to deterimine segment register\n *\n * Determine the segment register associated with the operands and, if\n * applicable, prefixes and the instruction pointed by @insn.\n *\n * The segment register associated to an operand used in register-indirect\n * addressing depends on:\n *\n * a) Whether running in long mode (in such a case segments are ignored, except\n * if FS or GS are used).\n *\n * b) Whether segment override prefixes can be used. Certain instructions and\n *    registers do not allow override prefixes.\n *\n * c) Whether segment overrides prefixes are found in the instruction prefixes.\n *\n * d) If there are not segment override prefixes or they cannot be used, the\n *    default segment register associated with the operand register is used.\n *\n * The function checks first if segment override prefixes can be used with the\n * operand indicated by @regoff. If allowed, obtain such overridden segment\n * register index. Lastly, if not prefixes were found or cannot be used, resolve\n * the segment register index to use based on the defaults described in the\n * Intel documentation. In long mode, all segment register indexes will be\n * ignored, except if overrides were found for FS or GS. All these operations\n * are done using helper functions.\n *\n * The operand register, @regoff, is represented as the offset from the base of\n * pt_regs.\n *\n * As stated, the main use of this function is to determine the segment register\n * index based on the instruction, its operands and prefixes. Hence, @insn\n * must be valid. However, if @regoff indicates rIP, we don't need to inspect\n * @insn at all as in this case CS is used in all cases. This case is checked\n * before proceeding further.\n *\n * Please note that this function does not return the value in the segment\n * register (i.e., the segment selector) but our defined index. The segment\n * selector needs to be obtained using get_segment_selector() and passing the\n * segment register index resolved by this function.\n *\n * Returns:\n *\n * An index identifying the segment register to use, among CS, SS, DS,\n * ES, FS, or GS. INAT_SEG_REG_IGNORE is returned if running in long mode.\n *\n * -EINVAL in case of error.\n */\nstatic int resolve_seg_reg(struct insn *insn, struct pt_regs *regs, int regoff)\n{\n\tint idx;\n\n\t/*\n\t * In the unlikely event of having to resolve the segment register\n\t * index for rIP, do it first. Segment override prefixes should not\n\t * be used. Hence, it is not necessary to inspect the instruction,\n\t * which may be invalid at this point.\n\t */\n\tif (regoff == offsetof(struct pt_regs, ip)) {\n\t\tif (user_64bit_mode(regs))\n\t\t\treturn INAT_SEG_REG_IGNORE;\n\t\telse\n\t\t\treturn INAT_SEG_REG_CS;\n\t}\n\n\tif (!insn)\n\t\treturn -EINVAL;\n\n\tif (!check_seg_overrides(insn, regoff))\n\t\treturn resolve_default_seg(insn, regs, regoff);\n\n\tidx = get_seg_reg_override_idx(insn);\n\tif (idx < 0)\n\t\treturn idx;\n\n\tif (idx == INAT_SEG_REG_DEFAULT)\n\t\treturn resolve_default_seg(insn, regs, regoff);\n\n\t/*\n\t * In long mode, segment override prefixes are ignored, except for\n\t * overrides for FS and GS.\n\t */\n\tif (user_64bit_mode(regs)) {\n\t\tif (idx != INAT_SEG_REG_FS &&\n\t\t    idx != INAT_SEG_REG_GS)\n\t\t\tidx = INAT_SEG_REG_IGNORE;\n\t}\n\n\treturn idx;\n}\n\n/**\n * get_segment_selector() - obtain segment selector\n * @regs:\t\tRegister values as seen when entering kernel mode\n * @seg_reg_idx:\tSegment register index to use\n *\n * Obtain the segment selector from any of the CS, SS, DS, ES, FS, GS segment\n * registers. In CONFIG_X86_32, the segment is obtained from either pt_regs or\n * kernel_vm86_regs as applicable. In CONFIG_X86_64, CS and SS are obtained\n * from pt_regs. DS, ES, FS and GS are obtained by reading the actual CPU\n * registers. This done for only for completeness as in CONFIG_X86_64 segment\n * registers are ignored.\n *\n * Returns:\n *\n * Value of the segment selector, including null when running in\n * long mode.\n *\n * -EINVAL on error.\n */\nstatic short get_segment_selector(struct pt_regs *regs, int seg_reg_idx)\n{\n#ifdef CONFIG_X86_64\n\tunsigned short sel;\n\n\tswitch (seg_reg_idx) {\n\tcase INAT_SEG_REG_IGNORE:\n\t\treturn 0;\n\tcase INAT_SEG_REG_CS:\n\t\treturn (unsigned short)(regs->cs & 0xffff);\n\tcase INAT_SEG_REG_SS:\n\t\treturn (unsigned short)(regs->ss & 0xffff);\n\tcase INAT_SEG_REG_DS:\n\t\tsavesegment(ds, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_ES:\n\t\tsavesegment(es, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_FS:\n\t\tsavesegment(fs, sel);\n\t\treturn sel;\n\tcase INAT_SEG_REG_GS:\n\t\tsavesegment(gs, sel);\n\t\treturn sel;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n#else /* CONFIG_X86_32 */\n\tstruct kernel_vm86_regs *vm86regs = (struct kernel_vm86_regs *)regs;\n\n\tif (v8086_mode(regs)) {\n\t\tswitch (seg_reg_idx) {\n\t\tcase INAT_SEG_REG_CS:\n\t\t\treturn (unsigned short)(regs->cs & 0xffff);\n\t\tcase INAT_SEG_REG_SS:\n\t\t\treturn (unsigned short)(regs->ss & 0xffff);\n\t\tcase INAT_SEG_REG_DS:\n\t\t\treturn vm86regs->ds;\n\t\tcase INAT_SEG_REG_ES:\n\t\t\treturn vm86regs->es;\n\t\tcase INAT_SEG_REG_FS:\n\t\t\treturn vm86regs->fs;\n\t\tcase INAT_SEG_REG_GS:\n\t\t\treturn vm86regs->gs;\n\t\tcase INAT_SEG_REG_IGNORE:\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tswitch (seg_reg_idx) {\n\tcase INAT_SEG_REG_CS:\n\t\treturn (unsigned short)(regs->cs & 0xffff);\n\tcase INAT_SEG_REG_SS:\n\t\treturn (unsigned short)(regs->ss & 0xffff);\n\tcase INAT_SEG_REG_DS:\n\t\treturn (unsigned short)(regs->ds & 0xffff);\n\tcase INAT_SEG_REG_ES:\n\t\treturn (unsigned short)(regs->es & 0xffff);\n\tcase INAT_SEG_REG_FS:\n\t\treturn (unsigned short)(regs->fs & 0xffff);\n\tcase INAT_SEG_REG_GS:\n\t\t/*\n\t\t * GS may or may not be in regs as per CONFIG_X86_32_LAZY_GS.\n\t\t * The macro below takes care of both cases.\n\t\t */\n\t\treturn get_user_gs(regs);\n\tcase INAT_SEG_REG_IGNORE:\n\t\t/* fall through */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n#endif /* CONFIG_X86_64 */\n}\n\nstatic int get_reg_offset(struct insn *insn, struct pt_regs *regs,\n\t\t\t  enum reg_type type)\n{\n\tint regno = 0;\n\n\tstatic const int regoff[] = {\n\t\toffsetof(struct pt_regs, ax),\n\t\toffsetof(struct pt_regs, cx),\n\t\toffsetof(struct pt_regs, dx),\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, sp),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n#ifdef CONFIG_X86_64\n\t\toffsetof(struct pt_regs, r8),\n\t\toffsetof(struct pt_regs, r9),\n\t\toffsetof(struct pt_regs, r10),\n\t\toffsetof(struct pt_regs, r11),\n\t\toffsetof(struct pt_regs, r12),\n\t\toffsetof(struct pt_regs, r13),\n\t\toffsetof(struct pt_regs, r14),\n\t\toffsetof(struct pt_regs, r15),\n#endif\n\t};\n\tint nr_registers = ARRAY_SIZE(regoff);\n\t/*\n\t * Don't possibly decode a 32-bit instructions as\n\t * reading a 64-bit-only register.\n\t */\n\tif (IS_ENABLED(CONFIG_X86_64) && !insn->x86_64)\n\t\tnr_registers -= 8;\n\n\tswitch (type) {\n\tcase REG_TYPE_RM:\n\t\tregno = X86_MODRM_RM(insn->modrm.value);\n\n\t\t/*\n\t\t * ModRM.mod == 0 and ModRM.rm == 5 means a 32-bit displacement\n\t\t * follows the ModRM byte.\n\t\t */\n\t\tif (!X86_MODRM_MOD(insn->modrm.value) && regno == 5)\n\t\t\treturn -EDOM;\n\n\t\tif (X86_REX_B(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\t\tbreak;\n\n\tcase REG_TYPE_INDEX:\n\t\tregno = X86_SIB_INDEX(insn->sib.value);\n\t\tif (X86_REX_X(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\n\t\t/*\n\t\t * If ModRM.mod != 3 and SIB.index = 4 the scale*index\n\t\t * portion of the address computation is null. This is\n\t\t * true only if REX.X is 0. In such a case, the SIB index\n\t\t * is used in the address computation.\n\t\t */\n\t\tif (X86_MODRM_MOD(insn->modrm.value) != 3 && regno == 4)\n\t\t\treturn -EDOM;\n\t\tbreak;\n\n\tcase REG_TYPE_BASE:\n\t\tregno = X86_SIB_BASE(insn->sib.value);\n\t\t/*\n\t\t * If ModRM.mod is 0 and SIB.base == 5, the base of the\n\t\t * register-indirect addressing is 0. In this case, a\n\t\t * 32-bit displacement follows the SIB byte.\n\t\t */\n\t\tif (!X86_MODRM_MOD(insn->modrm.value) && regno == 5)\n\t\t\treturn -EDOM;\n\n\t\tif (X86_REX_B(insn->rex_prefix.value))\n\t\t\tregno += 8;\n\t\tbreak;\n\n\tdefault:\n\t\tpr_err_ratelimited(\"invalid register type: %d\\n\", type);\n\t\treturn -EINVAL;\n\t}\n\n\tif (regno >= nr_registers) {\n\t\tWARN_ONCE(1, \"decoded an instruction with an invalid register\");\n\t\treturn -EINVAL;\n\t}\n\treturn regoff[regno];\n}\n\n/**\n * get_reg_offset_16() - Obtain offset of register indicated by instruction\n * @insn:\tInstruction containing ModRM byte\n * @regs:\tRegister values as seen when entering kernel mode\n * @offs1:\tOffset of the first operand register\n * @offs2:\tOffset of the second opeand register, if applicable\n *\n * Obtain the offset, in pt_regs, of the registers indicated by the ModRM byte\n * in @insn. This function is to be used with 16-bit address encodings. The\n * @offs1 and @offs2 will be written with the offset of the two registers\n * indicated by the instruction. In cases where any of the registers is not\n * referenced by the instruction, the value will be set to -EDOM.\n *\n * Returns:\n *\n * 0 on success, -EINVAL on error.\n */\nstatic int get_reg_offset_16(struct insn *insn, struct pt_regs *regs,\n\t\t\t     int *offs1, int *offs2)\n{\n\t/*\n\t * 16-bit addressing can use one or two registers. Specifics of\n\t * encodings are given in Table 2-1. \"16-Bit Addressing Forms with the\n\t * ModR/M Byte\" of the Intel Software Development Manual.\n\t */\n\tstatic const int regoff1[] = {\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, bx),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\toffsetof(struct pt_regs, bp),\n\t\toffsetof(struct pt_regs, bx),\n\t};\n\n\tstatic const int regoff2[] = {\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\toffsetof(struct pt_regs, si),\n\t\toffsetof(struct pt_regs, di),\n\t\t-EDOM,\n\t\t-EDOM,\n\t\t-EDOM,\n\t\t-EDOM,\n\t};\n\n\tif (!offs1 || !offs2)\n\t\treturn -EINVAL;\n\n\t/* Operand is a register, use the generic function. */\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\t*offs1 = insn_get_modrm_rm_off(insn, regs);\n\t\t*offs2 = -EDOM;\n\t\treturn 0;\n\t}\n\n\t*offs1 = regoff1[X86_MODRM_RM(insn->modrm.value)];\n\t*offs2 = regoff2[X86_MODRM_RM(insn->modrm.value)];\n\n\t/*\n\t * If ModRM.mod is 0 and ModRM.rm is 110b, then we use displacement-\n\t * only addressing. This means that no registers are involved in\n\t * computing the effective address. Thus, ensure that the first\n\t * register offset is invalild. The second register offset is already\n\t * invalid under the aforementioned conditions.\n\t */\n\tif ((X86_MODRM_MOD(insn->modrm.value) == 0) &&\n\t    (X86_MODRM_RM(insn->modrm.value) == 6))\n\t\t*offs1 = -EDOM;\n\n\treturn 0;\n}\n\n/**\n * get_desc() - Obtain contents of a segment descriptor\n * @out:\tSegment descriptor contents on success\n * @sel:\tSegment selector\n *\n * Given a segment selector, obtain a pointer to the segment descriptor.\n * Both global and local descriptor tables are supported.\n *\n * Returns:\n *\n * True on success, false on failure.\n *\n * NULL on error.\n */\nstatic bool get_desc(struct desc_struct *out, unsigned short sel)\n{\n\tstruct desc_ptr gdt_desc = {0, 0};\n\tunsigned long desc_base;\n\n#ifdef CONFIG_MODIFY_LDT_SYSCALL\n\tif ((sel & SEGMENT_TI_MASK) == SEGMENT_LDT) {\n\t\tbool success = false;\n\t\tstruct ldt_struct *ldt;\n\n\t\t/* Bits [15:3] contain the index of the desired entry. */\n\t\tsel >>= 3;\n\n\t\tmutex_lock(&current->active_mm->context.lock);\n\t\tldt = current->active_mm->context.ldt;\n\t\tif (ldt && sel < ldt->nr_entries) {\n\t\t\t*out = ldt->entries[sel];\n\t\t\tsuccess = true;\n\t\t}\n\n\t\tmutex_unlock(&current->active_mm->context.lock);\n\n\t\treturn success;\n\t}\n#endif\n\tnative_store_gdt(&gdt_desc);\n\n\t/*\n\t * Segment descriptors have a size of 8 bytes. Thus, the index is\n\t * multiplied by 8 to obtain the memory offset of the desired descriptor\n\t * from the base of the GDT. As bits [15:3] of the segment selector\n\t * contain the index, it can be regarded as multiplied by 8 already.\n\t * All that remains is to clear bits [2:0].\n\t */\n\tdesc_base = sel & ~(SEGMENT_RPL_MASK | SEGMENT_TI_MASK);\n\n\tif (desc_base > gdt_desc.size)\n\t\treturn false;\n\n\t*out = *(struct desc_struct *)(gdt_desc.address + desc_base);\n\treturn true;\n}\n\n/**\n * insn_get_seg_base() - Obtain base address of segment descriptor.\n * @regs:\t\tRegister values as seen when entering kernel mode\n * @seg_reg_idx:\tIndex of the segment register pointing to seg descriptor\n *\n * Obtain the base address of the segment as indicated by the segment descriptor\n * pointed by the segment selector. The segment selector is obtained from the\n * input segment register index @seg_reg_idx.\n *\n * Returns:\n *\n * In protected mode, base address of the segment. Zero in long mode,\n * except when FS or GS are used. In virtual-8086 mode, the segment\n * selector shifted 4 bits to the right.\n *\n * -1L in case of error.\n */\nunsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn -1L;\n\n\tif (v8086_mode(regs))\n\t\t/*\n\t\t * Base is simply the segment selector shifted 4\n\t\t * bits to the right.\n\t\t */\n\t\treturn (unsigned long)(sel << 4);\n\n\tif (user_64bit_mode(regs)) {\n\t\t/*\n\t\t * Only FS or GS will have a base address, the rest of\n\t\t * the segments' bases are forced to 0.\n\t\t */\n\t\tunsigned long base;\n\n\t\tif (seg_reg_idx == INAT_SEG_REG_FS)\n\t\t\trdmsrl(MSR_FS_BASE, base);\n\t\telse if (seg_reg_idx == INAT_SEG_REG_GS)\n\t\t\t/*\n\t\t\t * swapgs was called at the kernel entry point. Thus,\n\t\t\t * MSR_KERNEL_GS_BASE will have the user-space GS base.\n\t\t\t */\n\t\t\trdmsrl(MSR_KERNEL_GS_BASE, base);\n\t\telse\n\t\t\tbase = 0;\n\t\treturn base;\n\t}\n\n\t/* In protected mode the segment selector cannot be null. */\n\tif (!sel)\n\t\treturn -1L;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -1L;\n\n\treturn get_desc_base(&desc);\n}\n\n/**\n * get_seg_limit() - Obtain the limit of a segment descriptor\n * @regs:\t\tRegister values as seen when entering kernel mode\n * @seg_reg_idx:\tIndex of the segment register pointing to seg descriptor\n *\n * Obtain the limit of the segment as indicated by the segment descriptor\n * pointed by the segment selector. The segment selector is obtained from the\n * input segment register index @seg_reg_idx.\n *\n * Returns:\n *\n * In protected mode, the limit of the segment descriptor in bytes.\n * In long mode and virtual-8086 mode, segment limits are not enforced. Thus,\n * limit is returned as -1L to imply a limit-less segment.\n *\n * Zero is returned on error.\n */\nstatic unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)\n{\n\tstruct desc_struct desc;\n\tunsigned long limit;\n\tshort sel;\n\n\tsel = get_segment_selector(regs, seg_reg_idx);\n\tif (sel < 0)\n\t\treturn 0;\n\n\tif (user_64bit_mode(regs) || v8086_mode(regs))\n\t\treturn -1L;\n\n\tif (!sel)\n\t\treturn 0;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn 0;\n\n\t/*\n\t * If the granularity bit is set, the limit is given in multiples\n\t * of 4096. This also means that the 12 least significant bits are\n\t * not tested when checking the segment limits. In practice,\n\t * this means that the segment ends in (limit << 12) + 0xfff.\n\t */\n\tlimit = get_desc_limit(&desc);\n\tif (desc.g)\n\t\tlimit = (limit << 12) + 0xfff;\n\n\treturn limit;\n}\n\n/**\n * insn_get_code_seg_params() - Obtain code segment parameters\n * @regs:\tStructure with register values as seen when entering kernel mode\n *\n * Obtain address and operand sizes of the code segment. It is obtained from the\n * selector contained in the CS register in regs. In protected mode, the default\n * address is determined by inspecting the L and D bits of the segment\n * descriptor. In virtual-8086 mode, the default is always two bytes for both\n * address and operand sizes.\n *\n * Returns:\n *\n * An int containing ORed-in default parameters on success.\n *\n * -EINVAL on error.\n */\nint insn_get_code_seg_params(struct pt_regs *regs)\n{\n\tstruct desc_struct desc;\n\tshort sel;\n\n\tif (v8086_mode(regs))\n\t\t/* Address and operand size are both 16-bit. */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\n\tsel = get_segment_selector(regs, INAT_SEG_REG_CS);\n\tif (sel < 0)\n\t\treturn sel;\n\n\tif (!get_desc(&desc, sel))\n\t\treturn -EINVAL;\n\n\t/*\n\t * The most significant byte of the Type field of the segment descriptor\n\t * determines whether a segment contains data or code. If this is a data\n\t * segment, return error.\n\t */\n\tif (!(desc.type & BIT(3)))\n\t\treturn -EINVAL;\n\n\tswitch ((desc.l << 1) | desc.d) {\n\tcase 0: /*\n\t\t * Legacy mode. CS.L=0, CS.D=0. Address and operand size are\n\t\t * both 16-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(2, 2);\n\tcase 1: /*\n\t\t * Legacy mode. CS.L=0, CS.D=1. Address and operand size are\n\t\t * both 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 4);\n\tcase 2: /*\n\t\t * IA-32e 64-bit mode. CS.L=1, CS.D=0. Address size is 64-bit;\n\t\t * operand size is 32-bit.\n\t\t */\n\t\treturn INSN_CODE_SEG_PARAMS(4, 8);\n\tcase 3: /* Invalid setting. CS.L=1, CS.D=1 */\n\t\t/* fall through */\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\n/**\n * insn_get_modrm_rm_off() - Obtain register in r/m part of the ModRM byte\n * @insn:\tInstruction containing the ModRM byte\n * @regs:\tRegister values as seen when entering kernel mode\n *\n * Returns:\n *\n * The register indicated by the r/m part of the ModRM byte. The\n * register is obtained as an offset from the base of pt_regs. In specific\n * cases, the returned value can be -EDOM to indicate that the particular value\n * of ModRM does not refer to a register and shall be ignored.\n */\nint insn_get_modrm_rm_off(struct insn *insn, struct pt_regs *regs)\n{\n\treturn get_reg_offset(insn, regs, REG_TYPE_RM);\n}\n\n/**\n * get_seg_base_limit() - obtain base address and limit of a segment\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tOperand offset, in pt_regs, used to resolve segment descriptor\n * @base:\tObtained segment base\n * @limit:\tObtained segment limit\n *\n * Obtain the base address and limit of the segment associated with the operand\n * @regoff and, if any or allowed, override prefixes in @insn. This function is\n * different from insn_get_seg_base() as the latter does not resolve the segment\n * associated with the instruction operand. If a limit is not needed (e.g.,\n * when running in long mode), @limit can be NULL.\n *\n * Returns:\n *\n * 0 on success. @base and @limit will contain the base address and of the\n * resolved segment, respectively.\n *\n * -EINVAL on error.\n */\nstatic int get_seg_base_limit(struct insn *insn, struct pt_regs *regs,\n\t\t\t      int regoff, unsigned long *base,\n\t\t\t      unsigned long *limit)\n{\n\tint seg_reg_idx;\n\n\tif (!base)\n\t\treturn -EINVAL;\n\n\tseg_reg_idx = resolve_seg_reg(insn, regs, regoff);\n\tif (seg_reg_idx < 0)\n\t\treturn seg_reg_idx;\n\n\t*base = insn_get_seg_base(regs, seg_reg_idx);\n\tif (*base == -1L)\n\t\treturn -EINVAL;\n\n\tif (!limit)\n\t\treturn 0;\n\n\t*limit = get_seg_limit(regs, seg_reg_idx);\n\tif (!(*limit))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_reg() - Obtain effective address from register operand\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, with the effective address\n * @eff_addr:\tObtained effective address\n *\n * Obtain the effective address stored in the register operand as indicated by\n * the ModRM byte. This function is to be used only with register addressing\n * (i.e.,  ModRM.mod is 3). The effective address is saved in @eff_addr. The\n * register operand, as an offset from the base of pt_regs, is saved in @regoff;\n * such offset can then be used to resolve the segment associated with the\n * operand. This function can be used with any of the supported address sizes\n * in x86.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the effective address stored in the\n * operand indicated by ModRM. @regoff will have such operand as an offset from\n * the base of pt_regs.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_reg(struct insn *insn, struct pt_regs *regs,\n\t\t\t    int *regoff, long *eff_addr)\n{\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) != 3)\n\t\treturn -EINVAL;\n\n\t*regoff = get_reg_offset(insn, regs, REG_TYPE_RM);\n\tif (*regoff < 0)\n\t\treturn -EINVAL;\n\n\t/* Ignore bytes that are outside the address size. */\n\tif (insn->addr_bytes == 2)\n\t\t*eff_addr = regs_get_register(regs, *regoff) & 0xffff;\n\telse if (insn->addr_bytes == 4)\n\t\t*eff_addr = regs_get_register(regs, *regoff) & 0xffffffff;\n\telse /* 64-bit address */\n\t\t*eff_addr = regs_get_register(regs, *regoff);\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_modrm() - Obtain referenced effective address via ModRM\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, associated with segment\n * @eff_addr:\tObtained effective address\n *\n * Obtain the effective address referenced by the ModRM byte of @insn. After\n * identifying the registers involved in the register-indirect memory reference,\n * its value is obtained from the operands in @regs. The computed address is\n * stored @eff_addr. Also, the register operand that indicates the associated\n * segment is stored in @regoff, this parameter can later be used to determine\n * such segment.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the referenced effective address. @regoff\n * will have a register, as an offset from the base of pt_regs, that can be used\n * to resolve the associated segment.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_modrm(struct insn *insn, struct pt_regs *regs,\n\t\t\t      int *regoff, long *eff_addr)\n{\n\tlong tmp;\n\n\tif (insn->addr_bytes != 8 && insn->addr_bytes != 4)\n\t\treturn -EINVAL;\n\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\t*regoff = get_reg_offset(insn, regs, REG_TYPE_RM);\n\n\t/*\n\t * -EDOM means that we must ignore the address_offset. In such a case,\n\t * in 64-bit mode the effective address relative to the rIP of the\n\t * following instruction.\n\t */\n\tif (*regoff == -EDOM) {\n\t\tif (user_64bit_mode(regs))\n\t\t\ttmp = regs->ip + insn->length;\n\t\telse\n\t\t\ttmp = 0;\n\t} else if (*regoff < 0) {\n\t\treturn -EINVAL;\n\t} else {\n\t\ttmp = regs_get_register(regs, *regoff);\n\t}\n\n\tif (insn->addr_bytes == 4) {\n\t\tint addr32 = (int)(tmp & 0xffffffff) + insn->displacement.value;\n\n\t\t*eff_addr = addr32 & 0xffffffff;\n\t} else {\n\t\t*eff_addr = tmp + insn->displacement.value;\n\t}\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_modrm_16() - Obtain referenced effective address via ModRM\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, associated with segment\n * @eff_addr:\tObtained effective address\n *\n * Obtain the 16-bit effective address referenced by the ModRM byte of @insn.\n * After identifying the registers involved in the register-indirect memory\n * reference, its value is obtained from the operands in @regs. The computed\n * address is stored @eff_addr. Also, the register operand that indicates\n * the associated segment is stored in @regoff, this parameter can later be used\n * to determine such segment.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the referenced effective address. @regoff\n * will have a register, as an offset from the base of pt_regs, that can be used\n * to resolve the associated segment.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_modrm_16(struct insn *insn, struct pt_regs *regs,\n\t\t\t\t int *regoff, short *eff_addr)\n{\n\tint addr_offset1, addr_offset2, ret;\n\tshort addr1 = 0, addr2 = 0, displacement;\n\n\tif (insn->addr_bytes != 2)\n\t\treturn -EINVAL;\n\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\tret = get_reg_offset_16(insn, regs, &addr_offset1, &addr_offset2);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't fail on invalid offset values. They might be invalid because\n\t * they cannot be used for this particular value of ModRM. Instead, use\n\t * them in the computation only if they contain a valid value.\n\t */\n\tif (addr_offset1 != -EDOM)\n\t\taddr1 = regs_get_register(regs, addr_offset1) & 0xffff;\n\n\tif (addr_offset2 != -EDOM)\n\t\taddr2 = regs_get_register(regs, addr_offset2) & 0xffff;\n\n\tdisplacement = insn->displacement.value & 0xffff;\n\t*eff_addr = addr1 + addr2 + displacement;\n\n\t/*\n\t * The first operand register could indicate to use of either SS or DS\n\t * registers to obtain the segment selector.  The second operand\n\t * register can only indicate the use of DS. Thus, the first operand\n\t * will be used to obtain the segment selector.\n\t */\n\t*regoff = addr_offset1;\n\n\treturn 0;\n}\n\n/**\n * get_eff_addr_sib() - Obtain referenced effective address via SIB\n * @insn:\tInstruction. Must be valid.\n * @regs:\tRegister values as seen when entering kernel mode\n * @regoff:\tObtained operand offset, in pt_regs, associated with segment\n * @eff_addr:\tObtained effective address\n *\n * Obtain the effective address referenced by the SIB byte of @insn. After\n * identifying the registers involved in the indexed, register-indirect memory\n * reference, its value is obtained from the operands in @regs. The computed\n * address is stored @eff_addr. Also, the register operand that indicates the\n * associated segment is stored in @regoff, this parameter can later be used to\n * determine such segment.\n *\n * Returns:\n *\n * 0 on success. @eff_addr will have the referenced effective address.\n * @base_offset will have a register, as an offset from the base of pt_regs,\n * that can be used to resolve the associated segment.\n *\n * -EINVAL on error.\n */\nstatic int get_eff_addr_sib(struct insn *insn, struct pt_regs *regs,\n\t\t\t    int *base_offset, long *eff_addr)\n{\n\tlong base, indx;\n\tint indx_offset;\n\n\tif (insn->addr_bytes != 8 && insn->addr_bytes != 4)\n\t\treturn -EINVAL;\n\n\tinsn_get_modrm(insn);\n\n\tif (!insn->modrm.nbytes)\n\t\treturn -EINVAL;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) > 2)\n\t\treturn -EINVAL;\n\n\tinsn_get_sib(insn);\n\n\tif (!insn->sib.nbytes)\n\t\treturn -EINVAL;\n\n\t*base_offset = get_reg_offset(insn, regs, REG_TYPE_BASE);\n\tindx_offset = get_reg_offset(insn, regs, REG_TYPE_INDEX);\n\n\t/*\n\t * Negative values in the base and index offset means an error when\n\t * decoding the SIB byte. Except -EDOM, which means that the registers\n\t * should not be used in the address computation.\n\t */\n\tif (*base_offset == -EDOM)\n\t\tbase = 0;\n\telse if (*base_offset < 0)\n\t\treturn -EINVAL;\n\telse\n\t\tbase = regs_get_register(regs, *base_offset);\n\n\tif (indx_offset == -EDOM)\n\t\tindx = 0;\n\telse if (indx_offset < 0)\n\t\treturn -EINVAL;\n\telse\n\t\tindx = regs_get_register(regs, indx_offset);\n\n\tif (insn->addr_bytes == 4) {\n\t\tint addr32, base32, idx32;\n\n\t\tbase32 = base & 0xffffffff;\n\t\tidx32 = indx & 0xffffffff;\n\n\t\taddr32 = base32 + idx32 * (1 << X86_SIB_SCALE(insn->sib.value));\n\t\taddr32 += insn->displacement.value;\n\n\t\t*eff_addr = addr32 & 0xffffffff;\n\t} else {\n\t\t*eff_addr = base + indx * (1 << X86_SIB_SCALE(insn->sib.value));\n\t\t*eff_addr += insn->displacement.value;\n\t}\n\n\treturn 0;\n}\n\n/**\n * get_addr_ref_16() - Obtain the 16-bit address referred by instruction\n * @insn:\tInstruction containing ModRM byte and displacement\n * @regs:\tRegister values as seen when entering kernel mode\n *\n * This function is to be used with 16-bit address encodings. Obtain the memory\n * address referred by the instruction's ModRM and displacement bytes. Also, the\n * segment used as base is determined by either any segment override prefixes in\n * @insn or the default segment of the registers involved in the address\n * computation. In protected mode, segment limits are enforced.\n *\n * Returns:\n *\n * Linear address referenced by the instruction operands on success.\n *\n * -1L on error.\n */\nstatic void __user *get_addr_ref_16(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base, seg_limit;\n\tint ret, regoff;\n\tshort eff_addr;\n\tlong tmp;\n\n\tinsn_get_modrm(insn);\n\tinsn_get_displacement(insn);\n\n\tif (insn->addr_bytes != 2)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\teff_addr = tmp;\n\t} else {\n\t\tret = get_eff_addr_modrm_16(insn, regs, &regoff, &eff_addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, &seg_limit);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * Before computing the linear address, make sure the effective address\n\t * is within the limits of the segment. In virtual-8086 mode, segment\n\t * limits are not enforced. In such a case, the segment limit is -1L to\n\t * reflect this fact.\n\t */\n\tif ((unsigned long)(eff_addr & 0xffff) > seg_limit)\n\t\tgoto out;\n\n\tlinear_addr = (unsigned long)(eff_addr & 0xffff) + seg_base;\n\n\t/* Limit linear address to 20 bits */\n\tif (v8086_mode(regs))\n\t\tlinear_addr &= 0xfffff;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n\n/**\n * get_addr_ref_32() - Obtain a 32-bit linear address\n * @insn:\tInstruction with ModRM, SIB bytes and displacement\n * @regs:\tRegister values as seen when entering kernel mode\n *\n * This function is to be used with 32-bit address encodings to obtain the\n * linear memory address referred by the instruction's ModRM, SIB,\n * displacement bytes and segment base address, as applicable. If in protected\n * mode, segment limits are enforced.\n *\n * Returns:\n *\n * Linear address referenced by instruction and registers on success.\n *\n * -1L on error.\n */\nstatic void __user *get_addr_ref_32(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base, seg_limit;\n\tint eff_addr, regoff;\n\tlong tmp;\n\tint ret;\n\n\tif (insn->addr_bytes != 4)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &tmp);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\teff_addr = tmp;\n\n\t} else {\n\t\tif (insn->sib.nbytes) {\n\t\t\tret = get_eff_addr_sib(insn, regs, &regoff, &tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\teff_addr = tmp;\n\t\t} else {\n\t\t\tret = get_eff_addr_modrm(insn, regs, &regoff, &tmp);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\n\t\t\teff_addr = tmp;\n\t\t}\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, &seg_limit);\n\tif (ret)\n\t\tgoto out;\n\n\t/*\n\t * In protected mode, before computing the linear address, make sure\n\t * the effective address is within the limits of the segment.\n\t * 32-bit addresses can be used in long and virtual-8086 modes if an\n\t * address override prefix is used. In such cases, segment limits are\n\t * not enforced. When in virtual-8086 mode, the segment limit is -1L\n\t * to reflect this situation.\n\t *\n\t * After computed, the effective address is treated as an unsigned\n\t * quantity.\n\t */\n\tif (!user_64bit_mode(regs) && ((unsigned int)eff_addr > seg_limit))\n\t\tgoto out;\n\n\t/*\n\t * Even though 32-bit address encodings are allowed in virtual-8086\n\t * mode, the address range is still limited to [0x-0xffff].\n\t */\n\tif (v8086_mode(regs) && (eff_addr & ~0xffff))\n\t\tgoto out;\n\n\t/*\n\t * Data type long could be 64 bits in size. Ensure that our 32-bit\n\t * effective address is not sign-extended when computing the linear\n\t * address.\n\t */\n\tlinear_addr = (unsigned long)(eff_addr & 0xffffffff) + seg_base;\n\n\t/* Limit linear address to 20 bits */\n\tif (v8086_mode(regs))\n\t\tlinear_addr &= 0xfffff;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n\n/**\n * get_addr_ref_64() - Obtain a 64-bit linear address\n * @insn:\tInstruction struct with ModRM and SIB bytes and displacement\n * @regs:\tStructure with register values as seen when entering kernel mode\n *\n * This function is to be used with 64-bit address encodings to obtain the\n * linear memory address referred by the instruction's ModRM, SIB,\n * displacement bytes and segment base address, as applicable.\n *\n * Returns:\n *\n * Linear address referenced by instruction and registers on success.\n *\n * -1L on error.\n */\n#ifndef CONFIG_X86_64\nstatic void __user *get_addr_ref_64(struct insn *insn, struct pt_regs *regs)\n{\n\treturn (void __user *)-1L;\n}\n#else\nstatic void __user *get_addr_ref_64(struct insn *insn, struct pt_regs *regs)\n{\n\tunsigned long linear_addr = -1L, seg_base;\n\tint regoff, ret;\n\tlong eff_addr;\n\n\tif (insn->addr_bytes != 8)\n\t\tgoto out;\n\n\tif (X86_MODRM_MOD(insn->modrm.value) == 3) {\n\t\tret = get_eff_addr_reg(insn, regs, &regoff, &eff_addr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t} else {\n\t\tif (insn->sib.nbytes) {\n\t\t\tret = get_eff_addr_sib(insn, regs, &regoff, &eff_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tret = get_eff_addr_modrm(insn, regs, &regoff, &eff_addr);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t}\n\n\t}\n\n\tret = get_seg_base_limit(insn, regs, regoff, &seg_base, NULL);\n\tif (ret)\n\t\tgoto out;\n\n\tlinear_addr = (unsigned long)eff_addr + seg_base;\n\nout:\n\treturn (void __user *)linear_addr;\n}\n#endif /* CONFIG_X86_64 */\n\n/**\n * insn_get_addr_ref() - Obtain the linear address referred by instruction\n * @insn:\tInstruction structure containing ModRM byte and displacement\n * @regs:\tStructure with register values as seen when entering kernel mode\n *\n * Obtain the linear address referred by the instruction's ModRM, SIB and\n * displacement bytes, and segment base, as applicable. In protected mode,\n * segment limits are enforced.\n *\n * Returns:\n *\n * Linear address referenced by instruction and registers on success.\n *\n * -1L on error.\n */\nvoid __user *insn_get_addr_ref(struct insn *insn, struct pt_regs *regs)\n{\n\tif (!insn || !regs)\n\t\treturn (void __user *)-1L;\n\n\tswitch (insn->addr_bytes) {\n\tcase 2:\n\t\treturn get_addr_ref_16(insn, regs);\n\tcase 4:\n\t\treturn get_addr_ref_32(insn, regs);\n\tcase 8:\n\t\treturn get_addr_ref_64(insn, regs);\n\tdefault:\n\t\treturn (void __user *)-1L;\n\t}\n}\n"], "filenames": ["arch/x86/lib/insn-eval.c"], "buggy_code_start_loc": [560], "buggy_code_end_loc": [768], "fixing_code_start_loc": [560], "fixing_code_end_loc": [769], "type": "CWE-362", "message": "In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation.", "other": {"cve": {"id": "CVE-2019-13233", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-04T13:15:11.000", "lastModified": "2019-07-20T12:15:13.477", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation."}, {"lang": "es", "value": "En arch/x86/lib/insn-eval.c en el kernel de Linux en versiones anteriores a la 5.1.9, hay un uso de memoria previamente liberada para acceder a una  entrada LDT debido a una condici\u00f3n de carrera entre modify_ldt () y una excepci\u00f3n #BR para una violaci\u00f3n de los l\u00edmites de MPX."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.0, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.0, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.4}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.4, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}, {"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.1.9", "matchCriteriaId": "E567EFE6-8F22-4645-838E-9B381F951463"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-07/msg00025.html", "source": "cve@mitre.org"}, {"url": "http://packetstormsecurity.com/files/154408/Kernel-Live-Patch-Security-Notice-LSN-0055-1.html", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3309", "source": "cve@mitre.org"}, {"url": "https://access.redhat.com/errata/RHSA-2019:3517", "source": "cve@mitre.org"}, {"url": "https://bugs.chromium.org/p/project-zero/issues/detail?id=1879", "source": "cve@mitre.org", "tags": ["Exploit", "Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://cdn.kernel.org/pub/linux/kernel/v5.x/ChangeLog-5.1.9", "source": "cve@mitre.org", "tags": ["Mailing List", "Release Notes", "Vendor Advisory"]}, {"url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=de9f869616dd95e95c00bdd6b0fcd3421e8a4323", "source": "cve@mitre.org", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://seclists.org/bugtraq/2019/Aug/13", "source": "cve@mitre.org"}, {"url": "https://security.netapp.com/advisory/ntap-20190806-0001/", "source": "cve@mitre.org"}, {"url": "https://support.f5.com/csp/article/K13331647?utm_source=f5support&amp;utm_medium=RSS", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4093-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4094-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4117-1/", "source": "cve@mitre.org"}, {"url": "https://usn.ubuntu.com/4118-1/", "source": "cve@mitre.org"}, {"url": "https://www.debian.org/security/2019/dsa-4495", "source": "cve@mitre.org"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323"}}