{"buggy_code": ["// Package nanoauth provides a uniform means of serving HTTP/S for golang\n// projects securely. It allows the specification of a certificate (or\n// generates one) as well as an auth token which is checked before the request\n// is processed.\npackage nanoauth\n\nimport (\n\t\"crypto/tls\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// Auth is a structure containing listener information\ntype Auth struct {\n\tchild         http.Handler     // child is the http handler passed in\n\tHeader        string           // Header is the authentication token's header name\n\tCertificate   *tls.Certificate // Certificate is the tls.Certificate to serve requests with\n\tExcludedPaths []string         // ExcludedPaths is a list of paths to be excluded from being authenticated\n\tToken         string           // Token is the security/authentication string to validate by\n}\n\nvar (\n\t// DefaultAuth is the default Auth object\n\tDefaultAuth = &Auth{}\n\n\t// whether or not to check auth tokens\n\tcheck = true\n)\n\nfunc init() {\n\tDefaultAuth.Header = \"X-NANOBOX-TOKEN\"\n\tDefaultAuth.Certificate, _ = Generate(\"nanobox.io\")\n}\n\n// ServeHTTP is to implement the http.Handler interface. Also let clients know\n// when I have no matching route listeners\nfunc (self Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\treqPath := req.URL.Path\n\tskipOnce := false\n\n\tfor _, path := range self.ExcludedPaths {\n\t\tif path == reqPath {\n\t\t\tskipOnce = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// open up for the CORS \"secure\" pre-flight check (browser doesn't allow devs to set headers in OPTIONS request)\n\tif req.Method == \"OPTIONS\" {\n\t\t// todo: actually check origin header to better implement CORS\n\t\tskipOnce = true\n\t}\n\n\tif !skipOnce && check {\n\t\tauth := \"\"\n\t\tif auth = req.Header.Get(self.Header); auth == \"\" {\n\t\t\t// check form value (case sensitive) if header not set\n\t\t\tauth = req.FormValue(self.Header)\n\t\t}\n\n\t\tif auth != self.Token {\n\t\t\trw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\tself.child.ServeHTTP(rw, req)\n}\n\n// ListenAndServeTLS starts a TLS listener and handles serving https\nfunc (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excludedPaths ...string) error {\n\tconfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{*self.Certificate},\n\t}\n\tconfig.BuildNameToCertificate()\n\ttlsListener, err := tls.Listen(\"tcp\", addr, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif token == \"\" {\n\t\tcheck = false\n\t}\n\tself.ExcludedPaths = excludedPaths\n\tself.Token = token\n\n\tif h == nil {\n\t\th = http.DefaultServeMux\n\t}\n\tself.child = h\n\n\treturn http.Serve(tlsListener, self)\n}\n\n// ListenAndServe starts a normal tcp listener and handles serving http while\n// still validating the auth token.\nfunc (self *Auth) ListenAndServe(addr, token string, h http.Handler, excludedPaths ...string) error {\n\thttpListener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif token == \"\" {\n\t\tcheck = false\n\t}\n\tself.ExcludedPaths = excludedPaths\n\tself.Token = token\n\n\tif h == nil {\n\t\th = http.DefaultServeMux\n\t}\n\tself.child = h\n\n\treturn http.Serve(httpListener, self)\n}\n\n// ListenAndServeTLS is a shortcut function which uses the default one\nfunc ListenAndServeTLS(addr, token string, h http.Handler, excludedPaths ...string) error {\n\treturn DefaultAuth.ListenAndServeTLS(addr, token, h, excludedPaths...)\n}\n\n// ListenAndServe is a shortcut function which uses the default one\nfunc ListenAndServe(addr, token string, h http.Handler, excludedPaths ...string) error {\n\treturn DefaultAuth.ListenAndServe(addr, token, h, excludedPaths...)\n}\n"], "fixing_code": ["// Package nanoauth provides a uniform means of serving HTTP/S for golang\n// projects securely. It allows the specification of a certificate (or\n// generates one) as well as an auth token which is checked before the request\n// is processed.\npackage nanoauth\n\nimport (\n\t\"crypto/subtle\"\n\t\"crypto/tls\"\n\t\"errors\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// Auth is a structure containing listener information\ntype Auth struct {\n\tchild         http.Handler     // child is the http handler passed in\n\tHeader        string           // Header is the authentication token's header name\n\tCertificate   *tls.Certificate // Certificate is the tls.Certificate to serve requests with\n\tExcludedPaths []string         // ExcludedPaths is a list of paths to be excluded from being authenticated\n\tToken         string           // Token is the security/authentication string to validate by\n}\n\nvar (\n\t// DefaultAuth is the default Auth object\n\tDefaultAuth = &Auth{}\n)\n\nfunc init() {\n\tDefaultAuth.Header = \"X-NANOBOX-TOKEN\"\n\tDefaultAuth.Certificate, _ = Generate(\"nanobox.io\")\n}\n\n// ServeHTTP is to implement the http.Handler interface. Also let clients know\n// when I have no matching route listeners\nfunc (self *Auth) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n\treqPath := req.URL.Path\n\tskipOnce := false\n\n\tfor _, path := range self.ExcludedPaths {\n\t\tif path == reqPath {\n\t\t\tskipOnce = true\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// open up for the CORS \"secure\" pre-flight check (browser doesn't allow devs to set headers in OPTIONS request)\n\tif req.Method == \"OPTIONS\" {\n\t\t// todo: actually check origin header to better implement CORS\n\t\tskipOnce = true\n\t}\n\n\tif !skipOnce {\n\t\tauth := \"\"\n\t\tif auth = req.Header.Get(self.Header); auth == \"\" {\n\t\t\t// check form value (case sensitive) if header not set\n\t\t\tauth = req.FormValue(self.Header)\n\t\t}\n\n\t\tif subtle.ConstantTimeCompare([]byte(auth), []byte(self.Token)) == 0 {\n\t\t\trw.WriteHeader(http.StatusUnauthorized)\n\t\t\treturn\n\t\t}\n\t}\n\n\tself.child.ServeHTTP(rw, req)\n}\n\n// ListenAndServeTLS starts a TLS listener and handles serving https\nfunc (self *Auth) ListenAndServeTLS(addr, token string, h http.Handler, excludedPaths ...string) error {\n\tif token == \"\" {\n\t\treturn errors.New(\"nanoauth: token missing\")\n\t}\n\tconfig := &tls.Config{\n\t\tCertificates: []tls.Certificate{*self.Certificate},\n\t}\n\tconfig.BuildNameToCertificate()\n\ttlsListener, err := tls.Listen(\"tcp\", addr, config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tself.ExcludedPaths = excludedPaths\n\tself.Token = token\n\n\tif h == nil {\n\t\th = http.DefaultServeMux\n\t}\n\tself.child = h\n\n\treturn http.Serve(tlsListener, self)\n}\n\n// ListenAndServe starts a normal tcp listener and handles serving http while\n// still validating the auth token.\nfunc (self *Auth) ListenAndServe(addr, token string, h http.Handler, excludedPaths ...string) error {\n\tif token == \"\" {\n\t\treturn errors.New(\"nanoauth: token missing\")\n\t}\n\thttpListener, err := net.Listen(\"tcp\", addr)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tself.ExcludedPaths = excludedPaths\n\tself.Token = token\n\n\tif h == nil {\n\t\th = http.DefaultServeMux\n\t}\n\tself.child = h\n\n\treturn http.Serve(httpListener, self)\n}\n\n// ListenAndServeTLS is a shortcut function which uses the default one\nfunc ListenAndServeTLS(addr, token string, h http.Handler, excludedPaths ...string) error {\n\treturn DefaultAuth.ListenAndServeTLS(addr, token, h, excludedPaths...)\n}\n\n// ListenAndServe is a shortcut function which uses the default one\nfunc ListenAndServe(addr, token string, h http.Handler, excludedPaths ...string) error {\n\treturn DefaultAuth.ListenAndServe(addr, token, h, excludedPaths...)\n}\n"], "filenames": ["nanoauth.go"], "buggy_code_start_loc": [7], "buggy_code_end_loc": [106], "fixing_code_start_loc": [8], "fixing_code_end_loc": [104], "type": "CWE-287", "message": "Authentication is globally bypassed in github.com/nanobox-io/golang-nanoauth between v0.0.0-20160722212129-ac0cc4484ad4 and v0.0.0-20200131131040-063a3fb69896 if ListenAndServe is called with an empty token.", "other": {"cve": {"id": "CVE-2020-36569", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.857", "lastModified": "2023-01-09T19:03:36.060", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Authentication is globally bypassed in github.com/nanobox-io/golang-nanoauth between v0.0.0-20160722212129-ac0cc4484ad4 and v0.0.0-20200131131040-063a3fb69896 if ListenAndServe is called with an empty token."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-305"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:digitalocean:golang-nanoauth:*:*:*:*:*:go:*:*", "versionStartIncluding": "2016-07-22", "versionEndIncluding": "2020-01-31", "matchCriteriaId": "0BACD8D2-E5B2-4784-AA4D-08EC229199FF"}]}]}], "references": [{"url": "https://github.com/nanobox-io/golang-nanoauth/commit/063a3fb69896acf985759f0fe3851f15973993f3", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nanobox-io/golang-nanoauth/pull/5", "source": "security@golang.org", "tags": ["Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0004", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/nanobox-io/golang-nanoauth/commit/063a3fb69896acf985759f0fe3851f15973993f3"}}