{"buggy_code": ["/*\n * Copyright 2015, Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n*/\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <scsi/scsi.h>\n#include <glusterfs/api/glfs.h>\n#include \"darray.h\"\n\n#include \"tcmu-runner.h\"\n\n#define ALLOWED_BSOFLAGS (O_SYNC | O_DIRECT | O_RDWR | O_LARGEFILE)\n\n#define GLUSTER_PORT \"24007\"\n#define TCMU_GLFS_LOG_FILENAME \"tcmu-runner-glfs.log\"  /* MAX 32 CHAR */\n#define TCMU_GLFS_DEBUG_LEVEL  4\n\n/* tcmu log dir path */\nextern char *tcmu_log_dir;\n\ntypedef enum gluster_transport {\n\tGLUSTER_TRANSPORT_TCP,\n\tGLUSTER_TRANSPORT_UNIX,\n\tGLUSTER_TRANSPORT_RDMA,\n\tGLUSTER_TRANSPORT__MAX,\n} gluster_transport;\n\ntypedef struct unix_sockaddr {\n\tchar *socket;\n} unix_sockaddr;\n\ntypedef struct inet_sockaddr {\n\tchar *addr;\n\tchar *port;\n} inet_sockaddr;\n\ntypedef struct gluster_hostdef {\n\tgluster_transport type;\n\tunion { /* union tag is @type */\n\t\tunix_sockaddr uds;\n\t\tinet_sockaddr inet;\n\t} u;\n} gluster_hostdef;\n\ntypedef struct gluster_server {\n\tchar *volname;     /* volume name*/\n\tchar *path;        /* path of file in the volume */\n\tgluster_hostdef *server; /* gluster server definition */\n} gluster_server;\n\nstruct glfs_state {\n\tglfs_t *fs;\n\tglfs_fd_t *gfd;\n\tgluster_server *hosts;\n\n\t/*\n\t * Current tcmu helper API reports WCE=1, but doesn't\n\t * implement inquiry VPD 0xb2, so clients will not know UNMAP\n\t * or WRITE_SAME are supported. TODO: fix this\n\t */\n};\n\ntypedef struct glfs_cbk_cookie {\n\tstruct tcmu_device *dev;\n\tstruct tcmulib_cmd *cmd;\n\tsize_t length;\n\tenum {\n\t\tTCMU_GLFS_READ  = 1,\n\t\tTCMU_GLFS_WRITE = 2,\n\t\tTCMU_GLFS_FLUSH = 3\n\t} op;\n} glfs_cbk_cookie;\n\nstruct gluster_cacheconn {\n    char *volname;\n\tgluster_hostdef *server;\n\tglfs_t *fs;\n\tdarray(char *) cfgstring;\n} gluster_cacheconn;\n\nstatic darray(struct gluster_cacheconn *) cache = darray_new();\n\n\nconst char *const gluster_transport_lookup[] = {\n\t[GLUSTER_TRANSPORT_TCP] = \"tcp\",\n\t[GLUSTER_TRANSPORT_UNIX] = \"unix\",\n\t[GLUSTER_TRANSPORT_RDMA] = \"rdma\",\n\t[GLUSTER_TRANSPORT__MAX] = NULL,\n};\n\n\nstatic void gluster_free_host(gluster_hostdef *host)\n{\n\tif(!host)\n\t\treturn;\n\n\tswitch (host->type) {\n\tcase GLUSTER_TRANSPORT_UNIX:\n\t\tfree(host->u.uds.socket);\n\t\tbreak;\n\tcase GLUSTER_TRANSPORT_TCP:\n\tcase GLUSTER_TRANSPORT_RDMA:\n\t\tfree(host->u.inet.addr);\n\t\tfree(host->u.inet.port);\n\t\tbreak;\n\tcase GLUSTER_TRANSPORT__MAX:\n\t\tbreak;\n\t}\n}\n\nstatic bool\ngluster_compare_hosts(gluster_hostdef *src_server, gluster_hostdef *dst_server)\n{\n\tif (src_server->type != dst_server->type)\n\t\treturn false;\n\n\tswitch (src_server->type) {\n\t\tcase GLUSTER_TRANSPORT_UNIX:\n\t\t\tif (!strcmp(src_server->u.uds.socket, dst_server->u.uds.socket))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase GLUSTER_TRANSPORT_TCP:\n\t\tcase GLUSTER_TRANSPORT_RDMA:\n\t\t\tif (!strcmp(src_server->u.inet.addr, dst_server->u.inet.addr)\n\t\t\t\t\t&&\n\t\t\t\t!strcmp(src_server->u.inet.port, dst_server->u.inet.port))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase GLUSTER_TRANSPORT__MAX:\n\t\t\tbreak;\n\t}\n\n    return false;\n}\n\nstatic int gluster_cache_add(gluster_server *dst, glfs_t *fs, char* cfgstring)\n{\n\tstruct gluster_cacheconn *entry;\n\tchar* cfg_copy = NULL;\n\n\tentry = calloc(1, sizeof(gluster_cacheconn));\n\tif (!entry)\n\t\tgoto error;\n\n\tentry->volname = strdup(dst->volname);\n\n\tentry->server = calloc(1, sizeof(gluster_hostdef));\n\tif (!entry->server)\n\t\tgoto error;\n\n\tentry->server->type = dst->server->type;\n\n\tif (entry->server->type == GLUSTER_TRANSPORT_UNIX) {\n\t\tentry->server->u.uds.socket = strdup(dst->server->u.uds.socket);\n\t} else {\n\t\tentry->server->u.inet.addr = strdup(dst->server->u.inet.addr);\n\t\tentry->server->u.inet.port = strdup(dst->server->u.inet.port);\n\t}\n\n\tentry->fs = fs;\n\n\tcfg_copy = strdup(cfgstring);\n\tdarray_init(entry->cfgstring);\n\tdarray_append(entry->cfgstring, cfg_copy);\n\n\tdarray_append(cache, entry);\n\n\treturn 0;\n\n error:\n\treturn -1;\n}\n\nstatic glfs_t* gluster_cache_query(gluster_server *dst, char *cfgstring)\n{\n\tstruct gluster_cacheconn **entry;\n\tchar** config;\n\tchar* cfg_copy = NULL;\n\tbool cfgmatch = false;\n\n\tdarray_foreach(entry, cache) {\n\t\tif (strcmp((*entry)->volname, dst->volname))\n\t\t\tcontinue;\n\t\tif (gluster_compare_hosts((*entry)->server, dst->server)) {\n\n\t\t\tdarray_foreach(config, (*entry)->cfgstring) {\n\t\t\t\tif (!strcmp(*config, cfgstring)) {\n\t\t\t\t\tcfgmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cfgmatch) {\n\t\t\t\tcfg_copy = strdup(cfgstring);\n\t\t\t\tdarray_append((*entry)->cfgstring, cfg_copy);\n\t\t\t}\n\t\t\treturn (*entry)->fs;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void gluster_cache_refresh(glfs_t *fs, const char *cfgstring)\n{\n\tstruct gluster_cacheconn **entry;\n\tchar** config;\n\tsize_t i = 0;\n\tsize_t j = 0;\n\n\tif (!fs)\n\t\treturn;\n\n\tdarray_foreach(entry, cache) {\n\t\tif ((*entry)->fs == fs) {\n\t\t\tif (cfgstring) {\n\t\t\t\tdarray_foreach(config, (*entry)->cfgstring) {\n\t\t\t\t\tif (!strcmp(*config, cfgstring)) {\n\t\t\t\t\t\tfree(*config);\n\t\t\t\t\t\tdarray_remove((*entry)->cfgstring, j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (darray_size((*entry)->cfgstring))\n\t\t\t\treturn;\n\n\t\t\tfree((*entry)->volname);\n\t\t\tglfs_fini((*entry)->fs);\n\t\t\t(*entry)->fs = NULL;\n\t\t\tgluster_free_host((*entry)->server);\n\t\t\tfree((*entry)->server);\n\t\t\t(*entry)->server = NULL;\n\t\t\tfree((*entry));\n\n\t\t\tdarray_remove(cache, i);\n\t\t\treturn;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic void gluster_free_server(gluster_server **hosts)\n{\n\tif (!*hosts)\n\t\treturn;\n\tfree((*hosts)->volname);\n\tfree((*hosts)->path);\n\n\tgluster_free_host((*hosts)->server);\n\tfree((*hosts)->server);\n\t(*hosts)->server = NULL;\n\tfree(*hosts);\n\t*hosts = NULL;\n}\n\n/*\n * Break image string into server, volume, and path components.\n * Returns -1 on failure.\n */\nstatic int parse_imagepath(char *cfgstring, gluster_server **hosts)\n{\n\tgluster_server *entry = NULL;\n\tchar *origp = strdup(cfgstring);\n\tchar *p, *sep;\n\n\tif (!origp)\n\t\tgoto fail;\n\n\t/* part before '@' is the volume name */\n\tp = origp;\n\tsep = strchr(p, '@');\n\tif (!sep)\n\t\tgoto fail;\n\n\t*hosts = calloc(1, sizeof(gluster_server));\n\tif (!hosts)\n                goto fail;\n\tentry = *hosts;\n\n\tentry->server = calloc(1, sizeof(gluster_hostdef));\n\tif (!entry->server)\n                goto fail;\n\n\t*sep = '\\0';\n\tentry->volname = strdup(p);\n\tif (!entry->volname)\n\t\tgoto fail;\n\n\t/* part between '@' and 1st '/' is the server name */\n\tp = sep + 1;\n\tsep = strchr(p, '/');\n\tif (!sep)\n\t\tgoto fail;\n\n\t*sep = '\\0';\n\tentry->server->type = GLUSTER_TRANSPORT_TCP; /* FIXME: Get type dynamically */\n\tentry->server->u.inet.addr = strdup(p);\n\tif (!entry->server->u.inet.addr)\n\t\tgoto fail;\n\tentry->server->u.inet.port = strdup(GLUSTER_PORT); /* FIXME: Get port dynamically */\n\n\t/* The rest is the path name */\n\tp = sep + 1;\n\tentry->path = strdup(p);\n\tif (!entry->path)\n\t\tgoto fail;\n\n\tif (entry->server->type == GLUSTER_TRANSPORT_UNIX) {\n\t\tif (!strlen(entry->server->u.uds.socket) ||\n\t\t    !strlen(entry->volname) || !strlen(entry->path))\n\t\t\tgoto fail;\n\t} else {\n\t\tif (!strlen(entry->server->u.inet.addr) ||\n\t\t    !strlen(entry->volname) || !strlen(entry->path))\n\t\t\tgoto fail;\n\t}\n\n\tfree(origp);\n\n\treturn 0;\n\nfail:\n\tgluster_free_server(hosts);\n\tfree(origp);\n\n\treturn -1;\n}\n\nstatic glfs_t* tcmu_create_glfs_object(char *config, gluster_server **hosts)\n{\n\tgluster_server *entry = NULL;\n\tchar logfilepath[PATH_MAX];\n    glfs_t *fs =  NULL;\n    int ret = -1;\n\n\tif (parse_imagepath(config, hosts) == -1) {\n\t\ttcmu_err(\"hostaddr, volname, or path missing\\n\");\n\t\tgoto fail;\n\t}\n\tentry = *hosts;\n\n\tfs = gluster_cache_query(entry, config);\n\tif (fs)\n\t\treturn fs;\n\n\tfs = glfs_new(entry->volname);\n\tif (!fs) {\n\t\ttcmu_err(\"glfs_new failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = gluster_cache_add(entry, fs, config);\n\tif (ret) {\n\t\ttcmu_err(\"gluster_cache_add failed: %m\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = glfs_set_volfile_server(fs,\n\t\t\t\tgluster_transport_lookup[entry->server->type],\n\t\t\t\tentry->server->u.inet.addr,\n\t\t\t\tatoi(entry->server->u.inet.port));\n\tif (ret) {\n\t\ttcmu_err(\"glfs_set_volfile_server failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = tcmu_make_absolute_logfile(logfilepath, TCMU_GLFS_LOG_FILENAME);\n\tif (ret < 0) {\n\t\ttcmu_err(\"tcmu_make_absolute_logfile failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = glfs_set_logging(fs, logfilepath, TCMU_GLFS_DEBUG_LEVEL);\n\tif (ret < 0) {\n\t\ttcmu_err(\"glfs_set_logging failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = glfs_init(fs);\n\tif (ret) {\n\t\ttcmu_err(\"glfs_init failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\treturn fs;\n\n unref:\n\tgluster_cache_refresh(fs, config);\n\n fail:\n\tgluster_free_server(hosts);\n\treturn NULL;\n}\n\nstatic char* tcmu_get_path( struct tcmu_device *dev)\n{\n\tchar *config;\n\n\tconfig = strchr(tcmu_get_dev_cfgstring(dev), '/');\n\tif (!config) {\n\t\ttcmu_err(\"no configuration found in cfgstring\\n\");\n\t\treturn NULL;\n\t}\n\tconfig += 1; /* get past '/' */\n\n\treturn config;\n}\n\n\nstatic bool glfs_check_config(const char *cfgstring, char **reason)\n{\n\tchar *path;\n\tglfs_t *fs = NULL;\n\tglfs_fd_t *gfd = NULL;\n\tgluster_server *hosts = NULL; /* gluster server defination */\n\tbool result = true;\n\n\tpath = strchr(cfgstring, '/');\n\tif (!path) {\n\t\tif (asprintf(reason, \"No path found\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto done;\n\t}\n\tpath += 1; /* get past '/' */\n\n\tfs = tcmu_create_glfs_object(path, &hosts);\n\tif (!fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto done;\n\t}\n\n\tgfd = glfs_open(fs, hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfd) {\n\t\tif (asprintf(reason, \"glfs_open failed: %m\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\n\tif (glfs_access(fs, hosts->path, R_OK|W_OK) == -1) {\n\t\tif (asprintf(reason, \"glfs_access file not present, or not writable\") == -1)\n\t\t\t*reason = NULL;\n\t\tresult = false;\n\t\tgoto unref;\n\t}\n\n\tgoto done;\n\nunref:\n\tgluster_cache_refresh(fs, path);\n\ndone:\n\tif (gfd)\n\t\tglfs_close(gfd);\n\tgluster_free_server(&hosts);\n\n\treturn result;\n}\n\nstatic int tcmu_glfs_open(struct tcmu_device *dev)\n{\n\tstruct glfs_state *gfsp;\n\tint ret = 0;\n\tchar *config;\n\tstruct stat st;\n\n\tgfsp = calloc(1, sizeof(*gfsp));\n\tif (!gfsp)\n\t\treturn -ENOMEM;\n\n\ttcmu_set_dev_private(dev, gfsp);\n\n\tconfig = tcmu_get_path(dev);\n\tif (!config) {\n\t\tgoto fail;\n\t}\n\n\tgfsp->fs = tcmu_create_glfs_object(config, &gfsp->hosts);\n\tif (!gfsp->fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tgfsp->gfd = glfs_open(gfsp->fs, gfsp->hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfsp->gfd) {\n\t\ttcmu_err(\"glfs_open failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = glfs_lstat(gfsp->fs, gfsp->hosts->path, &st);\n\tif (ret) {\n\t\ttcmu_err(\"glfs_lstat failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tif (st.st_size != tcmu_get_device_size(dev)) {\n\t\ttcmu_err(\"device size and backing size disagree: \"\n\t\t       \"device %lld backing %lld\\n\",\n\t\t       tcmu_get_device_size(dev),\n\t\t       (long long) st.st_size);\n\t\tgoto unref;\n\t}\n\n\treturn 0;\n\nunref:\n\tgluster_cache_refresh(gfsp->fs, tcmu_get_path(dev));\n\nfail:\n\tif (gfsp->gfd)\n\t\tglfs_close(gfsp->gfd);\n\tgluster_free_server(&gfsp->hosts);\n\tfree(gfsp);\n\n\treturn -EIO;\n}\n\nstatic void tcmu_glfs_close(struct tcmu_device *dev)\n{\n\tstruct glfs_state *gfsp = tcmu_get_dev_private(dev);\n\n\tglfs_close(gfsp->gfd);\n\tgluster_cache_refresh(gfsp->fs, tcmu_get_path(dev));\n\tgluster_free_server(&gfsp->hosts);\n\tfree(gfsp);\n}\n\nstatic void glfs_async_cbk(glfs_fd_t *fd, ssize_t ret, void *data)\n{\n\tglfs_cbk_cookie *cookie = data;\n\tstruct tcmu_device *dev = cookie->dev;\n\tstruct tcmulib_cmd *cmd = cookie->cmd;\n\tsize_t length = cookie->length;\n\n\tif (ret < 0 || ret != length) {\n\t\t/* Read/write/flush failed */\n\t\tswitch (cookie->op) {\n\t\tcase TCMU_GLFS_READ:\n\t\t\tret =  tcmu_set_sense_data(cmd->sense_buf, MEDIUM_ERROR,\n\t\t\t                           ASC_READ_ERROR, NULL);\n\t\t\tbreak;\n\t\tcase TCMU_GLFS_WRITE:\n\t\tcase TCMU_GLFS_FLUSH:\n\t\t\tret =  tcmu_set_sense_data(cmd->sense_buf, MEDIUM_ERROR,\n\t\t\t                           ASC_WRITE_ERROR, NULL);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = SAM_STAT_GOOD;\n\t}\n\n\tcmd->done(dev, cmd, ret);\n\tfree(cookie);\n}\n\nstatic int tcmu_glfs_read(struct tcmu_device *dev,\n                          struct tcmulib_cmd *cmd,\n                          struct iovec *iov, size_t iov_cnt,\n                          size_t length, off_t offset)\n{\n\tstruct glfs_state *state = tcmu_get_dev_private(dev);\n\tglfs_cbk_cookie *cookie;\n\n\tcookie = calloc(1, sizeof(*cookie));\n\tif (!cookie) {\n\t\ttcmu_err(\"Could not allocate cookie: %m\\n\");\n\t\tgoto out;\n\t}\n\tcookie->dev = dev;\n\tcookie->cmd = cmd;\n\tcookie->length = length;\n\tcookie->op = TCMU_GLFS_READ;\n\n\tif (glfs_preadv_async(state->gfd, iov, iov_cnt, offset, SEEK_SET,\n\t                      glfs_async_cbk, cookie) < 0) {\n\t\ttcmu_err(\"glfs_preadv_async failed: %m\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tfree(cookie);\n\treturn SAM_STAT_TASK_SET_FULL;\n}\n\nstatic int tcmu_glfs_write(struct tcmu_device *dev,\n                           struct tcmulib_cmd *cmd,\n                           struct iovec *iov, size_t iov_cnt,\n                           size_t length, off_t offset)\n{\n\tstruct glfs_state *state = tcmu_get_dev_private(dev);\n\tglfs_cbk_cookie *cookie;\n\n\tcookie = calloc(1, sizeof(*cookie));\n\tif (!cookie) {\n\t\ttcmu_err(\"Could not allocate cookie: %m\\n\");\n\t\tgoto out;\n\t}\n\tcookie->dev = dev;\n\tcookie->cmd = cmd;\n\tcookie->length = length;\n\tcookie->op = TCMU_GLFS_WRITE;\n\n\tif (glfs_pwritev_async(state->gfd, iov, iov_cnt, offset,\n\t                       ALLOWED_BSOFLAGS, glfs_async_cbk, cookie) < 0) {\n\t\ttcmu_err(\"glfs_pwritev_async failed: %m\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tfree(cookie);\n\treturn SAM_STAT_TASK_SET_FULL;\n}\n\nstatic int tcmu_glfs_flush(struct tcmu_device *dev,\n                           struct tcmulib_cmd *cmd)\n{\n\tstruct glfs_state *state = tcmu_get_dev_private(dev);\n\tglfs_cbk_cookie *cookie;\n\n\tcookie = calloc(1, sizeof(*cookie));\n\tif (!cookie) {\n\t\ttcmu_err(\"Could not allocate cookie: %m\\n\");\n\t\tgoto out;\n\t}\n\tcookie->dev = dev;\n\tcookie->cmd = cmd;\n\tcookie->length = 0;\n\tcookie->op = TCMU_GLFS_FLUSH;\n\n\tif (glfs_fdatasync_async(state->gfd, glfs_async_cbk, cookie) < 0) {\n\t\ttcmu_err(\"glfs_fdatasync_async failed: %m\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tfree(cookie);\n\treturn SAM_STAT_TASK_SET_FULL;\n}\n\nstatic const char glfs_cfg_desc[] =\n\t\"glfs config string is of the form:\\n\"\n\t\"\\\"volume@hostname/filename\\\"\\n\"\n\t\"where:\\n\"\n\t\"  volume:    The volume on the Gluster server\\n\"\n\t\"  hostname:  The server's hostname\\n\"\n\t\"  filename:  The backing file\";\n\nstruct tcmur_handler glfs_handler = {\n\t.name \t\t= \"Gluster glfs handler\",\n\t.subtype \t= \"glfs\",\n\t.cfg_desc\t= glfs_cfg_desc,\n\n\t.check_config \t= glfs_check_config,\n\n\t.open \t\t= tcmu_glfs_open,\n\t.close \t\t= tcmu_glfs_close,\n\t.read \t\t= tcmu_glfs_read,\n\t.write\t\t= tcmu_glfs_write,\n\t.flush\t\t= tcmu_glfs_flush,\n};\n\n/* Entry point must be named \"handler_init\". */\nint handler_init(void)\n{\n\treturn tcmur_register_handler(&glfs_handler);\n}\n"], "fixing_code": ["/*\n * Copyright 2015, Red Hat, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License. You may obtain\n * a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n*/\n\n#define _GNU_SOURCE\n\n#include <errno.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#include <scsi/scsi.h>\n#include <glusterfs/api/glfs.h>\n#include \"darray.h\"\n\n#include \"tcmu-runner.h\"\n\n#define ALLOWED_BSOFLAGS (O_SYNC | O_DIRECT | O_RDWR | O_LARGEFILE)\n\n#define GLUSTER_PORT \"24007\"\n#define TCMU_GLFS_LOG_FILENAME \"tcmu-runner-glfs.log\"  /* MAX 32 CHAR */\n#define TCMU_GLFS_DEBUG_LEVEL  4\n\n/* tcmu log dir path */\nextern char *tcmu_log_dir;\n\ntypedef enum gluster_transport {\n\tGLUSTER_TRANSPORT_TCP,\n\tGLUSTER_TRANSPORT_UNIX,\n\tGLUSTER_TRANSPORT_RDMA,\n\tGLUSTER_TRANSPORT__MAX,\n} gluster_transport;\n\ntypedef struct unix_sockaddr {\n\tchar *socket;\n} unix_sockaddr;\n\ntypedef struct inet_sockaddr {\n\tchar *addr;\n\tchar *port;\n} inet_sockaddr;\n\ntypedef struct gluster_hostdef {\n\tgluster_transport type;\n\tunion { /* union tag is @type */\n\t\tunix_sockaddr uds;\n\t\tinet_sockaddr inet;\n\t} u;\n} gluster_hostdef;\n\ntypedef struct gluster_server {\n\tchar *volname;     /* volume name*/\n\tchar *path;        /* path of file in the volume */\n\tgluster_hostdef *server; /* gluster server definition */\n} gluster_server;\n\nstruct glfs_state {\n\tglfs_t *fs;\n\tglfs_fd_t *gfd;\n\tgluster_server *hosts;\n\n\t/*\n\t * Current tcmu helper API reports WCE=1, but doesn't\n\t * implement inquiry VPD 0xb2, so clients will not know UNMAP\n\t * or WRITE_SAME are supported. TODO: fix this\n\t */\n};\n\ntypedef struct glfs_cbk_cookie {\n\tstruct tcmu_device *dev;\n\tstruct tcmulib_cmd *cmd;\n\tsize_t length;\n\tenum {\n\t\tTCMU_GLFS_READ  = 1,\n\t\tTCMU_GLFS_WRITE = 2,\n\t\tTCMU_GLFS_FLUSH = 3\n\t} op;\n} glfs_cbk_cookie;\n\nstruct gluster_cacheconn {\n    char *volname;\n\tgluster_hostdef *server;\n\tglfs_t *fs;\n\tdarray(char *) cfgstring;\n} gluster_cacheconn;\n\nstatic darray(struct gluster_cacheconn *) cache = darray_new();\n\n\nconst char *const gluster_transport_lookup[] = {\n\t[GLUSTER_TRANSPORT_TCP] = \"tcp\",\n\t[GLUSTER_TRANSPORT_UNIX] = \"unix\",\n\t[GLUSTER_TRANSPORT_RDMA] = \"rdma\",\n\t[GLUSTER_TRANSPORT__MAX] = NULL,\n};\n\n\nstatic void gluster_free_host(gluster_hostdef *host)\n{\n\tif(!host)\n\t\treturn;\n\n\tswitch (host->type) {\n\tcase GLUSTER_TRANSPORT_UNIX:\n\t\tfree(host->u.uds.socket);\n\t\tbreak;\n\tcase GLUSTER_TRANSPORT_TCP:\n\tcase GLUSTER_TRANSPORT_RDMA:\n\t\tfree(host->u.inet.addr);\n\t\tfree(host->u.inet.port);\n\t\tbreak;\n\tcase GLUSTER_TRANSPORT__MAX:\n\t\tbreak;\n\t}\n}\n\nstatic bool\ngluster_compare_hosts(gluster_hostdef *src_server, gluster_hostdef *dst_server)\n{\n\tif (src_server->type != dst_server->type)\n\t\treturn false;\n\n\tswitch (src_server->type) {\n\t\tcase GLUSTER_TRANSPORT_UNIX:\n\t\t\tif (!strcmp(src_server->u.uds.socket, dst_server->u.uds.socket))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase GLUSTER_TRANSPORT_TCP:\n\t\tcase GLUSTER_TRANSPORT_RDMA:\n\t\t\tif (!strcmp(src_server->u.inet.addr, dst_server->u.inet.addr)\n\t\t\t\t\t&&\n\t\t\t\t!strcmp(src_server->u.inet.port, dst_server->u.inet.port))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\tcase GLUSTER_TRANSPORT__MAX:\n\t\t\tbreak;\n\t}\n\n    return false;\n}\n\nstatic int gluster_cache_add(gluster_server *dst, glfs_t *fs, char* cfgstring)\n{\n\tstruct gluster_cacheconn *entry;\n\tchar* cfg_copy = NULL;\n\n\tentry = calloc(1, sizeof(gluster_cacheconn));\n\tif (!entry)\n\t\tgoto error;\n\n\tentry->volname = strdup(dst->volname);\n\n\tentry->server = calloc(1, sizeof(gluster_hostdef));\n\tif (!entry->server)\n\t\tgoto error;\n\n\tentry->server->type = dst->server->type;\n\n\tif (entry->server->type == GLUSTER_TRANSPORT_UNIX) {\n\t\tentry->server->u.uds.socket = strdup(dst->server->u.uds.socket);\n\t} else {\n\t\tentry->server->u.inet.addr = strdup(dst->server->u.inet.addr);\n\t\tentry->server->u.inet.port = strdup(dst->server->u.inet.port);\n\t}\n\n\tentry->fs = fs;\n\n\tcfg_copy = strdup(cfgstring);\n\tdarray_init(entry->cfgstring);\n\tdarray_append(entry->cfgstring, cfg_copy);\n\n\tdarray_append(cache, entry);\n\n\treturn 0;\n\n error:\n\treturn -1;\n}\n\nstatic glfs_t* gluster_cache_query(gluster_server *dst, char *cfgstring)\n{\n\tstruct gluster_cacheconn **entry;\n\tchar** config;\n\tchar* cfg_copy = NULL;\n\tbool cfgmatch = false;\n\n\tdarray_foreach(entry, cache) {\n\t\tif (strcmp((*entry)->volname, dst->volname))\n\t\t\tcontinue;\n\t\tif (gluster_compare_hosts((*entry)->server, dst->server)) {\n\n\t\t\tdarray_foreach(config, (*entry)->cfgstring) {\n\t\t\t\tif (!strcmp(*config, cfgstring)) {\n\t\t\t\t\tcfgmatch = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!cfgmatch) {\n\t\t\t\tcfg_copy = strdup(cfgstring);\n\t\t\t\tdarray_append((*entry)->cfgstring, cfg_copy);\n\t\t\t}\n\t\t\treturn (*entry)->fs;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nstatic void gluster_cache_refresh(glfs_t *fs, const char *cfgstring)\n{\n\tstruct gluster_cacheconn **entry;\n\tchar** config;\n\tsize_t i = 0;\n\tsize_t j = 0;\n\n\tif (!fs)\n\t\treturn;\n\n\tdarray_foreach(entry, cache) {\n\t\tif ((*entry)->fs == fs) {\n\t\t\tif (cfgstring) {\n\t\t\t\tdarray_foreach(config, (*entry)->cfgstring) {\n\t\t\t\t\tif (!strcmp(*config, cfgstring)) {\n\t\t\t\t\t\tfree(*config);\n\t\t\t\t\t\tdarray_remove((*entry)->cfgstring, j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (darray_size((*entry)->cfgstring))\n\t\t\t\treturn;\n\n\t\t\tfree((*entry)->volname);\n\t\t\tglfs_fini((*entry)->fs);\n\t\t\t(*entry)->fs = NULL;\n\t\t\tgluster_free_host((*entry)->server);\n\t\t\tfree((*entry)->server);\n\t\t\t(*entry)->server = NULL;\n\t\t\tfree((*entry));\n\n\t\t\tdarray_remove(cache, i);\n\t\t\treturn;\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nstatic void gluster_free_server(gluster_server **hosts)\n{\n\tif (!*hosts)\n\t\treturn;\n\tfree((*hosts)->volname);\n\tfree((*hosts)->path);\n\n\tgluster_free_host((*hosts)->server);\n\tfree((*hosts)->server);\n\t(*hosts)->server = NULL;\n\tfree(*hosts);\n\t*hosts = NULL;\n}\n\n/*\n * Break image string into server, volume, and path components.\n * Returns -1 on failure.\n */\nstatic int parse_imagepath(char *cfgstring, gluster_server **hosts)\n{\n\tgluster_server *entry = NULL;\n\tchar *origp = strdup(cfgstring);\n\tchar *p, *sep;\n\n\tif (!origp)\n\t\tgoto fail;\n\n\t/* part before '@' is the volume name */\n\tp = origp;\n\tsep = strchr(p, '@');\n\tif (!sep)\n\t\tgoto fail;\n\n\t*hosts = calloc(1, sizeof(gluster_server));\n\tif (!hosts)\n                goto fail;\n\tentry = *hosts;\n\n\tentry->server = calloc(1, sizeof(gluster_hostdef));\n\tif (!entry->server)\n                goto fail;\n\n\t*sep = '\\0';\n\tentry->volname = strdup(p);\n\tif (!entry->volname)\n\t\tgoto fail;\n\n\t/* part between '@' and 1st '/' is the server name */\n\tp = sep + 1;\n\tsep = strchr(p, '/');\n\tif (!sep)\n\t\tgoto fail;\n\n\t*sep = '\\0';\n\tentry->server->type = GLUSTER_TRANSPORT_TCP; /* FIXME: Get type dynamically */\n\tentry->server->u.inet.addr = strdup(p);\n\tif (!entry->server->u.inet.addr)\n\t\tgoto fail;\n\tentry->server->u.inet.port = strdup(GLUSTER_PORT); /* FIXME: Get port dynamically */\n\n\t/* The rest is the path name */\n\tp = sep + 1;\n\tentry->path = strdup(p);\n\tif (!entry->path)\n\t\tgoto fail;\n\n\tif (entry->server->type == GLUSTER_TRANSPORT_UNIX) {\n\t\tif (!strlen(entry->server->u.uds.socket) ||\n\t\t    !strlen(entry->volname) || !strlen(entry->path))\n\t\t\tgoto fail;\n\t} else {\n\t\tif (!strlen(entry->server->u.inet.addr) ||\n\t\t    !strlen(entry->volname) || !strlen(entry->path))\n\t\t\tgoto fail;\n\t}\n\n\tfree(origp);\n\n\treturn 0;\n\nfail:\n\tgluster_free_server(hosts);\n\tfree(origp);\n\n\treturn -1;\n}\n\nstatic glfs_t* tcmu_create_glfs_object(char *config, gluster_server **hosts)\n{\n\tgluster_server *entry = NULL;\n\tchar logfilepath[PATH_MAX];\n    glfs_t *fs =  NULL;\n    int ret = -1;\n\n\tif (parse_imagepath(config, hosts) == -1) {\n\t\ttcmu_err(\"hostaddr, volname, or path missing\\n\");\n\t\tgoto fail;\n\t}\n\tentry = *hosts;\n\n\tfs = gluster_cache_query(entry, config);\n\tif (fs)\n\t\treturn fs;\n\n\tfs = glfs_new(entry->volname);\n\tif (!fs) {\n\t\ttcmu_err(\"glfs_new failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = gluster_cache_add(entry, fs, config);\n\tif (ret) {\n\t\ttcmu_err(\"gluster_cache_add failed: %m\\n\");\n\t\tgoto fail;\n\t}\n\n\tret = glfs_set_volfile_server(fs,\n\t\t\t\tgluster_transport_lookup[entry->server->type],\n\t\t\t\tentry->server->u.inet.addr,\n\t\t\t\tatoi(entry->server->u.inet.port));\n\tif (ret) {\n\t\ttcmu_err(\"glfs_set_volfile_server failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = tcmu_make_absolute_logfile(logfilepath, TCMU_GLFS_LOG_FILENAME);\n\tif (ret < 0) {\n\t\ttcmu_err(\"tcmu_make_absolute_logfile failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = glfs_set_logging(fs, logfilepath, TCMU_GLFS_DEBUG_LEVEL);\n\tif (ret < 0) {\n\t\ttcmu_err(\"glfs_set_logging failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = glfs_init(fs);\n\tif (ret) {\n\t\ttcmu_err(\"glfs_init failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\treturn fs;\n\n unref:\n\tgluster_cache_refresh(fs, config);\n\n fail:\n\tgluster_free_server(hosts);\n\treturn NULL;\n}\n\nstatic char* tcmu_get_path( struct tcmu_device *dev)\n{\n\tchar *config;\n\n\tconfig = strchr(tcmu_get_dev_cfgstring(dev), '/');\n\tif (!config) {\n\t\ttcmu_err(\"no configuration found in cfgstring\\n\");\n\t\treturn NULL;\n\t}\n\tconfig += 1; /* get past '/' */\n\n\treturn config;\n}\n\nstatic int tcmu_glfs_open(struct tcmu_device *dev)\n{\n\tstruct glfs_state *gfsp;\n\tint ret = 0;\n\tchar *config;\n\tstruct stat st;\n\n\tgfsp = calloc(1, sizeof(*gfsp));\n\tif (!gfsp)\n\t\treturn -ENOMEM;\n\n\ttcmu_set_dev_private(dev, gfsp);\n\n\tconfig = tcmu_get_path(dev);\n\tif (!config) {\n\t\tgoto fail;\n\t}\n\n\tgfsp->fs = tcmu_create_glfs_object(config, &gfsp->hosts);\n\tif (!gfsp->fs) {\n\t\ttcmu_err(\"tcmu_create_glfs_object failed\\n\");\n\t\tgoto fail;\n\t}\n\n\tgfsp->gfd = glfs_open(gfsp->fs, gfsp->hosts->path, ALLOWED_BSOFLAGS);\n\tif (!gfsp->gfd) {\n\t\ttcmu_err(\"glfs_open failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tret = glfs_lstat(gfsp->fs, gfsp->hosts->path, &st);\n\tif (ret) {\n\t\ttcmu_err(\"glfs_lstat failed: %m\\n\");\n\t\tgoto unref;\n\t}\n\n\tif (st.st_size != tcmu_get_device_size(dev)) {\n\t\ttcmu_err(\"device size and backing size disagree: \"\n\t\t       \"device %lld backing %lld\\n\",\n\t\t       tcmu_get_device_size(dev),\n\t\t       (long long) st.st_size);\n\t\tgoto unref;\n\t}\n\n\treturn 0;\n\nunref:\n\tgluster_cache_refresh(gfsp->fs, tcmu_get_path(dev));\n\nfail:\n\tif (gfsp->gfd)\n\t\tglfs_close(gfsp->gfd);\n\tgluster_free_server(&gfsp->hosts);\n\tfree(gfsp);\n\n\treturn -EIO;\n}\n\nstatic void tcmu_glfs_close(struct tcmu_device *dev)\n{\n\tstruct glfs_state *gfsp = tcmu_get_dev_private(dev);\n\n\tglfs_close(gfsp->gfd);\n\tgluster_cache_refresh(gfsp->fs, tcmu_get_path(dev));\n\tgluster_free_server(&gfsp->hosts);\n\tfree(gfsp);\n}\n\nstatic void glfs_async_cbk(glfs_fd_t *fd, ssize_t ret, void *data)\n{\n\tglfs_cbk_cookie *cookie = data;\n\tstruct tcmu_device *dev = cookie->dev;\n\tstruct tcmulib_cmd *cmd = cookie->cmd;\n\tsize_t length = cookie->length;\n\n\tif (ret < 0 || ret != length) {\n\t\t/* Read/write/flush failed */\n\t\tswitch (cookie->op) {\n\t\tcase TCMU_GLFS_READ:\n\t\t\tret =  tcmu_set_sense_data(cmd->sense_buf, MEDIUM_ERROR,\n\t\t\t                           ASC_READ_ERROR, NULL);\n\t\t\tbreak;\n\t\tcase TCMU_GLFS_WRITE:\n\t\tcase TCMU_GLFS_FLUSH:\n\t\t\tret =  tcmu_set_sense_data(cmd->sense_buf, MEDIUM_ERROR,\n\t\t\t                           ASC_WRITE_ERROR, NULL);\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tret = SAM_STAT_GOOD;\n\t}\n\n\tcmd->done(dev, cmd, ret);\n\tfree(cookie);\n}\n\nstatic int tcmu_glfs_read(struct tcmu_device *dev,\n                          struct tcmulib_cmd *cmd,\n                          struct iovec *iov, size_t iov_cnt,\n                          size_t length, off_t offset)\n{\n\tstruct glfs_state *state = tcmu_get_dev_private(dev);\n\tglfs_cbk_cookie *cookie;\n\n\tcookie = calloc(1, sizeof(*cookie));\n\tif (!cookie) {\n\t\ttcmu_err(\"Could not allocate cookie: %m\\n\");\n\t\tgoto out;\n\t}\n\tcookie->dev = dev;\n\tcookie->cmd = cmd;\n\tcookie->length = length;\n\tcookie->op = TCMU_GLFS_READ;\n\n\tif (glfs_preadv_async(state->gfd, iov, iov_cnt, offset, SEEK_SET,\n\t                      glfs_async_cbk, cookie) < 0) {\n\t\ttcmu_err(\"glfs_preadv_async failed: %m\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tfree(cookie);\n\treturn SAM_STAT_TASK_SET_FULL;\n}\n\nstatic int tcmu_glfs_write(struct tcmu_device *dev,\n                           struct tcmulib_cmd *cmd,\n                           struct iovec *iov, size_t iov_cnt,\n                           size_t length, off_t offset)\n{\n\tstruct glfs_state *state = tcmu_get_dev_private(dev);\n\tglfs_cbk_cookie *cookie;\n\n\tcookie = calloc(1, sizeof(*cookie));\n\tif (!cookie) {\n\t\ttcmu_err(\"Could not allocate cookie: %m\\n\");\n\t\tgoto out;\n\t}\n\tcookie->dev = dev;\n\tcookie->cmd = cmd;\n\tcookie->length = length;\n\tcookie->op = TCMU_GLFS_WRITE;\n\n\tif (glfs_pwritev_async(state->gfd, iov, iov_cnt, offset,\n\t                       ALLOWED_BSOFLAGS, glfs_async_cbk, cookie) < 0) {\n\t\ttcmu_err(\"glfs_pwritev_async failed: %m\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tfree(cookie);\n\treturn SAM_STAT_TASK_SET_FULL;\n}\n\nstatic int tcmu_glfs_flush(struct tcmu_device *dev,\n                           struct tcmulib_cmd *cmd)\n{\n\tstruct glfs_state *state = tcmu_get_dev_private(dev);\n\tglfs_cbk_cookie *cookie;\n\n\tcookie = calloc(1, sizeof(*cookie));\n\tif (!cookie) {\n\t\ttcmu_err(\"Could not allocate cookie: %m\\n\");\n\t\tgoto out;\n\t}\n\tcookie->dev = dev;\n\tcookie->cmd = cmd;\n\tcookie->length = 0;\n\tcookie->op = TCMU_GLFS_FLUSH;\n\n\tif (glfs_fdatasync_async(state->gfd, glfs_async_cbk, cookie) < 0) {\n\t\ttcmu_err(\"glfs_fdatasync_async failed: %m\\n\");\n\t\tgoto out;\n\t}\n\n\treturn 0;\n\nout:\n\tfree(cookie);\n\treturn SAM_STAT_TASK_SET_FULL;\n}\n\nstatic const char glfs_cfg_desc[] =\n\t\"glfs config string is of the form:\\n\"\n\t\"\\\"volume@hostname/filename\\\"\\n\"\n\t\"where:\\n\"\n\t\"  volume:    The volume on the Gluster server\\n\"\n\t\"  hostname:  The server's hostname\\n\"\n\t\"  filename:  The backing file\";\n\nstruct tcmur_handler glfs_handler = {\n\t.name \t\t= \"Gluster glfs handler\",\n\t.subtype \t= \"glfs\",\n\t.cfg_desc\t= glfs_cfg_desc,\n\n\t.open \t\t= tcmu_glfs_open,\n\t.close \t\t= tcmu_glfs_close,\n\t.read \t\t= tcmu_glfs_read,\n\t.write\t\t= tcmu_glfs_write,\n\t.flush\t\t= tcmu_glfs_flush,\n};\n\n/* Entry point must be named \"handler_init\". */\nint handler_init(void)\n{\n\treturn tcmur_register_handler(&glfs_handler);\n}\n"], "filenames": ["glfs.c"], "buggy_code_start_loc": [433], "buggy_code_end_loc": [686], "fixing_code_start_loc": [432], "fixing_code_end_loc": [631], "type": "CWE-119", "message": "tcmu-runner daemon version 0.9.0 to 1.2.0 is vulnerable to invalid memory references in the handler_glfs.so handler resulting in denial of service", "other": {"cve": {"id": "CVE-2017-1000198", "sourceIdentifier": "cve@mitre.org", "published": "2017-11-17T02:29:00.927", "lastModified": "2017-12-02T02:29:01.437", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "tcmu-runner daemon version 0.9.0 to 1.2.0 is vulnerable to invalid memory references in the handler_glfs.so handler resulting in denial of service"}, {"lang": "es", "value": "tcmu-runner daemon desde la versi\u00f3n 0.9.0 hasta la 1.2.0 es vulnerable a referencias de memoria no v\u00e1lidas en el manipulador handler_glfs.so, lo que resulta en una denegaci\u00f3n de servicio (DoS)."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": true, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:0.9.0:*:*:*:*:*:*:*", "matchCriteriaId": "0A222981-AB11-435B-9F57-DFE9A585F2B7"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:0.9.1:*:*:*:*:*:*:*", "matchCriteriaId": "6B0761D8-4B45-436F-B16B-4D56E70EEA70"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:0.9.2:*:*:*:*:*:*:*", "matchCriteriaId": "21BAC44B-5269-4A55-8DFA-AF4D89F5A86F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:0.9.3:*:*:*:*:*:*:*", "matchCriteriaId": "B04E2BFF-DDA0-4CCE-9DE5-6736C703BC13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:0.9.4:*:*:*:*:*:*:*", "matchCriteriaId": "FA1D1E9F-CCA6-4D16-9986-8D799289C284"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:1.0.5:*:*:*:*:*:*:*", "matchCriteriaId": "388F3BC0-E99E-44F4-9FF4-4792DEA57C13"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:1.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "E60BA1B4-3502-4667-96EA-988D382BFEEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:1.1.1:*:*:*:*:*:*:*", "matchCriteriaId": "C160773C-5CA9-4D6C-B500-DEEFB3E34B3B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:1.1.2:*:*:*:*:*:*:*", "matchCriteriaId": "4C099CE8-FE61-4613-9521-BA2CB65B8154"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:1.1.3:*:*:*:*:*:*:*", "matchCriteriaId": "85D0F823-B77A-454A-BB7F-64DB9AD46D1C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:tcmu-runner_project:tcmu-runner:1.2.0:*:*:*:*:*:*:*", "matchCriteriaId": "B2A4AFAD-5A0B-4179-BF06-9718F0C5540D"}]}]}], "references": [{"url": "https://access.redhat.com/errata/RHSA-2017:3277", "source": "cve@mitre.org"}, {"url": "https://github.com/open-iscsi/tcmu-runner/commit/61bd03e600d2abf309173e9186f4d465bb1b7157", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/open-iscsi/tcmu-runner/commit/61bd03e600d2abf309173e9186f4d465bb1b7157"}}