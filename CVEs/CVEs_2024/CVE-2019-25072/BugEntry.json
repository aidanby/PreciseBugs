{"buggy_code": ["package rpcclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\tamino \"github.com/tendermint/go-amino\"\n\n\ttypes \"github.com/tendermint/tendermint/rpc/lib/types\"\n)\n\nconst (\n\tprotoHTTP  = \"http\"\n\tprotoHTTPS = \"https\"\n\tprotoWSS   = \"wss\"\n\tprotoWS    = \"ws\"\n\tprotoTCP   = \"tcp\"\n)\n\n// HTTPClient is a common interface for JSONRPCClient and URIClient.\ntype HTTPClient interface {\n\tCall(method string, params map[string]interface{}, result interface{}) (interface{}, error)\n\tCodec() *amino.Codec\n\tSetCodec(*amino.Codec)\n}\n\n// TODO: Deprecate support for IP:PORT or /path/to/socket\nfunc makeHTTPDialer(remoteAddr string) (string, string, func(string, string) (net.Conn, error)) {\n\t// protocol to use for http operations, to support both http and https\n\tclientProtocol := protoHTTP\n\n\tparts := strings.SplitN(remoteAddr, \"://\", 2)\n\tvar protocol, address string\n\tif len(parts) == 1 {\n\t\t// default to tcp if nothing specified\n\t\tprotocol, address = protoTCP, remoteAddr\n\t} else if len(parts) == 2 {\n\t\tprotocol, address = parts[0], parts[1]\n\t} else {\n\t\t// return a invalid message\n\t\tmsg := fmt.Sprintf(\"Invalid addr: %s\", remoteAddr)\n\t\treturn clientProtocol, msg, func(_ string, _ string) (net.Conn, error) {\n\t\t\treturn nil, errors.New(msg)\n\t\t}\n\t}\n\n\t// accept http as an alias for tcp and set the client protocol\n\tswitch protocol {\n\tcase protoHTTP, protoHTTPS:\n\t\tclientProtocol = protocol\n\t\tprotocol = protoTCP\n\tcase protoWS, protoWSS:\n\t\tclientProtocol = protocol\n\t}\n\n\t// replace / with . for http requests (kvstore domain)\n\ttrimmedAddress := strings.Replace(address, \"/\", \".\", -1)\n\treturn clientProtocol, trimmedAddress, func(proto, addr string) (net.Conn, error) {\n\t\treturn net.Dial(protocol, address)\n\t}\n}\n\n// We overwrite the http.Client.Dial so we can do http over tcp or unix.\n// remoteAddr should be fully featured (eg. with tcp:// or unix://)\nfunc makeHTTPClient(remoteAddr string) (string, *http.Client) {\n\tprotocol, address, dialer := makeHTTPDialer(remoteAddr)\n\treturn protocol + \"://\" + address, &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\tDial: dialer,\n\t\t},\n\t}\n}\n\n//------------------------------------------------------------------------------------\n\n// JSONRPCClient takes params as a slice\ntype JSONRPCClient struct {\n\taddress string\n\tclient  *http.Client\n\tcdc     *amino.Codec\n}\n\n// NewJSONRPCClient returns a JSONRPCClient pointed at the given address.\nfunc NewJSONRPCClient(remote string) *JSONRPCClient {\n\taddress, client := makeHTTPClient(remote)\n\treturn &JSONRPCClient{\n\t\taddress: address,\n\t\tclient:  client,\n\t\tcdc:     amino.NewCodec(),\n\t}\n}\n\nfunc (c *JSONRPCClient) Call(method string, params map[string]interface{}, result interface{}) (interface{}, error) {\n\trequest, err := types.MapToRequest(c.cdc, types.JSONRPCStringID(\"jsonrpc-client\"), method, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trequestBytes, err := json.Marshal(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// log.Info(string(requestBytes))\n\trequestBuf := bytes.NewBuffer(requestBytes)\n\t// log.Info(Fmt(\"RPC request to %v (%v): %v\", c.remote, method, string(requestBytes)))\n\thttpResponse, err := c.client.Post(c.address, \"text/json\", requestBuf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer httpResponse.Body.Close() // nolint: errcheck\n\n\tresponseBytes, err := ioutil.ReadAll(httpResponse.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// \tlog.Info(Fmt(\"RPC response: %v\", string(responseBytes)))\n\treturn unmarshalResponseBytes(c.cdc, responseBytes, result)\n}\n\nfunc (c *JSONRPCClient) Codec() *amino.Codec {\n\treturn c.cdc\n}\n\nfunc (c *JSONRPCClient) SetCodec(cdc *amino.Codec) {\n\tc.cdc = cdc\n}\n\n//-------------------------------------------------------------\n\n// URI takes params as a map\ntype URIClient struct {\n\taddress string\n\tclient  *http.Client\n\tcdc     *amino.Codec\n}\n\nfunc NewURIClient(remote string) *URIClient {\n\taddress, client := makeHTTPClient(remote)\n\treturn &URIClient{\n\t\taddress: address,\n\t\tclient:  client,\n\t\tcdc:     amino.NewCodec(),\n\t}\n}\n\nfunc (c *URIClient) Call(method string, params map[string]interface{}, result interface{}) (interface{}, error) {\n\tvalues, err := argsToURLValues(c.cdc, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// log.Info(Fmt(\"URI request to %v (%v): %v\", c.address, method, values))\n\tresp, err := c.client.PostForm(c.address+\"/\"+method, values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close() // nolint: errcheck\n\n\tresponseBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn unmarshalResponseBytes(c.cdc, responseBytes, result)\n}\n\nfunc (c *URIClient) Codec() *amino.Codec {\n\treturn c.cdc\n}\n\nfunc (c *URIClient) SetCodec(cdc *amino.Codec) {\n\tc.cdc = cdc\n}\n\n//------------------------------------------------\n\nfunc unmarshalResponseBytes(cdc *amino.Codec, responseBytes []byte, result interface{}) (interface{}, error) {\n\t// Read response.  If rpc/core/types is imported, the result will unmarshal\n\t// into the correct type.\n\t// log.Notice(\"response\", \"response\", string(responseBytes))\n\tvar err error\n\tresponse := &types.RPCResponse{}\n\terr = json.Unmarshal(responseBytes, response)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"Error unmarshalling rpc response: %v\", err)\n\t}\n\tif response.Error != nil {\n\t\treturn nil, errors.Errorf(\"Response error: %v\", response.Error)\n\t}\n\t// Unmarshal the RawMessage into the result.\n\terr = cdc.UnmarshalJSON(response.Result, result)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"Error unmarshalling rpc response result: %v\", err)\n\t}\n\treturn result, nil\n}\n\nfunc argsToURLValues(cdc *amino.Codec, args map[string]interface{}) (url.Values, error) {\n\tvalues := make(url.Values)\n\tif len(args) == 0 {\n\t\treturn values, nil\n\t}\n\terr := argsToJSON(cdc, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor key, val := range args {\n\t\tvalues.Set(key, val.(string))\n\t}\n\treturn values, nil\n}\n\nfunc argsToJSON(cdc *amino.Codec, args map[string]interface{}) error {\n\tfor k, v := range args {\n\t\trt := reflect.TypeOf(v)\n\t\tisByteSlice := rt.Kind() == reflect.Slice && rt.Elem().Kind() == reflect.Uint8\n\t\tif isByteSlice {\n\t\t\tbytes := reflect.ValueOf(v).Bytes()\n\t\t\targs[k] = fmt.Sprintf(\"0x%X\", bytes)\n\t\t\tcontinue\n\t\t}\n\n\t\tdata, err := cdc.MarshalJSON(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\targs[k] = string(data)\n\t}\n\treturn nil\n}\n"], "fixing_code": ["package rpcclient\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"reflect\"\n\t\"strings\"\n\n\t\"github.com/pkg/errors\"\n\tamino \"github.com/tendermint/go-amino\"\n\n\ttypes \"github.com/tendermint/tendermint/rpc/lib/types\"\n)\n\nconst (\n\tprotoHTTP  = \"http\"\n\tprotoHTTPS = \"https\"\n\tprotoWSS   = \"wss\"\n\tprotoWS    = \"ws\"\n\tprotoTCP   = \"tcp\"\n)\n\n// HTTPClient is a common interface for JSONRPCClient and URIClient.\ntype HTTPClient interface {\n\tCall(method string, params map[string]interface{}, result interface{}) (interface{}, error)\n\tCodec() *amino.Codec\n\tSetCodec(*amino.Codec)\n}\n\n// TODO: Deprecate support for IP:PORT or /path/to/socket\nfunc makeHTTPDialer(remoteAddr string) (string, string, func(string, string) (net.Conn, error)) {\n\t// protocol to use for http operations, to support both http and https\n\tclientProtocol := protoHTTP\n\n\tparts := strings.SplitN(remoteAddr, \"://\", 2)\n\tvar protocol, address string\n\tif len(parts) == 1 {\n\t\t// default to tcp if nothing specified\n\t\tprotocol, address = protoTCP, remoteAddr\n\t} else if len(parts) == 2 {\n\t\tprotocol, address = parts[0], parts[1]\n\t} else {\n\t\t// return a invalid message\n\t\tmsg := fmt.Sprintf(\"Invalid addr: %s\", remoteAddr)\n\t\treturn clientProtocol, msg, func(_ string, _ string) (net.Conn, error) {\n\t\t\treturn nil, errors.New(msg)\n\t\t}\n\t}\n\n\t// accept http as an alias for tcp and set the client protocol\n\tswitch protocol {\n\tcase protoHTTP, protoHTTPS:\n\t\tclientProtocol = protocol\n\t\tprotocol = protoTCP\n\tcase protoWS, protoWSS:\n\t\tclientProtocol = protocol\n\t}\n\n\t// replace / with . for http requests (kvstore domain)\n\ttrimmedAddress := strings.Replace(address, \"/\", \".\", -1)\n\treturn clientProtocol, trimmedAddress, func(proto, addr string) (net.Conn, error) {\n\t\treturn net.Dial(protocol, address)\n\t}\n}\n\n// We overwrite the http.Client.Dial so we can do http over tcp or unix.\n// remoteAddr should be fully featured (eg. with tcp:// or unix://)\nfunc makeHTTPClient(remoteAddr string) (string, *http.Client) {\n\tprotocol, address, dialer := makeHTTPDialer(remoteAddr)\n\treturn protocol + \"://\" + address, &http.Client{\n\t\tTransport: &http.Transport{\n\t\t\t// Set to true to prevent GZIP-bomb DoS attacks\n\t\t\tDisableCompression: true,\n\t\t\tDial:               dialer,\n\t\t},\n\t}\n}\n\n//------------------------------------------------------------------------------------\n\n// JSONRPCClient takes params as a slice\ntype JSONRPCClient struct {\n\taddress string\n\tclient  *http.Client\n\tcdc     *amino.Codec\n}\n\n// NewJSONRPCClient returns a JSONRPCClient pointed at the given address.\nfunc NewJSONRPCClient(remote string) *JSONRPCClient {\n\taddress, client := makeHTTPClient(remote)\n\treturn &JSONRPCClient{\n\t\taddress: address,\n\t\tclient:  client,\n\t\tcdc:     amino.NewCodec(),\n\t}\n}\n\nfunc (c *JSONRPCClient) Call(method string, params map[string]interface{}, result interface{}) (interface{}, error) {\n\trequest, err := types.MapToRequest(c.cdc, types.JSONRPCStringID(\"jsonrpc-client\"), method, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\trequestBytes, err := json.Marshal(request)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// log.Info(string(requestBytes))\n\trequestBuf := bytes.NewBuffer(requestBytes)\n\t// log.Info(Fmt(\"RPC request to %v (%v): %v\", c.remote, method, string(requestBytes)))\n\thttpResponse, err := c.client.Post(c.address, \"text/json\", requestBuf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer httpResponse.Body.Close() // nolint: errcheck\n\n\tresponseBytes, err := ioutil.ReadAll(httpResponse.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// \tlog.Info(Fmt(\"RPC response: %v\", string(responseBytes)))\n\treturn unmarshalResponseBytes(c.cdc, responseBytes, result)\n}\n\nfunc (c *JSONRPCClient) Codec() *amino.Codec {\n\treturn c.cdc\n}\n\nfunc (c *JSONRPCClient) SetCodec(cdc *amino.Codec) {\n\tc.cdc = cdc\n}\n\n//-------------------------------------------------------------\n\n// URI takes params as a map\ntype URIClient struct {\n\taddress string\n\tclient  *http.Client\n\tcdc     *amino.Codec\n}\n\nfunc NewURIClient(remote string) *URIClient {\n\taddress, client := makeHTTPClient(remote)\n\treturn &URIClient{\n\t\taddress: address,\n\t\tclient:  client,\n\t\tcdc:     amino.NewCodec(),\n\t}\n}\n\nfunc (c *URIClient) Call(method string, params map[string]interface{}, result interface{}) (interface{}, error) {\n\tvalues, err := argsToURLValues(c.cdc, params)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// log.Info(Fmt(\"URI request to %v (%v): %v\", c.address, method, values))\n\tresp, err := c.client.PostForm(c.address+\"/\"+method, values)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer resp.Body.Close() // nolint: errcheck\n\n\tresponseBytes, err := ioutil.ReadAll(resp.Body)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn unmarshalResponseBytes(c.cdc, responseBytes, result)\n}\n\nfunc (c *URIClient) Codec() *amino.Codec {\n\treturn c.cdc\n}\n\nfunc (c *URIClient) SetCodec(cdc *amino.Codec) {\n\tc.cdc = cdc\n}\n\n//------------------------------------------------\n\nfunc unmarshalResponseBytes(cdc *amino.Codec, responseBytes []byte, result interface{}) (interface{}, error) {\n\t// Read response.  If rpc/core/types is imported, the result will unmarshal\n\t// into the correct type.\n\t// log.Notice(\"response\", \"response\", string(responseBytes))\n\tvar err error\n\tresponse := &types.RPCResponse{}\n\terr = json.Unmarshal(responseBytes, response)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"Error unmarshalling rpc response: %v\", err)\n\t}\n\tif response.Error != nil {\n\t\treturn nil, errors.Errorf(\"Response error: %v\", response.Error)\n\t}\n\t// Unmarshal the RawMessage into the result.\n\terr = cdc.UnmarshalJSON(response.Result, result)\n\tif err != nil {\n\t\treturn nil, errors.Errorf(\"Error unmarshalling rpc response result: %v\", err)\n\t}\n\treturn result, nil\n}\n\nfunc argsToURLValues(cdc *amino.Codec, args map[string]interface{}) (url.Values, error) {\n\tvalues := make(url.Values)\n\tif len(args) == 0 {\n\t\treturn values, nil\n\t}\n\terr := argsToJSON(cdc, args)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tfor key, val := range args {\n\t\tvalues.Set(key, val.(string))\n\t}\n\treturn values, nil\n}\n\nfunc argsToJSON(cdc *amino.Codec, args map[string]interface{}) error {\n\tfor k, v := range args {\n\t\trt := reflect.TypeOf(v)\n\t\tisByteSlice := rt.Kind() == reflect.Slice && rt.Elem().Kind() == reflect.Uint8\n\t\tif isByteSlice {\n\t\t\tbytes := reflect.ValueOf(v).Bytes()\n\t\t\targs[k] = fmt.Sprintf(\"0x%X\", bytes)\n\t\t\tcontinue\n\t\t}\n\n\t\tdata, err := cdc.MarshalJSON(v)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\targs[k] = string(data)\n\t}\n\treturn nil\n}\n"], "filenames": ["rpc/lib/client/http_client.go"], "buggy_code_start_loc": [77], "buggy_code_end_loc": [78], "fixing_code_start_loc": [77], "fixing_code_end_loc": [80], "type": "CWE-400", "message": "Due to support of Gzip compression in request bodies, as well as a lack of limiting response body sizes, a malicious server can cause a client to consume a significant amount of system resources, which may be used as a denial of service vector.", "other": {"cve": {"id": "CVE-2019-25072", "sourceIdentifier": "security@golang.org", "published": "2022-12-27T22:15:11.323", "lastModified": "2023-01-06T16:42:24.550", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Due to support of Gzip compression in request bodies, as well as a lack of limiting response body sizes, a malicious server can cause a client to consume a significant amount of system resources, which may be used as a denial of service vector."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}, {"source": "security@golang.org", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tendermint:tendermint:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.31.1", "matchCriteriaId": "3F9419AE-19B6-4F69-B886-5B43DDF13F92"}]}]}], "references": [{"url": "https://github.com/tendermint/tendermint/commit/03085c2da23b179c4a51f59a03cb40aa4e85a613", "source": "security@golang.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tendermint/tendermint/pull/3430", "source": "security@golang.org", "tags": ["Third Party Advisory"]}, {"url": "https://pkg.go.dev/vuln/GO-2020-0037", "source": "security@golang.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tendermint/tendermint/commit/03085c2da23b179c4a51f59a03cb40aa4e85a613"}}